./  ADD  NAME=ANALYSIS
 ANAL: PROC(PARM) OPTIONS(MAIN) REORDER;
 /*UICC PACKLIST/ORDER CARD GENERATOR - VERSION 2 - 7/13/77
     THIS PROGRAM TAKES THE INPUT FROM A PSW SAMPLER PROGRAM
    (PSWSAMP OR STATDIE/OURMF) AND THE A DIRECTORY LISTER
    (DIRECT OR MODMAP) AND CREATES PACKLIST OR ORDER CARDS
    BASED ON THE USAGE PATTERN SEEN FROM THE SAMPLED PSWS.
    ITS FUNCTIONAL FLOW IS AS FOLLOWS:

      1. READ THE FIRST RECORD FROM THE "DIRECT" INPUT.  THIS
         CONTAINS THE NUMBER OF LPA/CSECT ENTRIES, AND THE
         LPA/MODULE LOWER AND UPPER BOUNDS.
      2. ALLOCATE THE STRUCTURES AND ARRAYS TO THE APPROPRIATE
         SIZE BASED ON THIS INFORMATION.
      3. READ IN THE LPA/MODULE DIRECTORY (THE DIRECT OR MODMAP
         PROGRAM HAS ALREADY SORTED THE ENTRIES SO THEY ARE IN
         ASCENDING ORDER BY STARTING ADDRESSES.
      4. COMPUTE THE ENDING ADDRESS OF EACH MODULE/CSECT, ZERO THE
         MODULE/CSECT HIT COUNTS, AND TURN OFF THE MODULE/CSECT SELECTED
         INDICATORS.
      5. READ IN THE MODULE/CSECT HIT LIST FROM FILE "COUNTS", SEARCH
         THE MODULE TABLE FOR THE APPROPRIATE MODULE/CSECT, AND SET ITS
         SAMPLE COUNT.
      6. CALCULATE THE USE-FACTORS FOR THE MODULES/CSECTS.  THIS IS
         A FLOATING POINT NUMBER WHICH IS BASED ON THE FOLLOWING
         FORMULA:

                     (LPAHIGH-LPALOW)*MODULE_COUNT
          FACTOR =   -------------------------------
                     MODULE_LENGTH*TOTAL_COUNT

     THIS FACTOR WILL BE 1 IF THE MODULE IS GETTING ITS PROPORTION
        OF SAMPLES BASED ON ITS SIZE.  A NUMBER GREATER THAN 1
        INDICATES THAT THE MODULE IS GETTING HEAVIER THAN NORMAL
        USAGE.
     7. THE MODULES ARE THEN SORTED IN ALPHABETICAL ORDER AND THE
        FIRST REPORT IS PRINTED.
     8. THE MODULES ARE THEN SORTED BY THE USE-FACTORS AND THE SECO
        REPORT IS PRINTED.
     9. THE SYSIN FILE IS OPENED.  IF IT IS UNDEFINED, THE REST OF
        STEP IS SKIPPED.  THE SYSIN FILE MAY CONTAIN CONTROL CARDS
        HANDLE ANY SPECIAL CASES LIKE PURE DATA MODULES AND SPECIAL
        MODULE SEQUENCING.  ALSO THE CONTROL CARDS MAY SPECIFY THAT
        NO MODULE OF ANY SIGNIFICANCE SHOULD BE PACKED WITH THE
        DESIGNATED MODULES.  THE FORMAT OF THE INPUT CONTROL CARDS
        IS AS FOLLOWS:
           COMMAND MODULE1,MODULE2,...,MODULEN
        WHERE COMMAND IS:
         ZERO - ZERO THE USE-FACTORS OF THE FOLLOWING MODULES.
             (WE USE IT FOR THE DIFFERENT SSSM MODULES WHICH
              ARE SWITCHED PERIODICALLY.  SO THE USE-FACTORS
              ARE NOT SIGNIFICANT FOR THEM).
         EQUATE - EQUATES THE USE-FACTOR OF A PURE DATA MODULE
              WITH A CORRESPONDING CODE MODULE (DEVNAMET,DEVMASKT
              WITH IEFW21SD FOR EXAMPLE).
         PACK - FORCES THE MODULES TO BE PACKED TOGETHER
    10. THE MODULES ARE THEN RE-SORTED IN PSEUDO-ALPHABETICAL ORDER
        BASED ON THE FOLLOWING ALGORITHM:
         IF THE MODULE NAME DOES NOT START WITH "IGC" THE NAME
         IS USED AS IS, IF THE MODULE NAME IS "IGCXXYYY" THE
         SORT KEY WILL BE "IGCYYYXX".  THIS SORTS MULTIPLE LOADS
         OF THE SAME SVC TOGETHER.
    11.  THE MODULES ARE THEN SORTED BY USE-FACTOR.  THE TABLE
         IS NOW IN ITS FINAL FORM FOR INPUT INTO THE PACK LIST
         PROCESS.
    12.  MODULES ARE NOW SELECTED FOR PACKING FROM THE TOP OF
         THE TABLE.  AS MODULES ARE SELECTED, THEIR USED BIT
         IS TURNED ON TO INDICATE THAT THEY ARE NO LONGER
         CANDIDATES FOR SELECTION.  THE FIRST MODULE IS CHOSEN,
         ITS LENGTH IS TAKEN MODULO 4096, AND THE REST OF THE
         PAGE IS FILLED GOING DOWN THE TABLE.  WHEN THE PAGE
         IS FULL, OR THERE ARE NO MODULES THAT WILL FIT IN THE
         REMAINDER OF THE PAGE, THE GROUP IS TERMINATED AND THE
         NEXT MODULE FROM THE TOP OF THE TABLE IS CHOSEN TO START
         THE NEXT GROUP.
    13.  THE COMPOSITE GROUP FACTORS ARE CALCULATED ALONG WITH
         EACH GROUPS LENGTH, AND THE PACK GROUPS ARE LISTED.
    14.  THE CARDS FOR THE IEAPAK00 LIST OR THE LINKAGE EDITOR
         ORDER CARDS ARE GENERATED STARTING FROM THE MOST ACTIVE
         GROUP AND MOVING TO THE LEAST ACTIVE GROUP.

    THIS PROGRAM WAS WRITTEN USING THE PL/1 OPTIMIZING COMPILER BY:

              BARRY SCHRAGER
              COMPUTER CENTER
              UNIVERSITY OF ILLINOIS AT CHICAGO CIRCLE
              BOX 4348
              CHICAGO, ILLINOIS 60680

              (312) 996-2478

              VERSION 2 DATED 7/13/77                              */
   DCL (DIRECT,COUNTS) FILE RECORD SEQUENTIAL,
       CARDS FILE STREAM OUTPUT EXTERNAL,
       PARM CHAR(100) VAR,
       TYPRUN CHAR(4),
     1 MODULE(*) CONTROLLED,
       2 NAME CHAR(8),
       2 (LENGTH,COUNT) FIXED BIN(31),
       2 FACTOR FLOAT DECIMAL(6),
       2 USED BIT(1),
     1 STATS,
       2 (MODCOUNT,LPALOW,LPAHIGH,FILL) FIXED BIN(31),
     1 STAT2,
       2 (MODCOUNT2,FILL1,FILL2) FIXED BIN(31),
     1 DIRIN BASED(DIRPTR),
       2 NAME CHAR(8),
       2 (START,LENGTH) FIXED BIN(31),
     1 COUNTIN BASED(CNTPTR),
       2 NAME CHAR(8),
       2 COUNT FIXED BIN(31),
       IND(*) FIXED BIN(31) CONTROLLED,
       GIND(*) FIXED BIN(31) CONTROLLED,
       GROUP(*) FIXED BIN(31) CONTROLLED,
       ADR FIXED BIN(31) BASED(PADR),
       SEARCHING BIT(1),
       TOT FIXED BIN(31) INIT(0),
       (DATE,LENGTH) BUILTIN,
       (I,J,K,L,M,N,P,SIZE,MAXGROUP) FIXED BIN(31),
       CARD CHAR(70) VAR,
       HEX(0:15) CHAR(1) INIT('0','1','2','3','4','5','6','7',
        '8','9','A','B','C','D','E','F'),
      TDATE CHAR(8), CTEMP CHAR(6), CWORK CHAR(80) VAR,
      COMMAND CHAR(8),CMODS(20) CHAR(8),
      MODNAME CHAR(8) VAR,
      GFACT FLOAT DECIMAL(6);
1  TOHEX: PROC(A) RETURNS(CHAR(6));
      DCL C CHAR(6) VAR INIT(''), (A,I,AD) FIXED BIN(31);
      AD=A;
   DO I=1 TO 6;
    C=HEX(MOD(AD,16))××C; AD=AD/16;
   END;
    RETURN(C);
    END TOHEX;
0  ALPHA: PROC(A) RETURNS(CHAR(8));
     DCL (A,C) CHAR(8);
     IF SUBSTR(A,1,3)='IGC' THEN
       C=SUBSTR(A,1,3)××SUBSTR(A,6,3)××SUBSTR(A,4,2);
      ELSE C=A;
     RETURN(C);
     END ALPHA;
1 /*PROCESS PARM FIELD OPTION  -  DEFAULT IS PACK
    LINK SPECIFIES THAT ORDER CARDS ARE TO BE PRODUCED */
   IF LENGTH(PARM)=0 THEN TYPRUN='PACK';
    ELSE DO;
      SELECT;
       WHEN (PARM='PACK') TYPRUN='PACK';
       WHEN (SUBSTR(PARM,1,4)='LINK') DO;
         CWORK=SUBSTR(PARM,5);
         IF SUBSTR(CWORK,1,1)^='(' THEN DO;
           PUT EDIT('MODULE NAME FOR LINK MUST BE SPECIFIED')(A) SKIP;
           STOP;
         END;
         I=INDEX(CWORK,')');
         IF I<2 × I>10 THEN DO;
           PUT EDIT('INVALID MODULE NAME SYNTAX')(A) SKIP;
           STOP;
         END;
         MODNAME=SUBSTR(CWORK,2,I-2);
         TYPRUN='LINK';
       END;
       OTHER DO;
        PUT EDIT('ILLEGAL PARM FIELD OPTION',PARM,
        'EXECUTION TERMINATING')(A,X(1),A,X(1),A) SKIP;
        STOP;
      END;
     END;
    END;
1  ON ERROR PUT DATA;
  CTEMP=DATE;
  TDATE=SUBSTR(CTEMP,3,2)××'/'××SUBSTR(CTEMP,5,2)××'/'××SUBSTR(CTEMP,1,2
 );
  OPEN FILE(DIRECT) INPUT, FILE(COUNTS) INPUT;
  READ FILE(DIRECT) INTO(STATS);
  MAXGROUP=(LPAHIGH-LPALOW+4096)/2048;
  ALLOCATE MODULE(MODCOUNT), IND(MODCOUNT), GIND(MODCOUNT), GROUP(
 MAXGROUP);
  FILDIR: DO I=1 TO MODCOUNT;
    READ FILE(DIRECT) SET(DIRPTR);
    MODULE(I)=DIRIN, BY NAME;
    END FILDIR;
  MODULE(*).COUNT=0; MODULE(*).USED='0'B;
  READ FILE(COUNTS) INTO(STAT2);
  DO I=1 TO MODCOUNT2;
     READ FILE(COUNTS) SET(CNTPTR);
     SEARCHING = 1B;
     DO J=1 TO MODCOUNT WHILE(SEARCHING);
        IF MODULE(J).NAME = COUNTIN.NAME THEN DO;
           MODULE(J).COUNT = COUNTIN.COUNT;
           TOT = TOT + COUNTIN.COUNT;
           SEARCHING = 0B;
        END;
     END;
  END;
1 CALC: MODULE(*).FACTOR=(FLOAT(LPAHIGH-LPALOW)/FLOAT(MODULE(*).LENGTH))
      *(FLOAT(MODULE(*).COUNT)/FLOAT(TOT));
0  DO I=1 TO MODCOUNT; IND(I)=I; END;
0  SORTA: DO I=MODCOUNT-1 TO 1 BY -1;
     DO J=1 TO I;
      IF MODULE(IND(J)).NAME>MODULE(IND(J+1)).NAME THEN DO;
    K=IND(J); IND(J)=IND(J+1); IND(J+1)=K; END SORTA;
1 PLPA: DO I=1 TO MODCOUNT BY 200;
  PUT EDIT('UICC PACKLIST GENERATOR','MODULES/CSECTS SORTED ALPHABETICAL
 Y',TDATE)
   (COL(1),A,COL(43),A,COL(111),A) SKIP;
  PUT SKIP;
  CWORK='  NAME   LENGTH   FACTOR';
  PUT EDIT(CWORK,CWORK,CWORK,CWORK)(COL(1),A,COL(33),A,COL(65),A,COL(97)
 ,A) SKIP;
  PUT SKIP;
  K=(MIN(I+200,MODCOUNT+1)-I+3)/4;
  DO L=I TO I+K-1;
  PUT EDIT((MODULE(IND(L+J)).NAME,TOHEX(MODULE(IND(L+J)).LENGTH),
       MODULE(IND(L+J)).FACTOR DO J=0 TO 3*K BY K WHILE(L+J<=MODCOUNT)))
       ((4)(A(8),X(1),A(6),X(1),F(8,3),X(8))) SKIP;
   END;
  PUT PAGE;
 END PLPA;
0  SORT: DO I=MODCOUNT-1 TO 1 BY -1;
     DO J=1 TO I;
      IF MODULE(IND(J)).FACTOR<MODULE(IND(J+1)).FACTOR THEN DO;
       K=IND(J); IND(J)=IND(J+1); IND(J+1)=K;
   END SORT;
0 PLP1: DO I=1 TO MODCOUNT BY 200;
  PUT EDIT('UICC PACKLIST GENERATOR','MODULES/CSECTS SORTED BY USE FACTO
 R',TDATE)
   (COL(1),A,COL(43),A,COL(111),A) SKIP;
  PUT SKIP;
  CWORK='  NAME   LENGTH   FACTOR';
  PUT EDIT(CWORK,CWORK,CWORK,CWORK)(COL(1),A,COL(33),A,COL(65),A,COL(97)
 ,A) SKIP;
  PUT SKIP;
  K=(MIN(I+200,MODCOUNT+1)-I+3)/4;
  DO L=I TO I+K-1;
  PUT EDIT((MODULE(IND(L+J)).NAME,TOHEX(MODULE(IND(L+J)).LENGTH),
       MODULE(IND(L+J)).FACTOR DO J=0 TO 3*K BY K WHILE(L+J<=MODCOUNT)))
       ((4)(A(8),X(1),A(6),X(1),F(8,3),X(8))) SKIP;
   END;
  PUT PAGE;
 END PLP1;
1  ON ENDFILE(SYSIN) GO TO ESYSIN;
     ON UNDEFINEDFILE(SYSIN) GO TO NSYSIN;
     OPEN FILE(SYSIN) INPUT;
   PUT EDIT('UICC PACKLIST GENERATOR','SYSIN CONTROL CARD LISTING',TDATE
 )
     (COL(1),A,COL(45),A,COL(111),A) SKIP;
   PUT SKIP(2);
0 N=1; M=0;
0  CGET: GET EDIT(CWORK) (COL(1),A(80)); L=0;
   PUT EDIT(CWORK) (COL(1),A(80)) SKIP;
   PUT SKIP;
    COMMAND=SUBSTR(CWORK,1,INDEX(CWORK,' ')-1);
    I=INDEX(CWORK,' ');
    DO WHILE(SUBSTR(CWORK,I,1)=' '); I=I+1; END;
   CLOOP: CWORK=SUBSTR(CWORK,I);
    J=INDEX(CWORK,',');
    IF J=0 THEN J=INDEX(CWORK,' ');
    IF J>1 THEN DO;
     L=L+1; CMODS(L)=SUBSTR(CWORK,1,J-1); I=J+1; GO TO CLOOP; END;
    GFACT=0;
   SLOOP: DO I=1 TO L;
    DO J=1 TO MODCOUNT;
     IF CMODS(I)=MODULE(J).NAME THEN GO TO ESLOOP;
    END;
    PUT LIST('MODULE '××CMODS(I)××' NOT FOUND') SKIP; STOP;
   ESLOOP: IND(I)=J; GFACT=MAX(GFACT,MODULE(J).FACTOR);
   END SLOOP;
0  IF COMMAND = 'PACK' THEN DO;
      M = M + 1;
      GROUP(M) = N;
      DO I = 1 TO L;
         J = IND(I);
         GIND(N) = J; N = N + 1;
         MODULE(J).USED = '1'B;
      END;
      GO TO OKCOMD;
   END;
0  IF COMMAND='ZERO' THEN DO;
    GFACT=0; GO TO OKCOMD; END;
   IF COMMAND='EQUATE' THEN GO TO OKCOMD;
   PUT LIST(COMMAND××' IS NOT VALID') SKIP; STOP;
0  OKCOMD: PUT EDIT('THE USE-FACTOR OF THE FOLLOWING MODULES WILL BE SET
  TO',
     GFACT) (COL(3),A,X(1),F(8,3)) SKIP;
   DO I=1 TO L; MODULE(IND(I)).FACTOR=GFACT; END;
   PUT EDIT((MODULE(IND(I)).NAME DO I=1 TO L))
      (COL(10),(12)(A(8),X(1))) SKIP;
   PUT SKIP;
  GO TO CGET;
0 ESYSIN: PUT SKIP(3);
   PUT EDIT('END OF FILE ON SYSIN')(COL(1),A) SKIP;
   PUT PAGE;
 NSYSIN:
0  DO I=1 TO MODCOUNT; IND(I)=I; END;
0  PBSORT: DO I=MODCOUNT-1 TO 1 BY -1;
     DO J=1 TO I;
      IF ALPHA(MODULE(IND(J)).NAME)>ALPHA(MODULE(IND(J+1)).NAME) THEN DO
 ;
       K=IND(J); IND(J)=IND(J+1); IND(J+1)=K;
   END PBSORT;
0  BSORT: DO I=MODCOUNT-1 TO 1 BY -1;
     DO J=1 TO I;
      IF MODULE(IND(J)).FACTOR<MODULE(IND(J+1)).FACTOR THEN DO;
       K=IND(J); IND(J)=IND(J+1); IND(J+1)=K;
   END BSORT;
1 MAIN: DO I=1 TO MODCOUNT;
   J=IND(I);
   IF ^MODULE(J).USED THEN DO;
     MODULE(J).USED='1'B; M=M+1; GROUP(M)=N; GIND(N)=J; N=N+1;
     SIZE=MOD(MODULE(J).LENGTH,4096);
0    DO K=I TO MODCOUNT;
      L=IND(K);
      IF ^MODULE(L).USED THEN DO;
       IF MODULE(L).LENGTH<=4096-SIZE THEN DO;
        MODULE(L).USED='1'B; GIND(N)=L; N=N+1;
        SIZE=SIZE+MODULE(L).LENGTH;
       END;
      END;
     END;
    END;
    END MAIN;
0 GROUP(M+1)=N;
 PUT EDIT('UICC PACKLIST GENERATOR','PACK GROUPS GENERATED',TDATE)
     (COL(1),A,COL(50),A,COL(111),A) SKIP;
 PUT SKIP;
 PUT EDIT('PAGE NUM  LENGTH   FACTOR','MODULES')
     (COL(3),A,COL(75),A) SKIP;
 PUT SKIP;
0  N=1;
0 PLP2: DO I=1 TO M;
  J=GROUP(I); K=GROUP(I+1)-1;
  SIZE=0; P=0;
  IPLP2: DO L=J TO K;
    SIZE=SIZE+MODULE(GIND(L)).LENGTH;
    P=P+MODULE(GIND(L)).COUNT;
   END IPLP2;
    GFACT=(FLOAT(LPAHIGH-LPALOW)/FLOAT(SIZE))*(FLOAT(P)/FLOAT(TOT));
  PUT EDIT(N,TOHEX(SIZE),GFACT,(MODULE(GIND(L)).NAME DO L=J TO K))
   (COL(5),F(3),COL(13),A(6),COL(20),F(8,3),(99)(COL(30),(10)(A(8),X(1))
 )) SKIP;
   PUT SKIP;
  N=N+(SIZE+4095)/4096;
  END PLP2;
1 CARD='';
  PUT PAGE;
  PUT EDIT('UICC PACKLIST GENERATOR','CARDS PRODUCED',TDATE)
    (COL(1),A,COL(49),A,COL(111),A) SKIP;
  PUT SKIP;
  SELECT;
    WHEN (TYPRUN='PACK') DO;
  FOUT: DO I=1 TO M;
    J=GROUP(I); K=GROUP(I+1)-1; CARD=CARD××'(';
    DO L=J TO K;
     N=GIND(L);
     P=INDEX(MODULE(N).NAME,' '); IF P=0 THEN P=8; ELSE P=P-1;
     CARD=CARD××SUBSTR(MODULE(N).NAME,1,P);
     IF L<K THEN CARD=CARD××',';
      ELSE IF I<M THEN CARD=CARD××'),';
       ELSE CARD=CARD××')';
     IF LENGTH(CARD)>59 THEN DO;
     PUT FILE(CARDS) EDIT(CARD) (X(1),A(70)) SKIP;
     PUT EDIT(CARD)(COL(25),A) SKIP;
     CARD='';
     END;
   END FOUT;
     IF LENGTH(CARD)>0 THEN DO;
     PUT FILE(CARDS) EDIT(CARD) (X(1),A(70)) SKIP;
     PUT EDIT(CARD)(COL(25),A) SKIP;
     END;
    END;
    WHEN (TYPRUN='LINK') DO;
      CARD='INCLUDE SYSLIB('××MODNAME××')';
      PUT FILE(CARDS) EDIT(CARD) (X(1),A(70)) SKIP;
      PUT EDIT(CARD) (COL(25),A) SKIP;
0 COUT: DO I=1 TO M;
    J=GROUP(I); K=GROUP(I+1)-1;
    N=GIND(J);
    P=INDEX(MODULE(N).NAME,' '); IF P=0 THEN P=8; ELSE P=P-1;
    CARD='ORDER '××SUBSTR(MODULE(N).NAME,1,P)××'(P)';
    CWORK=',';
    DO L=J+1 TO K;
     N=GIND(L);
     P=INDEX(MODULE(N).NAME,' '); IF P=0 THEN P=8; ELSE P=P-1;
     CARD=CARD××CWORK××SUBSTR(MODULE(N).NAME,1,P);
     CWORK=',';
     IF LENGTH(CARD)>59 & L<K THEN DO;
       PUT FILE(CARDS) EDIT(CARD) (X(1),A(70)) SKIP;
       PUT EDIT(CARD) (COL(25),A) SKIP;
       CARD='';
       CWORK='ORDER ';
     END;
    END;
   PUT FILE(CARDS) EDIT(CARD) (X(1),A(70)) SKIP;
   PUT EDIT(CARD) (COL(25),A) SKIP;
  END COUT;
   CARD='NAME '××MODNAME××'(R)  INSERT PROPER ALIAS CARDS ABOVE';
   PUT FILE(CARDS) EDIT(CARD) (X(1),A(70)) SKIP;
   PUT EDIT(CARD) (COL(25),A) SKIP;
    END;
    OTHER PUT DATA;
*   RECFM=FB,LRECL=16,BLKSIZE=3120
*
*   THE RECORD CONTENTS ARE AS FOLLOWS:
*
*   RECORD 1:
*
*      **********************************************
*      * NUMBER OF * LPA LOW  * LPA HIGH * UNUSED   *
*      *  ENTIRES  * ADDRESS  * ADDRESS  *          *
*      **********************************************
*
*   ALL SUBSEQUENT RECORDS (=NUMBER OF ENTRIES)
*
*      **********************************************
*      *  MODULE NAME         * STARTING * MODULE   *
*      *                      * ADDRESS  * LENGTH   *
*      **********************************************
*
*   THIS PROGRAM REQUIRES SYS1.AMODGEN TO ASSEMBLE CORRECTLY.
*
*   THIS PROGRAM WAS WRITTEN BY:
*
*                 BARRY SCHRAGER
*                 COMPUTER CENTER
*                 UNIVERSITY OF ILLINOIS AT CHICAGO CIRCLE
*                 BOX 4348
*                 CHICAGO, ILLINOIS 60680
*
*                 (312) 996-2478
*
*                 VERSION 1 DATED 7/21/76
*
DIRBUILD CSECT
         CVT   DSECT=YES
         IHALPDE
LPDESIZE EQU   *-LPDE  SIZE OF LPDE ENTRY
DIRENT   DSECT   DIRECTORY ENTRY
DIRNAME  DS    CL8  MODULE NAME
DIRSTART DS    A   STARTING ADDRESS
DIRLNGTH DS    A   MODULE LENGTH
DIRSIZE  EQU   *-DIRENT   LENGTH OF DIRECTORY ENTRY
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         EJECT
DIRBUILD CSECT
         SAVE  (14,12),,*  ENTER
         LR    R12,R15  SET UP ADDRESSING
         USING DIRBUILD,R12
         LA    R2,SAVEAREA   CHAIN SAVE AREAS
         ST    R2,8(,R13)
         ST    R13,4(,R2)
         LR    R13,R2
         L     R2,CVTPTR  GET THE CVT ADDRESS
         L     R2,CVTLPDIA-CVT(R2)  GET LPA DIRECTORY ADDR
         USING LPDE,R2   ADDRESS FIRST ENTRY
         GETMAIN VU,LA=GMAINR,A=STORAGE,BNDRY=PAGE
         L     R3,STORAGE  POINT TO TABLE START
         LR    R15,R3  CALCULATE END OF TABLE
         A     R15,STORSIZE
         ST    R15,STOREND  AND SAVE FOR LATER
         USING DIRENT,R3  ADDRESS IT
         SR    R15,R15  CLEAR R15 FOR USE DURING TABLE BUILD
*
*  FILL THE DIRECTORY TABLE FROM THE LINK PACK AREA DIRECTORY
*
FLOOP    CLC   LPDENAME,=XL8'FFFFFFFFFFFFFFFF'  END OF LPA?
         BE    EFLOOP  YES, EXIT THIS LOOP
         TM    LPDEATTR,LPDEMIN  MINOR ENTRY?
         BO    IFLOOP  YES, SKIP IT
         MVC   DIRNAME,LPDENAME   MOVE MODULE NAME TO TABLE
         ICM   R15,7,LPDEXTAD+1   GET MODULE START
         ST    R15,DIRSTART  AND PUT ADDR IN TABLE
         ICM   R15,7,LPDEXTLN+1    GET MODULE LENGTH
         ST    R15,DIRLNGTH  AND PUT INTO TABLE
         LA    R3,DIRSIZE(,R3)  INC TO NEXT TABLE ENTRY
         C     R3,STOREND   CHECK AGAINST END
         BNL   ERRSIZE  SIGNAL REGION TOO SMALL
IFLOOP   LA    R2,LPDESIZE(,R2)  GO TO NEXT LPDE
         B     FLOOP   AND LOOP
         SPACE 2
EFLOOP   L     R4,STOREND   GET THE END OF THE STORAGE
         SR    R4,R3  CALCULATE UNUSED SPACE
         FREEMAIN RU,LV=(R4),A=(R3)  FREE IT
         ST    R3,STOREND  RESET END OF STORAGE
         S     R3,STORAGE  CALCULATE TABLE LENGTH
         ST    R3,STORSIZE  AND SAVE STORAGE SIZE
         DROP  R2,R3   DROP REGISTERS FROM FIRST LOOP
*
*  SORT THE DIRECTORY BY MODULE START
*
         LA    R0,DIRSIZE   SET UP OUTER LOOP
         SLA   R0,1  MULTIPLY ENTRY SIZE BY 2
         L     R1,STOREND  GET N+1ST ENTRY ADDR
         SR    R1,R0  WANT N-1ST ENTRY ADDR
         SRA   R0,1  GET ENTRY SIZE BACK
         LNR   R2,R0  GET NEG ENTRY SIZE IN R2
         L     R3,STORAGE  GET DIRECTORY STARTG
         SR    R3,R0  GET -1ST ENTRY
OLOOP    L     R5,STORAGE   SET UP INNER LOOP
         LA    R6,DIRSIZE   GET ENTRY SIZE
         LR    R7,R1  SET UP INNER LOOP LIMIT
ILOOP    LA    R8,DIRSIZE(,R5)  GET N+1ST ELEMENT
         L     R0,DIRSTART-DIRENT(R5)  GET NTH ENTRY PT
         C     R0,DIRSTART-DIRENT(R8)  COMPARE TO N+1ST ENTRY PT
         BL    EILOOP  IF LOW, CONTINUE
         MVC   WORK,0(R5)  SWAP THE ENTRIES
         MVC   0(L'WORK,R5),0(R8)
         MVC   0(L'WORK,R8),WORK
EILOOP   BXLE  R5,R6,ILOOP   END INNER LOOP
         BXH   R1,R2,OLOOP  END OUTER LOOP
*
* CALCULATE NUMBER OF ENTRIES, START AND END OF LPA
*
         XC    WORK,WORK  USE THE WORK AREA FOR STORAGE
         L     R1,STORSIZE  GET THE TABLE LENGTH
         SR    R0,R0  CLEAR R0 FOR DIVIDE
         LA    R15,DIRSIZE  GET THE ENTRY SIZE
         DR    R0,R15   GET THE NUMBER OF ENTRIES
         ST    R1,WORK  PUT INTO WORK STRING
         L     R1,STORAGE  GET THE FIRST ENTRY ADDRESS
         L     R0,DIRSTART-DIRENT(R1)  GET THE FIRST MODULE START
         ST    R0,WORK+4   PUT INTO WORK AREA
         L     R1,STOREND  GET THE ADDR OF THE N+1 ST ENTRY
         SR    R1,R15   GET THE NTH ENTRY ADDR
         L     R0,DIRSTART-DIRENT(R1)  GET THE MODULE START
         A     R0,DIRLNGTH-DIRENT(R1)  ADD IN THE MODULE LENGTH
         ST    R0,WORK+8  AND PUT INTO WORK AREA
*
*  OPEN UP THE OUTPUT FILE AND WRITE OUT THE DIRECTORY
*  THE FIRST RECORD IS THE NUMBER OF ENTRIES, THE
*  LPA START AND END.  THE REST ARE THE DIRECTORY
*  ENTRIES SORTED BY MODULE START.
*
         OPEN  (DIRECT,(OUTPUT))
         LTR   R15,R15  TEST FOR GOOD OPEN
         BZ    *+6  OK, CONTINUE
         DC    H'0'  ABEND OF NON-ZERO
         PUT   DIRECT,WORK  WRITE OUT STATS
         L     R3,STORAGE  SET UP FOR LOOP TO WRITE DIRECTORY
         LA    R4,DIRSIZE  ENTRY SIZE
         L     R5,STOREND
         SR    R5,R4  LAST ENTRY ADDRESS
WLOOP    PUT   DIRECT,(R3)  WRITE OUT DIRECTORY ENTRY
         BXLE  R3,R4,WLOOP   LOOP
         CLOSE (DIRECT)
         L     R3,STORSIZE  GET STORAGE SIZE
         FREEMAIN RU,LV=(R3),A=STORAGE
         L     R13,4(,R13)  GET OLD SAVE AREA
         RETURN (14,12),RC=0
ERRSIZE  WTO   'REGION TOO SMALL - DIRECTORY BUILD FAILURE',ROUTCDE=11
         L     R13,4(,R13)  GET OLD SAVE AREA
         RETURN (14,12),RC=12  RETURN
         SPACE 10
SAVEAREA DS    9D
WORK     DS    CL(DIRSIZE)  WORK AREA
GMAINR   DC    A(4096,409600)  STORAGE GETMAIN RANGE
STORAGE  DC    A(0)  STORAGE AREA START
STORSIZE DC    A(0)  SIZE OF STORAGE AREA
STOREND  DC    A(0)  FIRST BYTE NOT IN STORAGE AREA
DIRECT   DCB   DDNAME=DIRECT,BLKSIZE=3120,LRECL=DIRSIZE,DEVD=DA,       X
               DSORG=PS,MACRF=PM,RECFM=FB
         END DIRBUILD
./  ADD  NAME=DOCUM
      U I C C  P A C K L I S T  G E N E R A T O R

          VERSION 3       7/20/77

  THIS SET OF PROGRAMS WILL PERFORM THE FOLLOWING FUNCTIONS:

     1. COLLECT PSW SAMPLES FOR ROUTINES IN THE LINK PACK
        AREA (PSWSAMP).  THIS IS NOT THE RECOMMENDED COLLECTION
        PROGRAM.  THE RECOMMENDED APPROACH IS USING YALE'S
        STATDIE AND OURMF PROGRAMS TO COLLECT THE DATA.  THESE
        ROUTINES DO A MUCH BETTER JOB AT LESS OVERHEAD AND
        COLLECT SUFFICIENT INFORMATION TO DO PROGRAM PACKING
        ALSO.

     2. MAP THE LINK PACK AREA AND PRODUCE A SEQUENTIAL FILE
        OF MODULE STARTING ADDRESSES AND LENGTHS (DIRECT).

     3. PSEUDO-MAP THE LINK PACK AREA FROM THE DIRECTORY OF
        THE PDS "SYS1.LPALIB" AND PRODUCE A SEQUENTIAL FILE
        OF MODULE PSEUDO-STARTING ADDRESSES AND LENGTHS (LPAMAP).

     4. PSEUDO-MAP A LOAD MODULE FROM THE CESD ENTRIES IN THE
        LOAD MODULE AND PRODUCE A SEQUENTIAL FILE OF CSECT
        RELATIVE STARTING ADDRESSES AND LENGTHS (MODMAP).

     5. TAKE INFORMATION COLLECTED FROM OURMF (CONTACT YALE)
        AND POST PROCESS IT BY LPA MODULE, PROGRAM MODULE, OR
        STRAIGHT LPA MAPPING FUNCTIONS (OMFPST4).  ONE COULD
        DO LPA MODULE PACKING BY USING THE OUTPUT OF PSWSAMP
        AND THE DIRECT PROGRAM, BUT THIS IS NOT SUPPLIED SINCE
        WE NOW DO OUR OWN SAMPLING VIA OURMF AND STATDIE.

     6. PRODUCE A FILE OF COUNTS PER CSECT OR MODULE FROM THE
        OUTPUT OF THE PSWSAMP ROUTINE OR THE OURMF POST PROCESSOR
        (OMFPST4).

     7. PRODUCE SYS1.PARMLIB(IEAPAK00) CONTROL CARDS OR LINKAGE
        EDITOR CONTROL CARDS TO REPACK THE MODULES IN THE LPA
        OR THE CSECTS IN A LOAD MODULE (ANALYSIS).

USER CONTROL INPUT:

  ONLY TWO OF THE ROUTINES HAVE CONTROLLING INPUT PARAMETERS:

  OMFPST4: INPUT SPECIFIED EITHER IN SYSIN OR IN PARM FIELD
   CONTROL OPERANDS ARE:

       START(YYDDD,HHMMSS)   STARTING DATE AND TIME
       END(YYDDD,HHMMSS)     ENDING DATE AND TIME
       HOURS(HHMMSS,HHMMSS)  TIME PERIOD DURING THE DAY

           AND ONE OF THE FOLLOWING PARAMETERS

       LPA(MAP)   PRODUCE OUTPUT FOR PACKING THE LPA
       PGM(PGMNAME)  PRODUCE OUTPUT FOR PACKING A PROGRAM
       MOD(MODULE)  PRODUCE OUTPUT FOR PACKING AN LPA MODULE

  ANALYSIS: INPUT SPECIFIED IN PARM FIELD
   CONTROL OPERANDS AREA:

       PACK      PRODUCE CARDS FOR "SYS1.PARMLIB(IEAPAK00)"
       LINK(MODULE)  PRODUCE CARDS FOR THE RE-LINK EDIT OF
                     THE SPECIFIED MODULE
   SYSIN INPUT TO ANALYSIS IS AS FOLLOWS:

    ZERO M1,M2,M3,...,MN  ZERO THE USE FACTORS FOR THE SPECIFIED
          MODULES/CSECTS.  USEFUL WHEN DECEPTIVELY HIGH COUNTS
          WOULD MISLEAD THE PACKING ALGORITHM.  WE USE IT
          TO ZERO COUNTS FOR THE ALTERNATE JES SSSM'S.

    EQUATE M1,M2,M3,...,MN  EQUATE THE USE FACTORS FOR THE SPECIFED
           MODULES/CSECTS.  USEFUL FOR PURE DATA MODULES WHICH WOULD
           NOT GET PSW SAMPLES.  THIS WAY THEY CAN BE ASSOCIATED
           WITH THEIR PROPER CODE MODULES.

    PACK M1,M2,M3,...,MN  PACK THE SPECIFIED MODULES/CSECTS TOGETHER.
           THE ANALYSIS PROGRAM DOES NO VALIDITY CHECKING OF THE
           MODULES (CONCERNING LENGTHS, ETC.) AND MERELY PRODUCES
           THE MODULES AS ONE PACK GROUP.  YOU SHOULD FOLLOW THE
           RULES SPECIFIED IN INITIALIZATION AND TUNING GUIDE
           FOR PACKING MODULES.  USEFUL FOR RMF AND MF1 SYSTEMS
           WHICH FIX MODULES WHEN THEY ARE RUNNING.

****************************************************************
OMFPST4 AND THE MODULE AND PROGRAM REPACKING FUNCTIONS OF THIS
PACKAGE REQUIRE THE YALE COLLEGE OURMF SYSTEM WRITTEN BY
      HOWARD GILBERT
      YALE COLLEGE
      175 WHITNEY AVE
      NEW HAVEN, CT 06520
      203 432-4080
****************************************************************

THERE ARE FOUR SETS OF JCL IN THE PACKAGE WHICH ARE:

    JCLBTAPE: BUILD A TAPE OF THE LPA DIRECTORY AND MODULE COUNTS
    JCLATAPE: ANALYSE THE TAPE WITH A CHANGED LPA TO PRODUCE NEW
              NEW PACKING CARDS (USEFUL WITH SELECTABLE UNIT OR
              PROGRAM UPTAPE TAPE INSTALLATIONS).
    JCLLPA: REPACK THE LPA
    JCLMOD: RELINK A PROGRAM OR MODULE WITHIN THE LPA

THE ORIGINAL IDEA OF THIS PACKAGE CAME FROM THE GERRARD BANK PACKER
PROGRAM, BUT WE HAVE PROGRESSES SIGNIFICANTLY PAST THOSE BEGINNINGS.

THIS PACKAGE WAS WRITTEN BY:

         BARRY SCHRAGER
         COMPUTER CENTER
         UNIVERSITY OF ILLINOIS AT CHICAGO CIRCLE
         BOX 4348
         CHICAGO, ILLINOIS 60680

         312 996-2478
./  ADD  NAME=GENCNTS
 GENCNTS:PROC OPTIONS(MAIN) REORDER;
 /*
     THIS PROGRAM IS PART OF THE PACKLIST GENERATOR, IT

     1) READS THE LPA DIRECTORY FROM FILE "DIRECT"

     2) READS THE PSW SAMPLES (FILENAME "TAPE"), AND INCREMENTS
        COUNTS FOR THE MODULE IN LPA

     3) WRITES A NEW FILE (FILENAME "COUNTS") CONTAINING
        MODULE NAME AND REFRENCE COUNT.

    THE FILE "COUNTS" CAN BE USED WITH PACKER EVEN AFTER LPA
    HAS BEEN CHANGED.
                                                           */
        DCL (DIRECT,TAPE) FILE INPUT SEQUENTIAL,
0           COUNTS FILE OUTPUT RECORD SEQUENTIAL
               ENV(FB RECSIZE(12) BLKSIZE(3660)),
0           1 STATS,
              2 (MODCOUNT,LPALOW,LPAHIGH,FILL) FIXED BIN(31),
0           1 MODULE(*) CONTROLLED,
              2 NAME CHAR(8),
              2 (START,LENGTH,END,COUNT) FIXED BINARY(31),
0           1 DIRIN BASED(P),
              2 NAME CHAR(8),
              2 (START,LENGTH) FIXED BINARY(31),
0           1 MODOUT,
              2 NAME CHAR(8),
              2 COUNT FIXED BINARY(31),
          1 OSTATS,
              2 (OUTCOUNT,FILL1,FILL2) FIXED BINARY(31),
0           ADDRESS FIXED BINARY(31) BASED(P),
0           P POINTER,
0           SEARCHING BIT(1),
0           I FIXED BINARY(31),
0           HITS FIXED BINARY(31) INIT(0),
0           SAMPLCT FIXED BINARY(31) INIT(0);
1 /*
           READ THE LPA DIRECTORY
                                         */
         READ FILE(DIRECT) INTO(STATS);
         ALLOCATE MODULE(MODCOUNT);
         DO I=1 TO MODCOUNT;
            READ FILE(DIRECT) SET(P);
            MODULE(I) = DIRIN, BY NAME;
         END;
         CLOSE FILE(DIRECT);
         MODULE(*).END = MODULE(*).START + MODULE(*).LENGTH;
         MODULE(*).COUNT = 0;
         ON ENDFILE(TAPE) GO TO FINISH;
0 /*
             READ THE SAMPLES, MATCH THEM WITH LPA ENTRIES,
             AND INCREMENT THE HIT COUNT
                                                            */
         DO WHILE (1>0);
0           READ FILE(TAPE) SET(P);
            SAMPLCT = SAMPLCT + 1;
            SEARCHING = 1B;
0           IF ADDRESS >= LPALOW & ADDRESS <= LPAHIGH THEN
               DO I=1 TO MODCOUNT WHILE(SEARCHING);
0                 IF ADDRESS < MODULE(I).END THEN DO;
                     MODULE(I).COUNT = MODULE(I).COUNT + 1;
                     HITS = HITS + 1;
                     SEARCHING = 0B;
                   END;
               END;
         END;
0 /*
          WHEN WE HIT THE END OF SAMPLES, WRITE OUT THE
          STATISTICS RECORD (# OF MODULES), AND A RECORD
          FOR EACH MODULE
                                                         */
0FINISH:   CLOSE FILE(TAPE);
           OUTCOUNT = MODCOUNT; FILL1,FILL2=0;
            WRITE FILE(COUNTS) FROM(OSTATS);
            DO I=1 TO MODCOUNT;
               MODOUT = MODULE(I), BY NAME;
               WRITE FILE(COUNTS) FROM(MODOUT);
            END;
            PUT SKIP EDIT(SAMPLCT,'=NUMBER OF SAMPLES READ',
                           HITS,'=HITS') (F(5),A,SKIP);
            IF HITS=0 THEN STOP;
0END GENCNTS;
./  ADD  NAME=JCLATAPE
//PACKER JOB CLASS=U,TYPRUN=HOLD
//JOBCAT DD DSN=SYS1.NEWRES.CATALOG,DISP=SHR
/*MESSAGE     MOUNT -NEWRES- PACK
/*MESSAGE     MOUNT TAPE TP6322 RING/OUT
/*JOBPARM  T=5,L=10
//*
//LPAMAP  EXEC PGM=LPAMAP
//STEPLIB DD DSNAME=SYS1.UTILLIB,DISP=SHR
//DIRECT  DD UNIT=SYSDA,SPACE=(TRK,(5,5)),DSN=&DIRECT,
//           DCB=(RECFM=FB,LRECL=16,BLKSIZE=3664),DISP=(,PASS)
//LPALIB  DD DSNAME=SYS1.LPALIB,DISP=SHR
//*
//ANALYSIS EXEC PGM=ANALYSIS,PARM='/PACK'
//STEPLIB  DD DSNAME=SYS1.UTILLIB,DISP=SHR
//SYSPRINT DD SYSOUT=A
//DIRECT   DD DSNAME=&DIRECT,DISP=(OLD,DELETE)
//TAPE DD DSN=COUNTS,DISP=OLD,UNIT=TAPE,VOL=SER=TP6322,LABEL=3
//PAKLIST DD DSN=SYS1.PARMLIB(IEAPAK00),DISP=SHR
//SYSIN    DD DSNAME=UCC6064.$PUTCNTL.CNTL(PACKDATA),DISP=SHR
./  ADD  NAME=JCLBTAPE
//* THIS PROCEDURE BUILDS A TAPE FROM THE DATA PRODUCED
//* BY THE PACKER PSW COLLECTOR.  THE TAPE CAN BE USED
//* LATER TO REPACK THE LPA FOLLOWING PUT OR SU INSTALLATIONS.
//CRE EXEC PGM=DIRECT
// DCB=(RECFM=FB,LRECL=4,BLKSIZE=3664),LABEL=2
//GENCNTS EXEC PGM=GENCNTS
//STEPLIB DD DSN=SYS1.UTILLIB,DISP=SHR
//SYSPRINT DD SYSOUT=A
//DIRECT DD DSN=DIRECT,DISP=OLD,UNIT=TAPE,
// VOL=(,RETAIN,SER=(TP6322))
//TAPE DD DSN=PSWSAMP,DISP=OLD,UNIT=TAPE,
// VOL=(,RETAIN,SER=(TP6322)),LABEL=2
//OUT DD DSN=COUNTS,DISP=(,KEEP),UNIT=TAPE,
// VOL=(,RETAIN,SER=(TP6322)),LABEL=3,
// DCB=(RECFM=FB,LRECL=16,BLKSIZE=3664)
./  ADD  NAME=JCLLPA
//SCHRAGER JOB (,),SCHRAGER
/*MESSAGE   MOUNT OUMF01 TAPE
/*JOBPARM  U=10,T=5,L=20,I,WTP,Q=F
//JOBLIB DD DSN=UCC6007.NEWPACK.LOAD,DISP=SHR
//PSWS EXEC PGM=OMFPST4,
// PARM='LPA(MAP),START(77194),END(77196),HOURS(090000,150000)'
//SYSPRINT DD SYSOUT=A
//IN DD DSN=SYS1.OURMF.TAPE,DISP=OLD
//OUT DD DSN=&&PSWS,DISP=(,PASS),UNIT=SCRATCH,SPACE=(CYL,(1,1))
//DIRECT DD DSN=UCC6007.NEWPACK.LPAMAP.T77195.DATA,DISP=SHR
//COUNTS EXEC PGM=GENCNTS
//SYSPRINT DD SYSOUT=A
//TAPE DD DSN=&&PSWS,DISP=(OLD,DELETE)
//DIRECT DD DSN=UCC6007.NEWPACK.LPAMAP.T77195.DATA,DISP=SHR
//COUNTS DD DSN=&&COUNTS,DISP=(,PASS),UNIT=SCRATCH,
// SPACE=(CYL,(1,1))
//LPAMAP EXEC PGM=LPAMAP
//LPALIB DD DSN=SYS1.LPALIB,DISP=SHR
//DIRECT DD DSN=&&DIRECT,DISP=(,PASS),UNIT=SCRATCH,
// SPACE=(CYL,(1,1))
//ANALYSIS EXEC PGM=ANALYSIS,COND=(0,NE),PARM='/PACK'
//SYSPRINT DD SYSOUT=A
//COUNTS DD DSN=&&COUNTS,DISP=(OLD,DELETE)
//DIRECT DD DSN=&&DIRECT,DISP=(OLD,DELETE)
//CARDS DD DSN=UCC6007.NEWPACK.DATA(PACKLIST),DISP=OLD
//SYSIN DD DSN=UCC6007.NEWPACK.ASM(UICDATA),DISP=SHR
./  ADD  NAME=JCLMOD
//PACKIT PROC TYPE=PGM,SELECT=,LIB='SYS1.LINKLIB'
//DIRECT EXEC PGM=DIRECT
//STEPLIB DD DSN=SYS1.UTILLIB,DISP=SHR
//DIRECT DD DSN=&&LPAMAP,DISP=(,PASS),UNIT=SCRATCH,
// SPACE=(CYL,(1,1))
//MODMAP EXEC PGM=MODMAP
//STEPLIB DD DSN=UCC6007.NEWPACK.LOAD,DISP=SHR
//DIRECT DD DSN=&&DIRECT,DISP=(,PASS),UNIT=SCRATCH,
// SPACE=(CYL,(1,1))
//MODULE DD DSN=&LIB(&MODULE),DISP=SHR
//PSWS EXEC PGM=OMFPST4,PARM='/&TYPE(&MODULE)&SELECT'
//STEPLIB DD DSN=UCC6007.NEWPACK.LOAD,DISP=SHR
//SYSPRINT DD SYSOUT=A
//DIRECT DD DSN=&&LPAMAP,DISP=(OLD,DELETE)
//IN DD DSN=SYS1.OURMF.TAPE,DISP=SHR
//OUT DD DSN=&&PSWS,DISP=(,PASS),UNIT=SCRATCH,SPACE=(CYL,(1,1))
//COUNTS EXEC PGM=GENCNTS
//STEPLIB DD DSN=UCC6007.NEWPACK.LOAD,DISP=SHR
//SYSPRINT DD SYSOUT=A
//TAPE DD DSN=&&PSWS,DISP=(OLD,DELETE)
//DIRECT DD DSN=&&DIRECT,DISP=(OLD,PASS)
//COUNTS DD DSN=&&COUNTS,DISP=(,PASS),UNIT=SCRATCH,
// SPACE=(CYL,(1,1))
//ANALYSIS EXEC PGM=ANALYSIS,PARM='/LINK(&MODULE)',COND=(0,NE)
//STEPLIB DD DSN=UCC6007.NEWPACK.LOAD,DISP=SHR
//SYSPRINT DD SYSOUT=A
//COUNTS DD DSN=&&COUNTS,DISP=(OLD,DELETE)
//DIRECT DD DSN=&&DIRECT,DISP=(OLD,DELETE)
//CARDS DD DSN=UCC6007.NEWPACK.DATA(&MODULE),DISP=OLD
./  ADD  NAME=LPAMAP
LPAM     TITLE 'UICC LPA PACKER - PRODUCES DIRECTORY FROM SYS1.LPALIB'
*
* THIS ROUTINE READS THE DIRECTORY OF SYS1.LPALIB AND PRODUCES
* A FILE THAT IS COMPATIBLE WITH THE OUTPUT OF THE DIRECT PGM
* (WHICH READS THE IN-CORE DIRECTORY) FOR INPUT TO THE ANALYSIS
* ROUTINE.  THIS PROGRAM IS USEFUL IF THE CONTENTS OF THE
* LINK PACK AREA HAVE BEEN CHANGED SINCE THE DATA AND THE ORIGINAL
* DIRECT FILE WERE CREATED, WHICH WOULD HAPPEN DURING THE COURSE
* OF NORMAL SYSTEM MAINTENANCE.
*
* BIBLIOGRAPHY: FIGURE 41 - PARTITIONED ORGANIZATION DIRECTORY
* RECORD AS BUILT BY LINKAGE EDITOR IN OS/VS LINKAGE EDITOR
* LOGIC SY26-3815.
*
* INPUT: LPALIB DD CARD POINTING TO SYS1.LPALIB
* OUTPUT: DDNAME=DIRECT
*         DCB=(RECFM=FB,LRECL=16,BLKSIZE=3664)
*   THE RECORD CONTENTS ARE AS FOLLOWS:
*
*   RECORD 1:
*
*      **********************************************
*      * NUMBER OF * LPA LOW  * LPA HIGH * UNUSED   *
*      *  ENTIRES  * ADDRESS  * ADDRESS  *          *
*      **********************************************
*
*   ALL SUBSEQUENT RECORDS (=NUMBER OF ENTRIES)
*
*      **********************************************
*      *  MODULE NAME         * STARTING * MODULE   *
*      *                      * ADDRESS  * LENGTH   *
*      **********************************************
*
* THIS PROGRAM WAS WRITTEN BY:
*
*      BARRY SCHRAGER
*      COMPUTER CENTER
*      UNIVERSITY OF ILLINOIS AT CHICAGO CIRCLE
*      BOX 4348
*      CHICAGO, ILLINOIS 60680
*
*      (312) 996-2478
*
*      VERSION 1 DATED 7/18/77
*
PDSENT   DSECT  PDS DIRECTORY ENTRY AS BUILT BY LINKAGE EDITOR
PDSNAME  DS    CL8  MODULE NAME
PDSTTRM  DS    XL3  TTR OF MODULE
PDSMISC  DS    X  ALIAS INDICATOR AND MISC. FLAGS
PDSALIAS EQU   X'80'  ALIAS FLAG
PDSLMASK EQU   X'1F'  LENGTH MASK FOR ABOVE BYTE
PDSTTRT  DS    XL3  TTR OF FIRST TEXT RECORD
         DS    X  UNUSED
PDSTTRN  DS    XL3  TTR OF NOT LIST OR SCATTER RECORD
PDSCNTN  DS    X  NUMBER OF ENTRIES IN NOTE LIST
PDSATTR  DS    XL2  MODULE ATTRIBUTES
PDSLSIZE DS    XL3  TOTAL CONTIGUOUS VIRTUAL STORAGE REQUIRED
         SPACE 3
DIRENT   DSECT
DIRNAME  DS    CL8  MODULE NAME
DIRSTART DS    A  STARTING ADDRESS
DIRLNGTH DS    A  MODULE LENGTH
DIRSIZE  EQU   *-DIRENT  LENGTH OF DIRECTORY ENTRY
         SPACE 3
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         EJECT
LPAMAP   CSECT
         SAVE (14,12),,* ENTER
         LR    R12,R15  GET ADDRESSABILITY
         USING LPAMAP,R12
         LA    R2,SAVEAREA  POINT TO NEW SAVE AREA
         ST    R2,8(,R13)  FORWARD CHAIN SAVE AREA
         ST    R13,4(,R2)  BACK CHAIN SAVE AREA
         LR    R13,R2  SET UP NEW SAVE AREA
         OPEN (LPALIB,(INPUT))  OPEN LIBRARY DATASET
         LTR   R15,R15  TEST FOR GOOD OPEN
         BZ    *+6  OK, CONTINUE
         DC    H'0'  0C1  ABEND IF NOT
         GETMAIN VU,LA=GMAINR,A=STORAGE,BNDRY=PAGE
         L     R3,STORAGE  GET START OF AREA
         LR    R15,R3  CALCULATE END OF TABLE
         A     R15,STORSIZE
         ST    R15,STOREND  AND SAVE IT FOR LATER
         USING DIRENT,R3  ADDRESS FIRST ENTRY IN TABLE
*
* FILL IN THE TABLE FROM THE DIRECTORY OF SYS1.LPALIB
*
READ     READ  DECB,SF,LPALIB,PDSBLOCK,'S'  READ NEXT DIRECTORY BLOCK
         CHECK DECB
         CLC   PDSBLOCK(2),=H'0'  IS BLOCK EMPTY?
         BE    FINISH  YUP, THEN WE ARE FINISHED
         LA    R4,PDSBLOCK+2  SET INITIAL POINTER INTO BLOCK
PRONEXT  LR    R1,R4  GET CURRENT ADDRESS POINTER
         LA    R2,PDSBLOCK  GET BEGINNING OF BLOCK
         SR    R1,R2  GET DIFFERENCE
         CH    R1,PDSBLOCK  CHECK AGAINST USED AMT
         BNL   READ  IF LOW, THEN GET NEXT PDS DIRECTORY RECORD
         USING PDSENT,R4  ADDRESS PDS ENTRY
         CLC   PDSNAME,=XL8'FFFFFFFFFFFFFFFF'  NULL ENTRY?
         BE    READ  YES, GET NEXT BLOCK
         TM    PDSMISC,PDSALIAS  IS ALIAS FLAG ON?
         BO    GETLEN  YES, SKIP IT
         MVC   DIRNAME,PDSNAME  MOVE NAME FIELD
         L     R0,LPAHIGH  GET CURRENT LPA HIGH ADDRESS
         ST    R0,DIRSTART  SET AS MODULE START
         SR    R15,R15  CLEAR R15
         ICM   R15,7,PDSLSIZE  GET LOAD MOD SIZE
         ST    R15,DIRLNGTH  STORE MODULE LENGTH
         AR    R0,R15  BUMP LPA HIGH ADDRESS
         ST    R0,LPAHIGH  AND STUFF IT BACK
         LA    R3,DIRSIZE(R3)  INCREMENT DIRECTORY POINTER
         C     R3,STOREND  END OF TABLE?
         BNL   ERRSIZE  ERROR IF SO
GETLEN   SR    R1,R1  CLEAR R1
         NI    PDSMISC,PDSLMASK  MASK OFF EXTRANEOUS BITS
         IC    R1,PDSMISC  GET THE LENGTH IN HALFWORDS
         SLA   R1,1  GET THE LENGTH IN BYTES
         LA    R4,12(R1,R4)  GET THE NEXT ADDRESS
         B     PRONEXT  AND LOOK AT NEXT ENTRY
         SPACE 5
FINISH   L     R4,STOREND  GET THE END OF THE GETMAINED STORAGE
         SR    R4,R3  CALCULATE THE UNUSED SPACE
         FREEMAIN RU,LV=(R4),A=(R3)  FREE IT
         ST    R3,STOREND  RESET THE END OF THE STORAGE
         S     R3,STORAGE  CALCULATE THE TABLE SIZE
         ST    R3,STORSIZE  AND SAVE IT
         CLOSE (LPALIB)  CLOSE THE INPUT FILE
         SR    R2,R2  CLEAR R2
         LA    R15,DIRSIZE  GET THE TABLE ENTRY SIZE
         DR    R2,R15  CALCULATE NUMBER OF ENTRIES
         ST    R3,MODCOUNT  STORE INTO HEADER RECORD
*
* OPEN UP THE OUTPUT FILE AND WRITE OUT THE LPALIB DIRECTOR
* THE FIRST RECORD IS THE STATISTICS RECORDS
* THEN WRITE ONE RECORD FOR EACH MEMBER
*
         OPEN  (DIRECT,(OUTPUT))
         LTR   R15,R15  TEST RETURN CODE
         BZ    *+6   OK, CONTINUE
         DC    H'0' 0C1 ABEND IF NOT
         PUT   DIRECT,MODCOUNT  PUT OUT STAT RECORD
         L     R3,STORAGE  SET UP LOOP TO WRITE REST OF RECORDS
         LA    R4,DIRSIZE  ENTRY SIZE
         L     R5,STOREND  SIZE OF TABLE
         SR    R5,R4  ADDRESS OF LAST ENTRY
WLOOP    PUT   DIRECT,(R3)  WRITE RECORD
         BXLE  R3,R4,WLOOP  AND LOOP
         CLOSE (DIRECT)  CLOSE FILE
         L     R3,STORSIZE  GET STORAGE SIZE
         FREEMAIN RU,LV=(R3),A=STORAGE
         L     R13,4(,R13)  DECHAIN SAVE AREAS
         RETURN (14,12),RC=0
         SPACE 3
ERRSIZE  WTO   'REGION TOO SMALL - DIRECTORY BUILD FAILURE',           X
               ROUTCDE=11
         L     R13,4(,R13)
         RETURN (14,12),RC=12
         SPACE 3
SAVEAREA DS    9D  SAVE AREA
GMAINR   DC    A(4096,409600)  STORAGE GETMAIN AREA
STORAGE  DC    A(0)  STORAGE AREA START
STORSIZE DC    A(0)  STORAGE AREA SIZE
STOREND  DC    A(0)  FIRST BYTE NOT IN STORAGE AREA
MODCOUNT DC    A(0)  STAT RECORD
LPALOW   DC    A(0)  LPA LOW ADDRESS
LPAHIGH  DC    A(0)  LPA HIGH ADDRESS
         DC    A(0)  UNUSED IN STAT RECORD
PDSBLOCK DS    CL256  WORK AREA FOR READING IN DIRECTORY RECORD
DIRECT   DCB   DDNAME=DIRECT,BLKSIZE=3664,LRECL=DIRSIZE,DEVD=DA,       X
               DSORG=PS,MACRF=PM,RECFM=FB
LPALIB   DCB   DDNAME=LPALIB,BLKSIZE=256,LRECL=256,DEVD=DA,            X
               DSORG=PS,EODAD=FINISH,MACRF=RC,RECFM=F
         END   LPAMAP
./  ADD  NAME=MODMAP
MODB     TITLE 'UICC MODULE PACKER - LOAD MODULE DIRECTORY READ'
*
*   THIS PROGRAM BUILDS A FILE FROM THE CONTENTS OF THE LOAD MODULE
*   DIRECTORY.  THIS FILE IS USED BY THE PACK LIST GENERATING PROGRAM.
*
* INPUT: THE MODULE SHOULD BE ALLOCATED AS A PDS MEMBER TO THE
* DDNAME 'MODULE', IE
*   //MODULE DD DSN=SYS1.LINKLIB(PROGRAM),DISP=SHR
*
* RESTRICTIONS: PROPERLY THE MODULE SHOULD NOT BE SCATTER LOADED OR
* OVERLAYED. THIS PROGRAM DOES NOT CHECK FOR SUCH THINGS, BUT THE
* RESULTING ANALYSIS OF THE DATA WOULD PROVE CONFUSING. ONLY
* CSECTS ARE MAPPED, SO COMMON BLOCKS, PRIVATE CODE, AND ALTERNATE
* ENTRY POINTS WILL NOT SHOW UP (IE, THEY WILL LEAVE GAPS IN THE
* MAP OF SEEMINGLY UNALLOCATED STORAGE).
*
* BIBLIOGRAPY: FIGURE 39, 'CESD RECORD (LOAD MODULE)' IN SY26-3814
* OS/VS LOADER LOGIC.
*
*   THE FORMAT OF THE OUTPUT FILE IS AS FOLLOWS:
*
*   RECFM=FB,LRECL=16,BLKSIZE=3664
*
*   THE RECORD CONTENTS ARE AS FOLLOWS:
*
*   RECORD 1:
*
*      **********************************************
*      * NUMBER OF * MOD LOW  * MOD HIGH * UNUSED   *
*      *  ENTIRES  * ADDRESS  * ADDRESS  *          *
*      **********************************************
*
*   ALL SUBSEQUENT RECORDS (=NUMBER OF ENTRIES)
*
*      **********************************************
*      *   CSECT NAME         * STARTING * CSECT    *
*      *                      * ADDRESS  * LENGTH   *
*      **********************************************
*
*   THIS PROGRAM WAS WRITTEN BY:
*
*                 BARRY SCHRAGER
*                 COMPUTER CENTER
*                 UNIVERSITY OF ILLINOIS AT CHICAGO CIRCLE
*                 BOX 4348
*                 CHICAGO, ILLINOIS 60680
*
*                 (312) 996-2478
*
*    WITH A LOT OF HELP FROM HOWARD GILBERT OF THE YALE
*    COMPUTATION CENTER, NEW HAVEN, CT.
*
*                 VERSION 1 DATED 7/18/77
*
MODBUILD CSECT
ESDREC   DSECT
ID       DS    X
         DS    5X
COUNT    DS    H
CESD1    DS    0H
         SPACE 1
CESD     DSECT
CESDNAME DS    CL8
CESDTYPE DS    X
CESDADDR DS    XL3
         DS    X
CESDLEN  DS    XL3
DIRENT   DSECT   DIRECTORY ENTRY
DIRNAME  DS    CL8  CSECT NAME
DIRSTART DS    A   STARTING ADDRESS
DIRLNGTH DS    A   CSECT LENGTH
DIRSIZE  EQU   *-DIRENT   LENGTH OF DIRECTORY ENTRY
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         EJECT
MODBUILD CSECT
         SAVE  (14,12),,*  ENTER
         LR    R12,R15  SET UP ADDRESSING
         USING MODBUILD,R12
         LA    R2,SAVEAREA   CHAIN SAVE AREAS
         ST    R2,8(,R13)
         ST    R13,4(,R2)
         LR    R13,R2
         OPEN  (MODULE,(INPUT))
         LTR   R15,R15  TEST FOR GOOD OPEN
         BZ    *+6  OK, CONTINUE
         DC    H'0'  ABEND IF NOT
         GETMAIN VU,LA=GMAINR,A=STORAGE,BNDRY=PAGE
         L     R3,STORAGE  POINT TO TABLE START
         LR    R15,R3  CALCULATE END OF TABLE
         A     R15,STORSIZE
         ST    R15,STOREND  AND SAVE FOR LATER
         USING DIRENT,R3  ADDRESS IT
*
*  FILL THE DIRECTORY TABLE FROM THE LOAD MODULE DIRECTORY
*
RLOOP    GET   MODULE                   GET THE NEXT RECORD
         SR    R15,R15                  ZERO R15
         USING ESDREC,R1                ADDRESS ESDREC
         CLI   ID,X'20' CHECK FOR ESD ID.
         BNE   EFLOOP                   NOPE, DONE WITH ESDS
         LA    R4,16                    LOOP THRU ESD ENTRIES
         LH    R5,COUNT                 GET COUNT
         SR    R5,R4
         LA    R5,CESD1(R5)             INCREMENT
         LA    R6,CESD1
         USING CESD,R6                  ADDRESS CESD ENTRY
FLOOP    TM    CESDTYPE,X'07'           CHECK FOR PROPER TYPE
         BNZ   NXTCESD                  NOPE
         MVC   DIRNAME,CESDNAME         MOVE NAME TO STORAGE AREA
         ICM   R15,7,CESDADDR           AND BEGINNING ADDRESS
         ST    R15,DIRSTART             TO STORAGE AREA
         ICM   R15,7,CESDLEN            AND LENGTH
         ST    R15,DIRLNGTH             TO STORAGE AREA
         LA    R3,DIRSIZE(R3)           AND INCREMENT TO NEXT
         C     R3,STOREND               OUT OF STORAGE?
         BNL   ERRSIZE                  YUP, TOO BAD TRY BIGGER REGION
NXTCESD  BXLE  R6,R4,FLOOP              LOOP TO NEXT ENTRY
         B     RLOOP                    GET NEXT CARD
         SPACE 2
EFLOOP   L     R4,STOREND   GET THE END OF THE STORAGE
         SR    R4,R3  CALCULATE UNUSED SPACE
         FREEMAIN RU,LV=(R4),A=(R3)  FREE IT
         ST    R3,STOREND  RESET END OF STORAGE
         S     R3,STORAGE  CALCULATE TABLE LENGTH
         C     R3,=A(DIRSIZE)  CHECK FOR ZERO OR 1 ENTRY
         BNH   ERRZERO  ERROR IF SO
         ST    R3,STORSIZE  AND SAVE STORAGE SIZE
         LNR   R2,R0  GET NEG ENTRY SIZE IN R2
         L     R3,STORAGE  GET DIRECTORY STARTG
         SR    R3,R0  GET -1ST ENTRY
OLOOP    L     R5,STORAGE   SET UP INNER LOOP
         LA    R6,DIRSIZE   GET ENTRY SIZE
         LR    R7,R1  SET UP INNER LOOP LIMIT
ILOOP    LA    R8,DIRSIZE(,R5)  GET N+1ST ELEMENT
         L     R0,DIRSTART-DIRENT(R5)  GET NTH ENTRY PT
         C     R0,DIRSTART-DIRENT(R8)  COMPARE TO N+1ST ENTRY PT
         BL    EILOOP  IF LOW, CONTINUE
         MVC   WORK,0(R5)  SWAP THE ENTRIES
         MVC   0(L'WORK,R5),0(R8)
         MVC   0(L'WORK,R8),WORK
EILOOP   BXLE  R5,R6,ILOOP   END INNER LOOP
         BXH   R1,R2,OLOOP  END OUTER LOOP
*
* CALCULATE NUMBER OF ENTRIES, START AND END OF MODULE
*
         XC    WORK,WORK  USE THE WORK AREA FOR STORAGE
         L     R1,STORSIZE  GET THE TABLE LENGTH
         SR    R0,R0  CLEAR R0 FOR DIVIDE
         LA    R15,DIRSIZE  GET THE ENTRY SIZE
         DR    R0,R15   GET THE NUMBER OF ENTRIES
         ST    R1,WORK  PUT INTO WORK STRING
         L     R1,STORAGE  GET THE FIRST ENTRY ADDRESS
         L     R0,DIRSTART-DIRENT(R1)  GET THE FIRST CSECT START
         ST    R0,WORK+4   PUT INTO WORK AREA
         L     R1,STOREND  GET THE ADDR OF THE N+1 ST ENTRY
         SR    R1,R15   GET THE NTH ENTRY ADDR
         L     R0,DIRSTART-DIRENT(R1)  GET THE CSECT START
         A     R0,DIRLNGTH-DIRENT(R1)  ADD IN THE CSECT LENGTH
         ST    R0,WORK+8  AND PUT INTO WORK AREA
*
*  OPEN UP THE OUTPUT FILE AND WRITE OUT THE DIRECTORY
*  THE FIRST RECORD IS THE NUMBER OF ENTRIES, THE
*  MODULE START AND END.  THE REST ARE THE DIRECTORY
*  ENTRIES SORTED BY CSECT START.
*
         OPEN  (DIRECT,(OUTPUT))
         LTR   R15,R15  TEST FOR GOOD OPEN
         BZ    *+6  OK, CONTINUE
         DC    H'0'  ABEND OF NON-ZERO
         PUT   DIRECT,WORK  WRITE OUT STATS
         L     R3,STORAGE  SET UP FOR LOOP TO WRITE DIRECTORY
         LA    R4,DIRSIZE  ENTRY SIZE
         L     R5,STOREND
         SR    R5,R4  LAST ENTRY ADDRESS
WLOOP    PUT   DIRECT,(R3)  WRITE OUT DIRECTORY ENTRY
         BXLE  R3,R4,WLOOP   LOOP
         CLOSE (DIRECT)
         L     R3,STORSIZE  GET STORAGE SIZE
         FREEMAIN RU,LV=(R3),A=STORAGE
         L     R13,4(,R13)  GET OLD SAVE AREA
         RETURN (14,12),RC=0
ERRSIZE  WTO   'REGION TOO SMALL - DIRECTORY BUILD FAILURE',ROUTCDE=11
         L     R13,4(,R13)  GET OLD SAVE AREA
         RETURN (14,12),RC=12  RETURN
         SPACE 3
ERRZERO  WTO   'ONLY 1 CSECT IN LOAD MODULE - PACKING IMPOSSIBLE',     X
               ROUTCDE=11
         L     R13,4(,R13)  DECHAIN SAVE AREA
         RETURN (14,12),RC=12
         SPACE 10
SAVEAREA DS    9D
WORK     DS    CL(DIRSIZE)  WORK AREA
GMAINR   DC    A(4096,409600)  STORAGE GETMAIN RANGE
STORAGE  DC    A(0)  STORAGE AREA START
STORSIZE DC    A(0)  SIZE OF STORAGE AREA
STOREND  DC    A(0)  FIRST BYTE NOT IN STORAGE AREA
DIRECT   DCB   DDNAME=DIRECT,BLKSIZE=3664,LRECL=DIRSIZE,DEVD=DA,       X
               DSORG=PS,MACRF=PM,RECFM=FB
MODULE   DCB   DDNAME=MODULE,DEVD=DA,DSORG=PS,MACRF=GL
         END MODBUILD
./  ADD  NAME=OMFPST4
* PROCESS MACRO,MAR(2,72),OPT(TIME);
 /* OMFPST4: SUPPORT FOR UICC PACKER PROGRAM      */
 OMFPST4: PROC(PARM) OPTIONS(MAIN REENTRANT);
 /********************************************************************/
 /* PROCEDURE: OMFPST4                                               */
 /* FUNCTION:                                                        */
 /*            POST PROCESSOR FOR OMF1 RECORD (30 SECOND SUMMARY)    */
 /*             SUPPORT 'PROGLOOK' OR 'PACKER' TYPE FUNCTION BY      */
 /*             SELECTING THE PSW'S BY MODULE NAME AND WRITING       */
 /*             THE RELATIVE INSTRUCTION ADDRESS TO THE OUTPUT       */
 /*             DATASET.                                             */
 /* ATTRIBUTES: NONE                                                 */
 /* EXTERNAL: NONE                                                   */
 /* INPUT:                                                           */
 /*     FILE SYSIN CONTAINS PARAMETERS IN OURMF FORMAT               */
 /*      PARM FIELD MAY BE USED AS FIRST INPUT STRING                */
 /*           START( YYDDD HHMMSS )  /* STARTING DATE AND TIME       */
 /*           END  ( YYCCC HHMMSS )  /* ENDING DATE AND TIME         */
 /*           HOURS( HHMMSS HHMMSS)  /* APPLICABLE HOURS DURING      */
 /*                                  /* THIS TIME PERIOD             */
 /*           PGM( PGMNAME)        /* CDENAME SELECTED               */
 /*              OR                                                  */
 /*           MOD(MODNAME)          LPALIB MODULE SELECTED           */
 /*              OR                                                  */
 /*             LPA(MAP)                 FOR LPA REPACKING           */
 /*    ABOVE DIDDLE (MAP IS A PHONEY OPERAND) IS REQUIRED BECAUSE    */
 /*    THE ORIGINAL AUTHOR OF THE CODE DID NOT ALLOW STAND ALONE     */
 /*    OPERANDS....                                                  */
 /* DEFAULTS:  INCLUDE ALL RECORDS IN SCAN.                          */
 /*            PGM OR MOD OR LPA MUST BE SPECIFIED                   */
 /*                                                                  */
 /* THE OURMF OUTPUT DATA IS READ FROM DDNAME 'IN'                   */
 /* IF MOD IS SPECIFIED, THE LPA DIRECTORY IS READ FROM FILE 'DIRECT'*/
 /* IF LPA IS SPECIFIED, THE LPA STATS ARE READ IN FROM FILE 'DIRECT'*/
 /*                                                                  */
 /* AUTHOR:  HOWARD GILBERT                                          */
 /*          175 WHITNEY AVE                                         */
 /*          NEW HAVEN, CT 06520                                     */
 /*          203 432-4080                                            */
 /*MODIFIED: BARRY SCHRAGER                                          */
 /*          COMPUTER CENTER                                         */
 /*          UNIVERSITY OF ILLINOIS AT CHICAGO CIRCLE                */
 /*          BOX 4348                                                */
 /*          CHICAGO, ILLINOIS 60680                                 */
 /*          312 996-2478                                            */
 /* DISTIRBUTION                                                     */
 /*     THIS PROGRAM IS NOT RESTRICTED IN ANY WAY AND MAY BE         */
 /* MODIFIED OR DISTRIBUTED IN ANY MANNER AND FOR ANY PURPOSE.       */
 /* IT IS SUGGESTED THAT OTHER OURMF POST PROCESSORS CONSIDER        */
 /* COMPATIBLE SYNTAX AND PARAMETER SCANNING.                        */
 /********************************************************************/
 DCL 1 OPTIONS,
         5 STARTDATE FIXED DEC(7) INIT(0),
         5 STARTHOUR FIXED DEC(7) INIT(0),
         5 ENDDATE FIXED DEC(7) INIT(99365),
         5 ENDHOUR FIXED DEC(7) INIT(240000),
         5 EARLIEST FIXED DEC(7) INIT(0),
         5 LATEST FIXED DEC(7) INIT(240000),
         5 PGM CHAR(8) INIT((LOW(8))),
         5 LOWRANGE BIT(32) ALIGNED,
         5 HIGHRANGE BIT(32) ALIGNED,
         5 SCTYPE FIXED BIN(31) INIT(0),
         5 MODSTART FIXED BIN(31);
 %PAGE;
 % INCLUDE STATGLBL;
 %INCLUDE YCCSTART;
 % INCLUDE OURMFDEF;
 DCL MAXVALS(6) FIXED BIN INIT(2,2,2,1,1,1);
 DCL WORDS(6) CHAR(8) INIT('START','END','HOURS','PGM','MOD','LPA');
 DCL INSADDR BIT(32) ALIGNED;
 DCL MASK BIT(32) ALIGNED INIT(((8)'0'B××(24)'1'B));
 DCL IN INPUT FILE RECORD ENV(VB TOTAL);
 DCL OUT OUTPUT FILE RECORD ENV(FB RECSIZE(4) BLKSIZE(4240));
 DCL DIRECT FILE RECORD SEQUENTIAL INPUT,
     1 DIRIN BASED(DIRPTR),
       2 NAME CHAR(8),
       2 (START,SIZE) FIXED BIN(31),
     1 DIRSTAT,
       2 (MODCOUNT,LPALOW,LPAHIGH,FILL) FIXED BIN(31);
 DCL PARM CHAR(100) VAR;
 DCL T FIXED BIN(31);
 %PAGE;
 ON UNDEFINEDFILE(SYSIN)GO TO PROCESS;
 ON ENDFILE(SYSIN) GO TO PROCESS;
 ON CONVERSION CALL ERR('INVALID NUMBER IN '××WORDS(I));
 IF LENGTH(PARM)>0 THEN DO;
   CARD=PARM;
   SUBSTR(CARD,73,8)='PARMFLD';
   PUT EDIT(CARD)(A) SKIP;
   SUBSTR(CARD,73,8)=' ';
   END;
 KEYWDLOOP: CALL KEYWORD;
 I=INDOX('START END HOURS PGM MOD LPA',KEY);
 IF NVALS>MAXVALS(I) THEN CALL ERR('TOO MANY VALUES FOR '××WORDS(I));
 SELECT (I);
    WHEN (1)
         DO;
         STARTDATE=VAL(1);
         IF NVALS=2 THEN STARTHOUR=VAL(2);
         END;
    WHEN (2)
         DO;
         ENDDATE=VAL(1);
         IF NVALS=2 THEN ENDHOUR=VAL(2);
         END;
    WHEN (3)
         DO;
         EARLIEST=VAL(1);
         IF NVALS=2 THEN LATEST=VAL(2);
         END;
    WHEN (4)
         DO;
         IF LENGTH(VAL(1))>8 THEN
              CALL ERR('INVALID PGM NAME');
         PGM=VAL(1);
         SCTYPE=1;
         END;
         WHEN (5)
              DO;
              IF LENGTH(VAL(1))>8 THEN
                 CALL ERR('INVALID MODULE NAME');
              ON UNDEFINEDFILE(DIRECT)
                 CALL ERR('DIRECT FILE REQUIRED FOR MOD KEYWORD');
              ON ENDFILE(DIRECT)
                 CALL ERR('MODULE NOT FOUND IN LPA DIRECTORY');
              PGM=VAL(1);
              READ FILE(DIRECT) SET(DIRPTR);
              DO WHILE(PGM^=DIRIN.NAME);
                 READ FILE(DIRECT) SET(DIRPTR);
              END;
              SCTYPE=2;
              LOWRANGE=UNSPEC(DIRIN.START);
              HIGHRANGE=UNSPEC(DIRIN.START+DIRIN.SIZE);
              MODSTART=DIRIN.START;
              CLOSE FILE(DIRECT);
              END;
       WHEN (6)
            DO;
            SCTYPE=2;
            ON UNDEFINEDFILE(DIRECT)
               CALL ERR('DIRECT FILE RQUIRED FOR LPA KEYWORD');
            READ FILE(DIRECT) INTO(DIRSTAT);
            LOWRANGE=UNSPEC(LPALOW);
            HIGHRANGE=UNSPEC(LPAHIGH);
            MODSTART=0;
            CLOSE FILE(DIRECT);
            END;
    END;
 GO TO KEYWDLOOP;
 %PAGE;
 PROCESS:
 CLOSE FILE(SYSIN);
 IF SCTYPE=0 THEN
     CALL ERR('NO PGM NAME MOD NAME OR LPA KEYWORD PROVIDED IN INPUT');
 ON ENDFILE(IN) GO TO FINN;
 PRLOOP:
 READ FILE(IN) SET(OMFRECPTR);
 IF OMF1ID^='OMF1' THEN GO TO PRLOOP;
 IF OMF1DATE<STARTDATE ×
    (OMF1DATE=STARTDATE & OMF1TIME < STARTHOUR) ×
    OMF1DATE>ENDDATE ×
    (OMF1DATE=ENDDATE & OMF1TIME < ENDHOUR) ×
    OMF1TIME<EARLIEST ×
    OMF1TIME>LATEST
         THEN GO TO PRLOOP;
    DO I=1 TO SRBINTVL;
    SELECT (SCTYPE);
    WHEN (1) DO;
    IF CDENAME(I)=PGM & ADDRESS(I)<0 THEN
        DO;
        INSADDR=UNSPEC(ADDRESS(I))&MASK;
        WRITE FILE(OUT) FROM(INSADDR);
        END;
    END;
    WHEN (2) DO;
    IF ADDRESS(I)>0 THEN DO;
       INSADDR=UNSPEC(ADDRESS(I))&MASK;
       IF INSADDR>LOWRANGE & INSADDR<HIGHRANGE THEN DO;
          IF MODSTART>0 THEN DO;
             UNSPEC(T)=INSADDR;
             T=T-MODSTART;
             INSADDR=UNSPEC(T);
             END;
          WRITE FILE(OUT) FROM(INSADDR);
       END;
    END;
    END;
    END;
    END;
 GO TO PRLOOP;
 FINN: RETURN;
 %INCLUDE CNTLCRD;
 END;
./  ADD  NAME=PSWSAMP
PSWS     TITLE 'UICC LPA PACKER - PSW SAMPLER'
*   THE ORIGINAL IDEA OF THIS PROGRAM CAME FROM THE
*   GERRARD BANK PACKER PROGRAM.
*
*   THE FUNCTIONS PERFORMED BY THIS PSW SAMPLING PROGRAM
*   ARE AS FOLLOWS:
*      1. INITIALIZATION - OPEN FILE, OBTAIN THE CSA LOWER
*         BOUND ADDRESS.
*      2. SAMPLE THE EXTERNAL OLD PSW EVERY .2 SECONDS,
*         IF IT IS GREATER THAN THE CSA LOWER BOUND ADDR,
*         THEN PLACE THE LAST 4 BYTES INTO THE BUFFER,
*         CLEAN THE HIGH ORDER BYTE OF THE ADDRESS.
*      3. WHEN THE BUFFER IS FILLED, WRITE IT OUT AND DO
*         A TCLOSE ON THE DATASET. ZERO THE BUFFER AND START
*         TO REFILL IT.
*      4. JOB WILL TERMINATE WHEN ITS STOP ECB IS POSTED WITH
*         NO LOSS OF DATA, JOB MAY BE CANCELLED AT ANY TIME BUT
*         THE CONTENTS OF THE FINAL BUFFER WILL BE LOST.
*
*    JOB SHOULD BE RUN AT DISPATCHING PRIO (15,15) FOR A LONG TIME,
*    PREFERABLY AT LEAST SEVERAL DAYS.  BE SURE THAT NO CLPA'S ARE
*    DONE WHILE THE SAMPLING OR DATA ANALYSIS IS TAKING PLACE.
*
*    JCL SHOULD SPECIFY MOD FOR THE FILE FOR RUNS AFTER THE FIRST.
*
*    THIS PROGRAM WAS WRITTEN BY:
*
*               BARRY SCHRAGER
*               COMPUTER CENTER
*               UNIVERSITY OF ILLINOIS AT CHICAGO CIRCLE
*               BOX 4348
*               CHICAGO, ILLINOIS 60680
*
*               (312) 996-2478
*
*               VERSION 1 DATED 7/22/76
*
*
*  THIS PROGRAM REQUIRES SYS1.AMODGEN TO ASSEMBLE CORRECTLY
*
PSWSAMP  CSECT   (BASED ON GERRARD BANKS PACKER PGM)
         IHAPSA
         IHAPVT
         CVT   DSECT=YES
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         EJECT
PSWSAMP  CSECT
         SAVE (14,12),,*   ENTER PGM
         LR    R12,R15   AND SET UP ADDRESSABILITY
         USING PSWSAMP,R12
         LA    R2,SAVEAREA   AND CHAIN SAVE AREAS
         ST    R2,8(,R13)
         ST    R13,4(,R2)
         LR    R13,R2
         OPEN (TAPE,(OUTPUT))  OPEN OUTPUT FILE
         LTR   R15,R15  TEST FOR GOOD OPEN
         BZ    *+6   IF OPEN WAS GOOD, SKIP ABEND
         DC    H'0'  ABEND IF BAD OPEN
         EXTRACT COMMADDR,'S',FIELDS=(COMM)  GET COMM ADDR
         L     R2,COMMADDR  GET ADDR OF CIB AND ECB
         L     R3,4(,R2)   GET START CIB ADDR
         LTR   R3,R3  ZERO MEANS NOT STARTED FROM CONS
         BNZ   *+6   IF STARTED FROM CONSOLE, SKIP ABEND
         DC    H'0'  ABEND IF NOT STARTED FROM CONSOLE
         QEDIT ORIGIN=4(R2),BLOCK=(R3)  UNCHAIN START CIB
         QEDIT ORIGIN=4(R2),CIBCTR=0  ALLOW ONLY STOP COMMANDS
         L     R11,0(,R2)   GET ECB ADDR INTO R11 FOR LATER USE
         L     R1,CVTPTR  GET THE CVT POINTER
         L     R1,CVTPVTP-CVT(R1)  GET PVT POINTER
         LH    R8,PVTLCSA-PVT(R1)  GET LOW CSA BOUND
         SLL   R8,8  MAKE INTO BYTE ADDR
         LA    R8,0(,R8)   DROP HIGH ORDER BYTE
         WTO   'PSW COLLECTOR IN PROGRESS - USE P TO STOP'
INITBUFR LA    R2,BUFFER    POINT TO BUFFER
         LA    R3,LBUFFER   GET BUFFER LENGTH
         SR    R0,R0   CLEAR R0
         LR    R1,R0   AND R1
         MVCL  R2,R0     ZERO BUFFER
         LA    R10,BUFFER  SET UP REGS FOR DATA COLLECTION
         LA    R9,LBUFFER/4   GET COUNT OF ENTRIES/BUFFER
         SR    R7,R7   CLEAR R7 FOR PSW COLLECTION
LOOP     TM    0(R11),X'40'   TEST IF STOP ECB IS POSTED
         BO    STOP    YES, STOP NOW
         STIMER WAIT,BINTVL=LOOPTIME  WAIT A WHILE
         ICM   R7,7,FLCEOPSW-PSA+5   GET EXTERNAL OLD PSW ADDR
         CR    R7,R8   TEST AGAINST LOWER CSA BOUND
         BL    LOOP   LOOP IF NOT IN LPA
         STCM  R7,7,1(R10)   STORE ADDR INTO BUFFER
         LA    R10,4(,R10)  INCREMENT BUFFER POINTER
         BCT   R9,LOOP   AND CONTINUE
STOP     WRITE DECB,SF,TAPE,BUFFER,'S'  WRITE BUFFER
         CHECK DECB
         CLOSE (TAPE),TYPE=T
         TM    0(R11),X'40'   ENTERED BECAUSE OF STOP?
         BZ    INITBUFR  NO, RE-INITIALIZE THE BUFFER
         CLOSE (TAPE)   CLOSE THE FILE
         WTO   'PSW COLLECTOR TERMINATING'
         L     R13,4(,R13)  UNCHAIN SAVE AREA
         RETURN (14,12),RC=0   AND RETURN
TAPE     DCB   DDNAME=TAPE,BUFNO=0,NCP=1,DEVD=DA,DSORG=PS,             X
               LRECL=4,BLKSIZE=LBUFFER,MACRF=WC,RECFM=FB
LOOPTIME DC    F'20'   COLLECT EVERY .2 SECONDS
COMMADDR DS    A   WORK AREA FOR EXTRACT
SAVEAREA DS    9D    SAVE AREA
BUFFER   DS    916A   3664 BYTE BUFFER
LBUFFER  EQU   *-BUFFER  BUFFER LENGTH EQUATE
         END   PSWSAMP
./  ADD  NAME=UICDATA
ZERO HASPSSSM,JEZ2SSSM
ZERO DNKCPS,DNKTMESS
EQUATE IGC0021D,RAPEFDR,IGC0020D
EQUATE IEFW21SD,DEVMASKT,DEVNAMET
EQUATE SHOW,IGC0021E
EQUATE IGG0199F,IGG0199G,IGG0199W,IGG0198L
EQUATE IGC0008C,IEFU83
EQUATE IEEPRTN,IEEPRWI2,IEESB605
EQUATE IEFIRECM,IEFJDSNA,IEFJJTRM,IEFJRASP,IEFJRECM,IEFJSDTN,IEFJSREQ
