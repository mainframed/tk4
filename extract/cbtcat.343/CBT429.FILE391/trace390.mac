Trace390 TITLE 'Enterprise System Architecture/390 Instruction Trace'
&ABEND   SETC  '3579'               ABEND code issued by TRACE390
Bit0     EQU   X'80000000'          High order bit of fullword
ARmode   EQU   X'00000010'          Access-register mode
         SPACE
*---------------------------------------------------------------------*
*        General Purpose Registers                                    *
*---------------------------------------------------------------------*
         SPACE
R00      EQU   0                    Scratch register
R01      EQU   1                    Scratch register
R02      EQU   2                    Scratch register
R03      EQU   3                    Scratch register
R04      EQU   4                    Scratch register
R05      EQU   5                    Instruction attribute flags pointer
*                                   ... within routine 'ExecInst' only
R06      EQU   6                    Used by profiler/count print rtnes
R07      EQU   7                    1st program base
R08      EQU   8                    2nd program base
R09      EQU   9                    3rd program base
R10      EQU   10                   Base for data area
R11      EQU   11                   Traced program instruction pointer
R12      EQU   12                   First level subroutine linkage
R13      EQU   13                   Address of our register save area
R14      EQU   14                   Second level subroutine linkage
R15      EQU   15                   Scratch, base during initialisation
         SPACE
R0t      EQU   12                   Dummy GPR specifier used as base   -
                                    by instructions which will be      -
                                    updated (zapped) with a dynamically-
                                    determined register at run-time.   -
                                    Value is arbitrary, but non-zero
AR0t     EQU   R0t                  Matching dummy AR for R0t
         SPACE
*---------------------------------------------------------------------*
*        Access register equates                                      *
*---------------------------------------------------------------------*
         SPACE
AR00     EQU   0
AR01     EQU   1
AR02     EQU   2
AR03     EQU   3
AR04     EQU   4
AR05     EQU   5
AR06     EQU   6
AR07     EQU   7
AR08     EQU   8
AR09     EQU   9
AR10     EQU   10
AR11     EQU   11
AR12     EQU   12
AR13     EQU   13
AR14     EQU   14
AR15     EQU   15
         SPACE
*---------------------------------------------------------------------*
*        Instruction codes explicitly tested for, or for those        *
*        instructions prefixed by X'B2', the second byte only         *
*---------------------------------------------------------------------*
         SPACE
$01      EQU   X'01'                x'01' prefixed instructions
$A7      EQU   X'A7'                x'A7' prefixed instructions
$B2      EQU   X'B2'                x'B2' prefixed instructions
         SPACE
$BAKR    EQU   X'B240'-X'B200'      Branch and Stack
$BC      EQU   X'47'                Branch on Condition
$BCR     EQU   X'07'                Branch on Condition Register
$BSM     EQU   X'0B'                Branch and Set Mode
$CDS     EQU   X'BB'                Compare Double and Swap
$CLCL    EQU   X'0F'                Compare Logical Long
$CLCLE   EQU   X'A9'                Compare Logical Long Extended
$EAR     EQU   X'B24F'-X'B200'      Extract Access Register
$EREG    EQU   X'B249'-X'B200'      Extract Stacked Registers
$ESTA    EQU   X'B24A'-X'B200'      Extract Stacked State
$IPM     EQU   X'B222'-X'B200'      Insert Program Mask
$IVSK    EQU   X'B223'-X'B200'      Insert Virtual Storage Key
$LAM     EQU   X'9A'                Load Access Multiply
$LM      EQU   X'98'                Load Multiply
$MVCL    EQU   X'0E'                Move Characters Long
$MVCLE   EQU   X'A8'                Move Characters Long Extended
$MVCS    EQU   X'DB'                Move to Secondary
$PR      EQU   X'0101'-X'0100'      Program Return
$PT      EQU   X'B228'-X'B200'      Program Transfer
$SAR     EQU   X'B24E'-X'B200'      Store Access
$SRP     EQU   X'F0'                Shift and Round Packed
$STAM    EQU   X'9B'                Store Access Multiple
$STCM    EQU   X'BE'                Store Characters under Mask
$STM     EQU   X'90'                Store Multiple
$SVC     EQU   X'0A'                Supervisor Call
$TAR     EQU   X'B24C'-X'B200'      Test Access
$TRAP2   EQU   X'01FF'-X'0100'      Trap (2-byte version)
         EJECT
***********************************************************************
*                                                                     *
*        Machine instruction attribute flags                          *
*                                                                     *
***********************************************************************
         SPACE
*---------------------------------------------------------------------*
*        Flags in first attribute flag byte                           *
*---------------------------------------------------------------------*
          SPACE
bitILGL   EQU   X'80'               Illegal or unsupported instruction
bitCC     EQU   X'40'               Instruction sets condition code
bitBR     EQU   X'20'               Instruction is a (executed?) branch
bitAMODE  EQU   X'10'               Instruction alters addressing mode
bitACCESS EQU   X'08'               Access register(s) used/modified
bitPACKD  EQU   X'04'               Packed decimal instruction
bitMVCX   EQU   X'02'               MVCK, MVCP or MVCS instruction
bitALTER  EQU   X'01'               Instruction alters storage
          SPACE
*---------------------------------------------------------------------*
*        Flags in second attribute flag byte                          *
*---------------------------------------------------------------------*
         SPACE
bitRR     EQU   X'80'               RR format instruction
bitRX     EQU   X'40'               RX format instruction
bitRS     EQU   X'20'               RS format instruction
bitSSI    EQU   X'10'               S/SI format instruction
bitSS     EQU   X'08'               SS/SSE format instruction
bitRXEF   EQU   X'04'               RXE/RXF format instruction
bitIMDF   EQU   X'02'               Contains 8-bit immediate field
bitIMREL  EQU   X'01'               Immediate and Relative instruction
          SPACE
bitSI     EQU   bitSSI+bitIMDF      SI format instruction
bitRRE    EQU   bitRS+bitSSI        RRE format instruction
bitRSI    EQU   bitRS+bitIMREL      RSI/RI format instruction
          SPACE
*---------------------------------------------------------------------*
*        Flags in third attribute flag byte                           *
*---------------------------------------------------------------------*
          SPACE
bitDBLR   EQU   X'80'               Double word register operand(s)
bitDBLS   EQU   X'40'               Double word storage operand
bitFULL   EQU   X'20'               Full word storage operand
bitHALF   EQU   X'10'               Half word storage operand
bitBYTE   EQU   X'08'               Single byte storage operand
bitSHIFT  EQU   X'04'               Shift instruction
bitMASK   EQU   X'02'               Instruction contains bit mask
bitNOREF  EQU   X'01'               ddd(b) does NOT reference storage
         SPACE
*---------------------------------------------------------------------*
*        Flags in fourth attribute flag byte                          *
*---------------------------------------------------------------------*
         SPACE
bitDUMPR  EQU   X'80'               Dump all registers to SYSTRACE
bitEX     EQU   X'40'               Instruction is EXECUTE (EX)
bitFLOAT  EQU   X'20'               Floating point instruction
         EJECT
         PRINT NOGEN
         CVT   DSECT=YES,PREFIX=NO  Communications Vector Table (CVT)
         SPACE
         IEFTIOT1 ,                 Task Input/Output Table (TIOT)
         SPACE
         IHAPSA ,                   Prefixed Save Area (PSA)
         SPACE
         IHASDWA ,                  System Diagnostics Work Area (SDWA)
         SPACE
         IKJTCB ,                   Task Control Block (TCB)
         SPACE
         DCBD  DSORG=QS,DEVD=DA     Data Control Block (DCB)
         SPACE
         IHADCBE ,                  Data Control Block Extension (DCBE)
         SPACE
         IEFZB4D0 ,                 DYNALLOC parameter dsects
lenS99RB EQU   (S99RBEND-S99RB)     DYNALLOC request block length
         SPACE
         IEFZB4D2 ,                 DYNALLOC text unit keywords
         PRINT GEN
         EJECT
         TRCTBLS ,                  TRACE390 parm table entries
         SPACE 3
         TrcFlags ,                 TRACE390 user flag values
         SPACE 2
CNT$FLD  DSECT ,
CNT$OPCD DS    CL4                  Opcode
         DS    C
CNT$MNEM DS    CL5                  Assembler Mnemonic
         DS    C
CNT$ICNT DS    CL10                 Number of times executed
         DS    C
CNT$PCNT DS    CL6                  Percentage of total
         DS    CL4
CNT$LEN  EQU   *-CNT$FLD            Length
         EJECT
***********************************************************************
*                                                                     *
*   Title :                                                           *
*        ESA/390 Assembler Trace Routine                              *
*                                                                     *
*   Module Identifiers :                                              *
*        Source Name       - TRACE390                                 *
*        Link Name         - TRACE390                                 *
*        Entry Point       - TRACE390                                 *
*        Module Attributes - Re-usable, Only-loadable,                *
*                            Amode(31), Rmode(24).                    *
*                                                                     *
*   Credits :                                                         *
*        Bernard Schoch, Comnet Computer Center                       *
*        Debugged 1974/03/22 by Claude Schoch                         *
*        Converted for 370 instructions and extended floating point   *
*        instructions by Claude Schoch 1975/02/12.                    *
*                                                                     *
*        Enhanced and Supported by:                                   *
*          Lionel Silva                                               *
*          US Postal Data Center                                      *
*          850 Cherry Avenue                                          *
*          San Bruno, CA 94097-9330                                   *
*          (415) 876-9142                                             *
*                                                                     *
*        Enhanced by:                                                 *
*          Robert Ngan        (1987/09/10)                            *
*          Environment Technical Support,                             *
*          Databank Systems (NZ) Ltd.                                 *
*          175 The Terrace,                                           *
*          Wellington,                                                *
*          New Zealand.                                               *
*          (64) (4) 735-979                                           *
*                                                                     *
*        in the following areas:                                      *
*          Support bimodal addressing.                                *
*          Support 370/XA instructions.                               *
*          Support programs running in AMODE=31.                      *
*          Support programs (and data) above the 16M line.            *
*          Support semi and non privileged X'B2' instructions.        *
*          Trap storage alteration at user specified addresses.       *
*          Restrict instructions printed to user supplied ranges.     *
*          Add support for caller specified breakpoints.              *
*          Optional tracing of DL/I calls.                            *
*          Correct format of packed decimal operands for printing.    *
*          Prevent instruction fetches off the end of the program.    *
*          Trace program/subroutine call and return type branches.    *
*          Print module identification data on call type branches.    *
*          Gather program execution profile information.              *
*          Count number of instructions executed in user defined      *
*          ranges.                                                    *
*                                                                     *
*        Enhanced (and supported) by:                                 *
*          Robert Ngan        (1999/10/04)                            *
*          CSC Financial Services Group,                              *
*          5525 LBJ Freeway (3rd Floor),                              *
*          Dallas, TX 75240                                           *
*                                                                     *
*        in the following areas:                                      *
*          Support access-register ASC mode and the use of access     *
*          registers.                                                 *
*          Support tracing of BAKR and PR instructions.               *
*          Support the move-page facility.                            *
*          Support string-instruction facility.                       *
*          Support immediate-and-relative facility instructions.      *
*          Support compare-and-move-extended facility instructions.   *
*          Support the CHECKSUM instruction.                          *
*          Support TRAP facility instructions (well, recognize them!) *
*          Print BC, BCR and BRC instructions in extended mnemonic    *
*          format.                                                    *
*                                                                     *
*        Original program source can be found in:                     *
*          Appendix 2                                                 *
*          A Compiler Generator                                       *
*          by W M McKeeman, J J Horning and D B Wortman.              *
*          Prentice Hall. (c) 1970.                                   *
*          Library of Congress Catalog Number 76-117205               *
*                                                                     *
*   Function :                                                        *
*        This routine traces the execution of another program at the  *
*        assembler instruction level.                                 *
*                                                                     *
*   Reporting Problems :                                              *
*        Bug reports should be emailed to one of the follow accounts: *
*            RobertNgan@compuserve.com                                *
*            robngan@gte.net                                          *
*            Robert_Ngan@csc.com                                      *
*                                                                     *
*        This routine traces the execution of another program at the  *
*        assembler instruction level.                                 *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
*   Implementation Notes :                                            *
*        Suppression of tracing internal DL/I call logic was added    *
*        to prevent TRACE390 disabling itself when DL/I logic used    *
*        unsupported instructions (1990/04).                          *
*        Note that tracing of internal DL/I logic (both in BMP and    *
*        batch DL/I modes) has been tested successfully with v3r1 of  *
*        TRACE390 under IMS v5r1 (1999/10).                           *
*                                                                     *
*        The ASMTDLI/AIBTDLI interfaces are dynamically loaded so     *
*        as to match the version in the current environment.          *
*                                                                     *
*        Handling of X'01' prefixed instructions (PR/UPT/TRAP2) was   *
*        kludged since there are not that many to handle. If more of  *
*        these codes are ever used, the logic will need to be         *
*        rewritten.                                                   *
*                                                                     *
*        MVPG abends with a S0C4 when executed in primary ASC mode    *
*        when issued from 'Execute1'. Enabling bitACCESS for this     *
*        instruction (so it is issued from 'Execute2') corrects this  *
*        problem.                                                     *
*        I assume that the access registers are used (in primary ASC  *
*        mode) for what the "Principles of Operation" describes as    *
*        "additional address translation" within MVPG.                *
*                                                                     *
*        The End9nn/Retnnn logic would be handled cleaner by using a  *
*        RESUME PROGRAM instruction, however I'm not sure how         *
*        prevalent support for RP is at this time (1999/10).          *
*                                                                     *
*   Restrictions (and known bugs) :                                   *
*        Does not support the following instruction types:            *
*         - Privileged instructions                                   *
*         - Vector instructions                                       *
*         - Binary floating point instructions                        *
*         - Square-root facility instructions                         *
*         - Subspace-group facility instructions                      *
*                                                                     *
*        Storage altered by the following instructions do not trigger *
*        watchpoint exits:                                            *
*         - SVC                                                       *
*         - PC                                                        *
*         - UPT                                                       *
*         - MVPG                                                      *
*                                                                     *
*        Watchpoints are only triggered by (non-SVC) instructions     *
*        executed under the control of TRACE390, therefore if DL/I    *
*        call tracing is not enabled, storage altered within DL/I     *
*        logic will not trigger the watchpoint exit.                  *
*                                                                     *
*        Currently, only the ASMTDLI and AIBTDLI interfaces are       *
*        recognized as entry into DL/I (CBLTDLI and CEETDLI support   *
*        needs to be added).                                          *
*                                                                     *
*        If tracing is terminated when the local stack (BAKR_Stack)   *
*        is not empty, ESTA instruction to get the return PSW address *
*        or the branch address will get values inside TRACE390.       *
*                                                                     *
*        We should check when BAKR_Stack overflows and take some      *
*        appropriate action, this has not been implemented yet!       *
*                                                                     *
*   To Do List:                                                       *
*        Add support for binary floating point instructions.          *
*        Add support for the RESUME PROGRAM (RP) instruction.         *
*                                                                     *
***********************************************************************
         TITLE 'Change Log'
***********************************************************************
*                                                                     *
*   1999/10/21                                                        *
*        Add support for COMPRESSION CALL (CMPSC) instruction.        *
*                                                                     *
*   1999/10/19                                                        *
*        Zero AR15-AR00 at label ExER020 with LAM, not STAM!          *
*                                                                     *
*   1999/10/18                                                        *
*        Use SR to zero PSW condition code bits, SLR actually sets    *
*        condition code 2, not 0!                                     *
*        Add routine to handle IPM instruction, since condition code  *
*        bits are NOT restored by either Execute1 or Execute2.        *
*                                                                     *
***********************************************************************
         TITLE 'Enterprise System Architecture/390 Instruction Trace'
         SYSSTATE ASCENV=AR
&AsmDate SETC  '&SYSDATC'(1,4).'/'.'&SYSDATC'(5,2).'/'.'&SYSDATC'(7,2)
         SPACE
TRACE390 CSECT ,
TRACE390 AMODE 31                   So we can access stuff above 16M
TRACE390 RMODE 24                   Required for tracing AMODE=24 logic
         USING TRACE390,R15
         J     INIT
         DC    AL1(lenID)           Length of identification data
         DC    CL9'TRACE390'        Program id
         DC    CL12'v03.r01.m01'    Version
         DC    CL9'HLA&SYSVER'      HL Assembler version
         DC    CL11'&AsmDate'       Assembly date
         DC    CL5'&SYSTIME'        Assembly time
lenID    EQU   (*-TRACE390)-4-1
         SPACE
*---------------------------------------------------------------------*
*        Save area                                                    *
*---------------------------------------------------------------------*
         SPACE
SAVEAREA DC    18F'0'               Register save area
         EJECT
***********************************************************************
*                                                                     *
*        Program initialization                                       *
*                                                                     *
***********************************************************************
         SPACE
INIT     DS    0H
         LTR   R01,R01              Q. Parameter list passed?
         BZR   R14                  N. Do nothing
         STM   R00,R15,SAVEAREA     Y. Save all callers registers
         LM    R07,R10,aBASE           Load our base registers
         DROP  R15
         SPACE
         USING TRACE390,R07,R08,R09 Load module base registers
         USING Tr390$WS,R10         ...
         LA    R13,SAVEAREA         Load our save area pointer
         SPACE
         STAM  AR00,AR15,TraceARs   Save callers access registers
         IAC   R02                  Save callers ASC mode
         STCM  R02,B'0010',TraceASC ...
         NI    TraceASC,X'03'       ... and mask out any garbage
         SPACE
         NI    TrcFlag1,Trc$NoDD    Initialise status flags
         NI    TrcFlag2,255-Trc$NoIH ...
***                                 Set default processing flags
         MVI   UsrFlag1,Flg$PrHdr+Flg$Print ...
         MVI   UsrFlag2,0           ...
         MVI   UsrFlag3,0           ...
         MVI   UsrFlag4,0           ...
         SPACE
         LR    R03,R01              Get parmlist pointer
         LA    R15,VERIFY           Parmlist verification routine addr
         O     R15,BitZero          Invoke it in AMODE(31)
         BASSM R14,R15              Go validate parmlist
         SPACE
         ZAP   IRCOUNT,cpZero       Zero instructions counted this run
         ICM   R15,B'1111',AddrFlgs Q. Address of flags supplied?
         JZ    Init010              N. Use default flags
         MVC   UsrFlags,0(R15)      Y. Load user supplied flags
         SPACE
Init010  DS    0H
         MVC   TraceAMODE(1),SAVEAREA+4*14 Top byte of callers R14
         NI    TraceAMODE,X'80'     Clear all but high order bit
         SPACE
         ESTAEX MF=(E,cplESTAEX)
         LTR   R00,R15              Q. Abend exit established?
         JZ    Init020              Y. Continue
         BRAS  R14,HexToEBC         N. Convert return code to display
         STCM  R01,B'0011',cMsg006+28
         LA    R02,Msg006              Point to WTO message
         J     WTOABEND                Go issue WTO and ABEND
         SPACE
Init020  DS    0H
         L     R11,SAVEAREA+(4*14)  Address of 1st instruction traced
         MVC   DDNAME,SYSTRACE      Reset output ddname to default
         BRAS  R14,SetFlags         Process user flags
         SPACE
*---------------------------------------------------------------------*
*        Load ASMTDLI and AIBTDLI if not already loaded               *
*---------------------------------------------------------------------*
         SPACE
         TM    TrcFlag2,Trc$A2DL    Q. Tried to load ASMTDLI before?
         JNZ   Init030              Y. Don't do it again
         OI    TrcFlag2,Trc$A2DL    N. Indicate load attempted
         LOAD  EPLOC=ASMTDLI,ERRET=Init030
         ST    R00,ASM2DLI             Save entry point address
         SPACE
         LOAD  EPLOC=AIBTDLI,ERRET=Init030
         ST    R00,AIB2DLI             Save entry point address
         SPACE
*---------------------------------------------------------------------*
*        Copy the registers of the traced program into 'TraceGPRs'    *
*---------------------------------------------------------------------*
         SPACE
Init030  DS    0H
         MVC   TraceGPRs(64),SAVEAREA Copy traced programs registers
         BRAS  R14,TimeStamp        Obtain formatted date and time
         TM    UsrFlag1,Flg$Print   Q. Printing enabled?
         JZ    MainLoop             N. Nothing to print then
         BRAS  R12,DumpGPRs         Y. Dump the general registers
         BRAS  R12,DumpARs             Dump the access registers
         BRAS  R12,DumpFPRs            Dump floating point registers
         J     MainLoop
         SPACE 3
aBASE    DC    A(TRACE390)          Module base registers
         DC    A(TRACE390+4096)     ...
         DC    A(TRACE390+8192)     ...
         DC    A(Tr390$WS)          Address of trace routine data
         EJECT ,
***********************************************************************
*                                                                     *
*        Validate user parameters                                     *
*                                                                     *
***********************************************************************
         SPACE
VERIFY   DS    0H
         XC    ParmList,ParmList    Clear parmlist save area
         LHI   R15,-1               High values = default parameters
         CLR   R15,R03              Q. Use default parameters?
         JE    Ver990               Y. Nothing more to do here
         BCTR  R15,0                N. Minus one = -2
         CLR   R15,R03                 Q. Defaults with generated DSN?
         JNE   Ver010                  N. Go validate parameters
         OI    UsrFlag2,Flg$GDSN       Y. Indicate generated DSN
         J     Ver990                     Nothing more to do here
         SPACE
*---------------------------------------------------------------------*
*        Validate user flags                                          *
*---------------------------------------------------------------------*
         SPACE
Ver010   DS    0H
         ICM   R15,B'1111',AddrFlgs-ParmList(R03)
*                                   Q. User flags supplied?
         JZ    Ver100               N. Nothing to check then
         N     R15,SevenFs          Y. Q. User flags really supplied?
         JZ    Ver990                  N. Must be null last parameter
         ST    R15,AddrFlgs            Y. Save address of flags
         ICM   R00,B'0011',2(R15)         Q. Are last 2 bytes zeros?
         JZ    Ver020                     Y. Flags are ok then
         L     R00,0(,R15)                N. Load flag word
         BRAS  R14,HexToEBC                  Convert to display
         STM   R00,R01,cMsg001+59            Place into WTO message
         LA    R02,Msg001                    Point to WTO message
         J     WTOABEND                      ... and go issue WTO
         SPACE
Ver020   DS    0H
         TM    AddrFlgs-ParmList(R03),X'80'
*                                   Q. End of parmlist?
         JO    Ver990               N. Nothing more to check then
         SPACE
*---------------------------------------------------------------------*
*        Validate print-range table                                   *
*---------------------------------------------------------------------*
         SPACE
Ver100   DS    0H
         ICM   R15,B'1111',PrRngTbl-ParmList(R03)
*                                   Q. Print range table supplied?
         JZ    Ver200               N. Nothing to check then
         N     R15,SevenFs          Y. Q. Range table really supplied?
         JZ    Ver990                  N. Must be null end of list
         ST    R15,PrRngTbl            Y. Save table address
         USING PrtEntry,R15
         SPACE
Ver110   DS    0H
         LM    R01,R02,PrtStart     Load print range
         N     R01,SevenFs          Ensure top bit of start range clear
         CLR   R01,R02              Q. R01 higher than R02?
         JH    Ver120               Y. Invalid print range table
         LTR   R02,R02              Q. Q. End address negative?
         JM    Ver130                  Y. Bit zero set is invalid
         TM    PrtEntry,X'80'          N. Q. Last print range?
         JO    Ver190                     Y. This table validated
         LA    R15,PrtEntry+Prt$ELen      N. Point to next table entry
         J     Ver110
         SPACE
Ver120   DS    0H
         MVC   cMsg002+15(L'CC$PRT),CC$PRT
         J     Ver900
         SPACE
Ver130   DS    0H
         MVC   cMsg012+23(L'CC$PRT),CC$PRT
         J     Ver910
         SPACE
Ver190   DS    0H
         TM    PrRngTbl-ParmList(R03),X'80'
*                                   Q. End of parmlist?
         JO    Ver990               N. Nothing more to check then
         SPACE
*---------------------------------------------------------------------*
*        Validate break-point table                                   *
*---------------------------------------------------------------------*
         SPACE
Ver200   DS    0H
         ICM   R15,B'1111',BrkPtTbl-ParmList(R03)
*                                   Q. Break point table supplied?
         JZ    Ver300               N. Nothing to check then
         N     R15,SevenFs          Y. Q. Table really supplied?
         JZ    Ver990                  N. Must be null last parameter
         ST    R15,BrkPtTbl            Y. Save table address
         USING BptEntry,R15
         SPACE
Ver210   DS    0H
         L     R01,BptEXIT           Load breakpoint exit address
         N     R01,SevenFs           Q. Valid address?
         JZ    Ver220                N. Go complain about this
         IC    R01,0(,R01)           Y. Attempt access of exit address
         TM    BptEntry,X'80'           Q. Last entry in table
         JO    Ver230                   Y. Breakpoint table validated
         LA    R15,BptEntry+Bpt$ELEN    N. Point to next table entry
         J     Ver210
         SPACE
Ver220   DS    0H
         MVC   cMsg013+7(L'CC$BPT),CC$BPT
         J     Ver920
         SPACE
Ver230   DS    0H
         TM    BrkPtTbl-ParmList(R03),X'80'
*                                   Q. End of parmlist?
         JO    Ver990               N. Nothing more to check then
         SPACE
*---------------------------------------------------------------------*
*        Validate watch-point table                                   *
*---------------------------------------------------------------------*
         SPACE
Ver300   DS    0H
         ICM   R15,B'1111',WatchTbl-ParmList(R03)
*                                   Q. Watch point table supplied?
         JZ    Ver400               N. Nothing to check then
         N     R15,SevenFs          Y. Q. Table really suppled?
         JZ    Ver990                  N. Must be null last parameter
         ST    R15,WatchTbl            Y. Save table address
         USING WptEntry,R15
         SPACE
Ver310   DS    0H
         LM    R01,R02,WptStart     Load watchpoint addresses
         N     R01,SevenFs          Clear top bit of address
         CLR   R01,R02              Q. R01 higher than R02?
         JH    Ver320               Y. Invalid watchpoint entry
         LTR   R02,R02              N. Q. Top bit set in R02?
         JM    Ver330                  Y. Top bit set is invalid
         L     R01,WptExit             N. Load exit address
         N     R01,SevenFs                Q. Exit address valid?
         JZ    Ver340                     N. Invalid watchpoint entry
         IC    R01,0(,R01)                Y. S0C4 if EPA not readable
         TM    WptStart,X'80'                Q. Last entry in table
         JO    Ver390                        Y. Table validated
         LA    R15,WptEntry+Wpt$ELen         N. Point to next entry
         J     Ver310                           ... go process it
         SPACE
Ver320   DS    0H
         MVC   cMsg002+15(L'CC$WPT),CC$WPT
         J     Ver900
         SPACE
Ver330   DS    0H
         MVC   cMsg012+23(L'CC$WPT),CC$WPT
         J     Ver910
         SPACE
Ver340   DS    0H
         MVC   cMsg013+7(L'CC$WPT),CC$WPT
         J     Ver920
         SPACE
Ver390   DS    0H
         TM    WatchTbl-ParmList(R03),X'80'
*                                   Q. End of parmlist?
         JO    Ver990               N. Nothing more to check then
         SPACE
*---------------------------------------------------------------------*
*        Validate execution profile table                             *
*---------------------------------------------------------------------*
         SPACE
Ver400   DS    0H
         ICM   R15,B'1111',EProfTbl-ParmList(R03)
*                                   Q. Profiler point table supplied?
         JZ    Ver500               N. Nothing to check then
         N     R15,SevenFs          Y. Q. Table really supplied?
         JZ    Ver990                  N. Must be null last parameter
         ST    R15,EProfTbl            Y. Save table address
         USING PrfEntry,R15
         SPACE
Ver410   DS    0H
         L     R00,PrfTable         Get profiler data table address
         N     R00,SevenFs          Q. Address bits zero?
         JNZ   Ver420               N. Assume address is ok
         LA    R02,Msg011           Y. Point to WTO message
         MVC   cMsg011+40(L'CC$PROF),CC$PROF
         J     WTOABEND                Go issue WTO and ABEND
         SPACE
Ver420   DS    0H
         L     R00,PrfIntvl         Profiler range sub-interval size
         CHI   R00,4                Q. Sub-interval at least four?
         JNL   Ver430               Y. Sub-interval size ok, continue
         BRAS  R14,HexToEBC         N. Convert size to display
         STM   R00,R01,cMsg010+32      place into WTO message
         LA    R02,Msg010              Point to WTO text
         J     WTOABEND                Go issue WTO and ABEND
         SPACE
Ver430   DS    0H
         LM    R01,R02,PrfStart     Load profile range
         CLR   R01,R02              Q. R01 higher than R02?
         JH    Ver440               Y. Invalid profile range entry
         LTR   R02,R02              N. Q. Bit zero of address set?
         JM    Ver450                  Y. Address in invalid
         LTR   R02,R01                 N. Q. Bit zero of address set?
         JM    Ver450                     Y. Address in invalid
         TM    PrfEntry,X'80'             N. Q. Last entry in table?
         JO    Ver490                        Y. Table validated
         LA    R15,PrfEntry+PRF$ELEN         N. Point to next entry
         J     Ver410                           ... go process it
         SPACE
Ver440   DS    0H
         MVC   cMsg002+15(L'CC$PROF),CC$PROF
         J     Ver900
         SPACE
Ver450   DS    0H
         MVC   cMsg012+23(L'CC$PROF),CC$PROF
         J     Ver910
         SPACE
Ver490   DS    0H
         TM    EProfTbl-ParmList(R03),X'80'
*                                   Q. End of parmlist?
         JO    Ver990               N. Nothing more to check then
         SPACE
*---------------------------------------------------------------------*
*        Validate instruction count table                             *
*---------------------------------------------------------------------*
         SPACE
Ver500   DS    0H
         ICM   R15,B'1111',InstrTbl-ParmList(R03)
*                                   Q. Got instruction count table?
         JZ    Ver590               N. Nothing to check then
         N     R15,SevenFs          Y. Q. Really got count table?
         JZ    Ver990                  N. Must be null last parameter
         ST    R15,InstrTbl            Y. Save table address
         USING In#Entry,R15
         SPACE
Ver510   DS    0H
         L     R00,In#Table         Count table address
         N     R00,SevenFs          Q. Address zero?
         JNZ   Ver520               N. Assume its ok
         LA    R02,Msg011              Point to WTO text
         MVC   cMsg011+40(L'CC$ICNT),CC$ICNT
         J     WTOABEND                Go issue WTO and ABEND
Ver520   DS    0H
         LM    R01,R02,In#Start     Load instruction count range
         CLR   R01,R02              Q. R01 higher than R02?
         JH    Ver530               Y. Invalid profile range entry
         LTR   R02,R02              N. Q. Top bit of address set?
         JM    Ver540                  Y. Address is invalid
         LTR   R02,R01                 N. Q. Top bit of address set?
         JM    Ver540                     Y. Address is invalid
         TM    In#Entry,X'80'             N. Q. Last entry in table?
         JO    Ver590                        Y. Table validated
         LA    R15,In#Entry+IN#$ELEN         N. Point to next entry
         J     Ver510                           ... go process it
         SPACE
Ver530   DS    0H
         MVC   cMsg002+15(L'CC$ICNT),CC$ICNT
         J     Ver900
         SPACE
Ver540   DS    0H
         MVC   cMsg012+23(L'CC$ICNT),CC$ICNT
         J     Ver910
         SPACE
Ver590   DS    0H
         TM    InstrTbl-ParmList(R03),X'80'
*                                   Q. End of parmlist?
         JO    Ver990               N. Nothing more to check then
         DROP  R15
         SPACE
*---------------------------------------------------------------------*
*        Validate user DDname                                         *
*---------------------------------------------------------------------*
         SPACE
Ver600   DS    0H
         ICM   R15,B'1111',aUserDDN-ParmList(R03)
*                                   Q. User supplied DDNAME present?
         JNM   Ver610               N. Nothing to check then
         N     R15,SevenFs          Y. Q. Really got DDNAME?
         JZ    Ver990                  N. Must be null last parameter
         ST    R15,aUserDDN            Y. Save ddname address
         TRT   0(8,R15),DDNchars          Q. DDname OK?
         JZ    Ver990                     Y. Probably (not definitely)
***                                       N. Put bad ddname in message
         MVC   cMsg003+29(L'DCBDDNAM),0(R15)
         LA    R02,Msg003                    Point to WTO text
         J     WTOABEND                      Go issue WTO
         SPACE
Ver610   DS    0H
         LA    R02,Msg004           Parameter list is too long
         J     WTOABEND             Go issue WTO and ABEND
         SPACE
*---------------------------------------------------------------------*
*        Invalid range entry in table                                 *
*---------------------------------------------------------------------*
         SPACE
Ver900   DS    0H
         LR    R00,R01              Start address
         BRAS  R14,HexToEBC         Convert to display
         STM   R00,R01,cMsg002+46   ...
         LR    R00,R02              End address
         BRAS  R14,HexToEBC         Convert to display
         STM   R00,R01,cMsg002+63   ...
         LA    R02,Msg002           Address of WTO text
         J     WTOABEND
         SPACE
*---------------------------------------------------------------------*
*        Address with bit zero set is invalid                         *
*---------------------------------------------------------------------*
         SPACE
Ver910   DS    0H
         LR    R00,R02              Address in question
         BRAS  R14,HexToEBC         Convert to display
         STM   R00,R01,cMsg012+44   ...
         LA    R02,Msg012           Address of WTO text
         J     WTOABEND
         SPACE
*---------------------------------------------------------------------*
*        EPA of Exit is zero                                          *
*---------------------------------------------------------------------*
         SPACE
Ver920   DS    0H
         LR    R00,R15              Address of invalid entry
         BRAS  R14,HexToEBC         Convert to display
         STM   R00,R01,cMsg013+36   ...
         LA    R02,Msg013           Address of WTO text
         J     WTOABEND
         SPACE
*---------------------------------------------------------------------*
*        Parameter list validated, return to caller                   *
*---------------------------------------------------------------------*
         SPACE
Ver990   DS    0H
         BSM   0,R14                Return to caller
         SPACE 3
CC$PRT   DC    CL11'Print Range'
CC$BPT   DC    CL11'Break Point'
CC$WPT   DC    CL11'Watch Point'
CC$PROF  DC    CL11'Profiler   '
CC$ICNT  DC    CL11'Instr Count'
         EJECT
***********************************************************************
*                                                                     *
*        This is invoked if TRACE390 ABENDs                           *
*        All it does is attempt to close the SYSTRACE dataset         *
*                                                                     *
***********************************************************************
         SPACE
RECOVER  DS    0H
         CHI   R00,12               Q. SDWA provided?
         JNE   Rec010               Y. Attempt to close systrace
         SLR   R15,R15              N. Take ABEND with no action
         BSM   0,R14
         SPACE
Rec010   DS    0H
         LR    R11,R14              Save return address
         LM    R07,R10,0(R02)       Reload mainline base registers
         SPACE
         LR    R03,R01              Save pointer to SDWA
         USING SDWA,R03             ... and set base
         SPACE
         IAC   R04                  Q. In primary ASC mode?
         JZ    Rec020               Y. We're good as is
         SAC   0                    N. Switch to primary ASC mode
         SPACE
Rec020   DS    0H
         USING IHADCB,dcbTRACE
         TM    DCBOFLGS,DCBOFOPN    Q. Output dataset open?
         JZ    Rec999               N. No need to close it then
         TM    TrcFlag2,Trc$EPUT    Y. Q. ESTAEX PUT attempted already?
         JO    Rec060                  Y. Don't try it again
         OI    TrcFlag2,Trc$EPUT       N. Say ESTAEX PUT in progress
         LA    R15,ExecIns2               Executed instruction address
         TM    bAttribute1,bitACCESS      Q. Access registers involved?
         JO    Rec030                     Y. Got right instruction
         CLI   TraceASC,ARmode            N. Q. In AR ASC mode?
         JE    Rec030                        Y. Access registers used
         LA    R15,ExecIns1                  N. No access registers
         SPACE
Rec030   DS    0H
         LA    R00,6(,R15)          Maximum address of NSI
         L     R14,SDWANXT1         Get address of NSI
         N     R14,SevenFs          Clear AMODE indicator
         CLR   R14,R15              Q. Possibly ABEND at ExecInsx?
         JL    Rec040               N. Not a possibility
         CLR   R14,R00              Y. Q. Really at ExecInsN?
         JH    Rec040                  N. Must be some where else
         L     R00,SaveRegs+4*11       Y. Traced instruction pointer
         O     R00,TraceAMODE             OR in addressing mode
         BRAS  R14,HexToEBC               Convert to display hex
         STM   R00,R01,STAEaddr           Bung into print line
         LA    R00,STAEMSG2               Load message address
         J     Rec050                     and go put line
         SPACE
Rec040   DS    0H
         L     R00,SDWAEC1          Get first half of abending PSW
         BRAS  R14,HexToEBC         Convert to display hex
         STM   R00,R01,STAEPSW      ... and store in output line
         L     R00,SDWAEC1+4        Get second half of abending PSW
         BRAS  R14,HexToEBC         Convert to display hex
         STM   R00,R01,STAEPSW+9    ... and store in output line
         LA    R00,STAEMSG1         Load message address
         SPACE
Rec050   DS    0H
         PUT   dcbTRACE,(0)         Attempt final PUT
         NI    TrcFlag2,255-Trc$EPUT Reset 'PUT in progress' flag
         SPACE
Rec060   DS    0H
         TM    TrcFlag2,Trc$ECLS    Q. ESTAEX CLOSE attempted already?
         JO    Rec999               Y. Don't try it again
         OI    TrcFlag2,Trc$ECLS    N. Say ESTAEX CLOSE in progress
         MVI   cplCLOSE,X'80'          Indicate single entry in list
         CLOSE (dcbTRACE),MODE=31,MF=(E,cplCLOSE)
         NI    TrcFlag2,255-Trc$ECLS   Reset 'CLOSE in progress' flag
         SPACE
Rec999   DS    0H
         SETRP WKAREA=(R03),DUMP=YES,RC=0
         DROP  R03
         LR    R14,R11              Reload return address
         BR    R14                  and return control to RTM
         SPACE
         LTORG ,
         EJECT ,
***********************************************************************
*                                                                     *
*        Binary to EBCDIC hexadecimal conversion routine              *
*                                                                     *
***********************************************************************
         SPACE
HexToEBC DS    0H
         ST    R00,WorkDblW         Store the word to be converted
         UNPK  WorkCL9,WorkCL5      Spread out the hex digits
         TR    WorkDblW,HexChar-C'0' Translate to hex characters
         LM    R00,R01,WorkDblW     Load the results
         BSM   0,R14                and return
         EJECT
***********************************************************************
*                                                                     *
*        Main loop executed for each instruction                      *
*                                                                     *
***********************************************************************
         SPACE
MainLoop DS    0H
         TM    TrcFlag1,Trc$EndT    Q. Trace terminated by an exit?
         JO    End000               Y. End trace
         LA    R01,Main010          N. Set addressing mode to that of
         O     R01,TraceAMODE          ... the traced program
         BSM   0,R01                   ...
         SPACE
Main010  DS    0H
         MVC   OldAMODE(1),TraceAMODE Save current addressing mode
         LA    R11,0(,R11)          Ensure high order bit/byte cleared
         CLR   R11,R07              Q. Reached entry to TRACE390?
         JE    End000               Y. Go end trace
         SPACE
*---------------------------------------------------------------------*
*        Check for breakpoint                                         *
*---------------------------------------------------------------------*
         SPACE
         ICM   R15,B'1111',BrkPtTbl Q. Breakpoint table available?
         JZ    Main060              N. No break points active
         LA    R02,Main020          Y. Load BSM address
         O     R02,BitZero             Indicate AMODE=31
         BSM   0,R02                   Search table in AMODE=31
         USING BptEntry,R15
         SPACE
Main020  DS    0H
         L     R02,BptADDR          Load a breakpoint address
         N     R02,SevenFs          Ensure top bit is clear
         CLR   R02,R11              Q. Have we reached a breakpoint?
         JE    Main030              Y. Go call breakpoint exit
         TM    BptEntry,X'80'       N. Q. Last entry in table?
         JO    Main050                 Y. Nothing else to check then
         LA    R15,BptEntry+Bpt$ELEN   N. Point to next entry
         J     Main020                    and go check it out
         SPACE
*---------------------------------------------------------------------*
*        Breakpoint reached, call breakpoint exit                     *
*---------------------------------------------------------------------*
         SPACE
Main030  DS    0H
         O     R02,TraceAMODE       Put AMODE into instruction pointer
         ST    R02,InstrPointer     Store it where exit expects it
         XC    StoreAddr,StoreAddr  Indicate not a storage exception
         OI    TrcFlag1,Trc$Exit    Indicate user exit active
         L     R15,BptEXIT          AMODE/Address of breakpoint exit
         DROP  R15
         LA    R01,plUserExit       Point to exit parameter list
         BASSM R14,R15              Invoke breakpoint routine
         LTR   R15,R15              Q. Good return code from exit?
         JZ    Main040              Y. Keep going
         OI    TrcFlag1,Trc$EndT    N. Indicate termination by exit
         SPACE
Main040  DS    0H
         NI    TrcFlag1,255-Trc$Exit User exit no longer active
         BRAS  R12,CloseDS          Spin off output if required
         BRAS  R14,SetFlags         Re-process user flags
         CL    R02,InstrPointer     Q. AMODE/instruction ptr changed?
         JE    Main050              N. Nothing to reset then
***                                 Y. Save new addressing mode
         MVC   TraceAMODE(1),InstrPointer ...
         NI    TraceAMODE,X'80'        Only need high order bit
         LR    R15,R11                 Save old instruction pointer
         NI    InstrPointer,X'7F'      Clear out amode bit and
         L     R11,InstrPointer        ... load new instruction pointer
         CLR   R11,R15                 Q. Instruction pointer changed?
         JNE   MainLoop                Y. Go set (new) AMODE and check
*                                         ... for another breakpoint
         SPACE
Main050  DS    0H
         LA    R15,Main060          Switch back to the traced program's
         O     R15,TraceAMODE       ... addressing mode and continue
         BSM   0,R15                ...
         SPACE
*---------------------------------------------------------------------*
*        Get instruction attributes                                   *
*---------------------------------------------------------------------*
         SPACE
Main060  DS    0H
         NI    TrcFlag1,255-Trc$ModCall Turn off ID string present flag
         MVC   OldAMODE(1),TraceAMODE Save initial AMODE for printing
         MVC   OldRegs(4*16),TraceGPRs Save old registers for EvalXBD
         MVC   XCell+2(4),NopInstr  Pad XCell with NOPs
         MVC   XCell(2),0(R11)      Fetch first 2 bytes of instruction
         SLR   R01,R01              Clear R01
         IC    R01,XCell            The instruction code
         L     R15,aOpIndex         Instruction index address
         SPACE
*---------------------------------------------------------------------*
*        Check for 2 byte instruction codes (x'01'/x'B2'/x'A7' only)  *
*---------------------------------------------------------------------*
         SPACE
         CLI   XCell,$B2            Q. x'B2' type instruction?
         JNE   Main070              N. Bif not
         IC    R01,XCell+1          Y. 2nd byte of instruction code
         L     R15,aB2index            x'B2' instruction index address
         J     Main090
         SPACE
Main070  DS    0H
         CLI   XCell,$A7            Q. x'A7' type instruction?
         JNE   Main080              N. Bif not
         IC    R01,XCell+1          Y. 2nd byte of instruction code
         N     R01,OOOOOOOF            Isolate low order nybble
         L     R15,aA7index            x'A7' instruction index address
         J     Main090
         SPACE
Main080  DS    0H
         CLI   XCell,$01            Q. x'01' type instruction?
         JNE   Main090              N. First byte identifies opcode
         IC    R01,XCell+1          Y. 2nd byte of instruction code
         L     R15,a01index            x'01' instruction index address
         SPACE
Main090  DS    0H
         SLL   R01,1                Multiply by 2 for entry length
         LH    R01,0(R01,R15)       The instruction index
         L     R15,aOpFlags         Instruction attribute flags address
         L     R00,0(R01,R15)       The instruction attribute flags
         ST    R00,bAttributes      Save the flags
         TM    bAttribute1,bitILGL  Q. Instruction illegal?
         JO    ILGLOP               Y. Go print message and quit
         SPACE
*---------------------------------------------------------------------*
*        Move actual instruction into 'XCell'                         *
*        Note that instruction bytes are fetched 2 at a time to       *
*        prevent ABEND S0C4's if the instruction is less than 6 bytes *
*        long and it is the last instruction in a load module that    *
*        ends at the end of a page boundary (and the next page is not *
*        accessible).                                                 *
*---------------------------------------------------------------------*
         SPACE
         TM    bAttribute2,bitRR    Q. RR type instruction?
         JZ    Main100              N. Go get rest of instruction
         CLC   XCell(2),ABEND       Y. Q. ABEND SVC instruction?
         JNE   Main110                 N. Continue
         OI    TrcFlag1,Trc$EndT       Y. Indicate end of trace
         J     End000                     and return control to caller
         SPACE
Main100  DS    0H
         MVC   XCell+2(2),2(R11)    Get next two bytes
         TM    bAttribute2,bitSS    Q. SS(E) type instruction?
         JZ    Main110              N. Got all of instruction
         MVC   XCell+4(2),4(R11)    Y. Get last two bytes
         SPACE
*---------------------------------------------------------------------*
*        Call appropriate routine to execute instruction              *
*---------------------------------------------------------------------*
         SPACE
Main110  DS    0H
         TM    bAttribute1,bitBR    Q. Branch (or executed branch)?
         JZ    Main120              N. Process standard instruction
         TM    bAttribute4,bitEX    Y. Q. EXECUTE instruction?
         JO    ExOP                    Y. Go to the EXECUTE processor
         BRAS  R14,BrProc              N. Call the branch processor
         J     Main200
         SPACE 2
Main120  DS    0H
         MVC   ExecIns1,XCell       Parameters for execute routine
         LA    R05,bAttributes      Load address of flags
         BRAS  R03,ExecInst         Call the execute routine
         SPACE
*---------------------------------------------------------------------*
*        Update condition codes if then could have changed            *
*---------------------------------------------------------------------*
         SPACE
         TM    bAttribute1,bitCC    Q. Can condition codes change?
         JZ    Main200              N. Not a possibility
         SRL   R00,4                Y. Shift condition code into
         STCM  R00,B'1000',TraceCC     ... bits 6-7 and save
         EJECT
*---------------------------------------------------------------------*
*        Post instruction-execution processing                        *
*---------------------------------------------------------------------*
         SPACE
Main200  DS    0H
         TM    UsrFlag1,Flg$PrCurInst Q. Print this instruction?
         JO    Main230              Y. Go print it
         TM    UsrFlag1,Flg$Print   N. Q. Is printing enabled?
         JZ    Main300                 N. Skip print phase
         ICM   R01,B'1111',PrRngTbl    Y. Q. Got a print range table?
         JZ    Main230                    N. Print everything then
         LA    R15,Main210                Y. Ensure print range table
         O     R15,BitZero                   ... search is done in
         BSM   0,R15                         ... AMODE=31
         USING PrtEntry,R01
         SPACE
Main210  DS    0H
         LM    R14,R15,PrtStart     Load print range
         N     R14,SevenFs          Ensure start range top bit is clear
         CLR   R11,R14              Q. Address lower than low range?
         JL    Main220              Y. Not in this range, try next one
         CLR   R11,R15              N. Q. Addr higher than high range?
         JNH   Main230                 N. Inside range so print it
         SPACE
Main220  DS    0H
         TM    PrtEntry,X'80'        Q. End of range table entries?
         JO    Main300               Y. Nothing to print then
         LA    R01,PrtEntry+Prt$ELen N. Point to next range table entry
         J     Main210                  and go check it out
         DROP  R01
         SPACE
Main230  DS    0H
         LA    R15,Main240          BSM target address
         O     R15,OldAMODE         Insert target amode
         BSM   0,R15                Ensure right AMODE for EvalBD etc.
         SPACE
Main240  DS    0H
         BRAS  R14,PrintSup         Call the print supervisor
         NI    UsrFlag1,255-Flg$PrCurInst Disable current instr. flag
         SPACE
*---------------------------------------------------------------------*
*        Do execution profiling if required                           *
*---------------------------------------------------------------------*
         SPACE
Main300  DS    0H
         N     R11,SevenFs          Ensure H.O. bit is zero
         ICM   R02,B'1111',EProfTbl Q. Profiler table present?
         JZ    Main400              N. Skip execution profiling
         LA    R15,Main310          Y. Search table in AMODE=31
         O     R15,BitZero             ...
         BSM   0,R15                   ...
         USING PrfEntry,R02
         SPACE
Main310  DS    0H
         LM    R14,R15,PrfStart     Load a profiler range
         CLR   R11,R14              Q. IP lower than low range?
         JL    Main320              Y. No in this range
         CLR   R11,R15              N. Q. IP higher than high range?
         JH    Main320                 N. Not in this range
         L     R00,PrfIntvl            Y. Get range sub-interval size
         CHI   R00,4                      Q. Valid sub-interval size?
         JNL   Main330                    Y. Go update table
         BRAS  R14,HexToEBC               N. Convert to display
         STM   R00,R01,cMsg010+32            Move to message
         LA    R02,Msg010                    Point to error message
         J     WTOABEND                      Go write message and ABEND
         SPACE
Main320  DS    0H
         TM    PrfEntry,X'80'        Q. Last entry?
         JO    Main400               Y. Nothing to profile
         LA    R02,PrfEntry+PRF$ELEN N. Bump to next entry
         J     Main310                  and go process it
         SPACE
Main330  DS    0H
         LR    R15,R11              R11 - R14 gives the offset
         SLR   R15,R14              ... within the profiler range
         SLR   R14,R14              Clear top half of dividend
         DR    R14,R00              Relative sub-interval
         SLL   R15,2                Multiply by 4 (cell size)
         AL    R15,PrfTable         Address of relative cell
         LHI   R14,1                Increment value in cell
         AL    R14,0(,R15)          ...
         ST    R14,0(,R15)          ...
         DROP  R02
         SPACE
*---------------------------------------------------------------------*
*        Do instruction counting if required                          *
*---------------------------------------------------------------------*
         SPACE
Main400  DS    0H
         ICM   R02,B'1111',InstrTbl Q. Instruction count table present?
         JZ    Main500              N. Skip instruction counting
         LA    R15,Main410          Y. Search table in AMODE=31
         O     R15,BitZero             ...
         BSM   0,R15                   ...
         USING In#Entry,R02
         SPACE
Main410  DS    0H
         LM    R15,R00,In#Start     Load a instr. count range
         CLR   R11,R15              Q. IP lower than low range?
         JL    Main420              Y. No in this range
         CLR   R11,R00              N. Q. IP higher than high range?
         JNH   Main430                 N. Found an instr. count range
         SPACE
Main420  DS    0H
         TM    In#Entry,X'80'        Q. Last entry?
         JO    Main500               Y. Do not count this instruction
         LA    R02,In#Entry+IN#$ELEN N. Bump to next entry
         J     Main410                  and go process it
         SPACE
Main430  DS    0H
         TM    bAttribute4,bitFLOAT Q. Floating point instruction?
         JZ    Main440              N. Go count instruction
         TM    UsrFlag2,Flg$NCFP    Y. Q. Ignore floating point?
         JO    Main500                 Y. Skip instruction counting
         SPACE
Main440  DS    0H
         SLR   R00,R00              Default table offset is zero
         SLR   R15,R15              Ensure top 3 bytes are zero
         CLI   XCell,$B2            Q. x'B2' prefixed instruction?
         JNE   Main450              N. Check for x'A7'
         LHI   R00,256              Y. Offset to x'B2' table
         IC    R15,XCell+1             Use 2nd byte as instruction code
         J     Main480
         SPACE
Main450  DS    0H
         CLI   XCell,$A7            Q. x'A7' prefixed instruction?
         JNE   Main460              N. Check for x'01'
         LHI   R00,256+256          Y. Offset to x'A7' table
         IC    R15,XCell+1             Use 2nd byte as instruction code
         N     R15,OOOOOOOF            Only L.O. nybble is relevant
         J     Main480
         SPACE
Main460  DS    0H
         CLI   XCell,$01            Q. x'01' prefixed instruction?
         JNE   Main470              N. Stay with default table
         LHI   R00,256+256+16       Y. Offset to x'01' table
         IC    R15,XCell+1             Use 2nd byte as instruction code
         CLI   XCell+1,$TRAP2          Q. Is this TRAP2?
         JNE   Main480                 N. Instruction code is OK
         LHI   R15,03                  Y. Use 3 as the offset instead
         J     Main480
         SPACE
Main470  DS    0H
         IC    R15,XCell            Instruction code (1st byte only)
         SPACE
Main480  DS    0H
         ALR   R15,R00              Add table offset
         SLL   R15,2                Multiply by 4 (cell size)
         AL    R15,In#Table         Address of relative cell
         LHI   R14,1                Increment value in cell
         AL    R14,0(,R15)          ...
         ST    R14,0(,R15)          ...
         DROP  R02
         SPACE
*---------------------------------------------------------------------*
*        Update instruction pointer (IP) if necessary                 *
*---------------------------------------------------------------------*
         SPACE
Main500  DS    0H
         AP    IRCOUNT,cpOne        Increment instructions traced count
         AP    ITCOUNT,cpOne        Increment total instructions traced
         TM    TrcFlag1,Trc$Branch   Q. Increment the pseudo IP?
         JZ    Main510               Y. Go increment
         L     R11,BranchTgt         N. New IP from branch routine
         NI    TrcFlag1,255-Trc$Branch  Reset 'branch taken' flag
         J     MainLoop                 Go to the end of main loop
         SPACE
Main510  DS    0H                   Increment the pseudo IP
         SLR   R14,R14              Zero H.O. 3 bytes
         IC    R14,XCell            First byte of instruction
         SRL   R14,6                First 2 bits of instruction
         IC    R14,BitCount(R14)    Number of bits ON in 1st 2 bits is -
                                    ... instruction length in halfwords-
                                    ... minus one
         LA    R14,1(,R14)          Number of halfwords in instruction
         ALR   R14,R14              Number of bytes in instruction
         LA    R11,0(R14,R11)       Increment the instruction pointer
         J     MainLoop             Go process next instruction
         EJECT
***********************************************************************
*                                                                     *
*        Illegal/unsupported instruction handling                     *
*                                                                     *
***********************************************************************
         SPACE
ILGLOP   DS    0H
         MVC   PLINE(L'IlglMsg),IlglMsg **** ILLEGAL INSTRUCTION
         BRAS  R14,Write            Print the message
         BRAS  R14,PrintSup         Print the illegal instruction
         OI    TrcFlag1,Trc$EndT    Indicate instruction ptr in R11
         J     End000               End trace, let traced program ABEND
         SPACE 3
***********************************************************************
*                                                                     *
*        Issue WTO for error message and ABEND                        *
*                                                                     *
***********************************************************************
         SPACE
WTOABEND DS    0H
         WTO   TEXT=(R02),MF=(E,cplWTO) Write error message
         ABEND &ABEND,DUMP          ... and crap out
         SPACE 3
***********************************************************************
*                                                                     *
*        Set control flags as passed by caller                        *
*                                                                     *
***********************************************************************
         SPACE
SetFlags DS    0H
         TM    UsrFlag1,Flg$Spin    Q. Spin off previous output?
         JZ    SetF010              N. Bif not
         OI    TrcFlag1,Trc$SPEX    Y. Set internal spin off flag
         NI    UsrFlag1,255-Flg$Spin   and turn off user spin off flag
         SPACE
SetF010  DS    0H
         TM    UsrFlag2,Flg$PICT    Q. Print instruction count table?
         JZ    SetF020              N. Bif not
         OI    TrcFlag1,Trc$PICT    Y. Set internal print flag
         NI    UsrFlag2,255-Flg$PICT   and turn off user print flag
         SPACE
SetF020  DS    0H
         TM    UsrFlag2,Flg$PEPT    Q. Print execution profile table?
         JZ    SetF030              N. Bif not
         OI    TrcFlag2,Trc$PEPT    Y. Set internal print flag
         NI    UsrFlag2,255-Flg$PEPT   and turn off user print flag
         SPACE
SetF030  DS    0H
         TM    UsrFlag2,Flg$NALC    Q. Allocate DDNAME if not found?
         JZ    SetF040              Y. Nothing more to do
         OI    TrcFlag2,Trc$NALC    N. Set internal 'no allocate' flag
         NI    UsrFlag2,255-Flg$NALC   and turn off user flag
         SPACE
SetF040  DS    0H
         BSM   0,R14                Return to caller
         EJECT ,
***********************************************************************
*                                                                     *
*        Terminate tracing and resume execution of calling or traced  *
*        module (which ever is currently active)                      *
*                                                                     *
***********************************************************************
         SPACE
End000   DS    0H
         BRAS  R12,DumpGPRs         Dump general registers
         BRAS  R12,DumpARs          Dump access registers
         BRAS  R12,DumpFPRs         Dump floating point registers
         TM    TrcFlag2,Trc$PEPT    Q. Print instruction table?
         JZ    End010               N. Bif not
         BRAS  R14,PROFILER         Y. Print instruction count table
         SPACE
End010   DS    0H
         TM    TrcFlag1,Trc$PICT    Q. Print instruction table?
         JZ    End020               N. Bif not
         BRAS  R14,PRINTCNT         Y. Print instruction count table
         SPACE
End020   DS    0H
         TM    TrcFlag1,Trc$EndT    Q. Termination by user exit?
         JO    End030               Y. Got instruction pointer + AMODE
         L     R11,TraceGPRs+(4*14) N. R14 contains instruction pointer
         N     R11,SevenFs             Ensure top bit of address clear
         MVI   TraceAMODE,X'80'        Assume caller is using AMODE=31
         TM    TraceGPRs+(4*14),X'80'  Q. Actually using AMODE=31
         JO    End030                  Y. Leave rest of top byte alone
         ICM   R11,B'1000',HexZeros    N. Zero top byte of address
         MVI   TraceAMODE,0               Indicate AMODE=24
         SPACE
End030   DS    0H
         MVC   PrL$Data+3(L'EndMsg1),EndMsg1
         LA    R03,PrL$Data+3+L'EndMsg1 Address of resume address field
         L     R00,TraceAMODE       Get amode indicator
         OR    R00,R11              Merge in instruction pointer
         BRAS  R14,HexToEBC         Convert for printing
         STM   R00,R01,0(R03)       ... and place in message
         MVI   8(R03),C';'          Field separator
         LA    R03,10(,R03)         Bump past field separator
         LA    R02,IRCOUNT          # instructions traced this run
         BRAS  R14,Edit20           Convert to display
         EX    R15,MoveEDMK         Move to print line
         LA    R03,1(R15,R03)       Bump past count
         MVC   1(L'EndMsg2,R03),EndMsg2
         LA    R03,L'EndMsg2+1(,R03) Bump to end of message
         LA    R02,ITCOUNT          Total instructions traced
         BRAS  R14,Edit20           Convert to display
         EX    R15,MoveEDMK         Move to print line
         LA    R03,1(R15,R03)       Bump to end of total trace count
         MVI   0(R03),C')'
         MVI   PrL$CCB,C'0'         Double space the line
         BRAS  R14,Write            Print the message
         SPACE
         OI    UsrFlag1,Flg$Spin    Force close of output dataset
         BRAS  R12,CloseDS          ... and invoke close routine
         TM    TrcFlag1,Trc$SPEX    Q. Spin off output on exit?
         JZ    End900               N. Bif not
         SLR   R00,R00              Y. Indicate spinoff request
         BRAS  R14,SpinOff             Go spin off the output
         NI    TrcFlag1,255-Trc$SPEX   ... and clear flag
         SPACE
End900   DS    0H
         MVC   DDNAME,SYSTRACE      Reset default output ddname
         ESTAEX 0                   Cancel our ESTAEX routine
         SPACE
*---------------------------------------------------------------------*
*        Find a register with which we can branch back to the traced  *
*        program with and zap the return branch instruction with the  *
*        required index register and offset before executing it.      *
*---------------------------------------------------------------------*
         SPACE
End910   DS    0H
         LHI   R15,15               Register number
         L     R01,SevenFs          AMODE=31 address mask
         NR    R11,R01              Ensure high order bit is clear
         LR    R02,R11              High bound of register value
         LHI   R14,4095             Maximum branch offset allowed
         SLR   R02,R14              Low bound of search range
         TM    TraceAMODE,X'80'     Q. Traced program in AMODE=31?
         JO    End920               Y. Address mask is OK
         ICM   R01,B'1000',HexZeros N. Change to AMODE=24 address mask
         SPACE
End920   DS    0H
         LR    R14,R15              Get register number
         SLL   R14,2                Multiply by four for offset
         L     R14,TraceGPRs(R14)   Contents of register in question
         NR    R14,R01              Clear top bit(s) from address
         CLR   R14,R11              Q. Register possibly within bounds?
         JH    End930               N. Go try next register
         CLR   R14,R02              Y. Q. Can we use this register?
         JNL   End940                  Y. Go use this register
         SPACE
End930   DS    0H
         BRCT  R15,End920           Try next register
         LA    R02,Msg009           Tell user we cannot return
         J     WTOABEND             Go issue WTO and ABEND
         SPACE
End940   DS    0H
         SLR   R11,R14              Offset for branch
         SLL   R15,12               Move register id to bits 16-19
         OR    R11,R15              OR register with offset
         STCM  R11,B'0011',Zap4BC+2 Zap 'BC' with base and offset
         LA    R14,Ret999           Address of return code
         O     R14,TraceAMODE       Insert traced program's amode
         SPACE
         SR    R01,R01              Zero the condition code bits in PSW
         IPM   R01                  Get current program mask
         SLR   R02,R02              Clear for condition code insertion
         ICM   R02,B'1000',TraceCC  Get traced condition code
         SLL   R02,4                Shift condition code to bits 2-3
         OR    R01,R02              OR condition code with program mask
         SPM   R01                  Restore traced condition code
         BSM   0,R14                Go to return to caller code
         EJECT
***********************************************************************
*                                                                     *
*        Convert PL8 field to display                                 *
*                                                                     *
*        Entry - R02 contains address of PL8 field to convert         *
*        Exit  - R01 contains address of first display field          *
*                R15 contains length of display field minus one       *
*                                                                     *
***********************************************************************
         SPACE
Edit20   DS    0H
         MVC   WorkCL32,EDmask20         Move edit mask to work area
         LA    R01,WorkCL32+L'EDmask20-1 Init R01 to default value
         LR    R15,R01                   which is also end of the field
         EDMK  WorkCL32(L'EDmask20),0(R02) Convert packed to display
         SLR   R15,R01                   Calculate length minus one
         BSM   0,R14
         EJECT
***********************************************************************
*                                                                     *
*        Branch instruction processor                                 *
*                                                                     *
***********************************************************************
         SPACE
BrProc   DS    0H
         ST    R14,BRSAV            Save return address
         TM    bAttribute2,bitIMREL Q. Relative branch instruction?
         JZ    BP010                N. Must be an "old" style branch
         CLI   XCell,$A7            Y. Q. x'A7' type instruction?
         JNE   BP320                   N. Must be BRXH or BRXLE
         IC    R00,XCell+1             Y. Get 2nd instruction byte
         N     R00,OOOOOOOF               Isolate A7 qualifier nybble
         CHI   R00,05                     Q. BRAS instruction?
         JL    BP500                      Lo. Must be BRC
         JE    BP300                      Eq. Must be BRAS
         J     BP600                      Hi. Must be BRCT
         SPACE
BP010    DS    0H
         TM    bAttribute2,bitRRE   Q. BAKR instruction?
         JO    BP700                Y. Go process it
         TM    bAttribute2,bitRS    Q. BXH or BXLE ?
         JO    BP800                Y. Go process it
         TM    XCell,X'07'          Q. BC (X'47') or BCR (X'07')?
         JO    BP500                Y. Go process it
         TM    XCell,X'06'          Q. BCT(X'46') or BCTR(X'06')?
         JO    BP600                Y. Go process it
         CLI   XCell,$BSM           Q. BSM instruction?
         JE    BP100                N. Go process it
         CLI   XCell,$01            Q. PR instruction?
         JE    BP200                Y. Go process it
         J     BP300                N. Must be BAS, BASR, BASSM etc.
         SPACE
***********************************************************************
*                                                                     *
*        BSM processor                                                *
*                                                                     *
***********************************************************************
         SPACE
BP100    DS    0H
         TM    UsrFlag1,Flg$PrRet   Q. Print return type branches?
         JZ    BP110                N. Do not turn print flag on then
         OI    UsrFlag1,Flg$PrCurInst Y. Print this instruction
         SPACE
BP110    DS    0H
         IC    R02,XCell+1          rr
         N     R02,OOOOOOFO         r0
         JZ    BP120                Don't save mode if R00
         SRL   R02,2                r*4
         LA    R01,TraceGPRs(R02)   Address of r1
         NI    0(R01),X'7F'         Clear top bit of r1
         OC    0(1,R01),TraceAMODE  Set top bit from current amode
         J     BP930                Go evaluate branch address
         SPACE
BP120    DS    0H
         CLI   XCell+1,X'0F'        Q. Registers used 0 and 15?
         JNE   BP930                N. Can't be PEM calling assembler
         ICM   R00,15,TraceGPRs+4*14 Y. Q. Register 14 zero?
         JZ    BP350                   Y. PEM equivalent to BALR 14,15
         J     BP930                   N. Go evaluate branch address
         SPACE
***********************************************************************
*                                                                     *
*        PR processor                                                 *
*                                                                     *
***********************************************************************
         SPACE
BP200    DS    0H
         ICM   R00,B'1111',StackPtr Q. Local stack empty?
         JNZ   BP210                N. Process the PR instruction
***                                 Y. Can't handle PR from a BAKR that
         MVC   PLINE(L'UnMatchedPR),UnMatchedPR ... we did not trace!
         BRAS  R14,Write            Print the message
         OI    TrcFlag1,Trc$EndT    Indicate instruction ptr in R11
         J     End000               End trace
         SPACE
BP210    DS    0H
         TM    UsrFlag1,Flg$PrRet   Q. Print RETURN branches?
         JZ    BP220                N. Skip turning flag on
***                                 Y. Print this instruction
         OI    UsrFlag1,Flg$PrCurInst  ...
         SPACE
BP220    DS    0H
         NI    Zap3BRC+1,X'0F'      NOP the JUMP
         SPACE
         STM   R03,R13,SaveRegs+4*3 Save non-scratch registers
         LR    R15,R10              Point to our working storage
         PUSH  USING
         DROP  R10
         USING Tr390$WS,R15         Temporary base to working-storage
         EREG  R02,R14              Pop registers off stack entry
         STM   R02,R14,TraceGPRs+4*2  ... and save
         STAM  AR02,AR14,TraceARs+4*2 ...
         PR    ,                    Return to label Zap3BRC
         POP   USING
         SPACE
***********************************************************************
*                                                                     *
*        BAL(R), BAS(R), BRAS and BASSM processor                     *
*                                                                     *
***********************************************************************
         SPACE
BP300    DS    0H
         TM    UsrFlag1,Flg$PrBAL   Q. Print BAL(R) type branches?
         JZ    BP310                N. Bypass switch on of print flag
***                                 Y. Print this instruction
         OI    UsrFlag1,Flg$PrCurInst
         SPACE
BP310    DS    0H
         LHI   R01,2                Compute increment to R11
         ICM   R15,B'1000',bAttribute2
         ICM   R15,B'0100',bAttribute4
         TMH   R15,(bitRX+bitRS)*256+bitEX
***                                 Q. RS, RX or EXecute instruction?
         JZ    BP320                N. Must be RR, increment is 2
         ALR   R01,R01              Y. Instruction is BAL/BAS/BRAS/EX
         SPACE
BP320    DS    0H
         ALR   R01,R11              Return address for branch
         O     R01,TraceAMODE       OR in the current AMODE bit
         TM    XCell,X'0C'          Q. BAS, BASR or BASSM?
         JO    BP340                Y. Don't fiddle with H.O. byte
         LTR   R01,R01              N. Q. Program in AMODE=31?
         JM    BP340                   Y. BAL(R) -> BAS(R) in AMODE=31
         TM    bAttribute2,bitIMREL    N. Q. BRAS instruction?
         JO    BP340                      Y. Don't alter H.O. byte
         SPACE
*---------------------------------------------------------------------*
*        Build return register for an AMODE=24 BAL(R) instruction     *
*---------------------------------------------------------------------*
         SPACE
         IPM   R00                  Get program mask bits
         N     R00,OFOOOOOO         Program mask bits only
         OR    R01,R00              Insert in the return
         L     R00,ILC1             Get instruction length bits
         TMH   R15,bitRX*256+bitEX  Q. RX or EXecute instruction?
         JZ    BP330                N. Must be BALR so length is two
         ALR   R00,R00              Y. BAL or executed BALR length is 4
         SPACE
BP330    DS    0H
         OR    R01,R00              OR in instruction length code
         IC    R00,TraceCC          Get the correct condition code
         SLL   R00,28               Position it properly
         OR    R01,R00              OR in condition code bits
         SPACE
*---------------------------------------------------------------------*
*        R01 now contains the return register that would have         *
*        resulted in actual execution from storing the right half     *
*        of the PSW                                                   *
*---------------------------------------------------------------------*
         SPACE
BP340    DS    0H
         IC    R02,XCell+1          rr
         N     R02,OOOOOOFO         r0
         SRL   R02,2                r*4
         ST    R01,TraceGPRs(R02)   Store return in pseudo register
         TM    bAttribute2,bitIMREL Q. BRAS instruction?
         JO    BP920                Y. Always branch
         TM    bAttribute2,bitRX    N. Q. BAS or BAL instruction?
         JO    BP910                   Y. Always branch
         EJECT
***********************************************************************
*                                                                     *
*        Get module identification string (if possible)               *
*                                                                     *
***********************************************************************
         SPACE
         CLI   XCell+1,X'EF'        Q. Branch using registers R14,R15?
         JNE   BP930                N. Not a standard call
         TM    bAttribute1,bitAMODE Y. Q. BASSM instruction?
         JZ    BP350                   N. No need to check AMODEs
         TM    OldRegs+(4*15),X'80'    Y. Q. Going to AMODE=31?
         JZ    BP350                      N. Not a problem then
         TM    TraceAMODE,X'80'           Y. Q. Currently AMODE=24?
         JO    BP350                         N. Not a problem then
         TM    OldRegs+(4*15),X'7F'          Y. Q. Target above 16M?
         JNZ   BP930                            Y. Can't address it
         SPACE
BP350    DS    0H
         L     R15,OldRegs+(4*15)   Get destination address
         TM    UsrFlag1,Flg$Print+Flg$PrCurInst+Flg$Call
***                                 Q. Printing active?
         JZ    BP400                N. Ignore any ID string
         CLC   0(3,R15),BRANCH      Y. Q. BRANCH around ID string?
         JE    BP360                   Y. Go check it out
         CLC   0(3,R15),JUMP           N. Q. JUMP around ID string?
         JNE   BP400                      N. No ID string present
         SPACE
BP360    DS    0H
         CLI   4(R15),C'$'          Q. Is first byte the length?
         JL    BP370                Y. Go validate length byte
         LHI   R01,8                N. Assume length is 8 bytes
         LA    R14,4(,R15)             Get address of ID string
         J     BP380                   ... and go process it
         SPACE
BP370    DS    0H
         CLI   4(R15),0             Q. Valid length?
         JE    BP400                N. Can't use it then
         LA    R14,5(,R15)          Y. Get address of id string
         IC    R01,4(,R15)             Load length
         CLI   4(R15),L'IDstring       Q. Length too long?
         JNH   BP380                   N. Use it
         LHI   R01,L'IDstring          Y. Truncate to max length
         SPACE
BP380    DS    0H
         TRT   0(2,R14),DDNchars    Q. 1st 2 bytes valid in module id?
         JNZ   BP400                N. Assume no module id present
         MVI   IDstring,C' '        Y. Clear out module name field
         MVC   IDstring+1(L'IDstring-1),IDstring
         SPACE
         BCTR  R01,0                Get machine length
         EX    R01,MoveIdent        Save module id string
***      MVC   IDstring(0),0(R14)   ...
         TR    IDstring,EBCDIC      Replace non-display chars with C'.'
         OI    TrcFlag1,Trc$ModCall Indicate id string present
         TM    UsrFlag1,Flg$Call    Q. Print call information?
         JZ    BP930                N. Use default printing options
         OI    UsrFlag1,Flg$PrCurInst Y. Explicitly turn on printing
         J     BP930                   DL/I has no module id info
         SPACE
***********************************************************************
*        Trap calls to DL/I so internal DL/I logic is not traced.     *
*---------------------------------------------------------------------*
*        Note that the first 24 bytes of all DL/I interface routines  *
*        are the same but we cannot just do a 24 byte compare in case *
*        the storage we are branching to is shorter than 24 bytes     *
*        long and is at the end of a page boundary, so we will do     *
*        six 4-byte compares instead and (hopefully) avoid S0C4's.    *
*                                                                     *
***********************************************************************
         SPACE
BP400    DS    0H
         CLI   XCell,$BSM           Q. BSM instruction?
         JE    BP930                Y. Can't be call to DL/I
         CLI   bAttribute2,bitRRE   Q. BAKR instruction?
         JO    BP930                Y. Can't be call to DL/I
         TM    UsrFlag1,Flg$TrDLI   N. Q. Want DL/I calls traced too?
         JO    BP930                   Y. Bypass DL/I call test
         ICM   R02,B'1111',ASM2DLI     N. Q. ASMTDLI loaded?
         JZ    BP930                      Y. Cannot check for ASMTDLI
         LA    R14,ASMTDLI                N. First DL/I interface name
         SPACE
BP410    DS    0H
         LR    R01,R15              Get copy of branch address
         LHI   R00,6                Loop 6 times (test 24 bytes)
         SPACE
BP420    DS    0H
         CLC   0(4,R02),0(R01)      Q. Same code as DL/I interface?
         JNE   BP440                N. Go check for AIBTDLI
         LA    R02,4(,R02)          Y. Increment DL/I code pointer
         LA    R01,4(,R01)             Increment branch code pointer
         BRCT  R00,BP420               Loop for 6 fullwords
         SPACE
         OI    TrcFlag1,Trc$ModCall Indicate id string present
         MVI   IDstring,C' '        Clear out module name field
         MVC   IDstring+1(L'IDstring-1),IDstring
         MVC   IDstring(L'DLIcall),DLIcall ... Indicate call is to DL/I
         MVC   IDstring(8),0(R14)   Actual interface name
         SPACE
         L     R01,OldRegs+4        Load R01 with DL/I parmlist
         BASR  R14,R15              Do call to DL/I
         ST    R15,TraceGPRs+(4*15) Save return code
         LA    R02,2(,R11)          Point to next instruction
         TM    bAttribute4,bitEX    Q. Execute instruction?
         JZ    BP430                N. Got NSI address
         LA    R02,4(,R11)          Y. Execute is four bytes long
         SPACE
BP430    DS    0H
         LR    R00,R02              Load R00 with destination address
         TM    UsrFlag1,Flg$Call    Q. Print call information?
         JZ    BP990                N. Finished
***                                 Y. Print this instruction
         OI    UsrFlag1,Flg$PrCurInst  ...
         J     BP990                   ... and finish up
         SPACE
BP440    DS    0H
         CLC   AIBTDLI,0(R14)       Q. Did we just check for AIBTDLI?
         JZ    BP930                Y. Not a DL/I call
         ICM   R02,B'1111',AIB2DLI  N. Q. AIBTDLI loaded?
         JZ    BP930                   Y. Cannot check for AIBTDLI
         LA    R14,AIBTDLI             N. Point to DL/I interface name
         J     BP410
         EJECT
***********************************************************************
*                                                                     *
*        BC, BRC and BCR processor                                    *
*                                                                     *
***********************************************************************
         SPACE
BP500    DS    0H                   Conditional branch processor
         IC    R01,XCell+1          mr
         N     R01,OOOOOOFO         m0
         SLR   R02,R02              Clear R02
         IC    R02,TraceCC          Actual condition code
         SLL   R02,2                (condition code)*4
         N     R01,CCbits(R02)      Mask bits corresponding to
*                                   the condition code
         JZ    BP999                Branch is not taken
         TM    bAttribute2,bitIMREL Q. BRC instruction?
         JO    BP920                Y. Go evaluate relative address
         TM    bAttribute2,bitRX    Q. BC instruction?
         JO    BP910                Y. Go evaluate RX address
         TM    UsrFlag1,Flg$PrRet   N. Q. Print return type branches?
         JZ    BP930                   N. Go evaluate R address
         OI    UsrFlag1,Flg$PrCurInst  Y. Print this instruction
         J     BP930                      and go evaluate R address
         SPACE 3
***********************************************************************
*                                                                     *
*        BCT, BRCT and BCTR processor                                 *
*                                                                     *
***********************************************************************
         SPACE
BP600    DS    0H
         IC    R02,XCell+1          rr
         N     R02,OOOOOOFO         r0
         SRL   R02,2                r1*4
         L     R01,TraceGPRs(R02)   Value of the count register
         AHI   R01,-1               Subtract 1 (and set condition code)
         ST    R01,TraceGPRs(R02)   Store new value back
         JZ    BP999                No branch if new value is zero
         TM    bAttribute2,bitIMREL Q. BRC instruction?
         JO    BP920                Y. Go evaluate relative address
         TM    bAttribute2,bitRX    Q. RX instruction?
         JO    BP910                Y. Must be BCT, evaluate RX address
         J     BP930                N. Must be BCTR, evaluate R address
         EJECT
***********************************************************************
*                                                                     *
*        BAKR processor                                               *
*                                                                     *
***********************************************************************
         SPACE
BP700    DS    0H
         STM   R03,R13,SaveRegs+4*3 Save current registers now for     -
                                    ... restore after actual BAKR
         TM    UsrFlag1,Flg$PrBAL   Q. Print BAL(R) type branches?
         JZ    BP710                N. Bypass switch on of print flag
***                                 Y. Print this instruction
         OI    UsrFlag1,Flg$PrCurInst
         SPACE
BP710    DS    0H
         IC    R02,XCell+3          rr
         N     R02,OOOOOOFO         r0
         JZ    BP720                Return address is NSI when r1 is 0
         SRL   R02,2                r*4
         L     R01,TraceGPRs(R02)   Load return address register value
         LTR   R01,R01              Q. AMODE=31 on return?
         JM    BP730                Y. H.O. byte is OK
         ICM   R01,B'1000',HexZeros N. Ensure H.O. byte is zero
         J     BP730
         SPACE
BP720    DS    0H
         LA    R01,4(,R11)          Compute increment to IP
         O     R01,TraceAMODE       OR in the current AMODE bit
         SPACE
BP730    DS    0H
         L     R15,StackPtr         Current stack pointer (offset)
         LA    R14,BAKR_Stack       Point to our (local) stack
         LR    R02,R15              Current stack pointer (offset)
         SLL   R02,3                Multiply by 8 (stack entry length)
         ST    R01,0(R02,R14)       Save return address in stack entry
         LA    R15,1(,R15)          Increment stack pointer
         ST    R15,StackPtr         ... and update
         IC    R01,XCell+3          rr
         N     R01,OOOOOOOF         0r
         JZ    BP740                No branch if using register zero
         SLL   R01,2                r*4
         L     R00,OldRegs(R01)     Get address from register
         N     R00,SevenFs          Ensure H.O. bit is zero
         J     BP750
         SPACE
BP740    DS    0H
         LA    R00,4(,R11)          Address of NSI
         SPACE
BP750    DS    0H
         O     R00,OldAMODE         Merge with addressing mode bit
         LTR   R00,R00              Q. AMODE=31 address
         JM    BP760                Y. All bits are relevant
         ICM   R00,B'1000',HexZeros N. Zero the H.O. byte
         SPACE
BP760    DS    0H
         ST    R00,4(R02,R14)       Save branch address in stack entry
         B     Execute3             Go form the stack state entry
         EJECT
***********************************************************************
*                                                                     *
*        BXH/BRXH and BXLE/BRXLE processor                            *
*                                                                     *
***********************************************************************
         SPACE
BP800    DS    0H
         IC    R01,XCell+1          rr
         N     R01,OOOOOOOF         0r
         SLL   R01,2                r3*4
         L     R00,TraceGPRs(R01)   Value of the increment
         IC    R02,XCell+1          rr
         N     R02,OOOOOOFO         r0
         SRL   R02,2                r1*4
         AL    R00,TraceGPRs(R02)   1st operand + increment
         ST    R00,TraceGPRs(R02)   Store sum back in r1
         TM    XCell+1,X'01'        Q. Is r3 odd?
         JO    BP810                Y. So it is the comparand
         LA    R01,4(,R01)             (r3+1)*4
         SPACE
BP810    DS    0H
         C     R00,TraceGPRs(R01)   Compare new value and comparand
         JH    BP820                New value is greater
         TM    XCell,X'01'          Q. Is the instruction B(R)XLE?
         JO    BP900                Y. BXLE so branch is taken
         J     BP999                N. BXH so branch is not taken
         SPACE
BP820    DS    0H
         TM    XCell,X'01'          Q. Is the instruction B(R)XH?
         JNZ   BP999                N. Branch is not taken
         EJECT
*---------------------------------------------------------------------*
*        Type RS, branch is taken.  Compute effective address         *
*---------------------------------------------------------------------*
         SPACE
BP900    DS    0H
         TM    bAttribute2,bitIMREL Q. Relative branch?
         JO    BP920                Y. Go evaluate relative branch
         LA    R02,XCell+2          N. Point at base, displacement
         BRAS  R14,EvalBD              Go evaluate effective address
         J     BP990
         SPACE
*---------------------------------------------------------------------*
*        Type RX, branch is taken.  Compute effective address         *
*---------------------------------------------------------------------*
         SPACE
BP910    DS    0H
         LA    R02,XCell+2          Point at base, displacement field
         BRAS  R14,EvalXBD          Go evaluate effective address
         J     BP990
         SPACE
*---------------------------------------------------------------------*
*        Type RI, branch is taken.  Compute effective address         *
*---------------------------------------------------------------------*
         SPACE
BP920    DS    0H
         BRAS  R14,EvalRI           Go evaluate relative address
         J     BP990
         SPACE
*---------------------------------------------------------------------*
*        Type RR(E), branch is taken.  Compute effective address      *
*---------------------------------------------------------------------*
         SPACE
BP930    DS    0H
         IC    R01,XCell+1          rr from RR instruction
         TM    bAttribute2,bitRRE   Q. Actually an RRE instruction?
         JNO   BP940                N. Got the correct rr specifiers
         IC    R01,XCell+3          Y. Load correct rr for RRE
         SPACE
BP940    DS    0H
         N     R01,OOOOOOOF         0r
         JZ    BP999                No branch if register 0 specified
         SLL   R01,2                r*4
         L     R00,OldRegs(R01)     Get address from register
         SPACE
BP950    DS    0H
         TM    bAttribute1,bitAMODE Q. Does this instruction set mode?
         JZ    BP990                N. AMODE does not change then
         STCM  R00,8,TraceAMODE     Y. Save new addressing mode
         NI    TraceAMODE,X'80'        Only interested in H.O. bit
         SPACE
*---------------------------------------------------------------------*
*        Successful branch exit                                       *
*---------------------------------------------------------------------*
         SPACE
BP990    DS    0H
         ST    R00,BranchTgt        Save branch address as new IP
         OI    TrcFlag1,Trc$Branch  Indicate branch was taken
         SPACE
*---------------------------------------------------------------------*
*        Unsuccessful branch exit                                     *
*---------------------------------------------------------------------*
         SPACE
BP999    DS    0H
         L     R14,BRSAV            Restore return address
         BSM   0,R14                Return
         TITLE 'Execute Instruction Processor'
***********************************************************************
*                                                                     *
*        EXECUTE instruction processor                                *
*                                                                     *
***********************************************************************
         SPACE
ExOP     DS    0H
         MVC   PSXCell+2(4),NopInstr Pad PSXCell with NOPs
         LA    R02,XCell+2          Point to base and displacement
         BRAS  R14,EvalXBD          Evaluate the effective address of  X
                                    ... the EXECUTE'd instruction
         LR    R01,R00              Move address to non-zero register
         ST    R00,aEX_Target       Save address in case it's a BRANCH
         SPACE
         SLR   R14,R14              Clear work register
         IC    R14,0(,R01)          First byte of target instruction
         SRL   R14,6                Mask off instruction length code
         IC    R14,BitCount(R14)    Number of halfwords minus one
         ALR   R14,R14              Number of bytes in instruction - 2
         LA    R14,1(,R14)          Number of bytes in instruction - 1
         EX    R14,EXMVCEX          Load target instruction
***      MVC   PSXCell(0),0(R01)    ...
         SPACE
         IC    R02,XCell+1          rr of the EXECUTE instruction
         N     R02,OOOOOOFO         Isolate execute register
         SPACE
*---------------------------------------------------------------------*
*        If the r1 field of the execute instruction is zero then the  *
*        subject instruction is executed as is,  otherwise the right  *
*        hand byte of the register specified by the r1 field is OR'ed *
*        into the second byte of the subject instruction.             *
*---------------------------------------------------------------------*
         SPACE
         JZ    ExOp010              Register 0? Then nothing to OR in
         SRL   R02,2                r0 / 2 = r1*4
         IC    R02,TraceGPRs+3(R02) Get the bits to OR in
         SLL   R02,16               00nn0000 <- 000000nn
         O     R02,PSXCell          OR with the subject instruction
         STCM  R02,B'1100',PSXCell  ... and save updated instruction
         SPACE
ExOp010  DS    0H
         SLR   R01,R01              Clear R01
         IC    R01,PSXCell          Code of the subject instruction
         L     R15,aOpIndex         Instruction code index address
         CLI   XCell,$B2            Q. x'B2' type instruction?
         JNE   ExOp020              N. Go check for x'A7' instruction
         IC    R01,XCell+1          Y. 2nd byte of instruction code
         L     R15,aB2index            Instruction code index address
         J     ExOp040
         SPACE
ExOp020  DS    0H
         CLI   XCell,$A7            Q. x'A7' type instruction?
         JNE   ExOp030              N. No other checking
         IC    R01,XCell+1          Y. 2nd byte of instruction code
         N     R01,OOOOOOOF            Isolate low order nybble
         L     R15,aA7index            Instruction code index address
         J     ExOp040
         SPACE
ExOp030  DS    0H
         CLI   XCell,$01            Q. x'01' type instruction?
         JNE   ExOp040              N. No other checking
         IC    R01,XCell+1          Y. 2nd byte of instruction code
         L     R15,a01index            Instruction code index address
         SPACE
ExOp040  DS    0H
         SLL   R01,1                Multiply by 2 for entry length
         LH    R01,0(R01,R15)       Instruction code index
         L     R15,aOpFlags         Address of attribute flags table
         L     R01,0(R01,R15)       Load instruction attribute flags
         ST    R01,PSFLAGS          Save the flags
         TM    PSFLAGS,bitILGL      Q. Subject instruction illegal?
         JO    ILGLOP               Y. Print message and terminate
         TM    PSFLAGS,bitBR        Q. Is subject instruction a branch?
         JO    ExBr                 Y. Simulate an executed branch ins.
         MVC   ExecIns1,PSXCell     N. Parameters for execute routine
         LA    R05,PSFLAGS             Load address of PSFLAGS
         BRAS  R03,ExecInst            Call the execute routine
         SPACE
         TM    PSFLAGS,bitCC        Q. Condition code possibly changed?
         JZ    ExOp050              N. Not a possibility
         SRL   R00,4                Y. Shift condition code into
         STCM  R00,B'1000',TraceCC     ... bits 6-7 of R00 and save
         SPACE
ExOp050  DS    0H
         J     Main200              Return to the main loop
         TITLE 'Executed Branch Handler'
***********************************************************************
*                                                                     *
*       EXECUTE'd branch handler                                      *
*                                                                     *
***********************************************************************
         SPACE
ExBr     DS    0H
         TM    PSFLAGS+3,bitEX      Q. EXECUTE'd instruction an EX?
         JZ    ExBr010              N. Go process executed branch
         OI    TrcFlag1,Trc$EndT    Y. Indicate end of trace so the
         J     End000                  ... S0C3 happens outside TRACE
         SPACE
*---------------------------------------------------------------------*
*        Shuffle things around to fool the branch processor           *
*---------------------------------------------------------------------*
         SPACE
ExBr010  DS    0H
         L     R01,bAttributes      Swap bAttributes and PSFLAGS
         L     R02,PSFLAGS          ...
         ST    R01,PSFLAGS          ...
         ST    R02,bAttributes      ...
         LM    R00,R01,XCell        Swap XCell and PSXCell
         LM    R02,R03,PSXCell      ...
         STM   R00,R01,PSXCell      ...
         STM   R02,R03,XCell        ...
         SPACE
*---------------------------------------------------------------------*
*        Signal an executed branch so that the instruction length     *
*        code comes out right for RR format branch instructions       *
*---------------------------------------------------------------------*
         SPACE
         OI    bAttribute4,bitEX    Set executed branch flag
         BRAS  R14,BrProc           Call the branch processor
         SPACE
*---------------------------------------------------------------------*
*        Put things back the way they were so that the execute        *
*        instruction gets printed                                     *
*---------------------------------------------------------------------*
         SPACE
         L     R01,bAttributes      Swap bAttributes and PSFLAGS
         L     R02,PSFLAGS          ...
         ST    R01,PSFLAGS          ...
         ST    R02,bAttributes      ...
         LM    R00,R01,XCell        Swap XCell and PSXCell
         LM    R02,R03,PSXCell      ...
         STM   R00,R01,PSXCell      ...
         STM   R02,R03,XCell        ...
         J     Main200              Return to the main loop
         TITLE 'Non-Branch and Execute Instruction Handler'
***********************************************************************
*                                                                     *
*        Instruction execution processor                              *
*                                                                     *
*        ExecIns1 - Instruction to be executed                        *
*        R03      - Return address                                    *
*        R05      - Address of executed instruction's attribute flags *
*                                                                     *
***********************************************************************
         SPACE
ExecInst DS    0H
         CLI   ExecIns1,$LM         Q. 'Load Multiple' instruction?
         JE    ExecLM               Y. Go process
         STM   R03,R13,SaveRegs+4*3 N. Save callers registers
         SPACE
*---------------------------------------------------------------------*
*        Check for instructions which alter storage if necessary      *
*---------------------------------------------------------------------*
         SPACE
         TM    0(R05),bitALTER      Q. Instruction alter storage?
         JZ    EI200                N. Cannot alter storage
         ICM   R15,B'1111',WatchTbl Y. Q. Watchpoint table supplied?
         JZ    EI200                   N. Nothing to do then
         SPACE
         TM    2(R05),bitDBLS+bitFULL+bitHALF+bitBYTE
*                                   Q. Fixed length operand?
         JZ    EI010                N. Need to calculate length then
         LHI   R15,4-1              Y. Assume fullword operand
         TM    2(R05),bitFULL          Q. Really fullword operand?
         JO    EI100                   Y. Go calculate address
         SLR   R15,R15                 N. Assume byte operand
         TM    2(R05),bitBYTE             Q. Really byte operand?
         JO    EI100                      Y. Go calculate address
         LHI   R15,8-1                    N. Assume doubleword operand
         TM    2(R05),bitDBLS                Q. Really doubleword?
         JO    EI100                         Y. Go calculate address
         LHI   R15,2-1                       N. Must be halfword
         J     EI120                            Go calculate address
         SPACE
*---------------------------------------------------------------------*
*        Determine type of instruction                                *
*---------------------------------------------------------------------*
         SPACE
EI010    DS    0H
         CLI   ExecIns1,$STCM       Q. STCM instruction?
         JE    EI060                EQ. Yes, go get STCM operand length
         JL    EI020                LO. Must be MVCL or STM
         TM    0(R05),bitPACKD      HI. SS instruction, is it packed?
         JZ    EI030                    N. Non-packed SS instruction
         IC    R15,ExecIns1+1           Y. Get ll byte (l1,l2)
         N     R15,OOOOOOFO                Mask off l1
         SRL   R15,4                       Move into right nybble
         J     EI110                       Got get storage address
         SPACE
*---------------------------------------------------------------------*
*        Get length of storage accessed by STM instruction            *
*---------------------------------------------------------------------*
         SPACE
EI020    DS    0H
         CLI   ExecIns1,$STM        Q. STM instruction?
         JNE   EI070                Y. Must be MVCL instruction then
         IC    R15,ExecIns1+1       N. rr
         LR    R14,R15                 rr
         N     R14,OOOOOOFO            r0       r1
         SRL   R14,4                   r        r1
         N     R15,OOOOOOOF            0r       r2
         LA    R15,16(,R15)            r2 + 16
         SLR   R15,R14                 r2 + 16 - r1
         N     R15,OOOOOOOF            (r2 + 16 - r1) MOD 16
         SLL   R15,4                   = (# of registers minus one) * 4
         LA    R15,3(,R15)             = (# of registers * 4) minus one
         J     EI110                   Go find storage address
         SPACE
*---------------------------------------------------------------------*
*        Get length of storage altered by a non-decimal SS format     *
*        instruction  (note that MVCK and MVCP are special cases)     *
*---------------------------------------------------------------------*
         SPACE
EI030    DS    0H
         TM    0(R05),bitMVCX       Q. MVCK or MVCP instruction?
         JO    EI040                Y. Length is in a register
         SLR   R15,R15              N. Clear R15
         IC    R15,ExecIns1+1          Length minus one
         J     EI110                   Go get storage address
         SPACE
*---------------------------------------------------------------------*
*        Instruction is a MVCK or a MVCP                              *
*---------------------------------------------------------------------*
         SPACE
EI040    DS    0H
         IC    R15,ExecIns1+1       rr
         N     R15,OOOOOOFO         r0
         SRL   R15,2                r*4
         L     R15,TraceGPRs(R15)   True length
         CHI   R15,256              Q. True length less than 256 bytes?
         JNH   EI050                Y. True length will be used
         LHI   R15,256              N. Used length will be 256 bytes
         SPACE
EI050    DS    0H
         BCTR  R15,0                Want length minus one
         J     EI110                Go find storage address
         SPACE
*---------------------------------------------------------------------*
*        Instruction is a STCM                                        *
*---------------------------------------------------------------------*
         SPACE
EI060    DS    0H
         IC    R15,ExecIns1+1       rm
         N     R15,OOOOOOOF         0m
         IC    R15,BitCount(R15)    Number of bits
         BCTR  R15,0                Number of bits in m minus one
         J     EI110                Go find address of storage
         SPACE
*---------------------------------------------------------------------*
*        Get address and length of MVCL(E) instruction                *
*---------------------------------------------------------------------*
         SPACE
EI070    DS    0H
         IC    R15,ExecIns1+1       rr
         N     R15,OOOOOOFO         r0
         SRL   R15,2                r1*4
         SLR   R04,R04              Assume we're not in AR ASC mode
         CLI   TraceASC,ARmode      Q. In AR ASC mode?
         JNE   EI080                N. Default value is good
         L     R04,TraceARs(R15)    Y. Load associated ALET
         SPACE
EI080    DS    0H
         L     R14,TraceGPRs(R15)   Start address (contents of r1)
         LA    R14,0(,R14)          Ensure high order bit/byte clear
         LA    R15,4(,R15)          (r1 + 1) * 4
         L     R01,TraceGPRs(R15)   Length of target
         TM    bAttribute2,bitRR    Q. MVCL instruction?
         JZ    EI090                N. Length is OK for MVCLE
         ICM   R01,B'1000',HexZeros Y. MVCL only has 3-byte length
         SPACE
EI090    DS    0H
         LTR   R01,R01              Q. Target length zero?
         JZ    EI200                Y. Zero length results in no store
         BCTR  R01,0                N. Length minus 1
         LA    R15,0(R01,R14)          End address
         J     EI130
         EJECT
*---------------------------------------------------------------------*
*        Is instruction RX or one of S, SS, RS and SI                 *
*---------------------------------------------------------------------*
         SPACE
EI100    DS    0H
         TM    1(R05),bitRX         Q. RX instruction?
         JO    EI120                Y. Calculate ddd(x,b) address
         SPACE
*---------------------------------------------------------------------*
*        Generate address range used by S, SS, RS and SI instructions *
*---------------------------------------------------------------------*
         SPACE
EI110    DS    0H
         LA    R02,ExecIns1+2       Point to ddd(b)
         BRAS  R14,EvalBD           Generate address into R00
         LR    R14,R00              Start address of altered storage
         LA    R15,0(R15,R14)       End address of altered storage
         J     EI130                Go check address range
         SPACE
*---------------------------------------------------------------------*
*        Generate address range for RX instructions                   *
*---------------------------------------------------------------------*
         SPACE
EI120    DS    0H
         LA    R02,ExecIns1+2       Point to ddd(b)
         IC    R03,XCell+1          Save contents of XCell+1
         MVC   XCell+1(1),ExecIns1+1 ... and replace it
         BRAS  R14,EvalXBD          Generate address into R00
         STC   R03,XCell+1          Restore contents of XCell+1
         LR    R14,R00              Start address of altered storage
         LA    R15,0(R15,R14)       End address of altered storage
         J     EI130                Go test address range for trap
         SPACE
*---------------------------------------------------------------------*
*        Test if storage about to be altered is in a range            *
*        specified by the user in the watchpoint table.               *
*---------------------------------------------------------------------*
         SPACE
EI130    DS    0H
         L     R01,WatchTbl         Address of watch point table
         USING WptEntry,R01         ...
         LA    R02,EI140            Ensure that the watch point table
         O     R02,BitZero          ... is searched in AMODE=31
         BSM   0,R02                ...
         SPACE
EI140    DS    0H
         CL    R04,WptALET          Q. ALETs match?
         JNE   EI150                N. Ignore this range
         LM    R02,R03,WptEntry     Y. Load a watchpoint range
         N     R02,SevenFs             Ensure start range H.O. bit zero
         CLR   R14,R03                 Q. Possible overlap in ranges?
         JH    EI150                   N. Not a possibility
         CLR   R02,R15                 Y. Q. Really an overlap?
         JH    EI150                      N. Go try next range
         CLR   R02,R14                    Y. Q. R02 higher than R14?
         JNL   EI160                         Y. Pass R02 to exit
         LR    R02,R14                       N. Pass R14 to exit
         J     EI160
         SPACE
EI150    DS    0H
         TM    WptStart,X'80'       Q. Last watchpoint entry?
         JO    EI180                Y. No watch point for this address
         LA    R01,WptEntry+Wpt$ELEN   Point to next entry in table
         J     EI140                   and go check it out
         SPACE
*---------------------------------------------------------------------*
*        Invoke watchpoint exit                                       *
*---------------------------------------------------------------------*
         SPACE
EI160    DS    0H
         ST    R02,StoreAddr        Indicate watchpoint exit
         LR    R02,R11              Current instruction pointer
         O     R02,TraceAMODE       Merge in addressing mode bit
         ST    R02,InstrPointer     Store it where exit expects it
         OI    TrcFlag1,Trc$Exit    Indicate user exit active
         L     R15,WptExit          AMODE/Address of watch-point exit
         DROP  R01
         LA    R01,plUserExit       Point to exit parameter list
         BASSM R14,R15              Invoke watch-point routine
         LTR   R15,R15              Q. Good return code from exit?
         JZ    EI170                Y. Go execute the instruction
         OI    TrcFlag1,Trc$EndT    N. Indicate termination of tracing
         SPACE
EI170    DS    0H
         NI    TrcFlag1,255-Trc$Exit User exit no longer active
         BRAS  R12,CloseDS          Spin off output if required
         BRAS  R14,SetFlags         Reprocess user flags
         SPACE
EI180    DS    0H
         LA    R15,EI200            Restore addressing mode to that of
         O     R15,TraceAMODE       ... the traced program
         BSM   0,R15
         EJECT
*---------------------------------------------------------------------*
*        Mark register (pairs) used by the instruction                *
*---------------------------------------------------------------------*
         SPACE
EI200    DS    0H
         XC    ExecReg,ExecReg      Clear register (pairs) used
         CLI   ExecIns1,$B2         Q. X'B2' type instruction?
         JNE   EI240                N. Go check for normal formats
         TM    1(R05),bitRRE        Y. Q. RRE instruction?
         JZ    EI270                   N. Must be S format instruction
         CLI   ExecIns1+1,$IPM         Y. Q. IPM instruction?
         JE    ExecIPM                    Y. Go process the IPM
         SPACE
*---------------------------------------------------------------------*
*        Mark register (pairs) used by RRE instruction                *
*        Note that only some RRE instructions actually use r2         *
*---------------------------------------------------------------------*
         SPACE
         IC    R01,ExecIns1+3       Get byte containing registers
         BRAS  R14,ExecLeft         Get r1
         CLI   ExecIns1+1,$EREG     Q. EREG instruction?
         JE    EI220                Y. Special case
         CLI   ExecIns1+1,$BAKR     Q. BAKR instruction?
         JE    EI210                Y. r2 is used
         CLI   ExecIns1+1,$SAR      Q. SAR instruction?
         JE    EI210                Y. r2 is used
         CLI   ExecIns1+1,$TAR      Q. TAR instruction?
         JE    EI210                Y. r2 is used
         CLI   ExecIns1+1,$IVSK     Q. IVSK instruction?
         JE    EI210                Y. r2 is used
         CLI   ExecIns1+1,$PT       Q. PT instruction?
         JE    EI210                Y. r2 is used
         CLI   ExecIns1+1,$ESTA     Q. ESTA instruction?
         JNE   EI290                N. r2 not used
         SPACE
*---------------------------------------------------------------------*
*        Check ESTA for extraction of the PSW or branch address       *
*---------------------------------------------------------------------*
         SPACE
         IC    R15,XCell+3          rr
         N     R15,OOOOOOOF         r2
         SLL   R15,2                r2*4
         LA    R14,TraceGPRs+3(R15) Point to L.O. byte of r2
         TM    0(R14),03            Q. Want stacked PSW or branch addr?
         JNM   EI210                N. Not our "special" case(s)
         ICM   R02,B'1111',StackPtr Y. Q. Is our stack empty?
         JNZ   ExecESTA                N. Go get data from our stack
         SPACE
*---------------------------------------------------------------------*
*        Get r2 for RRE instruction                                   *
*---------------------------------------------------------------------*
         SPACE
EI210    DS    0H
         BRAS  R14,ExecRight        Get r2
         J     EI290
         SPACE
*---------------------------------------------------------------------*
*        EREG can potentially use ALL registers (however, in most     *
*        cases it won't!). We can safely use one of R01-R14 as R0t if *
*        they are available for use, otherwise even more specialized  *
*        logic will be required to emulate this instruction.          *
*---------------------------------------------------------------------*
         SPACE
EI220    DS    0H
         SLR   R01,R01              Load EREG register specifiers
         IC    R01,ExecIns1+3       ...
         LR    R14,R01              ...
         SRL   R01,4                Isolate r1
         N     R14,OOOOOOOF         Isolate r2
         CLR   R01,R14              Q. Extracting a single register?
         JE    EI290                Y. Standard processing will work!
         SPACE
EI230    DS    0H
         BCTR  R01,0                Decrement starting register ID
         N     R01,OOOOOOOF         Mask H.O. bits in case it wrapped
         CLR   R01,R14              Q. Reached ending register?
         JE    ExecEREG             Y. No registers available to use
         CHI   R01,15               N. Q. Register 15?
         JE    EI230                   Y. Can't use this register
         LTR   R01,R01                 N. Q. Register 0?
         JE    EI230                      Y. Can't use this register
         SLL   R01,4                      N. Shift ID to H.O. nybble
         J     EI320                         Use this register
         SPACE
*---------------------------------------------------------------------*
*        RR instruction, mark register (pairs) used                   *
*---------------------------------------------------------------------*
         SPACE
EI240    DS    0H
         TM    1(R05),bitRR         Q. RR instruction?
         JZ    EI250                N. Try RX, RS and SI
         TM    3(R05),bitFLOAT      Y. Q. Floating point instruction?
         JO    EI290                   Y. No general registers are used
         IC    R01,ExecIns1+1          N. Get register part
         BRAS  R14,ExecLeft               Get r1
         BRAS  R14,ExecRight              Get r2
         CLI   ExecIns1,$SVC              Q. SVC instruction?
         JNE   EI290                      N. Go find register pairs
         TM    UsrFlag1,Flg$Call          Y. Q. Print call information?
         JZ    EI290                         N. Go find register pairs
         OI    UsrFlag1,Flg$PrCurInst        Y. Print this instruction
         J     EI290                            Go find register pairs
         SPACE
*---------------------------------------------------------------------*
*        If an RX or RS instruction, mark register (pairs) used       *
*---------------------------------------------------------------------*
         SPACE
EI250    DS    0H
         TM    1(R05),bitSS         Q. SS/SSE type instruction?
         JO    EI280                Y. Go process it
         TM    1(R05),bitSSI        N. Q. S/SI type instruction?
         JO    EI270                   Y. There is no r1/x2
         IC    R01,ExecIns1+1          N. Must be RX or RS
         TM    3(R05),bitFLOAT            Q. Floating point?
         JO    EI260                      Y. r1 not a general register
         BRAS  R14,ExecLeft               N. Get r1
         TM    2(R05),bitSHIFT               Q. Shift instruction?
         JO    EI270                         Y. No r3 in instruction
         SPACE
EI260    DS    0H
         BRAS  R14,ExecRight        Get x2 (or r3)
         SPACE
EI270    DS    0H                   S/SI instruction (and RS, RX)
         IC    R01,ExecIns1+2
         BRAS  R14,ExecLeft         Get b2
         J     EI290
         SPACE
*---------------------------------------------------------------------*
*        Mark register (pairs) used by SS and SSE instructions        *
*---------------------------------------------------------------------*
         SPACE
EI280    DS    0H
         IC    R01,ExecIns1+2       Get b1
         BRAS  R14,ExecLeft         ...
         IC    R01,ExecIns1+4       Get b2
         BRAS  R14,ExecLeft         ...
         TM    0(R05),bitMVCX       Q. MVCK, MVCP or MVCS?
         JZ    EI290                N. r1/r3 not present then
         IC    R01,ExecIns1+1       Y. Get byte with r1/r3 in it
         BRAS  R14,ExecLeft            Get r1
         BRAS  R14,ExecRight           Get r3
         EJECT
*---------------------------------------------------------------------*
*        Search backwards starting at R10-R11 for a register pair     *
*        which is not used by the instruction to be executed.         *
*                                                                     *
*        There is a maximum of five register pairs looked at, these   *
*        being R02-R03, R04-R05, R06-R07, R08-R09 and R10-R11.        *
*        we cannot use R00-R01, R12-R13 or R14-R15 as they are        *
*        implicitly used by some instructions (i.e. SVC, TRT, etc.)   *
*                                                                     *
*        Since the maximum number of registers specified in any       *
*        instruction format is four, this search should never fail.   *
*---------------------------------------------------------------------*
         SPACE
EI290    DS    0H
         LHI   R01,4                Set maximum loop count to 4
         LA    R02,ExecReg+1(R01)   Addr of first reg pair to look at
         SPACE
EI300    DS    0H
         CLI   0(R02),X'FF'         Q. This register pair used?
         JNE   EI310                N. We can use it then
         BCTR  R02,0                Y. Point to previous register pair
         BRCT  R01,EI300               ... and go check it
         SPACE
*---------------------------------------------------------------------*
*        Chosen temporary base register (R0t) is the even register    *
*        in the register pair, put it into the right nybble of R01    *
*---------------------------------------------------------------------*
         SPACE
EI310    DS    0H
         LA    R01,1(,R01)          R01 + 1 = R0t / 2
         SLL   R01,5                R0t, moved into H.O. nybble
         SPACE
         TM    0(R05),bitACCESS     Q. Access register(s) affected?
         JO    EI320                Y. Use access register logic
         CLI   TraceASC,ARmode      N. Q. In AR ASC mode?
         JE    EI320                   Y. Can't ignore access registers
         SPACE
*---------------------------------------------------------------------*
*        Zap the appropriate bytes in storage which need to use R0t   *
*        and then invoke the (non-AR) instruction execution logic.    *
*---------------------------------------------------------------------*
         SPACE
         STC   R01,Zap1BASR+1       Store register to be used
         SRL   R01,2                R0t*4
         STC   R01,Zap1LA+3         ...
         NI    Zap1STM+2,X'0F'      Clear base register from STM
         OC    Zap1STM+2(1),Zap1BASR+1 ... and replace with new base
         SPACE
         B     Execute1             Go execute the traced instruction
         SPACE
*---------------------------------------------------------------------*
*        Zap the appropriate bytes in storage which need to use R0t   *
*        and then invoke the AR related instruction execution logic.  *
*---------------------------------------------------------------------*
         SPACE
EI320    DS    0H
         MVC   ExecIns2,ExecIns1    Instruction to be executed
         STC   R01,Zap2BASR+1       Store register to be used
         SRL   R01,2                R0t*4
         STC   R01,Zap2LA+3         ...
         SPACE
         NI    Zap2STM+2,X'0F'      Clear base register from STM
         OC    Zap2STM+2(1),Zap2BASR+1 ... and replace with new base
         SPACE
         LR    R00,R01              R0t*4
         SRL   R00,2                R0t
         STC   R00,WorkCL5          R0t in right nybble of a byte
         SLL   R01,2                R0t*16 (i.e. R0t in left nybble)
         SPACE
         NI    ZAP2ST+1,X'F0'       Clear old index register value
         NI    ZAP2ST+2,X'0F'       Ensure base register is zero
         OC    ZAP2ST+1(1),WorkCl5  Insert R0t as INDEX register
         SPACE
         NI    Zap2EAR+3,X'F0'      Clear base register from EAR
         OC    Zap2EAR+3(1),WorkCL5 ... and replace with new base
         SPACE
         OR    R00,R01              R0t in both nybbles of L.O. byte
         STC   R00,Zap2LAM1+1       Update register range in LAM
         NI    Zap2LAM1+2,X'0F'     Clear base register from LAM
         OC    Zap2LAM1+2(1),Zap2BASR+1 ... and replace with new base
         SPACE
         NI    Zap2STAM+2,X'0F'      Clear base register from STAM
         OC    Zap2STAM+2(1),Zap2BASR+1 ... and replace with new base
         SPACE
         NI    Zap2LAM2+2,X'0F'      Clear base register from LAM
         OC    Zap2LAM2+2(1),Zap2BASR+1 ... and replace with new base
         SPACE
         B     Execute2             Go execute the traced instruction
         EJECT
*---------------------------------------------------------------------*
*        These two routines are used to mark 'ExecReg' with the       *
*        register (pairs) used by the instruction to be executed.     *
*---------------------------------------------------------------------*
         SPACE
ExecRight DS   0H
         LR    R02,R01              Move parm (R01) into work register
         N     R02,OOOOOOOF         Mask out all but right nybble
         SRL   R02,1                Divide by two for byte offset
         J     ExecLRCT
         SPACE
ExecLeft DS    0H
         LR    R02,R01              Move parm (R01) into work register
         N     R02,OOOOOOFO         Mask out all but left nybble
         SRL   R02,5                Shift to right nybble & divide by 2
         SPACE
ExecLRCT DS    0H
         LA    R02,ExecReg(R02)     Point to register pair to be used
         MVI   0(R02),X'FF'         ... mark it
         BSM   0,R14                ... and return
         EJECT
*---------------------------------------------------------------------*
*        Process 'Load Multiple' instruction                          *
*---------------------------------------------------------------------*
         SPACE
ExecLM   DS    0H
         LA    R02,ExecIns1+2       Point to source operand
         BRAS  R14,EvalBD           Get address of source (in R00)
         LR    R14,R00              ... and copy to usable address reg
         SPACE
         CLI   TraceASC,ARmode      Q. Are we in AR ASC mode?
         JNE   ExLM010              N. Ignore access registers
         SLR   R01,R01              Y. Get source base register
         IC    R01,ExecIns1+2          ...
         SRL   R01,2                   b*4
         LA    R01,TraceARs(R01)       Address of associated AR
         LAM   AR14,AR14,0(R01)        Load associated AR
         SPACE
ExLM010  DS    0H
         IC    R01,XCell+1          Get LM registers
         LR    R02,R01              Copy here too
         N     R01,OOOOOOFO         Isolate r1
         SRL   R01,2                Mult. by 4 and put in right nybble
         N     R02,OOOOOOOF         Isolate r2
         SLL   R02,2                ... and multiply by four
         SLR   R15,R15              Zero index into source
         SPACE
ExLM020  DS    0H
         L     R00,0(R15,R14)       Load a word from the source
         ST    R00,TraceGPRs(R01)   Store it in the register table
         CLR   R01,R02              Q. LM completed?
         JE    ExLM030              Y. Exit from loop
         LA    R15,4(,R15)          N. Increment source index
         LA    R01,4(,R01)             Increment register table index
         N     R01,OOOOOO3C            Wrap register index if required
         J     ExLM020                 Go load next register
         SPACE
ExLM030  DS    0H
         SLR   R14,R14              Zero the access register
         SAR   AR14,R14             ...
         BSM   0,R03                Return to caller
         EJECT
*---------------------------------------------------------------------*
*        Process a ESTA instruction that extracts the PSW             *
*---------------------------------------------------------------------*
         SPACE
ExecESTA DS    0H
         MVC   WorkCL5(1),0(R14)    Save the function code
         IC    R01,XCell+3          rr
         N     R01,OOOOOOFO         r0
         SRL   R01,4                r1
         TML   R01,X'0001'          Q. Odd register specified as r1?
         JZ    ESTA010              N. Keep processing
         OI    TrcFlag1,Trc$EndT    Y. Disable tracing
         J     End000                  Let S0C6 occur in traced program
         SPACE
ESTA010  DS    0H
         SLL   R01,2                r1*4
         LHI   R00,1                Function = extract PSW
         ESTA  R14,R00              Extract the stacked PSW
         IPM   R00                  Save the condition code
         ST    R14,TraceGPRs(R01)   Save first 1/2 of extracted PSW
         BCTR  R02,0                Backup to last used stack entry
         SLL   R02,2                Multiply by 4 (entry length)
         L     R14,BAKR_Stack(R02)  Load stacked return address
         ST    R14,TraceGPRs+4(R01) ... and update traced registers
         BSM   0,R03                and we're done
         EJECT
*---------------------------------------------------------------------*
*        Process IPM instruction                                      *
*---------------------------------------------------------------------*
         SPACE
ExecIPM  DS    0H
         IC    R15,XCell+3          rr
         N     R15,OOOOOOFO         r0
         SRL   R15,2                r1*4
         LA    R15,TraceGPRs(R15)   A(byte in TraceGPRs to update)
         SPACE
         SR    R01,R01              Set PSW condition code bits to zero
         IPM   R01                  Get current program mask
         SLR   R02,R02              Clear for condition code insertion
         ICM   R02,B'1000',TraceCC  Get "traced" condition code
         SLL   R02,4                Shift condition code to bits 2-3
         OR    R01,R02              OR condition code with program mask
         STCM  R01,B'1000',0(R15)   Save result of IPM
         SPACE
         BSM   0,R03                and we're done
         EJECT
***********************************************************************
*        Pathological case EREG instruction                           *
*---------------------------------------------------------------------*
*        'Execute2' requires use of 2 (addressable) general registers *
*        for processing (R15 and one other). This routine is used for *
*        EREG instructions which extract R01 through R14 (and maybe   *
*        R00 and R15 as well)!                                        *
*                                                                     *
***********************************************************************
         SPACE
ExecEREG DS    0H
         LR    R15,R10              Temporary base to working storage
         PUSH  USING                ...
         DROP  R10                  ...
         USING Tr390$WS,R15         ...
         EREG  R01,R14              Extract (A)R01 through (A)R14
         STM   R01,R14,TraceGPRs+4*1  ... and save
         STAM  AR01,AR14,TraceARs+4*1 ...
         LM    R03,R13,SaveRegs+4*3 Restore our general registers
         LAM   AR01,AR14,HexZeros   Clear out the access registers
         POP   USING                Drop temporary base to WS
         SPACE
         CLI   Xcell+3,X'0E'        Q. Register range 0-14?
         JE    ExER010              Y. (A)R15 not required
         CLI   Xcell+3,X'1E'        N. Q. Register range 1-14?
         JE    ExER010                 Y. (A)R15 not required
         EREG  R15,R15                 N. Extract (A)R15 from stack
         ST    R15,TraceGPRs+4*15         ... and save
         STAM  AR15,AR15,TraceARs+4*15    ...
         SPACE
ExER010  DS    0H
         CLI   Xcell+3,X'1E'        Q. Register range 1-14?
         JE    ExER020              Y. (A)R00 not required
         CLI   Xcell+3,X'1F'        N. Q. Register range 1-15?
         JE    ExER020                 Y. (A)R00 not required
         EREG  R00,R00                 N. Extract (A)R00 from stack
         ST    R00,TraceGPRs              ... and save
         STAM  AR00,AR00,TraceARs         ...
         SPACE
ExER020  DS    0H
         LAM   AR15,AR00,HexZeros   Zero AR15 and AR00
         SPACE
         BSM   0,R03                Return to caller
         TITLE 'Trace Write Routine for User Exits'
***********************************************************************
*                                                                     *
*        Called by user exits to write to our output dataset          *
*                                                                     *
***********************************************************************
         SPACE
PUTR     DS    0H
         STM   R14,R12,12(R13)      Save callers registers
         L     R15,aBASEREGS-PUTR(,R15) Address of base addresses
         LM    R07,R10,0(R15)       Load base registers
         SPACE
         ST    R13,PUTRSAVE+4       Set save area back pointer
         LA    R15,PUTRSAVE         Point to new save area
         ST    R15,8(,R13)          Set callers forward pointer
         LR    R13,R15              Set up new save area pointer
         SPACE
         BRAS  R12,CloseDS          Spin off output if required
         TR    PLINE,EBCDIC         Remove any non-display chars
         BRAS  R14,Write            Write out line
         SPACE
         SLR   R15,R15              Zero return code
         L     R13,4(,R13)          Restore callers R13
         ST    R15,8(,R13)          Clear forward pointer
         L     R14,12(,R13)         Load return address
         LM    R00,R12,20(R13)      Restore caller's registers
         OI    15(R13),X'01'        Indicate exit from here
         BSM   0,R14                Return to the user exit
         TITLE 'Storage Dump Routine for User Exits'
***********************************************************************
*                                                                     *
*         Produce formatted dump of storage                           *
*         On entry:                                                   *
*              R00 - Address of first byte to be dumped               *
*              R01 - Number of fullwords to dump                      *
*                                                                     *
***********************************************************************
         SPACE
DumpVS   DS    0H
         STM   R14,R12,12(R13)      Save callers registers
         L     R15,aBASEREGS-DumpVS(,R15) Get pointer to base addresses
         LM    R07,R10,0(R15)       Load base registers
         SPACE
         ST    R13,PUTRSAVE+4       Chain save areas
         LA    R15,PUTRSAVE         ...
         ST    R15,8(,R13)          ...
         LR    R13,R15              ...
         SPACE
         LR    R02,R00              Load dump address
         LR    R03,R01              Move number of words to dump
         SLR   R04,R04              Initialise offset to zero
         SPACE
         L     R14,0(,R02)          First word to be dumped
         LA    R14,1(,R14)          Ensure not equal
         ST    R14,WorkCL32         Save in last line dumped save area
         SPACE
Dmp010   DS    0H
         LHI   R15,8                Number of words per line
         SPACE
Dmp020   DS    0H
         CLR   R03,R15              Q. More that a full line to dump?
         JNH   Dmp040               N. Dump last line
         LA    R14,0(R04,R02)       Y. Point to dump data
         CLC   WorkCL32,0(R14)         Q. Same as last line?
         JNE   Dmp030                  N. Go dump it
         MVC   PrD$HexData(4),SAME     Y. Indicate same as previous
         LA    R04,4*8(,R04)              Increment offset
         SLR   R03,R15                    Decrement number of words
         J     Dmp020                     Ignore this line
         SPACE
Dmp030   DS    0H
         MVC   WorkCL32,0(R14)      Reset last line
         SPACE
Dmp040   DS    0H
         CLC   PrD$HexData(4),SAME  Q. "Same" lines found?
         JNE   Dmp050               N. Bif not
         BRAS  R14,Write            Y. Write out the "SAME" line
         SPACE
Dmp050   DS    0H
         MVI   PrD$Offset-1,C'+'    Offset prefix character
         LR    R00,R04              Load offset
         BRAS  R14,HexToEBC         Convert to display hex
         STCM  R00,B'0011',PrD$Offset Move offset to print line
         STCM  R01,15,PrD$Offset+2  ...
         SPACE
         MVI   PrD$Address-1,C'@'   Address prefix character
         LA    R00,0(R04,R02)       Load current dump address
         BRAS  R14,HexToEBC         Convert to display hex
         STM   R00,R01,PrD$Address  Store in print line
         SPACE
         LHI   R15,8                Number of words per line
         LA    R11,PrD$HexData      Point to hex data area
         SPACE
Dmp060   DS    0H
         L     R00,0(R04,R02)       Load data byte
         LHI   R14,8                Calculate offset within EBCDIC
         SLR   R14,R15              ... data area for current word
         SLL   R14,2                ...
         ST    R00,PrD$EBCDIC(R14)  ... and store EBCDIC representation
         BRAS  R14,HexToEBC         Format hex data
         STM   R00,R01,0(R11)       Store data in print line
         LA    R11,L'PrD$HexData(,R11) Bump hex output area pointer
         LA    R04,4(,R04)          Bump offset value
         BCTR  R03,0                Decrement number of word left
         LTR   R03,R03              Q. Any words left?
         JNP   Dmp070               N. Drop out of loop
         BRCT  R15,Dmp060           Y. Loop up to 8 times
         SPACE
Dmp070   DS    0H
         TR    PrD$EBCDIC,EBCDIC    Replace any non-printable data
         BRAS  R14,Write            Write out the line
         LTR   R03,R03              Q. Any more words to dump?
         JNZ   Dmp010               Y. Start new line
         SPACE
         SLR   R15,R15              Zero return code
         L     R13,4(,R13)          Restore callers r13
         ST    R15,8(,R13)          Zero save area forward pointer
         L     R14,12(,R13)         Load return address
         LM    R00,R12,20(R13)      Restore callers registers
         OI    15(R13),X'01'        Set return indicator
         BSM   0,R14                ... and return
         SPACE 3
aBASEREGS DC   A(aBASE)             Address of base addresses
         TITLE 'High Level Write Routine'
***********************************************************************
*        Routine to output the print line                             *
*---------------------------------------------------------------------*
*        Also keeps track of the line count on a page so we know when *
*        to generate page headers.                                    *
*                                                                     *
***********************************************************************
         SPACE
Write    DS    0H
         ST    R14,WRSAV            Save return address
         TM    UsrFlag1,Flg$PrHdr   Q. Page headers to be printed?
         JZ    Write050             N. Bif not
         CLI   PrL$CCB,C' '         Y. Q. Single spacing?
         JE    Write040                Y. Space 1 line
         CLI   PrL$CCB,C'0'            N. Q. Double spacing?
         JE    Write030                   Y. Space 2 lines
         CLI   PrL$CCB,C'-'               N. Q. Triple spacing?
         JE    Write020                      Y. Space 3 line
         CLI   PrL$CCB,C'+'                  N. Q. Overstriking?
         JE    Write050                         Y. Don't count line
         CLI   PrL$CCB,C'1'                     N. Q. New page?
         JE    Write010                            Y. Generate header
         MVI   PrL$CCB,C' '                        N. Force single
         J     Write040                               ... spacing
         SPACE
Write010 DS    0H
         ZAP   LINE#,cpZero         Zero number of lines left on page
         J     Write040             Go force new page
         SPACE
Write020 DS    0H
         SP    LINE#,cpOne          Decrement line counter
         SPACE
Write030 DS    0H
         SP    LINE#,cpOne          Decrement line counter
         SPACE
Write040 DS    0H
         SP    LINE#,cpOne          Decrement line counter
         JP    Write050             Go do write if it will fit on page
         MVC   SAVELINE,PLINE       Save line to be printed
         MVI   PLINE,C' '           ... and clear printline
         MVC   PrL$Data(L'PrL$Data),PLINE ...
         BRAS  R14,PRINTHDR         Print page headers
         MVC   PLINE,SAVELINE       Restore original line
         MVI   PrL$CCB,C'0'         Double space after headers
         SPACE
Write050 DS    0H
         BRAS  R14,PutLine          Write out data line
         SPACE
         L     R14,WRSAV            Get return address
         BSM   0,R14                Return to caller
         TITLE 'Write Out a Print Line to the Output Dataset'
***********************************************************************
*        Routine which does the actual PUT                            *
*---------------------------------------------------------------------*
*        Also handles spinoff and opening of the output dataset       *
*                                                                     *
***********************************************************************
         SPACE
PutLine  DS    0H
         ST    R14,PLSAV            Save return address
         IAC   R04                  Q. In primary ASC mode?
         JZ    PutL010              Y. We're OK as is
         SAC   0                    N. Switch to primary ASC mode
         SPACE
PutL010  DS    0H
         TM    DCBOFLGS,DCBOFOPN    Q. Trace dataset opened yet?
         JO    PutL200              Y. No need to open it again
         ICM   R15,B'1111',aUserDDN N. Q. Did caller supply a DD name?
         JZ    PutL020                 N. Default is 'SYSTRACE'
         MVC   DDNAME,0(R15)           Y. Use supplied ddname
         SPACE
*---------------------------------------------------------------------*
*        Scan the Task I/O Table for the trace output ddname          *
*---------------------------------------------------------------------*
         SPACE
PutL020  DS    0H
         L     R01,FLCCVT-PSA       CVT address
         L     R01,CVTTCBP-CVT(,R01) Address of TCB pointers
         L     R01,4(,R01)          Current TCB address
         L     R01,TCBTIO-TCB(,R01) Address of TIOT
         LHI   R15,TIOENTRY-TIOT1   Displacement of 1st TIOT entry
         USING TIOENTRY,R01         Map TIOT entry
         SPACE
PutL030  DS    0H
         ALR   R01,R15              Bump to first/next entry
         ICM   R15,B'0001',TIOELNGH Q. Length of this TIOT entry zero?
         JZ    PutL040              Y. End of table reached
         CLC   TIOEDDNM,DDNAME      N. Q. Found our DD name in TIOT?
         JNE   PutL030                 N. Go look at next TIOT entry
         DROP  R01
         SPACE
         TM    TrcFlag1,Trc$SPIN    Q. Spin off old old dataset?
         JZ    PutL100              N. Go open reopen it
         SLR   R00,R00              Y. Indicate SpinOff request
         BRAS  R14,SpinOff             Attempt to spin off old output
         NI    TrcFlag1,255-Trc$SPIN   ... Clear spin off flag
         J     PutL100                 ... and go open dataset
         SPACE
*---------------------------------------------------------------------*
*        DDname is not in the task I/O table, tell user and quit      *
*---------------------------------------------------------------------*
         SPACE
PutL040  DS    0H
         TM    TrcFlag2,Trc$NALC    Q. Allocate DD name if not found?
         JO    PutL050              N. Must be an error then
         LHI   R00,1                Y. Indicate allocation request
         BRAS  R14,SpinOff             Allocate the output DD name
         J     PutL100                 ... and go OPEN the dataset
         SPACE
PutL050  DS    0H                   Move in DDNAME causing error
         MVC   cMsg008+15(L'DCBDDNAM),DDNAME
         WTO   TEXT=Msg008,MF=(E,cplWTO) Tell user about it
         OI    TrcFlag1,Trc$NoDD+Trc$EndT Indicate no DD name present  X
                                    and quit out of trace at mainline
         TM    TrcFlag1,Trc$Exit    Q. User exit active?
         JO    PutL900              Y. Return to exit
         J     End900               N. Return from trace
         SPACE
*---------------------------------------------------------------------*
*        Open the dataset, ABEND on OPEN failure                      *
*---------------------------------------------------------------------*
         SPACE
PutL100  DS    0H
         MVC   DCBDDNAM,DDNAME
         MVI   cplOPEN,X'80'        Indicate single entry in list
         OPEN  (dcbTRACE,OUTPUT),MODE=31,MF=(E,cplOPEN)
         SPACE
         TM    DCBOFLGS,DCBOFOPN    Q. OPEN successful?
         JO    PutL200              Y. Continue
***                                 N. Move in DDNAME causing error
         MVC   cMsg007+38(L'DCBDDNAM),DDNAME
         LA    R02,Msg007              Point to WTO text
         J     WTOABEND                Go issue WTO and ABEND
         SPACE
*---------------------------------------------------------------------*
*        Write the line and return to caller                          *
*---------------------------------------------------------------------*
         SPACE
PutL200  DS    0H
         PUT   dcbTRACE,PLINE       Write out the line
         SPACE
PutL900  DS    0H
         MVI   PLINE,C' '           One blank to start
         MVC   PrL$Data(L'PrL$Data),PLINE Propagate the blank
         SPACE
         TML   R04,X'0300'          Q. Were we in primary ASC mode?
         JZ    PutL990              Y. Nothing to restore then
         SAC   0(R04)               N. Switch back to entry ASC mode
         SPACE
PutL990  DS    0H
         L     R14,PLSAV            Get return address
         BSM   0,R14                Return to caller
         TITLE 'Close the Output Dataset'
***********************************************************************
*                                                                     *
*        This routine isolates closing of the output dataset into a   *
*        single location within the program (excluding ESTAE routine) *
*                                                                     *
***********************************************************************
         SPACE
CloseDS  DS    0H
         TM    UsrFlag1,Flg$Spin    Q. Spin off (close) output DS?
         BZR   R12                  N. Do nothing, just return
         TM    DCBOFLGS,DCBOFOPN    Y. Q. Is dataset open?
         JZ    Close020                N. No need to close it then
         IAC   R04                     Y. Q. In primary ASC mode?
         JZ    Close010                   Y. We're OK as is
         SAC   0                          N. Switch to primary ASC mode
         SPACE
Close010 DS    0H
         MVI   cplCLOSE,X'80'       Indicate single entry in list
         CLOSE (dcbTRACE),MODE=31,MF=(E,cplCLOSE)
         TML   R04,X'0300'          Q. Were we in primary ASC mode?
         JZ    Close020             Y. Nothing to restore then
         SAC   0(R04)               N. Switch back to entry ASC mode
         SPACE
Close020 DS    0H
         ZAP   LINE#,cpZero         Reset number of line left on page
         ZAP   PAGE#,cpZero         Reset page counter
         NI    UsrFlag1,255-Flg$Spin Turn off user SpinOff flag
         OI    TrcFlag1,Trc$SPIN    Turn on internal SpinOff flag
         SPACE
         BSM   0,R12                Return to caller
         TITLE 'Spin Off Output Dataset if Sysout Dataset'
***********************************************************************
*                                                                     *
*        Spin off the output dataset if it is of type SYSOUT          *
*                                                                     *
***********************************************************************
         SPACE
SpinOff  DS    0H
         ST    R14,SPSAV            Save return address
         SPACE
*---------------------------------------------------------------------*
*        Check if output dataset is a SYSOUT one                      *
*---------------------------------------------------------------------*
         SPACE
         LA    R02,SVC99RB          Point to DYNALLOC request block
         USING S99RB,R02            Set base
         XC    S99RB(lenS99RB),S99RB Zero the request block
         MVI   S99RBLN,lenS99RB     Set length field
         LTR   R00,R00              Q. Allocate only request?
         JNZ   Spin200              Y. Go do allocate
         TM    UsrFlag2,Flg$GDSN    N. Q. Generated output DS name?
         JO    Spin100                 Y. Deallocate it
         MVI   S99VERB,S99VRBIN        N. Information request
         LA    R15,plTestAlloc            Parameters for SYSOUT test
         ST    R15,S99TXTPP               Set parameter list pointer
         LA    R01,S99PARM                Parameter list for SVC 99
         DYNALLOC ,                       Issue the request
         LTR   R15,R15                    Q. Good result?
         JNZ   Spin900                    N. Go issue error message
         CLI   TESTPARM,X'10'             Y. Q. SYSOUT data set?
         JNE   Spin999                       N. Ignore it
         SPACE
         SPACE
*---------------------------------------------------------------------*
*        Deallocate current output dataset                            *
*---------------------------------------------------------------------*
         SPACE
Spin100  DS    0H
         LA    R15,plDeallocate     Get deallocate parameter list
         ST    R15,S99TXTPP         Put in request block
         MVI   S99VERB,S99VRBUN     Deallocate request
         LA    R01,S99PARM          Parameter list for SVC 99
         DYNALLOC ,                 De-allocate the DD
         LTR   R15,R15              Q. Good return?
         JNZ   Spin900              N. Go issue error message
         SPACE
Spin200  DS    0H
         LA    R15,plAllocate       Allocation parameter list
         ST    R15,S99TXTPP         Put in request block
         TM    UsrFlag2,Flg$GDSN    Q. Generated output DS name?
         JZ    Spin210              N. Allocate sysout dataset
         BRAS  R14,GENDSN           Y. Generate the dataset name
         LA    R15,plDSN_Allocate      Load text pointers address
         ST    R15,S99TXTPP            Put in request block
         MVC   tu$DDNAM,DDNAME         Move in correct DDNAME
         SPACE
Spin210  DS    0H
         MVI   S99VERB,S99VRBAL     Indicate allocate request
         LA    R01,S99PARM          Parameter list for SVC 99
         DYNALLOC ,                 (Re)allocate dataset
         LTR   R15,R15              Q. Successful allocation?
         JZ    Spin999              Y. Return to caller
         SPACE
*---------------------------------------------------------------------*
*        Non-zero return code from DYNALLOC, tell user and ABEND      *
*---------------------------------------------------------------------*
         SPACE
Spin900  DS    0H
         LR    R00,R15              Convert SVC 99 return code for msg
         BRAS  R14,HexToEBC         ...
         STCM  R01,B'0011',cMsg005+35
         SPACE
         IC    R00,S99VERB          Display DYNALLOC verb
         BRAS  R14,HexToEBC         ...
         STCM  R01,B'0011',cMsg005+28
         SPACE
         L     R00,S99ERROR         Load error and info codes
         BRAS  R14,HexToEBC         Convert to display
         STCM  R00,15,cMsg005+45    Put error code in WTO message
         STCM  R01,15,cMsg005+56    Put reason code in WTO message
         MVC   cMsg005+69(L'DCBDDNAM),DDNAME
         LA    R02,Msg005           Point to WTO text
         J     WTOABEND             Go issue WTO and ABEND
         DROP  R02
         SPACE
*---------------------------------------------------------------------*
*        Return to caller                                             *
*---------------------------------------------------------------------*
         SPACE
Spin999  DS    0H
         L     R14,SPSAV            Load return address
         BSM   0,R14                and return
         TITLE 'Generate Name for Output Dataset'
***********************************************************************
*        Allocate cataloged dataset to hold TRACE390 output           *
*---------------------------------------------------------------------*
*        Allocate a new (cataloged) dataset to the output DDNAME      *
*        to which the trace output will be written in the IMS/DC      *
*        (online) environment.                                        *
*        This must be done as most people do NOT have access to the   *
*        IMS message region SYSOUT datasets via SDSF.                 *
*                                                                     *
***********************************************************************
         SPACE
GENDSN   DS    0H
         ST    R14,GDSAV            Save return address
         TIME  ,                    Get the date and time
         L     R15,FLCCVT-PSA       CVT address
         L     R15,CVTTCBP-CVT(,R15) Address of TCB pointers
         L     R15,4(,R15)          Current TCB address
         L     R15,TCBTIO-TCB(,R15) Address of TIOT
         MVC   tu$DSN+13(8),0(R15)  Move in address space name
         LA    R15,tu$DSN+13+7      End of address space name field
         SPACE
GDSN010  DS    0H
         CLI   0(R15),C' '          Q. Is it a blank?
         JNE   GDSN020              N. Last character found
         BRCT  R15,GDSN010          Y. Loop 'til non-blank found
         SPACE
GDSN020  DS    0H
         CLI   0(R15),C'.'          Q. Is it a delimiter?
         JE    GDSN030              Y. Don't set another one
         LA    R15,1(,R15)          N. Bump pointer
         MVI   0(R15),C'.'             and insert delimiter
         SPACE
GDSN030  DS    0H
         LA    R15,1(,R15)          Bump past delimiter
         STCM  R01,B'0111',WorkDblW Store date for UNPK
         UNPK  0(6,R15),WorkDblW(3) Unpack julian date into DSN
         MVI   0(R15),C'D'          Insert 'D' into day qualifier
         MVI   6(R15),C'.'          Append qualifier character
         LA    R15,7(,R15)          Bump past date qualifier field
         SPACE
         LR    R14,R00              Save time
         SRL   R00,4                Shift off tenths of a second
         ST    R00,WorkDblW         Place in storage for UNPK
         OI    WorkDblW+3,X'0F'     Ensure F sign
         UNPK  0(7,R15),WorkDblW(4) Unpack time into dataset name
         MVI   0(R15),C'T'          Insert 'T' into the time qualifier
         SPACE
         MVI   7(R15),C'.'          Insert separator
         MVI   8(R15),C'S'          Insert S into sequence qualifier
         SPACE
         SLR   R14,R14              Ensure H.O. 3 bytes area zero
         IC    R14,DSNSEQ#          Get DSN sequence number
         LA    R14,1(,R14)          Increment sequence number
         STC   R14,DSNSEQ#          Save it back
         CLI   DSNSEQ#,X'0A'        wrap to 0 if it exceeds 9
         JNE   GDSN040
         MVI   DSNSEQ#,X'00'
         IC    R14,DSNSEQ#          reset r14 to 0
         SPACE
GDSN040  DS    0H
         SLL   R00,4                Make room for sequence number
         ALR   R00,R14              Add DSN sequence number
         SLL   R00,4                Make room for sign
         ST    R00,WorkDblW         Place in storage for UNPK
         OI    WorkDblW+3,X'0F'     Ensure F sign
         UNPK  9(3,R15),WorkDblW(4) Unpack sequence number
         LA    R15,12(,R15)         Bump to end of dataset name
         SPACE
         LA    R01,tu$DSN           Calculate then length of the
         SLR   R15,R01              ... dataset name
         STH   R15,tu$DSNL          Store in SVC 99 DSN length parm
         SPACE
         L     R14,GDSAV            Load return address
         BSM   0,R14
         TITLE 'Format Page Header'
***********************************************************************
*                                                                     *
*        Print field names for fields printed                         *
*                                                                     *
***********************************************************************
         SPACE
PRINTHDR DS    0H
         ST    R14,PHSAV            Save return address
         MVC   PrL$DATA(lenID),TRACE390+4+1
         TM    TrcFlag1,Trc$SPIN    Q. Dataset to be spinned off
         JZ    PHDR010              N. Bif not
         BRAS  R14,TimeStamp           Obtain formatted date and time
         SPACE
PHDR010  DS    0H
         AP    PAGE#,cpOne          Increment page counter
         ZAP   LINE#,PageLen        Line remaining on page
         MVC   PrL$DATE,PageDate    Current date
         MVC   PrL$TIME,PageTime    Time (when dataset was opened)
         MVC   PrL$PAGE,=C'Page'
         OI    PAGE#+L'PAGE#-1,X'0F' Ensure correct sign
         UNPK  PrL$PageNo,PAGE#     Page number
         MVI   PrL$CCB,C'1'         Skip to top of new page
         BRAS  R14,PutLine          Print the line
         SP    LINE#,cpOne          Decrement remaining lines
         TM    TrcFlag2,Trc$NoIH    Q. Print instruction fields?
         JO    PHDR900              N. Finished
         SPACE
         MVC   PrL$ILC,=CL8'PSW-Bits'       PSW bits 32-63
         MVI   PrL$ASC,C'A'                 ASC mode
         MVI   PrL$CondCode,C'C'            Condition code
         MVC   PrL$Reg1,=CL8'  DR1   '      Double register one
         MVC   PrL$DR1,=CL8' DR1+1  '       Second register in pair
         MVC   PrL$DR2A,=CL8'  DR2   '      Double register two
         MVC   PrL$DR2B,=CL8' DR2+1  '      Second register in pair
         BRAS  R14,PutLine                  Print the line
         SP    LINE#,cpOne                  Decrement remaining lines
         SPACE
         MVC   PrL$ILC,=CL8' 32-63  '       PSW bits 32-63
         MVC   PrL$ObjCode,=CL12'Object-Code' Instruction in hex
         MVI   PrL$ASC,C'S'                 ASC mode
         MVI   PrL$CondCode,C'C'            Condition codes
         MVC   PrL$Mnemonic,=CL6'OpCode'    Instruction Mnemonic
         MVC   PrL$Operands(8),=CL8'Operands' Instruction operands
         MVC   PrL$Reg1,=CL8'  Reg1  '      Contents of first register
         MVC   PrL$Reg2,=CL8'  Reg2  '      Contents of second register
         MVC   PrL$Address1,=CL8'Address1'  First operand address
         MVC   PrL$Data1,=CL8'Operand1'     First operand data
         MVC   PrL$Double1,=CL8'Operand1'   First operand data also
         MVC   PrL$Address2,=CL8'Address2'  Second operand address
         MVC   PrL$Data2,=CL8'Operand2'     Second operand data
         MVC   PrL$Double2,=CL8'Operand2'   Second operand data also
         BRAS  R14,PutLine                  Print the line
         SP    LINE#,cpOne                  Decrement remaining lines
         SPACE
PHDR900  DS    0H
         MVI   PrL$CCB,C'0'         Double space next line
         L     R14,PHSAV            Load return address
         BSM   0,R14                ... and return
         SPACE 2
         LTORG ,
         TITLE 'Print Instruction Counts'
***********************************************************************
*        Print contents of the instruction count table entries        *
*---------------------------------------------------------------------*
*        Note that handling of x'01' prefixed opcodes is somewhat     *
*        kludgy and will require rewriting if additional x'01' codes  *
*        are added to the architecture.                               *
*                                                                     *
***********************************************************************
         SPACE
PRINTCNT DS    0H
         ST    R14,PCSAV            Save return address
         ICM   R06,B'1111',InstrTbl Q. Instruction count table present?
         JZ    PIC900               N. Nothing to do then
         OI    TrcFlag2,Trc$NoIH    Y. No instruction field headers
         LA    R15,PIC010              Process table in AMODE=31
         O     R15,BitZero             ...
         BSM   0,R15                   ...
         USING In#Entry,R06
         SPACE
PIC010   DS    0H
         L     R14,In#Table         Address of instruction count table
         ZAP   WorkPL8,cpZero       Zero cumulative instruction count
         LA    R15,256+256+16+4     Loop counter
         SPACE
PIC020   DS    0H
         ICM   R00,B'1111',0(R14)   Q. Anything to count?
         JZ    PIC040               N. Ignore it then
         CVD   R00,WorkDblW         Y. Convert to packed
         CP    WorkDblW,cpZero         Q. Number negative?
         JNL   PIC030                  N. Use it as is
         AP    WorkDblW,TwoTo32        Y. Make it unsigned, add 2**32
         SPACE
PIC030   DS    0H
         AP    WorkPL8,WorkDblW     Add to total count of instructions
         SPACE
PIC040   DS    0H
         LA    R14,4(,R14)          Bump to next counter
         BRCT  R15,PIC020           Repeat for each counter
         SPACE
         MVC   PLINE(L'PCHEADER),PCHEADER
         MVC   WorkCL16(L'EDMask12),EDMask12  Move in edit mask
         ED    WorkCL16(L'EDMask12),WorkPL8+2 Format instruction count
         MVC   PrL$Data+5(11),WorkCL16+1
         L     R00,In#Start         Count range start address
         BRAS  R14,HexToEBC         Convert to display
         STM   R00,R01,PrL$Data+56  ... and place into title
         L     R00,IN#END           Count range end address
         BRAS  R14,HexToEBC         Convert to display
         STM   R00,R01,PrL$Data+65  ... and place into title
         MVC   PrL$Data+75(L'IN#IDENT),IN#IDENT
         BRAS  R14,Write            Print title line
         CP    WorkPL8,cpZero       Q. Any instrns executed in range?
         JZ    PIC300               N. Skip this entry
         SLR   R05,R05              Y. Initialise loop counter
         SPACE
*---------------------------------------------------------------------*
*        The following logic assumes OpCodes, B2codes and A7codes are *
*        defined back-to-back in contiguous storage.                  *
*---------------------------------------------------------------------*
         SPACE
PIC100   DS    0H
         LR    R15,R05              R15 := R05 * 6
         ALR   R15,R15              ...
         ALR   R15,R05              ...
         ALR   R15,R15              ...
         AL    R15,aOpCodes         Address of instruction mnemonic
         CLI   0(R15),C'A'          Q. Valid instruction?
         JL    PIC200               N. Ignore it then
         LR    R01,R05              Y. Instruction 1st/2nd byte value
         ICM   R01,B'0010',HexZeros    Only interested in L.O. byte
         SLL   R01,1                   Multiply by 2 for entry length
         LR    R02,R05                 Current index value
         SRL   R02,8                   Divide by 256 for table number
         SLL   R02,2                   Multiply by 4 for address length
         L     R14,aOpIndex(R02)       Address of attribute index table
         LH    R01,0(R01,R14)          Load attribute index value
         L     R14,aOpFlags            Attribute table address
         LA    R14,0(R01,R14)          Attributes for this instruction
         TM    3(R14),bitFLOAT         Q. Floating point instruction?
         JZ    PIC110                  N. Must be counted
         TM    UsrFlag2,Flg$NCFP       Y. Q. FP instructions counted?
         JO    PIC200                     N. Ignore this one then
         SPACE
PIC110   DS    0H
         LHI   R14,4-1              Max. entries per line minus one
         LA    R03,PrL$Data+2       Point to first entry on line
         USING CNT$FLD,R03
         SPACE
PIC120   DS    0H
         CLI   CNT$MNEM,C' '        Q. This entry used?
         JE    PIC130               N. Go use it
         LA    R03,CNT$FLD+CNT$LEN  Y. Bump to next entry
         BRCT  R14,PIC120              and go check it out
         SPACE
PIC130   DS    0H
         LR    R14,R05              Offset to instruction count
         SLL   R14,2                ...
         AL    R14,In#Table         Address of instruction count
         ICM   R02,B'1111',0(R14)   Q. Counter zero?
         JNZ   PIC140               N. Go process it
         TM    UsrFlag2,Flg$NPNE    Y. Q. Suppress zero counts?
         JO    PIC200                  Y. Ignore this instruction then
         SPACE
PIC140   DS    0H
         MVC   CNT$MNEM,0(R15)      Copy mnemonic to print line
         LR    R00,R05              Convert opcode to display
         CHI   R00,256+256+16       Q. This an x'01' opcode?
         JL    PIC150               N. Try x'A7' opcode
         AHI   R00,-16              Y. Compensate for x'A7' offset
         ICM   R00,B'0010',=AL1($01)   Set x'01' prefix
         J     PIC170
         SPACE
PIC150   DS    0H
         CHI   R00,512              Q. This an x'A7' opcode?
         JL    PIC160               N. Try x'B2' opcode
         ICM   R00,B'0010',=AL1($A7)
         J     PIC170
         SPACE
PIC160   DS    0H
         CHI   R00,256              Q. This a x'B2' opcode?
         JL    PIC180               N. Must be a 2 byte opcode
         ICM   R00,B'0010',=AL1($B2)
         SPACE
PIC170   DS    0H
         BRAS  R14,HexToEBC         Convert opcode to display hex
         ST    R01,CNT$OPCD         Move opcode to print line
         J     PIC190
         SPACE
PIC180   DS    0H
         BRAS  R14,HexToEBC         Convert opcode to display hex
         STH   R01,CNT$OPCD         Move opcode to print line
         SPACE
PIC190   DS    0H
         CVD   R02,WorkDblW         Convert to packed
         LA    R02,CNT$ICNT         Load pointer to display areas
         BRAS  R14,PERCENT          Format count and percentages
         SPACE
         CLI   PrL$Data+2+(4-1)*CNT$LEN,C' '
*                                   Q. Print line full?
         JE    PIC200               N. Defer printing it
         MVI   PrL$Data,C'+'        Y. Mark line as instruction counts
         BRAS  R14,Write               and go print it
         SPACE
PIC200   DS    0H
         LA    R05,1(,R05)          Increment instruction loop counter
         CHI   R05,256+256+16+4     Q. End of instructions?
         JL    PIC100               N. Go process next instruction
         CLI   PrL$Data+2,C' '      Y. Q. Partial print line built?
         JE    PIC300                  N. Finished with this range
         MVI   PrL$Data,C'+'           Y. Mark line as instr. counts
         BRAS  R14,Write                  Print the last (partial) line
         DROP  R03
         SPACE
PIC300   DS    0H
         TM    In#Entry,X'80'        Q. Last entry in table?
         JO    PIC900                Y. All finished then
         LA    R06,In#Entry+IN#$ELEN N. Point to next entry in table
         J     PIC010                   and go process it
         DROP  R06
         SPACE
PIC900   DS    0H
         NI    TrcFlag2,255-Trc$NoIH Reset header flag
         L     R14,PCSAV            Load return address
         BSM   0,R14                and return
         TITLE 'Print Execution Profiler Data'
***********************************************************************
*                                                                     *
*        Print data in execution profile table                        *
*                                                                     *
***********************************************************************
         SPACE
PROFILER DS    0H
         ST    R14,PFSAV            Save return address
         ICM   R06,B'1111',EProfTbl Q. Profiler table present?
         JZ    Prof900              N. Nothing to do then
         OI    TrcFlag2,Trc$NoIH    Y. No instruction field headers
         LA    R15,Prof010             Process table in AMODE=31
         O     R15,BitZero             ...
         BSM   0,R15                   ...
         USING PrfEntry,R06
         SPACE
*---------------------------------------------------------------------*
*        Loop for each entry, first print header line                 *
*---------------------------------------------------------------------*
         SPACE
Prof010  DS    0H
         MVC   PLINE(L'EPHEADER),EPHEADER
         L     R00,PrfStart         Profiler range start address
         BRAS  R14,HexToEBC         Convert to display
         STM   R00,R01,PrL$Data+46  ... and place into title
         L     R00,PRFEND           Profiler range end address
         BRAS  R14,HexToEBC         Convert to display
         STM   R00,R01,PrL$Data+55  ... and place into title
         MVC   PrL$Data+65(L'PRFIDENT),PRFIDENT
         BRAS  R14,Write            Print title line
         SPACE
*---------------------------------------------------------------------*
*        Find total number of instructions counted in range           *
*---------------------------------------------------------------------*
         SPACE
         L     R15,PRFEND           Calculate size of profile range
         SL    R15,PrfStart         ...
         SLR   R14,R14              Clear top half of dividend
         L     R01,PrfIntvl         Get sub-interval size
         DR    R14,R01              Calculate number of cells in table
         LTR   R14,R14              Q. Any remainder?
         JZ    Prof020              N. Quotient is correct value
         LA    R15,1(,R15)          Y. Add one for partial cell
         SPACE
Prof020  DS    0H
         ST    R15,#Cells           Save number of cells
         ZAP   WorkPL8,cpZero       Zero cumulative counts for range
         L     R14,PrfTable         Point to data table
         SPACE
Prof030  DS    0H
         ICM   R00,B'1111',0(R14)   Q. Anything to count?
         JZ    Prof050              N. Ignore it then
         CVD   R00,WorkDblW         Y. Convert to packed
         CP    WorkDblW,cpZero         Q. Number negative?
         JNL   Prof040                 N. Use as is
         AP    WorkDblW,TwoTo32        Y. Make it unsigned, add 2**32
         SPACE
Prof040  DS    0H
         AP    WorkPL8,WorkDblW     Add to total count
         SPACE
Prof050  DS    0H
         LA    R14,4(,R14)          Bump to next counter
         BRCT  R15,Prof030          Repeat for each counter
         SPACE
         XC    ZERO1RST,ZERO1RST    Zero first zero count address
         XC    ZEROLAST,ZEROLAST    Zero last zero count address
         XC    ZEROFSET,ZEROFSET    Zero offset
         SLR   R03,R03              Initialise cell id
         SPACE
*---------------------------------------------------------------------*
*        Loop for each cell                                           *
*---------------------------------------------------------------------*
         SPACE
Prof060  DS    0H
         LR    R15,R03              Cell id
         SLR   R14,R14              Clear top word
         M     R14,PrfIntvl         Calculate offset
         LR    R02,R15              Generate start address
         AL    R02,PrfStart         ...
         LR    R12,R02              Generate end address
         AL    R12,PrfIntvl         ...
         BCTR  R12,0                ...
         SPACE
         LR    R01,R03              Cell id
         SLL   R01,2                Multiply by cell size
         AL    R01,PrfTable         Address of cell
         ICM   R05,B'1111',0(R01)   Q. Count zero?
         JNZ   Prof080              N. Go process it
         ICM   R14,B'1111',ZERO1RST Y. Q. First zero address available?
         JNZ   Prof070                 Y. Leave it
         ST    R02,ZERO1RST            N. Save start address
         ST    R15,ZEROFSET               ... and offset
         SPACE
Prof070  DS    0H
         ST    R12,ZEROLAST         Save new end address
         J     Prof100
         SPACE
Prof080  DS    0H
         ICM   R00,B'1111',ZERO1RST Q. Zero range to print?
         JZ    Prof090              N. Go do normal print
         BRAS  R14,HexToEBC         Y. Format start address
         STM   R00,R01,PrL$Data+11     ...
         L     R00,ZEROLAST            Format end address of range
         BRAS  R14,HexToEBC            ...
         STM   R00,R01,PrL$Data+20     ...
         L     R00,ZEROFSET            Format offset for printing
         BRAS  R14,HexToEBC            ...
         STM   R00,R01,PrL$Data+1      ...
         MVC   PrL$Data+28(L'NOEXEC),NOEXEC
         ST    R15,ZEROFSET            Save R15
         BRAS  R14,Write
         XC    ZERO1RST,ZERO1RST       Clear first address
         L     R15,ZEROFSET            Restore R15 after write
         SPACE
Prof090  DS    0H
         LR    R00,R15              Offset
         BRAS  R14,HexToEBC         Convert to display
         STM   R00,R01,PrL$Data+1   Move to print line
         SPACE
         LR    R00,R02              Start address
         BRAS  R14,HexToEBC         Convert to display
         STM   R00,R01,PrL$Data+11  Move to print line
         SPACE
         LR    R00,R12              End address
         BRAS  R14,HexToEBC         Convert to display
         MVI   PrL$Data+19,C'-'
         STM   R00,R01,PrL$Data+20  Move to print line
         SPACE
         CVD   R05,WorkDblW         Convert to packed
         LA    R02,PrL$Data+30      Load pointer to printline fields
         BRAS  R14,PERCENT          Format count and percentage
         BRAS  R14,Write            Write out print line
         SPACE
Prof100  DS    0H
         LA    R03,1(,R03)          Bump to next cell
         CL    R03,#Cells           Q. Any more cells to process?
         JL    Prof060              Y. Go process them
         SPACE
         ICM   R00,B'1111',ZERO1RST N. Q. Zero range to print?
         JZ    Prof110                 N. Go do normal print
         BRAS  R14,HexToEBC            Y. Format start address
         STM   R00,R01,PrL$Data+11        ...
         L     R00,ZEROLAST               Format end address of range
         BRAS  R14,HexToEBC               ...
         STM   R00,R01,PrL$Data+20        ...
         L     R00,ZEROFSET               Format offset for printing
         BRAS  R14,HexToEBC               ...
         STM   R00,R01,PrL$Data+1         ...
         MVC   PrL$Data+28(L'NOEXEC),NOEXEC
         BRAS  R14,Write
         SPACE
Prof110  DS    0H
         TM    PrfEntry,X'80'        Q. Last entry in table?
         JO    Prof900               Y. Finished
         LA    R06,PrfEntry+PRF$ELEN N. Point to next entry
         J     Prof010                  and go process it
         DROP  R06
         SPACE
Prof900  DS    0H
         NI    TrcFlag2,255-Trc$NoIH Reset header flag
         L     R14,PFSAV            Load return address
         BSM   0,R14                and return
         TITLE 'Format Unsigned Count and Percentage'
***********************************************************************
*        Format count as number as well as a percentage               *
*---------------------------------------------------------------------*
*        On entry, R02 points to area to place print data             *
*                  WorkDblW contains count field                      *
*                  WorkPL8 contains total count                       *
*                                                                     *
***********************************************************************
         SPACE
PERCENT  DS    0H
         CP    WorkDblW,cpZero      Q. Is count negative?
         JNL   PER010               N. Top bit not used
         AP    WorkDblW,TwoTo32     Y. Convert to unsigned, add 2**32
         SPACE
PER010   DS    0H
         USING CNT$ICNT,R02
         MVC   WorkCL16(L'EDMask12),EDMask12   Move in edit mask
         ED    WorkCL16(L'EDMask12),WorkDblW+2 Format instruction count
         MVC   CNT$ICNT,WorkCL16+2             Move to print line
         SPACE
         CP    WorkPL8,WorkDblW     Q. Values equal (100%)?
         JNE   PER020               N. Go do normal processing
         MVC   CNT$PCNT,=C'  100%'  Y. Indicate 100%
         J     PER900
         SPACE
PER020   DS    0H
         ZAP   WorkCL16,WorkDblW    Instruction count
         SRP   WorkCL16,4,0         Multiply by 10**4 (i.e. 1000)
         DP    WorkCL16,WorkPL8     Divide by total instruction count
         OI    WorkCL16+7,X'0F'     Ensure F sign
         UNPK  WorkDblW(5),WorkCL16+5(3)
         MVC   CNT$PCNT(2),WorkDblW+1   Whole percentage points
         MVI   CNT$PCNT+2,C'.'          Decimal point
         MVC   CNT$PCNT+3(2),WorkDblW+3 100ths of a percentage point
         MVI   CNT$PCNT+L'CNT$PCNT-1,C'%'
         CLI   CNT$PCNT,C'0'        Q. First digit zero?
         JNE   PER900               N. Let it be
         MVI   CNT$PCNT,C' '        Y. Suppress leading zero
         SPACE
PER900   DS    0H
         BSM   0,R14
         DROP  R02
         SPACE 2
         LTORG ,
         TITLE 'Print Supervisor Routine Main Line'
***********************************************************************
*                                                                     *
*        Print supervisor                                             *
*                                                                     *
***********************************************************************
         SPACE
PrintSup DS    0H
         ST    R14,PSSAV            Save return
         BRAS  R14,PLINE1           Format location counter
         BRAS  R14,PrOpCode         Format opcode and operands
         BRAS  R14,PrintRegs        Format registers used
         BRAS  R14,PrintEFA         Format storage operands used
         TM    TrcFlag1,Trc$ModCall Q. Module name present?
         JZ    PS010                N. Nothing special to be done
         MVC   PrL$ModuleID,IDstring Y. Move module id to print line
         SPACE
PS010    DS    0H
         BRAS  R14,Write            Print the line
         TM    bAttribute4,bitDUMPR Q. Print all registers?
         JZ    PS999                N. Bif not
         CLI   XCell,$LAM           Y. Q. LAM instruction?
         JE    PS020                   Y. Don't dump general registers
         CLI   XCell,$STAM             N. Q. STAM instruction?
         JE    PS020                      Y. Don't dump general regs
         SPACE
         BRAS  R12,DumpGPRs         Dump general registers
         MVI   PrL$CCB,C'0'         Double space next line
         CLI   XCell,$LM            Q. LM instruction?
         JE    PS999                Y. Don't dump ARs
         CLI   XCell,$STM           N. Q. STM instruction?
         JE    PS999                   Y. Don't dump ARs
         SPACE
PS020    DS    0H
         BRAS  R12,DumpARs          Dump ARs too
         MVI   PrL$CCB,C'0'         Double space next line
         SPACE
PS999    DS    0H
         L     R14,PSSAV            Load return address
         BSM   0,R14                ... and return
         TITLE 'Format Location Counter and Hex Instruction Image'
***********************************************************************
*                                                                     *
*        Format the pseudo instruction pointer, ASC mode, hexadecimal *
*        instruction image and the condition code onto the print line *
*                                                                     *
***********************************************************************
         SPACE
PLINE1   DS    0H
         ST    R14,P1SAV            Save return address
         SPACE
*---------------------------------------------------------------------*
*        Format instruction pointer (PSW bits 32-63)                  *
*---------------------------------------------------------------------*
         SPACE
         LR    R00,R11              Copy instruction pointer
         O     R00,OldAMODE         Merge in addressing mode bit
         BRAS  R14,HexToEBC         Convert it for printing
         STM   R00,R01,PrL$ILC      Place it in the print line
         SPACE
*---------------------------------------------------------------------*
*        Format Address Space Control (ASC) mode                      *
*---------------------------------------------------------------------*
         SPACE
         SLR   R01,R01              Zero H.O. 3 bytes of work register
         IC    R01,TraceASC         Address Space Control mode
         IC    R00,ASCmodes(R01)    Get corresponding character
         STC   R00,PrL$ASC          Place character in print line
         SPACE
*---------------------------------------------------------------------*
*        Format instruction image                                     *
*---------------------------------------------------------------------*
         SPACE
         L     R00,XCell            Get the instruction image
         BRAS  R14,HexToEBC         Convert 1st four bytes
         STCM  R00,15,PrL$ObjCode   Place 1st 2 bytes in print line
         TM    bAttribute2,bitRR    Q. RR type instruction?
         JO    P1CC                 Y. Only print two bytes
         STCM  R01,15,PrL$ObjCode+4 N. Place 2nd 2 bytes in print line
         TM    bAttribute2,bitSS       Q. SS/SSe type instruction?
         JZ    P1CC                    N. Only print 4 bytes
         L     R00,XCell+4             Y. Last 2 bytes of instruction
         BRAS  R14,HexToEBC               Convert for printing
         STCM  R00,15,PrL$ObjCode+8       ... and place in print line
         SPACE
*---------------------------------------------------------------------*
*        Format condition code                                        *
*---------------------------------------------------------------------*
         SPACE
P1CC     DS    0H
         SLR   R01,R01              Clear R01
         IC    R01,TraceCC          Actual condition code
         IC    R00,EBDCC(R01)       Get corresponding character
         STC   R00,PrL$CondCode     Place character in print line
         SPACE
*---------------------------------------------------------------------*
*        Format branch indicator (successful branches only)           *
*---------------------------------------------------------------------*
         SPACE
         TM    TrcFlag1,Trc$Branch  Q. Branch taken?
         JZ    P1EXIT               N. Finished then
***                                 Y. Indicate branch taken
         MVC   PrL$BranchDir,BranchDir ...
         L     R15,BranchTgt           Get branch address
         TM    TraceAMODE,X'80'        Q. 31-bit addressing mode?
         JO    P1MODE31                Y. Don't clear top byte
         ICM   R15,B'1000',HexZeros    N. Clear top byte
         SPACE
P1MODE31 DS    0H
         N     R15,SevenFs          Ensure top bit clear for compare
         CLR   R11,R15              Q.  Which direction is branch?
         JL    P1BRFOR              Lo. Forward branch
         JE    P1EXIT               Eq. Branch to itself???
         MVI   PrL$BranchDir+1,C'-' Hi. Indicate backwards branch
         J     P1EXIT                   ... and return
         SPACE
P1BRFOR  DS    0H
         MVI   PrL$BranchDir,C'-'   Indicate forward branch
         SPACE
P1EXIT   DS    0H
         L     R14,P1SAV
         BSM   0,R14                Return
         TITLE 'Format Symbolic Opcode and Operands'
***********************************************************************
*                                                                     *
*        Place the symbolic instruction code and the instruction      *
*        fields in assembly format into the print line.               *
*                                                                     *
***********************************************************************
         SPACE
PrOpCode DS    0H
         ST    R14,POSAV            Save return address
         L     R14,aOpCodes         Point to standard mnemonic table
         SLR   R01,R01              Ensure H.O. 3-bytes are zero
         IC    R02,XCell+1          RR/RX/RS register specifiers
         IC    R01,XCell            Instruction code
         SPACE
         CLI   XCell,$B2            Q. X'B2' type instruction?
         JNE   PO010                N. Go check if x'A7' instruction
         IC    R01,XCell+1          Y. Use 2nd byte of instruction
         L     R14,aB2codes            ... and use X'B2' mnemonic table
         IC    R02,XCell+3             Register specifiers for RRE
         J     PO030
         SPACE
PO010    DS    0H
         CLI   XCell,$A7            Q. X'A7' type instruction?
         JNE   PO020                N. Go check if x'01' instruction
         IC    R01,XCell+1          Y. Use 2nd byte of instruction
         N     R01,OOOOOOOF            Clear out register specifier
         L     R14,aA7codes            ... and use X'A7' mnemonic table
         J     PO030
         SPACE
PO020    DS    0H
         CLI   XCell,$01            Q. X'01' type instruction?
         JNE   PO030                N. Use the standard table
         IC    R01,XCell+1          Y. Use 2nd byte of instruction
         L     R14,a01codes            ... and use X'01' mnemonic table
         SPACE
PO030    DS    0H
         LR    R00,R01
         ALR   R01,R01              (instruction code)*2
         ALR   R01,R00              (instruction code)*3
         ALR   R01,R01              (instruction code)*6
         LA    R01,0(R01,R14)       Address of instruction mnemonic
         MVC   PrL$Mnemonic,0(R01)  Place in print line
         LA    R03,PrL$Operands     Point R03 at operand area
         SPACE
         TM    bAttribute1,bitCC    Q. Instruction set condition code?
         JZ    PO040                N. Ignore it then
         MVC   LastCCOp,0(R01)      Y. Save it for EMC test
         SPACE
PO040    DS    0H
         CLI   XCell,$01            Q. X'01' type instruction?
         JE    PO999                N. No operands
         TM    UsrFlag2,Flg$NoPrEMC Y. Q. Want extended mnemonic codes?
         JO    PO200                   N. Bypass EMC logic
         SPACE
*---------------------------------------------------------------------*
*        Translate BC, BCR and BRC to Extended Mnemonic Codes (EMC)   *
*---------------------------------------------------------------------*
         SPACE
         CLI   XCell,$BC            Q. BC instruction?
         JE    PO100                Y. Process extended mnemonic
         CLI   XCell,$BCR           N. Q. BCR instruction?
         JE    PO100                   Y. Process extended mnemonic
         CLC   =C'BRC',0(R01)          N. Q. BRC instruction?
         JNE   PO200                      N. Not a conditional branch
         TM    XCell+1,X'F0'              Y. Q. JNOP instruction?
         JNE   PO100                         N. Go process EMC
         MVC   PrL$Mnemonic,=CL6'JNOP'       Y. Indicate JNOP
         SLR   R01,R01                          Indicate no index
         J     PO700                            Go process target
         SPACE
PO100    DS    0H
         LA    R14,EMstandard       Default is standard mnemonic table
         CLI   LastCCOp,C'C'        Q. Was it a compare instruction?
         JE    PO110                Y. Go use compare table
         CLC   =C'MVCL',LastCCOp    N. Q. Was it a MVCL(E) instruction?
         JNE   PO120                   N. Use standard mnemonic table
         SPACE
PO110    DS    0H
         LA    R14,EMcompare        Use the compare mnemonic table
         SPACE
PO120    DS    0H
         ICM   R15,B'1000',XCell+1  Load branch mask byte
         SRL   R15,28               Shift into low order nybble
         SLL   R15,2                Multiply by 4 for mnemonic offset
         LA    R14,0(R15,R14)       Point to extended mnemonic
         CLI   0(R14),C' '          Q. Is there an extended mnemonic?
         JE    PO200                N. Just use standard menonic
         MVC   PrL$Mnemonic(4),0(R14) Y. Replace the standard mnemonic
         TM    bAttribute2,bitRR       Q. BCR instruction?
         JO    PO130                   Y. Go append R to mnemonic
         TM    bAttribute2,bitIMREL    N. Q. BRC instruction?
         JZ    PO600                      N. Must have been BC
         MVI   PrL$Mnemonic,C'J'          Y. Indicate it's a JUMP
         J     PO600
         SPACE
PO130    DS    0H
         LA    R15,PrL$Mnemonic+1   Second byte of mnemonic
         LHI   R14,3                Number of bytes to test
         SPACE
PO140    DS    0H
         CLI   0(R15),C' '          Q. End of mnemonic found?
         JE    PO150                Y. Go append the 'R'
         LA    R15,1(,R15)          N. Bump to the next byte
         BCT   R14,PO140               Loop until a blank found
         SPACE
PO150    DS    0H
         MVI   0(R15),C'R'          Indicate it's an RR instruction
         J     PO520                Go format register number
         SPACE
*---------------------------------------------------------------------*
*        Prepare the instruction fields in assembly format            *
*---------------------------------------------------------------------*
         SPACE
PO200    DS    0H
         TM    bAttribute2,bitRR+bitRX+bitRS
*                                   Q. Is first operand a register?
         JNZ   PO500                Y. Go split the field into R,X
         SLR   R01,R01              N. Indicate no index register
         LH    R00,XCell+2             bddd
         BRAS  R14,BDproc              'ddd(b)'
         TM    bAttribute2,bitSS       Q. SS/SSE type instruction?
         JZ    PO400                   N. Must be S/SI type instruction
         TM    bAttribute1,bitPACKD    Y. Q. Decimal instruction?
         JO    PO300                      Y. Format packed decimal SS
         TM    bAttribute2,bitIMDF        N. Q. SSE instruction?
         JZ    PO210                         Y. No length field then
         SPACE
*---------------------------------------------------------------------*
*        Finish up type SS(E) instruction (non-decimal)               *
*---------------------------------------------------------------------*
         SPACE
         AHI   R03,-3               Back up the field pointer
         MVC   5(2,R03),1(R03)      'ddd(    b)'
         SLR   R01,R01              Clear R01
         IC    R01,XCell+1          ll        (machine) length field
         LA    R00,1(,R01)          lll       Add one for real length
         BRAS  R14,HexToEBC         Convert to display
         STCM  R01,B'0111',1(R03)   'ddd(lll b)'
         MVI   4(R03),C','          'ddd(lll,b)'
         LA    R03,7(,R03)          Adjust the field pointer
         SPACE
PO210    DS    0H
         MVI   0(R03),C','          'ddd(lll,b),' or 'ddd(b),'
         LA    R03,1(,R03)          Adjust field pointer
         LH    R00,XCell+4          bddd      2nd base,displacement
         SLR   R01,R01              Indicate no index register
         BRAS  R14,BDproc           'ddd(lll,b),ddd(b)'
         J     PO999                We're done
         SPACE
*---------------------------------------------------------------------*
*        Format packed decimal instruction operands                   *
*---------------------------------------------------------------------*
         SPACE
PO300    DS    0H
         AHI   R03,-3               Back up the field pointer
         MVC   4(2,R03),1(R03)      'ddd(   b)'
         IC    R01,XCell+1          ll        (machine) length field
         N     R01,OOOOOOFO         l0
         SRL   R01,4                l
         LA    R00,1(,R01)          l+1       Real length
         BRAS  R14,HexToEBC         Convert to display
         STCM  R01,B'0011',1(R03)   'ddd(ll b)'
         MVI   3(R03),C','          'ddd(ll,b)'
         MVI   6(R03),C','          'ddd(ll,b),'
         LA    R03,7(,R03)          Adjust the field pointer
         SPACE
         LH    R00,XCell+4          bddd      2nd base,displacement
         SLR   R01,R01              Indicate no index register
         BRAS  R14,BDproc           'ddd(ll,b),ddd(b)'
         CLI   XCell,$SRP           Q. SRP instruction?
         JE    PO310                Y. Go complete formatting SRP
         SPACE
         AHI   R03,-3               Back up the field pointer
         MVC   4(2,R03),1(R03)      'ddd(ll,b),ddd(  b)'
         IC    R01,XCell+1          ll        Length field
         N     R01,OOOOOOOF         l
         LA    R00,1(,R01)          l+1       Real length
         BRAS  R14,HexToEBC         Convert to display
         STCM  R01,B'0011',1(R03)   'ddd(ll,b),ddd(ll b)'
         MVI   3(R03),C','          'ddd(ll,b),ddd(ll,b)'
         J     PO999                Finished
         SPACE
PO310    DS    0H
         MVI   0(R03),C','          'ddd(ll,b),ddd(b),'
         IC    R01,XCell+1          li        Length field
         N     R01,OOOOOOOF         i
         IC    R01,HexChar(R01)     'i'
         STC   R01,1(,R03)          'ddd(ll,b),ddd(b),i'
         J     PO999                We're done
         SPACE
*---------------------------------------------------------------------*
*        Format immediate field of SI instruction                     *
*---------------------------------------------------------------------*
         SPACE
PO400    DS    0H
         TM    bAttribute2,bitIMDF  Q. S type instruction?
         JZ    PO999                Y. No immediate field then
         MVI   0(R03),C','          N. 'ddd(b),'
         SLR   R01,R01                 Clear R01
         IC    R01,XCell+1             ii        Immediate field
         SRL   R01,4                   i
         IC    R01,HexChar(R01)        'i'
         STC   R01,1(,R03)             'ddd(b),i'
         IC    R01,XCell+1             ii
         N     R01,OOOOOOOF            0i
         IC    R01,HexChar(R01)        'i'
         STC   R01,2(,R03)             'ddd(b),ii'
         J     PO999                   We're done
         SPACE
*---------------------------------------------------------------------*
*        Split the second byte of the instruction into r,x or r,r     *
*---------------------------------------------------------------------*
         SPACE
PO500    DS    0H
         LR    R01,R02              RX or RR register specifiers
         N     R01,OOOOOOFO         r0
         SRL   R01,4                r
         IC    R00,HexChar(R01)     'r'
         STC   R00,0(,R03)          'r'
         LA    R03,1(,R03)          Adjust field pointer
         CLI   XCell,$SVC           Q. SVC instruction?
         JNE   PO510                N. Skip SVC specific code
         CLI   XCell+1,HighSVC      Y. Q. SVC code in table?
         JH    PO520                   Y. Must be a user SVC
         SLR   R14,R14                 N. Clear index register
         IC    R14,XCell+1                Get SVC number
         SLL   R14,3                      Multiply by 8
         AL    R14,aSVCtable              Address of SVC entry
         IC    R15,5(,R14)                Length of mnemonic for EX
         L     R01,0(,R14)                Address of mnemonic
         EX    R15,MoveSVC                Copy mnemonic to print line
***      MVC   PrL$SVC(0),0(R01)          ...
         LH    R15,6(,R14)                Offset for special processing
         LTR   R15,R15                    Q. Any special processing?
         JM    PO520                      N. Bif not
         LA    R01,PrL$SVC+2              Y. Point to operand area
         AH    R01,4(,R14)                   ...
         L     R14,aSVC_Ops                  Get address of SVC operand
         L     R15,0(R15,R14)                ... special processing rtn
         BASR  R14,R15                       and invoke it
         J     PO520                         Go format operand as 'ii'
         SPACE
PO510    DS    0H
         MVI   0(R03),C','          'r,'
         LA    R03,1(,R03)          Adjust field pointer
         TM    bAttribute2,bitRR+bitRS Q. Need to format 'r,r'?
         JZ    PO600                N. Bif not
         TM    bAttribute3,bitSHIFT Y. Q. Shift instruction?
         JO    PO600                   Y. r2 is not used
         CLI   XCell,$A7               N. Q. x'A7' prefixed opcode?
         JE    PO600                      Y. r2 is part of opcode
         SPACE
PO520    DS    0H
         LR    R01,R02              rr     Register specifiers
         N     R01,OOOOOOOF         0r
         IC    R00,HexChar(R01)     'r'
         STC   R00,0(,R03)          'r,r'
         TM    bAttribute2,bitRR    Q. RR instruction?
         JO    PO999                Y. Finished
         TM    bAttribute2,bitRRE   N. Q. RRE instruction?
         JO    PO999                   Y. Finished
         SLR   R01,R01                 N. RS has no index register
         MVI   1(R03),C','                'r,r,'
         LA    R03,2(,R03)                Adjust the field pointer
         J     PO700                      Evaluate base, displacement
         SPACE
PO600    DS    0H
         IC    R01,XCell+1          rx
         N     R01,OOOOOOOF         0x
         SPACE
PO700    DS    0H
         LH    R00,XCell+2          bddd      Base and displacement
         BRAS  R14,BDproc           'r,ddd(x,b)'  or    'r,ddd(b)'
         SPACE
PO999    DS    0H
         L     R14,POSAV            Load return address
         BSM   0,R14                Return
         TITLE 'Format Base-Displacement-Index Fields for Operands'
***********************************************************************
*                                                                     *
*        Format the base, displacement, & index fields into assembly  *
*        format for printing.                                         *
*        On entry:                                                    *
*              R00 contains the 'base,displacement' (as a halfword)   *
*              R01 contains the number of the index register          *
*                                                                     *
*        On exit:                                                     *
*              Either 'ddd(b) or 'ddd(x,b)' is placed into the        *
*              instruction image at the address specified bt R03.     *
*              R00 and R01 are destroyed, R03 is modified             *
*                                                                     *
***********************************************************************
         SPACE
BDproc   DS    0H
         ST    R14,BDSAV            Save return address
         TM    bAttribute2,bitIMREL Q. Relative/immediate instruction?
         JZ    BD010                N. Must be base,displacement format
         BRAS  R14,HexToEBC         Y. Convert value to hex
         ST    R01,0(,R03)             Display halfword value
         LA    R03,4(,R03)             Adjust output pointer
         J     BD999
         SPACE
BD010    DS    0H
         ST    R00,BDTEMP           Save  bddd
         ST    R01,BDTEMP2          Save index specifier
         N     R00,OOOOOFFF         ddd       displacement
         BRAS  R14,HexToEBC         Convert for printing
         L     R00,BDTEMP2          x          index register
         ST    R01,BDTEMP2          '0ddd'
         MVC   0(3,R03),BDTEMP2+1   'ddd'
         MVI   3(R03),C'('          'ddd('
         LTR   R01,R00              Q. Is an index specified?
         JZ    BD020                N. Zero specifies no index
         IC    R01,HexChar(R01)     Y. 'x'
         STC   R01,4(R03)              'ddd(x'
         MVI   5(R03),C','             'ddd(x,'
         LA    R03,2(,R03)             Adjust pointer for the index
         SPACE
BD020    DS    0H
         L     R01,BDTEMP           bddd     Base, displacement
         N     R01,OOOOFOOO         b000
         SRL   R01,12               b        Base register
         IC    R01,HexChar(R01)     'b'
         STC   R01,4(,R03)          'ddd,x,b'     or   'ddd(b'
         MVI   5(R03),C')'          'ddd(x,b)'   or   'ddd(b)'
         LA    R03,6(,R03)          Adjust field pointer
         SPACE
BD999    DS    0H
         L     R14,BDSAV            Load return address
         BSM   0,R14                Return
         TITLE 'Display Registers used by Instructions'
***********************************************************************
*                                                                     *
*         Routine to place the operand registers referenced by the    *
*         instruction into the print line                             *
*                                                                     *
***********************************************************************
         SPACE
PrintRegs DS   0H
         TM    bAttribute2,bitRR+bitRX+bitRS
***                                      Q. Instruction use registers?
         BZR   R14                       N. So return
         CLI   XCell,$01                 Y. Q. E format instruction?
         BER   R14                          Y. Has no operands
         ST    R14,PRSAV                    N. Save return address
         IC    R03,XCell+1                     Load register specifiers
         TM    bAttribute1,bitBR               Q. Branch instruction?
         JZ    PR020                           N. Bif not
         SPACE
*---------------------------------------------------------------------*
*        Instruction is a branch, so test to see if it is a branch    *
*        condition, in which case the r1 field is actually the mask   *
*        against the condition code                                   *
*---------------------------------------------------------------------*
         SPACE
         CLI   XCell,$BC            Q. Is the instruction BC?
         JE    PR010                Y. Display cond-code mask only
         CLI   XCell,$BCR           N. Q. Is the instruction BCR?
         JE    PR010                   Y. Display cond-code mask only
         CLI   XCell,$A7               N. Q. Is the instruction BRC?
         JNE   PR020                      N. Bif not
         SPACE
PR010    DS    0H
         IC    R00,PrL$ObjCode+2    r (condition code mask) in EBCDIC
         STC   R00,PrL$Reg1+7       Store in register field
         LA    R02,TraceGPRs        Address of register table
         J     PR100                Go test for type RR instruction
         SPACE
PR020    DS    0H
         TM    bAttribute2,bitRRE   Q. RRE instruction?
         JNO   PR030                N. Got correct register specifiers
         IC    R03,XCell+3          Y. Load correct register specifiers
         SPACE
PR030    DS    0H
         CLI   XCell,$SVC           Q. SVC instruction?
         JE    PR999                Y. Doesn't actually use registers
         LR    R01,R03              N. rr
         N     R01,OOOOOOFO            r0
         SRL   R01,2                   r*4
         LA    R02,TraceGPRs           Address of register table
         TM    bAttribute4,bitFLOAT    Q. Floating point instruction?
         JZ    PR040                   N. Use general registers
         LA    R02,FPR0                Y. Use floating point registers
         STD   0,FPR0                     Load FP register table
         STD   2,FPR2                     ...
         STD   4,FPR4                     ...
         STD   6,FPR6                     ...
         J     PR060
         SPACE
PR040    DS    0H
         CLI   Xcell,$LAM           Q.  LAM instruction?
         JL    PR060                Lo. r1 must be a general register
         CLI   Xcell,$STAM          NL. Q. STAM instruction?
         JNH   PR050                    NH. LAM/STAM references AR
         CLI   Xcell,$B2                Hi. Q. x'B2' code?
         JNE   PR060                        N. r1 is a general register
         CLI   Xcell+1,$TAR                 Y. Q.  TAR instruction?
         JL    PR060                           Lo. r1 cannot be an AR
         CLI   Xcell+1,$SAR                    NL. Q. SAR instruction?
         JH    PR060                               Hi. r1 must be a GPR
         SPACE
PR050    DS    0H
         LA    R02,TraceARs         Use access register table
         SPACE
PR060    DS    0H
         L     R00,0(R01,R02)       Get the value of the register
         LR    R15,R01              Save register number
         BRAS  R14,HexToEBC         Convert value for printing
         STM   R00,R01,PrL$Reg1     Place in print line
         TM    bAttribute3,bitDBLR  Q. Doubleword register operand?
         JZ    PR100                N. Go process r2 as single register
         L     R00,4(R15,R02)       Y. Value of register r1+1
         BRAS  R14,HexToEBC            Convert for printing
         STM   R00,R01,PrL$DR1         Place in print line
         TM    bAttribute2,bitRR+bitRS Q. RR or RRE instruction?
         JZ    PR999                   N. Finished
         SPACE
*---------------------------------------------------------------------*
*        Process r2 when double registers are used                    *
*---------------------------------------------------------------------*
         SPACE
         LR    R01,R03              rr
         N     R01,OOOOOOOF         0r
         SLL   R01,2                r*4
         L     R00,0(R01,R02)       Get register value
         LR    R15,R01              Save register number
         BRAS  R14,HexToEBC         Convert for printing
         STM   R00,R01,PrL$DR2A     Place in print line
         L     R00,4(R15,R02)       Get 2nd half of value
         BRAS  R14,HexToEBC         Convert for printing
         STM   R00,R01,PrL$DR2B     Place in print line
         J     PR999                Finished
         SPACE
*---------------------------------------------------------------------*
*        Check if a second (single) register is specified             *
*---------------------------------------------------------------------*
         SPACE
PR100    DS    0H
         TM    bAttribute2,bitRR+bitRS
***                                 Q. RR(E) or RS instruction?
         JZ    PR999                N. No second register present
         TM    bAttribute3,bitSHIFT+bitMASK
***                                 Y. Q. Shift or mask instruction?
         JNZ   PR999                   Y. No second register
         CLI   XCell,$A7               N. Q. x'A7' instruction?
         JE    PR999                      Y. No second register
         SPACE
*---------------------------------------------------------------------*
*        EAR, SAR and TAR use both general and access registers       *
*---------------------------------------------------------------------*
         SPACE
         CLI   XCell,$B2            Q. x'B2' prefixed instruction?
         JNE   PR130                N. r1 and r2 are of the same type
         CLI   XCell+1,$TAR         Y. Q.  Is this a TAR instruction?
         JL    PR130                   Lo. r1/r2 must be same type
         JE    PR120                   Eq. TAR r2 is a general register
         CLI   XCell+1,$EAR            Hi. Q.  This an EAR instruction?
         JH    PR130                       Hi. r1/r2 must be same type
         JL    PR110                       Lo. Must be SAR or CPYA
         LA    R02,TraceARs                Eq. r2 of EAR is an AR
         J     PR130
         SPACE
PR110    DS    0H
         CLI   XCell+1,$SAR         Q. Is this a SAR instruction?
         JNE   PR130                N. Register type did not change
         SPACE
PR120    DS    0H
         LA    R02,TraceGPRs        Switch to general register table
         SPACE
PR130    DS    0H
         LR    R01,R03              rr
         N     R01,OOOOOOOF         0r
         SLL   R01,2                r*4
         L     R00,0(R01,R02)       Value of the register
         BRAS  R14,HexToEBC         Convert for printing
         STM   R00,R01,PrL$Reg2     Place in print line
         SPACE
PR999    DS    0H
         L     R14,PRSAV            Load return address
         BSM   0,R14                and return
         TITLE 'Display Operand Effective Addresses and their Contents'
***********************************************************************
*                                                                     *
*        Place the effective address of the instruction operand and   *
*        the contents at that memory location onto the print line.    *
*                                                                     *
***********************************************************************
         SPACE
PrintEFA DS    0H
         ST    R14,PESAV            Save return address
         TM    bAttribute2,bitRR    Q. RR type instruction?
         JO    PE050                Y. Go check if MVCL or CLCL
         TM    bAttribute2,bitRRE   N. Q. Type RRE instruction?
         BOR   R14                     Y. No memory reference
         TM    bAttribute2,bitIMREL    N. Q. RSI/RI instruction?
         JZ    PE010                      N. Go evaluate address
         TM    bAttribute1,bitBR          Y. Q. Relative branch?
         BZR   R14                           N. Nothing left to do
         SPACE
*---------------------------------------------------------------------*
*        Evaluate effective address of relative branch                *
*---------------------------------------------------------------------*
         SPACE
         BRAS  R14,EvalRI           Evaluate relative address
         BRAS  R14,HexToEBC         Convert address for printing
         STM   R00,R01,PrL$Address1 Place address in print line
         J     PE999                We're done
         SPACE
*---------------------------------------------------------------------*
*        Evaluate effective address of first storage operand          *
*---------------------------------------------------------------------*
         SPACE
PE010    DS    0H
         CLI   XCell,$MVCLE         Q. MVCLE instruction?
         JL    PE020                N. Must be standard RX/RS
         CLI   XCell,$CLCLE         Y. Q. MVCLE/CLCLE instruction?
         JNH   PE060                   N. Must be standard RX/RS
         SPACE
PE020    DS    0H
         LA    R02,XCell+2          Address of base, displacement
         TM    bAttribute2,bitRX    Q. RX type instruction?
         JZ    PE030                N. Has no index register then
         BRAS  R14,EvalXBD          Y. Evaluate indexed address
         J     PE040                   and go place in print line
         SPACE
PE030    DS    0H
         BRAS  R14,EvalBD           Evaluate address, no index
         CLI   XCell,$CDS           Q. CDS instruction?
         JNE   PE040                N. Go process first storage operand
         LHI   R03,8                Y. Operand length is 8
         LR    R02,R00                 Save effective address
         J     PE410                   Format onto 2nd operand area
         SPACE
*---------------------------------------------------------------------*
*        Format effective address of first storage operand            *
*---------------------------------------------------------------------*
         SPACE
PE040    DS    0H
         LR    R02,R00              Save effective address
         BRAS  R14,HexToEBC         Convert address for printing
         STM   R00,R01,PrL$Address1 Place address in print line
         TM    bAttribute3,bitSHIFT+bitNOREF
*                                   Q. Really an address?
         JNZ   PE999                N. No storage referenced
         CLI   XCell,$MVCS          Y. Q. MVCS instruction?
         JNE   PE080                   N. Go get operand length
         J     PE400                   Y. Cannot access secondary a/s
         SPACE
PE050    DS    0H
         CLI   XCell,$MVCL          Q. Possibly MVCL or CLCL?
         BLR   R14                  N. No storage operands
         CLI   XCell,$CLCL          Y. Q. Actually MVCL or CLCL?
         BHR   R14                     N. No storage operands
         SPACE
PE060    DS    0H
         IC    R15,XCell+1          rr
         N     R15,OOOOOOFO         r0 (destination register)
         SRL   R15,2                (r0 >> 4) * 4
         SLR   R04,R04              Assume we're not in AR ASC mode
         CLI   TraceASC,ARmode      Q. In AR ASC mode?
         JNE   PE070                N. Default value is good
         L     R04,TraceARs(R15)    Y. Load associated ALET
         SPACE
PE070    DS    0H
         L     R02,OldRegs(R15)     Original 1st operand address
         LA    R02,0(,R02)          Clear top byte/bit
         LR    R00,R02              Pass to conversion routine
         BRAS  R14,HexToEBC         Convert address for printing
         STM   R00,R01,PrL$Address1 Place address in print line
         L     R03,OldRegs+4(R15)   Get length register
         TM    bAttribute2,bitRR    Q. MVCL or CLCL instruction?
         JZ    PE300                N. Length is 4-bytes
         ICM   R03,B'1000',HexZeros Y. Ensure top byte is zero
         J     PE300                   Go get operand
         SPACE
*---------------------------------------------------------------------*
*        Get length of storage operand(s)                             *
*---------------------------------------------------------------------*
         SPACE
PE080    DS    0H
         TM    bAttribute3,bitDBLS+bitFULL+bitHALF+bitBYTE
*                                   Q. Fixed length operand?
         JZ    PE100                N. We need to calculate length
         LHI   R03,4                Y. Assume fullword operand
         TM    bAttribute3,bitFULL     Q. Really fullword operand?
         JO    PE300                   Y. Go calculate address
         LHI   R03,1                   N. Assume byte operand
         TM    bAttribute3,bitBYTE        Q. Really byte operand?
         JO    PE300                      Y. Go calculate address
         LHI   R03,8                      N. Assume doubleword operand
         TM    bAttribute3,bitDBLS           Q. Really doubleword?
         JO    PE300                         Y. Go calculate address
         LHI   R03,2                         N. Must be halfword
         J     PE300                            Go calculate address
         SPACE
*---------------------------------------------------------------------*
*        Get length of target of execute instruction                  *
*---------------------------------------------------------------------*
         SPACE
PE100    DS    0H
         TM    bAttribute4,bitEX    Q. Execute instruction?
         JZ    PE200                N. Try next instruction type
         SLR   R15,R15              Y. Clear work register
         LR    R03,R15                 ... and length register
         IC    R15,0(,R02)             First byte of target instruction
         SRL   R15,6                   Instruction length specifiers
         IC    R03,BitCount(R15)       Number of halfwords minus one
         LA    R03,1(,R03)             Number of halfwords
         ALR   R03,R03                 Times two gives number of bytes
         CLI   0(R02),$SVC             Q. SVC instruction?
         JNE   PE300                   N. Go get actual operands
         IC    R14,XCell+1             Y. Get rr
         N     R14,OOOOOOFO               Q. EXecute using register 0?
         JNZ   PE110                      N. Go OR reg with storage
         SLR   R14,R14                    Y. Register value is ignored
         IC    R14,1(,R02)                   Just use operand value
         J     PE120
         SPACE
PE110    DS    0H
         SRL   R14,2                r*4  (right 4 + left 2 = right 2)
         L     R14,OldRegs(R14)     Original register contents
         MVC   WorkCL5+3(1),1(R02)  Second byte of SVC instruction
         O     R14,WorkCL5          OR with register
         ICM   R14,B'1110',HexZeros Clear top 3 bytes
         SPACE
PE120    DS    0H
         CLM   R14,B'0001',=AL1(HighSVC)
*                                   Q. Is this a user SVC?
         JH    PE300                Y. No known mnemonic then
         SLL   R14,3                   Multiply by 8
         AL    R14,aSVCtable           Address of SVC descriptor entry
         IC    R15,5(,R14)             Length for move
         L     R01,0(,R14)             Address of SVC macro name
         EX    R15,MoveExSVC           Copy to print line
***      MVC   PrL$ESVC(0),0(R01)      ...
         LH    R15,6(,R14)             Offset for special processing
         LTR   R15,R15                 Q. Any special processing?
         JM    PE300                   N. Bif not
         LA    R01,PrL$ESVC+2          Y. Point to operand output area
         AH    R01,4(,R14)                ...
         L     R14,aSVC_Ops               Get address of SVC operand
         L     R15,0(R15,R14)             ... processing routine
         BASR  R14,R15                    and invoke it
         J     PE300                      Go get actual instruction
         SPACE
*---------------------------------------------------------------------*
*        Get number of bytes used by CLM, STCM or ICM instruction     *
*---------------------------------------------------------------------*
         SPACE
PE200    DS    0H
         TM    bAttribute1,bitBR    Q. Branch instruction?
         JO    PE999                Y. Ignore contents of storage
         TM    bAttribute2,bitRS    N. Q. RS instruction?
         JZ    PE220                   N. Must be a SS/S instruction
         TM    bAttribute3,bitMASK     Y. Q. Mask instruction?
         JZ    PE210                      N. Must be STM or LM then
         IC    R15,XCell+1                Y. rm
         N     R15,OOOOOOOF                  0m
         IC    R15,BitCount(R15)             Number of bits in m
         LTR   R03,R15                       Q. Zero length operand?
         JZ    PE999                         Y. No storage operand
         J     PE300                         N. Go get storage operand
         SPACE
PE210    DS    0H
         TM    bAttribute4,bitDUMPR Q. STM or LM instruction?
         BZ    *+1                  N. This should never happen!!!!!!
         LHI   R03,8                Y. Operand length is 8 (max)
         J     PE300
         SPACE
*---------------------------------------------------------------------*
*        Get length of first operand of a packed decimal instruction  *
*---------------------------------------------------------------------*
         SPACE
PE220    DS    0H
         TM    bAttribute1,bitPACKD Q. Packed decimal instruction?
         JZ    PE230                N. Go try next instruction type
         IC    R15,XCell+1          Y. Get ll byte (l1,l2)
         N     R15,OOOOOOFO            Mask off l1
         SRL   R15,4                   Shift into bottom nybble
         LA    R03,1(,R15)             Add one for real length
         J     PE300
         SPACE
*---------------------------------------------------------------------*
*        Get length of operand from ss instruction with byte length   *
*---------------------------------------------------------------------*
         SPACE
PE230    DS    0H
         TM    bAttribute1,bitMVCX  Q. MVCK/MVCP/MVCS instruction?
         JO    PE240                Y. Length is in a register
         SLR   R15,R15              N. Clear R15
         IC    R15,XCell+1             Length minus one
         LA    R03,1(,R15)             Actual length
         J     PE300
         SPACE
*---------------------------------------------------------------------*
*        Get length of MVCK/MVCP/MVCS instruction operand             *
*---------------------------------------------------------------------*
         SPACE
PE240    DS    0H
         IC    R15,XCell+1          rr
         N     R15,OOOOOOFO         r0
         SRL   R15,2                r*4
         L     R15,OldRegs(R15)     Operand length
         LTR   R03,R15              Q. Operand length zero?
         JZ    PE400                Y. Storage not accessed then
         SPACE
*---------------------------------------------------------------------*
*        Load storage operand, the number of bytes loaded is the      *
*        smaller of eight bytes or the actual operand length          *
*---------------------------------------------------------------------*
         SPACE
PE300    DS    0H
         LHI   R14,8                Maximum length displayed by trace
         CLR   R14,R03              Q. Operand length too long?
         JH    PE310                N. Use actual operand length
         LR    R03,R14              Y. Use maximum length allowed
         SPACE
PE310    DS    0H
         SAR   AR02,R04             Set access register
         LR    R14,R03              Get length of storage operand
         BCTR  R14,0                Machine length
         EX    R14,PEFAMVC          Get first storage operand
***      MVC   WorkDblW(0),0(R02)   ...
         LAM   AR02,AR02,HexZeros   Clear the access register
         SPACE
*---------------------------------------------------------------------*
*        Convert operand to display and move to print line            *
*---------------------------------------------------------------------*
         SPACE
         LM    R15,R00,WorkDblW     Load storage contents into regs
         L     R00,WorkDblW+4       Convert second word to display hex
         BRAS  R14,HexToEBC         ...
         STM   R00,R01,WorkCL16+8   ... and save
         SPACE
         LR    R00,R15              Convert first word to display hex
         BRAS  R14,HexToEBC         ...
         STM   R00,R01,WorkCL16     ... and save
         SPACE
         LR    R01,R03              Actual operand length
         ALR   R01,R01              Times two (for each hex nybble)
         LA    R14,WorkCL16(R01)    Address of end of operand
         LHI   R15,16               Maximum length of operand displayed
         SR    R15,R01              Number of positions to blank out
         JZ    PE320                Bif none
         AHI   R15,-2               Adjust for initial blank           X
                                    ... and machine length
         MVI   0(R14),C' '          Initial blank
         EX    R15,PEFACLR          Propagate the blank
***      MVC   1(0,R14),0(R14)      ...
         SPACE
PE320    DS    0H
         MVC   PrL$Data1,WorkCL16   Move into print line
         MVC   PrL$Double1,WorkCL16+8 ...
         SPACE
*---------------------------------------------------------------------*
*        Format second storage operand if there is one                *
*---------------------------------------------------------------------*
         SPACE
         CLI   XCell,$MVCLE         Q. MVCLE/CLCLE instruction?
         JL    PE330                N. Check for others
         CLI   XCell,$CLCLE         Y. Q. MVCLE/CLCLE instruction?
         JNH   PE340                   Y. Process as if RR
         SPACE
PE330    DS    0H
         TM    bAttribute2,bitRR+bitSS
***                                 Q. Can 2nd operand be from storage?
         JZ    PE999                N. We must be finished
         TM    bAttribute2,bitRR    Y. Q. RR instruction?
         JZ    PE400                   N. Must be ss instruction
         SPACE
PE340    DS    0H
         IC    R15,XCell+1          rr
         N     R15,OOOOOOOF         0r (source register)
         SLL   R15,2                0r times 4
         SLR   R04,R04              Assume we're not in AR ASC mode
         CLI   TraceASC,ARmode      Q. In AR ASC mode?
         JNE   PE350                N. Default value is good
         L     R04,TraceARs(R15)    Y. Load associated ALET
         SPACE
PE350    DS    0H
         L     R02,OldRegs(R15)     Original 2nd operand address
         LA    R02,0(,R02)          Clear top bit/byte
         L     R03,OldRegs+4(R15)   Get length register
         TM    bAttribute2,bitRR    Q. MVCL or CLCL instruction?
         JZ    PE410                N. MVCLE/CLCLE length is 4-bytes
         ICM   R03,B'1000',HexZeros Y. MVCL/CLCL length is 3-bytes
         J     PE410                   Go get operand
         SPACE
PE400    DS    0H
         CLI   XCell,$SRP           Q. SRP instruction?
         JE    PE999                Y. Second operand not an address
         LA    R02,XCell+4          N. Point to 2nd base, displacement
         BRAS  R14,EvalBD              Evaluate 2nd operand address
         LR    R02,R00                 Save effective address
         SPACE
         TM    bAttribute1,bitPACKD    Q. Packed decimal instruction?
         JZ    PE410                   N. Operand length still in R03
         IC    R15,XCell+1             Y. Get ll byte
         N     R15,OOOOOOOF               Mask off l2
         LA    R03,1(,R15)                Actual operand length
         SPACE
PE410    DS    0H
         LR    R00,R02              Load R00 with effective address
         BRAS  R14,HexToEBC         Convert EFA for printing
         STM   R00,R01,PrL$Address2 ... and move to print line
         SPACE
         LTR   R03,R03              Q. Zero length operand?
         JZ    PE999                Y. No storage to print then
         TM    bAttribute1,bitMVCX  N. Q. MVCK/MVCP/MVCS instruction?
         JZ    PE420                   N. Go get operands
         CLI   XCell,$MVCS             Y. Q. MVCS instruction?
         JNE   PE999                      N. Cannot access A/S used
         SPACE
PE420    DS    0H
         LHI   R14,8                Maximum operand display length
         CLR   R14,R03              Q. Operand length too long?
         JH    PE430                N. Use actual operand length
         LR    R03,R14              Y. Use maximum allowed length
         SPACE
PE430    DS    0H
         SAR   AR02,R04             Load ALET for MVC source
         LR    R14,R03              Load operand length
         BCTR  R14,0                Machine length
         EX    R14,PEFAMVC          Get second storage operand
***      MVC   WorkDblW(0),0(R02)   ...
         LAM   AR02,AR02,HexZeros   Ensure AR02 zero to avoid problems
         SPACE
*---------------------------------------------------------------------*
*        Convert storage contents to display and move to print line   *
*---------------------------------------------------------------------*
         SPACE
         LM    R15,R00,WorkDblW     Load storage contents into regs
         L     R00,WorkDblW+4       Convert second word to display hex
         BRAS  R14,HexToEBC         ...
         STM   R00,R01,WorkCL16+8   ... and save
         SPACE
         LR    R00,R15              Convert first word to display hex
         BRAS  R14,HexToEBC         ...
         STM   R00,R01,WorkCL16     ... and save
         SPACE
         ALR   R03,R03              Times two (for each hex nybble)
         LA    R14,WorkCL16(R03)    Address of end of operand
         LHI   R15,16               Maximum length of operand displayed
         SR    R15,R03              Number of positions to blank out
         JZ    PE440                Bif 8 bytes are displayed
         AHI   R15,-2               Adjust for initial blank           X
                                    ... and machine length
         MVI   0(R14),C' '          Initial blank
         EX    R15,PEFACLR          Propagate the blank
***      MVC   1(0,R14),0(R14)      ...
         SPACE
PE440    DS    0H
         MVC   PrL$Data2,WorkCL16   Move into print line
         MVC   PrL$Double2,WorkCL16+8 ...
         SPACE
PE999    DS    0H
         L     R14,PESAV            Load return address
         BSM   0,R14                Return
         SPACE 2
         LTORG ,
         TITLE 'Evaluate Memory Address Referenced by Instructions'
***********************************************************************
*        Evaluate the address of storage reference instructions       *
*---------------------------------------------------------------------*
*                                                                     *
*        R00-R01 - used for work, contents destroyed                  *
*        R02     - address of X'bddd' field                           *
*        XCell+1 - index register in bottom nybble for xbd            *
*                                                                     *
*        On return, R00 contains the effective address and R04 the    *
*        associated ALET.                                             *
*                                                                     *
***********************************************************************
         SPACE
EvalBD   DS    0H                   Base and displacement
         SLR   R00,R00              Value of the index is zero
         J     EA010                Go evaluate base, displacement
         SPACE
EvalXBD  DS    0H                   Index, base and displacement
         SLR   R00,R00              Clear R00
         IC    R01,XCell+1          rx
         N     R01,OOOOOOOF         0x
         JZ    EA010                Register zero implies no index
         SLL   R01,2                x*4
         L     R00,OldRegs(R01)     Value of the index
         SPACE
*---------------------------------------------------------------------*
*        At this point, R00 contains the value of the index           *
*---------------------------------------------------------------------*
         SPACE
EA010    DS    0H
         SLR   R04,R04              Default ALET value is zero
         IC    R01,0(,R02)          bd
         N     R01,OOOOOOFO         b0       base register
         JZ    EA030                Register zero implies no base
         SRL   R01,2                b*4
         CLI   TraceASC,ARmode      Q. In AR ASC mode?
         JNE   EA020                N. Use default ALET of zero
         L     R04,TraceARs(R01)    Y. Load associated ALET
         SPACE
EA020    DS    0H
         AL    R00,OldRegs(R01)     Index + base
         SPACE
EA030    DS    0H
         LH    R01,0(,R02)          bddd     base, displacement
         N     R01,OOOOOFFF         0ddd     displacement
         ALR   R01,R00              Index + base + displacement
         LA    R01,0(,R01)          Clear high order bit/byte
         LR    R00,R01              Load R00 with effective address
         BSM   0,R14                Return
         SPACE 3
*---------------------------------------------------------------------*
*        Evaluate address for a relative branch instruction           *
*---------------------------------------------------------------------*
         SPACE
EvalRI   DS    0H
         LH    R01,XCell+2          Load immediate value
         SLA   R01,1                Times 2 for number of halfwords
         TM    bAttribute4,bitEX    Q. EXECUTE'd relative branch?
         JO    EA100                Y. Relative to EX'ed instruction
         LA    R00,0(R01,R11)       N. Calculate effective address
         BSM   0,R14                   and return
         SPACE
EA100    DS    0H
         L     R02,aEX_Target       Address relative to the EXECUTE'd
         LA    R00,0(R01,R02)       ... instruction
         BSM   0,R14                and return
         TITLE 'Print Contents of General, Access and FP registers'
***********************************************************************
*        Register dump routines                                       *
*---------------------------------------------------------------------*
*        Contents of R00-R03 and R14-R15 are destroyed                *
*                                                                     *
***********************************************************************
         SPACE
DumpGPRs DS    0H                   Dump general registers
         LA    R02,TraceGPRs        Address of first 8 registers
         BRAS  R14,RPUT             Place them in print line
         MVI   PrL$CCB,C'0'         Double space next line
         MVC   PrL$Data+29(L'GRM0),GRM0   ' R00-R07  '
         BRAS  R14,Write            Print the line
         LA    R02,TraceGPRs+32     Address of 2nd 8 registers
         BRAS  R14,RPUT             Place them in print line
         MVC   Prl$Data+29(L'GRM8),GRM8   ' R08-R15  '
         BRAS  R14,Write            Print the line
         BSM   0,R12                Return
         SPACE 3
DumpARs  DS    0H                   Dump access registers
         LA    R02,TraceARs         Address of first 8 registers
         BRAS  R14,RPUT             Place them in print line
         MVI   PrL$CCB,C'0'         Double space next line
         MVC   PrL$Data+29(L'ARM0),ARM0   'AR00-AR07 '
         BRAS  R14,Write            Print the line
         LA    R02,TraceARs+32      Address of 2nd 8 registers
         BRAS  R14,RPUT             Place them in print line
         MVC   PrL$Data+29(L'ARM8),ARM8   'AR08-AR15 '
         BRAS  R14,Write            Print the line
         BSM   0,R12                Return
         SPACE 3
DumpFPRs DS    0H
         MVC   PrL$Data+29(L'FPM0),FPM0   'FPR0-FPR6'
         LA    R02,FPR0             Address of floating register table
         STD   0,FPR0               Load floating point register table
         STD   2,FPR2               ...
         STD   4,FPR4               ...
         STD   6,FPR6               ...
         BRAS  R14,RPUT             Format FP registers for printing
         BRAS  R14,Write            Print the line
         MVI   PrL$CCB,C'0'         Double space next line
         BSM   0,R12                Return
         SPACE 3
*---------------------------------------------------------------------*
*        Place eight registers into the print line                    *
*---------------------------------------------------------------------*
         SPACE
RPUT     DS    0H
         ST    R14,RPSAV            Save return address
         LA    R03,PrL$Data+40      Starting point in print line
         LHI   R15,8                Number of registers to print
         SPACE
RP010    DS    0H
         L     R00,0(,R02)          Get the value of a register
         BRAS  R14,HexToEBC         Convert it for printing
         STM   R00,R01,0(R03)       Place in print line
         SPACE
         LA    R02,4(,R02)          Point at next register
         SLR   R01,R01              Clear work register
         IC    R01,Offsets-1(R15)   Get offset to next field in line
         LA    R03,0(R01,R03)       Point to next field in print line
         BRCT  R15,RP010            Loop for eight fullwords
         SPACE
         L     R14,RPSAV            Load return address
         BSM   0,R14                ... and return
         TITLE 'Formatted Date and Time'
***********************************************************************
*                                                                     *
*        Format current date and time for display                     *
*                                                                     *
***********************************************************************
         SPACE
TimeStamp DS   0H
         ST    R14,TSSAV             Save return address
         MVC   PageDate,=X'21202020612020612020'
         MVC   PageTime,=X'4021207A20207A20204B202020202020'
         SPACE
         TIME  DEC,WorkCL16,DATETYPE=YYYYMMDD,                         X
               LINKAGE=SYSTEM,MF=(E,cplTIME)
         SPACE
         OI    WorkCL16+7,X'0F'      Force displayable packed sign
         SRP   WorkCL16(8),64-2,0    Shift off trailing zeros
         ED    PageTime,WorkCL16+1
         SPACE
         MVI   WorkCL16+12,X'0F'     Set packed sign
         ED    PageDate,WorkCL16+8
         SPACE
         L     R14,TSSAV             Reload return address
         BSM   0,R14                 ... and return to caller
         SPACE 2
         LTORG ,
         TITLE 'SVC Special Operand Processing Routines'
***********************************************************************
*        Format special operands for SVC print line                   *
*---------------------------------------------------------------------*
*        R01 points to area after SVC macro name                      *
*                                                                     *
***********************************************************************
         SPACE
SVC@06   DS    0H                   LINK
SVC@07   DS    0H                   XCTL
         L     R15,OldRegs+(4*15)   Address of parameter list
         L     R15,0(,R15)          Address of module name
         MVC   0(8,R01),0(R15)      Copy to print line
         BSM   0,R14                and return
         SPACE 2
SVC@08   DS    0H                   LOAD
         L     R00,OldRegs+(4*0)    Address of module name
         CLI   OldRegs+(4*0),X'FF'  Q. Is address complemented?
         JNE   SVC@08A              N. Use it as it is
         LCR   R00,R00              Y. Uncomplement it
         SPACE
SVC@08A  DS    0H
         LR    R15,R00              Copy to usable address register
         MVC   0(8,R01),0(R15)      Copy module name to print line
         BSM   0,R14                and return
         SPACE 2
SVC@09   DS    0H                   DELETE
         L     R15,OldRegs+(4*0)    Address of module name
         MVC   0(8,R01),0(R15)      Copy to print line
         BSM   0,R14                and return
         SPACE 2
SVC@7A   DS    0H                   LINK/XCTL/LOAD
         LHI   R00,7                Extended route code for LINK
         CL    R00,OldRegs+(4*15)   Q. Possibly LINK/XCTL/LOAD?
         BLR   R14                  N. Do nothing
         LHI   R00,9                Y. Extended route code for LOAD
         CL    R00,OldRegs+(4*15)      Q. Definitely LINK/XCTL/LOAD?
         BHR   R14                     N. Do nothing
         L     R15,OldRegs+(4*1)       Y. Address of parmlist
         L     R15,0(,R15)                Address of module name
         MVC   0(8,R01),0(R15)            Copy to print line
         BSM   0,R14                      and return
         TITLE 'Program Constants'
***********************************************************************
*                                                                     *
*        P R O G R A M   C O N S T A N T S                            *
*                                                                     *
***********************************************************************
         SPACE
aOpCodes DC    A(OpCodes)           Address of instruction opcode table
aB2codes DC    A(B2codes)           X'B2' prefixed opcode table address
aA7codes DC    A(A7codes)           X'A7' prefixed opcode table address
a01codes DC    A(O1codes)           X'01' prefixed opcode table address
aSVCtable DC   A(SVCtable)          SVC mnemonic descriptor table
aSVC_Ops DC    A(SVCOPS)            SVC operand special processing tbl
aOpFlags DC    A(OpFlags)           Opcode bit flag table
aOpIndex DC    A(OpIndex)           Opcode bit flag table index
aB2index DC    A(B2Index)           X'B2' opcode bit flag table index
aA7index DC    A(A7Index)           X'A7' opcode bit flag table index
a01index DC    A(O1Index)           X'01' opcode bit flag table index
         SPACE
plUserExit DS  0A                   Exit parameter list
         DC    A(UsrFlag1)           - Address of status flags
         DC    A(TraceGPRs)          - Address of general registers
         DC    A(TraceARs)           - Address of access registers
         DC    A(TraceCC)            - Address of program's cond-codes
         DC    A(InstrPointer)       - Address of AMODE/Instruction-Ptr
         DC    A(StoreAddr)          - Storage exception address
         DC    A(PUTR+Bit0)          - Address of trace put routine
         DC    A(PLINE)              - Address of the print line
         DC    A(DumpVS+Bit0)        - Address of storage dump routine
         SPACE
OOOOOOOF DC    X'0000000F'          Masking constants
OOOOOOFO DC    X'000000F0'
OOOOOFFF DC    X'00000FFF'
OOOOFOOO DC    X'0000F000'
OFOOOOOO DC    X'0F000000'
OOOOOO3C DC    X'0000003C'
SevenFs  DC    X'7FFFFFFF'
BitZero  DC    X'80000000'
         SPACE
ASMTDLI  DC    CL8'ASMTDLI'         DL/I interface stub module name
AIBTDLI  DC    CL8'AIBTDLI'         New DL/I interface stub module name
SYSTRACE DC    C'SYSTRACE'          Default output ddname
EBDCC    DC    C'8421'              Characters for condition code
         SPACE
CCbits   DC    X'00000080'          Bits corresponding to the
         DC    X'00000040'          ... condition code
         DC    X'00000020'
         DC    X'00000010'
         SPACE
ILC1     DC    X'40000000'          Instruction length code of BALR
         SPACE
ASCmodes DC    C'PSAH'              Primary, Secondary, Access, Home
         SPACE
Offsets  DC    X'09090A090C090A09'
         SPACE
*                 0 1 2 3 4 5 6 7 8 9 A B C D E F
BitCount DC    X'00010102010202030102020302030304'
         SPACE
EDMask12 DC    XL12'402020202020202020202120'
EDmask20 DC    X'402020206B2020206B2020206B2020206B202120'
HexChar  DC    C'0123456789ABCDEF'
         SPACE
cpZero   DC    P'0'                 Packed constant 0
cpOne    DC    P'1'                 Packed constant 1
TwoTo32  DC    P'4294967296'        Two to the power of thirty two
PageLen  DC    P'58'                Number of lines on a page
         SPACE
DLIcall  DC    C'DFSLI000 - DL/I Language Interface'
*                0----+----1----+----2----+----3----+----4----+----5---
PCHEADER DC    C'1**** *********** instructions executed in address ran-
               ge ********-******** (xxxxxxxx)'
EPHEADER DC    C'1**** Execution profile data for address range *******-
               *-******** (xxxxxxxx)'
*              -+----6----+----7----+----8----+
BranchDir DC   C'<>'                Branch direction indicator
FPM0     DC    C'FPR0-FPR6'
GRM0     DC    C'GR00-GR07'
GRM8     DC    C'GR08-GR15'
ARM0     DC    C'AR00-AR07'
ARM8     DC    C'AR08-AR15'
IlglMsg  DC    C'0****    Illegal  Instruction  ****'
EndMsg1  DC    C'  Resuming execution at: '
EndMsg2  DC    C'instructions traced this run (out of a total of '
UnMatchedPR DC C'0TRACE terminated by unmatched PR instruction'
NOEXEC   DC    C' - No instructions executed in this range'
SAME     DC    C'SAME'
         SPACE 2
NopInstr DS    0H                   NOPR instructions for padding
         NOPR  0                    ... ExecIns1 out to 6 bytes
         NOPR  0                    ...
         SPACE
MoveIdent MVC  IDstring(0),0(R14)   Save identification string
MoveSVC  MVC   PrL$SVC(0),0(R01)    Copy SVC mnemonic to print line
MoveExSVC MVC  PrL$ESVC(0),0(R01)   ditto but for executed SVC
PEFAMVC  MVC   WorkDblW(0),0(R02)   Get contents of storage operand
PEFACLR  MVC   1(0,R14),0(R14)      Blank end of operand
EXMVCEX  MVC   PSXCell(0),0(R01)    Get target instruction of execute
MoveEDMK MVC   0(0,R03),0(R01)      Move instruction count to prt line
JUMP     J     *+12                 JUMP (around module ID string)
BRANCH   B     0(0,R15)             BRANCH (around module ID string)
ABEND    DC    X'0A0D'              ABEND instruction
         SPACE
*---------------------------------------------------------------------*
*          Extended Mnemonics for BC/BCR and BRC                      *
*---------------------------------------------------------------------*
           SPACE
EMstandard DS    0F                      Standard table
           DC    C'NOP '                 0
           DC    C'BO  '                 1
           DC    C'BP  '                 2
           DC    C'    '                 3
           DC    C'BM  '                 4
           DC    C'    '                 5
           DC    C'    '                 6
           DC    C'BNZ '                 7
           DC    C'BZ  '                 8
           DC    C'    '                 9
           DC    C'    '                 A
           DC    C'BNM '                 B
           DC    C'    '                 C
           DC    C'BNP '                 D
           DC    C'BNO '                 E
           DC    C'B   '                 F
           SPACE 2
EMcompare  DS    0F                      After COMPARE instructions
           DC    C'NOP '                 0
           DC    C'BO  '                 1
           DC    C'BH  '                 2
           DC    C'    '                 3
           DC    C'BL  '                 4
           DC    C'    '                 5
           DC    C'    '                 6
           DC    C'BNE '                 7
           DC    C'BE  '                 8
           DC    C'    '                 9
           DC    C'    '                 A
           DC    C'BNL '                 B
           DC    C'    '                 C
           DC    C'BNH '                 D
           DC    C'BNO '                 E
           DC    C'B   '                 F
           SPACE 2
DDNchars DC    256X'FF'             Valid characters in ddnames and
         ORG   DDNchars+C'$'        ... load module member names
         DC    X'00'
         ORG   DDNchars+C'#'
         DC    X'00'
         ORG   DDNchars+C'@'
         DC    X'00'
         ORG   DDNchars+C' '
         DC    X'00'
         ORG   DDNchars+C'A'
         DC    9X'00'
         ORG   DDNchars+C'J'
         DC    9X'00'
         ORG   DDNchars+C'S'
         DC    8X'00'
         ORG   DDNchars+C'0'
         DC    10X'00'
         ORG   ,
         SPACE
EBCDIC   DC    256C'.'              Printable EBCDIC characters
         ORG   EBCDIC+X'40'
         DC    AL1(*-EBCDIC)
         ORG   EBCDIC+X'4A'
         DC    7AL1(*-EBCDIC)
         ORG   EBCDIC+X'5A'
         DC    8AL1(*-EBCDIC)
         ORG   EBCDIC+X'6A'
         DC    6AL1(*-EBCDIC)
         ORG   EBCDIC+X'79'
         DC    7AL1(*-EBCDIC)
         ORG   EBCDIC+X'81'
         DC    9AL1(*-EBCDIC)
         ORG   EBCDIC+X'91'
         DC    9AL1(*-EBCDIC)
         ORG   EBCDIC+X'A1'
         DC    9AL1(*-EBCDIC)
         ORG   EBCDIC+X'C0'
         DC    10AL1(*-EBCDIC)
         ORG   EBCDIC+X'D0'
         DC    10AL1(*-EBCDIC)
         ORG   EBCDIC+X'E0'
         DC    AL1(*-EBCDIC)
         ORG   EBCDIC+X'E2'
         DC    8AL1(*-EBCDIC)
         ORG   EBCDIC+X'F0'
         DC    10AL1(*-EBCDIC)
         ORG   ,
         SPACE 2
SVCOPS   DS    0A
SVC@06$$ DC    A(SVC@06)
SVC@07$$ DC    A(SVC@07)
SVC@08$$ DC    A(SVC@08)
SVC@09$$ DC    A(SVC@09)
SVC@7A$$ DC    A(SVC@7A)
         TITLE 'Instruction Mnemonics'
***********************************************************************
*                                                                     *
*        Isolate large (constant) data structures to relieve          *
*        addressibililty constraints in main CSECT.                   *
*                                                                     *
***********************************************************************
         SPACE
T390DATA RSECT
T390DATA AMODE ANY
T390DATA RMODE 24
         SPACE 2
OpCodes  DS    0C      * = Unsupported,  - = pre-XA only
         DC    C'???   X"01" ???   ???   SPM   BALR  BCTR  BCR   ' 00
         DC    C'-SSK  -ISK  SVC   BSM   BASSM BASR  MVCL  CLCL  ' 08
         DC    C'LPR   LNR   LTR   LCR   NR    CLR   OR    XR    ' 10
         DC    C'LR    CR    AR    SR    MR    DR    ALR   SLR   ' 18
         DC    C'LPDR  LNDR  LTDR  LCDR  HDR   LRDR  MXR   MXDR  ' 20
         DC    C'LDR   CDR   ADR   SDR   MDR   DDR   AWR   SWR   ' 28
         DC    C'LPER  LNER  LTER  LCER  HER   LRER  AXR   SXR   ' 30
         DC    C'LER   CER   AER   SER   MER   DER   AUR   SUR   ' 38
         DC    C'STH   LA    STC   IC    EX    BAL   BCT   BC    ' 40
         DC    C'LH    CH    AH    SH    MH    BAS   CVD   CVB   ' 48
         DC    C'ST    LAE   ???   ???   N     CL    O     X     ' 50
         DC    C'L     C     A     S     M     D     AL    SL    ' 58
         DC    C'STD   ???   ???   ???   ???   ???   ???   MXD   ' 60
         DC    C'LD    CD    AD    SD    MD    DD    AW    SW    ' 68
         DC    C'STE   MS    ???   ???   ???   ???   ???   ???   ' 70
         DC    C'LE    CE    AE    SE    ME    DE    AU    SU    ' 78
         DC    C'*SSM  ???   *LPSW *DIAG BRXH  BRXLE BXH   BXLE  ' 80
         DC    C'SRL   SLL   SRA   SLA   SRDL  SLDL  SRDA  SLDA  ' 88
         DC    C'STM   TM    MVI   TS    NI    CLI   OI    XI    ' 90
         DC    C'LM    *TRACELAM   STAM  -SIO  -TIO  -HIO  -TCH  ' 98
         DC    C'???   ???   ???   ???   *VAE+ *VAER+*VM+  X"A7" ' A0
         DC    C'MVCLE CLCLE ???   ???   *STNSM*STOSM*SIGP MC    ' A8
         DC    C'???   *LRA  X"B2" X"B3" ???   ???   *STCTL*LCTL ' B0
         DC    C'???   ???   CS    CDS   ???   CLM   STCM  ICM   ' B8
         DC    C'???   ???   ???   ???   ???   ???   ???   ???   ' C0
         DC    C'???   ???   ???   ???   ???   ???   ???   ???   ' C8
         DC    C'???   MVN   MVC   MVZ   NC    CLC   OC    XC    ' D0
         DC    C'???   MVCK  MVCP  MVCS  TR    TRT   ED    EDMK  ' D8
         DC    C'???   ???   ???   ???   *VLI+ *X"E5"???   ???   ' E0
         DC    C'MVCIN ???   ???   ???   ???   *X"ED"PLO   ???   ' E8
         DC    C'SRP   MVO   PACK  UNPK  ???   ???   ???   ???   ' F0
         DC    C'ZAP   CP    AP    SP    MP    DP    ???   ???   ' F8
         SPACE 3
B2codes  DS    0C
         DC    C'-CONC -DISC *STIDP-STIDC*SCK  STCK  *STKC *STCKC' 00
         DC    C'*SPT  *STPT SPKA  IPK   ???   *PTLB ???   ???   ' 08
         DC    C'*SPX  *STPX *STAP -RRB  ???   ???   ???   ???   ' 10
         DC    C'PC    SAC   CFC   ???   ???   ???   ???   ???   ' 18
         DC    C'SERVC *IPTE IPM   IVSK  IAC   SSAR  EPAR  ESAR  ' 20
         DC    C'PT    *ISKE *RRBE *SSKE *TB   DXR   ???   ???   ' 28
         DC    C'*CSCH *HSCH *MSCH *SSCH *STSCH*TSCH *TPI  *SAL  ' 30
         DC    C'*RSCH *STCRW*STCPS*RCHP *SCHM ???   ???   ???   ' 38
         DC    C'BAKR  CKSM  ???   ???   SQDR  SQER  *STURAMSTA  ' 40
         DC    C'*PALB EREG  ESTA  *LURA TAR   CPYA  SAR   EAR   ' 48
         DC    C'???   ???   MSR   ???   MVPG  MVST  ???   CUSE  ' 50
         DC    C'BSG   ???   BSA   ???   ???   CLST  SRST  ???   ' 58
         DC    C'???   ???   ???   CMPSC ???   ???   ???   ???   ' 60
         DC    C'???   ???   ???   ???   ???   ???   ???   ???   ' 68
         DC    C'???   ???   ???   ???   ???   ???   ???   RP    ' 70
         DC    C'STCKE SACF  ???   ???   ???   STSI  ???   ???   ' 78
         DC    C'???   ???   ???   ???   ???   ???   ???   ???   ' 80
         DC    C'???   ???   ???   ???   ???   ???   ???   ???   ' 88
         DC    C'???   ???   ???   ???   ???   ???   ???   ???   ' 90
         DC    C'???   SRNM  ???   ???   STFPC LFPC  ???   ???   ' 98
         DC    C'???   ???   ???   ???   ???   TRE   CUUTF CUTFU ' A0
         DC    C'???   ???   ???   ???   ???   ???   ???   ???   ' A8
         DC    C'???   ???   ???   ???   ???   ???   ???   ???   ' B0
         DC    C'???   ???   ???   ???   ???   ???   ???   ???   ' B8
         DC    C'???   ???   ???   ???   ???   ???   ???   ???   ' C0
         DC    C'???   ???   ???   ???   ???   ???   ???   ???   ' C8
         DC    C'???   ???   ???   ???   ???   ???   ???   ???   ' D0
         DC    C'???   ???   ???   ???   ???   ???   ???   ???   ' D8
         DC    C'???   ???   ???   ???   ???   ???   ???   ???   ' E0
         DC    C'???   ???   ???   ???   ???   ???   ???   ???   ' E8
         DC    C'???   ???   ???   ???   ???   ???   ???   ???   ' F0
         DC    C'???   ???   ???   ???   ???   ???   ???   TRAP4 ' F8
         SPACE 3
A7codes  DS    0C
         DC    C'TMH   TML   ???   ???   BRC   BRAS  BRCT  ???   ' 00
         DC    C'LHI   ???   AHI   ???   MHI   ???   CHI   ???   ' 08
         SPACE 3
O1codes  DS    0C
         DC    C'???   PR    UPT   ???   ???   ???   ???   ???   ' 00
         DC  30C'???   ???   ???   ???   ???   ???   ???   ???   ' ...
         DC    C'???   ???   ???   ???   ???   ???   ???   TRAP2 ' F8
         SPACE 3
         TITLE 'SVC Mnemonic Pointer table'
SVCtable DS    0A
         DC    A(SVC$00),AL2(L'SVC$00-1),AL2(65535)
         DC    A(SVC$01),AL2(L'SVC$01-1),AL2(65535)
         DC    A(SVC$02),AL2(L'SVC$02-1),AL2(65535)
         DC    A(SVC$03),AL2(L'SVC$02-1),AL2(65535)
         DC    A(SVC$04),AL2(L'SVC$04-1),AL2(65535)
         DC    A(SVC$05),AL2(L'SVC$05-1),AL2(65535)
         DC    A(SVC$06),AL2(L'SVC$06-1),AL2(SVC@06$$-SVCOPS)
         DC    A(SVC$07),AL2(L'SVC$07-1),AL2(SVC@07$$-SVCOPS)
         DC    A(SVC$08),AL2(L'SVC$08-1),AL2(SVC@08$$-SVCOPS)
         DC    A(SVC$09),AL2(L'SVC$09-1),AL2(SVC@09$$-SVCOPS)
         DC    A(SVC$0A),AL2(L'SVC$0A-1),AL2(65535)
         DC    A(SVC$0B),AL2(L'SVC$0B-1),AL2(65535)
         DC    A(SVC$0C),AL2(L'SVC$0C-1),AL2(65535)
         DC    A(SVC$0D),AL2(L'SVC$0D-1),AL2(65535)
         DC    A(SVC$0E),AL2(L'SVC$0E-1),AL2(65535)
         DC    A(SVC$0F),AL2(L'SVC$0F-1),AL2(65535)
         DC    A(SVC$10),AL2(L'SVC$10-1),AL2(65535)
         DC    A(SVC$11),AL2(L'SVC$11-1),AL2(65535)
         DC    A(SVC$12),AL2(L'SVC$12-1),AL2(65535)
         DC    A(SVC$13),AL2(L'SVC$13-1),AL2(65535)
         DC    A(SVC$14),AL2(L'SVC$14-1),AL2(65535)
         DC    A(SVC$15),AL2(L'SVC$14-1),AL2(65535)
         DC    A(SVC$16),AL2(L'SVC$16-1),AL2(65535)
         DC    A(SVC$17),AL2(L'SVC$17-1),AL2(65535)
         DC    A(SVC$18),AL2(L'SVC$18-1),AL2(65535)
         DC    A(SVC$19),AL2(L'SVC$19-1),AL2(65535)
         DC    A(SVC$1A),AL2(L'SVC$1A-1),AL2(65535)
         DC    A(SVC$1B),AL2(L'SVC$1B-1),AL2(65535)
         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)
         DC    A(SVC$1D),AL2(L'SVC$1D-1),AL2(65535)
         DC    A(SVC$1E),AL2(L'SVC$1E-1),AL2(65535)
         DC    A(SVC$1F),AL2(L'SVC$1F-1),AL2(65535)
         DC    A(SVC$20),AL2(L'SVC$20-1),AL2(65535)
         DC    A(SVC$21),AL2(L'SVC$21-1),AL2(65535)
         DC    A(SVC$22),AL2(L'SVC$22-1),AL2(65535)
         DC    A(SVC$23),AL2(L'SVC$23-1),AL2(65535)
         DC    A(SVC$24),AL2(L'SVC$24-1),AL2(65535)
         DC    A(SVC$25),AL2(L'SVC$25-1),AL2(65535)
         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)
         DC    A(SVC$27),AL2(L'SVC$27-1),AL2(65535)
         DC    A(SVC$28),AL2(L'SVC$28-1),AL2(65535)
         DC    A(SVC$29),AL2(L'SVC$29-1),AL2(65535)
         DC    A(SVC$2A),AL2(L'SVC$2A-1),AL2(65535)
         DC    A(SVC$2B),AL2(L'SVC$2B-1),AL2(65535)
         DC    A(SVC$2C),AL2(L'SVC$2C-1),AL2(65535)
         DC    A(SVC$2D),AL2(L'SVC$2D-1),AL2(65535)
         DC    A(SVC$2E),AL2(L'SVC$2E-1),AL2(65535)
         DC    A(SVC$2F),AL2(L'SVC$2F-1),AL2(65535)
         DC    A(SVC$30),AL2(L'SVC$30-1),AL2(65535)
         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)
         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)
         DC    A(SVC$33),AL2(L'SVC$33-1),AL2(65535)
         DC    A(SVC$34),AL2(L'SVC$34-1),AL2(65535)
         DC    A(SVC$35),AL2(L'SVC$35-1),AL2(65535)
         DC    A(SVC$36),AL2(L'SVC$36-1),AL2(65535)
         DC    A(SVC$37),AL2(L'SVC$37-1),AL2(65535)
         DC    A(SVC$38),AL2(L'SVC$38-1),AL2(65535)
         DC    A(SVC$39),AL2(L'SVC$39-1),AL2(65535)
         DC    A(SVC$3A),AL2(L'SVC$3A-1),AL2(65535)
         DC    A(SVC$3B),AL2(L'SVC$3B-1),AL2(65535)
         DC    A(SVC$3C),AL2(L'SVC$3C-1),AL2(65535)
         DC    A(SVC$3D),AL2(L'SVC$3D-1),AL2(65535)
         DC    A(SVC$3E),AL2(L'SVC$3E-1),AL2(65535)
         DC    A(SVC$3F),AL2(L'SVC$3F-1),AL2(65535)
         DC    A(SVC$40),AL2(L'SVC$40-1),AL2(65535)
         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)
         DC    A(SVC$42),AL2(L'SVC$42-1),AL2(65535)
         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)
         DC    A(SVC$44),AL2(L'SVC$44-1),AL2(65535)
         DC    A(SVC$45),AL2(L'SVC$45-1),AL2(65535)
         DC    A(SVC$46),AL2(L'SVC$46-1),AL2(65535)
         DC    A(SVC$47),AL2(L'SVC$47-1),AL2(65535)
         DC    A(SVC$NM),AL2(L'SVC$NM-1),AL2(65535)
         DC    A(SVC$49),AL2(L'SVC$49-1),AL2(65535)
         DC    A(SVC$4A),AL2(L'SVC$4A-1),AL2(65535)
         DC    A(SVC$4B),AL2(L'SVC$4B-1),AL2(65535)
         DC    A(SVC$4C),AL2(L'SVC$4C-1),AL2(65535)
         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)
         DC    A(SVC$4E),AL2(L'SVC$4E-1),AL2(65535)
         DC    A(SVC$4F),AL2(L'SVC$4F-1),AL2(65535)
         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)
         DC    A(SVC$51),AL2(L'SVC$51-1),AL2(65535)
         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)
         DC    A(SVC$53),AL2(L'SVC$53-1),AL2(65535)
         DC    A(SVC$54),AL2(L'SVC$54-1),AL2(65535)
         DC    A(SVC$55),AL2(L'SVC$55-1),AL2(65535)
         DC    A(SVC$56),AL2(L'SVC$56-1),AL2(65535)
         DC    A(SVC$57),AL2(L'SVC$57-1),AL2(65535)
         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)
         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)
         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)
         DC    A(SVC$5B),AL2(L'SVC$5B-1),AL2(65535)
         DC    A(SVC$5C),AL2(L'SVC$5C-1),AL2(65535)
         DC    A(SVC$5D),AL2(L'SVC$5D-1),AL2(65535)
         DC    A(SVC$5E),AL2(L'SVC$5E-1),AL2(65535)
         DC    A(SVC$5F),AL2(L'SVC$5F-1),AL2(65535)
         DC    A(SVC$60),AL2(L'SVC$60-1),AL2(65535)
         DC    A(SVC$61),AL2(L'SVC$61-1),AL2(65535)
         DC    A(SVC$62),AL2(L'SVC$62-1),AL2(65535)
         DC    A(SVC$63),AL2(L'SVC$63-1),AL2(65535)
         DC    A(SVC$64),AL2(L'SVC$64-1),AL2(65535)
         DC    A(SVC$65),AL2(L'SVC$65-1),AL2(65535)
         DC    A(SVC$66),AL2(L'SVC$66-1),AL2(65535)
         DC    A(SVC$67),AL2(L'SVC$67-1),AL2(65535)
         DC    A(SVC$68),AL2(L'SVC$68-1),AL2(65535)
         DC    A(SVC$69),AL2(L'SVC$69-1),AL2(65535)
         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)
         DC    A(SVC$6B),AL2(L'SVC$6B-1),AL2(65535)
         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)
         DC    A(SVC$6D),AL2(L'SVC$6D-1),AL2(65535)
         DC    A(SVC$NM),AL2(L'SVC$NM-1),AL2(65535)
         DC    A(SVC$NM),AL2(L'SVC$NM-1),AL2(65535)
         DC    A(SVC$70),AL2(L'SVC$70-1),AL2(65535)
         DC    A(SVC$71),AL2(L'SVC$71-1),AL2(65535)
         DC    A(SVC$72),AL2(L'SVC$72-1),AL2(65535)
         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)
         DC    A(SVC$74),AL2(L'SVC$74-1),AL2(65535)
         DC    A(SVC$75),AL2(L'SVC$75-1),AL2(65535)
         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)
         DC    A(SVC$77),AL2(L'SVC$77-1),AL2(65535)
         DC    A(SVC$78),AL2(L'SVC$78-1),AL2(65535)
         DC    A(SVC$79),AL2(L'SVC$79-1),AL2(65535)
         DC    A(SVC$7A),AL2(L'SVC$7A-1),AL2(SVC@7A$$-SVCOPS)
         DC    A(SVC$7B),AL2(L'SVC$7B-1),AL2(65535)
         DC    A(SVC$7C),AL2(L'SVC$7C-1),AL2(65535)
         DC    A(SVC$7D),AL2(L'SVC$7D-1),AL2(65535)
         DC    A(SVC$7E),AL2(L'SVC$7E-1),AL2(65535)
         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)
         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)
         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)
         DC    A(SVC$82),AL2(L'SVC$82-1),AL2(65535)
         DC    A(SVC$83),AL2(L'SVC$83-1),AL2(65535)
         DC    A(SVC$84),AL2(L'SVC$84-1),AL2(65535)
         DC    A(SVC$85),AL2(L'SVC$85-1),AL2(65535)
         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)
         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)
         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)
         DC    A(SVC$89),AL2(L'SVC$89-1),AL2(65535)
         DC    A(SVC$8A),AL2(L'SVC$8A-1),AL2(65535)
         DC    A(SVC$8B),AL2(L'SVC$8B-1),AL2(65535)
         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)
         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)
         DC    A(SVC$RS),AL2(L'SVC$RS-1),AL2(65535)
         DC    A(SVC$8F),AL2(L'SVC$8F-1),AL2(65535)
HighSVC  EQU   ((*-SVCtable)/8)-1
         TITLE 'SVC Mnemonics'
SVC$NM   DC    C'NO MACRO'          For SVC's not generated by macros
SVC$RS   DC    C'RESERVED'          Unused SVC numbers reserved by IBM
SVC$00   DC    C'EXCP/XDAP'
SVC$01   DC    C'WAIT/WAITR/PRTOV'
SVC$02   DC    C'POST'
SVC$03   DC    C'EXIT'
SVC$04   DC    C'GETMAIN (Type 1)'
SVC$05   DC    C'FREEMAIN (Type 1)'
SVC$06   DC    C'LINK(X)'
SVC$07   DC    C'XCTL(X)'
SVC$08   DC    C'LOAD'
SVC$09   DC    C'DELETE'
SVC$0A   DC    C'GETMAIN/FREEMAIN (R OPERAND)'
SVC$0B   DC    C'TIME'
SVC$0C   DC    C'SYNCH(X)'
SVC$0D   DC    C'ABEND'
SVC$0E   DC    C'SPIE'
SVC$0F   DC    C'ERREXCP'
SVC$10   DC    C'PURGE'
SVC$11   DC    C'RESTORE'
SVC$12   DC    C'BLDL/FIND (Type D)'
SVC$13   DC    C'OPEN'
SVC$14   DC    C'CLOSE'
SVC$15   DC    C'STOW'
SVC$16   DC    C'OPEN (TYPE=J)'
SVC$17   DC    C'CLOSE (TYPE=T)'
SVC$18   DC    C'DEVTYPE'
SVC$19   DC    C'TRKBAL'
SVC$1A   DC    C'CATALOG/INDEX/LOCATE'
SVC$1B   DC    C'OBTAIN'
SVC$1D   DC    C'SCRATCH'
SVC$1E   DC    C'RENAME'
SVC$1F   DC    C'FEOV'
SVC$20   DC    C'REALLOC'
SVC$21   DC    C'IOHALT'
SVC$22   DC    C'MGCR(E)/QEDIT'
SVC$23   DC    C'WTO/WTOR'
SVC$24   DC    C'WTL'
SVC$25   DC    C'SEGLD/SEGWT'
SVC$27   DC    C'LABEL'
SVC$28   DC    C'EXTRACT'
SVC$29   DC    C'IDENTIFY'
SVC$2A   DC    C'ATTACH(X)'
SVC$2B   DC    C'CIRB'
SVC$2C   DC    C'CHAP'
SVC$2D   DC    C'OVLYBRCH'
SVC$2E   DC    C'STIMERM/TTIMER'
SVC$2F   DC    C'STIMER/STIMERM'
SVC$30   DC    C'DEQ'
SVC$33   DC    C'SNAP(X)/SDUMP(X)'
SVC$34   DC    C'RESTART'
SVC$35   DC    C'RELEX'
SVC$36   DC    C'DISABLE'
SVC$37   DC    C'EOV'
SVC$38   DC    C'ENQ/RESERVE'
SVC$39   DC    C'FREEDBUF'
SVC$3A   DC    C'RELBUF/REQBUF'
SVC$3B   DC    C'OLTEP'
SVC$3C   DC    C'STAE/ESTAE'
SVC$3D   DC    C'IKJEGS6A'
SVC$3E   DC    C'DETACH'
SVC$3F   DC    C'CHKPT'
SVC$40   DC    C'RDJFCB'
SVC$42   DC    C'BTAMTEST'
SVC$44   DC    C'SYNADAF/SYNADRLS'
SVC$45   DC    C'BSP'
SVC$46   DC    C'GSERV'
SVC$47   DC    C'ASGNBFR/BUFINQ/RLSEBFR'
SVC$49   DC    C'SPAR'
SVC$4A   DC    C'DAR'
SVC$4B   DC    C'DQUEUE'
SVC$4C   DC    C'IFBSTAT'
SVC$4E   DC    C'LSPACE'
SVC$4F   DC    C'STATUS'
SVC$51   DC    C'SETDEV/SETPRT'
SVC$53   DC    C'SMFWTM/SMFEWTM,BRANCH=NO'
SVC$54   DC    C'GRAPHICS'
SVC$55   DC    C'DDRSWAP'
SVC$56   DC    C'ATLAS'
SVC$57   DC    C'DOM'
SVC$5B   DC    C'VOLSTAT'
SVC$5C   DC    C'TCPEXCP'
SVC$5D   DC    C'TGET/TPG/TPUT'
SVC$5E   DC    C'STCC (PLUS OTHERS)'
SVC$5F   DC    C'SYSEVENT'
SVC$60   DC    C'STAX'
SVC$61   DC    C'IKJEGS9G'
SVC$62   DC    C'PROTECT'
SVC$63   DC    C'DYNALLOC'
SVC$64   DC    C'IKJEFFIB'
SVC$65   DC    C'QTIP'
SVC$66   DC    C'AQCTL'
SVC$67   DC    C'XLATE'
SVC$68   DC    C'TOPCTL'
SVC$69   DC    C'IMGLIB'
SVC$6B   DC    C'MODESET'
SVC$6D   DC    C'MFSTART/MFDATA/ESPIE/MSGDISP/ESR/OUTADD/OUTDEL'
SVC$70   DC    C'PGRLSE'
SVC$71   DC    C'PGANY/PGFIX/PGFREE/PGLOAD/PGOUT'
SVC$72   DC    C'EXCPVR'
SVC$74   DC    C'IECTRDTI/IECTATNR/CHNGNTRY/IECTCHGA/RESETPL/CALLDISP'
SVC$75   DC    C'DEBCHK'
SVC$77   DC    C'TESTAUTH'
SVC$78   DC    C'GETMAIN/FREEMAIN'
SVC$79   DC    C'VSAM'
SVC$7A   DC    C'EVENTS/LINK/XCTL/LOAD'
SVC$7B   DC    C'PURGEDQ'
SVC$7C   DC    C'TPIO'
SVC$7D   DC    C'EVENTS'
SVC$7E   DC    C'MSS (ICB2SVC)'
SVC$82   DC    C'RACHECK'
SVC$83   DC    C'RACINIT'
SVC$84   DC    C'RACLIST'
SVC$85   DC    C'RACDEF'
SVC$89   DC    C'ESR'
SVC$8A   DC    C'PGSER'
SVC$8B   DC    C'CVAFDIR/CVAFDSM/CVAFSEQ/CVAFVOL/CVAFVRF'
SVC$8F   DC    C'CIPHER/EMK/GENKEY/RETKEY'
         TITLE 'Instruction Attribute Flags'
OpFlags     DS    0F
            SPACE
*---------------------------------------------------------------------*
*           Attributes for RR format instructions                     *
*---------------------------------------------------------------------*
            SPACE
bAttrRR_00  DC    AL1(bitILGL,bitRR,0,0)
bAttrRR_01  DC    AL1(0,bitRR,0,0)                                LR
bAttrRR_02  DC    AL1(bitBR,bitRR,0,0)
bAttrRR_03  DC    AL1(bitBR+bitAMODE,bitRR,0,0)
bAttrRR_04  DC    AL1(bitCC,bitRR,0,0)
bAttrRR_05  DC    AL1(0,bitRR,bitDBLR,0)
bAttrRR_06  DC    AL1(bitACCESS,bitRR,0,bitDUMPR)                 SVC
bAttrRR_07  DC    AL1(bitCC+bitALTER,bitRR,0,0)                   MVCL
bAttrRR_08  DC    AL1(0,bitRR,0,bitFLOAT)
bAttrRR_09  DC    AL1(bitCC,bitRR,0,bitFLOAT)
bAttrRR_10  DC    AL1(0,bitRR,bitDBLR,bitFLOAT)
bAttrRR_11  DC    AL1(bitCC,bitRR,bitDBLR,bitFLOAT)
            SPACE
*---------------------------------------------------------------------*
*           Attributes for RX format instructions                     *
*---------------------------------------------------------------------*
            SPACE
bAttrRX_00  DC    AL1(bitILGL,bitRX,0,0)
bAttrRX_01  DC    AL1(0,bitRX,bitFULL,0)
bAttrRX_02  DC    AL1(0,bitRX,bitHALF,0)
bAttrRX_03  DC    AL1(0,bitRX,bitBYTE,0)                          IC
bAttrRX_04  DC    AL1(bitCC,bitRX,bitFULL,0)
bAttrRX_05  DC    AL1(bitCC,bitRX,bitHALF,0)
bAttrRX_06  DC    AL1(0,bitRX,bitDBLS,0)                          CVB
bAttrRX_07  DC    AL1(bitALTER,bitRX,bitFULL,0)                   ST
bAttrRX_08  DC    AL1(bitALTER,bitRX,bitHALF,0)                   STH
bAttrRX_09  DC    AL1(bitALTER,bitRX,bitBYTE,0)                   STC
bAttrRX_10  DC    AL1(bitALTER,bitRX,bitDBLS,0)                   CVD
bAttrRX_11  DC    AL1(bitBR,bitRX,0,bitEX)                        EX
bAttrRX_12  DC    AL1(bitBR,bitRX,0,0)
bAttrRX_13  DC    AL1(0,bitRX,bitNOREF,0)                         LA
bAttrRX_14  DC    AL1(0,bitRX,bitDBLR+bitFULL,0)
bAttrRX_15  DC    AL1(0,bitRX,bitFULL,bitFLOAT)
bAttrRX_16  DC    AL1(bitCC,bitRX,bitFULL,bitFLOAT)
bAttrRX_17  DC    AL1(bitALTER,bitRX,bitFULL,bitFLOAT)
bAttrRX_18  DC    AL1(0,bitRX,bitDBLR+bitDBLS,bitFLOAT)
bAttrRX_19  DC    AL1(bitCC,bitRX,bitDBLR+bitDBLS,bitFLOAT)
bAttrRX_20  DC    AL1(bitALTER,bitRX,bitDBLR+bitDBLS,bitFLOAT)    STD
bAttrRX_21  DC    AL1(bitACCESS,bitRX,bitNOREF,0)                 LAE
            SPACE
*---------------------------------------------------------------------*
*           Attributes for RS format instructions                     *
*---------------------------------------------------------------------*
            SPACE
bAttrRS_00  DC    AL1(bitILGL,bitRS,0,0)
bAttrRS_01  DC    AL1(bitBR,bitRS,0,0)
bAttrRS_02  DC    AL1(0,bitRS,bitSHIFT+bitNOREF,0)
bAttrRS_03  DC    AL1(bitCC,bitRS,bitSHIFT+bitNOREF,0)
bAttrRS_04  DC    AL1(0,bitRS,bitDBLR+bitSHIFT+bitNOREF,0)
bAttrRS_05  DC    AL1(bitCC,bitRS,bitDBLR+bitSHIFT+bitNOREF,0)
bAttrRS_06  DC    AL1(0,bitRS,0,bitDUMPR)                         LM
bAttrRS_07  DC    AL1(bitCC,bitRS,bitMASK,0)
bAttrRS_08  DC    AL1(bitCC+bitALTER,bitRS,bitDBLR+bitDBLS,0)     CDS
bAttrRS_09  DC    AL1(bitALTER,bitRS,0,bitDUMPR)
bAttrRS_10  DC    AL1(bitCC+bitALTER,bitRS,bitFULL,0)             CS
bAttrRS_11  DC    AL1(bitCC+bitALTER,bitRS,bitMASK,0)             STCM
bAttrRS_12  DC    AL1(bitACCESS,bitRS,0,bitDUMPR)                 LAM
            SPACE
*---------------------------------------------------------------------*
*           Attributes for RSI/RI format instructions                 *
*---------------------------------------------------------------------*
            SPACE
bAttrRI_00  DC    AL1(bitILGL,bitRSI,0,0)
bAttrRI_01  DC    AL1(bitBR,bitRSI,0,0)
bAttrRI_02  DC    AL1(bitCC,bitRSI,bitNOREF,0)
bAttrRI_03  DC    AL1(0,bitRSI,bitHALF+bitNOREF,0)                LHI
bAttrRI_04  DC    AL1(bitCC,bitRSI,bitHALF+bitNOREF,0)
            SPACE
*---------------------------------------------------------------------*
*           Attributes for SI format instructions                     *
*---------------------------------------------------------------------*
            SPACE
bAttrSI_00  DC    AL1(bitILGL,bitSI,0,0)
bAttrSI_01  DC    AL1(0,bitSI,bitNOREF,0)                         MC
bAttrSI_02  DC    AL1(bitCC,bitSI,bitBYTE,0)
bAttrSI_03  DC    AL1(bitALTER,bitSI,bitBYTE,0)                   MVI
bAttrSI_04  DC    AL1(bitCC+bitALTER,bitSI,bitBYTE,0)
            SPACE
*---------------------------------------------------------------------*
*           Attributes for S format instructions                      *
*---------------------------------------------------------------------*
            SPACE
bAttrS_00   DC    AL1(bitILGL,bitSSI,0,0)
bAttrS_01   DC    AL1(0,bitSSI,bitNOREF,0)
bAttrS_02   DC    AL1(bitCC+bitALTER,bitSSI,bitDBLS,0)            STCK
bAttrS_03   DC    AL1(bitCC+bitALTER,bitSSI,bitBYTE,0)            TS
bAttrS_04   DC    AL1(bitACCESS,bitSSI,bitNOREF,bitDUMPR)         PC
bAttrS_05   DC    AL1(bitCC,bitSSI,bitNOREF,0)                    CFC
bAttrS_06   DC    AL1(bitACCESS,bitSSI,bitNOREF,0)
            SPACE
*---------------------------------------------------------------------*
*           Attributes for SS format instructions                     *
*---------------------------------------------------------------------*
            SPACE
bAttrSS_00  DC    AL1(bitILGL,bitSS,0,0)
bAttrSS_01  DC    AL1(bitCC,bitSS+bitIMDF,0,0)
bAttrSS_02  DC    AL1(bitALTER,bitSS+bitIMDF,0,0)
bAttrSS_03  DC    AL1(bitCC+bitALTER,bitSS+bitIMDF,0,0)
bAttrSS_04  DC    AL1(bitCC+bitPACKD,bitSS,0,0)                   CP
bAttrSS_05  DC    AL1(bitPACKD+bitALTER,bitSS,0,0)
bAttrSS_06  DC    AL1(bitCC+bitPACKD+bitALTER,bitSS,0,0)
bAttrSS_07  DC    AL1(bitCC+bitMVCX,bitSS,0,0)                    MVCS
bAttrSS_08  DC    AL1(bitCC+bitMVCX+bitALTER,bitSS,0,0)
            SPACE
*---------------------------------------------------------------------*
*           Attributes for RRE format instructions                    *
*---------------------------------------------------------------------*
            SPACE
bAttrRRE_00 DC    AL1(bitILGL,bitRRE,0,0)
bAttrRRE_01 DC    AL1(0,bitRRE,0,0)
bAttrRRE_02 DC    AL1(bitCC,bitRRE,0,0)
bAttrRRE_03 DC    AL1(0,bitRRE,bitDBLR,bitFLOAT)                  DXR
bAttrRRE_04 DC    AL1(bitBR+bitACCESS,bitRRE,0,bitDUMPR)          BAKR
bAttrRRE_05 DC    AL1(bitCC+bitALTER,bitRRE,0,0)                  MVST
bAttrRRE_06 DC    AL1(bitCC,bitRRE,bitDBLR,0)
bAttrRRE_07 DC    AL1(bitACCESS,bitRRE,0,0)
bAttrRRE_08 DC    AL1(bitCC+bitACCESS,bitRRE,0,0)                 MVPG
bAttrRRE_09 DC    AL1(0,bitRRE,bitDBLR,0)
bAttrRRE_10 DC    AL1(bitACCESS,bitRRE,0,bitDUMPR)                EREG
            SPACE
*---------------------------------------------------------------------*
*           Attributes for E format instructions                      *
*---------------------------------------------------------------------*
            SPACE
bAttrE_00   DC    AL1(bitILGL,bitRR,0,0)
bAttrE_01   DC    AL1(0,bitRR,0,0)                                TRAP2
bAttrE_02   DC    AL1(bitCC,bitRR,0,0)                            UPT
bAttrE_03   DC    AL1(bitBR+bitACCESS+bitAMODE,bitRR,0,bitDUMPR)  PR
         TITLE 'Instruction Attributes Index Table'
OpIndex  DS    0H                       * = privileged, - = pre-XA only
         DC    AL2(bAttrRR_00-OpFlags)   00  ...
         DC    AL2(bAttrE_00-OpFlags)    01  PR/UPT/TRAP2/SCKPF
         DC    AL2(bAttrRR_04-OpFlags)   02  ...
         DC    AL2(bAttrRR_00-OpFlags)   03  ...
         DC    AL2(bAttrRR_04-OpFlags)   04  SPM
         DC    AL2(bAttrRR_02-OpFlags)   05  BALR
         DC    AL2(bAttrRR_02-OpFlags)   06  BCTR
         DC    AL2(bAttrRR_02-OpFlags)   07  BCR
         DC    AL2(bAttrRR_00-OpFlags)   08 *SSK-
         DC    AL2(bAttrRR_00-OpFlags)   09 *ISK-
         DC    AL2(bAttrRR_06-OpFlags)   0A  SVC
         DC    AL2(bAttrRR_03-OpFlags)   0B  BSM
         DC    AL2(bAttrRR_03-OpFlags)   0C  BASSM
         DC    AL2(bAttrRR_02-OpFlags)   0D  BASR
         DC    AL2(bAttrRR_07-OpFlags)   0E  MVCL
         DC    AL2(bAttrRR_04-OpFlags)   0F  CLCL
         SPACE
         DC    AL2(bAttrRR_04-OpFlags)   10  LPR
         DC    AL2(bAttrRR_04-OpFlags)   11  LNR
         DC    AL2(bAttrRR_04-OpFlags)   12  LTR
         DC    AL2(bAttrRR_04-OpFlags)   13  LCR
         DC    AL2(bAttrRR_04-OpFlags)   14  NR
         DC    AL2(bAttrRR_04-OpFlags)   15  CLR
         DC    AL2(bAttrRR_04-OpFlags)   16  OR
         DC    AL2(bAttrRR_04-OpFlags)   17  XR
         DC    AL2(bAttrRR_01-OpFlags)   18  LR
         DC    AL2(bAttrRR_04-OpFlags)   19  CR
         DC    AL2(bAttrRR_04-OpFlags)   1A  AR
         DC    AL2(bAttrRR_04-OpFlags)   1B  SR
         DC    AL2(bAttrRR_05-OpFlags)   1C  MR
         DC    AL2(bAttrRR_05-OpFlags)   1D  DR
         DC    AL2(bAttrRR_04-OpFlags)   1E  ALR
         DC    AL2(bAttrRR_04-OpFlags)   1F  SLR
         SPACE
         DC    AL2(bAttrRR_11-OpFlags)   20  LPDR
         DC    AL2(bAttrRR_11-OpFlags)   21  LNDR
         DC    AL2(bAttrRR_11-OpFlags)   22  LTDR
         DC    AL2(bAttrRR_11-OpFlags)   23  LCDR
         DC    AL2(bAttrRR_10-OpFlags)   24  HDR
         DC    AL2(bAttrRR_10-OpFlags)   25  LRDR
         DC    AL2(bAttrRR_10-OpFlags)   26  MXR
         DC    AL2(bAttrRR_10-OpFlags)   27  MXDR
         DC    AL2(bAttrRR_10-OpFlags)   28  LDR
         DC    AL2(bAttrRR_11-OpFlags)   29  CDR
         DC    AL2(bAttrRR_11-OpFlags)   2A  ADR
         DC    AL2(bAttrRR_11-OpFlags)   2B  SDR
         DC    AL2(bAttrRR_10-OpFlags)   2C  MDR
         DC    AL2(bAttrRR_10-OpFlags)   2D  DDR
         DC    AL2(bAttrRR_11-OpFlags)   2E  AWR
         DC    AL2(bAttrRR_11-OpFlags)   2F  SWR
         SPACE
         DC    AL2(bAttrRR_09-OpFlags)   30  LPER
         DC    AL2(bAttrRR_09-OpFlags)   31  LNER
         DC    AL2(bAttrRR_09-OpFlags)   32  LTER
         DC    AL2(bAttrRR_09-OpFlags)   33  LCER
         DC    AL2(bAttrRR_08-OpFlags)   34  HER
         DC    AL2(bAttrRR_08-OpFlags)   35  LRER
         DC    AL2(bAttrRR_11-OpFlags)   36  AXR
         DC    AL2(bAttrRR_11-OpFlags)   37  SXR
         DC    AL2(bAttrRR_08-OpFlags)   38  LER
         DC    AL2(bAttrRR_09-OpFlags)   39  CER
         DC    AL2(bAttrRR_09-OpFlags)   3A  AER
         DC    AL2(bAttrRR_09-OpFlags)   3B  SER
         DC    AL2(bAttrRR_08-OpFlags)   3C  MER
         DC    AL2(bAttrRR_08-OpFlags)   3D  DER
         DC    AL2(bAttrRR_09-OpFlags)   3E  AUR
         DC    AL2(bAttrRR_09-OpFlags)   3F  SUR
         SPACE
         DC    AL2(bAttrRX_08-OpFlags)   40  STH
         DC    AL2(bAttrRX_13-OpFlags)   41  LA
         DC    AL2(bAttrRX_09-OpFlags)   42  STC
         DC    AL2(bAttrRX_03-OpFlags)   43  IC
         DC    AL2(bAttrRX_11-OpFlags)   44  EX
         DC    AL2(bAttrRX_12-OpFlags)   45  BAL
         DC    AL2(bAttrRX_12-OpFlags)   46  BCT
         DC    AL2(bAttrRX_12-OpFlags)   47  BC
         DC    AL2(bAttrRX_02-OpFlags)   48  LH
         DC    AL2(bAttrRX_05-OpFlags)   49  CH
         DC    AL2(bAttrRX_05-OpFlags)   4A  AH
         DC    AL2(bAttrRX_05-OpFlags)   4B  SH
         DC    AL2(bAttrRX_02-OpFlags)   4C  MH
         DC    AL2(bAttrRX_12-OpFlags)   4D  BAS
         DC    AL2(bAttrRX_10-OpFlags)   4E  CVD
         DC    AL2(bAttrRX_06-OpFlags)   4F  CVB
         SPACE
         DC    AL2(bAttrRX_07-OpFlags)   50  ST
         DC    AL2(bAttrRX_21-OpFlags)   51  LAE
         DC    AL2(bAttrRX_00-OpFlags)   52  ...
         DC    AL2(bAttrRX_00-OpFlags)   53  ...
         DC    AL2(bAttrRX_04-OpFlags)   54  N
         DC    AL2(bAttrRX_04-OpFlags)   55  CL
         DC    AL2(bAttrRX_04-OpFlags)   56  O
         DC    AL2(bAttrRX_04-OpFlags)   57  X
         DC    AL2(bAttrRX_01-OpFlags)   58  L
         DC    AL2(bAttrRX_04-OpFlags)   59  C
         DC    AL2(bAttrRX_04-OpFlags)   5A  A
         DC    AL2(bAttrRX_04-OpFlags)   5B  S
         DC    AL2(bAttrRX_14-OpFlags)   5C  M
         DC    AL2(bAttrRX_14-OpFlags)   5D  D
         DC    AL2(bAttrRX_04-OpFlags)   5E  AL
         DC    AL2(bAttrRX_04-OpFlags)   5F  SL
         SPACE
         DC    AL2(bAttrRX_20-OpFlags)   60  STD
         DC    AL2(bAttrRX_00-OpFlags)   61  ...
         DC    AL2(bAttrRX_00-OpFlags)   62  ...
         DC    AL2(bAttrRX_00-OpFlags)   63  ...
         DC    AL2(bAttrRX_00-OpFlags)   64  ...
         DC    AL2(bAttrRX_00-OpFlags)   65  ...
         DC    AL2(bAttrRX_00-OpFlags)   66  ...
         DC    AL2(bAttrRX_18-OpFlags)   67  MXD
         DC    AL2(bAttrRX_18-OpFlags)   68  LD
         DC    AL2(bAttrRX_19-OpFlags)   69  CD
         DC    AL2(bAttrRX_19-OpFlags)   6A  AD
         DC    AL2(bAttrRX_19-OpFlags)   6B  SD
         DC    AL2(bAttrRX_18-OpFlags)   6C  MD
         DC    AL2(bAttrRX_19-OpFlags)   6D  DD
         DC    AL2(bAttrRX_19-OpFlags)   6E  AW
         DC    AL2(bAttrRX_19-OpFlags)   6F  SW
         SPACE
         DC    AL2(bAttrRX_17-OpFlags)   70  STE
         DC    AL2(bAttrRX_01-OpFlags)   71  MS
         DC    AL2(bAttrRX_00-OpFlags)   72  ...
         DC    AL2(bAttrRX_00-OpFlags)   73  ...
         DC    AL2(bAttrRX_00-OpFlags)   74  ...
         DC    AL2(bAttrRX_00-OpFlags)   75  ...
         DC    AL2(bAttrRX_00-OpFlags)   76  ...
         DC    AL2(bAttrRX_00-OpFlags)   77  ...
         DC    AL2(bAttrRX_15-OpFlags)   78  LE
         DC    AL2(bAttrRX_16-OpFlags)   79  CE
         DC    AL2(bAttrRX_16-OpFlags)   7A  AE
         DC    AL2(bAttrRX_16-OpFlags)   7B  SE
         DC    AL2(bAttrRX_15-OpFlags)   7C  ME
         DC    AL2(bAttrRX_15-OpFlags)   7D  DE
         DC    AL2(bAttrRX_16-OpFlags)   7E  AU
         DC    AL2(bAttrRX_16-OpFlags)   7F  AU
         SPACE
         DC    AL2(bAttrS_00-OpFlags)    80 *SSM
         DC    AL2(bAttrS_00-OpFlags)    81  ...
         DC    AL2(bAttrS_00-OpFlags)    82 *LPSW
         DC    AL2(bAttrS_00-OpFlags)    83 *DIAG
         DC    AL2(bAttrRI_01-OpFlags)   84  BRXH
         DC    AL2(bAttrRI_01-OpFlags)   85  BRXLE
         DC    AL2(bAttrRS_01-OpFlags)   86  BXH
         DC    AL2(bAttrRS_01-OpFlags)   87  BXLE
         DC    AL2(bAttrRS_02-OpFlags)   88  SRL
         DC    AL2(bAttrRS_02-OpFlags)   89  SLL
         DC    AL2(bAttrRS_03-OpFlags)   8A  SRA
         DC    AL2(bAttrRS_03-OpFlags)   8B  SLA
         DC    AL2(bAttrRS_04-OpFlags)   8C  SRDL
         DC    AL2(bAttrRS_04-OpFlags)   8D  SLDL
         DC    AL2(bAttrRS_05-OpFlags)   8E  SRDA
         DC    AL2(bAttrRS_05-OpFlags)   8F  SLDA
         SPACE
         DC    AL2(bAttrRS_09-OpFlags)   90  STM
         DC    AL2(bAttrSI_02-OpFlags)   91  TM
         DC    AL2(bAttrSI_03-OpFlags)   92  MVI
         DC    AL2(bAttrS_03-OpFlags)    93  TS
         DC    AL2(bAttrSI_04-OpFlags)   94  NI
         DC    AL2(bAttrSI_02-OpFlags)   95  CLI
         DC    AL2(bAttrSI_04-OpFlags)   96  OI
         DC    AL2(bAttrSI_04-OpFlags)   97  XI
         DC    AL2(bAttrRS_06-OpFlags)   98  LM
         DC    AL2(bAttrRS_00-OpFlags)   99 *TRACE
         DC    AL2(bAttrRS_12-OpFlags)   9A  LAM
         DC    AL2(bAttrRS_09-OpFlags)   9B  STAM
         DC    AL2(bAttrS_00-OpFlags)    9C *SIO-
         DC    AL2(bAttrS_00-OpFlags)    9D *TIO-
         DC    AL2(bAttrS_00-OpFlags)    9E *HIO-
         DC    AL2(bAttrS_00-OpFlags)    9F *TCH-
         SPACE
         DC    AL2(bAttrS_00-OpFlags)    A0  ...
         DC    AL2(bAttrS_00-OpFlags)    A1  ...
         DC    AL2(bAttrS_00-OpFlags)    A2  ...
         DC    AL2(bAttrS_00-OpFlags)    A3  ...
         DC    AL2(bAttrS_00-OpFlags)    A4  VAE
         DC    AL2(bAttrS_00-OpFlags)    A5  VAER
         DC    AL2(bAttrS_00-OpFlags)    A6  VM
         DC    AL2(bAttrS_00-OpFlags)    A7  A7rx
         DC    AL2(bAttrRR_07-OpFlags)   A8  MVCLE
         DC    AL2(bAttrRR_04-OpFlags)   A9  CLCLE
         DC    AL2(bAttrS_00-OpFlags)    AA  ...
         DC    AL2(bAttrS_00-OpFlags)    AB  ...
         DC    AL2(bAttrSI_00-OpFlags)   AC *STNSM
         DC    AL2(bAttrSI_00-OpFlags)   AD *STOSM
         DC    AL2(bAttrRS_00-OpFlags)   AE *SIGP
         DC    AL2(bAttrSI_01-OpFlags)   AF  MC
         SPACE
         DC    AL2(bAttrSI_00-OpFlags)   B0  ...
         DC    AL2(bAttrRX_00-OpFlags)   B1 *LRA
         DC    AL2(bAttrS_00-OpFlags)    B2  B2xx
         DC    AL2(bAttrRRE_00-OpFlags)  B3  B3xx (HFP and BFP)
         DC    AL2(bAttrRS_00-OpFlags)   B4  ...
         DC    AL2(bAttrRS_00-OpFlags)   B5  ...
         DC    AL2(bAttrRS_00-OpFlags)   B6 *STCTL
         DC    AL2(bAttrRS_00-OpFlags)   B7 *LCTL
         DC    AL2(bAttrRS_00-OpFlags)   B8  ...
         DC    AL2(bAttrRS_00-OpFlags)   B9  ...
         DC    AL2(bAttrRS_10-OpFlags)   BA  CS
         DC    AL2(bAttrRS_08-OpFlags)   BB  CDS
         DC    AL2(bAttrRS_00-OpFlags)   BC  ...
         DC    AL2(bAttrRS_07-OpFlags)   BD  CLM
         DC    AL2(bAttrRS_11-OpFlags)   BE  STCM
         DC    AL2(bAttrRS_07-OpFlags)   BF  ICM
         SPACE
         DC    AL2(bAttrSS_00-OpFlags)   C0  ...
         DC    AL2(bAttrSS_00-OpFlags)   C1  ...
         DC    AL2(bAttrSS_00-OpFlags)   C2  ...
         DC    AL2(bAttrSS_00-OpFlags)   C3  ...
         DC    AL2(bAttrSS_00-OpFlags)   C4  ...
         DC    AL2(bAttrSS_00-OpFlags)   C5  ...
         DC    AL2(bAttrSS_00-OpFlags)   C6  ...
         DC    AL2(bAttrSS_00-OpFlags)   C7  ...
         DC    AL2(bAttrSS_00-OpFlags)   C8  ...
         DC    AL2(bAttrSS_00-OpFlags)   C9  ...
         DC    AL2(bAttrSS_00-OpFlags)   CA  ...
         DC    AL2(bAttrSS_00-OpFlags)   CB  ...
         DC    AL2(bAttrSS_00-OpFlags)   CC  ...
         DC    AL2(bAttrSS_00-OpFlags)   CD  ...
         DC    AL2(bAttrSS_00-OpFlags)   CE  ...
         DC    AL2(bAttrSS_00-OpFlags)   CF  ...
         SPACE
         DC    AL2(bAttrSS_00-OpFlags)   D0  ...
         DC    AL2(bAttrSS_02-OpFlags)   D1  MVN
         DC    AL2(bAttrSS_02-OpFlags)   D2  MVC
         DC    AL2(bAttrSS_02-OpFlags)   D3  MVZ
         DC    AL2(bAttrSS_03-OpFlags)   D4  NC
         DC    AL2(bAttrSS_01-OpFlags)   D5  CLC
         DC    AL2(bAttrSS_03-OpFlags)   D6  OC
         DC    AL2(bAttrSS_03-OpFlags)   D7  XC
         DC    AL2(bAttrSS_00-OpFlags)   D8  ...
         DC    AL2(bAttrSS_08-OpFlags)   D9  MVCK
         DC    AL2(bAttrSS_08-OpFlags)   DA  MVCP
         DC    AL2(bAttrSS_07-OpFlags)   DB  MVCS
         DC    AL2(bAttrSS_03-OpFlags)   DC  TR
         DC    AL2(bAttrSS_01-OpFlags)   DD  TRT
         DC    AL2(bAttrSS_03-OpFlags)   DE  ED
         DC    AL2(bAttrSS_03-OpFlags)   DF  EDMK
         SPACE
         DC    AL2(bAttrSS_00-OpFlags)   E0  ...
         DC    AL2(bAttrSS_00-OpFlags)   E1  ...
         DC    AL2(bAttrSS_00-OpFlags)   E2  ...
         DC    AL2(bAttrSS_00-OpFlags)   E3  ...
         DC    AL2(bAttrSS_00-OpFlags)   E4  ...
         DC    AL2(bAttrSS_00-OpFlags)   E5 *LASP/TPROT/MVCSK/MVCDK
         DC    AL2(bAttrSS_00-OpFlags)   E6  ...
         DC    AL2(bAttrSS_00-OpFlags)   E7  ...
         DC    AL2(bAttrSS_02-OpFlags)   E8  MVCIN
         DC    AL2(bAttrSS_00-OpFlags)   E9  ...
         DC    AL2(bAttrSS_00-OpFlags)   EA  ...
         DC    AL2(bAttrSS_00-OpFlags)   EB  ...
         DC    AL2(bAttrSS_00-OpFlags)   EC  ...
         DC    AL2(bAttrSS_00-OpFlags)   ED  EDxx (BFP instructions)
         DC    AL2(bAttrSS_00-OpFlags)   EE  PLO
         DC    AL2(bAttrSS_00-OpFlags)   EF  ...
         SPACE
         DC    AL2(bAttrSS_06-OpFlags)   F0  SRP
         DC    AL2(bAttrSS_05-OpFlags)   F1  MVO
         DC    AL2(bAttrSS_05-OpFlags)   F2  PACK
         DC    AL2(bAttrSS_05-OpFlags)   F3  UNPK
         DC    AL2(bAttrSS_00-OpFlags)   F4  ...
         DC    AL2(bAttrSS_00-OpFlags)   F5  ...
         DC    AL2(bAttrSS_00-OpFlags)   F6  ...
         DC    AL2(bAttrSS_00-OpFlags)   F7  ...
         DC    AL2(bAttrSS_06-OpFlags)   F8  ZAP
         DC    AL2(bAttrSS_04-OpFlags)   F9  CP
         DC    AL2(bAttrSS_06-OpFlags)   FA  AP
         DC    AL2(bAttrSS_06-OpFlags)   FB  SP
         DC    AL2(bAttrSS_05-OpFlags)   FC  MP
         DC    AL2(bAttrSS_05-OpFlags)   FD  DP
         DC    AL2(bAttrSS_00-OpFlags)   FE  ...
         DC    AL2(bAttrSS_00-OpFlags)   FF  ...
         SPACE 3
*---------------------------------------------------------------------*
*        Attributes for x'01' prefixed instructions                   *
*---------------------------------------------------------------------*
         SPACE
O1Index  DS    0H
         DC    AL2(bAttrE_00-OpFlags)    00  ...
         DC    AL2(bAttrE_03-OpFlags)    01  PR
         DC    AL2(bAttrE_02-OpFlags)    02  UPT
         DC 252AL2(bAttrE_00-OpFlags)    ??  ...   <--- Note repetition
         DC    AL2(bAttrE_01-OpFlags)    FF  TRAP2
         SPACE 3
*---------------------------------------------------------------------*
*        Attributes for x'A2' prefixed instructions                   *
*---------------------------------------------------------------------*
         SPACE
A7Index  DS    0H
         DC    AL2(bAttrRI_02-OpFlags)   00  TMH
         DC    AL2(bAttrRI_02-OpFlags)   01  TML
         DC    AL2(bAttrRI_00-OpFlags)   02  ...
         DC    AL2(bAttrRI_00-OpFlags)   03  ...
         DC    AL2(bAttrRI_01-OpFlags)   04  BRC
         DC    AL2(bAttrRI_01-OpFlags)   05  BRAS
         DC    AL2(bAttrRI_01-OpFlags)   06  BRCT
         DC    AL2(bAttrRI_00-OpFlags)   07  ...
         DC    AL2(bAttrRI_03-OpFlags)   08  LHI
         DC    AL2(bAttrRI_00-OpFlags)   09  ...
         DC    AL2(bAttrRI_04-OpFlags)   0A  AHI
         DC    AL2(bAttrRI_00-OpFlags)   0B  ...
         DC    AL2(bAttrRI_04-OpFlags)   0C  MHI
         DC    AL2(bAttrRI_00-OpFlags)   0D  ...
         DC    AL2(bAttrRI_04-OpFlags)   0E  CHI
         DC    AL2(bAttrRI_00-OpFlags)   0F  ...
         SPACE 3
*---------------------------------------------------------------------*
*        Attributes for x'B2' prefixed instructions                   *
*---------------------------------------------------------------------*
         SPACE
B2Index  DS    0H
         DC    AL2(bAttrS_00-OpFlags)    00 *CONCS-
         DC    AL2(bAttrS_00-OpFlags)    01 *DISCS-
         DC    AL2(bAttrS_00-OpFlags)    02 *STIDP
         DC    AL2(bAttrS_00-OpFlags)    03 *STIDC-
         DC    AL2(bAttrS_00-OpFlags)    04 *SCK
         DC    AL2(bAttrS_02-OpFlags)    05  STCK
         DC    AL2(bAttrS_00-OpFlags)    06 *SCKC
         DC    AL2(bAttrS_00-OpFlags)    07 *STCKC
         DC    AL2(bAttrS_00-OpFlags)    08 *SPT
         DC    AL2(bAttrS_00-OpFlags)    09 *STPT
         DC    AL2(bAttrS_01-OpFlags)    0A  SPKA
         DC    AL2(bAttrS_01-OpFlags)    0B  IPK
         DC    AL2(bAttrS_00-OpFlags)    0C  ...
         DC    AL2(bAttrS_00-OpFlags)    0D *PTLB
         DC    AL2(bAttrS_00-OpFlags)    0E  ...
         DC    AL2(bAttrS_00-OpFlags)    0F  ...
         SPACE
         DC    AL2(bAttrS_00-OpFlags)    10 *SPX
         DC    AL2(bAttrS_00-OpFlags)    11 *STPX
         DC    AL2(bAttrS_00-OpFlags)    12 *STAP
         DC    AL2(bAttrS_00-OpFlags)    13 *RRB-
         DC    AL2(bAttrS_00-OpFlags)    14  ...
         DC    AL2(bAttrS_00-OpFlags)    15  ...
         DC    AL2(bAttrS_00-OpFlags)    16  ...
         DC    AL2(bAttrS_00-OpFlags)    17  ...
         DC    AL2(bAttrS_04-OpFlags)    18  PC/PCF
         DC    AL2(bAttrS_06-OpFlags)    19  SAC
         DC    AL2(bAttrS_05-OpFlags)    1A  CFC
         DC    AL2(bAttrS_00-OpFlags)    1B  ...
         DC    AL2(bAttrS_00-OpFlags)    1C  ...
         DC    AL2(bAttrS_00-OpFlags)    1D  ...
         DC    AL2(bAttrS_00-OpFlags)    1E  ...
         DC    AL2(bAttrS_00-OpFlags)    1F  ...
         SPACE
         DC    AL2(bAttrRRE_00-OpFlags)  20  ...
         DC    AL2(bAttrRRE_00-OpFlags)  21 *IPTE
         DC    AL2(bAttrRRE_01-OpFlags)  22  IPM
         DC    AL2(bAttrRRE_01-OpFlags)  23  IVSK
         DC    AL2(bAttrRRE_02-OpFlags)  24  IAC
         DC    AL2(bAttrRRE_01-OpFlags)  25  SSAR
         DC    AL2(bAttrRRE_01-OpFlags)  26  EPAR
         DC    AL2(bAttrRRE_01-OpFlags)  27  ESAR
         DC    AL2(bAttrRRE_01-OpFlags)  28  PT
         DC    AL2(bAttrRRE_00-OpFlags)  29 *ISKE
         DC    AL2(bAttrRRE_00-OpFlags)  2A *RRBE
         DC    AL2(bAttrRRE_00-OpFlags)  2B *SSKE
         DC    AL2(bAttrRRE_00-OpFlags)  2C *TB
         DC    AL2(bAttrRRE_03-OpFlags)  2D  DXR
         DC    AL2(bAttrRRE_00-OpFlags)  2E  ...
         DC    AL2(bAttrRRE_00-OpFlags)  2F  ...
         SPACE
         DC    AL2(bAttrRRE_00-OpFlags)  30 *CSCH
         DC    AL2(bAttrRRE_00-OpFlags)  31 *HSCH
         DC    AL2(bAttrRRE_00-OpFlags)  32 *MSCH
         DC    AL2(bAttrRRE_00-OpFlags)  33 *SSCH
         DC    AL2(bAttrRRE_00-OpFlags)  34 *STSCH
         DC    AL2(bAttrRRE_00-OpFlags)  35 *TSCH
         DC    AL2(bAttrRRE_00-OpFlags)  36 *TPI
         DC    AL2(bAttrRRE_00-OpFlags)  37 *SAL
         DC    AL2(bAttrRRE_00-OpFlags)  38 *RSCH
         DC    AL2(bAttrRRE_00-OpFlags)  39 *STCRW
         DC    AL2(bAttrRRE_00-OpFlags)  3A *STCPS
         DC    AL2(bAttrRRE_00-OpFlags)  3B *RCHP
         DC    AL2(bAttrRRE_00-OpFlags)  3C *SCHM
         DC    AL2(bAttrRRE_00-OpFlags)  3D  ...
         DC    AL2(bAttrRRE_00-OpFlags)  3E  ...
         DC    AL2(bAttrRRE_00-OpFlags)  3F  ...
         SPACE
         DC    AL2(bAttrRRE_04-OpFlags)  40  BAKR
         DC    AL2(bAttrRRE_06-OpFlags)  41  CKSM
         DC    AL2(bAttrRRE_00-OpFlags)  42  ...
         DC    AL2(bAttrRRE_00-OpFlags)  43  ...
         DC    AL2(bAttrRRE_00-OpFlags)  44  ...
         DC    AL2(bAttrRRE_00-OpFlags)  45  ...
         DC    AL2(bAttrRRE_00-OpFlags)  46  STURA
         DC    AL2(bAttrRRE_09-OpFlags)  47  MSTA
         DC    AL2(bAttrRRE_00-OpFlags)  48  PALB
         DC    AL2(bAttrRRE_10-OpFlags)  49  EREG
         DC    AL2(bAttrRRE_06-OpFlags)  4A  ESTA
         DC    AL2(bAttrRRE_00-OpFlags)  4B  LURA
         DC    AL2(bAttrRRE_02-OpFlags)  4C  TAR
         DC    AL2(bAttrRRE_07-OpFlags)  4D  CPYA
         DC    AL2(bAttrRRE_07-OpFlags)  4E  SAR
         DC    AL2(bAttrRRE_01-OpFlags)  4F  EAR
         SPACE
         DC    AL2(bAttrRRE_00-OpFlags)  50  ...
         DC    AL2(bAttrRRE_00-OpFlags)  51  ...
         DC    AL2(bAttrRRE_00-OpFlags)  52  MSR
         DC    AL2(bAttrRRE_00-OpFlags)  53  ...
         DC    AL2(bAttrRRE_08-OpFlags)  54  MVPG
         DC    AL2(bAttrRRE_05-OpFlags)  55  MVST
         DC    AL2(bAttrRRE_00-OpFlags)  56  ...
         DC    AL2(bAttrRRE_06-OpFlags)  57  CUSE
         DC    AL2(bAttrRRE_00-OpFlags)  58  BSG
         DC    AL2(bAttrRRE_00-OpFlags)  59  ...
         DC    AL2(bAttrRRE_00-OpFlags)  5A  BSA
         DC    AL2(bAttrRRE_00-OpFlags)  5B  ...
         DC    AL2(bAttrRRE_00-OpFlags)  5C  ...
         DC    AL2(bAttrRRE_02-OpFlags)  5D  CLST
         DC    AL2(bAttrRRE_02-OpFlags)  5E  SRST
         DC    AL2(bAttrRRE_00-OpFlags)  5F  ...
         SPACE
         DC    AL2(bAttrRRE_00-OpFlags)  60  ...
         DC    AL2(bAttrRRE_00-OpFlags)  61  ...
         DC    AL2(bAttrRRE_00-OpFlags)  62  ...
         DC    AL2(bAttrRRE_06-OpFlags)  63  CMPSC
         DC    AL2(bAttrRRE_00-OpFlags)  64  ...
         DC    AL2(bAttrRRE_00-OpFlags)  65  ...
         DC    AL2(bAttrRRE_00-OpFlags)  66  ...
         DC    AL2(bAttrRRE_00-OpFlags)  67  ...
         DC    AL2(bAttrRRE_00-OpFlags)  68  ...
         DC    AL2(bAttrRRE_00-OpFlags)  69  ...
         DC    AL2(bAttrRRE_00-OpFlags)  6A  ...
         DC    AL2(bAttrRRE_00-OpFlags)  6B  ...
         DC    AL2(bAttrRRE_00-OpFlags)  6C  ...
         DC    AL2(bAttrRRE_00-OpFlags)  6D  ...
         DC    AL2(bAttrRRE_00-OpFlags)  6E  ...
         DC    AL2(bAttrRRE_00-OpFlags)  6F  ...
         SPACE
         DC    AL2(bAttrRRE_00-OpFlags)  70  ...
         DC    AL2(bAttrRRE_00-OpFlags)  71  ...
         DC    AL2(bAttrRRE_00-OpFlags)  72  ...
         DC    AL2(bAttrRRE_00-OpFlags)  73  ...
         DC    AL2(bAttrRRE_00-OpFlags)  74  ...
         DC    AL2(bAttrRRE_00-OpFlags)  75  ...
         DC    AL2(bAttrRRE_00-OpFlags)  76  ...
         DC    AL2(bAttrRRE_00-OpFlags)  77  RP
         DC    AL2(bAttrS_00-OpFlags)    78  STCKE
         DC    AL2(bAttrS_06-OpFlags)    79  SACF
         DC    AL2(bAttrS_00-OpFlags)    7A  ...
         DC    AL2(bAttrS_00-OpFlags)    7B  ...
         DC    AL2(bAttrS_00-OpFlags)    7C  ...
         DC    AL2(bAttrS_00-OpFlags)    7D *STSI
         DC    AL2(bAttrS_00-OpFlags)    7E  ...
         DC    AL2(bAttrS_00-OpFlags)    7F  ...
         SPACE
         DC    AL2(bAttrRRE_00-OpFlags)  80  ...
         DC    AL2(bAttrRRE_00-OpFlags)  81  ...
         DC    AL2(bAttrRRE_00-OpFlags)  82  ...
         DC    AL2(bAttrRRE_00-OpFlags)  83  ...
         DC    AL2(bAttrRRE_00-OpFlags)  84  ...
         DC    AL2(bAttrRRE_00-OpFlags)  85  ...
         DC    AL2(bAttrRRE_00-OpFlags)  86  ...
         DC    AL2(bAttrRRE_00-OpFlags)  87  ...
         DC    AL2(bAttrRRE_00-OpFlags)  88  ...
         DC    AL2(bAttrRRE_00-OpFlags)  89  ...
         DC    AL2(bAttrRRE_00-OpFlags)  8A  ...
         DC    AL2(bAttrRRE_00-OpFlags)  8B  ...
         DC    AL2(bAttrRRE_00-OpFlags)  8C  ...
         DC    AL2(bAttrRRE_00-OpFlags)  8D  ...
         DC    AL2(bAttrRRE_00-OpFlags)  8E  ...
         DC    AL2(bAttrRRE_00-OpFlags)  8F  ...
         SPACE
         DC    AL2(bAttrRRE_00-OpFlags)  90  ...
         DC    AL2(bAttrRRE_00-OpFlags)  91  ...
         DC    AL2(bAttrRRE_00-OpFlags)  92  ...
         DC    AL2(bAttrRRE_00-OpFlags)  93  ...
         DC    AL2(bAttrRRE_00-OpFlags)  94  ...
         DC    AL2(bAttrRRE_00-OpFlags)  95  ...
         DC    AL2(bAttrRRE_00-OpFlags)  96  ...
         DC    AL2(bAttrRRE_00-OpFlags)  97  ...
         DC    AL2(bAttrRRE_00-OpFlags)  98  ...
         DC    AL2(bAttrRRE_00-OpFlags)  99  SRNM
         DC    AL2(bAttrRRE_00-OpFlags)  9A  ...
         DC    AL2(bAttrRRE_00-OpFlags)  9B  ...
         DC    AL2(bAttrRRE_00-OpFlags)  9C  STFPC
         DC    AL2(bAttrRRE_00-OpFlags)  9D  LFPC
         DC    AL2(bAttrRRE_00-OpFlags)  9E  ...
         DC    AL2(bAttrRRE_00-OpFlags)  9F  ...
         SPACE
         DC    AL2(bAttrRRE_00-OpFlags)  A0  ...
         DC    AL2(bAttrRRE_00-OpFlags)  A1  ...
         DC    AL2(bAttrRRE_00-OpFlags)  A2  ...
         DC    AL2(bAttrRRE_00-OpFlags)  A3  ...
         DC    AL2(bAttrRRE_00-OpFlags)  A4  ...
         DC    AL2(bAttrRRE_00-OpFlags)  A5  TRE
         DC    AL2(bAttrRRE_00-OpFlags)  A6  CUUTF
         DC    AL2(bAttrRRE_00-OpFlags)  A7  CUTFU
         DC    AL2(bAttrRRE_00-OpFlags)  A8  ...
         DC    AL2(bAttrRRE_00-OpFlags)  A9  ...
         DC    AL2(bAttrRRE_00-OpFlags)  AA  ...
         DC    AL2(bAttrRRE_00-OpFlags)  AB  ...
         DC    AL2(bAttrRRE_00-OpFlags)  AC  ...
         DC    AL2(bAttrRRE_00-OpFlags)  AD  ...
         DC    AL2(bAttrRRE_00-OpFlags)  AE  ...
         DC    AL2(bAttrRRE_00-OpFlags)  AF  ...
         SPACE
         DC    AL2(bAttrRRE_00-OpFlags)  B0  ...
         DC    AL2(bAttrRRE_00-OpFlags)  B1  ...
         DC    AL2(bAttrRRE_00-OpFlags)  B2  ...
         DC    AL2(bAttrRRE_00-OpFlags)  B3  ...
         DC    AL2(bAttrRRE_00-OpFlags)  B4  ...
         DC    AL2(bAttrRRE_00-OpFlags)  B5  ...
         DC    AL2(bAttrRRE_00-OpFlags)  B6  ...
         DC    AL2(bAttrRRE_00-OpFlags)  B7  ...
         DC    AL2(bAttrRRE_00-OpFlags)  B8  ...
         DC    AL2(bAttrRRE_00-OpFlags)  B9  ...
         DC    AL2(bAttrRRE_00-OpFlags)  BA  ...
         DC    AL2(bAttrRRE_00-OpFlags)  BB  ...
         DC    AL2(bAttrRRE_00-OpFlags)  BC  ...
         DC    AL2(bAttrRRE_00-OpFlags)  BD  ...
         DC    AL2(bAttrRRE_00-OpFlags)  BE  ...
         DC    AL2(bAttrRRE_00-OpFlags)  BF  ...
         SPACE
         DC    AL2(bAttrRRE_00-OpFlags)  C0  ...
         DC    AL2(bAttrRRE_00-OpFlags)  C1  ...
         DC    AL2(bAttrRRE_00-OpFlags)  C2  ...
         DC    AL2(bAttrRRE_00-OpFlags)  C3  ...
         DC    AL2(bAttrRRE_00-OpFlags)  C4  ...
         DC    AL2(bAttrRRE_00-OpFlags)  C5  ...
         DC    AL2(bAttrRRE_00-OpFlags)  C6  ...
         DC    AL2(bAttrRRE_00-OpFlags)  C7  ...
         DC    AL2(bAttrRRE_00-OpFlags)  C8  ...
         DC    AL2(bAttrRRE_00-OpFlags)  C9  ...
         DC    AL2(bAttrRRE_00-OpFlags)  CA  ...
         DC    AL2(bAttrRRE_00-OpFlags)  CB  ...
         DC    AL2(bAttrRRE_00-OpFlags)  CC  ...
         DC    AL2(bAttrRRE_00-OpFlags)  CD  ...
         DC    AL2(bAttrRRE_00-OpFlags)  CE  ...
         DC    AL2(bAttrRRE_00-OpFlags)  CF  ...
         SPACE
         DC    AL2(bAttrRRE_00-OpFlags)  D0  ...
         DC    AL2(bAttrRRE_00-OpFlags)  D1  ...
         DC    AL2(bAttrRRE_00-OpFlags)  D2  ...
         DC    AL2(bAttrRRE_00-OpFlags)  D3  ...
         DC    AL2(bAttrRRE_00-OpFlags)  D4  ...
         DC    AL2(bAttrRRE_00-OpFlags)  D5  ...
         DC    AL2(bAttrRRE_00-OpFlags)  D6  ...
         DC    AL2(bAttrRRE_00-OpFlags)  D7  ...
         DC    AL2(bAttrRRE_00-OpFlags)  D8  ...
         DC    AL2(bAttrRRE_00-OpFlags)  D9  ...
         DC    AL2(bAttrRRE_00-OpFlags)  DA  ...
         DC    AL2(bAttrRRE_00-OpFlags)  DB  ...
         DC    AL2(bAttrRRE_00-OpFlags)  DC  ...
         DC    AL2(bAttrRRE_00-OpFlags)  DD  ...
         DC    AL2(bAttrRRE_00-OpFlags)  DE  ...
         DC    AL2(bAttrRRE_00-OpFlags)  DF  ...
         SPACE
         DC    AL2(bAttrRRE_00-OpFlags)  E0  ...
         DC    AL2(bAttrRRE_00-OpFlags)  E1  ...
         DC    AL2(bAttrRRE_00-OpFlags)  E2  ...
         DC    AL2(bAttrRRE_00-OpFlags)  E3  ...
         DC    AL2(bAttrRRE_00-OpFlags)  E4  ...
         DC    AL2(bAttrRRE_00-OpFlags)  E5  ...
         DC    AL2(bAttrRRE_00-OpFlags)  E6  ...
         DC    AL2(bAttrRRE_00-OpFlags)  E7  ...
         DC    AL2(bAttrRRE_00-OpFlags)  E8  ...
         DC    AL2(bAttrRRE_00-OpFlags)  E9  ...
         DC    AL2(bAttrRRE_00-OpFlags)  EA  ...
         DC    AL2(bAttrRRE_00-OpFlags)  EB  ...
         DC    AL2(bAttrRRE_00-OpFlags)  EC  ...
         DC    AL2(bAttrRRE_00-OpFlags)  ED  ...
         DC    AL2(bAttrRRE_00-OpFlags)  EE  ...
         DC    AL2(bAttrRRE_00-OpFlags)  EF  ...
         SPACE
         DC    AL2(bAttrRRE_00-OpFlags)  F0  ...
         DC    AL2(bAttrRRE_00-OpFlags)  F1  ...
         DC    AL2(bAttrRRE_00-OpFlags)  F2  ...
         DC    AL2(bAttrRRE_00-OpFlags)  F3  ...
         DC    AL2(bAttrRRE_00-OpFlags)  F4  ...
         DC    AL2(bAttrRRE_00-OpFlags)  F5  ...
         DC    AL2(bAttrRRE_00-OpFlags)  F6  ...
         DC    AL2(bAttrRRE_00-OpFlags)  F7  ...
         DC    AL2(bAttrRRE_00-OpFlags)  F8  ...
         DC    AL2(bAttrS_00-OpFlags)    F9  ...
         DC    AL2(bAttrS_00-OpFlags)    FA  ...
         DC    AL2(bAttrS_00-OpFlags)    FB  ...
         DC    AL2(bAttrS_00-OpFlags)    FC  ...
         DC    AL2(bAttrS_00-OpFlags)    FD  ...
         DC    AL2(bAttrS_00-OpFlags)    FE  ...
         DC    AL2(bAttrS_01-OpFlags)    FF  TRAP4
         TITLE 'Program Working Storage (Global)'
***********************************************************************
*                                                                     *
*        Modifiable code and storage areas                            *
*                                                                     *
***********************************************************************
         SPACE
Tr390$WS CSECT ,                    Origin of the modifiable data area
Tr390$WS AMODE 31
Tr390$WS RMODE 24
         SPACE
***********************************************************************
*        All references to R0t in the following labelled instructions *
*        are modified to reference a dynamically selected temporary   *
*        base register before the code sequence is invoked!           *
*                                                                     *
*        Uncomment the 'BR 0' instruction(s) below if you believe     *
*        your CPU's instruction pipeline is deep enough that any      *
*        instructions may have been prefetched BEFORE they are        *
*        modified by us.                                              *
*                                                                     *
***********************************************************************
         SPACE
*---------------------------------------------------------------------*
*        Execute an instruction from the traced program (no ARs)      *
*---------------------------------------------------------------------*
         SPACE
Execute1 DS    0H
*+++     BR    0                    Ensure that any instructions we    -
                                    ... zapped that are already in the -
                                    ... pipeline are discarded
         SPACE
         LM    R00,R15,TraceGPRs    Reload traced program's GPRs
         SPACE
         PUSH  USING
         DROP  R10                  Cannnot use R10 past this point
ExecIns1 DS    0XL6                 Executed instruction
         NOPR  0                    ... (padded with NOPR's)
         NOPR  0                    ...
         NOPR  0                    ...
Zap1BASR BASR  R0t,0                Temp addressibility to Tr390$WA
         USING *,R0t                ...
         SPACE
*---------------------------------------------------------------------*
*        Save the general registers used by the traced program        *
*---------------------------------------------------------------------*
         SPACE
Zap1STM  STM   R00,R15,TraceGPRs    Save traced program's GPRs
         IPM   R00                  Save the condition code
         DROP  R0t
         SPACE
         BASR  R01,0                Use R01 as temporary program base
         USING *,R01                ...
         SPACE
Zap1LA   LA    R15,4*R0t(0,0)       Offset to R0t in 'OldRegs'
         L     R14,OldRegs(R15)     Restore original value of R0t
         ST    R14,TraceGPRs(R15)   ...
         LM    R03,R13,SaveRegs+4*3 Restore callers registers
         LAM   AR14,AR01,HexZeros   Ensure "scratch" ARs are zero
         BSM   0,R03                and return to caller of 'ExecInst'
         POP   USING
         EJECT
***********************************************************************
*                                                                     *
*        Execute an instruction from the traced program (ARs used)    *
*                                                                     *
***********************************************************************
         SPACE
Execute2 DS    0H
*+++     BR    0                    Ensure that any instructions we    -
                                    ... zapped that are already in the -
                                    ... pipeline are discarded
         SPACE
         LM    R00,R09,TraceGPRs    Reload traced program's GPRs
         LM    R11,R15,TraceGPRs+4*11 ... except R10
         LAM   AR00,AR15,TraceARs   Reload traced program's access regs
         L     R10,(TraceGPRs-Tr390$WS)+4*10(R10,0) Reload traced R10
         SPACE
         PUSH  USING
         DROP  R10                  Cannnot use R10 past this point
ExecIns2 DS    0XL6                 Executed instruction
         NOPR  0                    ... (padded with NOPR's)
         NOPR  0                    ...
         NOPR  0                    ...
Zap2BASR BASR  R0t,0                Temp addressibility to Tr390$WA
         USING *,R0t                ...
         SPACE
*---------------------------------------------------------------------*
*        Save general & access registers used by the traced program   *
*---------------------------------------------------------------------*
         SPACE
Zap2ST   ST    R15,TraceGPRs+4*15   Save traced program's R15
Zap2EAR  EAR   R15,AR0t             Save copy of AR0t value in R15
Zap2LAM1 LAM   AR0t,AR0t,HexZeros   ... and then zero AR0t
Zap2STM  STM   R00,R14,TraceGPRs    Save traced program's GPRs
Zap2STAM STAM  AR00,AR15,TraceARs   Save traced program's ARs
Zap2LAM2 LAM   R00,R15,HexZeros     Clear all access registers
         IPM   R00                  Save the condition code
         DROP  R0t
         SPACE
         BASR  R01,0                Use R01 as temporary program base
         USING *,R01                ...
         SPACE
Zap2LA   LA    R02,4*R0t(0,0)       Offset to R0t in 'OldRegs'
         L     R14,OldRegs(R02)     Restore original value of R0t
         ST    R14,TraceGPRs(R02)   ...
         SPACE
         ST    R15,TraceARs(R02)    Save traced program's AR0t
         IAC   R02                  Save current ASC mode
         STCM  R02,B'0010',TraceASC ...
         NI    TraceASC,X'03'       ... and mask out any garbage
         LM    R03,R13,SaveRegs+4*3 Restore callers registers
         BSM   0,R03                and return to caller of 'ExecInst'
         POP   USING
         EJECT
***********************************************************************
*                                                                     *
*        Execute BAKR instruction (or return from PR instruction)     *
*                                                                     *
***********************************************************************
         SPACE
Execute3 DS    0H
         NI    Zap3BRC+1,X'0F'      NOP the JUMP
*+++     BR    0                    Flush instruction pipeline in case -
                                    ... Zap3BRC is already in it
         SR    R01,R01              Set PSW condition code bits to zero
         IPM   R01                  Get current program mask
         SLR   R02,R02              Clear for condition code insertion
         ICM   R02,B'1000',TraceCC  Get "traced" condition code
         SLL   R02,4                Shift condition code to bits 2-3
         OR    R01,R02              OR condition code with program mask
         SPM   R01                  Restore "trace" condition code
         SPACE
         LM    R00,R09,TraceGPRs    Reload traced program's GPRs
         LM    R11,R15,TraceGPRs+4*11 ... except R10
         LAM   AR00,AR15,TraceARs   Reload traced program's access regs
         L     R10,(TraceGPRs-Tr390$WS)+4*10(R10,0) Reload traced R10
         SPACE
         BAKR  0,0                  Form the stack state entry
         SPACE
*---------------------------------------------------------------------*
*        Traced PR instruction's always return to here                *
*---------------------------------------------------------------------*
         SPACE
Zap3BRC  J     Exec320              Jump for PR after TRACE terminated
         SPACE
*---------------------------------------------------------------------*
*        Restore environment after BAKR or PR (with trace active)     *
*---------------------------------------------------------------------*
         SPACE
         SLR   R00,R00              Ensure AR15 contains zero
         SAR   AR15,R00             ...
         PUSH  USING
         DROP  R10
         BASR  R15,0                Temp addressibility for LM
         USING *,R15                ...
         LM    R03,R13,SaveRegs+4*3 Restore our registers
         LAM   R00,R14,HexZeros     Clear all access registers
         POP   USING
         OI    Zap3BRC+1,X'F0'      Re-activate JUMP in case TRACE390  -
                                    ... is terminated for any reason
         CLI   XCell+1,$PR          Q. Is this a PR instruction?
         JE    Exec310              Y. Go do PR cleanup logic
         CLI   XCell+3,X'0F'        N. Q. Was it 'BAKR 0,15'?
         BNE   BP930                   N. Go complete BAKR processing
         B     BP350                   Y. Go check for module ID string
         SPACE
*---------------------------------------------------------------------*
*        Cleanup after executing a PR instruction (trace ACTIVE)      *
*---------------------------------------------------------------------*
         SPACE
Exec310  DS    0H
         IAC   R02                  Save unstacked ASC mode
         STCM  R02,B'0010',TraceASC ...
         NI    TraceASC,X'03'       ... and mask out any garbage
         L     R15,StackPtr         Load current local stack pointer
         LA    R14,BAKR_Stack       Point to start of local BAKR stack
         BCTR  R15,0                Offset to last used entry
         ST    R15,StackPtr         ... and update
         SLL   R15,3                Multiply by 8 (stack entry length)
         L     R00,0(R15,R14)       Get PR return address
         B     BP950                Finish up as a successful branch
         SPACE
*---------------------------------------------------------------------*
*        Restore environment after PR (trace NO LONGER ACTIVE)        *
*---------------------------------------------------------------------*
         SPACE
         PUSH  USING
         DROP  R10
Exec320  DS    0H
         BAKR  0,0                  Save state after (non-traced) PR
Zap3BRC2 BRC   0,Exec330            Branch NOP'ed by defaulted
         SLR   R15,R15              Ensure AR15 is zero
         SAR   AR15,R15             ...
         BASR  R15,0                Temp addressibility to this code
         USING *,R15                ...
         STM   R00,R14,TraceGPRs    Save (most of) callers general
         STAM  R00,R14,TraceARs     ... and access registers
         IAC   R02                  Save unstacked ASC mode
         STCM  R02,B'0010',TraceASC ...
         NI    TraceASC,X'03'       ... and mask out any garbage
         LAM   R00,R14,HexZeros     Clear all access registers
         LM    R07,R13,SaveRegs+4*7 Restore our base registers
         POP   USING
         SPACE
         OI    Zap3BRC2+1,X'F0'     Alter JNOP to J
*+++     B     R00                  Flush old Zap3BRC2 from pipline
         SPACE
         EREG  R15,R15              Reload R15/AR15 from untraced PR
         ST    R15,TraceGPRs+4*15   ... and save for resume processing
         STAM  AR15,AR15,TraceARs+4*14 ...
         L     R15,StackPtr         Load current local stack pointer
         LA    R14,BAKR_Stack       Point to start of local BAKR stack
         BCTR  R15,0                Offset to last used entry
         ST    R15,StackPtr         ... and update
         SLL   R15,3                Multiply by 8 (stack entry length)
         L     R11,0(R15,R14)       Get PR return address
         STCM  R11,B'1000',TraceAMODE Update addressing mode
         NI    TraceAMODE,X'80'      ...
         ST    R11,SaveRegs+4*11    Save resume address
         PR    ,                    Remove stack entry created by us
         PUSH  USING
         DROP  R10
         SPACE
Exec330  DS    0H
         BASR  R15,0                Temp addressibility to this code
         USING *,R15
         SLR   R00,R00              Zero AR15
         SAR   AR15,R00             ...
         LM    R07,R13,SaveRegs+4*7 Restore our registers
         LAM   R00,R14,HexZeros     Zero all access registers
         POP   USING
         NI    Zap3BRC2+1,X'0F'     Reset J back to JNOP
         B     End910               Get out of Dodge (err, TRACE390)
         EJECT
***********************************************************************
*                                                                     *
*        Trace terminated, restore and return to the traced program   *
*                                                                     *
***********************************************************************
         SPACE
Ret999   DS    0H
         LM    R00,R09,TraceGPRs    Reload traced program's GPRs
         LM    R11,R15,TraceGPRs+4*11 ... except R10
         LAM   AR00,AR15,TraceARs   Reload traced program's access regs
         L     R10,(TraceGPRs-Tr390$WS)+4*10(R10,0) Reload traced R10
Zap4BC   B     0(0,0)               Index/Offset zapped in before use
         EJECT
*---------------------------------------------------------------------*
*        HexZeros is a constant, it is placed in working storage as   *
*        it is the only constant required within the ExecuteN logic   *
*        and placing it here means we do not need a base to TRACE390  *
*---------------------------------------------------------------------*
         SPACE
HexZeros DC    16F'0'               Constant binary zeros
         SPACE
ParmList DS    0XL28                Program parameter list
AddrFlgs DC    A(0)                  - Address of status flags
PrRngTbl DC    A(0)                  - Address of print range table
BrkPtTbl DC    A(0)                  - Address of break point table
WatchTbl DC    A(0)                  - Address of watch point table
EProfTbl DC    A(0)                  - Execution profile table address
InstrTbl DC    A(0)                  - Instruction count table address
aUserDDN DC    A(0)                  - Address of user supplied ddname
         SPACE
TraceAMODE  DC    A(0)              Current AMODE of traced program
OldAMODE    DC    A(0)              AMODE at start of instruction
aEX_Target  DC    A(0)              Address of EXECUTE'd instruction
            SPACE
ASM2DLI     DC    A(0)              Address of ASMTDLI
AIB2DLI     DC    A(0)              Address of AIBTDLI
StoreAddr   DC    A(0)              Address causing a storage exception
InstrPointer DC   A(0)              AMODE/instruction ptr (for exits)
            SPACE
XCell       DC    XL8'00'           A copy of the instruction          -
                                    ... currently being traced
            SPACE
TraceGPRs   DC    16F'0'            Traced programs general registers
TraceARs    DC    16F'0'            Traced programs access registers
            SPACE
SaveRegs    DC    16F'0'            Save registers here while          -
                                    ... calling the execute routine
            SPACE
OldRegs     DC    16F'0'            Copy register table here before    -
                                    ... executing the instruction
            SPACE
BranchTgt   DC    A(0)              New value for the instruction      -
                                    ... pointer after a successful     -
                                    ... branch instruction
            SPACE
UsrFlags    DS    0BL4              User supplied status flags
UsrFlag1    DC    BL1'00000000'      - 1st user status flag byte
UsrFlag2    DC    BL1'00000000'      - 2nd user status flag byte
UsrFlag3    DC    BL1'00000000'      - 3rd user status flag byte
UsrFlag4    DC    BL1'00000000'      - 4th user status flag byte
            SPACE
bAttributes DS    0BL4              Attribute flags of instruction
bAttribute1 DC    BL1'00000000'      - 1st byte of attribute flags
bAttribute2 DC    BL1'00000000'      - 2nd byte of attribute flags
bAttribute3 DC    BL1'00000000'      - 3rd byte of attribute flags
bAttribute4 DC    BL1'00000000'      - 4th byte of attribute flags
            SPACE
TraceCC     DC    X'00'             Traced program's condition code
TraceASC    DC    X'00'             Traced program's ASC mode
            SPACE
TrcFlag1    DC    BL1'00000000'     Internal status flag byte 1
Trc$NoDD    EQU   X'80'              - Output ddname not found
Trc$Branch  EQU   X'40'              - PSW updated for branch
Trc$EndT    EQU   X'20'              - End trace at mainline
Trc$ModCall EQU   X'10'              - Module call id present
Trc$SPIN    EQU   X'08'              - Spin off output ds before open
Trc$Exit    EQU   X'04'              - User exit is active
Trc$SPEX    EQU   X'02'              - Spin off output on exit
Trc$PICT    EQU   X'01'              - Print instruction count table
            SPACE
TrcFlag2    DC    BL1'00000000'     Internal status flag byte 2
Trc$PEPT    EQU   X'80'              - Print execution profile table
Trc$NoIH    EQU   X'40'              - Do not print instruction headers
Trc$NALC    EQU   X'20'              - Output dataset is pre-allocated
Trc$ECLS    EQU   X'10'              - ESTAEX attempting dataset CLOSE
Trc$EPUT    EQU   X'08'              - ESTAEX attempting final PUT
Trc$A2DL    EQU   X'04'              - LOAD for ASMTDLI has been issued
            SPACE
LINE#       DC    PL2'0'            Line count within page
PAGE#       DC    PL4'0'            Page number
IRCOUNT     DC    PL8'0'            Instruction count (reset each run)
ITCOUNT     DC    PL8'0'            Instruction count (cumulative)
LastCCOp    DC    CL6' '            Mnemonic of last condition code    -
                                    ... altering instruction
DSNSEQ#     DC    X'00'             Generated DSN sequence number
            SPACE
ZEROFSET    DC    F'0'              Offset of range within table
ZERO1RST    DC    A(0)              Address of first address in range
ZEROLAST    DC    A(0)              Address of last address in range
            SPACE
            DS    0D
PageTime    DC    CL16' '           System time (HH:MM:SS.thmiju)
PageDate    DC    CL10' '           System date (in format YYYY/MM/DD)
            SPACE
StackPtr    DC    F'0'              Offset into BAKR_Stack of next     -
                                    ... available stack entry
BAKR_Stack  DC    32D'0'            BAKR/PR branch and return address  -
                                    ... simulation stack
            SPACE
FPR0        DS    D                 Work area used by DumpFPRs
FPR2        DS    D                 ...
FPR4        DS    D                 ...
FPR6        DS    D                 ...
            SPACE
WorkCL32    DS    XL32              Data on last line printed by DumpVS
            SPACE
            DS    0D
WorkCL16    DS    0CL16             Operand value formatting area
BDTEMP      DC    F'0'              BDproc temp storage
BDTEMP2     DC    F'0'              ...
ExecReg     DC    XL8'00'           Registers used markers
            SPACE
WorkPL8     DC    PL8'0'            Packed decimal work area
WorkDblW    DS    0D                General doubleword work area
WorkCL5     DS    0CL5
WorkCL9     DC    CL9' '
            SPACE 2
STAEMSG1    DC    CL133' '
         ORG   STAEMSG1
         DC    C'0* * * * * Data set closed by ESTAEX, abending PSW: '
STAEPSW  DC    C'XXXXXXXX XXXXXXXX * * * * *'
         ORG   ,
         SPACE 2
STAEMSG2 DC    CL133' '
         ORG   STAEMSG2
         DC    C'0* * * * * Data set closed by ESTAEX, abended while tr-
               acing instruction at address: '
STAEaddr DC    C'XXXXXXXX * * * * *'
         ORG   ,
         SPACE 2
         PRINT NOGEN
dcbTRACE DCB   MACRF=PM,LRECL=133,BLKSIZE=0,DDNAME=SYSTRACE,           X
               DSORG=PS,RECFM=FBA,BUFNO=16,DCBE=dcbETRACE
         SPACE
dcbeTRACE DCBE RMODE31=BUFF
         PRINT GEN
         TITLE 'Dynamic Allocation Parameters'
***********************************************************************
*                                                                     *
*        Parameter lists, request block and text units for dynamic    *
*        allocation and deallocation                                  *
*                                                                     *
***********************************************************************
         SPACE 2
S99PARM  DS    0F                   Pointer to request block
         DC    A(SVC99RB+Bit0)
         SPACE
SVC99RB  DS    0F                   SVC 99 request block
         DS    XL(lenS99RB)
         SPACE
*---------------------------------------------------------------------*
*        DYNALLOC text units for testing for sysout dataset           *
*---------------------------------------------------------------------*
         SPACE
plTestAlloc DS 0F                   Text pointer for allocation test
         DC    A(tuDDname)
         DC    A(tuTestSYSOUT+Bit0)
         SPACE 2
tuDDname DS    0F
         DC    AL2(DINDDNAM)        Indicate ddname specification
         DC    H'1'                 Number of parameters
         DC    AL2(L'DDname)        Length of parameter
DDname   DC    CL8'SYSTRACE'        Actual DD name of output dataset
         SPACE
tuTestSYSOUT DS 0F                  Test for a SYSOUT data set
         DC    AL2(DINRTTYP)        Return dataset type specification
         DC    H'1'                 Number of parameters
         DC    AL2(L'TESTPARM)      Length of parameter
TESTPARM DC    X'00'
         SPACE
*---------------------------------------------------------------------*
*        DYNALLOC text units for dataset de-allocation                *
*---------------------------------------------------------------------*
         SPACE
plDeallocate DS 0F                  Deallocate output dataset
         DC    A(tuDDname)
         DC    A(tuDeallocate+Bit0)
         SPACE 2
tuDeallocate DS 0F
         DC    AL2(DUNUNALC)        Deallocation request
         DC    H'0'                 Parameter count
         SPACE
*---------------------------------------------------------------------*
*        DYNALLOC text units for dataset allocation                   *
*---------------------------------------------------------------------*
         SPACE
plAllocate DS    0F                 Allocate output dataset
         DC    A(tuDDname)
         DC    A(tuAllocate+Bit0)
         SPACE 2
tuAllocate DS  0F
         DC    AL2(DALSYSOU)        Indicate sysout dataset
         DC    H'0'                 Zero parameters to specify default
         EJECT
plDSN_Allocate DS 0F                Text pointers for DSN allocation
         DC    A(tuAllocDD)          - DDNAME
         DC    A(tuAllocDSN)         - DSN Allocation
         DC    A(tuStatus)           - Dataset status
         DC    A(tuNormalDisp)       - Normal disposition
         DC    A(tuCondDisp)         - Conditional disposition
         DC    A(tuTrackAlloc)       - Allocate in tracks
         DC    A(tuPrimeSpace)       - Allocation primary quantity
         DC    A(tu2ndySpace)        - Allocation secondary quantity
         DC    A(tuRelease)          - Release unused space on close
         DC    A(tuUnits)            - Unit type to allocate on
         DC    A(tuClose)            - Deallocate on close
         DC    A(tuLRECL)            - Logical record length
         DC    A(tuRECFM+Bit0)       - Record format
         SPACE 2
tuAllocDD DS   0F                   DDNAME of dataset
         DC    AL2(DALDDNAM)
         DC    H'1'
         DC    AL2(L'tu$DDNAM)
tu$DDNAM DC    CL8' '
         SPACE
tuAllocDSN DS  0F                   Dataset name text unit
         DC    AL2(DALDSNAM)
         DC    H'1'
tu$DSNL  DC    AL2(L'tu$DSN)
tu$DSN   DC    CL44'TESTXXX.T390.ASNAME.D99001.T010101'
         SPACE
tuStatus DS    0F                   Dataset status
         DC    AL2(DALSTATS)
         DC    H'1'
         DC    AL2(L'tu$STATS)
tu$STATS DC    X'02'                - MOD
         SPACE
tuNormalDisp DS 0F                  Dataset normal disposition
         DC    AL2(DALNDISP)
         DC    H'1'
         DC    AL2(L'tu$NDISP)
tu$NDISP DC    X'02'                - CATLG
         SPACE
tuCondDisp DS  0F                   Dataset conditional disposition
         DC    AL2(DALCDISP)
         DC    H'1'
         DC    AL2(L'tu$CDISP)
tu$CDISP DC    X'02'                - CATLG
         SPACE
tuTrackAlloc DS 0F                  Dataset space allocation
         DC    AL2(DALTRK)          - Tracks
         DC    H'0'
         SPACE
tuPrimeSpace DS 0F                  Dataset primary space allocation
         DC    AL2(DALPRIME)
         DC    H'1'
         DC    AL2(L'tu$PRIME)
tu$PRIME DC    AL3(30)              - 30 tracks
         SPACE
tu2ndySpace DS 0F                   Dataset secondary space allocation
         DC    AL2(DALSECND)
         DC    H'1'
         DC    AL2(L'tu$SEC)
tu$SEC   DC    AL3(30)              - 30 tracks
         SPACE
tuRelease DS   0F                   Release unused space
         DC    AL2(DALRLSE)
         DC    H'0'
         SPACE
tuUnits  DS    0F                   Unit specification
         DC    AL2(DALUNIT)
         DC    H'1'
         DC    AL2(L'tu$UNIT)
tu$UNIT  DC    CL5'SYSDA'           - Disk
         SPACE
tuClose  DS    0F                   Deallocate file when closed
         DC    AL2(DALCLOSE)
         DC    H'0'
         SPACE
tuLRECL  DS    0F                   Logical record length
         DC    AL2(DALLRECL)
         DC    H'1'
         DC    AL2(L'tu$LRECL)
tu$LRECL DC    H'133'               - Standard SYSOUT print records
         SPACE
tuRECFM  DS    0F                   Record Format
         DC    AL2(DALRECFM)
         DC    H'1'
         DC    AL2(L'tu$RECFM)
tu$RECFM DC    X'94'               - Fixed, Blocked, ANSI
         TITLE 'WTO Messages for Fatal Conditions'
         PUSH  PRINT
         PRINT NOGEN
*                0----+----1----+----2----+----3----+----4----+----5---
*              -+----6----+----7----+----8----+----9----+----0
Msg001   DC    AL2(L'cMsg001)
cMsg001  DC    C'TRC001 Status flags invalid, bytes 3-4 are non-zero, FX
               lags=********'
Msg002   DC    AL2(L'cMsg002)
cMsg002  DC    C'TRC002 Invalid *********** table entry, Start(********X
               ) GT End(********)'
Msg003   DC    AL2(L'cMsg003)
cMsg003  DC    C'TRC003 User supplied DDNAME "********" is invalid'
Msg004   DC    AL2(L'cMsg004)
cMsg004  DC    C'TRC004 End of ParmList not found at seventh parameter'
Msg005   DC    AL2(L'cMsg005)
cMsg005  DC    C'TRC005 DYNALLOC error, Verb=**, RC=**, Error=****, InfX
               o=****, DDNAME=********'
Msg006   DC    AL2(L'cMsg006)
cMsg006  DC    C'TRC006 Attempt to ESTAEX failed, RC=**'
Msg007   DC    AL2(L'cMsg007)
cMsg007  DC    C'TRC007 Dataset OPEN failed on DDNAME "********"'
Msg008   DC    AL2(L'cMsg008)
cMsg008  DC    C'TRC008 DDNAME "********" not found in task I/O table, X
               tracing is disabled'
Msg009   DC    AL2(L'cMsg009)
cMsg009  DC    C'TRC009 Unable to return to traced program, no valid baX
               se register'
Msg010   DC    AL2(L'cMsg010)
cMsg010  DC    C'TRC010 Profiler sub-interval of ******** is invalid'
Msg011   DC    AL2(L'cMsg011)
cMsg011  DC    C'TRC011 Zero table address is invalid in *********** enX
               try'
Msg012   DC    AL2(L'cMsg012)
cMsg012  DC    C'TRC012 Bit zero set in *********** address (********)'
Msg013   DC    AL2(L'cMsg013)
cMsg013  DC    C'TRC013 *********** entry at address ******** has an exX
               it EPA of zero'
         SPACE
cplOPEN  DS    0D                   Control parameter list for SYSTRACE
cplCLOSE DC    D'0'                 ... OPEN and CLOSE
         SPACE
cplWTO   WTO   TEXT=,ROUTCDE=(11),DESC=(7),MF=L
         SPACE
cplTIME  TIME  LINKAGE=SYSTEM,MF=L
         SPACE
cplESTAEX ESTAEX RECOVER,PARAM=aBASE,                                  X
               XCTL=NO,PURGE=NONE,ASYNCH=YES,TERM=YES,MF=L
         TITLE 'Program Working Storage (local to each routine)'
***********************************************************************
*                                                                     *
*        Temporary storage used by the various routines               *
*                                                                     *
***********************************************************************
         SPACE
*---------------------------------------------------------------------*
*        Sub-routine return address save-areas                        *
*---------------------------------------------------------------------*
         SPACE
PSSAV    DS    A                    PrintSup
PHSAV    DS    A                    PRINTHDR
PFSAV    DS    A                    PROFILER
PCSAV    DS    A                    PRINTCNT
PLSAV    DS    A                    PutLine
P1SAV    DS    A                    PLINE1
POSAV    DS    A                    PrOpCode
BDSAV    DS    A                    BDproc
PRSAV    DS    A                    PrintRegs
PESAV    DS    A                    PrintEFA
BRSAV    DS    A                    BrProc
RPSAV    DS    A                    RPUT
SPSAV    DS    A                    SpinOff
GDSAV    DS    A                    GENDSN
WRSAV    DS    A                    WRITE
TSSAV    DS    A                    TimeStamp
         SPACE
PUTRSAVE DS    18F                  Save area used by PUTR
         SPACE
#Cells   DS    F                    Number of cells left to process
         SPACE
PSXCell  DS    XL8                  Copy of the subject instruction
PSFLAGS  DS    BL4                  Attribute flags of the above instr.
SAVELINE DS    CL133                Save PLINE here while title printed
         EJECT
*---------------------------------------------------------------------*
*            The print output line                                    *
*---------------------------------------------------------------------*
             SPACE
PLINE        DC    CL133' '
            ORG *-(L'PageDate+1+L'PageTime+3+L'PrL$PAGE+1+L'PrL$PageNo)
PrL$DATE     DS    CL(L'PageDate)   YYYY/MM/DD
             DS    C
PrL$TIME     DS    CL(L'PageTime)   HH:MM:SS.thmiju
             DS    CL3
PrL$PAGE     DS    CL4              C'PAGE'
             DS    C
PrL$PageNo   DS    ZL6              Page Number
             SPACE 2
             ORG   PLINE
PrL$CCB      DS    C                Carriage control byte
PrL$Data     DS    0CL132           Print line data
PrL$ILC      DS    CL8              Instruction pointer (PSW address)
             DS    C
PrL$ASC      DS    C                Address Space Control mode
             DS    C
PrL$ObjCode  DS    CL12             Instruction image
             DS    C
PrL$CondCode DS    C                Condition code
             DS    C
PrL$BranchDir DS   CL2              Branch direction
             DS    C
PrL$Mnemonic DS CL6                 Symbolic instruction code
             DS    C
PrL$Operands DS CL20                Instruction operand fields
             DS    C
PrL$Reg1     DS    CL8              First operand register
             DS    C
PrL$Reg2     DS    CL8              Second operand register
             DS    CL2
PrL$Address1 DS    CL8              1st operand effective address
             DS    CL2
PrL$Data1    DS    CL8              First operand data
             DS    C
PrL$Double1  DS    CL8              2nd half of doubleword at Address1
             DS    CL2
PrL$Address2 DS    CL8              Second operand effective address
             DS    CL2
PrL$Data2    DS    CL8              Second operand data
             DS    C
PrL$Double2  DS    CL8              2nd half of doubleword at Address2
             SPACE 2
             ORG   PrL$Reg2
PrL$DR1      DS    CL8              2nd half of 1st double register
             DS    CL2
PrL$DR2A     DS    CL8              2nd double register
             DS    CL2
PrL$DR2B     DS    CL8              2nd half of 2nd double register
             SPACE 2
             ORG   PrL$Address1
PrL$ModuleID DS    CL(L'PLINE-1-(PrL$Address1-PLINE)) Module id
             ORG   PrL$Reg1
PrL$SVC      DS    CL(L'PLINE-1-(PrL$Reg1-PLINE))     SVC Mnemonic
             ORG   PrL$Address2
***                                 Executed SVC Mnemonic
PrL$ESVC     DS    CL(L'PLINE-1-(PrL$Address2-PLINE))
             SPACE 2
             ORG   PrL$Data
             DS    C
PrD$Offset   DS    CL6              Offset from start of dump data
             DS    CL3
PrD$Address  DS    CL8              Virtual address
             DS    CL2
PrD$HexData  DS    8CL9             Data in display hex format
             DS    CL2
PrD$EBCDIC   DS    CL32             Data in EBCDIC format
             ORG   ,
             SPACE
IDstring     DC    CL(L'PrL$ModuleID)' ' Module id string
         SPACE 3
         END   TRACE390
         PUNCH ' PAGE TRACE390'
         PUNCH ' SETOPT PARM(REUS=SERIAL,CALL)'
         PUNCH ' NAME TRACE390(R)'
         END
