         TITLE '--- QUEUE--DDNAME -- LIST DDNMS && DSIDS FOR A JOB ---'
*---------------------------------------------------------------------*
*                                                                     *
*   DDNAME - List DDnames and DSIDs for a job                         *
*                                                                     *
*   Updates:                                                          *
*      14Jan92  LDW  Fix bug inserted by previous update              *
*                    Fix bug displaying spin stepnames                *
*                    Fiddle with DD@ENT                               *
*      06Jan92  LDW  Correct assembly error with PDB1PSO check under  *
*                       JES2 V4                                       *
*      05Aug91  LDW  Integrate GLA fixes below (with minor changes,   *
*                       except for DSID=0 problem fixed my way)       *
*     (17Jul91) GLA  Day one bug handling *.step.pstep.ddn            *
*     (10Jul91) GLA  Handle DynAlloc sysout that is not spin          *
*                    Eliminate problem doing PRINT/COPY/SPIN of       *
*                       wrong dataset from commandline after DD       *
*                       command issued                                *
*                    Correct display of DSID=0 datasets               *
*      15Mar91  LDW  Adjust Pgm= and PDBFLAG1 display lines for ISPF  *
*      20Dec90  LDW  Simplify previous update                         *
*      28Nov90  EMS  Updates for SP410                                *
*       7Aug90  EMS  Updates for SP313                                *
*      20Jun90  LDW  Display 6 digit DSID                             *
*      26Feb90  LDW  Fix typo in conditional assembly                 *
*      25Dec89  LDW  Q$KEYS -> QZKEYS,  Q$TEXT -> QZTEXT              *
*      12Dec89  LDW  Make OACFSORT expansion conditional (for Doron)  *
*      23Nov89  LDW  Remove unnecessary Q$JCT                         *
*      27Apr89  EMS  Updates for SP311                                *
*      30Jan88  LDW  Fix dsid table too small problem, possibly       *
*                       introduced by 9 July 87 update                *
*      31Dec87  LDW  Fix PRINT GEN/NOGEN screwup in previous update   *
*       9Aug87  EMS  Fix for procname = proc bug                      *
*                    Fix for OACFSORT 0C3 abends                      *
*                    Update for TERM=TS,SYSOUT= for TSU's             *
*                    Fix for SYSOUT override bug                      *
*       9Jul87  EMS  Use new table (QDSTART instead of QCSTART)       *
*                    Update for QSORT macro changes                   *
*                    Fix for tweaked line commands after "s" ln cmd   *
*                    Add calls to GETPDDB, GETREC routines.           *
*      21May87  LDW  Add translate for forms code                     *
*      20May87  EMS  Fix fix for DSID = 0                             *
*                    add call to QSORT                                *
*      21Mar87  LDW  Fix for DSID = 0 (from RSCS)                     *
*      25Jan87  LDW  Pass READSPC the JQE addr in case of CB ID error *
*      17Jan87  LDW  Eliminate "LC" macro usage                       *
*                    Misc cleanup                                     *
*      26Nov86  EMS  FIX FOR MULTI-LEN SYSIN/OUT DSIDS                *
*      04/03/86 LDW  USE SPECIFIC BIT NAMES IN QDEBUG                 *
*      03/31/86 LDW  RE-DESIGN 3278-5 SUPPORT (THIRD TRY!)            *
*                    SIMPLIFY STD FORMS CHECK                         *
*      02/07/85 EMS  MAKE DEFAULT STD FORM AN ASM TIME OPTION         *
*      01/30/85 LDW  CHANGE 'SJ' TO DEFAULT TO ONLY NON-EMPTY         *
*                       DATASETS; ADD 'ALL' KEYWORD                   *
*      01/27/85 LDW  FIX BUG:  CLEAR PROC NAME WHEN HIT NON-PROC EXEC *
*                    FIX LINE CMDS ON JES2 DATASETS FOR QLEVEL > 4    *
*      09/10/84 LDW  FIX FORMS CODE FOR NON-SP134 FORMS CODE          *
*      08/09/84 LDW  UPDATE FOR SP134 (USE IOTPDDB INSTEAD OF         *
*                       QCPDDB1),                                     *
*                    ALLOW FOR PDDB 5 NOT BEING IN FIRST IOT          *
*                    RE-ARRANGE FIELDS TO ALLOW FOR SP134 8 CHAR FORM *
*                    CHANGE DISPLAY OF UNKNOWN DSTYPE FROM '??????'   *
*                       TO 'UNKNWN'                                   *
*      04/11/84 LDW  JCTDSECT -> JCTSTART, IOTDSECT -> IOTSTART       *
*      01/23/84 LDW  ADD SUPPORT FOR COMMAND STACKING                 *
*                    ADD SUPPORT FOR 'SJ' AND 'NS' SUBCOMMANDS        *
*                    USING/DROP -> USNGX/DROPX                        *
*      06/21/83 LDW  REFORMAT DISPLAY -- PUT STEP ON SEPARATE LINE,   *
*                       ADD MORE LINE INFO (LIKE FORMS, ETC)          *
*      03/01/83 LDW  ADD SUPPORT FOR LINE COMMANDS                    *
*      02/16/83 LDW  CHECK FOR MULTIPLE DSN= ON A SYSOUT DD, AND USE  *
*                       THE LAST INSTEAD OF THE FIRST.  THIS SOLVES   *
*                       THE PROBLEM OF GETTING GARBAGE IF THE JCL IS  *
*                       EXECUTING A PROC WITH A TRUE DSN IN IT, BUT   *
*                       AN OVERRIDE TO SYSOUT IN THE JCL.             *
*      02/09/83 LDW  IF PDDB 5 NOT FOUND, PUT MSG TO SCREEN INSTEAD   *
*                       OF QTILT, AND CONTINUE WITH THE LIMITED INFO  *
*                       IN IOTS.  THIS IS NEEDED BECAUSE WITH SP      *
*                       JES2, A SYSOUT JOB THAT IS DUMPED AND THEN    *
*                       RELOADED WILL NOT HAVE ANY INTERNAL TEXT.     *
*                       IBM STRIKES AGAIN!!!                          *
*                    CHANGE PDBFLAG EXPLANATIONS TO LOWER CASE        *
*      01/19/83 LDW  USE FIRST BIT OF QDEBUG INSTEAD OF QM1PDBFL      *
*      01/14/83 LDW  PRE-SCAN IOT'S AND BUILD IN-STORAGE TABLE SO     *
*                       THAT WE ONLY READ THE IOT CHAIN ONCE.  THIS   *
*                       WILL GIVE (POSSIBLE DRASTIC) PERFORMANCE      *
*                       IMPROVEMENT FOR JOBS WITH MANY SPIN AND/OR    *
*                       HELD DATASETS                                 *
*                    REMOVE CODE TO SQUEEZE OUT ATTR BYTES FOR        *
*                       NON-TUBE, SINCE "DISPLAY" NOW DOES IT         *
*      01/04/83 LDW  FIX MINOR BUG CREATED BY DISPLAYING PDBFLAG1     *
*                       EXPLANATIONS (THIS BUG ONLY APPEARED IF       *
*                       "MODE PDBFLAG1" AND LAST STEP HAD NO SYSOUT   *
*                       DD STATEMENTS!!)                              *
*                    ADD WORKLEN=                                     *
*      12/20/82 LDW  RE-ARRANGE OUTPUT COLUMNS                        *
*                    DISPLAY SYSOUT DSIDS IN HIGH INTENSITY           *
*                    PROVIDE INPUT FIELDS FOR LINE COMMANDS           *
*                    CHANGE HEADER AND SOME OTHER DATA TO LOWER CASE  *
*                    DON'T SUPPRESS ANYTHING IF QMODE PDBFLAG1        *
*      12/08/82 LDW  USE $LRC MACRO SYMBOLS                           *
*      10/28/82 LDW  PUT JOBID ON TOP LINE (QDTOP)                    *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 3
DDNAME   QSTART  Q4,WORKLEN=DD@WORKL
         USNGX WORK,R13
         L     R0,QDSTART               -> current table
         A     R0,QDSIZE                current size
         SH    R0,=Y(DD@ENTL)           fudge - can't use last entry
         ST    R0,DD@TBLEE              -> end of table
         QCALL DISP80                   SWITCH TO 3278-2 MODE IF 3278-5
         MVC   DD@PROCN,=CL8'(none)'    THERE IS NO PROCEDURE IN EFFECT
***********************************************************************
*                                                                     *
*   CALL FINDJOB TO LOCATE THE JQE, JCT, AND IOT                      *
*                                                                     *
***********************************************************************
         QCALL FINDJOB                  FIND THE JOB
         OI    QSCFLAG1,QSC1JOB         PUT JOBID IN QDTOP
***********************************************************************
*                                                                     *
*   READ ALL PDDB'S AND SAVE INTERESTING INFORMATION                  *
*                                                                     *
***********************************************************************
         L     R7,QDSTART               -> TABLE START
         USNGX DD@ENT,R7
         MVI   DD@FLAGS,0
         MVI   QGPFLAG,QPFINIT          init for call
DD$PDBLP QCALL GETPDDB                  get a pddb
         LTR   R2,R1                    any left?
         BZ    DD$SORT                  no, sort table
         USNGX PDBDSECT,R2
          AIF  (&QLEVEL GE 9).DD01
         LH    R1,PDBDSKEY              GET DSID
          AGO  .DD02
.DD01     ANOP ,
         L     R1,PDBDSKEY              get dsid
.DD02     ANOP ,
*%%      LTR   R1,R1                    NULL PDDB?
*%%      BZ    DD$NXPDB                 YES - IGNORE IT
*%%      TM    PDBFLAG1,PDB1NULL        NULL PDDB?
*%%      BNZ   DD$NXPDB                 YES - IGNORE IT
*---  SAVE USEFUL INFORMATION FROM PDDB IN OUR OWN TABLE           ---*
         MVC   DD@FLAG1,PDBFLAG1        SAVE FLAG BYTE
         MVC   DD@RECFM,PDBRECFM        SAVE RECORD FORMAT
         MVC   DD@LRECL,PDBLRECL        SAVE MAXIMUM RECORD LENGTH
         ST    R1,DD@DSKEY              SAVE BINARY DSKEY
         MVC   DD@CLASS,PDBCLASS        SAVE SYSOUT CLASS
         MVC   DD@RECCT,PDBRECCT        SAVE RECORD COUNT
         MVC   DD@COPYS,PDBCOPYS        SAVE COPY COUNT
         MVC   DD@DEST,PDBDEST          SAVE DEST (BINARY)
**%%     MVC   DD@USER,PDBUSER          SAVE DEST USERID/RMTID
         MVC   DD@FORMS,PDBFORMS        SAVE FORMS CODE
         L     R15,=V(CHARTAB)          -> translate table
         TR    DD@FORMS,0(R15)          translate to valid chars
         CLC   DD@FORMS,=CL8'&@@QSTDF'  DEFAULT?
         BNE   *+10                     NO - KEEP IT
         MVC   DD@FORMS,QBLANK          YES - CLEAR IT
         MVC   DD@FCB,PDBFCB            SAVE FCB ID
         CLC   =C'****',DD@FCB          DEFAULT?
         BNE   *+10                     NO - KEEP IT
         MVC   DD@FCB,QBLANK            YES - CLEAR IT
         MVC   DD@UCS,PDBUCS            SAVE UCS ID
         CLC   =C'****',DD@UCS          DEFAULT?
         BNE   *+10                     NO - KEEP IT
         MVC   DD@UCS,QBLANK            YES - CLEAR IT
**%%     MVC   DD@CHARS(4*4),PDBCHAR1   SAVE ALL 4 XLATE TAB NAMES
         CLC   DD@UCS,QBLANK            ANYTHING HERE?
         BNE   *+10                     YES - KEEP IT
         MVC   DD@UCS,PDBCHAR1          NO - USE FIRST CHARS= NAME
         CLC   =C'****',DD@UCS          DEFAULT?
         BNE   *+10                     NO - KEEP IT
         MVC   DD@UCS,QBLANK            YES - CLEAR IT
**%%     MVC   DD@FLASH,PDBFLASH        SAVE FLASH ID
**%%     MVC   DD@MODF,PDBMODF          SAVE COPY MOD IMAGE
          AIF   (&QLEVEL LT 5).DD03
         MVC   DD@PNAME,PDBPNAME        SAVE PROC STEP NAME
         MVC   DD@SNAME,PDBSNAME        SAVE STEP NAME
         MVC   DD@DDNAM,PDBDDNAM        SAVE DD NAME
.DD03     ANOP
         MVI   DD@XFLAG,0               CLEAR DISPLAY FLAG
         MVC   DD@EYE,=C'DDE'           move in eyecatcher
         LA    R7,DD@ENTL(,R7)          -> NEXT TABLE ENTRY
         C     R7,DD@TBLEE              TABLE OVERFLOW?
         BL    DD$NXLST                 no, continue
***********************************************************************
*                                                                     *
*   DATASET RECORD NUMBER TABLE IS TOO SMALL.  TRY TO GET A BIGGER    *
*   ONE, COPY THE INFORMATION, AND FREE THE OLD ONE.  WE WILL TRY     *
*   FOR ONE 4 TIMES THE SIZE, SO WE WILL GO FROM THE ORIGINAL 8K TO   *
*   32K.  IF THAT ONE IS TOO SMALL, WE WILL GO TO 256K.  IF THAT      *
*   ONE IS TOO SMALL, YOU BETTER BE LOGGED ON IN A MONSTER REGION.    *
*                                                                     *
***********************************************************************
         S     R7,QDSTART               get offset
         STM   R14,R12,12(R13)          stash for a sec
         L     R2,QDSIZE                get current size
         LR    R7,R2                    copy for later
         SLL   R2,2                     multiply by 4
         GETMAIN  RC,LV=(R2),SP=1       get new workarea
         LTR   R15,R15                  did it work?
         BNZ   DD$TILT1                 no, exit stage right
         LR    R6,R1                    mvcl - target addr
         LR    R0,R1                    mvcl - target addr
         LR    R1,R2                    mvcl - target length
         LR    R15,R7                   mvcl - source length
         L     R14,QDSTART              mvcl - source addr
         MVCL  R0,R14                   copy table
         LR    R0,R7                    point to old table
         ICM   R0,B'1000',=AL1(1)       set subpool
         L     R1,QDSTART               ditto addr
         FREEMAIN  R,LV=(0),A=(1)       free old table
         ST    R6,QDSTART               set
         ST    R2,QDSIZE                   new
         AR    R6,R2                          table
         SH    R6,=Y(DD@ENTL)           fudge - can't use last entry
         ST    R6,DD@TBLEE              save for later
         LM    R14,R12,12(R13)          restore regs
         A     R7,QDSTART               new addr
DD$NXLST MVC   DD@DSKEY,=X'EEEEEEEE'    flag it as end of table
         MVI   DD@FLAG1,0               clear flag
         B     DD$PDBLP                 get next pddb
         DROPX R7,R2                    DD@ENT, PDDB
DD$SORT  QSORT ADDR=QDSTART,LEN==A(DD@ENTL),COMP==A(DD$CMP),OFFSET=R7, $
               PREFIX=DD
         SPACE 1
***********************************************************************
*                                                                     *
*   IF 'SJ' SUBCOMMAND, CREATE DSID TABLE FOR 'NS' SUBCOMMAND --LDW-- *
*                                                                     *
***********************************************************************
DD$SJCHK CLI   QCODE,4                  SJ?
         BNE   DD$SYSGO                 NO - CONTINUE NORMAL 'DD'
         CLI   QKEYWORD,C'A'            'ALL' SPECIFIED?
         BNE   *+8                      NO - SKIP
         OI    DD@FLAGS,DD@FSJAL        YES - REMEMBER
         L     R1,QCDDTBLA              -> CURRENT TABLE
         S     R7,QDSTART               COMPUTE TABLE LENGTH
         SR    R6,R6                    CLEAR FOR DIVIDE
         D     R6,=A(DD@ENTL)           COMPUTE NUMBER OF ENTRIES
         LA    R7,2(,R7)                ACCOUNT FOR START AND END
         SLL   R7,2                     times entry length
         C     R7,QCDDTBLL              NEED BIGGER THAN CURRENT?
         BL    DD$SJ$02                 NO - OK
         L     R0,QCDDTBLL              GET CURRENT LENGTH
         LTR   R0,R0                    ANY CURRENT TABLE?
         BZ    DD$SJ$01                 NO - DON'T FREEMAIN
         SPACE 1
         FREEMAIN  RU,LV=(0),A=(1),SP=3 FREE OLD TABLE
         SPACE 2
DD$SJ$01 GETMAIN  RU,LV=(R7),SP=3       GET A NEW TABLE
         SPACE 1
         ST    R7,QCDDTBLL              SAVE LENGTH OF NEW TABLE
         ST    R1,QCDDTBLA              SAVE ADDR
         ST    R1,QCDDTBLE              SET 'CURRENT ENTRY' POINTER
         SPACE 2
DD$SJ$02 MVC   0(2,R1),=C'*T'           INDICATE TOP
         LA    R1,4(,R1)                -> NEXT ENTRY
         L     R7,QDSTART               -> DDNAME'S DSID TABLE
         USNGX DD@ENT,R7
         SPACE 1
DD$SJ$LP TM    DD@FLAG1,PDB1NSOT        'NOT FOR SYSOUT'?
         BO    DD$SJNXT                 RIGHT - SKIP
         TM    DD@FLAGS,DD@FSJAL        'ALL'?
         BO    DD$SJ$SV                 YES - SAVE THIS ENTRY
         TM    DD@FLAG1,PDB1NULL        'NULL PDDB'?
         BNZ   DD$SJNXT                 YES - SKIP IT
DD$SJ$SV MVC   0(4,R1),DD@DSKEY         SAVE BINARY DSKEY
         LA    R1,4(,R1)                -> NEXT 'NS' TABLE ENTRY
DD$SJNXT LA    R7,DD@ENTL(,R7)          -> NEXT 'DD' TABLE ENTRY
         CLC   DD@DSKEY,=X'EEEEEEEE'    end of table?
         BNE   DD$SJ$LP                 NO - CONTINUE LOOP
         MVC   0(2,R1),=C'*E'           INDICATE END OF TABLE
         MVC   QKEYWORD(16),=CL16'TOP'
         MVI   QCODE,16                 SET "NS"
         QCALL LIST                     GO DISPLAY THE FIRST DATASET
         B     QSTOP                    LEAVE WHEN HE LEAVES
         DROPX R7                       DD@ENT
***********************************************************************
*                                                                     *
*   SHOW RECORD COUNTS FOR JES2 SPOOLED DATASETS              --LDW-- *
*                                                                     *
***********************************************************************
DD$SYSGO QSTACK  X'20'                  PUT 'DD' SUBCOMMAND ON STACK
         MVC   QDHLINE,=CL79'    DDname     DSid    DStype Records Cl  $
               Dest   Copies Ucs  Fcb  Forms'
         MVC   QDLCTBL,=V(PA#LC#DD)     SET ADDR OF LINE COMMANDS TABLE
         MVC   QCDDTBLE,QCDDTBLA        INIT DSID TAB CURRENT ENT PTR
         L     R7,QDSTART               -> IN-STORAGE DSID TABLE
         USNGX DD@ENT,R7
         SPACE 1
DD$SYSLP CLC   =X'EEEEEEEE',DD@DSKEY    end of table?
         BE    DDJOB                    YES - GO PROCESS NORMAL DSID'S
         L     R1,DD@DSKEY              GET DSID
         B     DD$SYOUT                 %%%%%%
         TM    DD@FLAG1,PDB1NSOT        NOT FOR SYSOUT?
         BZ    DD$SYOUT                 NO - IT'S FOR SYSOUT
         CH    R1,=H'2'                 IT IS 2 THRU 4?
         BL    DD$SYOUT                 NO - OK
         CH    R1,=H'4'                 IT IS 2 THRU 4?
         BNH   DD$SYSNX                 YES - IGNORE IT BECAUSE IT IS
*                                       MARKED "NOT FOR SYSOUT" AND IS
*                                       THE JOBLOG, JOBMSG, OR JCL DS,
*                                       WHICH ARE DUPLICATED ON THE
*                                       SPIN IOT WITHOUT THE "NOT FOR
*                                       SYSOUT" FLAG SET.
         SPACE 1
DD$SYOUT CH    R1,=H'100'               A PROBLEM PROGRAM DATASET?
         BH    DD$SYSNX                 YES - IGNORE ON THIS PASS
         CH    R1,=H'1'                 INPUT JCL?
         BE    DD$AUTH1                 YES - SHOW ONLY TO AUTH USERS
         BL    DD$SYSNX                 ignore VM/VSE oddity this pass
         CH    R1,=H'4'                 JOBLOG/JCL/JOBMSG?
         BH    DD$AUTH1                 NO - SHOW ONLY TO AUTH USERS
         MVC   DDATTR1,=X'1DC8'         SET INPUT, BRIGHT
         MVC   DDATTR2,=X'1D60'         SET OUTPUT, NORMAL
         MVC   DDATTR3,=X'1DE8'         SET OUTPUT, BRIGHT
         B     DD$SYSDS                 CONTINUE
DD$AUTH1 TM    QXAUTH,QXPSWD+QXSYSP     AUTHORIZED USER?
         BZ    DD$SYSNX                 NO - DON'T DISPLAY THIS DSID
         MVC   DDATTR1,=X'1DE8'         SET OUTPUT, BRIGHT
         MVC   DDATTR2,=X'1D60'         SET OUTPUT, NORMAL
         MVC   DDATTR3,=X'1D60'         SET OUTPUT, NORMAL
DD$SYSDS MVC   DDATTR4,=X'1D60'         SET OUTPUT, NORMAL
         MVI   QDATRNUM+1,4             SET # OF ATTR BYTES IN LINE
         MVC   DDDSTYPE,=C'$$JES2'      MOVE IN SYSTEM DSTYPE
*---  SAVE DATA IN ARRAY FOR LINE COMMANDS                         ---*
         XC    DD@TPTR(LCBELEN),DD@TPTR INIT ARRAY ELEMENT
         MVI   DD@ADDR1+3,DDSELECT-QDMSG  OFFSET INTO LINE OF 1ST FIELD
         MVC   DD@FLD1(2+8),QBLANK
         MH    R1,=H'6'                 MULTIPLY DSID BY entry length
         LA    R1,DDCMDSYS-6(R1)        -> SUBCMD TO USE IF LINE SELECT
         MVC   DD@ID,0(R1)              SAVE FOR DD@ID
          AIF   (&QLEVEL GE 5).DD04
         L     R1,DD@DSKEY              GET DSID
         MH    R1,=H'6'                 ENTRIES ARE 6 BYTES EACH
         LA    R1,DSIDTYPE-6(R1)        -> TYPE
         MVC   DDDSTYPE,0(R1)           MOVE IN SYSTEM DSTYPE
.DD04     ANOP
         BAL   R8,DD$FMT                FMT DSID/RECCT/CLASS/HOLD/PRINT
         TM    QXAUTH,QXPSWD+QXSYSP     AUTHORIZED USER?
         BNZ   *+10                     YES - DISPLAY DSID
         MVC   DDDSID,QBLANK            NO - CLEAR DSID FIELD
         LA    R1,DD@TPTR               -> MY ARRAY ELEMENT
         QCALL DISPADDX                 ADD THIS LINE TO SCREEN
DD$SYSNX LA    R7,DD@ENTL(,R7)          -> NEXT DSID TABLE ENTRY
         B     DD$SYSLP                 GO PROCESS
         DROPX R7                       DD@ENTL
         SPACE 1
***********************************************************************
*                                                                     *
*   LOCATE PDDB NUMBER 5                                              *
*                                                                     *
***********************************************************************
          AIF  (&QLEVEL GE 9).DD05
DDJOB    MVC   QPDSID,=H'5'             get it
          AGO  .DD06
.DD05     ANOP ,
DDJOB    MVC   QPDSID,=F'5'             get it
.DD06     ANOP ,
         NI    QFLAG2,255-Q2VALIDS      MARK NO VALID DS
         MVC   QDHDSID,=CL8'5'          set if needed
         MVI   QGPFLAG,QPFDIR+QPFNMSG   this one, no msg
         QCALL GETPDDB                  get it
         LTR   R2,R1                    find it?
         BP    DDFOUNDD                 yes, continue
         USNGX PDBDSECT,R2
******** QTILT '*** JOB DOES NOT HAVE DD TABLE ***'
         OI    DD@FLAGS,DD@FNOTX        REMEMBER NO INTERNAL TEXT
          AIF   (&QLEVEL GE 5).DD07
         MVC   QDMSG(NOTXTMGL),NOTXTMSG DISPLAY MESSAGE TO THAT EFFECT
         MVI   QDATRNUM+1,2             NUMBER OF ATTR BYTES IN LINE
         BAL   R14,QADDLINE             PUT MESSAGE TO SCREEN
.DD07     ANOP
         B     DDSPIN                   GO FORMAT FROM IN-STORAGE TABLE
         SPACE 2
DDFOUNDD MVC   QCGRMTTR,PDBMTTR         DISK ADDR OF FIRST BLOCK
         DROPX R2                       PDDB
         MVI   QCRFLAG,QRFINIT          start at top of dataset
***********************************************************************
*                                                                     *
*   PROCESS RECORDS                                                   *
*                                                                     *
***********************************************************************
         USNGX LRCDSECT,R4
DDNXTREC QCALL GETREC                   get a record
         LTR   R4,R4                    eof?
         BZ    DDSPIN                   yes, get spin datasets
         TM    LRCFLAG1,LRC1SPAN        IS THIS A SPANNED RECORD?
         BO    DDNXTREC                 yes, skip it.
         TM    LRCTEXT+2,EXECSTR        IS THIS AN EXEC RECORD?
         BO    DDEXEC                   YES. PROCESS IT.
         TM    LRCTEXT+2,DDSTR          IS THIS A DD RECORD?
         BO    DD$DD                    YES. PROCESS IT.
         B     DDNXTREC                 otherwise, ignore record.
***********************************************************************
*                                                                     *
*   PROCESS AN EXEC RECORD                                            *
*                                                                     *
***********************************************************************
DDEXEC   CLI   LRCTEXT+STREKEY-TEXT,EXECK  IS THERE A STEPNAME?
         BNE   DDNXTREC                 No, skip this record.
         SR    R1,R1                    CLEAR FOR IC
         IC    R1,LRCTEXT+STREKEY+2-TEXT  LENGTH OF PROCSTEP/STEPNAME
         TM    LRCTEXT+STREINDC-TEXT,ETXPRCV  EXEC PROC=XXXX?
         BO    DDEXPROC                 YES - HANDLE IT
         TM    LRCTEXT+STREINDC-TEXT,ETXPROC  IN A PROC?
         BO    *+10                     YES - KEEP PROC NAME
         MVC   DD@PROCN,=CL8'(none)'    NO - CLEAR THE FIELD
         MVC   QDMSG(2),=X'1DE8'        SET OUTPUT, BRIGHT
         MVC   QDMSG+2(2),=C'- '        START THE SEPARATOR LINE
         MVC   QDMSG+4(76),QDMSG+2      PROPAGATE THE SEPARATOR
         MVC   QDMSG+80(2),=X'1D60'     SET OUTPUT, NORMAL
         MVI   QDATRNUM+1,2             SET # OF ATTR BYTES IN LINE
         STM   R14,R1,DD@REGSV          SAVE VOLATILE REGS TEMPORARILY
         BAL   R14,QADDLINE             ADD THE SEPARATOR LINE
         LM    R14,R1,DD@REGSV          RESTORE VOLATILE REGS
         MVC   DDSTEPLN,DD#STHDR        MOVE IN HEADING
         MVC   DDPROCN,DD@PROCN         MOVE IN PROCNAME
*  ASSUME (FOR LACK OF KNOWLEDGE TO THE CONTRARY) THAT IT'S PGM=
*---  ASSUME NOT IN PROC, SET UP ACCORDINGLY                       ---*
         LA    R15,DDSTEPN              -> WHERE THE STEPNAME WILL GO
         TM    LRCTEXT+STREINDC-TEXT,ETXPROC  IN A PROC?
         BNO   DDEXNOPR                 NO - HANDLE IT
*---  IN A PROC -- MUST FLOAT A '.' AND THE STEPNAME               ---*
         MVC   DDSTEPN,DD@PSTEP         MOVE IN PROCSTEPNAME
         LA    R15,1(,R15)              -> NEXT POSSIBLE POSITION
         CLI   0(R15),C' '              END OF PROCSTEPNAME?
         BNE   *-8                      NO - KEEP LOOKING
         MVI   0(R15),C'.'              ADD THE SEPARATOR
         LA    R15,1(,R15)              AND BUMP PAST IT
         B     DDEXINPR                 CONTINUE
         SPACE 1
DDEXNOPR MVC   DD@PSTEP,=CL8'(none)'    THERE IS NO PROCEDURE IN EFFECT
         SPACE 1
DDEXINPR MVC   0(8,R15),=CL8'(none)'    CLEAR IT WITH ' (NONE) '
         MVC   DDPGM,=CL8'(none)'       AND THIS TOO
         SH    R1,=H'1'                 -1 FOR EX
         BM    DDNSTEP1                 SKIP IF NO STEPNAME
         MVC   0(8,R15),QBLANK          CLEAR THE FIELD FIRST
         EX    R1,DDMVCST               MOVE THE STEPNAME
DDNSTEP1 LA    R15,LRCTEXT+STREKEY+3-TEXT+1(R1) POINT TO PGMNAME KEY
         CLI   0(R15),PGMEK             IS THIS THE PROGRAM NAME?
         BNE   DDEXECOK                 NO - DONE WITH THIS RECORD
***      CLI   2(R15),X'83'             IS THIS PGM=*.STEP.DDNAME?
***      BE    DDEXSTAR                 YES - HANDLE IT
         TM    2(R15),X'80'             IS THIS MANY PIECES?
         BO    DDEXSTAR                 YES - must be PGM=*.S.PS.DDN
         SR    R1,R1                    CLEAR FOR IC
         IC    R1,2(,R15)               GET PGMNAME LENGTH
         SH    R1,=H'1'                 -1 FOR EX
         BM    DDEXECOK                 DONE - GO DISPLAY THIS STEP
         MVC   DDPGM,QBLANK             CLEAR THE FIELD
         EX    R1,DDMVCPGM              MOVE PGM NAME
*     (  B     DDEXECOK  )              CONTINUE PROCESSING
         SPACE 2
DDEXECOK MVI   QDATRNUM+1,2             SET # OF ATTR BYTES IN LINE
         QCALL DISPADD                  ADD THIS LINE TO SCREEN
         B     DDNXTREC                 All done
         SPACE 2
DDMVCST  MVC   0(*-*,R15),LRCTEXT+STREKEY+3-TEXT << EXECUTED >>
DDMVCPGM MVC   DDPGM(*-*),3(R15)        << EXECUTED >>
         SPACE 1
DDEXSTAR MVC   DDPGM,=C'*.DDNAME'       THE REAL WHOLE THING WON'T FIT
         B     DDEXECOK                 IGNORE THE REST OF THE RECORD
         SPACE 1
*---  THIS INTERNAL TEXT RECORD IS FOR EXEC PROC=XXX.              ---*
*---  SAVE THE INFO FOR DISPLAY BY REGULAR EXEC PGM= CODE.         ---*
DDEXPROC MVC   DD@PROCN,=CL8'(none)'    CLEAR THE FIELD
         MVC   DD@PSTEP,=CL8'(none)'    AND THIS ONE ALSO
         SH    R1,=H'1'                 -1 FOR EX
         BM    DDEXPR$1                 SKIP IF NONE
         MVC   DD@PSTEP,QBLANK          BLANK THE FIELD
         EX    R1,DDMVCPS               SAVE STEPNAME
DDEXPR$1 LA    R15,LRCTEXT+STREKEY+3-TEXT+1(R1) -> PROCNAME OR NXT UNIT
         CLI   LRCTEXT+STREKEY+1-TEXT,2 ARE THERE 2 POSITIONAL UNITS?
         BE    DDEXPROX                 YES - GO PROCESS IT
         CLI   0(R15),PROCEK            EXPLICIT EXEC PROC= ?
         BNE   DDNXTREC                 No - get out
         LA    R15,2(,R15)              POINT TO PROCNAME LENGTH
DDEXPROX SR    R1,R1                    CLEAR FOR IC
         IC    R1,0(,R15)               GET PROCNAME LENGTH
         SH    R1,=H'1'                 -1 FOR EX
         BM    DDNXTREC                 Ignore if none
         MVC   DD@PROCN,QBLANK          BLANK THE FIELD
         EX    R1,DDMVCPR               MOVE PROCNAME
         B     DDNXTREC                 Done with this record
         SPACE 2
DDMVCPS  MVC   DD@PSTEP(*-*),LRCTEXT+STREKEY+3-TEXT << EXECUTED >>
DDMVCPR  MVC   DD@PROCN(*-*),1(R15)     << EXECUTED >>
***********************************************************************
*                                                                     *
*   PROCESS DD RECORDS                                                *
*                                                                     *
***********************************************************************
DD$DD    TM    LRCTEXT+STRDINDC-TEXT,DTXSYSIN+DTXSYOUT SYSIN/SYSOUT DD?
         BZ    DDNXTREC                 No. skip the record.
         XC    DD@ADSNK,DD@ADSNK        NO DSN= TEXT UNIT YET
         NI    DD@FLAGS,255-DD@FTS      reset bit
         LA    R7,LRCTEXT+STRDKEY-TEXT  ADDR OF FIRST KEY
         LR    R8,R6                    REMAINING LENGTH OF RECORD
         SR    R15,R15                  CLEAR FOR IC
         SR    R14,R14                  CLEAR FOR IC
         SR    R1,R1                    CLEAR FOR IC
DDTRYFLD CLI   0(R7),DSNAMEK            IS THIS THE DSNAME?
         BE    DD$DSKEY                 YES. PROCESS IT.
          AIF   (&QLEVEL GE 5).DD08      DON'T NEED TO FIND DDN IF 134
         CLI   0(R7),DDK                IS THIS THE DDNAME?
         BE    DDKEY                    YES. PROCESS IT.
.DD08     ANOP
         CLI   0(R7),TERMK              term=ts?
         BE    DD$TERM                  YES. PROCESS IT.
DDNXTFLD IC    R1,1(,R7)                NUMBER OF SUBFIELDS
         LA    R7,2(,R7)                UPDATE LOCATION
         SH    R8,=H'2'                 REMAINING COUNT
         SR    R8,R1                    REMAINING COUNT
         BNP   DDENDREC                 REC IS EXHAUSTED - CHK FOR DSN=
         LTR   R1,R1                    ARE THERE ANY SUBFIELDS?
         BZ    DDTRYFLD                 NO. TRY NEXT FIELD.
DDLPFLD  TM    0(R7),X'80'              IS THIS A SUB-SUB-FIELD
         BZ    DDNOSUB                  NO. CONTINUE.
         IC    R14,0(,R7)               NUMBER OF SUB-SUB-FIELDS
         N     R14,=A(X'7F')            CLEAR THE HEX 80 BIT
         LA    R7,1(,R7)                UPDATE LOCATION
         SH    R8,=H'1'                 REMAINING COUNT
         SR    R8,R14                   REMAINING COUNT
         BNP   DDNXTREC                 Record is exhausted
         AR    R1,R14                   INCREASE NUMBER OF SUBFIELDS
         B     DDYESSUB                 DECREMENT AND TRY AGAIN
DDNOSUB  IC    R15,0(,R7)               SUBFIELD LENGTH
         LA    R7,1(R15,R7)             ADD TO LOCATION
         SR    R8,R15                   REMAINING COUNT
         BNP   DDNXTREC                 Record is exhausted
DDYESSUB BCT   R1,DDLPFLD               DO NEXT SUBFIELD
         B     DDTRYFLD                 TRY NEXT FIELD
          AIF   (&QLEVEL GE 5).DD09
DDKEY    IC    R1,2(,R7)                LENGTH OF DDNAME
         LTR   R1,R1                    IS THE LENGTH ZERO?
         BZ    DDNXTFLD                 YES. SKIP THE FIELD.
         BCTR  R1,0                     DECREMENT BY 1
         EX    R1,DDMVCDDN              MOVE THE DDNAME
         B     DDNXTFLD                 PROCESS NEXT FIELD
.DD09     ANOP
DD$TERM  OI    DD@FLAGS,DD@FTS          indicate presence of TERM=TS
         B     DDNXTFLD                 GO PROCESS NEXT TEXT UNIT
DD$DSKEY ST    R7,DD@ADSNK              SAVE PTR TO DSN= TEXT UNIT
         B     DDNXTFLD                 GO PROCESS NEXT TEXT UNIT
DDENDREC L     R7,DD@ADSNK              -> LAST DSN= TEXT UNIT, IF ANY
         LTR   R7,R7                    ANY?
         BZ    DDNXTREC                 No - go on to next record
         CLC   =C'TSU',8(R7)            this a tsu?
         BNE   *+4+4+4                  no, continue
         TM    DD@FLAGS,DD@FTS          term=ts present?
         BO    DDNXTREC                 yes, ignore dsn.
*        MVC   DDDSID,19(R7)            MOVE THE DSID
         XR    R1,R1                    CLEAR FOR IC
         IC    R1,LRCLRECL-LRCDSECT(,R7) GET LEN OF DSN FIELD
         LA    R1,LRCTEXT-LRCDSECT(R1,R7)  START OF NEXT FIELD
          AIF   (&QLEVEL LT 10).DD10     dsn format changed at 313
*        the following loop gets rid of the "dataset type" suffix
         BCTR  R1,0                     back 1 char
         CLI   0(R1),C'.'               qualifier delimiter?
         BNE   *-4-2                    no, try again
.DD10     ANOP
         SH    R1,=Y(L'DDDSID)          LESS LEN OF OUTPUT FIELD
         MVC   DDDSID,0(R1)             MOVE IN LAST PORTION OF DSID
*        CLI   DDDSID,C'0'              LEADING 0?
*        BNE   *+8                      NO - SKIP
*        MVI   DDDSID,C' '              YES - MAKE IT A BLANK
         PACK  DDN@DWD,DDDSID
         MVC   DDN@TEMP,=X'4020202020202120'      ID
         ED    DDN@TEMP,DDN@DWD+4
         MVC   DDDSID,DDN@TEMP+2
         CVB   R0,DDN@DWD               GET DSID IN BINARY
         MVC   DDDSTYPE,=C'*ERROR'      INIT FIELD
         TM    LRCTEXT+STRDINDC-TEXT,DTXSYOUT  SYSOUT?
         BNO   *+10                     NO - SKIP
         MVC   DDDSTYPE,=C'Sysout'      'SYSOUT'
         TM    LRCTEXT+STRDINDC-TEXT,DTXSYSIN  SYSIN?
         BNO   *+10                     NO - SKIP
         MVC   DDDSTYPE,=C'Sysin '      'SYSIN '
         TM    LRCTEXT+STRDINDC-TEXT,DTXSYOUT+DTXSYSIN  BOTH????
         BNO   *+10                     NO - SKIP
         MVC   DDDSTYPE,=C'ERROR*'
         DROPX R4                       LRC
***********************************************************************
*   FIND IN-STORAGE TABLE ENTRY FOR THIS PDDB                         *
*   EXTRACT RECORD COUNT, CLASS, HOLD, PRT, ETC                       *
***********************************************************************
         L     R7,QDSTART               -> IN-STORAGE TABLE
         USNGX DD@ENT,R7
DD$TBLLP CLC   =X'EEEEEEEE',DD@DSKEY    END OF TABLE?
         BE    DD$TBLNF                 YES - NOT FOUND
         C     R0,DD@DSKEY              THIS THE ENTRY?
         BE    DD$TBLOK                 YES - GO FORMAT DATA
         LA    R7,DD@ENTL(,R7)          -> NEXT TABLE ENTRY
         B     DD$TBLLP                 KEEP LOOKING
DD$TBLOK BAL   R8,DD$FMT2               FORMAT RECCT/CLASS/HOLD/PRINT
         DROPX R7                       DD@ENT
***********************************************************************
*   BUILD THE OUTPUT LINE                                             *
***********************************************************************
DD$TBLNF MVC   DDATTR1,=X'1DC8'         SET INPUT, BRIGHT
         MVC   DDATTR2,=X'1D60'         SET OUTPUT, NORMAL
         MVC   DDATTR3,=X'1DE8'         SET OUTPUT, BRIGHT
         CLC   =C'Sysout',DDDSTYPE      IS THIS A SYSOUT DATASET?
         BE    *+8                      YES - OK
         MVI   DDATTR3+1,X'60'          SET OUTPUT, NORMAL
         MVC   DDATTR4,=X'1D60'         SET OUTPUT, NORMAL
         MVI   QDATRNUM+1,4             SET # OF ATTR BYTES IN LINE
*---  SAVE DATA IN ARRAY FOR LINE COMMANDS                         ---*
         XC    DD@TPTR(LCBELEN),DD@TPTR INIT ARRAY ELEMENT
         MVI   DD@ADDR1+3,DDSELECT-QDMSG  OFFSET INTO LINE OF 1ST FIELD
         MVC   DD@ID,DDDSID             DSID
         MVC   DD@FLD1(2+8),QBLANK
         LA    R1,DD@TPTR               -> MY ARRAY ELEMENT
         QCALL DISPADDX                 ADD THIS LINE TO SCREEN
         B     DDNXTREC                 Process next record
*%%DDTILT1  QTILT '*** DSID TABLE OVERFLOW ***'
         SPACE 2
***********************************************************************
*                                                                     *
*   PROCESS SPUN OFF DATASETS                                         *
*                                                                     *
***********************************************************************
DDSPIN   L     R7,QDSTART               -> IN-STORAGE PDDB TABLE
         USNGX DD@ENT,R7
         MVC   DD@PSTEP,=X'EFFEEFFE'    CLEAR
         MVC   DD@STEP,=X'EFFEEFFE'     CLEAR
DDSPIN10 CLC   =X'EEEEEEEE',DD@DSKEY    end of table?
         BE    DDSPIN90                 YES - ALL DONE HERE
         MVI   DD@STAR,C' '             ASSUME NOTHING WEIRD
         TM    DD@FLAGS,DD@FNOTX        INTERNAL TEXT UNAVAILABLE?
         BO    DDSPIN20                 YES - DISPLAY THIS ENTRY
***      TM    DD@FLAG1,PDB1SPIN        SPIN DATASET?
***      BO    DDSPIN20                 YES - DISPLAY IT
*%        AIF   (&QLEVEL GE 11).DD15
*%       TM    DD@FLAG1,PDB1SPIN+PDB1PSO  PROCESSABLE??
*%        AGO   .DD16
.DD15     ANOP
*%       TM    DD@FLAG1,PDB1SPIN        PROCESSABLE?
.DD16     ANOP
*%       BNZ   DDSPIN20                 YES - DISPLAY IT
         TM    DD@FLAG1,PDB1SPIN        SPIN DATASET?
         BO    DDSPIN20                 YES - DISPLAY IT
         TM    QDEBUG1,QDEBUG11         DEBUGGING?
         BNO   DDSPIN50                 NO - SKIP THIS ENTRY
         CLI   DD@XFLAG,255             THIS ENTRY ALREADY DISPLAYED?
         BE    DDSPIN50                 YES - SKIP IT
         MVI   DD@STAR,C'*'             NO - INDICATE IT WOULD HAVE
*                                            HAVE BEEN SUPPRESSED
         B     DDSPIN30                 CONTINUE
DDSPIN20 CLI   DD@XFLAG,255             THIS ENTRY ALREADY DISPLAYED?
         BNE   DDSPIN25                 NO - CONTINUE
         TM    QDEBUG1,QDEBUG11         DEBUGGING?
         BNO   DDSPIN50                 NO - SKIP IT
         MVI   DD@STAR,C'<'             YES - FLAG SOMETHING FISHY HERE
         B     DDSPIN30                 and, display it
DDSPIN25 TM    DD@FLAG1,PDB1NULL+PDB1NSOT  null pddb entry?
         BZ    DDSPIN30                 no, continue
         TM    QDEBUG1,QDEBUG11         DEBUGGING?
         BNO   DDSPIN50                 NO - SKIP IT
DDSPIN30 EQU   *
          AIF   (&QLEVEL LT 5).DD11
         CLC   DD@PSTEP,DD@PNAME        DID PROCSTEPNAME CHANGE?
         BNE   DDSPIN31                 yes - save new info
         CLC   DD@STEP,DD@SNAME         DID STEPNAME CHANGE?
         BE    DDSPIN40                 NO - SKIP
DDSPIN31 MVC   DD@PSTEP,DD@PNAME        SAVE NEW PROCSTEPNAME
         MVC   DD@STEP,DD@SNAME         SAVE NEW STEPNAME
         MVC   QDMSG(2),=X'1DE8'        SET OUTPUT, BRIGHT
         MVC   QDMSG+2(2),=C'- '        START THE SEPARATOR LINE
         MVC   QDMSG+4(76),QDMSG+2      PROPAGATE THE SEPARATOR
         MVC   QDMSG+80(2),=X'1D60'     SET OUTPUT, NORMAL
         MVI   QDATRNUM+1,2             SET # OF ATTR BYTES IN LINE
         BAL   R14,QADDLINE             ADD THE SEPARATOR LINE
         MVC   DDSTEPLN,DD#STHDR        MOVE IN HEADING
         MVC   DDPGM,=C'*UNKNOWN'       MOVE IN PGMNAME
         MVC   DDPROCN,=C'*UNKNOWN'     MOVE IN PROCNAME
         MVC   DDSTEPN,DD@PNAME         MOVE IN PROCSTEPNAME
         CLC   DDSTEPN,QBLANK           ANY PROCSTEPNAME?
         BE    DDSPIN37                 NO - PUT STEPNAME HERE
         CLC   DD@SNAME,QBLANK          ANY STEPNAME?
         BE    DDSPIN39                 NO - DON'T PUT IN THE DOT
*---  FLOAT A '.' AND THE STEPNAME                                 ---*
         LA    R15,DDSTEPN              -> START OF FIELD
         LA    R15,1(,R15)              -> NEXT POSSIBLE POSITION
         CLI   0(R15),C' '              END OF PROCSTEPNAME?
         BNE   *-8                      NO - KEEP LOOKING
         MVI   0(R15),C'.'              ADD THE SEPARATOR
         MVC   1(8,R15),DD@SNAME        MOVE IN STEPNAME
         B     DDSPIN39
DDSPIN37 MVC   DDSTEPN,DD@SNAME         MOVE STEPNAME ONLY
DDSPIN39 MVI   QDATRNUM+1,2             SET # OF ATTR BYTES IN LINE
         QCALL DISPADD                  ADD THIS LINE TO SCREEN
DDSPIN40 EQU   *
.DD11     ANOP
         MVC   DDDSIDFL,DD@STAR         COPY "WEIRDNESS" FLAG
         MVC   DDDSTYPE,=C'<Spin>'      MOVE IN DATASET TYPE ('<SPIN>')
         TM    DD@FLAG1,PDB1SPIN        SPIN DATASET?
         BO    *+10                     YES - OK
***      MVC   DDDSTYPE,=C'UNKNWN'      INDICATE DATASET TYPE
         MVC   DDDSTYPE,=C'DynOut'      INDICATE FREE=END
         MVC   DDATTR1,=X'1DC8'         SET INPUT, BRIGHT
         MVC   DDATTR2,=X'1D60'         SET OUTPUT, NORMAL
         MVC   DDATTR3,=X'1DE8'         SET OUTPUT, BRIGHT
         MVC   DDATTR4,=X'1D60'         SET OUTPUT, NORMAL
         MVI   QDATRNUM+1,4             SET # OF ATTR BYTES IN LINE
         BAL   R8,DD$FMT                FMT DSID/RECCT/CLASS/HOLD/PRINT
*---  SAVE DATA IN ARRAY FOR LINE COMMANDS                         ---*
         XC    DD@TPTR(LCBELEN),DD@TPTR INIT ARRAY ELEMENT
         MVI   DD@ADDR1+3,DDSELECT-QDMSG  OFFSET INTO LINE OF 1ST FIELD
         MVC   DD@ID,DDDSID             DSID
         MVC   DD@FLD1(2+8),QBLANK
         LA    R1,DD@TPTR               -> MY ARRAY ELEMENT
         QCALL DISPADDX                 ADD LINE TO DISPLAY
DDSPIN50 LA    R7,DD@ENTL(,R7)          -> NEXT TABLE ENTRY
         B     DDSPIN10                 GO DISPLAY THIS ONE
         DROPX R7                       DD@ENTL
DDSPIN90 TM    QDEBUG1,QDEBUG11         DEBUGGING?
         BNO   QSTOP                    NO - ALL DONE
         MVI   QDMSG,C'-'               INSERT A LINE ...
         MVC   QDMSG+1(L'QDMSG-1),QDMSG ... OF DASHES
         MVC   QDMSG+(80-DDDFPDBL)/2(DDDFPDBL),DDDEFPDB  WITH HEADER
         MVI   QDATRNUM+1,2             2 ATTR BYTES HERE
         BAL   R14,QADDLINE             DISPLAY THIS LINE
         LA    R4,DDDEF80               -> first flag definition
         LA    R5,DDDEF08               -> fifth flag definition
         LA    R2,8/2                   number of times through loop
         LA    R3,2*2                   number of attr bytes per line
         TM    QISFLAG1,QIS1ISPF        running under ISPF?
         BZ    DD$FL$LP                 no - use two column format
         LA    R2,8                     yes - use single column format
         LA    R3,2                     number of attr bytes per line
*
DD$FL$LP MVC   QDMSG,QBLANK             clear the line
         MVC   QDMSG+20(DDDEFLEN),0(R4) copy one definition
         TM    QISFLAG1,QIS1ISPF        running under ISPF?
         BNZ   DD$FL$IS                 yes - skip other format
         MVC   QDMSG(DDDEFLEN),0(R4)    copy left half
         MVC   QDMSG+40(DDDEFLEN),0(R5) copy right half
DD$FL$IS STC   R3,QDATRNUM+1            indicate number of attr bytes
         BAL   R14,QADDLINE             DISPLAY THIS LINE
         LA    R4,DDDEFLEN(,R4)         bump left ptr
         LA    R5,DDDEFLEN(,R5)         bump right ptr
         BCT   R2,DD$FL$LP              loop
         BAL   R14,QADDLINE             DISPLAY A BLANK LINE
         B     QSTOP                    ALL DONE
***********************************************************************
*                                                                     *
*   FORMAT A LINE FOR 1 DSID                                          *
*                                                                     *
***********************************************************************
         USNGX DD@ENT,R7
DD$FMT   L     R0,DD@DSKEY              CONVERT
         CVD   R0,DDN@DWD                  DATA SET
         MVC   DDN@TEMP,=X'4020202020202120'      ID
         ED    DDN@TEMP,DDN@DWD+4
         MVC   DDDSID,DDN@TEMP+2
DD$FMT2  MVI   DD@XFLAG,255             INDICATE THIS ENTRY DISPLAYED
          AIF   (&QLEVEL LT 5).DD12
         MVC   DDDDNAME,DD@DDNAM        MOVE IN DDNAME FROM PDDB
.DD12     ANOP
         L     R0,DD@RECCT              CONVERT
         CVD   R0,DDN@DWD                  RECORD
         MVC   DDDSRECS,=X'4020202020202120'     COUNT TO
         ED    DDDSRECS,DDN@DWD+4                   PRINTABLE
         MVC   DDDSCLS,DD@CLASS         MOVE IN SYSOUT CLASS
         LA    R1,DD@DEST               -> BINARY DEST
         QCALL FINDRJE                  GET A DISPLAYABLE NAME
         MVC   DDDSDEST,0(R1)           DISPLAY THE RESULTS
         SR    R0,R0                    CLEAR FOR IC
         IC    R0,DD@COPYS              GET COPY COUNT
         CH    R0,=H'1'                 DEFAULT?
         BNH   DD$NOCPY                 YES - SKIP
         CVD   R0,DDN@DWD
         MVC   DDDSCPYS,=X'40202020'    GET EDIT MASK
         ED    DDDSCPYS,DDN@DWD+6       FILL IN COPY COUNT
DD$NOCPY MVC   DDDSFORM,DD@FORMS        MOVE IN FORMS CODE
         MVC   DDSFCB,DD@FCB            MOVE IN FCB CODE
         MVC   DDDSUCS,DD@UCS           MOVE IN UCS CODE
         MVC   DDHELD,QBLANK            CLEAR FIELD
          AIF   (&QLEVEL GE 11).DD13
         TM    DD@FLAG1,PDB1HOLD        HELD DATASET?
         BNO   *+10                     NO - SKIP
         MVC   DDHELD,=C'H-'            YES - INDICATE THAT
         TM    DD@FLAG1,PDB1SPIN        SPIN DATASET?
         BNO   DD$NOTP                  NO - SKIP
         TM    DD@FLAG1,PDB1PSO         AVAILABLE FOR SYSOUT?
         BO    DD$NOTP                  YES - OK
         MVC   DDHELD,=C'P-'            NO - INDIC. IT'S BEEN PRINTED
.DD13     ANOP
DD$NOTP  TM    QDEBUG1,QDEBUG11         WANT PDBFLAG DISPLAYED?
         BZR   R8                       NO - DON'T DISPLAY PDBFLAG1
         MVI   QDHLINE+78,C'F'          PUT IN COLUMN HEADER
         UNPK  DDN@DWD(2+1),DD@FLAG1(1+1)
         TR    DDN@DWD(2),QHEXTAB
         MVC   DDPDBFLG,DDN@DWD
         BR    R8                       RETURN TO CALLER
         DROPX R7                       DD@ENT
***********************************************************************
*                                                                     *
*   READ A BLOCK FROM HASPACE                                         *
*                                                                     *
***********************************************************************
DD$READ  ST    R4,QCTRAK                STORE DISK ADDR
         L     R0,QCJQEA                -> JQE
         LR    R1,R5                    IOAREA ADDRESS
         QCALL READSPC                  READ HASPACE
         BR    R8                       RETURN TO CALLER
         EJECT ,
***********************************************************************
*                                                                     *
*   Sort Compare ROUTINE                                              *
*                                                                     *
***********************************************************************
         SPACE 1
         DROPX ,
         USNGX DD$CMP,R15
         USNGX DD@ENT,R1
         USNGX WORK,R3
         SPACE 2
DD$CMP   MVI   DD@CFLAG,0               clear flags
         CLC   DD@DSKEY,DD@DSKEY-DD@ENT(R2) Same DSID?
         BNER  R14                      no, let sort do it
         TM    DD@FLAG1,PDB1NULL        null?
         BZ    *+8                      no, skip flag
         OI    DD@CFLAG,DD@CFN1         yes, flag it
         TM    DD@FLAG1-DD@ENT(R2),PDB1NULL  null?
         BZ    *+8                      no, skip flag
         OI    DD@CFLAG,DD@CFN2         yes, flag it
         TM    DD@CFLAG,DD@CFN1+DD@CFN2 any nulls?
         BNM   DD$CMPE                  zero/ones
DD$CNULL TM    DD@CFLAG,DD@CFN1         first entry null?
         BO    DD$CMPL                  yes, switch
         TM    DD@CFLAG,DD@CFN2         second entry null?
         BO    DD$CMPH                  no, continue
DD$CMPL  CLC   =H'1',=H'2'              set cc low
         BR    R14
DD$CMPH  CLC   =H'2',=H'1'              set cc high
         BR    R14
DD$CMPE  CLC   =H'1',=H'1'              set cc equ
         BR    R14
         SPACE 2
         DROPX R1,R3,R15
         EJECT ,
***********************************************************************
*                                                                     *
*   MISCELLANY                                                        *
*                                                                     *
***********************************************************************
         USNGX DDNAME,R12
         USNGX QCOMMON,R11
         USNGX WORK,R13
         SPACE 2
DD$TILT1 QTILT '*** Dataset Table Limits Exceeded ***'
         SPACE 3
         LTORG ,
         ENTRY SJ#KEYS
SJ#KEYS  DC    CL8'ALL     ',CL8'A       '
         DC    X'FF'                    END OF KEYWORD TABLE
          AIF   (&QLEVEL GE 5).DD14
DDMVCDDN MVC   DDDDNAME(*-*),3(R7)      << EXECUTED >>
.DD14     ANOP
          AIF   (&QLEVEL GE 5).DD91
DSIDTYPE DC    C'JCLIN '                DSID=1
         DC    C'JOBLOG'                DSID=2
         DC    C'JCL   '                DSID=3
         DC    C'JOBMSG'                DSID=4
         DC    C'JCLTXT'                DSID=5
         DC    C'SWA   '                DSID=6
.DD91     ANOP
DDCMDSYS DC    C'000001'                DSID=1
         DC    C'JLOG  '                DSID=2
         DC    C'JCL   '                DSID=3
         DC    C'JMSG  '                DSID=4
         DC    C'000005'                DSID=5
         DC    C'000006'                DSID=6
*D#STHDR DC    X'1DE8',CL(80-2)'** Pgm=          Proc=          Step='
DD#STHDR DC    X'1DE8',CL18'******************'
         DC    CL(80-2-18)'** Pgm=          Proc=          Step='
         DC    X'1D60'                  SET OUTPUT, NORMAL
         SPACE 1
          AIF   (&QLEVEL GE 5).DD92
NOTXTMSG DC    X'1DE8',C'************ DDname, Program, and Stepname inf$
               ormation unavailable ***********',X'1D60'
NOTXTMGL EQU   *-NOTXTMSG
.DD92     ANOP
         SPACE 1
DDDEFPDB DC    X'1DE8',C'  PDBFLAG1 definition  ',X'1D60'
DDDFPDBL EQU   *-DDDEFPDB
         SPACE 1
DDDEF80  DC X'1DE8',C'80=DSID',X'1D60',CL31'- DSID in PDBDSID/PDBWTRID'
DDDEFLEN EQU   *-DDDEF80
         DC X'1DE8',C'40=NULL',X'1D60',CL31'- This is a null PDDB     '
         DC X'1DE8',C'20=LOG ',X'1D60',CL31'- PDDB for HASP Job Log   '
         DC X'1DE8',C'10=MDES',X'1D60',CL31'- Mult-dest PDDBs follow  '
DDDEF08  DC X'1DE8',C'08=NSOT',X'1D60',CL31'- Not for Sysout          '
         DC X'1DE8',C'04=SPIN',X'1D60',CL31'- PDDB for Spin data set  '
         DC X'1DE8',C'02=HOLD',X'1D60',CL31'- PDDB for Held data set  '
         DC X'1DE8',C'01=PSO ',X'1D60',CL31'- Accessible by PSO       '
         SPACE 3
         QCOMMON
         PUSH  PRINT
         PRINT GEN                      get expansions back
         ORG   QDMSG                    LINE FOR EACH DSID
DDATTR1  DS    XL2
DDSELECT DS    CL2
DDATTR2  DS    XL2
DDDDNAME DS    CL8
DDATTR3  DS    XL2
DDDSID   DS    CL6
DDDSIDFL DS    C
DDATTR4  DS    XL2
DDHELD   DS    CL2                      'H-' OR 'P-' OR BLANK
DDDSTYPE DS    CL6                      'SYSOUT', 'SYSIN ', OR '<SPIN>'
DDDSRECS DS    CL8
         DS    CL2
DDDSCLS  DS    C
         DS    CL2
DDDSDEST DS    CL8
DDDSCPYS DS    CL4
         DS    CL2
DDDSUCS  DS    CL4
         DS    C
DDSFCB   DS    CL4
         DS    C
          AIF   (&QLEVEL GE 5).DD93
DDDSFORM DS    CL4
          AGO   .DD94
.DD93     ANOP
DDDSFORM DS    CL8
.DD94     ANOP
         DS    CL4
DDPDBFLG DS    CL2
         ORG   QDMSG                    LINE FOR EACH STEP
DDSTEPLN DS    0CL(2+78+2)
         DS    X'1DE8',CL18,C'** PGM='
DDPGM    DS    CL8
         DS    C'  PROC='
DDPROCN  DS    CL8
         DS    C'  STEP='
DDSTEPN  DS    CL8
         DC    C'.'
         DS    CL8
         SPACE 3
WORK     DSECT
         ORG   WORK+72                  SKIP OVER SAVE AREA
DDN@DWD  DS    D
DD@PROCN DS    CL8
DD@PSTEP DS    CL8
DD@STEP  DS    CL8
DD@ADSNK DS    A                        -> LAST DSN= INTERNAL TEXT UNIT
DD@TBLEE DS    A                        -> end of dsid table
DDN@TEMP DS    CL8
DD@STAR  DS    C
DD@WORK  DS    CL4
DD@REGSV DS    4F                       TEMP REGISTER SAVE AREA
DD@FLAGS DS    X
DD@FSPIN EQU   X'01'                    THIS IS A SPIN DSID
DD@FNOTX EQU   X'02'                    INTERNAL TEXT UNAVAILABLE
DD@FTS   EQU   X'04'                    term=ts text key
DD@FSJAL EQU   X'80'                    'ALL' OPERAND OF 'SJ' SUBCMD
         SPACE 1
         QLCB  PREFIX=DD@
*D@TPTR  DS    A                        LCBTPTR
*D@ADDR1 DS    A                        LCBADDR1
*D@ADDR2 DS    A                        LCBADDR2
*D@ID    DS    CL6                      LCBID (DSID)
*D@FLD1  DS    CL2                      LCBFLD1
*D@FLD2  DS    CL8                      LCBFLD2
          AIF   ('&@@OACFS' EQ '').DD95
DD@PARM  OACFSORT  PREFIX=DD@,DSECT=NO
.DD95     ANOP
         SPACE 1
DD@CFLAG DS    X                        misc flags for compare rtn
DD@CFN1  EQU   X'80'                    first dd entry null
DD@CFN2  EQU   X'40'                    second dd entry null
DD@WORKL EQU   *-WORK
DD@SWRK  DS    XL512
         SPACE 3
*---  COMPRESSED COPY OF A PDDB                                    ---*
DD@ENT   DSECT
DD@EYE   DS    CL3'DDE'                 eyecatcher
DD@XFLAG DS    X                        255 = ALREADY DISPLAYED
DD@DSKEY DS    F                        SAVE FOR PDBDSKEY
DD@RECCT DS    F                        SAVE FOR PDBRECCT
DD@DEST  DS    CL4                      SAVE FOR PDBDEST
          AIF   (&QLEVEL GE 5).DD96
DD@FORMS DS    CL4                      SAVE FOR PDBFORMS
          AGO   .DD97
.DD96     ANOP
DD@PNAME DS    CL8                      SAVE FOR PDBPNAME
DD@SNAME DS    CL8                      SAVE FOR PDBSNAME
DD@DDNAM DS    CL8                      SAVE FOR PDBDDNAM
DD@FORMS DS    CL8                      SAVE FOR PDBFORMS
.DD97     ANOP
DD@FCB   DS    CL4                      SAVE FOR PDBFCB
DD@UCS   DS    CL4                      SAVE FOR PDBUCS
DD@LRECL DS    H                        SAVE FOR PDBLRECL
DD@FLAG1 DS    B                        SAVE FOR PDBFLAG1
DD@RECFM DS    X                        SAVE FOR PDBRECFM
DD@CLASS DS    C                        SAVE FOR PDBCLASS
DD@COPYS DS    AL1                      SAVE FOR PDBCOPYS
         DS    0D                       make debugging easier
DD@ENTL  EQU   *-DD@ENT
         SPACE 3
*%%      DROPX R13                      WORK
         POP   PRINT
         SPACE 3
         Q$PDDB
         Q$LRC
         QZKEYS
         QZTEXT
