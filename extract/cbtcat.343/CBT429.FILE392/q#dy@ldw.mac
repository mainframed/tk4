         TITLE '--- QUEUE--DISPLAY -- 3270 DISPLAY ROUTINES ---'
*---------------------------------------------------------------------*
*                                                                     *
*   DISPLAY - DISPLAY CURRENT SCREEN BUFFER                           *
*                                                                     *
*   Updates:                                                          *
*      08Feb87  LDW  Support command ring for RECALL                  *
*      17Jan87  LDW  Remove "*" subcommand;  misc other cleanup       *
*                    Remove "LC" macro usage                          *
*      04/23/86 LDW  FIX BUGS                                         *
*      03/31/86 LDW  RE-DESIGN 3278-5 SUPPORT (THIRD TRY!)            *
*                    USE NEW COMMON LOGIC ERROR ROUTINE               *
*      09/13/84 LDW  ALLOW FOR 24 PFKEYS IF "MODE PFK24"              *
*      01/19/84 LDW  ADD SUPPORT FOR 'COLS' SUBCOMMAND                *
*                    FIX BUG IN HEADER IF 'JESNEWS'                   *
*      01/17/84 LDW  FIX ASM ERROR CAUSED BY EXPANSION OF QDSCREEN    *
*      04/07/83 LDW  FIX LOOP CAUSED BY LEADING BLANK IN INPUT FIELD  *
*                    FIX GLITCH IN "RECALL" CAUSED BY VTAM BUG        *
*      03/15/83 LDW  PROCESS MULTIPLE INPUT FIELDS ON SCREEN          *
*                    CHANGE USING/DROP TO USNGX/DROPX                 *
*                    FIX TTY MODE OUTPUT                              *
*                    CHANGE "*" SUBCOMMAND TO "RECALL" ("RC")         *
*      02/03/83 LDW  ADD "* I" TO REPROMPT LAST INQUIRY SUBCOMMAND    *
*      01/19/83 LDW  ADD WORKLEN= TO QSTART TYPE=ENTRY                *
*      01/14/83 LDW  ADD REPROMPT TSO AND MVS                         *
*      01/12/83 LDW  MOVE STARKEYS FROM "PARSE"                       *
*      01/10/83 LDW  SQUEEZE OUT ATTR BYTES IN "DY$TTY"               *
*                    HANDLE TCAM10 RESHOW (PA3)                       *
*                    REDESIGN SCREEN BUFFER LOGIC SO THAT BUFF PTR IS *
*                       ONLY RESET WHEN FIRST LINE IS TO BE STORED IN *
*                       BUFFER (THIS IS SO THAT A MESSAGE FROM QTILT  *
*                       CAN BE WRITTEN LEAVING THE REST OF THE        *
*                       INTACT)                                       *
*                    SUPPORT Q2SHORT WHICH INDICATES THAT ONLY THE    *
*                       TOP 3 SCREEN LINES SHOULD BE WRITTEN          *
*      01/06/83 LDW  FIX CLEAR LOGIC                                  *
*      01/04/83 LDW  ADD WORKLEN=                                     *
*                    HANDLE REPOSITIONING SUBCOMMAND DIRECTLY         *
*      12/17/82 LDW  PUT IN SUPPORT FOR IMBEDDED ATTR BYTES IN LINE   *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 3
DISPLAY  QSTART  Q5,WORKLEN=DY@WORKL
         USNGX WORK,R13
         MVI   DY@FLAG,DY@IMM           SET FLAG TO "IMMEDIATE DISPLAY"
         XC    DY@CURS,DY@CURS          INDICATE DEFAULT CURSOR POS
         OI    QFLAG1,Q1PROFOK          INITIALIZATION PROFILE COMPLETE
         BAL   R8,DY$SETOP              BUILD TOP SCREEN LINES (MAYBE)
         BAL   R8,DY$SETTL              BUILD LINE OF DASHES
         B     DY$WRITE                 GO WRITE SCREEN
         SPACE 3
*---------------------------------------------------------------------*
*                                                                     *
*   DISPADD - ADD A LINE TO SCREEN BUFFER, DISPLAY SCREEN IF FULL     *
*                                                                     *
*   ENTRY - LINE TO BE ADDED IN "QDMSG"                               *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 3
DISPADD  QSTART  TYPE=ENTRY
         XC    DY@TPTR,DY@TPTR          NO LINE CMD ELEMENT POINTER
         B     DY$ADD00                 CONTINUE
         SPACE 3
*---------------------------------------------------------------------*
*                                                                     *
*   DISPADDX - SAME FUNCTION AS DISPADD                               *
*                                                                     *
*   ENTRY - LINE TO BE ADDED IN "QDMSG"                               *
*         - R1 -> LINE COMMAND ELEMENT                                *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 3
DISPADDX QSTART  TYPE=ENTRY
         ST    R1,DY@TPTR               SAVE LINE CMD ELEMENT POINTER
         SPACE 1
DY$ADD00 MVI   DY@FLAG,0                SET FLAG TO "ADD MSG"
         XC    DY@CURS,DY@CURS          INDICATE DEFAULT CURSOR POS
         TM    QFLAG1,Q1IMMED           HERE ON "IMMEDIATE" COMMAND?
         BNO   DY$ADD01                 NO - SKIP
         NI    QFLAG1,255-Q1IMMED       RESET "IMMEDIATE COMMAND"
         L     R0,=C'DY1 '              SET LOGIC ERROR CODE
         L     R15,=V(LOGICERR)         -> ROUTINE
         BALR  R14,R15                  GO TO IT (NO RETURN)
***********************************************************************
*                                                                     *
*  QUICKIE DESCRIPTION OF "DISPLAY" LOGIC:                            *
*    (1) IF ROOM ON SCREEN FOR MESSAGE, MOVE IT IN AND RETURN         *
*    (2) IF NO ROOM, SHOW *MORE*, DISPLAY SCREEN, RESET POINTERS,     *
*        GO TO (1)                                                    *
***********************************************************************
         SPACE 1
***********************************************************************
*                                                                     *
*   CHECK FOR ROOM ON SCREEN                                          *
*                                                                     *
***********************************************************************
DY$ADD01 MVI   QDOVER,0                 RESET THE PAGE OVRFL INDICATOR
         TM    QTERMFLG,QTFSW2+QTFSW5   NEED TO SWITCH?
         BNZ   DY$ADD02                 YES - SKIP NEXT TEST
         TM    QFLAG2,Q2NEWSCR          THIS OUTPUT FOR LINE 1?
         BNO   DY$ADD03                 NO - SKIP
         SPACE 1
***********************************************************************
*                                                                     *
*   BUILD SCREEN HEADER IF NECESSARY AFTER MOD2 <-> MOD5 SIZE SWITCH  *
*                                                                     *
***********************************************************************
DY$ADD02 BAL   R8,DY$SETOP              BUILD TOP SCREEN LINES (MAYBE)
         BAL   R8,DY$SETTL              BUILD LINE OF DASHES
         MVC   QDNEXT,QVLINE1           SET ADDR OF FIRST OUTPUT LINE
         XC    QDLINECT,QDLINECT        RESET LINE NUMBER
         NI    QFLAG2,255-Q2NEWSCR      RESET FLAG
         XC    QDENDPTR,QDENDPTR        KILL PTR TO IC AT END
         SPACE 1
DY$ADD03 LH    R1,QDLINECT              GET CURRENT LINE COUNT
         LA    R1,1(,R1)                INCREMENT
         CH    R1,QDROWS                SCREEN BUFFER FULL?
         BH    DY$FULL                  YES - WRITE SCREEN.
         STH   R1,QDLINECT              SAVE UPDATED LINE COUNT
         CH    R1,=H'1'                 IS THIS DATA LINE 1?
         BNE   DY$ADD04                 NO - SKIP
         OI    QFLAG1,Q1MVHDR           YES - REQUEST "MOVE HEADER"
         TM    QFLAG2,Q2LISTDS+Q2COLIND IN 'LISTDS' AND WANT COL IND?
         BNO   DY$ADD04                 NO - SKIP
         L     R4,QDNEXT                -> NEXT LINE LOC
         LH    R5,QDCOLS                GET LINE LENGTH
         BCTR  R5,0                     -1 FOR EX
         LA    R15,DY#SCALE             -> MY COLUMN SCALE
         AH    R15,QPOFFSET             ADD COL-1
         EX    R5,DY$SCMVC              MVC 0(*-*,R4),0(R15)
         LA    R4,1(R5,R4)              -> NEXT LINE LOC
         ST    R4,QDNEXT                UPDATE PTR TO NEXT LINE LOC
         MVI   QDLINECT+1,2             SET LINE COUNT
***********************************************************************
*                                                                     *
*   MOVE THE MESSAGE TO THE SCREEN                                    *
*                                                                     *
***********************************************************************
DY$ADD04 L     R4,QDNEXT                -> NEXT LINE LOCATION
         LH    R5,QDCOLS                GET LINE LENGTH
         AH    R5,QDATRNUM              ADD # OF ATTR BYTES IN LINE
         BCTR  R5,0                     -1 FOR EX
         EX    R5,DY$ADD                MVC 0(*-*,R4),QDMSG
         MVC   QDMSG,QBLANK             CLEAR THE MSG WORK AREA
         OC    QDLCTBL,QDLCTBL          ANY LINE COMMANDS TABLE?
         BZ    DY$NAUPD                 NO - SKIP ARRAY UPDATE
         L     R15,DY@TPTR              GET SAVED POINTER
         LTR   R15,R15                  ANYTHING?
         BZ    DY$NAUPD                 NO - SKIP ARRAY UPDATE
         BCTR  R1,0                     MAKE LINE COUNT ORIGIN 0
         MH    R1,=Y(LCBELEN)           OFFSET OF ARRAY ELEMENT
         AL    R1,QVLCBUF               -> ARRAY ELEMENT
         USNGX LCBUFF,R1
         MVC   0(LCBELEN,R1),0(R15)     SAVE THE ARRAY ELEMENT
         ICM   R0,B'1111',LCBADDR1      GET OFFSET OF FIRST INPUT FIELD
         BZ    *+10    >======+         SKIP IF NOT SUPPLIED
         AR    R0,R4          ×         RELOCATE
         ST    R0,LCBADDR1    V         SAVE UPDATED ADDRESS
         ICM   R0,B'1111',LCBADDR2      GET OFFSET OF SECOND INPUT FLD
         BZ    *+10    >======+         SKIP IF NOT SUPPLIED
         AR    R0,R4          ×         RELOCATE
         ST    R0,LCBADDR2    V         SAVE UPDATED ADDRESS
         DROPX R1                       LCBUFF
DY$NAUPD LA    R4,1(R5,R4)              -> NEXT LINE LOC
         ST    R4,QDNEXT                SAVE FOR NEXT TIME
         SH    R5,QDATRNUM              ADJUST BACK TO LINELEN-1
         XC    QDATRNUM,QDATRNUM        NOW NO ATTR BYTES IN LINE
         TM    QFLAG1,Q1MVHDR           "MOVE HEADER" REQUESTED?
         BNO   QSTOP                    NO - SO DON'T
         L     R1,QVHLINE               -> WHERE IT GOES
         BCTR  R5,0                     END OF THIS LINE HAS ATTR BYTE
         EX    R5,DY$MVHDR              MOVE IT TO SCREEN BUFFER
         NI    QFLAG1,255-Q1MVHDR       RESET FLAG
         B     QSTOP                    RETURN TO CALLER
DY$SCMVC MVC   0(*-*,R4),0(R15)         << EXECUTED >>
DY$ADD   MVC   0(*-*,R4),QDMSG          << EXECUTED >>
DY$MVHDR MVC   0(*-*,R1),QDHLINE        << EXECUTED >>
***********************************************************************
*                                                                     *
*   WRITE A FULL SCREEN, WAIT FOR REPLY                               *
*                                                                     *
***********************************************************************
DY$FULL  LA    R15,QDTOP-8-7            -> AREA-LINELEN FOR ' *MORE'
         AH    R15,QDCOLS               -> AREA FOR ' *MORE*'
         MVC   0(7,R15),=C' *MORE*'     INDICATE SCREEN OVERFLOW
         SPACE 2
DY$WRITE TM    QFLAG1,Q1MVHDR           "MOVE HEADER" REQUESTED?
         BNO   DY$NMVHD                 NO - SKIP
         L     R1,QVHLINE               -> WHERE IT GOES
         LH    R14,QDCOLS               GET LINE LENGTH
         BCTR  R14,0                    -1 FOR ATTR BYTE AT END OF LINE
         BCTR  R14,0                    -1 FOR EX
         EX    R14,DY$MVHDR             MVC 0(*-*,R1),QDHLINE
         NI    QFLAG1,255-Q1MVHDR       RESET FLAG
         SPACE 1
DY$NMVHD CLI   QDHLINE,C'*'             ERROR MESSAGE?
         BNE   DY$NALRM                 NO - SKIP
         TM    QMODE1,QM1BEEP           WANT NOISE?
         BNO   DY$NALRM                 NO - SKIP
         OI    QDWCC,X'04'              YES - SET "ALARM"
         SPACE 1
DY$NALRM TM    QSCFLAG1,QSC1JOB         NEED JOBID ON TOP LINE?
         BNO   DY$NOJOB                 NO - SKIP
         MVI   QDTOP,C' '
         MVC   QDTOP+1(L'QDHJOBID+1),QDHJOBID  'JOBNAMEX(JOBNNNNN) '
         SPACE 1
DY$NOJOB TM    QSCFLAG1,QSC1PMPT        PROMPT WITH LAST INPUT COMMAND?
         BNO   DY$NPMPT                 NO - SKIP
         NI    QSCFLAG1,255-QSC1PMPT    YES - RESET FLAG
         L     R1,QVINPUT               -> INPUT AREA ON SCREEN
         MVC   0(QDREPLYL,R1),QDPROMPT  MOVE IN LAST COMMAND
         SPACE 1
DY$NPMPT TM    QTERMFLG,QTFTTY          IS TERMINAL A VIDEO?
         BO    DY$TTY                   NO - USE ALTERNATE ROUTINE
*--- SEE IF RA OR SBA SUFFIX ALREADY EXISTS IN BUFFER              ---*
         L     R1,QDENDPTR              -> PAST POSSIBLE IC AT END
         LR    R0,R1                    COPY PTR
         SH    R1,=H'4'                 BACK UP TO START OF SBA/IC SEQ
         LTR   R0,R0                    ANY?
         BNZ   DY$TPUT                  YES - ALL SET
         L     R15,QDNEXT               -> NEXT OUTPUT LOC
         CLC   QDLINECT,QDROWS          SCREEN FULL?
         BNE   DY$BSCAN                 NO - BACKSCAN FOR BLANKS
*--- LAST LINE OF SCREEN HAS DATA ON IT -- SEE IF ROOM FOR RA      ---*
         LR    R1,R15                   COPY PTR PAST LAST CHAR
         SH    R15,=H'4'                BACK UP
         CLC   0(4,R15),QBLANK          LAST 4 CHARS BLANK?
         BNE   DY$TPUT                  NO - LEAVE AS IS
         SPACE 2
*--- BACKSCAN FOR LAST NON-BLANK                                   ---*
DY$BSCAN BCTR  R15,0                    BACK UP TO LAST CHAR USED
         BALR  R14,0                    SET LOOP ADDR
         CLI   0(R15),C' '  <==+        FIND NON-BLANK?
         BNE   *+6     >=======×==+     YES - EXIT LOOP
         BCTR  R15,R14   >=====+  V     NO - KEEP LOOKING
         MVC   1(4,R15),=X'3C404000'    MOVE IN THE RA SEQUENCE
         LA    R1,1+4(,R15)             SKIP OVER IT
         SPACE 2
DY$TPUT  BAL   R8,DY$SETCP              SET SBA/IC SEQUENCE
         ST    R1,QDENDPTR              -> SAVE PTR PAST IC
         SPACE 2
RESHOW   LA    R3,QDSCREEN              LOAD ADDRESS OF SCREEN BUFFER
         L     R2,QDENDPTR              -> LAST BYTE+1 OF STREAM
         SR    R2,R3                    COMPUTE TPUT LENGTH
         B     RESHOW01                 SKIP AROUND
         SPACE 1
RESHOW00 MVC   QD3270OP,QDERASE         SET WRITE OP TO ERASE WRITE
         TM    QTERMFLG,QTFVTAM         BUT IS IT A VTAM TERMINAL?
         BO    RESHOW01                 YES - ERASE WRITE IS OK
         MVI   QD3270OP,X'F1'           NO - TCAM REQUIRES NORMAL ...
*                                       ... WRITE TO KEEP BMD'S ...
*                                       ... ZAPPED TCAM FROM PUKING.
*---  IF ACF/TCAM SUPPORTS LARGER SCREEN SIZES, THE CODE ABOVE     ---*
*---  WILL PROBABLY NEED TO BE DISABLED.  I DON'T KNOW ANYTHING    ---*
*---  ABOUT ACF/TCAM...                                            ---*
RESHOW01 L     R1,QVINPUT               -> FIRST CHAR (BXH STOP ADDR)
         LA    R15,QDREPLYL-1(,R1)      -> END OF REPLY INPUT AREA
         SR    R0,R0                    BXH ...
         BCTR  R0,0                     ... DECREMENT
         SPACE 1
RESHOW02 CLI   0(R15),C' '              FIND END?
         BNE   RESHOW03                 YES - DISPLAY THE RESULT
         MVI   0(R15),X'00'             CHANGE TRAILING BLANK TO NULL
         BXH   R15,R0,RESHOW02          BACKSCAN THE WHOLE THING
         SPACE 1
RESHOW03 TM    QFLAG2,Q2SHORT           SHORT WRITE REQUESTED?
         BNO   TPUTFULL                 NO - GO DO FULL WRITE
         NI    QFLAG2,255-Q2SHORT       RESET FLAG
         MVC   DY@TEMP(256),QDSCREEN    COPY ENOUGH OF THE SCREEN...
         MVC   DY@TEMP+256(256),QDSCREEN+256  ...TO INSURE THAT WE ...
*                                          ... HAVE THE FIRST 3 LINES
         L     R1,QVLINE1               -> FIRST DATA LINE IN REAL BUFF
         SR    R1,R3                    COMPUTE OFFSET OF 1ST DATA LINE
         LA    R0,DY@TEMP               -> TPUT BUFFER FOR SHORT WRITE
         AR    R1,R0                    OFFSET OF 1ST DATA LINE IN ...
*                                       ... BUFFER FOR SHORT WRITE
         SH    R1,=H'2'                 BACK UP OVER TRAILING ATTR BYTE
         OC    DY@CURS,DY@CURS          ANY CURSOR POSITION SPECIFIED?
         BNZ   RESHOW04                 YES - USE IT
         LH    R14,QDCOLNOW             NO - PUT IT ON COL 14 OF LINE 2
         LA    R14,14-1(,R14)           ... USING LINE LENGTH OF LAST
         STH   R14,DY@CURS              ... SCREEN WRITTEN
         SPACE 1
RESHOW04 BAL   R8,DY$SETCP              SET SBA/IC SEQUENCE
         SR    R1,R0                    COMPUTE SHORT TPUT LENGTH
         LR    R15,R1                   MOVE LENGTH TO TEMP REG
         LR    R1,R0                    MOVE ADDR TO CORRECT REG
         LR    R0,R15                   MOVE LENGTH TO CORRECT REG
         B     TPUT$NOW                 GO DO IT
         SPACE 2
TPUTFULL LR    R1,R3                    GET THE ADDRESS
         LR    R0,R2                    GET THE LENGTH
         SPACE 2
TPUT$NOW ICM   R1,B'1000',=X'03'        GET FULLSCR FLAG
         TPUT  (1),(0),R                WRITE SCREEN
         MVI   QD3270OP,X'F1'           SET WRITE OPCODE TO STD WRITE
         MVC   QDCOLNOW,QDCOLS          SHOW CURRENT SCREEN LINE LENGTH
         LA    R14,DY@INPUT             -> INPUT BUFFER
         LA    R15,L'DY@INPUT           LENGTH
         L     R1,=X'40000000'          GET SOURCE LENGTH, PAD CHAR
         MVCL  R14,R0                   FILL INPUT BUFFER WITH BLANKS
         MVC   QDREPLY,QBLANK
         MVC   QERRMSG,QBLANK
         LA    R1,DY@INPUT              LOAD ADDRESS OF REPLY AREA
         LA    R0,L'DY@INPUT            LENGTH OF INPUT BUFFER
         SPACE 1
         TGET  (1),(0),ASIS             WAIT FOR REPLY
         CLI   DY@AID,X'6B'             PA3? (TCAM10 RESHOW)
         BNE   *+8                      NO - SKIP
         MVI   DY@AID,X'6E'             YES - CHANGE TO VTAM RESHOW
         LR    R4,R1                    SAVE THE INPUT LENGTH
         CH    R15,=H'8'                ATTN?
         BE    RESHOW00                 YES
         CLI   DY@AID,X'6E'             PA2? (RESHOW)
         BE    DY$TCLRQ                 YES - GO FLUSH REST OF INPUT
         SPACE 1
TGET$CHK NI    QDWCC,255-X'04'          RESET "ALARM"
         CH    R15,=H'12'               INPUT LONGER THAN BUFFER?
         BNE   DY$NOCLR                 NO. CONTINUE.
         SPACE 1
DY$TCLRQ TCLEARQ INPUT                  CLEAR THE QUEUE
         SPACE 1
         CLI   DY@AID,X'6E'             PA2? (RESHOW)
         BE    RESHOW00                 YES - RE-DISPLAY LAST SCREEN
         SPACE 2
DY$NOCLR OI    QFLAG2,Q2NEWSCR          INDICATE NEXT OUTPUT LINE IS 1
         L     R1,QVINPUT               -> INPUT AREA ON SCREEN
         XC    0(QDREPLYL,R1),0(R1)     CLEAR IT
         LA    R15,DY@INPUT(R4)         -> PAST LAST INPUT CHAR
         MVI   0(R15),X'11'             PUT IN PHONY ENDING TO STOP TRT
         CLI   DY@INPUT+3,X'11'         DOES INPUT START WITH SBA?
         BNE   DY$ERROR                 NO - SCREEN FORMAT ERROR
         XC    DY@TRTAB,DY@TRTAB        CLEAR TRTAB
         MVI   DY@TRTAB+X'11',4         SET TO STOP ON SBA
         MVC   DY@PCMD,QBLANK           NO PRIMARY COMMAND YET
         XC    DY@PCLEN,DY@PCLEN        ...
         LA    R3,DY@INPUT+3+1          -> FIRST TEXT CHARACTER
         SH    R4,=H'3'                 ACCOUNT FOR AID, CURPOS
         BNP   DY$PC$GO                 NO INPUT
*---  FIXED LENGTH TRT IS OK BECAUSE NO INPUT FIELD IS LONGER THAN ---*
*---  QDREPLY (66), AND WE WILL HIT THE EXTRA SBA PREVIOUSLY SET   ---*
*---  DOWN.                                                        ---*
         SR    R1,R1                    CLEAR FOR IC
DY$FLOOP TRT   2(80,R3),DY@TRTAB        FIND AN SBA
         BZ    DY$ERROR                 NONE???
         MVC   DY@FIELD,QBLANK          CLEAR WORK FIELD
         SR    R1,R3                    COMPUTE FIELD LENGTH
         SH    R1,=H'3'                 -1 FOR EX, -2 FOR LOC
         BM    *+8
         EX    R1,DY$FMVC               MOVE TO DY@FIELD
*---  LEFT JUSTIFY THE DATA IN DY@FIELD                            ---*
         CLC   DY@FIELD,QBLANK          ANYTHING HERE AT ALL?
         BE    DY$FNONE                 NO - SKIP
DY$FLEFT CLI   DY@FIELD,C' '            LEFT JUSTIFIED?
         BNE   DY$FNONE                 YES - CONTINUE
         MVC   DY@FIELD(L'DY@FIELD-1),DY@FIELD+1   NO - SHIFT IT OVER
         MVI   DY@FIELD+L'DY@FIELD-1,C' '  CLEAR THE OPENED UP HOLE
         B     DY$FLEFT                 KEEP SHIFTING
         SPACE 1
DY$FNONE LA    R1,1(,R1)                GET FIELD LENGTH
         NC    0(2,R3),=X'3F3F'         MAKE TWO 6-BIT BYTES
         SR    R14,R14                  CLEAR FOR IC
         IC    R14,0(,R3)               GET HIGH ORDER 6 BITS OF ADDR
         SLL   R14,6                    ADJUST
         SR    R15,R15                  CLEAR FOR IC
         IC    R15,1(,R3)               GET LOW ORDER 6 BITS OF ADDR
         OR    R15,R14                  GET FIELD LOCATION
         SR    R14,R14                  CLEAR FOR DIVIDE
         LH    R0,QDCOLS                GET LINE LENGTH
         DR    R14,R0                   COMPUTE LINE NUMBER
         CH    R15,=H'1'                SECOND SCREEN LINE?
*%%%     BNE   DY$FSEL                  NO - MUST BE A SELECT LINE
         BH    DY$FSEL                  NO - MUST BE A SELECT LINE
         STH   R1,DY@PCLEN              SAVE LENGTH OF PRIMARY COMMAND
         MVC   DY@PCMD,DY@FIELD         SAVE PRIMARY COMMAND
         SPACE 2
DY$FNEXT LA    R3,3(R1,R3)              -> PAST SBA OF NEXT FIELD
         SR    R4,R1                    COMPUTE...
         SH    R4,=H'3'                 ... REMAINING LENGTH
         BP    DY$FLOOP                 PROCESS IT
         SPACE 2
*---  SEE IF ANY LINE COMMANDS PRESENT                             ---*
         L     R2,QVLCBUF               -> LINE COMMAND BUFFER
         LA    R0,43-3                  NUMBER OF ARRAY ELEMENTS
         USNGX LCBUFF,R2
DY$LC$L1 CLI   LCBFLD1,C' '             ANYTHING HERE?
         BH    DY$LC$EX                 YES - GO CHECK IT
         LA    R2,LCBELEN(,R2)          -> NEXT BUFFER ARRAY ELEMENT
         BCT   R0,DY$LC$L1              KEEP LOOKING
*---  NO LINE COMMANDS ENTERED - EXECUTE PRIMARY COMMAND, IF ANY   ---*
         MVC   QDREPLY,DY@PCMD          NO - GET PRIMARY LINE CMD
         MVC   QDRLNG,DY@PCLEN          ... AND ITS LENGTH
         B     DY$PC$GO                 GO EXECUTE IT
         SPACE 1
         DROPX R2                       LCBUFF
         SPACE 1
DY$FMVC  MVC   DY@FIELD(*-*),2(R3)      << EXECUTED >>
         SPACE 3
*---  STORE LINE COMMANDS                                          ---*
DY$FSEL  LR    R0,R15                   COPY LINE NUMBER
         SH    R15,=H'3'                ADJUST - FIRST IS ON LINE 4
*                                       (R15 WAS ORIGIN 0)
         BM    DY$ERR2                  LOGIC ERROR
         MH    R15,=Y(LCBELEN)          OFFSET OF LINE CMD TABLE ENTRY
         AL    R15,QVLCBUF              -> CORRECT ARRAY ELEMENT
         USNGX LCBUFF,R15
         CH    R14,=H'1'                FIELD AT LEFT SIDE OF SCREEN?
         BE    DY$FCMD                  YES - MUST BE SUBCOMMAND NAME
         MVC   LCBFLD2,DY@FIELD         SET OPERAND IN LINE CMD TABLE
         OC    LCBFLD2,QBLANK           MAKE IT UPPER CASE
         ICM   R14,B'1111',LCBADDR2     GET OPERAND LOC IN SCREEN BUFF
         BZ    DY$FNEXT                 SKIP IF NOT SUPPLIED
         MVC   0(8,R14),DY@FIELD        OPRND TO SCREEN IN CASE RESHOW
         B     DY$FNEXT                 PROCESS NEXT INPUT FIELD
         SPACE 1
DY$FCMD  XC    LCBTPTR,LCBTPTR          CLEAR CMD TABLE ENTRY POINTER
         MVC   LCBFLD1,DY@FIELD         SET CMDNAME IN LINE CMD TABLE
         OC    LCBFLD1,QBLANK           MAKE IT UPPER CASE
         ICM   R14,B'1111',LCBADDR1     GET CMDNAME LOC IN SCREEN BUFF
         BZ    DY$FNEXT                 SKIP IF NOT SUPPLIED
         MVC   0(2,R14),DY@FIELD        CMD TO SCREEN IN CASE RESHOW
         B     DY$FNEXT                 PROCESS NEXT FIELD
         SPACE 1
         DROPX R15                      LCBUFF
         SPACE 2
DY$ERR2  L     R0,=C'DY2 '              SET LOGIC ERROR CODE
         L     R15,=V(LOGICERR)         -> ROUTINE
         BALR  R14,R15                  GO TO IT (NO RETURN)
         SPACE 2
DY$ERR3  L     R0,=C'DY3 '              SET LOGIC ERROR CODE
         L     R15,=V(LOGICERR)         -> ROUTINE
         BALR  R14,R15                  GO TO IT (NO RETURN)
         SPACE 3
*---  CHECK FOR PROBLEMS WITH LINE COMMANDS                        ---*
         USNGX LCBUFF,R2
DY$LC$EX OC    DY@PCLEN,DY@PCLEN        ANY PRIMARY COMMAND ENTERED?
         BNZ   DY$LC$E1                 YES - GENERATE ERROR MSG
         NI    DY@FLAG,255-DY@DCMD      NO DESTRUCTIVE CMD FOUND YET
*---  FIND THE LINE COMMAND TABLE ENTRY                            ---*
DY$LC$CK CLI   LCBFLD1,C' '             ANYTHING HERE?
         BNH   DY$LC$L3                 NO - SKIP THIS ENTRY
         L     R1,QDLCTBL               -> LINE CMD TABLE
         LTR   R1,R1                    ANY?
         BZ    DY$ERR3                  NO - ERROR
         SPACE 1
         USNGX LCTABLE,R1
DY$LC$L2 CLC   LCBFLD1,LCTCMDNM         THIS IT?
         BE    DY$LCGOT                 YES
         LA    R1,LCTELEN(,R1)          -> NEXT TABLE ENTRY
         CLI   0(R1),X'FF'              END OF TABLE?
         BNE   DY$LC$L2                 NO - KEEP LOOKING
         SPACE 1
*---  LINE COMMAND IS INVALID                                      ---*
DY$INVLC MVC   QDHLINE,QBLANK           CLEAR ERROR MSG AREA
         MVC   QDHLINE(33),=C'*** LINE COMMAND "XX" INVALID ***'
         MVC   QDHLINE+18(2),LCBFLD1    FILL IN BAD COMMAND NAME
         SPACE 1
*---  LINE COMMAND ERROR - SET CURSOR POSITION                     ---*
DY$LC$ER LA    R14,43                   COMPUTE LINE NUMBER ...
         SR    R14,R0                   ... OF BAD COMMAND
         MH    R14,QDCOLS               MAKE IT SCREEN POSITION
         LA    R14,1(,R14)              MAKE IT COLUMN 2
         STH   R14,DY@CURS              SAVE FOR COMPUTE
         OI    QFLAG1,Q1MVHDR           REQUEST "MOVE HEADER"
         B     DY$WRITE                 GO RE-WRITE THE SCREEN
         SPACE 1
DY$LCGOT TM    LCTFLAGS,LCTFPRIV        PRIV CMD?
         BNO   *+12     >========+      NO - OK
         TM    QXAUTH,QXAUTHX    ×      PRIV USER?
         BZ    DY$INVLC          ×      NO - SAY INVALID COMMAND
         ST    R1,LCBTPTR   <====+      SAVE IN LINE CMD BUFFER
         TM    LCTFLAGS,LCTFDCMD        IS THIS A DESTRUCTIVE COMMAND?
         BNO   DY$LC$L3                 NO - SKIP
         TM    DY@FLAG,DY@DCMD          ALREADY HIT DESTRUCTIVE CMD?
         BO    DY$LC$E2                 YES - CONFLICT
         OI    DY@FLAG,DY@DCMD          REMEMBER DESTRUCTIVE CMD FOUND
DY$LC$L3 LA    R2,LCBELEN(,R2)          -> NEXT BUFFER ARRAY ELEMENT
         BCT   R0,DY$LC$CK              CHECK ALL ELEMENTS
         SPACE 2
*---  RETURN TO MAINLINE TO EXECUTE LINE COMMANDS                  ---*
         L     R13,QFRSTSA              GO BACK TO MAIN MODULE
         LM    R14,R12,12(R13)          RESTORE REGS FROM 1ST SAVEAREA
         BR    R10                      -> INTERRUPT HANDLER IN QUEUE
         SPACE 1
         DROPX R2,R1                    LCBUFF, LCTABLE
         SPACE 3
DY$LC$E1 MVC   QDHLINE,QBLANK           CLEAR ERROR MSG AREA
         MVC   QDHLINE(56),=C'*** PRIMARY AND LINE COMMANDS ARE MUTUALL$
               Y EXCLUSIVE ***'
         OI    QFLAG1,Q1MVHDR           REQUEST "MOVE HEADER"
         B     DY$WRITE                 GO RE-WRITE THE SCREEN
         SPACE 2
DY$LC$E2 MVC   QDHLINE,QBLANK           CLEAR ERROR MSG AREA
         MVC   QDHLINE(29),=C'*** LINE COMMAND CONFLICT ***'
         B     DY$LC$ER                 GO SET UP FOR RE-WRITE
         SPACE 3
*  REGISTER USAGE:
*    R6 -> NEXT LOC IN QDREPLY
*    R5  - LENGTH CURRENTLY IN QDREPLY
*    R4  - LENGTH REMAINING IN INPUT STREAM
*    R1  - LOW NIBBLE OF AID
DY$PC$GO LH    R4,DY@PCLEN              GET LENGTH OF PRIMARY COMMAND
         LA    R6,QDREPLY               %%%
         XR    R5,R5                    INITIAL "LENGTH IN QDREPLY"
         LA    R15,QDREPLYL-1           GET LENGTH TO MOVE (EX LEN)
         IC    R1,DY@AID                GET AID
         N     R1,=X'0000000F'          EXTRACT PF-KEY NUMBER
         CH    R1,=H'12'
         BH    DY$ENTER                 "ENTER" KEY
         TM    QMODE1,QM1PFK24          24 UNIQUE PFKEYS IN USE?
         BNO   DY$PFK12                 NO - KEEP AS 1-12
         TM    DY@AID,B'00110000'       1-12 OR 13-24???
         BO    DY$PFK12                 1-12, OK AS IS
         LA    R1,12(,R1)               ADJUST FOR 13-24
DY$PFK12 CH    R1,=H'4'                 PF4/16 (PRINT = SPF RETURN)
         BNE   DY$NOTK4                 NO - CONTINUE
         CLI   DY@PCMD,C'='             DOES HE THINK HE'S IN SPF?
         BE    DY$ENTER                 YES - DON'T COMPOUND CONFUSION
DY$NOTK4 BCTR  R1,0                     ADJUST ORIGIN
         SLL   R1,6                     MULTIPLY BY 64
         A     R1,QVPFKEYS              -> THIS PFK COMMAND
         MVC   QDREPLY(64),0(R1)        MOVE PF-KEY VALUE
         LA    R5,64                    LENGTH NOW IN QDREPLY
         LA    R6,QDREPLY+3             SKIP OVER PF KEY COMMAND
         SH    R15,=H'3'                ADJUST LENGTH LEFT TO MOVE
*Y$ENTER SH    R4,=H'3' %%%             ADJUST REMAINING INPUT LENGTH
DY$ENTER LTR   R4,R4    %%%             ANY INPUT REMAINING?
         NOPR  0        %%%
         BZ    DY$NOTXT                 SKIP IF NO OPERAND TO PFKEY
         EX    R15,DY$TXMVC             MVC 0(*-*,R6),DY@PCMD
         OC    DY@PCMD,QBLANK           TURN ALL HEX ZEROES TO BLANKS
         CLC   DY@PCMD,QBLANK           ANYTHING BESIDES NULLS & BLNKS?
         BNE   DY$3TEXT                 YES - PROCESS
         SR    R4,R4                    NOTHING CURRENTLY IN QDREPLY
         B     DY$NOTXT                 CONTINUE
         SPACE 2
DY$3TEXT LA    R5,3                     LNTH IN QDREPLY BEFORE NEW TEXT
         SPACE 1
DY$NOTXT LA    R4,0(R5,R4)              COMPUTE LENGTH IN QDREPLY
         STH   R4,QDRLNG                STORE LENGTH OF REPLY
         LTR   R4,R4                    RESPONSE FROM USER?
         BNZ   DY$INTER                 YES. INTERRUPT PROCESSING.
         MVI   QDOVER,1                 INDICATE PAGE OVERFLOW
         BAL   R8,DY$SETTL              CLEAR THE SCREEN BUFFER
         TM    DY@FLAG,DY@IMM           WAS REQUEST FOR IMMED WRITE?
         BO    QSTOP                    YES - ALL DONE
         OI    QFLAG1,Q1MVHDR           REQUEST "MOVE HEADER"
         B     DY$ADD02                 NO - MOVE SAVED LINE TO SCREEN
         SPACE 2
DY$ERROR LA    R1,=C'*** SCREEN FORMAT ERROR ***'
         LA    R0,27                    MSG LENGTH
         SPACE 1
         TPUT  (1),(0),R
         B     RESHOW                   WRITE WHOLE SCREEN AGAIN
         SPACE 2
DY$INTER L     R8,QVSAVE                -> MY SAVE AREA
         MVC   0(QSAVE1L,R8),QSAVE1     MOVE FIRST PART
         MVC   QSAVE1L(QSAVE2L,R8),QSAVE2    SECOND PART
         IC    R5,DY@AID                SAVE AID
         QCALL PARSE                    PARSE THE INPUT
         CLM   R5,B'0001',=X'7D'        ENTER?
         BNE   DY$NOT7D                 NO - DON'T SAVE CMD IN RING BUF
         L     R15,QSUBCMD              GET SUBCOMMAND EPA
         CL    R15,=A(RECALL)           "RECALL" REQUEST?
         BE    DY$NOT7D                 YES - NEVER SAVE IN RING BUFFER
         LH    R14,QCMDNUM              GET CURRENT COMMAND NUMBER
         LA    R14,1(,R14)              INCREMENT
         STH   R14,QCMDNUM              SAVE UPDATED NUMBER
         STH   R14,QRETNUM              SET NUMBER OF COMMAND TO RECALL
         N     R14,=F'15'               COMPUTE NUMBER MODULE(16)
         MH    R14,=Y(QDREPLYL)         GET OFFSET INTO RING BUFFER
         AL    R14,QVRING               -> CURRENT SLOT IN RING
         MVC   0(QDREPLYL,R14),QDREPLY  SAVE CURRENT COMMAND IN RING
DY$NOT7D TM    QFLAG1,Q1IMMED           IMMEDIATE COMMAND?
         BO    DY$IMMED                 YES - GO EXECUTE IT
         SPACE 2
*---  A NEW PRIMARY COMMAND HAS BEEN ENTERED - CLEAR ALL LINE CMDS ---*
DY$ARRGH XC    QDLCTBL,QDLCTBL          NO LINE COMMANDS VALID NOW
         L     R15,QVLCBUF              -> LINE CMD BUFFER
         USNGX LCBUFF,R15
         LA    R0,43-3                  NUMBER OF ENTRIES TO CLEAR
DY$ARG01 XC    0(LCBELEN,R15),0(R15)    CLEAR AN ENTRY
         MVI   LCBTPTR,X'80'            INDICATE NOTHING HERE
         LA    R15,LCBELEN(,R15)        -> NEXT ENTRY
         BCT   R0,DY$ARG01              CLEAR ALL ENTRIES
         DROPX R15
         MVC   QDPROMPT,QDREPLY         SAVE REPLY IN CASE REPROMPT
         L     R13,QFRSTSA              GO BACK TO MAIN MODULE
         LM    R14,R12,12(R13)          RESTORE REGS FROM 1ST SAVEAREA
         BR    R10                      -> INTERRUPT HANDLER IN QUEUE
         SPACE 2
DY$IMMED L     R15,QSUBCMD              GET SUBCOMMAND EPA
         CL    R15,=A(RECALL)           "RECALL" REQUEST?
         BE    RECALL                   YES - GO THERE
         QCALL (R15)                    INVOKE IMMEDIATE SUBCOMMAND
         TM    QFLAG1,Q1IMMED           DID SUBCMD RESET "IMMEDIATE"?
         BNO   DY$ARRGH                 YES - LET MAINLINE RE-INVOKE IT
         TM    QFLAG2,Q2REPOS           REPOSITIONING SUBCOMMAND?
         MVC   QSAVE1(QSAVE1L),0(R8)    RESTORE FIRST PART
         MVC   QSAVE2(QSAVE2L),QSAVE1L(R8)      SECOND PART
         BO    DY$REPOS                 YES (REPOSITIONING SUBCOMMAND)
         TM    QTERMFLG,QTFTTY          DISPLAY TERMINAL?
         BNO   RESHOW                   YES - DISPLAY SCREEN AGAIN
         B     DYTTYTG                  NO - GO BACK TO TTY INPUT
         SPACE 2
DY$REPOS TM    QFLAG2,Q2LISTDS          ARE WE IN LISTDS?
         BO    DY$LSTDS                 YES - OK
         L     R0,=C'DY4 '              SET LOGIC ERROR CODE
         L     R15,=V(LOGICERR)         -> ROUTINE
         BALR  R14,R15                  GO TO IT (NO RETURN)
         SPACE 1
*---  SIMULATE AN "RD" COMMAND (SORT OF)                           ---*
DY$LSTDS MVC   QSUBCMD,=V(LISTDS)       FAKE THE SUBCOMMAND ADDRESS
         MVI   QCODE,99                 INDICATE REPOSITIONING
         L     R13,QFRSTSA              GO BACK TO MAIN MODULE
         LM    R14,R12,12(R13)          RESTORE REGS FROM 1ST SAVEAREA
         BR    R10                      -> INTERRUPT HANDLER IN QUEUE
         SPACE 2
         ENTRY RECALL
*ECALL   LA    R1,QDPROMPT              ASSUME REGULAR RECALL REQUEST
RECALL   CLI   QKEYWORD,C' '            RECALL LAST?
         BE    RECALL$1                 RIGHT - OK
         CLI   QKEYWORD+16,C' '         A SECOND KEYWORD?
         BNE   RECALLNO                 YES - NO GOOD
         LA    R1,QFINDCMD              ASSUME RECALL LAST FIND CMD
         CLI   QKEYWORD,C'F'            RECALL LAST FIND COMMAND?
         BE    RECALLGO                 YES
         LA    R1,QTSOCMD               ASSUME RECALL LAST TSO CMD
         CLI   QKEYWORD,C'T'            RECALL LAST TSO COMMAND?
         BE    RECALLGO                 YES
         LA    R1,QINQCMD               ASSUME RECALL LAST INQUIRY
         CLI   QKEYWORD,C'I'            RECALL LAST INQUIRY COMMAND?
         BE    RECALLGO                 YES
         LA    R1,QMVSCMD               ANYTHING ELSE MUST BE MVS
         B     RECALLGO                 CONTINUE
         SPACE 1
RECALL$1 LH    R1,QRETNUM               GET COMMAND NUMBER TO RECALL
         LR    R0,R1                    COPY FOR ADJUSTMENT
         SH    R0,=H'1'                 BACK UP FOR NEXT RECALL
         BNM   *+8                      SKIP IF NOT BACK TO START
         LH    R0,QCMDNUM               ELSE RESET BACK TO TOP
         STH   R0,QRETNUM               SAVE NBR OF NEXT CMD TO RECALL
         N     R1,=F'15'                COMPUTE NUMBER MODULE(16)
         MH    R1,=Y(QDREPLYL)          GET OFFSET INTO RING
         AL    R1,QVRING                -> COMMAND TO RECALL
         SPACE 1
RECALLGO MVC   QSAVE1(QSAVE1L),0(R8)    RESTORE FIRST PART
         MVC   QSAVE2(QSAVE2L),QSAVE1L(R8)      SECOND PART
         OI    QFLAG2,Q2SHORT           INDICATE SHORT WRITE
         TM    QTERMFLG,QTFTTY          DISPLAY TERMINAL?
         BO    DY$TTYPM                 NO - ALTERNATE ROUTINE
         L     R14,QVINPUT              -> INPUT AREA ON SCREEN
         MVC   0(QDREPLYL,R14),0(R1)    COPY LAST COMMAND
         B     RESHOW                   RE-DISPLAY SCREEN
         SPACE 1
RECALLNO MVC   QDHLINE,QBLANK           CLEAR ERROR MSG AREA
         MVC   QDHLINE(27),=C'*** CONFLICTING OPTIONS ***'
         SPACE 1
DY$TILT  L     R1,QVINPUT               -> INPUT AREA ON SCREEN
         MVC   0(QDREPLYL,R1),QDREPLY   MOVE IN LAST COMMAND
         OI    QFLAG1,Q1MVHDR           REQUEST "MOVE HEADER"
         B     DY$WRITE                 FAKE QTILT
         SPACE 3
*---  SUBROUTINE TO REBUILD TOP SCREEN LINE                        ---*
DY$SETTL LH    R15,QDCOLS               GET SCREEN WIDTH
         SH    R15,=H'9'                ADJUST FOR ' QUEUE -' & EXECUTE
         EX    R15,DY$MVTOP             RESET TOP LINE TO DASHES
         BR    R8                       RETURN TO CALLER
DY$MVTOP MVC   QDTOP(*-*),QDTOP-1       << EXECUTED >>
         SPACE 3
*---  SUBROUTINE TO GENERATE 3270 CURSOR POSITION SEQUENCE         ---*
DY$SETCP MVC   0(4,R1),=X'11000013'     PUT IN SBA/IC SEQUENCE
         LH    R14,DY@CURS              GET CURSOR POSITION
         XC    DY@CURS,DY@CURS          SET TO DEFAULT NEXT TIME
         LTR   R14,R14                  ANY?
         BNZ   *+12     >=======+       YES - OK
         LA    R14,14-1         ×       NO - USE COL 14 ...
         AH    R14,QDCOLS       ×       ... ON LINE 2
         SRDL  R14,6     <======+       GET LOW ORDER SIX BITS IN R15
         SRL   R15,32-6                 SHIFT TO LOW END OF REGISTER
         STC   R14,1(,R1)               SET DOWN HI ORDER 6 BITS
         STC   R15,2(,R1)               SET DOWN LO ORDER 6 BITS
         TR    1(2,R1),DY#T3270         TRANSLATE TO VALID 3270 CHARS
         LA    R1,4(,R1)                BUMP OUTPUT POINTER
         BR    R8                       RETURN TO CALLER
         SPACE 3
***********************************************************************
*                                                                     *
*   ROUTINE TO HANDLE TERMINAL I/O FOR NON-VIDEO DISPLAY TERMINALS    *
*                                                                     *
***********************************************************************
DY$TTY   TM    QDWCC,X'04'              ALARM?
         BNO   DY$TTY$2                 NO - SKIP
         LA    R1,=X'2F'                YES - GET VALUE FOR "BELL"
         LA    R0,1                     LENGTH
         ICM   R1,B'1000',=X'02'        SET "CONTROL"
         TPUT  (1),(0),R                RING HIS CHIMES
         SPACE 1
DY$TTY$2 L     R1,QVHLINE               -> HEADER LINE
         LH    R0,QDCOLS                LENGTH + 1
         BCTR  R0,0                     LENGTH
         TPUT  (1),(0),R
         TM    QMISCFLG,QMFATTN         ATTN PRESSED?
         BO    DYTTYTG                  YES - GO DIRECTLY TO TGET
         L     R6,QVLINE1               -> FIRST DATA LINE
         LH    R7,QDCOLS                LENGTH
         LH    R3,QDROWS                NUMBER
         LR    R5,R7                    COPY LINE LENGTH
         BCTR  R5,0                     GET EX LENGTH
         XC    DY@TRTAB,DY@TRTAB        INIT TRT TABLE TO ...
         MVI   DY@TRTAB+X'1D',4         ... STOP ON "START FIELD"
         MVI   DY@TRTAB+X'3C',8         ... AND "REPEAT TO ADDR"
         SPACE 2
DY$TTYLP EX    R5,DYTTYMVC              MOVE DATA TO OUR BUFFER
         LA    R15,0(R5,R6)             -> END OF LINE
         LR    R14,R5                   LENGTH TO TRT
         LA    R1,DY@LINE               -> START OF LINE
         MVI   TTY@BYTE,C' '            ASSUME WON'T FIND ANYTHING
         SPACE 1
DY$TRTLP EX    R14,DYTTYTRT             LOOK FOR SF OR RA
         BZ    DY$TTYTP                 NONE FOUND - GO PUT THE LINE
         MVC   TTY@BYTE,0(R1)           SAVE FOR END OF SCREEN TESTING
         CLI   0(R1),X'3C'              IS THIS THE TRAILING "RA"?
         BE    DY$TTYRA                 YES - SPECIAL HANDLING
*---  REMOVE THE ATTR BYTE FROM THE LINE                           ---*
         MVI   0(R1),C' '               KILL THE X'1D'
         LA    R1,1(,R1)                SKIP OVER IT
         LA    R14,DY@LINE(R5)          -> LAST CHAR OF LINE
         SR    R14,R1                   EXECUTE LENGTH TO SHIFT OVER
         LA    R15,1(,R15)              ADJUST END OF LINE POINTER
         LA    R6,1(,R6)                ALSO, FIX PTR TO NEXT SCRN LINE
         LR    R2,R15                   COMPUTE ADDRESS OF PART OF LINE
         SR    R2,R14                   ... AFTER THE ATTR BYTE
         EX    R14,DYTTYSHF             SHIFT REMAINDER OF LINE LEFT
         B     DY$TRTLP                 LOOK FOR NEXT ATTR BYTE
         SPACE 1
DYTTYMVC MVC   DY@LINE(*-*),0(R6)       << EXECUTED >>
DYTTYTRT TRT   0(*-*,R1),DY@TRTAB       << EXECUTED >>
DYTTYSHF MVC   0(*-*,R1),0(R2)          << EXECUTED >>
DYTTYCLC CLC   DY@LINE(*-*),QBLANK      << EXECUTED >>
         SPACE 1
*---  THE TRAILING "RA" SEQUENCE HAS BEEN FOUND.  REMOVE IT.       ---*
DY$TTYRA MVC   0(132,R1),QBLANK         CLEAR REST OF PRINT LINE
         SPACE 1
*---  FINALLY, TPUT THE LINE IF IT'S NON-BLANK                     ---*
DY$TTYTP EX    R5,DYTTYCLC              BLANK LINE?
         BE    DY$TTYSK                 YES - SKIP IT
         LA    R1,DY@LINE               -> OUTPUT LINE
         TPUT  (1),(R7)                 PUT OUT THE LINE
DY$TTYSK CLI   TTY@BYTE,X'3C'           END OF SCREEN? (RA)
         BE    DYTTYTG                  YES - ALL DONE WITH SCREEN BUFF
         TM    QMISCFLG,QMFATTN         ATTN PRESSED?
         BO    DYTTYTG                  YES - GO DIRECTLY TO TGET
         AR    R6,R7                    -> NEXT DATA LINE
         BCT   R3,DY$TTYLP              DO THE WHOLE SCREEN
         B     DYTTYTG                  AND REQUEST INPUT
         SPACE 2
DY$TTYPM LA    R0,QDREPLYL              GET LENGTH
         TPUT  (1),(0),R                PUT IT OUT
         B     DYTTYTG                  GET NEXT COMMAND
         SPACE 2
DYTTYTG  NI    QMISCFLG,255-QMFATTN     RESET IN CASE INTERRUPTED OUTPT
         SPACE 1
DYTTYTG2 LA    R1,=C'QUEUE: '
         LA    R0,7
         LA    R15,QDTOP-8-7            -> AREA-LINELEN FOR ' *MORE'
         AH    R15,QDCOLS               -> AREA FOR ' *MORE*'
         CLC   0(7,R15),=C' *MORE*'     IS THERE MORE?
         BNE   *+12                     NO - KEEP IT
         LA    R1,=C'*MORE* QUEUE: '
         LA    R0,14
         ICM   R1,B'1000',=X'01'        SET "ASIS"
         TPUT  (1),(0),R
         SPACE 1
         LA    R1,DY@TEXT               -> INPUT LOC
         LA    R0,QDREPLYL              MAX LENGTH
         ICM   R1,B'1000',=X'80'        SET "TGET"
         TGET  (1),(0),R
         MVC   DY@INPUT(6),=X'7D4040114040'  FAKE OUT 3270 AID, ADDR,
*                                            SBA, ADDR
         LA    R4,6(,R1)                FAKE LENGTH FOR ABOVE
         CH    R15,=H'8'                ATTN?
         BNE   TGET$CHK                 NO - PROCESS INPUT
         B     DYTTYTG2                 YES - READ AGAIN
***********************************************************************
*                                                                     *
*   SUBROUTINE TO BUILD TOP SCREEN LINES IF NECESSARY                 *
*                                                                     *
***********************************************************************
DY$SETOP TM    QTERMFLG,QTFSW2+QTFSW5   NEED TO SWITCH?
         BZR   R8                       NO - JUST RETURN TO CALLER
         BNO   *+8                      YES - CONTINUE
         EX    0,*                      CAN'T USE 'LOGICERR' HERE...
         NI    QTERMFLG,255-QTFSW2-QTFSW5  RESET REQUEST FLAGS
         MVI   QDERASE,X'F5'            ASSUME MOD 2, SET ERASE WRITE
         NI    QTERMFLG,255-QTFNOW5     ASSUME IN MOD 2 MODE
         CLI   QDROWS+1,24-3            MODEL 2?
         BE    *+12    >============+   YES - SKIP
         MVI   QDERASE,X'7E'        ×   NO - USE ERASE WRITE ALTERNATE
         OI    QTERMFLG,QTFNOW5     ×   AND REMEMBER WE ARE MOD 5 MODE
         MVC   QD3270OP,QDERASE  <==+   FORCE ERASE WRITE ON NEXT WRITE
         LA    R14,QDTOP+1-9            -> SECOND SCREEN LINE
         AH    R14,QDCOLS               ...
         MVC   0(14,R14),DY#CMD         'COMMAND ===>' & ATTR
         LA    R14,14(,R14)             -> INPUT AREA
         ST    R14,QVINPUT              SAVE ADDRESS
         XC    0(QDREPLYL,R14),0(R14)   CLEAR IT
         MVC   QDREPLYL(2,R14),=X'1DE8' ATTR - PROT BRIGHT
         MVC   QDREPLYL+2(132-80,R14),QBLANK CLEAR THE REST J.I.C.
         LH    R1,QDCOLS                GET SCREEN WIDTH
         SH    R1,=H'80'                ADJUST FOR MIN WIDTH
         LA    R14,QDREPLYL+2(R1,R14)   -> THIRD LINE (HEADER)
         ST    R14,QVHLINE              SAVE ADDRESS
         AH    R14,QDCOLS               -> FOURTH LINE (SORT OF)
         BCTR  R14,0                    ADJUST FOR ATTRIBUTE BYTE
         MVC   0(2,R14),=X'1D60'        ATTR - PROT NORM
         LA    R14,2(,R14)              -> FIRST DATA LINE
         ST    R14,QVLINE1              SAVE ADDRESS
         ST    R14,QDNEXT               SET ADDRESS OF NEXT DATA LINE
         LA    R0,QDSCREEN              -> START OF SCREEN BUFFER
         SR    R14,R0                   COMPUTE LENGTH OF FIXED AREA
         L     R1,=A(QDSCRLEN)          GET LENGTH OF WHOLE BUFFER
         SR    R1,R14                   COMPUTE LENGTH REMAINING
         ST    R1,QDCLEARL              SAVE LENGTH TO CLEAR
         BR    R8                       RETURN TO CALLER
***********************************************************************
*                                                                     *
*   SUBROUTINE TO SWITCH TO MOD 2 SCREEN SIZE                         *
*                                                                     *
***********************************************************************
DISP80   QSTART  TYPE=ENTRY
         CLI   QDCOLS+1,80              ALREADY CORRECT?
         BE    QSTOP                    YES - SKIP
         MVC   QD3270OP,QDERASE         INSURE ERASE WRITE NEXT
         MVI   QDCOLS+1,80              SET SCREEN WIDTH
         MVI   QDROWS+1,24-3            SET SCREEN LENGTH (USABLE)
         ZAP   QTPAGE,=P'21'            NUMBER OF USABLE ROWS
         ZAP   QTHALF,=P'10'            SAME FOR HALF A SCREEN
         ZAP   QTPAGEX,=P'20'           SAME AS ABOVE IF COLUMN ...
         ZAP   QTHALFX,=P'10'           ... INDICATOR BEING DISPLAYED
         OI    QTERMFLG,QTFSW2          TELL DISPLAY TO REBUILD HEADER
         NI    QTERMFLG,255-QTFSW5      RESET OTHER FLAG
         B     QSTOP                    RETURN TO CALLER
***********************************************************************
*                                                                     *
*   SUBROUTINE TO SWITCH TO MOD 5 SCREEN SIZE                         *
*                                                                     *
***********************************************************************
DISP132  QSTART  TYPE=ENTRY
         TM    QTERMFLG,QTFMOD5         MODEL 5?
         BZ    QSTOP                    NO - DON'T DO ANYTHING
         CLI   QDCOLS+1,132             ALREADY CORRECT?
         BE    QSTOP                    YES - SKIP
         MVC   QD3270OP,QDERASE         INSURE ERASE WRITE NEXT
         MVI   QDCOLS+1,132             SET SCREEN WIDTH
         MVI   QDROWS+1,27-3            SET SCREEN LENGTH (USABLE)
         ZAP   QTPAGE,=P'24'            NUMBER OF USABLE ROWS
         ZAP   QTHALF,=P'12'            SAME FOR HALF A SCREEN
         ZAP   QTPAGEX,=P'23'           SAME AS ABOVE IF COLUMN...
         ZAP   QTHALFX,=P'11'           ... INDICATOR IS DISPLAYED
         OI    QTERMFLG,QTFSW5          TELL DISPLAY TO REBUILD HEADER
         NI    QTERMFLG,255-QTFSW2      RESET OTHER FLAG
         B     QSTOP                    RETURN TO CALLER
***********************************************************************
*                                                                     *
*   MISCELLANY                                                        *
*                                                                     *
***********************************************************************
DY$TXMVC MVC   0(*-*,R6),DY@PCMD        << EXECUTED >>
         SPACE 1
DY#CMD   DC    C'Command ===>'
         DC    X'1DC8'                  ATTR - INPUT, BRIGHT
         SPACE 2
         ENTRY RC#KEYS
RC#KEYS  DC    CL8'F',CL8'FIND'
         DC    CL8'T',CL8'TSO'
         DC    CL8'I',CL8'INQ',CL8'INQUIRY'
*---  ANYTHING NOT ONE OF THE ABOVE WILL BE ASSUMED TO BE 'C'      ---*
         DC    CL8'C',CL8'CMD'          MVS/JES2
         DC    X'FF'                    END OF TABLE INDIC.
         SPACE 2
DY#SCALE DC    C'----+----1----+----2----+----3----+----4----+----5'
         DC    C'----+----6----+----7----+----8----+----9----+---10'
         DC    C'----+---11----+---12----+---13----+---14----+---15'
         DC    C'----+---16----+---17----+---18----+---19----+---20'
         DC    C'----+---21----+---22----+---23----+---24----+---25'
         DC    C'----+---26----+---27----+---28----+---29----+---30'
         DC    C'----+---31----+---32----+---33----+---34----+---35'
         DC    C'----+---36----+---37----+---38----+---39----+---40'
         SPACE 2
DY#T3270 DC    0D'0'
         DC    X'40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F'
         DC    X'50D1D2D3D4D5D6D7D8D95A5B5C5D5E5F'
         DC    X'6061E2E3E4E5E6E7E8E96A6B6C6D6E6F'
         DC    X'F0F1F2F3F4F5F6F7F8F97A7B7C7D7E7F'
         SPACE 2
         LTORG
         SPACE 3
         DROPX R13
         SPACE 3
         QCOMMON
         SPACE 2
WORK     DSECT
         ORG   WORK+72
DY@TPTR  DS    A                        LINE CMD ELEMENT PTR PARM
DY@CURS  DS    H                        RELATIVE CURSOR POSITION
DY@FLAG  DS    B
DY@IMM   EQU   X'80'                    ENTRY IS FOR IMMEDIATE DISPLAY
DY@DCMD  EQU   X'40'                    HIT DESTRUCTIVE BUFFER COMMAND
DY@WORKL EQU   *-WORK
TTY@BYTE DS    C
DY@DWD   DS    0D
DY@TRTAB DS    XL256
DY@TEMP  DS    0CL512                   AREA FOR SHORT WRITES
DY@LINE  DS    CL132                    OUT LINE WORK AREA FOR TTY
         DS    CL150                    SLOP AREA (SEE DY$TTY CODE)
         ORG   DY@TEMP+L'DY@TEMP
         DS    0D                       ALIGN REPLY AREA
DY@FIELD DS    CL(QDREPLYL)             WORK AREA TO EXTRACT 1 FIELD
DY@PCMD  DS    CL(QDREPLYL)             PRIMARY LINE COMMAND
DY@PCLEN DS    H                        ITS LENGTH
DY@INPUT DS    0CL(3+3+QDREPLYL+(3+2+3+8)*40)
DY@AID   DS    C
         DS    CL2                      CURSOR ADDRESS
         DS    C,CL2                    SBA, DATA ADDRESS
DY@TEXT  EQU   *                        INPUT DATA
         ORG   DY@INPUT+L'DY@INPUT
