./       ADD   NAME=$$ATRACE
1
0

-
-
-                                       JUNE 1984
-
-
-
0                                         CDSI
0                                    DEBUGGING TOOL:
0                                       ASMTRACE
-
-
-
-
                                     by David Riker
0                              COMPUTER DATA SYSTEMS, INC.
                                     One Curie Court
                                   Rockville, Md 20850
1
0      January 16, 1985              DEBUGGING TOOLS

-      ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ×                   TRACE: AN INSTRUCTION TRACE ROUTINE
       ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       References:
          SOURCES: C6000A.DOR.ASMLIB(ASMTRACE) (Donot alter source.)
          To asm ASTRACE, use C6000A.DOR.ASMCNTL($ASMTRCE).
0         LOAD MODULE: use C6000A.DOR.LINKLIB2 with:
           ASMTRACE: print up to 4000 lines (turn off printing after 400
               instructions and continue to run.)
0          ASMTRA32: print up to 32000 lines (turn off printing after 32
               instructions and continue) to run.)
0          ASMTRALL: endless printing lines until traced program termina
                or abends.
-      The documentation is  described about ASMTRACE routine as  well a
       and procedure.
0      The ASMTRACE routine  is used to trace  a program through executi
       assembly level.   This is done by  retaining control of the  trac
       after  this   routine  is  called   and  executing  the   traced
       instructions.
0      The benefits of using ASMTRACE routine are:
0           1. Find a hard-solution problem of a traced program.
0           2. Show register changes or contents.
0           3. Show effective or poor logic flow of problem program.
0           4. Show relationship/interface of calling routine and called
0           5. Show data contents or changes.
0           6. Show whereabout of a logic flow or an initial cause of pr
-
-
-                              COMPUTER DATA SYSTEMS, INC.
1
0      January 16, 1985              DEBUGGING TOOLS

0
-      ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ×                   TRACE: AN INSTRUCTION TRACE ROUTINE
       ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ASMTRACE Routine Procedure:
+      ________ _______ _________
-      1.The "CALL TRACE" can be placed in any source area.
-      2. Reassemble the source.
-      3. Relink the object with "INCLUDE SYSMOD(ASMTRACE)" in the linka
          SYSIN.
-      4. SYSTRACE dd card must be in jcl; otherwise no trace is perform
-
-
-
-
-
-
-
-
-
-
                               COMPUTER DATA SYSTEMS, INC.
1
0      January 16, 1985              DEBUGGING TOOLS

0
-      ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ×                   TRACE: AN INSTRUCTION TRACE ROUTINE
       ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       EXPERT HINTS when using ASMTRACE routine:
+      ______ _____ ____ _____ ________ _______
-
       The ASMTRACE routine will not trace and print inside SVC module.
       It will trace  and name any module  or subroutine with BAL/BALR
       with IBM standard linkage convention. It is a better practice to
       name in IBM standard  linkage so you will see a  better listing r
       many ?????  or  unknown modules.  The routine will pick  new unkn
       name when it enters IBM standard linkage.
0      The ?????  module is detected by ASMTRACE routine that it does no
       standard  linkage convention  or does  not  reside within  known
       problem module.  The  routine will collects the module  length.
       module length, the ????? module might be shown.  If a main module
       csects or subroutines, the routine will divide length among csect
       create ????? modules like the most IBM subsystems.
0      ASMTRACE  routine will  check  non-instructional  operation code
       terminate at where the error is.   If  you get any illegal istruc
       is valided on IBM, give the trace output to Dave Riker. (Since IB
       instructions or features (microcode),  routine  have to be implem
       new upgraded instructions.)
0      If you have an  abended ASMTRACE with U0C1 or U0C4,   your progra
       gone off outside  of the problem program  area.   Check STM dumps
       further register changes.  Add many STM instructions to evaluate
       problem.
0      At any  serious problem  of traced program,   do not  pay attenti
       ASMTRACE abend  unless you believe that  it is an internal  ASMTR
       Check with Dave Riker for further help.
0      To reduce lots of  printing,  move "CALL TRACE" to lower  area of
       begin area  of specified/isolated  problem and reasm  & relink  t
       Notice that a long printing will cause a high cpu time.
0      Do not  place CALL  TRACE where  the traced  program can  lose r1
       Better to  use STM or  LM for saving  the r14 and  r15 between th
       necessary.
0      Other than assembly language, ASMTRACE can be called by COBOL, FO
       PLI program. Calling convention should be paid attention.
0                              COMPUTER DATA SYSTEMS, INC.
1
0      January 16, 1985              DEBUGGING TOOLS

0
-      ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ×                   TRACE: AN INSTRUCTION TRACE ROUTINE
       ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       For further questions of IBM instruction, please refer to IBM man
       GA22-7000 , entitled IBM System/370 Principles of Operation.
+                           ___ __________ __________ __ _________
0      Do you have any excellent hint using ASMTRACE? Let us know.
-
-
-
-
-
-
-
-
-
-
-
-
-
0                              COMPUTER DATA SYSTEMS, INC.
1
0      January 16, 1985              DEBUGGING TOOLS

0
-      ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ×                   TRACE: AN INSTRUCTION TRACE ROUTINE
       ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       OUTPUT FORMAT:    The  SYSTRACE output will  be printed with  the
+      ______ ______
       fields:
0      MODULE NAME    ('?????'= MODULE DO NOT HAVE IBM STANDARD LINKAGE)
0      MODULE OFFSET in hexadecimal
0      MODULE resident address in hexadecimal
0      INSTRUCTION code in hexadecimal
0      CONDITIONAL CODE
0      INSTRUCTION MNEMONIC code
0      INSTRUCTION operands code
0      REGISTER OPERAND contents after instruction excuted
0      BRANCH or SVC address pointer
0      RX/RS/SI/S formats:
+      __________ _______
       OPERAND 2 base address contents after excuted
       OPERAND 2 displacement address contents after excuted
0      ss format:
+      __ ______
       OPERAND 1/2 base address contents after excuted
       OPERAND 1/2 displacement address contents after excuted
0      The sixteen registers (R0-R15) dump will be printed after each LM
       SVC instruction.
0      At the  beginning of TRACE call,   the R0-R15 registers and  F0-F
       point registers will be printed.
-
-
-
0                              COMPUTER DATA SYSTEMS, INC.
1
0      January 16, 1985              DEBUGGING TOOLS

0
-      ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ×                   TRACE: AN INSTRUCTION TRACE ROUTINE
       ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ASMTRACE installation:
+      ________ ____________
-
       *****************************************************************
       *        TO UTILIZE TRACE PROGRAM:
       *
       *        TO INITIATE TRACE, CODE "CALL TRACE" IN ANY ASM SOURCE.
       *        THE PROBLEM SOURCE SHOULD BE LINKED WITH ASMTRACE MODULE
       *        AS SUBROUTINE. (USE A INCLUDE SYSLIB(ASMTRACE) CARD.)
       *
       *        TO TURN OFF TRACE PRINTING, CODE "CALL TRACEOFF".
       *        TO TURN ON TRACE PRINTING, CODE "CALL TRACEON".
       *        TO ABORT  TRACE PROCESSING, CODE "CALL TRACKILL".
       *
       *        WARNING: "CALL TRACE" MUST BE INITIATED FIRST BEFORE
       *              USING TRACEON, TRACEOFF, OR TRACKILL.
       *
       *        INCLUDE A //SYSTRACE DD CARD IN THE JCL USED TO EXECUTE
       *        THE TRACED PROGRAM.  ONE LINE OF OUTPUT PER INSTRUCTION
       *        WILL BE WRITTEN TO SYSTRACE.
       *
       *****************************************************************
-
-
-
-
-
-
-
                               COMPUTER DATA SYSTEMS, INC.
1
0      January 16, 1985              DEBUGGING TOOLS

0
-      ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ×                   TRACE: AN INSTRUCTION TRACE ROUTINE
       ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ASMTRACE CHANGE and FIX HISTORY:
+      ________ ______ ___ ___ _______
       *****************************************************************
       * -----  AUTHOR : BERNARD SCHOCH, COMNET COMPUTER CENTER
       *
       * -----  DEBUGGED 03/22/74 BY CLAUDE SCHOCH
       *
       * -----  CONVERTED FOR 370 INSTSRUCTIONS AND EXTENDED FLOATING PO
       *        INSTRUCTIONS BY CLAUDE SCHOCH 2/12/75
       *
       * -----  ENHANCED AND SUPPORTED BY:
       *                    LIONEL SILVA
       *                    US POSTAL DATA CENTER
       *                    850 CHERRY AVENUE
       *                    SAN BRUNO, CA 94097-9330
       *                    (415) 876-9142
       *         REASONS: ??????
       *
       * -----  ENHANCED AND IMPROVED BY:  3/9/84
       *                    DAVID O. RIKER
       *                    COMPUTER DATA SYSTEMS, INC
       *                    ONE CURIE COURT
       *                    ROCKVILLE, MD 20850
       *                    (202) 362-1160
       *
       *     1. SUPPORT FOR MVS EXTENTED INSTRUCTIONS (S,RRE, & SSE FORM
       *     2. ADD CSECT NAME AND OFFSET ADDRESS IN OUTPUT FORMAT
       *     3. BUILT CSECT TABLE WITH NAME, POINTER, AND LENGTH
       *     4. FIXED DECIMAL INSTRUCTION DISPLAY OUTPUT
       *     5. ADD TRACEON, TRACEOFF, TRACKILL INDICATOR SWITCH COMMAND
       *          TO REDUCE SYSTRACE OUTPUT LISTING.
       *     6. FUTURE PLANNING: MORE SWITCH COMMANDS LIKE SNAP SPECIFIE
       *        AREA WHEN HIT AT CSECT+XX, DISPLAY GREATER THAN 4 BYTES
       *        OF DISPLACMENT (LONG MVC OR DSECT), MORE AND MORE.....
       *        Planning to convert to ISPF.
       *
       *****************************************************************
-
-
-                              COMPUTER DATA SYSTEMS, INC.
1
0      January 16, 1985              DEBUGGING TOOLS

0
-      ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ×                   TRACE: AN INSTRUCTION TRACE ROUTINE
       ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       PRINTING LIMITATION:
+      ________ __________
0      To increase or decrease the number of printing lines, use the fie
0      MPRTCNTP DC    H'32000'
-      or zap the maximum number of lines.
0       NAME ASMTRACE TRACE
        VER  ????  7D00
        REP  ????  xxxx (must be a positive binary number up to 32767.)
-
-
-
-
-
-
-
-
-
-
-                              COMPUTER DATA SYSTEMS, INC.
1
0      January 16, 1985              DEBUGGING TOOLS

0
-      ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ×                   TRACE: AN INSTRUCTION TRACE ROUTINE
       ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ERROR MESSAGE SOLUTION:
+      _____ _______ ________
0      ERROR MSG: 'ERROR OVER 100 MODULES TABLE'
0      SOLUTION: change the following fields and reasm ASMTRACE.
-      MODCNTMX DC    H'100'   INCREASE THE NUMBER WHEN YOU INCREASE MAP
0      MAPDIR   DC    4*100F'0'   UP TO 100 CSECT NAMES CAN BE TRACED
       *                          16 BYTES PER CSECT NAME SEE MODDIRD DS
       *                        IF OVER 100, INCREASE THE MAPDIR
       *                                      AND MODCNTMX WITH SAME VAL
-
-
-
-
-
-
-
-
-
-
0                              COMPUTER DATA SYSTEMS, INC.
1
0      January 16, 1985              DEBUGGING TOOLS

0
-      ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ×                   TRACE: AN INSTRUCTION TRACE ROUTINE
       ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       RETURN CODE MESSAGE:
+      ______ ____ _______
0         USER ABENDS USED BY THE TRACE ARE:
0                U100 - ERROR OVER 100 MODULES TABLE
0                U111 - TRACE ROUTINE ATTEMPT TO STAE FAILED
0                U222 - ILLEGAL INSTRUCTION WAS DETECTED IN THE TRACE.
0                U333 - SYSTRACE DCB COULD NOT BE OPENED.
-
-
-
-
-
-
-
-
-
-
-
                               COMPUTER DATA SYSTEMS, INC.
1
0      January 16, 1985              DEBUGGING TOOLS

-      ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ×
       ×                            TABLE OF CONTENTS
       ×
       ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       Introduction ....................................................
       TRACE procedure .................................................
       Expert Hints ....................................................
       OUTPUT Description ..............................................
       Installation Guide ..............................................
       TRACE source fix history ........................................
       Printing lines limitation .......................................
       Error Messages solution .........................................
       Return Code Meanings ............................................
-
-
-
-
-
-
-
-
-
-
-
                               COMPUTER DATA SYSTEMS, INC.
./       ADD   NAME=$$DISASM
1
0

-
-
-                                       JUNE 1984
-
-
-
0                                         CDSI
0                                    DEBUGGING TOOL:
0                                     DISASSEMBLER
-
-
-
-
                                     by David Riker
0                              COMPUTER DATA SYSTEMS, INC.
                                     One Curie Court
                                   Rockville, Md 20850
1
0      January 16, 1985              DEBUGGING TOOLS

-      ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ×                     DISASMX: A DISASSEMBLY PROGRAM
       ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
-      References:
          SOURCES: C6000A.DOR.ASMLIB (Donot alter source.)
0         DISASMX  - First Phase
          DISASMX1 - Second Phase
          DISASMX3 - Third Phase
0         To asm DISASM, use C6000A.DOR.ASMCNTL($ASMDISX).
0         LOAD MODULE: use C6000A.DOR.LINKLIB2 with: DISASMX
-      The documentation is described about DISASM routine as well as so
       procedure.
0      DISASMX is  a one-pass  disassembler which  produces an  assemble
       source program from a CSECT within a load module.
0      Control cards  permit specification  of areas  containing no  ins
       allow base registers to be provides so  that symbolic labels may
       during disassembly, and definition of DSECTS to be used during di
0      Conditional branch instructions use the extended mnemonics, where
       and explicit registers are denoted by  R0,  R1,  ...   R15.   Inf
       comments  are given  on  SVC'S,  and  various BAL  instructions
       creating a documented source program.
-
-
-
-
-
0                              COMPUTER DATA SYSTEMS, INC.
1
0      January 16, 1985              DEBUGGING TOOLS

0
-      ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ×                     DISASMX: A DISASSEMBLY PROGRAM
       ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
-      JCL REQUIREMENTS:
+      ___ ____________
0      A. EXEC CARD:        To execute PGM=DISASMX. A PARM field may be
                            specified if floating point and/or privilege
                            instructions are to be found in the module.
0      B. STEPLIB DD CARD:  OPTIONAL, specify the pds containing the mod
                            DISASMX. Normally use C6000A.DOR.LINKLIB2.
0      C. LOADLIB DD CARD:  OPTIONAL, specify pds containing the modules
                            DISASMX1 and DISASMX2, If other than SYS1.LI
                            or STEPLIB.
0      D. SYSLIB DD CARD:   Specify pds containing the module to be
                            disassembled.
0      E. SYSPRINT DD CARD: OPTIONAL, specify the printed output dataset
                            BLKSIZE must be specified as a multiple of 1
                            RECFM=FBA,LRECL=121 is hard coded.
0      F. SYSPUNCH DD CARD: OPTIONAL, specify printed output dataset. BL
                            must be specified as a multiple of 80.
                            RECFM=FB,LRECL=80 is hard coded.
0      G. SYSIN DD CARD:    Contains control cards. The module-csect car
                            required. BLKSIZE must be a multiple of 80.
                            RECFM=FB,LRECL=80 is hard-coded.
-
-
-
-
-
                               COMPUTER DATA SYSTEMS, INC.
1
0      January 16, 1985              DEBUGGING TOOLS

0
-      ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ×                     DISASMX: A DISASSEMBLY PROGRAM
       ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
-      JCL EXAMPLE:
+      ___ _______
0      Disassemble  csect  IECIOSCN in  module  IEANUC01,   which  is in
       SYS1.NUCLEUS.  The modules DISASMX,  DISASMX1,  and DISASMX2 are
       pds SYS1.TECHLOAD.  A printed listing is to be mase, and the sour
       output will be placed in the sequential dataset USER02.IECIOSCN.A
-
0               //DISASM EXEC PGM=DISASMX
                //STEPLIB DD DSN=SYS1.TECHLOAD,DISP=SHR
                //SYSPRINT DD SYSOUT=A,DCB=BLKSIZE=121
                //SYSLIB DD DSN=SYS1.NUCLEUS,DISP=SHR
                //SYSPUNCH DD DSN=USER02.IECIOSCN.ASM,DISP=(,CATLG),
                              UNIT=SYSTS,DCB=18960,
                              SPACE=(TRK,(5,2),RLSE)
                //SYSIN DD *
                IEANUC01 IECIOSCN
-
-
-
-
-
-
-
-                              COMPUTER DATA SYSTEMS, INC.
1
0      January 16, 1985              DEBUGGING TOOLS

0
-      ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ×                     DISASMX: A DISASSEMBLY PROGRAM
       ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
-      PARM FIELD:
+      ____ _____
0      PARM field on the  EXEC card:  omit the PARM field,   unless floa
       and/or  privileged  instructions  are  to  be  found  in  the  cs
       disassembled.   When the  PARM field  is  not specified,   entrie
       privileged and  floating point  instructions are  erased from  th
       instruction tables used during disassembly.
0      Valid PARM fields are:
0        PARM=(SUPVR)           Assemble privileged instructions
0        PARM=(FLTPT)           Assemble floating point instructions
0        PARM=(SUPVR,FLTPT)     Assemble both privileged and floating po
                                 instructions.
-
-
-
-
-
-
-
-
-                              COMPUTER DATA SYSTEMS, INC.
1
0      January 16, 1985              DEBUGGING TOOLS

0
-      ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ×                     DISASMX: A DISASSEMBLY PROGRAM
       ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
-      CONTROL CARDS:
+      _______ _____
0      Control cards  entered in  the SYSIN  dataset.  Data  is containe
       columns 1-72.   Columns 73-80  may be  used for  any desired  pur
       addition, columns beyond the last specified may be used for any p
0      Leading zeros must  be included in all  fields giving hes or  dec
       Name fields  must be left justified  with trailing blanks.  Hex
       contain only the hex digits 0-9 and  A-F,  while decimal fields m
       only digits 0-9.
0      The module-csect card must  be the first card in the  input strea
       definitions may  not include  any other  control cards.    USING
       DSECTs must be entered at some point after the DSECT definition.
       cards and  program USING cards  may be entered  in any order  exc
       DSECT definitions.
-
-
-
-
-
-
-
-
-                              COMPUTER DATA SYSTEMS, INC.
1
0      January 16, 1985              DEBUGGING TOOLS

0
-      ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ×                     DISASMX: A DISASSEMBLY PROGRAM
       ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
-      CONTROL CARDS: MODULE-CSECT
+      _______ _____  ____________
0       A.  MODULE-CSECT  card (required),  must  be the  first card in
       stream. Specifies the module name and csect name.  Module name is
       and must name an entry in the directory  of the pds specified by
       DD card.  Csect name is optional.  If specified, the named csect
       in the module.  If omitted,  the csect with ESDID=0001 is disasse
       disassemble all csects of the module, specifies "*" as a csect en
0      MODULE-CSECT FORMAT:
+      ____________ ______
0      Free-form, with module name preceding csect name.   At least one
       seperate module name and  csect name.   The names may be  surroun
       number of blanks.  For example, see the JCL example.
-      CONTROL CARDS: DATA-ONLY
+      _______ _____  _________
0      B.  DATA-ONLY card  (optional),  used to describe areas of  the c
       disassembled which  contain no instructions.   Use of this  card
       creation of instructions from constant data.  Up to 256 data-only
       be entered.  These cards  may occur anywhere in the SYSIN  stream
       MODULE-CSECT card,  but not within a  dsect definition set.  This
       not be used during module-* card.
0      DATA-ONLY FORMAT:
+      _________ ______
0              COL  1-4  : Literal 'DATA'
               COL   5   : Blank
               COL  6-11 : Offset to beginning of area in hex.
               COL   12  : Blank
               COL 13-18 : Offset to end of area in hex
-
-
-
0                              COMPUTER DATA SYSTEMS, INC.
1
0      January 16, 1985              DEBUGGING TOOLS

0
-      ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ×                     DISASMX: A DISASSEMBLY PROGRAM
       ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
-      CONTROL CARDS: DSECT DEFINITIONS
+      _______ _____  _____ ___________
0      C.  DSECT  DEFINITIONS (optional).   A dsect  is defined  by a  h
       followed by  a variable  number of field  definition cards  (up t
       them).  No other control card may be entered within a dsect defin
       to 256 dsect definitions may be entered.   The dsect definitions
       used during MODULE-* card.
0      DSECT HEADER CARD FORMAT:
+      _____ ______ ____ ______
0           COL 1-8    : DSECT name
            COL 9      : Blank
            COL 10-14  : Literal 'DSECT'
            COL 15     : Blank
            COL 16-19  : Number of field cards to follow (decimal)
-      DSECT FIELD CARD FORMAT:
+      _____ _____ ____ ______
0           COL 1-8    : Field name
            COL 9      : Blank
            COL 10-13  : Offset to left end of field (decimal)
                         (Maximum offset is 4095.)
            COL 14     : Blank
            COL 15-17  : Length of field in bytes (deciaml)
                         (Maximum length is 256.)
-
-
-
-
-
0                              COMPUTER DATA SYSTEMS, INC.
1
0      January 16, 1985              DEBUGGING TOOLS

0
-      ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ×                     DISASMX: A DISASSEMBLY PROGRAM
       ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
-      CONTROL CARDS: ULABL
+      _______ _____  _____
0      D.  ULABL cards.  These cards define user labels to be placed on
       within the program.  If program base registers are set up with US
       These will  also be  generated as symbolic  operands on  instruct
       ULABL cards may not be used during the module-* card.
0      ULABL FORMAT:
+      _____ ______
0           COL  1-5   : Literal 'ULABL'
            COL   6    : Blank
            COL  7-14  : Label name
            COL  15    : Blank
            COL 16-21  : Offset to left end of field, in hex.
            COL  22    : Blank
            COL 23-25  : Length of field in decimal. (256 is maximum.)
-
-
-
-
-
-
-
-
-                              COMPUTER DATA SYSTEMS, INC.
1
0      January 16, 1985              DEBUGGING TOOLS

0
-      ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ×                     DISASMX: A DISASSEMBLY PROGRAM
       ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
-      CONTROL CARDS: USING
+      _______ _____  _____
0      E.  USING cards.  These cards define base register usage.   Up to
       cards  may be  entered.  Use  of these  cards permits  the dissas
       convert explicit base-displacement addresses to symbolic labels.
0      Labels created  within the program  will be  7 characters long.
       character is 'A', followed by the 6-hex-digit offset to the label
       card must be entered for each DSECT to  be used.  The USING card
       used during MODULE-* card.
0      USING FORMAT:
+      _____ ______
0          COL 1-5   : Literal 'USING'
           COL 6     : Blank
           COL 7-12  : Offset to begin locate for USING range in hex.
                       (This is where the USING statement will occur.)
           COL 13    : Blank
           COL 14-19 : Offset to ending locate for USING range in hex.
                       (This is where the DROP statement will occur.)
           COL 20    : Blank
           COL 21    : Base register to be used. (hex. 1-F)
           COL 22    : Blank
           COL 23    : Type code; P=program base or D=dsect base
           COL 24    : Blank
           COL 25-30 : Initial base register value (in hex.) if type cod
           COL 25-32 : Dsect name if type code is D.
-
-
-
-
-
                               COMPUTER DATA SYSTEMS, INC.
1
0      January 16, 1985              DEBUGGING TOOLS

0
-      ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ×                     DISASMX: A DISASSEMBLY PROGRAM
       ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
-      SUGGESTIONS FOR USE:
+      ___________ ___ ___
0      On the first  pass,  do not use a  SYSPUNCH DD card,  but  use th
       listing.  Use  Module-* card to  print all  CSECTs or use  Module
       specified csect listing.
0      Use the csect listing to determine which registers are used as pr
       registers,  their initial values and their ranges.  Make up USING
       these.  Find  any places  where no instructions  should be  gener
       constants), and make up DATA-ONLY cards for these ranges.
0      If you can  determine any registers that  are bases for areas  wh
       used for DSECTS (CVT reference,  etc.),   determine the range of
       and make up DSECT definitions and using cards for these.
0      Make a second run, including the above cards, and creating a sour
       output with the SYSPUNCH DD card.
-
-
-
-
-
-
-
-
0                              COMPUTER DATA SYSTEMS, INC.
1
0      January 16, 1985              DEBUGGING TOOLS

0
-      ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ×                     DISASMX: A DISASSEMBLY PROGRAM
       ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
-      OUTPUT DESCRIPTION:
+      ______ ___________
0      A.  SYSPUNCH:
+          ________
0      This output contains the disassembled source program. Statement n
       in column 1,   mnemonics begin in column  10,  operands in col  1
       occasional comment begins in column 44.  A sequence number (by te
       columns 73-80. Comments are included to show the macro name assoc
       SVC's, and other statements are flagged to aid in identification
       operations:
0                BALR 14,15              STD LINKAGE
                 BALR X,0                ADDRESS SET
                 OTHER BALR'S            NON-STD LINKAGE
                 BAL 0,XXX AND BAL 1,XXX PARM SET BRCH
                 BAL X,XXX               PERFORM
                 STM instructions        save regs
                 LM  instructions        restore regs
                 BR R14                  EXIT
                 ABS. LOCATION HEX 10    CVT address
                 ABS. LOCATION HEX 4C    CVT address
                 Other abs. locations    PSA REFERENCE
0      When used in explicitly in instructions, registers are specified
       R2,... R15.  An REQU macro is generated at the end if the program
       the appropriate  EQU statements.  If any  DSECTs were defined in
       dataset,  they will be  near the end of the source  program.   Th
       mnemonics are used for conditional branches wherever possible.
-
-
-
-
-                              COMPUTER DATA SYSTEMS, INC.
1
0      January 16, 1985              DEBUGGING TOOLS

0
-      ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ×                     DISASMX: A DISASSEMBLY PROGRAM
       ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
-      OUTPUT DESCRIPTION:
+      ______ ___________
0      B.  SYSPRINT CONTENT:
+          ________ _______
0       DIRECTORY INFORMATION: contains data from the directory entry of
              module containing the CSECT(s) to be disassembled.
0       ESD TABLE: a formatted list of all external symbol entries found
              the module.
0       RLD TABLE: a formatted listing of all relocation dictionary entr
              pertaining to this csect(s).
0       USER ENTERED CARDS: a list of the cards entered by the user, wit
              diagnostics, if appropriate.
0       PHASE 1 LABEL TABLE: a list of all the labels to be used during
              disassembly including those developed from ESD entries, RL
              entries, and generated names resulting from USING card
              processing.
0       TEXT: a storage-dump formatted listing of the text which compris
              the CSECT being disassembled.
0       SOURCE LISTING: a printout of the generated source program
               statements, including the hex value which resulted in the
               instruction's creation.
-
-
-
-
-
                               COMPUTER DATA SYSTEMS, INC.
1
0      January 16, 1985              DEBUGGING TOOLS

0
-      ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ×                     DISASMX: A DISASSEMBLY PROGRAM
       ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
-      PROGRAM PROCESSING DESCRIPTION:
+      _______ __________ ___________
0      The disassembler is composed of three modules. The first is calle
       The second phase is  DISASMX1,  and the third is DISASMX2.   The
       third phases are load'ed and performed by a BALR 14,15 from DISAS
-      DISASMX FUNCTIONS:
+      _______ _________
0        . Process the PARM field, If any: set indicators used by DISASM
           and DISASMX2 to set up their instruction tables.
0        . Open all files.
0        . Get storage for the symbol table, RLD table, and DATA-ONLY ta
           (109,544 bytes total).
0        . Process the MODULE-CSECT card to obtain the member and CSECT
           names.
0        . Issue BLDL against SYSLIB to obtain directory info for the me
           specified. If the specified member is an ALIAS, re-issue a BL
           for the real member. Print directory information.
0        . Point to the member in the SYSLIB pds, and process the member
           Load modules contain an external symbol dictionary followed b
           text and relocation dictionary information.  All ESD info for
           module precedes the first CONTROL record. A CONTROL record
           precedes each block of text.  RLD info for the text follows e
           text block. Processing of load module information is as follo
0          A. Build an external SYMBOL table, using the CESD blocks.
0          B. Search for the desired csect as the table is being built.
              csect must be found before the first CONTROL record.
0          C. Read blocks until a CONTROL record for the desired CSECT i
              found (by ESD id).
0          D. When found, issue GETMAIN for an area large enough to cont
              the entire text.
0                              COMPUTER DATA SYSTEMS, INC.
1
0      January 16, 1985              DEBUGGING TOOLS

0
-      ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ×                     DISASMX: A DISASSEMBLY PROGRAM
       ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
-          E. Place text blocks in contiguous storage locations and main
              during disassembly.
0          F. Use RLD information for the CSECT to build the RLD table.
0        . Load and perform DISASMX1.
0        . If any errors found by DISASMX1, terminate processing.
0        . Print the final label table to be used during disassembly.
0        . Load and execute DISASMX2.
0        . Generate the DSECT entries.
0        . Generate the REQU macro and END statements.
0        . Terminate processing after the MODULE-* card has a runout of
           CSECTs.
-
-
-
-
-
-
-
-                              COMPUTER DATA SYSTEMS, INC.
1
0      January 16, 1985              DEBUGGING TOOLS

0
-      ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ×                     DISASMX: A DISASSEMBLY PROGRAM
       ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
-      DISASMX1 FUNCTIONS:
+      ________ _________
0      DISASMX1 is the second phase of disassembly, and is performed by
       common data area, defined in DISASMX, is passed to this program o
0      The SYSIN  file is  read to  exhaustion.  USING  cards are  refor
       stored in a table - up to 256 USING statements may be entered.  D
       may  follow  the  USING  statements.   When  used,   DSECT  state
       reformatted, and built into tables. A maximum of 256 DSECTS may b
       DATA-ONLY cards may be included before,   between,  or after DSEC
       areas in the program where no instructions occur. Up to 256 DATA-
       may be specified.
0      At eof on SYSIN,  a pseudo dis-assembly  pass is made using the t
       by DISASMX.  Any resolvable address within the text is used to cr
       entry in the label table, which will be used by DISASMX2 in the a
       assembly pass.
0      Disassembly tables are set  up similarly to those used by  DISASM
       simulated  disassembly  performed in  this  module  when any  pro
       register using statements are entered.
0      Storage is obtained for the DSECT table  and USING table,  and ad
       these tables are stored in the common parameter area. USING and D
       are edited,   reformatted,  and placed in  the appropriate tables
       errors are found, they are printed,  and the disassembly will be
       on return to DISASMX.
0      Storage is obtained  for the LABEL table,  and a  simulated dis-a
       performed to create LABEL table entries  for labels which will be
       for base-displacement addresses by DISASMX2.   On return to DISAS
       labels will be sorted with external symbol and RLD labels to form
       LABEL table to be used by DISASMX2.
-
-
-
                               COMPUTER DATA SYSTEMS, INC.
1
0      January 16, 1985              DEBUGGING TOOLS

0
-      ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ×                     DISASMX: A DISASSEMBLY PROGRAM
       ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
-      DISASMX2 FUNCTIONS:
+      ________ _________
0      This sub-program  is called  by DISASMX after  completion of  pro
       DISASMX1. The final LABEL table and module text is in an area of
       common parameter area is defined in DISASMX, and passed to this p
0      Text bytes  are used to create  assembly lanquage statements,   a
       instruction  ststements.  Output  is written  to the  SYSPUNCH da
       further processing by other modules.
0      A test byte is  considered to be an instruction if it  occurs on
       boundary,   is a  valid  op-code,   and is  followed  by  a valid
       Unconditional branched need  not be followed by a  valid op-code,
       The  privileged  and  floating  point   instructions  are  not  t
       instructions unless the user specified their inclusion at exec ti
-
-
-
-
-
-
-
-
-
                               COMPUTER DATA SYSTEMS, INC.
1
0      January 16, 1985              DEBUGGING TOOLS

0
-      ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ×                     DISASMX: A DISASSEMBLY PROGRAM
       ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
-      INSTALLATION.
+      ____________
0      A. Assemble and link the three programs, DISASMX, DISASMX1, and
          DISASMX2.
0      B. If a single load module is desired, the load and BALR code in
          program DISASMX, (lines 10490-10590, and lines 11620-11720) ma
          changes to calls, passing the address of the common parameter
          as a parameter. The three programs will all be linked into a s
          module with entry point DISASMX, if this is done.
0      C. If storage utilization is found to be excessive, investagate t
          possibility of reducing the size of the table GETMAINS in DISA
          (lines 1360, 1380, 1440, 1500, 5460, and 9450,) and in DISASMX
          (lines 1520, 1610, and 4160.) The programs were written for ea
          use with an MVS operating system, and may cause problems in a
          storage constrained environment.
0      D. The SVC table and instruction op code tables in DISASMX1 and
          DISASMX2 should be checked for operating system validity, and
          currency with the hardware from time to time.
0      E. Macros used by the disassembler include SVLNK and REQU.
          SVLNK is used to establish addressability and chain
          save areas during initialization in each program, and
          set up register equates by use of the REQU macro. The
          REQU macro is also placed in each disassembled program
          if these macros are used, they should be places in a macro
          library or prefixed to the source before assembly. If
          other macros are used in their place, make appropriate
          source code changes in DISASMX, DISASMX1, and DISASMX2
          before assembly.
-
-
-
0                              COMPUTER DATA SYSTEMS, INC.
1
0      January 16, 1985              DEBUGGING TOOLS

0
-      ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ×                     DISASMX: A DISASSEMBLY PROGRAM
       ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
-      HISTORY and IMPROVEMENTS/FIXES:
+      _______ ___ __________________
0      Direct technical inquiries, comments, suggestions for improvement
          etc, to:
0      Original author:
0           DICK THORNTON
            BLUE CROSS OF VIRGINIA
            2015 STAPLES MILL ROAD
            RICHMOND, VA. 23279
0           PHONE: (804) 359-7248
-
       Modified for MODULE-* control card
             (multiple csects printing from one module).
0           DAVID RIKER
            COMPUTER DATA SYSTEMS, INC.
            One Curie Court
            Rockville MD 20850
0           (202) 362-1160
-
-
-
-
-
-                              COMPUTER DATA SYSTEMS, INC.
1
0      January 16, 1985              DEBUGGING TOOLS

-      ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
       ×
       ×                            TABLE OF CONTENTS
       ×
       ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
-
       Introduction ....................................................
       JCL Requirements ................................................
       JCL Example .....................................................
       PARM field ......................................................
       Control cards ...................................................
          MODULE-CSECT .................................................
          DATA-ONLY ....................................................
          DSECT Definitions ............................................
          ULABL Definitions ............................................
          USING Definitions ............................................
          Suggestions for use ..........................................
       Output Description ..............................................
          SYSPUNCH .....................................................
          SYSPRINT .....................................................
       Program Processing Description ..................................
          DISASMX ......................................................
          DISASMX1 .....................................................
          DISASMX2 .....................................................
       Installation ....................................................
       History and Improvements/Fixes ..................................
-
-
-
-
-
-
0                              COMPUTER DATA SYSTEMS, INC.
./       ADD   NAME=$ASMBLKH
//JOBASM JOB (XXXX,,999),'ASM BLOKHEAD',CLASS=A,MSGCLASS=A
//* REFER  SYS1.PROCLIB(ASMFCL)
//*
//ASM    EXEC  PGM=IEV90,PARM=OBJECT,REGION=1200K
//SYSLIB DD DSN=C6000A.DOR.UTIL316,VOL=SER=PPVOL1,
//          UNIT=3350,DISP=SHR
//       DD DSN=SYS1.MACLIB,DISP=SHR
//       DD DSN=SYS1.AMODGEN,VOL=SER=CDSI05,UNIT=3350,DISP=SHR
//SYSUT1   DD  UNIT=(SYSDA,SEP=SYSLIB),SPACE=(CYL,(10,5)),DSN=&SYSUT1
//SYSPUNCH DD  DUMMY,DCB=BLKSIZE=80
//SYSPRINT DD SYSOUT=A,DCB=(BLKSIZE=3509),UNIT=(,SEP=(SYSUT1,SYSPUNCH))
//SYSLIN   DD  DISP=(,PASS),UNIT=SYSDA,SPACE=(CYL,(5,5,0)),
//             DSN=&&LOADSET
//SYSIN DD DSN=C6000A.DOR.UTIL316(BLOCKSAS),DISP=SHR,
//         VOL=SER=PPVOL1,UNIT=3350
//LKED EXEC  PGM=IEWL,PARM='MAP,LET,LIST,NCAL',
//        REGION=1000K,COND=(8,LT,ASM)
//SYSLIN   DD  DSN=&&LOADSET,DISP=(OLD,DELETE)
//         DD  DDNAME=SYSIN
//SYSSMOD  DD DSN=C6000A.DOR.LINKLIB2,DISP=SHR,UNIT=3350
//SYSLMOD  DD DSN=C6000A.DOR.LINKLIB2,DISP=SHR,UNIT=3350
//SYSPRINT DD SYSOUT=A
//*  INCLUDE SYSSMOD(ASMTRA99) IF YOU NEED TO TRACE ASM
//SYSIN DD *
 SETSSI AB11C000
 INCLUDE SYSSMOD(EALSDW95)
 NAME BLOKHEAD(R)
/*
./       ADD   NAME=$ASMBLKS
//DORASM JOB (6000A,4,,999),'ASM BLOCKSUB',CLASS=A,MSGCLASS=A,
//    NOTIFY=DOR
//* REFER  SYS1.PROCLIB(ASMFCL)
//*
/*ROUTE PRINT RMT55
//ASM    EXEC  PGM=IEV90,PARM=OBJECT,REGION=1200K
//SYSLIB DD DSN=C6000A.DOR.UTIL316,VOL=SER=PPVOL1,
//          UNIT=3350,DISP=SHR
//       DD DSN=SYS1.MACLIB,DISP=SHR
//       DD DSN=SYS1.AMODGEN,VOL=SER=MVSDL2,UNIT=3350,DISP=SHR
//SYSUT1   DD  UNIT=(SYSDA,SEP=SYSLIB),SPACE=(CYL,(10,5)),DSN=&SYSUT1
//SYSPUNCH DD  DUMMY,DCB=BLKSIZE=80
//SYSPRINT DD SYSOUT=A,DCB=(BLKSIZE=3509),UNIT=(,SEP=(SYSUT1,SYSPUNCH))
//SYSLIN   DD  DISP=(,PASS),UNIT=SYSDA,SPACE=(CYL,(5,5,0)),
//             DSN=&&LOADSET
//SYSIN DD DSN=SYS7.TOCBT.SRCLIB(BLOCKSUB),DISP=SHR
//LKED EXEC  PGM=IEWL,PARM='MAP,LET,LIST,NCAL',
//        REGION=1000K,COND=(8,LT,ASM)
//SYSLIN   DD  DSN=&&LOADSET,DISP=(OLD,DELETE)
//         DD  DDNAME=SYSIN
//SYSSMOD  DD DSN=C6000A.DOR.LINKLIB2,DISP=SHR,UNIT=3350
//SYSLMOD  DD DSN=C6000A.DOR.LINKLIB2,DISP=SHR,UNIT=3350
//SYSPRINT DD SYSOUT=A
//*  INCLUDE SYSSMOD(ASMTRA99) IF YOU NEED TO TRACE ASM
//SYSIN DD *
 INCLUDE SYSSMOD(EALSDW95)
 NAME BLOCKSUB(R)
/*
./       ADD   NAME=$ASMDISX
//JOBASM JOB (XXXXXX,,999),'ASM DISX',CLASS=A,MSGCLASS=A,
//   NOTIFY=DOR
//* REFER  SYS1.PROCLIB(ASMFCL)
//*
//ASMXCL PROC MEMBER=,MEMLKED=
//ASM    EXEC  PGM=IEV90,PARM=OBJECT,REGION=600K
//SYSLIB DD DSN=C6000A.DOR.ASMLIB,VOL=SER=VTAM01,
//          UNIT=3350,DISP=SHR
//       DD DSN=SYS1.MACLIB,DISP=SHR
//       DD DSN=SYS1.AMODGEN,VOL=SER=MVSDLB,UNIT=3350,DISP=SHR
//SYSUT1   DD  UNIT=(SYSDA,SEP=SYSLIB),SPACE=(CYL,(10,5)),DSN=&SYSUT1
//SYSPUNCH DD  DUMMY,DCB=BLKSIZE=80
//SYSPRINT DD SYSOUT=A,DCB=(BLKSIZE=3509),UNIT=(,SEP=(SYSUT1,SYSPUNCH))
//SYSLIN   DD  DISP=(,PASS),UNIT=SYSDA,SPACE=(CYL,(5,5,0)),            *
//             DCB=(BLKSIZE=400),DSN=&&LOADSET
//SYSIN DD DSN=C6000A.DOR.ASMLIB(&MEMBER.),DISP=SHR,
//         VOL=SER=VTAM01,UNIT=3350
//LKED EXEC  PGM=IEWL,PARM='MAP,LET,LIST,NCAL',REGION=96K,
//         COND=(8,LT,ASM)
//SYSLIN   DD  DSN=&&LOADSET,DISP=(OLD,DELETE)
//         DD  DDNAME=SYSIN
//SYSLMOD  DD DSN=C6000A.DOR.LINKLIB2(&MEMLKED.),DISP=OLD,UNIT=3350
//SYSPRINT DD SYSOUT=A
//  PEND
//DISASMX EXEC ASMXCL,MEMBER=DISASMX,MEMLKED=DISASMX
//DISASMX1 EXEC ASMXCL,MEMBER=DISASMX1,MEMLKED=DISASMX1
//DISASMX2 EXEC ASMXCL,MEMBER=DISASMX1,MEMLKED=DISASMX2
./       ADD   NAME=$ASMEALS
//JOBASM JOB (XXXXX,,999),'ASM EALSD095',CLASS=A,MSGCLASS=A
//* REFER  SYS1.PROCLIB(ASMFCL)
//*
//ASM    EXEC  PGM=IEV90,PARM=OBJECT,REGION=200K
//SYSLIB DD DSN=C6000A.DOR.UTIL316,VOL=SER=PPVOL1,
//          UNIT=3350,DISP=SHR
//       DD DSN=SYS1.MACLIB,DISP=SHR
//       DD DSN=SYS1.AMODGEN,VOL=SER=CDSI05,UNIT=3350,DISP=SHR
//       DD DSN=SYS1.PVTMAC,VOL=SER=CDSI05,UNIT=3350,DISP=SHR
//SYSUT1   DD  UNIT=(SYSDA,SEP=SYSLIB),SPACE=(CYL,(10,5)),DSN=&SYSUT1
//SYSPUNCH DD  DUMMY,DCB=BLKSIZE=80
//SYSPRINT DD SYSOUT=A,DCB=(BLKSIZE=3509),UNIT=(,SEP=(SYSUT1,SYSPUNCH))
//SYSLIN   DD  DISP=(,PASS),UNIT=SYSDA,SPACE=(CYL,(5,5,0)),            *
//             DCB=(BLKSIZE=400),DSN=&&LOADSET
//SYSIN DD DSN=C6000A.DOR.UTIL316(EALSDW95),DISP=SHR,
//         VOL=SER=PPVOL1,UNIT=3350
//LKED EXEC  PGM=IEWL,PARM='MAP,LET,LIST,NCAL',REGION=500K,
//         COND=(8,LT,ASM)
//SYSLIN   DD  DSN=&&LOADSET,DISP=(OLD,DELETE)
//         DD  DDNAME=SYSIN
//SYSLMOD  DD DSN=C6000A.DOR.LINKLIB2(EALSDW95),DISP=OLD,UNIT=3350
//SYSPRINT DD SYSOUT=A
./       ADD   NAME=$ASMLPTF
//JOBASM JOB (XXXXX),'ASM LISTPTF',CLASS=A,MSGCLASS=A
//ASM    EXEC  PGM=IEV90,PARM=OBJECT,REGION=1200K
//SYSLIB DD DSN=XXXXXXX.ASM,VOL=SER=VTAM01,
//          UNIT=3350,DISP=SHR
//       DD DSN=SYS1.MACLIB,DISP=SHR
//       DD DSN=SYS1.AMODGEN,VOL=SER=MVSDL1,UNIT=3350,DISP=SHR
//SYSUT1   DD  UNIT=(SYSDA,SEP=SYSLIB),SPACE=(CYL,(10,5)),DSN=&SYSUT1
//SYSPUNCH DD  DUMMY,DCB=BLKSIZE=80
//SYSPRINT DD SYSOUT=A,DCB=(BLKSIZE=3509),UNIT=(,SEP=(SYSUT1,SYSPUNCH))
//SYSLIN   DD  DISP=(,PASS),UNIT=SYSDA,SPACE=(CYL,(5,5,0)),
//             DSN=&&LOADSET
//SYSIN DD DSN=XXXXXX(LISTPTF),DISP=SHR,UNIT=3350
//LKED EXEC  PGM=IEWL,PARM='MAP,LET,LIST,NCAL',
//        REGION=1000K,COND=(8,LT,ASM)
//SYSLIN   DD  DSN=&&LOADSET,DISP=(OLD,DELETE)
//         DD  DDNAME=SYSIN
//SYSSMOD  DD DSN=XXXXXXX.LINKLIB,DISP=SHR,UNIT=3350
//SYSLMOD  DD DSN=XXXXXXX.LINKLIB(LISTPTF),DISP=SHR,UNIT=3350
//SYSPRINT DD SYSOUT=A
//SYSIN DD *
 INCLUDE SYSSMOD(ASMTRACE)
 NAME LISTPTF(R)
/*
./       ADD   NAME=$ASMTRCE
//JOBASM JOB (XXXXX,,999),'ASM DISASMX',CLASS=A,MSGCLASS=A,
//   NOTIFY=DOR
//* REFER  SYS1.PROCLIB(ASMFCL)
//*
//ASM    EXEC  PGM=IEV90,PARM=OBJECT,REGION=1200K
//SYSLIB DD DSN=C6000A.DOR.ASM,VOL=SER=VTAM01,
//          UNIT=3350,DISP=SHR
//       DD DSN=SYS1.MACLIB,DISP=SHR
//       DD DSN=SYS1.AMODGEN,VOL=SER=CDSI05,UNIT=3350,DISP=SHR
//SYSUT1   DD  UNIT=(SYSDA,SEP=SYSLIB),SPACE=(CYL,(10,5)),DSN=&SYSUT1
//SYSPUNCH DD  DUMMY,DCB=BLKSIZE=80
//SYSPRINT DD SYSOUT=A,DCB=(BLKSIZE=3509),UNIT=(,SEP=(SYSUT1,SYSPUNCH))
//SYSLIN   DD  DISP=(,PASS),UNIT=SYSDA,SPACE=(CYL,(5,5,0)),
//             DSN=&&LOADSET
//SYSIN DD DSN=C6000A.DOR.ASMLIB(DISASMX),DISP=SHR,
//         VOL=SER=VTAM01,UNIT=3350
//LKED EXEC  PGM=IEWL,PARM='MAP,LET,LIST,NCAL',
//        REGION=1000K,COND=(8,LT,ASM)
//SYSLIN   DD  DSN=&&LOADSET,DISP=(OLD,DELETE)
//         DD  DDNAME=SYSIN
//SYSSMOD  DD DSN=C6000A.DOR.LINKLIB2,DISP=SHR,UNIT=3350
//SYSLMOD  DD DSN=C6000A.DOR.LINKLIB2(DISASMX),DISP=SHR,UNIT=3350
//SYSPRINT DD SYSOUT=A
//SYSIN DD *
 INCLUDE SYSSMOD(ASMTRACE)
 NAME DISASMX(R)
/*
./       ADD   NAME=$PDSMEM
//JOBPDSM  JOB (XXXXX,,99),'XXXXXX',
//         CLASS=A,MSGCLASS=A,NOTIFY=DOR
/*ROUTE PRINT RMT55
/*ROUTE PUNCH RMT55
//PDSMEM PROC DSN=,PREFIX='C6000A.DOR'
//LMEMBERS EXEC PGM=LSTPDSMD
//*   LSTPDSMD LIST MEMBERS IN COLUMNUAR FORMAT
//*   LSTPDSML  LIST MEMBERS IN ISPF FORMAT
//STEPLIB DD DSN=C6000A.DOR.LINKLIB2,DISP=SHR,UNIT=3350
//PDS DD DSN=&PREFIX..&DSN,DISP=SHR
//LISTING  DD SYSOUT=A,DCB=(RECFM=FB,LRECL=80,BLKSIZE=80)
//CONTENTS DD DSN=C6000A.DOR.CNTL($FILEMEM),DISP=(MOD,KEEP),
//    DCB=(RECFM=FB,LRECL=80,BLKSIZE=9440)
//SYSUDUMP DD SYSOUT=A
//SYSABEND DD SYSOUT=A
//*SYSTRACE DD SYSOUT=A
//*SYSTRAC2 DD SYSOUT=A
//   PEND
//S EXEC PDSMEM,DSN=SRCLIB,PREFIX='SYS7.TOCBT'
./       ADD   NAME=@RMFSASP
//JOBPERF JOB (XXXXX,,999),'MVS PERFORMANCE',CLASS=A,
//    MSGCLASS=A
//*-----------------------------------------------------------------
//*  WRITTEN BY: DAVID RIKER
//*              COMPUTER DATA SYSTEMS, INC.
//*              ONE CURIE COURT
//*              ROCKVILLE, MD 20850
//*              202- 362-1160
//*-----------------------------------------------------------------
//*  TWO STEPS TO PRODUCE DAILY MVS EXPECTIONS REPORTS.
//* STEP 1: EXTRACT AND GENERATE SAS-RECORDS
//* STEP 2: PRODUCE REPORTS/PLOTS OF CPU EXPECTIONS
//*-----------------------------------------------------------------
//* COMPUTER PERFORMANCE REPORTS IN:
//*   1. 8-UP PLOTTED CHARTS PER PAGE BY HOUR
//*   2. LISTING OF EXPECTIONS (SEE DDNAME DESCRIPTION BELOW)
//*-----------------------------------------------------------------
//*   SAS MACROS:  PLOT8UP - PRINT 8 DIFFERENT PLOT SETS PER PAGE
//*                PRTDATE - FILE STATEMENT FOR SPECIFIED DAY
//*                PAGEDATA- ARRAY DEFINITION FOR PAGE EXCEPTION
//*                SERVDATA- ARRAY DEFINITION FOR SERVICE EXCEPTION
//*                CHANDATA- ARRAY DEFINITION FOR CHANNEL EXCEPTION
//*                DEVDATA - ARRAY DEFINITION FOR DEVICE EXCEPTION
//*                CPUDATA - ARRAY DEFINITION FOR CPU EXCEPTION
//*-----------------------------------------------------------------
//*    SUBROUTINE: BLOKHEAD
//*-----------------------------------------------------------------
//RMFEXTR EXEC SAS,REGION=2500K,OPTIONS='LINESIZE=132'
//WORK DD UNIT=SYSDA,SPACE=(6160,(9999,9999),,,ROUND)
//*-----------------------------------------------------------------
//* FOR 24 HOUR EXTRACT RMF RECORDS ------
//* SHOW CDSI PERFORMANCE STATISTICS BY DAVE RIKER 11/21/84
//* BY MONTHLY, BY DAILY, OR BY PERIOD RUNS YOU HAVE TO SELECT SMFIN
//* SMFIN MUST BE SMF TYPE 70 THRU 79 RECORDS TO REDUCE IO TIME.
//*-----------------------------------------------------------------
//SMFIN DD  DSN=SYS7.SMF.IPO1.DAILY(0),DISP=SHR
//      DD  DSN=SYS7.SMF.IPO1.DAILY(-1),DISP=SHR
//      DD  DSN=SYS7.SMF.IPO1.DAILY(-2),DISP=SHR
//      DD  DSN=SYS7.SMF.IPO1.DAILY(-3),DISP=SHR
//SASRMF  DD DSN=&&RMFTABS,DISP=(,PASS),UNIT=SYSDA,
//           SPACE=(TRK,(200,100))
//*                       +-------------------------------------
//TRACE       DD SYSOUT=M ×CPU ACTIVITY EXCEPTIONS
//RPT70I      DD SYSOUT=M ×CPU ACTIVITY EXCEPTIONS
//RPT71S      DD SYSOUT=M ×STORAGE  EXCEPTIONS
//RPT71P      DD SYSOUT=M ×PAGING ACTIVITY EXECPTIONS
//RPT71SO     DD SYSOUT=M ×SWAPOUTS REASONS/EXCEPTIONS
//RPT72I      DD SYSOUT=M ×WORKLOAD EXCEPTIONS BY TIME
//RPT72PER    DD SYSOUT=M ×WORKLOAD EXCEPTIONS BY PERFGRP/DOM/OBJ
//RPT73CHN    DD SYSOUT=M ×CHANNEL ACTIVITY BY PHY/LOG CHANNEL ID
//*                       ×PAGE/SWAP DSN EXCEPTIONS BY DSNAME
//RPT74VOL    DD SYSOUT=M ×DEVICE EXCEPTIONS BY VOLUME SERIAL
//*                       +-------------------------------------
//SYSIN  DD  *
***********************************************************************
*       THIS SAS PROGRAM GETS THE RMF INFORMATION FROM THE SMF DATA   *
*       SET AND PRODUCES DETAIL PERFORMANCE STATISTICS  FOR CPU ,     *
*       CHANNELS , PAGING , HIGH DEVICE AND WORKLOAD/SERVICE UNITS    *
*       ON A DAILY BASIS                                              *
*                                                                     *
*       MODIFIED 04/22/78 FOR SOCO C.C. J. A. CHAPMAN                 *
*                                                                     *
*       DETAIL WORKLOAD PRINTS ADDED 05/05/78  JAC                    *
*                                                                     *
*       SMF TYPE 70, 71,72,73,74,75,76,77,78,79                       *
*                                                                     *
*       CMS DAILY DATABASE UPDATED                                    *
*                                                                     *
*       MODIFIED 11/16/84 FOR CDSI  BY DAVID O. RIKER                 *
*       1. ADD IBM'S  EXCEPTIONS CALCULATIONS  (RMF V2.4)             *
*       2. LISTINGS EXPANDABLE (TOTALS AVERAGE HIGH LOW ETC)          *
*       3. ARRAY COMPUTE FOR BREAKOUTS ( VOLSER PFGRP DOM OBJ CHANID) *
*                                                                     *
*                                                                     *
*                                                                     *
**********************************************************************;
OPTIONS PS=60 SKIP=0 NODATE S=72 ERROR=3 BLKSIZE=13030 ;
DATA   SASRMF.CPU ( KEEP = DATEX HR HWAIT LWAIT TWAIT HCPUBUSY
              LCPUBUSY TCPUBUSY HAVGRTT LAVGRTT TAVGRTT
              HAVGOTT LAVGOTT TAVGOTT HTOTASID LTOTASID
              TTOTASID HBTHASID LBTHASID TBTHASID TMAXBTCH
              HSTCASID LSTCASID TSTCASID TMAXSTC HTSOASID
              LTSOASID TTSOASID TMAXTSO )
  SASRMF.PAGING ( KEEP = DATEX  HR TSTORAGE HISQA LOSQA TMXSQA
           HICSAF LOCSAF TMXCSAF HICSAP LOCSAP TMXCSAP HIGVIOF
           LOWVIOF TMAXVIOF HTPAGRT LTPAGRT  TTPAGRT HPAGERT
           LPAGERT  TPAGERT HDPAGRT LDPAGRT  TDPAGRT HSWART LSWART
           TSWART HPLSWPIN LPLSWPIN TPLSWPIN HPLSWPOU LPLSWPOU
           TPLSWPOU HPSOCLTT   LPSOCLTT    TPSOCLTT HPSOCLW
           LPSOCLW    TPSOCLW HPSOCDW    LPSOCDW    TPSOCDW HPSOCU
           LPSOCU     TPSOCU HPSCEORV   LPSCEORV   TPSCEORV
           HPSCENQE   LPSCENQE   TPSCENQE HPSOCERQ   LPSOCERQ
           TPSOCERQ HPSCAXSS   LPSCAXSS   TPSCAXSS HPSCRPSS
           LPSCRPSS   TPSCRPSS HPSCTONS   LPSCTONS   TPSCTONS
           HPSOCTW    LPSOCTW    TPSOCTW)
SASRMF.CHANNELS ( KEEP = DATEX HR CXAN HXRT LXRT AXRT HXBSY LXBSY
          AXBSY HXAVG LXAVG AXAVG HXCWS LXCWS AXCWS )
SASRMF.LCHANNEL (KEEP=DATEX HR LCHANX HLCHX LLCHX ALCHX HLQ0DX LLQ0DX
          TLQ0DX HLQ1DX  LLQ1DX TLQ1DX HLQ2DX  LLQ2DX  TLQ2DX
          HLQ3DX  LLQ3DX    TLQ3D HLQ4D  LLQ4D    TLQ4D HLCBSY
          LLCBSYX TLCBSYX HLLBSYX  LLLBSYX TLLBSYX HLUBSYX  LLUBSYX
          TLUBSYX HLDBSYX  LLDBSYX TLDBSYX HFCBSYX  LFCBSYX
          TFCBSYX HFLBSYX  LFLBSYX  TFLBSYX HFUBSYX  LFUBSYX
          TFUBSYX HFDBSYX  LFDBSYX  TFDBSYX)
SASRMF.WORKLOAD ( KEEP =DATEX HR HTOTSRV LTOTSRV ATOTSRV HIOSRV
           LIOSRV AIOSRV HCPUSRV LCPUSRV ACPUSRV HSRBSRV
           LSRBSRV ASRBSRV HMSOSRV LMSOSRV AMSOSRV HTRANS
           AITRANS HRTIME  ARTIME HSPERTRA  ASPERTRA)
SASRMF.PERFGRP (KEEP = DATEX HR PXRFG HXTSV LXTSV AXTSV HXISV
           LXISV AXISV HXCSV LXCSV AXCSV HXSSV LXSSV AXSSV HXMSV LXMSV
           AXMSV HXXSV  AXXSV HXRTM  AXRTM HXPER  AXPER)
SASRMF.DOMAIN (KEEP = DATEX HR DOMY HYTSV LYTSV AYTSV HYISV
           LYISV AYISV HYCSV LYCSV AYCSV HYSSV LYSSV AYSSV
           HYMSV LYMSV AYMSV HYXSV  AYXSV HYRTM  AYRTM HYPER
           AYPER)
SASRMF.OBJECTIV  (KEEP = DATEX HR OBJZ HZTSV LZTSV AZTSV HZISV
           LZISV AZISV HZCSV LZCSV AZCSV HZSSV LZSSV AZSSV
           HZMSV LZMSV AZMSV HZXSV  AZXSV HZRTM  AZRTM HZPER
           AZPER)
SASRMF.PAGEDSN (KEEP= DATEX HR DSNX HPBSYX LPBSYX APBSYX HPAVGX LPAVGX
           APAVGX HPPTX LPPTX APPTX HPARTX LPARTX APARTX HPAVGSX
           LPAVGSX APAVGSX HPBADSX LPBADSX APBADSX)
SASRMF.DEV  ( KEEP = DATEX HR VOLX HDNTX LDNTX ADNTX HBSYBX LBSYBX
          ABSYBX HBSYNX LBSYNX ABSYNX HRDX LRDX ARDX HRAX LRX ARX HARTX
          LARTX AARTX HAVBEX LAVBEX AAVBEX HAVNBX LAVNBX AAVNBX HAQX
          LAQX AAQX);
INFILE SMFIN  END=EOF ;    * INPUT DDNAME ;
LENGTH DEFAULT=5;
RETAIN II 0;
IF EOF THEN GOTO EOFPRT;
PAGE;
*  DEFINITION OF ARRAYS AND RETAINS FOR ALL WORKS                 ;
*   RETAIN VALUES FOR RMF 70 TYPE SECTION                    ;
 RETAIN
 HOUR70 DATE70 SWT70
 HBTHASID LBTHASID TBTHASID HSTCASID LSTCASID TSTCASID
 HTSOASID LTSOASID TTSOASID HTOTASID LTOTASID TTOTASID
 HAVGRTT LAVGRTT TAVGRTT HAVGOTT LAVGOTT TAVGOTT
 HWAIT LWAIT TWAIT HCPUBUSY LCPUBUSY TCPUBUSY REC70;
*   RETAIN VALUES FOR RMF 71 TYPE SECTION                    ;
RETAIN HOUR71 DATE71 SWT71
   NREC71
   TPAGEINS TPAGEOUT TRCLAIMS TADSPSWP TSWAPIN  TSWAPOUT
   TVIOPGIN TVIOPGOU TVIORECL TCOMPGIN TCOMPGOU TCOMRECL
   HPAGEINS HPAGEOUT HRCLAIMS HADSPSWP HSWAPIN  HSWAPOUT
   HVIOPGIN HVIOPGOU HVIORECL HCOMPGIN HCOMPGOU HCOMRECL
   LPAGEINS LPAGEOUT LRCLAIMS LADSPSWP LSWAPIN  LSWAPOUT
   LVIOPGIN LVIOPGOU LVIORECL LCOMPGIN LCOMPGOU LCOMRECL
   HSTORAGE TSTORAGE HISQA LOSQA TMXSQA HICSAF
   LOCSAF TMXCSAF HICSAP LOCSAP TMXCSAP HIGVIOF LOWVIOF
   TMAXVIOF
   HTPAGRT LTPAGRT TTPAGRT HPAGERT LPAGERT TPAGERT HDPAGRT
   LDPAGRT TDPAGRT HSWART LSWART TSWART HPLSWPIN LPLSWPIN
   TPLSWPIN HPLSWPOU LPLSWPOU TPLSWPOU
   HPSOCLTT LPSOCLTT TPSOCLTT HPSOCLW LPSOCLW TPSOCLW HPSOCDW
   LPSOCDW TPSOCDW HPSOCU LPSOCU TPSOCU HPSCEORV LPSCEORV
   TPSCEORV HPSCENQE LPSCENQE TPSCENQE HPSOCERQ LPSOCERQ
   TPSOCERQ HPSCAXSS LPSCAXSS TPSCAXSS HPSCRPSS LPSCRPSS
   TPSCRPSS HPSCTONS LPSCTONS TPSCTONS HPSOCTW LPSOCTW TPSOCTW ;
PAGE;
*   RETAIN VALUES FOR RMF 72 TYPE SECTION                    ;
RETAIN REC72  HOUR72 DATE72 SWT72
HTOTSRV LTOTSRV ATOTSRV HIOSRV LIOSRV AIOSRV HCPUSRV LCPUSRV
ACPUSRV HSRBSRV LSRBSRV ASRBSRV HMSOSRV LMSOSRV AMSOSRV
HTRANS LTRANS AITRANS HRTIME LRTIME ARTIME HSPERTRA LSPERTRA
ASPERTRA ;
*  FOR EACH PERFORMANCE GROUP ID ;
ARRAY PERFG (I) PERFG1-PERFG15;
ARRAY PCNT  (I) PCNT1-PCNT15;
ARRAY HPTSV (I) HPTSV1-HPTSV15;
ARRAY LPTSV (I) LPTSV1-LPTSV15;
ARRAY APTSV (I) APTSV1-APTSV15;
ARRAY HPISV (I) HPISV1-HPISV15;
ARRAY LPISV (I) LPISV1-LPISV15;
ARRAY APISV (I) APISV1-APISV15;
ARRAY HPCSV (I) HPCSV1-HPCSV15;
ARRAY LPCSV (I) LPCSV1-LPCSV15;
ARRAY APCSV (I) APCSV1-APCSV15;
ARRAY HPSSV (I) HPSSV1-HPSSV15;
ARRAY LPSSV (I) LPSSV1-LPSSV15;
ARRAY APSSV (I) APSSV1-APSSV15;
ARRAY HPMSV (I) HPMSV1-HPMSV15;
ARRAY LPMSV (I) LPMSV1-LPMSV15;
ARRAY APMSV (I) APMSV1-APMSV15;
ARRAY HPXSV (I) HPXSV1-HPXSV15;
ARRAY LPXSV (I) LPXSV1-LPXSV15;
ARRAY APXSV (I) APXSV1-APXSV15;
ARRAY HPRTM (I) HPRTM1-HPRTM15;
ARRAY LPRTM (I) LPRTM1-LPRTM15;
ARRAY APRTM (I) APRTM1-APRTM15;
ARRAY HPPER (I) HPPER1-HPPER15;
ARRAY LPPER (I) LPPER1-LPPER15;
ARRAY APPER (I) APPER1-APPER15;
RETAIN
PERFG1-PERFG15 9999;
RETAIN
PCNT1-PCNT15 HPTSV1-HPTSV15 LPTSV1-LPTSV15
APTSV1-APTSV15 HPISV1-HPISV15 LPISV1-LPISV15 APISV1-APISV15
HPCSV1-HPCSV15 LPCSV1-LPCSV15 APCSV1-APCSV15 HPSSV1-HPSSV15
LPSSV1-LPSSV15 APSSV1-APSSV15 HPMSV1-HPMSV15 LPMSV1-LPMSV15
APMSV1-APMSV15 HPXSV1-HPXSV15 LPXSV1-LPXSV15 APXSV1-APXSV15
HPRTM1-HPRTM15 LPRTM1-LPRTM15 APRTM1-APRTM15
HPPER1-HPPER15 LPPER1-LPPER15 APPER1-APPER15 0;
*  FOR EACH DOMAIN ID ;
ARRAY DOM (I) DOM1-DOM10;
ARRAY DCNT  (I) DCNT1-DCNT10;
ARRAY HDTSV (I) HDTSV1-HDTSV10;
ARRAY LDTSV (I) LDTSV1-LDTSV10;
ARRAY ADTSV (I) ADTSV1-ADTSV10;
ARRAY HDISV (I) HDISV1-HDISV10;
ARRAY LDISV (I) LDISV1-LDISV10;
ARRAY ADISV (I) ADISV1-ADISV10;
ARRAY HDCSV (I) HDCSV1-HDCSV10;
ARRAY LDCSV (I) LDCSV1-LDCSV10;
ARRAY ADCSV (I) ADCSV1-ADCSV10;
ARRAY HDSSV (I) HDSSV1-HDSSV10;
ARRAY LDSSV (I) LDSSV1-LDSSV10;
ARRAY ADSSV (I) ADSSV1-ADSSV10;
ARRAY HDMSV (I) HDMSV1-HDMSV10;
ARRAY LDMSV (I) LDMSV1-LDMSV10;
ARRAY ADMSV (I) ADMSV1-ADMSV10;
ARRAY HDXSV (I) HDXSV1-HDXSV10;
ARRAY LDXSV (I) LDXSV1-LDXSV10;
ARRAY ADXSV (I) ADXSV1-ADXSV10;
ARRAY HDRTM (I) HDRTM1-HDRTM10;
ARRAY LDRTM (I) LDRTM1-LDRTM10;
ARRAY ADRTM (I) ADRTM1-ADRTM10;
ARRAY HDPER (I) HDPER1-HDPER10;
ARRAY LDPER (I) LDPER1-LDPER10;
ARRAY ADPER (I) ADPER1-ADPER10;
RETAIN
DOM1-DOM10 9999;
RETAIN
DCNT1-DCNT10 HDTSV1-HDTSV10 LDTSV1-LDTSV10
ADTSV1-ADTSV10 HDISV1-HDISV10 LDISV1-LDISV10 ADISV1-ADISV10
HDCSV1-HDCSV10 LDCSV1-LDCSV10 ADCSV1-ADCSV10 HDSSV1-HDSSV10
LDSSV1-LDSSV10 ADSSV1-ADSSV10 HDMSV1-HDMSV10 LDMSV1-LDMSV10
ADMSV1-ADMSV10 HDXSV1-HDXSV10 LDXSV1-LDXSV10 ADXSV1-ADXSV10
HDRTM1-HDRTM10 LDRTM1-LDRTM10 ADRTM1-ADRTM10
HDPER1-HDPER10 LDPER1-LDPER10 ADPER1-ADPER10 0;
*  FOR EACH OBJECTIVE ID ;
ARRAY OBJ (I) OBJ1-OBJ10;
ARRAY OCNT  (I) OCNT1-OCNT10;
ARRAY HOTSV (I) HOTSV1-HOTSV10;
ARRAY LOTSV (I) LOTSV1-LOTSV10;
ARRAY AOTSV (I) AOTSV1-AOTSV10;
ARRAY HOISV (I) HOISV1-HOISV10;
ARRAY LOISV (I) LOISV1-LOISV10;
ARRAY AOISV (I) AOISV1-AOISV10;
ARRAY HOCSV (I) HOCSV1-HOCSV10;
ARRAY LOCSV (I) LOCSV1-LOCSV10;
ARRAY AOCSV (I) AOCSV1-AOCSV10;
ARRAY HOSSV (I) HOSSV1-HOSSV10;
ARRAY LOSSV (I) LOSSV1-LOSSV10;
ARRAY AOSSV (I) AOSSV1-AOSSV10;
ARRAY HOMSV (I) HOMSV1-HOMSV10;
ARRAY LOMSV (I) LOMSV1-LOMSV10;
ARRAY AOMSV (I) AOMSV1-AOMSV10;
ARRAY HOXSV (I) HOXSV1-HOXSV10;
ARRAY LOXSV (I) LOXSV1-LOXSV10;
ARRAY AOXSV (I) AOXSV1-AOXSV10;
ARRAY HORTM (I) HORTM1-HORTM10;
ARRAY LORTM (I) LORTM1-LORTM10;
ARRAY AORTM (I) AORTM1-AORTM10;
ARRAY HOPER (I) HOPER1-HOPER10;
ARRAY LOPER (I) LOPER1-LOPER10;
ARRAY AOPER (I) AOPER1-AOPER10;
RETAIN
OBJ1-OBJ10 9999;
RETAIN
OCNT1-OCNT10 HOTSV1-HOTSV10 LOTSV1-LOTSV10
AOTSV1-AOTSV10 HOISV1-HOISV10 LOISV1-LOISV10 AOISV1-AOISV10
HOCSV1-HOCSV10 LOCSV1-LOCSV10 AOCSV1-AOCSV10 HOSSV1-HOSSV10
LOSSV1-LOSSV10 AOSSV1-AOSSV10 HOMSV1-HOMSV10 LOMSV1-LOMSV10
AOMSV1-AOMSV10 HOXSV1-HOXSV10 LOXSV1-LOXSV10 AOXSV1-AOXSV10
HORTM1-HORTM10 LORTM1-LORTM10 AORTM1-AORTM10
HOPER1-HOPER10 LOPER1-LOPER10 AOPER1-AOPER10 0 ;
PAGE;
*   RETAIN VALUES FOR RMF 73 TYPE SECTION                    ;
RETAIN HCACRT LCACRT ACACRT REC73P
       HCHBSY LCHBSY ACHBSY HCSAVG LCSAVG ACAVG ;
*  FOR EACH CHANNEL ID ;
ARRAY CHAN    (I)   CHAN1-CHAN6;
ARRAY CCNT    (I)   CCNT1-CCNT6;
ARRAY HCRT    (I)   HCRT1-HCRT6;
ARRAY LCRT    (I)   LCRT1-LCRT6;
ARRAY ACRT    (I)   ACRT1-ACRT6;
ARRAY HCBSY   (I)   HCBSY1-HCBSY6;
ARRAY LCBSY   (I)   LCBSY1-LCBSY6;
ARRAY ACBSY   (I)   ACBSY1-ACBSY6;
ARRAY HCAVG   (I)   HCAVG1-HCAVG6;
ARRAY LCAVG   (I)   LCAVG1-LCAVG6;
ARRAY ACAVX   (I)   ACAVX1-ACAVX6;
ARRAY HSCWS   (I)   HSCWS1-HSCWS6;
ARRAY LSCWS   (I)   LSCWS1-LSCWS6;
ARRAY ASCWS   (I)   ASCWS1-ASCWS6;
RETAIN
CHAN1-CHAN6 ;
RETAIN
CCNT1-CCNT6 HCRT1-HCRT6 LCRT1-LCRT6
ACRT1-ACRT6 HCBSY1-HCBSY6 LCBSY1-LCBSY6 ACBSY1-ACBSY6
HSCWS1-HSCWS6   LSCWS1-LSCWS6   ASCWS1-ASCWS6
HCAVG1-HCAVG6 LCAVG1-LCAVG6 ACAVX1-ACAVX6 0;
* FOR EACH LOGICAL CHANNEL ID ;
ARRAY LCHAN    (I)   LCHAN1-LCHAN6;
ARRAY LCCNT    (I)   LCCNT1-LCCNT6;
ARRAY HLCH     (I)   HLCH1-HLCH6;
ARRAY LLCH     (I)   LLCH1-LLCH6;
ARRAY ALCH     (I)   ALCH1-ALCH6;
ARRAY HLQ0D    (I)   HLQ0D1-HLQ0D6;
ARRAY LLQ0D    (I)   LLQ0D1-LLQ0D6;
ARRAY TLQ0D    (I)   TLQ0D1-TLQ0D6;
ARRAY HLQ1D    (I)   HLQ1D1-HLQ1D6;
ARRAY LLQ1D    (I)   LLQ1D1-LLQ1D6;
ARRAY TLQ1D    (I)   TLQ1D1-TLQ1D6;
ARRAY HLQ2D    (I)   HLQ2D1-HLQ2D6;
ARRAY LLQ2D    (I)   LLQ2D1-LLQ2D6;
ARRAY TLQ2D    (I)   TLQ2D1-TLQ2D6;
ARRAY HLQ3D    (I)   HLQ3D1-HLQ3D6;
ARRAY LLQ3D    (I)   LLQ3D1-LLQ3D6;
ARRAY TLQ3D    (I)   TLQ3D1-TLQ3D6;
ARRAY HLQ4D    (I)   HLQ4D1-HLQ4D6;
ARRAY LLQ4D    (I)   LLQ4D1-LLQ4D6;
ARRAY TLQ4D    (I)   TLQ4D1-TLQ4D6;
ARRAY HLCBSY   (I)   HLCBSY1-HLCBSY6;
ARRAY LLCBSY   (I)   LLCBSY1-LLCBSY6;
ARRAY TLCBSY   (I)   TLCBSY1-TLCBSY6;
ARRAY HLLBSY   (I)   HLLBSY1-HLLBSY6;
ARRAY LLLBSY   (I)   LLLBSY1-LLLBSY6;
ARRAY TLLBSY   (I)   TLLBSY1-TLLBSY6;
ARRAY HLUBSY   (I)   HLUBSY1-HLUBSY6;
ARRAY LLUBSY   (I)   LLUBSY1-LLUBSY6;
ARRAY TLUBSY   (I)   TLUBSY1-TLUBSY6;
ARRAY HLDBSY   (I)   HLDBSY1-HLDBSY6;
ARRAY LLDBSY   (I)   LLDBSY1-LLDBSY6;
ARRAY TLDBSY   (I)   TLDBSY1-TLDBSY6;
ARRAY HFCBSY   (I)   HFCBSY1-HFCBSY6;
ARRAY LFCBSY   (I)   LFCBSY1-LFCBSY6;
ARRAY TFCBSY   (I)   TFCBSY1-TFCBSY6;
ARRAY HFLBSY   (I)   HFLBSY1-HFLBSY6;
ARRAY LFLBSY   (I)   LFLBSY1-LFLBSY6;
ARRAY TFLBSY   (I)   TFLBSY1-TFLBSY6;
ARRAY HFUBSY   (I)   HFUBSY1-HFUBSY6;
ARRAY LFUBSY   (I)   LFUBSY1-LFUBSY6;
ARRAY TFUBSY   (I)   TFUBSY1-TFUBSY6;
ARRAY HFDBSY   (I)   HFDBSY1-HFDBSY6;
ARRAY LFDBSY   (I)   LFDBSY1-LFDBSY6;
ARRAY TFDBSY   (I)   TFDBSY1-TFDBSY6;
RETAIN LCHAN1-LCHAN6 9999 LCCNT1-LCCNT6
       HLCH1-HLCH6 LLCH1-LLCH6 ALCH1-ALCH6
HLQ0D1-HLQ0D6 LLQ0D1-LLQ0D6 TLQ0D1-TLQ0D6 HLQ1D1-HLQ1D6
LLQ1D1-LLQ1D6 TLQ1D1-TLQ1D6 HLQ2D1-HLQ2D6 LLQ2D1-LLQ2D6
TLQ2D1-TLQ2D6 HLQ3D1-HLQ3D6 LLQ3D1-LLQ3D6 TLQ3D1-TLQ3D6
HLQ4D1-HLQ4D6 LLQ4D1-LLQ4D6 TLQ4D1-TLQ4D6
HLCBSY1-HLCBSY6 LLCBSY1-LLCBSY6 TLCBSY1-TLCBSY6
HLLBSY1-HLLBSY6 LLLBSY1-LLLBSY6 TLLBSY1-TLLBSY6
HLUBSY1-HLUBSY6 LLUBSY1-LLUBSY6 TLUBSY1-TLUBSY6
HLDBSY1-HLDBSY6 LLDBSY1-LLDBSY6 TLDBSY1-TLDBSY6
HFCBSY1-HFCBSY6 LFCBSY1-LFCBSY6 TFCBSY1-TFCBSY6
HFLBSY1-HFLBSY6 LFLBSY1-LFLBSY6 TFLBSY1-TFLBSY6
HFUBSY1-HFUBSY6 LFUBSY1-LFUBSY6 TFUBSY1-TFUBSY6
HFDBSY1-HFDBSY6 LFDBSY1-LFDBSY6 TFDBSY1-TFDBSY6 0;
RETAIN HOUR73 DATE73 SWT73;
PAGE;
*   RETAIN VALUES FOR RMF 74 TYPE SECTION                    ;
RETAIN
TDNTRDY TDART TDAVGBE TDAVGNBE TDVBSYBE TDVBSYNB TDRD TDR
TDAQ HDNTRDY HDART HDAVGBE HDAVGNBE HDVBSYBE HDVBSYNB HDRD
HDR HDAQ LDNTRDY LDART LDAVGBE LDAVGNBE LDVBSYBE LDVBSYNB
LDRD LDR LDAQ ;
ARRAY VOL     (I)  $6 VOL1-VOL60;
ARRAY VCNT    (I)  VCNT1-VCNT60;
ARRAY HDNT    (I)  HDNT1-HDNT60;
ARRAY LDNT    (I)  LDNT1-LDNT60;
ARRAY ADNT    (I)  ADNT1-ADNT60;
ARRAY HBSYB   (I)  HBSYB1-HBSYB60;
ARRAY LBSYB   (I)  LBSYB1-LBSYB60;
ARRAY ABSYB   (I)  ABSYB1-ABSYB60;
ARRAY HBSYN   (I)  HBSYN1-HBSYN60;
ARRAY LBSYN   (I)  LBSYN1-LBSYN60;
ARRAY ABSYN   (I)  ABSYN1-ABSYN60;
ARRAY HRD     (I)  HRD1-HRD60;
ARRAY LRD     (I)  LRD1-LRD60;
ARRAY ARD     (I)  ARD1-ARD60;
ARRAY HRA     (I)  HRA1-HRA60;
ARRAY LR      (I)  LR1-LR60;
ARRAY AR      (I)  AR1-AR60;
ARRAY HART    (I)  HART1-HART60;
ARRAY LART    (I)  LART1-LART60;
ARRAY AART    (I)  AART1-AART60;
ARRAY HAVBE   (I)  HAVBE1-HAVBE60;
ARRAY LAVBE   (I)  LAVBE1-LAVBE60;
ARRAY AAVBE   (I)  AAVBE1-AAVBE60;
ARRAY HAVNB   (I)  HAVNB1-HAVNB60;
ARRAY LAVNB   (I)  LAVNB1-LAVNB60;
ARRAY AAVNB   (I)  AAVNB1-AAVNB60;
ARRAY HAQ     (I)  HAQ1-HAQ60;
ARRAY LAQ     (I)  LAQ1-LAQ60;
ARRAY AAQ     (I)  AAQ1-AAQ60;
RETAIN
VOL1-VOL60  ' ' VCNT1-VCNT60 HDNT1-HDNT60 LDNT1-LDNT60
ADNT1-ADNT60 HBSYB1-HBSYB60 LBSYB1-LBSYB60 ABSYB1-ABSYB60
HBSYN1-HBSYN60 LBSYN1-LBSYN60 ABSYN1-ABSYN60 HRD1-HRD60
LRD1-LRD60 ARD1-ARD60 HRA1-HRA60 LR1-LR60 AR1-AR60
HART1-HART60 LART1-LART60 AART1-AART60 HAVBE1-HAVBE60
LAVBE1-LAVBE60 AAVBE1-AAVBE60 HAVNB1-HAVNB60 LAVNB1-LAVNB60
AAVNB1-AAVNB60 HAQ1-HAQ60 LAQ1-LAQ60 AAQ1-AAQ60 0;
RETAIN HOUR74 DATE74 SWT74;
PAGE;
*   RETAIN VALUES FOR RMF 75 TYPE SECTION                    ;
*  FOR EACH PAGE/SWAP DATASET ;
ARRAY DSN     (I) $44 DSN1-DSN6;
ARRAY DSCNT   (I) DSCNT1-DSCNT6;
ARRAY LPBSY   (I) LPBSY1-LPBSY6;
ARRAY LPAVG   (I) LPAVG1-LPAVG6;
ARRAY LPPT    (I) LPPT1-LPPT6;
ARRAY LPART   (I) LPART1-LPART6;
ARRAY LPAVGS  (I) LPAVGS1-LPAVGS6;
ARRAY LPBADS  (I) LPBADS1-LPBADS6;
ARRAY HPBSY   (I) HPBSY1-HPBSY6;
ARRAY HPAVG   (I) HPAVG1-HPAVG6;
ARRAY HPPT    (I) HPPT1-HPPT6;
ARRAY HPART   (I) HPART1-HPART6;
ARRAY HPAVGS  (I) HPAVGS1-HPAVGS6;
ARRAY HPBADS  (I) HPBADS1-HPBADS6;
ARRAY APBSY   (I) APBSY1-APBSY6;
ARRAY APAVG   (I) APAVG1-APAVG6;
ARRAY APPT    (I) APPT1-APPT6;
ARRAY APART   (I) APART1-APART6;
ARRAY APAVGS  (I) APAVGS1-APAVGS6;
ARRAY APBADS  (I) APBADS1-APBADS6;
RETAIN
DSN1-DSN6 ' ' DSCNT1-DSCNT6 LPBSY1-LPBSY6 LPAVG1-LPAVG6
LPPT1-LPPT6 LPART1-LPART6 LPAVGS1-LPAVGS6
LPBADS1-LPBADS6 HPBSY1-HPBSY6 HPAVG1-HPAVG6 HPPT1-HPPT6
HPART1-HPART6 HPAVGS1-HPAVGS6 HPBADS1-HPBADS6
APBSY1-APBSY6 APAVG1-APAVG6 APPT1-APPT6 APART1-APART6
APAVGS1-APAVGS6 APBADS1-APBADS6 0;
RETAIN HOUR75 DATE75 SWT75;
PAGE;
* ------------  READ RMF/SMF RECORDS -----------------------------  ;
INPUT @2 REC_ID  PIB1.  @ ;  * GET THE RECORD ID   ;
IF REC_ID<70 OR REC_ID>75 THEN DELETE;       * REMOVE NON-RMF RECORDS;
IF _ERROR_ THEN DELETE; _ERROR_ =0;  *BAD SMF ,FILE RMF ,PUT _INFILE_ ;
INPUT @14 CPU_ID $1.   @17 TIME PD4.  YEAR $2.   DATE   PD2.
@21 DATEJ PD4.
RMFDPK PD4. @25 DURATION PD4.3 @ ;     IF DATE = . THEN DELETE ;
DAY = MOD(DATE,1000) ; KPDATE = MOD (DATE,7) ;
DATEX=DATEJUL(DATEJ);
*IF KPDATE = 0 OR KPDATE = 1 THEN DELETE ; * DELETE WEEKENDS ;
*    CALCULATE RMF DURATION AND SHIFT ;
RMFMIN = INT ( RMFDPK / 100000 )  ;
*  CALCULATION IN SECONDS;
   RMFDUR= 60*FLOOR(DURATION/100) +MOD(DURATION,100);
HOUR   =     ( TIME / 10000 )     ;
HR     = INT ( TIME / 10000 )     ;
SHIFT  = INT ( HR / 8 ) ;         IF SHIFT=0  THEN SHIFT=3 ;
****       ;
****       ;
** SELECT HOURS **;
FILE TRACE PRINT NOTITLES; PUT HR= TIME=; FILE PRINT NOTITLES;
* NOTE:HR=0 WILL CONFUSE PLOT ROUTINE; MUST BE HR=1 THRU 24 FOR THAT;
* IF HR>6 AND HR<18 THEN GOTO HEAD_OUT;* ELSE DELETE;* SELECT DAY;
IF HR>0 AND HR<25 THEN GOTO HEAD_OUT; ELSE DELETE;* COLLECT ALL;
HEAD_OUT: ;
** ------ SPLIT OUT EACH RMF SEPARATE RECORD TYPE  -------------**;
IF REC_ID = 70 THEN GOTO TYPE70               ; * CPU      RECORD ;
IF REC_ID = 71 THEN GOTO TYPE71               ; * PAGING   RECORD ;
IF REC_ID = 72 THEN GOTO TYPE72               ; * WORKLOAD RECORD ;
IF REC_ID = 73 THEN GOTO TYPE73               ; * CHANNELS RECORD ;
IF REC_ID = 74 THEN GOTO TYPE74               ; * DEVICES  RECORD ;
IF REC_ID = 75 THEN GOTO TYPE75               ; * P/S DSN  RECORD ;
DELETE;
PAGE;
* AT EOF,   PRINT TOTALS AND HIGH LOW AVG REPORTS .               ;
EOFPRT:
IF EOF THEN DO; NIL=.;
*       SUMMARY OF CPU ACTIVITY                                   ;
TWAIT=TWAIT/REC70;
TCPUBUSY=TCPUBUSY/REC70;
TAVGRTT=TAVGRTT/REC70;
TAVGOTT=TAVGOTT/REC70;
TTOTASID=TTOTASID/REC70;
TBTHASID=TBTHASID/REC70;
TSTCASID=TSTCASID/REC70;
TTSOASID=TTSOASID/REC70;
OUTPUT SASRMF.CPU;
*---------------- DETAILS REPORTS  AVERAGE PER INTERVIAL --------- ;
APAGEINS=TPAGEINS/NREC71;
APAGEOUT=TPAGEOUT/NREC71;
ARCLAIMS=TRCLAIMS/NREC71;
AADSPSWP=TADSPSWP/NREC71;
ASWAPIN =TSWAPIN /NREC71;
ASWAPOUT=TSWAPOUT/NREC71;
AVIOPGIN=TVIOPGIN/NREC71;
AVIOPGOU=TVIOPGOU/NREC71;
AVIORECL=TVIORECL/NREC71;
ACOMPGIN=TCOMPGIN/NREC71;
ACOMPGOU=TCOMPGOU/NREC71;
ACOMRECL=TCOMRECL/NREC71;
* STORAGE ANALYSIS REPORT    ;
TSTORAGE=TSTORAGE/NREC71;
TMXSQA  = TMXSQA/NREC71;
TMXCSAF = TMXCSAF/NREC71;
TMXCSAP = TMXCSAP/NREC71;
TMAXVIOF= TMAXVIOF/NREC71;
* PAGING RATE REPORT         ;
TTPAGRT=TTPAGRT/  NREC71;
TPAGERT=TPAGERT/  NREC71;
TDPAGRT=TDPAGRT/  NREC71;
TSWART=TSWART/    NREC71;
TPLSWPIN=TPLSWPIN/NREC71;
TPLSWPOU=TPLSWPOU/NREC71;
* SWAP-OUT PER SECOND REASONS   HIGH LOW AVG VALUES;
TPSOCLTT  =TPSOCLTT  /NREC71;
TPSOCLW   =TPSOCLW   /NREC71;
TPSOCDW   =TPSOCDW   /NREC71;
TPSOCU    =TPSOCU    /NREC71;
TPSCEORV  =TPSCEORV  /NREC71;
TPSCENQE  =TPSCENQE  /NREC71;
TPSOCERQ  =TPSOCERQ  /NREC71;
TPSCAXSS  =TPSCAXSS  /NREC71;
TPSCRPSS  =TPSCRPSS  /NREC71;
TPSCTONS  =TPSCTONS  /NREC71;
TPSOCTW   =TPSOCTW   /NREC71;
OUTPUT SASRMF.PAGING;
DO OVER PERFG;
IF PERFG ^= 9999 THEN DO;
IF PCNT ^= 0 THEN DO;
APTSV=APTSV/PCNT;
APISV=APISV/PCNT;
APCSV=APCSV/PCNT;
APSSV=APSSV/PCNT;
APMSV=APMSV/PCNT;
APXSV=APXSV/PCNT;
APRTM=APRTM/PCNT;
APPER=APPER/PCNT;
PXRFG   = PERFG  ; HXTSV   = HPTSV  ; LXTSV   = LPTSV  ;
AXTSV   = APTSV  ; HXISV   = HPISV  ; LXISV   = LPISV  ;
AXISV   = APISV  ; HXCSV   = HPCSV  ; LXCSV   = LPCSV  ;
AXCSV   = APCSV  ; HXSSV   = HPSSV  ; LXSSV   = LPSSV  ;
AXSSV   = APSSV  ; HXMSV   = HPMSV  ; LXMSV   = LPMSV  ;
AXMSV   = APMSV  ; HXXSV   = HPXSV  ; AXXSV   = APXSV  ;
HXRTM   = HPRTM  ; AXRTM   = APRTM  ; HXPER   = HPPER  ;
AXPER   = APPER  ;
OUTPUT SASRMF.PERFGRP;
 END;
 END;
END;
DO OVER DOM;
IF DOM ^= 9999 THEN DO;
IF DCNT ^= 0 THEN DO;
ADTSV=ADTSV/DCNT;
ADISV=ADISV/DCNT;
ADCSV=ADCSV/DCNT;
ADSSV=ADSSV/DCNT;
ADMSV=ADMSV/DCNT;
ADXSV=ADXSV/DCNT;
ADRTM=ADRTM/DCNT;
ADPER=ADPER/DCNT;
DOMY   =  DOM    ; HYTSV  =  HDTSV  ; LYTSV  =  LDTSV  ;
AYTSV  =  ADTSV  ; HYISV  =  HDISV  ; LYISV  =  LDISV  ;
AYISV  =  ADISV  ; HYCSV  =  HDCSV  ; LYCSV  =  LDCSV  ;
AYCSV  =  ADCSV  ; HYSSV  =  HDSSV  ; LYSSV  =  LDSSV  ;
AYSSV  =  ADSSV  ; HYMSV  =  HDMSV  ; LYMSV  =  LDMSV  ;
AYMSV  =  ADMSV  ; HYXSV  =  HDXSV  ; AYXSV  =  ADXSV  ;
HYRTM  =  HDRTM  ; AYRTM  =  ADRTM  ; HYPER  =  HDPER  ;
AYPER  =  ADPER  ;
OUTPUT SASRMF.DOMAIN;
END; END; END;
DO OVER OBJ;
IF OBJ ^= 9999 THEN DO;
IF OCNT ^= 0 THEN DO;
AOTSV=AOTSV/OCNT;
AOISV=AOISV/OCNT;
AOCSV=AOCSV/OCNT;
AOSSV=AOSSV/OCNT;
AOMSV=AOMSV/OCNT;
AOXSV=AOXSV/OCNT;
AORTM=AORTM/OCNT;
AOPER=AOPER/OCNT;
OBJZ   =  OBJ   ; HZTSV  =  HOTSV ; LZTSV  =  LOTSV ;
AZTSV =  AOTSV ; HZISV  =  HOISV ; LZISV  =  LOISV ;
AZISV  = AOISV ; HZCSV  =  HOCSV ; LZCSV  =  LOCSV ;
AZCSV  =  AOCSV ; HZSSV  =  HOSSV ; LZSSV  =  LOSSV ;
AZSSV  =  AOSSV ; HZMSV  =  HOMSV ; LZMSV  =  LOMSV ;
AZMSV  =  AOMSV ; HZXSV =  HOXSV ; AZXSV  =  AOXSV ;
HZRTM  =  HORTM ; AZRTM  = AORTM ; HZPER  =  HOPER ;
AZPER  =  AOPER ;
OUTPUT SASRMF.OBJECTIV;
END; END; END;
ATOTSRV =ATOTSRV/REC72;
AIOSRV =AIOSRV/REC72;
ACPUSRV =ACPUSRV/REC72;
ASRBSRV =ASRBSRV/REC72;
AMSOSRV =AMSOSRV/REC72;
AITRANS =AITRANS/REC72;
ARTIME =ARTIME/REC72;
ASPERTRA=ASPERTRA/REC72;
OUTPUT SASRMF.WORKLOAD;
DO OVER CHAN;
IF CCNT ^= 0 THEN DO;
IF CHAN ^= . THEN DO;
ACRT=ACRT/CCNT;
ACBSY=ACBSY/CCNT;
ACAVG=ACAVG/CCNT;
ASCWS=ASCWS/CCNT;
CXAN   =  CHAN   ; HXRT   =  HCRT   ; LXRT   =  LCRT   ;
AXRT   =  ACRT   ; HXBSY  =  HCBSY  ; LXBSY  =  LCBSY  ;
AXBSY  =  ACBSY  ; HXAVG  =  HCAVG  ; LXAVG  =  LCAVG  ;
AXAVG  =  ACAVG  ; HXCWS  =  HSCWS  ; LXCWS  =  LSCWS  ;
AXCWS  =  ASCWS  ;
OUTPUT SASRMF.CHANNELS;
END; END; END;
DO OVER LCHAN;
IF LCCNT ^= 0 THEN DO;
IF LCHAN ^= 9999 THEN DO;
ALCH=ALCH/LCCNT;
TLQ0D   =TLQ0D   /LCCNT;
TLQ1D   =TLQ1D   /LCCNT;
TLQ2D   =TLQ2D   /LCCNT;
TLQ3D   =TLQ3D   /LCCNT;
TLQ4D   =TLQ4D   /LCCNT;
TLCBSY  =TLCBSY  /LCCNT;
TLLBSY  =TLLBSY  /LCCNT;
TLUBSY  =TLUBSY  /LCCNT;
TLDBSY  =TLDBSY  /LCCNT;
TFCBSY  =TFCBSY  /LCCNT;
TFLBSY  =TFLBSY  /LCCNT;
TFUBSY  =TFUBSY  /LCCNT;
TFDBSY  =TFDBSY  /LCCNT;
LCHANX  = LCHAN   ; HLCHX   = HLCH    ; LLCHX   = LLCH    ;
ALCHX   = ALCH    ; HLQ0DX  = HLQ0D   ; LLQ0DX  = LLQ0D   ;
LQ0DX   = LQ0D    ; HLQ1DX  = HLQ1D   ; LLQ1DX  = LLQ1D   ;
TLQ1DX  = TLQ1D   ; HLQ2DX  = HLQ2D   ; LLQ2DX  = LLQ2D   ;
TLQ2DX  = TLQ2D   ; LQ3DX   = LQ3D    ; LLQ3DX  = LLQ3D   ;
TLQ3DX  = TLQ3D   ; HLQ4DX  = HLQ4D   ; LLQ4DX  = LLQ4D   ;
TLQ4DX  = TLQ4D   ; HLCBSYX = HLCBSY  ; LCBSYX  = LCBSY   ;
TLCBSYX = TLCBSY  ; HLLBSYX = HLLBSY  ; LLLBSYX = LLLBSY  ;
TLLBSYX = TLLBSY  ; HLUBSYX = HLUBSY  ; LLUBSYX = LLUBSY  ;
TLUBSYX  = TLUBSY   ; HLDBSYX = HLDBSY  ; LLDBSYX = LLDBSY  ;
TLDBSYX = TLDBSY  ; HFCBSYX = HFCBSY  ; LFCBSYX = LFCBSY  ;
TFCBSYX  = TFCBSY   ; HFLBSYX = HFLBSY  ; LFLBSYX = LFLBSY  ;
TFLBSYX = TFLBSY  ; HFUBSYX = HFUBSY  ; LFUBSYX = LFUBSY  ;
TFUBSYX  = TFUBSY   ; HFDBSYX = HFDBSY  ; LFDBSYX = LFDBSY  ;
TFDBSYX = TFDBSY  ;
OUTPUT SASRMF.LCHANNEL ;
END; END; END;
DO OVER DSN;
IF DSN ^= ' ' THEN DO;
IF DSCNT ^= 0 THEN DO;
APBSY   =APBSY/DSCNT;
APAVG   =APAVG/DSCNT;
APPT    =APPT/DSCNT;
APART   =APART/DSCNT;
APAVGS  =APAVGS/DSCNT;
APBADS  =APBADS/DSCNT;
DSNX    =  DSN   ; HPBSYX  =  HPBSY ; LPBSYX  =  LPBSY ;
APBSYX =  APBSY ; HPAVGX  =  HPAVG ; LPAVGX  =  LPAVG ;
APAVGX  = APAVG ; HPPTX   =  HPPT  ; LPPTX   =  LPPT  ;
APPTX   =  APPT ; HPARTX  =  HPART ; LPARTX  =  LPART ;
APARTX  =  APART ; HPAVGSX =  HPAVGS; LPAVGSX =  LPAVGS;
APAVGSX =  APAVGS; HPBADSX =  HPBADS; LPBADSX =  LPBADS;
APBADSX =  APBADS;
OUTPUT SASRMF.PAGEDSN ;
END;
END; END;
DO OVER VOL;
IF VCNT ^= 0 THEN DO;
IF VOL^=' ' THEN DO;
ADNT =ADNT/VCNT;
ABSYB =ABSYB/VCNT;
ABSYN =ABSYN/VCNT;
ARD =ARD/VCNT;
AR =AR/VCNT;
AART =AART/VCNT;
AAVBE =AAVBE/VCNT;
AAVNB =AAVNB/VCNT;
AAQ =AAQ/VCNT;
VOLX   =   VOL    ; HDNTX  =   HDNT   ; LDNTX  =   LDNT ;
ADNTX  =   ADNT   ; HBSYBX =   HBSYB  ; LBSYBX =   LBSYB ;
ABSYBX  =  ABSYB   ; HBSYNX =   HBSYN  ; LBSYNX =   LBSYN ;
ABSYNX =   ABSYN  ; HRDX=HRD; LRDX=LRD; ARDX=ARD; HRA=HRA;
LRX =LR;  ARX =AR ; HARTX  =   HART   ; LARTX   = LART    ;
AARTX  =   AART   ; HAVBEX =   HAVBE  ; LAVBEX = LAVBE  ;
AAVBEX =   AAVBE  ; HAVNBX =   HAVNB  ; LAVNBX = LAVNB  ;
AAVNBX =   AAVNB  ; HAQX   =   HAQ    ; AAQX    = AAQ     ;
OUTPUT SASRMF.DEV;
END;
END;
END;
*END OF EOF SERIES;
END;
RETURN  ;
PAGE;
*--------------------     CPU RECORD  --------------------------- ;
TYPE70:
IF HR ^= HOUR70 THEN DO;
IF SWT70 = 1 THEN DO;
FILE RPT70I HEADER=H70I NOTITLES PRINT;
 TBTHASID=TBTHASID/REC70;
 TSTCASID=TSTCASID/REC70;
 TTSOASID=TTSOASID/REC70;
 TTOTASID=TTOTASID/REC70;
 TAVGRTT=TAVGRTT/REC70;
 TAVGOTT=TAVGOTT/REC70;
 TWAIT=TWAIT/REC70;
 TCPUBUSY=TCPUBUSY/REC70;
 TMAXBTCH=TMAXBTCH/REC70;
 TMAXSTC=TMAXSTC/REC70;
 TMAXTSO=TMAXTSO/REC70;
 OUTPUT SASRMF.CPU;
TMAXBTCH=0; TMAXSTC=0; TMAXTSO=0;
HTSOASID  = 0; LTSOASID  = 0; TTSOASID  = 0; HTOTASID  = 0;
LTOTASID  = .; TTOTASID  = .; HAVGRTT   = 0; LAVGRTT   = .;
TAVGRTT   = 0; HAVGOTT   = 0; LAVGOTT   = .; TAVGOTT   = 0;
HWAIT     = 0; LWAIT     = .; TWAIT     = 0; HCPUBUSY  = 0;
LCPUBUSY  = .; TCPUBUSY  = 0; REC70     = 0;
END;
SWT70=1;
DATE70=DATEX;
HOUR70=HR;
END;
PTR=15;
INPUT @PTR COMSIZ PIB2. +16 SAMPLES PIB4. @;
PTR=PTR+COMSIZ;
INPUT @PTR CPUCSECT PIB2. NO_CPU PIB2. SIZE_CPU PIB2. CPUDSECT PIB2. @;
   PTR = PTR+CPUCSECT ;                    COUNT = 1      ;
   CPUSAV = CPU_ID   ;
   APTR = PTR+(SIZE_CPU*NO_CPU);
INPUT
 @APTR +4   RTT PIB4.
 @APTR +132 OTT PIB4.
 @APTR +242 MAXBATCH PIB2. BATCH PIB4.
       +50  MAXSTC PIB2.   STC PIB4.
       +50  MAXTSO PIB2.   TSO PIB4. @;
 BTH_ASID=BATCH/SAMPLES;  STC_ASID=STC/SAMPLES;  TSO_ASID=TSO/SAMPLES;
 TOT_ASID=(BATCH + STC + TSO) / SAMPLES ;
 TMAXBTCH+MAXBATCH;
 TMAXSTC+MAXSTC;
 TMAXTSO+MAXTSO;
 AVGRTT=RTT/SAMPLES; AVGOTT=OTT/SAMPLES;
 HBTHASID=MAX(HBTHASID,BTH_ASID);
 LBTHASID=MIN(LBTHASID,BTH_ASID);
 TBTHASID+BTH_ASID;
 HSTCASID=MAX(HSTCASID,STC_ASID);
 LSTCASID=MIN(LSTCASID,STC_ASID);
 TSTCASID+STC_ASID;
 HTSOASID=MAX(HTSOASID,TSO_ASID);
 LTSOASID=MIN(LTSOASID,TSO_ASID);
 TTSOASID+TSO_ASID;
 HTOTASID=MAX(HTOTASID,TOT_ASID);
 LTOTASID=MIN(LTOTASID,TOT_ASID);
 TTOTASID+TOT_ASID;
 HAVGRTT=MAX(HAVGRTT,AVGRTT);
 LAVGRTT=MIN(LAVGRTT,AVGRTT);
 TAVGRTT+AVGRTT;
 HAVGOTT=MAX(HAVGOTT,AVGOTT);
 LAVGOTT=MIN(LAVGOTT,AVGOTT);
 TAVGOTT+AVGOTT;
GETCPU:   INPUT @PTR (WAIT1 WAIT2) (PIB4.6)  +4 CPUID PIB2. @;
   CPU_ID = CPUSAV   ;
   WAIT=WAIT1*1048576+WAIT2/4096;
   WAIT=100*(WAIT/RMFDUR)+.005; * WAIT TIME PERCENTAGE ;
   IF CPU_ID = '9' AND CPUID = 0 THEN CPU_ID = '0' ;
   CPU_BUSY  =  100*(1-WAIT/RMFDUR)+.005 ;
IF SAMPLES=0 THEN SAMPLES=.1 ;
HWAIT=MAX(HWAIT,WAIT);
LWAIT=MIN(LWAIT,WAIT);
TWAIT+WAIT;
HCPUBUSY=MAX(HCPUBUSY,CPU_BUSY);
LCPUBUSY=MIN(LCPUBUSY,CPU_BUSY);
TCPUBUSY+CPU_BUSY;
REC70+1;
IF CPU_BUSY LT 0 THEN DELETE ; IF CPU_BUSY GT 1. THEN DELETE ;
IF COUNT GE NO_CPU THEN RETURN    ;
COUNT = COUNT + 1  ;
PTR = PTR + SIZE_CPU   ;
GOTO GETCPU  ;
PAGE;
* ------------- PAGING RECORD ---------------------------         ;
TYPE71:
IF HR ^= HOUR71 THEN DO; NIL=.;
IF SWT72 = 1 THEN DO;
*---------------- STORAGE ANALYSIS REPORT -----------------------    ;
TSTORAGE=TSTORAGE/NREC71;
TMXSQA  = TMXSQA/NREC71;
TMXCSAF = TMXCSAF/NREC71;
TMXCSAP = TMXCSAP/NREC71;
TMAXVIOF= TMAXVIOF/NREC71;
*-----------------  PAGING RATE REPORT -----------------------        ;
TTPAGRT  =TTPAGRT/NREC71;
TPAGERT  =TPAGERT/NREC71;
TDPAGRT  =TDPAGRT/NREC71;
TSWART   =TSWART/NREC71;
TPLSWPIN =TPLSWPIN/NREC71;
TPLSWPOU =TPLSWPOU/NREC71;
*----- SWAP-OUT PER SECOND REASONS : HIGH LOW AVG   VALUES------;
TPSOCLTT  =TPSOCLTT/NREC71;
TPSOCLW   =TPSOCLW/NREC71 ;
TPSOCDW   =TPSOCDW /NREC71;
TPSOCU    =TPSOCU/NREC71 ;
TPSCEORV  =TPSCEORV/NREC71;
TPSCENQE  =TPSCENQE/NREC71;
TPSOCERQ  =TPSOCERQ/NREC71;
TPSCAXSS  =TPSCAXSS/NREC71;
TPSCRPSS  =TPSCRPSS/NREC71;
TPSCTONS  =TPSCTONS/NREC71;
TPSOCTW   =TPSOCTW/NREC71 ;
OUTPUT SASRMF.PAGING;
NREC71    =0; TPAGEINS  =0; TPAGEOUT  =0; TRCLAIMS  =0;
TADSPSWP  =0; TSWAPIN   =0; TSWAPOUT  =0; TVIOPGIN  =0;
TVIOPGOU  =0; TVIORECL  =0; TCOMPGIN  =0; TCOMPGOU  =0;
TCOMRECL  =0; HPAGEINS  =0; HPAGEOUT  =0; HRCLAIMS  =0;
HADSPSWP  =0; HSWAPIN   =0; HSWAPOUT  =0; HVIOPGIN  =0;
HVIOPGOU  =0; HVIORECL  =0; HCOMPGIN  =0; HCOMPGOU  =0;
HCOMRECL  =0; LPAGEINS  =.; LPAGEOUT  =.; LRCLAIMS  =.;
LADSPSWP  =.; LSWAPIN   =.; LSWAPOUT  =.; LVIOPGIN  =.;
LVIOPGOU  =.; LVIORECL  =.; LCOMPGIN  =.; LCOMPGOU  =.;
LCOMRECL  =.; HSTORAGE  =0; TSTORAGE  =0; HISQA     =0;
LOSQA     =.; TMXSQA    =0; HICSAF    =0; LOCSAF    =.;
TMXCSAF   =0; HICSAP    =0; LOCSAP    =.; TMXCSAP   =0;
HIGVIOF   =0; LOWVIOF   =.; TMAXVIOF  =0;
HPSOCLTT  =0; LPSOCLTT  =.; TPSOCLTT  =0; HPSOCLW   =0;
LPSOCLW   =.; TPSOCLW   =0; HPSOCDW   =0; LPSOCDW   =.;
TPSOCDW   =0; HPSOCU    =0; LPSOCU    =.; TPSOCU    =0;
HPSCEORV  =0; LPSCEORV  =.; TPSCEORV  =0; HPSCENQE  =0;
LPSCENQE  =.; TPSCENQE  =0; HPSOCERQ  =0; LPSOCERQ  =.;
TPSOCERQ  =0; HPSCAXSS  =0; LPSCAXSS  =.; TPSCAXSS  =0;
HPSCRPSS  =0; LPSCRPSS  =.; TPSCRPSS  =0; HPSCTONS  =0;
LPSCTONS  =.; TPSCTONS  =0; HPSOCTW   =0; LPSOCTW   =.;
TPSOCTW   =0;
HTPAGRT   =0; LTPAGRT   =.; TTPAGRT   =0; HPAGERT   =0;
LPAGERT   =.; TPAGERT   =0; HDPAGRT   =0; LDPAGRT   =.;
TDPAGRT   =0; HSWART    =0; LSWART    =.; TSWART    =0;
HPLSWPIN  =0; LPLSWPIN  =.; TPLSWPIN  =0; HPLSWPOU  =0;
LPLSWPOU  =.; TPLSWPOU  =0;
END;
SWT71=1;
HOUR71=HR;
DATE71=DATEX;
END;
PTR=15;
INPUT @PTR COMSIZ PIB2. @;
       PTR = PTR+COMSIZ;
INPUT @PTR PCSIZ PIB2. @;
       PTR = PTR+PCSIZ;
INPUT @PTR
       PAGEINS  PIB4. PAGEOUTS PIB4. RECLAIMS PIB4. ADSPSWAP PIB4.
       SWAPIN   PIB4. SWAPOUT  PIB4. VIOPGIN  PIB4. VIOPGOUT PIB4.
       VIORECL  PIB4. COMPAGIN PIB4. COMPGOUT PIB4. COMRECL  PIB4. @;
 * EQUIVALENTS:
       PAGEINS =SMF71PIN PAGEOUTS=SMF71POT
       RECLAIMS=SMF71PRC ADSPSWAP=SMF71SSQ
       SWAPIN  =SMF71SIN SWAPOUT =SMF71SOT
       VIOPGIN =SMF71VIN VIOPGOUT=SMF71VOT
       VIORECL =SMF71VRC COMPAGIN=SMF71SNI
       COMPGOUT=SMF71SNO COMRECL =SMF71SNR ;
INPUT @PTR
      (SMF71PIN  SMF71POT SMF71PRC SMF71SSQ
       SMF71SIN  SMF71SOT SMF71VIN SMF71VOT
       SMF71VRC  SMF71SNI SMF71SNO SMF71SNR
       SMF71LNI  SMF71LNR SMF71SRC SMF71AFC
       SMF71TFC  SMF71TSC SMF71DSC SMF71VSC
       SMF71NSC  SMF71FIN
       SMF71MNF  SMF71MXF SMF71AVF
       SMF71MNP  SMF71MXP SMF71AVP
       SMF71MNS  SMF71MXS SMF71AVS
       SMF71MNT  SMF71MXT SMF71AVT
       SMF71MNQ  SMF71MXQ SMF71AVQ
       SMF71MNC  SMF71MXC SMF71AVC
       SMF71MNR  SMF71MXR SMF71AVR
       SMF71MNX  SMF71MXX SMF71AVX
       SMF71MNU  SMF71MXU SMF71AVU
       SMF71MNV  SMF71MXV SMF71AVV
       SMF71MNM  SMF71MXM SMF71AVM
       SMF71MNB  SMF71MXB SMF71AVB
       SMF71MNA SMF71MXA SMF71AVA
       SMF71TIS       SMF71LWS       SMF71DWS       SMF71ULS
       SMF71NRS       SMF71ASS       SMF71RSS       SMF71EXS
       SMF71EES       SMF71TOS       SMF71TXS       SMF71LGS
       SMF71LFS       SMF71LSS       SMF71LSE       SMF71NLP
       SMF71XLP       SMF71ALP       SMF71NLF       SMF71XLF
       SMF71ALF       SMF71NLS       SMF71XLS       SMF71ALS)
       (PIB4.) @;
*---------------- DETAILS REPORTS  ------------------------------- ;
NREC71+1;
HPAGEINS=MAX(HPAGEINS,PAGEINS);
LPAGEINS=MIN(LPAGEINS,PAGEINS);
HPAGEOUT=MAX(HPAGEOUT,PAGEOUTS);
LPAGEOUT=MIN(LPAGEOUT,PAGEOUTS);
HRCLAIMS=MAX(HRCLAIMS,RECLAIMS);
LRCLAIMS=MIN(LRCLAIMS,RECLAIMS);
HADSPSWP=MAX(HADSPSWP,ADSPSWAP);
LADSPSWP=MIN(LADSPSWP,ADSPSWAP);
HSWAPIN=MAX(HSWAPIN,SWAPIN);
LSWAPIN=MIN(LSWAPIN,SWAPIN);
HSWAPOUT=MAX(HSWAPOUT,SWAPOUT);
LSWAPOUT=MIN(LSWAPOUT,SWAPOUT);
HVIOPGIN=MAX(HVIOPGIN,VIOPGIN);
LVIOPGIN=MIN(LVIOPGIN,VIOPGIN);
HVIOPGOU=MAX(HVIOPGOU,VIOPGOUT);
LVIOPGOU=MIN(LVIOPGOU,VIOPGOUT);
HVIORECL=MAX(HVIORECL,VIORECL);
LVIORECL=MIN(LVIORECL,VIORECL);
HCOMPGIN=MAX(HCOMPGIN,COMPAGIN);
LCOMPGIN=MIN(LCOMPGIN,COMPAGIN);
HCOMPGOU=MAX(HCOMPGOU,COMPGOUT);
LCOMPGOU=MIN(LCOMPGOU,COMPGOUT);
HCOMRECL=MAX(HCOMRECL,COMRECL);
LCOMRECL=MIN(LCOMRECL,COMRECL);
TPAGEINS+PAGEINS;
TPAGEOUT+PAGEOUTS;
TRCLAIMS+RECLAIMS;
TADSPSWP+ADSPSWAP;
TSWAPIN+SWAPIN;
TSWAPOUT+SWAPOUT;
TVIOPGIN+VIOPGIN;
TVIOPGOU+VIOPGOUT;
TVIORECL+VIORECL;
TCOMPGIN+COMPAGIN;
TCOMPGOU+COMPGOUT;
TCOMRECL+COMRECL;
INPUT @PTR +300
      (ITERM_WT       LONG_WT        DETECTED       UNILATRL
       REQUESTD       AUX_SHRT       REL_SHRT       EXCHANGE
       ENQ_EXCH       OTERM_WT) (PIB4.) @                            ;
*--------------  IBM RMF CALCULATIONS -------------------------------;
STORAGE=(SMF71TFC+SMF71FIN);       * SIZE OF REAL STORAGE            ;
TPAGRT=(SMF71PIN+SMF71POT+SMF71SIN+SMF71SOT+SMF71VIN+SMF71VOT
       +SMF71SNI+SMF71SNO)/RMFDUR; * TOT # OF PAGES PER SEC          ;
PSOCLTT=SMF71LFS/RMFDUR; * SWAPOUT DUE DETECTED LONG THINK TIME;
PSOCLW=SMF71LWS/RMFDUR;            * SWAPOUT DUE TO LONG WAIT;
PSOCDW=SMF71DWS/RMFDUR;            * SWAPOUT DUE TO DETECTED WAIT;
PSOCU=SMF71ULS/RMFDUR;             * # OF UNILATERAL SWAP-OUTS       ;
PSOCEORV=SMF71EXS/RMFDUR;          * SWAP-OUT ON RECOM. VALUE        ;
PSOCENQE=SMF71EES/RMFDUR;          * SWAP-OUT ON ENQUEUE EXHANGE     ;
PSOCERQ=SMF71NRS/RMFDUR;           * # OF REQUESTED SWAP-OUTS        ;
PSOCAXSS=SMF71ASS/RMFDUR;          * SWAP-OUT AUXI STORAGE SHORTAGE  ;
PSOCRPSS=SMF71RSS/RMFDUR;          * SWAP-OUT REAL STORAGE SHORTAGE  ;
PSOCTONS=SMF71TXS/RMFDUR;          * SWAP-OUT ADDR SPACE MADE NONSWAP;
PAGERT=(SMF71PIN+SMF71PRC)/RMFDUR; * # OF PAGE FAULTS/SECOND         ;
DPAGRT=(SMF71PIN+SMF71POT)/RMFDUR; * DEMAND PAGING /SECOND           ;
SWART=SMF71SSQ/RMFDUR;             * SWAP RATE                       ;
IF SMF71LGS ^= 0 THEN
PLSWAPIN=(((SMF71LSS+SMF71LGS-SMF71LFS-SMF71LSE)*100)/SMF71LGS)+.005;
ELSE PLSWAPIN=0;                   * % SUCESSFUL SWAP-IN             ;
IF (SMF71TIS+SMF71TOS) ^= 0 THEN
PLSWAPOU=((SMF71LGS*100)/(SMF71TIS+SMF71TOS))+.005;
ELSE PLSWAPOU=0;                   * % SUCESSFUL SWAP-OUT            ;
MXSQA=SMF71MXQ;                    * MAX # SQA FRAMES                ;
AVGSQA=SMF71AVQ;                   * AVG # SQA FRAMES                ;
MXCSAF=SMF71MXC;                   * MAX # CSA FIXED-FRAMES          ;
AVGCSAF=SMF71AVC;                  * AVG # CSA FIXED FRAMES          ;
MXCSAP=SMF71MXP;                   * MAX # PAGEABLE CSA FRAMES       ;
AVGCSAP=SMF71AVP;                  * AVG # PAGEABLE CSA FRAMES       ;
MAXVIOF=SMF71MXV;                  * MAX # ALLOCATED VIO SLOTS       ;
AVGVIOF=SMF71AVV;                  * AVG # VIO ALLOCATED SLOTS       ;
PSOCTW=(SMF71TIS+SMF71TOS-SMF71LGS)/RMFDUR;
                                   * SWAP-OUT TERMINAL WAIT          ;
*---------------- STORAGE ANALYSIS REPORT -----------------------    ;
HSTORAGE=MAX( HSTORAGE,STORAGE);
TSTORAGE+STORAGE;
HISQA   =MAX( HISQA ,MXSQA);
LOSQA   =MIN( LOSQA ,MXSQA);
TMXSQA  + MXSQA;
HICSAF  =MAX( HICSAF ,MXCSAF);
LOCSAF  =MIN( LOCSAF ,MXCSAF);
TMXCSAF + MXCSAF;
HICSAP  =MAX( HICSAP ,MXCSAP);
LOCSAP  =MIN( LOCSAP ,MXCSAP);
TMXCSAP + MXCSAP;
HIGVIOF =MAX( HIGVIOF ,MAXVIOF);
LOWVIOF =MIN( LOWVIOF ,MAXVIOF);
TMAXVIOF+ MAXVIOF;
*-----------------  PAGING RATE REPORT -----------------------        ;
PSOCTW=   PSOCTW*10;     *   REDUCE IN 1/10 SCALE;
PSOCLTT=  PSOCLTT*10;    *   REDUCE IN 1/10 SCALE;
PSOCLW=   PSOCLW*10;     *   REDUCE IN 1/10 SCALE;
PSOCDW=   PSOCDW*10;     *   REDUCE IN 1/10 SCALE;
PSOCU=    PSOCU*10;      *   REDUCE IN 1/10 SCALE;
PSOCEORV= PSOCEORV*10;   *   REDUCE IN 1/10 SCALE;
PSOCENQE= PSOCENQE*10;   *   REDUCE IN 1/10 SCALE;
PSOCERQ=  PSOCERQ*10;    *   REDUCE IN 1/10 SCALE;
PSOCAXSS= PSOCAXSS*10;   *   REDUCE IN 1/10 SCALE;
PSOCRPSS= PSOCRPSS*10;   *   REDUCE IN 1/10 SCALE;
PSOCTONS= PSOCTONS*10;   *   REDUCE IN 1/10 SCALE;
PAGERT=   PAGERT*10;     *   REDUCE IN 1/10 SCALE;
DPAGRT=   DPAGRT*10;     *   REDUCE IN 1/10 SCALE;
SWART=    SWART*10;      *   REDUCE IN 1/10 SCALE;
HTPAGRT  =MAX( HTPAGRT ,TPAGRT);
LTPAGRT  =MIN( LTPAGRT ,TPAGRT);
TTPAGRT  +TPAGRT;
HPAGERT  =MAX( HPAGERT ,PAGERT);
LPAGERT  =MIN( LPAGERT ,PAGERT);
TPAGERT  +PAGERT;
HDPAGRT  =MAX( HDPAGRT ,DPAGRT);
LDPAGRT  =MIN( LDPAGRT ,DPAGRT);
TDPAGRT  +DPAGRT;
HSWART   =MAX( HSWART ,SWART);
LSWART   =MIN( LSWART ,SWART);
TSWART   +SWART;
HPLSWPIN =MAX( HPLSWPIN ,PLSWAPIN);
LPLSWPIN =MIN( LPLSWPIN ,PLSWAPIN);
TPLSWPIN +PLSWAPIN;
HPLSWPOU =MAX( HPLSWPOU ,PLSWAPOU);
LPLSWPOU =MIN( LPLSWPOU ,PLSWAPOU);
TPLSWPOU +PLSWAPOU;
*----- SWAP-OUT PER SECOND REASONS : HIGH LOW AVG  TODAY VALUES------;
HPSOCLTT  =MAX( HPSOCLTT ,PSOCLTT);
LPSOCLTT  =MIN( LPSOCLTT ,PSOCLTT);
TPSOCLTT  +PSOCLTT;
HPSOCLW   =MAX( HPSOCLW ,PSOCLW);
LPSOCLW   =MIN( LPSOCLW ,PSOCLW);
TPSOCLW   +PSOCLW ;
HPSOCDW   =MAX( HPSOCDW ,PSOCDW);
LPSOCDW   =MIN( LPSOCDW ,PSOCDW);
TPSOCDW   +PSOCDW ;
HPSOCU    =MAX( HPSOCU ,PSOCU);
LPSOCU    =MIN( LPSOCU ,PSOCU);
TPSOCU    +PSOCU ;
HPSCEORV  =MAX( HPSCEORV ,PSOCEORV);
LPSCEORV  =MIN( LPSCEORV ,PSOCEORV);
TPSCEORV  +PSOCEORV;
HPSCENQE  =MAX( HPSCENQE ,PSOCENQE);
LPSCENQE  =MIN( LPSCENQE ,PSOCENQE);
TPSCENQE  +PSOCENQE;
HPSOCERQ  =MAX( HPSOCERQ ,PSOCERQ);
LPSOCERQ  =MIN( LPSOCERQ ,PSOCERQ);
TPSOCERQ  +PSOCERQ;
HPSCAXSS  =MAX( HPSCAXSS ,PSOCAXSS);
LPSCAXSS  =MIN( LPSCAXSS ,PSOCAXSS);
TPSCAXSS  +PSOCAXSS;
HPSCRPSS  =MAX( HPSCRPSS ,PSOCRPSS);
LPSCRPSS  =MIN( LPSCRPSS ,PSOCRPSS);
TPSCRPSS  +PSOCRPSS;
HPSCTONS  =MAX( HPSCTONS ,PSOCTONS);
LPSCTONS  =MIN( LPSCTONS ,PSOCTONS);
TPSCTONS  +PSOCTONS;
HPSOCTW   =MAX( HPSOCTW  ,PSOCTW );
LPSOCTW   =MIN( LPSOCTW  ,PSOCTW );
TPSOCTW   +PSOCTW ;
* OLD RMF CALCULATIONS BY J. A. CHAPMAN ;
ENQ_CONT = ENQ_EXCH +LONG_WT ;
COMRATE  = (COMPAGIN+COMPGOUT ) / RMFDUR;
PGFAULT  = (VIORECL +RECLAIMS +VIOPGIN +PAGEINS ) / RMFDUR ;
SWAPRATE = ( SWAPIN + SWAPOUT ) / RMFDUR;
IPS      = UNILATRL + ENQ_EXCH   ;
TOT_SWP  = ITERM_WT +LONG_WT +DETECTED +UNILATRL +REQUESTD +AUX_SHRT
           +REL_SHRT +EXCHANGE +ENQ_EXCH +OTERM_WT;
SWP_SEC  = TOT_SWP / RMFDUR   ;
VIO      = (VIOPGIN + VIOPGOUT) / RMFDUR;
RETURN; * END OF PAGING ANALYSIS;
PAGE;
* ----------------    WORKLOAD RECORD  -----------------------      ;
TYPE72:
IF HR ^= HOUR72 THEN DO;
IF SWT72 = 1 THEN DO;
*   PERFORMANCE GROUP STATISTICS ;
DO OVER PERFG;
IF PERFG ^= 9999 THEN DO;
IF PCNT ^= 0 THEN DO;
APTSV=APTSV/PCNT;
APISV=APISV/PCNT;
APCSV=APCSV/PCNT;
APSSV=APSSV/PCNT;
APMSV=APMSV/PCNT;
APXSV=APXSV/PCNT;
APRTM=APRTM/PCNT;
APPER=APPER/PCNT;
PXRFG   = PERFG  ; HXTSV   = HPTSV  ; LXTSV   = LPTSV  ;
AXTSV   = APTSV  ; HXISV   = HPISV  ; LXISV   = LPISV  ;
AXISV   = APISV  ; HXCSV   = HPCSV  ; LXCSV   = LPCSV  ;
AXCSV   = APCSV  ; HXSSV   = HPSSV  ; LXSSV   = LPSSV  ;
AXSSV   = APSSV  ; HXMSV   = HPMSV  ; LXMSV   = LPMSV  ;
AXMSV   = APMSV  ; HXXSV   = HPXSV  ; AXXSV   = APXSV  ;
HXRTM   = HPRTM  ; AXRTM   = APRTM  ; HXPER   = HPPER  ;
AXPER   = APPER  ;
OUTPUT SASRMF.PERFGRP;
PCNT    =0; HPTSV   =0; LPTSV   =.; APTSV   =0; HPISV   =0;
LPISV   =.; APISV   =0; HPCSV   =0; LPCSV   =.; APCSV   =0;
HPSSV   =0; LPSSV   =.; APSSV   =0; HPMSV   =0; LPMSV   =.;
APMSV   =0; HPXSV   =0; LPXSV   =.; APXSV   =0; HPRTM   =0;
LPRTM   =.; APRTM   =0; HPPER   =0; LPPER   =.; APPER   =0;
 END; END;
END;
*   DOMAIN STATISTICS ;
DO OVER DOM;
IF DOM ^= 9999 THEN DO;
IF DCNT ^= 0 THEN DO;
ADTSV=ADTSV/DCNT;
ADISV=ADISV/DCNT;
ADCSV=ADCSV/DCNT;
ADSSV=ADSSV/DCNT;
ADMSV=ADMSV/DCNT;
ADXSV=ADXSV/DCNT;
ADRTM=ADRTM/DCNT;
ADPER=ADPER/DCNT;
DOMY   =  DOM    ; HYTSV  =  HDTSV  ; LYTSV  =  LDTSV  ;
AYTSV  =  ADTSV  ; HYISV  =  HDISV  ; LYISV  =  LDISV  ;
AYISV  =  ADISV  ; HYCSV  =  HDCSV  ; LYCSV  =  LDCSV  ;
AYCSV  =  ADCSV  ; HYSSV  =  HDSSV  ; LYSSV  =  LDSSV  ;
AYSSV  =  ADSSV  ; HYMSV  =  HDMSV  ; LYMSV  =  LDMSV  ;
AYMSV  =  ADMSV  ; HYXSV  =  HDXSV  ; AYXSV  =  ADXSV  ;
HYRTM  =  HDRTM  ; AYRTM  =  ADRTM  ; HYPER  =  HDPER  ;
AYPER  =  ADPER  ;
OUTPUT SASRMF.DOMAIN;
DCNT    =0; HDTSV   =0; LDTSV   =.; ADTSV   =0; HDISV   =0;
LDISV   =.; ADISV   =0; HDCSV   =0; LDCSV   =.; ADCSV   =0;
HDSSV   =0; LDSSV   =.; ADSSV   =0; HDMSV   =0; LDMSV   =.;
ADMSV   =0; HDXSV   =0; LDXSV   =.; ADXSV   =0; HDRTM   =0;
LDRTM   =.; ADRTM   =0; HDPER   =0; LDPER   =.; ADPER   =0;
END; END; END;
*    OBJECTIVE.......;
DO OVER OBJ;
IF OBJ ^= 9999 THEN DO;
IF OCNT ^= 0 THEN DO;
AOTSV=AOTSV/OCNT;
AOISV=AOISV/OCNT;
AOCSV=AOCSV/OCNT;
AOSSV=AOSSV/OCNT;
AOMSV=AOMSV/OCNT;
AOXSV=AOXSV/OCNT;
AORTM=AORTM/OCNT;
AOPER=AOPER/OCNT;
OBJZ   =  OBJ   ; HZTSV  =  HOTSV ; LZTSV  =  LOTSV ;
AZTSV =  AOTSV ; HZISV  =  HOISV ; LZISV  =  LOISV ;
AZISV  = AOISV ; HZCSV  =  HOCSV ; LZCSV  =  LOCSV ;
AZCSV  =  AOCSV ; HZSSV  =  HOSSV ; LZSSV  =  LOSSV ;
AZSSV  =  AOSSV ; HZMSV  =  HOMSV ; LZMSV  =  LOMSV ;
AZMSV  =  AOMSV ; HZXSV =  HOXSV ; AZXSV  =  AOXSV ;
HZRTM  =  HORTM ; AZRTM  = AORTM ; HZPER  =  HOPER ;
AZPER  =  AOPER ;
OUTPUT SASRMF.OBJECTIV;
OCNT    =0; HOTSV   =0; LOTSV   =.; AOTSV   =0; HOISV   =0;
LOISV   =.; AOISV   =0; HOCSV   =0; LOCSV   =.; AOCSV   =0;
HOSSV   =0; LOSSV   =.; AOSSV   =0; HOMSV   =0; LOMSV   =.;
AOMSV   =0; HOXSV   =0; LOXSV   =.; AOXSV   =0; HORTM   =0;
LORTM   =.; AORTM   =0; HOPER   =0; LOPER   =.; AOPER   =0;
END; END; END;
*    SERVICE RATES, TRANSACTION/SEC, AND REPONSE TIME;
ATOTSRV=ATOTSRV/REC72;
AIOSRV=AIOSRV/REC72;
ACPUSRV=ACPUSRV/REC72;
ASRBSRV=ASRBSRV/REC72;
AMSOSRV=AMSOSRV/REC72;
AITRANS=AITRANS/REC72;
ARTIME=ARTIME/REC72;
ASPERTRA=ASPERTRA/REC72;
OUTPUT SASRMF.WORKLOAD;
HTOTSRV   =0; LTOTSRV   =.;
ATOTSRV   =0; HIOSRV    =0; LIOSRV    =.; AIOSRV    =0; HCPUSRV   =0;
LCPUSRV   =.; ACPUSRV   =0; HSRBSRV   =0; LSRBSRV   =.; ASRBSRV   =0;
HMSOSRV   =0; LMSOSRV   =.; AMSOSRV   =0; HTRANS    =0; LTRANS    =.;
AITRANS   =0; HRTIME    =0; LRTIME    =.; ARTIME    =0; HSPERTRA  =0;
LSPERTRA  =.; ASPERTRA  =0; REC72=0;
END;
DATE72=DATEX ;
HOUR72=HR ;
SWT72=1;
END;
       PTR=15;
INPUT @PTR COMSIZ PIB2. +14 PERFGRP PIB2. @;
       PTR=PTR+COMSIZ;
INPUT @PTR WKLSIZ PIB2. NRPERIOD PIB2.  PG_SIZE PIB2.
      +22 (IOCCOEFF CPUCOEFF MSOCOEFF SRBCOEFF) (4.)
      +20 SMF72SYS $4. @;
PERIOD=1 ;
       PTR = PTR+WKLSIZ;
LOOP72: IF NRPERIOD=0 THEN RETURN ;
INPUT @PTR TRANS PIB4. ACTIVE PIB4. SERVICE PIB4. ELAPSED PIB4.
      WKLOAD PIB4. MSOUNITS PIB4. IOUNITS PIB4. CPUUNITS PIB4.
      RESIDENT PIB4. SWAPSEQ PIB4. DOMAIN PIB2. OBJECTIV PIB1.
      TSG PIB1. SRBUNITS PIB4. (PETI1 PETI2) (PIB4.) @;
IF SERVICE = 0 THEN GOTO X72;
INPUT @PTR (SMF72TTX SMF72ACT SMF72SER SMF72TTM SMF72LEV
            SMF72MTS SMF72ITS SMF72CTS SMF72TAT SMF72SPP) (PIB4.)
            SMF72CDN PIB2. (SMF72PON SMF72TSG) (PIB1.)
           (SMF72STS SMF72ETI SMF72ET2) (PIB4.) @;
PGNP=PERFGRP;
DMN=DOMAIN;
SUBSYS= SMF72SYS;
TOTSRV=SMF72SER/RMFDUR;
HTOTSRV    =MAX( HTOTSRV , TOTSRV);
LTOTSRV    =MIN( LTOTSRV ,TOTSRV);
ATOTSRV    + TOTSRV ;
IOSRV=SMF72ITS/RMFDUR;
HIOSRV     =MAX( HIOSRV ,IOSRV);
LIOSRV     =MIN( LIOSRV ,IOSRV);
AIOSRV      + IOSRV ;
CPUSRV=SMF72CTS/RMFDUR;
HCPUSRV    =MAX( HCPUSRV ,CPUSRV);
LCPUSRV    =MIN( LCPUSRV ,CPUSRV);
ACPUSRV     + CPUSRV;
SRBSRV=SMF72STS/RMFDUR;
HSRBSRV    =MAX( HSRBSRV ,SRBSRV);
LSRBSRV    =MIN( LSRBSRV ,SRBSRV);
ASRBSRV     + SRBSRV;
MSOSRV=SMF72MTS/RMFDUR;
HMSOSRV    =MAX( HMSOSRV ,MSOSRV);
LMSOSRV    =MIN( LMSOSRV ,MSOSRV);
AMSOSRV     + MSOSRV;
ITRANS=SMF72TTX/RMFDUR;
HTRANS     =MAX( HTRANS ,ITRANS);
LTRANS     =MIN( LTRANS ,ITRANS);
AITRANS     + ITRANS;
IF SMF72TTX ^= 0 THEN
RTIME=(SMF72TTM*1024/(60E6))/SMF72TTX ;
ELSE RTIME=0;
HRTIME     =MAX( HRTIME ,RTIME);
LRTIME     =MIN( LRTIME ,RTIME);
ARTIME      + RTIME ;
IF SMF72SPP ^= 0 THEN
SPERTRA=SMF72TTX/SMF72SPP;
ELSE SPERTRA=0;
HSPERTRA   =MAX( HSPERTRA ,SPERTRA);
LSPERTRA   =MIN( LSPERTRA ,SPERTRA);
ASPERTRA    + SPERTRA ;
FILE RPT72PER HEADER=H72PER NOTITLES PRINT;
DO OVER PERFG;
 IF PERFG = 9999 THEN PERFG=PERFGRP;
 IF PERFG = PERFGRP THEN DO;
 PCNT+1;
HPTSV    =MAX( HPTSV , TOTSRV);
LPTSV    =MIN( LPTSV ,TOTSRV);
APTSV    + TOTSRV ;
HPISV     =MAX( HPISV ,IOSRV);
LPISV     =MIN( LPISV ,IOSRV);
APISV      + IOSRV ;
HPCSV    =MAX( HPCSV ,CPUSRV);
LPCSV    =MIN( LPCSV ,CPUSRV);
APCSV     + CPUSRV;
HPSSV    =MAX( HPSSV ,SRBSRV);
LPSSV    =MIN( LPSSV ,SRBSRV);
APSSV     + SRBSRV;
HPMSV    =MAX( HPMSV ,MSOSRV);
LPMSV    =MIN( LPMSV ,MSOSRV);
APMSV     + MSOSRV;
HPXSV     =MAX( HPXSV ,ITRANS);
LPXSV     =MIN( LPXSV ,ITRANS);
APXSV     + ITRANS;
HPRTM      =MAX( HPRTM ,RTIME);
LPRTM      =MIN( LPRTM ,RTIME);
APRTM       + RTIME ;
HPPER   =MAX( HPPER ,SPERTRA);
LPPER   =MIN( LPPER ,SPERTRA);
APPER    + SPERTRA ;
GOTO SKIPP72;
END;
END;
SKIPP72:
DO OVER DOM;
 IF DOM = 9999 THEN DOM=DOMAIN;
 IF DOM = DOMAIN THEN DO;
 DCNT+1;
HDTSV    =MAX( HDTSV , TOTSRV);
LDTSV    =MIN( LDTSV ,TOTSRV);
ADTSV    + TOTSRV ;
HDISV     =MAX( HDISV ,IOSRV);
LDISV     =MIN( LDISV ,IOSRV);
ADISV      + IOSRV ;
HDCSV    =MAX( HDCSV ,CPUSRV);
LDCSV    =MIN( LDCSV ,CPUSRV);
ADCSV     + CPUSRV;
HDSSV    =MAX( HDSSV ,SRBSRV);
LDSSV    =MIN( LDSSV ,SRBSRV);
ADSSV     + SRBSRV;
HDMSV    =MAX( HDMSV ,MSOSRV);
LDMSV    =MIN( LDMSV ,MSOSRV);
ADMSV     + MSOSRV;
HDXSV     =MAX( HDXSV ,ITRANS);
LDXSV     =MIN( LDXSV ,ITRANS);
ADXSV     + ITRANS;
HDRTM      =MAX( HDRTM ,RTIME);
LDRTM      =MIN( LDRTM ,RTIME);
APRTM       + RTIME ;
HDPER   =MAX( HDPER ,SPERTRA);
LDPER   =MIN( LDPER ,SPERTRA);
ADPER    + SPERTRA ;
GOTO SKIPD72;
END;
END;
SKIPD72:
DO OVER OBJ;
 IF OBJ = 9999 THEN OBJ=OBJECTIV;
 IF OBJ = OBJECTIV THEN DO;
 OCNT+1;
HOTSV    =MAX( HOTSV , TOTSRV);
LOTSV    =MIN( LOTSV ,TOTSRV);
AOTSV    + TOTSRV ;
HOISV     =MAX( HOISV ,IOSRV);
LOISV     =MIN( LOISV ,IOSRV);
AOISV      + IOSRV ;
HOCSV    =MAX( HOCSV ,CPUSRV);
LOCSV    =MIN( LOCSV ,CPUSRV);
AOCSV     + CPUSRV;
HOSSV    =MAX( HOSSV ,SRBSRV);
LOSSV    =MIN( LOSSV ,SRBSRV);
AOSSV     + SRBSRV;
HOMSV    =MAX( HOMSV ,MSOSRV);
LOMSV    =MIN( LOMSV ,MSOSRV);
AOMSV     + MSOSRV;
HOXSV     =MAX( HOXSV ,ITRANS);
LOXSV     =MIN( LOXSV ,ITRANS);
AOXSV     + ITRANS;
HORTM      =MAX( HORTM ,RTIME);
LORTM      =MIN( LORTM ,RTIME);
AORTM       + RTIME ;
HOPER   =MAX( HOPER ,SPERTRA);
LOPER   =MIN( LOPER ,SPERTRA);
AOPER    + SPERTRA ;
GOTO SKIPO72;
END;
END;
SKIPO72:
REC72+1;
WKLOAD=WKLOAD/256 ;
ACT_MIN=ACTIVE*1024/(60E6);
IF ACTIVE ^= 0 THEN ACT_SEC=ACTIVE * 1024/1.0E6 ;
IF RESIDENT^=0 THEN RES_SEC=RESIDENT*1024/1.0E6 ;
IF SERVICE ^=0 THEN ABS=SERVICE/RES_SEC ;
IF CPUUNITS^=0 THEN X=CPUUNITS/CPUCOEFF ;
ELP_MIN=ELAPSED*1024/(60E6);            ELP_SEC=ELAPSED*1024/1.0E6 ;
RES_MIN=RESIDENT*1024/(60E6);
      *CALCULATE CPUMIN FROM CPUUNITS. 60 IS CONVERSION TO MINUTES ;
      *CPUFACT IS NUMBER FOR CPU SU PER SECOND FROM IBM TABLES.
      *151 FOR 168, 125 FOR 165, 51.2 FOR 158, 42 FOR 155 & 24 FOR 145;
      *CORRESPONDING SECONDS PER SU (FOR SYS9 CPUS) ARE 151 - .0066,
      *125 - .080, 51.2 - .0195, 42.0 - .0238, 24 - .0417 ;
    SU_SEC=78.9;                             TSR=SERVICE/ACT_SEC ;
    CPUMIN=CPUUNITS/(CPUCOEFF*SU_SEC*60);
    IF TRANS ^= 0 THEN TRLEN=ELP_SEC/TRANS ; ELSE TRLEN=0;
    IOSERV=IOUNITS/IOCCOEFF;                 CPUSERV=CPUUNITS/CPUCOEFF;
    MSSERV=MSOUNITS/MSOCOEFF;                TOT_SRV=SERVICE/RMFDUR;
    SRBSERV=SRBUNITS/SRBCOEFF;               SRB_SRV=SRBUNITS/RMFDUR;
    AVE_TRAN=ACT_SEC/RMFDUR ;                MSO_SRV=MSOUNITS/RMFDUR;
    TRAN_WS=((MSOUNITS/MSOCOEFF)*50)/X ;
    RES_TIME=RES_SEC/ABS ;                   TRAN_SWA=RES_SEC/RMFDUR ;
IF TRANS^=0 THEN IO_TRAN = IOUNITS/(IOCCOEFF*TRANS) ;
    DMN_WS=TRAN_WS/TRAN_SWA   ;
    IO_SRV=IOUNITS/RMFDUR ;                  CPU_SRV=CPUUNITS/RMFDUR;
      IF SERVICE ^=0 THEN RETURN;
X72:  NRPERIOD=NRPERIOD-1 ;
      PERIOD=PERIOD+1 ;                      PTR=PTR+PG_SIZE ;
      GOTO LOOP72 ;
   RETURN             ;
PAGE;
* ------------------     CHANNEL RECORD  -------------------        ;
TYPE73:
IF HR ^= HOUR73 THEN DO;
IF SWT73 =1 THEN DO;
*    PHYSICAL LOCAL CHANNELS.....................................;
DO OVER CHAN;
IF CCNT ^= 0 THEN DO;
IF CHAN ^= . THEN DO;
ACRT=ACRT/CCNT;
ACBSY=ACBSY/CCNT;
ACAVG=ACAVG/CCNT;
ASCWS=ASCWS/CCNT;
CXAN   =  CHAN   ; HXRT   =  HCRT   ; LXRT   =  LCRT   ;
AXRT   =  ACRT   ; HXBSY  =  HCBSY  ; LXBSY  =  LCBSY  ;
AXBSY  =  ACBSY  ; HXAVG  =  HCAVG  ; LXAVG  =  LCAVG  ;
AXAVG  =  ACAVG  ; HXCWS  =  HSCWS  ; LXCWS  =  LSCWS  ;
AXCWS  =  ASCWS  ;
OUTPUT SASRMF.CHANNELS;
CCNT    =0; HCRT    =0; LCRT    =.; ACRT    =0; HCBSY   =0;
LCBSY   =.; ACBSY   =0; HCAVG   =0; LCAVG   =.; ACAVX   =0;
HSCWS =0; LSCWS =.; ASCWS =0;
END; END; END;
*    LOCAL CHANNELS.....................................;
DO OVER LCHAN;
IF LCCNT ^= 0 THEN DO;
IF LCHAN ^= 9999 THEN DO;
ALCH=ALCH/LCCNT;
TLQ0D   =TLQ0D   /LCCNT;
TLQ1D   =TLQ1D   /LCCNT;
TLQ2D   =TLQ2D   /LCCNT;
TLQ3D   =TLQ3D   /LCCNT;
TLQ4D   =TLQ4D   /LCCNT;
TLCBSY  =TLCBSY  /LCCNT;
TLLBSY  =TLLBSY  /LCCNT;
TLUBSY  =TLUBSY  /LCCNT;
TLDBSY  =TLDBSY  /LCCNT;
TFCBSY  =TFCBSY  /LCCNT;
TFLBSY  =TFLBSY  /LCCNT;
TFUBSY  =TFUBSY  /LCCNT;
TFDBSY  =TFDBSY  /LCCNT;
LCHANX  = LCHAN   ; HLCHX   = HLCH    ; LLCHX   = LLCH    ;
ALCHX   = ALCH    ; HLQ0DX  = HLQ0D   ; LLQ0DX  = LLQ0D   ;
LQ0DX   = LQ0D    ; HLQ1DX  = HLQ1D   ; LLQ1DX  = LLQ1D   ;
TLQ1DX  = TLQ1D   ; HLQ2DX  = HLQ2D   ; LLQ2DX  = LLQ2D   ;
TLQ2DX  = TLQ2D   ; LQ3DX   = LQ3D    ; LLQ3DX  = LLQ3D   ;
TLQ3DX  = TLQ3D   ; HLQ4DX  = HLQ4D   ; LLQ4DX  = LLQ4D   ;
TLQ4DX  = TLQ4D   ; HLCBSYX = HLCBSY  ; LCBSYX  = LCBSY   ;
TLCBSYX = TLCBSY  ; HLLBSYX = HLLBSY  ; LLLBSYX = LLLBSY  ;
TLLBSYX = TLLBSY  ; HLUBSYX = HLUBSY  ; LLUBSYX = LLUBSY  ;
TLUBSYX  =TLUBSY   ; HLDBSYX = HLDBSY  ; LLDBSYX = LLDBSY  ;
TLDBSYX = TLDBSY  ; HFCBSYX = HFCBSY  ; LFCBSYX = LFCBSY  ;
TFCBSYX = TFCBSY   ; HFLBSYX = HFLBSY  ; LFLBSYX = LFLBSY  ;
TFLBSYX = TFLBSY  ; HFUBSYX = HFUBSY  ; LFUBSYX = LFUBSY  ;
TFUBSYX  = TFUBSY   ; HFDBSYX = HFDBSY  ; LFDBSYX = LFDBSY  ;
TFDBSYX = TFDBSY  ;
OUTPUT SASRMF.LCHANNEL ;
LCCNT    =0; HLCH    =0; LLCH    =.; ALCH    =0;
HLQ0D    =0; LLQ0D    =.; TLQ0D    =0; HLQ1D    =0;
LLQ1D =.; TLQ1D =0; HLQ2D =0; LLQ2D =.; TLQ2D =0; HLQ3D
=0; LLQ3D =.; TLQ3D =0; HLQ4D =0; LLQ4D =.; TLQ4D =0;
HLCBSY =0; LLCBSY =.; TLCBSY =0; HLLBSY =0; LLLBSY
=.; TLLBSY   =0; HLUBSY   =0; LLUBSY   =.; TLUBSY   =0;
HLDBSY   =0; LLDBSY   =.; TLDBSY   =0; HFCBSY =0;
LFCBSY   =.; TFCBSY   =0; HFLBSY   =0; LFLBSY   =.;
TFLBSY   =0; HFUBSY   =0; LFUBSY   =.; TFUBSY   =0;
HFDBSY =0; LFDBSY   =.; TFDBSY   =0;
END; END; END;
DATE73=DATEX;
HCACRT  =0; LCACRT  =.; ACACRT  =0; REC73P  =.; HCHBSY  =0;
LCHBSY  =.; ACHBSY  =0; HCSAVG  =0; LCSAVG  =.; ACAVG   =0;
END;
SWT73=1;
DATE73=DATEX;
HOUR73=HR;
END;
       PTR=15;
INPUT @PTR COMSIZ PIB2. +16 SAMPLES PIB4. @;
       PTR=PTR+COMSIZ;
INPUT @PTR PHYSIZ PIB2. NO_CHN PIB2. SIZE_CHN PIB2.
           NO_LOGI PIB2. SIZE_LOG PIB2. @;
       PTR = PTR+PHYSIZ;
COUNT = 1; LCOUNT=1;
CPUSAV = CPU_ID   ;
GETCHN:
INPUT @PTR CPUID PIB2.  CHN_ID PIB1. CHN_FLAG PIB1.
           CHN_SIO PIB4.  CHN_TCHB PIB4. CHN_TBW PIB4.  @  ;
   IF (CHN_SIO = 0 AND CHN_TCHB = 0 AND CHN_TBW = 0) THEN GOTO X73;
   CHN_BUSY = CHN_TCHB / SAMPLES          ; * CHANNEL BUSY FRACTION ;
   CHN_BSWT = CHN_TBW / SAMPLES          ; * CHAN BUSY, CPU WAIT   ;
   CHN_SIO  = CHN_SIO / RMFDUR           ; * SIO'S PER SECOND      ;
   FORMAT CHN_ID  HEX1.;
INPUT @PTR SMF73CID PIB2. (SMF73HID SMF73FG2) (PIB1.)
   (SMF73CNT SMF73BSY SMF73OLP SMF73PQ0 SMP73PG1 SMF73PQ2
    SMF73PG3 SMF73PG4 SMF73PRT) (PIB4.) @;
CACRT=SMF73CNT/RMFDUR; * CHANNEL ACTIVITY RATE PER SECOND;
CHBSY=((SMF73BSY*100)/SAMPLES)+.005; *PERCENT CHANNEL BUSY;
CSAVG=((SMF73BSY*RMFDUR)/SAMPLES)/SMF73CNT; * AVG CHANNEL SERVICE TIME;
CBSCWS=100*(SMF73OLP/SAMPLES)+.005; *PCT CHAN BUSY & CPU WAIT ;
HCACRT=MAX(HCACRT,CACRT);
LCACRT=MIN(LCACRT,CACRT);
ACACRT+CACRT;
REC73P+1;
HCHBSY=MAX(HCHBSY,CHBSY);
LCHBSY=MIN(LCHBSY,CHBSY);
ACHBSY+CHBSY;
HCSAVG=MAX(HCSAVG,CSAVG);
LCSAVG=MIN(LCSAVG,CSAVG);
ACAVG+CSAVG;
DO OVER CHAN;
IF CHAN= . THEN CHAN=SMF73HID;
IF CHAN =SMF73HID THEN DO;
    CCNT+1;
    HCRT=MAX(HCRT,CACRT);
    LCRT=MIN(LCRT,CACRT);
    ACRT+CACRT;
    HCBSY=MAX(HCBSY,CHBSY);
    LCBSY=MIN(LCBSY,CHBSY);
    ACBSY+CHBSY;
    HCAVG=MAX(HCAVG,CSAVG);
    LCAVG=MIN(LCAVG,CSAVG);
    ACAVX+CSAVG;
    HSCWS=MAX(HSCWS,CBSCWS);
    LSCWS=MIN(LSCWS,CBSCWS);
    ASCWS+CBSCWS;
    GO TO SKIP73;
    END;
END;
SKIP73:
   *    TEST THE CHANNEL FLAG         * ;
   *    X'01' IS ONLINE SELECTOR, X'21' IS ONLINE BLOCK MPX    ;
   IF CHN_FLAG = 1 OR CHN_FLAG = 33 THEN GOTO CHNOKDAT ; * DATA IS OK ;
   *  INVALID CHANNEL ID OR CPU WAS VARIED, SO DATA IS INVALID ;
   *   DATA IS INVALID FOR BYTE MPX TOO ;
   CHN_SIO  = .  ;  CHN_BUSY = . ; CHN_BSWT = .  ;
   CHNOKDAT:
   CPU_ID = CPUSAV   ;
X73:   IF COUNT GE NO_CHN THEN GOTO X73L;
   COUNT = COUNT + 1    ;
   PTR = PTR + SIZE_CHN   ;
   GOTO GETCHN  ;
*  LOGICAL CHANNEL MEASUREMENTS;
X73L:
   PTR = PTR + SIZE_CHN   ;
X73LL:
INPUT @PTR
  (SMF73LID SMF73PCI SMF73PCO SMF73RV9) (PIB2.)
  (SMF73RV6 SMF73RV7 SMF73RQS SMF73LQ0 SMF73LQ1 SMF73LQ2 SMF73LQ3
   SMF73LQ4 SMF73LQT SMF73PBC SMF73LBC SMF73CHF
   SMF73LGF SMF73CUB SMF73DVB
   SMF73CUF SMF73DVF) (PIB4.) SMF73FG3 PIB2. SMF73RV8 $2. @;
IF SMF73RQS ^= 0 THEN
DIOBLCH=(SMF73LBC+SMF73PBC+SMF73CUB+SMF73DVB)/SMF73RQS;
ELSE DIOBLCH=0;
TRQSDIF= SMF73PBC+SMF73LBC+SMF73CUB+SMF73DVB;* TOTALS RQS DIFFERED;
LQ0D   =.005+100*(SMF73LQ0/SAMPLES); * PCT QUEUE DISTRIBUTION 0 ;
LQ1D   =.005+100*(SMF73LQ1/SAMPLES); * PCT QUEUE DISTRIBUTION 1 ;
LQ2D   =.005+100*(SMF73LQ2/SAMPLES); * PCT QUEUE DISTRIBUTION 2 ;
LQ3D   =.005+100*(SMF73LQ3/SAMPLES); * PCT QUEUE DISTRIBUTION 3 ;
LQ4D   =.005+100*(SMF73LQ4/SAMPLES); * PCT QUEUE DISTRIBUTION 4 ;
LGCBSY =0; LGLBSY =0; LGUBSY =0; LGDBSY =0;
IF TRQSDIF ^= 0 THEN DO;
LGCBSY =.005+100*(SMF73PBC/TRQSDIF); * PCT PHYSCIAL CHANNEL BUSY;
LGLBSY =.005+100*(SMF73LBC/TRQSDIF); * PCT LOGICAL CHANNEL BUSY;
LGUBSY =.005+100*(SMF73CUB/TRQSDIF); * PCT CONTROL UNIT CHANNEL BUSY;
LGDBSY =.005+100*(SMF73DVB/TRQSDIF); * PCT DEVICE CHANNEL BUSY;
END;
LFCBSX =.005+100*(SMF73CHF/SAMPLES); * PCT PHYSCIAL CHANNEL BUSY;
LFLBSX =.005+100*(SMF73LGF/SAMPLES); * PCT LOGICAL CHANNEL BUSY;
LFUBSX =.005+100*(SMF73CUF/SAMPLES); * PCT CONTROL UNIT CHANNEL BUSY;
LFDBSX =.005+100*(SMF73DVF/SAMPLES); * PCT DEVICE CHANNEL BUSY;
DO OVER LCHAN;
IF LCHAN= 9999 THEN LCHAN=SMF73LID;
IF LCHAN =SMF73LID THEN DO;
    LCCNT+1;
    HLCH = MAX(HLCH,DIOBLCH);
    LLCH = MIN(LLCH,DIOBLCH);
    ALCH +DIOBLCH;
    HLQ0D   = MAX( HLQ0D ,LQ0D);
    HLQ1D   = MAX( HLQ1D ,LQ1D);
    HLQ2D   = MAX( HLQ2D ,LQ2D);
    HLQ3D   = MAX( HLQ3D ,LQ3D);
    HLQ4D   = MAX( HLQ4D ,LQ4D);
    LLQ0D   = MIN( LLQ0D ,LQ0D);
    LLQ1D   = MIN( LLQ1D ,LQ1D);
    LLQ2D   = MIN( LLQ2D ,LQ2D);
    LLQ3D   = MIN( LLQ3D ,LQ3D);
    LLQ4D   = MIN( LLQ4D ,LQ4D);
    TLQ0D   + LQ0D;
    TLQ1D   + LQ1D;
    TLQ2D   + LQ2D;
    TLQ3D   + LQ3D;
    TLQ4D   + LQ4D;
    HLCBSY = MAX( HLCBSY ,LGCBSY);
    HLLBSY = MAX( HLLBSY ,LGLBSY);
    HLUBSY = MAX( HLUBSY ,LGUBSY);
    HLDBSY = MAX( HLDBSY ,LGDBSY);
    LLCBSY = MIN( LLCBSY ,LGCBSY);
    LLLBSY = MIN( LLLBSY ,LGLBSY);
    LLUBSY = MIN( LLUBSY ,LGUBSY);
    LLDBSY = MIN( LLDBSY ,LGDBSY);
    TLCBSY + LGCBSY;
    TLLBSY + LGLBSY;
    TLUBSY + LGUBSY;
    TLDBSY + LGDBSY;
    HFCBSY = MAX( HFCBSY ,LFCBSX);
    HFLBSY = MAX( HFLBSY ,LFLBSX);
    HFUBSY = MAX( HFUBSY ,LFUBSX);
    HFDBSY = MAX( HFDBSY ,LFDBSX);
    LFCBSY = MIN( LFCBSY ,LFCBSX);
    LFLBSY = MIN( LFLBSY ,LFLBSX);
    LFUBSY = MIN( LFUBSY ,LFUBSX);
    LFDBSY = MIN( LFDBSY ,LFDBSX);
    TFCBSY + LFCBSX;
    TFLBSY + LFLBSX;
    TFUBSY + LFUBSX;
    TFDBSY + LFDBSX;
    GO TO SKIP73L;
    END;
END;
SKIP73L:
IF LCOUNT GE NO_LOGI THEN RETURN;
   LCOUNT = LCOUNT + 1    ;
   PTR = PTR + SIZE_LOG   ;
   GOTO X73LL  ;
PAGE;
*---------------------   DEVICE RECORD  -------------------        ;
TYPE74:
IF HR ^= HOUR74 THEN DO;
IF SWT74=1 THEN DO;
DO OVER VOL;
IF VCNT ^= 0 THEN DO;
IF VOL^=' ' THEN DO;
ADNT =ADNT/VCNT;
ABSYB =ABSYB/VCNT;
ABSYN =ABSYN/VCNT;
ARD =ARD/VCNT;
AR =AR/VCNT;
AART =AART/VCNT;
AAVBE =AAVBE/VCNT;
AAVNB =AAVNB/VCNT;
AAQ =AAQ/VCNT;
* TOUT = 0 IGNORE VOLSER WITH NO VALUES (0);
TOUT=HDNT+LDNT+ADNT+HBSYB+LBSYB+ABSYB+HBSYN+LBSYN+ABSYN+HRD+
     LRD+ARD+HRA+LR+AR+HART+LART+AART+
     HAVBE+LAVBE+AAVBE+HAVNB+LAVNB+AAVNB+HAQ+LAQ+AAQ;
IF TOUT > 0.99999 THEN DO;
VOLX   =   VOL    ; HDNTX  =   HDNT   ; LDNTX  =   LDNT ;
ADNTX  =   ADNT   ; HBSYBX =   HBSYB  ; LBSYBX =   LBSYB ;
ABSYBX  =   ABSYB   ; HBSYNX =   HBSYN  ; LBSYNX =   LBSYN ;
ABSYNX =   ABSYN  ; HRDX=HRD; LRDX=LRD; ARDX=ARD; HRA=HRA;
LRX =LR;  ARX =AR ; HARTX  =   HART   ;
AARTX  =   AART   ; HAVBEX =   HAVBE  ; LAVBEX = LAVBE  ;
AAVBEX =   AAVBE  ; HAVNBX =   HAVNB  ; LAVNBX = LAVNB  ;
AAVNBX =   AAVNB  ; HAQX   =   HAQ    ; AAQX    = AAQ     ;
OUTPUT SASRMF.DEV; END;
 VCNT=0; HDNT=0; LDNT=.; ADNT=0; HBSYB=0; LBSYB=.; ABSYB=0;
HBSYN=0; LBSYN=.; ABSYN=0; HRD=0; LRD=.; ARD=0; HRA=0;
LR=.; AR=0; HART=0; LART=.; AART=0; HAVBE=0; LAVBE=.;
AAVBE=0; HAVNB=0; LAVNB=.; AAVNB=0; HAQ=0; LAQ=.; AAQ=0;
END;
END;
END;
DATE74=DATEX;
HOUR74=HR;
TDNTRDY   =0; TDART     =0; TDAVGBE   =0; TDAVGNBE =0; TDVBSYBE  =0;
TDVBSYNB  =0; TDRD      =0; TDR =0; TDAQ =0; HDNTRDY   =0; HDART =0;
HDAVGBE   =0; HDAVGNBE  =0; HDVBSYBE  =0; HDVBSYNB  =0; HDRD =0; HDR
=0; HDAQ =0; LDNTRDY   =.; LDART     =.; LDAVGBE   =.; LDAVGNBE =.;
LDVBSYBE  =.; LDVBSYNB =.; LDRD      =.; LDR =.; LDAQ =.;
END;
SWT74=1;
DATE74=DATEX;
HOUR74=HR;
END;
PTR=15;
INPUT @PTR COMSIZ PIB2. +16 NO_SAMPL PIB4. @;
PTR=PTR+COMSIZ;
INPUT @PTR DEVCSECT PIB2. NO_DEV PIB2. DEVDSECT PIB2. @   ;
PTR = PTR+DEVCSECT ; COUNT = 1 ;
* PUT '74: ' COMSIZ NO_SAMPL DEVCSECT NO_DEV DEVDSECT RMFDUR;
GETDEV: INPUT @PTR CU $CHAR1. @PTR CUB PIB1. @;
FORMAT CU  $HEX2. ;
        IF NO_SAMPL =0 THEN NO_SAMPL =.1;
  *     IF  80>CUB<128   THEN DELETE ;
INPUT @PTR DEV_ADDR PIB2.    +6 VOLSER $6.
           +2 (DEV_SIO  DEV_TDB  QDEPTH) (PIB4.) @;
INPUT @PTR SMF74ADD PIB2. (SMF74RV3 SMF74CNF) (PIB1.)
   SMF74TYP PIB4. SMF74SER $CHAR6. SMF74LCH PIB2.
   (SMF74CNT SMF74ACT SMF74QUE SMF74CON SMF74NRD SMF74ALC
    SMF74CUB SMF74BUS SMF74DSO SMF74AC0 SMF74AC1 SMF74AC2
    SMF74AC3 SMF74AC4 SMF74RSV SMF74MTP SMF74RDL SMF74DVB
    SMF74PTH SMF74CUD SMF74RDR) (PIB4.) @;
IF (DEV_TDB = 0  AND  DEV_SIO = 0) THEN GOTO DEVNEXT;
FORMAT DEV_ADDR $HEX4. ; IF DEV_TDB=0 THEN DEV_TDB=.001 ;
DEV_BUSY = DEV_TDB / NO_SAMPL ;
SIO_SEC = DEV_SIO / RMFDUR   ;
IF DEV_TDB <= 0 THEN AVE_QUE = QDEPTH / DEV_TDB   ;
                ELSE AVE_QUE = 0.0;
PCT_BUSY = INT(100 * (DEV_BUSY + .005));
DNOTRDY=((SMF74NRD*100)/NO_SAMPL)+.005;  *PERCENT NOT READY     ;
DART   =SMF74CNT/RMFDUR;                 *SIO PER SECOND        ;
DAVGBE =((SMF74CON*RMFDUR)/NO_SAMPL)/SMF74CNT;*AVG SERVICE TIME/SIO;
DAVGNBE=((SMF74ACT*RMFDUR)/NO_SAMPL)/SMF74CNT;*AVG SERVICE TIME/SIO;
DVBSYBE=((SMF74CON*100)/NO_SAMPL)+.005; *PERCENT DEVICE BUSY ;
DVBSYNB=((SMF74ACT*100)/NO_SAMPL)+.005; *PERCENT DEVICE BUSY ;
DRD    =((SMF74RDL*100)/NO_SAMPL)+.005; *PERCENT RESERVE DELAY;
DR     =((SMF74RSV*100)/NO_SAMPL)+.005; *PERCENT RESERVED    ;
DAQ    =SMF74QUE/NO_SAMPL; *AVG QUEUE LENGTH ON DEVICE       ;
DO OVER VOL;
  IF VOL=' ' THEN VOL=VOLSER;
  IF VOLSER=VOL THEN DO;
    VCNT+1;
    ADNT +DNOTRDY;
    AART +DART;
    AAVBE+DAVGBE;
    AAVNB+DAVGNBE;
    ABSYB+DVBSYBE;
    ABSYN+DVBSYNB;
    ARD +DRD;
    AR  +DR;
    AAQ  +DAQ;
    HDNT   =MAX( HDNT ,DNOTRDY);
    HART   =MAX( HART ,DART);
    HAVBE  =MAX( HAVBE ,DAVGBE);
    HAVNB  =MAX( HAVNB ,DAVGNBE);
    HBSYB  =MAX( HBSYB ,DVBSYBE);
    HBSYN  =MAX( HBSYN ,DVBSYNB);
    HRD   =MAX( HRD ,DRD);
    HRA   =MAX( HRA,DR);
    HAQ    =MAX( HAQ ,DAQ);
    LDNT   =MIN( LDNT ,DNOTRDY);
    LART   =MIN( LART ,DART);
    LAVBE =MIN( LAVBE ,DAVGBE);
    LAVNB =MIN( LAVNB ,DAVGNBE);
    LBSYB  =MIN( LBSYB ,DVBSYBE);
    LBSYN  =MIN( LBSYN ,DVBSYNB);
    LRD   =MIN( LRD ,DRD);
    LR    =MIN( LR ,DR);
    LAQ    =MIN( LAQ ,DAQ);
    GOTO SKIP74;
    END;
  END;
SKIP74:
TDNTRDY +DNOTRDY;
TDART   +DART;
TDAVGBE +DAVGBE;
TDAVGNBE+DAVGNBE;
TDVBSYBE+DVBSYBE;
TDVBSYNB+DVBSYNB;
TDRD    +DRD;
TDR     +DR;
TDAQ    +DAQ;
HDNTRDY   =MAX( HDNTRDY ,DNOTRDY);
HDART     =MAX( HDART ,DART);
HDAVGBE   =MAX( HDAVGBE ,DAVGBE);
HDAVGNBE  =MAX( HDAVGNBE ,DAVGNBE);
HDVBSYBE  =MAX( HDVBSYBE ,DVBSYBE);
HDVBSYNB  =MAX( HDVBSYNB ,DVBSYNB);
HDRD      =MAX( HDRD ,DRD);
HDR       =MAX( HDR ,DR);
HDAQ      =MAX( HDAQ ,DAQ);
LDNTRDY   =MIN( LDNTRDY ,DNOTRDY);
LDART     =MIN( LDART ,DART);
LDAVGBE   =MIN( LDAVGBE ,DAVGBE);
LDAVGNBE  =MIN( LDAVGNBE ,DAVGNBE);
LDVBSYBE  =MIN( LDVBSYBE ,DVBSYBE);
LDVBSYNB  =MIN( LDVBSYNB ,DVBSYNB);
LDRD      =MIN( LDRD ,DRD);
LDR       =MIN( LDR ,DR);
LDAQ      =MIN( LDAQ ,DAQ);
DEVNEXT: IF COUNT GE NO_DEV THEN RETURN ;
COUNT = COUNT + 1 ;    PTR=PTR + DEVDSECT ;
GOTO GETDEV ;
PAGE;
*------------ PAGE/SWAP DATASET RECORD  -------------------        ;
TYPE75:
IF HR ^= HOUR75 THEN DO;
IF SWT75=1 THEN DO;
FILE RPT73CHN NOTITLES PRINT;
DO OVER DSN;
IF DSN ^= ' ' THEN DO;
IF DSCNT ^= 0 THEN DO;
APBSY   =APBSY/DSCNT;
APAVG   =APAVG/DSCNT;
APPT    =APPT/DSCNT;
APART   =APART/DSCNT;
APAVGS  =APAVGS/DSCNT;
APBADS  =APBADS/DSCNT;
DSNX    =  DSN   ; HPBSYX  =  HPBSY ; LPBSYX  =  LPBSY ;
APBSYX =  APBSY ; HPAVGX  =  HPAVG ; LPAVGX  =  LPAVG ;
APAVGX  = APAVG ; HPPTX   =  HPPT  ; LPPTX   =  LPPT  ;
APPTX   =  APPT ; HPARTX  =  HPART ; LPARTX  =  LPART ;
APARTX  =  APART ; HPAVGSX =  HPAVGS; LPAVGSX =  LPAVGS;
APAVGSX =  APAVGS; HPBADSX =  HPBADS; LPBADSX =  LPBADS;
APBADSX =  APBADS;
OUTPUT SASRMF.PAGEDSN ;
DSCNT  =0; LPBSY  =.; LPAVG    =.; LPPT   =.; LPART  =.; LPAVGS   =.;
LPBADS =.; HPBSY  =0; HPAVG    =0; HPPT   =0; HPART  =0; HPAVGS   =0;
HPBADS =0; APBSY  =0; APAVG    =0; APPT   =0; APART  =0; APAVGS   =0;
APBADS =0;
END;
END; END;
END; SWT75=1;
DATE75=DATEX;
HOUR75=HR;
END; PTR=15; INPUT @PTR COMSIZ PIB2. +16
NO_SAMPL PIB4. @; PTR=PTR+COMSIZ; INPUT @PTR SMF75SCA PIB2.
SMF75SDA PIB2. @; PTR = PTR+SMF75SCA ; INPUT @PTR
    SMF75DSN $CHAR44. (SMF75PST SMF75RV4 SMF75RV5) (PIB1.)
    SMF75TYP PIB4. SMF75CHA PIB2. SMF75VOL $CHAR6. SMF75RV2 PIB5.
   (SMF75SLA SMF75MXU SMF75MNU SMF75AVU SMF75BDS SMF75USE
    SMF75REQ SMF75SIO SMF75PGX SPF75RV8) (PIB4.) @;
PSBSY=((SMF75USE*100)/NO_SAMPL)+.005; *PERCENT BUSY-DATA SET ;
IF SMF75SIO ^= 0 THEN
PSAVG=((SMF75REQ*RMFDUR)/NO_SAMPL)/SMF75SIO; *AVG SERVICE TIME PER SEC;
ELSE PSAVG=0;
PSPT =SMF75PGX/RMFDUR;                *PAGES XFERED PER SEC ;
PSART=SMF75SIO/RMFDUR;                *PAGES DSN ACTIVITY RATE PER SEC;
PSAVGSL=SMF75AVU;                     *AVG SLOTS USED                 ;
PSBADS =SMF75BDS;                     *NUMBER OF BAD SLOTS            ;
DO OVER DSN;
IF DSN = ' ' THEN DSN=SMF75DSN;
IF DSN = SMF75DSN THEN DO;
    DSCNT+1;
    LPBSY   =MIN(  LPBSY ,PSBSY);
    LPAVG   =MIN(  LPAVG ,PSAVG);
    LPPT    =MIN(  LPPT ,PSPT);
    LPART   =MIN(  LPART ,PSART);
    LPAVGS  =MIN(  LPAVGS  ,PSAVGSL);
    LPBADS  =MIN(  LPBADS ,PSBADS);
    HPBSY   =MAX(  HPBSY ,PSBSY);
    HPAVG   =MAX(  HPAVG ,PSAVG);
    HPPT    =MAX(  HPPT ,PSPT);
    HPART   =MAX(  HPART ,PSART);
    HPAVGS  =MAX(  HPAVGS  ,PSAVGSL);
    HPBADS  =MAX(  HPBADS ,PSBADS);
    APBSY   +PSBSY;
    APAVG   +PSAVG;
    APPT    +PSPT;
    APART   +PSART;
    APAVGS  +PSAVGSL;
    APBADS  +PSBADS;
    GOTO SKIP75;
    END;
  END;
SKIP75:
RETURN;
PAGE;
H70I: PUT 'RMF 70 --- CPU ACTIVITY -- EXCEPTIONS -'
    ' DATE=' DATE70 WORDDATE18.;
PUT ' DATE '
    'CPU'
    '<--- % WAIT  ---->'
    '<-  % CPUBSY  >'
    '<  AVG IN RDY >'
    '<  AVG OU RDY >'
    '< TOT ASID >'
    '<- BATCH ASID ->'
    '<-   STC ASID ->'
    '<-   TSO ASID ->' /
    @10
    '  HIGH   LOW   AVG'
    '   HI   LO   AV'
    '   HI   LO   AV'
    '   HI   LO   AV'
    '  HI  LO  AV'
    '  HI  LO  AV MAX'
    '  HI  LO  AV MAX'
    '  HI  LO  AV MAX';
RETURN;
PAGE;
H71S: PUT 'RMF 71 --- STORAGE ANALYSIS -- EXCEPTIONS --'
    ' DATE=' DATE71 WORDDATE18.;
PUT '   DATE           REAL'
    '<----   SQA FRAMES ---->'
    '<-- CSA FIXED-FRAMES -->'
    '<- PAGEABLE CSA FRAMES->'
    '<-- VIO ALLOC SLOTS --->' /
    '                 STOR.'
    '  HIGH   LOW   AVG     .'
    '  HIGH   LOW   AVG     .'
    '  HIGH   LOW   AVG     .'
    '  HIGH   LOW   AVG     .' /
;
RETURN;
H71P: PUT 'RMF 71 --- PAGING RATE REPORT -- EXCEPTIONS --'
    ' DATE=' DATE71 WORDDATE18.;
PUT '   DATE        '
    ' <--------------      '
    'PAGES PER SECOND '
    '      --------------->'
    '<---    PCT SUCESSFULLY    -->' / @17
    '<-  PAGES    ->'
    '<-  FAULTS   ->'
    '<-  DEMAND   ->'
    '<-  SWAP     ->'
    '<-SWAP-IN    ->'
    '<-SWAP-OUT   ->' / @17
    '   HI  LOW  AVG'
    '   HI  LOW  AVG'
    '   HI  LOW  AVG'
    '   HI  LOW  AVG'
    '   HI  LOW  AVG'
    '   HI  LOW  AVG' /;
;
RETURN;
H71SO: PUT 'RMF 71 --- SWAP-OUT PER SECOND (SCALE 1:1/10) ---'
    'EXCEPTIONS/REASONS ---'
    ' DATE=' DATE71 WORDDATE18.;
*    1234567812345678                             ;
*    123456123456123456123456123456123456123456   ;
*    1234123412341234                             ;
PUT '    DATE' /
    '  LONG THINK'
    '   LONG WAIT'
    ' DETECT WAIT'
    '  UNILATERAL'
    '  RECOM VALU'
    '  ENQ EXCHAN'
    '   REQUESTED'
    '  AUX. SHORT'
    '  REAL SHORT'
    ' ASID NONSWP'
    '   TERM WAIT' /
    '  HI LOW  AV'
    '  HI LOW  AV'
    '  HI LOW  AV'
    '  HI LOW  AV'
    '  HI LOW  AV'
    '  HI LOW  AV'
    '  HI LOW  AV'
    '  HI LOW  AV'
    '  HI LOW  AV'
    '  HI LOW  AV'
    '  HI LOW  AV' /;
RETURN;
PAGE;
H72I: PUT 'RMF 72 --- WORKLOAD ACTIVITY --- EXCEPTIONS - '
    ' DATE=' DATE72  WORDDATE18.;
  PUT // '    DATE           '
 '<-  TOT SERV ->'
 '<-  I/O RATE ->'
 '<--   CPU  --->'
 '<--   SRB  --->'
 '<--   MSO  --->'
 '<-TRANS-->'
 '<RESP TME>'
 '<SWAP/TRAN >'
/ '                   '
 '   HI   LO  AVG'
 '   HI   LO  AVG'
 '   HI   LO  AVG'
 '   HI   LO  AVG'
 '   HI   LO  AVG'
 '   HI  AVG'
 '   HI  AVG'
 '    HI   AVG';
RETURN;
H72PER: PUT 'RMF 72 --- WORKLOAD ACTIVITY --- EXCEPTIONS - '
    ' DATE=' DATE72 WORDDATE18.;
  PUT // ' PG '
 '<-  TOT SERV ->'
 '<-  I/O RATE ->'
 '<--   CPU  --->'
 '<--   SRB  --->'
 '<--   MSO  --->'
 '<-TRANS-->'
 '<RESP TME>'
 '<SWAP/TRAN >'
/ @5
 '   HI   LO  AVG'
 '   HI   LO  AVG'
 '   HI   LO  AVG'
 '   HI   LO  AVG'
 '   HI   LO  AVG'
 '   HI  AVG'
 '   HI  AVG'
 '    HI   AVG';
RETURN;
PAGE;
H73CHN: PUT 'RMF 73 -- CHANNEL ACTIVITY - '
        '  PHYSICAL EXCEPTIONS -- BY CHANNEL ID '
    ' DATE=' DATE73 WORDDATE18.;
PUT ' CHNID '
'<-ACTIVITY RATE ->'
'<- % CHAN BUSY  ->'
'<-AVG SERV TIME ->'
'% CHN BSY & CPU WT' /
@7
'  HIGH   LOW   AVG'
'  HIGH   LOW   AVG'
'  HIGH   LOW   AVG'
'  HIGH   LOW   AVG' ;
RETURN;
PAGE;
H74VOL: PUT 'RMF 74 --- DEVICE ACTIVITY - EXCEPTIONS '
 '   BY VOLUME SERIAL    '
    ' DATE=' DATE74 WORDDATE18.;
PUT 'VOLSER '
   ' % NOT READY'
   '% DEV BSY BE'
   '% DEV BSY NB'
   '% RESV DELAY'
   ' % RESERVED '
   ' SIO PER SEC'
   'AVG SERV/SIO BE'
   'AVG SERV/SIO NB'
   'AVG QUEUE LNGTH' / @8
   '  HI  LO AVG'
   '  HI  LO AVG'
   '  HI  LO AVG'
   '  HI  LO AVG'
   '  HI  LO AVG'
   '  HI  LO AVG'
   '   HI   LO  AVG'
   '   HI   LO  AVG'
   '   HI   LO  AVG' ;
RETURN;
PAGE;
PROC SORT DATA=SASRMF.DEV;      BY DATEX HR VOLX;
PROC SORT DATA=SASRMF.CPU;      BY DATEX HR;
PROC SORT DATA=SASRMF.WORKLOAD; BY DATEX HR;
PROC SORT DATA=SASRMF.PAGING;   BY DATEX HR;
PROC SORT DATA=SASRMF.PAGEDSN;  BY DATEX HR DSNX;
PROC SORT DATA=SASRMF.CHANNELS; BY DATEX HR CXAN;
//*-----------------------------------------------------------------
//* FOR HOURLY REPORTING/PLOTTING REPORT ------
//* SHOW COMPUTER PERFORMANCE STATISTICS BY DAVE RIKER 11/21/84
//* BY MONTHLY, BY DAILY, OR BY PERIOD RUNS YOU HAVE TO SELECT SMFIN
//*-----------------------------------------------------------------
//RMFPLOT EXEC SAS,REGION=2500K,OPTIONS='LINESIZE=132'
//WORK DD UNIT=SYSDA,SPACE=(6160,(9999,9999),,,ROUND)
//SASRMF  DD DSN=&&RMFTABS,DISP=(OLD,PASS),UNIT=SYSDA
//*  SPREAD REPORTS FOR EACH SPECIFIED DAY FOR EASIER READING --
//DAY1   DD  SYSOUT=M,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)
//DAY2   DD  SYSOUT=M,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)
//DAY3   DD  SYSOUT=M,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)
//DAY4   DD  SYSOUT=M,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)
//DAY5   DD  SYSOUT=M,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)
//DAY6   DD  SYSOUT=M,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)
//DAY7   DD  SYSOUT=M,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)
//DAY8   DD  SYSOUT=M,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)
//DAY9   DD  SYSOUT=M,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)
//DAY10  DD  SYSOUT=M,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)
//DAY11  DD  SYSOUT=M,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)
//DAY12  DD  SYSOUT=M,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)
//DAY13  DD  SYSOUT=M,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)
//DAY14  DD  SYSOUT=M,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)
//DAY15  DD  SYSOUT=M,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)
//DAY16  DD  SYSOUT=M,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)
//DAY17  DD  SYSOUT=M,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)
//DAY18  DD  SYSOUT=M,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)
//DAY19  DD  SYSOUT=M,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)
//DAY20  DD  SYSOUT=M,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)
//DAY21  DD  SYSOUT=M,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)
//DAY22  DD  SYSOUT=M,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)
//DAY23  DD  SYSOUT=M,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)
//DAY24  DD  SYSOUT=M,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)
//DAY25  DD  SYSOUT=M,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)
//DAY26  DD  SYSOUT=M,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)
//DAY27  DD  SYSOUT=M,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)
//DAY28  DD  SYSOUT=M,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)
//DAY29  DD  SYSOUT=M,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)
//DAY30  DD  SYSOUT=M,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)
//DAY31  DD  SYSOUT=M,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)
//SYSIN  DD  *
OPTIONS  MACROGEN MCOMPILE PS=60 SKIP=0 NODATE S=72 ERROR=3 ;
*-------------------------------------------------------;
*                                                       ;
* MACRO TO PRINT A PLOT OF EIGHT SETS PER PAGE    ------;
*                                                       ;
*-------------------------------------------------------;
MACRO PLOT8UP;
**  LOAD PLT1 THRU PLT8 ARRAYS SO THAT THE HIT IS ASSOCATED WITH ;
**      CORRECT ROW AND COLUMN OF EACH SET;
DO OVER SAMP; * DO EIGHT SET OF SAMPLES;
    PO=HS;
    * CALCULATE FOR INTERVAL FOR EACH PLOT;
    IX=HS;
    IF INTER < 20 THEN IVAL=1;                  * RANGE 0 TO   20;
     ELSE IF INTER < 60  THEN IVAL=3;           * RANGE 0 TO   60;
      ELSE IF INTER < 100 THEN IVAL=5;          * RANGE 0 TO  100;
      ELSE IF INTER < 160 THEN IVAL=8;          * RANGE 0 TO  160;
       ELSE IF INTER < 300 THEN IVAL=15;        * RANGE 0 TO  300;
        ELSE IF INTER < 500 THEN IVAL=25;       * RANGE 0 TO  500;
         ELSE IF INTER < 1000 THEN IVAL=50;     * RANGE 0 TO 1000;
          ELSE IF INTER < 1500 THEN IVAL=75;    * RANGE 0 TO 1500;
           ELSE IF INTER < 2000 THEN IVAL=100;  * RANGE 0 TO 2000;
            ELSE IVAL=200;                      * RANGE 0 TO 4000;
*     TOP INTERVAL: INTERVAL*21;
*  BOTTOM INTERVAL: -INTERVAL;
         PCT=IVAL*21;PCTD=-IVAL;
         INTER=0; * CLEAR FOR NEXT DATE;
  DO HX=1 TO 24; * DO 24 HOUR UNITS TO BE PLOT WITHIN ONE SET;
     BKD=((20-INT(SAMP/IVAL)) * 24) + HX ;
     DO PA=BKD TO 504; * PLOT IT WITHIN A SET;
        PLOT='.';
        PA=505;
     END;
  END;
 END;
** PRINT CONTENTS OF PLOT CHART IN EIGHT SETS PER PAGE ;
PUT _PAGE_  @20 TITLE
    ' AS OF ' DATEX MMDDYY8. @;
   DO KTR1=0 TO 7 BY 4; /* 4 PLOT SETS ARE PRINTED PER LINE */
      PO=KTR1;
      *PRINT ROWS  NAME BANNERS ACCROSS PAGE;
      PUT /@;
         * PRINT CONTENTS OF ARRAYS PLT 1 THRU PLT8 ACROSS PAGE ONE
         * LINE AT A TIME;
         DO PK = 0 TO 20;
            PO=KTR1;
            DO KTR2 = 0 TO 3;
               PO + 1;
               PCT+PCTD;
               PTR = 24 * KTR2 + 9 * KTR2 ;
               PUT @PTR PCT 4. '×' @;
               DO KTR3 = 1 TO 24;
                  PA = 24 * PK + KTR3;
                  PTR1 = PTR + KTR3 + 4;
                  PUT @PTR1 PLOT @;
               END;
             END;
          PUT;
          END;
         DO KTR2= 0 TO 3;
            PTR = 24 * KTR2 + 9 * KTR2 + 4;
            PUT @PTR '+-------------------------' @;
         END;
         PUT ;
         * PRINT HOUR GUIDELINES  ACROSS PAGE;
         DO KTR2= 0 TO 3;
            PTR = 24 * KTR2 + 9 * KTR2 + 4;
            PUT @PTR ' 1.3..6..9.12..3..6..9.12' @;
         END;
         PUT ;
         * PRINT HOUR BANNERS ACROSS PAGE;
         DO KTR2 = 0 TO 3;
            PTR = 24 *KTR2 +9 * KTR2 + 4;
            PUT @PTR ' <--- AM ----><--- PM --->' @;
         END;
         PUT;
         * PRINT TITLE BANNERS ACCROSS PAGE;
         PO=KTR1;
         DO KTR2 = 0 TO 3;
            PO + 1;
            PTR = 24 *KTR2 +9 * KTR2 + 8;
            PUT @PTR PTITL $CHAR20.       @;
         END;
         PUT;
      END;
*  CLEAR PLOT AND SAMPLE FOR NEXT DATE;
DO OVER SAMP; * DO EIGHT SET OF SAMPLES;
    PO=HS;
  DO HX=1 TO 24; * DO 24 HOUR UNITS TO BE PLOT WITHIN ONE SET;
     SAMP=0;
     DO PA=1 TO 504; * CLEAR WITHIN A SET;
        PLOT=' ';
     END;
  END;
 END; %
*-------------------------------------------------------;
*                                                       ;
* MACRO TO DEFINE ARRAYS RETAIN FOR APPLICATION   ------;
*                                                       ;
*-------------------------------------------------------;
MACRO PAGEDATA;
**---- PAGE VALUE TABLE PER POINTER---- **;
ARRAY RMF1  (SX)  KA1-KA24;
ARRAY RMF2  (SX)  KB1-KB24;
ARRAY RMF3  (SX)  KC1-KC24;
ARRAY RMF4  (SX)  KD1-KD24;
ARRAY RMF5  (SX)  KE1-KE24;
ARRAY RMF6  (SX)  KF1-KF24;
ARRAY RMF7  (SX)  KG1-KG24;
ARRAY RMF8  (SX)  KH1-KH24;
ARRAY RMF9  (SX)  KI1-KI24;
ARRAY RMF10 (SX)  KJ1-KJ24;
ARRAY RMF11 (SX)  KK1-KK24;
ARRAY RMF12 (SX)  KL1-KL24;
ARRAY RMF13 (SX)  KM1-KM24;
ARRAY RMF14 (SX)  KN1-KN24;
ARRAY RMF15 (SX)  KO1-KO24;
ARRAY RMF16 (SX)  KP1-KP24;
ARRAY SAMPX (SS)  RMF1-RMF16;
* ---- SAMPLE FOR PLOT ---- ;
ARRAY RXX1  (HX)  SA1-SA24;
ARRAY RXX2  (HX)  SB1-SB24;
ARRAY RXX3  (HX)  SC1-SC24;
ARRAY RXX4  (HX)  SD1-SD24;
ARRAY RXX5  (HX)  SE1-SE24;
ARRAY RXX6  (HX)  SF1-SF24;
ARRAY RXX7  (HX)  SG1-SG24;
ARRAY RXX8  (HX)  SH1-SH24;
ARRAY SAMP  (HS)  RXX1-RXX8;
ARRAY PTITL (PO) $24 PTITL1-PTITL8;
**  DEFINE ARRAYS ;
ARRAY PLT1  (PA) $1 A1-A504;
ARRAY PLT2  (PA) $1 B1-B504;
ARRAY PLT3  (PA) $1 C1-C504;
ARRAY PLT4  (PA) $1 D1-D504;
ARRAY PLT5  (PA) $1 E1-E504;
ARRAY PLT6  (PA) $1 F1-F504;
ARRAY PLT7  (PA) $1 G1-G504;
ARRAY PLT8  (PA) $1 H1-H504;
ARRAY PLOT  (PO)    PLT1-PLT8;
** ARRAY FOR INTERVAL CONTROL OF EACH PLOT;
ARRAY IVAL  (PO)    IVAL1-IVAL8;
ARRAY PCT   (PO)    PCT1-PCT8;
ARRAY PCTD  (PO)    PCTD1-PCTD8;
** HIGHEST VALUE OF THE DAY FOR INTERVAL DECISION;
ARRAY INTER (IX)  INTER1-INTER8;
RETAIN INTER1-INTER8 IVAL1-IVAL8 PCT1-PCT8 PCTD1-PCTD8;
**  RETAIN ARRAYS ;
RETAIN
PAGEH1-PAGEH16 0
SA1-SA24 SB1-SB24 SC1-SC24 SD1-SD24 SE1-SE24 SF1-SF24
SG1-SG24 SH1-SH24
KA1-KA24 KB1-KB24 KC1-KC24 KD1-KD24 KE1-KE24 KF1-KF24
KG1-KG24 KH1-KH24
KI1-KI24 KJ1-KJ24 KK1-KK24 KL1-KL24 KM1-KM24 KN1-KN24
KO1-KO24 KP1-KP24 0
A1-A504 B1-B504 C1-C504
D1-D504 E1-E504 F1-F504 G1-G504 H1-H504 ;
RETAIN PTITL1-PTITL8 PAGE1-PAGE16;
%
*-------------------------------------------------------;
*                                                       ;
* MACRO TO DEFINE ARRAYS RETAIN FOR APPLICATION   ------;
*                                                       ;
*-------------------------------------------------------;
MACRO DEVDATA;
**  DEFINE ARRAYS OF SAMPLES;
**---- DEVICE TABLE ---- **;
ARRAY DEV   (DX)  $6 DEV1-DEV60;
ARRAY DEVH  (DH)     DEVH1-DEVH60;
**---- DEVICE VALUE TABLE PER POINTER---- **;
ARRAY RMF1  (SX)  KA1-KA24;
ARRAY RMF2  (SX)  KB1-KB24;
ARRAY RMF3  (SX)  KC1-KC24;
ARRAY RMF4  (SX)  KD1-KD24;
ARRAY RMF5  (SX)  KE1-KE24;
ARRAY RMF6  (SX)  KF1-KF24;
ARRAY RMF7  (SX)  KG1-KG24;
ARRAY RMF8  (SX)  KH1-KH24;
ARRAY RMF9  (SX)  KI1-KI24;
ARRAY RMF10 (SX)  KJ1-KJ24;
ARRAY RMF11 (SX)  KK1-KK24;
ARRAY RMF12 (SX)  KL1-KL24;
ARRAY RMF13 (SX)  KM1-KM24;
ARRAY RMF14 (SX)  KN1-KN24;
ARRAY RMF15 (SX)  KO1-KO24;
ARRAY RMF16 (SX)  KP1-KP24;
ARRAY RMF17 (SX)  KQ1-KQ24;
ARRAY RMF18 (SX)  KR1-KR24;
ARRAY RMF19 (SX)  KS1-KS24;
ARRAY RMF20 (SX)  KT1-KT24;
ARRAY RMF21 (SX)  KU1-KU24;
ARRAY RMF22 (SX)  KV1-KV24;
ARRAY RMF23 (SX)  KW1-KW24;
ARRAY RMF24 (SX)  KX1-KX24;
ARRAY RMF25 (SX)  KY1-KY24;
ARRAY RMF26 (SX)  KZ1-KZ24;
ARRAY RMF27 (SX)  TA1-TA24;
ARRAY RMF28 (SX)  TB1-TB24;
ARRAY RMF29 (SX)  TC1-TC24;
ARRAY RMF30 (SX)  UA1-UA24;
ARRAY RMF31 (SX)  UB1-UB24;
ARRAY RMF32 (SX)  UC1-UC24;
ARRAY RMF33 (SX)  UD1-UD24;
ARRAY RMF34 (SX)  UE1-UE24;
ARRAY RMF35 (SX)  UF1-UF24;
ARRAY RMF36 (SX)  UG1-UG24;
ARRAY RMF37 (SX)  UH1-UH24;
ARRAY RMF38 (SX)  UI1-UI24;
ARRAY RMF39 (SX)  UJ1-UJ24;
ARRAY RMF40 (SX)  WA1-WA24;
ARRAY RMF41 (SX)  WB1-WB24;
ARRAY RMF42 (SX)  WC1-WC24;
ARRAY RMF43 (SX)  WD1-WD24;
ARRAY RMF44 (SX)  WE1-WE24;
ARRAY RMF45 (SX)  WF1-WF24;
ARRAY RMF46 (SX)  WG1-WG24;
ARRAY RMF47 (SX)  WH1-WH24;
ARRAY RMF48 (SX)  WI1-WI24;
ARRAY RMF49 (SX)  WJ1-WJ24;
ARRAY RMF50 (SX)  VA1-VA24;
ARRAY RMF51 (SX)  VB1-VB24;
ARRAY RMF52 (SX)  VC1-VC24;
ARRAY RMF53 (SX)  VD1-VD24;
ARRAY RMF54 (SX)  VE1-VE24;
ARRAY RMF55 (SX)  VF1-VF24;
ARRAY RMF56 (SX)  VG1-VG24;
ARRAY RMF57 (SX)  VH1-VH24;
ARRAY RMF58 (SX)  VI1-VI24;
ARRAY RMF59 (SX)  VJ1-VJ24;
ARRAY RMF60 (SX)  VK1-VK24;
ARRAY SAMPX (SS)  RMF1-RMF60;
* ---- SAMPLE FOR PLOT ---- ;
ARRAY RXX1  (HX)  SA1-SA24;
ARRAY RXX2  (HX)  SB1-SB24;
ARRAY RXX3  (HX)  SC1-SC24;
ARRAY RXX4  (HX)  SD1-SD24;
ARRAY RXX5  (HX)  SE1-SE24;
ARRAY RXX6  (HX)  SF1-SF24;
ARRAY RXX7  (HX)  SG1-SG24;
ARRAY RXX8  (HX)  SH1-SH24;
ARRAY SAMP  (HS)  RXX1-RXX8;
ARRAY PTITL (PO) $20 PTITL1-PTITL8;
**  DEFINE ARRAYS ;
ARRAY PLT1  (PA) $1 A1-A504;
ARRAY PLT2  (PA) $1 B1-B504;
ARRAY PLT3  (PA) $1 C1-C504;
ARRAY PLT4  (PA) $1 D1-D504;
ARRAY PLT5  (PA) $1 E1-E504;
ARRAY PLT6  (PA) $1 F1-F504;
ARRAY PLT7  (PA) $1 G1-G504;
ARRAY PLT8  (PA) $1 H1-H504;
ARRAY PLOT  (PO)    PLT1-PLT8;
** ARRAY FOR INTERVAL CONTROL OF EACH PLOT;
ARRAY IVAL  (PO)    IVAL1-IVAL8;
ARRAY PCT   (PO)    PCT1-PCT8;
ARRAY PCTD  (PO)    PCTD1-PCTD8;
** HIGHEST VALUE OF THE DAY FOR INTERVAL DECISION;
ARRAY INTER (IX)  INTER1-INTER8;
RETAIN INTER1-INTER8 IVAL1-IVAL8 PCT1-PCT8 PCTD1-PCTD8;
**  RETAIN ARRAYS ;
RETAIN
DEVH1-DEVH60 0
SA1-SA24 SB1-SB24 SC1-SC24 SD1-SD24 SE1-SE24 SF1-SF24
SG1-SG24 SH1-SH24
KA1-KA24 KB1-KB24 KC1-KC24 KD1-KD24 KE1-KE24 KF1-KF24
KG1-KG24 KH1-KH24
KI1-KI24 KJ1-KJ24 KK1-KK24 KL1-KL24 KM1-KM24 KN1-KN24
KO1-KO24 KP1-KP24 KQ1-KQ24 KR1-KR24 KS1-KS24 KT1-KT24
KU1-KU24 KV1-KV24 KW1-KW24 KX1-KX24 KY1-KY24 KZ1-KZ24
TA1-TA24 TB1-TB24 TC1-TC24 UA1-UA24 UB1-UB24 UC1-UC24
UD1-UD24 UE1-UE24 UF1-UF24 UG1-UG24 UH1-UH24 UI1-UI24
UJ1-UJ24 WA1-WA24 WB1-WB24 WC1-WC24 WD1-WD24 WE1-WE24
WF1-WF24 WG1-WG24 WH1-WH24 WI1-WI24 WJ1-WJ24 VA1-VA24
VB1-VB24 VC1-VC24 VD1-VD24 VE1-VE24 VF1-VF24 VG1-VG24
VH1-VH24 VI1-VI24 VJ1-VJ24 VK1-VK24 0
A1-A504 B1-B504 C1-C504
D1-D504 E1-E504 F1-F504 G1-G504 H1-H504 ;
RETAIN PTITL1-PTITL8 DEV1-DEV60;
%
*-------------------------------------------------------;
*                                                       ;
* MACRO TO DEFINE ARRAYS RETAIN FOR APPLICATION   ------;
*                                                       ;
*-------------------------------------------------------;
MACRO CPUDATA;
**  DEFINE ARRAYS OF SAMPLES;
ARRAY RMF1  (HX)  SA1-SA24;
ARRAY RMF2  (HX)  SB1-SB24;
ARRAY RMF3  (HX)  SC1-SC24;
ARRAY RMF4  (HX)  SD1-SD24;
ARRAY RMF5  (HX)  SE1-SE24;
ARRAY RMF6  (HX)  SF1-SF24;
ARRAY RMF7  (HX)  SG1-SG24;
ARRAY RMF8  (HX)  SH1-SH24;
ARRAY SAMP  (HS)  RMF1-RMF8;
ARRAY PTITL (PO) $20 PTITL1-PTITL8;
**  DEFINE ARRAYS ;
ARRAY PLT1  (PA) $1 A1-A504;
ARRAY PLT2  (PA) $1 B1-B504;
ARRAY PLT3  (PA) $1 C1-C504;
ARRAY PLT4  (PA) $1 D1-D504;
ARRAY PLT5  (PA) $1 E1-E504;
ARRAY PLT6  (PA) $1 F1-F504;
ARRAY PLT7  (PA) $1 G1-G504;
ARRAY PLT8  (PA) $1 H1-H504;
ARRAY PLOT  (PO)    PLT1-PLT8;
** ARRAY FOR INTERVAL CONTROL OF EACH PLOT;
ARRAY IVAL  (PO)    IVAL1-IVAL8;
ARRAY PCT   (PO)    PCT1-PCT8;
ARRAY PCTD  (PO)    PCTD1-PCTD8;
** HIGHEST VALUE OF THE DAY FOR INTERVAL DECISION;
ARRAY INTER (IX)  INTER1-INTER8;
RETAIN INTER1-INTER8 IVAL1-IVAL8 PCT1-PCT8 PCTD1-PCTD8;
**  RETAIN ARRAYS ;
RETAIN
SA1-SA24 SB1-SB24 SC1-SC24 SD1-SD24 SE1-SE24 SF1-SF24
SG1-SG24 SH1-SH24 0 A1-A504 B1-B504 C1-C504
D1-D504 E1-E504 F1-F504 G1-G504 H1-H504 ;
RETAIN PTITL1-PTITL8;
%
*-------------------------------------------------------;
*                                                       ;
* MACRO TO DEFINE ARRAYS RETAIN FOR APPLICATION   ------;
*                                                       ;
*-------------------------------------------------------;
MACRO SERVDATA;
**  DEFINE ARRAYS OF SAMPLES;
** RAW DATA VALUES FOR EACH HOUR ;
ARRAY RMF1  (HX)  SA1-SA24;
ARRAY RMF2  (HX)  SB1-SB24;
ARRAY RMF3  (HX)  SC1-SC24;
ARRAY RMF4  (HX)  SD1-SD24;
ARRAY RMF5  (HX)  SE1-SE24;
ARRAY RMF6  (HX)  SF1-SF24;
ARRAY RMF7  (HX)  SG1-SG24;
ARRAY RMF8  (HX)  SH1-SH24;
ARRAY SAMP  (HS)  RMF1-RMF8;
ARRAY PTITL (PO) $20 PTITL1-PTITL8;
**  DEFINE ARRAYS ;
ARRAY PLT1  (PA) $1 A1-A504;
ARRAY PLT2  (PA) $1 B1-B504;
ARRAY PLT3  (PA) $1 C1-C504;
ARRAY PLT4  (PA) $1 D1-D504;
ARRAY PLT5  (PA) $1 E1-E504;
ARRAY PLT6  (PA) $1 F1-F504;
ARRAY PLT7  (PA) $1 G1-G504;
ARRAY PLT8  (PA) $1 H1-H504;
ARRAY PLOT  (PO)    PLT1-PLT8;
** ARRAY FOR INTERVAL CONTROL OF EACH PLOT;
ARRAY IVAL  (PO)    IVAL1-IVAL8;
ARRAY PCT   (PO)    PCT1-PCT8;
ARRAY PCTD  (PO)    PCTD1-PCTD8;
** HIGHEST VALUE OF THE DAY FOR INTERVAL DECISION;
ARRAY INTER (IX)  INTER1-INTER8;
RETAIN INTER1-INTER8 IVAL1-IVAL8 PCT1-PCT8 PCTD1-PCTD8;
**  RETAIN ARRAYS ;
RETAIN
SA1-SA24 SB1-SB24 SC1-SC24 SD1-SD24 SE1-SE24 SF1-SF24
SG1-SG24 SH1-SH24 0 A1-A504 B1-B504 C1-C504
D1-D504 E1-E504 F1-F504 G1-G504 H1-H504 ;
RETAIN PTITL1-PTITL8;
%
*-------------------------------------------------------;
*                                                       ;
* MACRO TO DEFINE ARRAYS/RETAIN FOR CHANNELS       -----;
*                                                       ;
*-------------------------------------------------------;
MACRO CHANDATA;
**---- CHNICE VALUE TABLE PER POINTER---- **;
ARRAY RMF1  (SX)  KA1-KA24;
ARRAY RMF2  (SX)  KB1-KB24;
ARRAY RMF3  (SX)  KC1-KC24;
ARRAY RMF4  (SX)  KD1-KD24;
ARRAY RMF5  (SX)  KE1-KE24;
ARRAY RMF6  (SX)  KF1-KF24;
ARRAY RMF7  (SX)  KG1-KG24;
ARRAY RMF8  (SX)  KH1-KH24;
ARRAY RMF9  (SX)  KI1-KI24;
ARRAY RMF10 (SX)  KJ1-KJ24;
ARRAY RMF11 (SX)  KK1-KK24;
ARRAY RMF12 (SX)  KL1-KL24;
ARRAY RMF13 (SX)  KM1-KM24;
ARRAY RMF14 (SX)  KN1-KN24;
ARRAY RMF15 (SX)  KO1-KO24;
ARRAY RMF16 (SX)  KP1-KP24;
ARRAY SAMPX (SS)  RMF1-RMF16;
* ---- SAMPLE FOR PLOT ---- ;
ARRAY RXX1  (HX)  SA1-SA24;
ARRAY RXX2  (HX)  SB1-SB24;
ARRAY RXX3  (HX)  SC1-SC24;
ARRAY RXX4  (HX)  SD1-SD24;
ARRAY RXX5  (HX)  SE1-SE24;
ARRAY RXX6  (HX)  SF1-SF24;
ARRAY RXX7  (HX)  SG1-SG24;
ARRAY RXX8  (HX)  SH1-SH24;
ARRAY SAMP  (HS)  RXX1-RXX8;
ARRAY PTITL (PO) $20 PTITL1-PTITL8;
**  DEFINE ARRAYS ;
ARRAY PLT1  (PA) $1 A1-A504;
ARRAY PLT2  (PA) $1 B1-B504;
ARRAY PLT3  (PA) $1 C1-C504;
ARRAY PLT4  (PA) $1 D1-D504;
ARRAY PLT5  (PA) $1 E1-E504;
ARRAY PLT6  (PA) $1 F1-F504;
ARRAY PLT7  (PA) $1 G1-G504;
ARRAY PLT8  (PA) $1 H1-H504;
ARRAY PLOT  (PO)    PLT1-PLT8;
** ARRAY FOR INTERVAL CONTROL OF EACH PLOT;
ARRAY IVAL  (PO)    IVAL1-IVAL8;
ARRAY PCT   (PO)    PCT1-PCT8;
ARRAY PCTD  (PO)    PCTD1-PCTD8;
** HIGHEST VALUE OF THE DAY FOR INTERVAL DECISION;
ARRAY INTER (IX)  INTER1-INTER8;
RETAIN INTER1-INTER8 IVAL1-IVAL8 PCT1-PCT8 PCTD1-PCTD8;
**  RETAIN ARRAYS ;
RETAIN
SA1-SA24 SB1-SB24 SC1-SC24 SD1-SD24 SE1-SE24 SF1-SF24
SG1-SG24 SH1-SH24
KA1-KA24 KB1-KB24 KC1-KC24 KD1-KD24 KE1-KE24 KF1-KF24
KG1-KG24 KH1-KH24
KI1-KI24 KJ1-KJ24 KK1-KK24 KL1-KL24 KM1-KM24 KN1-KN24
KO1-KO24 KP1-KP24 0
A1-A504 B1-B504 C1-C504
D1-D504 E1-E504 F1-F504 G1-G504 H1-H504 ;
RETAIN PTITL1-PTITL8 CHN1-CHN16;
%
*-------------------------------------------------------;
*                                                       ;
* MACRO TO DEFINE FILE STATEMENT FOR SPECIFIED DAY -----;
*                                                       ;
*-------------------------------------------------------;
MACRO PRTDATE;
DAYN=DAY(DATEX); * PUT PLOT INTO DAY SYSOUT FOR EASIER READING;
IF DAYN = 1 THEN FILE DAY1 PRINT NOTITLES;
ELSE IF  DAYN = 2 THEN FILE DAY2 PRINT NOTITLES;
ELSE IF  DAYN = 3 THEN FILE DAY3 PRINT NOTITLES;
ELSE IF  DAYN = 4 THEN FILE DAY4 PRINT NOTITLES;
ELSE IF  DAYN = 5 THEN FILE DAY5 PRINT NOTITLES;
ELSE IF  DAYN = 6 THEN FILE DAY6 PRINT NOTITLES;
ELSE IF  DAYN = 7 THEN FILE DAY7 PRINT NOTITLES;
ELSE IF  DAYN = 8 THEN FILE DAY8 PRINT NOTITLES;
ELSE IF  DAYN = 9 THEN FILE DAY9 PRINT NOTITLES;
ELSE IF  DAYN = 10 THEN FILE DAY10 PRINT NOTITLES;
ELSE IF  DAYN = 11 THEN FILE DAY11 PRINT NOTITLES;
ELSE IF  DAYN = 12 THEN FILE DAY12 PRINT NOTITLES;
ELSE IF  DAYN = 13 THEN FILE DAY13 PRINT NOTITLES;
ELSE IF  DAYN = 14 THEN FILE DAY14 PRINT NOTITLES;
ELSE IF  DAYN = 15 THEN FILE DAY15 PRINT NOTITLES;
ELSE IF  DAYN = 16 THEN FILE DAY16 PRINT NOTITLES;
ELSE IF  DAYN = 17 THEN FILE DAY17 PRINT NOTITLES;
ELSE IF  DAYN = 18 THEN FILE DAY18 PRINT NOTITLES;
ELSE IF  DAYN = 19 THEN FILE DAY19 PRINT NOTITLES;
ELSE IF  DAYN = 20 THEN FILE DAY20 PRINT NOTITLES;
ELSE IF  DAYN = 21 THEN FILE DAY21 PRINT NOTITLES;
ELSE IF  DAYN = 22 THEN FILE DAY22 PRINT NOTITLES;
ELSE IF  DAYN = 23 THEN FILE DAY23 PRINT NOTITLES;
ELSE IF  DAYN = 24 THEN FILE DAY24 PRINT NOTITLES;
ELSE IF  DAYN = 25 THEN FILE DAY25 PRINT NOTITLES;
ELSE IF  DAYN = 26 THEN FILE DAY26 PRINT NOTITLES;
ELSE IF  DAYN = 27 THEN FILE DAY27 PRINT NOTITLES;
ELSE IF  DAYN = 28 THEN FILE DAY28 PRINT NOTITLES;
ELSE IF  DAYN = 29 THEN FILE DAY29 PRINT NOTITLES;
ELSE IF  DAYN = 30 THEN FILE DAY30 PRINT NOTITLES;
ELSE IF  DAYN = 31 THEN FILE DAY31 PRINT NOTITLES;
%
*-------------------------------------------------------;
*                                                       ;
*-----   PRINT BANNERS OF DAY/MONTH/YEAR          ------;
*                                                       ;
*-------------------------------------------------------;
DATA _NULL_; * PRINT BANNERS BY DAY MONTH AND YEAR;
OPTIONS MISSING=' ';
**  DEFINE INPUT FILE;
SET  SASRMF.DEV END=EOF; BY DATEX HR;
IF LAST.DATEX × EOF THEN DO;
LENGTH STR $ 20;
LENGTH STRM $ 20;
LENGTH YEAR $ 4;
DAYN=DAY(DATEX); * PUT PAGE BANNER ON SYSOUT FOR EASIER READING;
MONTH=MONTH(DATEX);YEAR=YEAR(DATEX);
IF MONTH = 1        THEN STRM= '/JANUARY/' ×× YEAR ×× '/';
  ELSE IF MONTH = 2 THEN STRM= '/FEBRUARY/' ×× YEAR ×× '/';
  ELSE IF MONTH = 3 THEN STRM= '/MARCH/'    ×× YEAR ×× '/';
  ELSE IF MONTH = 4 THEN STRM= '/APRIL/'    ×× YEAR ×× '/';
  ELSE IF MONTH = 5 THEN STRM= '/MAY/'      ×× YEAR ×× '/';
  ELSE IF MONTH = 6 THEN STRM= '/JUNE/'     ×× YEAR ×× '/';
  ELSE IF MONTH = 7 THEN STRM= '/JULY/'     ×× YEAR ×× '/';
  ELSE IF MONTH = 8 THEN STRM= '/AUGUST/'   ×× YEAR ×× '/';
  ELSE IF MONTH = 9 THEN STRM= '/SEPTEMBER/' ×× YEAR ×× '/';
  ELSE IF MONTH = 10 THEN STRM= '/OCTOBER/'  ×× YEAR ×× '/';
  ELSE IF MONTH = 11 THEN STRM= '/NOVEMBER/' ×× YEAR ×× '/';
  ELSE IF MONTH = 12 THEN STRM= '/DECEMBER/' ×× YEAR ×× '/';
 IF DAYN = 1       THEN STR='(DAY1)/1'   ×× STRM;
ELSE IF  DAYN = 2 THEN  STR='(DAY2)/2'   ×× STRM;
ELSE IF  DAYN = 3 THEN  STR='(DAY3)/3'   ×× STRM;
ELSE IF  DAYN = 4 THEN  STR='(DAY4)/4'   ×× STRM;
ELSE IF  DAYN = 5 THEN  STR='(DAY5)/5'   ×× STRM;
ELSE IF  DAYN = 6 THEN  STR='(DAY6)/6'   ×× STRM;
ELSE IF  DAYN = 7 THEN  STR='(DAY7)/7'   ×× STRM;
ELSE IF  DAYN = 8 THEN  STR='(DAY8)/8'   ×× STRM;
ELSE IF  DAYN = 9 THEN  STR='(DAY9)/9'   ×× STRM;
ELSE IF  DAYN = 10 THEN STR='(DAY10)/10' ×× STRM;
ELSE IF  DAYN = 11 THEN STR='(DAY11)/11' ×× STRM;
ELSE IF  DAYN = 12 THEN STR='(DAY12)/12' ×× STRM;
ELSE IF  DAYN = 13 THEN STR='(DAY13)/13' ×× STRM;
ELSE IF  DAYN = 14 THEN STR='(DAY14)/14' ×× STRM;
ELSE IF  DAYN = 15 THEN STR='(DAY15)/15' ×× STRM;
ELSE IF  DAYN = 16 THEN STR='(DAY16)/16' ×× STRM;
ELSE IF  DAYN = 17 THEN STR='(DAY17)/17' ×× STRM;
ELSE IF  DAYN = 18 THEN STR='(DAY18)/18' ×× STRM;
ELSE IF  DAYN = 19 THEN STR='(DAY19)/19' ×× STRM;
ELSE IF  DAYN = 20 THEN STR='(DAY20)/20' ×× STRM;
ELSE IF  DAYN = 21 THEN STR='(DAY21)/21' ×× STRM;
ELSE IF  DAYN = 22 THEN STR='(DAY22)/22' ×× STRM;
ELSE IF  DAYN = 23 THEN STR='(DAY23)/23' ×× STRM;
ELSE IF  DAYN = 24 THEN STR='(DAY24)/24' ×× STRM;
ELSE IF  DAYN = 25 THEN STR='(DAY25)/25' ×× STRM;
ELSE IF  DAYN = 26 THEN STR='(DAY26)/26' ×× STRM;
ELSE IF  DAYN = 27 THEN STR='(DAY27)/27' ×× STRM;
ELSE IF  DAYN = 28 THEN STR='(DAY28)/28' ×× STRM;
ELSE IF  DAYN = 29 THEN STR='(DAY29)/29' ×× STRM;
ELSE IF  DAYN = 30 THEN STR='(DAY30)/30' ×× STRM;
ELSE IF  DAYN = 31 THEN STR='(DAY31)/31' ×× STRM;
CALL BLOKHEAD(STR); *ASM PGM TO PRINT BLOCK HEAD PAGE;
     END;
RETURN;
*-------------------------------------------------------;
*                                                       ;
*-----   VOLUME SERIAL ANLYSIS AND PERFORMANCE    ------;
*                                                       ;
*-------------------------------------------------------;
DATA _NULL_; * DEVICE PERFORMANCE IN PLOTTING;
OPTIONS MISSING=' ';
**  DEFINE INPUT FILE;
SET SASRMF.DEV END=EOF; BY DATEX HR;
DEVDATA;
**  ESTABLISH INPUT AND OUTPUT FILE;
IF HR = . THEN DELETE;
FILE PRINT NOTITLES;
DO OVER SAMPX;
DO SX=HR TO 24;
* SAMPLES DEV  ( KEEP = DATEX HR VOLX HDNTX LDNTX ADNTX HBSYBX LBSYBX
          ABSYBX HBSYNX LBSYNX ABSYNX HRDX LRDX ARDX HRAX LRX ARX HARTX
          LARTX AARTX HAVBEX LAVBEX AAVBEX HAVNBX LAVNBX AAVNBX HAQX
          LAQX AAQX);
DO DX=1 TO 60;
IF DEV = '      ' THEN DEV=VOLX;
IF DEV = VOLX THEN DO;
   SS=DX;
   DH=DX;
   SAX=INT(ABSYNX);
   DEVH=MAX(DEVH,SAX);
   SAMPX=INT(SAX);
* PUT 'TAB: ' HR= VOLX= ABSYNX= DEV= DEVH= SAMPX= DX= DH=;
   DX=60;
   END;
END;
SX=24; END;
SS=60; END;
IF LAST.DATEX × EOF THEN DO;
PRTDATE;
* SELECT TOP EIGHT DEVICES WITH HIGHEST BUSY VALUE ;
DO OVER SAMP;
PO=HS;
 DO DX=1 TO 60;
  DO OVER SAMPX;
  DH=DX;
* PUT 'TAB: '  DEV= DEVH= PO= HS= DH= DX=;
  IF DEVH > 35 THEN DO; * THESHOLD PERCENTAGE ADJUSTABLE HERE;
     PTITL=DEV;
     PTITL='        ' ×× PTITL ;
     SS=DX;
 *   PUT 'HIT: '  DEV= DEVH=;
     DO HX=1 TO 24;
        SX=HX;
        SAMP=SAMPX;
        IX=HS;INTER=MAX(INTER,SAMP);
        END;
     HS+1; PO=HS;
     END;
     DEVH=0; *CLEAR FOR NEXT DAY;
   SS=60; END;
   IF PO=9 THEN DX=60;
  END;
  HS=8;
END;
RETAIN TITLE;
TITLE='VOLUME SERIAL BUSY OVER 35% ';
PLOT8UP;
     END;
RETURN;
*-------------------------------------------------------;
*                                                       ;
*-------         CPU PERFORMANCE                  ------;
*                                                       ;
*-------------------------------------------------------;
DATA _NULL_;*  CPU PERFORMANCE WITH PLOTTING;
OPTIONS MISSING=' ';
**  DEFINE INPUT FILE;
SET SASRMF.CPU END=EOF; BY DATEX HR;
CPUDATA;
**  ESTABLISH INPUT AND OUTPUT FILE;
IF HR = . THEN DELETE;
DO OVER SAMP;
DO HX=HR TO 24;
* SAMPLES   CPU ( KEEP = DATEX HR HWAIT LWAIT TWAIT HCPUBUSY
              LCPUBUSY TCPUBUSY HAVGRTT LAVGRTT TAVGRTT
              HAVGOTT LAVGOTT TAVGOTT HTOTASID LTOTASID
              TTOTASID HBTHASID LBTHASID TBTHASID TMAXBTCH
              HSTCASID LSTCASID TSTCASID TMAXSTC HTSOASID
              LTSOASID TTSOASID TMAXTSO );
HS=1; SAMP=INT(TWAIT);
IX=HS;INTER=MAX(INTER,SAMP);
HS=2; SAMP=INT(TCPUBUSY);
IX=HS;INTER=MAX(INTER,SAMP);
HS=3; SAMP=INT(TAVGRTT*100); * SCALE 1=.01 ;
IX=HS;INTER=MAX(INTER,SAMP);
HS=4; SAMP=INT(TAVGOTT*100); * SCALE 1=.01;
IX=HS;INTER=MAX(INTER,SAMP);
HS=5; SAMP=INT(TTOTASID);
IX=HS;INTER=MAX(INTER,SAMP);
HS=6; SAMP=INT(TBTHASID);
IX=HS;INTER=MAX(INTER,SAMP);
HS=7; SAMP=INT(TSTCASID);
IX=HS;INTER=MAX(INTER,SAMP);
HS=8; SAMP=INT(TTSOASID);
IX=HS;INTER=MAX(INTER,SAMP);
HX=24;END; HS=8 ;END;
IF LAST.DATEX × EOF THEN DO;
PRTDATE;
PO=1;PTITL=' CPU WAIT IN PCT' ;
PO=2;PTITL=' CPU BUSY IN PCT' ;
PO=3;PTITL='AVG IN READY (.01)' ;
PO=4;PTITL='AVG OUT READY(.01)' ;
*           12345678901234567890;
PO=5;PTITL='   TOTAL ASID' ;
PO=6;PTITL='   BATCH JOBS' ;
PO=7;PTITL='    STC ASIDS' ;
PO=8;PTITL='    TSO USERS' ;
RETAIN TITLE;TITLE='CPU PERFORMANCE ';
PLOT8UP;
     END;
RETURN;
*-------------------------------------------------------;
*                                                       ;
*------     SERVICE ANALYSIS AND PERFORMANCE       -----;
*                                                       ;
*-------------------------------------------------------;
DATA _NULL_;* PAGING WORKLOAD PERFORMANCE WITH PLOTTING;
OPTIONS MISSING=' ';
**  DEFINE INPUT FILE;
SET SASRMF.WORKLOAD END=EOF; BY DATEX HR;
SERVDATA;
**  ESTABLISH INPUT AND OUTPUT FILE;
IF HR = . THEN DELETE;
DO OVER SAMP;
DO HX=HR TO 24;
*      WORKLOAD ( KEEP =DATEX HR HTOTSRV LTOTSRV ATOTSRV HIOSRV
           LIOSRV AIOSRV HCPUSRV LCPUSRV ACPUSRV HSRBSRV
           LSRBSRV ASRBSRV HMSOSRV LMSOSRV AMSOSRV HTRANS
           AITRANS HRTIME  ARTIME HSPERTRA  ASPERTRA);
HS=1; SAMP=INT(ATOTSRV);
IX=HS;INTER=MAX(INTER,SAMP);
HS=2; SAMP=INT(AIOSRV);
IX=HS;INTER=MAX(INTER,SAMP);
HS=3; SAMP=INT(ACPUSRV);
IX=HS;INTER=MAX(INTER,SAMP);
HS=4; SAMP=INT(ASRBSRV);
IX=HS;INTER=MAX(INTER,SAMP);
HS=5; SAMP=INT(AMSOSRV);
IX=HS;INTER=MAX(INTER,SAMP);
HS=6; SAMP=INT(ARTIME);
IX=HS;INTER=MAX(INTER,SAMP);
HS=7; SAMP=INT(ASPERTRA*100); * SCALE: 1 = .01;
IX=HS;INTER=MAX(INTER,SAMP);
HS=8; SAMP=INT(AITRANS*100);  * SCALE 1 = .01;
IX=HS;INTER=MAX(INTER,SAMP);
HX=24;END; HS=8 ;END;
IF LAST.DATEX × EOF THEN DO;
PRTDATE;
PO=1;PTITL='TOT SERVICE RATE ' ;
PO=2;PTITL='I/O SERVICE RATE ' ;
PO=3;PTITL='CPU SERVICE RATE ' ;
PO=4;PTITL='SRB SERVICE RATE ' ;
PO=5;PTITL='MSO SERVICE RATE ' ;
PO=6;PTITL=' REPONSE TIME' ;
PO=7;PTITL=' SWAP/TRANS(.01)';
PO=8;PTITL=' TRANS/SEC (.01)' ;
RETAIN TITLE;
TITLE='SERVICE RATE';
PLOT8UP;
     END;
RETURN;
*-------------------------------------------------------;
*                                                       ;
* CPU AND PAGING STORAGE ANALYSIS AND PERFORMANCE ------;
*                                                       ;
*-------------------------------------------------------;
DATA _NULL_;* PAGING PERFORMANCE WITH PLOTTING;
OPTIONS MISSING=' ';
**  DEFINE INPUT FILE;
SET SASRMF.PAGING END=EOF; BY DATEX HR;
CPUDATA;
**  ESTABLISH INPUT AND OUTPUT FILE;
IF HR = . THEN DELETE;
DO OVER SAMP;
DO HX=HR TO 24;
*        PAGING ( KEEP = DATEX  HR TSTORAGE HISQA LOSQA TMXSQA
           HICSAF LOCSAF TMXCSAF HICSAP LOCSAP TMXCSAP HIGVIOF
           LOWVIOF TMAXVIOF HTPAGRT LTPAGRT  TTPAGRT HPAGERT
           LPAGERT  TPAGERT HDPAGRT LDPAGRT  TDPAGRT HSWART LSWART
           TSWART HPLSWPIN LPLSWPIN TPLSWPIN HPLSWPOU LPLSWPOU
           TPLSWPOU HPSOCLTT   LPSOCLTT    TPSOCLTT HPSOCLW
           LPSOCLW    TPSOCLW HPSOCDW    LPSOCDW    TPSOCDW HPSOCU
           LPSOCU     TPSOCU HPSCEORV   LPSCEORV   TPSCEORV
           HPSCENQE   LPSCENQE   TPSCENQE HPSOCERQ   LPSOCERQ
           TPSOCERQ HPSCAXSS   LPSCAXSS   TPSCAXSS HPSCRPSS
           LPSCRPSS   TPSCRPSS HPSCTONS   LPSCTONS   TPSCTONS
           HPSOCTW    LPSOCTW    TPSOCTW);
HS=1; SAMP=INT(TMXSQA);
IX=HS;INTER=MAX(INTER,SAMP);
HS=2; SAMP=INT(TMXCSAF);
IX=HS;INTER=MAX(INTER,SAMP);
HS=3; SAMP=INT(TMXCSAP);
IX=HS;INTER=MAX(INTER,SAMP);
HS=4; SAMP=INT(TMAXVIOF);
IX=HS;INTER=MAX(INTER,SAMP);
HS=5; SAMP=INT(TTPAGRT);
IX=HS;INTER=MAX(INTER,SAMP);
HS=6; SAMP=INT(TPAGERT);
IX=HS;INTER=MAX(INTER,SAMP);
HS=7; SAMP=INT(TDPAGRT);
IX=HS;INTER=MAX(INTER,SAMP);
HS=8; SAMP=INT(TSWART);
IX=HS;INTER=MAX(INTER,SAMP);
HX=24;END; HS=8 ;END;
IF LAST.DATEX × EOF THEN DO;
PRTDATE;
PO=1;PTITL='    SQA FRAMES' ;
PO=2;PTITL='  CSA FIXED FRAMES' ;
PO=3;PTITL=' PAGEABLE CSA FRAMES' ;
PO=4;PTITL='  VIO ALLOC SLOTS' ;
PO=5;PTITL='  PAGES PER SECOND';
*           12345678901234567890;
PO=6;PTITL='  FAULTED PAGES/SEC';
PO=7;PTITL=' DEMANDED PAGES/SEC';
PO=8;PTITL='  SWAPPED PAGES/SEC';
RETAIN TITLE;
TITLE='PAGING STORAGE PERFORMANCE';
PLOT8UP;
     END;
RETURN;
*-------------------------------------------------------;
*                                                       ;
*------     PAGE/DSN ANLYSIS AND PERFORMANCE       -----;
*                                                       ;
*-------------------------------------------------------;
DATA _NULL_;* PAGE DSN PERFORMANCE WITH PLOTTING;
OPTIONS MISSING=' ';
**  DEFINE INPUT FILE;
SET SASRMF.PAGEDSN END=EOF; BY DATEX HR;

**  DEFINE ARRAYS OF SAMPLES;
**---- PAGE TABLE ---- **;
ARRAY PAGE  (DX)  $40 PAGE1-PAGE16;
ARRAY PAGEH (DH)     PAGEH1-PAGEH16;
PAGEDATA;
**  ESTABLISH INPUT AND OUTPUT FILE;
IF HR = . THEN DELETE;
DO OVER SAMPX;
DO SX=HR TO 24;
*      PAGEDSN (KEEP= DATEX HR DSNX HPBSYX LPBSYX APBSYX HPAVGX LPAVGX
           APAVGX HPPTX LPPTX APPTX HPARTX LPARTX APARTX HPAVGSX
           LPAVGSX APAVGSX HPBADSX LPBADSX APBADSX) ;
DO DX=1 TO 10;
IF PAGE = '      ' THEN PAGE=DSNX;
IF PAGE = DSNX THEN DO;
   SS=DX;
   DH=DX;
   SAX=INT(APBSYX);
   PAGEH=MAX(PAGEH,SAX);
   SAMPX=INT(SAX);
* PUT 'TAB: ' HR= CXAN= AXBSY= PAGE= PAGEH= SAMPX= DX= DH=;
   DX=10;
   END;
END;
SX=24; END;
SS=60; END;
IF LAST.DATEX × EOF THEN DO;
PRTDATE;
RETAIN TITLE;
TITLE='PAGE/SWAP - BUSY PERCENTAGE - ';
DO OVER SAMP;
PO=HS;
 DO DX=1 TO 10;
  DO OVER SAMPX;
  DH=DX;
    IF PAGE ^= ' ' THEN PTITL=PAGE;
                  ELSE  PTITL='     ';
     SS=DX;
     DO HX=1 TO 24;
        SX=HX;
        SAMP=SAMPX;
        IX=HS;INTER=MAX(INTER,SAMP);
        END;
     HS+1; PO=HS;
*    END;
     PAGEH=0; *CLEAR FOR NEXT DAY;
   SS=60; END;
   IF PO=9 THEN DX=10;
  END;
  HS=8;
END;
PLOT8UP;
     END;
RETURN;
*-------------------------------------------------------;
*                                                       ;
*------     PAGE/DSN ANLYSIS AND PERFORMANCE       -----;
*                                                       ;
*-------------------------------------------------------;
DATA _NULL_;* PAGE DSN PERFORMANCE WITH PLOTTING;
OPTIONS MISSING=' ';
**  DEFINE INPUT FILE;
SET SASRMF.PAGEDSN END=EOF; BY DATEX HR;
**  DEFINE ARRAYS OF SAMPLES;
**---- PAGE TABLE ---- **;
ARRAY PAGE  (DX)  $40 PAGE1-PAGE16;
ARRAY PAGEH (DH)     PAGEH1-PAGEH16;
PAGEDATA;
**  ESTABLISH INPUT AND OUTPUT FILE;
IF HR = . THEN DELETE;
DO OVER SAMPX;
DO SX=HR TO 24;
*      PAGEDSN (KEEP= DATEX HR DSNX HPBSYX LPBSYX APBSYX HPAVGX LPAVGX
           APAVGX HPPTX LPPTX APPTX HPARTX LPARTX APARTX HPAVGSX
           LPAVGSX APAVGSX HPBADSX LPBADSX APBADSX) ;
DO DX=1 TO 10;
IF PAGE = '      ' THEN PAGE=DSNX;
IF PAGE = DSNX THEN DO;
   SS=DX;
   DH=DX;
   SAX=INT(APAVGX*100);* SCALE: 1 = .01 UNITS;
   PAGEH=MAX(PAGEH,SAX);
   SAMPX=INT(SAX);
* PUT 'TAB: ' HR= CXAN= AXBSY= PAGE= PAGEH= SAMPX= DX= DH=;
   DX=10;
   END;
END;
SX=24; END;
SS=60; END;
IF LAST.DATEX × EOF THEN DO;
PRTDATE;
RETAIN TITLE;
TITLE='PAGE/SWAP - AVERAGE SERVICE PER SECOND - ';
DO OVER SAMP;
PO=HS;
 DO DX=1 TO 10;
  DO OVER SAMPX;
  DH=DX;
    IF PAGE ^= ' ' THEN PTITL=PAGE;
                  ELSE  PTITL='     ';
     SS=DX;
     DO HX=1 TO 24;
        SX=HX;
        SAMP=SAMPX;
        IX=HS;INTER=MAX(INTER,SAMP);
        END;
     HS+1; PO=HS;
*    END;
     PAGEH=0; *CLEAR FOR NEXT DAY;
   SS=60; END;
   IF PO=9 THEN DX=10;
  END;
  HS=8;
END;
PLOT8UP;
     END;
RETURN;
*-------------------------------------------------------;
*                                                       ;
*------     PAGE/DSN ANLYSIS AND PERFORMANCE       -----;
*                                                       ;
*-------------------------------------------------------;
DATA _NULL_;* PAGE DSN PERFORMANCE WITH PLOTTING;
OPTIONS MISSING=' ';
**  DEFINE INPUT FILE;
SET SASRMF.PAGEDSN END=EOF; BY DATEX HR;
**  DEFINE ARRAYS OF SAMPLES;
**---- PAGE TABLE ---- **;
ARRAY PAGE  (DX)  $40 PAGE1-PAGE16;
ARRAY PAGEH (DH)     PAGEH1-PAGEH16;
PAGEDATA;
**  ESTABLISH INPUT AND OUTPUT FILE;
IF HR = . THEN DELETE;
DO OVER SAMPX;
DO SX=HR TO 24;
*      PAGEDSN (KEEP= DATEX HR DSNX HPBSYX LPBSYX APBSYX HPAVGX LPAVGX
           APAVGX HPPTX LPPTX APPTX HPARTX LPARTX APARTX HPAVGSX
           LPAVGSX APAVGSX HPBADSX LPBADSX APBADSX) ;
DO DX=1 TO 10;
IF PAGE = '      ' THEN PAGE=DSNX;
IF PAGE = DSNX THEN DO;
   SS=DX;
   DH=DX;
   SAX=INT(APPTX*100);* SCALE: 1 = .01 UNITS;
   PAGEH=MAX(PAGEH,SAX);
   SAMPX=INT(SAX);
* PUT 'TAB: ' HR= CXAN= AXBSY= PAGE= PAGEH= SAMPX= DX= DH=;
   DX=10;
   END;
END;
SX=24; END;
SS=60; END;
IF LAST.DATEX × EOF THEN DO;
PRTDATE;
RETAIN TITLE;
TITLE=
'PAGE/SWAP - PAGES TRANSFER / SECOND - (SCALE: 1=.01 SEC UNIT)';
DO OVER SAMP;
PO=HS;
 DO DX=1 TO 10;
  DO OVER SAMPX;
  DH=DX;
    IF PAGE ^= ' ' THEN PTITL=PAGE;
                  ELSE  PTITL='     ';
     SS=DX;
     DO HX=1 TO 24;
        SX=HX;
        SAMP=SAMPX;
        IX=HS;INTER=MAX(INTER,SAMP);
        END;
     HS+1; PO=HS;
*    END;
     PAGEH=0; *CLEAR FOR NEXT DAY;
   SS=60; END;
   IF PO=9 THEN DX=10;
  END;
  HS=8;
END;
RETAIN TITLE;
PLOT8UP;
     END;
RETURN;
*-------------------------------------------------------;
*                                                       ;
*------     PAGE/DSN ANLYSIS AND PERFORMANCE       -----;
*                                                       ;
*-------------------------------------------------------;
DATA _NULL_;* PAGE DSN PERFORMANCE WITH PLOTTING;
OPTIONS MISSING=' ';
**  DEFINE INPUT FILE;
SET SASRMF.PAGEDSN END=EOF; BY DATEX HR;
**  DEFINE ARRAYS OF SAMPLES;
**---- PAGE TABLE ---- **;
ARRAY PAGE  (DX)  $40 PAGE1-PAGE16;
ARRAY PAGEH (DH)     PAGEH1-PAGEH16;
PAGEDATA;
**  ESTABLISH INPUT AND OUTPUT FILE;
IF HR = . THEN DELETE;
RETAIN TITLE;
TITLE=
'PAGE/SWAP - RATE PER SECOND -  (SCALE: 1 = .01 SECOND UNIT)';
DO OVER SAMPX;
DO SX=HR TO 24;
*      PAGEDSN (KEEP= DATEX HR DSNX HPBSYX LPBSYX APBSYX HPAVGX LPAVGX
           APAVGX HPPTX LPPTX APPTX HPARTX LPARTX APARTX HPAVGSX
           LPAVGSX APAVGSX HPBADSX LPBADSX APBADSX) ;
DO DX=1 TO 10;
IF PAGE = '      ' THEN PAGE=DSNX;
IF PAGE = DSNX THEN DO;
   SS=DX;
   DH=DX;
   SAX=INT(APARTX*100);* SCALE: 1 = .01 UNITS;
   PAGEH=MAX(PAGEH,SAX);
   SAMPX=INT(SAX);
* PUT 'TAB: ' HR= CXAN= AXBSY= PAGE= PAGEH= SAMPX= DX= DH=;
   DX=10;
   END;
END;
SX=24; END;
SS=60; END;
IF LAST.DATEX × EOF THEN DO;
PRTDATE;
DO OVER SAMP;
PO=HS;
 DO DX=1 TO 10;
  DO OVER SAMPX;
  DH=DX;
    IF PAGE ^= ' ' THEN PTITL=PAGE;
                  ELSE  PTITL='     ';
     SS=DX;
     DO HX=1 TO 24;
        SX=HX;
        SAMP=SAMPX;
        IX=HS;INTER=MAX(INTER,SAMP);
        END;
     HS+1; PO=HS;
*    END;
     PAGEH=0; *CLEAR FOR NEXT DAY;
   SS=60; END;
   IF PO=9 THEN DX=10;
  END;
  HS=8;
END;
PLOT8UP;
     END;
RETURN;
*-------------------------------------------------------;
*                                                       ;
*------     PAGE/DSN ANLYSIS AND PERFORMANCE       -----;
*             BY PAGE/DSN                               ;
*-------------------------------------------------------;
DATA _NULL_;* PAGE DSN PERFORMANCE WITH PLOTTING;
OPTIONS MISSING=' ';
**  DEFINE INPUT FILE;
SET SASRMF.PAGEDSN END=EOF; BY DATEX HR;
**  DEFINE ARRAYS OF SAMPLES;
**---- PAGE TABLE ---- **;
ARRAY PAGE  (DX)  $40 PAGE1-PAGE16;
ARRAY PAGEH (DH)     PAGEH1-PAGEH16;
PAGEDATA;
**  ESTABLISH INPUT AND OUTPUT FILE;
IF HR = . THEN DELETE;
RETAIN TITLE;
TITLE='PAGE/SWAP - AVERAGE SLOTS USED';
DO OVER SAMPX;
DO SX=HR TO 24;
*      PAGEDSN (KEEP= DATEX HR DSNX HPBSYX LPBSYX APBSYX HPAVGX LPAVGX
           APAVGX HPPTX LPPTX APPTX HPARTX LPARTX APARTX HPAVGSX
           LPAVGSX APAVGSX HPBADSX LPBADSX APBADSX) ;
DO DX=1 TO 10;
IF PAGE = '      ' THEN PAGE=DSNX;
IF PAGE = DSNX THEN DO;
   SS=DX;
   DH=DX;
   SAX=INT(APAVGSX);
   PAGEH=MAX(PAGEH,SAX);
   SAMPX=INT(SAX);
* PUT 'TAB: ' HR= CXAN= AXBSY= PAGE= PAGEH= SAMPX= DX= DH=;
   DX=10;
   END;
END;
SX=24; END;
SS=60; END;
IF LAST.DATEX × EOF THEN DO;
PRTDATE;
DO OVER SAMP;
PO=HS;
 DO DX=1 TO 10;
  DO OVER SAMPX;
  DH=DX;
    IF PAGE ^= ' ' THEN PTITL=PAGE;
                  ELSE  PTITL='     ';
     SS=DX;
     DO HX=1 TO 24;
        SX=HX;
        SAMP=SAMPX;
        IX=HS;INTER=MAX(INTER,SAMP);
        END;
     HS+1; PO=HS;
*    END;
     PAGEH=0; *CLEAR FOR NEXT DAY;
   SS=60; END;
   IF PO=9 THEN DX=10;
  END;
  HS=8;
END;
PLOT8UP
     END;
RETURN;
*-------------------------------------------------------;
*             PROBLEM # 1                               ;
*------  CHANNELS ANALYSIS AND PERFORMANCE         -----;
*             BY CHANNEL ID                             ;
*-------------------------------------------------------;
DATA _NULL_; *CHANNELS PERFORMANCE WITH PLOTTING;
OPTIONS MISSING=' ';
**  DEFINE INPUT FILE;
SET SASRMF.CHANNELS END=EOF; BY DATEX HR;
**  DEFINE ARRAYS OF SAMPLES;
**---- CHNICE TABLE ---- **;
ARRAY CHN   (DX)  $6 CHN1-CHN16;
ARRAY CHNH  (DH)     CHNH1-CHNH16;
**  RETAIN ARRAYS ;
RETAIN CHNH1-CHNH16 0;
CHANDATA;
**  ESTABLISH INPUT AND OUTPUT FILE;
IF HR = . THEN DELETE;
DO OVER SAMPX;
DO SX=HR TO 24;
*      CHANNELS ( KEEP = DATEX HR CXAN HXRT LXRT AXRT HXBSY LXBSY
          AXBSY HXAVG LXAVG AXAVG HXCWS LXCWS AXCWS ) ;
DO DX=1 TO 16;
IF CHN = '      ' THEN CHN=CXAN;
IF CHN = CXAN THEN DO;
   SS=DX;
   DH=DX;
   SAX=INT(AXBSY);
   CHNH=MAX(CHNH,SAX);
   SAMPX=INT(SAX);
   DX=60;
   END;
END;
SX=24; END;
SS=60; END;
IF LAST.DATEX × EOF THEN DO;
PRTDATE;
DO OVER SAMP;
PO=HS;
 DO DX=1 TO 16;
  DO OVER SAMPX;
  DH=DX;
    IF CHN ^= ' ' THEN  PTITL='CHANNEL #' ×× CHN;
                  ELSE  PTITL='     ';
     SS=DX;
     DO HX=1 TO 24;
        SX=HX;
        SAMP=SAMPX;
        IX=HS;INTER=MAX(INTER,SAMP);
        END;
     HS+1; PO=HS;
     CHNH=0; *CLEAR FOR NEXT DAY;
   SS=60; END;
   IF PO=9 THEN DX=60;
  END;
  HS=8;
END;
RETAIN TITLE; TITLE='CHANNEL BUSY';
PLOT8UP;
     END;
RETURN;
*-------------------------------------------------------;
*             PROBLEM # 2                               ;
*------  CHANNELS ANALYSIS AND PERFORMANCE         -----;
*             BY CHANNEL ID                             ;
*-------------------------------------------------------;
DATA _NULL_; *CHANNELS PEROFRMANCE WITH PLOTTING;
OPTIONS MISSING=' ';
**  DEFINE INPUT FILE;
SET SASRMF.CHANNELS END=EOF; BY DATEX HR;
**  DEFINE ARRAYS OF SAMPLES;
**---- CHNICE TABLE ---- **;
ARRAY CHN   (DX)  $6 CHN1-CHN16;
ARRAY CHNH  (DH)     CHNH1-CHNH16;
**  RETAIN ARRAY ;
RETAIN CHNH1-CHNH16 0 ;
CHANDATA;
**  ESTABLISH INPUT AND OUTPUT FILE;
IF HR = . THEN DELETE;
DO OVER SAMPX;
DO SX=HR TO 24;
*      CHANNELS ( KEEP = DATEX HR CXAN HXRT LXRT AXRT HXBSY LXBSY
          AXBSY HXAVG LXAVG AXAVG HXCWS LXCWS AXCWS ) ;
DO DX=1 TO 16;
IF CHN = '      ' THEN CHN=CXAN;
IF CHN = CXAN THEN DO;
   SS=DX;
   DH=DX;
   SAX=INT(AXRT*10); * SCALE: 1= .1 SEC;
   CHNH=MAX(CHNH,SAX);
   SAMPX=INT(SAX);
   DX=60;
   END;
END;
SX=24; END;
SS=60; END;
IF LAST.DATEX × EOF THEN DO;
PRTDATE;
DO OVER SAMP;
PO=HS;
 DO DX=1 TO 16;
  DO OVER SAMPX;
  DH=DX;
    IF CHN ^= ' ' THEN  PTITL='CHANNEL #' ×× CHN;
                  ELSE  PTITL='     ';
     SS=DX;
     DO HX=1 TO 24;
        SX=HX;
        SAMP=SAMPX;
        IX=HS;INTER=MAX(INTER,SAMP);
        END;
     HS+1; PO=HS;
     CHNH=0; *CLEAR FOR NEXT DAY;
   SS=60; END;
   IF PO=9 THEN DX=60;
  END;
  HS=8;
END;
RETAIN TITLE;
TITLE='CHANNEL ACTIVITY RATE (SCALE: 1= .01 SECOND)';
PLOT8UP;
     END;
RETURN;
*-------------------------------------------------------;
*             PROBLEM # 3                               ;
*------  CHANNELS ANALYSIS AND PERFORMANCE         -----;
*             BY CHANNEL ID                             ;
*-------------------------------------------------------;
DATA _NULL_; * CHANNELS PERFORMANCE WITH PLOTTING;
OPTIONS MISSING=' ';
**  DEFINE INPUT FILE;
SET SASRMF.CHANNELS END=EOF; BY DATEX HR;
**  DEFINE ARRAYS OF SAMPLES;
**---- CHNICE TABLE ---- **;
ARRAY CHN   (DX)  $6 CHN1-CHN16;
ARRAY CHNH  (DH)     CHNH1-CHNH16;
**  RETAIN ARRAY  ;
RETAIN
CHNH1-CHNH16 0;
CHANDATA;
**  ESTABLISH INPUT AND OUTPUT FILE;
IF HR = . THEN DELETE;
DO OVER SAMPX;
DO SX=HR TO 24;
*      CHANNELS ( KEEP = DATEX HR CXAN HXRT LXRT AXRT HXBSY LXBSY
          AXBSY HXAVG LXAVG AXAVG HXCWS LXCWS AXCWS ) ;
DO DX=1 TO 16;
IF CHN = '      ' THEN CHN=CXAN;
IF CHN = CXAN THEN DO;
   SS=DX;
   DH=DX;
   SAX=INT(AXCWS);
   CHNH=MAX(CHNH,SAX);
   SAMPX=INT(SAX);
   DX=60;
   END;
END;
SX=24; END;
SS=60; END;
IF LAST.DATEX × EOF THEN DO;
PRTDATE;
DO OVER SAMP;
PO=HS;
 DO DX=1 TO 16;
  DO OVER SAMPX;
  DH=DX;
    IF CHN ^= ' ' THEN  PTITL='CHANNEL #' ×× CHN;
                  ELSE  PTITL='     ';
     SS=DX;
     DO HX=1 TO 24;
        SX=HX;
        SAMP=SAMPX;
        IX=HS;INTER=MAX(INTER,SAMP);
        END;
     HS+1; PO=HS;
     CHNH=0; *CLEAR FOR NEXT DAY;
   SS=60; END;
   IF PO=9 THEN DX=60;
  END;
  HS=8;
END;
RETAIN TITLE;
TITLE='CHANNEL BUSY AND CPU WAIT';
PLOT8UP;
     END;
RETURN;
//*-----------------------------------------------------------------
//* FOR 24 HOUR REPORTING------
//* SHOW CDSI PERFORMANCE STATISTICS BY DAVE RIKER 11/21/84
//* BY MONTHLY, BY DAILY, OR BY PERIOD RUNS YOU HAVE TO SELECT SMFIN
//* SMFIN MUST BE SMF TYPE 70 THRU 79 RECORDS TO REDUCE IO TIME.
//*-----------------------------------------------------------------
//RMFRPT  EXEC SAS,REGION=2500K,OPTIONS='LINESIZE=132'
//WORK DD UNIT=SYSDA,SPACE=(6160,(9999,9999),,,ROUND)
//SMFIN DD  DSN=SYS7.SMF.IPO1.DAILY(0),DISP=SHR
//      DD  DSN=SYS7.SMF.IPO1.DAILY(-1),DISP=SHR
//      DD  DSN=SYS7.SMF.IPO1.DAILY(-2),DISP=SHR
//*                       +-------------------------------------
//RPT70I      DD SYSOUT=M ×CPU ACTIVITY EXCEPTIONS
//RPT71S      DD SYSOUT=M ×STORAGE  EXCEPTIONS
//RPT71P      DD SYSOUT=M ×PAGING ACTIVITY EXECPTIONS
//RPT71SO     DD SYSOUT=M ×SWAPOUTS REASONS/EXCEPTIONS
//RPT72I      DD SYSOUT=M ×WORKLOAD EXCEPTIONS BY TIME
//RPT72PER    DD SYSOUT=M ×WORKLOAD EXCEPTIONS BY PERFGRP/DOM/OBJ
//RPT73CHN    DD SYSOUT=M ×CHANNEL ACTIVITY BY PHY/LOG CHANNEL ID
//*                       ×PAGE/SWAP DSN EXCEPTIONS BY DSNAME
//RPT74VOL    DD SYSOUT=M ×DEVICE EXCEPTIONS BY VOLUME SERIAL
//*                       +-------------------------------------
//SYSIN  DD  *
***********************************************************************
*       THIS SAS PROGRAM GETS THE RMF INFORMATION FROM THE SMF DATA   *
*       SET AND PRODUCES DETAIL PERFORMANCE STATISTICS  FOR CPU ,     *
*       CHANNELS , PAGING , HIGH DEVICE AND WORKLOAD/SERVICE UNITS    *
*       ON A DAILY BASIS                                              *
*                                                                     *
*       MODIFIED 04/22/78 FOR SOCO C.C. J. A. CHAPMAN                 *
*                                                                     *
*       DETAIL WORKLOAD PRINTS ADDED 05/05/78  JAC                    *
*                                                                     *
*       SMF TYPE 70, 71,72,73,74,75,76,77,78,79                       *
*                                                                     *
*       CMS DAILY DATABASE UPDATED                                    *
*                                                                     *
*       MODIFIED 11/16/84 FOR CDSI  BY DAVID O. RIKER                 *
*       1. ADD IBM'S  EXCEPTIONS CALCULATIONS                         *
*       2. LISTINGS EXPANDABLE (TOTALS AVERAGE HIGH LOW ETC)          *
*       3. ARRAY COMPUTE FOR BREAKOUTS ( VOLSER PFGRP DOM OBJ CHANID) *
*                                                                     *
*                                                                     *
*                                                                     *
**********************************************************************;
OPTIONS PS=60 SKIP=0   NODATE S=72 ERROR=3          BLKSIZE=13030 ;
DATA   CPU ( KEEP = TIME SHIFT DATE CPU_ID RMFDUR CPU_BUSY HR HOUR
             BTH_ASID STC_ASID TSO_ASID TOT_ASID )
    PAGING ( KEEP = TIME SHIFT DATE CPU_ID RMFDUR  HR HOUR PAGERATE
             COMRATE SWAPRATE PGFAULT DEMAND PAGEINS PAGEOUTS ADSPSWAP
             SWAPIN SWAPOUT TOT_SWP SWP_SEC LONG_WT UNILATRL ENQ_EXCH
             VIO REL_SHRT          IPS ENQ_CONT EXCHANGE DETECTED )
CHANNELS ( KEEP = TIME SHIFT DATE CPU_ID RMFDUR CHN_BUSY CHN_ID CHAN_ID
             CH_ID CHN_TCHB SAMPLES CHN_BSWT CHN_SIO HR HOUR )
  WORKLOAD ( KEEP =SHIFT DATE CPU_ID PERFGRP NRPERIOD CPUMIN DOMAIN ABS
             TSR TOT_SRV HR CPUUNITS IOUNITS MSOUNITS AVE_TRAN IO_SRV
             SRB_SRV SRBUNITS
             CPU_SRV MSO_SRV TRAN_WS RES_TIME TRAN_SWA DMN_WS IO_TRAN )
       DEV ( KEEP = TIME SHIFT DATE CPU_ID RMFDUR DEV_ADDR PCT_BUSY
             SIO_SEC AVE_QUE QDEPTH HR CUB  VOLSER  DASDI DASD_I HOUR )
   RPTDATE ( KEEP = RPT_DATE ) ;
INFILE SMFIN  END=EOF;    * INPUT DDNAME ;
LENGTH DEFAULT=5;
RETAIN II 0;
IF EOF THEN GOTO EOFPRT;
PAGE;
*  DEFINITION OF ARRAYS AND RETAINS FOR ALL WORKS                 ;
*   RETAIN VALUES FOR RMF 70 TYPE SECTION                    ;
 RETAIN
 DATE70 SWT70
 HBTHASID LBTHASID TBTHASID HSTCASID LSTCASID TSTCASID
 HTSOASID LTSOASID TTSOASID HTOTASID LTOTASID TTOTASID
 HAVGRTT LAVGRTT TAVGRTT HAVGOTT LAVGOTT TAVGOTT
 HWAIT LWAIT TWAIT HCPUBUSY LCPUBUSY TCPUBUSY REC70;
*   RETAIN VALUES FOR RMF 71 TYPE SECTION                    ;
RETAIN DATE71 SWT71
   NREC71
   TPAGEINS TPAGEOUT TRCLAIMS TADSPSWP TSWAPIN  TSWAPOUT
   TVIOPGIN TVIOPGOU TVIORECL TCOMPGIN TCOMPGOU TCOMRECL
   HPAGEINS HPAGEOUT HRCLAIMS HADSPSWP HSWAPIN  HSWAPOUT
   HVIOPGIN HVIOPGOU HVIORECL HCOMPGIN HCOMPGOU HCOMRECL
   LPAGEINS LPAGEOUT LRCLAIMS LADSPSWP LSWAPIN  LSWAPOUT
   LVIOPGIN LVIOPGOU LVIORECL LCOMPGIN LCOMPGOU LCOMRECL
   HSTORAGE TSTORAGE HISQA LOSQA TMXSQA HICSAF
   LOCSAF TMXCSAF HICSAP LOCSAP TMXCSAP HIGVIOF LOWVIOF
   TMAXVIOF
   HTPAGRT LTPAGRT TTPAGRT HPAGERT LPAGERT TPAGERT HDPAGRT
   LDPAGRT TDPAGRT HSWART LSWART TSWART HPLSWPIN LPLSWPIN
   TPLSWPIN HPLSWPOU LPLSWPOU TPLSWPOU
   HPSOCLTT LPSOCLTT TPSOCLTT HPSOCLW LPSOCLW TPSOCLW HPSOCDW
   LPSOCDW TPSOCDW HPSOCU LPSOCU TPSOCU HPSCEORV LPSCEORV
   TPSCEORV HPSCENQE LPSCENQE TPSCENQE HPSOCERQ LPSOCERQ
   TPSOCERQ HPSCAXSS LPSCAXSS TPSCAXSS HPSCRPSS LPSCRPSS
   TPSCRPSS HPSCTONS LPSCTONS TPSCTONS HPSOCTW LPSOCTW TPSOCTW ;
PAGE;
*   RETAIN VALUES FOR RMF 72 TYPE SECTION                    ;
RETAIN REC72  DATE72 SWT72
HTOTSRV LTOTSRV ATOTSRV HIOSRV LIOSRV AIOSRV HCPUSRV LCPUSRV
ACPUSRV HSRBSRV LSRBSRV ASRBSRV HMSOSRV LMSOSRV AMSOSRV
HTRANS LTRANS AITRANS HRTIME LRTIME ARTIME HSPERTRA LSPERTRA
ASPERTRA ;
*  FOR EACH PERFORMANCE GROUP ID ;
ARRAY PERFG (I) PERFG1-PERFG15;
ARRAY PCNT  (I) PCNT1-PCNT15;
ARRAY HPTSV (I) HPTSV1-HPTSV15;
ARRAY LPTSV (I) LPTSV1-LPTSV15;
ARRAY APTSV (I) APTSV1-APTSV15;
ARRAY HPISV (I) HPISV1-HPISV15;
ARRAY LPISV (I) LPISV1-LPISV15;
ARRAY APISV (I) APISV1-APISV15;
ARRAY HPCSV (I) HPCSV1-HPCSV15;
ARRAY LPCSV (I) LPCSV1-LPCSV15;
ARRAY APCSV (I) APCSV1-APCSV15;
ARRAY HPSSV (I) HPSSV1-HPSSV15;
ARRAY LPSSV (I) LPSSV1-LPSSV15;
ARRAY APSSV (I) APSSV1-APSSV15;
ARRAY HPMSV (I) HPMSV1-HPMSV15;
ARRAY LPMSV (I) LPMSV1-LPMSV15;
ARRAY APMSV (I) APMSV1-APMSV15;
ARRAY HPXSV (I) HPXSV1-HPXSV15;
ARRAY LPXSV (I) LPXSV1-LPXSV15;
ARRAY APXSV (I) APXSV1-APXSV15;
ARRAY HPRTM (I) HPRTM1-HPRTM15;
ARRAY LPRTM (I) LPRTM1-LPRTM15;
ARRAY APRTM (I) APRTM1-APRTM15;
ARRAY HPPER (I) HPPER1-HPPER15;
ARRAY LPPER (I) LPPER1-LPPER15;
ARRAY APPER (I) APPER1-APPER15;
RETAIN
PERFG1-PERFG15 9999;
RETAIN
PCNT1-PCNT15 HPTSV1-HPTSV15 LPTSV1-LPTSV15
APTSV1-APTSV15 HPISV1-HPISV15 LPISV1-LPISV15 APISV1-APISV15
HPCSV1-HPCSV15 LPCSV1-LPCSV15 APCSV1-APCSV15 HPSSV1-HPSSV15
LPSSV1-LPSSV15 APSSV1-APSSV15 HPMSV1-HPMSV15 LPMSV1-LPMSV15
APMSV1-APMSV15 HPXSV1-HPXSV15 LPXSV1-LPXSV15 APXSV1-APXSV15
HPRTM1-HPRTM15 LPRTM1-LPRTM15 APRTM1-APRTM15
HPPER1-HPPER15 LPPER1-LPPER15 APPER1-APPER15 0;
*  FOR EACH DOMAIN ID ;
ARRAY DOM (I) DOM1-DOM10;
ARRAY DCNT  (I) DCNT1-DCNT10;
ARRAY HDTSV (I) HDTSV1-HDTSV10;
ARRAY LDTSV (I) LDTSV1-LDTSV10;
ARRAY ADTSV (I) ADTSV1-ADTSV10;
ARRAY HDISV (I) HDISV1-HDISV10;
ARRAY LDISV (I) LDISV1-LDISV10;
ARRAY ADISV (I) ADISV1-ADISV10;
ARRAY HDCSV (I) HDCSV1-HDCSV10;
ARRAY LDCSV (I) LDCSV1-LDCSV10;
ARRAY ADCSV (I) ADCSV1-ADCSV10;
ARRAY HDSSV (I) HDSSV1-HDSSV10;
ARRAY LDSSV (I) LDSSV1-LDSSV10;
ARRAY ADSSV (I) ADSSV1-ADSSV10;
ARRAY HDMSV (I) HDMSV1-HDMSV10;
ARRAY LDMSV (I) LDMSV1-LDMSV10;
ARRAY ADMSV (I) ADMSV1-ADMSV10;
ARRAY HDXSV (I) HDXSV1-HDXSV10;
ARRAY LDXSV (I) LDXSV1-LDXSV10;
ARRAY ADXSV (I) ADXSV1-ADXSV10;
ARRAY HDRTM (I) HDRTM1-HDRTM10;
ARRAY LDRTM (I) LDRTM1-LDRTM10;
ARRAY ADRTM (I) ADRTM1-ADRTM10;
ARRAY HDPER (I) HDPER1-HDPER10;
ARRAY LDPER (I) LDPER1-LDPER10;
ARRAY ADPER (I) ADPER1-ADPER10;
RETAIN
DOM1-DOM10 9999;
RETAIN
DCNT1-DCNT10 HDTSV1-HDTSV10 LDTSV1-LDTSV10
ADTSV1-ADTSV10 HDISV1-HDISV10 LDISV1-LDISV10 ADISV1-ADISV10
HDCSV1-HDCSV10 LDCSV1-LDCSV10 ADCSV1-ADCSV10 HDSSV1-HDSSV10
LDSSV1-LDSSV10 ADSSV1-ADSSV10 HDMSV1-HDMSV10 LDMSV1-LDMSV10
ADMSV1-ADMSV10 HDXSV1-HDXSV10 LDXSV1-LDXSV10 ADXSV1-ADXSV10
HDRTM1-HDRTM10 LDRTM1-LDRTM10 ADRTM1-ADRTM10
HDPER1-HDPER10 LDPER1-LDPER10 ADPER1-ADPER10 0;
*  FOR EACH OBJECTIVE ID ;
ARRAY OBJ (I) OBJ1-OBJ10;
ARRAY OCNT  (I) OCNT1-OCNT10;
ARRAY HOTSV (I) HOTSV1-HOTSV10;
ARRAY LOTSV (I) LOTSV1-LOTSV10;
ARRAY AOTSV (I) AOTSV1-AOTSV10;
ARRAY HOISV (I) HOISV1-HOISV10;
ARRAY LOISV (I) LOISV1-LOISV10;
ARRAY AOISV (I) AOISV1-AOISV10;
ARRAY HOCSV (I) HOCSV1-HOCSV10;
ARRAY LOCSV (I) LOCSV1-LOCSV10;
ARRAY AOCSV (I) AOCSV1-AOCSV10;
ARRAY HOSSV (I) HOSSV1-HOSSV10;
ARRAY LOSSV (I) LOSSV1-LOSSV10;
ARRAY AOSSV (I) AOSSV1-AOSSV10;
ARRAY HOMSV (I) HOMSV1-HOMSV10;
ARRAY LOMSV (I) LOMSV1-LOMSV10;
ARRAY AOMSV (I) AOMSV1-AOMSV10;
ARRAY HOXSV (I) HOXSV1-HOXSV10;
ARRAY LOXSV (I) LOXSV1-LOXSV10;
ARRAY AOXSV (I) AOXSV1-AOXSV10;
ARRAY HORTM (I) HORTM1-HORTM10;
ARRAY LORTM (I) LORTM1-LORTM10;
ARRAY AORTM (I) AORTM1-AORTM10;
ARRAY HOPER (I) HOPER1-HOPER10;
ARRAY LOPER (I) LOPER1-LOPER10;
ARRAY AOPER (I) AOPER1-AOPER10;
RETAIN
OBJ1-OBJ10 9999;
RETAIN
OCNT1-OCNT10 HOTSV1-HOTSV10 LOTSV1-LOTSV10
AOTSV1-AOTSV10 HOISV1-HOISV10 LOISV1-LOISV10 AOISV1-AOISV10
HOCSV1-HOCSV10 LOCSV1-LOCSV10 AOCSV1-AOCSV10 HOSSV1-HOSSV10
LOSSV1-LOSSV10 AOSSV1-AOSSV10 HOMSV1-HOMSV10 LOMSV1-LOMSV10
AOMSV1-AOMSV10 HOXSV1-HOXSV10 LOXSV1-LOXSV10 AOXSV1-AOXSV10
HORTM1-HORTM10 LORTM1-LORTM10 AORTM1-AORTM10
HOPER1-HOPER10 LOPER1-LOPER10 AOPER1-AOPER10 0 ;
PAGE;
*   RETAIN VALUES FOR RMF 73 TYPE SECTION                    ;
RETAIN HCACRT LCACRT ACACRT REC73P
       HCHBSY LCHBSY ACHBSY HCSAVG LCSAVG ACAVG ;
*  FOR EACH CHANNEL ID ;
ARRAY CHAN    (I)   CHAN1-CHAN6;
ARRAY CCNT    (I)   CCNT1-CCNT6;
ARRAY HCRT    (I)   HCRT1-HCRT6;
ARRAY LCRT    (I)   LCRT1-LCRT6;
ARRAY ACRT    (I)   ACRT1-ACRT6;
ARRAY HCBSY   (I)   HCBSY1-HCBSY6;
ARRAY LCBSY   (I)   LCBSY1-LCBSY6;
ARRAY ACBSY   (I)   ACBSY1-ACBSY6;
ARRAY HCAVG   (I)   HCAVG1-HCAVG6;
ARRAY LCAVG   (I)   LCAVG1-LCAVG6;
ARRAY ACAVX   (I)   ACAVX1-ACAVX6;
ARRAY HSCWS   (I)   HSCWS1-HSCWS6;
ARRAY LSCWS   (I)   LSCWS1-LSCWS6;
ARRAY ASCWS   (I)   ASCWS1-ASCWS6;
RETAIN
CHAN1-CHAN6 ;
RETAIN
CCNT1-CCNT6 HCRT1-HCRT6 LCRT1-LCRT6
ACRT1-ACRT6 HCBSY1-HCBSY6 LCBSY1-LCBSY6 ACBSY1-ACBSY6
HSCWS1-HSCWS6   LSCWS1-LSCWS6   ASCWS1-ASCWS6
HCAVG1-HCAVG6 LCAVG1-LCAVG6 ACAVX1-ACAVX6 0;
* FOR EACH LOGICAL CHANNEL ID ;
ARRAY LCHAN    (I)   LCHAN1-LCHAN6;
ARRAY LCCNT    (I)   LCCNT1-LCCNT6;
ARRAY HLCH     (I)   HLCH1-HLCH6;
ARRAY LLCH     (I)   LLCH1-LLCH6;
ARRAY ALCH     (I)   ALCH1-ALCH6;
ARRAY HLQ0D    (I)   HLQ0D1-HLQ0D6;
ARRAY LLQ0D    (I)   LLQ0D1-LLQ0D6;
ARRAY TLQ0D    (I)   TLQ0D1-TLQ0D6;
ARRAY HLQ1D    (I)   HLQ1D1-HLQ1D6;
ARRAY LLQ1D    (I)   LLQ1D1-LLQ1D6;
ARRAY TLQ1D    (I)   TLQ1D1-TLQ1D6;
ARRAY HLQ2D    (I)   HLQ2D1-HLQ2D6;
ARRAY LLQ2D    (I)   LLQ2D1-LLQ2D6;
ARRAY TLQ2D    (I)   TLQ2D1-TLQ2D6;
ARRAY HLQ3D    (I)   HLQ3D1-HLQ3D6;
ARRAY LLQ3D    (I)   LLQ3D1-LLQ3D6;
ARRAY TLQ3D    (I)   TLQ3D1-TLQ3D6;
ARRAY HLQ4D    (I)   HLQ4D1-HLQ4D6;
ARRAY LLQ4D    (I)   LLQ4D1-LLQ4D6;
ARRAY TLQ4D    (I)   TLQ4D1-TLQ4D6;
ARRAY HLCBSY   (I)   HLCBSY1-HLCBSY6;
ARRAY LLCBSY   (I)   LLCBSY1-LLCBSY6;
ARRAY TLCBSY   (I)   TLCBSY1-TLCBSY6;
ARRAY HLLBSY   (I)   HLLBSY1-HLLBSY6;
ARRAY LLLBSY   (I)   LLLBSY1-LLLBSY6;
ARRAY TLLBSY   (I)   TLLBSY1-TLLBSY6;
ARRAY HLUBSY   (I)   HLUBSY1-HLUBSY6;
ARRAY LLUBSY   (I)   LLUBSY1-LLUBSY6;
ARRAY TLUBSY   (I)   TLUBSY1-TLUBSY6;
ARRAY HLDBSY   (I)   HLDBSY1-HLDBSY6;
ARRAY LLDBSY   (I)   LLDBSY1-LLDBSY6;
ARRAY TLDBSY   (I)   TLDBSY1-TLDBSY6;
ARRAY HFCBSY   (I)   HFCBSY1-HFCBSY6;
ARRAY LFCBSY   (I)   LFCBSY1-LFCBSY6;
ARRAY TFCBSY   (I)   TFCBSY1-TFCBSY6;
ARRAY HFLBSY   (I)   HFLBSY1-HFLBSY6;
ARRAY LFLBSY   (I)   LFLBSY1-LFLBSY6;
ARRAY TFLBSY   (I)   TFLBSY1-TFLBSY6;
ARRAY HFUBSY   (I)   HFUBSY1-HFUBSY6;
ARRAY LFUBSY   (I)   LFUBSY1-LFUBSY6;
ARRAY TFUBSY   (I)   TFUBSY1-TFUBSY6;
ARRAY HFDBSY   (I)   HFDBSY1-HFDBSY6;
ARRAY LFDBSY   (I)   LFDBSY1-LFDBSY6;
ARRAY TFDBSY   (I)   TFDBSY1-TFDBSY6;
RETAIN LCHAN1-LCHAN6 9999 LCCNT1-LCCNT6
       HLCH1-HLCH6 LLCH1-LLCH6 ALCH1-ALCH6
HLQ0D1-HLQ0D6 LLQ0D1-LLQ0D6 TLQ0D1-TLQ0D6 HLQ1D1-HLQ1D6
LLQ1D1-LLQ1D6 TLQ1D1-TLQ1D6 HLQ2D1-HLQ2D6 LLQ2D1-LLQ2D6
TLQ2D1-TLQ2D6 HLQ3D1-HLQ3D6 LLQ3D1-LLQ3D6 TLQ3D1-TLQ3D6
HLQ4D1-HLQ4D6 LLQ4D1-LLQ4D6 TLQ4D1-TLQ4D6
HLCBSY1-HLCBSY6 LLCBSY1-LLCBSY6 TLCBSY1-TLCBSY6
HLLBSY1-HLLBSY6 LLLBSY1-LLLBSY6 TLLBSY1-TLLBSY6
HLUBSY1-HLUBSY6 LLUBSY1-LLUBSY6 TLUBSY1-TLUBSY6
HLDBSY1-HLDBSY6 LLDBSY1-LLDBSY6 TLDBSY1-TLDBSY6
HFCBSY1-HFCBSY6 LFCBSY1-LFCBSY6 TFCBSY1-TFCBSY6
HFLBSY1-HFLBSY6 LFLBSY1-LFLBSY6 TFLBSY1-TFLBSY6
HFUBSY1-HFUBSY6 LFUBSY1-LFUBSY6 TFUBSY1-TFUBSY6
HFDBSY1-HFDBSY6 LFDBSY1-LFDBSY6 TFDBSY1-TFDBSY6 0;
RETAIN DATE73 SWT73;
PAGE;
*   RETAIN VALUES FOR RMF 74 TYPE SECTION                    ;
RETAIN
TDNTRDY TDART TDAVGBE TDAVGNBE TDVBSYBE TDVBSYNB TDRD TDR
TDAQ HDNTRDY HDART HDAVGBE HDAVGNBE HDVBSYBE HDVBSYNB HDRD
HDR HDAQ LDNTRDY LDART LDAVGBE LDAVGNBE LDVBSYBE LDVBSYNB
LDRD LDR LDAQ ;
ARRAY VOL     (I)  $6 VOL1-VOL60;
ARRAY VCNT    (I)  VCNT1-VCNT60;
ARRAY HDNT    (I)  HDNT1-HDNT60;
ARRAY LDNT    (I)  LDNT1-LDNT60;
ARRAY ADNT    (I)  ADNT1-ADNT60;
ARRAY HBSYB   (I)  HBSYB1-HBSYB60;
ARRAY LBSYB   (I)  LBSYB1-LBSYB60;
ARRAY ABSYB   (I)  ABSYB1-ABSYB60;
ARRAY HBSYN   (I)  HBSYN1-HBSYN60;
ARRAY LBSYN   (I)  LBSYN1-LBSYN60;
ARRAY ABSYN   (I)  ABSYN1-ABSYN60;
ARRAY HRD     (I)  HRD1-HRD60;
ARRAY LRD     (I)  LRD1-LRD60;
ARRAY ARD     (I)  ARD1-ARD60;
ARRAY HRA     (I)  HRA1-HRA60;
ARRAY LR      (I)  LR1-LR60;
ARRAY AR      (I)  AR1-AR60;
ARRAY HART    (I)  HART1-HART60;
ARRAY LART    (I)  LART1-LART60;
ARRAY AART    (I)  AART1-AART60;
ARRAY HAVBE   (I)  HAVBE1-HAVBE60;
ARRAY LAVBE   (I)  LAVBE1-LAVBE60;
ARRAY AAVBE   (I)  AAVBE1-AAVBE60;
ARRAY HAVNB   (I)  HAVNB1-HAVNB60;
ARRAY LAVNB   (I)  LAVNB1-LAVNB60;
ARRAY AAVNB   (I)  AAVNB1-AAVNB60;
ARRAY HAQ     (I)  HAQ1-HAQ60;
ARRAY LAQ     (I)  LAQ1-LAQ60;
ARRAY AAQ     (I)  AAQ1-AAQ60;
RETAIN
VOL1-VOL60  ' ' VCNT1-VCNT60 HDNT1-HDNT60 LDNT1-LDNT60
ADNT1-ADNT60 HBSYB1-HBSYB60 LBSYB1-LBSYB60 ABSYB1-ABSYB60
HBSYN1-HBSYN60 LBSYN1-LBSYN60 ABSYN1-ABSYN60 HRD1-HRD60
LRD1-LRD60 ARD1-ARD60 HRA1-HRA60 LR1-LR60 AR1-AR60
HART1-HART60 LART1-LART60 AART1-AART60 HAVBE1-HAVBE60
LAVBE1-LAVBE60 AAVBE1-AAVBE60 HAVNB1-HAVNB60 LAVNB1-LAVNB60
AAVNB1-AAVNB60 HAQ1-HAQ60 LAQ1-LAQ60 AAQ1-AAQ60 0;
RETAIN DATE74 SWT74;
PAGE;
*   RETAIN VALUES FOR RMF 75 TYPE SECTION                    ;
*  FOR EACH PAGE/SWAP DATASET ;
ARRAY DSN     (I) $44 DSN1-DSN6;
ARRAY DSCNT   (I) DSCNT1-DSCNT6;
ARRAY LPBSY   (I) LPBSY1-LPBSY6;
ARRAY LPAVG   (I) LPAVG1-LPAVG6;
ARRAY LPPT    (I) LPPT1-LPPT6;
ARRAY LPART   (I) LPART1-LPART6;
ARRAY LPAVGS  (I) LPAVGS1-LPAVGS6;
ARRAY LPBADS  (I) LPBADS1-LPBADS6;
ARRAY HPBSY   (I) HPBSY1-HPBSY6;
ARRAY HPAVG   (I) HPAVG1-HPAVG6;
ARRAY HPPT    (I) HPPT1-HPPT6;
ARRAY HPART   (I) HPART1-HPART6;
ARRAY HPAVGS  (I) HPAVGS1-HPAVGS6;
ARRAY HPBADS  (I) HPBADS1-HPBADS6;
ARRAY APBSY   (I) APBSY1-APBSY6;
ARRAY APAVG   (I) APAVG1-APAVG6;
ARRAY APPT    (I) APPT1-APPT6;
ARRAY APART   (I) APART1-APART6;
ARRAY APAVGS  (I) APAVGS1-APAVGS6;
ARRAY APBADS  (I) APBADS1-APBADS6;
RETAIN
DSN1-DSN6 ' ' DSCNT1-DSCNT6 LPBSY1-LPBSY6 LPAVG1-LPAVG6
LPPT1-LPPT6 LPART1-LPART6 LPAVGS1-LPAVGS6
LPBADS1-LPBADS6 HPBSY1-HPBSY6 HPAVG1-HPAVG6 HPPT1-HPPT6
HPART1-HPART6 HPAVGS1-HPAVGS6 HPBADS1-HPBADS6
APBSY1-APBSY6 APAVG1-APAVG6 APPT1-APPT6 APART1-APART6
APAVGS1-APAVGS6 APBADS1-APBADS6 0;
RETAIN DATE75 SWT75;
PAGE;
* ------------  READ RMF/SMF RECORDS -----------------------------  ;
INPUT @2 REC_ID  PIB1.  @ ;  * GET THE RECORD ID   ;
IF REC_ID<70 OR REC_ID>75 THEN DELETE;       * REMOVE NON-RMF RECORDS;
IF _ERROR_ THEN DELETE; _ERROR_ =0;  *BAD SMF ,FILE RMF ,PUT _INFILE_ ;
INPUT @14 CPU_ID $1.   @17 TIME PD4.  YEAR $2.   DATE   PD2.
@21 DATEJ PD4.
RMFDPK PD4. @25 DURATION PD4.3 @ ;     IF DATE = . THEN DELETE ;
DAY = MOD(DATE,1000) ; KPDATE = MOD (DATE,7) ;
DATEX=DATEJUL(DATEJ);
*IF KPDATE = 0 OR KPDATE = 1 THEN DELETE ; * DELETE WEEKENDS ;
*    CALCULATE RMF DURATION AND SHIFT ;
RMFMIN = INT ( RMFDPK / 100000 )  ;
*  CALCULATION IN SECONDS;
   RMFDUR= 60*FLOOR(DURATION/100) +MOD(DURATION,100);
HOUR   =     ( TIME / 10000 )     ;
HR     = INT ( TIME / 10000 )     ;
SHIFT  = INT ( HR / 8 ) ;         IF SHIFT=0  THEN SHIFT=3 ;
****       ;
****       ;
** SELECT HOURS **;
IF HR>6 AND HR<18 THEN GOTO HEAD_OUT; ELSE DELETE;
HEAD_OUT: ;
** ------ SPLIT OUT EACH RMF SEPARATE RECORD TYPE  -------------**;
IF REC_ID = 70 THEN GOTO TYPE70               ; * CPU      RECORD ;
IF REC_ID = 71 THEN GOTO TYPE71               ; * PAGING   RECORD ;
IF REC_ID = 72 THEN GOTO TYPE72               ; * WORKLOAD RECORD ;
IF REC_ID = 73 THEN GOTO TYPE73               ; * CHANNELS RECORD ;
IF REC_ID = 74 THEN GOTO TYPE74               ; * DEVICES  RECORD ;
IF REC_ID = 75 THEN GOTO TYPE75               ; * P/S DSN  RECORD ;
DELETE;
PAGE;
* AT EOF,   PRINT TOTALS AND HIGH LOW AVG REPORTS .               ;
EOFPRT:
IF EOF THEN DO; NIL=.;
*       SUMMARY OF CPU ACTIVITY                                   ;
AWAIT=TWAIT/REC70;
ACPUBUSY=TCPUBUSY/REC70;
AAVGRTT=TAVGRTT/REC70;
AAVGOTT=TAVGOTT/REC70;
ATOTASID=TTOTASID/REC70;
ABTHASID=TBTHASID/REC70;
ASTCASID=TSTCASID/REC70;
ATSOASID=TTSOASID/REC70;
FILE RPT70I HEADER=H70I NOTITLES PRINT;
PUT DATE70 MMDDYY8. +1
   (HWAIT LWAIT AWAIT)                             (6.)
   (HCPUBUSY LCPUBUSY ACPUBUSY
    HAVGRTT LAVGRTT AAVGRTT
    HAVGOTT LAVGOTT AAVGOTT)                       (5.)
   (HTOTASID LTOTASID ATOTASID
    HBTHASID LBTHASID ABTHASID NIL
    HSTCASID LSTCASID ASTCASID NIL
    HTSOASID LTSOASID ATSOASID NIL )           (4.) ;
*---------------- DETAILS REPORTS  AVERAGE PER INTERVIAL --------- ;
APAGEINS=TPAGEINS/NREC71;
APAGEOUT=TPAGEOUT/NREC71;
ARCLAIMS=TRCLAIMS/NREC71;
AADSPSWP=TADSPSWP/NREC71;
ASWAPIN =TSWAPIN /NREC71;
ASWAPOUT=TSWAPOUT/NREC71;
AVIOPGIN=TVIOPGIN/NREC71;
AVIOPGOU=TVIOPGOU/NREC71;
AVIORECL=TVIORECL/NREC71;
ACOMPGIN=TCOMPGIN/NREC71;
ACOMPGOU=TCOMPGOU/NREC71;
ACOMRECL=TCOMRECL/NREC71;
* STORAGE ANALYSIS REPORT    ;
TSTORAGE=TSTORAGE/NREC71;
TMXSQA  = TMXSQA/NREC71;
TMXCSAF = TMXCSAF/NREC71;
TMXCSAP = TMXCSAP/NREC71;
TMAXVIOF= TMAXVIOF/NREC71;
FILE RPT71S HEADER=H71S NOTITLES PRINT;
PUT  DATE71 MMDDYY8. +8
(TSTORAGE
 HISQA LOSQA       TMXSQA NIL
 HICSAF LOCSAF     TMXCSAF NIL
 HICSAP LOCSAP     TMXCSAP NIL
 HIGVIOF LOWVIOF   TMAXVIOF NIL) (6.) ;
* PAGING RATE REPORT         ;
ATPAGRT=TTPAGRT/  NREC71;
APAGERT=TPAGERT/  NREC71;
ADPAGRT=TDPAGRT/  NREC71;
ASWART=TSWART/    NREC71;
APLSWPIN=TPLSWPIN/NREC71;
APLSWPOU=TPLSWPOU/NREC71;
FILE RPT71P HEADER=H71P NOTITLES PRINT;
PUT  DATE71 MMDDYY8. +8
(HTPAGRT LTPAGRT ATPAGRT
 HPAGERT LPAGERT APAGERT
 HDPAGRT LDPAGRT ADPAGRT
 HSWART LSWART ASWART
 HPLSWPIN LPLSWPIN APLSWPIN
 HPLSWPOU LPLSWPOU APLSWPOU ) (5.) ;
* SWAP-OUT PER SECOND REASONS   HIGH LOW AVG VALUES;
APSOCLTT  =TPSOCLTT  /NREC71;
APSOCLW   =TPSOCLW   /NREC71;
APSOCDW   =TPSOCDW   /NREC71;
APSOCU    =TPSOCU    /NREC71;
APSCEORV  =TPSCEORV  /NREC71;
APSCENQE  =TPSCENQE  /NREC71;
APSOCERQ  =TPSOCERQ  /NREC71;
APSCAXSS  =TPSCAXSS  /NREC71;
APSCRPSS  =TPSCRPSS  /NREC71;
APSCTONS  =TPSCTONS  /NREC71;
APSOCTW   =TPSOCTW   /NREC71;
FILE RPT71SO HEADER=H71SO NOTITLES PRINT;
  PUT  DATE71 MMDDYY8.  /
(HPSOCLTT   LPSOCLTT   APSOCLTT
HPSOCLW    LPSOCLW    APSOCLW
HPSOCDW    LPSOCDW    APSOCDW
HPSOCU     LPSOCU     APSOCU
HPSCEORV   LPSCEORV   APSCEORV
HPSCENQE   LPSCENQE   APSCENQE
HPSOCERQ   LPSOCERQ   APSOCERQ
HPSCAXSS   LPSCAXSS   APSCAXSS
HPSCRPSS   LPSCRPSS   APSCRPSS
HPSCTONS   LPSCTONS   APSCTONS
HPSOCTW    LPSOCTW    APSOCTW) (4.);
FILE RPT72PER HEADER=H72PER NOTITLES PRINT;
PUT /  'BY PERFORMANCE GROUP' 100*'-';
DO OVER PERFG;
IF PERFG ^= 9999 THEN DO;
IF PCNT ^= 0 THEN DO;
APTSV=APTSV/PCNT;
APISV=APISV/PCNT;
APCSV=APCSV/PCNT;
APSSV=APSSV/PCNT;
APMSV=APMSV/PCNT;
APXSV=APXSV/PCNT;
APRTM=APRTM/PCNT;
APPER=APPER/PCNT;
 PUT
 PERFG  3. ' '
(HPTSV LPTSV APTSV
 HPISV LPISV APISV
 HPCSV LPCSV APCSV
 HPSSV LPSSV APSSV
 HPMSV LPMSV APMSV
 HPXSV  APXSV
 HPRTM  APRTM) (5.)
(HPPER  APPER) (6.) ;
 END;
 END;
END;
PUT / 'BY DOMAIN ' 100*'-';
DO OVER DOM;
IF DOM ^= 9999 THEN DO;
IF DCNT ^= 0 THEN DO;
ADTSV=ADTSV/DCNT;
ADISV=ADISV/DCNT;
ADCSV=ADCSV/DCNT;
ADSSV=ADSSV/DCNT;
ADMSV=ADMSV/DCNT;
ADXSV=ADXSV/DCNT;
ADRTM=ADRTM/DCNT;
ADPER=ADPER/DCNT;
 PUT
 DOM    3. ' '
(HDTSV LDTSV ADTSV
 HDISV LDISV ADISV
 HDCSV LDCSV ADCSV
 HDSSV LDSSV ADSSV
 HDMSV LDMSV ADMSV
 HDXSV  ADXSV
 HDRTM  ADRTM) (5.)
(HDPER  ADPER) (6.) ;
END; END; END;
PUT / 'BY OBJECTIVE ' 100*'-';
DO OVER OBJ;
IF OBJ ^= 9999 THEN DO;
IF OCNT ^= 0 THEN DO;
AOTSV=AOTSV/OCNT;
AOISV=AOISV/OCNT;
AOCSV=AOCSV/OCNT;
AOSSV=AOSSV/OCNT;
AOMSV=AOMSV/OCNT;
AOXSV=AOXSV/OCNT;
AORTM=AORTM/OCNT;
AOPER=AOPER/OCNT;
 PUT
 OBJ    3. ' '
(HOTSV LOTSV AOTSV
 HOISV LOISV AOISV
 HOCSV LOCSV AOCSV
 HOSSV LOSSV AOSSV
 HOMSV LOMSV AOMSV
 HOXSV  AOXSV
 HORTM  AORTM) (5.)
(HOPER  AOPER) (6.) ;
END; END; END;
ATOTSRV =ATOTSRV/REC72;
AIOSRV =AIOSRV/REC72;
ACPUSRV =ACPUSRV/REC72;
ASRBSRV =ASRBSRV/REC72;
AMSOSRV =AMSOSRV/REC72;
AITRANS =AITRANS/REC72;
ARTIME =ARTIME/REC72;
ASPERTRA=ASPERTRA/REC72;
FILE RPT72I HEADER=H72I NOTITLES PRINT;
 PUT DATE72 MMDDYY8. +11
(HTOTSRV LTOTSRV ATOTSRV
 HIOSRV LIOSRV AIOSRV
 HCPUSRV LCPUSRV ACPUSRV
 HSRBSRV LSRBSRV ASRBSRV
 HMSOSRV LMSOSRV AMSOSRV
 HTRANS  AITRANS
 HRTIME  ARTIME) (5.)
(HSPERTRA  ASPERTRA) (6.) ;
FILE RPT73CHN HEADER=H73CHN NOTITLES PRINT;
DO OVER CHAN;
IF CCNT ^= 0 THEN DO;
IF CHAN ^= . THEN DO;
ACRT=ACRT/CCNT;
ACBSY=ACBSY/CCNT;
ACAVG=ACAVG/CCNT;
ASCWS=ASCWS/CCNT;
PUT  CHAN 6.
(HCRT LCRT ACRT
HCBSY LCBSY ACBSY
HCAVG LCAVG ACAVG
HSCWS LSCWS ASCWS ) (6.1);
CCNT    =0; HCRT    =0; LCRT    =0; ACRT    =0; HCBSY   =0;
LCBSY   =0; ACBSY   =0; HCAVG   =0; LCAVG   =0; ACAVX   =0;
HSCWS =0; LSCWS =0; ASCWS =0;
END; END; END;
PUT // 'RMF 73 -- CHANNEL ACTIVITY - LOGICAL EXCEPTIONS '
    '--  DATE=' DATE73 WORDDATE18.;
PUT 'LID % REQUEST<-------- % QLENGTH DISTRIBUTION    -------->'
    '<--- % REQUEST DIFFER CONDITION --->'
    '<------ %FREQ. OF CONDITION  ------>'
/  @8      'DIFFER    -0-      -1-      -2-      -3-      -4+- '
    'PHYS BSY LOG. BSY  C.U. BSY DEV. BSY'
    'PHYS BSY LOG. BSY  C.U. BSY DEV. BSY'
/ @5    ' HI LO AV HI LO AV HI LO AV HI LO AV HI LO AV HI LO AV'
    ' HI LO AV HI LO AV HI LO AV HI LO AV'
    ' HI LO AV HI LO AV HI LO AV HI LO AV';
DO OVER LCHAN;
IF LCCNT ^= 0 THEN DO;
IF LCHAN ^= 9999 THEN DO;
ALCH=ALCH/LCCNT;
TLQ0D   =TLQ0D   /LCCNT;
TLQ1D   =TLQ1D   /LCCNT;
TLQ2D   =TLQ2D   /LCCNT;
TLQ3D   =TLQ3D   /LCCNT;
TLQ4D   =TLQ4D   /LCCNT;
TLCBSY  =TLCBSY  /LCCNT;
TLLBSY  =TLLBSY  /LCCNT;
TLUBSY  =TLUBSY  /LCCNT;
TLDBSY  =TLDBSY  /LCCNT;
TFCBSY  =TFCBSY  /LCCNT;
TFLBSY  =TFLBSY  /LCCNT;
TFUBSY  =TFUBSY  /LCCNT;
TFDBSY  =TFDBSY  /LCCNT;
PUT  LCHAN 3. ' '
(HLCH LLCH ALCH
HLQ0D  LLQ0D    TLQ0D
HLQ1D  LLQ1D    TLQ1D
HLQ2D  LLQ2D    TLQ2D
HLQ3D  LLQ3D    TLQ3D
HLQ4D  LLQ4D    TLQ4D
HLCBSY  LLCBSY TLCBSY
HLLBSY  LLLBSY TLLBSY
HLUBSY  LLUBSY TLUBSY
HLDBSY  LLDBSY TLDBSY
HFCBSY  LFCBSY  TFCBSY
HFLBSY  LFLBSY  TFLBSY
HFUBSY  LFUBSY  TFUBSY
HFDBSY  LFDBSY  TFDBSY) (3.);
LCCNT    =0; HLCH    =0; LLCH    =0; ALCH    =0;
END; END; END;
PUT // 'RMF 75 --- PAGE/SWAP DATA SET - EXCEPTIONS '
 '   BY DSNAME '
    ' DATE=' DATE75 WORDDATE18.;
PUT
'<--       PAGE/SWAP DATA SET NAME        -->'
' % BUSY-DSN '
' AVG SRV/SEC'
'PGS XFRD/SEC'
'PDSN RTE/SEC'
' AVG SLOTS USED'
' # BAD SLOTS' / @45
'  HI  LO AVG'
'  HI  LO AVG'
'  HI  LO AVG'
'  HI  LO AVG'
' HIGH  LOW  AVG'
'  HI  LO AVG';
DO OVER DSN;
IF DSN ^= ' ' THEN DO;
IF DSCNT ^= 0 THEN DO;
APBSY   =APBSY/DSCNT;
APAVG   =APAVG/DSCNT;
APPT    =APPT/DSCNT;
APART   =APART/DSCNT;
APAVGS  =APAVGS/DSCNT;
APBADS  =APBADS/DSCNT;
PUT DSN $CHAR44.
(HPBSY LPBSY APBSY HPAVG LPAVG APAVG HPPT LPPT APPT
 HPART LPART APART) (4.) (HPAVGS LPAVGS APAVGS) (5.)
(HPBADS LPBADS APBADS) (4.);
END;
END; END;
FILE RPT74VOL HEADER=H74VOL NOTITLES PRINT;
DO OVER VOL;
IF VCNT ^= 0 THEN DO;
IF VOL^=' ' THEN DO;
ADNT =ADNT/VCNT;
ABSYB =ABSYB/VCNT;
ABSYN =ABSYN/VCNT;
ARD =ARD/VCNT;
AR =AR/VCNT;
AART =AART/VCNT;
AAVBE =AAVBE/VCNT;
AAVNB =AAVNB/VCNT;
AAQ =AAQ/VCNT;
  PUT
VOL    $CHAR6. ' '
(HDNT LDNT ADNT HBSYB LBSYB ABSYB HBSYN LBSYN ABSYN HRD
LRD ARD HRA LR AR HART LART AART) (4.)
(HAVBE LAVBE AAVBE HAVNB LAVNB AAVNB HAQ LAQ AAQ) (5.);
END;
END;
END;
*END OF EOF SERIES;
END;
RETURN  ;
PAGE;
*--------------------     CPU RECORD  --------------------------- ;
TYPE70:
IF DATEX ^= DATE70 THEN DO;
IF SWT70 = 1 THEN DO;
FILE RPT70I HEADER=H70I NOTITLES PRINT;
 TBTHASID=TBTHASID/REC70;
 TSTCASID=TSTCASID/REC70;
 TTSOASID=TTSOASID/REC70;
 TTOTASID=TTOTASID/REC70;
 TAVGRTT=TAVGRTT/REC70;
 TAVGOTT=TAVGOTT/REC70;
 TWAIT=TWAIT/REC70;
 TCPUBUSY=TCPUBUSY/REC70;
 TMAXBTCH=TMAXBTCH/REC70;
 TMAXSTC=TMAXSTC/REC70;
 TMAXTSO=TMAXTSO/REC70;
PUT  DATE70 MMDDYY8.
     + 1
   (HWAIT LWAIT TWAIT)                             (6.)
   (HCPUBUSY LCPUBUSY TCPUBUSY
    HAVGRTT LAVGRTT TAVGRTT
    HAVGOTT LAVGOTT TAVGOTT)                       (5.)
   (HTOTASID LTOTASID TTOTASID
    HBTHASID LBTHASID TBTHASID TMAXBTCH
    HSTCASID LSTCASID TSTCASID TMAXSTC
    HTSOASID LTSOASID TTSOASID TMAXTSO )           (4.) ;
TMAXBTCH=0; TMAXSTC=0; TMAXTSO=0;
HTSOASID  = 0; LTSOASID  = 0; TTSOASID  = 0; HTOTASID  = 0;
LTOTASID  = .; TTOTASID  = .; HAVGRTT   = 0; LAVGRTT   = .;
TAVGRTT   = 0; HAVGOTT   = 0; LAVGOTT   = .; TAVGOTT   = 0;
HWAIT     = 0; LWAIT     = .; TWAIT     = 0; HCPUBUSY  = 0;
LCPUBUSY  = .; TCPUBUSY  = 0; REC70     = 0;
END;
SWT70=1;
DATE70=DATEX;
END;
PTR=15;
INPUT @PTR COMSIZ PIB2. +16 SAMPLES PIB4. @;
PTR=PTR+COMSIZ;
INPUT @PTR CPUCSECT PIB2. NO_CPU PIB2. SIZE_CPU PIB2. CPUDSECT PIB2. @;
   PTR = PTR+CPUCSECT ;                    COUNT = 1      ;
   CPUSAV = CPU_ID   ;
   APTR = PTR+(SIZE_CPU*NO_CPU);
INPUT
 @APTR +4   RTT PIB4.
 @APTR +132 OTT PIB4.
 @APTR +242 MAXBATCH PIB2. BATCH PIB4.
       +50  MAXSTC PIB2.   STC PIB4.
       +50  MAXTSO PIB2.   TSO PIB4. @;
 BTH_ASID=BATCH/SAMPLES;  STC_ASID=STC/SAMPLES;  TSO_ASID=TSO/SAMPLES;
 TOT_ASID=(BATCH + STC + TSO) / SAMPLES ;
 TMAXBTCH+MAXBATCH;
 TMAXSTC+MAXSTC;
 TMAXTSO+MAXTSO;
 AVGRTT=RTT/SAMPLES; AVGOTT=OTT/SAMPLES;
 HBTHASID=MAX(HBTHASID,BTH_ASID);
 LBTHASID=MIN(LBTHASID,BTH_ASID);
 TBTHASID+BTH_ASID;
 HSTCASID=MAX(HSTCASID,STC_ASID);
 LSTCASID=MIN(LSTCASID,STC_ASID);
 TSTCASID+STC_ASID;
 HTSOASID=MAX(HTSOASID,TSO_ASID);
 LTSOASID=MIN(LTSOASID,TSO_ASID);
 TTSOASID+TSO_ASID;
 HTOTASID=MAX(HTOTASID,TOT_ASID);
 LTOTASID=MIN(LTOTASID,TOT_ASID);
 TTOTASID+TOT_ASID;
 HAVGRTT=MAX(HAVGRTT,AVGRTT);
 LAVGRTT=MIN(LAVGRTT,AVGRTT);
 TAVGRTT+AVGRTT;
 HAVGOTT=MAX(HAVGOTT,AVGOTT);
 LAVGOTT=MIN(LAVGOTT,AVGOTT);
 TAVGOTT+AVGOTT;
GETCPU:   INPUT @PTR (WAIT1 WAIT2) (PIB4.6)  +4 CPUID PIB2. @;
   CPU_ID = CPUSAV   ;
   WAIT=WAIT1*1048576+WAIT2/4096;
   WAIT=100*(WAIT/RMFDUR)+.005; * WAIT TIME PERCENTAGE ;
   IF CPU_ID = '9' AND CPUID = 0 THEN CPU_ID = '0' ;
   CPU_BUSY  =  100*(1-WAIT/RMFDUR)+.005 ;
IF SAMPLES=0 THEN SAMPLES=.1 ;
HWAIT=MAX(HWAIT,WAIT);
LWAIT=MIN(LWAIT,WAIT);
TWAIT+WAIT;
HCPUBUSY=MAX(HCPUBUSY,CPU_BUSY);
LCPUBUSY=MIN(LCPUBUSY,CPU_BUSY);
TCPUBUSY+CPU_BUSY;
REC70+1;
IF CPU_BUSY LT 0 THEN DELETE ; IF CPU_BUSY GT 1. THEN DELETE ;
IF COUNT GE NO_CPU THEN RETURN    ;
COUNT = COUNT + 1  ;
PTR = PTR + SIZE_CPU   ;
GOTO GETCPU  ;
PAGE;
* ------------- PAGING RECORD ---------------------------         ;
TYPE71:
IF DATEX ^= DATE71 THEN DO; NIL=.;
IF SWT72 = 1 THEN DO;
*---------------- STORAGE ANALYSIS REPORT -----------------------    ;
TSTORAGE=TSTORAGE/NREC71;
TMXSQA  = TMXSQA/NREC71;
TMXCSAF = TMXCSAF/NREC71;
TMXCSAP = TMXCSAP/NREC71;
TMAXVIOF= TMAXVIOF/NREC71;
FILE RPT71S HEADER=H71S NOTITLES PRINT;
PUT DATE71 MMDDYY8. +8
    (                 TSTORAGE
     HISQA LOSQA TMXSQA NIL
     HICSAF LOCSAF TMXCSAF NIL
     HICSAP LOCSAP TMXCSAP NIL
     HIGVIOF LOWVIOF TMAXVIOF NIL    )             (6.) ;
*-----------------  PAGING RATE REPORT -----------------------        ;
TTPAGRT  =TTPAGRT/NREC71;
TPAGERT  =TPAGERT/NREC71;
TDPAGRT  =TDPAGRT/NREC71;
TSWART   =TSWART/NREC71;
TPLSWPIN =TPLSWPIN/NREC71;
TPLSWPOU =TPLSWPOU/NREC71;
FILE RPT71P HEADER=H71P NOTITLES PRINT;
PUT DATE71 MMDDYY8. +8
    (HTPAGRT LTPAGRT  TTPAGRT
     HPAGERT LPAGERT  TPAGERT
     HDPAGRT LDPAGRT  TDPAGRT
     HSWART LSWART    TSWART
     HPLSWPIN LPLSWPIN TPLSWPIN
     HPLSWPOU LPLSWPOU TPLSWPOU) (5.) ;
*----- SWAP-OUT PER SECOND REASONS : HIGH LOW AVG   VALUES------;
TPSOCLTT  =TPSOCLTT/NREC71;
TPSOCLW   =TPSOCLW/NREC71 ;
TPSOCDW   =TPSOCDW /NREC71;
TPSOCU    =TPSOCU/NREC71 ;
TPSCEORV  =TPSCEORV/NREC71;
TPSCENQE  =TPSCENQE/NREC71;
TPSOCERQ  =TPSOCERQ/NREC71;
TPSCAXSS  =TPSCAXSS/NREC71;
TPSCRPSS  =TPSCRPSS/NREC71;
TPSCTONS  =TPSCTONS/NREC71;
TPSOCTW   =TPSOCTW/NREC71 ;
FILE RPT71SO HEADER=H71SO NOTITLES PRINT;
  PUT DATE71 MMDDYY8. /
      (HPSOCLTT   LPSOCLTT    TPSOCLTT
        HPSOCLW    LPSOCLW    TPSOCLW
        HPSOCDW    LPSOCDW    TPSOCDW
        HPSOCU     LPSOCU     TPSOCU
        HPSCEORV   LPSCEORV   TPSCEORV
        HPSCENQE   LPSCENQE   TPSCENQE
        HPSOCERQ   LPSOCERQ   TPSOCERQ
        HPSCAXSS   LPSCAXSS   TPSCAXSS
        HPSCRPSS   LPSCRPSS   TPSCRPSS
        HPSCTONS   LPSCTONS   TPSCTONS
        HPSOCTW    LPSOCTW    TPSOCTW)
         (4.) ;
NREC71    =0; TPAGEINS  =0; TPAGEOUT  =0; TRCLAIMS  =0;
TADSPSWP  =0; TSWAPIN   =0; TSWAPOUT  =0; TVIOPGIN  =0;
TVIOPGOU  =0; TVIORECL  =0; TCOMPGIN  =0; TCOMPGOU  =0;
TCOMRECL  =0; HPAGEINS  =0; HPAGEOUT  =0; HRCLAIMS  =0;
HADSPSWP  =0; HSWAPIN   =0; HSWAPOUT  =0; HVIOPGIN  =0;
HVIOPGOU  =0; HVIORECL  =0; HCOMPGIN  =0; HCOMPGOU  =0;
HCOMRECL  =0; LPAGEINS  =.; LPAGEOUT  =.; LRCLAIMS  =.;
LADSPSWP  =.; LSWAPIN   =.; LSWAPOUT  =.; LVIOPGIN  =.;
LVIOPGOU  =.; LVIORECL  =.; LCOMPGIN  =.; LCOMPGOU  =.;
LCOMRECL  =.; HSTORAGE  =0; TSTORAGE  =0; HISQA     =0;
LOSQA     =.; TMXSQA    =0; HICSAF    =0; LOCSAF    =.;
TMXCSAF   =0; HICSAP    =0; LOCSAP    =.; TMXCSAP   =0;
HIGVIOF   =0; LOWVIOF   =.; TMAXVIOF  =0;
HPSOCLTT  =0; LPSOCLTT  =.; TPSOCLTT  =0; HPSOCLW   =0;
LPSOCLW   =.; TPSOCLW   =0; HPSOCDW   =0; LPSOCDW   =.;
TPSOCDW   =0; HPSOCU    =0; LPSOCU    =.; TPSOCU    =0;
HPSCEORV  =0; LPSCEORV  =.; TPSCEORV  =0; HPSCENQE  =0;
LPSCENQE  =.; TPSCENQE  =0; HPSOCERQ  =0; LPSOCERQ  =.;
TPSOCERQ  =0; HPSCAXSS  =0; LPSCAXSS  =.; TPSCAXSS  =0;
HPSCRPSS  =0; LPSCRPSS  =.; TPSCRPSS  =0; HPSCTONS  =0;
LPSCTONS  =.; TPSCTONS  =0; HPSOCTW   =0; LPSOCTW   =.;
TPSOCTW   =0;
HTPAGRT   =0; LTPAGRT   =.; TTPAGRT   =0; HPAGERT   =0;
LPAGERT   =.; TPAGERT   =0; HDPAGRT   =0; LDPAGRT   =.;
TDPAGRT   =0; HSWART    =0; LSWART    =.; TSWART    =0;
HPLSWPIN  =0; LPLSWPIN  =.; TPLSWPIN  =0; HPLSWPOU  =0;
LPLSWPOU  =.; TPLSWPOU  =0;
END;
SWT71=1;
DATE71=DATEX;
END;
PTR=15;
INPUT @PTR COMSIZ PIB2. @;
       PTR = PTR+COMSIZ;
INPUT @PTR PCSIZ PIB2. @;
       PTR = PTR+PCSIZ;
INPUT @PTR
       PAGEINS  PIB4. PAGEOUTS PIB4. RECLAIMS PIB4. ADSPSWAP PIB4.
       SWAPIN   PIB4. SWAPOUT  PIB4. VIOPGIN  PIB4. VIOPGOUT PIB4.
       VIORECL  PIB4. COMPAGIN PIB4. COMPGOUT PIB4. COMRECL  PIB4. @;
 * EQUIVALENTS:
       PAGEINS =SMF71PIN PAGEOUTS=SMF71POT
       RECLAIMS=SMF71PRC ADSPSWAP=SMF71SSQ
       SWAPIN  =SMF71SIN SWAPOUT =SMF71SOT
       VIOPGIN =SMF71VIN VIOPGOUT=SMF71VOT
       VIORECL =SMF71VRC COMPAGIN=SMF71SNI
       COMPGOUT=SMF71SNO COMRECL =SMF71SNR ;
INPUT @PTR
      (SMF71PIN  SMF71POT SMF71PRC SMF71SSQ
       SMF71SIN  SMF71SOT SMF71VIN SMF71VOT
       SMF71VRC  SMF71SNI SMF71SNO SMF71SNR
       SMF71LNI  SMF71LNR SMF71SRC SMF71AFC
       SMF71TFC  SMF71TSC SMF71DSC SMF71VSC
       SMF71NSC  SMF71FIN
       SMF71MNF  SMF71MXF SMF71AVF
       SMF71MNP  SMF71MXP SMF71AVP
       SMF71MNS  SMF71MXS SMF71AVS
       SMF71MNT  SMF71MXT SMF71AVT
       SMF71MNQ  SMF71MXQ SMF71AVQ
       SMF71MNC  SMF71MXC SMF71AVC
       SMF71MNR  SMF71MXR SMF71AVR
       SMF71MNX  SMF71MXX SMF71AVX
       SMF71MNU  SMF71MXU SMF71AVU
       SMF71MNV  SMF71MXV SMF71AVV
       SMF71MNM  SMF71MXM SMF71AVM
       SMF71MNB  SMF71MXB SMF71AVB
       SMF71MNA SMF71MXA SMF71AVA
       SMF71TIS       SMF71LWS       SMF71DWS       SMF71ULS
       SMF71NRS       SMF71ASS       SMF71RSS       SMF71EXS
       SMF71EES       SMF71TOS       SMF71TXS       SMF71LGS
       SMF71LFS       SMF71LSS       SMF71LSE       SMF71NLP
       SMF71XLP       SMF71ALP       SMF71NLF       SMF71XLF
       SMF71ALF       SMF71NLS       SMF71XLS       SMF71ALS)
       (PIB4.) @;
*---------------- DETAILS REPORTS  ------------------------------- ;
NREC71+1;
HPAGEINS=MAX(HPAGEINS,PAGEINS);
LPAGEINS=MIN(LPAGEINS,PAGEINS);
HPAGEOUT=MAX(HPAGEOUT,PAGEOUTS);
LPAGEOUT=MIN(LPAGEOUT,PAGEOUTS);
HRCLAIMS=MAX(HRCLAIMS,RECLAIMS);
LRCLAIMS=MIN(LRCLAIMS,RECLAIMS);
HADSPSWP=MAX(HADSPSWP,ADSPSWAP);
LADSPSWP=MIN(LADSPSWP,ADSPSWAP);
HSWAPIN=MAX(HSWAPIN,SWAPIN);
LSWAPIN=MIN(LSWAPIN,SWAPIN);
HSWAPOUT=MAX(HSWAPOUT,SWAPOUT);
LSWAPOUT=MIN(LSWAPOUT,SWAPOUT);
HVIOPGIN=MAX(HVIOPGIN,VIOPGIN);
LVIOPGIN=MIN(LVIOPGIN,VIOPGIN);
HVIOPGOU=MAX(HVIOPGOU,VIOPGOUT);
LVIOPGOU=MIN(LVIOPGOU,VIOPGOUT);
HVIORECL=MAX(HVIORECL,VIORECL);
LVIORECL=MIN(LVIORECL,VIORECL);
HCOMPGIN=MAX(HCOMPGIN,COMPAGIN);
LCOMPGIN=MIN(LCOMPGIN,COMPAGIN);
HCOMPGOU=MAX(HCOMPGOU,COMPGOUT);
LCOMPGOU=MIN(LCOMPGOU,COMPGOUT);
HCOMRECL=MAX(HCOMRECL,COMRECL);
LCOMRECL=MIN(LCOMRECL,COMRECL);
TPAGEINS+PAGEINS;
TPAGEOUT+PAGEOUTS;
TRCLAIMS+RECLAIMS;
TADSPSWP+ADSPSWAP;
TSWAPIN+SWAPIN;
TSWAPOUT+SWAPOUT;
TVIOPGIN+VIOPGIN;
TVIOPGOU+VIOPGOUT;
TVIORECL+VIORECL;
TCOMPGIN+COMPAGIN;
TCOMPGOU+COMPGOUT;
TCOMRECL+COMRECL;
INPUT @PTR +300
      (ITERM_WT       LONG_WT        DETECTED       UNILATRL
       REQUESTD       AUX_SHRT       REL_SHRT       EXCHANGE
       ENQ_EXCH       OTERM_WT) (PIB4.) @                            ;
*--------------  IBM RMF CALCULATIONS -------------------------------;
STORAGE=(SMF71TFC+SMF71FIN);       * SIZE OF REAL STORAGE            ;
TPAGRT=(SMF71PIN+SMF71POT+SMF71SIN+SMF71SOT+SMF71VIN+SMF71VOT
       +SMF71SNI+SMF71SNO)/RMFDUR; * TOT # OF PAGES PER SEC          ;
PSOCLTT=SMF71LFS/RMFDUR; * SWAPOUT DUE DETECTED LONG THINK TIME;
PSOCLW=SMF71LWS/RMFDUR;            * SWAPOUT DUE TO LONG WAIT;
PSOCDW=SMF71DWS/RMFDUR;            * SWAPOUT DUE TO DETECTED WAIT;
PSOCU=SMF71ULS/RMFDUR;             * # OF UNILATERAL SWAP-OUTS       ;
PSOCEORV=SMF71EXS/RMFDUR;          * SWAP-OUT ON RECOM. VALUE        ;
PSOCENQE=SMF71EES/RMFDUR;          * SWAP-OUT ON ENQUEUE EXHANGE     ;
PSOCERQ=SMF71NRS/RMFDUR;           * # OF REQUESTED SWAP-OUTS        ;
PSOCAXSS=SMF71ASS/RMFDUR;          * SWAP-OUT AUXI STORAGE SHORTAGE  ;
PSOCRPSS=SMF71RSS/RMFDUR;          * SWAP-OUT REAL STORAGE SHORTAGE  ;
PSOCTONS=SMF71TXS/RMFDUR;          * SWAP-OUT ADDR SPACE MADE NONSWAP;
PAGERT=(SMF71PIN+SMF71PRC)/RMFDUR; * # OF PAGE FAULTS/SECOND         ;
DPAGRT=(SMF71PIN+SMF71POT)/RMFDUR; * DEMAND PAGING /SECOND           ;
SWART=SMF71SSQ/RMFDUR;             * SWAP RATE                       ;
IF SMF71LGS ^= 0 THEN
PLSWAPIN=(((SMF71LSS+SMF71LGS-SMF71LFS-SMF71LSE)*100)/SMF71LGS)+.005;
ELSE PLSWAPIN=0;                   * % SUCESSFUL SWAP-IN             ;
IF (SMF71TIS+SMF71TOS) ^= 0 THEN
PLSWAPOU=((SMF71LGS*100)/(SMF71TIS+SMF71TOS))+.005;
ELSE PLSWAPOU=0;                   * % SUCESSFUL SWAP-OUT            ;
MXSQA=SMF71MXQ;                    * MAX # SQA FRAMES                ;
AVGSQA=SMF71AVQ;                   * AVG # SQA FRAMES                ;
MXCSAF=SMF71MXC;                   * MAX # CSA FIXED-FRAMES          ;
AVGCSAF=SMF71AVC;                  * AVG # CSA FIXED FRAMES          ;
MXCSAP=SMF71MXP;                   * MAX # PAGEABLE CSA FRAMES       ;
AVGCSAP=SMF71AVP;                  * AVG # PAGEABLE CSA FRAMES       ;
MAXVIOF=SMF71MXV;                  * MAX # ALLOCATED VIO SLOTS       ;
AVGVIOF=SMF71AVV;                  * AVG # VIO ALLOCATED SLOTS       ;
PSOCTW=(SMF71TIS+SMF71TOS-SMF71LGS)/RMFDUR;
                                   * SWAP-OUT TERMINAL WAIT          ;
*---------------- STORAGE ANALYSIS REPORT -----------------------    ;
HSTORAGE=MAX( HSTORAGE,STORAGE);
TSTORAGE+STORAGE;
HISQA   =MAX( HISQA ,MXSQA);
LOSQA   =MIN( LOSQA ,MXSQA);
TMXSQA  + MXSQA;
HICSAF  =MAX( HICSAF ,MXCSAF);
LOCSAF  =MIN( LOCSAF ,MXCSAF);
TMXCSAF + MXCSAF;
HICSAP  =MAX( HICSAP ,MXCSAP);
LOCSAP  =MIN( LOCSAP ,MXCSAP);
TMXCSAP + MXCSAP;
HIGVIOF =MAX( HIGVIOF ,MAXVIOF);
LOWVIOF =MIN( LOWVIOF ,MAXVIOF);
TMAXVIOF+ MAXVIOF;
*-----------------  PAGING RATE REPORT -----------------------        ;
PSOCTW=   PSOCTW*10;     *   REDUCE IN 1/10 SCALE;
PSOCLTT=  PSOCLTT*10;    *   REDUCE IN 1/10 SCALE;
PSOCLW=   PSOCLW*10;     *   REDUCE IN 1/10 SCALE;
PSOCDW=   PSOCDW*10;     *   REDUCE IN 1/10 SCALE;
PSOCU=    PSOCU*10;      *   REDUCE IN 1/10 SCALE;
PSOCEORV= PSOCEORV*10;   *   REDUCE IN 1/10 SCALE;
PSOCENQE= PSOCENQE*10;   *   REDUCE IN 1/10 SCALE;
PSOCERQ=  PSOCERQ*10;    *   REDUCE IN 1/10 SCALE;
PSOCAXSS= PSOCAXSS*10;   *   REDUCE IN 1/10 SCALE;
PSOCRPSS= PSOCRPSS*10;   *   REDUCE IN 1/10 SCALE;
PSOCTONS= PSOCTONS*10;   *   REDUCE IN 1/10 SCALE;
PAGERT=   PAGERT*10;     *   REDUCE IN 1/10 SCALE;
DPAGRT=   DPAGRT*10;     *   REDUCE IN 1/10 SCALE;
SWART=    SWART*10;      *   REDUCE IN 1/10 SCALE;
HTPAGRT  =MAX( HTPAGRT ,TPAGRT);
LTPAGRT  =MIN( LTPAGRT ,TPAGRT);
TTPAGRT  +TPAGRT;
HPAGERT  =MAX( HPAGERT ,PAGERT);
LPAGERT  =MIN( LPAGERT ,PAGERT);
TPAGERT  +PAGERT;
HDPAGRT  =MAX( HDPAGRT ,DPAGRT);
LDPAGRT  =MIN( LDPAGRT ,DPAGRT);
TDPAGRT  +DPAGRT;
HSWART   =MAX( HSWART ,SWART);
LSWART   =MIN( LSWART ,SWART);
TSWART   +SWART;
HPLSWPIN =MAX( HPLSWPIN ,PLSWAPIN);
LPLSWPIN =MIN( LPLSWPIN ,PLSWAPIN);
TPLSWPIN +PLSWAPIN;
HPLSWPOU =MAX( HPLSWPOU ,PLSWAPOU);
LPLSWPOU =MIN( LPLSWPOU ,PLSWAPOU);
TPLSWPOU +PLSWAPOU;
*----- SWAP-OUT PER SECOND REASONS : HIGH LOW AVG  TODAY VALUES------;
HPSOCLTT  =MAX( HPSOCLTT ,PSOCLTT);
LPSOCLTT  =MIN( LPSOCLTT ,PSOCLTT);
TPSOCLTT  +PSOCLTT;
HPSOCLW   =MAX( HPSOCLW ,PSOCLW);
LPSOCLW   =MIN( LPSOCLW ,PSOCLW);
TPSOCLW   +PSOCLW ;
HPSOCDW   =MAX( HPSOCDW ,PSOCDW);
LPSOCDW   =MIN( LPSOCDW ,PSOCDW);
TPSOCDW   +PSOCDW ;
HPSOCU    =MAX( HPSOCU ,PSOCU);
LPSOCU    =MIN( LPSOCU ,PSOCU);
TPSOCU    +PSOCU ;
HPSCEORV  =MAX( HPSCEORV ,PSOCEORV);
LPSCEORV  =MIN( LPSCEORV ,PSOCEORV);
TPSCEORV  +PSOCEORV;
HPSCENQE  =MAX( HPSCENQE ,PSOCENQE);
LPSCENQE  =MIN( LPSCENQE ,PSOCENQE);
TPSCENQE  +PSOCENQE;
HPSOCERQ  =MAX( HPSOCERQ ,PSOCERQ);
LPSOCERQ  =MIN( LPSOCERQ ,PSOCERQ);
TPSOCERQ  +PSOCERQ;
HPSCAXSS  =MAX( HPSCAXSS ,PSOCAXSS);
LPSCAXSS  =MIN( LPSCAXSS ,PSOCAXSS);
TPSCAXSS  +PSOCAXSS;
HPSCRPSS  =MAX( HPSCRPSS ,PSOCRPSS);
LPSCRPSS  =MIN( LPSCRPSS ,PSOCRPSS);
TPSCRPSS  +PSOCRPSS;
HPSCTONS  =MAX( HPSCTONS ,PSOCTONS);
LPSCTONS  =MIN( LPSCTONS ,PSOCTONS);
TPSCTONS  +PSOCTONS;
HPSOCTW   =MAX( HPSOCTW  ,PSOCTW );
LPSOCTW   =MIN( LPSOCTW  ,PSOCTW );
TPSOCTW   +PSOCTW ;
* OLD RMF CALCULATIONS BY J. A. CHAPMAN ;
ENQ_CONT = ENQ_EXCH +LONG_WT ;
COMRATE  = (COMPAGIN+COMPGOUT ) / RMFDUR;
PGFAULT  = (VIORECL +RECLAIMS +VIOPGIN +PAGEINS ) / RMFDUR ;
SWAPRATE = ( SWAPIN + SWAPOUT ) / RMFDUR;
IPS      = UNILATRL + ENQ_EXCH   ;
TOT_SWP  = ITERM_WT +LONG_WT +DETECTED +UNILATRL +REQUESTD +AUX_SHRT
           +REL_SHRT +EXCHANGE +ENQ_EXCH +OTERM_WT;
SWP_SEC  = TOT_SWP / RMFDUR   ;
VIO      = (VIOPGIN + VIOPGOUT) / RMFDUR;
RETURN; * END OF PAGING ANALYSIS;
PAGE;
* ----------------    WORKLOAD RECORD  -----------------------      ;
TYPE72:
IF DATEX ^= DATE72 THEN DO;
IF SWT72 = 1 THEN DO;
FILE RPT72PER HEADER=H72PER NOTITLES PRINT;
PUT / 'BY PERFORMANCE GROUP  '   100*'-';
DO OVER PERFG;
IF PERFG ^= 9999 THEN DO;
IF PCNT ^= 0 THEN DO;
APTSV=APTSV/PCNT;
APISV=APISV/PCNT;
APCSV=APCSV/PCNT;
APSSV=APSSV/PCNT;
APMSV=APMSV/PCNT;
APXSV=APXSV/PCNT;
APRTM=APRTM/PCNT;
APPER=APPER/PCNT;
 PUT
 PERFG  3. ' '
(HPTSV LPTSV APTSV
 HPISV LPISV APISV
 HPCSV LPCSV APCSV
 HPSSV LPSSV APSSV
 HPMSV LPMSV APMSV
 HPXSV  APXSV
 HPRTM  APRTM) (5.)
(HPPER  APPER) (6.) ;
PCNT    =0; HPTSV   =0; LPTSV   =.; APTSV   =0; HPISV   =0;
LPISV   =.; APISV   =0; HPCSV   =0; LPCSV   =.; APCSV   =0;
HPSSV   =0; LPSSV   =.; APSSV   =0; HPMSV   =0; LPMSV   =.;
APMSV   =0; HPXSV   =0; LPXSV   =.; APXSV   =0; HPRTM   =0;
LPRTM   =.; APRTM   =0; HPPER   =0; LPPER   =.; APPER   =0;
 END; END;
END;
PUT / 'BY DOMAIN   '              100*'-';
DO OVER DOM;
IF DOM ^= 9999 THEN DO;
IF DCNT ^= 0 THEN DO;
ADTSV=ADTSV/DCNT;
ADISV=ADISV/DCNT;
ADCSV=ADCSV/DCNT;
ADSSV=ADSSV/DCNT;
ADMSV=ADMSV/DCNT;
ADXSV=ADXSV/DCNT;
ADRTM=ADRTM/DCNT;
ADPER=ADPER/DCNT;
 PUT
 DOM    3. ' '
(HDTSV LDTSV ADTSV
 HDISV LDISV ADISV
 HDCSV LDCSV ADCSV
 HDSSV LDSSV ADSSV
 HDMSV LDMSV ADMSV
 HDXSV  ADXSV
 HDRTM  ADRTM) (5.)
(HDPER  ADPER) (6.) ;
DCNT    =0; HDTSV   =0; LDTSV   =.; ADTSV   =0; HDISV   =0;
LDISV   =.; ADISV   =0; HDCSV   =0; LDCSV   =.; ADCSV   =0;
HDSSV   =0; LDSSV   =.; ADSSV   =0; HDMSV   =0; LDMSV   =.;
ADMSV   =0; HDXSV   =0; LDXSV   =.; ADXSV   =0; HDRTM   =0;
LDRTM   =.; ADRTM   =0; HDPER   =0; LDPER   =.; ADPER   =0;
END; END; END;
PUT / 'BY OBJECTIVE  ' 100*'-';
DO OVER OBJ;
IF OBJ ^= 9999 THEN DO;
IF OCNT ^= 0 THEN DO;
AOTSV=AOTSV/OCNT;
AOISV=AOISV/OCNT;
AOCSV=AOCSV/OCNT;
AOSSV=AOSSV/OCNT;
AOMSV=AOMSV/OCNT;
AOXSV=AOXSV/OCNT;
AORTM=AORTM/OCNT;
AOPER=AOPER/OCNT;
 PUT
 OBJ    3. ' '
(HOTSV LOTSV AOTSV
 HOISV LOISV AOISV
 HOCSV LOCSV AOCSV
 HOSSV LOSSV AOSSV
 HOMSV LOMSV AOMSV
 HOXSV  AOXSV
 HORTM  AORTM) (5.)
(HOPER  AOPER) (6.) ;
OCNT    =0; HOTSV   =0; LOTSV   =.; AOTSV   =0; HOISV   =0;
LOISV   =.; AOISV   =0; HOCSV   =0; LOCSV   =.; AOCSV   =0;
HOSSV   =0; LOSSV   =.; AOSSV   =0; HOMSV   =0; LOMSV   =.;
AOMSV   =0; HOXSV   =0; LOXSV   =.; AOXSV   =0; HORTM   =0;
LORTM   =.; AORTM   =0; HOPER   =0; LOPER   =.; AOPER   =0;
END; END; END;
PUT _PAGE_;
FILE RPT72I HEADER=H72I NOTITLES PRINT;
ATOTSRV=ATOTSRV/REC72;
AIOSRV=AIOSRV/REC72;
ACPUSRV=ACPUSRV/REC72;
ASRBSRV=ASRBSRV/REC72;
AMSOSRV=AMSOSRV/REC72;
AITRANS=AITRANS/REC72;
ARTIME=ARTIME/REC72;
ASPERTRA=ASPERTRA/REC72;
 PUT DATE72 MMDDYY8. +11
(HTOTSRV LTOTSRV ATOTSRV
 HIOSRV LIOSRV AIOSRV
 HCPUSRV LCPUSRV ACPUSRV
 HSRBSRV LSRBSRV ASRBSRV
 HMSOSRV LMSOSRV AMSOSRV
 HTRANS  AITRANS
 HRTIME  ARTIME) (5.)
(HSPERTRA  ASPERTRA) (6.) ;
HTOTSRV   =0; LTOTSRV   =.;
ATOTSRV   =0; HIOSRV    =0; LIOSRV    =.; AIOSRV    =0; HCPUSRV   =0;
LCPUSRV   =.; ACPUSRV   =0; HSRBSRV   =0; LSRBSRV   =.; ASRBSRV   =0;
HMSOSRV   =0; LMSOSRV   =.; AMSOSRV   =0; HTRANS    =0; LTRANS    =.;
AITRANS   =0; HRTIME    =0; LRTIME    =.; ARTIME    =0; HSPERTRA  =0;
LSPERTRA  =.; ASPERTRA  =0; REC72=0;
END;
DATE72=DATEX ;
SWT72=1;
END;
       PTR=15;
INPUT @PTR COMSIZ PIB2. +14 PERFGRP PIB2. @;
       PTR=PTR+COMSIZ;
INPUT @PTR WKLSIZ PIB2. NRPERIOD PIB2.  PG_SIZE PIB2.
      +22 (IOCCOEFF CPUCOEFF MSOCOEFF SRBCOEFF) (4.)
      +20 SMF72SYS $4. @;
PERIOD=1 ;
       PTR = PTR+WKLSIZ;
LOOP72: IF NRPERIOD=0 THEN RETURN ;
INPUT @PTR TRANS PIB4. ACTIVE PIB4. SERVICE PIB4. ELAPSED PIB4.
      WKLOAD PIB4. MSOUNITS PIB4. IOUNITS PIB4. CPUUNITS PIB4.
      RESIDENT PIB4. SWAPSEQ PIB4. DOMAIN PIB2. OBJECTIV PIB1.
      TSG PIB1. SRBUNITS PIB4. (PETI1 PETI2) (PIB4.) @;
IF SERVICE = 0 THEN GOTO X72;
INPUT @PTR (SMF72TTX SMF72ACT SMF72SER SMF72TTM SMF72LEV
            SMF72MTS SMF72ITS SMF72CTS SMF72TAT SMF72SPP) (PIB4.)
            SMF72CDN PIB2. (SMF72PON SMF72TSG) (PIB1.)
           (SMF72STS SMF72ETI SMF72ET2) (PIB4.) @;
PGNP=PERFGRP;
DMN=DOMAIN;
SUBSYS= SMF72SYS;
TOTSRV=SMF72SER/RMFDUR;
HTOTSRV    =MAX( HTOTSRV , TOTSRV);
LTOTSRV    =MIN( LTOTSRV ,TOTSRV);
ATOTSRV    + TOTSRV ;
IOSRV=SMF72ITS/RMFDUR;
HIOSRV     =MAX( HIOSRV ,IOSRV);
LIOSRV     =MIN( LIOSRV ,IOSRV);
AIOSRV      + IOSRV ;
CPUSRV=SMF72CTS/RMFDUR;
HCPUSRV    =MAX( HCPUSRV ,CPUSRV);
LCPUSRV    =MIN( LCPUSRV ,CPUSRV);
ACPUSRV     + CPUSRV;
SRBSRV=SMF72STS/RMFDUR;
HSRBSRV    =MAX( HSRBSRV ,SRBSRV);
LSRBSRV    =MIN( LSRBSRV ,SRBSRV);
ASRBSRV     + SRBSRV;
MSOSRV=SMF72MTS/RMFDUR;
HMSOSRV    =MAX( HMSOSRV ,MSOSRV);
LMSOSRV    =MIN( LMSOSRV ,MSOSRV);
AMSOSRV     + MSOSRV;
ITRANS=SMF72TTX/RMFDUR;
HTRANS     =MAX( HTRANS ,ITRANS);
LTRANS     =MIN( LTRANS ,ITRANS);
AITRANS     + ITRANS;
IF SMF72TTX ^= 0 THEN
RTIME=(SMF72TTM*1024/(60E6))/SMF72TTX ;
ELSE RTIME=0;
HRTIME     =MAX( HRTIME ,RTIME);
LRTIME     =MIN( LRTIME ,RTIME);
ARTIME      + RTIME ;
IF SMF72SPP ^= 0 THEN
SPERTRA=SMF72TTX/SMF72SPP;
ELSE SPERTRA=0;
HSPERTRA   =MAX( HSPERTRA ,SPERTRA);
LSPERTRA   =MIN( LSPERTRA ,SPERTRA);
ASPERTRA    + SPERTRA ;
FILE RPT72PER HEADER=H72PER NOTITLES PRINT;
DO OVER PERFG;
 IF PERFG = 9999 THEN PERFG=PERFGRP;
 IF PERFG = PERFGRP THEN DO;
 PCNT+1;
HPTSV    =MAX( HPTSV , TOTSRV);
LPTSV    =MIN( LPTSV ,TOTSRV);
APTSV    + TOTSRV ;
HPISV     =MAX( HPISV ,IOSRV);
LPISV     =MIN( LPISV ,IOSRV);
APISV      + IOSRV ;
HPCSV    =MAX( HPCSV ,CPUSRV);
LPCSV    =MIN( LPCSV ,CPUSRV);
APCSV     + CPUSRV;
HPSSV    =MAX( HPSSV ,SRBSRV);
LPSSV    =MIN( LPSSV ,SRBSRV);
APSSV     + SRBSRV;
HPMSV    =MAX( HPMSV ,MSOSRV);
LPMSV    =MIN( LPMSV ,MSOSRV);
APMSV     + MSOSRV;
HPXSV     =MAX( HPXSV ,ITRANS);
LPXSV     =MIN( LPXSV ,ITRANS);
APXSV     + ITRANS;
HPRTM      =MAX( HPRTM ,RTIME);
LPRTM      =MIN( LPRTM ,RTIME);
APRTM       + RTIME ;
HPPER   =MAX( HPPER ,SPERTRA);
LPPER   =MIN( LPPER ,SPERTRA);
APPER    + SPERTRA ;
GOTO SKIPP72;
END;
END;
SKIPP72:
DO OVER DOM;
 IF DOM = 9999 THEN DOM=DOMAIN;
 IF DOM = DOMAIN THEN DO;
 DCNT+1;
HDTSV    =MAX( HDTSV , TOTSRV);
LDTSV    =MIN( LDTSV ,TOTSRV);
ADTSV    + TOTSRV ;
HDISV     =MAX( HDISV ,IOSRV);
LDISV     =MIN( LDISV ,IOSRV);
ADISV      + IOSRV ;
HDCSV    =MAX( HDCSV ,CPUSRV);
LDCSV    =MIN( LDCSV ,CPUSRV);
ADCSV     + CPUSRV;
HDSSV    =MAX( HDSSV ,SRBSRV);
LDSSV    =MIN( LDSSV ,SRBSRV);
ADSSV     + SRBSRV;
HDMSV    =MAX( HDMSV ,MSOSRV);
LDMSV    =MIN( LDMSV ,MSOSRV);
ADMSV     + MSOSRV;
HDXSV     =MAX( HDXSV ,ITRANS);
LDXSV     =MIN( LDXSV ,ITRANS);
ADXSV     + ITRANS;
HDRTM      =MAX( HDRTM ,RTIME);
LDRTM      =MIN( LDRTM ,RTIME);
APRTM       + RTIME ;
HDPER   =MAX( HDPER ,SPERTRA);
LDPER   =MIN( LDPER ,SPERTRA);
ADPER    + SPERTRA ;
GOTO SKIPD72;
END;
END;
SKIPD72:
DO OVER OBJ;
 IF OBJ = 9999 THEN OBJ=OBJECTIV;
 IF OBJ = OBJECTIV THEN DO;
 OCNT+1;
HOTSV    =MAX( HOTSV , TOTSRV);
LOTSV    =MIN( LOTSV ,TOTSRV);
AOTSV    + TOTSRV ;
HOISV     =MAX( HOISV ,IOSRV);
LOISV     =MIN( LOISV ,IOSRV);
AOISV      + IOSRV ;
HOCSV    =MAX( HOCSV ,CPUSRV);
LOCSV    =MIN( LOCSV ,CPUSRV);
AOCSV     + CPUSRV;
HOSSV    =MAX( HOSSV ,SRBSRV);
LOSSV    =MIN( LOSSV ,SRBSRV);
AOSSV     + SRBSRV;
HOMSV    =MAX( HOMSV ,MSOSRV);
LOMSV    =MIN( LOMSV ,MSOSRV);
AOMSV     + MSOSRV;
HOXSV     =MAX( HOXSV ,ITRANS);
LOXSV     =MIN( LOXSV ,ITRANS);
AOXSV     + ITRANS;
HORTM      =MAX( HORTM ,RTIME);
LORTM      =MIN( LORTM ,RTIME);
AORTM       + RTIME ;
HOPER   =MAX( HOPER ,SPERTRA);
LOPER   =MIN( LOPER ,SPERTRA);
AOPER    + SPERTRA ;
GOTO SKIPO72;
END;
END;
SKIPO72:
REC72+1;
WKLOAD=WKLOAD/256 ;
ACT_MIN=ACTIVE*1024/(60E6);
IF ACTIVE ^= 0 THEN ACT_SEC=ACTIVE * 1024/1.0E6 ;
IF RESIDENT^=0 THEN RES_SEC=RESIDENT*1024/1.0E6 ;
IF SERVICE ^=0 THEN ABS=SERVICE/RES_SEC ;
IF CPUUNITS^=0 THEN X=CPUUNITS/CPUCOEFF ;
ELP_MIN=ELAPSED*1024/(60E6);            ELP_SEC=ELAPSED*1024/1.0E6 ;
RES_MIN=RESIDENT*1024/(60E6);
      *CALCULATE CPUMIN FROM CPUUNITS. 60 IS CONVERSION TO MINUTES ;
      *CPUFACT IS NUMBER FOR CPU SU PER SECOND FROM IBM TABLES.
      *151 FOR 168, 125 FOR 165, 51.2 FOR 158, 42 FOR 155 & 24 FOR 145;
      *CORRESPONDING SECONDS PER SU (FOR SYS9 CPUS) ARE 151 - .0066,
      *125 - .080, 51.2 - .0195, 42.0 - .0238, 24 - .0417 ;
    SU_SEC=78.9;                             TSR=SERVICE/ACT_SEC ;
    CPUMIN=CPUUNITS/(CPUCOEFF*SU_SEC*60);
    IF TRANS ^= 0 THEN TRLEN=ELP_SEC/TRANS ; ELSE TRLEN=0;
    IOSERV=IOUNITS/IOCCOEFF;                 CPUSERV=CPUUNITS/CPUCOEFF;
    MSSERV=MSOUNITS/MSOCOEFF;                TOT_SRV=SERVICE/RMFDUR;
    SRBSERV=SRBUNITS/SRBCOEFF;               SRB_SRV=SRBUNITS/RMFDUR;
    AVE_TRAN=ACT_SEC/RMFDUR ;                MSO_SRV=MSOUNITS/RMFDUR;
    TRAN_WS=((MSOUNITS/MSOCOEFF)*50)/X ;
    RES_TIME=RES_SEC/ABS ;                   TRAN_SWA=RES_SEC/RMFDUR ;
IF TRANS^=0 THEN IO_TRAN = IOUNITS/(IOCCOEFF*TRANS) ;
    DMN_WS=TRAN_WS/TRAN_SWA   ;
    IO_SRV=IOUNITS/RMFDUR ;                  CPU_SRV=CPUUNITS/RMFDUR;
      IF SERVICE ^=0 THEN RETURN;
X72:  NRPERIOD=NRPERIOD-1 ;
      PERIOD=PERIOD+1 ;                      PTR=PTR+PG_SIZE ;
      GOTO LOOP72 ;
   RETURN             ;
PAGE;
* ------------------     CHANNEL RECORD  -------------------        ;
TYPE73:
IF DATEX ^= DATE73 THEN DO;
IF SWT73 =1 THEN DO;
DO OVER CHAN;
IF CCNT ^= 0 THEN DO;
IF CHAN ^= . THEN DO;
ACRT=ACRT/CCNT;
ACBSY=ACBSY/CCNT;
ACAVG=ACAVG/CCNT;
ASCWS=ASCWS/CCNT;
FILE RPT73CHN HEADER=H73CHN NOTITLES PRINT;
PUT  CHAN 6.
(HCRT LCRT ACRT
HCBSY LCBSY ACBSY
HCAVG LCAVG ACAVG
HSCWS LSCWS ASCWS ) (6.1);
CCNT    =0; HCRT    =0; LCRT    =.; ACRT    =0; HCBSY   =0;
LCBSY   =.; ACBSY   =0; HCAVG   =0; LCAVG   =.; ACAVX   =0;
HSCWS =0; LSCWS =.; ASCWS =0;
END; END; END;
PUT // 'RMF 73 -- CHANNEL ACTIVITY - LOGICAL EXCEPTIONS '
    '--  DATE=' DATE73 WORDDATE18.;
PUT 'LID % REQUEST<-------- % QLENGTH DISTRIBUTION    -------->'
    '<--- % REQUEST DIFFER CONDITION --->'
    '<------ %FREQ. OF CONDITION  ------>'
/  @8      'DIFFER    -0-      -1-      -2-      -3-      -4+- '
    'PHYS BSY LOG. BSY  C.U. BSY DEV. BSY'
    'PHYS BSY LOG. BSY  C.U. BSY DEV. BSY'
/ @5    ' HI LO AV HI LO AV HI LO AV HI LO AV HI LO AV HI LO AV'
    ' HI LO AV HI LO AV HI LO AV HI LO AV'
    ' HI LO AV HI LO AV HI LO AV HI LO AV';
DO OVER LCHAN;
IF LCCNT ^= 0 THEN DO;
IF LCHAN ^= 9999 THEN DO;
ALCH=ALCH/LCCNT;
TLQ0D   =TLQ0D   /LCCNT;
TLQ1D   =TLQ1D   /LCCNT;
TLQ2D   =TLQ2D   /LCCNT;
TLQ3D   =TLQ3D   /LCCNT;
TLQ4D   =TLQ4D   /LCCNT;
TLCBSY  =TLCBSY  /LCCNT;
TLLBSY  =TLLBSY  /LCCNT;
TLUBSY  =TLUBSY  /LCCNT;
TLDBSY  =TLDBSY  /LCCNT;
TFCBSY  =TFCBSY  /LCCNT;
TFLBSY  =TFLBSY  /LCCNT;
TFUBSY  =TFUBSY  /LCCNT;
TFDBSY  =TFDBSY  /LCCNT;
PUT  LCHAN 3. ' '
(HLCH LLCH ALCH
HLQ0D  LLQ0D    TLQ0D
HLQ1D  LLQ1D    TLQ1D
HLQ2D  LLQ2D    TLQ2D
HLQ3D  LLQ3D    TLQ3D
HLQ4D  LLQ4D    TLQ4D
HLCBSY  LLCBSY TLCBSY
HLLBSY  LLLBSY TLLBSY
HLUBSY  LLUBSY TLUBSY
HLDBSY  LLDBSY TLDBSY
HFCBSY  LFCBSY  TFCBSY
HFLBSY  LFLBSY  TFLBSY
HFUBSY  LFUBSY  TFUBSY
HFDBSY  LFDBSY  TFDBSY) (3.);
LCCNT    =0; HLCH    =0; LLCH    =.; ALCH    =0;
HLQ0D    =0; LLQ0D    =.; TLQ0D    =0; HLQ1D    =0;
LLQ1D =.; TLQ1D =0; HLQ2D =0; LLQ2D =.; TLQ2D =0; HLQ3D
=0; LLQ3D =.; TLQ3D =0; HLQ4D =0; LLQ4D =.; TLQ4D =0;
HLCBSY =0; LLCBSY =.; TLCBSY =0; HLLBSY =0; LLLBSY
=.; TLLBSY   =0; HLUBSY   =0; LLUBSY   =.; TLUBSY   =0;
HLDBSY   =0; LLDBSY   =.; TLDBSY   =0; HFCBSY =0;
LFCBSY   =.; TFCBSY   =0; HFLBSY   =0; LFLBSY   =.;
TFLBSY   =0; HFUBSY   =0; LFUBSY   =.; TFUBSY   =0;
HFDBSY =0; LFDBSY   =.; TFDBSY   =0;
END; END; END;
DATE73=DATEX;
HCACRT  =0; LCACRT  =.; ACACRT  =0; REC73P  =.; HCHBSY  =0;
LCHBSY  =.; ACHBSY  =0; HCSAVG  =0; LCSAVG  =.; ACAVG   =0;
END;
SWT73=1;
DATE73=DATEX;
END;
       PTR=15;
INPUT @PTR COMSIZ PIB2. +16 SAMPLES PIB4. @;
       PTR=PTR+COMSIZ;
INPUT @PTR PHYSIZ PIB2. NO_CHN PIB2. SIZE_CHN PIB2.
           NO_LOGI PIB2. SIZE_LOG PIB2. @;
       PTR = PTR+PHYSIZ;
COUNT = 1; LCOUNT=1;
CPUSAV = CPU_ID   ;
GETCHN:
INPUT @PTR CPUID PIB2.  CHN_ID PIB1. CHN_FLAG PIB1.
           CHN_SIO PIB4.  CHN_TCHB PIB4. CHN_TBW PIB4.  @  ;
   IF (CHN_SIO = 0 AND CHN_TCHB = 0 AND CHN_TBW = 0) THEN GOTO X73;
   CHN_BUSY = CHN_TCHB / SAMPLES          ; * CHANNEL BUSY FRACTION ;
   CHN_BSWT = CHN_TBW / SAMPLES          ; * CHAN BUSY, CPU WAIT   ;
   CHN_SIO  = CHN_SIO / RMFDUR           ; * SIO'S PER SECOND      ;
   FORMAT CHN_ID  HEX1.;
INPUT @PTR SMF73CID PIB2. (SMF73HID SMF73FG2) (PIB1.)
   (SMF73CNT SMF73BSY SMF73OLP SMF73PQ0 SMP73PG1 SMF73PQ2
    SMF73PG3 SMF73PG4 SMF73PRT) (PIB4.) @;
CACRT=SMF73CNT/RMFDUR; * CHANNEL ACTIVITY RATE PER SECOND;
CHBSY=((SMF73BSY*100)/SAMPLES)+.005; *PERCENT CHANNEL BUSY;
CSAVG=((SMF73BSY*RMFDUR)/SAMPLES)/SMF73CNT; * AVG CHANNEL SERVICE TIME;
CBSCWS=100*(SMF73OLP/SAMPLES)+.005; *PCT CHAN BUSY & CPU WAIT ;
HCACRT=MAX(HCACRT,CACRT);
LCACRT=MIN(LCACRT,CACRT);
ACACRT+CACRT;
REC73P+1;
HCHBSY=MAX(HCHBSY,CHBSY);
LCHBSY=MIN(LCHBSY,CHBSY);
ACHBSY+CHBSY;
HCSAVG=MAX(HCSAVG,CSAVG);
LCSAVG=MIN(LCSAVG,CSAVG);
ACAVG+CSAVG;
DO OVER CHAN;
IF CHAN= . THEN CHAN=SMF73HID;
IF CHAN =SMF73HID THEN DO;
    CCNT+1;
    HCRT=MAX(HCRT,CACRT);
    LCRT=MIN(LCRT,CACRT);
    ACRT+CACRT;
    HCBSY=MAX(HCBSY,CHBSY);
    LCBSY=MIN(LCBSY,CHBSY);
    ACBSY+CHBSY;
    HCAVG=MAX(HCAVG,CSAVG);
    LCAVG=MIN(LCAVG,CSAVG);
    ACAVX+CSAVG;
    HSCWS=MAX(HSCWS,CBSCWS);
    LSCWS=MIN(LSCWS,CBSCWS);
    ASCWS+CBSCWS;
    GO TO SKIP73;
    END;
END;
SKIP73:
   *    TEST THE CHANNEL FLAG         * ;
   *    X'01' IS ONLINE SELECTOR, X'21' IS ONLINE BLOCK MPX    ;
   IF CHN_FLAG = 1 OR CHN_FLAG = 33 THEN GOTO CHNOKDAT ; * DATA IS OK ;
   *  INVALID CHANNEL ID OR CPU WAS VARIED, SO DATA IS INVALID ;
   *   DATA IS INVALID FOR BYTE MPX TOO ;
   CHN_SIO  = .  ;  CHN_BUSY = . ; CHN_BSWT = .  ;
   CHNOKDAT:
   CPU_ID = CPUSAV   ;
X73:   IF COUNT GE NO_CHN THEN GOTO X73L;
   COUNT = COUNT + 1    ;
   PTR = PTR + SIZE_CHN   ;
   GOTO GETCHN  ;
*  LOGICAL CHANNEL MEASUREMENTS;
X73L:
   PTR = PTR + SIZE_CHN   ;
X73LL:
INPUT @PTR
  (SMF73LID SMF73PCI SMF73PCO SMF73RV9) (PIB2.)
  (SMF73RV6 SMF73RV7 SMF73RQS SMF73LQ0 SMF73LQ1 SMF73LQ2 SMF73LQ3
   SMF73LQ4 SMF73LQT SMF73PBC SMF73LBC SMF73CHF
   SMF73LGF SMF73CUB SMF73DVB
   SMF73CUF SMF73DVF) (PIB4.) SMF73FG3 PIB2. SMF73RV8 $2. @;
IF SMF73RQS ^= 0 THEN
DIOBLCH=(SMF73LBC+SMF73PBC+SMF73CUB+SMF73DVB)/SMF73RQS;
ELSE DIOBLCH=0;
TRQSDIF= SMF73PBC+SMF73LBC+SMF73CUB+SMF73DVB;* TOTALS RQS DIFFERED;
LQ0D   =.005+100*(SMF73LQ0/SAMPLES); * PCT QUEUE DISTRIBUTION 0 ;
LQ1D   =.005+100*(SMF73LQ1/SAMPLES); * PCT QUEUE DISTRIBUTION 1 ;
LQ2D   =.005+100*(SMF73LQ2/SAMPLES); * PCT QUEUE DISTRIBUTION 2 ;
LQ3D   =.005+100*(SMF73LQ3/SAMPLES); * PCT QUEUE DISTRIBUTION 3 ;
LQ4D   =.005+100*(SMF73LQ4/SAMPLES); * PCT QUEUE DISTRIBUTION 4 ;
LGCBSY =0; LGLBSY =0; LGUBSY =0; LGDBSY =0;
IF TRQSDIF ^= 0 THEN DO;
LGCBSY =.005+100*(SMF73PBC/TRQSDIF); * PCT PHYSCIAL CHANNEL BUSY;
LGLBSY =.005+100*(SMF73LBC/TRQSDIF); * PCT LOGICAL CHANNEL BUSY;
LGUBSY =.005+100*(SMF73CUB/TRQSDIF); * PCT CONTROL UNIT CHANNEL BUSY;
LGDBSY =.005+100*(SMF73DVB/TRQSDIF); * PCT DEVICE CHANNEL BUSY;
END;
LFCBSX =.005+100*(SMF73CHF/SAMPLES); * PCT PHYSCIAL CHANNEL BUSY;
LFLBSX =.005+100*(SMF73LGF/SAMPLES); * PCT LOGICAL CHANNEL BUSY;
LFUBSX =.005+100*(SMF73CUF/SAMPLES); * PCT CONTROL UNIT CHANNEL BUSY;
LFDBSX =.005+100*(SMF73DVF/SAMPLES); * PCT DEVICE CHANNEL BUSY;
DO OVER LCHAN;
IF LCHAN= 9999 THEN LCHAN=SMF73LID;
IF LCHAN =SMF73LID THEN DO;
    LCCNT+1;
    HLCH = MAX(HLCH,DIOBLCH);
    LLCH = MIN(LLCH,DIOBLCH);
    ALCH +DIOBLCH;
    HLQ0D   = MAX( HLQ0D ,LQ0D);
    HLQ1D   = MAX( HLQ1D ,LQ1D);
    HLQ2D   = MAX( HLQ2D ,LQ2D);
    HLQ3D   = MAX( HLQ3D ,LQ3D);
    HLQ4D   = MAX( HLQ4D ,LQ4D);
    LLQ0D   = MIN( LLQ0D ,LQ0D);
    LLQ1D   = MIN( LLQ1D ,LQ1D);
    LLQ2D   = MIN( LLQ2D ,LQ2D);
    LLQ3D   = MIN( LLQ3D ,LQ3D);
    LLQ4D   = MIN( LLQ4D ,LQ4D);
    TLQ0D   + LQ0D;
    TLQ1D   + LQ1D;
    TLQ2D   + LQ2D;
    TLQ3D   + LQ3D;
    TLQ4D   + LQ4D;
    HLCBSY = MAX( HLCBSY ,LGCBSY);
    HLLBSY = MAX( HLLBSY ,LGLBSY);
    HLUBSY = MAX( HLUBSY ,LGUBSY);
    HLDBSY = MAX( HLDBSY ,LGDBSY);
    LLCBSY = MIN( LLCBSY ,LGCBSY);
    LLLBSY = MIN( LLLBSY ,LGLBSY);
    LLUBSY = MIN( LLUBSY ,LGUBSY);
    LLDBSY = MIN( LLDBSY ,LGDBSY);
    TLCBSY + LGCBSY;
    TLLBSY + LGLBSY;
    TLUBSY + LGUBSY;
    TLDBSY + LGDBSY;
    HFCBSY = MAX( HFCBSY ,LFCBSX);
    HFLBSY = MAX( HFLBSY ,LFLBSX);
    HFUBSY = MAX( HFUBSY ,LFUBSX);
    HFDBSY = MAX( HFDBSY ,LFDBSX);
    LFCBSY = MIN( LFCBSY ,LFCBSX);
    LFLBSY = MIN( LFLBSY ,LFLBSX);
    LFUBSY = MIN( LFUBSY ,LFUBSX);
    LFDBSY = MIN( LFDBSY ,LFDBSX);
    TFCBSY + LFCBSX;
    TFLBSY + LFLBSX;
    TFUBSY + LFUBSX;
    TFDBSY + LFDBSX;
    GO TO SKIP73L;
    END;
END;
SKIP73L:
IF LCOUNT GE NO_LOGI THEN RETURN;
   LCOUNT = LCOUNT + 1    ;
   PTR = PTR + SIZE_LOG   ;
   GOTO X73LL  ;
PAGE;
*---------------------   DEVICE RECORD  -------------------        ;
TYPE74:
IF DATEX ^= DATE74 THEN DO;
IF SWT74=1 THEN DO;
FILE RPT74VOL HEADER=H74VOL NOTITLES PRINT;
DO OVER VOL;
IF VCNT ^= 0 THEN DO;
IF VOL^=' ' THEN DO;
ADNT =ADNT/VCNT;
ABSYB =ABSYB/VCNT;
ABSYN =ABSYN/VCNT;
ARD =ARD/VCNT;
AR =AR/VCNT;
AART =AART/VCNT;
AAVBE =AAVBE/VCNT;
AAVNB =AAVNB/VCNT;
AAQ =AAQ/VCNT;
* TOUT = 0 IGNORE VOLSER WITH NO VALUES (0);
TOUT=HDNT+LDNT+ADNT+HBSYB+LBSYB+ABSYB+HBSYN+LBSYN+ABSYN+HRD+
     LRD+ARD+HRA+LR+AR+HART+LART+AART+
     HAVBE+LAVBE+AAVBE+HAVNB+LAVNB+AAVNB+HAQ+LAQ+AAQ;
IF TOUT > 0.99999 THEN
  PUT
VOL    $CHAR6. ' '
(HDNT LDNT ADNT HBSYB LBSYB ABSYB HBSYN LBSYN ABSYN HRD
LRD ARD HRA LR AR HART LART AART) (4.)
(HAVBE LAVBE AAVBE HAVNB LAVNB AAVNB HAQ LAQ AAQ) (5.);
 VCNT=0; HDNT=0; LDNT=.; ADNT=0; HBSYB=0; LBSYB=.; ABSYB=0;
HBSYN=0; LBSYN=.; ABSYN=0; HRD=0; LRD=.; ARD=0; HRA=0;
LR=.; AR=0; HART=0; LART=.; AART=0; HAVBE=0; LAVBE=.;
AAVBE=0; HAVNB=0; LAVNB=.; AAVNB=0; HAQ=0; LAQ=.; AAQ=0;
END;
END;
END;
DATE74=DATEX;
PUT _PAGE_;
TDNTRDY   =0; TDART     =0; TDAVGBE   =0; TDAVGNBE =0; TDVBSYBE  =0;
TDVBSYNB  =0; TDRD      =0; TDR =0; TDAQ =0; HDNTRDY   =0; HDART =0;
HDAVGBE   =0; HDAVGNBE  =0; HDVBSYBE  =0; HDVBSYNB  =0; HDRD =0; HDR
=0; HDAQ =0; LDNTRDY   =.; LDART     =.; LDAVGBE   =.; LDAVGNBE =.;
LDVBSYBE  =.; LDVBSYNB =.; LDRD      =.; LDR =.; LDAQ =.;
END;
SWT74=1;
DATE74=DATEX;
END;
PTR=15;
INPUT @PTR COMSIZ PIB2. +16 NO_SAMPL PIB4. @;
PTR=PTR+COMSIZ;
INPUT @PTR DEVCSECT PIB2. NO_DEV PIB2. DEVDSECT PIB2. @   ;
PTR = PTR+DEVCSECT ; COUNT = 1 ;
* PUT '74: ' COMSIZ NO_SAMPL DEVCSECT NO_DEV DEVDSECT RMFDUR;
GETDEV: INPUT @PTR CU $CHAR1. @PTR CUB PIB1. @;
FORMAT CU  $HEX2. ;
        IF NO_SAMPL =0 THEN NO_SAMPL =.1;
  *     IF  80>CUB<128   THEN DELETE ;
INPUT @PTR DEV_ADDR PIB2.    +6 VOLSER $6.
           +2 (DEV_SIO  DEV_TDB  QDEPTH) (PIB4.) @;
INPUT @PTR SMF74ADD PIB2. (SMF74RV3 SMF74CNF) (PIB1.)
   SMF74TYP PIB4. SMF74SER $CHAR6. SMF74LCH PIB2.
   (SMF74CNT SMF74ACT SMF74QUE SMF74CON SMF74NRD SMF74ALC
    SMF74CUB SMF74BUS SMF74DSO SMF74AC0 SMF74AC1 SMF74AC2
    SMF74AC3 SMF74AC4 SMF74RSV SMF74MTP SMF74RDL SMF74DVB
    SMF74PTH SMF74CUD SMF74RDR) (PIB4.) @;
IF (DEV_TDB = 0  AND  DEV_SIO = 0) THEN GOTO DEVNEXT;
FORMAT DEV_ADDR $HEX4. ; IF DEV_TDB=0 THEN DEV_TDB=.001 ;
DEV_BUSY = DEV_TDB / NO_SAMPL ;
SIO_SEC = DEV_SIO / RMFDUR   ;
IF DEV_TDB <= 0 THEN AVE_QUE = QDEPTH / DEV_TDB   ;
                ELSE AVE_QUE = 0.0;
PCT_BUSY = INT(100 * (DEV_BUSY + .005));
DNOTRDY=((SMF74NRD*100)/NO_SAMPL)+.005;  *PERCENT NOT READY     ;
DART   =SMF74CNT/RMFDUR;                 *SIO PER SECOND        ;
DAVGBE =((SMF74CON*RMFDUR)/NO_SAMPL)/SMF74CNT;*AVG SERVICE TIME/SIO;
DAVGNBE=((SMF74ACT*RMFDUR)/NO_SAMPL)/SMF74CNT;*AVG SERVICE TIME/SIO;
DVBSYBE=((SMF74CON*100)/NO_SAMPL)+.005; *PERCENT DEVICE BUSY ;
DVBSYNB=((SMF74ACT*100)/NO_SAMPL)+.005; *PERCENT DEVICE BUSY ;
DRD    =((SMF74RDL*100)/NO_SAMPL)+.005; *PERCENT RESERVE DELAY;
DR     =((SMF74RSV*100)/NO_SAMPL)+.005; *PERCENT RESERVED    ;
DAQ    =SMF74QUE/NO_SAMPL; *AVG QUEUE LENGTH ON DEVICE       ;
DO OVER VOL;
  IF VOL=' ' THEN VOL=VOLSER;
  IF VOLSER=VOL THEN DO;
    VCNT+1;
    ADNT +DNOTRDY;
    AART +DART;
    AAVBE+DAVGBE;
    AAVNB+DAVGNBE;
    ABSYB+DVBSYBE;
    ABSYN+DVBSYNB;
    ARD +DRD;
    AR  +DR;
    AAQ  +DAQ;
    HDNT   =MAX( HDNT ,DNOTRDY);
    HART   =MAX( HART ,DART);
    HAVBE  =MAX( HAVBE ,DAVGBE);
    HAVNB  =MAX( HAVNB ,DAVGNBE);
    HBSYB  =MAX( HBSYB ,DVBSYBE);
    HBSYN  =MAX( HBSYN ,DVBSYNB);
    HRD   =MAX( HRD ,DRD);
    HRA   =MAX( HRA,DR);
    HAQ    =MAX( HAQ ,DAQ);
    LDNT   =MIN( LDNT ,DNOTRDY);
    LART   =MIN( LART ,DART);
    LAVBE =MIN( LAVBE ,DAVGBE);
    LAVNB =MIN( LAVNB ,DAVGNBE);
    LBSYB  =MIN( LBSYB ,DVBSYBE);
    LBSYN  =MIN( LBSYN ,DVBSYNB);
    LRD   =MIN( LRD ,DRD);
    LR    =MIN( LR ,DR);
    LAQ    =MIN( LAQ ,DAQ);
    GOTO SKIP74;
    END;
  END;
SKIP74:
TDNTRDY +DNOTRDY;
TDART   +DART;
TDAVGBE +DAVGBE;
TDAVGNBE+DAVGNBE;
TDVBSYBE+DVBSYBE;
TDVBSYNB+DVBSYNB;
TDRD    +DRD;
TDR     +DR;
TDAQ    +DAQ;
HDNTRDY   =MAX( HDNTRDY ,DNOTRDY);
HDART     =MAX( HDART ,DART);
HDAVGBE   =MAX( HDAVGBE ,DAVGBE);
HDAVGNBE  =MAX( HDAVGNBE ,DAVGNBE);
HDVBSYBE  =MAX( HDVBSYBE ,DVBSYBE);
HDVBSYNB  =MAX( HDVBSYNB ,DVBSYNB);
HDRD      =MAX( HDRD ,DRD);
HDR       =MAX( HDR ,DR);
HDAQ      =MAX( HDAQ ,DAQ);
LDNTRDY   =MIN( LDNTRDY ,DNOTRDY);
LDART     =MIN( LDART ,DART);
LDAVGBE   =MIN( LDAVGBE ,DAVGBE);
LDAVGNBE  =MIN( LDAVGNBE ,DAVGNBE);
LDVBSYBE  =MIN( LDVBSYBE ,DVBSYBE);
LDVBSYNB  =MIN( LDVBSYNB ,DVBSYNB);
LDRD      =MIN( LDRD ,DRD);
LDR       =MIN( LDR ,DR);
LDAQ      =MIN( LDAQ ,DAQ);
DEVNEXT: IF COUNT GE NO_DEV THEN RETURN ;
COUNT = COUNT + 1 ;    PTR=PTR + DEVDSECT ;
GOTO GETDEV ;
PAGE;
*------------ PAGE/SWAP DATASET RECORD  -------------------        ;
TYPE75:
IF DATEX ^= DATE75 THEN DO;
IF SWT75=1 THEN DO;
FILE RPT73CHN NOTITLES PRINT;
PUT // 'RMF 75 --- PAGE/SWAP DATA SET - EXCEPTIONS '
 '   BY DSNAME '
    ' DATE=' DATE75 WORDDATE18.;
PUT
'<--       PAGE/SWAP DATA SET NAME        -->'
' % BUSY-DSN '
' AVG SRV/SEC'
'PGS XFRD/SEC'
'PDSN RTE/SEC'
' AVG SLOTS USED'
' # BAD SLOTS' / @45
'  HI  LO AVG'
'  HI  LO AVG'
'  HI  LO AVG'
'  HI  LO AVG'
' HIGH  LOW  AVG'
'  HI  LO AVG';
DO OVER DSN;
IF DSN ^= ' ' THEN DO;
IF DSCNT ^= 0 THEN DO;
APBSY   =APBSY/DSCNT;
APAVG   =APAVG/DSCNT;
APPT    =APPT/DSCNT;
APART   =APART/DSCNT;
APAVGS  =APAVGS/DSCNT;
APBADS  =APBADS/DSCNT;
PUT DSN $CHAR44.
(HPBSY LPBSY APBSY HPAVG LPAVG APAVG HPPT LPPT APPT
 HPART LPART APART) (4.) (HPAVGS LPAVGS APAVGS) (5.)
(HPBADS LPBADS APBADS) (4.);
DSCNT  =0; LPBSY  =.; LPAVG    =.; LPPT   =.; LPART  =.; LPAVGS   =.;
LPBADS =.; HPBSY  =0; HPAVG    =0; HPPT   =0; HPART  =0; HPAVGS   =0;
HPBADS =0; APBSY  =0; APAVG    =0; APPT   =0; APART  =0; APAVGS   =0;
APBADS =0;
END;
END; END;
FILE RPT73CHN HEADER=H73CHN NOTITLES PRINT; PUT _PAGE_;
END; SWT75=1;
DATE75=DATEX;
END; PTR=15; INPUT @PTR COMSIZ PIB2. +16
NO_SAMPL PIB4. @; PTR=PTR+COMSIZ; INPUT @PTR SMF75SCA PIB2.
SMF75SDA PIB2. @; PTR = PTR+SMF75SCA ; INPUT @PTR
    SMF75DSN $CHAR44. (SMF75PST SMF75RV4 SMF75RV5) (PIB1.)
    SMF75TYP PIB4. SMF75CHA PIB2. SMF75VOL $CHAR6. SMF75RV2 PIB5.
   (SMF75SLA SMF75MXU SMF75MNU SMF75AVU SMF75BDS SMF75USE
    SMF75REQ SMF75SIO SMF75PGX SPF75RV8) (PIB4.) @;
PSBSY=((SMF75USE*100)/NO_SAMPL)+.005; *PERCENT BUSY-DATA SET ;
IF SMF75SIO ^= 0 THEN
PSAVG=((SMF75REQ*RMFDUR)/NO_SAMPL)/SMF75SIO; *AVG SERVICE TIME PER SEC;
ELSE PSAVG=0;
PSPT =SMF75PGX/RMFDUR;                *PAGES XFERED PER SEC ;
PSART=SMF75SIO/RMFDUR;                *PAGES DSN ACTIVITY RATE PER SEC;
PSAVGSL=SMF75AVU;                     *AVG SLOTS USED                 ;
PSBADS =SMF75BDS;                     *NUMBER OF BAD SLOTS            ;
DO OVER DSN;
IF DSN = ' ' THEN DSN=SMF75DSN;
IF DSN = SMF75DSN THEN DO;
    DSCNT+1;
    LPBSY   =MIN(  LPBSY ,PSBSY);
    LPAVG   =MIN(  LPAVG ,PSAVG);
    LPPT    =MIN(  LPPT ,PSPT);
    LPART   =MIN(  LPART ,PSART);
    LPAVGS  =MIN(  LPAVGS  ,PSAVGSL);
    LPBADS  =MIN(  LPBADS ,PSBADS);
    HPBSY   =MAX(  HPBSY ,PSBSY);
    HPAVG   =MAX(  HPAVG ,PSAVG);
    HPPT    =MAX(  HPPT ,PSPT);
    HPART   =MAX(  HPART ,PSART);
    HPAVGS  =MAX(  HPAVGS  ,PSAVGSL);
    HPBADS  =MAX(  HPBADS ,PSBADS);
    APBSY   +PSBSY;
    APAVG   +PSAVG;
    APPT    +PSPT;
    APART   +PSART;
    APAVGS  +PSAVGSL;
    APBADS  +PSBADS;
    GOTO SKIP75;
    END;
  END;
SKIP75:
RETURN;
PAGE;
H70I: PUT 'RMF 70 --- CPU ACTIVITY -- EXCEPTIONS -'
    ' DATE=' DATE70 WORDDATE18.;
PUT ' DATE '
    'CPU'
    '<--- % WAIT  ---->'
    '<-  % CPUBSY  >'
    '<  AVG IN RDY >'
    '<  AVG OU RDY >'
    '< TOT ASID >'
    '<- BATCH ASID ->'
    '<-   STC ASID ->'
    '<-   TSO ASID ->' /
    @10
    '  HIGH   LOW   AVG'
    '   HI   LO   AV'
    '   HI   LO   AV'
    '   HI   LO   AV'
    '  HI  LO  AV'
    '  HI  LO  AV MAX'
    '  HI  LO  AV MAX'
    '  HI  LO  AV MAX';
RETURN;
PAGE;
H71S: PUT 'RMF 71 --- STORAGE ANALYSIS -- EXCEPTIONS --'
    ' DATE=' DATE71 WORDDATE18.;
PUT '   DATE           REAL'
    '<----   SQA FRAMES ---->'
    '<-- CSA FIXED-FRAMES -->'
    '<- PAGEABLE CSA FRAMES->'
    '<-- VIO ALLOC SLOTS --->' /
    '                 STOR.'
    '  HIGH   LOW   AVG     .'
    '  HIGH   LOW   AVG     .'
    '  HIGH   LOW   AVG     .'
    '  HIGH   LOW   AVG     .' /
;
RETURN;
H71P: PUT 'RMF 71 --- PAGING RATE REPORT -- EXCEPTIONS --'
    ' DATE=' DATE71 WORDDATE18.;
PUT '   DATE        '
    ' <--------------      '
    'PAGES PER SECOND '
    '      --------------->'
    '<---    PCT SUCESSFULLY    -->' / @17
    '<-  PAGES    ->'
    '<-  FAULTS   ->'
    '<-  DEMAND   ->'
    '<-  SWAP     ->'
    '<-SWAP-IN    ->'
    '<-SWAP-OUT   ->' / @17
    '   HI  LOW  AVG'
    '   HI  LOW  AVG'
    '   HI  LOW  AVG'
    '   HI  LOW  AVG'
    '   HI  LOW  AVG'
    '   HI  LOW  AVG' /;
;
RETURN;
H71SO: PUT 'RMF 71 --- SWAP-OUT PER SECOND (SCALE 1:1/10) ---'
    'EXCEPTIONS/REASONS ---'
    ' DATE=' DATE71 WORDDATE18.;
*    1234567812345678                             ;
*    123456123456123456123456123456123456123456   ;
*    1234123412341234                             ;
PUT '    DATE' /
    '  LONG THINK'
    '   LONG WAIT'
    ' DETECT WAIT'
    '  UNILATERAL'
    '  RECOM VALU'
    '  ENQ EXCHAN'
    '   REQUESTED'
    '  AUX. SHORT'
    '  REAL SHORT'
    ' ASID NONSWP'
    '   TERM WAIT' /
    '  HI LOW  AV'
    '  HI LOW  AV'
    '  HI LOW  AV'
    '  HI LOW  AV'
    '  HI LOW  AV'
    '  HI LOW  AV'
    '  HI LOW  AV'
    '  HI LOW  AV'
    '  HI LOW  AV'
    '  HI LOW  AV'
    '  HI LOW  AV' /;
RETURN;
PAGE;
H72I: PUT 'RMF 72 --- WORKLOAD ACTIVITY --- EXCEPTIONS - '
    ' DATE=' DATE72  WORDDATE18.;
  PUT // '    DATE           '
 '<-  TOT SERV ->'
 '<-  I/O RATE ->'
 '<--   CPU  --->'
 '<--   SRB  --->'
 '<--   MSO  --->'
 '<-TRANS-->'
 '<RESP TME>'
 '<SWAP/TRAN >'
/ '                   '
 '   HI   LO  AVG'
 '   HI   LO  AVG'
 '   HI   LO  AVG'
 '   HI   LO  AVG'
 '   HI   LO  AVG'
 '   HI  AVG'
 '   HI  AVG'
 '    HI   AVG';
RETURN;
H72PER: PUT 'RMF 72 --- WORKLOAD ACTIVITY --- EXCEPTIONS - '
    ' DATE=' DATE72 WORDDATE18.;
  PUT // ' PG '
 '<-  TOT SERV ->'
 '<-  I/O RATE ->'
 '<--   CPU  --->'
 '<--   SRB  --->'
 '<--   MSO  --->'
 '<-TRANS-->'
 '<RESP TME>'
 '<SWAP/TRAN >'
/ @5
 '   HI   LO  AVG'
 '   HI   LO  AVG'
 '   HI   LO  AVG'
 '   HI   LO  AVG'
 '   HI   LO  AVG'
 '   HI  AVG'
 '   HI  AVG'
 '    HI   AVG';
RETURN;
PAGE;
H73CHN: PUT 'RMF 73 -- CHANNEL ACTIVITY - '
        '  PHYSICAL EXCEPTIONS -- BY CHANNEL ID '
    ' DATE=' DATE73 WORDDATE18.;
PUT ' CHNID '
'<-ACTIVITY RATE ->'
'<- % CHAN BUSY  ->'
'<-AVG SERV TIME ->'
'% CHN BSY & CPU WT' /
@7
'  HIGH   LOW   AVG'
'  HIGH   LOW   AVG'
'  HIGH   LOW   AVG'
'  HIGH   LOW   AVG' ;
RETURN;
PAGE;
H74VOL: PUT 'RMF 74 --- DEVICE ACTIVITY - EXCEPTIONS '
 '   BY VOLUME SERIAL    '
    ' DATE=' DATE74 WORDDATE18.;
PUT 'VOLSER '
   ' % NOT READY'
   '% DEV BSY BE'
   '% DEV BSY NB'
   '% RESV DELAY'
   ' % RESERVED '
   ' SIO PER SEC'
   'AVG SERV/SIO BE'
   'AVG SERV/SIO NB'
   'AVG QUEUE LNGTH' / @8
   '  HI  LO AVG'
   '  HI  LO AVG'
   '  HI  LO AVG'
   '  HI  LO AVG'
   '  HI  LO AVG'
   '  HI  LO AVG'
   '   HI   LO  AVG'
   '   HI   LO  AVG'
   '   HI   LO  AVG' ;
RETURN;
PAGE;
./       ADD   NAME=ASMTRACE
         MACRO
&N       STIOT &DDNAME,&DDLOC=,&START=,&NF=
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*                                                          STIOT
.*
.*       STIOT   - SEARCHES THE TASK INPUT/OUTPUT TABLE (TIOT)
.*       -----------------------------------------------------------
.*
.*             RULES TO USE THIS MACRO WOULD BE DIFFICULT TO DEFINE.
.*       INSTEAD, SEVERAL EXAMPLES ARE SHOWN.
.*
.*
.*  +-----------------------------------------------------------------+
.*  ×<SYMBOL>×STIOT  × <DDNAME><,DDLOC=><,START=><,NF=>               ×
.*  +-----------------------------------------------------------------+
.*
.*       DDNAME
.*             NOT GIVEN - RETURN POINTER TO DD ENTRY PORTION OF
.*                         TIOT IN REG 1.
.*             $  -  RETURN POINTER TO TIOT IN REG 1.
.*             *  -  RETURN POINTER TO LAST TIOT ENTRY IN REG 1.
.*             DDNAME - SEARCH TIOT FOR DDNAME (OR DDNAME NODE:
.*                      CLC =C'DDNAME',TIOTDDN)
.*
.*       DDLOC=
.*             SPECIFIES THE ADDRESS OF THE DDNAME VALUE.
.*
.*       START=
.*             SPECIFIES THE STARTING DDNAME ENTRY TO USE FOR THE
.*             SEARCH.  CAN BE A LABEL OR A REGISTER.
.*
.*       NF=
.*             BRANCH ADDRESS TO TAKE IF ENTRY IS NOT FOUND.
.*
.*
.*       EXAMPLES:
.*
.*      STIOT SYSPRINT,NF=NOPRINT
.*         SEARCH FOR SYSPRINT DD.  IF PRESENT, RETURN POINTER TO
.*         IT IN REG1, ELSE GO TO NOPRINT.
.*
.*      STIOT DDLOC=DD,NF=NOTFOUND
.*         SEARCH FOR THE DDNAME AT DD. GO TO NOTFOUND IF NOT FOUND,
.*         ELSE RETURN ITS ADDRESS IN REG 1.
.*
.*      STIOT
.*         RETURN POINTER TO TIOT DD ENTRY PORTION IN REG 1.
.*
.*      STIOT *
.*         RETURN IN REG 1 THE ADDRESS OF THE TIOT.
.*
.*      STIOT SYSPRINT,START=(R5),NF=NOPRINT
.*         SEARCH FOR THE SYSPRINT DD ENTRY BEGINNING WITH THE DD
.*         ENTRY ADDRESS CONTAINED IN R5.  IF NOT FOUND, GO TO NOPRINT,
.*         ELSE RETURN ADDRESS OF SYSPRINT IN REG 1.
.*
.**********************************************************************
         AIF   ('&START' EQ '').FIND
         AIF   ('&START' NE '&START(1)').REG  TEST FOR REG NOTATION
&N       L     1,&START
         AGO   .ON
.REG     AIF   ('&START' EQ '(1)').PRELOAD
&N       LR    1,&START(1)
         AGO   .ON
.PRELOAD ANOP
&N       SLR   15,15
         AGO   .ON1
.FIND    ANOP
&N       L     1,16 CVT
         L     1,0(1) TCB POINTERS
         L     1,4(1) TCB
         L     1,12(1) TIOT
         AIF   ('&DDNAME' EQ '$').ON4  EXIT IF NOT LOCATING ENTRY
         LA    15,24 DISPLACEMENT OF 1ST DD ENTRY
         AGO   .AR
.ON      SLR   15,15
.ON1     IC    15,0(1)
.AR      AR    1,15 BUMP TO NEXT ENTRY
         AIF   ('&DDNAME' EQ '' AND '&DDLOC' EQ '' AND '&NF' EQ '').ON4
         IC    15,0(1) LENGTH OF ENTRY
         AIF   ('&DDNAME' EQ '*').LAST
         LTR   15,15
         AIF   ('&NF' NE '').BZ
         BZ    *+14       TAKE NOT FOUND EXIT IF END OF TABLE
         AGO   .IF
.BZ      BZ    &NF TAKE NOT FOUND EXIT IF END OF TABLE
.IF      AIF   ('&DDNAME' EQ '' AND '&DDLOC' EQ '').ON4
         AIF   ('&DDNAME' NE '').ON2
         CLC   &DDLOC,4(1)
         AGO   .ON3
.ON2     CLC   =C'&DDNAME',4(1)
.ON3     BNE   *-18
         MEXIT
.LAST    STC   15,*+7 LENGTH IS DISPLACEMENT
         CLI   0(1),0 LOOK AHEAD
         BNE   *-14 DROP THRU IF LAST TIOT ENTRY
.ON4     MEND
TRACE    TITLE 'TRACE: AN INSTRUCTION TRACE ROUTINE'
***********************************************************************
*                                                                     *
*                                                                     *
*        THE TRACE ROUTINE IS USED TO TRACE A PROGRAM THROUGH         *
*        EXECUTION AT THE ASSEMBLY LEVEL. THIS IS DONE BY RETAINING   *
*        CONTROL OF THE TRACED PROGRAM AFTER THIS ROUTINE IS CALLED   *
*        AND EXECUTING THE TRACED PROGRAMS' INSTRUCTIONS.             *
*        USER ABENDS USED BY THE TRACE ARE:                           *
*              U111 - TRACE ROUTINE ATTEMPT TO STAE FAILED            *
*              U222 - ILLEGAL INSTRUCTION WAS DETECTED IN THE TRACE.  *
*              U333 - SYSTRACE DCB COULD NOT BE OPENED.               *
*        AUTHOR : BERNARD SCHOCH, COMNET COMPUTER CENTER              *
*        DEBUGGED 03/22/74 BY CLAUDE SCHOCH                           *
*        CONVERTED FOR 370 INSTSRUCTIONS AND EXTENDED FLOATING POINT  *
*        INSTRUCTIONS BY CLAUDE SCHOCH 2/12/75                        *
*        ENHANCED AND SUPPORTED BY:                                   *
*                    LIONEL SILVA                                     *
*                    US POSTAL DATA CENTER                            *
*                    850 CHERRY AVENUE                                *
*                    SAN BRUNO, CA 94097-9330                         *
*                    (415) 876-9142                                   *
*        ENHANCED AND IMPROVED BY:  3/9/84                            *
*                    DAVID O. RIKER                                   *
*                    COMPUTER DATA SYSTEMS, INC                       *
*                    1 CURIE COURT                                    *
*                    ROCKVILLE, MD 20850                              *
*     1. SUPPORT FOR MVS EXTENTED INSTRUCTIONS (S,RRE, & SSE FORMATS) *
*     2. ADD CSECT NAME AND OFFSET ADDRESS IN OUTPUT FORMAT           *
*     3. BUILT CSECT TABLE WITH NAME, POINTER, AND LENGTH             *
*     4. FIXED DECIMAL INSTRUCTION DISPLAY OUTPUT                     *
*     5. ADD TRACEON, TRACEOFF, TRACKILL INDICATOR SWITCH COMMANDS    *
*          TO REDUCE SYSTRACE OUTPUT LISTING.                         *
*     6. FUTURE PLANNING: MORE SWITCH COMMANDS LIKE SNAP SPECIFIED    *
*        AREA WHEN HIT AT CSECT+XX, DISPLAY GREATER THAN 4 BYTES      *
*        OF DISPLACMENT (LONG MVC OR DSECT), MORE AND MORE.....       *
*     7. FIX WRONG LOGIC ON ADDING INDEX WHILE BXH OR BXLE INSTRUCTION*
*     8. IMPROPERLY USED WITH B2XX 9CXX 9DXX 9EXX E5XX INSTRUCTIONS
*        FIXED TO USE RRE AND SSE FORMAT LOGICS.
*     9. ADD LRA INSTUCTION TO OPERATOR TABLE (WAS TREATED AS ILLEGAL).
*    10. IMPROVE LOGIC TO CLEAR REGISTER  BEFORE IC INSTRUCTION.
*        IT WAS CAUSED SOME PROBLEMS ON PRINT SHIFT INSTRUCTION LINE.
*                                                                     *
*        TO UTILIZE TRACE PROGRAM:                                    *
*                                                                     *
*        TO INITIATE TRACE, CODE "CALL TRACE" IN ANY ASM SOURCE.      *
*        THE PROBLEM SOURCE SHOULD BE LINKED WITH ASMTRACE MODULE     *
*        AS SUBROUTINE. (USE A INCLUDE SYSLIB(ASMTRACE) CARD.)        *
*                                                                     *
*        TO TURN OFF TRACE PRINTING, CODE "CALL TRACEOFF".            *
*        TO TURN ON TRACE PRINTING, CODE "CALL TRACEON".              *
*        TO ABORT  TRACE PROCESSING, CODE "CALL TRACKILL".            *
*                                                                     *
*        WARNING: "CALL TRACE" MUST BE INITIATED FIRST BEFORE         *
*              USING TRACEON, TRACEOFF, OR TRACKILL.                  *
*                                                                     *
*        INCLUDE A //SYSTRACE DD CARD IN THE JCL USED TO EXECUTE      *
*        THE TRACED PROGRAM.  ONE LINE OF OUTPUT PER INSTRUCTION      *
*        WILL BE WRITTEN TO SYSTRACE.                                 *
*                                                                     *
***********************************************************************
         GBLC  &TYPE
&TYPE    SETC  'OS'
         EJECT
TRACE    CSECT
SCR0     EQU   0                       SCRATCH REGISTER
SCR1     EQU   SCR0+1                  SCRATCH REGISTER
SCR2     EQU   2                       SCRATCH REGISTER
SCR3     EQU   3                       SCRATCH REGISTER
FLDPT    EQU   3                       POINTER FOR PLINOP
INITLR   EQU   15                      BASE REGISTER FOR INITIALIZATION
EXEC     EQU   4                       ADDRESS OF EXECUTE ROUTINE
DATA     EQU   9                       BASE FOR DATA AREA
HEX2EBC  EQU   10                      ADDRESS OF CONVERT ROUTINE
HEX2EBC2 EQU   7                       ADDRESS OF SECOND BASE
ILCR     EQU   11                      PSEUDO LOCATION COUNTER
CBR      EQU   12
BRFROM   EQU   12                      BRANCH REGISTER
BRFROX   EQU   8                       BRANCH REGISTER
OSAVE    EQU   13                      ADDRESS OF SAVE AREA
SELF     EQU   15                      ADDRESS OF TRACE ROUTINE
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
***********************************************************************
*                                                                     *
*              SPECIFY LENGTH OF PRINTED LINE                         *
*                                                                     *
***********************************************************************
LPL      EQU   132                     LENGTH OF THE PRINT LINE
***********************************************************************
*                                                                     *
*              DEFINE FLAG BITS USED THROUGHOUT THE TRACE ROUTINE     *
*              TO SPECIFY THE ATTRIBUTES OF THE MACHINE INSTRUCTIONS  *
*                                                                     *
***********************************************************************
ILGLBIT  EQU   B'10000000'             ILLEGAL INSTRUCTION
SPECBIT  EQU   B'10000000'             S/RRE/SSE FORMAT INSTRUCTION
CCBIT    EQU   B'01000000'             INSTRUCTION SETS CONDITION CODE
BRBIT    EQU   B'00100000'             INSTRUCTION IS BRANCH OR EXECUTE
HALFBIT  EQU   B'00010000'             HALF WORD INSTRUCTION
FULLBIT  EQU   B'00001000'             FULL WORD INSTRUCTION
DBLBIT   EQU   B'00000100'             DOUBLE WORD INSTRUCTION
FLOATBIT EQU   B'00000010'             FLOATING POINT INSTRUCTION
SHIFTBIT EQU   B'00000001'             SHIFT INSTRUCTION
***********************************************************************
*                                                                     *
*        ATTRIBUTES WHICH MAY OCCUR IN THE SECODN BYTE                *
*              OF 'FLAGS'                                             *
*                                                                     *
***********************************************************************
RRBIT    EQU   B'10000000'             TYPE RR  INSTRUCTION
SBIT     EQU   B'10000000'             TYPE S   INSTRUCTION
RXBIT    EQU   B'01000000'             TYPE RX  INSTRUCTION
RREBIT   EQU   B'01000000'             TYPE RRE INSTRUCTION
RSBIT    EQU   B'00100000'             TYPE RS  INSTRUCTION
SSEBIT   EQU   B'00100000'             TYPE SSE INSTRUCTION
SIBIT    EQU   B'00010000'             TYPE SI  INSTRUCTION
SSBIT    EQU   B'00001000'             TYPE SS  INSTRUCTION
IMDFBIT  EQU   B'00000100'             INSTRUCTION CONTAINS 8-BIT
*                                      IMMEDIATE FIELD
LMSTMBIT EQU   B'00000010'             IMSTRUCTION IS LM OR STM
EXBIT    EQU   B'00000001'             INSTRUCTION IS EXECUTE (EX)
         EJECT
TRACE    CSECT
         ENTRY TRACE
         USING *,INITLR
         B     TRACEB
         DC    AL1(6)                  CSECT IDENTIFIER
         DC    CL6'TRACE'
TRACEB   STM   0,15,SAVE               SAVE ALL REGISTERS
         LA    OSAVE,SAVE              BASE ADDRESS
         USING SAVE,OSAVE
         B     BEGN
         DROP INITLR,OSAVE
         SPACE 1
***********************************************************************
*                                                                     *
*  TRACEOFF    TURN OFF PRINTING AND CONTINUE TRACE ROUTINE
*                                                                     *
***********************************************************************
         DS    0F
         USING *,INITLR
         ENTRY TRACEOFF
TRACEOFF EQU   *
         STM   14,12,12(13)
         LA    OSAVE,SAVE
         USING SAVE,OSAVE
         DROP  INITLR
         L     DATA,ADATA              ADDRESS OF THE DATA AREA
         USING DATAREA,DATA
         MVI   PRINTING,X'00'          TURN OFF PRINTING
         LM    14,12,12(13)
         BR    R14
         DROP DATA
         EJECT
***********************************************************************
*                                                                     *
*  TRACKILL    TURN OFF PRINTING AND STOP TRACING
*                                                                     *
***********************************************************************
         DS    0F
         ENTRY TRACKILL
         USING *,INITLR
TRACKILL EQU   *
         STM   14,12,12(13)
         LA    OSAVE,SAVE
         USING SAVE,OSAVE
         DROP  INITLR
         L     DATA,ADATA              ADDRESS OF THE DATA AREA
         USING DATAREA,DATA
         MVI   PRINTING,X'99'          ABORT TRACING PROCESSING
         LM    14,12,12(13)
         BR    R14
         DROP DATA
         EJECT
***********************************************************************
*                                                                     *
*  TRACEON     TURN ON  PRINTING AND CONTINUE TRACE ROUTINE
*                                                                     *
***********************************************************************
         DS    0F
         ENTRY TRACEON
         USING *,INITLR
TRACEON EQU   *
          STM   14,12,12(13)            SAVE ALL REGISTERS
          LA    OSAVE,SAVE
         USING SAVE,OSAVE
         DROP  INITLR
          L     DATA,ADATA              ADDRESS OF THE DATA AREA
          USING DATAREA,DATA
          MVI   PRINTING,X'FF'          TURN ON PRINTING
          LM     14,12,12(13)
         BR    R14
         DROP DATA
*        EJECT
***********************************************************************
*                                                                     *
*              SAVE  AREA                                             *
*                                                                     *
***********************************************************************
         SPACE 1
SAVE     DC    18F'0'                  SAVE AREA
ADATA    DC    A(DATAREA)              ADDRESS OF TRACE ROUTINE DATA
AHEX     DC    A(HEXTOEBC)             ADDRESS OF CONVERT ROUTINE
         SPACE 3
***********************************************************************
*                                                                     *
*  HEXTOEBC    BINARY TO EBCDIC CONVERSION ROUTINE                    *
*                                                                     *
***********************************************************************
         SPACE 1
         USING *,HEX2EBC
         USING *+4096,HEX2EBC2
TRACEDS  DS    0F
HEXTOEBC ST    SCR0,HEXTABLE+16        STORE THE WORD TO BE CONVERTED
         L     SCR1,HEXTABLE-4         NORMALIZED ADDRESS OF CONVERT
*                                      TABLE
         UNPK  HEXTABLE+16(9),HEXTABLE+16(5)
*                                      SPREAD THE HEX DIGITS
         TR    HEXTABLE+16(8),0(1)     TRANSLATE DIGISS TO
*                                      CORRESPONDING CHARACTERS
         LM    SCR0,SCR1,HEXTABLE+16   LOAD RESULT
         BR    BRFROM                  RETURN
         DROP  HEX2EBC,HEX2EBC2
         DC    A(HEXTABLE-240)         NORMALIZED ADDRESS CONSTANT
HEXTABLE DC    CL25'0123456789ABCDEF'
         EJECT
***********************************************************************
*                                                                     *
*  BEGN        INITIALIZATION OF THE TRACE ROUTINE
*                                                                     *
***********************************************************************
         SPACE 1
BEGN     L     DATA,ADATA              ADDRESS OF THE DATA AREA
         USING DATAREA,DATA
         ST    SELF,AENTRY             SAVE ADDRESS OF THE TRACE
         LA    SCR0,DCB
         ST    SCR0,ESTAEPRM
         ESTAE RECOVER,XCTL=NO,PARAM=ESTAEPRM,PURGE=HALT,ASYNCH=NO
         LTR   15,15
         BZ    ESTAEOK
         ABEND 111,DUMP
ESTAEOK  DS    0H
*                                      ROUTINE ENTRY POINT
         LR    ILCR,14                 ADDRESS OF 1ST INSTRUCTION
*                                      TO BE TRACED
         L     EXEC,AEXEC              EXECUTE ROUTINE ADDRESS
         L     HEX2EBC,AHEX
         USING HEXTOEBC,HEX2EBC
         LA    HEX2EBC2,4095(,HEX2EBC)
         LA    HEX2EBC2,1(,HEX2EBC2)
         USING HEXTOEBC+4096,HEX2EBC2
         SPACE 3
***********************************************************************
*                                                                     *
*              COPY THE REGISTERS OF THE TRACED PROGRAM INTO REGTBL   *
*                                                                     *
***********************************************************************
         SPACE 1
         MVC   REGTBL(64),SAVE
         BAL   BRFROM,WRITE            WRITE 1 BLANK LINE
         BAL   BRFROM,RDUMP            DUMP THE INITIAL
*                                      GENERAL REGISTERS
         STD   0,F0                    SAVE THE INITIAL VALUES
         STD   2,F2                    OF THE FLOATING POINT
         STD   4,F4                    REGISTERS
         STD   6,F6
         BAL   BRFROM,FDUMP            DUMP THE FLOAING  POINT
*                                      REGISTERS
         BAL   BRFROM,WRITE            WRITE 1 BLANK LINE
         EJECT
***********************************************************************
*       BUILT CSECT TABLE                                             *
*       WITH  PROGRAMS NAME, LOCATION, AND LENGTH
*       SPOOL NUMBER AND LOCATION AND LENGTH                          *
***********************************************************************
MAPCSECT EQU   *
         STM   0,15,SAVEMAPR
         ST    R15,SAVER15
         CLI   MAPSWT,X'FF'     FIRST TIME MAP BUILDER?
         BE    MAPOFF
         MVI   MAPSWT,X'FF'
         L     R4,16         CVT
         L     R4,0(R4)      ADDR OF TCB BOX
         L     R4,4(R4)      ADDR OF CUR TCB TO BE EXCUTED
         ST    R4,TCBADR
         L     R4,540        PSATOLD-PSA   CURRENT TCB
         ST    R4,TCBCUR
         L     R6,TCBADR
         LR    R5,R6
         B     TCBDISP
TCBREP   L     R5,136(R6)          1ST ATTACHED TCB
         LTR   R5,R5
         BNZ   TCBDISP
TCB1     L     R5,128(R6)          PREVIOUSLY ATTACHED TCB
         LTR   R5,R5
         BNZ   TCBDISP
         L     R6,132(R6)          TASK'S TCB
         LA    R6,0(R6)            ADDRESS OF THIS TCB
         L     R5,TCBADR
         LA    R5,0(R5)            ADDRESS OF THIS TCB
         CR    R5,R6               IF SAME TCBS END OF PROCESSING
         BNE   TCB1
MAPEX2   EQU   *
         B     MAPDONE                     EXIT
TCBDISP  EQU   *
         LR    R11,R5              TCB ADDRESS CONVERT EBCDI HEX
         CLI   174(R5),X'00' NO ABEND
         BE    TCBX2
         TM    174(R5),X'40' IS TASK SET NON-DISPATCH ABILITY
         BO    TCBX2
         TM    33(R5),X'80' IS ANOTHER TASK IS IN SYSTEMMUST COMPLETE
         BZ    TCBX1
         LR    R6,R5               TCB ADDRESS
         B     TCBREP              TRY NEXT TCB
TCBX1    L     R7,0(,R5)           ADDR OF RB
         LA    R3,64               RB-64
         SR    R7,R3               OFFSET TO -64
         CLI   63(R7),X'3D'        RB-1  INTERUPTION CODE RBINTCOD
         BE    TCBX2
         CLI   63(R7),X'61'        RB-1
         BE    TCBX2
         LR    R6,R5               NEXT TCB
         B     TCBREP
TCBX2    L     R7,36(,R5)          ADDR OF LLE (LAST LOAD LIST ELEMENT
         L     R15,MAPDIRA
         USING MODDIRD,R15
TCBX21   LA    R7,0(R7)            ADDR OF NEXT LLE
         LTR   R7,R7
         BNZ   TCBX4
         OI    MAPFLAG,X'04'
         B     TCBX7
TCBX3    L     R8,20(,R8)          ADR OF NEXT MINOR CDE
         LA    R8,0(R8)
         B     TCBX41
TCBX4    L     R8,4(,R7)           ADR OF CDE
TCBX41   TM    28(R8),X'04'        SEE IF IT IS MINOR CDE?
         BO    TCBX3               NO,
         MVC   MODNMEX(8),8(R8)
         L     R6,20(,R8)          EXTEND CDE ADDR
         L     R3,4(,R6)           RB ADR
         LR    R8,R3
         SLA   R8,2
         XR    R4,R4
TCBX6    LTR   R3,R3
         BNP   TCBXA
         MVC   MODNME(8),MODNMEX
         LH    R11,MODCNT
         LA    R11,1(,R11)
         CH    R11,MODCNTMX
         BH    MAPERR1
         STH   R11,MODCNT
         L     R11,8(R8,R6)        ADDRESS OF MODULE
         ST    R11,MODADR
         L     R11,8(R4,R6)
         LA    R11,0(R11)          SIZE OF MODULE
         ST    R11,MODSIZE
         BCTR  R3,R0
         LA    R15,16(R15)             BUMP MODULE DIRECTORY PTR
         LA    R4,4(R4)
         LA    R8,4(R8)
         B     TCBX6
TCBX7    L     R7,0(,R5)
         LA    R7,0(R7)
         LTR   R7,R7
         BZ    TCBXG
TCBX8    TM    10(R7),X'C0'
         BZ    TCBX9
TCBX81   L     R7,28(,R7)
         LA    R7,0(R7)
         CR    R7,R5
         BE    TCBXG
         B     TCBX8
TCBX9    L     R8,12(,R7)
         LA    R8,0(R8)
         LTR   R8,R8
         BZ    TCBX81
         B     TCBX41
TCBXA    L     R7,0(,R7)
         TM    MAPFLAG,X'04'
         BO    TCBXG
         B     TCBX21
TCBXG    XR    R6,R6
         L     R4,24(,R5)
         LA    R4,0(R4)
         LTR   R4,R4
         BZ    TCBXI
TCBXGA   TM    8(R4),X'80'
         BO    TCBXH
         L     R8,4(,R4)
TCBXGB   LA    R8,0(R8)
         LTR   R8,R8
         BZ    TCBXG1
         TM    10(R4),X'80'
         BO    TCBXG1
         L     R8,4(,R8)
         B     TCBXGB
TCBXG1   LTR   R6,R6
         BZ    TCBXG2
         LR    R4,R6
         TM    8(R4),X'40'
         BO    TCBXI
         L     R4,0(R4)
         XR    R6,R6
         B     TCBXGA
TCBXG2   TM    8(R4),X'40'
         BO    TCBXI
         L     R4,0(,R4)
         B     TCBXGA
TCBXH    LR    R6,R4
         L     R4,4(,R4)
         L     R8,4(,R4)
         B     TCBXGB
TCBXI    B     MAPDONE
TCBXII   LR    R6,R5
         B     TCBREP
MAPERR1  LA    R3,ERROR1
         LA    R1,PLINE
         LH    R2,0(R3)
         BCTR  R2,R0
         EX    R2,MVCEXT
         STM   R0,R15,SAVEREGS
         LM    R0,R15,SAVEMAPR
         PUT   DCB,PLINE
         LM    R0,R15,SAVEREGS
MAPCLR   EQU   *
         LA    R1,PLINE
         MVI   9(R1),C' '
         MVC   10(80,R1),9(R1)
         B     MAPDONE
MAPOFF   EQU   *
         B     MAPDONE
MVCEXT   MVC   8(1,R1),4(R3)
         DS    0F
SAVER15  DC    F'0'
SAVEMAPR DC    18F'0'
WORKAREA DC    18F'0'
SAVEREGS DC    18F'0'
MARK09   DC    F'00009'
TCBADR   DC    F'0'
TCBCUR   DC    F'0'
MAPDIRA  DC    A(MAPDIR)
MAPDIRE  DC    X'80',AL3(MAPDIR)
MAPDIRN  DC    A(MAPDIR)
INSTONE  DC    F'1'
INSTFOUR DC    F'4'
MODCNT   DC    H'0'
MODCNTMX DC    H'100'   INCREASE THE NUMBER WHEN YOU INCREASE MAPDIR.
MPRTCNT  DC    H'0'
MPRTCNTP DC    H'32000'   UP TO 32000 LINES
MAPSWT   DC    X'00'
NEWCSECT DC    X'47F0F0' IBM STANDARD LINKAGE INSTRUCTION
MODNMEX  DC    CL8' '
MCNT100T DC    CL14'MOD CNT GT 100'
NOMOD    DC    CL5'?????' SOME MODULE DO NOT HAVE IBM STANDARD LINKAGE
         DS    0H
MAPDONE  EQU   *
         L     R15,SAVER15
         LM    0,15,SAVEMAPR
         EJECT
***********************************************************************
*                                                                     *
*  MAINLOOP    THE MAJOR CYCLE OF THE TRACE ROUTINE                   *
*                                                                     *
***********************************************************************
         SPACE 1
MAINLOOP DS    0H
         MVC   OLDREG(4*16),REGTBL     SAVE OLD REGISTERS FOR EVALXBD
         C     ILCR,AENTRY             REACHED ENTRY OF TRACE ?
         BE    ENDTRACE                YES, GO END TRACE
         CLI   PRINTING,X'99'          IS END TRACE REQUIRED?
         BE    ENDTRACE                YES, FINISH TRACE PHASE
*        CLI   XTRACE,X'FF'
*        BE    MAINPASS
*        CALL  TRACEX
*        MVI   XTRACE,X'FF'
MAINPASS EQU   *
         MVC   XCELL(6),0(ILCR)        FETCH THE NEXT 6 BYTES OF
*                                      THE INSTRUCTION IMAGE
         SR    SCR1,SCR1               CLEAR SCR1
         IC    SCR1,XCELL              THE INSTRUCTION CODE
         IC    SCR1,OPINDEX(SCR1)      THE INSTRUCTION INDEX
         LH    SCR1,OPFLAGS(SCR1)      THE INSTRUCTION ATTRIBUTE FLAGS
         STH   SCR1,FLAGS              SAVE THE FLAGS
         TM    FLAGS,ILGLBIT           IS THE INSTRUCTION ILLEGAL ?
         BO    ILGLOP                  YES, GO PRINT MESSAGE AND QUIT
         TM    FLAGS,BRBIT             IS THE INSTRUCTION
*                                      A BRANCH OR EXECUTE ?
         BO    BROP                    YES, GO TO THE BRANCH PROCESSOR
MAINSPEC STM   0,15,SAVREG             SAVE THE TRACE ROUTINE'S
*                                      REGISTERS
         LM    0,2,XCELL               PARAMETERS FOR EXECUTE ROUTINE
         LA    8,FLAGS                 LOAD ADDRESS OF FLAGS
         DROP  DATA,HEX2EBC,OSAVE,HEX2EBC2
         BALR  3,4                     CALL THE EXECUTE ROUTIN I
         USING *,3
         TM    FLAGS,CCBIT             COULD THE INSTRUCTION HAVE
*                                      CHANGED THE CONDITION CODE ?
         BZ    NOCC                    NO, NOT A POSSIBILITY
         SR    SCR0,SCR0               CLEAR SCR0
         SLL   SCR1,2                  SHIFT OFF LENGTH CODE
         SLDL  SCR0,2                  CONDITION CODE IN SCR0
         STC   SCR0,REALCC             SAVE CONDITION CODE IN REALCC
NOCC     DS    0H
         LM    0,15,SAVREG             RESTORE TRACE ROUTINE'S
*                                      REGISTERS
         USING DATAREA,DATA
         USING HEXTOEBC,HEX2EBC
         USING HEXTOEBC+4096,HEX2EBC2
         USING SAVE,OSAVE
         DROP  3
         TM    FLAGS,FLOATBIT          FLOATING POINT INSTRUCTION ?
         BZ    BRETN                   NO, FLOATING REGISTERS
*                                      ARE UNCHANGED
         STD   0,F0                    SAVE THE POSSIBLY MODIFIED
         STD   2,F2                    FLOATING POINT REGISTERS
         STD   4,F4                    FOR THE PRINT ROUTINES
         STD   6,F6
         EJECT
***********************************************************************
*                                                                     *
*  BRETN       THE BRANCH AND EXECUTE INSTRUCTION PROCESSORS          *
*              RETURN TO THE MAIN LOOP HERE                           *
*                                                                     *
***********************************************************************
         SPACE 1
BRETN    DS    0H
         TM    PRINTING,X'FF'          IS PRINTING ENABLED
         BZ    NOPRTS                  NO, SO SKIP PRINT PHASE
         BAL   BRFROM,PRINTSUP         CALL THE PRINT SUPERVISOR
*                                      TO PRINT WHAT HAPPENED
NOPRTS   DS    0H
         TM    NOBUMP,X'FF'            SHOULD THE PSEUDO LOCATION
*                                      COUNTER BE INCREMENTED ?
         BZ    INCR                    YES, GO INCREMENT
         MVI   NOBUMP,X'00'            RESET FLAG
         SPACE 3
***********************************************************************
*                                                                     *
*              FETCH THE NEW VALUE FOR THE PSEUDO LOCATION COUNTER    *
*              THAT WAS PREPARED BY THE BRANCH PROCESSOR              *
*                                                                     *
***********************************************************************
         SPACE 1
         L     ILCR,NEWILC
         B     CTEST                   TO TO END OF MAIN LOOP
INCR     DS    0H                      INCREMENT THE PSEUDO LOCATION
*                                      COUNTER
         LA    ILCR,2(0,ILCR)          PLUS 2 BYTE 0-1
         CLI   XCELL,X'B2'             SPECIAL INSTRUCTION FORMAT
         BE    INCRSPEC
         CLI   XCELL,X'9C'             SPECIAL INSTRUCTION FORMAT
         BE    INCRSPEC
         CLI   XCELL,X'9D'             SPECIAL INSTRUCTION FORMAT
         BE    INCRSPEC
         CLI   XCELL,X'9E'             SPECIAL INSTRUCTION FORMAT
         BE    INCRSPEC
         CLI   XCELL,X'9F'             SPECIAL INSTRUCTION FORMAT
         BE    INCRSPEC
         CLI   XCELL,X'E5'             SPECIAL INSTRUCTION FORMAT
         BE    INCRSPEC
         TM    FLAGS+1,RRBIT           TYPE RR INSTRUCTION ?
         BO    CTEST                   YES, SO DONE INCREMENTING
         LA    ILCR,2(0,ILCR)          PLUS 2 MORE  BYTE 2-3
         TM    FLAGS+1,SSBIT           TYPE SS INSTRUCTION ?
         BZ    CTEST                   NO, SO DONE INCREMENTING
         LA    ILCR,2(0,ILCR)          PLUS 2 MORE BYTE 4-5
CTEST    DS    0H
         B     MAINLOOP                AROUND THE LOOP AGIIN
INCRSPEC EQU   *  SPECIAL INSTRUCTION FORMAT S/RRE/SSE
         LA    ILCR,2(0,ILCR)          PLUS 2 MORE FOR S OR RRE FORMAT
         TM    FLAGS+1,SBIT            TYPE S INSTRUCTION ?
         BO    CTEST                   YES, SO DONE INCREMENTING
         TM    FLAGS+1,SSEBIT          TYPE SSE INSTRUCTION ?
         BZ    CTEST                   NO, SO DONE INCREMENTING
         LA    ILCR,2(0,ILCR)          PLUS 2 MORE FOR TYPE SS
         B     CTEST
         EJECT
***********************************************************************
*                                                                     *
*  ILGLOP      ILLEGAL  INSTRUCTION  HANDLING                         *
*                                                                     *
***********************************************************************
         SPACE 1
ILGLOP   DS    0H
         CLI   XCELL,X'B2'             S OR RRE FORMAT
         BE    SPECFMT
         CLI   XCELL,X'9C'             S FORMAT
         BE    SPECF9C
         CLI   XCELL,X'9D'             S FORMAT
         BE    SPECF9C
         CLI   XCELL,X'9E'             S FORMAT
         BE    SPECF9C
         CLI   XCELL,X'9F'             S FORMAT
         BE    SPECF9C
         CLI   XCELL,X'E5'             SSE FORMAT
         BE    SPECFE5
         MVC   PLINE+4(40),ILGMSG      '****  ILLEGAL INSTRUCTION
         BAL   BRFROM,WRITE            PRINT THE MESSAGE
         BAL   BRFROM,PRINTSUP         PRINT THE ILLEGAL INSTRUCTION
         BAL   BRFROM,RDUMP            DUMP THE GENERAL REGISTERS
         BAL   BRFROM,FDUMP            DUMP THE FLOATING GEGISTERS
         AIF   ('&TYPE'EQ'OS').F
         EOJ
         AGO   .G
.F       ANOP
         ABEND 222,DUMP
.G       ANOP
         SPACE 3
***********************************************************************
*                                                                     *
*  SPECFMT     ROUTINE TO DETERMINE B2XX OPER CODES EXECUTION         *
*                                                                     *
***********************************************************************
SPECFMT   EQU  *
         SR    SCR1,SCR1
         IC    SCR1,XCELL+1            THE SECOND BYTE INSTRUCTION CODE
         IC    SCR1,SOPINDEX(SCR1)      THE INSTRUCTION INDEX
*        9CXX 9DXX 9EXX 9FXX AND B2XX (00-06) S FORMAT
SPECFXX  LH    SCR1,OPFLAGS(SCR1)      THE INSTRUCTION ATTRIBUTE FLAGS
         STH   SCR1,FLAGS              SAVE THE FLAGS
         B     MAINSPEC
         SPACE  3
***********************************************************************
*                                                                     *
*  SPECF9C     ROUTINE TO DETERMINE 9CXX OPER CODES EXECUTION         *
*                                                                     *
***********************************************************************
SPECF9C   EQU  *
         LA    SCR1,80                 THE SECOND BYTE INSTRUCTION CODE
         B     SPECFXX
***********************************************************************
*                                                                     *
*  SPECFE5     ROUTINE TO DETERMINE E5XX OPER CODES EXECUTION         *
*                                                                     *
***********************************************************************
SPECFE5   EQU  *
         LA    SCR1,84                 THE SECOND BYTE INSTRUCTION CODE
         CLI   XCELL+1,X'00'
         BNE   SPECFXX
         LA    SCR1,90                 REQUIRED REGISTER DUMP
         B     SPECFXX
***********************************************************************
*                                                                     *
*  ENDTRACE    ROUTINE TO TERMINATE TRACING AND RESUME EXECUTION      *
*                                                                     *
***********************************************************************
ENDTRACE DS    0H
         TM    PRINTING,X'FF'          IS PRINTING ENABLED ?
         BZ    GOEXEC                  NO, SO SKIP PRINTING
         L     SCR0,REGTBL+(4*14)      LOAD RETURN ADDRESS
         BALR  BRFROM,HEX2EBC          CONVERT FOR PRINTING
         STM   SCR0,SCR1,ENDADR        PLACE IN MESSAGE
         MVC   ENDADR(2),BLANKS        TRIM TO SIX HEX DIGITS
         BAL   BRFROM,RDUMP            DUMP GENERAL REGISTERS
         BAL   BRFROM,FDUMP            DUMP FLOATING REGISTERS
         BAL   BRFROM,WRITE            PRINT 1 BLANK LINE
         MVC   PLINE+4(48),ENDTM       '  RESUME EXECUTION AT :  HHHHHH
         BAL   BRFROM,WRITE            PRINT THE MESSAGE
         BAL   BRFROM,WRITE            PRINT 1 BLANK LINE
         CLOSE DCB                     CLOSE THE OUTPUT TRACE FILE
GOEXEC   DS    0H
         ESTAE 0                       KILL MY ESTAE EXIT
         LM    0,15,REGTBL             LOAD THE BENERAL REGISTERS
*                                      OF THE TRACED PROGRAM
         SR    15,15               CLEAR RETURN CODE
         BR    14                      RESUME EXECUTION OF THE PROGRAM
         EJECT
***********************************************************************
*                                                                     *
*  BROP        ROUTINE TO HANDLE BRANCH AND EXECUTE INSTRUCTIONS      *
*                                                                     *
***********************************************************************
         SPACE 1
BROP     DS    0H
         TM    FLAGS+1,EXBIT           EXECUTE INSTRUCTION ?
         BO    EXOP                    YES, GO TO EXECUTE PROCESSOR
         BAL   BRFROM,BRPROC           CALL THE BRANCH PROCESSOR
         B     BRETN                   RETURN TO THE MAIN LOOP
         SPACE 3
***********************************************************************
*                                                                     *
*  BRPROC      BRANCH INSTRUCTION PROCESSOR                           *
*                                                                     *
***********************************************************************
         SPACE 1
BRPROC   DS    0H
         ST    BRFROM,BRSV             SAVE RETURN ADDRESS
         TM    FLAGS+1,RSBIT           BXH OR BXLE ?
         BO    BXHBXLE                 YES, GO PROCESS
         TM    XCELL,X'07'             BC ("47") OR BCR ("07") ?
         BO    BCBCR                   YES, GO PROCESS
         TM    XCELL,X'02'             BCT ("46") OR BCTR ("06") ?
         BO    BCTBCTR                 YES, GO PROCESS
*                                      BY DEFAULT THE INSTRUCTION IS
*                                      BAL ("45") OR BALR ("05")
         SPACE 3
***********************************************************************
*                                                                     *
*              BAL AND BALR                                           *
*                                                                     *
***********************************************************************
         SPACE 1
         LA    SCR1,2                  COMPUTE INCREMENT TO ILCR
         TM    FLAGS+1,RRBIT           BALR ?
         BO    BAL1                    YES, SO INCREMENT IS 2
         AR    SCR1,SCR1               BAL, SO INCREMENT IS 4
BAL1     AR    SCR1,ILCR               RETURN ADDRESS FOR BRANCH
         SPACE 3
***********************************************************************
*                                                                     *
*              BUILD UP COMPLETE RETURN REGISTER IN SCR1              *
*                                                                     *
***********************************************************************
         SPACE 1
         BALR  SCR0,SCR0               GET PROGRAM MASK BITS
         N     SCR0,OFOOOOOO           PROGRAM MASK BITS ONLY
         OR    SCR1,SCR0               INSERT IN THE RETURN
         L     SCR0,ILC1               GET INSTRUCTION LINGTH BITS
         TM    FLAGS+1,RXBIT+EXBIT     BAL OR EXECUTE OR A BRANCH ?
         BZ    BAL2                    NO, BALR SO LENGTH IS 2
         SLL   SCR0,1                  BAL OR EXECUTED BRANCH
*                                      LENGTH IS 4
BAL2     OR    SCR1,SCR0               OR IN INSTRUCTION LINGTH CODE
         SR    SCR0,SCR0               CLEAR SCR0
         IC    SCR0,REALCC             GET THE CORRCCT CONDITION CODE
         SLL   SCR0,28                 POSITION IT PROPERLY
         OR    SCR1,SCR0               OR IN CONDITION CODE BITS
         SPACE 3
***********************************************************************
*                                                                     *
*              SCR1 NOW CONTAINS THE RETURN REGISTER THAT WOULD HAVE  *
*              RESULTED IN ACTUAL EXECUTION FROM STORING THE RIGHT    *
*              HALF OF THE PSW                                        *
*                                                                     *
***********************************************************************
         SPACE 1
         SR    SCR2,SCR2
         IC    SCR2,XCELL+1            RR
         N     SCR2,OOOOOOFO           R0
         SRL   SCR2,2                  R*4
         ST    SCR1,REGTBL(SCR2)       STORE RETURN IN PSEUDO REGISTER
         TM    FLAGS+1,RXBIT           BAL ?
         BO    BRXGO                   BAL ALWAYS TRANSFERS
*                                      GO CALCULATE ADDRESS
         SPACE 3
***********************************************************************
*                                                                     *
*  BRRGO       COMPUTATION OF THE BRANCH ADDRESS                      *
*  BRXGO                                                              *
*                                                                     *
***********************************************************************
         SPACE 1
BRRGO    DS    0H                      TYPE RR,  BRANCH IS TAKEN
*                                      COMPUTE EFFECTIVE ADDRESS
         SR    SCR1,SCR1
         IC    SCR1,XCELL+1            RR
         N     SCR1,OOOOOOOF           0R
         BZ    BRTN1                   NO BRANCH IF REGISTER ZERO
*                                      IS SPECIFIED
         SLL   SCR1,2                  R*4
         L     SCR0,OLDREG(SCR1)       GET ADDRESS FROM REGISTER
BRTN     DS    0H                      SUCCESSFUL BRANCH EXIT
         ST    SCR0,NEWILC             SAVE BRANCH ADDRESS
*                                      FOR LOADING AT END OF MAIN LOOP
         MVI   NOBUMP,X'FF'            SET BRANCH FLAG
BRTN1    DS    0H                      UNSUCCESFUL BRANCH EXIT
         L     BRFROM,BRSV             RESTORE RETURN ADDRESS
         BR    BRFROM                  RETURN
BRXGO    DS    0H                      TYPE RX,  BRANCH TAKEN
         LA    SCR2,XCELL+2            POINT AT BASE,DISPLACEMENT FIELD
         BAL   BRFROM,EVALXBD          GO EVALUATE EFFECTIVE ADDRESS
         B     BRTN
         SPACE 3
***********************************************************************
*                                                                     *
*  BCBCR       BC AND BCR                                             *
*                                                                     *
***********************************************************************
         SPACE 1
BCBCR    DS    0H                      CONDITIONAL BRANCH PROCESSOR
         SR    SCR1,SCR1
         IC    SCR1,XCELL+1            RR
         N     SCR1,OOOOOOFO           R0
         SR    SCR2,SCR2               CLEAR SCR2
         IC    SCR2,REALCC             ACTUAL CONDITION CODE
         SLL   SCR2,2                  (CONDITION CODE)*4
         N     SCR1,CCBITS(SCR2)       MASK BITS CORRESPONDING TO
*                                      THE CONDITION CODE
         BZ    BRTN1                   BRANCH IS NOT TAKEN
         TM    FLAGS+1,RXBIT           BC INSTRUCTION ?
         BO    BRXGO                   YES, GO EVALUATE ADDRESS
         B     BRRGO                   BCR, GO EVALUATE ADDRESS
         SPACE 3
***********************************************************************
*                                                                     *
*  BXHBXLE     BXH AND BXLE                                           *
*                                                                     *
***********************************************************************
         SPACE 1
BXHBXLE  DS    0H                      BXH  BXLE  INSTRUCTION PROCESSOR
         SR    SCR1,SCR1               CLEAR SCR1
         IC    SCR1,XCELL+1            RR
         N     SCR1,OOOOOOOF           0R
         SLL   SCR1,2                  R3*4
         L     SCR0,REGTBL(SCR1)       VALUE OF THE INCREMENT
         SR    SCR2,SCR2               CLEAR SCR2
         IC    SCR2,XCELL+1            RR
         N     SCR2,OOOOOOFO           R0
         SRL   SCR2,2                  R1*4
         A     SCR0,REGTBL(SCR2)       1ST OPERAND + INCREMENT
         ST    SCR0,REGTBL(SCR2)       STORE SUM BACK IN R1
         TM    XCELL+1,X'01'           IS R3 ADD ?
         BO    CR3                     YES, SO IT IS THE COMPARAND
         LA    SCR1,4(SCR1)            (R3+1)*4
         N     SCR1,OOOOOO3C           MODULO 16
CR3      C     SCR0,REGTBL(SCR1)       COMPARE NEW VALUE AND COMPARAND
         BH    BHGO                    NEW VALUE IS GREATER
*                                      NEW VALUE IS LESS THAN OR EQUAL
BLEGO    TM    XCELL,X'01'             IS THE INSTRUCTION BXLE ("87") ?
         BO    BRXGO                   YES, BXLE SO BRANCH IS TAKEN
         B     BRTN1                   NO, BXH SO BRANCH IS NTO TAKEN
BHGO     TM    XCELL,X'01'             IS THE INSTRUCTION BSH ("86") ?
         BZ    BRXGO                   BXH, SO BRANCH IS TAKEN
         B     BRTN1                   BXLE,  BRANCH IS NOT TAKEN
         SPACE 3
***********************************************************************
*                                                                     *
*  BCTBCTR     BCT AND BCTR                                           *
*                                                                     *
***********************************************************************
         SPACE 1
BCTBCTR  DS    0H                      BCT AND BCTR PROCESSOR
         SR    SCR2,SCR2
         IC    SCR2,XCELL+1            RR
         N     SCR2,OOOOOOFO           R0
         SRL   SCR2,2                  R1*4
         L     SCR1,REGTBL(SCR2)       VALUE OF THE INDEX
         S     SCR1,F1                 SUBTRACT ONE
         ST    SCR1,REGTBL(SCR2)       STORE NEW VALUE BACK
         BZ    BRTN1                   5O BRANCH IF NEW VALUE IS ZERO
         TM    FLAGS+1,RXBIT           BCT OR BCRR ?
         BO    BRXGO                   BCT, GO EVALUATE ADDRESS
         B     BRRGO                   BCTR, GO EVALUATE ADDRESS
         EJECT
***********************************************************************
*                                                                     *
*  EXOP        EXECUTE INSTRUCTION PROCESSOR                          *
*                                                                     *
***********************************************************************
         SPACE 1
EXOP     DS    0H
         LA    SCR2,XCELL+2            POINT TO BASE AND DISPLACEMENT
         BAL   BRFROM,EVALXBD          EVALUATE THE EFFECTIVE ADDRESS
*                                      OF THE EXECUTE INSTRUCTION
         LR    SCR1,SCR0               ADDRESS IS IN SCR0, MOVE IT
         MVC   PSXCELL(6),0(SCR1)      FETCH 6 BYTES OF THE SUBJECT
*                                      INSTRUCTION
         SR    SCR1,SCR1
         IC    SCR1,XCELL+1            RR  OF THE EXECUTE INSTRUCTION
         N     SCR1,OOOOOOFO           R0
         SPACE 3
***********************************************************************
*                                                                     *
*              IF THE R1 FIELD OF THE EXECUTE INSTRUCTION IS ZERO     *
*              THEN THE SUBJECT INSTRUCTION IS EXECUTED AS IS.        *
*              OTHERWISE THE RIGHT HAND BYTE OF THE REGISTER          *
*              SPECIFIED BY THE R1 FIELD IS OR'ED INTO THE SECOND     *
*              BYTE OF THE SUBJECT INSTRUCTION                        *
*                                                                     *
***********************************************************************
         SPACE 1
         BZ    NOOR                    NOTHING TO OR IN
         SRL   SCR1,2                  R1*4
         L     SCR2,REGTBL(SCR1)       GET THE BITS TO OR IN
         EX    SCR2,ORI                ORINTO THE SUBJECT INSTRUCTION
NOOR     DS    0H
         SR    SCR1,SCR1               CLEAR SCR1
         IC    SCR1,PSXCELL            INSTRUCTION CODE OF THE SUBJECT
*                                      INSTRUCTION
         IC    SCR1,OPINDEX(SCR1)      INSTRUCTION CODE INDEX
         LH    SCR1,OPFLAGS(SCR1)      INSTRUCTION CODE ATTRIBUTE FLAGS
         STH   SCR1,PSFLAGS            SAVE THE FLAGS
         TM    PSFLAGS,ILGLBIT         IS THE SUBJECT INSTRUCTION
*                                      ILLEGAL ?
         BO    ILGLOP                  YES, PRINT MESSAGE AND TERMINATE
         TM    PSFLAGS,BRBIT           IS THE SUBJECT INSTRUCTION
*                                      A BRANCH ?
         BO    EXBR                    YES, GO SIMULATE AN EXECUTED
*                                      BRANCH INSTRUCTION
         STM   0,15,SAVREG             SAVE TRACE ROUTINE REGISTERS
         LM    0,2,PSXCELL             PARAMETERS FOR EXECUTE ROUTINE
         LA    8,PSFLAGS               LOAD ADDRESS OF PSFLAGS
         DROP  DATA,HEX2EBC,OSAVE,HEX2EBC2
         BALR  3,4                     CALL THE EXECUTE ROUTINE
         EJECT
***********************************************************************
*                                                                     *
*              EXEC ROUTINE RETURNS HERE VIA A BALR 1,3 THUS          *
*              LEAVING THE POSSIBLY MODIFIED CONDITION CODE IN        *
*              REGISTER 1                                             *
*                                                                     *
***********************************************************************
         SPACE 1
         USING *,3
         TM    PSFLAGS,CCBIT           WAS THE CONDITION CODE POSSIBLY
*                                      CHANGED ?
         BZ    NXCC                    NO,NOT A POSSIBILITY
         SR    SCR0,SCR0               CLEAR SCR0
         SLL   SCR1,2                  DELETE INSTRUCTION LENGTH CODE
         SLDL  SCR0,2                  CONDITION CODE TO SCR0
         STC   SCR0,REALCC             SAVE CONDITION CODE IN REALCC
NXCC     DS    0H
         LM    0,15,SAVREG             RESTORE TRACE ROUTINE REGISTERS
         USING DATAREA,DATA
         USING HEXTOEBC,HEX2EBC
         USING HEXTOEBC+4096,HEX2EBC2
         USING SAVE,OSAVE
         DROP  3
         B     BRETN                   RETURN TO THE MAIN LOOP
         SPACE 3
***********************************************************************
*                                                                     *
*  EXBR        ROUTINE TO HANDLE EXECUTED BRANCHES                    *
*                                                                     *
***********************************************************************
         SPACE 1
EXBR     DS    0H
         TM    PSFLAGS+1,EXBIT         IS THE SUBJECT INSTRUCTION
*                                      REALLY AN EXECUTE INSTRUCTION ?
         BO    ILGLOP                  EXECUTED EXECUTES ARE ILLEGAL
***********************************************************************
*                                                                     *
*              MOVE THINGS AROUND TO FOOL THE BRANCH PROCESSOR        *
*                                                                     *
***********************************************************************
         LH    SCR1,FLAGS              SWAP FLAGS AND PSFLAGS
         LH    SCR2,PSFLAGS
         STH   SCR1,PSFLAGS
         STH   SCR2,FLAGS
         LM    SCR0,SCR1,XCELL         SWAP XCELL AND PSXCELL
         LM    SCR2,SCR3,PSXCELL
         STM   SCR0,SCR1,PSXCELL
         STM   SCR2,SCR3,XCELL
***********************************************************************
*                                                                     *
*              SIGNAL AN EXECUTED BRANCH SO THAT THE INSTRUCTION      *
*              LENGTH CODE COMES OUT RIGHT FOR BAL AND BALR           *
*                                                                     *
***********************************************************************
         OI    FLAGS+1,EXBIT           SET EXECUTED BRANCH FLAG
         BAL   BRFROM,BRPROC           CALL THE BRANCH PROCESSOR
***********************************************************************
*                                                                     *
*              PUT THINGS BACK THE WAY THEY WERE SO THAT THE EXECUTE  *
*              INSTRUCTION GETS PRINTED                               *
*                                                                     *
***********************************************************************
         LH    SCR1,FLAGS              SWAP FLAGS AND PSFLAGS
         LH    SCR2,PSFLAGS
         STH   SCR1,PSFLAGS
         STH   SCR2,FLAGS
         LM    SCR0,SCR1,XCELL         SWAP XCELL AND PSXCELL
         LM    SCR2,SCR3,PSXCELL
         STM   SCR0,SCR1,PSXCELL
         STM   SCR2,SCR3,XCELL
         B     BRETN                   RETURN TO THE MAIN LOOP
         EJECT
***********************************************************************
*                                                                     *
*  PRINTSUP    PRINT SUPERVISOR        *                              *
*                                                                     *
***********************************************************************
         SPACE 1
PRINTSUP DS    0H
         ST    BRFROM,PRTS             SAVE RETURN
         BAL   BRFROM,PLIMOD           CALL PLIMOD
         BAL   BRFROM,PLINE1           CALL PLINE1
         BAL   BRFROM,PLINOP           CALL PLINOP
         BAL   BRFROM,PLINREG          CALL PLINREG
         BAL   BRFROM,PLINEFA          CALL PLINEFA
         BAL   BRFROM,WRITE            PRINT THE LINE
         TM    FLAGS+1,LMSTMBIT        LM OR STM INSTRUCTION ?
         BZ    NORDMP                  NO
         BAL   BRFROM,RDUMP            YES, SO DUMP GENERAL REGISTERS
         BAL   BRFROM,WRITE            PRINT 1 BLANK LINE
NORDMP   DS    0H
         L     BRFROM,PRTS             LOAD RETURN ADDRESS
         BR    BRFROM                  RETURN
         SPACE 3
***********************************************************************
*                                                                     *
*  PLIMOD      ROUTINE TO PLACE THE NAME OF MODULE AND DISPLACEMENT   *
*              IN THE PRINT LINE                                      *
*                                                                     *
***********************************************************************
         SPACE 1
PLIMOD   DS    0H
         ST    BRFROM,PMS              SAVE RETURN ADDRESS
         STM   0,15,SAVEREGS
         L     R15,MAPDIRA
         USING MODDIRD,R15
         SR    R8,R8
         LH    R8,MPRTCNT
         LA    R8,1(R8)
         STH   R8,MPRTCNT
         CH    R8,MPRTCNTP
         BL    PLIMODC
NOPRTCN  MVI   PRINTING,X'00'       DISABLE TRACE PRINTING
PLIMODC  SR    R8,R8
         LH    R8,MODCNT
         LR    SCR1,ILCR               COPY THE PSEUDO LOCATION COUNTER
         LA    SCR1,0(SCR1)        DROP HIGH ORDER BITS
PLIMODL  C     SCR1,MODADR
         BL    PLILOW
         L     SCR0,MODSIZE
         A     SCR0,MODADR
         CR    SCR1,SCR0
         BH    PLIHIGH
         S     SCR1,MODADR         FIND DISPLACEMENT FROM MODULE+0
         LR    SCR0,SCR1
         LTR   SCR1,SCR1
         BZ    PLIMODH             DO NOT REDUCE AT MODULE+0
         CLC   XCELL(2),NEWCSECT    SEE IF IT IS A NEW CSECT
         BNE   PLIMODH
         CLC   XCELL+2(1),NEWCSECT+2 SEE IF IT IS A NEW CSECT
         BNE   PLIMODH
         L     SCR0,MODSIZE
         S     SCR1,INSTONE        LESS END OF THIS INSTRUCTION
         S     SCR0,INSTFOUR       LESS THIS INSTRUCTION SIZE
         ST    SCR1,MODSIZE        REDUCED MODULE SIZE AFTER DEFAULT
         SR    SCR0,SCR1           REMAINDER SIZE FOR THIS CSECT
PLIMDRA  LA    R15,16(R15)         FIND NEXT TABLE ENTRY
         BCT   R8,PLIMDRA          DRAIN THE TABLE FOR END OF TABLE PTR
         LR    SCR1,ILCR               COPY THE PSEUDO LOCATION COUNTER
         LA    SCR1,0(SCR1)        DROP HIGH ORDER BYTE
PLIMODCS ST    SCR1,MODADR
         MVC   MODNME(8),5(SCR1)
         ST    SCR0,MODSIZE
         SR    SCR0,SCR0
         LH    R11,MODCNT
         LA    R11,1(R11)
         CH    R11,MODCNTMX
         BL    PLIMODH1
MCNT100  MVC   ILCMOD(14),MCNT100T     MAXIMUM NO OF CSECTS IN A TABLES
         B     PLIMODX
PLIMODH1 STH   R11,MODCNT
PLIMODH  BALR  BRFROM,HEX2EBC          CONVERT IT FOR PRINTING
         STM   SCR0,SCR1,ILCDISP       PLACE IT IN THE PRINT LINE
         MVC   ILCDISP(2),BLANKS       DELETE LEADING ZEROS
         MVC   ILCMOD(8),MODNME
         MVI   ILCMOD+8,C'+'
PLIMODX  LM    0,15,SAVEREGS
         L     BRFROM,PMS
         BR    BRFROM                  RETURN
PLILOW   EQU   *
PLIHIGH  EQU   *
         LA    R15,16(R15)         BUMP NEXT MODULE ADDRESS TABLE
         BCT   R8,PLIMODL
         ST    R15,MAPDIRE
         MVI   MAPDIRE,X'80'
         STM   R0,15,WORKAREA
         LM    R0,15,WORKAREA
         LA    SCR1,0(SCR1)        DROP HIGH ORDER BYTE
         CLC   XCELL(2),NEWCSECT    SEE IF IT IS A NEW CSECT
         BNE   PLIDONE
         L     SCR0,CSECTMAX       DEFAULT 4096 BYTES LENGTH
         CLC   XCELL+2(1),NEWCSECT+2 SEE IF IT IS A NEW CSECT
         BE    PLIMODCS
PLIDONE  SR    R11,R11
         LH    R11,MODCNT
         LA    R11,1(R11)
         STH   R11,MODCNT
         ST    SCR1,MODADR
         L     SCR1,CSECTMAX       DEFAULT 4096 BYTES LENGTH
         ST    SCR1,MODSIZE
         LR    SCR0,R11
         BALR  BRFROM,HEX2EBC          CONVERT IT FOR PRINTING
         STM   SCR0,SCR1,MODNME        PLACE IT IN THE PRINT LINE
         MVC   MODNME(4),NOMOD
         SR    SCR0,SCR0
         B     PLIMODH
         SPACE 3
***********************************************************************
*                                                                     *
*  PLINE1      ROUTINE TO PLACE THE PSEUDO LOCATION COUNTER, THE      *
*              HEXADECIMAL INSTRUCTION IMAGE, AND TEE CONDITION CODE  *
*              IN THE PRINT LINE                                      *
*                                                                     *
***********************************************************************
         SPACE 1
PLINE1   DS    0H
         ST    BRFROM,P1S              SAVE RETURN ADDRESS
         LR    SCR0,ILCR               COPY THE PSEUDO LOCATION COUNTER
         SLA   SCR0,4                  MOVE 4 BITS LEFT
         BALR  BRFROM,HEX2EBC          CONVERT IT FOR PRINTING
         STM   SCR0,SCR1,ILC           PLACE IT IN THE PRINT LINE
         MVC   ILC(1),BLANKS           DELETE LEADING ZEROS
         MVC   ILC+7(1),BLANKS         DELETE SHIFTED ZEROS
         L     SCR0,XCELL              GET THE INSTRUCTION IMAGEJ
         BALR  BRFROM,HEX2EBC          CONVERT 1ST FOUR BYTES
         ST    SCR0,INSTR              PLACE 1ST 2 BYTES IN PRINT LINE
         CLI   XCELL,X'B2'             SPECIAL INSTRUCTION FORMAT
         BE    P1CCSPEC
         CLI   XCELL,X'9C'             SPECIAL INSTRUCTION FORMAT
         BE    P1CCSPEC
         CLI   XCELL,X'9D'             SPECIAL INSTRUCTION FORMAT
         BE    P1CCSPEC
         CLI   XCELL,X'9E'             SPECIAL INSTRUCTION FORMAT
         BE    P1CCSPEC
         CLI   XCELL,X'9F'             SPECIAL INSTRUCTION FORMAT
         BE    P1CCSPEC
         CLI   XCELL,X'E5'             SPECIAL INSTRUCTION FORMAT
         BE    P1CCSPEC
         TM    FLAGS+1,RRBIT           TYPE RR INSTRUCTION ?
         BO    P1CC                    YES, ONLY PRINT TWO BYTES
         ST    SCR1,INSTR+4            PLACE 2ND 2 BYTES OF THE
*                                      INSTRUCTION IN THE PRINT LINE
         TM    FLAGS+1,SSBIT           TYPE SS INSTRUCTION ?
         BZ    P1CC                    NO, ONLY PRINT 4 BYTES
P1CC6    L     SCR0,XCELL+4            GET LAST 2 BYTES OF INSTRUCTION
         BALR  BRFROM,HEX2EBC          CONVERT FOR PRINTING
         ST    SCR0,INSTR+8            PLACE LAST 2 BYTES IN PRINT LINE
P1CC     DS    0H                      PLACE THE CONDITION CODE IN THE
*                                      PRINT LINE
         SR    SCR1,SCR1               CLEAR SCR1
         IC    SCR1,REALCC             ACTUAL CONDITION CODE
         IC    SCR0,EBDCC(SCR1)        GET CORRESPONDING CHARACTER
         STC   SCR0,CC                 PLACE CHARACTER INPRINT LINE
         L     BRFROM,P1S
         BR    BRFROM                  RETURN
         SPACE 1
P1CCSPEC EQU   *  SPECIAL INSTRUCTION FORMAT S/RRE/SSE
         ST    SCR1,INSTR+4            PLACE 2ND 2 BYTES OF THE
*                                      INSTRUCTION IN THE PRINT LINE
         TM    FLAGS+1,SSEBIT          TYPE SSE INSTRUCTION ?
         BZ    P1CC                    NO, ONLY PRINT 4 BYTES
         B     P1CC6                   PRINT 6 BYTES
         SPACE 3
***********************************************************************
*                                                                     *
*  PLINOP      ROUTINE TO PLACE THE SYMBOLIC INSTRUCTION CODE AND THE *
*              INSTRUCTION FIELDS IN ASSEMBLY FORMAT INTO THE         *
*              PRINT LINE.                                            *
*                                                                     *
***********************************************************************
         SPACE 1
PLINOP   DS    0H
         ST    BRFROM,P2S              SAVE RETURN ADDRESS
         SR    SCR1,SCR1               CLEAR SCR1
         CLI   XCELL,X'B2'             S OR RRE FORMAT
         BE    SPECFMTX
         CLI   XCELL,X'9C'             S FORMAT
         BE    SPECF9CX
         CLI   XCELL,X'9D'             S FORMAT
         BE    SPECF9DX
         CLI   XCELL,X'9E'             S FORMAT
         BE    SPECF9EX
         CLI   XCELL,X'9F'             S FORMAT
         BE    SPECF9FX
         CLI   XCELL,X'E5'             SSE FORMAT
         BE    SPECFE5X
         SR    SCR1,SCR1
         IC    SCR1,XCELL              INSTRUCTION CODE
         SLL   SCR1,2                  (INSTRUCTION CODE)*4
         L     SCR0,BCDOP(SCR1)        SYMBOLIC INSTRUCTION CODE
PLINOP2  ST    SCR0,OP                 PLACE IN PRINT LINE
***********************************************************************
*                                                                     *
*              PREPARE THE INSTRUCTION FIELDS IN ASSEMBLY FORMAT      *
*                                                                     *
***********************************************************************
         LA    FLDPT,FIELDS            POINTER RO THE INSTRUCTION
         CLI   XCELL,X'D9'             SS FORMAT THIRD REGISTER
         BE    SPECFSS3
         CLI   XCELL,X'DA'             SS FORMAT THIRD REGISTER
         BE    SPECFSS3
         CLI   XCELL,X'DB'             SS FORMAT THIRD REGISTER
         BE    SPECFSS3
         CLI   XCELL,X'EF'             SS FORMAT THIRD REGISTER
         BH    SPECFSS3                YES,F0 THRU FF
*                                      FIELDS IN THE PRINT LINE
         TM    FLAGS,SPECBIT           SPECIAL INSTRUCTION ?
         BO    SPEC1                   YES,
         TM    FLAGS+1,IMDFBIT         DOES THE INSTRUCTION CONTAIN
*                                      AN IMMEDIATE FIELD ?
         BZ    SPLT                  YES, SO SPLIT THE FIELD INTO R,X
         SR    SCR1,SCR1               SIGNAL NO INDEX
         LH    SCR0,XCELL+2            BDDD
         BAL   BRFROM,BDPROC           'DDD(B)'
         TM    FLAGS+1,SSBIT           TYPE SS INSTRUCTION ?
         BZ    FSI                     NO, MUST BE TYPE SI INSTRUCTION
         S     FLDPT,F3                BACK UP THE FIELD POINTER
         MVC   4(2,FLDPT),1(FLDPT)     'DDD(   B)'
         SR    SCR1,SCR1               CLEAR SCR1
         IC    SCR1,XCELL+1            LL        LENGTH FIELD
         SRL   SCR1,4                  L
         IC    SCR1,HEXCHAR(SCR1)      'L'
         STC   SCR1,1(FLDPT)           'DDD(L  B)'
         SR    SCR1,SCR1
         IC    SCR1,XCELL+1            LL
         N     SCR1,OOOOOOOF           L
         IC    SCR1,HEXCHAR(SCR1)      'L'
         STC   SCR1,2(FLDPT)           'DDD(LL B)'
         MVI   3(FLDPT),C','           'DDD(LL,B)'
         LA    FLDPT,6(FLDPT)          ADJUST THE FIELD POINTER
         B     FSS                     GO FINISH TYPE SS INSTRUCTION
FSI      MVI   0(FLDPT),C','           'DDD(B),'
         SR    SCR1,SCR1               CLEAR SCR1
         IC    SCR1,XCELL+1            II        IMMEDIATE FIELD
         SRL   SCR1,4                  I
         IC    SCR1,HEXCHAR(SCR1)      'I'
         STC   SCR1,1(FLDPT)           'DDD(B),I'
         SR    SCR1,SCR1               CLEAR SCR1
         IC    SCR1,XCELL+1            II
         N     SCR1,OOOOOOOF            I
         IC    SCR1,HEXCHAR(SCR1)      'I'
         STC   SCR1,2(FLDPT)           'DDD(B),II'
         B     POPDONE                 FINISHED, SO RETURN
SPECFSS3 EQU   *
         SR    SCR1,SCR1               SIGNAL NO INDEX
         LH    SCR0,XCELL+2            BDDD
         BAL   BRFROM,BDPROC           'DDD(B)'
         S     FLDPT,F3                BACK UP THE FIELD POINTER
         MVC   3(2,FLDPT),1(FLDPT)     'DDD(  B)'
         SR    SCR1,SCR1               CLEAR SCR1
         IC    SCR1,XCELL+1            RR        LENGTH FIELD
         SRL   SCR1,4                  R1
         IC    SCR1,HEXCHAR(SCR1)      'R'
         STC   SCR1,1(FLDPT)           'DDD(R B)'
         MVI   2(FLDPT),C','           'DDD(R,B)'
         LA    FLDPT,5(FLDPT)          ADJUST THE FIELD POINTER
         MVI   0(FLDPT),C','           'DDD(R,B),'
         LA    FLDPT,1(FLDPT)          ADJUST FIELD POINTER
         LH    SCR0,XCELL+4            BDDD      2ND BASE,DISPLACEMENT
         SR    SCR1,SCR1               INDICATE NO INDEX
         BAL   BRFROM,BDPROC           'DDD(R,B),DDD(B)'
         SR    SCR1,SCR1
         IC    SCR1,XCELL+1            RR
         N     SCR1,OOOOOOOF           R3
         IC    SCR1,HEXCHAR(SCR1)      'R'
         CLI   XCELL,X'F0'
         BNE   SPECFDEC                DECIMAL INSTRUCTIONS
         STC   SCR1,1(FLDPT)           'DDD(R,B),DDD(B) R'
         MVI   0(FLDPT),C','           'DDD(R,B),DDD(B),R'
         B     POPDONE
SPECFDEC EQU   *
         S     FLDPT,F3                BACK BY 3 CHARS
         MVC   3(2,FLDPT),1(FLDPT)     DDD(R,B),DDD(  B)
         STC   SCR1,1(FLDPT)           DDD(R,B),DDD(R B)
         MVI   2(FLDPT),C','           DDD(R,B),DDD(R,B)
         B     POPDONE
SPECFMTX EQU   *
         OI    FLAGS,SPECBIT          TURN ON SPECIAL INSTRUCTION
         SR    SCR1,SCR1
         IC    SCR1,XCELL+1            SECOND BYTE INSTRUCTION CODE
         SLL   SCR1,2                  (INSTRUCTION CODE)*4
         L     SCR0,SBCDOP(SCR1)       SYMBOLIC INSTRUCTION CODE
         B     PLINOP2
SPECF9CX EQU   *
         OI    FLAGS,SPECBIT          TURN ON SPECIAL INSTRUCTION
         SR    SCR1,SCR1
         IC    SCR1,XCELL+1            SECOND BYTE INSTRUCTION CODE
         SLL   SCR1,2                  (INSTRUCTION CODE)*4
         L     SCR0,NBCDOP9C(SCR1)       SYMBOLIC INSTRUCTION CODE
         B     PLINOP2
SPECF9DX EQU   *
         OI    FLAGS,SPECBIT          TURN ON SPECIAL INSTRUCTION
         SR    SCR1,SCR1
         IC    SCR1,XCELL+1            SECOND BYTE INSTRUCTION CODE
         SLL   SCR1,2                  (INSTRUCTION CODE)*4
         L     SCR0,NBCDOP9D(SCR1)       SYMBOLIC INSTRUCTION CODE
         B     PLINOP2
SPECF9EX EQU   *
         OI    FLAGS,SPECBIT          TURN ON SPECIAL INSTRUCTION
         SR    SCR1,SCR1
         IC    SCR1,XCELL+1            SECOND BYTE INSTRUCTION CODE
         SLL   SCR1,2                  (INSTRUCTION CODE)*4
         L     SCR0,NBCDOP9E(SCR1)       SYMBOLIC INSTRUCTION CODE
         B     PLINOP2
SPECF9FX EQU   *
         OI    FLAGS,SPECBIT          TURN ON SPECIAL INSTRUCTION
         SR    SCR1,SCR1
         IC    SCR1,XCELL+1            SECOND BYTE INSTRUCTION CODE
         SLL   SCR1,2                  (INSTRUCTION CODE)*4
         L     SCR0,NBCDOP9F(SCR1)       SYMBOLIC INSTRUCTION CODE
         B     PLINOP2
SPECFE5X EQU   *
         OI    FLAGS,SPECBIT          TURN ON SPECIAL INSTRUCTION
         SR    SCR1,SCR1
         IC    SCR1,XCELL+1            SECOND BYTE INSTRUCTION CODE
         SLL   SCR1,2                  (INSTRUCTION CODE)*4
         L     SCR0,EBCDOP(SCR1)       SYMBOLIC INSTRUCTION CODE
         B     PLINOP2
         SPACE  3
SPEC1    EQU   *
         TM    FLAGS+1,SBIT       4 BYTES
         BZ    SPECSPLT
FSSE     SR    SCR1,SCR1
         LH    SCR0,XCELL+2        BDDD
         BAL   BRFROM,BDPROC       'DDD(B)'
         TM    FLAGS+1,SSEBIT
         BZ    POPDONE
         B     FSS
SPECSPLT TM    FLAGS+1,RREBIT      XXRR
         BZ    FSSE                MUST BE SSE FORMAT
         SR    SCR1,SCR1
         IC    SCR1,XCELL+3        XXRR
         N     SCR1,OOOOOOFO       XXRX
         SRL   SCR1,4              XXXR
         IC    SCR0,HEXCHAR(SCR1) 'R'
         STC   SCR0,0(0,FLDPT)    'R'
         MVI   1(FLDPT),C','      'R,'
         LA    FLDPT,2(FLDPT)
         SR    SCR1,SCR1
         IC    SCR1,XCELL+3        XXRR
         N     SCR1,OOOOOOOF       XXXR
         IC    SCR0,HEXCHAR(SCR1)   'R'
         STC   SCR0,0(0,FLDPT)     'R,R'
         B     POPDONE
         SPACE 3
***********************************************************************
*                                                                     *
*              SPLIT THE SECOND BYTE OF THE INSTRUCTION INTO          *
*              R,X OR R,R                                             *
*                                                                     *
***********************************************************************
         SPACE 1
SPLT     SR    SCR1,SCR1
         IC    SCR1,XCELL+1            RX        REGISTER SPECFIERS
         N     SCR1,OOOOOOFO           R0
         SRL   SCR1,4                  R
         IC    SCR0,HEXCHAR(SCR1)      'R'
         STC   SCR0,0(0,FLDPT)         'R'
         MVI   1(FLDPT),C','           'R,'
         LA    FLDPT,2(FLDPT)          ADJUST FIELD POINTER
         TM    FLAGS+1,RRBIT+LMSTMBIT  IS THE INSTRUCTION TYPE RR OR
*                                      LM OR STM ?
         BZ    NOTRR                   NO
         SR    SCR1,SCR1
         IC    SCR1,XCELL+1            RR
         N     SCR1,OOOOOOOF           0R
         IC    SCR0,HEXCHAR(SCR1)      'R'
         STC   SCR0,0(0,FLDPT)         'R,R'
         TM    FLAGS+1,RRBIT           IS THE INSTRUCTION TYPE RR ?
         BO    POPDONE                 YES, SO FINISHED
         SR    SCR1,SCR1               NO INDEX FOR LM OR STM
         MVI   1(FLDPT),C','           'R,R,'
         LA    FLDPT,2(FLDPT)          ADJUST THE FIELD POINTER
         B     NOTRR2                  GO EVALUATE BASE, DISPLACEMENT
NOTRR    SR    SCR1,SCR1
         IC    SCR1,XCELL+1            RX
         N     SCR1,OOOOOOOF           0X
NOTRR2   LH    SCR0,XCELL+2            BDDD      BASE AND DISPLACEMENT
         BAL   BRFROM,BDPROC           'R,DDD(X,B)'  OR    'R,DDD(B)'
         B     POPDONE                 FINISHED SO RETURN
         SPACE 3
***********************************************************************
*                                                                     *
*              FINISH UP TYPE SS INSTRUCTION                          *
*                                                                     *
         SPACE 1
FSS      MVI   0(FLDPT),C','           'DDD(LL,B),'
         LA    FLDPT,1(FLDPT)          ADJUST FIELD POINTER
         LH    SCR0,XCELL+4            BDDD      2ND BASE,DISPLACEMENT
         SR    SCR1,SCR1               INDICATE NO INDEX
         BAL   BRFROM,BDPROC           'DDD(LL,B),DDD(B)'
POPDONE  L     BRFROM,P2S              LOAD RETURN ADDRESS
         BR    BRFROM                  RETURN
         SPACE 3
***********************************************************************
*                                                                     *
*  BDPROC      ROUTINE TO FORMAT THE BASE, DISPLACEMENT, AND INDEX    *
*              FIELDS INTO ASSEMBLY FORMAT FOR PRINTING               *
*              INPUT IS A BASE,DISPLACEMENT HALFWORD IN SCR0 AND THE  *
*              NUMBER OR THE INDEX REGISTER INSSCR1                   *
*              PLACES EITHER  'DDD(B) OR 'DDD(X,B)' INTO THE          *
*              INSTRUCTION IMAGE AT THE POINT SPECIFIED BY FLDPT      *
*                                                                     *
***********************************************************************
         SPACE 1
BDPROC   ST    BRFROM,BDS              SAVE RETURN ADDRESS
         ST    SCR0,BDT                SAVE  BDDD
         ST    SCR1,BDT2               SAVE INDEX SPECIFIER
         N     SCR0,OOOOOFFF           DDD       DISPLACEMENT
         BALR  BRFROM,HEX2EBC          CONVERT FOR PRINTING
         L     SCR0,BDT2               X          INDEX REGISTER
         ST    SCR1,BDT2               '0DDD'
         MVC   0(3,FLDPT),BDT2+1       'DDDD'
         MVI   3(FLDPT),C'('           'DDD('
         LTR   SCR1,SCR0               IS AN INDEX SPECIFIED ?
         BZ    BDPNX                   NO, ZERO SPECIFIES NO INDEX
         IC    SCR1,HEXCHAR(SCR1)      'X'
         STC   SCR1,4(FLDPT)           'DDD(X'
         MVI   5(FLDPT),C','           'DDD(X,'
         LA    FLDPT,2(FLDPT)          ADJUST POINTER FOR THE INDEX
BDPNX    L     SCR1,BDT                BDDD      BASE, DISPLACEMENT
         N     SCR1,OOOOFOOO           B000
         SRL   SCR1,12                 B        BASE REGISTER
         IC    SCR1,HEXCHAR(SCR1)      'B'
         STC   SCR1,4(FLDPT)           'DDD,X,B'     OR   'DDD(B'
         MVI   5(FLDPT),C')'           'DDD(X,B)'   OR   'DDD(B)'
         LA    FLDPT,6(FLDPT)          ADJUST FIELD POINTER
         L     BRFROM,BDS              LOAD RETURN ADDRESS
         BR    BRFROM                  RETURN
         SPACE 3
***********************************************************************
*                                                                     *
*  PLINREG     ROUTINE TO PLACE THE OPERAND REGISTERS REFERENCED      *
*              BY THE INSTRUCTION INTO THE PRINT LINE                 *
*                                                                     *
***********************************************************************
         SPACE 1
PLINREG  DS    0H
         CLI   XCELL,X'B2'
         BE    PREGSPEC
         TM    FLAGS+1,RRBIT+RXBIT+RSBIT
*                                      DOES THE INSTRUCTION REFERENCE
*                                      REGISTERS ?
         BCR   B'1000',BRFROM          NO, SO RETURN
         ST    BRFROM,P3S              SAVE RETURN ADDRESS
         TM    FLAGS,BRBIT             BRANCH INSTRUCTION ?
         BZ    GR1                     NO
***********************************************************************
*                                                                     *
*              INSTRUCTION IS A BRANCH, SO TEST TO SEE IF IT IS       *
*              A BRANCH CONDITION, IN WHICH CASE THE R1 FIELD         *
*              IS USED AS A MASK AGAINST THE CONDITION CODE           *
*                                                                     *
***********************************************************************
         CLI   XCELL,X'47'             IS THE INSTRUCTION BC ?
         BE    R1MASK                  YES
         CLI   XCELL,X'07'             IS THE INSTRUCTION BCR ?
         BNE   GR1                     NO
R1MASK   DS    0H
         SR    SCR0,SCR0
         IC    SCR0,FIELDS             R IN EBCDIC
         STC   SCR0,PR1+7              STORE IN REGISTER FIELD
         LA    SCR2,REGTBL             ADDRESS OF REGISTER TABLE
         B     RGRR                    GO TEST FOR TYPE RR INSTRUCTION
GR1      DS    0H
         SR    SCR1,SCR1
         IC    SCR1,XCELL+1            RR
         CLI   XCELL,X'B2'             RRE REQUIRED
         BNE   GR1X
         IC    SCR1,XCELL+3            RR FROM RRE FORMAT
GR1X     N     SCR1,OOOOOOFO           R0
         SRL   SCR1,2                  R*4
         LA    SCR2,REGTBL             ADDRESS OF REGISTER TABLE
         TM    FLAGS,FLOATBIT          FLOATING POINT INSTRUCTION ?
         BZ    FIXD                    NO, USE GENERAL REGISTERS
         LA    SCR2,F0                 YES, USE FLOATING REGISTERS
FIXD     DS    0H
         L     SCR0,0(SCR1,SCR2)       GET THE VALUE OF THE REGISTER
         ST    SCR1,PRT                SAVE REGISTER NUMBER
         BALR  BRFROM,HEX2EBC          CONVERT VALUE FOR PRINTING
         STM   SCR0,SCR1,PR1           PLACE IN PRINT LINE
         TM    FLAGS,DBLBIT            DOUBLE WORD INSTRUCTION ?
         BZ    RGRR                    NO
         L     SCR1,PRT                R*4  AGAIN
         LA    SCR1,4(0,SCR1)          (R+1)*4   SECOND REGISTER NUMBER
         L     SCR0,0(SCR1,SCR2)       VALUE OF SECOND REGISTER
         BALR  BRFROM,HEX2EBC          CONVERT FOR PRINTING
         STM   SCR0,SCR1,DR1           PLACE IN PRINT LINE
         TM    FLAGS+1,RRBIT           TYPE RR INSTRUCTION ?
         BZ    PRDONE                  NO, SO FINISHED
***********************************************************************
*                                                                     *
*              GET THE VALUE OF THE 2ND DOUBLE WORD REGISTER          *
*                                                                     *
***********************************************************************
         SR    SCR1,SCR1
         IC    SCR1,XCELL+1            RR
         CLI   XCELL,X'B2'             RRE REQUIRED
         BNE   GR2X
         IC    SCR1,XCELL+3            RR FROM RRE FORMAT
GR2X     N     SCR1,OOOOOOOF           0R
         SLL   SCR1,2                  R*4
         L     SCR0,0(SCR1,SCR2)       GET REGISTER VALUE
         ST    SCR1,PRT                SAVE REGISTER NUMBER
         BALR  BRFROM,HEX2EBC          CONVERT FOR PRINTING
         STM   SCR0,SCR1,DR2A          PLACE IN PRINT LINE
         L     SCR1,PRT                R*4  AGAIN
         L     SCR0,4(SCR1,SCR2)       GET 2ND HALF OF VALUE
         BALR  BRFROM,HEX2EBC          CONVERT FOR PRINTING
         STM   SCR0,SCR1,DR2B          PLACE IN PRINT LINE
         B     PRDONE                  FINISHED
RGRR     DS    0H
         TM    FLAGS+1,RRBIT           TYPE RR INSTRUCTION ?
         BZ    PRDONE                  NO, SO DONE
         SR    SCR1,SCR1
         IC    SCR1,XCELL+1            RR
         N     SCR1,OOOOOOOF           0R
         SLL   SCR1,2                  R*4
         L     SCR0,0(SCR1,SCR2)       VALUE OF THE REGISTER
         BALR  BRFROM,HEX2EBC          CONVERT FOR PRINTING
         STM   SCR0,SCR1,PR2            PLACE IN PRINT LINE
PRDONE   DS    0H
         L     BRFROM,P3S              LOAD RETURN ADDRESS
         BR    BRFROM                  RETURN
         SPACE 1
PREGSPEC  EQU   *
         TM    FLAGS+1,RREBIT
         BCR   B'1000',BRFROM          NO, SO RETURN
         B     GR1
         SPACE 3
***********************************************************************
*                                                                     *
*  PLINEFA     ROUTINE TO PLACE THE EFFECTIVE ADDRESS OF THE          *
*              INSTRUCTION AND THE CONTENTS OF THE MEMORY LOCATION    *
*              REFERENCED BY THE INSTRUCTION INTO THE RPINT LINE      *
*                                                                     *
***********************************************************************
         SPACE 1
PLINEFA  DS    0H
         CLI   XCELL,X'B2'             SPECIAL INSTRUCTION FORMAT
         BE    PEFASPEC
         CLI   XCELL,X'9C'             SPECIAL INSTRUCTION FORMAT
         BE    PEFASPEC
         CLI   XCELL,X'9D'             SPECIAL INSTRUCTION FORMAT
         BE    PEFASPEC
         CLI   XCELL,X'9E'             SPECIAL INSTRUCTION FORMAT
         BE    PEFASPEC
         CLI   XCELL,X'9F'             SPECIAL INSTRUCTION FORMAT
         BE    PEFASPEC
         CLI   XCELL,X'E5'             SPECIAL INSTRUCTION FORMAT
         BE    PEFASPEC
         TM    FLAGS+1,RRBIT           TYPE RR INSTRUCTION ?
         BCR   B'0001',BRFROM          YES, SO NO MEMORY REFERENCE
         ST    BRFROM,P4S              SAVE RETURN ADDRESS
         LA    SCR2,XCELL+2            ADDRESS OF BASS, DISPLACEMENT
         TM    FLAGS+1,RXBIT           TYPE RX INSTRUCTION ?
         BZ    NOTRX                   NO
         BAL   BRFROM,EVALXBD          GO EVALUATE ADDRESS WITH INDEX
         B     PEFA                    GO PLACE IN PRINT LINE
PEFASPEC EQU   *
         TM    FLAGS+1,RREBIT
         BCR   B'0001',BRFROM          YES, SO NO MEMORY REFERENCE
         ST    BRFROM,P4S              SAVE RETURN ADDRESS
         LA    SCR2,XCELL+2            ADDRESS OF BASS, DISPLACEMENT
         CLI   XCELL,X'B2'             SPECIAL INSTRUCTION FORMAT
         BNE   NOTRX
         CLI   XCELL+1,X'0B'           B20B IGNORE D2(B2)
         BE    PEFADONE
         CLI   XCELL+1,X'0D'           B20D IGNORE D2(B2)
         BE    PEFADONE
NOTRX    TM    FLAGS,SHIFTBIT           GO EVALUATE ADDRESS, NO INDEX
         BO    PEFADONE                DONT  GET ADDRESS ON SHIFT
         BAL   BRFROM,EVALBD           GO EVALUATE ADDRESS, NO INDEX
PEFA     ST    SCR0,EFAT0              SAVE EFFECTIVE ADDRESS
         BALR  BRFROM,HEX2EBC          CONVERT ADDRESS FOR PRINTING
         STM   SCR0,SCR1,EFA1          PLACE ADDRESS IN PRINT LINE
         MVC   EFA1(2),BLANKS          DELETE LEADING ZEROS
         TM    FLAGS,SHIFTBIT          SHIFTBIT INSTRUCTION ?
         BO    PEFADONE                YES, SO NO MEMORY REFERENCE
         CLI   XCELL,X'41'             LOAD ADDRESS INSTRUCTION ?
         BE    PEFADONE                YES, SO NO MEMEMORY REFERENCE
         L     SCR2,EFAT0              EFFECTIVE ADDRESS AGAIN
         MVC   EFAT0(4),0(SCR2)        CONTENTS OF MEMORY REFERENCED
         L     SCR0,EFAT0              PLACE CONTENTS IN SCR0
         BALR  BRFROM,HEX2EBC          CONVERT FOR PRINTING
         STM   SCR0,SCR1,EFA1+12       PLACE CONTENTS IN PRINT LINE
         TM    FLAGS,HALFBIT           HALF WORD INSTRUCTION ?
         BZ    PEFA1                   NO
         MVC   EFA1+16(4),BLANKS       YES, ONLY PRINT HALF WORD
         B     PEFADONE                FINISHED
PEFA1    DS    0H
         TM    FLAGS+1,SIBIT           TYPE SI INSTRUCTION ?
         BZ    PEFA2                   NO
         MVC   EFA1+14(6),BLANKS       ONLY ONE BYTE
         B     PEFADONE                FINISHED
PEFA2    DS    0H
         TM    FLAGS,DBLBIT            DOUBLE WORD RX INSTRUCTION ?
         BZ    PEFA3                   NO
         MVC   EFAT0(4),4(SCR2)        CONTENTS OF SECOND WORK
         L     SCR0,EFAT0              PLACE IN SCR0
         BALR  BRFROM,HEX2EBC          CONVERT FOR PRINTING
         STM   SCR0,SCR1,EFA1+20       PLACEI N THE PRINT LINE
         B     PEFADONE                FINISHED
PEFA3    DS    0H
         CLI   XCELL,X'E5'             SPECIAL INSTRUCTION FORMAT
         BNE   PEFA3X
         TM    FLAGS+1,SSEBIT
         BZ    PEFADONE
         B     PEFA3Y
PEFA3X   TM    FLAGS+1,SSBIT           TYPE SS INSTRUCTION ?
         BZ    PEFADONE                NO, SO FINISHED
PEFA3Y   LA    SCR2,XCELL+4            ADDRESS OF 2ND BASE,DISPLACEMENT
         BAL   BRFROM,EVALBD           EVALUATE ADDRESS
         ST    SCR0,EFAT0              SAVE EFFECTIVE ADDRESS
         BALR  BRFROM,HEX2EBC          CONVERT FOR PRINTING
         STM   SCR0,SCR1,EFA2          PLACE IN PRINT LINE
         MVC   EFA2(2),BLANKS          DELETE LEADING BLANKS
         L     SCR1,EFAT0              EFFECTIVE ADDRESS AGAIN
         MVC   EFAT0(4),0(SCR1)        GET CONTENTS OF MEMORY
         L     SCR0,EFAT0              LOAD CONTENTS INTO SCR0
         BALR  BRFROM,HEX2EBC          CONVERT FOR PRINTING
         STM   SCR0,SCR1,EFA2+12       PLACE IN PRINT LINE
PEFADONE DS    0H
         L     BRFROM,P4S              LOAD RETURN ADDRESS
         BR    BRFROM                  RETURN
         SPACE 3
***********************************************************************
*                                                                     *
*  EVALBD      ROUTINE TO EVALUATE THE MEMORY ADDRESS OF MEMORY       *
*  EVALXBD     REFERENCE INSTRUCTIONS                                 *
*                                                                     *
***********************************************************************
         SPACE 1
EVALBD   DS    0H
         SR    SCR0,SCR0     VALUE OF THE INDEX IS ZERO
         B     NOX                     GO EVALUATE BASE, DISPLACEMENT
EVALXBD  DS    0H
         SR    SCR0,SCR0               CLEAR SCR0
*  BXH OR BXLE DONT NEED INDEX ADDING FOR BASE+DISPLACEMENT.
         CLI   XCELL,X'86'             BXH ?
         BE    NOX                     IGNORE INDEX ADDING
         CLI   XCELL,X'87'             BXLE?
         BE    NOX                     IGNORE INDEX ADDING
         SR    SCR1,SCR1
         IC    SCR1,XCELL+1            RX
         N     SCR1,OOOOOOOF           0X
         BZ    NOX                     REGISTER ZERO IMPLIES NO INDEX
         SLL   SCR1,2                  X*4
         L     SCR0,OLDREG(SCR1)       VALUE OF THE INDEX
NOX      DS    0H                      AT THIS POINT, SCR0 CONTAINS
*                                      THE VALUE OF THE INDEX
         IC    SCR1,0(SCR2)            BD
         N     SCR1,OOOOOOFO           B0       BASE REGISTER
         BZ    NOB                     REGISTER ZERO IMPLIES NO BASE
         SRL   SCR1,2                  B*4
         A     SCR0,OLDREG(SCR1)       INDEX + BASE
NOB      DS    0H
         LH    SCR1,0(0,SCR2)          BDDD      BASE, DISPLACEMENT
         N     SCR1,OOOOOFFF           0DDD     DISPLACEMENT
         AR    SCR0,SCR1               INDEX + BASE + DISPLACEMENT
         BR    BRFROM                  RETU9N
         EJECT
***********************************************************************
*                                                                     *
*  RDUMP       REGISTER DUMP ROUTINES                                 *
*  FDUMP                                                              *
*                                                                     *
***********************************************************************
         SPACE 1
RDUMP    DS    0H                      DUMP GENERAL REGISTERS
         ST    BRFROM,RDSV             SAVE RETURN ADDRESS
         BAL   BRFROM,WRITE            PRINT 1 BLANK LINE
         LA    SCR2,REGTBL             ADDRESS OF UST 8 REGISTERS
         BAL   BRFROM,RPUT             PLACE THEM IN PRINT LINE
         MVC   PLINE(10),RM0           ' R0-R7    '
         BAL   BRFROM,WRITE            PRINT THE LINE
         LA    SCR2,REGTBL+32          ADDRESS OF 2ND 8 REGISTERS
         BAL   BRFROM,RPUT             PLACE THEM IN PRINT LINE
         MVC   PLINE(10),RM8           ' R8-R15   '
         BAL   BRFROM,WRITE            PRINT THE LINE
         L     BRFROM,RDSV             LOAD RETURN ADDRESS
         BR    BRFROM                  RETU9N
FDUMP    DS    0H
         ST    BRFROM,FDSV             SAVE RETURN ADDRESS
         BAL   BRFROM,WRITE            PRINT 1 BLANK LINE
         MVC   PLINE(10),FM0           ' F0-F6   '
         LA    SCR2,F0                 ADDRESS OF FLOATING REGISTER
*                                      TABLE
         BAL   BRFROM,RPUT             PLACE THEM IN PRINT LINE
         BAL   BRFROM,WRITE            PRINT THE LINE
         L     BRFROM,FDSV             LOAD RETURN ADDRESS
         BR    BRFROM                  RETURN
RPUT     DS    0H                      PLACE EIGHT REGISTERS INTO
*                                      THE PRINT LINE
         ST    BRFROM,RPSV             SAVE RETURN ADDRESS
         LA    SCR3,PLINE+16           STARTING POINT IN PRINT LINE
RNX      L     SCR0,0(SCR2)            GET THE VALUE OF A REGISTER
         BALR  BRFROM,HEX2EBC          CONVERT IT FOR PRINTING
         STM   SCR0,SCR1,0(SCR3)       PLACE IN PRINT LINE
         LA    SCR2,4(0,SCR2)          POINT AT NEXT REGISTER
         LA    SCR3,12(0,SCR3)         NEXT SPACE IN PRINT LINE
         C     SCR3,EOL                END OF PRINT LINE ?
         BL    RNX                     NO, GO GET NEXT REGISTER
         L     BRFROM,RPSV             YES, LOAD RETURN ADDRESS
         BR    BRFROM                  RETURN
         EJECT
***********************************************************************
*                                                                     *
*  WRITE       ROUTINE TO OUTPUT THE PRINT LINE                       *
*                                                                     *
***********************************************************************
         SPACE 1
WRITE    DS    0H
         STM   0,2,WTS                 SAVE REGISTERS
         AIF   ('&TYPE'EQ'OS').A
         EXCP  WROUT
         WAIT  WROUT
         AGO   .B
.A       ANOP
         STM   13,15,WTR
         TM    DCB+48,X'10'
         BO    WRITEA
         STIOT SYSTRACE,NF=GOEXEC  IF NO SYSTRACE DD THEN RETURN LHS
         OPEN  (DCB,OUTPUT)
         TM    DCB+48,X'10'
         BO    WRITEA
         ABEND 333,DUMP
WRITEA   PUT   DCB,PLINE
         LM    13,15,WTR
.B       ANOP
         SPACE 3
***********************************************************************
*                                                                     *
*              BLANK THE PRINT LINE                                   *
*                                                                     *
***********************************************************************
         SPACE 1
         MVI   PLINE,C' '              ONE BLANK TO START
         MVC   PLINE+1(LPL-1),PLINE    PROPAGATE THE BLANK
         LM    0,2,WTS                 RESTORE REGISTERS
         BR    BRFROM
         LTORG
CODEND   DS    0H
         EJECT
***********************************************************************
*                                                                     *
*  EXECR       EXECUTE ROUTINE                                        *
*                                                                     *
***********************************************************************
         SPACE 1
         USING *,4
EXECR    STM   0,3,EXECSAVE
         XC    EXECREG,EXECREG
         MVC   EXECINS,EXECINOP
         CLI   EXECSAVE,X'98'          IS IT A LM ?
         BE    EXECLM                  YES, GO PROCESS
         SR    SCR1,SCR1               CLEAR SCR1
         TM    1(8),RRBIT              IS IT AN RR INSTRUCTION ?
         BNO   EXECRXRS                NO, TRY RX RX AND SI
         SR    SCR1,SCR1
         IC    SCR1,EXECSAVE+1         GET REG PART
         BAL   BRFROM,EXECLEFT         GET R1
         BAL   BRFROM,EXECRITE         GET R2
         MVC   EXECINS(2),EXECSAVE     MOVE IN INSTRUCTION
         B     EXECFIND
EXECRXRS TM    1(8),SSBIT
         BO    EXECSS
         SR    SCR1,SCR1
         IC    SCR1,EXECSAVE+1
         BAL   BRFROM,EXECLEFT
         BAL   BRFROM,EXECRITE
         SR    SCR1,SCR1
         IC    SCR1,EXECSAVE+2
         BAL   BRFROM,EXECLEFT
         MVC   EXECINS(4),EXECSAVE
         B     EXECFIND
EXECSS   SR    SCR1,SCR1
         IC    SCR1,EXECSAVE+2
         BAL   BRFROM,EXECLEFT
         SR    SCR1,SCR1
         IC    SCR1,EXECSAVE+4
         BAL   BRFROM,EXECLEFT
         MVC   EXECINS,EXECSAVE
EXECFIND LA    SCR1,4
         LA    SCR2,EXECREG+1(SCR1)
EXECLOOP CLI   0(SCR2),X'FF'
         BNE   EXECLFND
         BCTR  SCR2,0
         BCT   SCR1,EXECLOOP
EXECLFND LA    SCR1,1(SCR1)
         SLL   SCR1,5
         STC   SCR1,EXECBALR+1         STORE REG TO BE USED
         STC   SCR1,EXECSTM+2          STORE BASE *****CHECK DISPLAC
         STC   SCR1,EXECLA+3
         L     SCR2,EXECSAVE+8
         LM    0,15,0(2)               LOAD ALL REGISTERS
EXECINS  DS    CL6                     EXECUTE INSTRUCTION
EXECBALR BALR  2,0
         DROP  DATA
         USING *,2
EXECSTM  STM   0,15,REGTBL             STORE ALL REGISTERS
         DROP  2
EXECRET  BALR  1,0
         USING *,1
         L     3,EXECSAVE+12
EXECLA   LA    SCR2,0
         SRL   SCR2,2
         L     8,OLDREG(2)
         ST    8,REGTBL(2)
         BR    3
         DROP  1
         USING DATAREA,DATA
EXECLEFT LR    SCR2,SCR1
         N     SCR2,OOOOOOFO
         SRL   SCR2,5
EXECLRCT LA    SCR2,EXECREG(SCR2)
         MVI   0(SCR2),X'FF'
         BR    BRFROM
EXECRITE LR    SCR2,SCR1
         N     SCR2,OOOOOOOF
         SRL   SCR2,1
         B     EXECLRCT
EXECLM   LA    SCR2,EXECSAVE+2
         BAL   BRFROM,EVALBD
         SR    SCR2,SCR2
         SR    SCR1,SCR1
         SR    5,5
         SR    SCR1,SCR1
         IC    SCR1,XCELL+1
         LR    SCR2,SCR1
         N     SCR1,OOOOOOFO
         SRL   SCR1,2
         N     SCR2,OOOOOOOF
         SLL   SCR2,2
         LR    3,0
EXECLMLP L     0,0(5,3)
         ST    0,REGTBL(SCR1)
         CR    1,2
         BE    EXECRET1
         LA    5,4(5)
         LA    SCR1,4(1)
         N     SCR1,OOOOOO3C           MOD 16
         B     EXECLMLP
EXECRET1 L     3,EXECSAVE+12
         BR    3
         EJECT
***********************************************************************
*                                                                     *
*              DATA AREA FOR THE TRACE ROUTINES                       *
*                                                                     *
***********************************************************************
         SPACE 1
DATAREA  DS    0H                      ORIGIN OF THE DATA AREA
AEXEC    DC    A(EXECR)
FLAGS    DC    H'0'                    ATTRIBUTE FLAGS DESCRIBING THE
*                                      CURRENT INSTRUCTION
HEXCHAR  DC    C'0123456789ABCDEF'
ESTAEPRM DC    A(0)                    SYSTRACE DCB ADDRESS
NOBUMP   DC    X'00'                   BRANCH INSTRUCTION FLAG
PRINTING DC    X'FF'                   PRINTING ENABLED FLAG
XTRACE   DC    X'00'                   PRINTING ENABLED FLAG
REALCC   DC    X'0'                    ACTUAL CONDITION CODE
XCELL    DC    F'0'                    A COPY OF THE INSTRUCTION
         DC    F'0'                    CURRENTLY BEING TRACED
         DC    A(REGTBL)               ADDRESS OF PSEUDO REGISTER
*                                      TABLE
REGTBL   DC    16F'0'                  REGISTERS OF THE TRACED PROGRAM
F0       DC    D'0'                    FLOATING POINT REGISTERS
F2       DC    D'0'                    OF THE TRACED PROGRAM
F4       DC    D'0'
F6       DC    D'0'
SAVREG   DC    16F'0'                  SAVE REGISTERS HERE WHILE
*                                      CALLING THE EXECUTE ROUTINE
OLDREG   DC    16F'0'                  COPY REGISTER TABLE HERE BEFORE
*                                      EXECUTING THE INSTRUCTIN
AENTRY   DC    F'0'                    ADDRESS OF TRACE ROUTINE ENTRY
NEWILC   DC    F'0'                    NEW VALUE FOR HTE LOCATION
*                                      COUNTER FOR SUCCESSFUL BRANCHES
         AIF   ('&TYPE'EQ'OS').D
WROUT    CCB   SYSLST,WRCCW
WRCCW    CCW   9,PLINE,0,LPL
         AGO   .E
.D       ANOP
DCB      DCB   DDNAME=SYSTRACE,MACRF=PM,LRECL=LPL,BLKSIZE=9372,        *
               DSORG=PS,RECFM=FB,BUFNO=2
.E       ANOP
EXECSAVE DS    4F
EXECREG  DS    XL8
EXECINOP DC    4X'0700'
*              MASKING CONSTANTS                                      *
         DS    0F                      INSURE ALLIGNMENT
OOOOOOOF DC    X'0000000F'
OOOOOOFO DC    X'000000F0'
OOOOOFFF DC    X'00000FFF'
OOOOFOOO DC    X'0000F000'
OFOOOOOO DC    X'0F000000'
OOOOOO3C DC    X'0000003C'
         DS    0F
         EJECT
***********************************************************************
*                                                                     *
*              TEMPORARY STORAGE USED BY THE VARIOUS ROUTINES         *
*                                                                     *
***********************************************************************
*                                      BY PRINTSUP
PRTS     DC    F'0'                    RETURN ADDRESS
*                                      BY PLINE1
PMS      DC    F'0'                    RETURN ADDRESS
P1S      DC    F'0'                    RETURN ADDRESS
EBDCC    DC    C'8421'                 CHARACTERS FOR CONDITION CODE
*                                      BY PLINOP
F3       DC    F'3'                    THE CONSTANT 3
P2S      DC    F'0'                    RETURN ADDRESS
*                                      BY BDPROC
BDS      DC    F'0'                    RETURN ADDRESS
BDT      DC    F'0'
BDT2     DS    F
*                                      BY PLINREG
P3S      DC    F'0'                    RETURN ADDRESS
PRT      DC    F'0'
*                                      BY PLINEFA
P4S      DC    F'0'                    RETURN ADDRESS
EFAT0    DC    F'0'
*                                      BY PRPROC
CCBITS   DC    X'00000080'             BITS CORRESPONDING TO THE
         DC    X'00000040'             CONDITION CODE
         DC    X'00000020'
         DC    X'00000010'
ILC1     DC    X'40000000'             INSTRUCTION LINGTH CODE
*                                      FOR BAL AND BALR
F1       DC    F'1'                    THE CONSTANT 1
BRSV     DC    F'0'                    RETURN ADDRESS
*                                      BY WRITE
WTS      DC    3F'0'
WTR      DC    3F'0'                   RETURN ADDRESS
         DS    0F                      INSURE ALIGNMENT
PDESC    DC    AL1(LPL-1)              STRING DESCRIPTOR
         DC    AL3(PLINE)              FOR THE PRINT LINE
*                                      BY RDUMP
RDSV     DC    F'0'                    RETURN ADDRESS
*                                      BY FDUMP
FDSV     DC    F'0'                    RETURN ADDRESS
*                                      BY RPUT
RPSV     DC    F'0'                    RETURN ADDRESS
EOL      DC    A(PLINE+16+8*12)        ADDRESS OF END OF PRINTLINE
*                                      BY EXOP
ORI      OI    PSXCELL+1,0             INSTRUCTION TO OR ONE BYTE
*                                      INTO THE SUBJECT INSTRUCTION
*                                      OF AND EXECUTE INSTRUCTION
PSXCELL  DC    F'0'                    COPY OF THE SUBJECT
         DC    F'0'                    INSTRUCTION
         DC    A(REGTBL)               ADDRESS OF THE REGISTER TABLE
PSFLAGS  DS    H'0'                    ATRRIBUTE FLAGS FOR THE SUBJECT
*                                      INSTRUCTION
*                                      BY GOIO
*                                      CHARACTER CONSTANTS
BLANKS   DC    CL8' '
FM0      DC    CL10' F0-F6    '
RM0      DC    C' R0-R7    '
RM8      DC    C' R8-R15   '
ILGMSG   DC    CL40' ****    ILLEGAL  INSTRUCTION  ****'
         DS    0F                      INSURE ALIGNMENT
ENDTM    DC    CL24'  RESUME EXECUTION AT: '
ENDADR   DC    CL24' '
***********************************************************************
*                                                                     *
*              THE PRINT LINE                                         *
*                                                                     *
***********************************************************************
         DS    0F                      INSURE ALIGNMENT
PLINE    DC    CL(LPL)' '
***********************************************************************
*                                                                     *
*              DEFINE SUBFIELDS WITHIN THE PRINT LINE FOR USE         *
*              BY THE PRINT ROUTINES                                  *
*                                                                     *
***********************************************************************
ILCMOD   EQU   PLINE+1                 LOCATION COUNTER
ILCDISP  EQU   PLINE+8                 LOCATION COUNTER
ILC      EQU   PLINE+16                LOCATION COUNTER
INSTR    EQU   PLINE+24                INSTRUCTION IMAGE
*ILC     EQU   PLINE+4                 LOCATION COUNTER
*INSTR   EQU   PLINE+16                INSTRUCTION IMAGE
CC       EQU   PLINE+36                CONDITION CODE
OP       EQU   PLINE+40                SYMBOLIC INSTRUCTION CODE
FIELDS   EQU   PLINE+48                INSTRUCTION FIELDS
PR1      EQU   PLINE+64                FIRST OPERAND REGISTER
DR1      EQU   PR1+8                   2ND HALF OF 1ST DOUBLE REGISTER
DR2A     EQU   DR1+12                  2ND DOUBLE REGISTER
DR2B     EQU   DR2A+8                  2ND HALF OF 2ND DOUBLE REGISTER
PR2      EQU   PLINE+76                SECOND SINGLE REGISTER
EFA1     EQU   PLINE+88                1ST EFFECTIVE ADDRESS
EFA2     EQU   PLINE+112               2ND EFFECTIVE ADDRESS
         EJECT
***********************************************************************
*                                                                     *
*              DEFINE TO INSTRUCTION CODE FLAG FIELDS USED TO         *
*              GENERATE THE ATTRIBUTE FLAG TABLE                      *
*              SHIFTING CONSTANTS FOR FIELD DEFINITIONS               *
*                                                                     *
***********************************************************************
LEFT     EQU   B'100000000'            PLACE IN LEFT HALF FLAGS
RIGHT    EQU   B'00000001'             PLACE IN RIGHT HALF OF FLAGS
B0       EQU   ILGLBIT*LEFT            ILLEGAL INSTRUCTION
B1       EQU   CCBIT*LEFT              CONDITION CODE SET
B2       EQU   BRBIT*LEFT              BRANCH INCTRUCTION
B3       EQU   HALFBIT*LEFT            HALF WORD INSTRUCTION
B4       EQU   FULLBIT*LEFT            FULL WORD INSTRUCTION
B5       EQU   DBLBIT*LEFT             DOUBLE WORD INSTRUCTION
B6       EQU   FLOATBIT*LEFT           FLOATING POINT INSTRUCTION
B7       EQU   SHIFTBIT*LEFT           SHIFT INSTRUCTION
B8       EQU   RRBIT*RIGHT             TYPE RR OR S INSTRUCTION
B9       EQU   RXBIT*RIGHT             TYPE RX OR RRE INSTRUCTION
BA       EQU   RSBIT*RIGHT             TYPE RS OR SSE INSTRUCTION
BB       EQU   SIBIT*RIGHT             TYPE SI INSTRUCTION
BC       EQU   SSBIT*RIGHT             TYPE SS INSTRUCTION
BD       EQU   IMDFBIT*RIGHT           CONTAINS 8-BIT OR 16-BIT FIELD
BE       EQU   LMSTMBIT*RIGHT          INSTRUCTION IS LM OR STM
BF       EQU   EXBIT*RIGHT             EXECUTE INSTRUCTION
OPFLAGS  DS    0H
         DC    AL2(B0+B8)          00
         DC    AL2(B2+B8)          02
         DC    AL2(B1+B4+B8)       04
         DC    AL2(B4+B8)          06
         DC    AL2(B1+B5+B8)       08
         DC    AL2(B1+B5+B6+B8)    0A
         DC    AL2(B5+B6+B8)       0C
         DC    AL2(B1+B4+B6+B8)    0E
         DC    AL2(B4+B6+B8)       10
         DC    AL2(B3+B9)          12
         DC    AL2(B4+B9)          14
         DC    AL2(B2+B4+B9+BF)    16
         DC    AL2(B2+B9)          18
         DC    AL2(B1+B3+B9)       1A
         DC    AL2(B0+B9)          1C
         DC    AL2(B1+B4+B9)       1E
         DC    AL2(B5+B6+B9)       20
         DC    AL2(B1+B5+B6+B9)    22
         DC    AL2(B4+B6+B9)       24
         DC    AL2(B1+B4+B6+B9)    26
         DC    AL2(B0+BB)          28
         DC    AL2(B2+B4+B6+BA)    2A
         DC    AL2(B4+B7+BA)       2C
         DC    AL2(B1+B4+B7+BA)    2E
         DC    AL2(BA+BE)          30
         DC    AL2(B1+BB+BD)       32
         DC    AL2(BB+BD)          34
         DC    AL2(B0+BB+BD)       36
         DC    AL2(B0+BB)          38
         DC    AL2(B0+BC)          3A
         DC    AL2(BC+BD)          3C
         DC    AL2(B1+BC+BD)       3E
         DC    AL2(BC)             40
         DC    AL2(B1+BC)          42
         DC    AL2(B5+B7+BA)       44
         DC    AL2(B1+B5+B7+BA)    46
         DC    AL2(B8+BE)          48
         DC    AL2(B1+B4+BA+BE)    4A
         DC    AL2(B1+B5+BA+BE)    4C
         DC    AL2(B1+B4+BB)       4E  LIE A LITTLE ABOUT B2 OPCODE LHS
         DC    AL2(B1+B4+B8+BD)    50  S FORMAT (9CXX OR B2XX OPCODES)
         DC    AL2(B1+B4+B9+BD)    52  RRE FORMAT (B2XX OPCODES)
         DC    AL2(B1+B4+BA+BD)    54  SSE FORMAT (E5XX OPCODES)
         DC    AL2(B1+B4+BA)       56  RS INSTRUCTION
         DC    AL2(B1+B4+B8+BD+BE) 58  S FORMAT (B20B OR B218 OPCODES)
*                                   USE WITH SVERAL REGISTERS
         DC    AL2(B1+B4+BA+BD+BE) 5A  SSE FORMAT (E500 OPCODES)
*                                   USE WITH SVERAL REGISTERS
         EJECT
OPINDEX  DS    0H
         DC    X'00000000'  RR00   ...     ...     ...     ...       00
         DC    X'06020202'    04   SPM     BALR    BCTR    BCR       01
         DC    X'00004800'    08  *SSK    *ISK    *SVC     ...       02
         DC    X'00020604'    0C   ...     BASR    MVCL    CLCL      03
         DC    X'04040404'    10   LPR     LNR     LTR     LCR       04
         DC    X'04040404'    14   NR      CLR     OR      XR        05
         DC    X'06040404'    18   LR      CR      AR      SR        06
         DC    X'06060404'    1C   MR      DR      ALR     SLR       07
         DC    X'0A0A0A0A'    20   LPDR    LNDR    LTDR    LCDR      08
         DC    X'0C0C0C0C'    24   HDR     LRDR    NXR     MXDR      09
         DC    X'0C0A0A0A'    28   LDR     CDR     ARD     SDR       10
         DC    X'0C0C0A0A'    2C   MDR     DDR     AWR     SWR       11
         DC    X'0E0E0E0E'    30   LPER    LNER    LTER    LCER      12
         DC    X'10100A0A'    34   HER    LRER     AXR     SXR       13
         DC    X'100E0E0E'    38   LER     CER     ALR     SER       14
         DC    X'10100E0E'    3C   MER     DER     AUR     SUR       15
         DC    X'12141414'  Ö?40   STH     LA      STC     IC        16
         DC    X'16181818'    44   EX      BAL     BCT     BC        17
         DC    X'121A1A1A'    48   LH      CH      AH      SH        18
         DC    X'12181414'    4C   MH      BAS     CVD     CVB       19
         DC    X'141C1C1C'    50   ST      ...     ...     ...       20
         DC    X'1E1E1E1E'    54   N       CL      O       X         21
         DC    X'141E1E1E'    58   L       C       A       S         22
         DC    X'14141E1E'    5C   M       D       AL      SL        23
         DC    X'201C1C1C'    60   STD     ...     ...     ...       24
         DC    X'1C1C1C20'    64   ...     ...     ...     MXD       25
         DC    X'20222222'    68   LD      CD      AD      SD        26
         DC    X'20202222'    6C   MD      DD      AW      SW        27
         DC    X'241C1C1C'    70   STE     ...     ...     ...       28
         DC    X'1C1C1C1C'    74   ...     ...     ...     ...       29
         DC    X'24262626'    78   LE      CE      AE      SE        30
         DC    X'24242626'    7C   ME      DE      AU      SU        31
         DC    X'28282828'    80  *SSM     ...    *LPSW    ...       32
         DC    X'28282A2A'    84  *WRD    *RDD     BXH     BXLE      33
         DC    X'2C2C2E2E'    88   SRL     SLL     SRA     SLA       34
         DC    X'44444646'    8C   SRDL    SLDL    SRDA    SLDA      35
         DC    X'30323436'  SI90   STM     TM      MVI    *TS        36
         DC    X'32323232'    94   NI      CLI     OI      XI        37
         DC    X'30383838'    98   LM      ...     ...     ...       38
         DC    X'38383838'    9C  *SIO    *TIO    *HIO    *TCH       39
         DC    X'38383838'    A0   ...     ...     ...     ...       40
         DC    X'38383838'    A4   ...     ...     ...     ...       41
         DC    X'38383838'    A8   ...     ...     ...     ...       42
         DC    X'32325632'    AC   STNSM   STOSM   SIGP    MC        43
         DC    X'381E3838'    B0   ...     LRA     ?LIE?4D ...   LHS 44
         DC    X'38383030'    B4   ...     ...    STCTL    LCTL      45
         DC    X'38384A4C'    B8   ...     ...     CS      CDS       46
         DC    X'384A4A4A'    BC   ...     CLM     STCM    ICM       47
         DC    X'3A3A3A3A'  SSC0   ...     ...     ...     ...       48
         DC    X'3A3A3A3A'    C4   ...     ...     ...     ...       49
         DC    X'3A3A3A3A'    C8   ...     ...     ...     ...       50
         DC    X'3A3A3A3A'    CC   ...     ...     ...     ...       51
         DC    X'3A3C3C3C'    D0   ...     MVN     MVC     MVZ       52
         DC    X'3E3E3E3E'    D4   NC      CLC     OC      XC        53
         DC    X'3A424242'    D8   ...     MVCK    MVCP    MVCS      54
         DC    X'3E3E3E3E'    DC   TR      TRT     ED      EDMK      55
         DC    X'3A3A3A3A'    E0   ...     ...     ...     ...       56
         DC    X'3A3A3A3A'    E4   ...     ...     ...     ...       57
         DC    X'423A3A3A'    E8   MVCIN   ...     ...     ...       58
         DC    X'3A3A3A3A'    EC   ...     ...     ...     ...       59
         DC    X'42404040'    F0   SRP     MVO     PACK    UNPK      60
         DC    X'3A3A3A3A'    F4   ...     ...     ...     ...       61
         DC    X'42424242'    F8   ZAP     CP      AP      SP        62
         DC    X'40403A3A'    FC   MP      DP      ...     ...       63
         EJECT
SOPINDEX DS    0F                  B2XX SECOND BIT OPER CODES
*                          ALSO 9CXX 9DXX 9EXX  9FXX (S FORMAT)
         DC    X'50505050'  RR00   CONCS   DISCS   STIDP   STDC      00
         DC    X'50505050'    04   SCK     STCK    SCKC    STCKC     01
         DC    X'50505058'    08   SPT     STPT    SPKA    IPK       02
         DC    X'00500000'    0C   ...     PTLB    ...     ...       03
         DC    X'50505050'    10   SPX     STPX    STAP    RRB       04
         DC    X'00000000'    14   ...     ...     ...     ...       05
         DC    X'58500000'    18   PC      SAC     ...     ...       06
         DC    X'00000000'    1C   ...     ...     ...     ...       07
         DC    X'00520052'    20   ...     IPTE    ...     IVSK      08
         DC    X'52525252'    24   IAC     SSAR    EPAR    ESAR      09
         DC    X'52525252'    28   PT      ISKE    RRBE    SSKE      10
         DC    X'52000000'    2C   TB      ...     ...     ...       11
BCDOP    DS    0F
         DC    C'                SPM BALRBCTRBCR '  00              000
         DC    C'SSK ISK SVC         BASRMVCLCLCL'  08              020
         DC    C'LPR LNR LTR LCR NR  CLR OR  XR  '  10              040
*                0   1   2   3   4   5   6   7
*                8   9   A   B   C   D   E   F
         DC    C'LR  CR  AR  SR  MR  DR  ALR SLR '  18              060
         DC    C'LPDRLNDRLTDRLCDRHDR LRDRNXR MXDR'  20               80
         DC    C'LDR CDR ADR SDR MDR DDR AWR SWR '  28              0A0
         DC    C'LPERLNERLTERLCERHER LRERAXR SXR '  30              0C0
         DC    C'LER CER AER SER MER DER AUR SUR '  38              0E0
         DC    C'STH LA  STC IC  EX  BAL BCT BC  '  40              100
         DC    C'LH  CH  AH  SH  MH  BAS CVD CVB '  48              120
         DC    C'ST              N   CL  O   X   '  50              140
         DC    C'L   C   A   S   M   D   AL  SL  '  58              160
         DC    C'STD                         MXD '  60              180
         DC    C'LD  CD  AD  SD  MD  DD  AW  SW  '  68              1A0
         DC    C'STE                             '  70              1C0
         DC    C'LE  CE  AE  SE  ME  DE  AU  SU  '  78              1E0
         DC    C'SSM     LPSW    WRD RDD BXH BXLE'  80              200
         DC    C'SRL SLL SRA SLA SRDLSLDLSRDASLDA'  88              220
         DC    C'STM TM  MVI TS  NI  CLI OI  XI  '  90              240
         DC    C'LM              SIO TIO HIO TCH '  98              260
         DC    C'                                '  A0              280
         DC    C'                STNSSTOSSIGPMC  '  A8              2A0
         DC    C'    LRA S*?*            STCTLCTL'  B0  LHS         2C0
         DC    C'        CS  CDS     CLM STCMICM '  B8
         DC    C'                                '  C0              300
         DC    C'                                '  C8              320
         DC    C'    MVN MVC MVZ NC  CLC OC  XC  '  D0              340
         DC    C'    MVCKMVCPMVCSTR  TRT ED  EDMK'  D8              360
         DC    C'                                '  E0              380
         DC    C'MVIN                            '  E8              3A0
         DC    C'SRP MVO PACKUNPK                '  F0              3C0
         DC    C'ZAP CP  AP  SP  MP  DP          '  F8              3E0
SBCDOP   DS    0F    EXTRA CODES
         DC    C'CONCDISCSTDPSTDCSCK STCKSCKCSTCK'                  000
         DC    C'SPT STPTSPKAIPK     PTLB        '                  008
         DC    C'SPX STPXSTAPRRB                 '                  010
         DC    C'PC  SAC                         '                  018
         DC    C'    IPTE    IVSKIAC SSAREPARESAR'                  020
         DC    C'PT  ISKERRBESSKETB              '                  028
NBCDOP9C DS    0F
         DC    C'SIO SIOFRIO                     '                  000
NBCDOP9D DS    0F
         DC    C'TIO CLRI                        '                  000
NBCDOP9E DS    0F
         DC    C'HIO HDV                         '                  000
NBCDOP9F DS    0F
         DC    C'TCH CLRC                        '                  000
EBCDOP   DS    0F
         DC    C'LASPTPRO                        '                  000
         DS    0F
CSECTMAX DC    F'4096'      MAXIMUM CSECT LENGTH
         DS    0F
CLRCHAR  EQU   *,4
         DC    X'00'
         DC    C' '
         DC    H'0'
MAPFLAG  DC    X'00'
ERROR1   DC    X'00280000'
         DC    C'     ERR'
         DC    C'OR OVER '
         DC    C'100 MODU'
         DC    C'LES TABL'
         DC    C'E   '
DATAEND  DS    0H                 END OF TRACE ROUTINE DATA AREA
         TITLE 'ERROR RECOVERY ROUTINE (ESTAE EXIT)'
RECOVER  DS    0H
*
*   THIS IS INVOKED IF TRACE ABENDS
*     ALL IT DOES IS A CLOSE OF SYSTRACE
*
         USING RECOVER,15
         C     0,=F'12'     SDWA PROVIDED
         BNE   GOODSDWA
         SR    15,15       NO...THEN TAKE ABEND WITH NO ACTION
         BR    14
GOODSDWA DS    0H
         SAVE  (14,12)
         LR    12,15
         DROP  15
         USING RECOVER,12
         LR    2,1        SAVE PTR TO SDWA
         L     3,0(2)     GET ESTAEPRM
         CLOSE ((3))       CLOSE SYSTRACE FILE
         SETRP WKAREA=(2),REGS=(14,12),DUMP=YES,RC=0
MAPDIR   DC    400F'0'   UP TO 100 CSECT NAMES CAN BE TRACED
*                          16 BYTES PER CSECT NAME SEE MODDIRD DSECT
*                        IF OVER 100, INCREASE THE MAPDIR
*                                      AND MODCNTMX WITH SAME VALUE.
         DROP  12
MODDIRD  DSECT
MODNME   DS    CL8
MODADR   DS    F
MODSIZE  DS    F
         IHASDWA
         END
./       ADD   NAME=BLOCKSAS
BLOK TITLE '  "BLOKHEAD" -- BLOCK PAGE HEADER ROUTINE -- BY BARTH'
*  BLOKHEAD REMODIFIED FOR SAS AS SUBROUTINE (SEE BLOKTST2 DOC)
*  DAVID RIKER 1/5/85
*  COMPUTER DATA SYSTEMS INC
*  ONE CURIE COURT
*  ROCKVILLE MD 20850
*  202-362-1160
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* *                                                               * *
* *                      " B L O K H E A D "                      * *
* *                                                               * *
* *                  BLOCK PAGE HEADER ROUTINE                    * *
* *                     BY C. WRANDLE BARTH                       * *
* *                 GODDARD SPACE FLIGHT CENTER                   * *
* *                         2 APRIL 1971                          * *
* *                                                               * *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 5
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                   *
*        "BLOKHEAD" IS A SHORT PROGRAM WHICH WILL PROVIDE BLOCK     *
*  LETTER HEADINGS ON A DATA SET USING THE MODIFIED "IEFSD095"*     *
*  ROUTINE TO GENERATE THE LETTERS.  IT IS PARTICULARLY USEFUL FOR  *
*  HEADING MICROFILM WITH IDENTIFYING FRAMES WHICH ARE READABLE     *
*  WITHOUT INSERTION INTO A VIEWER.                                 *
*                                                                   *
*        "BLOKHEAD" MAY BE INVOKED EITHER BY EXECUTE CARD OR IT     *
*  MAY BE LINKED TO DIRECTLY.  THE INFORMATION TO BE PRINTED IS     *
*  PASSED IN THE PARAMETER OF THE EXECUTE CARD IN THE FORM:         *
*                                                                   *
*        PARM='(DDNAME),AAA...AA,BBB...BB,CCC...CC,'                *
*                                                                   *
*  THE FIRST PARAMETER IS THE DDNAME OF THE DATA SET TO RECEIVE     *
*  THE HEADING.  IF PRESENT, IT MUST BE INCLOSED IN PARENTHESES.    *
*  IF OMITTED, "FT12F001" WILL BE ASSUMED.  THE REMAINING PARAMETERS*
*  ARE THE LINES TO BE PRINTED.  "BLOKHEAD" WILL ATTEMPT TO PUT     *
*  EACH PARAMETER ON A LINE BY ITSELF, BUT IF THE LINE WILL NOT     *
*  HOLD THE FULL PARAMETER, IT WILL BE SPLIT UP.  EACH LINE WILL    *
*  BE CENTERED ON THE PAGE.  THE PARAMETERS MAY CONTAIN ANY VALID   *
*  PN/QN CHAIN CHARACTER PLUS THE EXCLAMATION POINT AND CENT SIGN.  *
*  SINCE THE COMMA WAS USED ABOVE TO DELIMIT THE PARAMETERS, IT     *
*  MAY NOT BE A PART OF A PARAMETER;  HOWEVER, ANY CHARACTER (EXCEPT*
*  AN OPEN PARENTHESIS) MAY BE USED TO DELIMIT THE PARAMETER STRING.*
*  FOR EXAMPLE:                                                     *
*                                                                   *
*        PARM='(SYSUT1)/A,B,C/D,E,F/'                               *
*                                                                   *
*  COULD BE USED TO PRINT THE TWO LINES "A,B,C" AND "D,E,F".        *
*  TWO CONSECUTIVE DELIMITERS WILL CAUSE A PAGE EJECT.  IF A LINE   *
*  CONSISTS ONLY OF THE CENT SIGN CHARACTER, A FULL PAGE OF         *
*  ASTERISKS WILL BE PRINTED.  THE FINAL DELIMITER IS OPTIONAL.     *
*                                                                   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                   *
*        IF "BLOKHEAD" IS LINKED TO, THE SAME PARAMETER SHOULD BE   *
*  PROVIDED IN A FORMAT COMPATABLE TO THE EXEC CARD---THAT IS,      *
*  REGISTER 1 SHOULD POINT TO A HALF-WORD CHARACTER COUNT FOLLOWED  *
*  BY THE PARAMETER PROPER.                                         *
*                                                                   *
*        EXAMPLES:                                                  *
*                                                                   *
*        PARM='(DD1),NOW,IS,THE TIME,,FOR,ALL,GOOD,MEN...'          *
*                                                                   *
*  WOULD GIVE ON DD1...           NOW            FOR                *
*                                  IS            ALL                *
*                              THE TIME         GOOD                *
*                                               MEN...              *
*                                                                   *
*        PARM='/1234567890/0987654321/C/'                           *
*                                     ×                             *
*                                     CENT SIGN                     *
*                                                                   *
*  WOULD GIVE ON FT12F001...   1234567890      **********           *
*                              0987654321      **********           *
*                                              **********           *
*                                              **********           *
*                                                                   *
*  FOR REGULAR PRINTOUT, THE MAXIMUM NUMBER OF CHARACTERS PER LINE  *
*  IS 9 (132 CHARACTER LINE).  THE MAXIMUM NUMBER OF LINES PER      *
*  PAGE IS 4 (66 LINE PAGE).                                        *
*                                                                   *
*        "BLOKHEAD" IS REUSABLE.                                    *
*                                                           -CWB-   *
*                                                                   *
*  _______________                                                  *
*  *THE UNMODIFIED "IEFSD095" MAY BE USED, BUT IT ONLY HANDLES      *
*        LETTERS AND NUMBERS;  THE GODDARD MODIFIED VERSION ALSO    *
*        OUTPUTS ALL PN/QN CHARACTERS AND THE EXCLAMATION POINT     *
*        AND CENT SIGN.                                             *
*  _______________                                                  *
*  *UPDATED 19SEP83, WILLIAM SMITH, SYNTEX CORPORATION,             *
*        PALO ALTO, CALIFORNIA 94304 - (415) 852-1638               *
*                                                                   *
*  *THIS UTILITY HAS BEEN SUCCESSFULLY TESTED ON A MVS/SP 1.3.3     *
*        JES2 SYSTEM USING BOTH THE MODIFIED AND UNMODIFIED VER-    *
*        SIONS OF IEFSD095.  FOR MORE INFORMATION CONSULT "OS/VS2   *
*        MVS SYSTEM PROGRAMMING LIBRARY:  JOB MANAGEMENT", PUBLI-   *
*        CATION NO. GC28-0627-2, CHAPTER 10: EXTERNAL WRITERS.      *
*        NOTE THAT THE "VANILLA" VERSION OF IEFSD095 CONTINUES TO   *
*        ONLY SUPPORT BLOCK LETTERS (A TO Z), BLOCK NUMBERS (0 TO   *
*        9), A BLANK, AND THE NATIONAL CHARACTERS (#,@,$).          *
*                                                                   *
*  *THE IBM ROUTINE IEFSD095 IS REENTERABLE AND RESIDES IN THE      *
*        MODULE LIBRARY SYS1.AOSB0.                                 *
*                                                                   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         EJECT
BLOKHEAD CSECT
         ENTRY BLOKHEAD
         USING *,#15               PROVIDE TEMPORARY ADDRESSABILITY.
         SAVE  (14,12),,*          SAVE REGISTERS.
         L     #PARM,0(#1)         GET ADDRESS OF PARAMETER.
         CNOP  0,4                 ADVANCE TO FULLWORD.
         BAL   #1,LINKUP           GET ADDRESS OF SAVE AREA.
SAVE     DC    18F'0'              REGISTER SAVE AREA.
LINKUP   ST    #13,SAVE+4          CROSS-LINK SAVE AREAS.
         ST    #1,8(#13)
         LR    #13,#1              POINT TO NEW SAVE AREA.
         DROP  #15                 USE #13 AS NEW BASE
         USING SAVE,#13                 REGISTER.
         SR    #COUNT,#COUNT       SAS: CLEAR COUNTS
         IC    #COUNT,0(#PARM)     SAS: 1ST BYTE IS LENGTH
*                                       2-4 BYTES IS ADDR OF FIRST CHAR
         L     #PARM,0(#PARM)      SAS: GET ADDR OF FIRST CHAR
         LA    #PARM,0(#PARM)      SAS: REMOVE VL / COUNT BYTE
*OLD     LH    #COUNT,0(#PARM)     PICK UP LENGTH OF PARM.
*OLD     LA    #PARM,2(#PARM)      ADVANCE TO BEGINNING OF PARM.
         MVC   DCB+40(8),=C'FT12F001'
*                                  SET DEFAULT DDNAME.
         CLI   0(#PARM),C'('       DOES PARM BEGIN WITH "("?
         BNE   OPENIT              IF NOT, GO OPEN DCB.
         BCTR  #COUNT,0            COUNT OFF "(".
         LA    #DDNAME,DCB+40      POINT TO RECEIVING FIELD FOR DDNAME.
         MVI   DCB+40,C' '         CLEAR OUT OLD DDNAME.
         MVC   DCB+41(7),DCB+40    CLEAR IT ALL OUT.
         LA    #LIMIT,8(#PARM)     POINT TO 8 CHARACTERS FROM NOW.
         SPACE
NEXTONE  LA    #PARM,1(#PARM)      ADVANCE TO NEXT CHARACTER.
         CLI   0(#PARM),C')'       IS THIS THE ")"?
         BE    STEP1               IF SO, BRANCH.
         CR    #PARM,#LIMIT        HAVE WE PASSED 8 CHARACTERS?
         BH    ZILTCH              IF SO, OOPS;  BRANCH.
         IC    #1,0(#PARM)         PICK UP CHARACTER AND
         STC   #1,0(#DDNAME)            PUT IT INTO DCB.
         LA    #DDNAME,1(#DDNAME)  POINT TO NEXT DDNAME CHARACTER.
         BCT   #COUNT,NEXTONE      LOWER PARM COUNT AND CONTINUE.
         B     ZILTCH              RUNNING OUT OF PARM HERE IS A GOOF.
         SPACE 3
STEP1    LA    #PARM,1(#PARM)      ADVANCE PAST ")".
         BCT   #COUNT,OPENIT       DOWN COUNT AND GO OPEN DCB.
         B     ZILTCH              IF #COUNT GOES ZERO HERE, BRANCH.
         SPACE 5
OPENIT   OPEN  (DCB,OUTPUT)        OPEN THE DCB.
         TM    DCB+36,B'00000010'  DOES THE DATA SET USE MACHINE
         BO    BADRECFM                 CONTROL?  IF SO, BRANCH.
         PUT   DCB                 FIRST PUT TO GET FIRST BUFFER.
         LR    #OUTAREA,#1         GET ADDRESS OF FIRST BUFFER.
         SR    #DELIMTR,#DELIMTR   CLEAR REGISTER FOR IC INSTRUCTIONS.
         SR    #CHAR,#CHAR         DITTO.
         IC    #DELIMTR,0(#PARM)   GET DELIMITER.
         LH    #LENGTH,DCB+82      GET DCB'S LRECL.
         TM    DCB+36,B'10000000'  IS THE RECFM V?
         BO    CALCMAX             IF NOT, BRANCH.
         STH   #LENGTH,LENGCNTR    PUT TRUE MAX LRECL INTO FULL WORD'S
*                                       HIGH END FOR USE AS VARIABLE
*                                       LENGTH RECORD CONTROL WORD.
         MVC   0(4,#OUTAREA),LENGCNTR
*                                  STORE IT INTO RECORD BUFFER.
*                                       NOTE THAT ALL RECFM=V IN
*                                       "BLOKHEAD" ARE OUTPUT AT
*                                       MAXIMUM LENGTH.
         LA    #1,4                GET A 4.
         AR    #OUTAREA,#1         ADVANCE PAST CONTROL WORD.
         SR    #LENGTH,#1          DECREASE #LENGTH BY 4.
*                                  NOW CONTINUE PROCESSING AS FOR
*                                       RECFM F OR U.
CALCMAX  LA    #LINEMAX,1(#LENGTH) LRECL INCLUDES CONTROL CHARACTER;
*                                       PUT LRECL - 1 (CONTROL CH.)
*                                       + 2 INTO #LINEMAX.
*                                       (THE +2 IS FOR THE TWO SEPARA-
*                                       TING BLANKS BETWEEN CHARACTERS
*                                       WHICH NEED NOT FOLLOW LAST
*                                       CHARACTER.)
         SR    #DIVIDND,#DIVIDND   CLEAR PRECEDING EVEN REGISTER FOR
*                                       DIVISION.
         D     #DIVIDND,=F'14'     DIVIDE BY 14 TO GET NUMBER PER LINE
*                                       IN #LINEMAX.
         LTR   #LINEMAX,#LINEMAX   IS THERE ENOUGH ROOM FOR AT LEAST
*                                       ONE?
         BZ    KABOOM              IF NOT, BRANCH.
         C     #LINEMAX,=F'20'     IS THE LINE LONGER THAN 20 BLOCK
*                                       CHARACTERS LONG?
         BNH   SETLENG             IF NOT, BRANCH.
         L     #LINEMAX,=F'20'     ELSE, LIMIT LINES TO 20 CHARACTERS.
SETLENG  BCTR  #LENGTH,0           DECREASE 1 FOR CARRIAGE CONTROL.
         LR    #MVLENG,#LENGTH     COPY INTO #MVLENG.
         BCTR  #MVLENG,0           DECREASE 1 SINCE "RIPPLE" DOESN'T
*                                       MOVE TO FIRST CHARACTER OF
*                                       RECORD.
         BCTR  #MVLENG,0           DECREASE 1 FOR EX INSTRUCTIONS.
         B     NEXTPAGE            GO SET PAGE EJECTION.
         SPACE 5
NXSTRING SR    #CHARCNT,#CHARCNT   NOTE THAT 0 CHARACTERS ARE ON THIS
*                                       LINE SO FAR.
         IC    #CHAR,0(#PARM)      PICK UP NEXT PARM CHARACTER.
         CR    #CHAR,#DELIMTR      IS THIS LINE OF LENGTH ZERO?
         BNE   BLACKCHK            IF NOT, BRANCH.
NEXTPAGE MVI   0(#OUTAREA),C' '   SET TO EJECT PAGE. LET SAS USER DO IT
         B     BUMPER              GO ADVANCE TO NEXT CHARACTER.
         SPACE 5
BLACKCHK C     #CHAR,BLACKIND      IS THIS CHARACTER A CENT SIGN?
         BNE   GATHER              IF NOT, GO COLLECT LINE.
         LA    #1,1                PICK UP A 1.
         CR    #COUNT,#1           IS THAT WHAT #COUNT IS (IS THE
*                                       CENT SIGN THE LAST CHARACTER)?
         BE    ALLSTAR             IF SO, BRANCH.
         EX    #DELIMTR,NEXTCHK    IS IT FOLLOWED BY A DELIMITER?
*                                       NOTE THAT:
*                                       NEXTCHK CLI 1(#PARM),0
         BNE   GATHER              IF NOT, BRANCH.
ALLSTAR  LA    #LINECNT,60         WE WILL MAKE 60 LINES.
         MVI   0(#OUTAREA),C' '    START ON NEW PAGE.
FILLPAGE MVI   1(#OUTAREA),C'*'    INSERT STAR INTO BUFFER.
         EX    #MVLENG,RIPPLE      FILL LINE WITH STARS.
*                                       NOTE THAT:
*                                       RIPPLE MVC 2(,#OUTAREA),
*                                                    1(#OUTAREA)
         PUT   DCB                 OUTPUT LINE OF STARS.
         LR    #OUTAREA,#1         POINT TO NEXT BUFFER.
         TM    DCB+36,B'10000000'  IS THIS A VARIABLE LENGTH RECORD?
         BO    SNGLSPCE            IF NOT, BRANCH.
         MVC   0(4,#OUTAREA),LENGCNTR
*                                 SET CONTROL WORD INTO BUFFER.
         LA    #OUTAREA,4(#OUTAREA)
*                                  ADVANCE PAST CONTROL WORD.
SNGLSPCE MVI   0(#OUTAREA),C' '    SINGLE SPACE THIS LINE.
         BCT   #LINECNT,FILLPAGE   LOOP TILL PAGE FULL.
         LA    #PARM,1(#PARM)      ADVANCE TO DELIMITER AFTER
         BCT   #COUNT,NEXTPAGE          CENT SIGN, DOWN COUNT, AND
*                                       BRANCH.
         B     GOODOUT             IF THAT'S ALL THE PARM, BRANCH OUT.
         SPACE 5
NEXTSYM  IC    #CHAR,0(#PARM)      ADD ANOTHER CHARACTER TO THIS
*                                       LINE AS FOLLOWS:  GET
*                                       NEXT PARM CHARACTER.
         CR    #CHAR,#DELIMTR      IS IT A DELIMITER?
         BE    OUTLINE             IF SO, GO OUTPUT LINE.
GATHER   STC   #CHAR,LINESPOT(#CHARCNT)
*                                  STORE THIS CHARACTER INTO LINE'S
*                                       ACCUMULATION AREA.
         LA    #CHARCNT,1(#CHARCNT)
*                                  INCREASE CHARACTER COUNT.
         CR    #CHARCNT,#LINEMAX   IS THE LINE FULL?
         BNL   DELCHK              IF SO, BRANCH.
         LA    #PARM,1(#PARM)      ELSE ADVANCE TO NEXT CHARACTER.
         BCT   #COUNT,NEXTSYM      DOWN COUNT AND GO GET NEXT SYMBOL
*                                       (CHARACTER).  IF PARM IS ALL
*                                       DONE, FALL THROUGH TO:
JIMMY    LA    #COUNT,1            RESET COUNT TO 1 SO THAT
*                                       BCT INSTRUCTION AT "BUMPER"
*                                       WILL ALSO FALL THROUGH.
         B     OUTLINE             GO OUTPUT LAST LINE.
         SPACE 5
DELCHK   EX    #DELIMTR,NEXTCHK    IS THE NEXT CHARACTER A DELIMITER?
         BNE   OUTLINE             IF NOT, BRANCH.
         LA    #PARM,1(#PARM)      ELSE, IGNORE DELIMITER.
         BCT   #COUNT,OUTLINE      DOWN COUNT AND GO OUTPUT.
         B     JIMMY               PARM SHOULDN'T END HERE (IF IT DOES
*                                       THAT DELIMITER WE SAW WAS
*                                       GARBAGE);  BUT BRANCH TO
*                                       KEEP THINGS SAFE.
         SPACE 5
OUTLINE  LR    #OFFSET,#LENGTH     GET LENGTH OF LINE (EXCLUDING
*                                       CARRIAGE CONTROL).
         LR    #0,#CHARCNT         GET NUMBER OF BLOCKS TO BE PRINTED.
         MH    #0,=H'14'           MULTIPLY BY 14--NUMBER OF CHARACTERS
*                                       IN EACH BLOCK (12) PLUS NUMBER
*                                       OF SPACES BETWEEN BLOCKS (2).
*                                       NOTE THAT THIS PRODUCT IS TOO
*                                       BIG BY 2--THE SPACES AFTER THE
*                                       LAST BLOCK.
         SR    #OFFSET,#0          SUBTRACT PRODUCT FROM LINE LENGTH
*                                       GIVING NUMBER OF BYTES NOT
*                                       USED MINUS 2.
         SRA   #OFFSET,1           DIVIDE BY 2 FOR HALF PAGE.
         A     #OFFSET,=F'2'       ADD 2;  1 FOR THE EXCESS MENTIONED
*                                       ABOVE AND 1 SINCE WE START AT
*                                       AN OFFSET OF 1 NOT ZERO IN
*                                       THE BUFFER.
         ST    #CHARCNT,STRINGLN   STORE LENGTH OF DATA STRING FOR
*                                       "IEFSD095".
         SR    #LINECNT,#LINECNT   CLEAR #LINECNT FOR LOOP.
         SPACE
LOOP095  LA    #1,PARM095          POINT TO "IEFSD095" PARMS.
         LA    #LINECNT,1(#LINECNT)
*                                  ADVANCE TO NEXT LINE IN BLOCK.
         ST    #LINECNT,LINENO     STORE LINE NUMBER FOR "IEFSD095".
         LR    #0,#OFFSET          COPY OFFSET INTO #0.
         AR    #0,#OUTAREA         ADD ADDRESS OF START OF BUFFER.
         ST    #0,STRINGAD         STORE INTO "IEFSD095" PARM AS
*                                       ADDRESS TO RECEIVE STRING.
         MVI   1(#OUTAREA),C' '    CLEAR OUT OUTPUT BUFFER.
         EX    #MVLENG,RIPPLE      CLEAR IT ALL THE WAY OUT.
*                                       NOTE:  RIPPLE MVC
*                                            2(,#OUTAREA),1(#OUTAREA)
         CALL  EALSDW95            CREATE LINE FOR BLOCK LETTERS.
         PUT   DCB                 OUTPUT LINE.
         LR    #OUTAREA,#1         POINT TO NEXT BUFFER.
         TM    DCB+36,B'10000000'  IS THIS A VARIABLE LENGTH RECORD?
         BO    READYNXT            IF NOT, BRANCH.
         MVC   0(4,#OUTAREA),LENGCNTR
*                                 SET CONTROL WORD INTO BUFFER.
         LA    #OUTAREA,4(#OUTAREA)
*                                  ADVANCE PAST CONTROL WORD.
READYNXT MVI   0(#OUTAREA),C' '    SINGLE SPACE NEXT LINE.
         C     #LINECNT,=F'12'     HAS THE LAST LINE BEEN OUTPUT?
         BNE   LOOP095             IF NOT, BRANCH.
         MVI   0(#OUTAREA),C'-'    DOUBLE SPACE NEXT LINE.
         SPACE
BUMPER   LA    #PARM,1(#PARM)      POINT TO NEXT CHARACTER.
         BCT   #COUNT,NXSTRING     DOWN COUNT AND BRANCH IF MORE
*                                       TO DO.
GOODOUT  SR    #RC,#RC             NORMAL EXIT;  CLEAR RETURN CODE.
         SPACE 3
CLOSEUP  MVI   0(#OUTAREA),C' '    CLEAR OUT LAST BUFFER SO THAT
         MVI   1(#OUTAREA),C' '         CLOSE WILL PRINT ONLY
         EX    #MVLENG,RIPPLE           A BLANK LINE.
         CLOSE DCB                 CLOSE DCB.
         SPACE
LEAVE    L     #13,SAVE+4          RESTORE SAVE POINTER.
         LR    #15,#RC             PUT RETURN CODE INTO #15.
         RETURN (14,12),RC=(15)    RETURN.
         SPACE 5
ZILTCH   LA    #RC,4               ERROR EXIT;  DDNAME INVALID.
         L     #13,SAVE+4          RESTORE SAVE POINTER.
         LR    #15,#RC             PUT RETURN CODE INTO #15.
         L     14,12(13,0)
         LM    0,12,20(13)
         B     4(14)              SAS: EXIT FOR INVALID ARGUMENTS
         SPACE 3
KABOOM   LA    #RC,8               ERROR EXIT;  LRECL TOO SHORT.
         SR    #MVLENG,#MVLENG     CLEAR #MVLENG TO LIMIT RIPPLE.
         B     CLOSEUP             RETURN (AND CLOSE DCB).
         SPACE 5
BADRECFM LA    #RC,12              ERROR EXIT;  SET RETURN CODE.
         B     CLOSEUP             RETURN (AND CLOSE DCB).
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              SYMBOLIC REGISTER DESIGNATIONS                       *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 5
#0       EQU   0                   WORK REGISTER.
#1       EQU   1                   WORK REGISTER.
#PARM    EQU   2                   POINTER TO CHARACTER OF "BLOKHEAD"
*                                       PARAMETER CURRENTLY BEING
*                                       PROCESSED.
#COUNT   EQU   3                   LENGTH OF PARM FIELD YET TO BE
*                                       PROCESSED.
#OFFSET  EQU   4                   OFFSET IN BUFFER AT WHICH
*                                       BLOCK LETTERS SHOULD BE
*                                       GENERATED TO BE CENTERED.
#RC      EQU   4                   RETURN CODE FROM "BLOKHEAD".
#DIVIDND EQU   4                   HIGH HALF OF DIVIDEND IN DIVISION
*                                       OF #LINEMAX;  MUST BE AN
*                                       EVEN-NUMBERED REGISTER.
#LINEMAX EQU   #DIVIDND+1          CONTAINS MAXIMUM NUMBER OF
*                                       CHARACTERS WHICH MAY BE
*                                       OUTPUT BLOCK-FASHION ON A
*                                       LINE.
#DDNAME  EQU   6                   POINTER TO DDNAME CHARACTER IN
*                                       DCB BEING FILLED IN.
#MVLENG  EQU   6                   LRECL OF DCB MINUS 3.
#LIMIT   EQU   7                   POINTS TO LAST PARM CHARACTER
*                                       WHICH COULD CONTAIN A DDNAME
*                                       CHARACTER.
#LINECNT EQU   7                   CONTAINS NUMBER OF LINE: (1) FOR
*                                       PAGE OF STARS, NUMBER OF LINES
*                                       YET TO BE PRINTED.  (2) FOR
*                                       BLOCK LETTERS, NUMBER OF LINE
*                                       (1 THROUGH 12) BEING PRINTED.
#OUTAREA EQU   8                   POINTER TO OUTPUT BUFFER.
#DELIMTR EQU   9                   CONTAINS USER'S DELIMITER CHARACTER.
#CHAR    EQU   10                  CONTAINS CHARACTER FROM PARAMETER
*                                       CURRENTLY BEING PROCESSED.
#LENGTH  EQU   11                  LRECL OF DCB MINUS 1.
#CHARCNT EQU   12                  NUMBER OF CHARACTERS IN LINE AT
*                                       THIS TIME.
#13      EQU   13                  SAVE AREA POINTER/BASE REGISTER.
#15      EQU   15                  ENTRY POINT ADDRESS.
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              DATA AREA                                            *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 5
BLACKIND DS    0F                  FULLWORD CONTAINING
         DC    AL3(0),C'Ö'              THE CENT SIGN CHARACTER IN THE
*                                       LOW-ORDER BYTE.
LENGCNTR DC    F'0'                FULL WORD WHOSE TOP HALF CONTAINS
*                                       MAX LRECL FOR RECFM=V RECORDS
*                                       AND WITH LOWER HALF OF ZERO.
*                                       NOTE THAT ALL RECFM=V IN
*                                       "BLOKHEAD" ARE OUTPUT AT
*                                       MAXIMUM LENGTH.
STRINGLN DC    F'0'                LENGTH OF STRING INPUT TO
*                                       "IEFSD095".
LINENO   DC    F'0'                LINE NUMBER OF BLOCK LETTERS TO BE
*                                       GENERATED BY "IEFSD095".
PARM095  DS    0F                  PARAMETERS FOR "IEFSD095".
         DC    A(LINESPOT)              STRING TO BE TRANSLATED.
         DC    A(LINENO)                LINE NUMBER REQUIRED.
STRINGAD DC    A(0)                     RECEIVING AREA FOR OUTPUT.
         DC    A(STRINGLN)              LENGTH OF INPUT STRING.
         SPACE
LINESPOT DC    CL20'           '   AREA TO HOLD STRING FOR TRANSLATION.
         SPACE 3
         LTORG
         SPACE 3
NEXTCHK  CLI   1(#PARM),0          EXECUTED INSTRUCTION;  COMPARES THE
*                                       NEXT CHARACTER IN THE PARAMETER
*                                       WITH THE CHARACTER IN THE
*                                       EX REGISTER.
RIPPLE   MVC   2(,#OUTAREA),1(#OUTAREA)
*                                  EXECUTED INSTRUCTION;  FILLS THE
*                                       OUTPUT BUFFER WITH WHATEVER
*                                       CHARACTER IS IN THE FIRST
*                                       POSITION.
         SPACE 5
DCB      DCB   DSORG=PS,DDNAME=FT12F001,MACRF=(PL)
*                                  DCB TO BE HEADED.
         SPACE 5
         END
./       ADD   NAME=BLOCKSUB
BLOK TITLE '  "BLOCKSUB" -- BLOCK PAGE HEADER ROUTINE -- BY BARTH'
*  BLOCKSUB REMODIFIED FOR SUBROUTINE INTERFACE TO ASM,COBOL,F4
*  THE BLOCK CAN BE WRITTEN ANYWHERE ANYTIME AFTER THE SPECIFIED
*   DCB IS ALREADY OPENED BY CALLED PROGRAM.
*  R1 PARM MUST BE FORMATED AS:
*  +0  DCB ADDRESS
*  +4  PARM LENGTH
*  +6  PARM STRING FOLLOWING THIS DOCUMENTATION
*
*  DAVID RIKER 1/5/85
*  COMPUTER DATA SYSTEMS INC
*  ONE CURIE COURT
*  ROCKVILLE MD 20850
*  202-362-1160
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* *                                                               * *
* *                      " B L O K H E A D "                      * *
* *                                                               * *
* *                  BLOCK PAGE HEADER ROUTINE                    * *
* *                     BY C. WRANDLE BARTH                       * *
* *                 GODDARD SPACE FLIGHT CENTER                   * *
* *                         2 APRIL 1971                          * *
* *                                                               * *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 5
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                   *
*        "BLOKHEAD" IS A SHORT PROGRAM WHICH WILL PROVIDE BLOCK     *
*  LETTER HEADINGS ON A DATA SET USING THE MODIFIED "IEFSD095"*     *
*  ROUTINE TO GENERATE THE LETTERS.  IT IS PARTICULARLY USEFUL FOR  *
*  HEADING MICROFILM WITH IDENTIFYING FRAMES WHICH ARE READABLE     *
*  WITHOUT INSERTION INTO A VIEWER.                                 *
*                                                                   *
*        "BLOKHEAD" MAY BE INVOKED EITHER BY EXECUTE CARD OR IT     *
*  MAY BE LINKED TO DIRECTLY.  THE INFORMATION TO BE PRINTED IS     *
*  PASSED IN THE PARAMETER OF THE EXECUTE CARD IN THE FORM:         *
*                                                                   *
*        PARM='(DDNAME),AAA...AA,BBB...BB,CCC...CC,'                *
*                                                                   *
*  THE FIRST PARAMETER IS THE DDNAME OF THE DATA SET TO RECEIVE     *
*  THE HEADING.  IF PRESENT, IT MUST BE INCLOSED IN PARENTHESES.    *
*  IF OMITTED, "FT12F001" WILL BE ASSUMED.  THE REMAINING PARAMETERS*
*  ARE THE LINES TO BE PRINTED.  "BLOKHEAD" WILL ATTEMPT TO PUT     *
*  EACH PARAMETER ON A LINE BY ITSELF, BUT IF THE LINE WILL NOT     *
*  HOLD THE FULL PARAMETER, IT WILL BE SPLIT UP.  EACH LINE WILL    *
*  BE CENTERED ON THE PAGE.  THE PARAMETERS MAY CONTAIN ANY VALID   *
*  PN/QN CHAIN CHARACTER PLUS THE EXCLAMATION POINT AND CENT SIGN.  *
*  SINCE THE COMMA WAS USED ABOVE TO DELIMIT THE PARAMETERS, IT     *
*  MAY NOT BE A PART OF A PARAMETER;  HOWEVER, ANY CHARACTER (EXCEPT*
*  AN OPEN PARENTHESIS) MAY BE USED TO DELIMIT THE PARAMETER STRING.*
*  FOR EXAMPLE:                                                     *
*                                                                   *
*        PARM='(SYSUT1)/A,B,C/D,E,F/'                               *
*                                                                   *
*  COULD BE USED TO PRINT THE TWO LINES "A,B,C" AND "D,E,F".        *
*  TWO CONSECUTIVE DELIMITERS WILL CAUSE A PAGE EJECT.  IF A LINE   *
*  CONSISTS ONLY OF THE CENT SIGN CHARACTER, A FULL PAGE OF         *
*  ASTERISKS WILL BE PRINTED.  THE FINAL DELIMITER IS OPTIONAL.     *
*                                                                   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                   *
*        IF "BLOKHEAD" IS LINKED TO, THE SAME PARAMETER SHOULD BE   *
*  PROVIDED IN A FORMAT COMPATABLE TO THE EXEC CARD---THAT IS,      *
*  REGISTER 1 SHOULD POINT TO A HALF-WORD CHARACTER COUNT FOLLOWED  *
*  BY THE PARAMETER PROPER.                                         *
*                                                                   *
*        EXAMPLES:                                                  *
*                                                                   *
*        PARM='(DD1),NOW,IS,THE TIME,,FOR,ALL,GOOD,MEN...'          *
*                                                                   *
*  WOULD GIVE ON DD1...           NOW            FOR                *
*                                  IS            ALL                *
*                              THE TIME         GOOD                *
*                                               MEN...              *
*                                                                   *
*        PARM='/1234567890/0987654321/C/'                           *
*                                     ×                             *
*                                     CENT SIGN                     *
*                                                                   *
*  WOULD GIVE ON FT12F001...   1234567890      **********           *
*                              0987654321      **********           *
*                                              **********           *
*                                              **********           *
*                                                                   *
*  FOR REGULAR PRINTOUT, THE MAXIMUM NUMBER OF CHARACTERS PER LINE  *
*  IS 9 (132 CHARACTER LINE).  THE MAXIMUM NUMBER OF LINES PER      *
*  PAGE IS 4 (66 LINE PAGE).                                        *
*                                                                   *
*        "BLOKHEAD" IS REUSABLE.                                    *
*                                                           -CWB-   *
*                                                                   *
*  _______________                                                  *
*  *THE UNMODIFIED "IEFSD095" MAY BE USED, BUT IT ONLY HANDLES      *
*        LETTERS AND NUMBERS;  THE GODDARD MODIFIED VERSION ALSO    *
*        OUTPUTS ALL PN/QN CHARACTERS AND THE EXCLAMATION POINT     *
*        AND CENT SIGN.                                             *
*  _______________                                                  *
*  *UPDATED 19SEP83, WILLIAM SMITH, SYNTEX CORPORATION,             *
*        PALO ALTO, CALIFORNIA 94304 - (415) 852-1638               *
*                                                                   *
*  *THIS UTILITY HAS BEEN SUCCESSFULLY TESTED ON A MVS/SP 1.3.3     *
*        JES2 SYSTEM USING BOTH THE MODIFIED AND UNMODIFIED VER-    *
*        SIONS OF IEFSD095.  FOR MORE INFORMATION CONSULT "OS/VS2   *
*        MVS SYSTEM PROGRAMMING LIBRARY:  JOB MANAGEMENT", PUBLI-   *
*        CATION NO. GC28-0627-2, CHAPTER 10: EXTERNAL WRITERS.      *
*        NOTE THAT THE "VANILLA" VERSION OF IEFSD095 CONTINUES TO   *
*        ONLY SUPPORT BLOCK LETTERS (A TO Z), BLOCK NUMBERS (0 TO   *
*        9), A BLANK, AND THE NATIONAL CHARACTERS (#,@,$).          *
*                                                                   *
*  *THE IBM ROUTINE IEFSD095 IS REENTERABLE AND RESIDES IN THE      *
*        MODULE LIBRARY SYS1.AOSB0.                                 *
*                                                                   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         EJECT
BLOCKSUB CSECT
         ENTRY BLOCKSUB
         USING *,#15               PROVIDE TEMPORARY ADDRESSABILITY.
         SAVE  (14,12),,*          SAVE REGISTERS.
*        L     #PARM,0(#1)         GET ADDRESS OF PARAMETER.
         LR    #PARM,#1         GET ADDRESS OF PARAMETER.
         CNOP  0,4                 ADVANCE TO FULLWORD.
         BAL   #1,LINKUP           GET ADDRESS OF SAVE AREA.
SAVE     DC    18F'0'              REGISTER SAVE AREA.
LINKUP   ST    #13,SAVE+4          CROSS-LINK SAVE AREAS.
         ST    #1,8(#13)
         LR    #13,#1              POINT TO NEW SAVE AREA.
         DROP  #15                 USE #13 AS NEW BASE
         USING SAVE,#13                 REGISTER.
         SR    #COUNT,#COUNT       CLEAR COUNTS
         L     #15,0(#PARM)        PICK DCB ADDRESS
         ST    #15,DCBADR          SAVE DCB ADDRESS
         LA    #PARM,4(#PARM)      BUMP OVER WORD BOUNDARY
         LH    #COUNT,0(#PARM)     PICK UP LENGTH OF PARM.
         LA    #PARM,2(#PARM)      ADVANCE TO BEGINNING OF PARM.
*                                  SET DEFAULT DDNAME.
         CLI   0(#PARM),C'('       DOES PARM BEGIN WITH "("?
         BNE   OPENIT              IF NOT, GO OPEN DCB.
         BCTR  #COUNT,0            COUNT OFF "(".
         LA    #DDNAME,DCB+40      POINT TO RECEIVING FIELD FOR DDNAME.
         MVI   DCB+40,C' '         CLEAR OUT OLD DDNAME.
         MVC   DCB+41(7),DCB+40    CLEAR IT ALL OUT.
         LA    #LIMIT,8(#PARM)     POINT TO 8 CHARACTERS FROM NOW.
         SPACE
NEXTONE  LA    #PARM,1(#PARM)      ADVANCE TO NEXT CHARACTER.
         CLI   0(#PARM),C')'       IS THIS THE ")"?
         BE    STEP1               IF SO, BRANCH.
         CR    #PARM,#LIMIT        HAVE WE PASSED 8 CHARACTERS?
         BH    ZILTCH              IF SO, OOPS;  BRANCH.
         IC    #1,0(#PARM)         PICK UP CHARACTER AND
         STC   #1,0(#DDNAME)            PUT IT INTO DCB.
         LA    #DDNAME,1(#DDNAME)  POINT TO NEXT DDNAME CHARACTER.
         BCT   #COUNT,NEXTONE      LOWER PARM COUNT AND CONTINUE.
         B     ZILTCH              RUNNING OUT OF PARM HERE IS A GOOF.
         SPACE 3
STEP1    LA    #PARM,1(#PARM)      ADVANCE PAST ")".
         BCT   #COUNT,OPENIT       DOWN COUNT AND GO OPEN DCB.
         B     ZILTCH              IF #COUNT GOES ZERO HERE, BRANCH.
         SPACE 5
OPENIT   L     #5,DCBADR          GET DCB ADDRESS DOR
*OPENIT   OPEN  (DCB,OUTPUT)        OPEN THE DCB.
*        TM    36(#5),B'00000010'  DOES THE DATA SET USE MACHINE
*        BO    BADRECFM                 CONTROL?  IF SO, BRANCH.
*        PUT   (#5)                FIRST PUT TO GET FIRST BUFFER.
         L     #0,BUFSIZE
         GETMAIN R,LV=(0)
         ST    #1,BUFADR
         LR    #OUTAREA,#1         GET ADDRESS OF FIRST BUFFER.
         SR    #DELIMTR,#DELIMTR   CLEAR REGISTER FOR IC INSTRUCTIONS.
         SR    #CHAR,#CHAR         DITTO.
         IC    #DELIMTR,0(#PARM)   GET DELIMITER.
         LH    #LENGTH,82(#5)      GET DCB'S LRECL.
         CH    #LENGTH,=H'131'                                  .DOR
         BNH   LENGTHOK                                         .DOR
         LA    #LENGTH,131 DEFAULT LENGTH FOR OUTPUT BLOCKS     .DOR
LENGTHOK TM    36(#5),B'10000000'  IS THE RECFM V?
         BO    CALCMAX             IF NOT, BRANCH.
         STH   #LENGTH,LENGCNTR    PUT TRUE MAX LRECL INTO FULL WORD'S
*                                       HIGH END FOR USE AS VARIABLE
*                                       LENGTH RECORD CONTROL WORD.
         MVC   0(4,#OUTAREA),LENGCNTR
*                                  STORE IT INTO RECORD BUFFER.
*                                       NOTE THAT ALL RECFM=V IN
*                                       "BLOKHEAD" ARE OUTPUT AT
*                                       MAXIMUM LENGTH.
         LA    #1,4                GET A 4.
         AR    #OUTAREA,#1         ADVANCE PAST CONTROL WORD.
         SR    #LENGTH,#1          DECREASE #LENGTH BY 4.
*                                  NOW CONTINUE PROCESSING AS FOR
*                                       RECFM F OR U.
CALCMAX  LA    #LINEMAX,1(#LENGTH) LRECL INCLUDES CONTROL CHARACTER;
*                                       PUT LRECL - 1 (CONTROL CH.)
*                                       + 2 INTO #LINEMAX.
*                                       (THE +2 IS FOR THE TWO SEPARA-
*                                       TING BLANKS BETWEEN CHARACTERS
*                                       WHICH NEED NOT FOLLOW LAST
*                                       CHARACTER.)
         SR    #DIVIDND,#DIVIDND   CLEAR PRECEDING EVEN REGISTER FOR
*                                       DIVISION.
         D     #DIVIDND,=F'14'     DIVIDE BY 14 TO GET NUMBER PER LINE
*                                       IN #LINEMAX.
         LTR   #LINEMAX,#LINEMAX   IS THERE ENOUGH ROOM FOR AT LEAST
*                                       ONE?
         BZ    KABOOM              IF NOT, BRANCH.
         C     #LINEMAX,=F'20'     IS THE LINE LONGER THAN 20 BLOCK
*                                       CHARACTERS LONG?
         BNH   SETLENG             IF NOT, BRANCH.
         L     #LINEMAX,=F'20'     ELSE, LIMIT LINES TO 20 CHARACTERS.
SETLENG  BCTR  #LENGTH,0           DECREASE 1 FOR CARRIAGE CONTROL.
         LR    #MVLENG,#LENGTH     COPY INTO #MVLENG.
         BCTR  #MVLENG,0           DECREASE 1 SINCE "RIPPLE" DOESN'T
*                                       MOVE TO FIRST CHARACTER OF
*                                       RECORD.
         BCTR  #MVLENG,0           DECREASE 1 FOR EX INSTRUCTIONS.
         B     NEXTPAGE            GO SET PAGE EJECTION.
         SPACE 5
NXSTRING SR    #CHARCNT,#CHARCNT   NOTE THAT 0 CHARACTERS ARE ON THIS
*                                       LINE SO FAR.
         IC    #CHAR,0(#PARM)      PICK UP NEXT PARM CHARACTER.
         CR    #CHAR,#DELIMTR      IS THIS LINE OF LENGTH ZERO?
         BNE   BLACKCHK            IF NOT, BRANCH.
NEXTPAGE MVI   0(#OUTAREA),C'1'   SET TO EJECT PAGE.
         B     BUMPER              GO ADVANCE TO NEXT CHARACTER.
         SPACE 5
BLACKCHK C     #CHAR,BLACKIND      IS THIS CHARACTER A CENT SIGN?
         BNE   GATHER              IF NOT, GO COLLECT LINE.
         LA    #1,1                PICK UP A 1.
         CR    #COUNT,#1           IS THAT WHAT #COUNT IS (IS THE
*                                       CENT SIGN THE LAST CHARACTER)?
         BE    ALLSTAR             IF SO, BRANCH.
         EX    #DELIMTR,NEXTCHK    IS IT FOLLOWED BY A DELIMITER?
*                                       NOTE THAT:
*                                       NEXTCHK CLI 1(#PARM),0
         BNE   GATHER              IF NOT, BRANCH.
ALLSTAR  LA    #LINECNT,60         WE WILL MAKE 60 LINES.
         MVI   0(#OUTAREA),C' '    START ON NEW PAGE.
FILLPAGE MVI   1(#OUTAREA),C'*'    INSERT STAR INTO BUFFER.
         EX    #MVLENG,RIPPLE      FILL LINE WITH STARS.
*                                       NOTE THAT:
*                                       RIPPLE MVC 2(,#OUTAREA),
*                                                    1(#OUTAREA)
         STM   1,14,SAVEPUT
         L     #6,BUFADR
         L     #5,DCBADR          GET DCB ADDRESS DOR
         PUT   (#5),(#6)          OUTPUT LINE OF STARS.
         L     #OUTAREA,BUFADR RESET TO FIRST BYTE OF BUFFER
         TM    36(#5),B'10000000'  IS THIS A VARIABLE LENGTH RECORD?
         BO    SNGLSPCE            IF NOT, BRANCH.
         MVC   0(4,#OUTAREA),LENGCNTR
*                                 SET CONTROL WORD INTO BUFFER.
         LA    #OUTAREA,4(#OUTAREA)
*                                  ADVANCE PAST CONTROL WORD.
SNGLSPCE EQU   *
         LM    1,14,SAVEPUT
         MVI   0(#OUTAREA),C' '    SINGLE SPACE THIS LINE.
         BCT   #LINECNT,FILLPAGE   LOOP TILL PAGE FULL.
         LA    #PARM,1(#PARM)      ADVANCE TO DELIMITER AFTER
         BCT   #COUNT,NEXTPAGE          CENT SIGN, DOWN COUNT, AND
*                                       BRANCH.
         B     GOODOUT             IF THAT'S ALL THE PARM, BRANCH OUT.
         SPACE 5
NEXTSYM  IC    #CHAR,0(#PARM)      ADD ANOTHER CHARACTER TO THIS
*                                       LINE AS FOLLOWS:  GET
*                                       NEXT PARM CHARACTER.
         CR    #CHAR,#DELIMTR      IS IT A DELIMITER?
         BE    OUTLINE             IF SO, GO OUTPUT LINE.
GATHER   STC   #CHAR,LINESPOT(#CHARCNT)
*                                  STORE THIS CHARACTER INTO LINE'S
*                                       ACCUMULATION AREA.
         LA    #CHARCNT,1(#CHARCNT)
*                                  INCREASE CHARACTER COUNT.
         CR    #CHARCNT,#LINEMAX   IS THE LINE FULL?
         BNL   DELCHK              IF SO, BRANCH.
         LA    #PARM,1(#PARM)      ELSE ADVANCE TO NEXT CHARACTER.
         BCT   #COUNT,NEXTSYM      DOWN COUNT AND GO GET NEXT SYMBOL
*                                       (CHARACTER).  IF PARM IS ALL
*                                       DONE, FALL THROUGH TO:
JIMMY    LA    #COUNT,1            RESET COUNT TO 1 SO THAT
*                                       BCT INSTRUCTION AT "BUMPER"
*                                       WILL ALSO FALL THROUGH.
         B     OUTLINE             GO OUTPUT LAST LINE.
         SPACE 5
DELCHK   EX    #DELIMTR,NEXTCHK    IS THE NEXT CHARACTER A DELIMITER?
         BNE   OUTLINE             IF NOT, BRANCH.
         LA    #PARM,1(#PARM)      ELSE, IGNORE DELIMITER.
         BCT   #COUNT,OUTLINE      DOWN COUNT AND GO OUTPUT.
         B     JIMMY               PARM SHOULDN'T END HERE (IF IT DOES
*                                       THAT DELIMITER WE SAW WAS
*                                       GARBAGE);  BUT BRANCH TO
*                                       KEEP THINGS SAFE.
         SPACE 5
OUTLINE  LR    #OFFSET,#LENGTH     GET LENGTH OF LINE (EXCLUDING
*                                       CARRIAGE CONTROL).
         LR    #0,#CHARCNT         GET NUMBER OF BLOCKS TO BE PRINTED.
         MH    #0,=H'14'           MULTIPLY BY 14--NUMBER OF CHARACTERS
*                                       IN EACH BLOCK (12) PLUS NUMBER
*                                       OF SPACES BETWEEN BLOCKS (2).
*                                       NOTE THAT THIS PRODUCT IS TOO
*                                       BIG BY 2--THE SPACES AFTER THE
*                                       LAST BLOCK.
         SR    #OFFSET,#0          SUBTRACT PRODUCT FROM LINE LENGTH
*                                       GIVING NUMBER OF BYTES NOT
*                                       USED MINUS 2.
         SRA   #OFFSET,1           DIVIDE BY 2 FOR HALF PAGE.
         A     #OFFSET,=F'2'       ADD 2;  1 FOR THE EXCESS MENTIONED
*                                       ABOVE AND 1 SINCE WE START AT
*                                       AN OFFSET OF 1 NOT ZERO IN
*                                       THE BUFFER.
         ST    #CHARCNT,STRINGLN   STORE LENGTH OF DATA STRING FOR
*                                       "IEFSD095".
         SR    #LINECNT,#LINECNT   CLEAR #LINECNT FOR LOOP.
         SPACE
LOOP095  LA    #1,PARM095          POINT TO "IEFSD095" PARMS.
         LA    #LINECNT,1(#LINECNT)
*                                  ADVANCE TO NEXT LINE IN BLOCK.
         ST    #LINECNT,LINENO     STORE LINE NUMBER FOR "IEFSD095".
         LR    #0,#OFFSET          COPY OFFSET INTO #0.
         AR    #0,#OUTAREA         ADD ADDRESS OF START OF BUFFER.
         ST    #0,STRINGAD         STORE INTO "IEFSD095" PARM AS
*                                       ADDRESS TO RECEIVE STRING.
         MVI   1(#OUTAREA),C' '    CLEAR OUT OUTPUT BUFFER.
         EX    #MVLENG,RIPPLE      CLEAR IT ALL THE WAY OUT.
*                                       NOTE:  RIPPLE MVC
*                                            2(,#OUTAREA),1(#OUTAREA)
         CALL  EALSDW95            CREATE LINE FOR BLOCK LETTERS.
         STM   1,14,SAVEPUT
         L     #6,BUFADR
         L     #5,DCBADR          GET DCB ADDRESS DOR
         PUT   (#5),(#6)           OUTPUT LINE.
         L     #OUTAREA,BUFADR RESET TO FIRST BYTE OF BUFFER
         TM    36(#5),B'10000000'  IS THIS A VARIABLE LENGTH RECORD?
         BO    READYNXT            IF NOT, BRANCH.
         MVC   0(4,#OUTAREA),LENGCNTR
*                                 SET CONTROL WORD INTO BUFFER.
         LA    #OUTAREA,4(#OUTAREA)
*                                  ADVANCE PAST CONTROL WORD.
READYNXT EQU   *
         LM    1,14,SAVEPUT
         MVI   0(#OUTAREA),C' '    SINGLE SPACE NEXT LINE.
         C     #LINECNT,=F'12'     HAS THE LAST LINE BEEN OUTPUT?
         BNE   LOOP095             IF NOT, BRANCH.
         MVI   0(#OUTAREA),C'-'    DOUBLE SPACE NEXT LINE.
         SPACE
BUMPER   LA    #PARM,1(#PARM)      POINT TO NEXT CHARACTER.
         BCT   #COUNT,NXSTRING     DOWN COUNT AND BRANCH IF MORE
*                                       TO DO.
GOODOUT  SR    #RC,#RC             NORMAL EXIT;  CLEAR RETURN CODE.
         SPACE 3
CLOSEUP  MVI   0(#OUTAREA),C' '    CLEAR OUT LAST BUFFER SO THAT
         MVI   1(#OUTAREA),C' '         CLOSE WILL PRINT ONLY
         EX    #MVLENG,RIPPLE           A BLANK LINE.
         L     #6,BUFADR
         L     #0,BUFSIZE
         FREEMAIN R,LV=(0),A=(6)
#        CLOSE DCB                 CLOSE DCB.
         SPACE
LEAVE    L     #13,SAVE+4          RESTORE SAVE POINTER.
         LR    #15,#RC             PUT RETURN CODE INTO #15.
         RETURN (14,12),RC=(15)    RETURN.
         SPACE 5
ZILTCH   LA    #RC,4               ERROR EXIT;  DDNAME INVALID.
         L     #13,SAVE+4          RESTORE SAVE POINTER.
         LR    #15,#RC             PUT RETURN CODE INTO #15.
         L     14,12(13,0)
         LM    0,12,20(13)
         B     4(14)              SAS: EXIT FOR INVALID ARGUMENTS
         SPACE 3
KABOOM   LA    #RC,8               ERROR EXIT;  LRECL TOO SHORT.
         SR    #MVLENG,#MVLENG     CLEAR #MVLENG TO LIMIT RIPPLE.
         B     CLOSEUP             RETURN (AND CLOSE DCB).
         SPACE 5
BADRECFM LA    #RC,12              ERROR EXIT;  SET RETURN CODE.
         B     CLOSEUP             RETURN (AND CLOSE DCB).
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              SYMBOLIC REGISTER DESIGNATIONS                       *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 5
#0       EQU   0                   WORK REGISTER.
#1       EQU   1                   WORK REGISTER.
#PARM    EQU   2                   POINTER TO CHARACTER OF "BLOKHEAD"
*                                       PARAMETER CURRENTLY BEING
*                                       PROCESSED.
#COUNT   EQU   3                   LENGTH OF PARM FIELD YET TO BE
*                                       PROCESSED.
#OFFSET  EQU   4                   OFFSET IN BUFFER AT WHICH
*                                       BLOCK LETTERS SHOULD BE
*                                       GENERATED TO BE CENTERED.
#RC      EQU   4                   RETURN CODE FROM "BLOKHEAD".
#DIVIDND EQU   4                   HIGH HALF OF DIVIDEND IN DIVISION
*                                       OF #LINEMAX;  MUST BE AN
*                                       EVEN-NUMBERED REGISTER.
#LINEMAX EQU   #DIVIDND+1          CONTAINS MAXIMUM NUMBER OF
*                                       CHARACTERS WHICH MAY BE
*                                       OUTPUT BLOCK-FASHION ON A
*                                       LINE.
#5       EQU   5                   WORK REGISTER.   DOR
#6       EQU   6                   WORK REGISTER.   DOR
#DDNAME  EQU   6                   POINTER TO DDNAME CHARACTER IN
*                                       DCB BEING FILLED IN.
#MVLENG  EQU   6                   LRECL OF DCB MINUS 3.
#LIMIT   EQU   7                   POINTS TO LAST PARM CHARACTER
*                                       WHICH COULD CONTAIN A DDNAME
*                                       CHARACTER.
#LINECNT EQU   7                   CONTAINS NUMBER OF LINE: (1) FOR
*                                       PAGE OF STARS, NUMBER OF LINES
*                                       YET TO BE PRINTED.  (2) FOR
*                                       BLOCK LETTERS, NUMBER OF LINE
*                                       (1 THROUGH 12) BEING PRINTED.
#OUTAREA EQU   8                   POINTER TO OUTPUT BUFFER.
#DELIMTR EQU   9                   CONTAINS USER'S DELIMITER CHARACTER.
#CHAR    EQU   10                  CONTAINS CHARACTER FROM PARAMETER
*                                       CURRENTLY BEING PROCESSED.
#LENGTH  EQU   11                  LRECL OF DCB MINUS 1.
#CHARCNT EQU   12                  NUMBER OF CHARACTERS IN LINE AT
*                                       THIS TIME.
#13      EQU   13                  SAVE AREA POINTER/BASE REGISTER.
#14      EQU   14                  WORKING REGISTER  DOR
#15      EQU   15                  ENTRY POINT ADDRESS.
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              DATA AREA                                            *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 5
         DS    0F
SAVEPUT  DC    18F'0'
BUFSIZE  DC    AL1(1),AL3(4096) ESTABLISH SUBPOOL AREA SIZE
DCBADR   DC    F'0'                FULL WORD POINTING DCB FROM CALLED
*                                  PROGRAM
BUFADR   DC    F'0'                FULL WORD POINTING BUFFER
BLACKIND DS    0F                  FULLWORD CONTAINING
         DC    AL3(0),C'Ö'              THE CENT SIGN CHARACTER IN THE
*                                       LOW-ORDER BYTE.
LENGCNTR DC    F'0'                FULL WORD WHOSE TOP HALF CONTAINS
*                                       MAX LRECL FOR RECFM=V RECORDS
*                                       AND WITH LOWER HALF OF ZERO.
*                                       NOTE THAT ALL RECFM=V IN
*                                       "BLOKHEAD" ARE OUTPUT AT
*                                       MAXIMUM LENGTH.
STRINGLN DC    F'0'                LENGTH OF STRING INPUT TO
*                                       "IEFSD095".
LINENO   DC    F'0'                LINE NUMBER OF BLOCK LETTERS TO BE
*                                       GENERATED BY "IEFSD095".
PARM095  DS    0F                  PARAMETERS FOR "IEFSD095".
         DC    A(LINESPOT)              STRING TO BE TRANSLATED.
         DC    A(LINENO)                LINE NUMBER REQUIRED.
STRINGAD DC    A(0)                     RECEIVING AREA FOR OUTPUT.
         DC    A(STRINGLN)              LENGTH OF INPUT STRING.
         SPACE
LINESPOT DC    CL20'           '   AREA TO HOLD STRING FOR TRANSLATION.
         SPACE 3
         LTORG
         SPACE 3
NEXTCHK  CLI   1(#PARM),0          EXECUTED INSTRUCTION;  COMPARES THE
*                                       NEXT CHARACTER IN THE PARAMETER
*                                       WITH THE CHARACTER IN THE
*                                       EX REGISTER.
RIPPLE   MVC   2(,#OUTAREA),1(#OUTAREA)
*                                  EXECUTED INSTRUCTION;  FILLS THE
*                                       OUTPUT BUFFER WITH WHATEVER
*                                       CHARACTER IS IN THE FIRST
*                                       POSITION.
         SPACE 5
DCB      DCB   DSORG=PS,DDNAME=FT12F001,MACRF=(PL)
*                                  DCB TO BE HEADED.
         SPACE 5
         END
./       ADD   NAME=BLOKTST2
//JOBSAST JOB (XXXXX,,99),'SAS BLOCKHEAD TEST',
//         MSGCLASS=A,CLASS=A
//*
//*****************************************************************
//* COMMENTS: DAVE RIKER/ COMPUTER DATA SYSTEMS INC/ 9 JAN 1985
//* APPLICATIONS: SAS
//*
//* IN SAS, "BLOKHEAD" MAY BE INVOKED  BY USING "CALL" STATEMENT.   *
//* THE INFORMATION TO BE PRINTED IS                                *
//* PASSED IN THE STRING  OF THE VARIABLE IN THE FORM:              *
//*                                                                 *
//*      LENGTH STR $ 50;                                           *
//*      STR='(DDNAME),AAA...AA,BBB...BB,CCC...CC,';               *
//*      CALL BLOKHEAD(STR);                                        *
//*                                                                 *
//* THE FIRST STRING IS THE DDNAME OF THE DATA SET TO RECEIVE       *
//* THE HEADING. IF PRESENT, IT MUST BE INCLOSED IN PARENTHESES.    *
//* IF OMITTED, "FT12F001" WILL BE ASSUMED. THE REMAINING STRINGS*
//* ARE THE LINES TO BE PRINTED. "BLOKHEAD" WILL ATTEMPT TO PUT     *
//* EACH STRING ON A LINE BY ITSELF, BUT IF THE LINE WILL NOT       *
//* HOLD THE FULL STRING, IT WILL BE SPLIT UP. EACH LINE WILL       *
//* BE CENTERED ON THE PAGE. THE STRINGS MAY CONTAIN ANY VALID      *
//* PN/QN CHAIN CHARACTER PLUS THE EXCLAMATION POINT AND CENT SIGN. *
//* SINCE THE COMMA WAS USED ABOVE TO DELIMIT THE STRINGS, IT       *
//* MAY NOT BE A PART OF A STRING; HOWEVER, ANY CHARACTER (EXCEPT*
//* AN OPEN PARENTHESIS) MAY BE USED TO DELIMIT THE STRING STRING.*
//* FOR EXAMPLE:                                                    *
//*                                                                 *
//*      STR='(SYSUT1)/A,B,C/D,E,F/'                               *
//*                                                                 *
//* COULD BE USED TO PRINT THE TWO LINES "A,B,C" AND "D,E,F".       *
//* TWO CONSECUTIVE DELIMITERS WILL CAUSE A PAGE EJECT. IF A LINE   *
//* CONSISTS ONLY OF THE CENT SIGN CHARACTER, A FULL PAGE OF        *
//* ASTERISKS WILL BE PRINTED. THE FINAL DELIMITER IS OPTIONAL.     *
//*                                                                 *
//*                                                                 *
//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
//*                                                                 *
//*      EXAMPLES:                                                  *
//*                                                                 *
//*      STR='(DD1),NOW,IS,THE TIME,,FOR,ALL,GOOD,MEN...';          *
//*                                                                 *
//* WOULD GIVE ON DD1...          NOW            FOR                *
//*                                IS            ALL                *
//*                            THE TIME         GOOD                *
//*                                             MEN...              *
//*                                                                 *
//*      STR='/1234567890/0987654321/C/';                          *
//*                                   ×                             *
//*                                   CENT SIGN                     *
//*                                                                 *
//* WOULD GIVE ON FT12F001...  1234567890      **********           *
//*                            0987654321      **********           *
//*                                            **********           *
//*                                            **********           *
//*                                                                 *
//* FOR REGULAR PRINTOUT, THE MAXIMUM NUMBER OF CHARACTERS PER LINE *
//* IS 9 (132 CHARACTER LINE). THE MAXIMUM NUMBER OF LINES PER      *
//* PAGE IS 4 (66 LINE PAGE).                                       *
//*                                                                 *
//*  RECFM MUST BE "A" OR "M" TO SUPPORT PRINTER CONTROL CHARACTER. *
//*  FT12F001 OR DDNAME SHOULD HAVE DCB SPECIFICATIONS LIKE:        *
//*    DCB=(RECFM=FBA,LRECL133,BLKSIZE=1330).                       *
//*                                                                 *
//*  THE BLOKHEAD DO NOT HAVE PAGE EJECT CONTROL CHARACTER. IT IS
//*  THE RESPONSIBILITY FOR THE SAS USER TO USE "PUT _PAGE_;".
//*******************************************************************
//SASX EXEC SAS,REGION=2000K,OPTIONS='LINESIZE=132,NODATE'
//SAS.STEPLIB DD DSN=SYS3.SAS.V824.LIBRARY,DISP=SHR
//            DD DSN=SYS1.PLIXLIB,UNIT=3350,VOL=SER=PPVOL1,DISP=SHR
//  DD DSN=C6000A.DOR.LINKLIB2,DISP=SHR,UNIT=3350,VOL=SER=VTAM01
//            DD DISP=(OLD,PASS),DSN=*.LIBRARY,VOL=REF=*.LIBRARY
//SAS.FT12F001 DD SYSOUT=A,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330)
//SYSIN     DD  *
OPTIONS   PS=60 SKIP=0 NODATE S=72 ERROR=3 ;
DATA _NULL_; * PRINT BANNERS;
OPTIONS MISSING=' ';
**  DEFINE INPUT FILE;
DO DATE=85001 TO 85366 BY 30;
LENGTH STR $ 20;
LENGTH YEAR $ 4;
LENGTH DAYN $ 2;
DATEX=DATEJUL(DATE);
DAYN=DAY(DATEX); * PUT PAGE BANNER ON SYSOUT FOR EASIER READING;
MONTH=MONTH(DATEX);YEAR=YEAR(DATEX);
IF MONTH = 1       THEN STR='/' ×× DAYN ×× '/JANUARY/'×× YEAR ×× '/';
 ELSE IF MONTH = 2 THEN STR='/' ×× DAYN ×× '/FEBRUARY/' ×× YEAR ×× '/';
 ELSE IF MONTH = 3 THEN STR='/' ×× DAYN ×× '/MARCH/'   ×× YEAR ×× '/';
 ELSE IF MONTH = 4 THEN STR='/' ×× DAYN ×× '/APRIL/'  ×× YEAR ×× '/';
 ELSE IF MONTH = 5 THEN STR='/' ×× DAYN ×× '/MAY/'    ×× YEAR ×× '/';
 ELSE IF MONTH = 6 THEN STR='/' ×× DAYN ×× '/JUNE/'   ×× YEAR ×× '/';
 ELSE IF MONTH = 7 THEN STR='/' ×× DAYN ×× '/JULY/'   ×× YEAR ×× '/';
 ELSE IF MONTH = 8 THEN STR='/' ×× DAYN ×× '/AUGUST/' ×× YEAR ×× '/';
ELSE IF MONTH = 9 THEN STR='/' ×× DAYN ×× '/SEPTEMBER/' ×× YEAR ×× '/';
 ELSE IF MONTH = 10 THEN STR='/' ×× DAYN ×× '/OCTOBER/' ×× YEAR ×× '/';
ELSE IF MONTH = 11 THEN STR='/' ×× DAYN ×× '/NOVEMBER/' ×× YEAR ×× '/';
ELSE IF MONTH = 12 THEN STR='/' ×× DAYN ×× '/DECEMBER/' ×× YEAR ×× '/';
FILE PRINT NOTITLES;
PUT _PAGE_;
CALL BLOKHEAD(STR);
END;
./       ADD   NAME=DISASMX
DIS      TITLE '***** DISASSEMBLY PHASE 0 *****'
         MACRO
&NAME    SVLNK &REG1,&REG2,&REG4,&REG3,&IND,&LV=
         GBLC  &EQU
         GBLC  &GM
         GBLC  &CSECT
         LCLC  &REGA
         AIF   (T'&NAME EQ 'O').NOCSECT
         AIF   ('&NAME' EQ '*').NOCSECT
&CSECT   SETC  '&NAME'
&CSECT   CSECT 
         AGO   .RST
.NOCSECT ANOP
&CSECT   SETC  '*'
         CSECT 
.RST     ANOP
         AIF   ('&EQU' EQ 'ON').NRQ
&EQU     SETC  'ON'
*
***REGISTER EQUATES***
*
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
.NRQ     ANOP
*
*******************  PROGRAM INITIALIZATION  *************************
*
         AIF   (T'&REG1 EQ 'O').NOREG
&REGA    SETC  '&REG1'
         AIF   (T'&REG2 EQ 'O').ONEREG
         AIF   (T'&REG4 EQ 'O').TWOREG
         USING &CSECT,&REGA,&REG2,&REG4 ESTABLISH ADDRESSABILITY
         AGO   .BYUSE
.TWOREG  USING &CSECT,&REGA,&REG2 
         AGO   .BYUSE
.NOREG   ANOP
&REGA    SETC  'R3'
.ONEREG  USING &CSECT,&REGA 
.BYUSE   ANOP
         STM   R14,R12,12(R13) :       STORE REGS IN HIGH SAVE AREA
         LR    &REGA,R15 
         AIF   (T'&REG2 EQ 'O').NOLA
         LA    &REG2,4095(&REGA) 
         LA    &REG2,1(&REG2) 
         AIF   (T'&REG4 EQ 'O').NOLA
         LA    &REG4,4095(&REG2) 
         LA    &REG4,1(&REG4) 
.NOLA    ANOP
         AIF   (T'&REG3 EQ 'O').NOLNK
         L     &REG3,0(R1) 
.NOLNK   ANOP
         AIF (T'&IND EQ 'O').GETIT
         CNOP  0,4
         BAL   R15,SAVEAREA+72 
SAVEAREA DS    18F 
         ST    R15,8(R13)
         ST    R13,SAVEAREA+4
         LR    R13,R15
         AGO   .NOSAVE
.GETIT   ANOP
         AIF   (T'&LV EQ 'O').GMD
&GM      SETC  '&LV'
         AGO   .DGM
.GMD     ANOP
&GM      SETC  '72'
.DGM     ANOP
*
***GET MAIN STORAGE FOR SAVE AREA***
*
         AIF   ('&GM' LT '4096').LA
         GETMAIN R,LV=&GM 
         AGO   .EGM
.LA      ANOP
         LA    R0,&GM                  GET &GM BYTES
         GETMAIN R,LV=(0)
.EGM     ANOP
*
***SET UP SAVE AREA POINTERS***
*
         ST    R1,8(R13) 
         ST    R13,4(R1) 
         LR    R13,R1 
         AIF   (T'&REG3  NE 'O').NOSAVE
         L     R1,4(R13) 
         L     R1,24(R1) 
.NOSAVE  ANOP
         AIF   ('&CSECT' EQ '*').EXIT
         B     *+12
         DC    CL8'&CSECT'  
.EXIT    ANOP
*
*********************  END INITIALIZATION  ***************************
*
         MEND
         EJECT
DISASM   SVLNK R3,R4,R5
*        PRINT NOGEN
*DISASSEMBLER PROGRAM TO CREATE AN ASSEMBLER SOURCE PROGRAM
*FROM A LOAD MODULE IN A PDS. DD CARDS REQUIRED INCLUDE
*SYSPRINT FOR MESSAGES AND DIAGNOSTICS USING BLKSIZE A MULTIPLE
*OF 121, SYSLIB SPECIFYING THE PDS CONTAINING THE MEMBER,        FIX***
*WHICH MUST BE A PDS, SYSPUNCH FOR THE ASSEMBLER SOURCE
*PROGRAM, HAVING BLKSIZE A MULTIPLE OF 80, AND SYSIN
*FOR THE CONTROL CARD INPUT. CONTROL INPUT MAY OPTIONALLY
*BE ENTERED VIA THE PARM ON THE EXECUTE CARD. CONTROL
*INFORMATION INCLUDES THE MEMBER NAME AND CSECT NAME
*TO BE DISASSEMBLED. IF CSECT NAME IS OMITTED, THE CSECT
*FOR ESD-ID 0001 WILL BE USED.
*
*
* FILES USED BY THIS PROGRAM INCLUDE THE FOLLOWING:
*
* DDNAME SYSLIB: RECFM=U. INPUT LOAD MODULE LIBRARY.
*
* DDNAME SYSPUNCH: RECFM=FB,LRECL=80. OUTPUT FILE CONTAINING
*                 DISASSEMBLED TEXT. (MAXBLK=18,960)
*
* DDNAME SYSPRINT: RECFM=FBA,LRECL=121.  PRINTED OUTPUT CONTAINING A
*                LIST OF THE ESD TABLE, RLD TABLE, AND TEXT.
*                (MAXBLK=18997)
* DDNAME LOADLIB: (OPTIONAL) NAMES A PDS CONTAINING THE
*                 MODULES OF DISASM IF DIFFERENT FROM
*                 THE STEPLIB. USED PRIMARILY FOR TSO.
*
* DDNAME SYSIN: RECFM=FB, LRECL=80. CONTROL CARD INPUT.
*
*
* THE CONTROL CARD PROVIDES THE MEMBER NAME AND CSECT NAME
* OF THE PROGRAM TO BE DISASSEMBLED. MEMBER NAME IS REQUIRED.
* IF CSECT NAME IS OMITTED, THE CSECT WITH ESDID 0001 WILL
* BE USED. FORMAT IS FREE-FORM. MEMBER NAME MUST PRECEDE CSECT
* NAME. ANY NUMBER OF BLANKS MAY PRECEDE AND FOLLOW MEMBER NAME.
* A COMMA MAY IMMEDIATELY FOLLOW MEMBER NAME IF DESIRED.
*
*
* PARM DATA FROM THE EXECUTE CARD MAY BE USED TO SPECIFY
* VALIDITY OF PRIVILEGED OR FLOATING POINT INSTRUCTIONS.
* IF NOT SPECIFIED, PRIVILEGED AND FLOATING POINT OPERATION
* CODES WILL NOT BE TREATED AS INSTRUCTION OP-CODES. TO
* INCLUDE THESE INSTRUCTIONS, CODE:
*     PARM=(SUPVR)      PRIVILEGED INSTRUCTIONS
*     PARM=(FLTPT)      FLOATING POINT INSTRUCTIONS
*     PARM=(SUPVR,FLTPT) BOTH
*
*
*PROCESSING FLOW:
* 1. PROCESS THE CONTROL INFORMATION TO OBTAIN THE MEMBER
*    AND CSECT NAMES.
* 2. ISSUE BLDL AGAINST SYSLIB TO OBTAIN DIRECTORY INFO FOR
*    THE MEMBER SPECIFIED. IF THE SPECIFIED MEMBER IS AN
*    ALIAS, RE-ISSUE A BLDL FOR THE REAL MEMBER. PRINT
*    DIRECTORY INFORMATION.
* 3. POINT TO THE MEMBER IN THE SYSLIB PDS, AND PROCESS THE
*    MEMBER. LOAD MODULES CONTAIN AN EXTERNAL SYMBOL DICTIONARY
*    FOLLOWED BY TEXT AND RELOCATION DICTIONARY INFORMATION.
*    ALL ESD INFO FOR THE MODULE PRECEDES THE FIRST CONTROL
*    RECORD. A CONTROL RECORD PRECEDES EACH BLOCK OF TEXT.
*    RLD INFO FOR THE TEXT FOLLOWS EACH TEXT BLOCK. PROCESSING
*    OF LOAD MODULE INFORMATION IS AS FOLLOWS:
*    A. BUILD AN EXTERNAL SYMBOL TABLE, USING THE CESD BLOCKS.
*    B. SEARCH FOR THE DESIRED CSECT AS THE TABLE IS BEING
*       BUILT. THIS CSECT MUST BE FOUND BEFORE THE FIRST
*       CONTROL RECORD.
*    C. READ BLOCKS UNTIL A CONTROL RECORD FOR THE DESIRED
*       CSECT IS FOUND (BY ESD-ID). WHEN FOUND, SAVE THE
*       TEXT FOR DISASSEMBLY, AND USE THE FOLLOWING RLD
*       INFORMATION TO BUILD A RELOCATION DICTIONARY TO BE USED
*       DURING DISASSEMBLY.
* 4. DISASSEMBLY USES THE EXTERNAL SYMBOL TABLE, RELOCATION
*    DICTIONARY, AND TEXT BUILT BY THE PREVIOUS STEPS.
*
*
* AUTHOR R THORNTON - NOV 1977
*
*
****************************************************************
*                                                              *
* PROCESS THE PARM FIELD, IF ANY.                              *
*                                                              *
****************************************************************
*
         L     R12,0(R1)               GET PARM FIELD ADDRESS
         SR    R1,R1                   CLEAR WORK REG
         ICM   R1,3,0(R12)             PICK UP PARM LENGTH
         BZ    OPENS                   NO PARM INFO ENTERED
         CH    R1,H5                   5-BYTES OF PARM
         BE    SGLPARM                 YES, SINGLE PARM FIELD
         CH    R1,H11                  11-BYTES OF PARM
         BE    DBLPARM                 YES, BOTH PARMS
BADPARM  WTO   'INVALID PARM, SPECIFY ONLY SUPVR AND/OR FLTPT',        X
               ROUTCDE=11
         ABEND 777,DUMP,STEP
SGLPARM  CLC   2(5,R12),=C'SUPVR'      IS PARM=SUPVR
         BE    SUPARM                  YES
         CLC   2(5,R12),=C'FLTPT'      PARM IS FLTPT
         BNE   BADPARM                 NO, ERROR
         MVI   FLPTASM,1               SET FLOATING POINT O.K.
         B     OPENS                   CONTINUE
DBLPARM  CLC   2(5,R12),=C'SUPVR'      IS 1ST PARM SUPVR
         BE    CK2FPT                  YES
         CLC   2(5,R12),=C'FLTPT'      IS 1ST PARM FLTPT
         BNE   BADPARM                 NO, ERROR
         CLC   8(5,R12),=C'SUPVR'      IS 2ND PARM SUPVR         FIX***
         BNE   BADPARM                 NO, ERROR
         B     FPT2PARM                BOTH O.K.
CK2FPT   CLC   8(5,R12),=C'FLTPT'      IS 2ND PARM FLTPT         FIX***
         BNE   BADPARM                 YES
FPT2PARM MVI   FLPTASM,1               SET FLOATING POINT O.K.
SUPARM   MVI   PRIVASM,1               SET PRIVILEGED INSTR O.K.
OPENS    RDJFCB LOADLIB                WAS LOADLIB DD CARD INCLUDED
         LTR   R15,R15                 JFCB READ O.K.
         BNZ   OPEN1                   NO, DONT OPEN
         OPEN  LOADLIB                 GOT DD CARD, OPEN FILE
*
****************************************************************
*                                                              *
* GET STORAGE FOR THE SYMBOL TABLE, RLD TABLE, AND DATA-ONLY   *
* TABLES, AND OPEN FILES.                                      *
*                                                              *
****************************************************************
*
OPEN1    OPEN  (SYSPRINT,OUTPUT,SYSPUNCH,OUTPUT)
         OPEN  (SYSLIB,,SYSIN)         OPEN FILES
         TM    SYSIN+48,X'10'          DID SYSIN OPEN O.K.
         BZ    NOCTL                   NO
RESETX   BAL   R9,GETCTL               EXTRACT DESIRED MEMBER AND CSECT
         BAL   R9,BLDL                 ISSUE BLDL AND PRINT
         MVI   CCAT,0                  INSURE TTR0
         POINT SYSLIB,TTRMOD           POINT TO 1ST BLOCK OF MODULE
         MVC   BUFFLEN,SYSLIB+62       GET BLOCKSIZE
         L     R0,BUFFER               GET SP 200 OF BLOCKSIZE
         GETMAIN R,LV=(0)              GET BLOCKSIZE AREA
         ST    R1,BUFAD                SAVE BUFFER ADDRESS
         L     R0,BUFFER               GET SP 200 OF BLOCKSIZE
         GETMAIN R,LV=(0)              GET BLOCKSIZE AREA
         ST    R1,BUFAD3               SAVE BUFFER ADDRESS
         SR    R0,R0
         ICM   R0,7,TOTVIRT            GET MAX MODULE SIZE
         C     R0,=F'32767'            MAX FOR HALFWORD VALUE
         BH    BIGMODX
         STH   R0,MODLEN
         L     R0,MODAREA
         GETMAIN R,LV=(0)              GET MODULE AREA
         ST    R1,BUFAD2               SAVE MODULE ADDRESS
         B     MODOK
BIGMODX  ST    R0,BIGMOD+4             REPLACE GETMAIN SIZE
BIGMOD   GETMAIN R,LV=40000            LARGER THAN 32767 BYTES
         ST    R1,BUFAD2               SAVE MODULE ADDRESS
MODOK    GETMAIN R,LV=38000            GET SYMBOL TABLE STORAGE
         ST    R1,SYMTBAD              SAVE SYMBOL TABLE ADDRESS
         ST    R1,CURRSYM              SAVE CURRENT SYMBOL ADDR
         MVI   0(R1),X'FF'             TABLE END INDIC
         A     R1,ENDSYML              COMPUTE END ADDR
         ST    R1,ENDSYM               STORE TBL END ADDR
         GETMAIN R,LV=60000            GET RLD TABLE STORAGE
         ST    R1,RLDTBL               SAVE RLD TABLE ADDRESS
         ST    R1,CURRLD               SAVE CURRENT RLD ADDR
         MVI   0(R1),X'FF'             TABLE END INDIC
         A     R1,ENDRLDL              COMPUTE END ADDR
         ST    R1,ENDRLD               STORE TBL END ADDR
         GETMAIN R,LV=1544             GET DATA ONLY TABLE STORAGE
         ST    R1,DATONLY              SAVE TBL ADDRESS
         MVC   0(3,R1),HIVAL           SET END VALUE
         ST    R1,DATOCUR              SET CURRENT ADDRESS
         A     R1,ENDATO               COMPUTE TABLE END ADDR
         ST    R1,DATOEND              SAVE END ADDR
         MVC   PRT+15(29),=C'*** EXTERNAL SYMBOL TABLE ***'
         MVI   PCC,C'-'                SET SKIP 3 LINES
         BAL   R9,PRINT                PRINT
         MVC   PRTLINE,SYMHDR          SYM TBL HEADER
         BAL   R9,PRINT                PRINT
        CALL  TRACE
*
*
*
****************************************************************
*                                                              *
* MAINLINE PROCESSING FOR THE LOAD MODULE. THE DIRECTORY ENTRY *
* AND TEXT ARE PROCESSED.                                      *
*                                                              *
****************************************************************
*
MAINLINE EQU   *                       MAINLINE ROUTINE
         L     R6,BUFAD                GET BUFFER ADDRESS
         READ  DECB,SF,SYSLIB,(6),'S'  READ BLOCK FROM MEMBER
         CHECK DECB                    AWAIT COMPLETION
         CLI   0(R6),X'20'             CESD RECORD
         BNE   TESTOTHR                NO
         BAL   R9,CESDREC              PROCESS CESD RECORDS
         B     MAINLINE                GO READ AGAIN
TESTOTHR LA    R9,CNTLRECS             ASSUME CONTROL RECORD
         CLI   0(R6),1                 IT IS CONTROL
         BE    PERFORM                 YES
         CLI   0(R6),5                 IS IT CONTROL
         BE    PERFORM                 YES
         CLI   0(R6),13                IS IT CONTROL
         BE    PERFORM                 YES
         LA    R9,RLDRECS              ASSUME RLD RECORD
         CLI   0(R6),2                 IS IT RLD
         BE    PERFORM                 YES
         CLI   0(R6),6                 IS IT RLD
         BE    PERFORM                 YES
         CLI   0(R6),14                IS IT RLD
         BE    PERFORM                 YES
         LA    R9,CTRLRECS             ASSUME CONTROL AND RLD
         CLI   0(R6),3                 IS IT CTL AND RLD
         BE    PERFORM                 YES
         CLI   0(R6),7                 IS IT CTL AND RLD
         BE    PERFORM                 YES
         CLI   0(R6),15                IS IT CTL AND RLD
         BE    PERFORM                 YES
         B     MAINLINE                NONE OF THESE, SKIP
PERFORM  TM    PROCESS,X'80'           WAS CSECT FOUND
         BZ    MISSCS                  NO, ERROR
         BALR  R9,R9                   PERFORM APPROPRIATE ROUTINE
         TM    PROCESS,X'40'           MODULE PROCESSING DONE
         BZ    MAINLINE                NO, GO READ AGAIN
         MVI   EOFSW+1,0               SET END OF FILE SWITCH
         B     ENDINIT                 GO COMPLETE PROCESSING
*
*
RESET    EQU   *      RESET THE WHOLE THING IN STORAGE
         L     R12,BUFAD
         FREEMAIN  R,A=(12),LV=20000
         L     R7,SYMTBAD
RESETNXT CLI   0(R7),X'FF'            END OF SYMBOL TABLE?
         BE    RESETEND
         USING SYMTBL,R7
         CLI   TYPSYM,X'00'
         BE    RESETCSD
NXTCESD  LA    R7,L'SYMENT(R7)
         B     RESETNXT
RESETCSD L     R12,STXTSTRT
         L     R2,SLENGTH
         FREEMAIN R,A=(12),LV=(2)
         B     NXTCESD
RESETEND EQU   *
         L     R12,SYMTBAD
         FREEMAIN R,A=(12),LV=ENDSYML
         L     R12,RLDTBL
         FREEMAIN R,A=(12),LV=ENDRLDL
         L     R12,DATONLY
         FREEMAIN R,A=(12),LV=1544
         B     RESETX
*
*
*
****************************************************************
*                                                              *
* PROCESS LOAD MODULE CONTROL RECORDS. THESE RECORDS PRECEDE   *
* TEXT RECORDS, WHICH ARE READ AND PLACED IN STORAGE IN CONTIG-*
* UOUS LOCATIONS SO THAT THE TEXT FOR THE DESIRED CSECT WILL   *
* ALL BE IN STORAGE FOR THE REMAINDER OF DISASSEMBLY.          *
*                                                              *
****************************************************************
*
CNTLRECS EQU   *                       CONTROL RECORD PROCESSING
         ST    R9,CT9                  SAVE RETURN ADDR
         SR    R8,R8                   CLEAR WORK
         ICM   R8,7,9(R6)              LKED ASGND @ OF TXT
         ST    R8,MODSIZE              BEGIN OF MODULE ADDRESS
         TM    0(R6),X'08'             RECORD PRECEDES LAST RECORD OF M
         BZ    CNCKTYP                 NO
         OI    PROCESS,X'40'           YES, SHOW PROCESSING COMPLETE
CNCKTYP  TM    0(R6),X'02'             CONTROL AND RLD
         BO    CNPASRLD                YES
         LA    R12,16(R6)              @ CESD ENTRY NBR
         B     CNCKESD                 CONTINUE
CNPASRLD LH    R12,6(R6)               GET RLD SECTION LENGTH
         LA    R12,16(R6,R12)          @ CESD ENTRY NBR
CNCKESD  LH    R11,4(R6)               LENGTH OF CONTROL INFO SECTION
         SRL   R11,2                   COMPUTE NBR CNTL ENTRIES
         ST    R11,SAVER11             SAVE # OF CNTL
         SR    R10,R10                 OFFSET TO 1ST BYTE
         ST    R10,CSLNGTH
         SR    R9,R9                   LENGTH OF TEXT
CNCKESD1 EQU   *
         CLI   ALLSWT,X'FF'            DISASM ALL CSECTS
         BE    CNFNDXX
         CLC   ESDID,0(R12)            THIS THE DESIRED ESD   FIX***
         BE    CNFNDIT                 YES
         AH    R10,2(R12)              MAINTAIN OFFSET TO 1ST TEXT BYTE
         LA    R12,4(R12)              TO NEXT CNTL ENTRY
         BCT   R11,CNCKESD1            LOOP THRU CNTL ENTRIES  FIX***
         B     READTEXT                GO READ FOLLOWING TEXT
CNFNDIT  LH    R9,2(R12)               GET TEXT LENGTH
READTEXT READ  DECB,SF,,(6),MF=E       READ FOLLOWING TEXT RECORD
         CHECK DECB                    AWAIT COMPLETION
         LTR   R9,R9                   DOES IT CONTAIN DESIRED TEXT
         BZ    CTXIT                   NO, SKIP IT
         S     R8,START                (-) OFFSET IN MODULE    FIX***
         AR    R8,R10                  ADD OFFSET OF PORTION IN RCD  **
*           R8 SHOULD NOW CONTAIN THE OFFSET WITHIN THE CSECT
*           THAT THIS BLOCK CONTAINS (TRICKY).
*
         A     R10,BUFAD               @ 1ST TEXT BYTE
***      S     R8,START    MOVED UP    RELATIVIZE TEXT ADDR    FIX***
         A     R8,TXTSTRT              @ PLACE TO MOVE TEXT
         LR    R11,R9                  COPY LENGTH TO MOVE
         MVCL  R8,R10                  MOVE TEXT TO STORAGE
CTXIT    L     R9,CT9                  GET RETURN ADDR
         BR    R9                      EXIT
CNFNDXX  EQU   * BUILT ALL CSECTS OF MEMBER
         ST    R12,SAVER12
         LH    R9,2(R12)               GET TEXT LENGTH
         L     R6,BUFAD3
READTXT  READ  DECB,SF,,(6),MF=E       READ FOLLOWING TEXT RECORD
         CHECK DECB                    AWAIT COMPLETION
         LTR   R9,R9                   DOES IT CONTAIN DESIRED TEXT
         BZ    CTXIT                   NO, SKIP IT
ESDBEG   L     R7,SYMTBAD
         MVI   ESDSWT,X'00'
         USING SYMTBL,R7
ESDNXT   CLC   SYMESDID,0(R12)
         BE    FINDESD
         LA    R7,L'SYMENT(R7)
         CLI   0(R7),X'FF'
         BE    MISSCSTX
         B     ESDNXT
MISSCSTX MVC   0(2,12),=X'0002' DEFAULT ESDID IF NO CSECTS FOUND
         CLI   ESDSWT,X'00'
         BNE   MISSCST         SECOND TIME NO CSECTS
         MVI   ESDSWT,X'FF'
         B     ESDBEG          TRY ONE MORE
FINDESD  EQU   *
         ST    R11,SAVER11
         LH    R9,2(R12)
         LTR   R9,R9
         BZ    CXIT
         SR    R11,R11
         ICM   R11,7,SYMADDR
         SR    R8,R8                   BEGIN OF TEXT ADDRESS
         AR    R8,R11                      OFFSET IN MODULE
         L     R10,CSLNGTH            TEXT LENGTH
*           R8 SHOULD NOW CONTAIN THE OFFSET WITHIN THE CSECT
*           THAT THIS BLOCK CONTAINS (TRICKY).
*
         A     R10,BUFAD3              @ 1ST TEXT BYTE OF INPUT
         A     R8,BUFAD2               @ PLACE OF MODULE TO MOVE TEXT
         ST    R8,STXTSTRT         CSECT START ADDRESS
         ST    R8,STXTCURR
         LR    R11,R9                  COPY LENGTH TO MOVE
         MVCL  R8,R10                  MOVE TEXT TO STORAGE
         L     R10,CSLNGTH
         L     R8,STXTSTRT
         SR    R9,R9
         LH    R9,2(R12)            TOTAL OF CSECT SIZE
         AR    R9,R8
         ST    R9,STXTEND           CSECT END ADDRESS
CXIT     AH    R10,2(R12)
         ST    R10,CSLNGTH
         LA    R12,4(R12)
         L     R11,SAVER11
         BCT   R11,ESDBEG
         B     CTXIT
*
*
*
****************************************************************
*                                                              *
* PROCESS RLD RECORDS. A TABLE OF RLD DATA IS BUILT WHICH WILL *
* LATER BE USED TO BUILD PROGRAM LABELS AND ADCONS.            *
*                                                              *
****************************************************************
*
RLDRECS  EQU   *                       RLD RECORD PROCESSING
         TM    0(R6),X'08'             LAST RECORD OF MODULE
         BZ    RLSV9                   NO
         OI    PROCESS,X'40'           SHOW PROCESSING COMPLETE
RLSV9    ST    R9,RL9                  SAVE RETURN ADDR
RLDSW    NOP   RLDST                   FIRST TIME SWITCH
         MVI   RLDSW+1,C'0'            RESET 1ST TIME SW
         MVC   PRT+15(20),=C'***** RLD INFO *****'
         MVI   PCC,C'-'                SKIP 3 LINES
         BAL   R9,PRINT                PRINT
         MVC   PRTLINE,RLDHDR          RLD HEADER
         BAL   R9,PRINT                PRINT RLD HEADER
RLDST    LH    R8,6(R6)                NBR BYTES OF RLD DATA
         LA    R6,16(R6)               @ 1ST BYTE OF RLD DATA
         AR    R8,R6                   END OF RLD DATA ADDR
         L     R7,CURRLD               @ NEXT RLD TBL ENTRY
         USING RLDTBLD,R7
         LH    R10,0(R6)               RELOCATION POINTER
         LH    R11,2(R6)               POSITION POINTER
         LA    R6,4(R6)                PASS POINTERS
RLDNXT   EQU   *
         CLI   ALLSWT,X'FF' DISASM ALL CSECTS
         BE    RLDACPT
         CLC   1(3,R6),START+1         RLD ADDR BELOW CSECT
         BL    RLDSTEP                 LOW, IGNORE
         CLC   1(3,R6),END+1           RLD ADDR ABOVE CSECT
         BH    RLDSTEP                 HIGH, IGNORE
RLDACPT  C     R7,ENDRLD               END OF RLD TBL
         BE    RLDFULL                 YES, ERROR
         STH   R10,RLDRP               SAVE RELOC PTR
         STH   R11,RLDPP               POS PTR
         PACK  RLDTYPE,0(1,R6)         INVERT FLAG BYTE
         NI    RLDTYPE,X'0F'           CLEAR HI-ORDER
         CLI   RLDTYPE,9               UNRESOLVED
         BNE   RLDMOVLN                NO
         MVI   RLDTYPE,8               YES, USE PREFERRED VALUE
RLDMOVLN MVC   RLDLEN,0(R6)            FLAG BYTE
         NI    RLDLEN,X'0F'            CLEAR HI-ORDER
         SR    R12,R12                 CLEAR WORK
         IC    R12,RLDLEN              PICK UP BYTE
         SRL   R12,2                   SHIFT OUT DIR, IND BITS
         LA    R12,1(R12)              ADD 1 = LENGTH
         STC   R12,RLDLEN              LENGTH CODE
         MVI   RLDDIR,C'+'             ASSUME POS RELOC
         TM    0(R6),2                 IS IT POSITIVE
         BZ    RLADMV                  YES
         MVI   RLDDIR,C'-'             NO, SHOW NEGATIVE
RLADMV   SR    R1,R1                   CLEAR WORK REG
         ICM   R1,7,1(R6)              PICK UP ADDRESS
         CLI   ALLSWT,X'FF'
         BE  RLAESD
         S     R1,START                RELATIVIZE WITHIN CSECT
RLAESD   STCM  R1,7,RLDADDR            SAVE RELATIVE ADDRESS
         LA    R12,RLDRP               @ RELOC PTR
         BAL   R9,HEXPRT2              CONVERT
         MVC   PRT+6(4),PRTABL         RELOC PTR
         LA    R12,RLDPP               @ POS PTR
         BAL   R9,HEXPRT2              CONVERT
         MVC   PRT+14(4),PRTABL        POS PTR
         MVC   PRT+24(4),=C'ACON'      ASSUME A TYPE ADCON
         CLI   RLDTYPE,0               IS IT ADCON
         BE    RLDLN                   YES
         MVC   PRT+24(4),=C'VCON'      ASSUME VCON
         CLI   RLDTYPE,1               IS IT VCON
         BE    RLDLN                   YES
         MVC   PRT+22(6),=C'PRDISP'    ASSUME PSEUDO REG DISPL
         CLI   RLDTYPE,2               IS IT P.R. DISPL
         BE    RLDLN                   YES
         MVC   PRT+22(6),=C'PRCUM'     ASSUME PSEUDO REG CUMUL DISPL
         CLI   RLDTYPE,3               IS IT P.R. CUM DISPL
         BE    RLDLN                   YES
         MVC   PRT+21(10),=C'UNRESOLVED' ASSUME UNRESOLVED
         CLI   RLDTYPE,8               IS IT UNRESOLVED
         BE    RLDLN                   YES
         MVC   PRT+21(10),BLANX        CLEAR FIELD
         MVC   PRT+24(3),=C'??:'
         LA    R12,RLDTYPE             @ TYPE
         BAL   R9,HEXPRT1              CONVERT
         MVC   PRT+27(1),PRTABL+1      TYPE
RLDLN    MVC   PRT+35(1),RLDLEN        LENGTH
         OI    PRT+35,C'0'             CLEAR ZONE
         MVC   PRT+42(1),RLDDIR        RELOCATION DIRECTION
         LA    R12,RLDADDR             @ ADDRESS
         BAL   R9,HEXPRT3              CONVERT
         MVC   PRT+46(6),PRTABL        ADDRESS
         XC    RLDNAME(9),RLDNAME      CLEAR
         LH    R15,RLDRP               GET RELOCATION POINTER
         BCTR  R15,R0                  DEDUCT 1
         LTR   R15,R15                 TEST DIFFERENCE
         BM    RLPRT                   NEG, ERROR
         MH    R15,SYMLEN              TIMES SYM TBL ENTRY LENG
         A     R15,SYMTBAD             @ ESD SYMBOL TBL ENTRY
         C     R15,CURRSYM             PAST END OF TABLE
         BH    RLPRT                   YES, ERROR
         USING SYMTBL,R15
         MVC   RLDNAME,EXTSYM          ESD SYMBOL TO RLD TBL ENTRY
         MVC   RLDESDTP,TYPSYM         ESD TYPE TO RLD ENTRY
         DROP  R15
         MVC   PRT+60(8),RLDNAME       NAME TO PRINT
         MVC   PRT+70(2),=C'LR'        ASSUME LR
         CLI   RLDESDTP,3              IS IT LR
         BE    RLPRT                   YES
         MVC   PRT+70(2),=C'SD'        ASSUME SD
         CLI   RLDESDTP,0              IS IT SD
         BE    RLPRT                   YES
         MVC   PRT+70(2),=C'ER'        ASSUME ER
         CLI   RLDESDTP,2              IS IT ER
         BE    RLPRT                   YES
         MVC   PRT+70(2),=C'PC'        ASSUME PC
         CLI   RLDESDTP,4              IS IT PC
         BE    RLPRT                   YES
         MVC   PRT+70(2),=C'PR'        ASSUME PR
         CLI   RLDESDTP,6              IS IT PR
         BE    RLPRT                   YES
         MVC   PRT+70(2),=C'CM'        ASSUME CM
         CLI   RLDESDTP,5              IS IT CM
         BE    RLPRT                   YES
         MVC   PRT+70(2),=C'WX'        ASSUME WX
         CLI   RLDESDTP,X'0A'          IS IT WX
         BE    RLPRT                   YES
         MVC   PRT+70(4),=C'NULL'      ASSUME NULL
         CLI   RLDESDTP,7              IS IT NULL
         BE    RLPRT                   YES
         MVC   PRT+70(6),=C'E/STAB'    ASSUME E/STAB
         CLI   RLDESDTP,X'0F'          IS IT E/STAB
         BE    RLPRT                   YES
         MVC   PRT+70(6),=C'??????'    UNKNOWN YPE
RLPRT    BAL   R9,PRINT                PRINT
         CLI   ALLSWT,X'FF'            DISASM ALL CSECT
         BE    ALLRLD
         CLC   RLDNAME,CSECT           RLD NAME IS CSECT NAME
         BNE   GOODRLD                 NO
ALLRLD   CLC   RLDADDR,XZROS           RELATIVE OFFSET IS ZERO
         BE    RLDSTEP                 YES, IGNORE ENTRY
GOODRLD  LA    R7,L'RLDENT(R7)         TO NEXT TBL ENTRY
RLDSTEP  TM    0(R6),1                 NEXT ITEM HAS REL AND POS PTRS
         BO    RLSAME                  NO
         LH    R10,4(R6)               PICK UP NEW REL PTR
         LH    R11,6(R6)               PICK UP NEW POS PTR
         LA    R6,4(R6)                STEP OVER 4 BYTES
RLSAME   LA    R6,4(R6)                TO NEXT RLD ITEM
         CR    R6,R8                   END OF RLD DATA
         BL    RLDNXT                  NO
         MVI   0(R7),X'FF'             SET TBL END INDIC
         ST    R7,CURRLD               SET NEW CURRENT ADDRESS
         L     R9,RL9                  GET RETURN ADDR
         BR    R9                      EXIT
         DROP  R7
*
*
*
****************************************************************
*                                                              *
* PROCESS CONTROL AND RLD RECORDS. THESE RECORDS CONTAIN BOTH  *
* RLD AND CONTROL INFORMATION, AND ARE PROCESSED BY BOTH       *
* THE RLDRECS AND CNTLRECS ROUTINES.                           *
*                                                              *
****************************************************************
*
CTRLRECS EQU   *                       CONTROL AND RLD RECORDS
         ST    R9,CR9                  SAVE RETURN ADDR
         BAL   R9,RLDRECS              PROCESS RLD DATA
         L     R6,BUFAD                RESET BUFFER ADDRESS
         BAL   R9,CNTLRECS             PROCESS CONTROL DATA
         L     R9,CR9                  GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
*
*
*
****************************************************************
*                                                              *
* PROCESS COMPOSITE ESD RECORDS. DATA FROM THESE RECORDS IS    *
* PLACED IN THE SYMBOL TABLE, AND IS USED TO CREATE PROGRAM    *
* ENTRY STATEMENTS, AND TO IDENTIFY THE NAMES OF EXTERNAL      *
* SYMBOLS USED BY THE PROGRAM.                                 *
*                                                              *
****************************************************************
*
CESDREC  EQU   *                       CESD RECORD PROCESSING
         ST    R9,CES9                 SAVE RETURN
         L     R7,CURRSYM              GET SYMBOL TBL ADDR
         USING SYMTBL,R7
         LH    R10,4(R6)               GET ESD ID OF 1ST ITEM
         LH    R8,6(R6)                NBR BYTES OF ESD DATA
         SRL   R8,4                    COMPUTE NBR ENTRIES
         LA    R6,8(R6)                STEP TO 1ST RECORD ESD ITEM
CESDNXT  C     R7,ENDSYM               END OF TABLE
         BNL   SYMFULL                 YES, ERROR
         MVC   EXTSYM,0(R6)            SYMBOL NAME
         MVC   TYPSYM,8(R6)            TYPE
         NI    TYPSYM,X'0F'            CLEAR BITS 0-3
         MVC   SYMIND,8(R6)            INDICATOR BYTE
         NI    SYMIND,X'0F'            CLEAR BITS 4-7
         TM    8(R6),X'14'             POSSIBLE ENTAB/SEGTAB
         BNO   CEMVAD                  NO
         TM    8(R6),X'03'             IS IT ENTAB/SEGTAB
         BNZ   CEMVAD                  NO
         MVC   TYPSYM(2),=X'0F00'      SHOW ENTAB/SEGTAB
CEMVAD   MVC   SYMADDR,9(R6)           ADDRESS OF SYMBOL
         MVC   SYMSEG,12(R6)           SEGMENT WHERE DEFINED
         MVC   SYMLENG,13(R6)          LENGTH OR LR ESD ID
         STCM  R10,3,SYMESDID          ESD ID
         MVC   PRT+5(8),EXTSYM         SYMBOL NAME
         MVC   PRT+20(2),=C'SD'        ASSUME SD
         CLI   TYPSYM,0                IS IT SD
         BE    CEPIND                  YES
         MVC   PRT+20(2),=C'LR'        ASSUME LR
         CLI   TYPSYM,3                IS IT LR
         BE    CEPIND                  YES
         MVC   PRT+20(2),=C'ER'        ASSUME ER
         CLI   TYPSYM,2                IS IT ER
         BE    CEPIND                  YES
         MVC   PRT+20(2),=C'PC'        ASSUME PC
         CLI   TYPSYM,4                IS IT PC
         BE    CEPIND                  YES
         MVC   PRT+20(2),=C'PR'        ASSUME PR
         CLI   TYPSYM,6                IS IT PR
         BE    CEPIND                  YES
         MVC   PRT+20(2),=C'CM'        ASSUME CM
         CLI   TYPSYM,5                IS IT CM
         BE    CEPIND                  YES
         MVC   PRT+20(2),=C'WX'        ASSUME WX
         CLI   TYPSYM,X'0A'            IS IT WX
         BE    CEPIND                  YES
         MVC   PRT+19(4),=C'NULL'      ASSUME NULL
         CLI   TYPSYM,7                IS IT NULL
         BE    CEPIND                  YES
         MVC   PRT+18(6),=C'E/STAB'    ASSUME ENTAB/SEGTAB
         CLI   TYPSYM,X'0F'            IS IT ENTAB/SEGTAB
         BE    CEPIND                  YES
         MVC   PRT+18(4),=C' ??: '     UNIDENTIFIABLE TYPE
         LA    R12,TYPSYM              @ TYPE
         BAL   R9,HEXPRT1              CONVERT
         MVC   PRT+23(2),PRTABL        TYPE
CEPIND   LA    R12,SYMIND              @ INDICATOR
         BAL   R9,HEXPRT1              CONVERT
         MVC   PRT+27(1),PRTABL        INDICATOR
         LA    R12,SYMADDR             @ SYMBOL ADDR
         BAL   R9,HEXPRT3              CONVERT
         MVC   PRT+30(6),PRTABL        SYMBOL ADDR
         LA    R12,SYMSEG              @ SEGMENT NBR
         BAL   R9,HEXPRT1              CONVERT
         MVC   PRT+39(2),PRTABL        SEGMENT NBR
         CLI   TYPSYM,2                IS IT ER
         BE    CEESD                   YES
         CLI   TYPSYM,3                IS IT AN LR
         BNE   CENOTLR                 NO
         LA    R12,SYMLRID             @ LR ESD ID
         BAL   R9,HEXPRT2              CONVERT
         MVC   PRT+43(4),PRTABL        LR ESD ID
         B     CEESD                   CONTINUE
CENOTLR  LA    R12,SYMLENG             @ LENGTH
         BAL   R9,HEXPRT3              CONVERT
         MVC   PRT+49(6),PRTABL        SYMBOL LENGTH
CEESD    LA    R12,SYMESDID            @ ESD ID
         BAL   R9,HEXPRT2              CONVERT
         MVC   PRT+57(4),PRTABL        ESD ID
         TM    PROCESS,X'80'           FOUND CSECT
         BO    CSGOTCX                 YES
         CLI   TYPSYM,0                SD
         BE    CECKCSB                 YES
         CLI   TYPSYM,4                PC
         BNE   CESDPT                  NO
CECKCSB  EQU   *
         CLC   CSECT,BLANX             ANY CSECT NAME ENTERED
         BNE   CECKNM                  YES
         MVC   CSECT,EXTSYM            NAME TO CSECT
         B     CSGOTCS                 CONTINUE
CECKNM   CLI   TYPSYM,4                PC
         BE    CESDPT                  YES
         CLI   ALLSWT,X'FF'            DISASM ALL CSECT
         BE    CSGOTCX
         CLC   CSECT,EXTSYM            FOUND DESIRED NAME
         BNE   CESDPT                  NO
         TM    PROCESS,X'80'           ALREADY FOUND CSECT
         BZ    CSGOTCS                 NO
         MVC   PRT+15(2),=C'??'        SHOW DUPL
         B     CESDPT                  CONTINUE
CSGOTCS  OI    PROCESS,X'80'           SHOW CSECT FOUND
         MVC   PRT+15(2),=C'**'        FLAG ON PRINTOUT
         MVC   ESDID,SYMESDID          SAVE ESD ID FOUND
         MVC   START+1,SYMADDR         SAVE CSECT START ADDR
         MVC   LENGTH+1(3),SYMLENG     SAVE CSECT LENGTH
         MVC   SSTART+1,SYMADDR         SAVE CSECT START ADDR
         MVC   SLENGTH+1(3),SYMLENG     SAVE CSECT LENGTH
         L     R1,LENGTH               PICK UP LENGTH
         A     R1,START                COMPUTE CSECT END ADDR
         ST    R1,END                  SAVE CSECT END ADDR
         ST    R1,SEND                  SAVE CSECT END ADDR
         L     R11,LENGTH              TEXT LENGTH
         LA    R11,256(R11)            ADD FOR SAFETY
         GETMAIN R,LV=(11)             GET STORAGE FOR TEXT
         ST    R1,TXTSTRT              SAVE TEXT ADDR
         ST    R1,STXTSTRT              SAVE TEXT ADDR
         SH    R11,H256                DEDUCT SAFETY FACTOR
         AR    R1,R11                  TXT END ADDR
         ST    R1,TXTEND               SAVE TEXT END ADDR
         ST    R1,STXTEND               SAVE TEXT END ADDR
CESDPT   BAL   R9,PRINT                PRINT
         LA    R7,L'SYMENT(R7)         TO NEXT TBL ENTRY LOCATION
         LA    R10,1(R10)              ADD 1 TO ESD COUNTER
         LA    R6,16(R6)               TO NEXT ESD ITEM IN INPUT
         BCT   R8,CESDNXT              LOOP THRU INPUT RECORD
         MVI   0(R7),X'FF'             SET END OF TABLE INDIC
         ST    R7,CURRSYM              SAVE NEXT TABLE ADDR
         L     R9,CES9                 GET RETURN ADDR
         BR    R9                      EXIT
CSGOTCX  EQU   *
         CLI   TYPSYM,0                SD
         BNE   CESDPT                  YES
         MVC   SSTART+1,SYMADDR         SAVE CSECT START ADDR
         MVC   SLENGTH+1(3),SYMLENG     SAVE CSECT LENGTH
         L     R1,SLENGTH               PICK UP LENGTH
         A     R1,SSTART                COMPUTE CSECT END ADDR
         ST    R1,SEND                  SAVE CSECT END ADDR
         B     CESDPT
         DROP  R7
*
*
*
****************************************************************
*                                                              *
* ISSUE BLDL FOR THE MAIN MODULE, AND PRINT MODULE RELATED INFO*
*                                                              *
****************************************************************
*
BLDL     EQU   *                       ISSUE BLDL AND PRINT INFO
         ST    R9,BL9                  SAVE RETURN ADDR
ISSBLDL  BLDL  SYSLIB,BLDLIST          ISSUE BLDL
         LTR   R15,R15                 ANY ERRORS
         BNZ   MISSMEM                 YES
         LA    R1,MEMBER+35            END OF BASIC PORTION
         TM    ATTR2,X'10'             SSI PRESENT
         BZ    BLREFA1                 NO
         LA    R1,4(R1)                ADD FOR SSI
BLREFA1  TM    ALIASIND,X'80'          ALIAS
         BZ    BLREFA2                 NO
         LA    R1,11(R1)               ADD FOR ALIAS
BLREFA2  TM    ATTR1A,X'04'            SCATTER FORMAT
         BZ    BLREFA3                 NO
         LA    R1,8(R1)                ADD FOR SCATTER
BLREFA3  MVC   AUTHLEN(2),0(R1)        AUTH LENGTH AND CODE
         TM    ATTR2,X'10'             SSI PRESENT
         BZ    BLCKALI                 NO
         LA    R1,MEMBER+35            END OF BASIC PORTION
         TM    ATTR1A,X'04'            SCATTER FORMAT
         BZ    BLSSI2                  NO
         TM    ALIASIND,X'80'          ALIAS
         BO    BLFMTED                 YES, NO REFORMAT NEEDED
         LA    R1,8(R1)                NO, STEP PAST SCATTER SECTION
         B     BLMVSSI                 GO MOVE SSI
BLSSI2   TM    ALIASIND,X'80'          ALIAS
         BZ    BLMVSSI                 NO
         LA    R1,11(R1)               YES, STEP PAST ALIAS SECTION
BLMVSSI  MVC   SSI,0(R1)               MOVE SSI DATA
BLCKALI  TM    ALIASIND,X'80'          ALIAS
         BO    BLASC                   YES
         B     BLFMTED                 FINISHED
BLASC    TM    ATTR1A,X'04'            SCATTER FORMAT
         BO    BLFMTED                 YES, NO REFORMAT NEEDED
         MVC   ALMEM,MEMBER+38         MOVE ALIAS MEMBER
         MVC   ALEPA(3),MEMBER+35      YES, MOVE ALIAS DATA
BLFMTED  MVC   PRT(26),=C'DIRECTORY INFO FOR MODULE '
         MVC   PRT+27(8),MEMBER        MEMBER NAME TO PRINT
         BAL   R9,PRINT                PRINT
         MVC   PRT+10(14),=C'TTR OF MODULE='
         LA    R12,TTRMOD              @ TTR
         BAL   R9,HEXPRT3              CONVERT
         MVC   PRT+24(6),PRTABL        TTR TO PRINT
         BAL   R9,PRINT                PRINT
         MVC   PRT+10(18),=C'CONCATENATION NBR='
         LA    R12,CCAT                @ CONCATENATION NBR
         BAL   R9,HEXPRT1              CONVERT
         MVC   PRT+28(2),PRTABL        CONCATENATION NBR
         BAL   R9,PRINT                PRINT
         MVC   PRT+10(12),=C'ALIAS INDIC='
         LA    R12,ALIASIND            @ ALIAS INDICATOR
         BAL   R9,HEXPRT1              CONVERT
         MVC   PRT+22(2),PRTABL        ALIAS INDICATOR
         TM    ALIASIND,X'80'          IS IT AN ALIAS
         BZ    BLALPRT                 NO
         MVC   PRT+50(13),=C'*** ALIAS ***'
BLALPRT  BAL   R9,PRINT                PRINT
         MVC   PRT+10(18),=C'TTR, 1ST TXT RECD='
         LA    R12,TTR1TXT             @ TTR
         BAL   R9,HEXPRT3              CONVERT
         MVC   PRT+28(6),PRTABL        TTR OF 1ST TXT BLOCK
         BAL   R9,PRINT                PRINT
         MVC   PRT+10(25),=C'TTR OF NOTE/SCATTER LIST='
         LA    R12,TTRNS               @ TTR
         BAL   R9,HEXPRT3              CONVERT
         MVC   PRT+35(6),PRTABL        TTR OF NOTE/SCATTER
         BAL   R9,PRINT                PRINT
         MVC   PRT+10(17),=C'NBR NOTE ENTRIES='
         LA    R12,NNOTE               @ NBR NOTES
         BAL   R9,HEXPRT1              CONVERT
         MVC   PRT+27(2),PRTABL        NBR NOTE ENTRIES
         BAL   R9,PRINT                PRINT
         MVC   PRT+10(13),=C'ATTRIBUTES 1='
         LA    R12,ATTR1A              @ ATTRIBUTES
         BAL   R9,HEXPRT2              CONVERT
         MVC   PRT+23(4),PRTABL        ATTRIBUTES 1
         TM    ATTR1A,X'80'            RENT
         BZ    BLAT1A                  NO
         MVC   PRT+30(4),=C'RENT'
BLAT1A   TM    ATTR1A,X'40'            REUS
         BZ    BLAT1B                  NO
         MVC   PRT+35(4),=C'REUS'
BLAT1B   TM    ATTR1A,X'20'            OVLY
         BZ    BLAT1C                  NO
         MVC   PRT+40(4),=C'OVLY'
BLAT1C   TM    ATTR1A,X'10'            TEST
         BZ    BLAT1D                  NO
         MVC   PRT+45(4),=C'TEST'
BLAT1D   TM    ATTR1B,X'08'            OL
         BZ    BLAT1E                  NO
         MVC   PRT+50(2),=C'OL'
BLAT1E   TM    ATTR1A,X'04'            SCTR
         BZ    BLAT1F                  NO
         MVC   PRT+53(4),=C'SCTR'
BLAT1F   TM    ATTR1A,X'02'            EXEC
         BZ    BLAT1G                  NO
         MVC   PRT+58(4),=C'EXEC'
BLAT1G   TM    ATTR1B,X'01'            REFR
         BZ    BLAT1PRT                NO
         MVC   PRT+63(4),=C'REFR'
BLAT1PRT BAL   R9,PRINT                PRINT
         MVC   PRT+10(13),=C'TOTAL LENGTH='
         LA    R12,TOTVIRT             @ TOTAL LENGTH
         BAL   R9,HEXPRT3              CONVERT
         MVC   PRT+23(6),PRTABL        TOTAL LENGTH OF MODULE
         BAL   R9,PRINT                PRINT
         MVC   PRT+10(23),=C'LENGTH OF 1ST TXT RECD='
         LA    R12,LENG1               @ 1ST TXT LENG
         BAL   R9,HEXPRT2              CONVERT
         MVC   PRT+33(4),PRTABL        LENGTH OF 1ST TXT BLOCK
         BAL   R9,PRINT                PRINT
         MVC   PRT+10(11),=C'E. P. ADDR='
         LA    R12,LKEPA               @ E.P. ADDR
         BAL   R9,HEXPRT3              CONVERT
         MVC   PRT+21(6),PRTABL        E.P. ADDR
         BAL   R9,PRINT                PRINT
         MVC   PRT+10(13),=C'ATTRIBUTES 2='
         LA    R12,ATTR2               @ ATTRIBUTES 2
         BAL   R9,HEXPRT1              CONVERT
         MVC   PRT+23(2),PRTABL        ATTRIBUTES 2
         TM    ATTR2,X'20'             PAGE ALIGNMENT
         BZ    BLAT3A                  NO
         MVC   PRT+30(16),=C'PAGE ALIGN REQRD'
BLAT3A   TM    ATTR2,X'10'             SSI PRESENT
         BZ    BLAT3PRT                NO
         MVC   PRT+50(11),=C'SSI PRESENT'
BLAT3PRT BAL   R9,PRINT                PRINT
         TM    ATTR1A,X'04'            SCATTER FORMAT
         BZ    BLFAL                   NO
         MVC   PRT+10(8),=C'SCTRLEN='
         LA    R12,SCTRLEN             @ SCATTER LIST LENGTH
         BAL   R9,HEXPRT2              CONVERT
         MVC   PRT+18(4),PRTABL        SCATTER LIST LENGTH
         BAL   R9,PRINT                PRINT
         MVC   PRT+10(18),=C'TRANSLATE TBL LEN='
         LA    R12,TTLEN               @ TRANS TBL LEN
         BAL   R9,HEXPRT2              CONVERT
         MVC   PRT+28(4),PRTABL        TRANSLATION TABLE LENGTH
         BAL   R9,PRINT                PRINT
         MVC   PRT+10(18),=C'ESD ID OF 1ST TXT='
         LA    R12,SCESDID             @ ESD ID
         BAL   R9,HEXPRT2              CONVERT
         MVC   PRT+28(4),PRTABL        ESD ID OF 1ST TXT
         BAL   R9,PRINT                PRINT
         MVC   PRT+10(23),=C'ESD ID CONTAINING E.P.='
         LA    R12,SCEPESD             @ ESD ID
         BAL   R9,HEXPRT2              CONVERT
         MVC   PRT+33(4),PRTABL        @ ESD ID OF CSECT CONTAINING E.P
         BAL   R9,PRINT                PRINT
BLFAL    TM    ALIASIND,X'80'          ALIAS
         BZ    BLFSSI                  NO
         MVC   PRT+10(28),=C'E.P. ADDRESS OF THIS MEMBER='
         LA    R12,ALEPA               @ E.P. ADDR
         BAL   R9,HEXPRT3              CONVERT
         MVC   PRT+38(6),PRTABL        E.P. ADDR
         BAL   R9,PRINT
         MVC   PRT+10(17),=C'REAL MEMBER NAME='
         MVC   PRT+27(8),ALMEM         REAL MEMBER NAME
         BAL   R9,PRINT
BLFSSI   TM    ATTR2,X'10'             ANY SSI INFO
         BZ    BLAUTHC                 NO
         MVC   PRT+10(9),=C'SSI INFO='
         LA    R12,SSI                 @ SSI INFO
         BAL   R9,HEXPRT4              CONVERT
         MVC   PRT+19(8),PRTABL        SSI INFO
         BAL   R9,PRINT                PRINT
BLAUTHC  MVC   PRT+10(10),=C'AUTH CODE='
         LA    R12,AUTHCOD             @ AUTH CODE
         BAL   R9,HEXPRT1              CONVERT
         MVC   PRT+20(2),PRTABL        AUTH CODE
         BAL   R9,PRINT                PRINT
         TM    ALIASIND,X'80'          ALIAS
         BZ    BLXIT                   NO
         MVC   PRT+5(38),=C'***** REAL MEMBER DIRECTORY INFO *****'
         MVI   PCC,C'0'                DOUBLE SPACE
         BAL   R9,PRINT                PRINT
         MVC   MEMBER,ALMEM            REAL MEMBER NAME TO LIST
         B     ISSBLDL                 DO OVER FOR REAL MEMBER
BLXIT    L     R9,BL9                  GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
****************************************************************
*                                                              *
* CREATE PRINTABLE HEX FROM HEX. ON ENTRY, REG 12 CONTAINS THE *
* ADDRESS OF THE DATA TO BE REFORMATTED. ENTRY POINT USED      *
* DETERMINES THE SIZE OF THE FIELD. OUTPUT DATA IS PLACED IN   *
* THE PRTABL FIELD, 2 CHARACTERS PER BYTE.                     *
*                                                              *
****************************************************************
*
HEXPRT   EQU   *                       HEX TO PRINTABLE ROUTINE
HEXPRT1  UNPK  PRTABL(3),0(2,R12)      UNPACK HEX
         B     HEXCLTR                 CONTINUE
HEXPRT2  UNPK  PRTABL(5),0(3,R12)      UNPACK HEX
         B     HEXCLTR                 CONTINUE
HEXPRT3  UNPK  PRTABL(7),0(4,R12)      UNPACK HEX
         B     HEXCLTR                 CONTINUE
HEXPRT4  UNPK  PRTABL(9),0(5,R12)      UNPACK HEX
HEXCLTR  MVZ   PRTABL(8),XZROS         CLEAR FOR TRANSLATE
         TR    PRTABL(8),TRTBL         MAKE PRINTABLE
         BR    R9                      EXIT
*
*
*
****************************************************************
*                                                              *
* PRINT USING SYSPRINT.                                        *
*                                                              *
****************************************************************
*
PRINT    EQU   *                       PRINT ROUTINE
         TM    SYSPRINT+48,X'10'       IS SYSPRINT OPEN
         BNO   CLRPRT                  NO
         PUT   SYSPRINT,PRTLINE        WRITE PRINT LINE
CLRPRT   MVC   PRT,BLANX               CLEAR PRINT LINE
         AP    LINECT,P1               INCR LINE COUNTER
         CLI   PCC,C' '                SINGLE SPACED
         BE    SETSGL                  YES
         AP    LINECT,P1               INCR LINE COUNTER
         CLI   PCC,C'0'                DOUBLE SPACED
         BE    SETSGL                  YES
         AP    LINECT,P1               INCR LINE COUNTER
         CLI   PCC,C'-'                TRIPLE SPACED
         BE    SETSGL                  YES
         ZAP   LINECT,P0               NO, MUST BE NEW PAGE
SETSGL   MVI   PCC,C' '                SET SINGLE SPACING
         CP    LINECT,P58              PAST END OF PAGE
         BH    NEWPAGE                 YES
         BR    R9                      EXIT
NEWPAGE  MVI   PCC,C'1'                SET SKIP TO HOF
         ZAP   LINECT,P0               RESET LINE COUNTER
         BR    R9                      EXIT
*
*
****************************************************************
*                                                              *
* PROCESS THE CONTROL CARD CONTAINING MODULE NAME AND CSECT.   *
* THIS MUST BE THE FIRST CARD IN THE SYSIN DECK.               *
*                                                              *
****************************************************************
*
GETCTL   EQU   *                       EXTRACT DESIRED MEMBER/CSECT
         GET   SYSIN                   READ THE CONTROL CARD
         LA    R12,72                  LENGTH OF CONTROL CARD
         LA    R11,8                   MAX LENGTH OF MEMBER NAME
         LA    R10,MEMBER              @ MEMBER NAME FIELD
CKBLK1   CLI   0(R1),C' '              CONTROL BYTE IS BLANK
         BNE   GCMEMOV                 NO, GO MOVE MEMBER NAME
         LA    R1,0(R1)                TO NEXT CONTROL BYTE
         BCT   R12,CKBLK1              SUBTRACT 1 FROM REMAINING LENGTH
         B     GCEND                   ALL BLANKS, EXIT
GCMEMOV  MVC   0(1,R10),0(R1)          CONTROL BYTE TO MEMBER NAME
         LA    R1,1(R1)                TO NEXT CONTROL BYTE
         BCTR  R12,R0                  SUBTRACT 1 FROM LENGTH
         LA    R10,1(R10)              TO NEXT NAME BYTE
         BCTR  R11,R0                  SUBTRACT 1 FROM LENGTH
         CLI   0(R1),C' '              GOT A BLANK
         BE    GCSETUP2                YES
         CLI   0(R1),C','              GOT A COMMA
         BE    GCSETUP2                YES
         LTR   R12,R12                 END OF CONTROL DATA
         BE    GCEND                   YES
         LTR   R11,R11                 NAME FULL
         BNZ   GCMEMOV                 NO, CONTINUE
         B     NAMEOV8                 YES, NAME TOO LONG
GCSETUP2 LA    R11,8                   CSECT NAME MAX LENGTH
         LA    R10,CSECT               @ CSECT NAME FIELD
GCSTEP2  LA    R1,1(R1)                STEP PAST BLANK
         BCT   R12,GCHKBK2             CHECK NEXT FOR BLANK
         B     GCEND                   END OF SCAN
GCHKBK2  CLI   0(R1),C' '              CONTROL DATA IS BLANK
         BE    GCSTEP2                 YES
GCCSMOV  MVC   0(1,R10),0(R1)          CONTROL BYTE TO CSECT NAME
         LA    R1,1(R1)                TO NEXT CONTROL BYTE
         LA    R10,1(R10)              TO NEXT NAME BYTE
         BCTR  R12,R0                  DEDUCT 1 FROM CONTROL LENGTH
         BCTR  R11,R0                  DEDUCT 1 FROM NAME LENGTH
         LTR   R12,R12                 ANY CONTROL BYTES LEFT
         BZ    GCEND                   NO
         CLI   0(R1),C' '              NEXT CONTROL BYTE BLANK
         BE    GCEND                   YES
         LTR   R11,R11                 ANY NAME BYTES LEFT
         BNZ   GCCSMOV                 YES, LOOP
         B     NAMEOV8                 NAME TOO LONG, ERROR
GCEND    CLC   MEMBER,BLANX            ANY MEMBER NAME FOUND
         BE    NOMBR                   NO
         CLC   CSECT,=CL8'ALL '
         BE    ALLCSECT
         CLC   CSECT,=CL8'* '
         BNER  R9
ALLCSECT EQU   *
         MVI   ALLSWT,X'FF'
         MVC   CSECT(8),BLANX
         BR    R9                      EXIT
*
*
*
****************************************************************
*                                                              *
* MISCELLANEOUS ERROR MESSAGES.                                *
*                                                              *
****************************************************************
*
ERRORS   EQU   *                       ERROR END MESSAGES
NOCTL    MVC   PRT(L'NOCNTRL),NOCNTRL  NO CONTROL INFO MESSAGE
         B     ERREND                  GO PRINT
NAMEOV8  MVC   PRT(L'OVER8),OVER8      NAME OVER 8 MESSAGE
         B     ERREND                  GO PRINT
NOMBR    MVC   PRT(L'NOMEM),NOMEM      MISSING MEMBER NAME MESSAGE
         B     ERREND                  GO PRINT
MISSMEM  MVC   PRT(L'INVMEM),INVMEM    MEMBER NOT IN PDS MESSAGE
         B     ERREND                  GO PRINT
MISSCS   MVC   PRT(L'INVCSECT),INVCSECT CSECT NOT IN MEMBER MESSAGE
         B     ERREND                  GO PRINT
MISSCST  MVC   PRT(L'INXCSECT),INXCSECT CSECT NOT IN SYMBOL TABLE
         B     ERREND                  GO PRINT
SYMFULL  MVC   PRT(L'FULLSYM),FULLSYM  FULL SYM TBL MSG
         B     ERREND                  GO PRINT
RLDFULL  MVC   PRT(L'FULLRLD),FULLRLD  RLD TBL FULL MSDG
         B     ERREND                  GO PRINT
ERREND   BAL   R9,PRINT                GO PRINT MESSAGE
*        LA    R7,SNAPA
**       L     R9,SYMTBAD
*        ST    R9,0(R7)
*        L     R9,ENDSYM
*        ST    R9,4(R7)
*        OI    4(R7),X'80'
*        SNAP  MF=(E,SNAPEXEC)
         ABEND 077,DUMP,STEP           ABEND
*
*
*
*
****************************************************************
*                                                              *
* COUNT THE ENTRIES IN THE ESD TABLE WHICH WILL RESULT IN      *
* ENTRIES IN THE LABEL TABLE.                                  *
*                                                              *
****************************************************************
ENDINIT  EQU   *                       *** FINAL PROCESSING ***
         L     R6,SYMTBAD
         ST    R6,NXTSYPTR
*
LOOPTEXT EQU   *                       *** DISASM ALL CSECTS ****
*
LOOPCLR  L     R6,NXTSYPTR
         USING SYMTBL,R6
LOOPNXT  CLI   0(R6),X'FF'            END OF SYMBOL TABLE?
         BE    EOJLOOP
         CLI   TYPSYM,X'00'
         BE    LOOPCESD
         LA    R6,L'SYMENT(R6)
         B     LOOPNXT
EOJLOOP  CLI   ALLSWT,X'00'
         BE    PHASE1
         B     EOJ
LOOPCESD MVC   TXTSTRT,STXTSTRT
         MVC   TXTCURR,STXTCURR
         MVC   TXTEND,STXTEND
         MVC   ESDID,SYMESDID
         MVC   POFSET(4),=F'0'    SET TEXT OFFSET TO ZERO FOR EACH
         MVC   CSECT,EXTSYM
         MVC   START,SSTART
         MVC   END,SEND
         MVC   LENGTH,SLENGTH
         LA    R6,L'SYMENT(R6)
         ST    R6,NXTSYPTR
*
         L     R6,SYMTBAD              GET @ ESD TABLE
         USING SYMTBL,R6
         LA    R7,4                    INITIAL LABEL COUNT VALUE
SYMCNT   CLI   0(R6),X'FF'             END OF ESD TBL
         BE    RLDCNT                  YES
         CLI   TYPSYM,3                IS ESD AN LR ENTRY
         BNE   SCSTP                   NO, IGNORE
         CLC   SYMADDR,START+1         ADDR BELOW DESIRED CSECT
         BL    SCSTP                   YES, IGNORE
         CLC   SYMADDR,END+1           ADDR ABOVE DESIRED CSECT
         BH    SCSTP                   YES, IGNORE
         LA    R7,1(R7)                ADD TO LABEL COUNT
         MVC   SYMLENG,=C'***'         FLAG AS USABLE
SCSTP    LA    R6,L'SYMENT(R6)         TO NEXT ESD ENTRY
         B     SYMCNT
         DROP  R6
*
****************************************************************
*                                                              *
* COUNT THE ENTRIES IN THE RLD TABLE WHICH WILL RESULT IN      *
* ENTRIES IN THE LABEL TABLE.                                  *
*                                                              *
****************************************************************
*
RLDCNT   L     R6,RLDTBL               GET RLD TBL ADDR
         USING RLDTBLD,R6
RLDCEND  CLI   0(R6),X'FF'             END OF RLD TABLE
         BE    LBLGET                  YES
         CLC   RLDRP,ESDID             ESDID SAME AS DESIRED CSECT
         BNE   RLDC1                   NO, EXTRN REF
         LA    R7,1(R7)                ADD 1 TO LABEL COUNT
RLDC1    LA    R7,1(R7)                ADD 1 TO LABEL COUNT
         LA    R6,L'RLDENT(R6)         TO NEXT RLD ENTRY
         B     RLDCEND                 LOOP THRU RLD TBL
         DROP  R6
LBLGET   MH    R7,LBLLGTH              COMPUTE LABEL TABLE SIZE
         L     R1,LENGTH               GET CSECT LENGTH
         SRL   R1,2                    DIVIDE BY 4
         MH    R1,LBLLGTH              TIMES LABEL ENTRY LENGTH
         AR    R7,R1                   TOTAL LABEL TABLE LENGTH
*
****************************************************************
*                                                              *
* CREATE INITIAL ENTRIES IN THE LABEL TABLE USING DATA FROM    *
* THE ESD AND RLD TABLES.                                      *
*                                                              *
****************************************************************
*
         GETMAIN R,LV=(7)              GET LABEL TBL STORAGE
         ST    R1,LBLTBL               SAVE LABEL TBL ADDR
         ST    R1,CURRLBL              SAVE CURRENT LABEL ADDR
         AR    R1,R7                   COMPUTE LABEL TBL END ADDR
         ST    R1,ENDLBL               SAVE END OF LBL TBL ADDR
         L     R6,LBLTBL               GET @ LABEL TABLE
         USING LABELD,R6
         L     R7,SYMTBAD              GET ESD TBL ADDR
         USING SYMTBL,R7
         CLC   LKEPA,XZROS             E.P. ADDR ZERO
         BE    LRENTS                  YES
         SR    R1,R1                   CLEAR WORK
         ICM   R1,7,LKEPA              PICK UP E.P. ADDR
         S     R1,START                RELATIVIZE IN CSECT
         BM    LRENTS                  NEG, ERROR
         STCM  R1,7,LBLADR             SAVE OFFSET
         MVI   LBLTYP,C'L'             SET LABEL TYPE IN ENTRY
         LA    R12,LBLADR              POINT TO OFFSET
         BAL   R9,HEXPRT3              CONVERT TO PRINTABLE
         MVI   LBLNAME,C'A'            1ST CHAR OF LABEL IS 'A'
         MVC   LBLNAME+1(6),PRTABL     END OF LABEL IS OFFSET
         LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY
         ST    R6,CURRLBL              SAVE IT'S ADDRESS
LRENTS   CLI   0(R7),X'FF'             END OF ESD TBL
         BE    RLDLBLS                 YES
         CLC   SYMLENG,=C'***'         THIS DESIRED LR ENTRY
         BE    GOTLR                   YES
LRESTP   LA    R7,L'SYMENT(R7)         TO NEXT ESD ENTRY
         B     LRENTS                  LOOP THRU ESD TBL
GOTLR    SR    R12,R12                 CLEAR WORK REG
         ICM   R12,7,SYMADDR           GET SYMBOL ADDR
         S     R12,START               RELATIVIZE IN CSECT
         STCM  R12,7,LBLADR            SAVE RELATIVE ADDR
         MVC   LBLNAME,EXTSYM          SYMBOL NAME TO OUTPUT
         MVI   LBLTYP,C'L'             SHOW LABEL ENTRY
         LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY
         ST    R6,CURRLBL              SAVE NEXT LABEL ENTRY ADDR
         B     LRESTP                  CONTINUE ESD PROCESSING
         DROP  R7
RLDLBLS  L     R7,RLDTBL               GET RLD TBL ADDR
         USING RLDTBLD,R7
RLDLBND  CLI   0(R7),X'FF'             END OF RLD TABLE
         BE    PHASE1                  YES
         CLC   RLDRP,ESDID             RLD ESDID = DESIRED CSECT ESDID
         BE    INTREFS                 YES, INTERNAL ADCON
         CLI   ALLSWT,X'FF'
         BNE   RLDNOESD
         CLC   RLDADDR,START+1
         BL    RLLSTP
         CLC   RLDADDR,END+1
         BH    RLLSTP
RLDNOESD CLI   RLDTYPE,1               VCON
         BE    EXTREFS                 YES
         CLI   RLDTYPE,8               IS IT UNRESOLVED
         BE    EXTREFS                 YES
RLLSTP   LA    R7,L'RLDENT(R7)         TO NEXT RLD ENTRY
         B     RLDLBND                 LOOP THRU RLD TABLE
EXTREFS  CLI   RLDESDTP,X'0A'          W-CON
         BNE   VCONLBL                 NO, BUILD V-CON
         MVI   LBLTYP,C'W'             SHOW W-CON
         B     FXTLBL                  CONTINUE LABEL ENTRY FORMAT
VCONLBL  MVI   LBLTYP,C'V'             SHOW V-CON
FXTLBL   MVC   LBLNAME,RLDNAME         NAME TO LABEL ENTRY
FINLBL   MVC   LBLADR,RLDADDR          ADDRESS TO LABEL ENTRY
         MVC   LBLLEN,RLDLEN           LENGTH TO LABEL ENTRY
         LA    R6,L'LABEL(R6)          TO NEXT LABEL TBL ENTRY
         ST    R6,CURRLBL              SAVE CURRENT LABEL TBL ADDR
         B     RLLSTP                  CONTINUE LABEL TABLE BUILD
INTREFS  CLI   RLDTYPE,0               A-CON
         BNE   RLLSTP                  NO, IGNORE
         MVI   LBLTYP,C'L'             SHOW LABEL ENTRY TYPE
         SR    R12,R12                 CLEAR WORK REG
         ICM   R12,7,RLDADDR           GET RLD ADDR
         A     R12,TXTSTRT             FIND LOC IN TEXT
         MVC   LBLADR,1(R12)           MOVE TO LABEL ENTRY
         CLI   RLDLEN,4                ADCON IS 4-BYTES
         BE    INTGOTL                 YES
         MVC   LBLADR,0(R12)           TEXT TO LABEL ENTRY
         CLI   RLDLEN,3                ADCON IS 3-BYTES
         BE    INTGOTL                 YES
         MVC   LBLADR+1(2),0(R12)      TEXT TO LABEL ENTRY
         MVI   LBLADR,0                CLEAR 1ST BYTE
         CLI   RLDLEN,2                ADCON IS 2-BYTES
         BE    INTGOTL                 YES
         XC    LBLADR,LBLADR           CLEAR LABEL ENTRY ADDR
         MVC   LBLADR+2(1),0(R12)      TEXT TO LABEL ENTRY
INTGOTL  SR    R12,R12                 CLEAR WORK
         ICM   R12,7,LBLADR            GET ADDRESS
         S     R12,START               RELATIVIZE IN CSECT
         BM    RLLSTP                  NEGATIVE, IGNORE
         STCM  R12,7,LBLADR            STORE RELATIVE ADDRESS
         LA    R12,LBLADR              POINT TO ADDRESS
         BAL   R9,HEXPRT3              CONVERT TO PRINTABLE
         MVI   LBLNAME,C'A'            SET LABEL ENTRY TYPE
         MVC   LBLNAME+1(6),PRTABL     LOW ORDER NAME POSITIONS
         MVI   LBLNAME+7,C' '          CLEAR LAST NAME BYTE
         MVC   L'LABEL(L'LABEL,R6),0(R6) COPY THIS ENTRY TO NEXT
         MVI   LBLLEN,0                SET LENGTH = 0
         LA    R6,L'LABEL(R6)          STEP TO NEXT
         MVI   LBLTYP,C'A'             SHOW TYPE
         B     FINLBL                  FINISH LABEL
         DROP  R6
         DROP  R7
*
****************************************************************
*                                                              *
* LOAD AND EXECUTE PHASE 1: DISASM1                            *
*                                                              *
****************************************************************
*
PHASE1   MVC   0(3,R6),HIVAL           SET END OF LABEL TABLE  FIX***
         CLI   ALLSWT,X'FF'
         BE    CSECTALL
         TM    LOADLIB+48,X'10'        LOADLIB DD CARD ENTERED
         BZ    NODCB1                  NO
         LOAD  EP=DISASMX1,DCB=LOADLIB  LOAD PHASE1
         B     EXEC1                   CONTINUE
NODCB1   LOAD  EP=DISASMX1              LOAD PHASE1
EXEC1    LR    R15,R0                  COPY E.P. ADDRESS
         LA    R1,=A(COMMPARM)         @ PARAMETER LIST
         BALR  R14,R15                 LINK TO PHASE1
         DELETE EP=DISASMX1             DELETE AFTER USE
         CLI   USERR,10                RESET
         BE    RESET
         CLI   USERR,0                 ANY ERRORS
         BNE   CLOSES                  YES, STOP THE RUN
CSECTALL EQU   *
*
****************************************************************
*                                                              *
* PRINT THE LABEL TABLE AFTER PHASE 1 COMPLETION.              *
*                                                              *
****************************************************************
*
         MVC   PRTLINE,PH1LBL          HEADER 1
         MVC   PRTLINE+42(8),CSECT
         BAL   R9,PRINT                PRINT IT
         MVC   PRTLINE,PH1HDR          HEADER 2
         BAL   R9,PRINT                PRINT IT
         L     R6,LBLTBL               GET LABEL TABLE ADDR
         USING LABELD,R6
LPEND    C     R6,CURRLBL              END OF TABLE       FIX****
         BNL   FREESTRG                YES                FIX****
         LA    R12,LBLADR              @ LABEL ADDRESS
         BAL   R9,HEXPRT3              CONVERT
         MVC   PRT(6),PRTABL           ADDRESS TO PRINT
         MVC   PRT+9(1),LBLTYP         TYPE TO PRINT
         MVC   PRT+12(8),LBLNAME       SYMBOL TO PRINT
         CLI   LBLLEN,0                ANY LENGTH
         BE    LTPPRT                  NO
         LA    R12,LBLLEN              GET @ LENGTH
         BAL   R9,HEXPRT1              CONVERT
         MVC   PRT+22(2),PRTABL        LENGTH TO PRINT
LTPPRT   BAL   R9,PRINT                PRINT TBL ENTRY
         LA    R6,L'LABEL(R6)          TO NEXT ENTRY
         B     LPEND                   LOOP THRU TABLE
FREESTRG EQU   *
         CLI   ALLSWT,X'FF'
         BE    PASSFREE
         L     R12,RLDTBL              @ RLD TABLE
         FREEMAIN R,A=(12),LV=60000    FREE RLD TABLE
PASSFREE EQU   *
*
****************************************************************
*                                                              *
* PRINT THE TEXT FOR THE CSECT TO BE DISASSEMBLED.             *
*                                                              *
****************************************************************
*
         MVI   PCC,C'1'                SET SKIP TO HEAD
         MVC   PRT+50(19),=C'***** T E X T *****'
         BAL   R9,PRINT                PRINT TEXT HEADER
         MVI   PCC,C'0'                SET DOUBLE SPACING
         L     R11,TXTSTRT             GET TEXT START ADDRESS
PNEXLIN  LA    R10,2                   GROUPS PER LINE
         LA    R12,POFSET+1            @ OFFSET
         BAL   R9,HEXPRT3              CONVERT
         MVC   PRT(6),PRTABL           OFFSET TO PRINT
         MVC   PGRPFULL+1(1),=X'1F'
         L     R9,TXTEND
         SR    R9,R11
         C     R9,=F'32'
         BH    PGRPFULL
         STC   R9,PGRPFULL+1
PGRPFULL MVC   PRT+85(32),0(R11)       TEXT TO PRINT
         LA    R7,PRTCHAR
         TR    PRT+85(32),0(R7)        TRANSLATE TO PRINTABLE
         LA    R8,PRT+9                @ 1ST PRINT WORD
         LA    R7,4                    4 WORDS PER GROUP
PGRP     LA    R12,0(R11)              @ TEXT WORD
         BAL   R9,HEXPRT4              CONVERT
         MVC   0(8,R8),PRTABL          TEXT TO PRINT WORD
         LA    R11,4(R11)              TO NEXT TEXT WORD
         C     R11,TXTEND
         BNL   PGRPEND
         LA    R8,9(R8)                TO NEXT PRINT LOC
         BCT   R7,PGRP                 DO 4 TIMES
         LA    R8,2(R8)                SPACE BETWEEN GROUPS
         LA    R7,4                    FOR 2ND GROUP
         BCT   R10,PGRP                DO 4 MORE TIMES
PGRPEND  BAL   R9,PRINT                PRINT THE LINE
         L     R9,POFSET               GET OFFSET
         LA    R9,32(R9)               ADD 32 BYTES
         ST    R9,POFSET               UPDATE OFFSET
         C     R11,TXTEND              END OF TEXT
         BL    PNEXLIN                 NO, CONTINUE
         MVI   PCC,C'1'                SET SKIP TO HEAD
         MVC   WORKREC,BLANX           CLEAR OUTPUT RECORD
         MVC   NAME,CSECT              CSECT NAME
*
****************************************************************
*                                                              *
* CREATE THE INITIAL CSECT INSTRUCTION, AND ANY ENTRY STATE-   *
* MENTS WHICH MAY BE INDICATED BY ESD TABLE ENTRIES.           *
*                                                              *
****************************************************************
*
         MVC   MNEMONIC,=C'CSECT'      SET MNEMONIC
         BAL   R9,WRTOUT               WRITE OUTPUT RECORD
         BAL   R9,PRINT                AND PRINT IT
         L     R7,SYMTBAD              GET ESD TBL ADDR
         USING SYMTBL,R7
LREFSS   CLI   0(R7),X'FF'             END OF ESD TBL
         BE    CKLDLB                  YES
         CLC   SYMLENG,=C'***'         THIS DESIRED LR ENTRY
         BE    MAKEXT                  YES
ESDTSTP  LA    R7,L'SYMENT(R7)         TO NEXT ESD ENTRY
         B     LREFSS                  LOOP THRU ESD TBL
MAKEXT   MVC   MNEMONIC,=C'ENTRY'      MNEMONIC IS ENTRY
         MVC   OPNDS(8),EXTSYM         SYMBOL TO OPERAND
         BAL   R9,WRTOUT               WRITE OUTPUT RECORD
         BAL   R9,PRINT                AND PRINT IT
         B     ESDTSTP                 CONTINUE ESD PROCESSING
         DROP  R7
         DROP  R6
CKLDLB   EQU   *
         CLI   ALLSWT,X'FF'
         BE    PASSSYM
         L     R12,SYMTBAD             @ ESD SYMBOL TABLE
*
****************************************************************
*                                                              *
* LOAD AND EXECUTE PHASE 2: DISASM2                            *
*                                                              *
****************************************************************
*
         FREEMAIN R,A=(12),LV=38000    FREE SYMBOL TABLE
PASSSYM  EQU   *
         TM    LOADLIB+48,X'10'        LOADLIB DD CARD SUPPLIED
         BZ    NODCB                   NO
         LOAD  EP=DISASMX2,DCB=LOADLIB  LOAD DISASM2
         B     EXEC2                   CONTINUE
NODCB    LOAD  EP=DISASMX2              LOAD DISASM2
EXEC2    LR    R15,R0                  COPY E.P. ADDRESS
         LA    R1,=A(COMMPARM)         GET PARAMETER ADDRESS
         BALR  R14,R15                 CALL DISASM2
         DELETE EP=DISASMX2             DELETE AFTER USE
         CLI   ALLSWT,X'FF'
         BE    CLRTEXT
         B     EOJ                     GO FINISH
*
*
CLRTEXT  EQU   *
         L     R6,SYMTBAD              GET @ ESD TABLE
         USING SYMTBL,R6
CLRNT    CLI   0(R6),X'FF'             END OF ESD TBL
         BE    LOOPTEXT                YES
         CLC   SYMLENG,=C'***'         ADDR BELOW DESIRED CSECT
         BNE   CLRTP                   YES, IGNORE
         MVC   SYMLENG,=C'   '         FLAG AS USABLE
CLRTP    LA    R6,L'SYMENT(R6)         TO NEXT ESD ENTRY
         B     CLRNT
         DROP  R6
*
*
*
*
*
*
****************************************************************
*                                                              *
* WRITE OUTPUT TO SYSPUNCH.                                    *
*                                                              *
****************************************************************
*
WRTOUT   EQU   *                       WRITE OUTPUT RECORDS
         MVC   PRT(80),WORKREC         SAVE IN PRINT
         TM    SYSPUNCH+48,X'10'       IS FILE OPEN
         BZ    CLRWKR                  NO
         AP    CARDNO,=P'10'           INCREMENT CARD NO
         UNPK  SEQNBR,CARDNO           UNPACK INTO CARD
         OI    SEQNBR+7,C'0'           CLEAR SIGN
         PUT   SYSPUNCH,WORKREC        WRITE SOURCE CARD
CLRWKR   MVC   WORKREC,BLANX           CLEAR OUTPUT RECORD
         BR    R9                      RETURN
*
*
*
****************************************************************
*                                                              *
* END OF JOB. DISASSEMBLY COMPLETE.                            *
*                                                              *
****************************************************************
EOJ      EQU   *                       END OF JOB
EOFSW    B     NOCTL                   RESET IF CTL CARD FOUND
         MVC   MNEMONIC,=CL5'REQU'     SET MNEMONIC
         BAL   R9,WRTOUT               WRITE RECORD
         BAL   R9,PRINT                GO PRINT IT
         L     R12,DTBSTRT             @ DSECT HEADER TBL
CENDSTB  CLI   0(R12),X'FF'            END OF TABLE
         BE    ENDSTMT                 YES
         MVC   NAME,0(R12)             DSECT NAME TO RECORD
         MVC   MNEMONIC(5),=C'DSECT'   OPERATION IS DSECT
         BAL   R9,WRTOUT               WRITE DSECT HEADER
         BAL   R9,PRINT                AND PRINT IT
         ICM   R11,7,8(R12)            GET FIELD TABLE ADDR
         USING DSECTD,R11
CENDFTB  CLI   0(R11),X'FF'            END OF FIELD TABLE
         BNE   DFMTFLD                 NO
         LA    R12,11(R12)             TO NEXT DSECT HEADER
         B     CENDSTB                 LOOP
DFMTFLD  MVC   NAME,DSNAME             NAME TO RECORD
         MVC   MNEMONIC(3),=C'EQU'     OPERATION IS EQU
         MVC   OPNDS(8),0(R12)         BASE NAME TO OPERAND
         LA    R10,OPNDS+7             @ NAME RHE
CFRHE    CLI   0(R10),C' '             AT RHE
         BNE   CFPLUS                  YES
         BCT   R10,CFRHE               BACK UP 1 AND LOOP
CFPLUS   LA    R10,1(R10)              TO NEXT POS
         MVI   0(R10),C'+'             DELIMITER
         SR    R1,R1                   CLEAR WORK
         ICM   R1,7,DSOFSET            GET OFFSET
         CVD   R1,DBLWD                CONVERT
         UNPK  DBLWD(4),DBLWD+4(4)     UNPACK
         OI    DBLWD+3,C'0'            CLEAR SIGN
         CH    R1,H1000                OFFSET < 1000
         BL    CFO100                  YES
         MVC   1(4,R10),DBLWD          NO, MOVE 4-DIGIT OFFSET
         LA    R10,5(R10)              TO NEXT POS
         B     CFCMA                   CONTINUE
CFO100   CH    R1,H100                 OFFSET < 100
         BL    CFO10                   YES
         MVC   1(3,R10),DBLWD+1        NO, MOVE 3-DIGIT OFFSET
         LA    R10,4(R10)              TO NEXT POS
         B     CFCMA                   CONTINUE
CFO10    CH    R1,H10                  OFFSET < 10
         BL    CFO1                    YES
         MVC   1(2,R10),DBLWD+2        MOVE 2-DIGIT OFFSET
         LA    R10,3(R10)              TO NEXT POS
         B     CFCMA                   CONTINUE
CFO1     LTR   R1,R1                   ANY OFFSET
         BZ    CFCMA                   NO
         MVC   1(1,R10),DBLWD+3        YES, MOVE 1-DIGIT OFFSET
         LA    R10,2(R10)              TO NEXT POS
CFCMA    MVI   0(R10),C','             DELIMITER
         SR    R1,R1                   CLEAR WORK
         IC    R1,DSLENG               PICK UP LENGTH
         CVD   R1,DBLWD                CONVERT
         UNPK  DBLWD(3),DBLWD+4(4)     UNPACK
         OI    DBLWD+2,C'0'            CLEAR SIGN
         CH    R1,H100                 LENGTH < 100
         BL    CFL10                   YES
         MVC   1(3,R10),DBLWD          NO, MOVE 3-DIGIT LENGTH
         B     CFWRT                   CONTINUE
CFL10    CH    R1,H10                  LENGTH < 10
         BL    CFL1                    YES
         MVC   1(2,R10),DBLWD+1        NO, MOVE 2-DIGIT LENGTH
         B     CFWRT                   CONTINUE
CFL1     MVC   1(1,R10),DBLWD+2        MOVE 1-DIGIT LENGTH
CFWRT    BAL   R9,WRTOUT               WRITE THE RECORD
         BAL   R9,PRINT                PRINT THE RECORD
         LA    R11,L'DSECT(R11)        TO NEXT FIELD ENTRY
         B     CENDFTB                 LOOP
ENDSTMT  MVC   MNEMONIC,=CL5'END'      MNEMONIC TO OUTPUT RECORD
         MVC   OPNDS(8),ENDLBLNM       POINT END STMT TO BEGIN LOC
         BAL   R9,WRTOUT               WRITE THE RECORD
         BAL   R9,PRINT                GO PRINT IT
CLOSES   CLOSE (SYSLIB,,SYSPUNCH,,SYSPRINT,,SYSIN) CLOSE FILES
         L     R13,4(R13)              GET POINTER TO CALLER'S SAVE ARE
         LM    R14,R12,12(R13)         RESTORE CALLER'S REGS
         SR    R15,R15                 CLEAR RETURN CODE
         BR    R14                     RETURN TO CALLER
         DROP  R11
*
*
*
*                 *** DATA AND WORK AREAS ***
****************************************************************
*
* FOLLOWING FIELDS: COMMPARM THRU COMMEND ARE COMMON AREAS SHARED
* BY THIS, AND CALLED SUB-PROGRAMS. ALL CHANGES MUST BE COORDINTAED
* WITH ALL OTHER PROGRAMS.
*
****************************************************************
*
         DS    0D
COMMPARM EQU   *                       COMMON AREAS
DBLWD    DS    D                       DOUBLEWORD WORK AREA
PUNCHDCB DC    A(SYSPUNCH)             @ SYSPUNCH DCB
PRINTDCB DC    A(SYSPRINT)             @ SYSPRINT DCB
INDCB    DC    A(SYSIN)                @ SYSIN DCB
CSECT    DC    CL8' '                  SPECIFIED CSECT NAME
ESDID    DC    X'0001'                 ESD ID OF SPECIFIED CSECT
ENDLBLNM DC    CL8' '                  SYMBOL FOR END STMT BEGIN POINTE
LINECT   DC    PL2'0'                  PRINT LINE COUNTER
START    DC    F'0'                    LKED ASSIGNED START ADDR OF CSEC
END      DC    F'0'                    CSECT END ADDRESS
LENGTH   DC    F'0'                    LENGTH OF SPECIFIED CSECT
LBLTBL   DS    F                       @ LABEL TABLE
CURRLBL  DS    F                       CURRENT LABEL ENTRY ADDR
ENDLBL   DS    F                       @ END OF LABEL TBL
LBLLGTH  DC    AL2(L'LABEL)            LENGTH OF LABEL ENTRY         */
TXTSTRT  DS    F                       @ TEXT STORAGE AREA
TXTEND   DS    F                       @ END OF TEXT AREA
TXTCURR  DS    F                       @ CURRENT TEXT LOC
DTBCURR  DC    F'0'                    DSECT TABLE CURRENT ENTRY ADDR
DTBEND   DC    F'0'                    DSECT TABLE END ADDR
DTBSTRT  DC    A(HIVAL)                DSECT TABLE START ADDR
USGSTRT  DC    A(HIVAL)                USING TABLE START ADDR
USGCUR   DC    F'0'                    USING TABLE CURRENT ADDR
USGEND   DC    F'0'                    USING TABLE END ADDR
DATONLY  DS    F                       DATA ONLY TABLE ADDR
DATOCUR  DS    F                       CURRENT DATA ONLY ADDR
DATOEND  DS    F                       END OF DATA ONLY TABLE
FLPTASM  DC    X'00'                   FLOATING POINT INDICATOR
PRIVASM  DC    X'00'                   PRIVILEGED INDICATOR
USERR    DC    X'00'                   ERROR INDIC FOR DISASM1
NBRLBLS  DC    H'0'                    NBR LABELS FROM DISASM1
*
*
*
WORKREC  DS    0CL80                   DISASSEMBLY WORK AREA
NAME     DS    CL8                     NAME
         DS    CL1
MNEMONIC DS    CL5                     INSTRUCTION MNEMONIC
         DS    CL1
OPNDS    DS    CL27                    1ST OPERAND
         DS    CL1
COMMENT  DS    CL28                    COMMENT
COL72    DS    CL1
SEQNBR   DS    CL8                     CARD SEQ NBR
*
*
*
CARDNO   DC    PL4'0'                  OUTPUT CARD NBR
PRTLINE  DS    0CL121                  PRINT LINE
PCC      DC    C'1'                    CARRIAGE CONTROL
PRT      DC    CL120' '                PRINT DATA
*
*
*
         DS    0F
BLDLIST  DS    0CL62                   BLDL LIST
         DC    H'1'                    ONE ENTRY
         DC    H'58'                   LENGTH OF ENTRY
MEMBER   DC    CL8' '                  MEMBER NAME
TTRMOD   DC    XL3'000000'             TTR OF MODULE
CCAT     DC    XL1'00'                 CONCATENATION NUMBER
         DC    XL1'00'
ALIASIND DC    XL1'00'                 ALIAS AND MISC INDICATOR
*                           80=ALIAS
TTR1TXT  DC    XL3'000000'             TTR OF 1ST TXT RECORD
         DC    XL1'00'
TTRNS    DC    XL3'000000'             TTR OF NOTE OR SCATTER LIST
NNOTE    DC    XL1'00'                 NBR ENTRIES IN NOTE LIST
ATTR1A   DC    XL1'00'                 MODULE ATTRIBUTES 1, BYTE 1
*                           80=RENT
*                           40=REUS
*                           20=OVERLAY
*                           10=UNDER TEST
*                           08=ONLY LOADABLE
*                           04=SCATTER FORMAT
*                           02=EXECUTABLE
*                           01=ONE TXT, NO RLD RECORDS
ATTR1B   DC    XL1'00'                 ATTRIBUTES 1, BYTE 2
*                           80=CANNOT BE REPROCESSED BY LKED E
*                           40=ORIGIN OF 1ST TXT RECORD IS ZERO
*                           20=ASSIGNED ENTRY POINT ADDR IS ZERO
*                           10=CONTAINS NO RLD RECORD
*                           08=CANNOT BE REPROCESSED BY LKED
*                           04=CONTAINS TESTRAN SYMBOLS
*                           02=CREATED BY LKED
*                           01=REFR
TOTVIRT  DC    XL3'000000'             TOTAL VIRTUAL STRG REQRD FOR MOD
LENG1    DC    XL2'0000'               LENGTH OF 1ST TEXT RECORD
LKEPA    DC    XL3'000000'             ASSIGNED ENTRY POINT ADDR
ATTR2    DC    XL1'00'                 ATTRIBUTES 2
*                           80=PROCESSED BY OS/VS LKED
*                           20=PAGE ALIGNMENT REQUIRED FOR MODULE
*                           10=SSI PRESENT
         DC    XL2'0000'
SCTRLEN  DC    XL2'0000'               SCATTER LIST LENGTH
TTLEN    DC    XL2'0000'               TRANSLATION TABLE LENGTH
SCESDID  DC    XL2'0000'               CESD NBR FOR 1ST TXT RECD
SCEPESD  DC    XL2'0000'               CESD NBR FOR ENTRY POINT
ALEPA    DC    XL3'000000'             ENTRY POINT OF THE MEMBER NAME
ALMEM    DC    CL8' '                  REAL MEMBER NAME FOR ALIAS
SSI      DS    XL4'00000000'           SSI BYTES
AUTHLEN  DC    XL1'00'                 AUTH CODE LENGTH
AUTHCOD  DC    XL1'00'                 AUTH CODE
*
*
*
COMMEND  EQU   *
*
*
*
LABELD   DSECT ,                       LABEL TABLE ENTRY
LABEL    DS    0CL13                   13-BYTE ENTRIES
LBLADR   DS    XL3                     RELATIVE ADDR IN TEXT
LBLTYP   DS    CL1                     TYPE: L=LABEL, A=ADCON, V=VCON,
LBLNAME  DS    CL8                     NAME (SYMBOL)
LBLLEN   DS    XL1                     LENGTH IF A, V, OR W
*
*
*
USINGD   DSECT ,                       USING TABLE ENTRY
USING    DS    0CL11
USBGN    DS    XL3                     OFFSET TO BEGINNING OF RANGE
USEND    DS    XL3                     OFFSET TO END OF RANGE
USREG    DS    XL1                     BASE REGISTER USED
USTYPE   DS    XL1                     TYPE:P=PGM,D=DSECT
USVALU   DS    XL3                     BASE REG VALUE
*
*
*
DSECTD   DSECT ,                       DSECT FIELD TABLE ENTRY
DSECT    DS    0CL13
DSOFSET  DS    XL3                     OFFSET TO 1ST BYTE OF FIELD
DSLBTYP  DS    CL1                     LABEL TYPE = L
DSNAME   DS    CL8                     FIELD NAME
DSLENG   DS    XL1                     FIELD LENGTH
*
*
*
DISASM   CSECT
*
*
*
*
*
*
RLDTBLD  DSECT ,                       RELOCATION DICTIONARY TABLE
RLDENT   DS    0CL20                   11 BYTE ENTRIES
RLDRP    DS    XL2                     RELOCATION POINTER
RLDPP    DS    XL2                     POS PTR (SYMBOL CESD NBR)
RLDTYPE  DS    XL1                     TYPE
*                    00=A-TYPE ADCON
*                    01=V-TYPE ADCON
*                    02=PSEUDO REGISTER DISPLACEMENT
*                    03=PSEUDO REG CUMULATIVE DISPL
*                    08=UNRESOLVED
RLDLEN   DS    XL1                     LENGTH OF CONSTANT
RLDDIR   DS    CL1                     RELOCATION DIRECTION, + OR
RLDADDR  DS    XL3                     LKED ASSGND ADDR OF CONSTANT
RLDNAME  DS    CL8                     NAME FROM ASSOC ESD
RLDESDTP DS    XL1                     TYPE FROM ASSOC ESD
         DS    XL1
DISASM   CSECT
*
*
*
SYMTBL   DSECT ,                       EXTERNAL SYMBOL TABLE ENTRY
SYMENT   DS    0CL48                   19 BYTE ENTRIES
EXTSYM   DS    CL8                     EXTERNAL SYMBOL NAME
TYPSYM   DS    XL1                     SYMBOL TYPE
*                        00=SD (NAMED CSECT)
*                        02=ER (EXTRN)
*                        03=LR (ENTRY)
*                        04=PC (UNNAMED CSECT)
*                        05=CM (COM)
*                        06=PR (PSEUDO REGISTER)
*                        07=NULL
*                        0A=WX (WXTRN)
*                        0F=ENTAB OR SEGTAB
SYMIND   DS    XL1                     INDICATOR
*                        BIT 0 = MAP
*                        BIT 1 = CHAIN
*                        BIT 2 = INSERT
*                        BIT 3 = DELETE/REPLACE
SYMADDR  DS    XL3                     SYMBOL ADDRESS (0 FOR ER, WX, NU
SYMSEG   DS    XL1                     SEGMENT ID (0 FOR ER, WX, NULL)
SYMLRID  DS    0XL2                    ESD ID OF DEF FOR LR
SYMLENG  DS    XL3                     LENGTH FOR SD, PC, CM, PR
*                        0 FOR ER, WX, NULL
SYMESDID DS    XL2                     ESD ID OF THIS ITEM
         DS    0F        FULLWORD BOUNDARY
STXTSTRT DS    F
STXTCURR DS    F
STXTEND  DS    F
SDATE    DS    CL3
         DS    CL1
SSTART   DS    F
SEND     DS    F
SLENGTH  DS    F
DISASM   CSECT
*
*
*
BUFFER   DC    0F'0',X'0200'           LENGTH + SP FOR GETMAIN
BUFFLEN  DC    H'0'                    MAX BLOCKSIZE
MODAREA  DC    0F'0',X'0200'           LENGTH + SP FOR GETMAIN
MODLEN   DC    H'0'                    MAX MODULE SIZE
ALLSWT   DC    X'00'                   DISASM ALL CSECT
ESDSWT   DC    X'00'
         DS    0F                      FULLWORD BOUNDARY
MODSIZE  DC    F'0'                    MODULE SIZE
CSLNGTH  DC    F'0'                    CSECT  SIZE LENGTH
SAVER11  DC    F'0'                    REGISTER 11
SAVER12  DC    F'0'                    REGISTER 12
NXTSYPTR DC    F'0'                    SYM TBL POINTER ADDR
ENDSYML  DC    F'38000'                SYM TBL END ADDR
ENDRLDL  DC    F'60000'                RLD TBL END ADDR
BUFAD    DS    F                       SYSLIB BUFFER ADDR
BUFAD2   DS    F                       SYSLIB BUFFER ADDR
BUFAD3   DS    F                       SYSLIB BUFFER ADDR
SYMTBAD  DS    F                       SYMBOL TABLE ADDRESS
CURRSYM  DS    F                       CURRENT SYM TBL ADDR
ENDSYM   DC    F'38000'                SYM TBL END ADDR
RLDTBL   DS    F                       ADDR OF RLD TABLE
CURRLD   DS    F                       CURR RLD TBL ADDR
ENDRLD   DC    F'60000'                RLD TBL END ADDR
ENDATO   DC    F'1536'                 DATA ONLY TBL LENGTH
PROCESS  DC    XL1'00'                 PROCESS INDIC 80=SYM TBL BUILT
CES9     DS    F                       CESDREC RETURN ADDR
BL9      DS    F                       BLDL RTN RETURN ADDR
CR9      DS    F                       CTRLRECS RETURN ADDR
CT9      DS    F                       CNTLRECS RETURN ADDR
RL9      DS    F                       RLDRECS RETURN ADDR
TX9      DS    F                       TXTFMT RETURN ADDR
HIVAL    DC    4X'FF'                  CONSTANT F'S
H1000    DC    H'1000'                 CONSTANT 1000
H100     DC    H'100'                  CONSTANT 100
H10      DC    H'10'                   CONSTANT 10
SYMLEN   DC    AL2(L'SYMENT)           LENGTH OF SYMTBL ENTRY        */
PRTABL   DS    CL9                     HEX-PRINTABLE CONVERSION AREA
P0       DC    P'0'                    CONSTANT 0
P1       DC    P'1'                    CONSTANT 1
P58      DC    P'58'                   CONSTANT 58
JFCBAD   DS    0F                      DCB EXIT LIST
         DC    X'87'                   RDJFCB, END OF LIST
         DC    AL3(JFCB)               ADDRESS OF JFCB READ AREA
JFCB     DS    CL176                   JFCB
SYMHDR   DC    C'0     SYMBOL        TYPE   IND  ADDR'
         DC    C'    SEG  LRID   LENG  ESDID'
         DC    CL64' '
*
*
*
RLDHDR   DC    C'0     RELPTR  POSPTR      TYPE     LEN'
         DC    C'    DIR   ADDR'
         DC    CL90' '
*
*
*
PH1LBL   DC    CL121'1***** PHASE 1 LABEL TABLE ***** CSECT '
PH1HDR   DC    CL121'0  ADDR TYPE  SYMBOL  LEN'
*
*
*
H1       DC    H'1'                    CONSTANT 1
H5       DC    H'5'                    CONSTANT 5
H11      DC    H'11'                   CONSTANT 11
H16      DC    H'16'                   CONSTANT 16
H256     DC    H'256'                  CONSTANT 256
BLANX    DC    CL121' '                CONSTANT BLANKS
XZROS    DC    8X'00'                  CONSTANT ZEROS
TRTBL    DC    C'0123456789ABCDEF'     TRANSLATE TBL
NOCNTRL  DC    C'MEMBER AND CSECT MUST BE ENTERED VIA SYSIN'
OVER8    DC    C'MEMBER OR CSECT NAME OVER 8 CHARACTERS'
NOMEM    DC    C'NO MEMBER NAME FOUND IN CONTROL CARD OR PARM'
INVMEM   DC    C'SPECIFIED MEMBER NOT FOUND IN SYSLIB PDS'
INVCSECT DC    C'SPECIFIED CSECT NOT FOUND IN MEMBER'
INXCSECT DC    C'CNTL CSECT NOT IN SYM TABLE'
FULLSYM  DC    C'SYMBOL TABLE FULL: OVER 2000 ENTRIES'
FULLRLD  DC    C'RLD TABLE FULL: OVER 3000 ENTRIES'
         LTORG
POFSET   DC    F'0'                    OFFSET FOR TEXT PRINT
*
*
*
SYSPUNCH DCB   DSORG=PS,MACRF=(PM,GM),DDNAME=SYSPUNCH,                 X
               RECFM=FB,LRECL=80
SYSIN    DCB   DSORG=PS,MACRF=GL,DDNAME=SYSIN,                         X
               RECFM=FB,LRECL=80,EODAD=NOCTL
SYSLIB   DCB   DSORG=PO,MACRF=R,DDNAME=SYSLIB,                         X
               RECFM=U,NCP=1
SYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,                      X
               RECFM=FBA,LRECL=121
LOADLIB  DCB   DSORG=PO,MACRF=R,DDNAME=LOADLIB,EXLST=JFCBAD
*SNAPEXEC SNAP  DCB=SYSSNAP,PDATA=(REGS),LIST=SNAPA,ID=255,MF=L
*YSSNAP  DCB   DDNAME=SYSSNAP,BLKSIZE=882,DSORG=PS,LRECL=125,
*              MACRF=(W),RECFM=VBA
PRTCHAR  DC    256C'.'                 CHARACTER TRANSLATE TABLE
         ORG   PRTCHAR+C' '
         DC    C' '
         ORG   PRTCHAR+C'A'
         DC    C'ABCDEFGHI'
         ORG   PRTCHAR+C'J'
         DC    C'JKLMNOPQR'
         ORG   PRTCHAR+C'S'
         DC    C'STUVWXYZ'
         ORG   PRTCHAR+C'0'
         DC    C'0123456789'
         ORG
*SNAPA    10F'0'
         END
./       ADD   NAME=DISASMX1
DIS1     TITLE '*** DISASSEMBLY PHASE 1 ***'
         MACRO
&NAME    SVLNK &REG1,&REG2,&REG3,&IND,&LV=
         GBLC  &EQU
         GBLC  &GM
         GBLC  &CSECT
         LCLC  &REGA
         AIF   (T'&NAME EQ 'O').NOCSECT
         AIF   ('&NAME' EQ '*').NOCSECT
&CSECT   SETC  '&NAME'
&CSECT   CSECT 
         AGO   .RST
.NOCSECT ANOP
&CSECT   SETC  '*'
         CSECT 
.RST     ANOP
         AIF   ('&EQU' EQ 'ON').NRQ
&EQU     SETC  'ON'
*
***REGISTER EQUATES***
*
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
.NRQ     ANOP
*
*******************  PROGRAM INITIALIZATION  *************************
*
         AIF   (T'&REG1 EQ 'O').NOREG
&REGA    SETC  '&REG1'
         AIF   (T'&REG2 EQ 'O').ONEREG
         USING &CSECT,&REGA,&REG2 
         AGO   .BYUSE
.NOREG   ANOP
&REGA    SETC  'R3'
.ONEREG  USING &CSECT,&REGA 
.BYUSE   ANOP
         STM   R14,R12,12(R13) :       STORE REGS IN HIGH SAVE AREA
         LR    &REGA,R15 
         AIF   (T'&REG2 EQ 'O').NOLA
         LA    &REG2,4095(&REGA) 
         LA    &REG2,1(&REG2) 
.NOLA    ANOP
         AIF   (T'&REG3 EQ 'O').NOLNK
         L     &REG3,0(R1) 
.NOLNK   ANOP
         AIF (T'&IND EQ 'O').GETIT
         CNOP  0,4
         BAL   R15,SAVEAREA+72 
SAVEAREA DS    18F 
         ST    R15,8(R13)
         ST    R13,SAVEAREA+4
         LR    R13,R15
         AGO   .NOSAVE
.GETIT   ANOP
         AIF   (T'&LV EQ 'O').GMD
&GM      SETC  '&LV'
         AGO   .DGM
.GMD     ANOP
&GM      SETC  '72'
.DGM     ANOP
*
***GET MAIN STORAGE FOR SAVE AREA***
*
         AIF   ('&GM' LT '4096').LA
         GETMAIN R,LV=&GM 
         AGO   .EGM
.LA      ANOP
         LA    R0,&GM                  GET &GM BYTES
         GETMAIN R,LV=(0)
.EGM     ANOP
*
***SET UP SAVE AREA POINTERS***
*
         ST    R1,8(R13) 
         ST    R13,4(R1) 
         LR    R13,R1 
         AIF   (T'&REG3  NE 'O').NOSAVE
         L     R1,4(R13) 
         L     R1,24(R1) 
.NOSAVE  ANOP
         AIF   ('&CSECT' EQ '*').EXIT
         B     *+12
         DC    CL8'&CSECT'  
.EXIT    ANOP
*
*********************  END INITIALIZATION  ***************************
*
         MEND
         EJECT
DISASM1  SVLNK R3,R4
         PRINT NOGEN
* THIS SUB-PROGRAM IS CALLED BY DISASM, AND IS PHASE 2 OF
* THE DISASSEMBLY PROCESS. A COMMON DATA
* AREA IS DEFINED IN DISASM, AND PASSED TO THIS PROGRAM.
*
*    THE SYSIN FILE IS READ TO EXHAUSTION. USING CARDS ARE
* REFORMATTED AND STORED IN A TABLE - UP TO 256 USING
* STATEMENTS MAY BE ENTERED. DSECT CARDS MAY FOLLOW THE
* USING STATEMENTS. WHEN USED, DSECT STATEMENTS ARE
* REFORMATTED, AND BUILT INTO TABLES. A MAXIMUM OF 256 DSECTS
* MAY BE ENTERED. DATA ONLY CARDS MAY BE INCLUDED BEFORE, BETWEEN,
* OR AFTER DSECTS TO SHOW AREAS IN THE PROGRAM WHERE NO INSTRUCTIONS
* OCCUR. UP TO 256 DATA ONLY AREAS MAY BE SPECIFIED.
*
*     AT EOF ON SYSIN, A PSEUDO DIS-ASSEMBLY PASS IS MADE
* USING THE TEXT STORED BY DISASM. ANY RESOLVABLE ADDRESS
* WITHIN THE TEXT IS USED TO CREATE A NEW ENTRY IN THE
* LABEL TABLE, WHICH WILL BE USED BY DISASM2 IN THE
* ACTUAL DIS-ASSEMBLY PASS.
*
* THE USING CARDS FOR BASE REGISTERS ASSOCIATED WITH DSECT DEFINITIONS
* MUST BE ENTERED AT SOME POINT AFTER THE DSECT CARDS HAVE BEEN
* INCLUDED. USING CARDS FOR PROGRAM BASE REGISTERS MAY BE ENTERED
* AT ANY POINT. THE USING CARD FORMAT IS:
*       COL 1-5   : LITERAL 'USING'
*       COL 6     : BLANK
*       COL 7-12  : OFFSET TO BEGIN LOCATION FOR USING RANGE (HEX)
*       COL 13    : BLANK
*       COL 14-19 : OFFSET TO ENDING LOCATION FOR USING RANGE (HEX)
*       COL 20    : BLANK
*       COL 21    : BASE RESISTER TO BE USED (HEX, 1-F)
*       COL 22    : BLANK
*       COL 23    : TYPE, P=PROGRAM BASE, D=DSECT BASE
*       COL 24    : BLANK
*       COL 25-30 : INITIAL BASE REGISTER VALUE IF TYPE P (HEX)
*       COL 25-32 : DSECT NAME IF TYPE D
*
*     A DSECT IS ENTERED USING A HEADER CARD,FOLLOWED BY
* ONE OR MORE FIELD DEFINITION CARDS. ALL FIELD DEFINITION
* CARDS MUST FOLLOW THE DSECT HEADER CARD. USING CARDS MAY
* NOT BE INTERSPERSED WITH DSECT DEFINITIONS, BUT MAY PRECEDE
* OR FOLLOW ANY DSECT.
*     DSECT HEADER CARD FORMAT:
*        COL 1-8    : DSECT NAME
*        COL 9      : BLANK
*        COL 10-14  : LITERAL 'DSECT'
*        COL 15     : BLANK
*        COL 16-19  : NUMBER OF FIELD CARDS TO FOLLOW (DECIMAL)
*
*     DSECT FIELD CARD FORMAT:
*        COL 1-8    : FIELD NAME
*        COL 9      : BLANK
*        COL 10-13  : OFFSET TO LEFT END OF FIELD (DECIMAL)
*        COL 14     : BLANK
*        COL 15-17  : LENGTH OF FIELD IN BYTES (DECIMAL)
*
*     A DATA ONLY CARD IS USED TO DESIGNATE A RANGE OF OFFSETS
* BETWEEN WHICH NO INSTRUCTIONS EXIST. USE OF THESE CARDS ELIMINATES
* THE CHANCE THAT DATA ELEMENTS WILL BE TREATED AS INSTRUCTIONS
* BETWEEN THE OFFSETS SPECIFIED. FORMAT IS:
*        COL 1-4    : LITERAL 'DATA'
*        COL 5      : BLANK
*        COL 6-11   : OFFSET TO BEGINNING OF AREA (HEX)
*        COL 12     : BLANK
*        COL 13-18  : OFFSET TO END OF AREA (HEX)
*
*
*     USER LABEL CARDS ARE USED TO PERMIT SPECIFICATION OF
* LABELS OTHER THAN THE AXXXXXX NAMES CREATED BY DISASM. THEY
* MAY APPEAR ANYWHERE IN THE SYSIN STREAM EXCEPT AS THE FIRST
* CARD, OR WITHIN A DSECT DEFINITION.
*        COL  1-5  : LITERAL 'ULABL'
*        COL   6   : BLANK
*        COL  7-14 : FIELD NAME
*        COL   15  : BLANK
*        COL 16-21 : OFFSET TO LEFT END OF AREA (HEX)
*        COL   22  : BLANK
*        COL 23-25 : FIELD LENGTH (DECIMAL)
*
*      DISASSEMBLY TABLES ARE SET UP IDENTICALLY TO THOSE USED BY
* DISASM2 FOR THE SIMULATED DISASSEMBLY PERFORMED IN THIS
* MODULE WHEN ANY PROGRAM BASE REGISTER USING STATEMENTS
* ARE ENTERED.
*
*     STORAGE IS OBTAINED FOR THE DSECT TABLE AND USING TABLE,
* AND ADDRESSES OF THESE TABLES ARE STORED IN THE COMMON PARAMETER
* AREA. USING AND DSECT CARDS ARE EDITED, REFORMATTED, AND PLACED
* IN THE APPROPRIATE TABLES. IF ANY ERRORS ARE FOUND, THEY ARE
* PRINTED, AND THE DISASSEMBLY WILL BE TERMINATED ON RETURN
* TO DISASM.
*
*     STORAGE IS OBTAINED FOR THE LABEL TABLE, AND A SIMULATED
* DIS-ASSEMBLY IS PERFORMED TO CREATE LABEL TABLE ENTRIES FOR
* LABELS WHICH WILL BE GENERATED FOR BASE-DISPLACEMENT ADDRESSES
* BY DISASM2. ON RETURN TO DISASM, THESE LABELS WILL BE SORTED
* WITH EXTERNAL SYMBOL AND RLD LABELS TO FORM THE FINAL LABEL
* TABLE TO BE USED BY DISASM2.
*
*
*
*
* AUTHOR R THORNTON - FEB 1978
*
*
******************************************************************
*                                                                *
* CHECK FOR PRIVILEGED AND/OR FLOATING POINT INSTRUCTION OPTION. *
* IF THESE INSTRUCTIONS ARE NOT TO BE ASSEMBLED, CLEAR THEIR     *
* INSTRUCTION TABLE ENTRIES.                                     *
*                                                                *
******************************************************************
*
         L     R5,0(R1)                GET PARM FIELD ADDRESS
         USING COMMPARM,R5
         CLI   FLPTASM,1               FLOATING POINT INSTR O.K.
         BE    TSTPRIV                 YES
         LA    R12,SGLOP               POINT TO OP-CODE TBL
TSTOPND  CLI   0(R12),X'FF'            END OF TBL
         BE    TSTPRIV                 YES
         TM    ICLASS-INSTENT(R12),FLTPT IS IT FLOATING POINT
         BZ    FLPSTP                  NO
         XC    0(L'SGLOP,R12),0(R12)   CLEAR ENTRY
FLPSTP   LA    R12,L'SGLOP(R12)        TO NEXT ENTRY
         B     TSTOPND                 LOOP THRU TABLE
TSTPRIV  CLI   PRIVASM,1               PRIVILEGED INSTR O.K.
         BE    GETUSGTB                YES
         LA    R12,SGLOP               POINT TO OP-CODE TBL
TTOPND   CLI   0(R12),X'FF'            END OF TABLE
         BE    CKDBLS                  YES
         TM    ICLASS-INSTENT(R12),PRIV PRIVILEGED INSTR
         BZ    PRIVSTP                 NO
         XC    0(L'SGLOP,R12),0(R12)   YES, CLEAR ENTRY
PRIVSTP  LA    R12,L'SGLOP(R12)        TO NEXT ENTRY
         B     TTOPND                  LOOP THRU TABLE
CKDBLS   L     R12,DBLOPAD             @ 2-BYTE OP-CODE TBL
CKDBND   CLI   0(R12),X'FF'            END OF TBL
         BE    GETUSGTB                YES
         TM    ICLASS-INSTENT+2(R12),PRIV PRIVILEGED OP-CODE
         BZ    DBSTP                   NO
         XC    0(L'DBLOP,R12),0(R12)   YES, CLEAR ENTRY
DBSTP    LA    R12,L'DBLOP(R12)        TO NEXT ENTRY
         B     CKDBND                  LOOP THRU TABLE
*
******************************************************************
*                                                                *
* GET STORAGE FOR USING AND DSECT POINTER TABLES.                *
*                                                                *
******************************************************************
*
GETUSGTB GETMAIN R,LV=2864             GET STORAGE FOR USING TABLE
         MVI   0(R1),X'FF'             SET TABLE END INDIC
         ST    R1,USGSTRT              SAVE TABLE START ADDR
         ST    R1,USGCUR               SET TABLE CURRENT ADDR
         LA    R1,2816(R1)             COMPUTE TABLE END ADDR
         ST    R1,USGEND               SAVE USING TABLE END ADDR
         L     R2,INDCB                GET SYSIN DCB ADDR
         LA    R1,EOFCARD              GET EOF ADDR
         STCM  R1,7,33(R2)             SET EOF ADDR IN DCB
         GETMAIN R,LV=2864             GET STORAGE FOR DSECT TABLE
         MVI   0(R1),X'FF'             SET TABLE END ADDR
         ST    R1,DTBSTRT              SAVE DSECT TABLE START ADDR
         ST    R1,DTBCUR               SAVE DSECT TABLE CURRENT ADDR
         LA    R1,2816(R1)             COMPUTE TABLE END ADDR
         ST    R1,DTBEND               SAVE DSECT TABLE END ADDR
         L     R1,INDCB                @ SYSIN DCB
         TM    48(R1),X'10'            IS IT OPEN
         BZ    EOFCARD                 NO
*
*
*
******************************************************************
*                                                                *
* READ SYSIN CARDS, AND DISTRIBUTE TO THE APPROPRIATE PROCESSING *
* ROUTINE: USINGS, DSECTS, OR DATAS. DETECT ANY ERRORS AND PRINT *
* ALL CARDS WITH MESSAGES AS NECESSARY.                          *
*                                                                *
******************************************************************
*
RDCARD   EQU   *                       *** PROCESS SYSIN CARDS ***
         L     R1,INDCB                GET SYSIN DCB ADDR
         GET   (1)                     READ NEXT CARD
         MVC   WORKREC,0(R1)           MOVE IT TO WORK AREA
         NOP   MVPRT                   FIRST TIME SWITCH
         MVI   *-3,C'0'                RESET FIRST TIME SWITCH
         MVI   PCC,C'1'                SET SKIP TO HEAD
         MVC   PRT+10(26),=C'*** USER ENTERED CARDS ***'
         BAL   R9,PRINT                GO PRINT
MVPRT    MVC   PRT(80),WORKREC         CARD TO PRINT
RDGRTN   LA    R9,RCCKERR              GET RETURN ADDRESS
         CLC   WORKREC(5),=C'USING'    IS IT A USING CARD
         BE    USINGS                  YES
         CLC   WORKREC+9(5),=C'DSECT'  IS IT A DSECT HEADER
         BE    DSECTS                  YES
         CLC   WORKREC(4),=C'DATA'     IS IT DATA ONLY CARD
         BE    DATAS                   YES
         CLC   WORKREC(5),=C'ULABL'    IS IT A USER LABEL
         BE    ULABLS                  YES
         CLC   WORKREC(5),=C'RESET'    IS IT A RESET
         BE    RESET                   YES
         MVC   PRT+85(21),=C'UNIDENT OR OUT OF SEQ'
         MVI   USERR,X'FF'             SET ERROR FLAG
RCCKERR  NI    USERR,X'FE'             RESET CURRENT ERROR FLAG
         BAL   R9,PRINT                GO PRINT
         B     RDCARD                  CONTINUE
EOFCARD  CLI   USERR,0                 ANY ERRORS FOUND
         BNE   EOJ                     YES, EXIT
*
******************************************************************
*                                                                *
* CHECK FOR ANY USING CARDS ENTERED. IF NOT, NO PRE-ASSEMBLY IS  *
* NECESSARY. IF ANY USING CARDS FOUND, CREATE LABEL TABLE ENTRIES*
* SO THAT USING STATEMENTS WILL BE VALID.                        *
*                                                                *
******************************************************************
*
         L     R1,DATOCUR              GET CURRENT DATA ONLY @
         MVC   NOINAD,DATONLY          SAVE DATA ONLY TBL ADDR
         MVC   0(3,R1),HIVAL           SET END
         L     R11,USGSTRT             GET USING TBL ADDR
CUSNGND  CLI   0(R11),X'FF'            END OF TABLE
         BE    CKPRE                   GO CHECK FOR PRE-DISASM
         L     R10,CURRLBL             GET LABEL ADDRESS
         USING USINGD,R11
         USING LABELD,R10
         MVC   LBLADR,USVALU           OFFSET TO LABEL
         MVI   LBLTYP,C'L'             LABEL TYPE ENTRY
         MVI   LBLLEN,1                SET LENGTH TO 1
         MVI   LBLNAME,C'A'            1ST CHAR OF NAME
         LA    R12,USVALU              @ OFFSET
         BAL   R9,HEXPRT3              CONVERT
         MVC   LBLNAME+1(6),PRTABL     MIDDLE OF NAME
         MVI   LBLNAME+7,C' '          BLANK LAST POS
         LA    R10,L'LABEL(R10)        STEP TO NEXT LABEL
         ST    R10,CURRLBL             SAVE IN CURRLBL     FIX******
         MVC   0(3,R10),HIVAL          SET END VALUE       FIX******
         LA    R11,L'USING(R11)        STEP TO NEXT USING
         B     CUSNGND                 LOOP
         DROP  R10
         DROP  R11
CKPRE    L     R1,USGSTRT              GET USING TBL START ADDR
         CLI   0(R1),X'FF'             ANY ENTRIES
         BNE   MAINLINE                YES, GO TO PRE-DISASM
         B     EOJ                     OTHERWISE GET OUT
*
*
*
*
******************************************************************
*                                                                *
* EDIT USING CARDS FOR VALIDITY. PUT APPROPRIATE COMMENT IN PRINT*
* LINE WHEN INVALID. WHEN NO ERRORS FOUND, CREATE AN ENTRY IN THE*
* USING TABLE.                                                   *
*                                                                *
******************************************************************
*
USINGS   EQU   *                       *** USING CARD PROCESSING ***
         L     R12,USGCUR              GET CURRENT USING TBL ADDR
         C     R12,USGEND              END OF TBL
         BNL   UERR6                   YES, TABLE FULL
         USING USINGD,R12
         TR    WORKREC+6(6),TRHEX      TRANSLATE TO MAKE HEX
         TRT   WORKREC+6(6),TRTHEX     CHECK VALID
         BNZ   UERR1                   INVALID BEGIN ADDR
         TR    WORKREC+13(6),TRHEX     TRANSLATE TO MAKE HEX
         TRT   WORKREC+13(6),TRTHEX    CHECK VALID
         BNZ   UERR2                   INVALID END ADDR
         TR    WORKREC+20(1),TRHEX     TRANSLATE TO MAKE HEX
         TRT   WORKREC+20(1),TRTHEX    CHECK VALID
         BNZ   UERR3                   INVALID BASE REG
         CLI   WORKREC+20,0            VALID BASE REG
         BE    UERR3                   NO
         CLI   WORKREC+22,C'P'         VALID TYPE
         BE    CKINIT                  YES, PROGRAM BASE
         CLI   WORKREC+22,C'D'         VALID TYPE
         BNE   UERR8                   NO, ERROR
         L     R1,DTBSTRT              GET DSECT TABLE STRT
CKDSEND  CLI   0(R1),X'FF'             END OF TABLE
         BE    UERR5                   YES, MISSING DSECT
         CLC   0(8,R1),WORKREC+24      THIS THE DSECT ENTRY
         BE    USDSMV                  YES
         LA    R1,11(R1)               TO NEXT ENTRY
         B     CKDSEND                 LOOP THRU DSECT TABLE
USDSMV   MVC   USVALU,8(R1)            MOVE DSECT TBL ADDR
         B     USFINI                  CONTINUE
CKINIT   TR    WORKREC+24(6),TRHEX     TRANSLATE TO MAKE HEX
         TRT   WORKREC+24(6),TRTHEX    CHECK VALIDITY
         BNZ   UERR4                   INVALID BASE REG VALUE
         PACK  DBLWD(4),WORKREC+24(7)  PACK TO MAKE HEX
         MVC   USVALU,DBLWD            BASE REG VALUE TO USING TBL
USFINI   PACK  DBLWD(4),WORKREC+6(7)   PACK TO MAKE HEX
         MVC   USBGN,DBLWD             BEGIN ADDR TO USING TABLE
         PACK  DBLWD(4),WORKREC+13(7)  PACK TO MAKE HEX
         MVC   USEND,DBLWD             END ADDR TO USING TABLE
         TM    USEND+2,1               IS IT ODD
         BO    UERR2                   YES, ERROR
         CLI   WORKREC+22,C'D'         DSECT BASE
         BE    USFREG                  YES
         CLC   USEND,LENGTH+1          WITHIN PROGRAM
         BH    UERR2                   YES, ERROR
USFREG   MVC   USREG,WORKREC+20        BASE REG TO USING TABLE
         MVC   USTYPE,WORKREC+22       TYPE TO USING TABLE
         CLC   USBGN,USEND             END < BEGIN
         BH    UERR7                   YES, ERROR
         LA    R12,L'USING(R12)        TO NEXT USING TBL ENTRY
         MVI   0(R12),X'FF'            SET TABLE END INDIC
         ST    R12,USGCUR              SAVE UPDATED TABLE ADDR
         BR    R9                      EXIT
UERR1    MVC   PRT+85(22),=C'INVALID BEGIN COL 7-12'
         B     UERRS                   CONTINUE
UERR2    MVC   PRT+85(21),=C'INVALID END COL 14-19'
         B     UERRS                   CONTINUE
UERR3    MVC   PRT+85(18),=C'INVALID REG COL 21'
         B     UERRS                   CONTINUE
UERR4    MVC   PRT+85(25),=C'INVALID ADDRESS COL 25-30'
         B     UERRS                   CONTINUE
UERR5    MVC   PRT+85(25),=C'UNDEFINED DSECT COL 25-32'
         B     UERRS                   CONTINUE
UERR6    MVC   PRT+85(20),=C'OVER 256 USING CARDS'
         B     UERRS                   CONTINUE
UERR7    MVC   PRT+85(16),=C'END BEFORE BEGIN'
         B     UERRS                   CONTINUE
UERR8    MVC   PRT+85(19),=C'INVALID TYPE COL 23'
UERRS    MVI   USBGN,X'FF'             INSURE TABLE END INDIC
         MVI   USERR,X'FF'             SHOW ERROR
         BR    R9                      EXIT
         DROP  R12
*
*
*
******************************************************************
*                                                                *
* EDIT ULABL CARDS FOR VALIDITY. PUT APPROPRIATE COMMENT IN PRINT*
* LINE WHEN INVALID. WHEN NO ERRORS FOUND, CREATE AN ENTRY IN THE*
* LABEL TABLE. SEARCH FOR ANY TYPE A (ADCON) ENTRIES HAVING A    *
* SYMBOL OF AXXXXXX, WHERE XXXXXX IS THE HEX OFFSET TO THE USER  *
* LABEL. IF AN A TYPE ENTRY IS FOUND, CHANGE ITS SYMBOLIC NAME TO*
* THAT OF THE USER LABEL.                                        *
*                                                                *
******************************************************************
*
ULABLS   EQU   *                       PROCESS USER LABEL CARDS
         STM   R6,R12,ULSAV            SAVE REGS
         CLI   WORKREC+6,C' '          NAME VALID
         BE    ULERR1                  NO, 1ST CHAR CANNOT BE BLANK
         MVC   UNAME+1(6),WORKREC+15   BUILD AXXXXXX NAME
         TR    WORKREC+15(6),TRHEX     TRANSLATE TO MAKE HEX
         TRT   WORKREC+15(6),TRTHEX    CHECK VALID HEX
         BNZ   ULERR2                  NOT VALID
         MVZ   NUMCK,WORKREC+22        ZONES FOR NUMERIC TEST
         CLC   NUMCK(3),ZEROS          LENGTH IS NUMERIC
         BNE   ULERR3                  NO, ERROR
         L     R6,CURRLBL              GET CURRENT LABEL TABLE ADDRESS
         USING LABELD,R6
         C     R6,ENDLBL               END OF TABLE
         BNL   ULERR4                  YES, ERROR
         MVC   LBLNAME,WORKREC+6       NAME TO LABEL ENTRY
         MVI   LBLTYP,C'U'             TYPE TO LABEL ENTRY
         PACK  DBLWD,WORKREC+22(3)     PACK LENGTH
         CP    DBLWD,P256              LENGTH > 256
         BH    ULERR2                  YES, ERROR
         CVB   R12,DBLWD               CONVERT TO BINARY
         STC   R12,LBLLEN              LENGTH TO LABEL ENTRY
         PACK  DBLWD(4),WORKREC+15(7)  PACK TO MAKE VALID HEX
         MVC   LBLADR,DBLWD            OFFSET TO LABEL
         LA    R7,L'LABEL(R6)          @ NEXT LABEL ENTRY
         MVC   0(3,R7),HIVAL           SET END INDIC
         ST    R7,CURRLBL              SET NEW TABLE END ADDR
         LR    R7,R6                   SAVE NEW ENTRY ADDRESS
         L     R6,LBLTBL               GET 1ST LABEL ENTRY ADDR
ULBCKND  C     R6,CURRLBL              END OF TABLE
         BNL   ULXIT                   YES, EXIT
         CLI   LBLTYP,C'A'             IS IT ADCON ENTRY
         BNE   ULBSTEP                 NO
         CLC   LBLNAME,UNAME           ADCON SYMBOL AT USER LBL ADDR
         BNE   ULBSTEP                 NO
         MVC   LBLNAME,LBLNAME-LABEL(R7) SET USER SYMBOL IN ADCON
ULBSTEP  LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY
         B     ULBCKND                 LOOP THRU LABEL TABLE
         B     ULXIT                   EXIT
ULERR1   MVC   PRT+85(21),=C'INVALID NAME COL 7-14'
         B     ULERRS                  CONTINUE
ULERR2   MVC   PRT+85(28),=C'INVALID HEX OFFSET COL 16-21'
         B     ULERRS                  CONTINUE
ULERR3   MVC   PRT+85(32),=C'INVALID DECIMAL LENGTH COL 23-25'
         B     ULERRS                  CONTINUE
ULERR4   MVC   PRT+85(20),=C'LABEL TABLE OVERFLOW'
ULERRS   MVI   USERR,X'FF'             SET ERROR FLAG
ULXIT    LM    R6,R12,ULSAV            RESTORE REGS
         BR    R9                      EXIT
RESET    MVI   USERR,X'10'             SET RESET FLAG
*        STM   R6,R12,RESAV            SAVE REGS
*REXIT    LM    R6,R12,RESAV            RESTORE REGS
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* EDIT DSECT CARDS FOR VALIDITY. PUT APPROPRIATE COMMENT IN PRINT*
* LINE WHEN INVALID. WHEN NO ERRORS FOUND, CREATE AN ENTRY IN THE*
* DSECT HEADER TABLE, GETMAIN AN AREA TO CONTAIN THE FIELD       *
* DESCRIPTION ENTRIES, READ AND BUILD FIELD ENTRIES FOR ALL FIELD*
* DESCRIPTION CARDS ENTERED.                                     *
*                                                                *
******************************************************************
*
DSECTS   EQU   *                       *** DSECT PROCESSING ***
         ST    R9,DSCT9                SAVE RETURN ADDR
         CLI   WORKREC,C' '            NAME IS BLANK
         BE    DSERR1                  YES, ERROR
         MVZ   NUMCK,WORKREC+15        ZONES FOR CHECK
         CLC   NUMCK,ZEROS             IS NBR FIELDS NUMERIC
         BNE   DSERR2                  NO, ERROR
         L     R12,DTBCUR              GET CURRENT DSECT TBL ADDR
         C     R12,DTBEND              AT END OF TABLE
         BNL   DSERR3                  YES, ERROR
         MVC   0(8,R12),WORKREC        NAME TO DSECT TABLE
         PACK  DBLWD,WORKREC+15(4)     PACK NBR ENTRIES
         CVB   R10,DBLWD               CONVERT TO BINARY
         LA    R10,4(R10)              ADD FOR SAFETY
         MH    R10,DTBLEN              TIMES ENTRY LENGTH
         GETMAIN R,LV=(10)             GET STORAGE FOR FIELD TABLE
         STCM  R1,7,8(R12)             SAVE FIELD TABLE ADDRESS
         LA    R12,11(R12)             TO NEXT DSECT TABLE ENTRY
         ST    R12,DTBCUR              UPDATE CURRENT DSECT TBL ADDR
         MVI   0(R12),X'FF'            SET END INDIC
         LR    R12,R1                  COPY FIELD TABLE ADDR
         BAL   R9,PRINT                PRINT DSECT RECORD
         USING DSECTD,R12
         CVB   R11,DBLWD               NBR ENTRIES IN LOOP REG
RDFLD    L     R1,INDCB                GET SYSIN DCB ADDR
         GET   (1)                     READ NEXT CARD
         MVC   WORKREC,0(R1)           MOVE RECORD TO WORK AREA
         MVC   PRT(80),WORKREC         MOVE RECORD TO PRINT AREA
         CLI   WORKREC,C' '            NAME FIELD BLANK
         BE    DSERR1                  YES, ERROR
         MVC   DSNAME,WORKREC          NAME TO ENTRY
         MVI   DSLBTYP,C'L'            SET LABEL TYPE
         MVZ   NUMCK,WORKREC+9         ZONES FOR TEST
         CLC   NUMCK,ZEROS             IS OFFSET NUMERIC
         BNE   DSERR3                  NO, ERROR
         PACK  DBLWD,WORKREC+9(4)      PACK OFFSET
         CP    DBLWD,P4096             OFFSET > 4096
         BH    DSERR3                  YES, ERROR
         CVB   R1,DBLWD                CONVERT
         STCM  R1,7,DSOFSET            OFFSET TO TABLE ENTRY
         MVZ   NUMCK(3),WORKREC+14     ZONES FOR TEST
         CLC   NUMCK(3),ZEROS          IS LENGTH NUMERIC
         BNE   DSERR4                  NO, ERROR
         PACK  DBLWD,WORKREC+14(3)     PACK LENGTH
         CP    DBLWD,P256              LENGTH OVER 256
         BH    DSERR4                  YES, ERROR
         CVB   R1,DBLWD                CONVERT
         LTR   R1,R1                   LENGTH IS ZERO
         BZ    DSERR4                  YES, ERROR
         STC   R1,DSLENG               LENGTH TO TABLE ENTRY
         LA    R12,L'DSECT(R12)        TO NEXT ENTRY
         MVI   0(R12),X'FF'            SET TBL END INDIC
         BAL   R9,PRINT                GO PRINT CARD
         BCT   R11,RDFLD               LOOP THRU DSECT
         MVC   DSOFSET,HIVAL           TABLE STOPPER
         L     R9,DSCT9                GET RETURN ADDR
         BR    R9                      EXIT
DSERR1   MVC   PRT+85(20),=C'INVALID NAME COL 1-8'
         B     DSERRS                  CONTINUE
DSERR2   MVC   PRT+85(28),=C'INVALID NBR FIELDS COL 16-19'
         B     DSERRS                  CONTINUE
DSERR3   MVC   PRT+85(24),=C'INVALID OFFSET COL 10-13'
         B     DSERRS                  CONTINUE
DSERR4   MVC   PRT+85(24),=C'INVALID LENGTH COL 15-18'
         B     DSERRS                  CONTINUE
DSERRS   MVI   USERR,X'FF'             SHOW ERROR FOUND
         L     R9,DSCT9                GET RETURN ADDR
         BR    R9                      EXIT
         DROP  R12
*
*
*
******************************************************************
*                                                                *
* EDIT DATA ONLY CARDS FOR VALIDITY. PLACE ERROR DESCRIPTION IN  *
* PRINT LINE IF ERRORS FOUND. CREATE DATA ONLY TABLE ENTRY IF NO *
* ERRORS ARE FOUND.                                              *
*                                                                *
******************************************************************
*
DATAS    EQU   *                       *** DATA CARD PROCESSING ***
         TR    WORKREC+5(6),TRHEX      TRANSLATE TO MAKE HEX
         TRT   WORKREC+5(6),TRTHEX     CHECK VALID
         BNZ   DERR1                   INVALID HEX
         TR    WORKREC+12(6),TRHEX     TRANSLATE TO MAKE HEX
         TRT   WORKREC+12(6),TRTHEX    CHECK VALID
         BNZ   DERR2                   INVALID HEX
         PACK  DBLWD(4),WORKREC+5(7)   PACK TO MAKE HEX
         PACK  DBLWD+4(4),WORKREC+12(7) PACK TO MAKE HEX
         CLC   DBLWD(3),DBLWD+4        CHECK 1ST LOW
         BNL   DERR3                   1ST NOT LOW, ERROR
         L     R1,DATOCUR              GET TBL ADDR
         MVC   0(3,R1),DBLWD           MOVE 1ST OFFSET TO TBL
         MVC   3(3,R1),DBLWD+4         MOVE 2ND OFFSET TO TBL
         LA    R1,6(R1)                TO NEXT ENTRY
         ST    R1,DATOCUR              SAVE CURRENT ENTRY ADDR
         BR    R9                      EXIT
DERR1    MVC   PRT+85(22),=C'1ST OFFSET INVALID HEX'
         B     DERRS                   CONTINUE
DERR2    MVC   PRT+85(22),=C'2ND OFFSET INVALID HEX'
         B     DERRS                   CONTINUE
DERR3    MVC   PRT+85(23),=C'END OFFSET BEFORE BEGIN'
DERRS    MVI   USERR,X'FF'             FLAG ERROR
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* MAINLINE ROUTINE FOR THE PRE-DISASSEMBLY. PURPOSE OF THIS PART *
* OF THE PROGRAM IS TO ATTEMPT TO CREATE A LABEL ENTRY FOR INSTR-*
* UCTIONS HAVING STORAGE OPERANDS. THE RESULTING LABEL TABLE WILL*
* BE SORTED, AND DUPLICATE ENTRIES ELIMINATED BEFORE EXIT FROM   *
* THIS PHASE OF DISASSEMBLY.                                     *
*                                                                *
******************************************************************
*
MAINLINE EQU   *                       MAINLINE ROUTINE
         L     R6,LBLTBL               @ LABEL TABLE
         USING LABELD,R6
         MVC   TXTCURR,TXTSTRT         COPY TEXT START ADDR
GETCURR  L     R7,TXTCURR              @ CURRENT TXT BYTE
         C     R7,TXTEND               END OF TEXT
         BNL   EOJ                     YES             FIX********
         LR    R12,R7                  COPY TEXT ADDR
         S     R12,TXTSTRT             COMPUTE OFFSET
         ST    R12,TXTOFST             SAVE OFFSET TO THIS BYTE
         CLC   NEXCHG,TXTOFSET         TIME TO CHANGE USING TBLS
         BH    CKDARNG                 NO
         BAL   R9,NEXUSG               YES, GO DO IT
CKDARNG  L     R12,NOINAD              GET DATA ONLY ENTRY ADDRESS
         CLC   TXTOFSET,0(R12)         NOT YET TO THIS RANGE
         BL    CKLOSEQ                 TRUE
         CLC   TXTOFSET,3(R12)         NOW IN THE RANGE
         BNH   CONST                   TRUE, TREAT AS CONSTANT
         LA    R12,6(R12)              PAST THIS ONE, STEP TO NEXT
         ST    R12,NOINAD              SAVE NEW ADDRESS
         B     CKDARNG                 AND CHECK AGAIN
CKLOSEQ  CLC   TXTOFSET,LBLADR         LABEL ENTRY OUT OF SEQ
         BNH   GCKODD                  NO, CONTINUE
         BAL   R9,FORCONST             YES, FORCE ANY CONSTANT OUT
         LA    R6,L'LABEL(R6)          TO NEXT LABEL
         B     CKLOSEQ                 CONTINUE SEQ CHK
GCKODD   TM    TXTCURR+3,1             ODD ADDRESS
         BO    CONST                   YES, NOT INSTR
         CLC   1(3,R7),0(R7)           4 CONSEC IDENTICAL BYTES
         BE    CONST                   YES, NOT INSTR
         TRT   0(1,R7),CHARTRAN        TEST TEXT BYTE
         BNZ   CKINSTR                 NOT CHARACTER
         CLI   CONPROG,1               IS CONSTANT IN PROGRESS
         BNE   CK6                     NO
         CLI   CONTYPE,C'C'            IS IT CHARACTER TYPE
         BE    CONST                   YES, ADD THIS TO CONSTANT
CK6      TRT   0(6,R7),CHARTRAN        6 CONSECUTIVE CHARACTERS
         BZ    CONST                   YES, NOT INSTRUCTION
CKINSTR  SR    R8,R8                   CLEAR WORK
         IC    R8,0(R7)                PICK UP TXT BYTE
         MH    R8,SGOPLEN              TIMES TABLE LENGTH
         LA    R8,SGLOP(R8)            @ INSTR TBL ENTRY
         MVC   INSTENT,0(R8)           SAVE INSTRUCTION TBL ENTRY
         CLI   INAME,0                 IS IT AN INSTR OP-CODE
         BE    CONST                   NO
         CLI   ITYPE,TWO               TWO-BYTE OP-CODE
         BNE   INSTR                   NO
         L     R8,DBLOPAD              YES, GET 2-BYTE TBL ADDR
DBLND    CLI   0(R8),X'FF'             END OF TABLE
         BE    CONST                   YES, NOT INSTR
         CLC   0(2,R8),0(R7)           THIS ENTRY MATCHES TXT
         BE    GOTDBLI                 YES
         LA    R8,L'DBLOP(R8)          TO NEXT ENTRY
         B     DBLND                   LOOP THRU TBL
GOTDBLI  LA    R8,2(R8)                PASS OP-CODE BYTES
*
*
*
******************************************************************
*                                                                *
* CHECK TO SEE IF THIS BYTE OF THE PROGRAM IS AN INSTRUCTION OP  *
* CODE. IF SO, PERFORM THE APPROPRIATE PROCESSING ROUTINE.       *
*                                                                *
******************************************************************
*
INSTR    EQU   *                       *** INSTRUCTIONS (POSSIBLY) ***
         MVC   ILENG+1(1),INLNG        SET INSTR LENGTH
         LH    R12,ILENG               PICK UP LENGTH
         AR    R12,R7                  ADDR OF NEXT OP CODE
         SR    R15,R15                 CLEAR WORK
         IC    R15,0(R12)              PICK UP NEXT OP-CODE
         MH    R15,SGOPLEN             TIMES TBL ENTRY LENG
         LA    R15,SGLOP(R15)          INSTR TBL ENTRY ADDR
         CLI   INAME-INSTENT(R15),0    IS IT AN OP-CODE
         BNE   ICKSEC                  YES
         CLI   0(R7),X'45'             IS IT BAL
         BE    ICKTBL                  YES, CONTINUE
         CLI   0(R7),7                 NO, IS IT BRCH
         BE    POSSB                   YES
         CLI   0(R7),X'47'             IS IT BRCH
         BNE   CONST                   NO, THEN THIS NOT INSTR
POSSB    TM    1(R7),X'F0'             IS IT UNCONDL BRCH
         BNO   CONST                   NO, THEN THIS NOT INSTR
         B     ICKTBL                  ACCEPT UNCOND BRCHS
ICKSEC   SR    R1,R1                   CLEAR WORK
         IC    R1,INLNG-INSTENT(R15)   GET INSTR LENGTH
         AR    R1,R12                  ADDR OF NEXT OP CODE
         SR    R14,R14                 CLEAR WORK
         IC    R14,0(R1)               PICK UP NEXT OP-CODE
         MH    R14,SGOPLEN             TIMES TBL ENTRY LENG
         LA    R14,SGLOP(R14)          INSTR TBL ENTRY ADDR
         CLI   INAME-INSTENT(R14),0    IS IT AN OP-CODE
         BNE   ICKTBL                  YES
         CLI   0(R12),X'45'            IS IT BAL
         BE    ICKTBL                  YES, CONTINUE
         CLI   0(R12),X'07'            NO, IS IT BRCH
         BE    POSSB2                  YES
         CLI   0(R12),X'47'            IS IT BRCH
         BNE   CONST                   NO, THEN THIS NOT INSTR
POSSB2   TM    1(R12),X'F0'            IS IT UNCONDL BRCH
         BNO   CONST                   NO, THEN THIS NOT INSTR
ICKTBL   LH    R12,ILENG               GET INSTR LENGTH
         AR    R12,R7                  @ NEXT TEXT LOC
         BCTR  R12,R0                  BACK UP 1
         S     R12,TXTSTRT             RELATIVIZE IN CSECT
         CLM   R12,7,LBLADR            LBL TBL ADDR HERE
         BL    NOILBL                  NO
         CLC   TXTOFSET,LBLADR         LABEL AT INSTR START
         BNE   CONST                   NO, MUST BE CONSTANT
         CLI   LBLTYP,C'L'             IS IT A LABEL ONLY
         BNE   CONST                   NO
         CLI   CONPROG,1               CONSTANT IN PROGRESS
         BNE   SETLBL                  NO
         BAL   R9,FORCONST             YES, FORCE IT OUT
SETLBL   LA    R6,L'LABEL(R6)          TO NEXT LABEL TBL ENTRY
         B     ICKTBL                  GO CHECK NEXT LABEL
NOILBL   CLI   CONPROG,1               CONSTANT IN PROGRESS
         BNE   MVMNE                   NO
         BAL   R9,FORCONST             YES, FORCE IT OUT
MVMNE    MVC   MNEMONIC,0(R8)          SET INSTR MNEMONIC
         MVC   OFFSET,TXTOFSET         SET OFFSET
         MVC   INSTYP,5(R8)            SET INSTR TYPE
         MVI   TYPE,X'0D'              SHOW IT IS AN INSTRUCTION
         MVC   LEN,ILENG+1             SHOW LENGTH
         MVC   TEXT(6),0(R7)           MOVE ACTUAL TEXT
OPNDFMT  TM    ICLASS,FLTPT            FLOATING POINT OP-CODE
         BO    FPVERFY                 YES, GO VERIFY
         CLI   IEDT,0                  ANY EDIT REQUIRED
         BE    PFMFMT                  NO
         B     IVERFY                  YES, GO EDIT
PFMFMT   SR    R1,R1                   CLEAR WORK
         IC    R1,INSTYP               GET INSTRUCTION TYPE
         L     R9,OPND9                GET FORMAT ROUTINE RETURN ADDR
         B     *+4(R1)                 TO APPROPRIATE FORMATTING ROUTIN
         B     INSTOUT                 TYPE=0, RR
         B     RXOPND                  TYPE=4, RX
         B     SOPND                   TYPE=8, S
         B     SIOPND                  TYPE=C, SI
         B     RSOPND                  TYPE=10, RS
         B     SS1OPND                 TYPE=14, 1-LENGTH SS
         B     SS2OPND                 TYPE=18, 2-LENGTH SS
         B     SOPND                   TYPE=1C, 2-BYTE OP-CODES
         B     RXOPND                  TYPE=20, CONDITIONAL BRANCH
         B     SVCOPND                 TYPE=24, SVC
OPNDRTN  B     INSTOUT                 NORMAL OPERAND FORMAT RETURN
         B     CONST                   ERROR INSTRUCTION, TREAT AS CONS
INSTOUT  AH    R7,ILENG                STEP TO NEXT TEXT BYTE
         ST    R7,TXTCURR              SAVE NEXT ADDR
         MVC   CCTYPE,ICCSET           SHOW COND CODE SET TYPE
         B     GETCURR                 CONTINUE TXT PROCESSING
*
*
*
******************************************************************
*                                                                *
* GENERAL OP-CODE TESTS TO VERIFY THAT NON-FLOATING-POINT OP     *
* CODES ARE INDEED OP-CODES.                                     *
*                                                                *
******************************************************************
*
IVERFY   EQU   *                       *** VERIFY POSSIBLE INSTRUCTION
         TM    IEDT,EPR                EVEN-ODD REG PAIR
         BZ    IVE2                    NO
         TM    1(R7),X'10'             R1 IS ODD
         BO    CONST                   YES, NOT INSTR
         CLI   0(R7),X'0E'             IS IT MVCL
         BE    IVTRG2                  YES
         CLI   0(R7),X'0F'             IS IT CLCL
         BNE   IVE2                    NO
IVTRG2   TM    1(R7),X'01'             R2 IS ODD
         BO    CONST                   YES, NOT INSTR
         SR    R1,R1                   CLEAR WORK
         SR    R2,R2                   CLEAR WORK
         IC    R1,1(R7)                GET R1R2
         SRL   R1,4                    SHIFT OUT R2
         PACK  DBLWD(1),1(1,R7)        FLIP R1R2 BYTE
         IC    R2,DBLWD                PICK UP R2R1
         SRL   R2,4                    SHIFT OUT R1
         CR    R1,R2                   R1=R2
         BE    CONST                   YES, NOT INSTR
         B     PFMFMT                  NO, GOOD INSTR
IVE2     TM    IEDT,E2                 HALFWORD STORAGE ALIGNMENT
         BZ    IVE4                    NO
         TM    3(R7),X'01'             DISPL IS ODD
         BZ    IVES2                   NO, O.K.
         TM    2(R7),X'F0'             BASE REG = 0
         BNZ   IVES2                   NO, CONTINUE
         CLI   0(R7),X'44'             EX OP CODE
         BE    CONST                   YES, NOT INSTR
         CLI   0(R7),X'47'             BC OP CODE
         BE    CONST                   YES, NOT INSTR
         CLI   ITYPE,RS                RS INSTRUCTION
         BE    CONST                   YES, NOT INSTR
         TM    1(R7),X'0F'             INDEX REG IS 0
         BZ    CONST                   YES, NOT INSTR
         B     IVES2                   CONTINUE
IVE4     TM    IEDT,E4                 2ND OPND ON FULLWORD BOUND
         BZ    IVE8                    NO
         TM    3(R7),X'03'             DISPL DIV BY 4
         BZ    IVES2                   YES, O.K.
         TM    2(R7),X'F0'             BASE REG = 0
         BNZ   IVES2                   NO, CONTINUE
         CLI   ITYPE,RS                RS INSTRUCTION OP CODE
         BE    CONST                   YES, NOT INSTR
         TM    1(R7),X'0F'             INDEX REG = 0
         BZ    CONST                   YES, NOT INSTR
         B     IVES2                   NO, CONTINUE
IVE8     TM    IEDT,E8                 2ND OPND ON DBLWD BOUND
         BZ    IVES2                   NO
         TM    3(R7),X'07'             DISPL DIV BY 8
         BZ    IVES2                   YES, O.K.
         TM    2(R7),X'F0'             BASE REG = 0
         BNZ   IVES2                   NO
         TM    1(R7),X'0F'             INDEX REG = 0
         BZ    CONST                   YES, NOT INSTR
IVES2    CLI   PRIVASM,1               PRIVILEGED INSTR O.K.
         BE    PFMFMT                  YES
         TM    IEDT,S2                 OPND2 MUST HAVE BASE
         BZ    IVES1                   NO
         TM    2(R7),X'F0'             BASE REG = 0
         BNZ   PFMFMT                  NO, O.K.
         CLI   ITYPE,RS                RS INSTRUCTION
         BE    CONST                   YES, NOT INSTR
         CLI   0(R7),X'92'             IS IT MVI OP CODE
         BE    CONST                   YES, NOT INSTR
         TM    1(R7),X'0F'             INDEX REG = 0
         BZ    CONST                   YES, NOT INSTR
         B     PFMFMT                  NO, GOOD INSTR
IVES1    TM    IEDT,S1                 1ST OPND MUST HAVE BASE
         BZ    PFMFMT                  NO, CONTINUE
         TM    2(R7),X'F0'             1ST OPND HAS BASE
         BZ    CONST                   NO, NOT INSTR
         B     PFMFMT                  YES, INSTR O.K.
*
*
*
******************************************************************
*                                                                *
* GENERAL OP-CODE TESTS TO VERIFY THAT FLOATING-POINT OP-CODES   *
* ARE INDEED OP-CODES.                                           *
*                                                                *
******************************************************************
*
FPVERFY  EQU   *                       *** VALIDATE FLOATING POINT OP-C
         TM    1(R7),X'90'             R1 IS 0, 2, 4, OR 6
         BNZ   CONST                   NO, NOT INSTR
         CLI   0(R7),X'27'             MXDR OP-CODE
         BE    FPR1EXT                 YES
         CLI   0(R7),X'67'             MXD OP-CODE
         BNE   FPCKTYP                 NO
FPR1EXT  TM    1(R7),X'B0'             R1 IS 0 OR 4
         BNZ   CONST                   NO, NOT INSTR
FPCKTYP  CLI   ITYPE,RR                RR TYPE INSTRUCTION
         BNE   FPRXVER                 NO
         TM    1(R7),X'09'             R2 IS 0, 2, 4, 6
         BNZ   CONST                   NO, NOT INSTR
         CLI   0(R7),X'25'             LRDR OP CODE
         BE    FPR2EXT                 YES
         CLI   0(R7),X'37'             SXR OP-CODE
         BE    FPR2EXT                 YES
         CLI   0(R7),X'26'             MXR OP-CODE
         BE    FPR2EXT                 YES
         CLI   0(R7),X'36'             AXR OP-CODE
         BNE   PFMFMT                  NO, GOOD INSTR
FPR2EXT  TM    1(R7),X'0B'             R2 IS 0 OR 4
         BZ    PFMFMT                  YES, GOOD INSTR
         B     CONST                   NO, NOT INSTR
FPRXVER  CLI   PRIVASM,1               PRIVILEGED INSTRUCTIONS O.K.
         BE    FPALIGN                 YES
         TM    2(R7),X'F0'             ANT BASE REG
         BNZ   FPALIGN                 YES
         TM    1(R7),X'0F'             ANY INDEX REG
         BZ    CONST                   NO, NOT INSTR
FPALIGN  TM    2(R7),X'F0'             ANY BASE REG
         BNZ   PFMFMT                  YES, ACCEPT INSTR
         TM    1(R7),X'0F'             ANY INDEX REG
         BNZ   PFMFMT                  YES, ACCEPT INSTR
         TM    3(R7),X'03'             DISPL DIV BY 4
         BNZ   CONST                   NO, NOT INSTR
         TM    ICLASS,FLSHT            SHORT PRECISION
         BO    PFMFMT                  YES, ACCEPT INSTRUCTION
         TM    3(R7),X'07'             DISPL DIV BY 8
         BZ    PFMFMT                  YES, ACCEPT INSTR
         B     CONST                   NO, NOT INSTR
*
*
*
******************************************************************
*                                                                *
* PROCESS TEXT BYTES DETERMINED TO BE CONSTANT DATA.             *
*                                                                *
******************************************************************
*
CONST    EQU   *                       *** PROCESS CONSTANTS ***
         MVC   WORKREC,BLANX           CLEAR WORK RECORD AREA
         CLI   CONPROG,1               CONSTANT IN PROGRESS
         BNE   CCNEW                   NO
         CLC   TXTOFSET,LBLADR         LABEL ENTRY HAS THIS OFFSET
         BNE   CGETYP                  NO
CSTNEW   BAL   R9,FORCONST             FORCE IT OUT
         B     CCNEW                   GO START A NEW ONE
CGETYP   TRT   0(1,R7),CHARTRAN        CHECK DATA TYPE OF BYTE
         BNZ   CHEX                    IT'S HEX
         MVI   CCKTYP+1,C'C'           SET TYPE IN COMPARE
         B     CCKTYP                  GO COMPARE
CHEX     MVI   CCKTYP+1,C'X'           SET TYPE IN COMPARE
CCKTYP   CLI   CONTYPE,C' '            TYPE IN PROG SAME AS THIS BYTE
         BNE   CSTNEW                  NO
CUPDCON  LH    R11,CONLEN              GET CURRENT LENGTH
         LA    R11,1(R11)              ADD 1
         STH   R11,CONLEN              UPDATE LENGTH
         CLI   CONTYPE,C'C'            CHARACTER CONSTANT
         BE    CCK8                    YES
         TM    CONOFST+3,1             OFFSET IS ODD
         BO    CCFIN1                  YES
         TM    CONOFST+3,2             HALFWORD OFFSET
         BZ    CCFWD                   NO
         CLI   CONLEN+1,1              HALFWORD, IS LENGTH = 1
         BE    CCXIT1                  YES
         B     CCFIN1                  NO
CCFWD    CLI   CONLEN+1,4              NO, IS HEX CONST 4 BYTES
         BL    CCXIT1                  NOT YET
CCFIN1   BAL   R9,FORCONST             MAX LENG, FORCE IT OUT
         B     CCXIT1                  FINISH
CCK8     CLC   CONLEN,H8               CHAR CONSTANT 8 BYTES
         BNL   CCFIN1                  YES
CCXIT1   LA    R7,1(R7)                STEP OVER 1 BYTE IN TEXT
         ST    R7,TXTCURR              UPDATE TEXT ADDR
         B     GETCURR                 CONTINUE TEXT PROCESSING
CCNEW    MVI   CONPROG,1               SHOW CONSTANT IN PROGRESS
         MVC   CONOFST,TXTOFST         SET OFFSET TO 1ST BYTE
         MVC   CONLEN,XZROS            CLEAR LENGTH
         CLC   TXTOFSET,LBLADR         LABEL AT THIS OFFSET
         BE    CLBLD                   YES
TRTYPE   TRT   0(1,R7),CHARTRAN        CHECK DATA TYPE OF BYTE
         BNZ   CCSHX                   IT'S HEX
         MVI   CONTYPE,C'C'            IT'S CHAR, SO INDICATE
         B     CUPDCON                 GO COMPLETE
CCSHX    MVI   CONTYPE,C'X'            IT'S HEX, SO INDICATE
         B     CUPDCON                 GO COMPLETE
CLBLD    CLI   LBLTYP,C'L'             IS IT A LABEL ONLY
         BNE   CDATACON                NO
         LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY
         CLC   TXTOFSET,LBLADR         THIS LABEL AT SAME ADDR
         BNE   TRTYPE                  NO
         CLI   LBLTYP,C'L'             THIS ANOTHER LABEL ONLY
         BNE   CDATACON                NO
         LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY
         B     CCNEW                   GO TO NEXT LABEL
CDATACON MVC   CONTYPE,LBLTYP          TYPE TO CONSTANT AREA
         SR    R1,R1                   CLEAR WORK
         IC    R1,LBLLEN               PICK UP CONSTNT LENGTH
         STH   R1,CONLEN               SAVE CONSTANT LENGTH
         SR    R11,R11                 CLEAR WORK REG
         IC    R11,LBLLEN              PICK UP LENGTH
         AR    R7,R11                  STEP PAST TEXT
         ST    R7,TXTCURR              UPDATE TEXT ADDRESS
         BAL   R9,FORCONST             FORCE CONSTANT OUT
         LA    R6,L'LABEL(R6)          STEP TO NEXT LABEL ENTRY
         B     GETCURR                 CONTINUE TEXT PROCESS
         DROP  R6
*
*
*
******************************************************************
*                                                                *
* CLEAR OUT AREAS SET UP FOR CONSTANT DATA.                      *
*                                                                *
******************************************************************
*
FORCONST EQU   *                       *** FORCE OUT CONSTANT IN PROGRE
         MVI   CONPROG,0               RESET CONSTANT IN PROGRESS
         MVI   CONTYPE,0               RESET TYPE
         XC    CONLEN,CONLEN           CLEAR LENGTH
         MVC   CONOFST,XZROS           CLEAR OFFSET TO CONSTANT
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* PROCESS RX-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESS  *
* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION.         *
*                                                                *
******************************************************************
*
RXOPND   EQU   *                       *** RX FORMAT INSTRUCTIONS ***
         SR    R11,R11                 CLEAR WORK REG
         ICM   R11,3,TEXT+2            GET BDDD
         LA    R10,4                   SET LENGTH = 4
         TM    INLNG,E4                FULLWORD OPERAND
         BO    RXBDDD                  YES
         LA    R10,2                   SET LENGTH = 2
         TM    INLNG,E2                HALFWORD OPERAND
         BO    RXBDDD                  YES
         LA    R10,1                   SET LENGTH = 1
         TM    INLNG,E8                DOUBLEWORD OPERAND
         BZ    RXBDDD                  NO
         LA    R10,8                   YES, SET LENGTH = 8
RXBDDD   B     BDLADR                  CHECK LABEL
*
*
*
******************************************************************
*                                                                *
* PROCESS S-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESS   *
* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION.         *
*                                                                *
******************************************************************
*
SOPND    EQU   *                       *** S FORMAT INSTRUCTIONS ***
         CLI   1(R7),0                 BYTE 2 OF INSTR IS ZERO
         BE    SCK2                    YES
         CLI   0(R7),X'80'             NO, IS IT SSM
         BE    4(R9)                   YES, NOT INSTR
         CLI   0(R7),X'82'             NO, IS IT LPSW
         BE    4(R9)                   YES, NOT INSTR
         CLI   0(R7),X'93'             NO, IS IT TS
         BE    4(R9)                   YES, NOT INSTR
SCK2     CLI   0(R7),X'B2'             OP-CODE IS B2
         BNE   SSTRT                   NO
         CLC   2(2,R7),XZROS           3RD AND 4TH BYTES ZERO
         BE    SSTRT                   YES
         CLI   1(R7),X'0B'             IPK INSTRUCTION
         BE    4(R9)                   YES, NOT INSTR
         CLI   1(R7),X'0D'             PTLB INSTR
         BE    4(R9)                   YES, NOT INSTR
SSTRT    SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD
         LA    R10,4                   SET LENGTH = 4
         TM    INLNG,E4                FULLWORD OPERAND
         BO    SBDDD                   YES
         LA    R10,2                   SET LENGTH = 2
         TM    INLNG,E2                HALFWORD OPERAND
         BO    SBDDD                   YES
         LA    R10,1                   SET LENGTH = 1
         TM    INLNG,E8                DOUBLEWORD OPERAND
         BZ    SBDDD                   NO
         LA    R10,8                   YES, SET LENGTH = 8
SBDDD    B     BDLADR                  CHECK FOR LABEL
*
*
*
******************************************************************
*                                                                *
* PROCESS SI-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESS  *
* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION.         *
*                                                                *
******************************************************************
*
SIOPND   EQU   *                       *** SI FORMAT INSTRUCTIONS ***
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD ADDRESS
         LA    R10,0                   LENGTH=DON'T CARE
         B     BDLADR                  CHECK FOR LABEL
*
*
*
******************************************************************
*                                                                *
* PROCESS RS-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESS  *
* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION.         *
*                                                                *
******************************************************************
*
RSOPND   EQU   *                       *** RS FORMAT INSTRUCTIONS ***
         CLI   0(R7),X'88'             IS IT SHIFT INSTR
         BL    RSCMA1                  NO
         CLI   0(R7),X'8F'             IS IT SHIFT INSTR
         BH    RSCMA1                  NO
         TM    1(R7),X'0F'             SHIFT, IS R3 POS = 0
         BZ    0(R9)                   YES, GOOD SHIFT
         B     4(R9)                   NO, NOT INSTR
RSCMA1   SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDD ADDRESS
         LA    R10,4                   SET LENGTH = 4
         TM    INLNG,E4                FULLWORD OPERAND
         BO    RSBDDD                  YES
         LA    R10,2                   SET LENGTH = 2
         TM    INLNG,E2                HALFWORD OPERAND
         BO    RSBDDD                  YES
         LA    R10,1                   SET LENGTH = 1
         TM    INLNG,E8                DOUBLEWORD OPERAND
         BZ    RSBDDD                  NO
         LA    R10,8                   YES, SET LENGTH = 8
RSBDDD   B     BDLADR                  CHECK FOR LABEL
*
*
*
******************************************************************
*                                                                *
* PROCESS SS-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESSES*
* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION. THE     *
* SINGLE-LENGTH SS FORMAT INSTRUCTIONS ARE HANDLED HERE.         *
*                                                                *
******************************************************************
*
SS1OPND  EQU   *                       *** SS FORMAT INSTRUCTIONS - SIN
         SR    R10,R10                 CLEAR WORK
         IC    R10,TEXT+1              GET LENGTH CODE
         LA    R10,1(R10)              COMPUTE ACTUAL LENGTH
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD ADDRESS
         LA    R1,SS1RTN               GET RTEURN ADDR
         MVC   SAVOP9,OPND9            SAVE NORMAL RETURN ADDR
         ST    R1,OPND9                CHANGE RETURN ADDR
         B     BDLADR                  CHECK LABEL
SS1RTN   MVC   OPND9,SAVOP9            RESTORE NORMAL RETURN ADDR
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+4            GET SECOND BDDD ADDRESS
         SR    R10,R10                 CLEAR LENGTH REG
         IC    R10,TEXT+1              GET INSTR LENGTH
         LA    R10,1(R10)              COMPUTE ACTUAL LENGTH
         B     BDLADR                  CHECK FOR LABEL
*
*
*
******************************************************************
*                                                                *
* PROCESS SS-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESSES*
* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION. THE     *
* DOUBLE-LENGTH SS FORMAT INSTRUCTIONS ARE HANDLED HERE.         *
*                                                                *
******************************************************************
*
SS2OPND  EQU   *                       *** SS FORMAT INSTRUCTIONS - 2 L
         SR    R10,R10                 CLEAR WORK
         IC    R10,TEXT+1              GET L1L2
         SRL   R10,4                   SHIFT OUT L2
         LA    R10,1(R10)              COMPUTE ACTUAL LENGTH
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD ADDRESS
         LA    R1,SS2RTN               GET RETURN ADDR
         MVC   SAVOP9,OPND9            SAVE NORMAL RETURN ADDR
         ST    R1,OPND9                CHANGE RETURN ADDRESS
         B     BDLADR                  CHECK LABEL
SS2RTN   MVC   OPND9,SAVOP9            RESTORE NORMAL RETURN ADDR
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+4            GET 2ND BDDD ADDR
         PACK  DBLWD(1),TEXT+1(1)      FLIP LENGTH BYTE
         SR    R10,R10                 CLEAR WORK
         IC    R10,DBLWD               PICK UP L2L1
         SRL   R10,4                   SHIFT OUT L1
         CLI   TEXT,X'F0'              SRP OP-CODE
         BNE   SS2BDDD                 NO
         IC    R10,TEXT+1              GET INSTR LENGTH
         SRL   R10,4                   SHIFT OUT I3
SS2BDDD  LA    R10,1(R10)              COMPUTE ACTUAL LENGTH
         B     BDLADR                  CHECK LABEL
*
*
*
******************************************************************
*                                                                *
* PROCESS SVC INSTRUCTIONS. THE SOLE PROCESSING IS TO VERIFY THAT*
* THIS IS A VALID SVC.                                           *
*                                                                *
******************************************************************
*
SVCOPND  EQU   *                       *** SVC INSTRUCTIONS ***
         CLI   TEXT+1,126              VALID OPERAND
         BH    NOTSVC                  NO, NOT SVC
         L     R1,SVCTBLAD             GET SVC TABLE ADDRESS
SVCKND   CLI   0(R1),X'FF'             END OF SVC TABLE
         BE    NOTSVC                  YES, MUST NOT BE SVC
         CLC   0(1,R1),TEXT+1          THIS THE ENTRY
         BE    GOTSVC                  YES
         LA    R1,L'SVCOP(R1)          STEP TO NEXT ENTRY
         B     SVCKND                  LOOP THRU TABLE
NOTSVC   B     4(R9)                   ERROR RETURN
GOTSVC   BR    R9                      EXIT, NO STORAGE OPND
*
*
*
******************************************************************
*                                                                *
* SET UP CURRENT BASE REGISTERS IN THE BASE TABLE. THE USING     *
* TABLE IS SCANNED FOR ENTRIES VALID AT THE CURRENT TEXT OFFSET. *
* WHEN A BASE REGISTER ENTRY IS FOUND TO BE VALID AT THE CURRENT *
* TEXT OFFSET, THE USING ENTRY IS MOVED TO THE APPROPRIATE LOC-  *
* ATION IN THE BASE TABLE FOR USE BY THE BDLADR ROUTINE. THE TEXT*
* OFFSET TO THE NEXT BASE REGISTER CHANGE IS SET SO THAT THIS    *
* ROUTINE WILL AGAIN BE ENTERED WHEN THE CURRENT BASE REGISTERS  *
* ARE EXHAUSTED.                                                 *
*                                                                *
******************************************************************
*
NEXUSG   EQU   *                       *** GET NEXT BASE REGS ***
         MVI   MORUSG,0                RESET INDICATOR
         XC    BASES,BASES             CLEAR OLD BASE REG VALUES
         MVC   NEXCHG,HIVAL            SET NEXT CHANGE LOC HIGH
         L     R2,USGSTRT              GET USING TBL START
         USING USINGD,R2
ENDUS    CLI   0(R2),X'FF'             END OF TABLE
         BCR   8,R9                    YES, EXIT
         CLC   TXTOFSET,USEND          PAST THIS ONE
         BNL   ECSTEP                  YES
         OI    MORUSG,1                SHOW MORE BASES AVAILABLE
USBGCK   CLC   TXTOFSET,USBGN          THIS STARTS LATER
         BNL   CKNEWLO                 NO
         CLC   USBGN,NEXCHG            BEGINS BEFORE NEXT CHG
         DS    0H
         BNL   ECSTEP                  NO
         MVC   NEXCHG,USBGN            YES, SET NEW CHANGE OFFSET
         B     ECSTEP                  CONTINUE
CKNEWLO  CLC   USEND,NEXCHG            NEW LOW CHANGE ADDR
         BNL   ECMVC                   NO
         MVC   NEXCHG,USEND            YES, SET LOWER OFFSET
ECMVC    SR    R1,R1                   CLEAR WORK
         IC    R1,USREG                PICK UP REGISTER
         MH    R1,USGLEN               TIMES ENTRY LENGTH
         LA    R1,BASES(R1)            @ TABLE ENTRY
         MVC   0(L'USING,R1),USING     ENTRY TO TABLE
         OI    MORUSG,X'80'            SHOW BASE REG CURRENT
ECSTEP   LA    R2,L'USING(R2)          TO NEXT USING TBL ENTRY
         B     ENDUS                   LOOP THRU USING TBL
         DROP  R2
*
*
*
******************************************************************
*                                                                *
* A BASE-DISPLACEMENT IS PROVIDED IN REG 11 ON ENTRY. IF ANY     *
* BASE REGISTERS ARE CURRENT, AND THE BASE REGISTER FOR THE GIVEN*
* ADDRESS IS A CURRENT PROGRAM BASE REGISTER, A LABEL ENTRY IS   *
* BUILT. OFFSET TO THE LABEL WILL BE FOUND BY ADDING THE ASSUMED *
* BASE REGISTER VALUE TO THE GIVEN DISPLACEMENT. THE LABEL NAME  *
* WILL BE THE LETTER 'A' FOLLOWED BY THE OFFSET.                 *
*                                                                *
******************************************************************
*
BDLADR   EQU   *                       *** BUILD LABEL ENTRIES ***
         TM    MORUSG,1                ANY BASES CURRENT
         BZ    BDLXIT                  NO
         LR    R2,R11                  COPY BDDD ADDRESS
         SRL   R2,12                   RIGHT JUSTIFY BASE REG
         MH    R2,USGLEN               TIMES ENTRY LENGTH
         LA    R2,BASES(R2)            @ BASE REG TABLE ENTRY
         USING USINGD,R2
         CLI   USTYPE,C'P'             IS IT A PROGRAM BASE
         BNE   BDLXIT                  NO
         SLL   R11,20                  ISOLATE THE
         SRL   R11,20                  DDD IN R11
         SR    R1,R1                   CLEAR WORK
         ICM   R1,7,USVALU             GET BASE REG VALUE
         AR    R11,R1                  COMPUTE PROGRAM OFFSET
         DROP  R2
         L     R1,CURRLBL              GET LBL TBL ADDR
         C     R1,ENDLBL               END OF TABLE
         BL    GOTHOLE                 NO
         BAL   R9,COMPLBL              YES, COMPRESS DUPLICATES
         L     R1,CURRLBL              GET NEW CURRENT LBL ADDR
         C     R1,ENDLBL               STILL AT END
         BNL   TXTEND                  YES, TERMINATE THIS STAGE
         USING LABELD,R1
GOTHOLE  STCM  R11,7,LBLADR            SET LABEL ENTRY OFFSET
         MVI   LBLNAME,C'A'            BEGIN LABEL NAME
         LA    R12,LBLADR              @ OFFSET
         BAL   R9,HEXPRT3              GO CONVERT
         MVC   LBLNAME+1(6),PRTABL     REST OF NAME
         MVI   LBLNAME+7,C' '          FINAL BLANK IN NAME
         MVI   LBLTYP,C'L'             SET LABEL TYPE
         CLI   TEXT,X'47'              THIS A CONDITIONAL BRANCH
         BE    INSTREF                 YES
         CLI   TEXT,X'45'              BAL INSTR
         BE    INSTREF                 YES
         CLI   TEXT,X'46'              BCT INSTR
         BE    INSTREF                 YES
         CLI   TEXT,X'44'              EX INSTR
         BE    INSTREF                 YES
         CLI   TEXT,X'87'              BXLE INSTRUCTION
         BE    INSTREF                 YES
         CLI   TEXT,X'86'              BXH INSTRUCTION
         BNE   BDLSTP                  NO
INSTREF  SR    R12,R12                 CLEAR WORK REG
         A     R11,TXTSTRT             BRCH ADDR IN STORED TEXT
         LA    R10,4                   ASSUME LENGTH IS 4
         TM    0(R11),X'C0'            TEST HI 2-BITS OF OP-CODE
         BM    BDLSTP                  01 OR 10 IS 4-BYTE INSTR
         BO    BDLSIX                  YES, SIX-BYTE INSTR
         LA    R10,2                   BOTH OFF, 2-BYTE INSTR
         B     BDLSTP                  CONTINUE
BDLSIX   LA    R10,6                   SET LENGTH TO 6
BDLSTP   STC   R10,LBLLEN              LENGTH TO LABEL ENTRY
         LA    R1,L'LABEL(R1)          TO NEXT ENTRY
         ST    R1,CURRLBL              SAVE UPDATED TBL ADDR
BDLXIT   L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
         DROP  R1
*
*
*
******************************************************************
*                                                                *
* SORT THE LABEL TABLE AND ELIMINATE ANY DUPLICATE ENTRIES.      *
*                                                                *
******************************************************************
*
COMPLBL  EQU   *                       *** COMPRESS AND SORT LABEL TABL
         USING LABELD,R6
         L     R6,LBLTBL               GET LABEL TABLE ADDR
LBSTPASS LA    R7,L'LABEL(R6)          @ NEXT LABEL TABLE ENTRY
LBLND    C     R7,CURRLBL              AT TABLE END
         BL    LBSAMPS                 NO
NEXPAS0  LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY
         C     R6,CURRLBL              END OF TABLE
         BL    LBSTPASS                NO
         B     LBFEND                  YES, FIND END
LBSAMPS  CLC   LBLADR,LBLADR-LABEL(R7) IDENTICAL OFFSETS
         BH    LBSWCH                  NO, FIRST HIGH, SWITCH
         BL    LBSTP                   NO, LOW, CONTINUE SCAN
         CLC   LABEL,0(R7)             ENTRIES ARE IDENTICAL
         BNE   LBCKLBL                 NO
LBNULL2  MVC   LBLADR-LABEL(3,R7),HIVAL YES, NULL 2ND
         B     LBSTP                   AND CONTINUE SCAN
LBCKLBL  CLC   LBLNAME,LBLNAME-LABEL(R7) IDENTICAL LABELS
         BNE   LBCKTYP                 NO, CHECK TYPES
LBCKLN   CLI   LBLLEN,0                THIS ENTRY LENGTH = 0
         BNE   LBCKLN2                 NO
         MVI   LBLLEN,X'FF'            YES, SET HIGH LENGTH
LBCKLN2  CLC   LBLLEN,LBLLEN-LABEL(R7) COMPARE LENGTHS
         BH    LBSWCH                  1ST LENGTH HIGH, SWITCH ENTRIES
         B     LBNULL2                 1ST LOW/=, NULL 2ND
LBCKTYP  CLC   LBLTYP,LBLTYP-LABEL(R7) SAME ENTRY TYPE
         BNE   LBCK1L                  NO, CHK TYPE ORDER
         CLI   LBLTYP,C'L'             ARE THEY TYPE L
         BE    LBSTP                   YES, CONTINUE SCAN
         CLI   LBLTYP,C'U'             USER LABEL
         BNE   LBNULL2                 NO
         B     LBSTP                   YES
LBCK1L   CLI   LBLTYP,C'U'             1ST IS USER LABEL
         BNE   LBCK2L                  NO
         CLI   LBLTYP-LABEL(R7),C'L'   2ND IS TYPE L
         BE    LBNULL2                 YES, NULL THE 2ND
         B     LBSTP                   CONTINUE SCAN
LBCK2L   CLI   LBLTYP-LABEL(R7),C'U'   2ND IS USER LABEL
         BE    LBSWCH                  YES
         CLI   LBLTYP,C'L'             1ST IS LABEL TYPE
         BE    LBSTP                   YES, CONTINUE SCAN
LBSWCH   MVC   WORKREC(L'LABEL),LABEL  HOLD 1ST ENTRY
         MVC   LABEL,0(R7)             MOVE 2ND ENTRY TO 1ST
         MVC   0(L'LABEL,R7),WORKREC   1ST ENTRY TO 2ND LOCATION
         B     LBSAMPS                 GO RECHECK
LBSTP    LA    R7,L'LABEL(R7)          TO NEXT LABEL ENTRY
         B     LBLND                   CONTINUE SCAN
LBFEND   L     R6,LBLTBL               @ LABEL TABLE
LBFCKFF  CLI   LABEL,X'FF'             NULL ENTRY
         BE    LBSTCURR                YES
         C     R6,CURRLBL              AT FORMER END
         BE    LBSTCURR                YES
         LA    R6,L'LABEL(R6)          TO NEXT ENTRY
         B     LBFCKFF                 LOOP TO FIND END
LBSTCURR ST    R6,CURRLBL              SAVE NEW TBL END ADDR
         BR    R9                      EXIT
         DROP  R6
*
*
*
******************************************************************
*                                                                *
* END OF PHASE 1. SORT/COMPRESS THE LABEL TABLE AND RETURN.      *
*                                                                *
******************************************************************
*
EOJ      EQU   *                       END OF JOB
         BAL   R9,COMPLBL              SORT/COMPRESS LABEL TBL
         L     R6,LBLTBL               GET LABEL TABLE ADDR
         USING LABELD,R6
EOJCKND  C     R6,CURRLBL              END OF TABLE
         BNL   EOJ2                    YES
         CLI   LBLTYP,C'U'             USER LABEL
         BNE   EOJSTEP                 NO
         MVI   LBLTYP,C'L'             YES, CHANGE TO TYPE L
EOJSTEP  LA    R6,L'LABEL(R6)          TO NEXT ENTRY
         B     EOJCKND                 CONTINUE LOOP
         DROP  R6
EOJ2     MVC   PRT,BLANX               CLEAR PRINT
         L     R13,4(R13)              GET POINTER TO CALLER'S SAVE ARE
         LM    R14,R12,12(R13)         RESTORE CALLER'S REGS
         SR    R15,R15                 CLEAR RETURN CODE
         BR    R14                     RETURN TO CALLER
*
*
*
******************************************************************
*                                                                *
* CONVERT HEX BYTES TO THEIR PRINTABLE EQUIVALENTS. ON ENTRY, REG*
* 12 CONTAINS THE ADDRESS OF THE FIRST BYTE TO BE CONVERTED. THE *
* NUMBER OF BYTES IS DETERMINED BY THE ENTRY SELECTED. PRINTABLE *
* HEX IS PLACED IN THE FIELD PRTABL, TWO CHARACTERS PER BYTE.    *
*                                                                *
******************************************************************
*
HEXPRT   EQU   *                       HEX TO PRINTABLE ROUTINE
HEXPRT1  UNPK  PRTABL(3),0(2,R12)      UNPACK HEX
         B     HEXCLTR                 CONTINUE
HEXPRT2  UNPK  PRTABL(5),0(3,R12)      UNPACK HEX
         B     HEXCLTR                 CONTINUE
HEXPRT3  UNPK  PRTABL(7),0(4,R12)      UNPACK HEX
         B     HEXCLTR                 CONTINUE
HEXPRT4  UNPK  PRTABL(9),0(5,R12)      UNPACK HEX
HEXCLTR  MVZ   PRTABL(8),XZROS         CLEAR FOR TRANSLATE
         TR    PRTABL(8),TRTBL         MAKE PRINTABLE
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* PRINT A LINE USING THE SYSPRINT DCB DEFINED IN DISASM PHASE 0. *
*                                                                *
******************************************************************
*
PRINT    EQU   *                       PRINT ROUTINE
         L     R1,PRINTDCB             @ SYSPRINT DCB
         TM    48(R1),X'10'            IS SYSPRINT OPEN
         BNO   CLRPRT                  NO
         PUT   (1),PRTLINE             WRITE PRINT LINE
CLRPRT   MVC   PRT,BLANX               CLEAR PRINT LINE
         AP    LINECT,P1               INCR LINE COUNTER
         CLI   PCC,C' '                SINGLE SPACED
         BE    SETSGL                  YES
         AP    LINECT,P1               INCR LINE COUNTER
         CLI   PCC,C'0'                DOUBLE SPACED
         BE    SETSGL                  YES
         AP    LINECT,P1               INCR LINE COUNTER
         CLI   PCC,C'-'                TRIPLE SPACED
         BE    SETSGL                  YES
         ZAP   LINECT,P0               NO, MUST BE NEW PAGE
SETSGL   MVI   PCC,C' '                SET SINGLE SPACING
         CP    LINECT,P58              PAST END OF PAGE
         BH    NEWPAGE                 YES
         BR    R9                      EXIT
NEWPAGE  MVI   PCC,C'1'                SET SKIP TO HOF
         ZAP   LINECT,P0               RESET LINE COUNTER
         BR    R9                      EXIT
*
*
*
*                 *** DATA AND WORK AREAS ***
*
******************************************************************
*                                                                *
* FOLLOWING FIELDS: COMMPARM THRU COMMEND ARE COMMON AREAS SHARED
* BY THIS, AND CALLED SUB-PROGRAMS. ALL CHANGES MUST BE COORDINTAED
* WITH ALL OTHER PROGRAMS.
*
******************************************************************
*
         DS    0D
COMMPARM DSECT ,                       COMMON AREAS
DBLWD    DS    D                       DOUBLEWORD WORK AREA
PUNCHDCB DS    F                       @ SYSPUNCH DCB
PRINTDCB DS    F                       @ SYSPRINT DCB
INDCB    DS    F                       @ SYSIN DCB
CSECT    DS    CL8                     SPECIFIED CSECT NAME
ESDID    DS    XL2                     ESD ID OF SPECIFIED CSECT
ENDLBLNM DS    CL8                     SYMBOL FOR END STMT BEGIN POINTE
LINECT   DS    PL2                     PRINT LINE COUNTER
START    DS    A                       LKED ASSIGNED START ADDR OF CSEC
END      DS    A                       CSECT END ADDRESS
LENGTH   DS    F                       LENGTH OF SPECIFIED CSECT
LBLTBL   DS    F                       @ LABEL TABLE
CURRLBL  DS    F                       CURRENT LABEL ENTRY ADDR
ENDLBL   DS    F                       @ END OF LABEL TBL
LBLLGTH  DS    AL2                     LENGTH OF LABEL ENTRY
TXTSTRT  DS    F                       @ TEXT STORAGE AREA
TXTEND   DS    F                       @ END OF TEXT AREA
TXTCURR  DS    F                       @ CURRENT TEXT LOC
DTBCUR   DS    F                       @ CURRENT DSECT TBL ENTRY
DTBEND   DS    F                       @ DSECT TBL END
DTBSTRT  DS    F                       @ DSECT TBL START
USGSTRT  DS    F                       @ USING TBL START
USGCUR   DS    F                       @ CURRENT USING TBL ENTRY
USGEND   DS    F                       @ USING TBL END
DATONLY  DS    F                       @ DATA ONLY TABLE
DATOCUR  DS    F                       @ CURRENT DATA ONLY ENTRY
DATOEND  DS    F                       @ END OF DATA ONLY TABLE
FLPTASM  DS    XL1                     FLOATING POINT INDICATOR
PRIVASM  DS    XL1                     PRIVILEGED INDICATOR
USERR    DS    XL1                     ERROR INDIC FOR DISASM1
NBRLBLS  DS    H                       NBR LABELS FROM DISASM1
*
*
*
WORKREC  DS    0CL80                   DISASSEMBLY WORK AREA
NAME     DS    CL8                     NAME
         DS    CL1
MNEMONIC DS    CL5                     INSTRUCTION MNEMONIC
         DS    CL1
OPNDS    DS    CL27                    1ST OPERAND
         DS    CL1
COMMENT  DS    CL28                    COMMENT
COL72    DS    CL1                     CONTINUATION COLUMN
SEQNBR   DS    CL8                     CARD SEQUENCE NBR
*
*
*
CARDNO   DS    PL4                     CURRENT OUTPUT CARD NBR
PRTLINE  DS    0CL121                  PRINT LINE
PCC      DS    CL1                     CARRIAGE CONTROL
PRT      DS    CL120                   PRINT DATA
*
*
*
         DS    0F
BLDLIST  DS    0CL62                   BLDL LIST
         DC    H'1'                    ONE ENTRY
         DC    H'58'                   LENGTH OF ENTRY
MEMBER   DC    CL8' '                  MEMBER NAME
TTRMOD   DC    XL3'000000'             TTR OF MODULE
CCAT     DC    XL1'00'                 CONCATENATION NUMBER
         DC    XL1'00'
ALIASIND DC    XL1'00'                 ALIAS AND MISC INDICATOR
*                           80=ALIAS
TTR1TXT  DC    XL3'000000'             TTR OF 1ST TXT RECORD
         DC    XL1'00'
TTRNS    DC    XL3'000000'             TTR OF NOTE OR SCATTER LIST
NNOTE    DC    XL1'00'                 NBR ENTRIES IN NOTE LIST
ATTR1A   DC    XL1'00'                 MODULE ATTRIBUTES 1, BYTE 1
*                           80=RENT
*                           40=REUS
*                           20=OVERLAY
*                           10=UNDER TEST
*                           08=ONLY LOADABLE
*                           04=SCATTER FORMAT
*                           02=EXECUTABLE
*                           01=ONE TXT, NO RLD RECORDS
ATTR1B   DC    XL1'00'                 ATTRIBUTES 1, BYTE 2
*                           80=CANNOT BE REPROCESSED BY LKED E
*                           40=ORIGIN OF 1ST TXT RECORD IS ZERO
*                           20=ASSIGNED ENTRY POINT ADDR IS ZERO
*                           10=CONTAINS NO RLD RECORD
*                           08=CANNOT BE REPROCESSED BY LKED
*                           04=CONTAINS TESTRAN SYMBOLS
*                           02=CREATED BY LKED
*                           01=REFR
TOTVIRT  DC    XL3'000000'             TOTAL VIRTUAL STRG REQRD FOR MOD
LENG1    DC    XL2'0000'               LENGTH OF 1ST TEXT RECORD
LKEPA    DC    XL3'000000'             ASSIGNED ENTRY POINT ADDR
ATTR2    DC    XL1'00'                 ATTRIBUTES 2
*                           80=PROCESSED BY OS/VS LKED
*                           20=PAGE ALIGNMENT REQUIRED FOR MODULE
*                           10=SSI PRESENT
         DC    XL2'0000'
SCTRLEN  DC    XL2'0000'               SCATTER LIST LENGTH
TTLEN    DC    XL2'0000'               TRANSLATION TABLE LENGTH
SCESDID  DC    XL2'0000'               CESD NBR FOR 1ST TXT RECD
SCEPESD  DC    XL2'0000'               CESD NBR FOR ENTRY POINT
ALEPA    DC    XL3'000000'             ENTRY POINT OF THE MEMBER NAME
ALMEM    DC    CL8' '                  REAL MEMBER NAME FOR ALIAS
SSI      DS    XL4'00000000'           SSI BYTES
AUTHLEN  DC    XL1'00'                 AUTH CODE LENGTH
AUTHCOD  DC    XL1'00'                 AUTH CODE
*
*
*
COMMEND  EQU   *
*
*
*
LABELD   DSECT ,                       LABEL TABLE ENTRY
LABEL    DS    0CL13                   13-BYTE ENTRIES
LBLADR   DS    XL3                     RELATIVE ADDR IN TEXT
LBLTYP   DS    CL1                     TYPE: L=LABEL, A=ADCON, V=VCON,
LBLNAME  DS    CL8                     NAME (SYMBOL)
LBLLEN   DS    XL1                     LENGTH IF A, V, OR W
*
*
*
USINGD   DSECT ,                       USING TABLE ENTRY
USING    DS    0CL11
USBGN    DS    XL3                     OFFSET TO BEGINNING OF RANGE
USEND    DS    XL3                     OFFSET TO END OF RANGE
USREG    DS    XL1                     BASE REGISTER USED
USTYPE   DS    XL1                     TYPE:P=PGM,D=DSECT
USVALU   DS    XL3                     BASE REG VALUE
*
*
*
DSECTD   DSECT ,                       DSECT FIELD TABLE ENTRY
DSECT    DS    0CL13
DSOFSET  DS    XL3                     OFFSET TO 1ST BYTE OF FIELD
DSLBTYP  DS    CL1                     LABEL TYPE = L
DSNAME   DS    CL8                     FIELD NAME
DSLENG   DS    XL1                     FIELD LENGTH
*
*
*
DISASM1  CSECT
*
*
*
SVCTBLAD DC    A(SVCOP)                @ SVC TABLE
DBLOPAD  DC    A(DBLOP)                @ TWO-BYTE OP-CODE TBL
OPND9    DC    A(OPNDRTN)              RETURN ADDR FOR OPERAND ROUTINES
DSCT9    DS    F                       RETURN FOR DSECTS
SAVOP9   DS    F                       SAVE AREA FOR OPND9
ULSAV    DS    7F                      SAVE AREA FOR CKADCON
RESAV    DS    7F                      SAVE AREA FOR CKADCON
NOINAD   DS    F                       DATA ONLY TABLE ADDRESS
SGOPLEN DC AL2(L'SGLOP) SINGLE BYTE OP COD TBL LEN                   */
DTBLEN DC AL2(L'DSECT) DSECT TABLE ENTRY LENGTH                      */
NUMCK    DC    C'0000'                 NUMERIC CHECK AREA
ZEROS    DC    C'0000'                 CONSTANT ZEROS
ILENG    DC    H'0'                    INSTRUCTION LENGTH  FIX***
CONPROG  DC    X'00'                   CONSTANT IN PROGRESS INDIC
BASES    DC    XL256'0'                CURRENT BASE REGS
HIVAL    DC    4X'FF'                  CONSTANT F'S
         DS    0H
USGLEN DC AL2(L'USING) LENGTH OF USING TBL ENTRY                     */
NEXCHG   DC    XL3'00'                 NEXT BASE REG CHG OFFSET
MORUSG   DC    X'00'                   80=CURRENT BASE, 0=NO MORE BASES
CONTYPE  DS    CL1                     TYPE
CONLEN   DS    H                       CONSTANT LENGTH
CONOFST  DS    F                       RELATIVE OFFSET TO CONSTANT
CCTYPE   DC    X'00'                   CC SET TYPE OF INSTR SETTING
TXTOFST  DS    0F
         DS    X
TXTOFSET DS    XL3                     OFFSET TO TEXT BYTE
OFFSET   DS    XL3                     OFFSET FROM PGM START
INSTYP   DS    CL1                     INSTRUCTION TYPE
TYPE     DS    XL1                     TYPE CODE
*                                       0=CSECT, 1=ADCON, 2=CONST
*                                       E=USING, D=INSTRUCTION
*                                       C=COMMENT, 9=ENTRY
*                                       A=EQU
LEN      DS    XL1                     TEXT LENGTH
TEXT     DS    XL8                     TEXT
H1       DC    H'1'                    CONSTANT 1
H2       DC    H'2'                    CONSTANT 2
H4       DC    H'4'                    CONSTANT 4
H7       DC    H'7'                    CONSTANT 7
H8       DC    H'8'                    CONSTANT 8
H10      DC    H'10'                   CONSTANT 10
H11      DC    H'11'                   CONSTANT 11
H13      DC    H'13'                   CONSTANT 13
H14      DC    H'14'                   CONSTANT 14
H100     DC    H'100'                  CONSTANT 100
H1000    DC    H'1000'                 CONSTANT 1000
P0       DC    P'0'                    CONSTANT 0
P1       DC    P'1'                    CONSTANT 1
P58      DC    P'58'                   CONSTANT 58
P256     DC    P'256'                  CONSTANT 256
P4096    DC    P'4096'                 CONSTANT 4096
BLANX    DC    CL121' '                CONSTANT BLANKS
UNAME    DC    CL8'A'                  USER NAME AREA
XZROS    DC    8X'00'                  CONSTANT ZEROS
TRTBL    DC    C'0123456789ABCDEF'     TRANSLATE TBL
PRTABL   DS    CL9                     PRINTABLE HEX WORK
CHARTRAN DC    256X'FF'                TRT TABLE FOR CHAR/HEX DETERMINA
         ORG   CHARTRAN+C' '
         DC    X'00'                   BLANK IS CHARACTER
         ORG   CHARTRAN+C'A'
         DC    9X'00'                  A-I ARE CHARACTERS
         ORG   CHARTRAN+C'J'
         DC    9X'00'                  J-R ARE CHARACTERS
         ORG   CHARTRAN+C'S'
         DC    8X'00'                  S-Z ARE CHARACTERS
         ORG   CHARTRAN+C'0'
         DC    10X'00'                 0-9 ARE CHARACTERS
         ORG
TRHEX    DC    256X'FF'                HEX TRANSLATION TABLE
         ORG   TRHEX+C'A'
         DC    X'0A0B0C0D0E0F'
         ORG   TRHEX+C'0'
         DC    X'00010203040506070809'
         ORG
TRTHEX   DS    0X                      VERIFY HEX TABLE
         DC    XL16'00'
         DC    XL240'FF'
         ORG
         LTORG
*
* INSTRUCTION DISASSEMBLY TABLES. THESE TABLES DEFINE VALID
* INSTRUCTION OP-CODES, AND GIVE MNEMONICS, FORMAT-TYPES,
* AND AN INDICATOR TO SHOW CONDITION SETTING INSTRUCTIONS,
* PRIVILEGED INSTRUCTIONS, AND FLOATING POINT INSTRUCTIONS.
*
*
INSTENT  DS    0CL10                   CURRENT INSTRUCTION ENTRY
INAME    DS    CL5                     INSTR NAME (MNEMONIC)
ITYPE    DS    XL1                     INSTRUCTION TYPE
RR       EQU   0                       RR FORMAT
RX       EQU   4                       RX FORMAT
S        EQU   8                       S FORMAT
SI       EQU   12                      SI FORMAT
RS       EQU   16                      RS FORMAT
SS1      EQU   20                      SS FORMAT, SINGLE LENGTH
SS2      EQU   24                      SS FORMAT, 2 LENGTHS
TWO      EQU   28                      TWO BYTE OP-CODE
CONDBR   EQU   32                      CONDITIONAL BRANCH
SVC      EQU   36                      SUPERVISOR CALL
ICLASS   DS    XL1                     INSTRUCTION CLASS
PRIV     EQU   2                       PRIVILEGED INSTRUCTION
FLTPT    EQU   4                       FLOATING POINT INSTRUCTION
FLSHT    EQU   5                       SHORT PREC FLT PT INSTR
IEDT     DS    XL1                     INSTRUCTION EDITS
EPR      EQU   X'40'                   EVEN-ODD REGISTER PAIR
E2       EQU   X'20'                   2ND OPND ON HALFWORD BOUND
E4       EQU   X'10'                   2ND OPND ON FULLWORD BOUND
E8       EQU   X'08'                   2ND OPND ON DBL WORD BOUND
S1       EQU   X'02'                   1ST OPND MUST HAVE BASE/INDEX
S2       EQU   X'01'                   2ND OPND MUST HAVE BASE
ICCSET   DS    XL1                     TYPE CONDITION CODE SET
ARITH    EQU   X'80'                   ARITHMETIC TYPE
CPR      EQU   X'40'                   COMPARE TYPE
ZRO8     EQU   X'20'                   BC 8 MAY BE BZ
INLNG    DS    XL1                     INSTRUCTION LENGTH
*
*
*
SGLOP    DS    0CL10                   SINGLE BYTE OP-CODE TABLE
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'02' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'02' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'02' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'02' NOT INSTR
         DC    CL5'SPM',AL1(RR),AL1(0),AL1(0),AL1(0),X'02' 04
         DC    CL5'BALR',AL1(RR),AL1(0),AL1(0),AL1(0),X'02' 05
         DC    CL5'BCTR',AL1(RR),AL1(0),AL1(0),AL1(0),X'02' 06
         DC    CL5'BCR',AL1(RR),AL1(0),AL1(0),AL1(0),X'02' 07
         DC    CL5'SSK',AL1(RR),AL1(PRIV),AL1(0),AL1(0),X'02' 08
         DC    CL5'ISK',AL1(RR),AL1(PRIV),AL1(0),AL1(0),X'02' 09
         DC    CL5'SVC',AL1(SVC),AL1(0),AL1(0),AL1(0),X'02' 0A
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'02' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'02' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'02' NOT INSTR
         DC    CL5'MVCL',AL1(RR),AL1(0),AL1(EPR),AL1(0),X'02' 0E
         DC    CL5'CLCL',AL1(RR),AL1(0),AL1(EPR),AL1(0),X'02' 0F
         DC    CL5'LPR',AL1(RR),AL1(0),AL1(0),AL1(ARITH),X'02' 10
         DC    CL5'LNR',AL1(RR),AL1(0),AL1(0),AL1(ARITH),X'02' 11
         DC    CL5'LTR',AL1(RR),AL1(0),AL1(0),AL1(ARITH),X'02' 12
         DC    CL5'LCR',AL1(RR),AL1(0),AL1(0),AL1(ARITH),X'02' 13
         DC    CL5'NR',AL1(RR),AL1(0),AL1(0),AL1(ZRO8),X'02' 14
         DC    CL5'CLR',AL1(RR),AL1(0),AL1(0),AL1(CPR),X'02' 15
         DC    CL5'OR',AL1(RR),AL1(0),AL1(0),AL1(ZRO8),X'02' 16
         DC    CL5'XR',AL1(RR),AL1(0),AL1(0),AL1(ZRO8),X'02' 17
         DC    CL5'LR',AL1(RR),AL1(0),AL1(0),AL1(0),X'02' 18
         DC    CL5'CR',AL1(RR),AL1(0),AL1(0),AL1(CPR),X'02' 19
         DC    CL5'AR',AL1(RR),AL1(0),AL1(0),AL1(ARITH),X'02' 1A
         DC    CL5'SR',AL1(RR),AL1(0),AL1(0),AL1(ARITH),X'02' 1B
         DC    CL5'MR',AL1(RR),AL1(0),AL1(EPR),AL1(0),X'02' 1C
         DC    CL5'DR',AL1(RR),AL1(0),AL1(EPR),AL1(0),X'02' 1D
         DC    CL5'ALR',AL1(RR),AL1(0),AL1(0),AL1(0),X'02' 1E
         DC    CL5'SLR',AL1(RR),AL1(0),AL1(0),AL1(0),X'02' 1F
         DC    CL5'LPDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 20
         DC    CL5'LNDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 21
         DC    CL5'LTDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 22
         DC    CL5'LCDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 23
         DC    CL5'HDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 24
         DC    CL5'LRDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 25
         DC    CL5'MXR',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 26
         DC    CL5'MXDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 27
         DC    CL5'LDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 28
         DC    CL5'CDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(CPR),X'02' 29
         DC    CL5'ADR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 2A
         DC    CL5'SDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 2B
         DC    CL5'MDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 2C
         DC    CL5'DDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 2D
         DC    CL5'AWR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 2E
         DC    CL5'SWR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 2F
         DC    CL5'LPER',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 30
         DC    CL5'LNER',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 31
         DC    CL5'LTER',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 32
         DC    CL5'LCER',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 33
         DC    CL5'HER',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 34
         DC    CL5'LRER',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 35
         DC    CL5'AXR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 36
         DC    CL5'SXR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 37
         DC    CL5'LER',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 38
         DC    CL5'CER',AL1(RR),AL1(FLTPT),AL1(0),AL1(CPR),X'02' 39
         DC    CL5'AER',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 3A
         DC    CL5'SER',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 3B
         DC    CL5'MER',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 3C
         DC    CL5'DER',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 3D
         DC    CL5'AUR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 3E
         DC    CL5'SUR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 3F
         DC    CL5'STH',AL1(RX),AL1(0),AL1(E2+S2),AL1(0),X'04' 40
         DC    CL5'LA',AL1(RX),AL1(0),AL1(0),AL1(0),X'04' 41
         DC    CL5'STC',AL1(RX),AL1(0),AL1(S2),AL1(0),X'04' 42
         DC    CL5'IC',AL1(RX),AL1(0),AL1(0),AL1(0),X'04' 43
         DC    CL5'EX',AL1(RX),AL1(0),AL1(E2+S2),AL1(0),X'04' 44
         DC    CL5'BAL',AL1(RX),AL1(0),AL1(E2),AL1(0),X'04' 45
         DC    CL5'BCT',AL1(RX),AL1(0),AL1(E2+S2),AL1(0),X'04' 46
         DC    CL5'BC',AL1(CONDBR),AL1(0),AL1(E2),AL1(0),X'04' 47
         DC    CL5'LH',AL1(RX),AL1(0),AL1(E2),AL1(0),X'04' 48
         DC    CL5'CH',AL1(RX),AL1(0),AL1(E2),AL1(CPR),X'04' 49
         DC    CL5'AH',AL1(RX),AL1(0),AL1(E2),AL1(ARITH),X'04' 4A
         DC    CL5'SH',AL1(RX),AL1(0),AL1(E2),AL1(ARITH),X'04' 4B
         DC    CL5'MH',AL1(RX),AL1(0),AL1(E2),AL1(0),X'04' 4C
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    CL5'CVD',AL1(RX),AL1(0),AL1(E8+S2),AL1(0),X'04' 4E
         DC    CL5'CVB',AL1(RX),AL1(0),AL1(E8),AL1(0),X'04' 4F
         DC    CL5'ST',AL1(RX),AL1(0),AL1(E4+S2),AL1(0),X'04' 50
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    CL5'N',AL1(RX),AL1(0),AL1(E4),AL1(ZRO8),X'04' 54
         DC    CL5'CL',AL1(RX),AL1(0),AL1(E4),AL1(CPR),X'04' 55
         DC    CL5'O',AL1(RX),AL1(0),AL1(E4),AL1(ZRO8),X'04' 56
         DC    CL5'X',AL1(RX),AL1(0),AL1(E4),AL1(ZRO8),X'04' 57
         DC    CL5'L',AL1(RX),AL1(0),AL1(E4),AL1(0),X'04' 58
         DC    CL5'C',AL1(RX),AL1(0),AL1(E4),AL1(CPR),X'04' 59
         DC    CL5'A',AL1(RX),AL1(0),AL1(E4),AL1(ARITH),X'04' 5A
         DC    CL5'S',AL1(RX),AL1(0),AL1(E4),AL1(ARITH),X'04' 5B
         DC    CL5'M',AL1(RX),AL1(0),AL1(E4+EPR),AL1(0),X'04' 5C
         DC    CL5'D',AL1(RX),AL1(0),AL1(E4+EPR),AL1(0),X'04' 5D
         DC    CL5'AL',AL1(RX),AL1(0),AL1(E4),AL1(0),X'04' 5E
         DC    CL5'SL',AL1(RX),AL1(0),AL1(E4),AL1(0),X'04' 5F
         DC    CL5'STD',AL1(RX),AL1(FLTPT),AL1(0),AL1(0),X'04' 60
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    CL5'MXD',AL1(RX),AL1(FLTPT),AL1(0),AL1(0),X'04' 67
         DC    CL5'LD',AL1(RX),AL1(FLTPT),AL1(0),AL1(0),X'04' 68
         DC    CL5'CD',AL1(RX),AL1(FLTPT),AL1(0),AL1(CPR),X'04' 69
         DC    CL5'AD',AL1(RX),AL1(FLTPT),AL1(0),AL1(ARITH),X'04' 6A
         DC    CL5'SD',AL1(RX),AL1(FLTPT),AL1(0),AL1(ARITH),X'04' 6B
         DC    CL5'MD',AL1(RX),AL1(FLTPT),AL1(0),AL1(0),X'04' 6C
         DC    CL5'DD',AL1(RX),AL1(FLTPT),AL1(0),AL1(0),X'04' 6D
         DC    CL5'AW',AL1(RX),AL1(FLTPT),AL1(0),AL1(ARITH),X'04' 6E
         DC    CL5'SW',AL1(RX),AL1(FLTPT),AL1(0),AL1(ARITH),X'04' 6F
         DC    CL5'STE',AL1(RX),AL1(FLSHT),AL1(0),AL1(0),X'04' 70
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    CL5'LE',AL1(RX),AL1(FLSHT),AL1(0),AL1(0),X'04' 78
         DC    CL5'CE',AL1(RX),AL1(FLSHT),AL1(0),AL1(CPR),X'04' 79
         DC    CL5'AE',AL1(RX),AL1(FLSHT),AL1(0),AL1(ARITH),X'04' 7A
         DC    CL5'SE',AL1(RX),AL1(FLSHT),AL1(0),AL1(ARITH),X'04' 7B
         DC    CL5'ME',AL1(RX),AL1(FLSHT),AL1(0),AL1(0),X'04' 7C
         DC    CL5'DE',AL1(RX),AL1(FLSHT),AL1(0),AL1(0),X'04' 7D
         DC    CL5'AU',AL1(RX),AL1(FLSHT),AL1(0),AL1(ARITH),X'04' 7E
         DC    CL5'SU',AL1(RX),AL1(FLSHT),AL1(0),AL1(ARITH),X'04' 7F
         DC    CL5'SSM',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04' 80
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    CL5'LPSW',AL1(S),AL1(PRIV),AL1(E8),AL1(0),X'04' 82
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    CL5'WRD',AL1(SI),AL1(PRIV),AL1(0),AL1(0),X'04' 84
         DC    CL5'RDD',AL1(SI),AL1(PRIV),AL1(0),AL1(0),X'04' 85
         DC    CL5'BXH',AL1(RS),AL1(0),AL1(E2+S2),AL1(0),X'04' 86
         DC    CL5'BXLE',AL1(RS),AL1(0),AL1(E2+S2),AL1(0),X'04' 87
         DC    CL5'SRL',AL1(RS),AL1(0),AL1(0),AL1(ARITH),X'04' 88
         DC    CL5'SLL',AL1(RS),AL1(0),AL1(0),AL1(ARITH),X'04' 89
         DC    CL5'SRA',AL1(RS),AL1(0),AL1(0),AL1(ARITH),X'04' 8A
         DC    CL5'SLA',AL1(RS),AL1(0),AL1(0),AL1(ARITH),X'04' 8B
         DC    CL5'SRDL',AL1(RS),AL1(0),AL1(EPR),AL1(ARITH),X'04' 8C
         DC    CL5'SLDL',AL1(RS),AL1(0),AL1(EPR),AL1(ARITH),X'04' 8D
         DC    CL5'SRDA',AL1(RS),AL1(0),AL1(EPR),AL1(ARITH),X'04' 8E
         DC    CL5'SLDA',AL1(RS),AL1(0),AL1(EPR),AL1(ARITH),X'04' 8F
         DC    CL5'STM',AL1(RS),AL1(0),AL1(E4+S2),AL1(0),X'04' 90
         DC    CL5'TM',AL1(SI),AL1(0),AL1(0),AL1(ARITH),X'04' 91
         DC    CL5'MVI',AL1(SI),AL1(0),AL1(S2),AL1(0),X'04' 92
         DC    CL5'TS',AL1(S),AL1(0),AL1(0),AL1(0),X'04' 93
         DC    CL5'NI',AL1(SI),AL1(0),AL1(0),AL1(ZRO8),X'04' 94
         DC    CL5'CLI',AL1(SI),AL1(0),AL1(0),AL1(CPR),X'04' 95
         DC    CL5'OI',AL1(SI),AL1(0),AL1(0),AL1(ZRO8),X'04' 96
         DC    CL5'XI',AL1(SI),AL1(0),AL1(0),AL1(ZRO8),X'04' 97
         DC    CL5'LM',AL1(RS),AL1(0),AL1(E4),AL1(0),X'04' 98
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    CL5' ',AL1(TWO),AL1(0),AL1(0),AL1(0),X'04' 9C
         DC    CL5' ',AL1(TWO),AL1(0),AL1(0),AL1(0),X'04' 9D
         DC    CL5' ',AL1(TWO),AL1(0),AL1(0),AL1(0),X'04' 9E
         DC    CL5' ',AL1(TWO),AL1(0),AL1(0),AL1(0),X'04' 9F
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    CL5'STNSM',AL1(SI),AL1(PRIV),AL1(0),AL1(0),X'04' AC
         DC    CL5'STOSM',AL1(SI),AL1(PRIV),AL1(0),AL1(0),X'04' AD
         DC    CL5'SIGP',AL1(RS),AL1(PRIV),AL1(0),AL1(0),X'04' AE
         DC    CL5'MC',AL1(SI),AL1(0),AL1(0),AL1(0),X'04' AF
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    CL5'LRA',AL1(RX),AL1(PRIV),AL1(0),AL1(0),X'04' B1
         DC    CL5' ',AL1(TWO),AL1(0),AL1(0),AL1(0),X'04' B2
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    CL5'STCTL',AL1(RS),AL1(PRIV),AL1(0),AL1(0),X'04' B6
         DC    CL5'LCTL',AL1(RS),AL1(PRIV),AL1(E4),AL1(0),X'04' B7
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    CL5'CS',AL1(RS),AL1(0),AL1(E4+EPR),AL1(0),X'04' BA
         DC    CL5'CDS',AL1(RS),AL1(0),AL1(E4+EPR),AL1(0),X'04' BB
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    CL5'CLM',AL1(RS),AL1(0),AL1(0),AL1(CPR),X'04' BD
         DC    CL5'STCM',AL1(RS),AL1(0),AL1(S2),AL1(0),X'04' BE
         DC    CL5'ICM',AL1(RS),AL1(0),AL1(0),AL1(ZRO8),X'04' BF
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    CL5'MVN',AL1(SS1),AL1(0),AL1(S1),AL1(0),X'06' D1
         DC    CL5'MVC',AL1(SS1),AL1(0),AL1(S1),AL1(0),X'06' D2
         DC    CL5'MVZ',AL1(SS1),AL1(0),AL1(S1),AL1(0),X'06' D3
         DC    CL5'NC',AL1(SS1),AL1(0),AL1(S1),AL1(ZRO8),X'06' D4
         DC    CL5'CLC',AL1(SS1),AL1(0),AL1(0),AL1(CPR),X'06' D5
         DC    CL5'OC',AL1(SS1),AL1(0),AL1(S1),AL1(ZRO8),X'06' D6
         DC    CL5'XC',AL1(SS1),AL1(0),AL1(S1),AL1(ZRO8),X'06' D7
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    CL5'TR',AL1(SS1),AL1(0),AL1(S1),AL1(0),X'06' DC
         DC    CL5'TRT',AL1(SS1),AL1(0),AL1(0),AL1(ZRO8),X'06' DD
         DC    CL5'ED',AL1(SS1),AL1(0),AL1(S1),AL1(ARITH),X'06' DE
         DC    CL5'EDMK',AL1(SS1),AL1(0),AL1(S1),AL1(ARITH),X'06' DF
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    CL5'SRP',AL1(SS2),AL1(0),AL1(S1),AL1(ARITH),X'06' F0
         DC    CL5'MVO',AL1(SS2),AL1(0),AL1(S1),AL1(0),X'06' F1
         DC    CL5'PACK',AL1(SS2),AL1(0),AL1(S1),AL1(0),X'06' F2
         DC    CL5'UNPK',AL1(SS2),AL1(0),AL1(S1),AL1(0),X'06' F3
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    CL5'ZAP',AL1(SS2),AL1(0),AL1(S1),AL1(ARITH),X'06' F8
         DC    CL5'CP',AL1(SS2),AL1(0),AL1(0),AL1(CPR),X'06' F9
         DC    CL5'AP',AL1(SS2),AL1(0),AL1(S1),AL1(ARITH),X'06' FA
         DC    CL5'SP',AL1(SS2),AL1(0),AL1(S1),AL1(ARITH),X'06' FB
         DC    CL5'MP',AL1(SS2),AL1(0),AL1(S1),AL1(0),X'06' FC
         DC    CL5'DP',AL1(SS2),AL1(0),AL1(S1),AL1(0),X'06' FD
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    X'FFFF'                 TABLE END
*
*
*
DBLOP    DS    0CL12                   TWO-BYTE OP-CODE TABLE
         DC    X'9C00',CL5'SIO',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'9C01',CL5'SIOF',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'9D00',CL5'TIO',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'9D01',CL5'CLRIO',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'9E00',CL5'HIO',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'9E01',CL5'HDV',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'9F00',CL5'TCH',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'B20B',CL5'IPK',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'B20D',CL5'PTLB',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'B213',CL5'RRB',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'B204',CL5'SCK',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'B206',CL5'SCKC',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'B208',CL5'SPT',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'B210',CL5'SPX',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'B20A',CL5'SPKA',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'B203',CL5'STIDC',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'B205',CL5'STCK',AL1(S),AL1(0),AL1(E8+S2),AL1(0),X'04'
         DC    X'B207',CL5'STCKC',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'B212',CL5'STAP',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'B202',CL5'STIDP',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'B209',CL5'STPT',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'B211',CL5'STPX',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'FFFF'                 TABLE END
*
*
*
SVCOP    DS    0CL15                   SVC NAME TABLE
         DC    AL1(0),CL14'EXCP/XDAP'
         DC    AL1(1),CL14'WAIT/WAITR'
         DC    AL1(2),CL14'POST/PRTOV'
         DC    AL1(3),CL14'EXIT'
         DC    AL1(4),CL14'GETMAIN'
         DC    AL1(5),CL14'FREEMAIN'
         DC    AL1(6),CL14'LINK'
         DC    AL1(7),CL14'XCTL'
         DC    AL1(8),CL14'LOAD'
         DC    AL1(9),CL14'DELETE'
         DC    AL1(10),CL14'GET/FREEMAIN R'
         DC    AL1(11),CL14'TIME'
         DC    AL1(12),CL14'SYNCH'
         DC    AL1(13),CL14'ABEND'
         DC    AL1(14),CL14'SPIE'
         DC    AL1(15),CL14'ERREXCP'
         DC    AL1(16),CL14'PURGE'
         DC    AL1(17),CL14'RESTORE'
         DC    AL1(18),CL14'BLDL/FIND'
         DC    AL1(19),CL14'OPEN'
         DC    AL1(20),CL14'CLOSE'
         DC    AL1(21),CL14'STOW'
         DC    AL1(22),CL14'OPEN TYPE J'
         DC    AL1(23),CL14'CLOSE TYPE T'
         DC    AL1(24),CL14'DEVTYPE'
         DC    AL1(25),CL14'TRKBAL'
         DC    AL1(26),CL14'LOCATE, ETC'
         DC    AL1(27),CL14'OBTAIN'
         DC    AL1(28),CL14'CVOL'
         DC    AL1(29),CL14'SCRATCH'
         DC    AL1(30),CL14'RENAME'
         DC    AL1(31),CL14'FEOV'
         DC    AL1(32),CL14'(NO MACRO)'
         DC    AL1(33),CL14'IOHALT'
         DC    AL1(34),CL14'MGCR/QEDIT'
         DC    AL1(35),CL14'WTO/WTOR'
         DC    AL1(36),CL14'WTL'
         DC    AL1(37),CL14'SEGLD/SEGWT'
         DC    AL1(39),CL14'LABEL'
         DC    AL1(40),CL14'EXTRACT'
         DC    AL1(41),CL14'IDENTIFY'
         DC    AL1(42),CL14'ATTACH'
         DC    AL1(43),CL14'CIRB'
         DC    AL1(44),CL14'CHAP'
         DC    AL1(45),CL14'OVLYBRCH'
         DC    AL1(46),CL14'TTIMER'
         DC    AL1(47),CL14'STIMER'
         DC    AL1(48),CL14'DEQ'
         DC    AL1(51),CL14'SNAP/SDUMP'
         DC    AL1(52),CL14'RESTART'
         DC    AL1(53),CL14'RELEX'
         DC    AL1(54),CL14'DISABLE'
         DC    AL1(55),CL14'EOV'
         DC    AL1(56),CL14'ENQ/RESERVE'
         DC    AL1(57),CL14'FREEDBUF'
         DC    AL1(58),CL14'RELBUF/REQBUF'
         DC    AL1(59),CL14'OLTEP'
         DC    AL1(60),CL14'(E)STAE/STAI'
         DC    AL1(61),CL14'IKJEGS6A'
         DC    AL1(62),CL14'DETACH'
         DC    AL1(63),CL14'CHKPT'
         DC    AL1(64),CL14'RDJFCB'
         DC    AL1(66),CL14'BTAMTEST'
         DC    AL1(67),CL14'SYNADAF'
         DC    AL1(68),CL14'SYNADRLS'
         DC    AL1(69),CL14'BSP'
         DC    AL1(70),CL14'GSERV'
         DC    AL1(71),CL14'ASGNBFR, ETC'
         DC    AL1(72),CL14'CHATR'
         DC    AL1(73),CL14'SPAR'
         DC    AL1(74),CL14'DAR'
         DC    AL1(75),CL14'DQUEUE'
         DC    AL1(76),CL14'(NO MACRO)'
         DC    AL1(78),CL14'(NO MACRO)'
         DC    AL1(79),CL14'STATUS'
         DC    AL1(81),CL14'SETPRT'
         DC    AL1(82),CL14'DASDR'
         DC    AL1(83),CL14'SMFWTM'
         DC    AL1(84),CL14'GRAPHICS'
         DC    AL1(85),CL14'DDRSWAP'
         DC    AL1(86),CL14'ATLAS'
         DC    AL1(87),CL14'DOM'
         DC    AL1(88),CL14'MOD88'
         DC    AL1(91),CL14'VOLSTAT'
         DC    AL1(92),CL14'TCBEXCP'
         DC    AL1(93),CL14'TGET/TPUT'
         DC    AL1(94),CL14'STCC'
         DC    AL1(95),CL14'SYSEVENT'
         DC    AL1(96),CL14'STAX'
         DC    AL1(97),CL14'TSO TEST'
         DC    AL1(98),CL14'PROTECT'
         DC    AL1(99),CL14'DDDYNAM'
         DC    AL1(100),CL14'IKJEFFIB'
         DC    AL1(101),CL14'QTIP'
         DC    AL1(102),CL14'AQCTL'
         DC    AL1(103),CL14'XLATE'
         DC    AL1(104),CL14'TOPCTL'
         DC    AL1(105),CL14'IMAGLIB'
         DC    AL1(107),CL14'MODESET'
         DC    AL1(109),CL14'ESR TYPE 4'
         DC    AL1(110),CL14'DSTATUS'
         DC    AL1(111),CL14'(NO MACRO)'
         DC    AL1(112),CL14'PGRLSE'
         DC    AL1(113),CL14'PGFIX,CL14' ETC'
         DC    AL1(114),CL14'EXCPVR'
         DC    AL1(116),CL14'ESR TYPE 1'
         DC    AL1(117),CL14'DEBCHK'
         DC    AL1(119),CL14'TESTAUTH'
         DC    AL1(120),CL14'GETMAIN/FREEMAIN'
         DC    AL1(121),CL14'VSAM'
         DC    AL1(122),CL14'EVENTS'
         DC    AL1(123),CL14'PURGEDQ'
         DC    AL1(124),CL14'TPIO'
         DC    AL1(125),CL14'EVENTS'
         DC    AL1(126),CL14'MSS INTERFACE'
         DC    X'FF'                   END OF TABLE
         END
./       ADD   NAME=DISASMX2
DIS2     TITLE '*** DISASSEMBLY PHASE 2 ***'
         MACRO
&NAME    SVLNK &REG1,&REG2,&REG3,&IND,&LV=
         GBLC  &EQU
         GBLC  &GM
         GBLC  &CSECT
         LCLC  &REGA
         AIF   (T'&NAME EQ 'O').NOCSECT
         AIF   ('&NAME' EQ '*').NOCSECT
&CSECT   SETC  '&NAME'
&CSECT   CSECT 
         AGO   .RST
.NOCSECT ANOP
&CSECT   SETC  '*'
         CSECT 
.RST     ANOP
         AIF   ('&EQU' EQ 'ON').NRQ
&EQU     SETC  'ON'
*
***REGISTER EQUATES***
*
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
.NRQ     ANOP
*
*******************  PROGRAM INITIALIZATION  *************************
*
         AIF   (T'&REG1 EQ 'O').NOREG
&REGA    SETC  '&REG1'
         AIF   (T'&REG2 EQ 'O').ONEREG
         USING &CSECT,&REGA,&REG2 
         AGO   .BYUSE
.NOREG   ANOP
&REGA    SETC  'R3'
.ONEREG  USING &CSECT,&REGA 
.BYUSE   ANOP
         STM   R14,R12,12(R13) :       STORE REGS IN HIGH SAVE AREA
         LR    &REGA,R15 
         AIF   (T'&REG2 EQ 'O').NOLA
         LA    &REG2,4095(&REGA) 
         LA    &REG2,1(&REG2) 
.NOLA    ANOP
         AIF   (T'&REG3 EQ 'O').NOLNK
         L     &REG3,0(R1) 
.NOLNK   ANOP
         AIF (T'&IND EQ 'O').GETIT
         CNOP  0,4
         BAL   R15,SAVEAREA+72 
SAVEAREA DS    18F 
         ST    R15,8(R13)
         ST    R13,SAVEAREA+4
         LR    R13,R15
         AGO   .NOSAVE
.GETIT   ANOP
         AIF   (T'&LV EQ 'O').GMD
&GM      SETC  '&LV'
         AGO   .DGM
.GMD     ANOP
&GM      SETC  '72'
.DGM     ANOP
*
***GET MAIN STORAGE FOR SAVE AREA***
*
         AIF   ('&GM' LT '4096').LA
         GETMAIN R,LV=&GM 
         AGO   .EGM
.LA      ANOP
         LA    R0,&GM                  GET &GM BYTES
         GETMAIN R,LV=(0)
.EGM     ANOP
*
***SET UP SAVE AREA POINTERS***
*
         ST    R1,8(R13) 
         ST    R13,4(R1) 
         LR    R13,R1 
         AIF   (T'&REG3  NE 'O').NOSAVE
         L     R1,4(R13) 
         L     R1,24(R1) 
.NOSAVE  ANOP
         AIF   ('&CSECT' EQ '*').EXIT
         B     *+12
         DC    CL8'&CSECT'  
.EXIT    ANOP
*
*********************  END INITIALIZATION  ***************************
*
         MEND
         EJECT
DISASM2  SVLNK R3,R4
         PRINT NOGEN
* THIS SUB-PROGRAM IS CALLED BY DISASM AFTER THE DIRECTORY
* ENTRY AND LOAD MODULE ARE PROCESSED. THE ESD AND RLD
* ENTRIES HAVE BEEN USED TO CREATE A PROGRAM LABEL TABLE,
* AND MODULE TEXT IS IN AN AREA OF STORAGE. A COMMON PARAMETER
* AREA IS DEFINED IN DISASM, AND PASSED TO THIS PROGRAM.
*
* TEXT BYTES ARE USED TO CREATE ASSEMBLY LANGUAGE STATEMENTS,
* AND MACHINE INSTRUCTION STATEMENTS. OUTPUT IS WRITTEN
* TO THE WORK1 DATASET FOR FURTHER PROCESSING BY OTHER
* MODULES.
*   A TEXT BYTE IS CONSIDERED TO BE AN INSTRUCTION IF
* IT OCCURS ON A HALFWORD BOUNDARY, IS A VALID OP-CODE,
* AND IS FOLLOWED BY A VALID OP-CODE. UNCONDITIONAL BRANCHES
* NEED NOT BE FOLLOWED BY A VALID OP-CODE, HOWEVER. THE
* PRIVILEGED AND FLOATING POINT INSTRUCTIONS ARE NOT
* TREATED AS INSTRUCTIONS UNLESS THE USER SPECIFIED
* THEIR INCLUSION AT EXEC TIME.
*
*
*
*
* AUTHOR R THORNTON - NOV 1977
*
*
******************************************************************
*                                                                *
* CHECK IF USER WISHES FLOATING POINT AND PRIVILEGED INSTRUCTIONS*
* IF NOT, CLEAR THE APPROPRIATE ENTRIES IN THE INSTRUCTION OP    *
* CODE TABLES.                                                   *
*                                                                *
******************************************************************
*
         L     R5,0(R1)                GET PARM FIELD ADDRESS
         USING COMMPARM,R5
         CLI   FLPTASM,1               FLOATING POINT INSTR O.K.
         BE    TSTPRIV                 YES
         LA    R12,SGLOP               POINT TO OP-CODE TBL
TSTOPND  CLI   0(R12),X'FF'            END OF TBL
         BE    TSTPRIV                 YES
         TM    ICLASS-INSTENT(R12),FLTPT IS IT FLOATING POINT
         BZ    FLPSTP                  NO
         XC    0(L'SGLOP,R12),0(R12)   CLEAR ENTRY
FLPSTP   LA    R12,L'SGLOP(R12)        TO NEXT ENTRY
         B     TSTOPND                 LOOP THRU TABLE
TSTPRIV  CLI   PRIVASM,1               PRIVILEGED INSTR O.K.
         BE    MAINLINE                YES
         LA    R12,SGLOP               POINT TO OP-CODE TBL
TTOPND   CLI   0(R12),X'FF'            END OF TABLE
         BE    CKDBLS                  YES
         TM    ICLASS-INSTENT(R12),PRIV PRIVILEGED INSTR
         BZ    PRIVSTP                 NO
         XC    0(L'SGLOP,R12),0(R12)   YES, CLEAR ENTRY
PRIVSTP  LA    R12,L'SGLOP(R12)        TO NEXT ENTRY
         B     TTOPND                  LOOP THRU TABLE
CKDBLS   L     R12,DBLOPAD             @ 2-BYTE OP-CODE TBL
CKDBND   CLI   0(R12),X'FF'            END OF TBL
         BE    MAINLINE                YES
         TM    ICLASS-INSTENT+2(R12),PRIV PRIVILEGED OP-CODE
         BZ    DBSTP                   NO
         XC    0(L'DBLOP,R12),0(R12)   YES, CLEAR ENTRY
DBSTP    LA    R12,L'DBLOP(R12)        TO NEXT ENTRY
         B     CKDBND                  LOOP THRU TABLE
*
*
*
******************************************************************
*                                                                *
* MAINLINE ROUTINE FOR DISASSEMBLY. EACH BYTE OF TEXT IS CHECKED *
* TO DETERMINE WHETHER IT MAY BE AN INSTRUCTION OP-CODE. IF NOT, *
* THE CONST ROUTINE IS PERFORMED TO HANDLE CONSTANT DATA. IF IT  *
* APPEARS TO BE AN OP-CODE, THE INSTR ROUTINE IS PERFORMED.      *
* WHEN TEXT IS EXHAUSTED, THIS PHASE TERMINATES.                 *
*                                                                *
******************************************************************
*
MAINLINE EQU   *                       MAINLINE ROUTINE
         L     R6,LBLTBL               @ LABEL TABLE
         USING LABELD,R6
         MVC   TXTCURR,TXTSTRT         COPY TEXT START ADDR
GETCURR  L     R7,TXTCURR              @ CURRENT TXT BYTE
         C     R7,TXTEND               END OF TEXT
         BNL   EOJ                     YES          FIX******
         LR    R12,R7                  COPY TEXT ADDR
         S     R12,TXTSTRT             COMPUTE OFFSET
         ST    R12,TXTOFST             SAVE OFFSET TO THIS BYTE
         CLC   NEXCHG,TXTOFSET         TIME TO CHANGE BASES
         BH    CKDARNG                 NO
         BAL   R9,NEXUSG               YES, GO DO IT
CKDARNG  L     R12,DATONLY             GET DATA ONLY TBL ADDR
         CLC   TXTOFSET,0(R12)         RANGE BEGINS LATER
         BL    CKLOSEQ                 YES
         CLC   TXTOFSET,3(R12)         THIS BYTE IN THE RANGE
         BNH   CONST                   YES
         LA    R12,6(R12)              PAST THIS ENTRY, STEP OVER 1
         ST    R12,DATONLY             SAVE UPDATED ADDR
         B     CKDARNG                 GO CHECK AGAIN
CKLOSEQ  CLC   TXTOFSET,LBLADR         LABEL ENTRY OUT OF SEQ
         BNH   GCKODD                  NO, CONTINUE
         BAL   R9,FORCONST             YES, FORCE ANY CONSTANT OUT
         MVC   NAME,LBLNAME            NAME TO OUTPUT
         MVC   MNEMONIC,=CL5'EQU'      MNEMONIC
         MVI   OPNDS,C'*'              OPERAND
         MVC   COMMENT(14),=14C'?'     SHOW ERROR
         BAL   R9,WRTOUT               WRITE ERROR RECORD
         BAL   R9,PRINT                GO PRINT IT
         LA    R6,L'LABEL(R6)          TO NEXT LABEL
         B     CKLOSEQ                 CONTINUE SEQ CHK
GCKODD   TM    TXTCURR+3,1             ODD ADDRESS
         BO    CONST                   YES, NOT INSTR
         CLC   1(3,R7),0(R7)           4 CONSEC IDENTICAL BYTES
         BE    CONST                   YES, NOT INSTR
         TRT   0(1,R7),CHARTRAN        TEST TEXT BYTE
         BNZ   CKINSTR                 NOT CHARACTER
         CLI   CONPROG,1               IS CONSTANT IN PROGRESS
         BNE   CK6                     NO
         CLI   CONTYPE,C'C'            IS IT CHARACTER TYPE
         BE    CONST                   YES, ADD THIS TO CONSTANT
CK6      TRT   0(6,R7),CHARTRAN        6 CONSECUTIVE CHARACTERS
         BZ    CONST                   YES, NOT INSTRUCTION
CKINSTR  SR    R8,R8                   CLEAR WORK
         IC    R8,0(R7)                PICK UP TXT BYTE
         MH    R8,SGOPLEN              TIMES TABLE LENGTH
         LA    R8,SGLOP(R8)            @ INSTR TBL ENTRY
         MVC   INSTENT,0(R8)           SAVE INSTRUCTION TBL ENTRY
         CLI   INAME,0                 IS IT AN INSTR OP-CODE
         BE    CONST                   NO
         CLI   ITYPE,TWO               TWO-BYTE OP-CODE
         BNE   INSTR                   NO
         L     R8,DBLOPAD              YES, GET 2-BYTE TBL ADDR
DBLND    CLI   0(R8),X'FF'             END OF TABLE
         BE    CONST                   YES, NOT INSTR
         CLC   0(2,R8),0(R7)           THIS ENTRY MATCHES TXT
         BE    GOTDBLI                 YES
         LA    R8,L'DBLOP(R8)          TO NEXT ENTRY
         B     DBLND                   LOOP THRU TBL
GOTDBLI  LA    R8,2(R8)                PASS OP-CODE BYTES
         MVC   INSTENT,0(R8)           SAVE INSTR TBL ENTRY
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS ENTERED WHEN CURSORY CHECKS IN THE MAINLINE    *
* INDICATE THIS TEXT BYTE IS AN INSTRUCTION OP-CODE. FURTHER     *
* TESTING IS DONE BY THE IVERFY (NON-FLOATING POINT), OR FPVERFY *
* (FLOATING POINT) ROUTINES. BYTES PASSING THESE TESTS ARE       *
* ACCEPTED AS OP-CODES, AND ARE PASSED TO THE APPROPRIATE FORMAT *
* ROUTINES. FORMAT ROUTINES ARE ENTERED VIA A BRANCH TABLE USING *
* A BYTE IN THE INSTRUCTION OP-CODE TABLE ENTRY.                 *
*                                                                *
******************************************************************
*
INSTR    EQU   *                       *** INSTRUCTIONS (POSSIBLY) ***
         MVC   ILENG+1(1),INLNG        SET INSTR LENGTH
         LH    R12,ILENG               PICK UP LENGTH
         AR    R12,R7                  ADDR OF NEXT OP CODE
         SR    R15,R15                 CLEAR WORK
         IC    R15,0(R12)              PICK UP NEXT OP-CODE
         MH    R15,SGOPLEN             TIMES TBL ENTRY LENG
         LA    R15,SGLOP(R15)          INSTR TBL ENTRY ADDR
         CLI   INAME-INSTENT(R15),0    IS IT AN OP-CODE
         BNE   ICKSEC                  YES
         CLI   0(R7),X'45'             IS IT BAL
         BE    ICKTBL                  YES, CONTINUE
         CLI   0(R7),7                 NO, IS IT BRCH
         BE    POSSB                   YES
         CLI   0(R7),X'47'             IS IT BRCH
         BNE   CONST                   NO, THEN THIS NOT INSTR
POSSB    TM    1(R7),X'F0'             IS IT UNCONDL BRCH
         BNO   CONST                   NO, THEN THIS NOT INSTR
         B     ICKTBL                  ACCEPT UNCOND BRCHS
ICKSEC   SR    R1,R1                   CLEAR WORK
         IC    R1,INLNG-INSTENT(R15)   GET INSTR LENGTH
         AR    R1,R12                  ADDR OF NEXT OP CODE
         SR    R14,R14                 CLEAR WORK
         IC    R14,0(R1)               PICK UP NEXT OP-CODE
         MH    R14,SGOPLEN             TIMES TBL ENTRY LENG
         LA    R14,SGLOP(R14)          INSTR TBL ENTRY ADDR
         CLI   INAME-INSTENT(R14),0    IS IT AN OP-CODE
         BNE   ICKTBL                  YES
         CLI   0(R12),X'45'            IS IT BAL
         BE    ICKTBL                  YES, CONTINUE
         CLI   0(R12),X'07'            NO, IS IT BRCH
         BE    POSSB2                  YES
         CLI   0(R12),X'47'            IS IT BRCH
         BNE   CONST                   NO, THEN THIS NOT INSTR
POSSB2   TM    1(R12),X'F0'            IS IT UNCONDL BRCH
         BNO   CONST                   NO, THEN THIS NOT INSTR
ICKTBL   LH    R12,ILENG               GET INSTR LENGTH
         AR    R12,R7                  @ NEXT TEXT LOC
         BCTR  R12,R0                  BACK UP 1
         S     R12,TXTSTRT             RELATIVIZE IN CSECT
         CLM   R12,7,LBLADR            LBL TBL ADDR HERE
         BL    NOILBL                  NO
         CLC   TXTOFSET,LBLADR         LABEL AT INSTR START
         BNE   NOTINST                 NO, MUST BE CONSTANT      FIX***
         CLI   LBLTYP,C'L'             IS IT A LABEL ONLY
         BNE   NOTINST                 NO                        FIX***
         CLI   CONPROG,1               CONSTANT IN PROGRESS
         BNE   CKLBLNG                 NO
         BAL   R9,FORCONST             YES, FORCE IT OUT
CKLBLNG  CLC   LBLLEN,INLNG            LENGTHS SAME
         BE    SETLBL                  YES
         CLI   LBLLEN,0                DON'T CARE LENGTH
         BE    SETLBL                  YES
         BAL   R9,EQUSTMT              NO, BUILD EQU STATEMENT
         B     ISTPLBL                 CONTINUE
SETLBL   MVC   NAME,LBLNAME            LABEL ENTRY NAME TO INSTR
         MVC   CONLEN,LBLLEN           SET CONSTANT LENGTH IN CASE
ISTPLBL  LA    R6,L'LABEL(R6)          TO NEXT LABEL TBL ENTRY
         CLM   R6,7,LBLADR             THIS ENTRY SAME ADDR
         BNE   ICKTBL                  NO
         SH    R6,LBLLGTH              BACK UP TO 1ST ENTRY
         BAL   R9,EQUSTMT              GO BUILD EQU STATEMENT
         LA    R6,L'LABEL(R6)          TO NEXT ENTRY
         B     ICKTBL                  GO CHECK NEXT LABEL
NOILBL   CLI   CONPROG,1               CONSTANT IN PROGRESS
         BNE   MVMNE                   NO
         BAL   R9,FORCONST             YES, FORCE IT OUT
MVMNE    MVC   MNEMONIC,0(R8)          SET INSTR MNEMONIC
         MVC   OFFSET,TXTOFSET         SET OFFSET
         MVC   INSTYP,5(R8)            SET INSTR TYPE
         MVI   TYPE,X'0D'              SHOW IT IS AN INSTRUCTION
         MVC   LEN,ILENG+1             SHOW LENGTH
         MVC   TEXT(6),0(R7)           MOVE ACTUAL TEXT
OPNDFMT  TM    ICLASS,FLTPT            FLOATING POINT OP-CODE
         BO    FPVERFY                 YES, GO VERIFY
         CLI   IEDT,0                  ANY EDIT REQUIRED
         BE    PFMFMT                  NO
         B     IVERFY                  YES, GO EDIT
PFMFMT   SR    R1,R1                   CLEAR WORK
         IC    R1,INSTYP               GET INSTRUCTION TYPE
         L     R9,OPND9                GET FORMAT ROUTINE RETURN ADDR
         B     *+4(R1)                 TO APPROPRIATE FORMATTING ROUTIN
         B     RROPND                  TYPE=0, RR
         B     RXOPND                  TYPE=4, RX
         B     SOPND                   TYPE=8, S
         B     SIOPND                  TYPE=C, SI
         B     RSOPND                  TYPE=10, RS
         B     SS1OPND                 TYPE=14, 1-LENGTH SS
         B     SS2OPND                 TYPE=18, 2-LENGTH SS
         B     SOPND                   TYPE=1C, 2-BYTE OP-CODES
         B     BCOPND                  TYPE=20, CONDITIONAL BRANCH
         B     SVCOPND                 TYPE=24, SVC
OPNDRTN  B     INSTOUT                 NORMAL OPERAND FORMAT RETURN
         MVC   CONNAME,NAME            ANY NAME TO CONSTANT AREA
         B     CONST                   ERROR INSTRUCTION, TREAT AS CONS
NOTINST  CLC   NAME,BLANX              IS NAME FILLED IN?        FIX***
         BE    CONST                                             FIX***
         SH    R6,LBLLGTH              BACK UP                   FIX***
         B     CONST                                             FIX***
INSTOUT  BAL   R9,WRTOUT               WRITE INSTRUCTION RECORD
         BAL   R9,TXTFMT               FORMAT HEX DATA
         BAL   R9,PRINT                GO PRINT IT
         AH    R7,ILENG                STEP TO NEXT TEXT BYTE
         ST    R7,TXTCURR              SAVE NEXT ADDR
         MVC   CCTYPE,ICCSET           SHOW COND CODE SET TYPE
         B     GETCURR                 CONTINUE TXT PROCESSING
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS ENTERED FROM THE INSTR ROUTINE FOR NON FLOATING*
* POINT INSTRUCTIONS. VARIOUS EDITS ARE PERFORMED TO INSURE THE  *
* INPUT TEXT BYTE IS AN OP-CODE. IF IT IS, RETURN IS TO LABEL    *
* PFMFMT, OTHERWISE THE CONST ROUTINE IS PERFORMED.              *
*                                                                *
******************************************************************
*
IVERFY   EQU   *                       *** VERIFY POSSIBLE INSTRUCTION
         TM    IEDT,EPR                EVEN-ODD REG PAIR
         BZ    IVE2                    NO
         TM    1(R7),X'10'             R1 IS ODD
         BO    CONST                   YES, NOT INSTR
         CLI   0(R7),X'0E'             IS IT MVCL
         BE    IVTRG2                  YES
         CLI   0(R7),X'0F'             IS IT CLCL
         BNE   IVE2                    NO
IVTRG2   TM    1(R7),X'01'             R2 IS ODD
         BO    CONST                   YES, NOT INSTR
         SR    R1,R1                   CLEAR WORK
         SR    R2,R2                   CLEAR WORK
         IC    R1,1(R7)                GET R1R2
         SRL   R1,4                    SHIFT OUT R2
         PACK  DBLWD(1),1(1,R7)        FLIP R1R2 BYTE
         IC    R2,DBLWD                PICK UP R2R1
         SRL   R2,4                    SHIFT OUT R1
         CR    R1,R2                   R1=R2
         BE    CONST                   YES, NOT INSTR
         B     PFMFMT                  NO, GOOD INSTR
IVE2     TM    IEDT,E2                 HALFWORD STORAGE ALIGNMENT
         BZ    IVE4                    NO
         TM    3(R7),X'01'             DISPL IS ODD
         BZ    IVES2                   NO, O.K.
         TM    2(R7),X'F0'             BASE REG = 0
         BNZ   IVES2                   NO, CONTINUE
         CLI   0(R7),X'44'             EX OP CODE
         BE    CONST                   YES, NOT INSTR
         CLI   0(R7),X'47'             BC OP CODE
         BE    CONST                   YES, NOT INSTR
         CLI   ITYPE,RS                RS INSTRUCTION
         BE    CONST                   YES, NOT INSTR
         TM    1(R7),X'0F'             INDEX REG IS 0
         BZ    CONST                   YES, NOT INSTR
         B     IVES2                   CONTINUE
IVE4     TM    IEDT,E4                 2ND OPND ON FULLWORD BOUND
         BZ    IVE8                    NO
         TM    3(R7),X'03'             DISPL DIV BY 4
         BZ    IVES2                   YES, O.K.
         TM    2(R7),X'F0'             BASE REG = 0
         BNZ   IVES2                   NO, CONTINUE
         CLI   ITYPE,RS                RS INSTRUCTION OP CODE
         BE    CONST                   YES, NOT INSTR
         TM    1(R7),X'0F'             INDEX REG = 0
         BZ    CONST                   YES, NOT INSTR
         B     IVES2                   NO, CONTINUE
IVE8     TM    IEDT,E8                 2ND OPND ON DBLWD BOUND
         BZ    IVES2                   NO
         TM    3(R7),X'07'             DISPL DIV BY 8
         BZ    IVES2                   YES, O.K.
         TM    2(R7),X'F0'             BASE REG = 0
         BNZ   IVES2                   NO
         TM    1(R7),X'0F'             INDEX REG = 0
         BZ    CONST                   YES, NOT INSTR
IVES2    CLI   PRIVASM,1               PRIVILEGED INSTR O.K.
         BE    PFMFMT                  YES
         TM    IEDT,S2                 OPND2 MUST HAVE BASE
         BZ    IVES1                   NO
         TM    2(R7),X'F0'             BASE REG = 0
         BNZ   PFMFMT                  NO, O.K.
         CLI   ITYPE,RS                RS INSTRUCTION
         BE    CONST                   YES, NOT INSTR
         CLI   0(R7),X'92'             IS IT MVI OP CODE
         BE    CONST                   YES, NOT INSTR
         TM    1(R7),X'0F'             INDEX REG = 0
         BZ    CONST                   YES, NOT INSTR
         B     PFMFMT                  NO, GOOD INSTR
IVES1    TM    IEDT,S1                 1ST OPND MUST HAVE BASE
         BZ    PFMFMT                  NO, CONTINUE
         TM    2(R7),X'F0'             1ST OPND HAS BASE
         BZ    CONST                   NO, NOT INSTR
         B     PFMFMT                  YES, INSTR O.K.
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS ENTERED FROM THE INSTR ROUTINE FOR FLOATING    *
* POINT INSTRUCTIONS. VARIOUS EDITS ARE PERFORMED TO INSURE THE  *
* INPUT TEXT BYTE IS AN OP-CODE. IF IT IS, RETURN IS TO LABEL    *
* PFMFMT, OTHERWISE THE CONST ROUTINE IS PERFORMED.              *
*                                                                *
******************************************************************
*
FPVERFY  EQU   *                       *** VALIDATE FLOATING POINT OP-C
         TM    1(R7),X'90'             R1 IS 0, 2, 4, OR 6
         BNZ   CONST                   NO, NOT INSTR
         CLI   0(R7),X'27'             MXDR OP-CODE
         BE    FPR1EXT                 YES
         CLI   0(R7),X'67'             MXD OP-CODE
         BNE   FPCKTYP                 NO
FPR1EXT  TM    1(R7),X'B0'             R1 IS 0 OR 4
         BNZ   CONST                   NO, NOT INSTR
FPCKTYP  CLI   ITYPE,RR                RR TYPE INSTRUCTION
         BNE   FPRXVER                 NO
         TM    1(R7),X'09'             R2 IS 0, 2, 4, 6
         BNZ   CONST                   NO, NOT INSTR
         CLI   0(R7),X'25'             LRDR OP CODE
         BE    FPR2EXT                 YES
         CLI   0(R7),X'37'             SXR OP-CODE
         BE    FPR2EXT                 YES
         CLI   0(R7),X'26'             MXR OP-CODE
         BE    FPR2EXT                 YES
         CLI   0(R7),X'36'             AXR OP-CODE
         BNE   PFMFMT                  NO, GOOD INSTR
FPR2EXT  TM    1(R7),X'0B'             R2 IS 0 OR 4
         BZ    PFMFMT                  YES, GOOD INSTR
         B     CONST                   NO, NOT INSTR
FPRXVER  CLI   PRIVASM,1               PRIVILEGED INSTRUCTIONS O.K.
         BE    FPALIGN                 YES
         TM    2(R7),X'F0'             ANT BASE REG
         BNZ   FPALIGN                 YES
         TM    1(R7),X'0F'             ANY INDEX REG
         BZ    CONST                   NO, NOT INSTR
FPALIGN  TM    2(R7),X'F0'             ANY BASE REG
         BNZ   PFMFMT                  YES, ACCEPT INSTR
         TM    1(R7),X'0F'             ANY INDEX REG
         BNZ   PFMFMT                  YES, ACCEPT INSTR
         TM    3(R7),X'03'             DISPL DIV BY 4
         BNZ   CONST                   NO, NOT INSTR
         TM    ICLASS,FLSHT            SHORT PRECISION
         BO    PFMFMT                  YES, ACCEPT INSTRUCTION
         TM    3(R7),X'07'             DISPL DIV BY 8
         BZ    PFMFMT                  YES, ACCEPT INSTR
         B     CONST                   NO, NOT INSTR
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS ENTERED FROM VARIOUS OTHER ROUTINES WHEN THE   *
* CURRENT TEXT BYTE IS DETERMINED NOT TO BE AN INSTRUCTION OP    *
* CODE. A CONSTANT AREA IS BUILT TO CONTAIN THE CONSTANT, IT'S   *
* DATA TYPE, SYMBOL TO BE USED FOR ADCONS, LABEL TO BE USED, IF  *
* ANY, ETC. THE CONSTANT IS BUILT BYTE BY BYTE, AND IS TERMINATED*
* FOR OUTPUT BY THE FORCONST ROUTINE. THIS ROUTINE DETECTS END OF*
* CONSTANT WHEN THE CONSTANT IN PROGRESS EXCEEDS 2 BYTES FOR A   *
* HALFWORD, 4 BYTES FOR A FULLWORD, OR 8 BYTES AS A MAXIMUM. IT  *
* IS ALSO TERMINATED WHEN A CHANGE IN DATA TYPE OCCURS.          *
*                                                                *
******************************************************************
*
CONST    EQU   *                       *** PROCESS CONSTANTS ***
         MVC   WORKREC,BLANX           CLEAR WORK RECORD AREA
         CLI   CONPROG,1               CONSTANT IN PROGRESS
         BNE   CCNEW                   NO
         CLC   TXTOFSET,LBLADR         LABEL ENTRY HAS THIS OFFSET
         BNE   CGETYP                  NO
CSTNEW   BAL   R9,FORCONST             FORCE IT OUT
         B     CCNEW                   GO START A NEW ONE
CGETYP   TRT   0(1,R7),CHARTRAN        CHECK DATA TYPE OF BYTE
         BNZ   CHEX                    IT'S HEX
         MVI   CCKTYP+1,C'C'           SET TYPE IN COMPARE
         B     CCKTYP                  GO COMPARE
CHEX     MVI   CCKTYP+1,C'X'           SET TYPE IN COMPARE
CCKTYP   CLI   CONTYPE,C' '            TYPE IN PROG SAME AS THIS BYTE
         BNE   CSTNEW                  NO
CUPDCON  LH    R11,CONLEN              GET CURRENT LENGTH
         LA    R11,1(R11)              ADD 1
         STH   R11,CONLEN              UPDATE LENGTH
         L     R11,CONLOC              GET CURRENT LOC IN CONST DATA
         MVC   0(1,R11),0(R7)          MOVE BYTE TO DATA
         LA    R11,1(R11)              STEP OVER ONE BYTE
         ST    R11,CONLOC              SAVE UPDATED DATA ADDR
         CLI   CONTYPE,C'C'            CHARACTER CONSTANT
         BE    CCK8                    YES
         TM    CONOFST+3,1             OFFSET IS ODD
         BO    CCFIN1                  YES
         TM    CONOFST+3,2             HALFWORD OFFSET
         BZ    CCFWD                   NO
         CLI   CONLEN+1,1              HALFWORD, IS LENGTH = 1
         BE    CCXIT1                  YES
         B     CCFIN1                  NO
CCFWD    CLI   CONLEN+1,4              NO, IS HEX CONST 4 BYTES
         BL    CCXIT1                  NOT YET
CCFIN1   BAL   R9,FORCONST             MAX LENG, FORCE IT OUT
         B     CCXIT1                  FINISH
CCK8     CLC   CONLEN,H8               CHAR CONSTANT 8 BYTES
         BNL   CCFIN1                  YES
CCXIT1   LA    R7,1(R7)                STEP OVER 1 BYTE IN TEXT
         ST    R7,TXTCURR              UPDATE TEXT ADDR
         B     GETCURR                 CONTINUE TEXT PROCESSING
CCNEW    MVI   CONPROG,1               SHOW CONSTANT IN PROGRESS
         MVC   CONOFST,TXTOFST         SET OFFSET TO 1ST BYTE
         MVC   CONNAME,BLANX           CLEAR NAME
         XC    CONDATA,CONDATA         CLEAR DATA AREA
         MVC   CONSYM,BLANX            CLEAR SYMBOL NAME
         MVC   CONLEN,XZROS            CLEAR LENGTH
         LA    R11,CONDATA             GET 1ST DATA BYTE ADDR
         ST    R11,CONLOC              SET STARTING ADDRESS OF DATA
         CLC   TXTOFSET,LBLADR         LABEL AT THIS OFFSET
         BE    CLBLD                   YES
TRTYPE   TRT   0(1,R7),CHARTRAN        CHECK DATA TYPE OF BYTE
         BNZ   CCSHX                   IT'S HEX
         MVI   CONTYPE,C'C'            IT'S CHAR, SO INDICATE
         B     CUPDCON                 GO COMPLETE
CCSHX    MVI   CONTYPE,C'X'            IT'S HEX, SO INDICATE
         B     CUPDCON                 GO COMPLETE
CLBLD    CLI   LBLTYP,C'L'             IS IT A LABEL ONLY
         BNE   CDATACON                NO
         MVC   CONNAME,LBLNAME         NAME TO CONSTANT WORK AREA
         MVC   CONLLEN,LBLLEN         SAVE LENGTH
         LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY
         CLC   TXTOFSET,LBLADR         THIS LABEL AT SAME ADDR
         BNE   TRTYPE                  NO
         CLI   LBLTYP,C'L'             THIS ANOTHER LABEL ONLY
         BNE   CDATACON                NO
         SH    R6,LBLLGTH             BACK UP TO LABEL ENTRY
         BAL   R9,EQUSTMT             GO BUILD EQU STATEMENT
         LA    R6,L'LABEL(R6)          TO NEXT LABELENTRY
         B     CCNEW                   GO TO NEXT LABEL
CDATACON MVC   CONTYPE,LBLTYP          TYPE TO CONSTANT AREA
         SR    R1,R1                   CLEAR WORK
         IC    R1,LBLLEN               PICK UP CONSTNT LENGTH
         STH   R1,CONLEN               SAVE CONSTANT LENGTH
         BCTR  R1,R0                   COMPUTE CONSTANT LENGTH CODE
         STC   R1,MCD+1                SET MOVE LENGTH CODE
MCD      MVC   CONDATA,0(R7)           MOVE DATA TO RECORD
         MVC   CONSYM,LBLNAME          SYMBOL TO CONSTANT AREA
         SR    R11,R11                 CLEAR WORK REG
         IC    R11,LBLLEN              PICK UP LENGTH
         AR    R7,R11                  STEP PAST TEXT
         ST    R7,TXTCURR              UPDATE TEXT ADDRESS
         BAL   R9,FORCONST             FORCE CONSTANT OUT
         LA    R6,L'LABEL(R6)          STEP TO NEXT LABEL ENTRY
         B     GETCURR                 CONTINUE TEXT PROCESS
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS ENTERED BY VARIOUS ROUTINES WHEN IT IS         *
* NECESSARY TO WRITE THE CONSTANT CURRENTLY IN PROGRESS, AND     *
* CLEAR FIELDS FOR THE NEXT CONSTANT TO BE CREATED.              *
*                                                                *
******************************************************************
*
FORCONST EQU   *                       *** FORCE OUT CONSTANT IN PROGRE
         ST    R9,FC9                  SAVE RETURN ADDR
         CLC   CONNAME,BLANX           ANY LABEL NAME SET UP
         BE    CKCNPRG                 NO, CONTINUE
         CLC   CONLLEN,CONLEN+1        LENGTHS SAME
         BE    CKCNPRG                 YES, CONTINUE
         ST    R6,FC6                  SAVE LABEL TABLE ADDR
         LA    R6,CONPSLBL             @ PSEUDO LABEL ENTRY
         BAL   R9,EQUSTMT              GO BUILD EQU STATEMENT
         MVC   CONNAME,BLANX           CLEAR STATEMENT LABEL FIELD
         L     R6,FC6                  RESTORE LABEL TABLE POINTER
CKCNPRG  CLI   CONPROG,1               CONSTANT IN PROGRESS
         BNE   FCCLR                   NO
         CLI   CONLEN+1,0              ANY DATA LENGTH
         BE    FCCLR                   NO
         XC    TEXT,TEXT               CLEAR TEXT FIELD
         MVC   MNEMONIC(2),=C'DC'      SET MNEMONIC
         MVC   OPNDS(1),CONTYPE        SET TYPE
         MVI   OPNDS+1,C''''           OPERAND DELIMITER
         MVC   NAME,CONNAME            NAME TO RECORD
         MVC   OFFSET,CONOFST+1        OFFSET TO RECORD
         MVI   INSTYP,0                NOT AN INSTRUCTION
         MVI   TYPE,2                  NON-ADDRESS CONSTANT
         MVC   LEN,CONLEN+1            DATA LENGTH
         LH    R11,CONLEN              DATA LENGTH
         BCTR  R11,R0                  DATA LENGTH CODE
         STC   R11,FMCON+1             MOVE LENGTH TO MVC
FMCON    MVC   TEXT,CONDATA            DATA TO RECORD
         CLI   CONTYPE,C'C'            CHARACTER TYPE
         BE    FCHAR                   YES
         CLI   CONTYPE,C'X'            HEX TYPE
         BNE   FSYMBOL                 NO
         TM    CONOFST+3,1             OFFSET TO CONSTANT IS ODD
         BO    FHEX                    YES
         TM    CONLEN+1,1              LENGTH IS ODD
         BO    FHEX                    YES
         TM    CONOFST+3,2             OFFSET DIVISIBLE BY 4
         BO    FHWD                    NO
         CLI   CONLEN+1,4              IS IT 4-BYTES
         BNE   FHWD                    NO, JUST HALFWORD
         CLC   CONDATA(4),XZROS        CONSTANT IS ALL ZEROS
         BNE   FFCKNEG                 NO
         MVC   OPNDS(4),=C'F''0'''     BUILD OPERANDS
         B     FCWRT                   CONTINUE
FFCKNEG  ICM   R11,15,CONDATA          GET DATA
         BM    FHEX                    NEG, TREAT AS HEX
         C     R11,=F'99999'           VALUE EXCEEDS 99,999
         BH    FHEX                    YES, TREAT AS HEX
         MVC   OPNDS(2),=C'F'''        OPERAND DATA TYPE IS F
         CVD   R11,DBLWD               CONVERT VALUE TO PACKED
         UNPK  OPNDS+2(5),DBLWD+5(3)   UNPACK INTO OPERAND
         OI    OPNDS+6,C'0'            SET SIGN = F
         MVI   OPNDS+7,C''''           ENDING QUOTE
         B     FCWRT                   CONTINUE
FHWD     LH    R11,CONDATA             PICK UP HALFWORD
         LTR   R11,R11                 TEST CONSTANT VALUE
         BM    FHEX                    NEGATIVE, TREAT AS HEX
         BNZ   FHCMAX                  NOT ZERO, CHECK MAX VALUE
         MVC   OPNDS(4),=C'H''0'''     SET OPERAND FOR ZERO
         B     FCWRT                   CONTINUE
FHCMAX   CH    R11,=H'9999'            VALUE EXCEEDS 9,999
         BH    FHEX                    YES, TREAT AS HEX
         CVD   R11,DBLWD               CONVERT TO PACKED
         OI    DBLWD+7,X'0F'           CLEAR SIGN TO F
         MVC   OPNDS(2),=C'H'''        SET DELIMITER IN OPERAND
         UNPK  OPNDS+2(4),DBLWD+5(3)   UNPACK VALUE TO OPERAND
         MVI   OPNDS+6,C''''           ENDING DELIMITER
         B     FCWRT                   CONTINUE
FCHAR    MVC   OPNDS(2),=C'C'''        OPERAND DELIMITER FOR CHARACTER
         LH    R11,CONLEN              GET DATA LENGTH
         BCTR  R11,R0                  LENGTH CODE
         STC   R11,FMCNT+1             SET MOVE LENGTH
FMCNT    MVC   OPNDS+2,CONDATA         DATA TO OPERAND
         LA    R11,OPNDS+3(R11)        STEP PAST OPERAND DATA
         MVI   0(R11),C''''            ENDING QUOTE
         B     FCWRT                   CONTINUE
FSYMBOL  CLC   CONSYM,BLANX            IS IT BLANK
         BE    FHEX                    YES, TREAT AS HEX
         CLI   CONLEN+1,4              LENGTH IS 4
         BH    FHEX                    NO, GREATER
         BE    AC4                     YES, 4 BYTES
         CLI   CONLEN+1,3              LENGTH IS 3
         BE    AC3                     YES
         CLI   CONLEN+1,2              LENGTH IS 2
         BE    AC2                     YES
         MVC   OPNDS+1(2),=C'L1'       OPND LENGTH
         B     FSLHE1                  CONTINUE
AC2      MVC   OPNDS+1(2),=C'L2'       OPND LGTH
         B     FSLHE1                  CONTINUE
AC3      MVC   OPNDS+1(2),=C'L3'       OPND LENGTH
         B     FSLHE1                  CONTINUE
AC4      LA    R11,OPNDS+1             STEP TO ( POS
         B     FSLHE                   CONTINUE
FSLHE1   LA    R11,OPNDS+3             STEP TO ( POS
FSLHE    MVI   0(R11),C'('             DELIMITER
         MVC   1(8,R11),CONSYM         SYMBOL TO RECORD
         LA    R11,9(R11)              @ RHE SYMBOL IN OPERAND
FRHE     CLI   0(R11),C' '             CHARACTER IS BLANK
         BNE   SETRPAR                 NO
         BCT   R11,FRHE                LOOP TO FIND RHE
SETRPAR  MVI   1(R11),C')'             SET CLOSING PAREN
         B     FCWRT                   CONTINUE
FHEX     MVC   OPNDS(2),=C'X'''        TYPE AND BEGIN QUOTE
         LA    R12,CONDATA             @ CONSTANT DATA
         BAL   R9,HEXPRT4              CONVERT TO PRINTABLE
         LH    R12,CONLEN              GET DATA LENGTH
         SLL   R12,1                   DOUBLE IT
         BCTR  R12,R0                  -1 = LENGTH CODE
         STC   R12,MVHX+1              SET MOVE LENGTH
MVHX     MVC   OPNDS+2(1),PRTABL       HEX CHARS TO OPERAND
         LA    R12,OPNDS+2(R12)        OPERAND END ADDRESS
         MVI   1(R12),C''''            ENDING QUOTE
         B     FCWRT                   CONTINUE
FCWRT    BAL   R9,WRTOUT               WRITE RECORD
         BAL   R9,TXTFMT               GO FORMAT HEX DATA
         BAL   R9,PRINT                GO PRINT IT
FCCLR    MVI   CONPROG,0               RESET CONSTANT IN PROGRESS
         MVC   CONNAME,BLANX           CLEAR NAME
         MVI   CONTYPE,0               RESET TYPE
         XC    CONDATA,CONDATA         CLEAR CONSTANT DATA
         MVC   CONSYM,BLANX            CLEAR SYMBOL
         XC    CONLEN,CONLEN           CLEAR LENGTH
         MVC   CONLOC,XZROS            CLEAR LOCATION
         MVC   CONOFST,XZROS           CLEAR OFFSET TO CONSTANT
         L     R9,FC9                  GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE FORMATS RR-FORMAT INSTRUCTIONS FOR OUTPUT.        *
*                                                                *
******************************************************************
*
RROPND   EQU   *                       *** RR FORMAT INSTRUCTIONS ***
         CLI   0(R7),X'05'             IS IT BALR
         BNE   RRSTRT
         CLI   1(R7),X'EF'             IS IT BALR 14,15
         BE    RRSTDL                  YES
         TM    1(R7),X'0F'             NO, IS R2 = 0
         BNZ   RRNSTD                  NO
         MVC   COMMENT(11),=C'ADDRESS SET'
         B     RRSTRT                  CONTINUE
RRSTDL   MVC   COMMENT(11),=C'STD LINKAGE'
         B     RRSTRT                  CONTINUE
RRNSTD   MVC   COMMENT(14),=C'NONSTD LINKAGE'
RRSTRT   SR    R1,R1                   CLEAR WORK
         IC    R1,TEXT+1               GET 2ND BYTE
         SRL   R1,4                    SHIFT OUT R2
         CVD   R1,DBLWD                CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         MVI   OPNDS,C'R'              BEGIN R1 OPERAND
         CH    R1,H10                  REG NBR > 9
         BL    RR11                    NO, 0-9
         MVC   OPNDS+1(2),DBLWD        YES, 10-15
         LA    R1,OPNDS+3              TO NEXT POS
         B     RRCMA                   CONTINUE
RR11     MVC   OPNDS+1(1),DBLWD+1      MOVE REG NBR
         LA    R1,OPNDS+2              TO NEXT POS
RRCMA    CLI   TEXT,X'04'              IS IT SPM
         BNE   RRCMA1                  NO
         TM    1(R7),X'0F'             YES, IS R2 FIELD = 0
         BZ    RRXIT                   YES, GOOD INSTR
         B     4(R9)                   ERROR RETURN (NOT INSTR)
RRCMA1   MVC   0(2,R1),=C',R'          DELIMITERS
         PACK  DBLWD(1),TEXT+1(1)      FLIP 2ND BYTE
         SR    R15,R15                 CLEAR WORK
         IC    R15,DBLWD               GET R2R1
         SRL   R15,4                   SHIFT OUT R1
         CVD   R15,DBLWD               CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CH    R15,H10                 R2 > 9
         BL    RR21                    NO, 0-9
         MVC   2(2,R1),DBLWD           YES, MOVE REG 10-15
         BR    R9                      EXIT
RR21     MVC   2(1,R1),DBLWD+1         MOVE REG 0-9
RRXIT    BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT RX-TYPE  *
* INSTRUCTIONS. THE BDXADR ROUTINE IS CALLED TO FORMAT THE       *
* STORAGE OPERAND.                                               *
*                                                                *
******************************************************************
*
RXOPND   EQU   *                       *** RX FORMAT INSTRUCTIONS ***
         CLI   0(R7),X'45'             IS IT BAL OP CODE
         BNE   RXSTRT                  NO
         MVC   COMMENT(7),=C'PERFORM'
         TM    1(R7),X'E0'             R1 = 0 OR 1
         BNZ   RXSTRT                  NO
         MVC   COMMENT(13),=C'PARM SET BRCH'
RXSTRT   SR    R1,R1                   CLEAR WORK
         IC    R1,TEXT+1               GET R1X2
         SRL   R1,4                    SHIFT OUT X2
         CVD   R1,DBLWD                CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         MVI   OPNDS,C'R'              BEGIN 1ST OPERAND
         CH    R1,H10                  R1 < 10
         BL    RXR11                   YES, 0-9
         MVC   OPNDS+1(2),DBLWD        NO, MOVE REG 10-15
         LA    R15,OPNDS+3             TO NEXT POS
         B     RXCMA                   CONTINUE
RXR11    MVC   OPNDS+1(1),DBLWD+1      MOVE REG 0-9
         LA    R15,OPNDS+2             TO NEXT POS
RXCMA    MVI   0(R15),C','             DELIMITER
         PACK  DBLWD(1),TEXT+1(1)      FLIP 2ND BYTE
         SR    R10,R10                 CLEAR WORK
         IC    R10,DBLWD               PICK UP X2R1
         SRL   R10,4                   SHIFT OUT R1
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD
         BAL   R9,BDXADR               CONVERT RX ADDRESS
         STC   R10,BDXMVC+1            SET MOVE LENGTH
BDXMVC   MVC   1(1,R15),OPNDWK         MOVE RX OPERAND
         L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT S-TYPE   *
* INSTRUCTIONS. THE BDADR ROUTINE IS CALLED TO FORMAT THE        *
* STORAGE OPERAND.                                               *
*                                                                *
******************************************************************
*
SOPND    EQU   *                       *** S FORMAT INSTRUCTIONS ***
         CLI   1(R7),0                 BYTE 2 OF INSTR IS ZERO
         BE    SCK2                    YES
         CLI   0(R7),X'80'             NO, IS IT SSM
         BE    4(R9)                   YES, NOT INSTR
         CLI   0(R7),X'82'             NO, IS IT LPSW
         BE    4(R9)                   YES, NOT INSTR
         CLI   0(R7),X'93'             NO, IS IT TS
         BE    4(R9)                   YES, NOT INSTR
SCK2     CLI   0(R7),X'B2'             OP-CODE IS B2
         BNE   SSTRT                   NO
         CLC   2(2,R7),XZROS           3RD AND 4TH BYTES ZERO
         BE    SSTRT                   YES
         CLI   1(R7),X'0B'             IPK INSTRUCTION
         BE    4(R9)                   YES, NOT INSTR
         CLI   1(R7),X'0D'             PTLB INSTR
         BE    4(R9)                   YES, NOT INSTR
SSTRT    SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD
         BAL   R9,BDADR                CONVERT BDDD ADDRESS
         STC   R10,SOPMVC+1            SET MOVE LENGTH
SOPMVC   MVC   OPNDS,OPNDWK            MOVE OPERAND
         L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SI-TYPE  *
* INSTRUCTIONS. THE BDADR ROUTINE IS CALLED TO FORMAT THE        *
* STORAGE OPERAND.                                               *
*                                                                *
******************************************************************
*
SIOPND   EQU   *                       *** SI FORMAT INSTRUCTIONS ***
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD ADDRESS
         BAL   R9,BDADR                CONVERT ADDRESS
         STC   R10,SIOMVC+1            SET MOVE LENGTH
SIOMVC   MVC   OPNDS,OPNDWK            MOVE BDDD OPERAND
         LA    R15,OPNDS+1(R10)        TO NEXT POS
         MVI   0(R15),C','             DELIMITER
         TRT   TEXT+1(1),CHARTRAN      TEST IF CHARACTER
         BNZ   HEXIMM                  NO, HEX
         CLI   TEXT,X'95'              IS IT CLI
         BE    CHIMM                   YES
         CLI   TEXT,X'92'              IS IT MVI
         BNE   HEXIMM                  NO
CHIMM    MVC   1(2,R15),=C'C'''        DELIMITER
         MVC   3(1,R15),TEXT+1         CHARACTER TO OPERAND
         MVI   4(R15),C''''            ENDING DELIMITER
         L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
HEXIMM   MVC   1(2,R15),=C'X'''        DELIMITER FOR HEX
         LA    R12,TEXT+1              @ HEX BYTE
         BAL   R9,HEXPRT1              CONVERT
         MVC   3(2,R15),PRTABL         PRINTABLE HEX TO OPERAND
         MVI   5(R15),C''''            FINAL QUOTE
         L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT RS-TYPE  *
* INSTRUCTIONS. THE BDADR ROUTINE IS CALLED TO FORMAT THE        *
* STORAGE OPERAND.                                               *
*                                                                *
******************************************************************
*
RSOPND   EQU   *                       *** RS FORMAT INSTRUCTIONS ***
         CLI   TEXT,X'90'              IS IT STM
         BE    RSSTM                   YES
         CLI   TEXT,X'98'              IS IT LM
         BNE   RSCLR1                  NO
         MVC   COMMENT(12),=C'RESTORE REGS'
         B     RSCLR1                  CONTINUE
RSSTM    MVC   COMMENT(9),=C'SAVE REGS'
RSCLR1   SR    R1,R1                   CLEAR WORK
         IC    R1,TEXT+1               PICK UP R1R3
         SRL   R1,4                    SHIFT OUT R3
         CVD   R1,DBLWD                CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         MVI   OPNDS,C'R'              BEGINNING OPERAND 1
         CH    R1,H10                  REG NBR < 10
         BL    RSR11                   YES
         MVC   OPNDS+1(2),DBLWD        MOVE REG 10-15
         LA    R15,OPNDS+3             TO NEXT POS
         B     RSCMA                   CONTINUE
RSR11    MVC   OPNDS+1(1),DBLWD+1      MOVE REG 0-9
         LA    R15,OPNDS+2             TO NEXT POS
RSCMA    CLI   0(R7),X'88'             IS IT SHIFT INSTR
         BL    RSCMA1                  NO
         CLI   0(R7),X'8F'             IS IT SHIFT INSTR
         BH    RSCMA1                  NO
         TM    1(R7),X'0F'             SHIFT, IS R3 POS = 0
         BZ    RSBDD                   YES, GOOD SHIFT
         B     4(R9)                   NO, NOT INSTR
RSCMA1   MVC   0(2,R15),=C',R'         DELIMITERS
         CLI   0(R7),X'BD'             CLM, STCM, OR ICM
         BL    RSPK2                   NO
         CLI   0(R7),X'BF'             CLM,STCM, OR ICM
         BH    RSPK2                   NO
         BCTR  R15,R0                  CLM, STCM, ICM HAVE MASK IN R3 P
RSPK2    PACK  DBLWD(1),TEXT+1(1)      FLIP 2ND BYTE
         SR    R1,R1                   CLEAR WORK
         IC    R1,DBLWD                GET R3R1
         SRL   R1,4                    SHIFT OUT R1
         CVD   R1,DBLWD                CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CH    R1,H10                  REG NBR < 10
         BL    RSR31                   YES, 0-9
         MVC   2(2,R15),DBLWD          MOVE REG 10-15
         LA    R15,4(R15)              TO NEXT POS
         B     RSBDD                   CONTINUE
RSR31    MVC   2(1,R15),DBLWD+1        MOVE REG 0-9
         LA    R15,3(R15)              TO NEXT POS
RSBDD    MVI   0(R15),C','             DELIMITER
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDD ADDRESS
         BAL   R9,BDADR                CONVERT BDDD ADDRESS
         STC   R10,RSMVC+1             SET MOVE LENGTH
RSMVC    MVC   1(1,R15),OPNDWK         MOVE BDDD ADDRESS
         L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SS-TYPE  *
* INSTRUCTIONS OF THE SINGLE LENGTH VARIETY. THE BDLADR ROUTINE  *
* IS CALLED TO FORMAT THE 1ST STRG OPND, AND BDADR FOR THE 2ND.  *
*                                                                *
******************************************************************
*
SS1OPND  EQU   *                       *** SS FORMAT INSTRUCTIONS - SIN
         SR    R10,R10                 CLEAR WORK
         IC    R10,TEXT+1              GET LENGTH CODE
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD ADDRESS
         BAL   R9,BDLADR               CONVERT ADDRESS
         STC   R10,SS1MV1+1            SET MOVE LENGTH
SS1MV1   MVC   OPNDS,OPNDWK            MOVE ADDRESS
         LA    R15,OPNDS+1(R10)        TO NEXT POS
         MVI   0(R15),C','             DELIMITER
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+4            GET SECOND BDDD ADDRESS
         BAL   R9,BDADR                CONVERT ADDRESS
         STC   R10,SS1MV2+1            SET MOVE LENGTH
SS1MV2   MVC   1(1,R15),OPNDWK         MOVE 2ND OPERAND
         L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SS-TYPE  *
* INSTRUCTIONS OF THE DOUBLE LENGTH VARIETY. THE BDLADR ROUTINE  *
* IS CALLED TO FORMAT THE STORAGE OPERANDS.                      *
*                                                                *
******************************************************************
*
SS2OPND  EQU   *                       *** SS FORMAT INSTRUCTIONS - 2 L
         SR    R10,R10                 CLEAR WORK
         IC    R10,TEXT+1              GET L1L2
         SRL   R10,4                   SHIFT OUT L2
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD ADDRESS
         BAL   R9,BDLADR               CONVERT ADDRESS
         STC   R10,SS2MV1+1            SET MOVE LENGTH
SS2MV1   MVC   OPNDS,OPNDWK            MOVE 1ST OPERAND
         LA    R15,OPNDS+1(R10)        TO NEXT POS
         MVI   0(R15),C','             DELIMITER
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+4            GET 2ND BDDD ADDR
         PACK  DBLWD(1),TEXT+1(1)      FLIP LENGTH BYTE
         SR    R10,R10                 CLEAR WORK
         IC    R10,DBLWD               PICK UP L2L1
         SRL   R10,4                   SHIFT OUT L1
         CLI   TEXT,X'F0'              SRP OP-CODE
         BE    SRPOP2                  YES
         BAL   R9,BDLADR               CONVERT ADDRESS
         STC   R10,SS2MV2+1            SET MOVE LENGTH
SS2MV2   MVC   1(1,R15),OPNDWK         MOVE 2ND OPERAND
SS2XIT   L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
SRPOP2   BAL   R9,BDADR                GO BUILD OPERAND 2
         STC   R10,SRMV1+1             SET MOVE LENGTH
SRMV1    MVC   1(1,R15),OPNDWK         MOVE OPERAND 2
         LA    R15,2(R10,R15)          TO NEXT OPERAND POS  FIX***
         PACK  DBLWD(1),TEXT+1(1)      FLIP LENGTH BYTE
         SR    R10,R10                 CLEAR WORK
         IC    R10,DBLWD               PICK UP I3L1
         SRL   R10,4                   SHIFT OUT L1
         CVD   R10,DBLWD               CONVERT I3
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         MVI   0(R15),C','             OPERAND SEPARATOR    FIX***
         UNPK  1(1,R15),DBLWD+7(1)     UNPACK I3 TO OPERAND FIX***
         CH    R2,H10                  I3 < 10
         BL    SS2XIT                  YES
         UNPK  1(2,R15),DBLWD+6(2)     NO, UNPACK MORE
         B     SS2XIT                  CONTINUE
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT COND-    *
* ITIONAL BRANCH INSTRUCTIONS. AN ATTEMPT IS MADE TO USE THE     *
* EXTENDED MNEMONICS WHERE POSSIBLE. FOR RR-TYPE BRANCHES, ONLY  *
* THE BR AND NOPR MNEMONICS ARE USED. FOR RX-TYPE BRANCHES, THE  *
* FULL SET OF EXTENDED MNEMONICS IS USED. THE TYPES USED ARE     *
* ARITHMETIC, COMPARE, AND 8=ZERO TYPES. THE SET TO BE USED IS   *
* DETERMINED BY THE TYPE SAVED BY THE LAST CONDITION-CODE-SETTING*
* INSTRUCTION GENERATED.                                         *
*
******************************************************************
*
BCOPND   EQU   *                       *** CONDITIONAL BRANCH INSTRUCTI
         TM    TEXT+1,X'F0'            UNCONDITIONAL BRANCH
         BZ    NOPS                    NO, NOP
         BO    UNCNDS                  YES, UNCONDITIONAL
         SR    R11,R11                 CLEAR WORK
         IC    R11,TEXT+1              PICK UP M1X2
         SRL   R11,4                   SHIFT OUT ALL BUT M1
         CLI   TEXT,X'07'              BCR OP CODE
         BE    NOEXTND                 YES, NO EXTENDED MNEMONICS
         CLI   CCTYPE,0                LAST INSTR SET CC
         BE    NOEXTND                 NO
         TM    CCTYPE,ARITH            YES, WAS IT ARITHMETIC
         BO    EXTARITH                YES
         TM    CCTYPE,CPR              WAS IT COMPARE
         BO    EXTCPR                  YES
         TM    CCTYPE,ZRO8             IS IT VALID FOR 8 = BZ
         BO    EXTZRO                  YES
NOEXTND  CVD   R11,DBLWD               CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CH    R11,H10                 MASK < 10
         BL    BCM1                    YES, SINGLE DIGIT MASK
         MVC   OPNDS(2),DBLWD          2-DIGIT MASK TO OPERAND
         LA    R15,OPNDS+2             TO NEXT POS
         B     BCCMA                   CONTINUE
BCM1     MVC   OPNDS(1),DBLWD+1        SINGLE DIGIT MASK TO OPERAND
         LA    R15,OPNDS+1             TO NEXT POS
BCCMA    MVI   0(R15),C','             DELIMITER
         CLI   TEXT,X'07'              RR BRANCH
         BE    BCROPND                 YES
BCXOPND  PACK  DBLWD(1),TEXT+1(1)      PACK 2ND BYTE
         SR    R10,R10                 CLEAR WORK
         IC    R10,DBLWD               PICK UP X2M1
         SRL   R10,4                   SHIFT OUT M1
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            PICK UP BDDD ADDRESS
         BAL   R9,BDXADR               CONVERT ADDRESS
         STC   R10,BLDXMVC+1           SET MOVE LENGTH
BLDXMVC  MVC   1(1,R15),OPNDWK         MOVE OPERAND
         B     BCOXIT                  GO TO EXIT
BCROPND  MVI   1(R15),C'R'             REGISTER DELIMITER
         SR    R10,R10                 CLEAR WORK
         PACK  DBLWD(1),TEXT+1(1)      FLIP 2ND BYTE
         IC    R10,DBLWD               PICK UP R2M1
         SRL   R10,4                   SHIFT OUT M1
         CVD   R10,DBLWD               CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CH    R10,H10                 REG NBR < 10
         BL    BCRR1                   YES, 0-9
         MVC   2(2,R15),DBLWD          MOVE 2-DIGIT REG NBR
         B     BCOXIT                  GO TO EXIT
BCRR1    MVC   2(1,R15),DBLWD+1        MOVE 1-DIGIT REG NBR
         B     BCOXIT                  GO TO EXIT
NOPS     CLI   TEXT,X'07'              RR NOP
         BNE   BCXNOP                  NO, RX
         MVC   MNEMONIC,=CL5'NOPR'     SET MNEMONIC
         LA    R15,OPNDS-1             TO OPND POS
         B     BCROPND                 FINISH
BCXNOP   MVC   MNEMONIC,=CL5'NOP'      SET MNEMONIC
         LA    R15,OPNDS               TO OPND POS
         B     BCXOPND                 FINISH
UNCNDS   CLI   TEXT,X'07'              IS IT RR BRANCH
         BNE   BCXBRCH                 NO, RX
         MVC   MNEMONIC,=CL5'BR'       SET MNEMONIC
         LA    R15,OPNDS-1             OPERAND ADDR
         CLI   TEXT+1,X'FE'            IS IT BR 14
         BNE   BCROPND                 NO
         MVC   COMMENT(4),=C'EXIT'     COMMENT
         B     BCROPND                 FINISH FORMATTING
BCXBRCH  MVC   MNEMONIC(5),=CL5'B'     SET MNEMONIC
BCXTFIN  LA    R15,OPNDS-1             SET OPND POS
         B     BCXOPND                 FINISH FORMAT
BCOXIT   L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
EXTARITH CH    R11,H8                  COND CODE = 8
         BE    ARBZ                    YES
         BL    ARLOW                   NO, LOWER
         CH    R11,H14                 COND CODE = 14
         BE    ARBNO                   YES
         CH    R11,H13                 COND CODE = 13
         BE    ARBNP                   YES
         CH    R11,H11                 COND CODE = 11
         BE    ARBNM                   YES
         B     NOEXTND                 NO, NOT EXTENDED
ARLOW    CH    R11,H7                  COND CODE = 7
         BE    ARBNZ                   YES
         CH    R11,H1                  COND CODE = 1
         BE    ARBO                    YES
         CH    R11,H2                  COND CODE = 2
         BE    ARBP                    YES
         CH    R11,H4                  COND CODE = 4
         BE    ARBM                    YES
         B     NOEXTND                 NO, NOT EXTENDED
ARBZ     MVC   MNEMONIC(2),=C'BZ'      SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
ARBNO    MVC   MNEMONIC(3),=C'BNO'     SET EXTENDED MNEMONIC
         B     BCXTFIN                 CONTINUE
ARBNP    MVC   MNEMONIC(3),=C'BNP'     SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
ARBNM    MVC   MNEMONIC(3),=C'BNM'     SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
ARBNZ    MVC   MNEMONIC(3),=C'BNZ'     SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
ARBO     MVC   MNEMONIC(2),=C'BO'      SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
ARBP     MVC   MNEMONIC(2),=C'BP'      SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
ARBM     MVC   MNEMONIC(2),=C'BM'      SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
EXTZRO   CH    R11,H8                  COND CODE = 8
         BE    ARBZ                    YES, USE BZ MNEMONIC
         CH    R11,H7                  COND CODE IS 7
         BE    ARBNZ                   YES
         B     NOEXTND                 NO, NOT EXTENDED
EXTCPR   CH    R11,H8                  COND CODE = 8
         BE    CPBE                    YES
         CH    R11,H7                  COND CODE = 7
         BE    CPBNE                   YES
         BL    CPLOW                   NO, LOWER
         CH    R11,H13                 COND CODE = 13
         BE    CPBNH                   YES
         CH    R11,H11                 COND CODE = 11
         BE    CPBNL                   YES
         B     NOEXTND                 NO, NOT EXTENDED
CPLOW    CH    R11,H4                  COND CODE = 4
         BE    CPBL                    YES
         CH    R11,H2                  COND CODE = 2
         BE    CPBH                    YES
         B     NOEXTND                 NO, NOT EXTENDED
CPBE     MVC   MNEMONIC(2),=C'BE'      SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
CPBNE    MVC   MNEMONIC(3),=C'BNE'     SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
CPBNH    MVC   MNEMONIC(3),=C'BNH'     SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
CPBNL    MVC   MNEMONIC(3),=C'BNL'     SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
CPBL     MVC   MNEMONIC(2),=C'BL'      SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
CPBH     MVC   MNEMONIC(2),=C'BH'      SET EXTENDED MNEMONIC
         B     BCXTFIN                 CONTINUE
*
*
*
******************************************************************
*                                                                *
* VALIDATE AND FORMAT SVC INSTRUCTIONS. IF THE SVC OP-CODE IS    *
* FOUND IN THE SVC TABLE, IT IS ACCEPTED AS AN SVC, AND THE TABLE*
* LITERAL IS MOVED TO THE COMMENTS FIELD OF THE INSTRUCTION.     *
*                                                                *
******************************************************************
*
SVCOPND  EQU   *                       *** SVC INSTRUCTIONS ***
         CLI   TEXT+1,126              VALID OPERAND
         BH    NOTSVC                  NO, NOT SVC
         L     R1,SVCTBLAD             GET SVC TABLE ADDRESS
SVCKND   CLI   0(R1),X'FF'             END OF SVC TABLE
         BE    NOTSVC                  YES, MUST NOT BE SVC
         CLC   0(1,R1),TEXT+1          THIS THE ENTRY
         BE    GOTSVC                  YES
         LA    R1,L'SVCOP(R1)          STEP TO NEXT ENTRY
         B     SVCKND                  LOOP THRU TABLE
NOTSVC   B     4(R9)                   ERROR RETURN
GOTSVC   MVC   COMMENT(14),1(R1)       COMMENT TO WORK AREA
         SR    R1,R1                   CLEAR WORK
         IC    R1,TEXT+1               GET SVC OPERAND
         CVD   R1,DBLWD                CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(3),DBLWD+6(2)     UNPACK
         CH    R1,H100                 OPERAND > 100
         BL    SVCK10                  YES
         MVC   OPNDS(3),DBLWD          MOVE 3-DIGIT OPERAND
         B     SVCXIT                  EXIT
SVCK10   CH    R1,H10                  OPERAND < 10
         BL    SVCL10                  YES
         MVC   OPNDS(2),DBLWD+1        MOVE 2-DIGIT OPERAND
         B     SVCXIT                  EXIT
SVCL10   MVC   OPNDS(1),DBLWD+2        MOVE 1-DIGIT OPERAND
SVCXIT   BR    R9                      EXIT
*
*
*
******************************************************************
* BUILD EQU STATEMENTS USING THE LABEL TABLE ENTRY ADDRESSED BY  *
* REG 6 ON ENTRY.                                                *
*                                                                *
******************************************************************
*                                                                *
EQUSTMT  EQU   *                       BUILD EQU STATEMENTS
         ST    R9,EQU9                 SAVE RETURN ADDR
         USING LABELD,R6
         MVC     NAME,LBLNAME          NAME TO EQU STMT
         MVC   MNEMONIC,=CL5'EQU'      BUILD EQU STATEMENT
         MVI   OPNDS,C'*'              SET EQU OPERAND
         CLI   LBLLEN,1                LENGTH 0 OR 1
         BNH   CCXEQU                  YES
         SR    R9,R9                   CLEAR WORK
         IC    R9,LBLLEN               GET LENGTH
         CVD   R9,DBLWD                CONVERT
         UNPK  DBLWD(3),DBLWD+6(2)     UNPACK
         OI    DBLWD+2,C'0'            CLEAR SIGN
         CH    R9,H100                 LENGTH < 100
         BL    CCXQ10                  YES
         MVC   OPNDS+2(3),DBLWD        MOVE LENGTH
         B     CCXEQC                  GO SET COMMA
CCXQ10   CH    R9,H10                  LENGTH < 10
         BL    CCXQ1                   YES
         MVC   OPNDS+2(2),DBLWD+1      MOVE 2-DIGIT LENGTH
         B     CCXEQC                  GO SET COMMA
CCXQ1    MVC   OPNDS+2(1),DBLWD+2      MOVE 1-DIGIT LENGTH
CCXEQC   MVI   OPNDS+1,C','            SET COMMA
CCXEQU   BAL   R9,WRTOUT               OUTPUT EQU STATEMENT
         BAL   R9,PRINT                GO PRINT IT
         L     R9,EQU9                 GET RETURN ADDR
         BR    R9                      RETURN
         DROP  R6
*
*
*
******************************************************************
*                                                                *
* BUILDS STORAGE OPERANDS CONTAINING BASE, DISPLACEMENT, AND     *
* LENGTH. ON ENTRY, REG 11 CONTAINS THE BDDD ADDRESS, AND REG 10 *
* CONTAINS THE LENGTH. THE SCHLBL ROUTINE IS CALLED TO CREATE A  *
* LABEL REFERENCE, IF THE BASE REG IS CURRENT, AND A LABEL EXISTS*
* IF SCHLBL IS UNSUCCESSFUL, AN EXPLICIT ADDRESS OF THE FORM     *
* DDDD(LLL,RRR) IS CREATED.                                      *
*                                                                *
******************************************************************
*
BDLADR   EQU   *                       *** FORMAT DDDD(LLL,RRR) OPERAND
         ST    R9,BDL9                 SAVE RETURN ADDR
         SR    R0,R0                   CLEAR WORK REG
         LR    R1,R11                  COPY BDDD ADDRESS
         SLDL  R0,20                   BASE REG TO R0
         LTR   R0,R0                   IS BASE REG 0
         BNZ   BDLSCHL                 NO
         SRL   R1,20                   RIGHT JUSTIFY DISPL
         CH    R1,H16                  REFERENCE TO CVT ADDR
         BE    BDLCVTR                 YES
         CH    R1,H76                  REF TO ALTERNATE CVT ADDR
         BE    BDLCVTR                 YES
         MVC   COMMENT(13),=C'PSA REFERENCE'
         B     BDLSCHL                 CONTINUE
BDLCVTR  MVC   COMMENT(11),=C'CVT ADDRESS'
BDLSCHL  BAL   R9,SCHLBL               SEARCH FOR LABEL
         B     BDLGLBL                 BRANCH IF LABEL FOUND
         LR    R1,R11                  COPY BDDD ADDRESS
         SLL   R1,20                   SHIFT OUT B
         SRL   R1,20                   RIGHT JUSTIFY DDD
         CVD   R1,DBLWD                CONVERT DDD
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(4),DBLWD+5(3)     UNPACK
         MVC   OPNDWK,BLANX            CLEAR WORK AREA
         CH    R1,H1000                DISPL < 1000
         BL    BDLD100                 YES
         MVC   OPNDWK(4),DBLWD         MOVE 4-DIGIT DISPL
         LA    R1,OPNDWK+4             TO NEXT POS
         B     BDLLPN                  CONTINUE
BDLD100  CH    R1,H100                 DISPL < 100
         BL    BDLD10                  YES
         MVC   OPNDWK(3),DBLWD+1       MOVE 3-DIGIT DISPL
         LA    R1,OPNDWK+3             TO NEXT POS
         B     BDLLPN                  CONTINUE
BDLD10   CH    R1,H10                  DISPL < 10
         BL    BDLD1                   YES
         MVC   OPNDWK(2),DBLWD+2       MOVE 2-DIGIT DISPL
         LA    R1,OPNDWK+2             TO NEXT POS
         B     BDLLPN                  CONTINUE
BDLD1    MVC   OPNDWK(1),DBLWD+3       MOVE 1-DIGIT DISPL
         LA    R1,OPNDWK+1             TO NEXT POS
BDLLPN   MVI   0(R1),C'('              LEFT PAREN DELIMITER
         LA    R10,1(R10)              COMPUTE ACTUAL LENGTH FROM LENG
         CVD   R10,DBLWD               CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(3),DBLWD+6(2)     UNPACK
         CH    R10,H100                LENGTH < 100
         BL    BDLL10                  YES
         MVC   1(3,R1),DBLWD           MOVE 3-DIGIT LENGTH
         LA    R1,4(R1)                TO NEXT POS
         B     BDLCMA                  CONTINUE
BDLL10   CH    R10,H10                 LENGTH < 10
         BL    BDLL1                   YES
         MVC   1(2,R1),DBLWD+1         MOVE 2-DIGIT LENGTH
         LA    R1,3(R1)                TO NEXT POS
         B     BDLCMA                  CONTINUE
BDLL1    MVC   1(1,R1),DBLWD+2         MOVE 1-DIGIT LENGTH
         LA    R1,2(R1)                TO NEXT POS
BDLCMA   MVC   0(2,R1),=C',R'          DELIMITERS
         SRL   R11,12                  RT JUSTIFY BASE REG
         CVD   R11,DBLWD               CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CH    R11,H10                 REG < 10
         BL    BDLR1                   YES
         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT REGISTER
         LA    R1,4(R1)                TO NEXT POS
         B     BDLRPN                  CONTINUE
BDLR1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT REG
         CLI   2(R1),C'0'              IS REG = 0
         BNE   BDLB1                   NO
         MVC   0(2,R1),BLANX           YES, BLANK IT
***      BCTR  R1,R0                   BACK UP 1            FIX***
         B     BDLRPN                  CONTINUE
BDLB1    LA    R1,3(R1)                TO NEXT POS
BDLRPN   MVI   0(R1),C')'              FINAL DELIMITER
         LR    R10,R1                  COPY END ADDRESS
         S     R10,OWSTRT              COMPUTE OPERAND LENGTH CODE
         L     R9,BDL9                 GET RETURN ADDR
         BR    R9                      EXIT
         USING LABELD,R12
BDLGLBL  MVC   OPNDWK(8),LBLNAME       LABEL ENTRY NAME TO WORK
         LA    R10,1(R10)              COMPUTE ACTUAL LENGTH
         LA    R1,OPNDWK+7             @ LAST POSS CHARACTER
BDLGRHE  CLI   0(R1),C' '              AT RHE
         BNE   BDLGCKLN                YES
         BCT   R1,BDLGRHE              LOOP TO RHE
BDLGCKLN CLM   R10,1,LBLLEN            LBL AND INSTR LENGTHS SAME
         BE    BDLGCMP                 YES
         MVI   1(R1),C'('              NO, DELIMITER
         CVD   R10,DBLWD               CONVERT LENGTH
         UNPK  DBLWD(3),DBLWD+5(3)     UNPACK
         OI    DBLWD+2,C'0'            CLEAR SIGN
         CH    R10,H100                LENGTH < 100
         BL    BDLG10                  YES
         MVC   2(3,R1),DBLWD           MOVE 3-DIGIT LENGTH
         LA    R1,5(R1)                TO NEXT POS
         B     BDLGRPN                 CONTINUE
BDLG10   CH    R10,H10                 LENGTH < 10
         BL    BDLG1                   YES
         MVC   2(2,R1),DBLWD+1         MOVE 2-DIGIT LENGTH
         LA    R1,4(R1)                TO NEXT POS
         B     BDLGRPN                 CONTINUE
BDLG1    MVC   2(1,R1),DBLWD+2         MOVE 1-DIGIT LENGTH
         LA    R1,3(R1)                TO NEXT POS
BDLGRPN  MVI   0(R1),C')'              FINAL DELIMITER
BDLGCMP  LR    R10,R1                  COPY END ADDRESS
         S     R10,OWSTRT              COMPUTE LENGTH CODE
         L     R12,SLSAV+12            RESTORE R12
         L     R9,BDL9                 GET RETURN ADDR
         BR    R9                      EXIT
         DROP  R12
*
*
*
******************************************************************
*                                                                *
* BUILDS STORAGE OPERANDS CONTAINING BASE AND DISPLACEMENT.      *
* THE SCHLBL ROUTINE IS CALLED TO SEE WHETHER A LABEL REFERENCE  *
* MAY BE USED, RATHER THAN AN EXPLICIT ADDRESS. IF LBLSCH IS NOT *
* SUCCESSFUL, AN EXPLICIT ADDRESS OF THE FORM DDDD(RRR) IS FORMED*
* ON ENTRY, REG 11 CONTAINS THE BDDD ADDRESS.                    *
*                                                                *
******************************************************************
*
BDADR    EQU   *                       *** FORMAT DDDD(RRR) OPERANDS **
         ST    R9,BD9                  SAVE RETURN ADDR
         SR    R0,R0                   CLEAR WORK REG
         LR    R1,R11                  COPY BDDD ADDRESS
         SLDL  R0,20                   BASE REG TO R0
         LTR   R0,R0                   IS BASE REG 0
         BNZ   BDSCHL                  NO
         CLI   TEXT,X'8F'              IS IT SLDA??              FIX***
         BH    BDSADR1                 YES                       FIX***
         CLI   TEXT,X'88'              IS IT SRL                 FIX***
         BNL   BDSCHL                  YES                       FIX***
BDSADR1  SRL   R1,20                   RIGHT JUSTIFY DISPL       FIX***
         CH    R1,H16                  REFERENCE TO CVT ADDR
         BE    BDCVTR                  YES
         CH    R1,H76                  REF TO ALTERNATE CVT ADDR
         BE    BDCVTR                  YES
         MVC   COMMENT(13),=C'PSA REFERENCE'
         B     BDSCHL                  CONTINUE
BDCVTR   MVC   COMMENT(11),=C'CVT ADDRESS'
BDSCHL   BAL   R9,SCHLBL               GO SEARCH FOR LABEL
         B     BDGLBL                  BRANCH IF FOUND
         LR    R1,R11                  COPY BDDD ADDRESS
         SLL   R1,20                   SHIFT OUT B
         SRL   R1,20                   RIGHT JUSTIFY DDD
         CVD   R1,DBLWD                CONVERT DISPL
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(4),DBLWD+5(3)     UNPACK
         CH    R1,H1000                DISPL < 1000
         BL    BDAD100                 YES
         MVC   OPNDWK(4),DBLWD         MOVE 4-DIGIT DISPL
         LA    R1,OPNDWK+4             TO NEXT POS
         B     BDALPN                  CONTINUE
BDAD100  CH    R1,H100                 DISPL < 100
         BL    BDAD10                  YES
         MVC   OPNDWK(3),DBLWD+1       MOVE 3-DIGIT DISPL
         LA    R1,OPNDWK+3             TO NEXT POS
         B     BDALPN                  CONTINUE
BDAD10   CH    R1,H10                  DISPL < 10
         BL    BDAD1                   YES
         MVC   OPNDWK(2),DBLWD+2       MOVE 2-DIGIT DISPL
         LA    R1,OPNDWK+2             TO NEXT POS
         B     BDALPN                  CONTINUE
BDAD1    MVC   OPNDWK(1),DBLWD+3       MOVE 1-DIGIT DISPL
         LA    R1,OPNDWK+1             TO NEXT POS
BDALPN   MVC   0(2,R1),=C'(R'          DELIMITERS
         SRL   R11,12                  RT JUSTIFY BASE REG
         CVD   R11,DBLWD               CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CH    R11,H10                 BASE REG < 10
         BL    BDAR1                   YES
         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT BASE REG
         LA    R1,4(R1)                TO NEXT POS
         B     BDARPN                  CONTINUE
BDAR1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT BASE REG
         LA    R1,3(R1)                TO NEXT POS
BDARPN   MVI   0(R1),C')'              FINAL DELIMITER
         LR    R2,R1                   COPY END ADDRESS
         SH    R2,H4                   BACK UP 4
         CLC   1(4,R2),=C'(R0)'        BASE REG IS ZERO
         BNE   BDCE                    NO
         MVC   1(4,R2),BLANX           CLEAR BASE REG
         LR    R1,R2                   COPY NEW END ADDR
BDCE     LR    R10,R1                  COPY END ADDR
         S     R10,OWSTRT              COMPUTE LENGTH CODE
         L     R9,BD9                  GET RETURN ADDR
         BR    R9                      EXIT
         USING LABELD,R12
BDGLBL   MVC   OPNDWK(8),LBLNAME       LABEL ENTRY NAME TO WORK
         LA    R1,OPNDWK+7             @ LAST POSS CHARACTER
BDGRHE   CLI   0(R1),C' '              AT RHE
         BNE   BDGCMP                  YES
         BCT   R1,BDGRHE               LOOP TO RHE
BDGCMP   LR    R10,R1                  COPY END ADDRESS
         S     R10,OWSTRT              COMPUTE LENGTH CODE
         L     R12,SLSAV+12            RESTORE R12
         L     R9,BD9                  GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* BUILDS STORAGE OPERANDS CONTAINING BASE, DISPLACEMENT, AND     *
* INDEX. ON ENTRY, REG 11 CONTAINS THE BDDD ADDRESS, AND REG 10  *
* CONTAINS THE INDEX. THE SCHLBL ROUTINE IS CALLED TO CREATE A   *
* LABEL REFERENCE, IF THE BASE REG IS CURRENT, AND A LABEL EXISTS*
* IF SCHLBL IS UNSUCCESSFUL, AN EXPLICIT ADDRESS OF THE FORM     *
* DDDD(XXX,RRR) IS CREATED.                                      *
*                                                                *
******************************************************************
*
BDXADR   EQU   *                       *** FORMAT DDDD(XXX,BBB) OPERAND
         ST    R9,BDX9                 SAVE RETURN ADDR
         LTR   R10,R10                 ANY INDEX REG
         BNZ   BDXSCHL                 YES
         SR    R0,R0                   CLEAR WORK REG
         LR    R1,R11                  COPY BDDD ADDRESS
         SLDL  R0,20                   BASE REG TO R0
         LTR   R0,R0                   IS BASE REG 0
         BNZ   BDXSCHL                 NO
         CLI   TEXT,X'41'              IS IT LA
         BE    BDXSCHL                 YES
         SRL   R1,20                   RIGHT JUSTIFY DISPL
         CH    R1,H16                  REFERENCE TO CVT ADDR
         BE    BDXCVTR                 YES
         CH    R1,H76                  REF TO ALTERNATE CVT ADDR
         BE    BDXCVTR                 YES
         MVC   COMMENT(13),=C'PSA REFERENCE'
         B     BDXSCHL                 CONTINUE
BDXCVTR  MVC   COMMENT(11),=C'CVT ADDRESS'
BDXSCHL  BAL   R9,SCHLBL               GO SEARCH FOR LABEL
         B     BDXGLBL                 BRANCH IF FOUND
         LR    R1,R11                  COPY BDDD ADDRESS
         SLL   R1,20                   SHIFT OUT BASE REG
         SRL   R1,20                   RIGHT JUSTIFY DISPL
         SRL   R11,12                  RT JUSTIFY BASE REG
         CVD   R1,DBLWD                CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(4),DBLWD+5(3)     UNPACK
         CH    R1,H1000                DISPL < 1000
         BL    BDXD100                 YES
         MVC   OPNDWK(4),DBLWD         MOVE 4-DIGIT DISPL
         LA    R1,OPNDWK+4             TO NEXT POS
         B     BDXLPN                  CONTINUE
BDXD100  CH    R1,H100                 DISPL < 100
         BL    BDXD10                  YES
         MVC   OPNDWK(3),DBLWD+1       MOVE 3-DIGIT DISPL
         LA    R1,OPNDWK+3             TO NEXT POS
         B     BDXLPN                  CONTINUE
BDXD10   CH    R1,H10                  DISPL < 10
         BL    BDXD1                   YES
         MVC   OPNDWK(2),DBLWD+2       MOVE 2-DIGIT DISPL
         LA    R1,OPNDWK+2             TO NEXT POS
         B     BDXLPN                  CONTINUE
BDXD1    MVC   OPNDWK(1),DBLWD+3       MOVE 1-DIGIT DISPL
         LA    R1,OPNDWK+1             TO NEXT POS
BDXLPN   LTR   R10,R10                 ANY INDEX REG
         BNZ   BDXLPNR                 YES
         LTR   R11,R11                 ANY BASE REG
         BNZ   PREPB                   YES
         BCTR  R1,R0                   NO, BACK UP TO RHE
         B     BDXCE                   CONTINUE
PREPB    MVC   0(3,R1),=C'(,R'         DELIMITERS
         LA    R1,1(R1)                STEP OVER 1 BYTE
         B     BDXCBAS                 CONTINUE
BDXLPNR  MVC   0(2,R1),=C'(R'          DELIMITERS
         CVD   R10,DBLWD               CONVERT INDEX REG
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CH    R10,H10                 INDEX REG < 10
         BL    BDXX1                   YES
         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT INDEX REG
         LA    R1,4(R1)                TO NEXT POS
         B     BDXCMA                  CONTINUE
BDXX1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT INDEX REG
         LA    R1,3(R1)                TO NEXT POS
BDXCMA   LTR   R11,R11                 ANY BASE REG
         BZ    BDXRPN                  NO
         MVC   0(2,R1),=C',R'          DELIMITERS
BDXCBAS  CVD   R11,DBLWD               CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CH    R11,H10                 BASE REG < 10
         BL    BDXB1                   YES
         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT BASE REG
         LA    R1,4(R1)                TO NEXT POS
         B     BDXRPN                  CONTINUE
BDXB1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT BASE REG
         LA    R1,3(R1)                TO NEXT POS
BDXRPN   MVI   0(R1),C')'              FINAL DELIMITER
BDXCE    LR    R10,R1                  COPY END ADDR
         S     R10,OWSTRT              COMPUTE LENGTH CODE
         L     R9,BDX9                 GET RETURN ADDR
         BR    R9                      EXIT
         USING LABELD,R12
BDXGLBL  MVC   OPNDWK(8),LBLNAME       LABEL ENTRY NAME TO WORK
         LA    R1,OPNDWK+7             @ LAST POSS CHARACTER
BDXGRHE  CLI   0(R1),C' '              AT RHE
         BNE   BDXGCKLN                YES
         BCT   R1,BDXGRHE              LOOP TO RHE
BDXGCKLN LTR   R10,R10                 ANY INDEX REGISTER
         BZ    BDXGCMP                 NO
         MVI   1(R1),C'('              YES, DELIMITER
         CVD   R10,DBLWD               CONVERT LENGTH
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         OI    DBLWD+1,C'0'            CLEAR SIGN
BDXG10   CH    R10,H10                 LENGTH < 10
         BL    BDXG1                   YES
         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT LENGTH
         LA    R1,4(R1)                TO NEXT POS
         B     BDXGRPN                 CONTINUE
BDXG1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT LENGTH
         LA    R1,3(R1)                TO NEXT POS
BDXGRPN  MVI   0(R1),C')'              FINAL DELIMITER
BDXGCMP  LR    R10,R1                  COPY END ADDRESS
         S     R10,OWSTRT              COMPUTE LENGTH CODE
         L     R12,SLSAV+12            RESTORE R12
         L     R9,BDX9                 GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
WRTOUT   EQU   *                       WRITE OUTPUT RECORDS
         L     R1,PUNCHDCB             @ SYSPUNCH DCB
         MVC   PRT(80),WORKREC         SAVE IN PRINT
         TM    48(R1),X'10'            IS FILE OPEN
         BZ    CLRWKR                  NO
         AP    CARDNO,=P'10'           INCREMENT CARD NO
         UNPK  SEQNBR,CARDNO           UNPACK INTO CARD
         OI    SEQNBR+7,C'0'           CLEAR SIGN
         PUT   (1),WORKREC             WRITE SOURCE CARD
CLRWKR   MVC   WORKREC,BLANX           CLEAR OUTPUT RECORD
         BR    R9                      RETURN
*
*
*
******************************************************************
*                                                                *
* SEARCHES THE BASE REGISTER TABLE TO FIND THE BASE REGISTER     *
* ASSOCIATED WITH THE BDDD OPERAND ADDRESS PASSED IN REG 11 ON   *
* ENTRY. IF THE BASE REGISTER GIVEN IS NOT A CURRENT BASE REG    *
* THE UNSUCCESSFUL RETURN IS MADE TO 4 BYTES PAST THE ADDRESS    *
* IN REG 9 ON ENTRY. WHEN THE CURRENT BASE REGISTER ENTRY IS FOR *
* A PROGRAM BASE REG, THE DISPLACEMENT IS ADDED TO THE ASSUMED   *
* BASE REGISTER VALUE IS ADDED TO THE DISPLACEMENT TO GIVE AN    *
* OFFSET IN THE PROGRAM. THE LABEL TABLE IS SEARCHED FOR AN ENTRY*
* WITH THIS OFFSET, AND IF FOUND, IS RETURNED TO THE CALLER. WHEN*
* THE BASE REGISTER FOUND IS FOR A DSECT, THE DSECT HEADER ENTRY *
* ADDRESS IS GIVEN IN THE BASE TABLE ENTRY. THE DSECT HEADER HAS *
* THE ADDRESS OF THE FIELD DEFINITION TABLE FOR THE DSECT. THE   *
* FIELD DEFINITION TABLE IS SEARCHED FOR AN ENTRY HAVING THE     *
* DISPLACEMENT IN THE BDDD INSTRUCTION, AND IF FOUND IS PASSED   *
* BACK TO THE CALLER. IF THE LABEL/FIELD TABLE SEARCHES ARE      *
* UNSUCCESSFUL, RETURN IS TO 4 BYTES PAST REG 9.                 *
*                                                                *
******************************************************************
*
SCHLBL   EQU   *                       *** SEARCH FOR LABEL AT BDDD ADD
         TM    MORUSG,X'80'            ANY BASES ACTIVE
         BZ    4(R9)                   NO, UNSUCCESSFUL EXIT
         STM   R9,R12,SLSAV            YES, SAVE REGS USED
         LR    R12,R11                 COPY BDDD ADDRESS
         SRL   R12,12                  CLEAR WORK REG
         LTR   R12,R12                 IS BASE REG ZERO
         BZ    SCHNF                   YES, NO LABEL
         MH    R12,USGLEN              BASE X BASE TBL ENTRY LENG
         LA    R12,BASES(R12)          @ BASE TBL ENTRY
         USING USINGD,R12
         CLI   USTYPE,0                ENTRY IN USE
         BE    SCHNF                   NO, EXIT
         LR    R9,R11                  COPY BDDD ADDRESS
         SLL   R9,20                   SHIFT OUT BASE
         SRL   R9,20                   RIGHT JUSTIFY DDD
         ICM   R11,7,USVALU            GET BASE REG VALUE
         LA    R11,0(R11)              CLEAR HI-ORDER
         CLI   USTYPE,C'P'             PROGRAM BASE REG
         BE    PGMBASE                 YES
         DROP  R12
         LR    R12,R11                 COPY DSECT FIELD TBL ADDRESS
         USING DSECTD,R12
CKDSCTND CLM   R9,7,DSOFSET            THIS THE ENTRY
         BE    SCHFD                   YES
         CLC   DSOFSET,HIVAL           NO, AT TABLE END
         BE    SCHNF                   YES, NO LABEL FOUND
         LA    R12,L'DSECT(R12)        STEP TO NEXT ENTRY
         B     CKDSCTND                LOOP THRU DSECT FIELDS
PGMBASE  AR    R9,R11                  COMPUTE OFFSET
         DROP  R12
         L     R12,LBLTBL              @ LABEL TABLE
         USING LABELD,R12
CKENTFD  CLM   R9,7,LBLADR             THIS THE ENTRY
         BE    SCHFD                   YES
         LA    R12,L'LABEL(R12)        TO NEXT ENTRY
         C     R12,CURRLBL             END OF TBL
         BNL   SCHNF                   YES, NO LABEL
         B     CKENTFD                 NO, CONTINUE SEARCH
SCHNF    LM    R9,R12,SLSAV            NOT FOUND, RESTORE REGS
         B     4(R9)                   NOT FOUND RETURN
SCHFD    LM    R9,R11,SLSAV            FOUND RESTORE ALL BUT 12
         BR    R9                      FOUND RETURN
         DROP  R12
*
*
*
******************************************************************
*                                                                *
* PRINT A LINE USING THE SYSPRINT DCB DEFINED IN DISASM PHASE 0. *
*                                                                *
******************************************************************
*
PRINT    EQU   *                       PRINT ROUTINE
         L     R1,PRINTDCB             @ SYSPRINT DCB
         TM    48(R1),X'10'            IS SYSPRINT OPEN
         BNO   CLRPRT                  NO
         PUT   (1),PRTLINE             WRITE PRINT LINE
CLRPRT   MVC   PRT,BLANX               CLEAR PRINT LINE
         AP    LINECT,P1               INCR LINE COUNTER
         CLI   PCC,C' '                SINGLE SPACED
         BE    SETSGL                  YES
         AP    LINECT,P1               INCR LINE COUNTER
         CLI   PCC,C'0'                DOUBLE SPACED
         BE    SETSGL                  YES
         AP    LINECT,P1               INCR LINE COUNTER
         CLI   PCC,C'-'                TRIPLE SPACED
         BE    SETSGL                  YES
         ZAP   LINECT,P0               NO, MUST BE NEW PAGE
SETSGL   MVI   PCC,C' '                SET SINGLE SPACING
         CP    LINECT,P58              PAST END OF PAGE
         BH    NEWPAGE                 YES
         BR    R9                      EXIT
NEWPAGE  MVI   PCC,C'1'                SET SKIP TO HOF
         ZAP   LINECT,P0               RESET LINE COUNTER
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* CONVERT HEX DATA TO PRINTABLE FORM: 2 CHARACTERS PER BYTE. ON  *
* ENTRY, REG 12 CONTAINS THE ADDRESS OF THE LEFT END OF THE FIELD*
* TO BE CONVERTED, AND THE ENTRY POINT USED DETERMINES THE LENGTH*
* FORMATTED OUTPUT IS PLACED IN THE PRTABL FIELD.                *
*                                                                *
******************************************************************
*
HEXPRT   EQU   *                       HEX TO PRINTABLE ROUTINE
HEXPRT1  UNPK  PRTABL(3),0(2,R12)      UNPACK HEX
         B     HEXCLTR                 CONTINUE
HEXPRT2  UNPK  PRTABL(5),0(3,R12)      UNPACK HEX
         B     HEXCLTR                 CONTINUE
HEXPRT3  UNPK  PRTABL(7),0(4,R12)      UNPACK HEX
         B     HEXCLTR                 CONTINUE
HEXPRT4  UNPK  PRTABL(9),0(5,R12)      UNPACK HEX
HEXCLTR  MVZ   PRTABL(8),XZROS         CLEAR FOR TRANSLATE
         TR    PRTABL(8),TRTBL         MAKE PRINTABLE
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* FORMATS THE HEX DATA CORRESPONDING TO THE FORMATTED INSTRUCTION*
* BEING OUTPUT. PRINTABLE HEX IS PLACED AT THE RIGHT OF THE LINE *
* ON THE SYSPRINT OUTPUT.                                        *
*                                                                *
******************************************************************
*
TXTFMT   EQU   *                       *** FORMAT TEXT FOR PRINT ***
         ST    R9,TX9                  SAVE RETURN ADDR
         LA    R11,PRT                 @ PRINT LINE
         CLI   TYPE,1                  ADCON
         BE    TFOFST                  YES
         CLI   TYPE,2                  CONSTANT
         BE    TFOFST                  YES
         CLI   TYPE,X'0D'              INSTRUCTION
         BNE   TXTCLEAN                NO
TFOFST   LA    R12,OFFSET              @ OFFSET TO INSTR
         BAL   R9,HEXPRT3              CONVERT TO PRINTABLE
         MVC   PRT+80(6),PRTABL        OFFSET TO PRINT
         LA    R12,LEN                 @ DATA LENGTH
         BAL   R9,HEXPRT1              MAKE PRINTABLE
         MVC   PRT+88(2),PRTABL        LENGTH TO PRINT
         LA    R12,TEXT                @ TEXT TO PRINT
         BAL   R9,HEXPRT4              CONVERT 1ST 4 BYTES
         CLI   LEN,4                   IS IT 4 BYTES
         BNL   TXT4                    YES, OR MORE
         CLI   LEN,3                   IS IT 3 BYTES
         BE    TXT3                    YES
         CLI   LEN,2                   IS IT 2 BYTES
         BE    TXT2                    YES
         MVC   PRT+94(2),PRTABL        TEXT TO PRINT
         B     TXTCLEAN                FINISH
TXT2     MVC   PRT+94(4),PRTABL        TEXT TO PRINT
         B     TXTCLEAN                FINISH
TXT3     MVC   PRT+94(6),PRTABL        TEXT TO PRINT
         B     TXTCLEAN                FINISH
TXT4     MVC   PRT+94(8),PRTABL        TEXT TO PRINT
         CLI   LEN,4                   IS IT 4 BYTES
         BE    TXTCLEAN                YES, FINISH
         LA    R12,TEXT+4              @ TEXT
         BAL   R9,HEXPRT4              CONVERT
         CLI   LEN,8                   8 BYTES OF TEXT
         BE    TXT8                    YES
         CLI   LEN,7                   7 BYTES OF TEXT
         BE    TXT7                    YES
         CLI   LEN,6                   6 BYTES OF TEXT
         BE    TXT6                    YES
         MVC   PRT+98(2),PRTABL        TEXT TO PRINT
         B     TXTCLEAN                FINISH
TXT6     MVC   PRT+102(4),PRTABL       TEXT TO PRINT
         B     TXTCLEAN                FINISH
TXT7     MVC   PRT+102(6),PRTABL       TEXT TO PRINT
         B     TXTCLEAN                FINISH
TXT8     MVC   PRT+102(8),PRTABL       TEXT TO PRINT
TXTCLEAN XC    OFFSET,OFFSET           CLEAR
         L     R9,TX9                  GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* ENTERED WHENEVER THE CURRENT TEXT OFFSET IS PAST THE NEXCHG    *
* FIELD VALUE. THIS ROUTINE CREATES DROP CARDS FOR EXHAUSTED BASE*
* REGISTERS, AND USING STATEMENTS FOR NEW BASE REGISTERS. THE    *
* BASES TABLE IS SCANNED, AND ANY ENTRY WHICH IS NO LONGER IN USE*
* IS ZEROED OUT, AND A DROP RECORD IS CREATED. NEXT, THE USING   *
* TABLE IS SCANNED. WHEN AN ENTRY IS FOUND WHICH IS VALID AT THE *
* CURRENT OFFSET, THE BASE TABLE IS CHECKED. IF THE ENTRY IS NOT *
* IN USE, A USING STATEMENT IN CREATED, AND THE USING TABLE ENTRY*
* IS MOVED TO THE BASES TABLE. THE NEXCHG FIELD IS CHANGED TO    *
* CONTAIN THE OFFSET AT WHICH THE NEXT SCAN MUST BE MADE. AN IND-*
* ICATOR CALLED MORUSG IS SET TO SHOW WHEN ANY BASE REGISTERS ARE*
* CURRENTLY IN USE. WHEN NO MORE REGISTERS ARE AVAILABLE, THE    *
* NEXCHG FIELD IS SET TO HEX FF'S.                               *
*                                                                *
******************************************************************
*
NEXUSG   EQU   *                       *** GET NEXT BASE REG SET ***
         MVC   NEXCHG,HIVAL            RESET NEXT CHANGE ADDR
         MVI   MORUSG,0                CLEAR BASE REG AVAIL INDIC
         ST    R9,USG9                 SAVE RETURN ADDR
         XC    BASES(L'USING),BASES    CLEAR R0 ELEMENT
         MVC   BASES+16*L'USING(4),HIVAL SET TABLE STOPPER
         USING USINGD,R2
         LA    R2,BASES+L'USING        @ R1'S ELEMENT
DRPCKND  CLI   0(R2),X'FF'             END OF TABLE
         BE    USGUSG                  YES
         CLC   USEND,XZROS             ENTRY USED
         BE    DRPSTEP                 NO
         CLC   TXTOFSET,USEND          PAST END OF THIS ONE
         BL    DRPSTEP                 NO
         MVC   MNEMONIC(4),=C'DROP'    OPERATION IS DROP
         MVI   OPNDS,C'R'              DELIMITER FOR REGS
         SR    R12,R12                 CLEAR WORK
         IC    R12,USREG               GET REG
         CVD   R12,DBLWD               CONVERT TO PACKED
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         OI    DBLWD+1,C'0'            CLEAR SIGN
         CH    R12,H10                 REG < 10
         BL    DPR1                    YES
         MVC   OPNDS+1(2),DBLWD        MOVE REG NBR
         B     WRTDROP                 GO WRITE DROP
DPR1     MVC   OPNDS+1(1),DBLWD+1      MOVE 1-DIGIT REG
WRTDROP  BAL   R9,WRTOUT               WRITE DROP RECORD
         BAL   R9,PRINT                PRINT DROP RECORD
         XC    USING,USING             CLEAR THE ENTRY
DRPSTEP  LA    R2,L'USING(R2)          TO NEXT BASE ELEMENT
         B     DRPCKND                 LOOP
USGUSG   L     R2,USGSTRT              GET FIRST USING TBL ADDR
ENDUS    CLI   0(R2),X'FF'             END OF TABLE
         BE    XITUS                   YES
         CLC   TXTOFSET,USEND          PAST END OF THIS ONE
         BNL   ECSTEP                  YES
         OI    MORUSG,1                SHOW MORE BASES AVAIL
USBGCK   CLC   TXTOFSET,USBGN          CURR LOC BEFORE THIS
         BNL   CKNEWLO                 NO
         CLC   USBGN,NEXCHG            BEGINS BEFORE NEXT CHANGE
         BNL   ECSTEP                  NO
         MVC   NEXCHG,USBGN            YES, SET LOWER CHANGE OFFSET
         B     ECSTEP                  CONTINUE
CKNEWLO  CLC   USEND,NEXCHG            THIS ENTRY ENDS EARLIER
         BNL   ECMVC                   NO
         MVC   NEXCHG,USEND            YES, SET NEW END
ECMVC    SR    R1,R1                   CLEAR WORK
         IC    R1,USREG                PICK UP REG
         MH    R1,USGLEN               TIMES ENTRY LENGTH
         LA    R1,BASES(R1)            @ BASE TABLE ENTRY
         OI    MORUSG,X'80'            SHOW BASE IN USE
         CLC   USING,0(R1)             OLD AND NEW IDENTICAL
         BE    ECSTEP                  YES
MAKUSG   MVC   0(L'USING,R1),USING     NEW USING TO TABLE
         MVC   MNEMONIC(5),=C'USING'   OPERATION IS USING
         CLI   USTYPE,C'D'             IS IT A DSECT
         BNE   CKUTPS                  NO
         ICM   R12,7,USVALU            YES, GET DSECT HEADER ADDR
         L     R11,DTBSTRT             @ 1ST DSECT HEADER ENTRY
DSCTEND  C     R11,DTBCURR             END OF TABLE
         BH    MVDSNAME                YES
         CLM   R12,7,8(11)             THIS THE HEADER ENTRY
         BNE   DSCTSTEP                NO
         LR    R12,R11                 YES, COPY IT'S ADDRESS
         B     MVDSNAME                CONTINUE
DSCTSTEP LA    R11,11(R11)             TO NEXT HEADER ENTRY
         B     DSCTEND                 LOOP THRU TABLE
MVDSNAME MVC   OPNDS(8),0(R12)         DSECT NAME TO OPERANDS
         LA    R12,OPNDS+7             TO END OF NAME
USFRHED  CLI   0(R12),C' '             FOUND RHE
         BNE   USFMADD                 YES
         BCT   R12,USFRHED             BACK UP 1 AND LOOP
USFMADD  LA    R12,1(R12)              TO NEXT BYTE
USFMCMA  MVC   0(2,R12),=C',R'         DELIMITERS
         SR    R11,R11                 CLEAR WORK
         IC    R11,USREG               GET REGISTER NBR
         CVD   R11,DBLWD               CONVERT TO PACKED
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK REG NBR
         OI    DBLWD+1,C'0'            CLEAR SIGN
         CH    R11,H10                 REG < 10
         BL    USFMR1                  YES
         MVC   2(2,R12),DBLWD          MOVE 2-DIGIT REG NBR
         B     USINGOUT                GO WRITE USING
USFMR1   MVC   2(1,R12),DBLWD+1        MOVE 1-DIGIT REG NBR
USINGOUT BAL   R9,WRTOUT               WRITE USING STMT
         BAL   R9,PRINT                PRINT USING STMT
         B     ECSTEP                  CONTINUE
CKUTPS   CLC   USVALU,TXTOFSET         USING AT CURR LOC
         BNE   USFMLBL                 NO
         MVI   OPNDS,C'*'              SET CURRENT LOC SYMBOL IN OPERAN
         LA    R12,OPNDS+1             GET NEXT POS ADDR
         B     USFMCMA                 GO FORMAT REG
USFMLBL  MVI   OPNDS,C'A'              SET 1ST CHAR OF LABEL NAME
         LA    R12,USVALU              GET OFFSET
         BAL   R9,HEXPRT3              CONVERT TO PRINTABLE
         MVC   OPNDS+1(6),PRTABL       PRINTABLE HEX TO LABEL
         LA    R12,OPNDS+7             TO NEXT LOC
         B     USFMCMA                 FORMAT REG
ECSTEP   LA    R2,L'USING(R2)          TO NEXT USING ENTRY
         B     ENDUS                   CONTINUE SCAN
XITUS    L     R9,USG9                 GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* END OF PHASE 2 - RETURN TO PHASE 0                             *
*                                                                *
******************************************************************
*
EOJ      EQU   *                       END OF JOB
         BAL   R9,FORCONST             YES, FORCE IT OUT
         L     R13,4(R13)              GET POINTER TO CALLER'S SAVE ARE
         LM    R14,R12,12(R13)         RESTORE CALLER'S REGS
         SR    R15,R15                 CLEAR RETURN CODE
         BR    R14                     RETURN TO CALLER
*
*
*
*                 *** DATA AND WORK AREAS ***
******************************************************************
*                                                                *
*
* FOLLOWING FIELDS: COMMPARM THRU COMMEND ARE COMMON AREAS SHARED
* BY THIS, AND CALLED SUB-PROGRAMS. ALL CHANGES MUST BE COORDINTAED
* WITH ALL OTHER PROGRAMS.
*
******************************************************************
*
         DS    0D
COMMPARM DSECT ,                       COMMON AREAS
DBLWD    DS    D                       DOUBLEWORD WORK AREA
PUNCHDCB DS    F                       @ SYSPUNCH DCB
PRINTDCB DS    F                       @ SYSPRINT DCB
INDCB    DS    F                       @ SYSIN DCB
CSECT    DS    CL8                     SPECIFIED CSECT NAME
ESDID    DS    XL2                     ESD ID OF SPECIFIED CSECT
ENDLBLNM DS    CL8                     SYMBOL FOR END STMT BEGIN POINTE
LINECT   DS    PL2                     PRINT LINE COUNTER
START    DS    A                       LKED ASSIGNED START ADDR OF CSEC
END      DS    A                       CSECT END ADDRESS
LENGTH   DS    F                       LENGTH OF SPECIFIED CSECT
LBLTBL   DS    F                       @ LABEL TABLE
CURRLBL  DS    F                       CURRENT LABEL ENTRY ADDR
ENDLBL   DS    F                       @ END OF LABEL TBL
LBLLGTH  DS    AL2                     LENGTH OF LABEL ENTRY
TXTSTRT  DS    F                       @ TEXT STORAGE AREA
TXTEND   DS    F                       @ END OF TEXT AREA
TXTCURR  DS    F                       @ CURRENT TEXT LOC
DTBCURR  DS    F                       @ CURRENT DSECT TABLE ENTRY
DTBEND   DS    F                       @ DSECT TABLE END
DTBSTRT  DS    F                       @ DSECT TABLE START
USGSTRT  DS    F                       @ USING TABLE START
USGCUR   DS    F                       @ CURRENT USING TABLE ENTRY
USGEND   DS    F                       @ USING TABLE END
DATONLY  DS    F                       @ DATA ONLY TABLE
DATOCUR  DS    F                       @ CURRENT DATA ONLY ENTRY
DATEND   DS    F                       @ END OF DATA ONLY TABLE
FLPTASM  DS    XL1                     FLOATING POINT INDICATOR
PRIVASM  DS    XL1                     PRIVILEGED INDICATOR
USERR    DS    XL1                     ERROR INDIC FOR DISASM1
NBRLBLS  DS    H                       NBR LABELS FROM DISASM1
*
*
*
WORKREC  DS    0CL80                   DISASSEMBLY WORK AREA
NAME     DS    CL8                     NAME
         DS    CL1
MNEMONIC DS    CL5                     INSTRUCTION MNEMONIC
         DS    CL1
OPNDS    DS    CL27                    1ST OPERAND
         DS    CL1
COMMENT  DS    CL28                    COMMENT
COL72    DS    CL1                     CONTINUATION COLUMN
SEQNBR   DS    CL8                     CARD SEQUENCE NBR
*
*
*
CARDNO   DS    PL4                     CURRENT OUTPUT CARD NBR
PRTLINE  DS    0CL121                  PRINT LINE
PCC      DS    CL1                     CARRIAGE CONTROL
PRT      DS    CL120                   PRINT DATA
*
*
*
         DS    0F
BLDLIST  DS    0CL62                   BLDL LIST
         DC    H'1'                    ONE ENTRY
         DC    H'58'                   LENGTH OF ENTRY
MEMBER   DC    CL8' '                  MEMBER NAME
TTRMOD   DC    XL3'000000'             TTR OF MODULE
CCAT     DC    XL1'00'                 CONCATENATION NUMBER
         DC    XL1'00'
ALIASIND DC    XL1'00'                 ALIAS AND MISC INDICATOR
*                           80=ALIAS
TTR1TXT  DC    XL3'000000'             TTR OF 1ST TXT RECORD
         DC    XL1'00'
TTRNS    DC    XL3'000000'             TTR OF NOTE OR SCATTER LIST
NNOTE    DC    XL1'00'                 NBR ENTRIES IN NOTE LIST
ATTR1A   DC    XL1'00'                 MODULE ATTRIBUTES 1, BYTE 1
*                           80=RENT
*                           40=REUS
*                           20=OVERLAY
*                           10=UNDER TEST
*                           08=ONLY LOADABLE
*                           04=SCATTER FORMAT
*                           02=EXECUTABLE
*                           01=ONE TXT, NO RLD RECORDS
ATTR1B   DC    XL1'00'                 ATTRIBUTES 1, BYTE 2
*                           80=CANNOT BE REPROCESSED BY LKED E
*                           40=ORIGIN OF 1ST TXT RECORD IS ZERO
*                           20=ASSIGNED ENTRY POINT ADDR IS ZERO
*                           10=CONTAINS NO RLD RECORD
*                           08=CANNOT BE REPROCESSED BY LKED
*                           04=CONTAINS TESTRAN SYMBOLS
*                           02=CREATED BY LKED
*                           01=REFR
TOTVIRT  DC    XL3'000000'             TOTAL VIRTUAL STRG REQRD FOR MOD
LENG1    DC    XL2'0000'               LENGTH OF 1ST TEXT RECORD
LKEPA    DC    XL3'000000'             ASSIGNED ENTRY POINT ADDR
ATTR2    DC    XL1'00'                 ATTRIBUTES 2
*                           80=PROCESSED BY OS/VS LKED
*                           20=PAGE ALIGNMENT REQUIRED FOR MODULE
*                           10=SSI PRESENT
         DC    XL2'0000'
SCTRLEN  DC    XL2'0000'               SCATTER LIST LENGTH
TTLEN    DC    XL2'0000'               TRANSLATION TABLE LENGTH
SCESDID  DC    XL2'0000'               CESD NBR FOR 1ST TXT RECD
SCEPESD  DC    XL2'0000'               CESD NBR FOR ENTRY POINT
ALEPA    DC    XL3'000000'             ENTRY POINT OF THE MEMBER NAME
ALMEM    DC    CL8' '                  REAL MEMBER NAME FOR ALIAS
SSI      DS    XL4'00000000'           SSI BYTES
AUTHLEN  DC    XL1'00'                 AUTH CODE LENGTH
AUTHCOD  DC    XL1'00'                 AUTH CODE
*
*
*
COMMEND  EQU   *
*
*
*
LABELD   DSECT ,                       LABEL TABLE ENTRY
LABEL    DS    0CL13                   13-BYTE ENTRIES
LBLADR   DS    XL3                     RELATIVE ADDR IN TEXT
LBLTYP   DS    CL1                     TYPE: L=LABEL, A=ADCON, V=VCON,
LBLNAME  DS    CL8                     NAME (SYMBOL)
LBLLEN   DS    XL1                     LENGTH IF A, V, OR W
*
*
*
USINGD   DSECT ,                       USING TABLE ENTRY
USING    DS    0CL11
USBGN    DS    XL3                     OFFSET TO BEGINNING OF RANGE
USEND    DS    XL3                     OFFSET TO END OF RANGE
USREG    DS    XL1                     BASE REGISTER USED
USTYPE   DS    XL1                     TYPE:P=PGM,D=DSECT
USVALU   DS    XL3                     BASE REG VALUE
*
*
*
DSECTD   DSECT ,                       DSECT FIELD TABLE ENTRY
DSECT    DS    0CL13
DSOFSET  DS    XL3                     OFFSET TO 1ST BYTE OF FIELD
DSLBTYP  DS    CL1                     LABEL TYPE = L
DSNAME   DS    CL8                     FIELD NAME
DSLENG   DS    XL1                     FIELD LENGTH
*
*
*
DISASM2  CSECT
*
*
*
*
*
*
SVCTBLAD DC    A(SVCOP)                @ SVC TABLE
DBLOPAD  DC    A(DBLOP)                @ TWO-BYTE OP-CODE TBL
OWSTRT   DC    A(OPNDWK)               @ OPERAND WORK AREA
OPND9    DC    A(OPNDRTN)              RETURN ADDR FOR OPERAND ROUTINES
USG12    DS    2F                      REG SAVE AREA
USG9     DS    F                       RETURN SAVE
EQU9     DS    F                       RETURN ADDR FOR EQUSTMT
FC6      DS    F                       SAVE AREA FOR R6
FC9      DS    F                       FORCONST RETURN ADDR
TX9      DS    F                       RETURN ADDR FOR TXTFMT
BD9      DS    F                       RETURN FOR BDADR
BDX9     DS    F                       RETURN FOR BDXADR
BDL9     DS    F                       RETURN FOR BDLADR
SLSAV    DS    4F                      SAVE FOR SCHLBL
SGOPLEN DC AL2(L'SGLOP) SINGLE BYTE OP COD TBL LEN                   */
ILENG    DC    H'0'                    INSTRUCTION LENGTH  FIX***
CONPROG  DC    X'00'                   CONSTANT IN PROGRESS INDIC
CONPSLBL DS    0CL13                   PSEUDO LABEL ENTRY FOR CONSTANTS
         DS    XL4
CONNAME  DS    CL8                     CONSTANT NAME
CONLLEN  DS    XL1                     LABEL LENGTH
CONTYPE  DS    CL1                     TYPE
         DS    0H
CONDATA  DS    XL8                     CONSTANT DATA
CONSYM   DS    CL8                     CONSTANT SYMBOL
CONLEN   DS    H                       CONSTANT LENGTH
CONOFST  DS    F                       RELATIVE OFFSET TO CONSTANT
CONLOC   DS    F                       @ CURRENT BYTE IN CONSTANT
CCTYPE   DC    X'00'                   CC SET TYPE OF INSTR SETTING
TXTOFST  DS    0F
         DS    X
TXTOFSET DS    XL3                     OFFSET TO TEXT BYTE
OPNDWK   DS    CL13                    OPERAND BUILD AREA
OFFSET   DS    XL3                     OFFSET FROM PGM START
INSTYP   DS    CL1                     INSTRUCTION TYPE
TYPE     DS    XL1                     TYPE CODE
*                                       0=CSECT, 1=ADCON, 2=CONST
*                                       E=USING, D=INSTRUCTION
*                                       C=COMMENT, 9=ENTRY
*                                       A=EQU
LEN      DS    XL1                     TEXT LENGTH
TEXT     DS    XL8                     TEXT
H1       DC    H'1'                    CONSTANT 1
H2       DC    H'2'                    CONSTANT 2
H4       DC    H'4'                    CONSTANT 4
H7       DC    H'7'                    CONSTANT 7
H8       DC    H'8'                    CONSTANT 8
H10      DC    H'10'                   CONSTANT 10
H11      DC    H'11'                   CONSTANT 11
H13      DC    H'13'                   CONSTANT 13
H14      DC    H'14'                   CONSTANT 14
H16      DC    H'16'                   CONSTANT 16
H76      DC    H'76'                   CONSTANT 76
H100     DC    H'100'                  CONSTANT 100
H1000    DC    H'1000'                 CONSTANT 1000
P0       DC    P'0'                    CONSTANT 0
P1       DC    P'1'                    CONSTANT 1
P58      DC    P'58'                   CONSTANT 58
BLANX    DC    CL121' '                CONSTANT BLANKS
XZROS    DC    16X'00'                 CONSTANT ZEROS
HIVAL    DC    4X'FF'                  CONSTANT X F'S
NEXCHG   DC    XL3'00'                 OFFSET TO NEXT BASE REG CHG
USGLEN DC AL2(L'USING) LENGTH OF USING TBL ENTRIES
MORUSG   DC    X'00'                   0=NO MORE BASES, 80=MORE BASES A
TRTBL    DC    C'0123456789ABCDEF'     TRANSLATE TBL
PRTABL   DS    CL9                     PRINTABLE HEX WORK
BASES    DC    XL256'00'               BASE REG TABLE
CHARTRAN DC    256X'FF'                TRT TABLE FOR CHAR/HEX DETERMINA
         ORG   CHARTRAN+C' '
         DC    X'00'                   BLANK IS CHARACTER
         ORG   CHARTRAN+C'A'
         DC    9X'00'                  A-I ARE CHARACTERS
         ORG   CHARTRAN+C'J'
         DC    9X'00'                  J-R ARE CHARACTERS
         ORG   CHARTRAN+C'S'
         DC    8X'00'                  S-Z ARE CHARACTERS
         ORG   CHARTRAN+C'0'
         DC    10X'00'                 0-9 ARE CHARACTERS
         ORG
         LTORG
*
* INSTRUCTION DISASSEMBLY TABLES. THESE TABLES DEFINE VALID
* INSTRUCTION OP-CODES, AND GIVE MNEMONICS, FORMAT-TYPES,
* AND AN INDICATOR TO SHOW CONDITION SETTING INSTRUCTIONS,
* PRIVILEGED INSTRUCTIONS, AND FLOATING POINT INSTRUCTIONS.
*
*
INSTENT  DS    0CL10                   CURRENT INSTRUCTION ENTRY
INAME    DS    CL5                     INSTR NAME (MNEMONIC)
ITYPE    DS    XL1                     INSTRUCTION TYPE
RR       EQU   0                       RR FORMAT
RX       EQU   4                       RX FORMAT
S        EQU   8                       S FORMAT
SI       EQU   12                      SI FORMAT
RS       EQU   16                      RS FORMAT
SS1      EQU   20                      SS FORMAT, SINGLE LENGTH
SS2      EQU   24                      SS FORMAT, 2 LENGTHS
TWO      EQU   28                      TWO BYTE OP-CODE
CONDBR   EQU   32                      CONDITIONAL BRANCH
SVC      EQU   36                      SUPERVISOR CALL
ICLASS   DS    XL1                     INSTRUCTION CLASS
PRIV     EQU   2                       PRIVILEGED INSTRUCTION
FLTPT    EQU   4                       FLOATING POINT INSTRUCTION
FLSHT    EQU   5                       SHORT PREC FLT PT INSTR
IEDT     DS    XL1                     INSTRUCTION EDITS
EPR      EQU   X'40'                   EVEN-ODD REGISTER PAIR
E2       EQU   X'20'                   2ND OPND ON HALFWORD BOUND
E4       EQU   X'10'                   2ND OPND ON FULLWORD BOUND
E8       EQU   X'08'                   2ND OPND ON DBL WORD BOUND
S1       EQU   X'02'                   1ST OPND MUST HAVE BASE/INDEX
S2       EQU   X'01'                   2ND OPND MUST HAVE BASE
ICCSET   DS    XL1                     TYPE CONDITION CODE SET
ARITH    EQU   X'80'                   ARITHMETIC TYPE
CPR      EQU   X'40'                   COMPARE TYPE
ZRO8     EQU   X'20'                   BC 8 MAY BE BZ
INLNG    DS    XL1                     INSTRUCTION LENGTH
*
*
*
SGLOP    DS    0CL10                   SINGLE BYTE OP-CODE TABLE
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'02' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'02' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'02' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'02' NOT INSTR
         DC    CL5'SPM',AL1(RR),AL1(0),AL1(0),AL1(0),X'02' 04
         DC    CL5'BALR',AL1(RR),AL1(0),AL1(0),AL1(0),X'02' 05
         DC    CL5'BCTR',AL1(RR),AL1(0),AL1(0),AL1(0),X'02' 06
         DC    CL5'BCR',AL1(CONDBR),AL1(0),AL1(0),AL1(0),X'02' 07
         DC    CL5'SSK',AL1(RR),AL1(PRIV),AL1(0),AL1(0),X'02' 08
         DC    CL5'ISK',AL1(RR),AL1(PRIV),AL1(0),AL1(0),X'02' 09
         DC    CL5'SVC',AL1(SVC),AL1(0),AL1(0),AL1(0),X'02' 0A
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'02' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'02' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'02' NOT INSTR
         DC    CL5'MVCL',AL1(RR),AL1(0),AL1(EPR),AL1(0),X'02' 0E
         DC    CL5'CLCL',AL1(RR),AL1(0),AL1(EPR),AL1(0),X'02' 0F
         DC    CL5'LPR',AL1(RR),AL1(0),AL1(0),AL1(ARITH),X'02' 10
         DC    CL5'LNR',AL1(RR),AL1(0),AL1(0),AL1(ARITH),X'02' 11
         DC    CL5'LTR',AL1(RR),AL1(0),AL1(0),AL1(ARITH),X'02' 12
         DC    CL5'LCR',AL1(RR),AL1(0),AL1(0),AL1(ARITH),X'02' 13
         DC    CL5'NR',AL1(RR),AL1(0),AL1(0),AL1(ZRO8),X'02' 14
         DC    CL5'CLR',AL1(RR),AL1(0),AL1(0),AL1(CPR),X'02' 15
         DC    CL5'OR',AL1(RR),AL1(0),AL1(0),AL1(ZRO8),X'02' 16
         DC    CL5'XR',AL1(RR),AL1(0),AL1(0),AL1(ZRO8),X'02' 17
         DC    CL5'LR',AL1(RR),AL1(0),AL1(0),AL1(0),X'02' 18
         DC    CL5'CR',AL1(RR),AL1(0),AL1(0),AL1(CPR),X'02' 19
         DC    CL5'AR',AL1(RR),AL1(0),AL1(0),AL1(ARITH),X'02' 1A
         DC    CL5'SR',AL1(RR),AL1(0),AL1(0),AL1(ARITH),X'02' 1B
         DC    CL5'MR',AL1(RR),AL1(0),AL1(EPR),AL1(0),X'02' 1C
         DC    CL5'DR',AL1(RR),AL1(0),AL1(EPR),AL1(0),X'02' 1D
         DC    CL5'ALR',AL1(RR),AL1(0),AL1(0),AL1(0),X'02' 1E
         DC    CL5'SLR',AL1(RR),AL1(0),AL1(0),AL1(0),X'02' 1F
         DC    CL5'LPDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 20
         DC    CL5'LNDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 21
         DC    CL5'LTDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 22
         DC    CL5'LCDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 23
         DC    CL5'HDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 24
         DC    CL5'LRDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 25
         DC    CL5'MXR',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 26
         DC    CL5'MXDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 27
         DC    CL5'LDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 28
         DC    CL5'CDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(CPR),X'02' 29
         DC    CL5'ADR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 2A
         DC    CL5'SDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 2B
         DC    CL5'MDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 2C
         DC    CL5'DDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 2D
         DC    CL5'AWR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 2E
         DC    CL5'SWR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 2F
         DC    CL5'LPER',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 30
         DC    CL5'LNER',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 31
         DC    CL5'LTER',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 32
         DC    CL5'LCER',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 33
         DC    CL5'HER',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 34
         DC    CL5'LRER',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 35
         DC    CL5'AXR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 36
         DC    CL5'SXR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 37
         DC    CL5'LER',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 38
         DC    CL5'CER',AL1(RR),AL1(FLTPT),AL1(0),AL1(CPR),X'02' 39
         DC    CL5'AER',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 3A
         DC    CL5'SER',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 3B
         DC    CL5'MER',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 3C
         DC    CL5'DER',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 3D
         DC    CL5'AUR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 3E
         DC    CL5'SUR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 3F
         DC    CL5'STH',AL1(RX),AL1(0),AL1(E2+S2),AL1(0),X'04' 40
         DC    CL5'LA',AL1(RX),AL1(0),AL1(0),AL1(0),X'04' 41
         DC    CL5'STC',AL1(RX),AL1(0),AL1(S2),AL1(0),X'04' 42
         DC    CL5'IC',AL1(RX),AL1(0),AL1(0),AL1(0),X'04' 43
         DC    CL5'EX',AL1(RX),AL1(0),AL1(E2+S2),AL1(0),X'04' 44
         DC    CL5'BAL',AL1(RX),AL1(0),AL1(E2),AL1(0),X'04' 45
         DC    CL5'BCT',AL1(RX),AL1(0),AL1(E2+S2),AL1(0),X'04' 46
         DC    CL5'BC',AL1(CONDBR),AL1(0),AL1(E2),AL1(0),X'04' 47
         DC    CL5'LH',AL1(RX),AL1(0),AL1(E2),AL1(0),X'04' 48
         DC    CL5'CH',AL1(RX),AL1(0),AL1(E2),AL1(CPR),X'04' 49
         DC    CL5'AH',AL1(RX),AL1(0),AL1(E2),AL1(ARITH),X'04' 4A
         DC    CL5'SH',AL1(RX),AL1(0),AL1(E2),AL1(ARITH),X'04' 4B
         DC    CL5'MH',AL1(RX),AL1(0),AL1(E2),AL1(0),X'04' 4C
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    CL5'CVD',AL1(RX),AL1(0),AL1(E8+S2),AL1(0),X'04' 4E
         DC    CL5'CVB',AL1(RX),AL1(0),AL1(E8),AL1(0),X'04' 4F
         DC    CL5'ST',AL1(RX),AL1(0),AL1(E4+S2),AL1(0),X'04' 50
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    CL5'N',AL1(RX),AL1(0),AL1(E4),AL1(ZRO8),X'04' 54
         DC    CL5'CL',AL1(RX),AL1(0),AL1(E4),AL1(CPR),X'04' 55
         DC    CL5'O',AL1(RX),AL1(0),AL1(E4),AL1(ZRO8),X'04' 56
         DC    CL5'X',AL1(RX),AL1(0),AL1(E4),AL1(ZRO8),X'04' 57
         DC    CL5'L',AL1(RX),AL1(0),AL1(E4),AL1(0),X'04' 58
         DC    CL5'C',AL1(RX),AL1(0),AL1(E4),AL1(CPR),X'04' 59
         DC    CL5'A',AL1(RX),AL1(0),AL1(E4),AL1(ARITH),X'04' 5A
         DC    CL5'S',AL1(RX),AL1(0),AL1(E4),AL1(ARITH),X'04' 5B
         DC    CL5'M',AL1(RX),AL1(0),AL1(E4+EPR),AL1(0),X'04' 5C
         DC    CL5'D',AL1(RX),AL1(0),AL1(E4+EPR),AL1(0),X'04' 5D
         DC    CL5'AL',AL1(RX),AL1(0),AL1(E4),AL1(0),X'04' 5E
         DC    CL5'SL',AL1(RX),AL1(0),AL1(E4),AL1(0),X'04' 5F
         DC    CL5'STD',AL1(RX),AL1(FLTPT),AL1(0),AL1(0),X'04' 60
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    CL5'MXD',AL1(RX),AL1(FLTPT),AL1(0),AL1(0),X'04' 67
         DC    CL5'LD',AL1(RX),AL1(FLTPT),AL1(0),AL1(0),X'04' 68
         DC    CL5'CD',AL1(RX),AL1(FLTPT),AL1(0),AL1(CPR),X'04' 69
         DC    CL5'AD',AL1(RX),AL1(FLTPT),AL1(0),AL1(ARITH),X'04' 6A
         DC    CL5'SD',AL1(RX),AL1(FLTPT),AL1(0),AL1(ARITH),X'04' 6B
         DC    CL5'MD',AL1(RX),AL1(FLTPT),AL1(0),AL1(0),X'04' 6C
         DC    CL5'DD',AL1(RX),AL1(FLTPT),AL1(0),AL1(0),X'04' 6D
         DC    CL5'AW',AL1(RX),AL1(FLTPT),AL1(0),AL1(ARITH),X'04' 6E
         DC    CL5'SW',AL1(RX),AL1(FLTPT),AL1(0),AL1(ARITH),X'04' 6F
         DC    CL5'STE',AL1(RX),AL1(FLSHT),AL1(0),AL1(0),X'04' 70
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    CL5'LE',AL1(RX),AL1(FLSHT),AL1(0),AL1(0),X'04' 78
         DC    CL5'CE',AL1(RX),AL1(FLSHT),AL1(0),AL1(CPR),X'04' 79
         DC    CL5'AE',AL1(RX),AL1(FLSHT),AL1(0),AL1(ARITH),X'04' 7A
         DC    CL5'SE',AL1(RX),AL1(FLSHT),AL1(0),AL1(ARITH),X'04' 7B
         DC    CL5'ME',AL1(RX),AL1(FLSHT),AL1(0),AL1(0),X'04' 7C
         DC    CL5'DE',AL1(RX),AL1(FLSHT),AL1(0),AL1(0),X'04' 7D
         DC    CL5'AU',AL1(RX),AL1(FLSHT),AL1(0),AL1(ARITH),X'04' 7E
         DC    CL5'SU',AL1(RX),AL1(FLSHT),AL1(0),AL1(ARITH),X'04' 7F
         DC    CL5'SSM',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04' 80
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    CL5'LPSW',AL1(S),AL1(PRIV),AL1(E8),AL1(0),X'04' 82
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    CL5'WRD',AL1(SI),AL1(PRIV),AL1(0),AL1(0),X'04' 84
         DC    CL5'RDD',AL1(SI),AL1(PRIV),AL1(0),AL1(0),X'04' 85
         DC    CL5'BXH',AL1(RS),AL1(0),AL1(E2+S2),AL1(0),X'04' 86
         DC    CL5'BXLE',AL1(RS),AL1(0),AL1(E2+S2),AL1(0),X'04' 87
         DC    CL5'SRL',AL1(RS),AL1(0),AL1(0),AL1(ARITH),X'04' 88
         DC    CL5'SLL',AL1(RS),AL1(0),AL1(0),AL1(ARITH),X'04' 89
         DC    CL5'SRA',AL1(RS),AL1(0),AL1(0),AL1(ARITH),X'04' 8A
         DC    CL5'SLA',AL1(RS),AL1(0),AL1(0),AL1(ARITH),X'04' 8B
         DC    CL5'SRDL',AL1(RS),AL1(0),AL1(EPR),AL1(ARITH),X'04' 8C
         DC    CL5'SLDL',AL1(RS),AL1(0),AL1(EPR),AL1(ARITH),X'04' 8D
         DC    CL5'SRDA',AL1(RS),AL1(0),AL1(EPR),AL1(ARITH),X'04' 8E
         DC    CL5'SLDA',AL1(RS),AL1(0),AL1(EPR),AL1(ARITH),X'04' 8F
         DC    CL5'STM',AL1(RS),AL1(0),AL1(E4+S2),AL1(0),X'04' 90
         DC    CL5'TM',AL1(SI),AL1(0),AL1(0),AL1(ARITH),X'04' 91
         DC    CL5'MVI',AL1(SI),AL1(0),AL1(S2),AL1(0),X'04' 92
         DC    CL5'TS',AL1(S),AL1(0),AL1(0),AL1(0),X'04' 93
         DC    CL5'NI',AL1(SI),AL1(0),AL1(0),AL1(ZRO8),X'04' 94
         DC    CL5'CLI',AL1(SI),AL1(0),AL1(0),AL1(CPR),X'04' 95
         DC    CL5'OI',AL1(SI),AL1(0),AL1(0),AL1(ZRO8),X'04' 96
         DC    CL5'XI',AL1(SI),AL1(0),AL1(0),AL1(ZRO8),X'04' 97
         DC    CL5'LM',AL1(RS),AL1(0),AL1(E4),AL1(0),X'04' 98
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    CL5' ',AL1(TWO),AL1(0),AL1(0),AL1(0),X'04' 9C
         DC    CL5' ',AL1(TWO),AL1(0),AL1(0),AL1(0),X'04' 9D
         DC    CL5' ',AL1(TWO),AL1(0),AL1(0),AL1(0),X'04' 9E
         DC    CL5' ',AL1(TWO),AL1(0),AL1(0),AL1(0),X'04' 9F
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    CL5'STNSM',AL1(SI),AL1(PRIV),AL1(0),AL1(0),X'04' AC
         DC    CL5'STOSM',AL1(SI),AL1(PRIV),AL1(0),AL1(0),X'04' AD
         DC    CL5'SIGP',AL1(RS),AL1(PRIV),AL1(0),AL1(0),X'04' AE
         DC    CL5'MC',AL1(SI),AL1(0),AL1(0),AL1(0),X'04' AF
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    CL5'LRA',AL1(RX),AL1(PRIV),AL1(0),AL1(0),X'04' B1
         DC    CL5' ',AL1(TWO),AL1(0),AL1(0),AL1(0),X'04' B2
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    CL5'STCTL',AL1(RS),AL1(PRIV),AL1(0),AL1(0),X'04' B6
         DC    CL5'LCTL',AL1(RS),AL1(PRIV),AL1(E4),AL1(0),X'04' B7
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    CL5'CS',AL1(RS),AL1(0),AL1(E4+EPR),AL1(0),X'04' BA
         DC    CL5'CDS',AL1(RS),AL1(0),AL1(E4+EPR),AL1(0),X'04' BB
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR
         DC    CL5'CLM',AL1(RS),AL1(0),AL1(0),AL1(CPR),X'04' BD
         DC    CL5'STCM',AL1(RS),AL1(0),AL1(S2),AL1(0),X'04' BE
         DC    CL5'ICM',AL1(RS),AL1(0),AL1(0),AL1(ZRO8),X'04' BF
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    CL5'MVN',AL1(SS1),AL1(0),AL1(S1),AL1(0),X'06' D1
         DC    CL5'MVC',AL1(SS1),AL1(0),AL1(S1),AL1(0),X'06' D2
         DC    CL5'MVZ',AL1(SS1),AL1(0),AL1(S1),AL1(0),X'06' D3
         DC    CL5'NC',AL1(SS1),AL1(0),AL1(S1),AL1(ZRO8),X'06' D4
         DC    CL5'CLC',AL1(SS1),AL1(0),AL1(0),AL1(CPR),X'06' D5
         DC    CL5'OC',AL1(SS1),AL1(0),AL1(S1),AL1(ZRO8),X'06' D6
         DC    CL5'XC',AL1(SS1),AL1(0),AL1(S1),AL1(ZRO8),X'06' D7
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    CL5'TR',AL1(SS1),AL1(0),AL1(S1),AL1(0),X'06' DC
         DC    CL5'TRT',AL1(SS1),AL1(0),AL1(0),AL1(ZRO8),X'06' DD
         DC    CL5'ED',AL1(SS1),AL1(0),AL1(S1),AL1(ARITH),X'06' DE
         DC    CL5'EDMK',AL1(SS1),AL1(0),AL1(S1),AL1(ARITH),X'06' DF
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    CL5'SRP',AL1(SS2),AL1(0),AL1(S1),AL1(ARITH),X'06' F0
         DC    CL5'MVO',AL1(SS2),AL1(0),AL1(S1),AL1(0),X'06' F1
         DC    CL5'PACK',AL1(SS2),AL1(0),AL1(S1),AL1(0),X'06' F2
         DC    CL5'UNPK',AL1(SS2),AL1(0),AL1(S1),AL1(0),X'06' F3
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    CL5'ZAP',AL1(SS2),AL1(0),AL1(S1),AL1(ARITH),X'06' F8
         DC    CL5'CP',AL1(SS2),AL1(0),AL1(0),AL1(CPR),X'06' F9
         DC    CL5'AP',AL1(SS2),AL1(0),AL1(S1),AL1(ARITH),X'06' FA
         DC    CL5'SP',AL1(SS2),AL1(0),AL1(S1),AL1(ARITH),X'06' FB
         DC    CL5'MP',AL1(SS2),AL1(0),AL1(S1),AL1(0),X'06' FC
         DC    CL5'DP',AL1(SS2),AL1(0),AL1(S1),AL1(0),X'06' FD
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR
         DC    X'FFFF'                 TABLE END
*
*
*
DBLOP    DS    0CL12                   TWO-BYTE OP-CODE TABLE
         DC    X'9C00',CL5'SIO',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'9C01',CL5'SIOF',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'9D00',CL5'TIO',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'9D01',CL5'CLRIO',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'9E00',CL5'HIO',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'9E01',CL5'HDV',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'9F00',CL5'TCH',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'B20B',CL5'IPK',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'B20D',CL5'PTLB',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'B213',CL5'RRB',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'B204',CL5'SCK',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'B206',CL5'SCKC',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'B208',CL5'SPT',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'B210',CL5'SPX',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'B20A',CL5'SPKA',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'B203',CL5'STIDC',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'B205',CL5'STCK',AL1(S),AL1(0),AL1(E8+S2),AL1(0),X'04'
         DC    X'B207',CL5'STCKC',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'B212',CL5'STAP',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'B202',CL5'STIDP',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'B209',CL5'STPT',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'B211',CL5'STPX',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'
         DC    X'FFFF'                 TABLE END
*
*
*
SVCOP    DS    0CL15                   SVC NAME TABLE
         DC    AL1(0),CL14'EXCP/XDAP'
         DC    AL1(1),CL14'WAIT/WAITR'
         DC    AL1(2),CL14'POST/PRTOV'
         DC    AL1(3),CL14'EXIT'
         DC    AL1(4),CL14'GETMAIN'
         DC    AL1(5),CL14'FREEMAIN'
         DC    AL1(6),CL14'LINK'
         DC    AL1(7),CL14'XCTL'
         DC    AL1(8),CL14'LOAD'
         DC    AL1(9),CL14'DELETE'
         DC    AL1(10),CL14'GET/FREEMAIN R'
         DC    AL1(11),CL14'TIME'
         DC    AL1(12),CL14'SYNCH'
         DC    AL1(13),CL14'ABEND'
         DC    AL1(14),CL14'SPIE'
         DC    AL1(15),CL14'ERREXCP'
         DC    AL1(16),CL14'PURGE'
         DC    AL1(17),CL14'RESTORE'
         DC    AL1(18),CL14'BLDL/FIND'
         DC    AL1(19),CL14'OPEN'
         DC    AL1(20),CL14'CLOSE'
         DC    AL1(21),CL14'STOW'
         DC    AL1(22),CL14'OPEN TYPE J'
         DC    AL1(23),CL14'CLOSE TYPE T'
         DC    AL1(24),CL14'DEVTYPE'
         DC    AL1(25),CL14'TRKBAL'
         DC    AL1(26),CL14'LOCATE, ETC'
         DC    AL1(27),CL14'OBTAIN'
         DC    AL1(28),CL14'CVOL'
         DC    AL1(29),CL14'SCRATCH'
         DC    AL1(30),CL14'RENAME'
         DC    AL1(31),CL14'FEOV'
         DC    AL1(32),CL14'(NO MACRO)'
         DC    AL1(33),CL14'IOHALT'
         DC    AL1(34),CL14'MGCR/QEDIT'
         DC    AL1(35),CL14'WTO/WTOR'
         DC    AL1(36),CL14'WTL'
         DC    AL1(37),CL14'SEGLD/SEGWT'
         DC    AL1(39),CL14'LABEL'
         DC    AL1(40),CL14'EXTRACT'
         DC    AL1(41),CL14'IDENTIFY'
         DC    AL1(42),CL14'ATTACH'
         DC    AL1(43),CL14'CIRB'
         DC    AL1(44),CL14'CHAP'
         DC    AL1(45),CL14'OVLYBRCH'
         DC    AL1(46),CL14'TTIMER'
         DC    AL1(47),CL14'STIMER'
         DC    AL1(48),CL14'DEQ'
         DC    AL1(51),CL14'SNAP/SDUMP'
         DC    AL1(52),CL14'RESTART'
         DC    AL1(53),CL14'RELEX'
         DC    AL1(54),CL14'DISABLE'
         DC    AL1(55),CL14'EOV'
         DC    AL1(56),CL14'ENQ/RESERVE'
         DC    AL1(57),CL14'FREEDBUF'
         DC    AL1(58),CL14'RELBUF/REQBUF'
         DC    AL1(59),CL14'OLTEP'
         DC    AL1(60),CL14'(E)STAE/STAI'
         DC    AL1(61),CL14'IKJEGS6A'
         DC    AL1(62),CL14'DETACH'
         DC    AL1(63),CL14'CHKPT'
         DC    AL1(64),CL14'RDJFCB'
         DC    AL1(66),CL14'BTAMTEST'
         DC    AL1(67),CL14'SYNADAF'
         DC    AL1(68),CL14'SYNADRLS'
         DC    AL1(69),CL14'BSP'
         DC    AL1(70),CL14'GSERV'
         DC    AL1(71),CL14'ASGNBFR, ETC'
         DC    AL1(72),CL14'CHATR'
         DC    AL1(73),CL14'SPAR'
         DC    AL1(74),CL14'DAR'
         DC    AL1(75),CL14'DQUEUE'
         DC    AL1(76),CL14'(NO MACRO)'
         DC    AL1(78),CL14'(NO MACRO)'
         DC    AL1(79),CL14'STATUS'
         DC    AL1(81),CL14'SETPRT'
         DC    AL1(82),CL14'DASDR'
         DC    AL1(83),CL14'SMFWTM'
         DC    AL1(84),CL14'GRAPHICS'
         DC    AL1(85),CL14'DDRSWAP'
         DC    AL1(86),CL14'ATLAS'
         DC    AL1(87),CL14'DOM'
         DC    AL1(88),CL14'MOD88'
         DC    AL1(91),CL14'VOLSTAT'
         DC    AL1(92),CL14'TCBEXCP'
         DC    AL1(93),CL14'TGET/TPUT'
         DC    AL1(94),CL14'STCC'
         DC    AL1(95),CL14'SYSEVENT'
         DC    AL1(96),CL14'STAX'
         DC    AL1(97),CL14'TSO TEST'
         DC    AL1(98),CL14'PROTECT'
         DC    AL1(99),CL14'DDDYNAM'
         DC    AL1(100),CL14'IKJEFFIB'
         DC    AL1(101),CL14'QTIP'
         DC    AL1(102),CL14'AQCTL'
         DC    AL1(103),CL14'XLATE'
         DC    AL1(104),CL14'TOPCTL'
         DC    AL1(105),CL14'IMAGLIB'
         DC    AL1(107),CL14'MODESET'
         DC    AL1(109),CL14'ESR TYPE 4'
         DC    AL1(110),CL14'DSTATUS'
         DC    AL1(111),CL14'(NO MACRO)'
         DC    AL1(112),CL14'PGRLSE'
         DC    AL1(113),CL14'PGFIX,CL14' ETC'
         DC    AL1(114),CL14'EXCPVR'
         DC    AL1(116),CL14'ESR TYPE 1'
         DC    AL1(117),CL14'DEBCHK'
         DC    AL1(119),CL14'TESTAUTH'
         DC    AL1(120),CL14'GETMAIN/FREEMAIN'
         DC    AL1(121),CL14'VSAM'
         DC    AL1(122),CL14'EVENTS'
         DC    AL1(123),CL14'PURGEDQ'
         DC    AL1(124),CL14'TPIO'
         DC    AL1(125),CL14'EVENTS'
         DC    AL1(126),CL14'MSS INTERFACE'
         DC    X'FF'                   END OF TABLE
         END
./       ADD   NAME=EALSDW95
  TITLE 'EASTERN AIR LINES VERSION OF IEFSD095 BLOCK LETTER ROUTINE'
*$DOC@*****************************************************************
*                  I  E  F  S  D  0  9  5                             *
*                                                                     *
*   THIS MODULE HAS BEEN MODIFIED BY EASTERN AIR LINES.               *
*                                                                     *
*   UPDATES HAVE BEEN APPLIED SO THAT:                                *
*                                                                     *
*   1. THE SPECIAL CHARACTERS FOUND ON MOST PRINTER UNITS WILL        *
*      PRINT IN BLOCK FORMAT.                                         *
*                                                                     *
*      THE SPECIAL CHARACTERS ARE:                                    *
*                                                                     *
*      . < ( + × & $ * ) ; ^ - / , % _ > ? : # @ ' = ''               *
*                                                                     *
*$DOC$*****************************************************************
         SPACE 2
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
WORKAREA DSECT
         DS    0F
SAVECHAR DS    F
SAVEREGR DS    F
UNUSEDPT DS    6F
WORKEND  EQU   *
*INITIALIZE
EALSDW95 CSECT
         ENTRY EALSDW95
         SAVE  (14,12)                 SAVE REGISTERS
         BALR  R9,0                    SET BASE REGISTER
         USING *,R9
         L     R3,4(R1)
         L     R3,0(R3)
         L     R4,8(R1)
         L     R11,12(R1)
         L     R11,0(R11)
         L     R1,0(R1)
         LR    R10,R1
         LA    R0,WORKEND-WORKAREA
         GETMAIN R,LV=(0)              GET CORE FOR WORK AREA
         LR    R12,R1
         USING WORKAREA,R12
         LR    R1,R10                  RESTORE R1
         ST    R13,SAVEREGR            SAVE R13
         XC    SAVECHAR(4),SAVECHAR    ZERO SAVECHAR
LOOP     MVC   SAVECHAR+3(1),0(R1)     GET CHARACTER
         L     R2,SAVECHAR             PUT IT IN R2
         LR    R10,R2
         C     R2,BNK                  IS IT A BLANK, IF SO
         BE    FBL                     BRANCH TO FBL
         C     R2,C1                   IS IT LESS THAN C1 IF SO
         BL    TROUBLE                 BRANCH TO TROUBLE
         C     R2,CA
         BL    TEST2
         C     R2,D1
         BL    TROUBLE
         C     R2,DA
         BL    TEST3
         C     R2,E2
         BL    TROUBLE
         C     R2,EA
         BL    TEST4
         C     R2,F0
         BL    TROUBLE
         C     R2,FA
         BL    TEST5
         B     FBL                                               *EAL*1
TROUBLE  C     R2,FOURB                                          *EAL*1
         BL    FBL                                               *EAL*1
         C     R2,FIVE1                                          *EAL*1
         BL    TEST6                                             *EAL*1
         C     R2,FIVEB                                          *EAL*1
         BL    FBL                                               *EAL*1
         C     R2,SIX2                                           *EAL*1
         BL    TEST7                                             *EAL*1
         C     R2,SIXB                                           *EAL*1
         BL    FBL                                               *EAL*1
         C     R2,SEVEN0                                         *EAL*1
         BL    TEST8                                             *EAL*1
         C     R2,SEVENA                                         *EAL*1
         BL    FBL                                               *EAL*1
         C     R2,EIGHT0                                         *EAL*1
         BL    TEST9                                             *EAL*1
FBL      LA    R6,CHARACTR-1          SET R6 TO ADDR OF BLANK
         B     EXIT1
TEST2    S     R2,C0                   GET OFF SET
         MH    R2,TWLV+2
         LA    R6,CHARACTR-1          SET  R6 TO ADDR OF LETTER
         AR    R6,R2
         B     EXIT1
TEST3    S     R2,D0
         MH    R2,TWLV+2
         A     R2,ONZET
         LA    R6,CHARACTR-1          SET  R6 TO ADDR OF LETTER
         AR    R6,R2
         B     EXIT1                                             *EAL*1
TEST6    S     R2,FOURA                                          *EAL*1
         B     TEST12                                            *EAL*1
TEST7    S     R2,FIVE4                                          *EAL*1
         B     TEST12                                            *EAL*1
TEST8    S     R2,FIVED                                          *EAL*1
         B     TEST12                                            *EAL*1
TEST9    S     R2,SIX7                                           *EAL*1
TEST12   MH    R2,TWLV+2                                         *EAL*1
         A     R2,SPECIAL                                        *EAL*1
         LA    R6,CHARACTR-1                                     *EAL*1
         AR    R6,R2                                             *EAL*1
         B     EXIT1
TEST4    S     R2,E1
         MH    R2,TWLV+2
         A     R2,TWOSX
         LA    R6,CHARACTR-1          SET  R6 TO ADDR OF LETTER
         AR    R6,R2
         B     EXIT1
TEST5    S     R2,EF
         MH    R2,TWLV+2
         A     R2,TROTW
         LA    R6,CHARACTR-1          SET  R6 TO ADDR OF LETTER
         AR    R6,R2
*   GET POINTER TO LINE PATTERN
EXIT1    XR    R7,R7
         AR    R6,R3
         IC    R7,0(R6)
*                                      LINE PATTERN FROM LINEPATH
         LA    R8,LINEPATN
         AR    R7,R8
         LH    R5,0(R7)
         SLL   R5,19
         O     R5,ONEX
         BXH   R5,R5,LP1
         STC   R10,0(R4)
LP1      BXH   R5,R5,LP2
         STC   R10,1(R4)
LP2      BXH   R5,R5,LP3
         STC   R10,2(R4)
LP3      BXH   R5,R5,LP4
         STC   R10,3(R4)
LP4      BXH   R5,R5,LP5
         STC   R10,4(R4)
LP5      BXH   R5,R5,LP6
         STC   R10,5(R4)
LP6      BXH   R5,R5,LP7
         STC   R10,6(R4)
LP7      BXH   R5,R5,LP8
         STC   R10,7(R4)
LP8      BXH   R5,R5,LP9
         STC   R10,8(R4)
LP9      BXH   R5,R5,LP10
         STC   R10,9(R4)
LP10     BXH   R5,R5,LP11
         STC   R10,10(R4)
LP11     BXH   R5,R5,LP12
         STC   R10,11(R4)
LP12     A     R4,FORT
         A     R1,ONEX
         S     R11,ONEX
         XR    R8,R8
         CR    R11,R8
         BH    LOOP
         L     R13,SAVEREGR
         LA    R0,WORKEND-WORKAREA
         LR    R1,R12
         FREEMAIN  R,LV=(0),A=(1)
         RETURN (14,12)
*   CONSTANTS
         DS    0F
BNK      DC    XL4'40'
C1       DC    XL4'C1'
CA       DC    XL4'CA'
D1       DC    XL4'D1'
DA       DC    XL4'DA'
E2       DC    XL4'E2'
EA       DC    XL4'EA'
F0       DC    XL4'F0'
FA       DC    XL4'FA'
C0       DC    XL4'C0'
D0       DC    XL4'D0'
E1       DC    XL4'E1'
EF       DC    XL4'EF'
FOURA    DC    XL4'4A'                                           *EAL*1
FOURB    DC    XL4'4B'                                           *EAL*1
FIVE1    DC    XL4'51'                                           *EAL*1
FIVE4    DC    XL4'54'                                           *EAL*1
FIVEB    DC    XL4'5B'                                           *EAL*1
FIVED    DC    XL4'5D'                                           *EAL*1
SIX2     DC    XL4'62'                                           *EAL*1
SIX7     DC    XL4'67'                                           *EAL*1
SIXB     DC    XL4'6B'                                           *EAL*1
SEVEN0   DC    XL4'70'                                           *EAL*1
SEVENA   DC    XL4'7A'                                           *EAL*1
EIGHT0   DC    XL4'80'                                           *EAL*1
SPECIAL  DC    XL4'01B0'                                         *EAL*1
TWLV     DC    XL4'0C'
ONZET    DC    XL4'6C'
TWOSX    DC    XL4'D8'
TROTW    DC    XL4'0138'
FORT     DC    XL4'0E'
ONEX     DC    XL4'01'
CHARACTR DS    0F
BLANK    DC    12X'4C'
A        DC    X'020008080800000808080808'
B        DC    X'2C000808322A2A320808002C'
C        DC    X'020008262626262626080002'
D        DC    X'282A32080808080808322A28'
E        DC    X'000026262668682626260000'
F        DC    X'000026262668682626262626'
G        DC    X'020008262626343408080002'
H        DC    X'080808080800000808080808'
I        DC    X'020214141414141414140202'
J        DC    X'66660A0A0A0A0A0A3A3A686A'
K        DC    X'08322E3C3A36363A3C2E3208'
L        DC    X'262626262626262626260000'
M        DC    X'083E40424446080808080808'
N        DC    X'086C6E484A464E5052540876'
O        DC    X'000008080808080808080000'
P        DC    X'2C00080808002C2626262626'
Q        DC    X'020008080808084E50522C56'
R        DC    X'2C00080808002C3A3C2E3208'
S        DC    X'02000826585A5C5E64080002'
T        DC    X'000014141414141414141414'
U        DC    X'080808080808080808080002'
V        DC    X'080808080808083062206014'
W        DC    X'080808080808464442403E08'
X        DC    X'080830622060602062300808'
Y        DC    X'080830622060141414141414'
Z        DC    X'00001070120A147216742400'
ZERO     DC    X'040208080808080808080204'
ONE      DC    X'140C0E141414141414140202'
TWO      DC    X'020008646410121416180000'
THREE    DC    X'02000864641A1A6464080002'
FOUR     DC    X'061C1E202224001212121212'
FIVE     DC    X'0000262626282A106464002C'
SIX      DC    X'02000826262C000808080002'
SEVEN    DC    X'002C2E120A14141414141414'
EIGHT    DC    X'020008083004043008080002'
NINE     DC    X'020008080800006464080002'
PERIOD   DC    X'4C4C4C4C4C4C4C4C4C146014'                       *EAL*1
LESSTHAN DC    X'64700A7274262674720A7064'                       *EAL*1
LPAREN   DC    X'120A14147272727214140A12'                       *EAL*1
PLUS     DC    X'4C4C14141400001414144C4C'                       *EAL*1
BAR      DC    X'141414141414141414141414'                       *EAL*1
AMPRSAND DC    X'0CAC2222AC0CAEB0B2B4B6B8'                       *EAL*1
DOLLARS  DC    X'14040246785A5C7A46020414'                       *EAL*1
ASTERISK DC    X'4C4C14860288880286144C4C'                       *EAL*1
RPAREN   DC    X'167214140A0A0A0A14147216'                       *EAL*1
SEMICOLN DC    X'4C4C4C1460144C1460820A80'                       *EAL*1
NOT      DC    X'000064644C4C4C4C4C4C4C4C'                       *EAL*1
DASH     DC    X'4C4C4C4C4C00004C4C4C4C4C'                       *EAL*1
SLASH    DC    X'7C641070120A14721674187E'                       *EAL*1
COMMA    DC    X'4C4C4C4C4C4C4C1460820A80'                       *EAL*1
PERCENT  DC    X'66929496980A149A9C9EA0A2'                       *EAL*1
UNDSCORE DC    X'4C4C4C4C4C4C4C4C4C4C0000'                       *EAL*1
GRTHAN   DC    X'2674720A706464700A727426'                       *EAL*1
QUESTION DC    X'60886262120A14144C146014'                       *EAL*1
COLON    DC    X'4C4C4C4C1460144C4C146014'                       *EAL*1
POUND    DC    X'4C202000002020000020204C'                       *EAL*1
AT       DC    X'88043008A4A6A84E4EAA0488'                       *EAL*1
APOSTRFY DC    X'1460820A804C4C4C4C4C4C4C'                       *EAL*1
EQUAL    DC    X'4C4C4C00004C4C00004C4C4C'                       *EAL*1
QUOTES   DC    X'228A8C8E904C4C4C4C4C4C4C'                       *EAL*1
LINEPATN DS    0F
L1       DC    BL2'111111111111'
L2       DC    BL2'011111111110'
L3       DC    BL2'001111111100'
L4       DC    BL2'000000111000'
L5       DC    BL2'110000000011'
L6       DC    BL2'000000110000'
L7       DC    BL2'000011100000'
L8       DC    BL2'000111100000'
L9       DC    BL2'000000000110'
L10      DC    BL2'000000011000'
L11      DC    BL2'000001100000'
L12      DC    BL2'000110000000'
L13      DC    BL2'011000000000'
L14      DC    BL2'000000011110'
L15      DC    BL2'000001111000'
L16      DC    BL2'000011011000'
L17      DC    BL2'000110011000'
L18      DC    BL2'001100011000'
L19      DC    BL2'011111111111'
L20      DC    BL2'110000000000'
L21      DC    BL2'111111111000'
L22      DC    BL2'111111111100'
L23      DC    BL2'111111111110'
L24      DC    BL2'110000001100'
L25      DC    BL2'011000000110'
L26      DC    BL2'110000000110'
L27      DC    BL2'110000011111'
L28      DC    BL2'111111100000'
L29      DC    BL2'110001100000'
L30      DC    BL2'110000110000'
L31      DC    BL2'110000011000'
L32      DC    BL2'111000000111'
L33      DC    BL2'111100001111'
L34      DC    BL2'110110011011'
L35      DC    BL2'110011110011'
L36      DC    BL2'110001100011'
L37      DC    BL2'110110000011'
L38      DC    BL2'110011000011'
L39      DC    BL2'000000000000'
L40      DC    BL2'110000110011'
L41      DC    BL2'110000011011'
L42      DC    BL2'110000001111'
L43      DC    BL2'110000000111'
L44      DC    BL2'011111111011'
L45      DC    BL2'111000000000'
L46      DC    BL2'011111111100'
L47      DC    BL2'001111111110'
L48      DC    BL2'000000000111'
L49      DC    BL2'000011110000'
L50      DC    BL2'001100001100'
L51      DC    BL2'000000000011'
L52      DC    BL2'001111111111'
L53      DC    BL2'111111110000'
L54      DC    BL2'011111100000'
L55      DC    BL2'111000000011'
L56      DC    BL2'111100000011'
L57      DC    BL2'000000001100'
L58      DC    BL2'000011000000'
L59      DC    BL2'001100000000'
L60      DC    BL2'110000000001'
L61      DC    BL2'110001100001'                                 *EAL*1
L62      DC    BL2'100001100011'                                 *EAL*1
L63      DC    BL2'000000000001'                                 *EAL*1
L64      DC    BL2'010000000000'                                 *EAL*1
L65      DC    BL2'000000100000'                                 *EAL*1
L66      DC    BL2'000001110000'                                 *EAL*1
L67      DC    BL2'010001100010'                                 *EAL*1
L68      DC    BL2'011001100110'                                 *EAL*1
L69      DC    BL2'000111111000'                                 *EAL*1
L70      DC    BL2'011110111100'                                 *EAL*1
L71      DC    BL2'001110011100'                                 *EAL*1
L72      DC    BL2'000110001100'                                 *EAL*1
L73      DC    BL2'000100001000'                                 *EAL*1
L74      DC    BL2'011100000011'                                 *EAL*1
L75      DC    BL2'110110000110'                                 *EAL*1
L76      DC    BL2'011100001100'                                 *EAL*1
L77      DC    BL2'001000011000'                                 *EAL*1
L78      DC    BL2'000011000100'                                 *EAL*1
L79      DC    BL2'000110001110'                                 *EAL*1
L80      DC    BL2'001100011011'                                 *EAL*1
L81      DC    BL2'011000001110'                                 *EAL*1
L82      DC    BL2'110000000100'                                 *EAL*1
L83      DC    BL2'100111000011'                                 *EAL*1
L84      DC    BL2'001111110011'                                 *EAL*1
L85      DC    BL2'011000110011'                                 *EAL*1
L86      DC    BL2'011000110110'                                 *EAL*1
L87      DC    BL2'000110110000'                                 *EAL*1
L88      DC    BL2'000111100110'                                 *EAL*1
L89      DC    BL2'001100111100'                                 *EAL*1
L90      DC    BL2'011000011000'                                 *EAL*1
L91      DC    BL2'011000111100'                                 *EAL*1
L92      DC    BL2'001111100110'                                 *EAL*1
L93      DC    BL2'000111000010'                                 *EAL*1
         END
./       ADD   NAME=ISP@SPY
//DORISPY JOB (6000A,601,,9999),SPYISPF,CLASS=A,MSGCLASS=A,
//   NOTIFY=DOR
/*ROUTE  PRINT  RMT55
//ASM    EXEC PGM=IEV90,
//     PARM='RENT,RLD,LOAD,NODECK,LINECNT=54,OBJECT',
//     REGION=1000K
//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR
//         DD  DSN=SYS1.AMODGEN,DISP=SHR,UNIT=3350,VOL=SER=MVSDLB
//         DD  DSN=SYS1.PVTMAC,DISP=SHR,VOL=SER=MVSDLB,UNIT=3350
//         DD  DSN=C6000A.DOR.QISPFLIB,DISP=SHR,UNIT=3350
//SYSUT1   DD  UNIT=(SYSDA,SEP=SYSLIB),SPACE=(CYL,(10,5)),DSN=&SYSUT1
//SYSPUNCH DD  DUMMY,DCB=BLKSIZE=80
//SYSPRINT DD SYSOUT=*,DCB=(BLKSIZE=3509),UNIT=(,SEP=(SYSUT1,SYSPUNCH))
//SYSLIN   DD  DISP=(,PASS),UNIT=SYSDA,SPACE=(CYL,(5,5,0)),            *
//             DCB=(BLKSIZE=400),DSN=&&LOADSET
   TITLE 'S P Y --  MVS CONSOLE SPY PROGRAM  --  V3.1 -- ISPF '
         MACRO
.*                                                      RON MURA, TPD
&LABEL   ENTER &SA=,        SAVEAREA ADDRESS                           X
               &BASE=12,    BASE REGISTER                              X
               &BASE2=,     SECOND BASE REGISTER                       X
               &BASE3=,     THIRD BASE REGISTER                        X
               &ID=,        MODULE IDENTIFIER                          X
               &TITLE=,     ASSEMBLY LISTING TITLE                     X
               &RENT=NO,    REENTERANT OR NONREENTERANT SAVEAREAS      X
               &CSECT=YES,  CSECT OR NOT                    9/3/81     X
               &WKBYTES=0,  BYTES TO BE GETMAIN'D BESIDES 72 FOR SA    X
               &GETFAIL=    BRANCH-TO ADDRESS IF GETMAIN FAILS
.*               NO PARAMETERS REQUIRED
.*               SA IGNORED IF RENT=YES SPECIFIED
.*               WKBYTES AND GETFAIL IGNORED UNLESS RENT=YES SPECIFIED
         MNOTE *,'*** ENTER - STANDARD OS LINKAGE ***'
         GBLB  &RENTSW1     1 = REENTERANT SAVEAREA
         GBLC  &WKLNTH
&RENTSW1 SETB  0            TURN OFF IN CASE MULT. MACROS PER ASSEMBLY
&WKLNTH  SETC  '&WKBYTES'   KEEP FOR FREEMAIN IN LEAVE MACRO
         LCLC  &CSECTNM,&ID2,&NDX,&SAVE,&GETTYPE
&NDX     SETC  '&SYSNDX'
         AIF   ('&TITLE' EQ '').NOTITLE
         TITLE &TITLE
.*                          TITLE MUST BE ENCLOSED BY QUOTATION MARKS
.NOTITLE AIF   ('&LABEL' EQ '').NOLABEL
&CSECTNM SETC  '&LABEL'
         AGO   .CHKID
.NOLABEL AIF   ('&CSECT' NE 'YES').CHKID                    9/3/81
&CSECTNM SETC  '$PRIVATE'
         MNOTE *,'*** NO LABEL ON ENTER MACRO, CSECT CALLED ''$PRIVATE'X
               ' ***'
.CHKID   AIF   (T'&ID EQ 'O').NOID
&ID2     SETC  '&ID'
         AGO   .CHKSA
.NOID    ANOP
&ID2     SETC  '&CSECTNM-&SYSDATE-&SYSTIME'
.CHKSA   ANOP
         AIF   ('&CSECT' EQ 'YES').CS                       9/3/81
&LABEL   SAVE  (14,12),,&ID2                                9/3/81
         AGO   .LR
.CS      ANOP                                               9/3/81
&CSECTNM CSECT
         SAVE  (14,12),,&ID2
.LR      ANOP                                               9/3/81
         LR    &BASE,15               ESTABLISH BASE
         USING &CSECTNM,&BASE         INFORM ASSEMBLER
         AIF   (T'&BASE2 EQ 'O').CHKRENT
         LA    &BASE2,2048(&BASE)
         LA    &BASE2,2048(&BASE2)    ESTABLISH SECOND BASE REG
         USING &CSECTNM+4096,&BASE2
         AIF   (T'&BASE3 EQ 'O').CHKRENT
         LA    &BASE3,2048(&BASE2)
         LA    &BASE3,2048(&BASE3)    ESTABLISH THIRD BASE REG
         USING &CSECTNM+8192,&BASE3
.CHKRENT AIF   ('&RENT' EQ 'YES').REENT
         AIF   (T'&SA EQ 'O').NOSA
&SAVE    SETC  '&SA'
         AGO   .SAOK
.NOSA    ANOP
&SAVE    SETC  'SAVE&NDX'
.SAOK    ANOP
         ST    13,&SAVE+4             CHAIN UP TO HSA
         LA    15,&SAVE
         ST    15,8(13)               CHAIN DOWN TO LSA
         LR    13,15                  POINT TO SAVEAREA
         AGO   .CHKB
.REENT   ANOP
&RENTSW1 SETB  1         INDICATE REENTERANT SAVEAREA FOR LEAVE MACRO
         LR    14,1                   SAVE PTR TO PARAM LIST
         LR    15,0                   SAVE REG 0
         AIF   (T'&GETFAIL EQ 'O').UNCOND
         MNOTE '         GETMAIN RC,LV=72+&WKBYTES  REENT. SA FMT USED'
         GETMAIN RC,LV=72+&WKBYTES    GET 72 BYTES FOR SAVEAREA
         LTR   15,15                  TEST FOR SUCCESS
         BNZ   &GETFAIL
         AGO   .CHAIN
.UNCOND  MNOTE '         GETMAIN R,LV=72+&WKBYTES  REENTERANT SAVEAREA X
               FORMAT USED'
         GETMAIN R,LV=72+&WKBYTES     GET 72 BYTES FOR SAVEAREA
.CHAIN   ANOP
         ST    13,4(1)                CHAIN UP TO HSA
         ST    1,8(13)                CHAIN DOWN TO LSA
         LR    0,15                   RESTORE REG 0
         LR    13,1                   POINT TO SAVEAREA
         LR    1,14                   RESTORE REG 1
.*    SEE IF WE NEED TO BRANCH AROUND CONSTANTS:
.CHKB    AIF   (T'&SA NE 'O' OR '&RENT' EQ 'YES').MEND
         B     SAVE&NDX.+72           BRANCH AROUND SAVEAREA
SAVE&NDX DS    18F
.MEND    MEND
         MACRO
.*                                                      RON MURA, TPD
&LBL     ISPCALL &LIST,        CALL PARAMETERS                         X
               &EP=ISPLINK,                                            X
               &LISTLBL=,      LABEL FOR PARAMETER LIST (NON-REENT)    X
               &WKAREA=,       TO BUILD CALL LIST (REENTERANT CODE)    X
               &WKREG=,        WORK REGISTER (DEFAULT 1)               X
               &TRACE=         'OFF' OR BIT FOR TRACE MODE
.*  ONCE WKAREA, WKREG, AND TRACE ARE SPECIFIED, THEY ARE USED IN ALL
.*  SUBSEQUENT OCCURRENCES OF THIS MACRO, UNLESS THE PARAMETER IS
.*  EXPLICITLY CODED.
.*  NOTE: FIRST 4 BYTES OF WKAREA ARE USED TO STORE NUMERIC VALUES,
.*  WHICH ARE PRIMARILY LENGTH FIELDS.
         LCLA  &S,&T,&U,&TRCEMSK
         LCLB  &NUMSW
         LCLC  &NDX,&WKAR,&WKRG
         GBLC  &ISPRREG,&ISPRAR,&ISPTRC1
         GBLA  &ISPTRC2
&NDX     SETC  '&SYSNDX'
&S       SETA  1               SUBSCRIPT FOR GOING THRU &LIST
***********************************************************************
         AIF   (T'&LBL NE 'O').L1
*                  ISPCALL  -  INVOKE ISPF DIALOG SERVICES      ISPCALL
         AGO   .L2
.L1      ANOP
&LBL     DS    0H  ISPCALL  -  INVOKE ISPF DIALOG SERVICES      ISPCALL
.L2      ANOP
         AIF   (T'&LIST NE 'O').A1
         MNOTE 12,'*** ISPCALL PARAMETERS MUST BE PROVIDED ***'
         AGO   .EXIT
.A1      AIF   ('&LIST'(1,1) EQ '(').CHKTRCE
         MNOTE 12,'*** ISPCALL PARAMETERS MUST BE ENCLOSED IN PARENTHESX
               ES ***'
         AGO   .EXIT
.****************** ANALYZE "TRACE" PARAMETER *************************
.CHKTRCE AIF   (T'&TRACE EQ 'O' AND '&ISPTRC1' NE '').TRCE4
         AIF   (T'&TRACE EQ 'O' AND '&ISPTRC1' EQ '').TRCEOFF
         AIF   ('&TRACE'(1,1) EQ '(').TRCEON
         AIF   ('&TRACE' EQ 'OFF').TRCEOFF
         MNOTE 12,'*** INVALID TRACE PARAMETERS ***'
         AGO   .EXIT
.TRCEON  AIF   (T'&TRACE(2) EQ 'N').TRCE2
.TRCE8   MNOTE 12,'*** TRACE BIT (2ND PARAMETER) MUST BE 0 - 7 ***'
         AGO   .EXIT
.TRCE2   AIF   (&TRACE(2) GE 0 OR &TRACE(2) LE 7).TRCE3
         AGO   .TRCE8
.TRCE3   ANOP
&ISPTRC1 SETC  '&TRACE(1)'     SET GLOBAL VARIABLE
&ISPTRC2 SETA  &TRACE(2)       SET GLOBAL VARIABLE
.TRCE4   ANOP
&U       SETA  0
&TRCEMSK SETA  255
&T       SETA  128
.TRCE5   AIF   (&U GT 7).CHKREG
         AIF   (&ISPTRC2 NE &U).TRCE7
.TRCE6   ANOP
&U       SETA  &U+1
&T       SETA  &T/2
         AGO   .TRCE5
.TRCE7   ANOP
&TRCEMSK SETA  &TRCEMSK-&T
         AGO   .TRCE6
.TRCEOFF ANOP
&ISPTRC1 SETC  ''              SET GLOBAL VARIABLE
.****************** ANALYZE "WKREG" PARAMETER *************************
.CHKREG  AIF   (T'&WKREG EQ 'O').A2
&ISPRREG SETC  '&WKREG'        SET GLOBAL VARIABLE
.A2      AIF   ('&ISPRREG' EQ '').A3
&WKRG    SETC  '&ISPRREG'
         AGO   .CHKAREA
.A3      ANOP
&ISPRREG SETC  '1'             SET GLOBAL VARIABLE
         AGO   .A2
.****************** SEE IF USING PROVIDED WORKAREA ********************
.CHKAREA AIF   (T'&WKAREA NE 'O' OR '&ISPRAR' NE '').RENT
         AIF   (T'&LISTLBL EQ 'O').B1
&WKAR    SETC  '&LISTLBL'
         AGO   .B2
.B1      ANOP
&WKAR    SETC  'ISPC&NDX'      LABEL FOR MACRO WORKAREA
.B2      ANOP
&T       SETA  4*(N'&LIST+1)   LENGTH OF MACRO WORKAREA
         B     &WKAR.+&T             BRANCH AROUND DATA         ISPCALL
&T       SETA  N'&LIST+1
&WKAR    DC    &T.F'0'               PARAMETER LIST             ISPCALL
.******************** BUILD PARAMETER LIST ****************************
.LOOP    AIF   (&S GT N'&LIST).ENDLOOP
         AIF   ('&LIST(&S)'(1,1) EQ '''').C1 TEST FOR LITERAL
         AIF   (T'&LIST(&S) EQ 'N').NUM      TEST FOR NUMERIC
         AIF   ('&LIST(&S)'(1,1) EQ '(').REG TEST FOR REG NOTATION
         LA    &WKRG,&LIST(&S)       LOAD DATA ADDR             ISPCALL
.ST      ANOP
&T       SETA  4*&S
         ST    &WKRG,&WKAR.+&T       STORE IN PARAM LIST        ISPCALL
         AIF   ('&ISPTRC1' EQ '' OR &S GT 1).C3           TRACE
         TM    &ISPTRC1,&TRCEMSK     IS TRACE BIT ON?     TRACE ISPCALL
         BZ    ISPT&NDX                                   TRACE ISPCALL
         AIF   ('&WKRG' EQ '1' OR '&WKRG' EQ 'R1').C4     TRACE
         LR    1,&WKRG               LOAD SRVC NAME ADDR  TRACE ISPCALL
.C4      AIF   ('&LIST(&S)'(1,1) EQ '''').C5 LITERAL?     TRACE
         LA    0,8                   LOAD LENGTH          TRACE ISPCALL
         AGO   .C6                                        TRACE
.C5      ANOP                                             TRACE
&U       SETA  K'&LIST(&S)-2   LENGTH OF SERVICE NAME     TRACE
         LA    0,&U                  LOAD LENGTH          TRACE ISPCALL
.C6      ANOP                                             TRACE
         SVC   93                    ISSUE TPUT SVC       TRACE ISPCALL
ISPT&NDX EQU   *                                          TRACE ISPCALL
.C3      ANOP
&S       SETA  &S+1
         AGO   .LOOP
.C1      AIF   (&S EQ 1).C2    SPF SERVICE NAME - LENGTH IS OK
&T       SETA  K'&LIST(&S)-2
         AIF   (&T GT 7).C2    LENGTH 8 OR GREATER IS OK
&T       SETA  &T+1            ADD FOR ONE BLANK
         LA    &WKRG,=CL&T.&LIST(&S) LOAD DATA ADDR             ISPCALL
         AGO   .ST
.C2      ANOP
         LA    &WKRG,=C&LIST(&S)     LOAD DATA ADDR             ISPCALL
         AGO   .ST
.NUM     AIF   (&NUMSW).NUM2
.*  NOTE: SPF WILL MODIFY LENGTH FIELDS, SO THEY CANNOT BE IN
.*  REENTERANT CODE.
         MVC   &WKAR.(4),=F'&LIST(&S)'                                 X
                                     MOVE NUMERIC VALUE         ISPCALL
&NUMSW   SETB  1
         AGO   .LA
.NUM2    MNOTE 12,'*** ONLY ONE NUMERIC ALLOWED PER ISPCALL MACRO - LISX
               T ITEM &S --&LIST(&S)-- IS SECOND OCCURRENCE ***'
         AGO   .EXIT
.LA      ANOP
         LA    &WKRG,&WKAR           LOAD DATA ADDR             ISPCALL
         AGO   .ST
.REG     ANOP
&T       SETA  4*&S
         ST    &LIST(&S),&WKAR.+&T                              ISPCALL
         AGO   .C3
.******************** USING PROVIDED WORKAREA *************************
.RENT    AIF   (T'&WKAREA EQ 'O').RENT2
&ISPRAR  SETC  '&WKAREA'       SET GLOBAL VARIABLE
.RENT2   ANOP
&WKAR    SETC  '&ISPRAR'
         AGO   .LOOP
.****************** GENERATE STATEMENTS FOR CALL **********************
.ENDLOOP ANOP
         OI    &WKAR.+&T,X'80'       TURN ON VL BIT             ISPCALL
         LA    1,&WKAR.+4                                       ISPCALL
         L     15,=V(&EP)                                       ISPCALL
         BALR  14,15                                            ISPCALL
.EXIT    ANOP
***********************************************************************
         SPACE 2
         MEND
         MACRO
.*                                                      RON MURA, TPD
&LBL     SCANLINE &SEEK,      CHARS SOUGHT (IN QUOTES)                 X
               &RECADDR=,     START OF RECORD TO BE SEARCHED           X
               &STRTCOL=1,    STARTING COLUMN                          X
               &ENDCOL=71,    ENDING COLUMN                            X
               &FIND=,        BRANCH ADDRESS IF CHARS FOUND            X
               &NOFIND=,      BRANCH ADDRESS IF CHARS NOT FOUND        X
               &WKREG=15      WORK REGISTER
.*   THIS MACRO GENERATES REENTERANT CODE.
         LCLA  &WORK,&WORK2
         LCLB  &ERRSW,&RECSW
         LCLC  &NDX
&NDX     SETC  '&SYSNDX'       KEEP IN SHORT-NAMED FIELD FOR ALIGNMENT
         AIF   (T'&SEEK EQ 'O').ERR1
.CHK2    AIF   (T'&RECADDR EQ 'O').WARN1
.CHK4    AIF   (T'&FIND EQ 'O' AND T'&NOFIND EQ 'O').ERR2
.CHK5    AIF   (T'&STRTCOL NE 'N' OR T'&ENDCOL NE 'N').ERR3
         AIF   (&STRTCOL GT &ENDCOL).ERR4
         AIF   (&ERRSW EQ 1).MEND
         AIF   (&RECSW EQ 1).R3OK    BRANCH IF DEFAULT (REG 1)
         AIF   ('&RECADDR'(1,1) EQ '(').REG    CHECK FOR REG FORMAT
&LBL     LA    1,&RECADDR            LOAD RECORD ADDRESS
         AGO   .R3OK
.REG     AIF   ('&RECADDR(1)' EQ '1').R3OK
&LBL     LR    1,&RECADDR(1)         LOAD RECORD ADDRESS
.R3OK    ANOP
&WORK    SETA  &STRTCOL-1
         AIF   (&WORK EQ 0).SKPLA1   IF 0, LA IS NOT NEEDED
         LA    1,&WORK.(0,1)         POINT AT START LOCATION
.SKPLA1  ANOP
&WORK    SETA  &ENDCOL-&STRTCOL+1    NUMBER OF COLUMNS TO BE SEARCHED
&WORK2   SETA  K'&SEEK-2             ASSUME CHARACTER DATA - SET LENGTH
.*                                   (SUBTRACT 2 FOR QUOTES)
&WORK    SETA  &WORK-&WORK2+1        MAX NUMBER OF SEARCHES NEEDED
         LA    &WKREG,&WORK          LOAD MAX NUMBER OF SEARCHES
SCCL&NDX CLC   0(&WORK2,1),=C&SEEK
         AIF   (T'&FIND EQ 'O').FIND2
         BE    &FIND
         AGO   .LA
.FIND2   ANOP
         BE    SCEX&NDX
.LA      ANOP
         LA    1,1(0,1)              INCREMENT TO NEXT POSITION
         BCT   &WKREG,SCCL&NDX
         XR    1,1                   STRING NOT FOUND
         AIF   (T'&NOFIND EQ 'O').END
         B     &NOFIND
.END     ANOP
.*               NO NEED FOR SCEX LABEL IF FIND PROVIDED:
         AIF   (T'&FIND NE 'O').MEND
SCEX&NDX EQU   *                     END OF SCANLINE MACRO
         AGO   .MEND
.ERR1    MNOTE 12,'*** NO STRING TO BE FOUND SPECIFIED ***'
&ERRSW   SETB  1
         AGO   .CHK2
.WARN1   MNOTE *,'*** NO RECORD ADDR SPECIFIED - REG. 1 ASSUMED ***'
&RECSW   SETB  1
         AGO   .CHK4
.ERR2    MNOTE *,'*** NO FIND OR NOFIND ADDRESS GIVEN ***'
         AGO   .CHK5
.ERR3    MNOTE 12,'*** STRTCOL AND ENDCOL MUST BE NUMERIC ***'
         AGO   .MEND
.ERR4    MNOTE 12,'*** STRTCOL MAY NOT BE GREATER THAN ENDCOL ***'
         AGO   .MEND
.FIN     ANOP
.MEND    MEND
         MACRO
&NAME    SETAUTH &PASSWD
         AIF   (K'&PASSWD EQ 0).ERROR1
         AIF   ('&PASSWD' EQ 'ON').SWON
         AIF   ('&PASSWD' EQ 'OFF').SWOFF
         AIF   ('&PASSWD' EQ 'ON-IMS').SWONIMS
         MNOTE 12,'INVALID PASSWORD FOR SETAUTH MACRO'
         MEXIT
.ERROR1  MNOTE 12,'PASSWORD MISSING FOR SETAUTH MACRO'
         MEXIT
.SWON    ANOP
&NAME    L     0,=C'ON  '         PUT PASSWORD INTO REGISTER 0
         AGO   .COMMON
.SWOFF   ANOP
&NAME    L     0,=C'OFF '         PUT PASSWORD INTO REGISTER 0
         AGO   .COMMON
.SWONIMS ANOP
&NAME    L     0,=C'ONOK'         PUT PASSWORD INTO REGISTER 0
.COMMON  ANOP
         SVC   243
         MEND
***********************************************************************
* SPY USING ISPF/PDF DIALOG MANAGEMENT                                *
*  MODIFIED BY DAVE RIKER                                             *
*              COMPUTER DATA SYSTEMS INC                              *
*              ONE CURIE COURT                                        *
*              ROCKVILLE MD 20850                                     *
*              301 921 7036                                           *
*  SOURCE ORIGINATED CREDITS TO:                                      *
* SPY:    STEVE LANGLEY OF SOUTHERN CALIF EDISON AND                  *
* ISPF:   RON MURA OF JOHN HANCOCK MUTIUAL LIFE INS CO                *
*                                                                     *
***********************************************************************
*                                                                     *
*                                 S P Y                               *
*                                                                     *
*                               02/26/82                              *
*                                                                     *
*                       OPERATOR CONSOLE MONITOR                      *
*                                                                     *
*     THIS PROGRAM DISPLAYS THE CONTENTS OF ALL ACTIVE GRAPHIC        *
*     OPERATOR'S CONSOLES ON A TSO CRT. THE OPERATOR'S SCREEN CAN BE  *
*     EITHER A 327X OR A 370-168 INTEGRATED CONSOLE WITH 35 LINES.    *
*     THE TSO USER CAN USE ANY 327X TERMINAL.                         *
*                                                                     *
*     SPY MUST, ALAS, BE APF AUTHORIZED. THE OPERATOR CONSOLE BUFFERS *
*     AND CONTROL BLOCKS ARE NOW IN FETCH PROTECTED STORAGE. BE       *
*     SURE TO PLACE THE 'SPY' COMMAND IN IKJEFTE2 AND/OR IKJEFTE8     *
*     SO THAT IT WILL RETAIN APF AUTHORIZATION FROM TSO.              *
*                                                                     *
*     SPY GIVES A TSO USER THE CAPABILITY TO ENTER ANY                *
*     CONSOLE OPERATOR COMMAND. THIS FACILITY IN PROTECTED BY A       *
*     SIMPLE 3 CHARACTER PASSWORD (IN 1WORD) TO PREVENT YOU           *
*     FROM ENTERING AN OPERATOR COMMAND BY ACCIDENT. THE SYNTAX IS    *
*                                                                     *
*     JES COMMAND:  $...  ANY JES COMMAND ...                         *
*     OS COMMAND:   /...  ANY OS COMMAND ...  (THE / IS STRIPPED OFF) *
*                                                                     *
*     TYPING THE 3-LETTER VIP PASSWORD 'TOGGLES' THE VIP FLAG.        *
*     THIS FACILITY WORKS BY PASSING THE COMMAND TO THE COMMAND       *
*     PROGRAM AS A PARM, WHO IN TURN EXECUTES IT USING SVC 34.        *
*     SPY,COMMAND AND LINK MUST ALL BE APF AUTHORIZED IF THEY ARE     *
*     TO WORK PROPERLY IN CONCERT. NOTE THAT THE RESPONSE TO THE      *
*     COMMAND APPEARS ONLY ON THE SCREEN YOU ARE WATCHING AT THE      *
*     TIME. ALSO, YOUR COMMANDS HAVE THE SAME CONSOLE AUTHORITY       *
*     AS THE SCREEN YOU ARE WATCHING, INCLUDING THE MASTER CONSOLE!   *
*     THE MORAL BEING DON'T WATCH THE MASTER CONSOLE AND ACCIDENTALLY *
*     ENTER '/Q' OR SOMETHING LIKE THAT...                            *
*                                                                     *
*     THIS PROGRAM WILL PROBABLY REQUIRE BOTH THE SYS1.AMODGEN AND    *
*     SYS1.APVTMACS MACRO LIBRARIES TO ASSEMBLE PROPERLY.             *
*     SPY WAS DEVELOPED ON A 370/168 MVS RELEASE 3.7; THIS VERSION    *
*     WILL ONLY RUN ON MVS/SP1.3                                      *
*                                                                     *
*                        STEVE LANGLEY                                *
*                        SOUTHERN CALIF. EDISON                       *
*                        ROSEMEAD, CALIF   91770                      *
*                        213-572-3435                                 *
*                                                                     *
*                                                                     *
***********************************************************************
      EJECT
***********************************************************************
*                                                                     *
*                                                                     *
*  COMMAND     DESCRIPTION                             PF KEY         *
*                                                                     *
*     B        END SPY                                   3            *
*     C        SWITCH MONITOR TO CONSOLE 1               8            *
*     CXX      SWITCH MONITOR TO CONSOLE XX                           *
*     DXX      SET DELAY TO XX TENTHS SECONDS                         *
*     E        END SPY                                   3            *
*     F        FREEZE DISPLAY ON CURRENT PAGE           10            *
*     L        LINK TO SWAP PROGRAM (IF AVAILABLE)                    *
*     R        RELEASE DISPLAY                           5            *
*     S        STATUS OF ALL CONSOLES                                 *
*     W        START TIMER MODE FOR 30 SECONDS           6            *
*     WXX      START TIMER MODE FOR XX SECONDS                        *
*     W0       START TIMER MODE UNTIL INTERRUPT                       *
*     ?        DISPLAY THIS PAGE                         7            *
*     1        DISPLAY MODE 1                                         *
*     2        DISPLAY MODE 2                                         *
*     *        RESTORED PREVIOUS COMMAND                11            *
*                                                                     *
*  HITTING INTERRUPT WILL STOP THE WAIT TIMER                         *
*                                                                     *
*     DISPLAY MODES 1 AND 2 ARE ONLY USEFUL WHEN WATCHING A LARGE     *
*     35-LINE 3066 370-168 INTEGRATED CONSOLE FROM A 24-LINE 327X-2   *
*     TSO TERMINAL. THESE MODES ARE:                                  *
*                                                                     *
*     DISPLAY MODE 1 - PAGE 1 = TOP 22 LINES                          *
*                      PAGE 2 = BOTTOM 12 LINES                       *
*     DISPLAY MODE 2 - PAGE 1 = TOP 22 LINES                          *
*                      PAGE 2 = BOTTOM 22 LINES                       *
*                                                                     *
***********************************************************************
***********************************************************************
*   THUS, THE LINES ADDED TO ISR@PRIM LOOK LIKE:                      *
*                                                                     *
*     %  II +SPY/ISPF   - OPER CONSOLE USING DIALOG MGMT              *
*                                                                     *
*                    II,'PGM(ISP@SPY) PARM(ISPANEL) NOCHECK'
*                                                                     *
*       &ZTRAIL= .TRAIL
*                                                                     *
***********************************************************************
         SPACE 4
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         EJECT
ISP@SPY  CSECT
         B     40(R15)             BRANCH AROUND SAVE AREAS
         DC    CL9'ISP@SPY'           IDENTIFIER
         DC    CL9'&SYSDATE'
         DC    CL7'&SYSTIME'
         DC    CL11'VERSION 3.1'
PROLOG   STM   R14,R12,12(R13)    SAVE REGISTERS
         LR    R12,R15            R12 = ADDR OF ENTRY POINT
         USING ISP@SPY,R12            ADDRESABILITY TO CSECT
         LA    R11,4095(R12)      R11 WILL BE
         LA    R11,1(R11)         SECOND BASE REGISTER
         USING ISP@SPY+4096,R11
         LR    R14,R1              SAVE PARM PTR
         LR    R15,R0              SAVE REG 0
         GETMAIN RC,LV=72+(ENDDSECT-DSECT)  REENT
         LTR   R15,R15             TEST FOR CORE
         BNZ   NOCORE
         ST    R13,4(1)            CHAIN UP TO HSA
         ST    1,8(R13)            CHAIN DOWN TO HSA
         LR    0,R15
         LR    R13,1
         USING DSECT,R13
         ST    R13,SAVDSECT
         ST    R14,SAVEPARM
         MVI   CRTFLAG,X'FF'      WE ARE USING A ISPF CRT ALWAYS
         MVC   TPUTLEN(4),MOD2TPUT
         MVI   OPERPRM1,X'80'
         MVI   VIPFLG,X'FF'
         MVI   SLASH,C'/'
         MVC   HEADING,=C'C'
         MVC   PAUSE,=C'1.0'
         MVC   HEADING2(10),=C'M:F2 PAGE2'
         MVC   IPANEL(8),=CL8'ISPANEL'
         MVC   UNITXXX(4),=CL9' '
         MVC   SVCRCM(9),=CL9' '
         MVC   NOTR15(8),=CL9' '
         MVC   IERROR(8),=CL9' '
         MVC   CMND(2),=H'79'
         MVI   ISCERR,X'00'
         MVI   XUCMID,X'01'
         MVC   CONSOLE(4),=F'1'
         MVC   OLDCONS(4),=F'1'
         MVC   TIMER(4),=F'30'
         MVC   DELAY(4),=F'100'
         MVI   WAITFLG,X'00'      TURN OFF WAIT FLAG
         MVC   ANSWER(4),=F'0'
         MVC   NUMUCMS(2),=H'0'
         LA    R5,OPERCMDL
         ST    R5,OPERPRM          PARMLIST FOR 'COMMAND'
         LA    R5,OPERCN
         ST    R5,OPERPRM1
         MVI   OPERPRM1,X'80'
         LA    R5,ANSWER
*        EXTRACT MF=(E,EXTRPSCB)      YES..CHECK FOR OPER PRIVLEDGE
         EXTRACT (R5),'S',FIELDS=(PSB)
         L     R1,ANSWER
         USING PSCB,R1
                                  EJECT
*********************************************************************
*                                                                   *
*  CHECK USER AUTHORITY                                             *
*                                                                   *
*     THREE POSSIBLE AUTHORITITES                                   *
*                                                                   *
*     $     - DO ANYTHING WITH NO LOGGING                           *
*     L     - DO ANYTHING BUT LOG IT ALL                            *
*     BLANK - DO ALL BUT $ COMMANDS AND LOG IT ALL                  *
*                                                                   *
*********************************************************************
CHKOPER  TM    PSCBATR1,PSCBCTRL     OPER PRIV?
         BNO   DONE
         CLC   PSCBUSER(6),=C'DCMEJM'
         BE    SYSINIT
         CLC   PSCBUSER(3),=C'DOR'
         BE    LOGINIT
         B     DONE
LOGINIT  MVI   CMDALLOW,C'L'
         B     INITIAL
SYSINIT  MVI   CMDALLOW,C'$'
INITIAL  LA    R7,WTOLOG
         MVC   4(7,R7),PSCBUSER    SET UP TO LOG THE COMMAND
         DROP  R1
         EJECT
***********************************************************************
*                                                                     *
*                       PROGRAM INITIALIZATION                        *
*                                                                     *
***********************************************************************
         SR    R5,R5
         ST    R5,CPECB
         ST    R5,FLAGWORD
         STH   R5,CBUF+2
         LA    R5,84
         STH   R5,CBUF
         L     R1,SAVEPARM
         BAL   R14,INITSCAN       INITIALIZE IKJSCAN PARMLIST
         L     R1,SAVEPARM
         LM    R2,R3,0(R1)                LOAD ADDR OF TLD AND PARM
         L     R8,56(R2)                  LOAD ADDR OF TSI
         SH    R3,=H'2'                   BACKUP TO GET PARM LENGTH
         LH    R4,0(R3)                   LOAD PARM LENGTH
         ST    R13,DSECTR13               SAVE R13 FOR DISPLAY
         ST    R12,ISPQBASE               SAVE R12 FOR DISPLAY
         MVC   SI@002A(SIERR$-SI@002A$+L'SIERR$),SI@002A$
*                                         MOVE TO MODIFIABLE CORE
         MVI   SWITCHES,X'00'             INITIALIZE
         LTR   R4,R4                      ANY USER PARM PROVIDED?
         BZ    INITFLDS
         MVC   USERPARM,BLANKS
         CH    R4,=H'8'
         BNH   USRPRMOK
         LH    R4,=H'8'                   MAX. ALLOWABLE PARM LNTH IS 8
USRPRMOK SH    R4,=H'1'                   SUBTRACT 1 FOR EX
         EX    R4,MVC$                    MOVE IN USER PARM
         CLC   USERPARM(6),=C'NOCORE'
         BNE   CHANGESI
         B     NOCORE                     SIMULATE GETMAIN FAILURE
MVC$     MVC   USERPARM(1),2(R3)          MOVE USER PARM (EXECUTED)
         B     INITFLDS
CHANGESI EQU   *
*---------------------------------------------------------------------*
*  INITIALIZE FIELDS, GET LIST OF PROFILE VARIABLES NEEDED BY         *
*  SI@A, AND MAKE OTHER   VARIABLES AVAILABLE TO DIALOG:              *
*---------------------------------------------------------------------*
INITFLDS MVC   XOPT,BLANKS                INITIALIZE
         MVC   WOPT,BLANKS
*---------------------------------------------------------------------*
*  GET CONTENTS OF XOPT (ENTERED ON ISP@PRIM TO INVOKE THIS FUNCTION) *
*  AND DETERMINE IF A SUBOPTION WAS ENTERED (E.G., "SI.ST"):          *
*  (TELL SPF NOT TO QUIT WITH DIALOG ERROR ON VCOPY IN CASE USER      *
*  ENTERS A LONG--AND INVALID--SUBOPTION ON ISP@PRIM, WHICH WOULD     *
*  CAUSE A TRUNCATION ERROR ON VCOPY SERVICE.)                        *
*---------------------------------------------------------------------*
COPYXOPT ISPCALL ('CONTROL','ERRORS','RETURN'), DON'T QUIT IF ERROR    X
               WKAREA=WKAREA
         ISPCALL ('VCOPY','ZTRAIL',60,XOPT,'MOVE')
         ISPCALL ('CONTROL','ERRORS','CANCEL')  RESTORE TO DEFAULT
         SCANLINE '.',RECADDR=XOPT,ENDCOL=15,NOFIND=SINITST
         CLI   XOPT,X'40'                'SI. ' ENTERED?
         BE    SINITOPT                       YES - DON'T SKIP SEL PNL
*---------------------------------------------------------------------*
*  A SUBOPTION WAS ENTERED, SO
*                  SET WOPT VARIABLE TO SUBOPTION VALUE:              *
*---------------------------------------------------------------------*
         OI    SWITCHES,B'00000010'       SKIP SELECTION PANEL
         LA    R3,60                      LOAD ADDR LAST ALLOWABLE CHAR
         LA    R4,1(R1)                   R4 -> SUBOPTION
         LA    R5,WOPT
WOPTLOOP MVC   0(1,R5),0(R4)              MOVE CHAR INTO WOPT
         LA    R5,1(R5)                   POINT TO NEXT CHAR IN WOPT
         LA    R4,1(R4)                   POINT TO NEXT CHAR IN XOPT
WOPTBCT  BCT   R3,WOPTLOOP                KEEP ON UNLESS END OF XOPT
WOPTDONE ISPCALL ('VREPLACE','ZCMD',60,WOPT)  MAKE WOPT AVAIL TO FUNCT
SINITST  EQU   *
SINITOPT EQU   *                   SUBCOMMAND FLAG ON
         L     R1,=F'80'           PUT INITIAL SCREEN LENGTH OF 1
         LA    R2,VRARRAY
         LA    R3,23
SINTLOP  ST    R1,0(R2)
         LA    R2,4(,R2)           NEXT F FIELD
         BCT   R3,SINTLOP
         ISPCALL  ('VREPLACE','(ISCR01 ISCR02 ISCR03 ISCR04 ISCR05     X
               ISCR06 ISCR07 ISCR08 ISCR09 ISCR10 ISCR11 ISCR12 ISCR13 X
               ISCR14 ISCR15 ISCR16 ISCR17 ISCR18 ISCR19 ISCR20 ISCR21 X
               ISCR22 ISCR23)',VRARRAY,BLANKS)
         L     R1,540         TCBPTR
         L     R1,112(,R1)    TCBFSA
         L     R1,24(,R1)     R1 OF TCB
         L     R1,0(,R1)      TLD POINTER
         USING  TLD,R1
         CLC   TLDTBLID,=CL3'TLD'
         BNE   DONETLD
         CLC   TLDTCBP(4),540  MATCH TO PSA TCB
         BNE   DONETLD
         ST    R1,TLDPTR
*        GTSIZE ,                 GET SCREEN SIZE
         L     R0,TLDMPSLN      SCREEN LINES  FROM TLD
*        VARIED FROM SPLIT SCREEN OF ISPF
         S     R0,=F'3'         LESS FIRST THREE HEADINGS
         L     R1,TLDMPSWD      CHARACTERS PER LINES
***********************************************************************
*                                                                     *
*                       THIS TERMINAL IS A CRT                        *
*                                                                     *
***********************************************************************
CRT      STH   R0,LPSCREEN        R0 = LINES PER SCREEN
         STH   R1,CPLINE          R1 = CHARACTERS PER LINE
         CH    R0,=H'24'          IS USER ON A 3277?
         BE    FLSCREEN           YES, JUST CONTINUE
         MVI   MOD4FLG,X'FF'      SET 3278-4 FLAG ON
*ISPF    MVC   CMDCTRL(3),R41C1   ROW 41, COL 1
*ISPF    MVC   PHEADING(3),R42C1  ROW 42, COL 1
*ISPF    MVC   R24C1(3),R43C1     ROW 43, COL 1
FLSCREEN CLI   TESTFLAG,X'00'
         BNE   SKPTST3
         STFSMODE ON,INITIAL=YES  TURN ON VTAM FULL SCREEN MODE
         LA    R3,STAXLIST        R3 = ADDRESS OF STAX LIST MACRO
         STAX  ATTNEXIT,MF=(E,(3)) ATTN EXIT TRAP
SKPTST3  EQU   *
         B     BLDUCMS
***********************************************************************
*                                                                     *
*                    THIS TERMINAL IS A HARDCOPY                      *
*                                                                     *
***********************************************************************
HARDCOPY STSIZE SIZE=80           OTHERWISE, HARDCOPY; SET LSIZE=80
         MVI   CRTFLAG,X'00'      WE ARE USING A HARDCOPY
*ISPF    MVC   CMDCTRL(5),BLANKS  ZAP OUT 327X CNTRL CHARS
*ISPF    MVC   PHEADING(5),BLANKS ZAP OUT 327X CNTRL CHARS
*ISPF    MVC   HELP(14),BLANKS    ZAP OUT 327X CNTRL CHARS
         SPACE 3
***********************************************************************
*                                                                     *
*          BUILD A TABLE OF UCM ADDRESSES (ONE PER CONSOLE)           *
*                                                                     *
***********************************************************************
BLDUCMS  L     R4,CVTPTR          R4 = ADDR OF CVT
         USING CVT,R4
         L     R4,CVTCUCB         R4 = ADDR OF 'CUCB' (UCM BASE)
         DROP  R4
         USING UCM,R4
         LR    R2,R4              R2 = R4
         S     R2,=F'4'           R2 = ADDR OF ADDR OF UCM PREFIX
         L     R2,0(R2)           R2 = ADDR OF UCM PREFIX
         USING UCMPRFX,R2
         L     R5,UCMVEA          R5 = ADDR OF FIRST UCM ENTRY
         L     R6,UCMVEZ          R6 = LENGTH OF EACH UCM ENTRY
         L     R7,UCMVEL          R7 = ADDR OF LAST UCM ENTRY
         LA    R8,UCMTAB+16       R8 = ADDR OF UCMTAB
         L     R9,UCMTABE         R9 = ADDR OF END OF UCMTAB
         XR    R10,R10            R10 = 0 (NUMBER OF VALID UCMS)
UCMLOOP  ST    R5,0(R8)           SAVE UCM ADDRESS IN UCMTAB
         LA    R10,1(R10)         R10 = R10 + 1  (ONE MORE UCM)
         C     R5,UCMMCENT        IS THIS UCM THE MASTER CONSOLE UCM?
         BNE   UCMNEXT            NO;  GO LOOK AT NEXT UCM ENTRY
         ST    R10,CONSOLE        YES; LOOK AT THIS ONE FIRST
UCMNEXT  LA    R8,16(R8)          R8 = ADDR OF NEXT UCMTAB ENTRY
         CR    R8,R9              DOES R8 POINT PAST END OF UCMTAB?
         BNL   UCMFULL            YES; LEAVE LOOP
         AR    R5,R6              R5 = ADDR OF NEXT UCM ENTRY
         CR    R5,R7              DOES R5 POINT PAST UCM ENTRIES?
         BL    UCMLOOP            NO; KEEP GOING
         B     UCMDONE            YES; TABLE COMPLETE
UCMFULL  MVC   ERROR(26),ERRMSG5  UCM TABLE TOO SMALL
         MVI   ISCERR,X'FF'
UCMDONE  STH   R10,NUMUCMS        SAVE NUMBER OF UCMS FOUND
         MVC   CONSOLE(4),=F'10'  MAKE DEFAULT CONSOLE = 10
         DROP  R2,R4
         SPACE 3
***********************************************************************
*                                                                     *
*         HERE WE GO... USE MODESET TO PUT US IN KEY 0                *
*                                                                     *
***********************************************************************
SETAUTH  DS    0H                                                  SP3
         CLI   TESTFLAG,X'00'
         BNE   SKPTST4
*                                                              AEI SP3
         SETAUTH ON                                            DST SP3
*                                                              AEI SP3
         MODESET MODE=SUP                                          SP3
         ESAR  R5                   GET SEC ASID                   SP3
         ST    R5,SASID             KEEP IT                        SP3
         AXSET AX=ONE               SET AX TO ALLOW SSAR           SP3
         GETMAIN R,LV=820           GETMAIN AREA FOR TDCM          SP3
         ST    R1,LOCDCM            SAVE THE ADDRESS               SP3
SKPTST4  EQU   *
         EJECT
***********************************************************************
*                                                                     *
*                            TOP OF LOOP                              *
*              LOCATE SCREEN BUFFER AND PREPARE TO TPUT               *
*                                                                     *
***********************************************************************
NEXTPAGE CLI   ATTNFLG,X'00'      WAS ATTN HIT?
         BE    NOATTN             NO
*                                 ATTENTION KEY HIT; PROCESS IT
         MVI   ATTNFLG,X'00'      YES, RESET FLAG
         MVC   TIME(3),BLANKS     BLANK OUT TIMER FIELD
         MVI   WAITFLG,X'00'      TURN OFF WAIT FLAG
         XC    TIMER,TIMER        SET TIMER TO 0
NOATTN   EQU   *
         LA    R5,UCMTAB          R5 = ADDR OF UCMTAB
         L     R4,CONSOLE         R4 = CONSOLE TO BE DISPLAYED
         CH    R4,NUMUCMS         IS NUMBER TOO HIGH?
         BNH   GETUCM             NO, CONTINUE
RESETCN  MVC   ERROR(26),ERRMSG1  CONSOLE UNDEFINED
         MVI   ISCERR,X'FF'
RESETCN1 L     R4,OLDCONS         RESET TO OLD CONSOLE
         ST    R4,CONSOLE         AND SAVE IT
GETUCM   SLL   R4,4               MULTIPLY BY 16
         LA    R5,0(R5,R4)        R5 = ADDR OF ADDR OF UCM
         LR    R1,R5              R1 = ADDR OF UCMTAB ENTRY
         L     R5,0(R5)           R5 = ADDR OF UCM
         USING UCMLIST,R5
         L     R6,UCMXB           R6 = ADDR OF RDCM
         USING DCMTSRT,R6
         LTR   R6,R6              IS THIS A GRAPHICS CONSOLE?
         BP    GRAPHICS           YES
***********************************************************************
*                                                                     *
*       THIS IS NOT AN OPERATOR GRAPHIC CONSOLE - GIVE ERRMSG4        *
*                                                                     *
***********************************************************************
         LA    R5,UCMTAB          R5 = ADDR OF UCMTAB
         MVC   ERROR(26),ERRMSG4  NON-GRAPHIC CONSOLE
         MVI   ISCERR,X'FF'
         B     RESETCN1           RESET THE CONSOLE NUMBER
***********************************************************************
*                                                                     *
*   THIS IS A GRAPHIC CONSOLE - BUILD TRAILER LINE WITH CONSDATA      *
*                                                                     *
***********************************************************************
GRAPHICS EQU   *
         BAL   R14,CONSDATA       CALL CONSDATA RTN
         SPACE
*       SETUP TO COPY PAGEABLE DCM TO OUR ADDRESS SPACE            SP3
         L     R5,DCMADTRN        ADDR OF TDCM - 'FROM' FOR MVCP   SP3
         LA    R7,CONASID         GET 'CONSOLE' ASID               SP3
         SSAR  R7                 SET CONSOLE AS SECONDARY         SP3
         L     R7,LOCDCM          'TO' ADDR FOR MVCP               SP3
         LA    R3,820             LENGTH TO MOVE                   SP3
         SR    R15,R15            'FROM' KEY                       SP3
MOVEDCM  MVCP  0(R3,R7),0(R5),R15  MOVE IT                         SP3
         BZ    DCMMOVED                                            SP3
         LA    R5,256(R5)         BUMP 'FROM' ADDR                 SP3
         LA    R7,256(R7)         BUMP 'TO' ADDR                   SP3
         SH    R3,=H'256'         DECREMENT TRUE LENGTH            SP3
         B     MOVEDCM            GO GET THE REST                  SP3
         SPACE
DCMMOVED L     R5,SASID           RESTORE PREVIOUS SECONDARY -     SP3
         SSAR  R5                 SHOULD BE SAME AS PRIMARY        SP3
         L     R7,LOCDCM          ADDR OF OUR COPY                 SP3
         USING DCMSTRT,R7
         SPACE
***********************************************************************
*                                                                     *
*    FILLIN OPERATORS COMMAND INPUT BUFFER AND SET VIP FLAG INDICATOR *
*                                                                     *
***********************************************************************
         MVC   LASTLINE(79),DCMINPUT MOVE IN INPUT BUFFER LINE
         MVI   MODE+1,C' '        BLANK OUT VIP INDICATOR
         CLI   VIPFLG,X'FF'       IS THE VIP FLAG ON?
         BNE   CHKINTEG           NOPE
         MVI   MODE+1,C'*'        TURN ON VIP INDICATOR
***********************************************************************
*                                                                     *
*                         CHECK CONSOLE TYPE                          *
*                                                                     *
***********************************************************************
CHKINTEG MVI   INTEGFLG,X'FF'     TURN ON 3066 CONSOLE FLAG
         CLC   DCMMSGAL(2),=H'30' IS THIS REALLY A 3066 CONSOLE?
         BE    CHKMODEL           YES; CHK IF IT WILL FIT ON OUR TERM
         MVI   INTEGFLG,X'00'     NO; TURN OFF 3066 CONSOLE FLAG
*        CLC   DCMMSGAL(2),=H'20' IS THIS 327X-2 TYPE CONSOLE?     AEI
*        BNE   NOTSUPRT           NO;  NOT SUPPORTED, SO ABEND     AEI
         MVI   FREEZE,C'F'        YES; FREEZE DISPLAY
         MVI   PAGE,C'1'               ON PAGE 1 OF USER'S CRT
         MVC   TPUTLEN(4),MOD2TPUT SET TPUT LENGTH FOR SHORT SCREEN
         B     MOD2               AND TREAT USER AS MOD2 FOR NOW
***********************************************************************
*                                                                     *
*        THIS OPERATOR'S CONSOLE IS NEITHER A 24-LINE 327X-2 NOR      *
*        A 35-LINE 3066 270-168 INTEGRATED CONSOLE, SO ABEND.         *
*                                                                     *
***********************************************************************
NOTSUPRT LA    R1,ERRMSG6         R1 = ADDR OF STRING TO TPUT
         LA    R0,26              R0 = LENGTH OF TPUT
         ISPCALL ('VREPLACE','IUNIT',26,ERRMSG6),WKAREA=ISPC
         ISPCALL ('DISPLAY',IPANEL,IERROR)
         ABEND 999
***********************************************************************
*                                                                     *
*     THIS IS A 35-LINE 3066 OPERATORS CONSOLE. IF THE USER HAS A     *
*     43-LINE 3278-4 THERE IS NO PROBLEM, THE WHOLE THING CAN BE      *
*     DISPLAYED AT ONCE. HOWEVER, IF THE USER HAS A 24-LINE 327X-2    *
*     WE WILL HAVE TO BREAK THE DISPLAY INTO 2 PAGES SO IT WILL FIT.  *
*                                                                     *
***********************************************************************
CHKMODEL CLI   MOD4FLG,X'FF'      IS THIS A 3278-4? (43 LINES)
         BNE   MOD2               NO - MUST BE A MOD2 (24 LINES)
***********************************************************************
*                                                                     *
*                  USER HAS A 43-LINE 3278-4 CRT                      *
*                                                                     *
*        WE CAN JUST FREEZE HIS DISPLAY ON 'PAGE 1' AND CONTINUE      *
*                                                                     *
***********************************************************************
         MVI   FREEZE,C'F'        FREEZE DISPLAY
         MVI   PAGE,C'1'          ON PAGE 1 INITIALLY
         MVC   TPUTLEN(4),MOD4TPUT SET LENGTH FOR FULL 3278-4 SCREEN
         L     R8,DCMASCRN        R8 = ADDR OF SCREEN BUFFER + 6
         LA    R4,BUF             R4 = ADDR OF OUTPUT BUFFER
         LA    R5,M4BUFLEN        R5 = 3278-4 BUFFER LEN (35 LINES)
         LA    R9,M4BUFLEN        R9 = 3278-4 BUFFER LEN (35 LINES)
         B     MOVEBUFF
***********************************************************************
*                                                                     *
*                  USER HAS A 24-LINE 327X-2 CRT                      *
*                                                                     *
*        THIS OPER CONSOLE WILL HAVE TO BE DISPLAYED IN TWO SEGMENTS  *
*        OR 'PAGES' SINCE 35 LINES WON'T FIT IN THIS 24 LINE TUBE.    *
*                                                                     *
***********************************************************************
MOD2     CLI   PAGE,C'1'          ARE WE ON PAGE 1?
         BNE   ONTWO              NO, SO WE MUST BE ON 2
         CLI   FREEZE,C'F'        ARE WE FROZEN ON PAGE 1?
         BNE   PAGE2              NO, SO DISPLAY PAGE 2
         B     PAGE1              YES, SO DISPLAY PAGE 1
ONTWO    CLI   FREEZE,C'F'        ARE WE FROZEN ON PAGE 2?
         BE    PAGE2              YES, SO DISPLAY PAGE 2
PAGE1    MVI   PAGE,C'1'          PAGE = 1
         L     R8,DCMASCRN        R8 = ADDR OF SCREEN IMAGE BUFFER + 6
         LA    R4,BUF             R4 = ADDR OF OUTPUT BUFFER
         LA    R5,M2BUFLEN        R5 = LENGTH OF OUTPUT BUF (21 LINES)
         LA    R9,M2BUFLEN        R9 = CONSOLE BUFFER LEN   (21 LINES)
         S     R8,=F'6'           GET ATTRIBUTE BYTE
         B     MVETRAIL           GO MOVE THE BUFFER
PAGE2    MVI   PAGE,C'2'          PAGE = 2
         L     R8,DCMASCRN        R8 = ADDR OF SCREEN IMAGE BUFFER + 6
         CLI   MODE,C'2'          ARE WE IN DISPLAY MODE 2?
         BE    DMODE2             YES, BRANCH TO DMODE2
DMODE1   LA    R8,LEN22(R8)       MOVE POINTER DOWN 23 LINES
         LA    R9,LEN13           R9 = LENGTH OF LAST 12 LINES
         B     CONTINUE           JUMP AROUND MODE 2 DISPLAY
DMODE2   LA    R8,LEN9(R8)        MOVE POINTER DOWN 9 LINES
         LA    R9,LEN21           R9 = LENGTH OF SOURCE BUFFER
CONTINUE LA    R4,BUF             R4 = ADDR OF OUTPUT BUFFER
         LA    R5,M2BUFLEN        R5 = LENGTH OF OUTPUT BUFFER
*MVETRAIL MVC   ENDMOD2(TRAILEN),CMDCTRL MOVE IN TRAILER
MVETRAIL EQU    *
         SPACE
***********************************************************************
*                                                                     *
*               MOVE THE SCREEN IMAGE BUFFER INTO BUF                 *
*                                                                     *
***********************************************************************
MOVEBUFF STM   R4,R9,MOVEBSAV     KEEP REGS                        SP3
*        SETUP TO COPY CONSOLE BUFFER TO OUR ADDRESS SPACE.        SP3
*        FIRST FILL AREA WITH SPACES                               SP3
         L     R9,=X'40000000'    MAKE BLANK THE PAD, LENGTH =0    SP3
         LA    R8,*               NOT THAT IT REALLY MATTERS       SP3
         MVCL  R4,R8              PAD WITH SPACES                  SP3
         SPACE
         LA    R4,CONASID         GET 'CONSOLE' ASID               SP3
         SSAR  R4                 SET 'CONSOLE' AS SECONDARY       SP3
         LM    R4,R9,MOVEBSAV     GET BACK ADDRESSES, LENGTHS      SP3
         SR    R15,R15            'FROM' KEY                       SP3
MOVEBFR  MVCP  0(R9,R4),0(R8),R15 MOVE IT                          SP3
         BZ    BFRMOVED           GET OUT WHEN ALL MOVED           SP3
         LA    R8,256(R8)         BUMP FROM ADDR                   SP3
         LA    R4,256(R4)         BUMP TO ADDR                     SP3
         SH    R9,=H'256'         DECREMENT TRUE LENGTH            SP3
         B     MOVEBFR            GET THE REST                     SP3
         SPACE
BFRMOVED L     R4,SASID           RESTORE PREVIOUS SECONDARY -     SP3
         SSAR  R4                 SHOULD BE SAME AS PRIMARY.       SP3
         SPACE 2
         DROP  R5,R6,R7
*        CLI   CRTFLAG,X'FF'      IS THIS A CRT?
         EJECT
TPUTCRT  LA    R1,BUF             R1 = ADDR OF OUTPUT STREAM
         L     R0,TPUTLEN         R0 = LENGTH OF TPUT
         LA    R5,18              R5 = NO LINES IN A SCREEN
*        ICM   R1,8,FULLSCR       SET ASIS TYPE FOR TPUT
         BAL   R14,WRITE          DO A TPUT; DISPLAY ENTIRE SCREEN
         SPACE 3
***********************************************************************
*                                                                     *
*      IF WE ARE IN WAIT MODE SO A STIMER FOR THE NECESSARY LENGTH    *
*      OF TIME, THEN CALCULATE AND DISPLAY THE NEW TIMER COUNT.       *
*      IF COUNT HAS HIT ZERO, TURN OFF WAIT FLAG.                     *
*                                                                     *
***********************************************************************
CHKWAIT  MVC   ERROR(66),BLANKS   BLANK OUT ERROR FIELD
         MVI   ISCERR,X'00'
         CLI   WAITFLG,X'FF'      IS THE WAIT FLAG ON?
         BNE   READCHAR           NO, SO GO GET A COMMAND
         STIMER WAIT,BINTVL=DELAY WAIT FOR DELAY * .01 SECONDS
         L     R2,TIMER           R2 = CURRENT VALUE OF TIMER
         BCTR  R2,0               TIMER = TIMER - 1
         ST    R2,TIMER           STORE NEW VALUE OF TIMER
         CVD   R2,WORK            CONVERT TO DECIMAL.
         MVC   SCRATCH(4),PATTERN MOVE IN EDIT PATTERN
         ED    SCRATCH(4),WORK+6  EDIT IN CONSOLE NUMBER
         MVC   TIME(3),SCRATCH+1  MOVE TIME LEFT INTO PLACE
         LTR   R2,R2              HAS TIMER HIT ZERO?
         BNZ   NEXTPAGE           NO, CONTINUE TO COUNT
         MVC   TIME(3),BLANKS     CLEAR COUNTER FIELD
         XI    WAITFLG,X'FF'      TOGGLE WAIT FLAG OFF
         B     NEXTPAGE           AND GO ON AS IF NOTHING HAPPENED..
         EJECT
***********************************************************************
*                                                                     *
*                       READ COMMAND FROM USER                        *
*                                                                     *
***********************************************************************
READCHAR EQU   *
         MVC   REPLY(79),BLANKS   BLANK OUT REPLY FIELD
*        TGET  REPLY,79           GET 79 CHARACTERS FROM TERMINAL
         MVC   REPLY(60),WOPT      REPLAY
         ISPCALL ('VREPLACE','ZCMD',60,BLANKS)
***********************************************************************
*                                                                     *
*               CHECK FOR SYSTEM OPERATOR COMMANDS                    *
*                                                                     *
***********************************************************************
         CLI   VIPFLG,X'FF'       ARE WE IN VIP MODE?
         BNE   PARSECMD           NO, SO CONTINUE
OPER     CLI   REPLY,C'/'         IS THIS AN OS OPERATOR COMMAND?
         BNE   JES                NO, CHECK FOR JES CMD
         MVC   OPERCMD(79),REPLY+1 YES; QUIT AND BLANK OUT REPLY FIELD
         MVI   OPERCMD+79,C' '    BLANK OUT COLUMN 80
         B     DOCMD              BRANCH TO COMMAND AND SVC34
JES      CLI   REPLY,C'$'         IS THIS A JES COMMAND?
         BNE   PARSECMD           NO, CONTINUE
         MVC   SCRATCH(3),REPLY   SAVE 3 CHARS OF REPLY
         OC    SCRATCH(3),BLANKS  CONVERT TO UPPER CASE
         CLC   SCRATCH(3),=CL3'$TA' IS THIS A $TA COMMAND?
         BE    CMDOKAY              YES; COMMAND IS OKAY
         CLC   SCRATCH(2),=CL2'$T'  IS THIS A $TX COMMAND?
         BE    CMDOKAY              YES; COMMAND IS RESTRICTED
         CLC   SCRATCH(3),=CL3'$VS' IS THIS A $VS COMMAND?
         BNE   CMDOKAY            NO;  COMMAND IS OKAY
CMDRSTR  MVC   ERROR(26),ERRMSG7  YES; PUT IN ERROR MESSAGE
         MVI   ISCERR,X'FF'
         B     NEXTPAGE           AND CONTINUE ON
CMDOKAY  MVC   OPERCMD(80),REPLY  MOVE CMD IN FROM REPLY FIELD
DOCMD    MVC   REPLY(80),BLANKS   BLANK OUT REPLY FIELD
         LA    R3,OPERCMD+79      R3 = ADDR OF LAST COLUMN
         LA    R1,OPERCMD         R1 = ADDR OF FIRST COLUMN
NXTCHAR  CLI   0(R3),C' '         IS THIS A BLANK?
         BNE   LASTCHAR           NO; THIS IS LAST CHAR IN CMD
         BCTR  R3,0               R3 = R3 - 1
         CR    R3,R1              IS WHOLE THING BLANK?
         BL    NEXTPAGE           YES; SOMETHING WRONG, BUT CONT ANYWAY
         B     NXTCHAR            NO;  GO LOOK AT NEXT CHAR
LASTCHAR SR    R3,R1              R3 = R3- R1
         LA    R3,1(R3)           R3 = R3 + 1
         STH   R3,OPERCMDL        SAVE CMD LENGTH
         L     R3,SAVEUPT         R3 = ADDR OF UPT
         USING UPT,R3
         NI    UPTSWS,X'FF'-UPTWTP TURN OFF 'WTP'
         MVC   OPERCN(4),CONSOLE  SAVE CONSOLE ID IN COMMAND PARMS
         LA    R1,OPERPRM         R1 = ADDR OF PARMLIST FOR 'COMMAND'
         LINK  EP=COMMAND         EXECUTE OPERATOR COMMAND
         OI    UPTSWS,UPTWTP      TURN ON  'WTP'
         B     NEXTPAGE
***********************************************************************
*                                                                     *
*          CONVERT COMMAND TO UPPER CASE AND CALL IKJSCAN             *
*                                                                     *
*    THIS CALL TO IKJSCAN IS COMPLETELY UNNECESSARY TO THE OPERATION  *
*    OF SPY. IT IS INCLUDED SOLELY TO ALLOW THE 'X' FEATURE OF        *
*    PCF2 TO OPERATE. IF YOU DO NOT HAVE PCF2, THIS COULD BE REMOVED. *
*                                                                     *
***********************************************************************
PARSECMD OC    REPLY(79),BLANKS   CONVERT CHARS TO UPPER CASE
         XC    CBUF+2(2),CBUF+2   CLEAR OFFSET
         MVC   CSPLBLOK(24),CSPLSAVE  COPY IN CSPL BLOK
         XC    CSOABLOK(8),CSOABLOK
*        L     R2,SAVEJSCB        R2 = ADDR OF OUR JSCB        AEI SP3
*        USING IEZJSCB,R2                                      AEI SP3
*        NI    JSCBOPTS,X'FF'-JSCBAUTH TAPF OFF FOR PCFSCAN    AEI SP3
         LA    R1,CSPLBLOK        R1 = ADDR OF CMD SCAN PARM LIST
         L     R15,ADDRSCAN       R15 = ADDR OF IKJSCAN
         BALR  R14,R15            INVOKE IKJSCAN
*        OI    JSCBOPTS,JSCBAUTH  TURN ON APF BIT AGAIN        AEI SP3
*        DROP  R2                                              AEI SP3
         LA    R1,CSOABLOK        R1 = ADDR OF CMD SCAN OUTPUT AREA
         USING CSOA,R1
         TM    CSOAFLG,CSOANOC    IS THE BUFFER EMPTY?
         BO    NEXTPAGE           YES; JUST GO REFRESH
         DROP  R1
***********************************************************************
*                                                                     *
*                       W  --  ENTER WAIT MODE                        *
*                                                                     *
***********************************************************************
CWAIT    CLI   REPLY,C'W'         DO WE SHIFT TO WAIT MODE?
         BNE   CDELAY             NO, SO CONTINUE
         XI    WAITFLG,X'FF'      TURN ON WAIT FLAG
         LA    R2,30              SET DEFAULT VALUE = 30
         LA    R15,CONVBIN        BRANCH TO CONVERSION RTN
         BALR  R14,R15            EBCDIC TO BINARY
         MVC   SCRATCH(4),PATTERN MOVE IN EDIT PATTERN
         ED    SCRATCH(4),WORK+6  EDIT IN CONSOLE NUMBER
         MVC   TIME(3),SCRATCH+1  MOVE TIME LEFT INTO PLACE
         ST    R2,TIMER           STORE STARTING TIMER VALUE
         B     NEXTPAGE           ALL SET - GO DISPLAY NEXT PAGE
***********************************************************************
*                                                                     *
*            D  --  SET TIMER DELAY IN TENTHS OF A SECOND             *
*                                                                     *
***********************************************************************
CDELAY   CLI   REPLY,C'D'         ARE WE CHANGING THE TIME DELAY?
         BNE   CCONSOLE           NO, SO CONTINUE
         LA    R2,10              SET DEFAULT VALUE = 10 TENTHS SECOND
         LA    R15,CONVBIN        BRANCH TO CONVERSION RTN
         BALR  R14,R15            EBCDIC TO BINARY
         MVC   SCRATCH(5),DPATTRN MOVE IN EDIT PATTERN
         ED    SCRATCH(5),WORK+6  EDIT IN DELAY TIME
         MVC   PAUSE(3),SCRATCH+2 MOVE TIME LEFT INTO PLACE
         MH    R2,=H'10'          CONVERT TO 100THS OF A SECOND
         ST    R2,DELAY           STORE WAIT DELAY VALUE
         B     NEXTPAGE           ALL SET - GO DISPLAY NEXT PAGE
***********************************************************************
*                                                                     *
*                    C  --  SET CONSOLE NUMBER                        *
*                                                                     *
***********************************************************************
CCONSOLE CLI   REPLY,C'C'         DO WE CHANGE CONSOLES?
         BNE   BYE                NO, SO CONTINUE
         L     R2,CONSOLE         SET DEFAULT CONSOLE
         ST    R2,OLDCONS         SAVE OLD CONSOLE #
         LA    R15,CONVBIN        BRANCH TO
         BALR  R14,R15            EBCDIC->BINARY CONVERTOR
         ST    R2,CONSOLE         STORE R2 AWAY AS CONSOLE NUMBER
         B     NEXTPAGE           CONTINUE
***********************************************************************
*                                                                     *
*                        B  --  TERMINATE SPY                         *
*                                                                     *
***********************************************************************
BYE      CLI   REPLY,C'B'         IS IT A 'B'?
         BE    DONE               YES, SO QUIT
***********************************************************************
*                                                                     *
*                        E  --  TERMINATE SPY                         *
*                                                                     *
***********************************************************************
END      CLI   REPLY,C'E'         IS IT AN 'E'?
         BE    DONE               YES, SO QUIT
***********************************************************************
*                                                                     *
*               F  --  FREEZE DISPLAY ON CURRENT PAGE                 *
*                                                                     *
***********************************************************************
F        CLI   REPLY,C'F'         IS IT AN 'F'?
         BNE   R                  NO, SO CONTINUE ON
         MVI   FREEZE,C'F'        TURN ON FREEZE INDICATOR
         B     NEXTPAGE           CONTINUE
***********************************************************************
*                                                                     *
*           R  --  RELEASE FREEZE ON CURRENT PAGE DISPLAY             *
*                                                                     *
***********************************************************************
R        CLI   REPLY,C'R'         IS IT AN 'R'?
         BNE   MODE1              NO, SO CONTINUE ON
         MVI   FREEZE,C'R'        TURN OFF FREEZE INDICATOR
         B     NEXTPAGE           CONTINUE
***********************************************************************
*                                                                     *
*                1  --  SHIFT TO MODE 1 TYPE DISPLAY                  *
*                                                                     *
***********************************************************************
MODE1    CLI   REPLY,C'1'         DO WE SHIFT TO MODE 1 DISPLAY?
         BNE   MODE2              NO, SO CONTINUE
         MVI   MODE,C'1'          SET MODE INDICATOR
         B     NEXTPAGE
***********************************************************************
*                                                                     *
*                2  --  SHIFT TO MODE 2 TYPE DISPLAY                  *
*                                                                     *
***********************************************************************
MODE2    CLI   REPLY,C'2'         DO WE SHIFT TO MODE 2 DISPLAY?
         BNE   GETHELP            NO, SO CONTINUE
         MVI   MODE,C'2'          SET MODE INDICATOR
         B     NEXTPAGE
***********************************************************************
*                                                                     *
*           ?  --  LIST HELP FOR SPY COMMANDS ON TERMINAL             *
*                                                                     *
***********************************************************************
GETHELP  CLI   REPLY,C'?'         IS HE ASKING FOR HELP?
         BNE   GETSTAT            NO,SO CONTINUE
         LA    R1,HELP            R1 = ADDR OF HELP PAGE
         LA    R0,HLENGTH         R0 = LENGTH OF HELP PAGE
         LA    R5,20              R5 = NO LINES IN A SCREEN
*        ICM   R1,8,FULLSCR       INSERT ASIS CNTL CHARS
         BAL   R14,WRITE          DO A TPUT; DISPLAY HELP
         B     READCHAR
***********************************************************************
*                                                                     *
*           S  --  LIST STATUS PAGE FOR ALL DEFINED CONSOLES          *
*                                                                     *
***********************************************************************
GETSTAT  CLI   REPLY,C'S'         IS HE ASKING FOR STATUS REPORT?
         BNE   SWAPLINK           NO; CONTINUE
         BAL   R14,CLRBUF         CLEAR BUFFER
         LH    R10,NUMUCMS        R10 = NUMBER OF CONSOLES
         LA    R2,UCMTAB+16       R2 = ADDR OF FIRST CONSOLE ENTRY
         XR    R4,R4              CLEAR R4
         LA    R4,BUF             R4 = ADDR OF TPUT BUFFER
         LA    R3,23              R3 = NUMBER OF LINES ON SCREEN
STLOOP   LR    R1,R2              R1 = ADDR OF UCMTAB ENTRY
         BAL   R14,CONSDATA       CALL CONSOLE DATA ROUTINE
         MVC   0(45,R4),CONNUM    SAVE RESULTS IN BUFFER
         LA    R4,80(R4)          R4 = ADDR OF NEXT LINE IN BUFFER
         LA    R2,16(R2)          R2 = ADDR OF NEXT UCMTAB ENTRY
         BCT   R3,NOTFULL         BRANCH IF THE SCREEN NOT FULL
FULL     LA    R1,HEADER          R1 = ADDR OF TPUT BUF
         LA    R0,STATLEN         R0 = LENGTH OF TPUT BUF
         SR    R5,R5
         LA    R5,23              R5 = NO LINES IN A SCREEN
*        ICM   R1,8,FULLSCR       INSERT ASIS CNTL CHARS
         BAL   R14,WRITE80        DO A TPUT; DISPLAY STATUS PAGE
         BAL   R14,CLRBUF         CLEAR BUFFER
         LA    R4,BUF             R4 = ADDR OF TPUT BUFFER
         LA    R3,23              R3 = NUMBER OF LINES ON SCREEN
         BCT   R10,MORE           MORE ENTRIES?
         B     NEXTPAGE           NO; CONTINUE
*MORE    TGET  REPLY,1            PAUSE FOR ENTER
MORE     MVC   REPLY(80),WOPT     PAUSE FOR ENTER
         B     STLOOP             AND LOOP
NOTFULL  BCT   R10,STLOOP         LOOP IF MORE
         LA    R1,HEADER          R1 = ADDR OF TPUT BUF
         LA    R0,STATLEN         R0 = LENGTH OF TPUT BUF
         SR    R5,R5
         LH    R5,NUMUCMS         R5 = NO LINES IN A SCREEN
*        ICM   R1,8,FULLSCR       INSERT ASIS CNTL CHARS
         BAL   R14,WRITE80        DO A TPUT; DISPLAY STATUS PAGE
         MVC   REPLY(80),WOPT     PAUSE FOR ENTER
*        TGET  REPLY,1            PAUSE FOR ENTER
         B     NEXTPAGE
***********************************************************************
*                                                                     *
*                    L  --  LINK TO SWAP PROGRAM                      *
*                                                                     *
***********************************************************************
SWAPLINK CLI   REPLY,C'L'         SHOULD WE XCTL TO SWAP?
         BNE   VIP                NO, SO CONTINUE
         CLI   TESTFLAG,X'00'
         BNE   SKPTST5
         MODESET MODE=PROB        DON'T NEED SUP STATE ANYMORE
SKPTST5  EQU   *
         L     R13,SAVEAREA+4         CALLERS SAVE AREA POINTER.
         XCTL  (2,12),EP=SWAP     XCTL TO SWAP
***********************************************************************
*                                                                     *
*                       CHECK FOR VIP PASSWORD                        *
*                                                                     *
***********************************************************************
VIP      CLC   REPLY(3),VIPWORD   WAS VIP PASSWORD ENTERED?
         BNE   BADCMD             NO, CONTINUE
         XI    VIPFLG,X'FF'       TOGGLE VIP FLAG
         B     NEXTPAGE
***********************************************************************
*                                                                     *
*                      COMMAND WAS INVALID                            *
*                                                                     *
***********************************************************************
BADCMD   EQU   *
         CLC   REPLY(79),BLANKS    BLANKS
         BE    NEXTPAGE
         MVC   ERROR(26),ERRMSG3  COMMAND WAS INVALID
         MVI   ISCERR,X'FF'
         MVC   ERROR+26(40),REPLY PUT BAD CMD IN DISPLAY LINE
         B     NEXTPAGE
         EJECT
***********************************************************************
*                                                                     *
*                     ALL DONE - PREPARE TO END                       *
*                                                                     *
***********************************************************************
DONETLD  DS    0H
DONE     DS    0H
         CLI   CRTFLAG,X'00'      IS THIS A HARDCOPY?
         BE    ALLDONE            YES
*        TPUT  CLR,CLRLEN,FULLSCR NO, LETS CLEAR THE SCREEN FIRST
         CLI   TESTFLAG,X'00'
         BNE   SKPTST6
*        STFSMODE OFF             AND TURN OFF FULLSCREEN MODE
SKPTST6  EQU   *
ALLDONE  EQU   *
         CLI   TESTFLAG,X'00'
         BNE   SKPTST7
         L     R1,LOCDCM          PREPARE TO FREEMAIN TDCM AREA    SP3
         FREEMAIN R,LV=820,A=(1)  DO IT                            SP3
         AXSET AX=ZERO            AUTH INDEX BACK TO 0             SP3
         MODESET MODE=PROB        GO BACK TO PROBLEM STATE         SP3
*                                                              AEI SP3
         SETAUTH OFF              MAKE SPY UN-AUTHORIZED       DST SP3
*                                                              AEI SP3
SKPTST7  EQU   *
         L     R13,SAVEAREA+4     RESTORE POINTER TO CALLER'S SAVE AREA
         LM    R14,R12,12(R13)    RESTORE REGISTERS
         LA    R15,0              SET RC = 0
         BR    R14                RETURN TO SYSTEM
         EJECT
***********************************************************************
*                                                                     *
*            CONVERT EBCDIC NUMBERS FROM USER INTO BINARY             *
*                                                                     *
***********************************************************************
CONVBIN  CVD   R2,WORK            CONVERT TO DECIMAL.
         CLI   REPLY+1,C' '       DID HE ENTER A NUMBER?
         BE    RTRN               NO, USE THE DEFAULT
         CLI   REPLY+1,C'0'       IS THE HEX CODE < 'F0' ?
         BL    BADCHAR            YES, ERROR
         CLI   REPLY+1,C'9'       IS THE HEX CODE > 'F9' ?
         BH    BADCHAR            YES, ERROR
         PACK  WORK(8),REPLY+1(1) PACK EBCDIC (ASSUME 1 DIGIT)
         CLI   REPLY+2,C' '       DID HE ENTER 2 DIGITS?
         BE    CVB                NO, DONT DO THE 2 DIGIT PACK
         CLI   REPLY+2,C'0'       IS THE HEX CODE < 'F0' ?
         BL    BADCHAR            YES, ERROR
         CLI   REPLY+2,C'9'       IS THE HEX CODE > 'F9' ?
         BH    BADCHAR            YES, ERROR
         PACK  WORK(8),REPLY+1(2) PACK AGAIN, WITH 2 DIGITS THIS TIME
CVB      CVB   R2,WORK            GET BINARY
RTRN     BR    R14                RETURN TO MAINLINE
BADCHAR  MVC   ERROR(26),ERRMSG2  CONSOLE NUMBER ERROR
         MVI   ISCERR,X'FF'
         B     RTRN
         SPACE 2
***********************************************************************
*                                                                     *
*                            C L R B U F                              *
*                                                                     *
*               CLEAR THE ENTIRE BUF AREA TO HEX ZEROS                *
*                                                                     *
***********************************************************************
CLRBUF   STM   R2,R5,SAVE25       SAVE REGS 2 - 5
         LA    R2,BUF             R2 = ADDR OF BUFFER
         LA    R3,M4BUFLEN        R3 = LENGTH OF BUFFER (35 LINES)
         LA    R4,BLANKS          R4 = ADDR OF BLANKS
         LA    R5,1               R5 = LENGTH OF BLANK
         ICM   R5,8,BLANKS        SETUP PAD CHAR = X'40'
         MVCL  R2,R4
         LM    R2,R5,SAVE25       RESTORE REGS
         BR    R14                RETURN TO CALLER
         SPACE 2
***********************************************************************
*                                                                     *
*                         T E R M P U T                               *
*                                                                     *
*          DO A TPUT TO THE TERMINAL; R0 AND R1 HOLD PARMS            *
*                                                                     *
***********************************************************************
*
* LOCAL SUBROUTINE WRITE SCREEN VIA TPUT, AND GET REPLY VIA TGET
*
WRITE80  EQU   *
         LA    R6,80               NO SBA SCANNING
         B     WRITEX
WRITE    EQU   *
         LA    R6,0                SBA SCANNING REQUIRED
WRITEX   ST    R14,SAVER14
*        CALL  TRACE
         ST    R1,ISPBUFA
         ST    R0,ISPLENG
         ST    R5,DISSIZE
         CLI   ISCERR,X'00'
         BNE   WRITERR
         ISPCALL ('VREPLACE','IUNIT',75,HEADING+18),WKAREA=ISPC
         B     WRITEOK
WRITERR  ISPCALL ('VREPLACE','IUNIT',66,ERROR)
WRITEOK  MVI   ISCERR,X'00'
         LA    R1,ISCBTAB          BEGIN ADDRESS OF VARIABLE NAME
         ST    R1,ISCTPTR
         L     R1,TLDPTR         GET TLD PTR
         L     R5,204(R1)  SCREEN LINES  FROM TLD
         S     R5,=F'3'         LESS FIRST THREE HEADINGS
         ST    R5,ISCSIZE
         LA    R5,0                CONSOLE LINES
         L     R9,ISPBUFA          FIRST CHAR OF SCREEN
         L     R7,ISPLENG
*        LA    R7,80*21            SCREEN LENGTH
ISPCLOOP L     R1,ISCTPTR
         CLC   0(8,R1),=CL8'XXXX '   LAST LINE?
         BE    ISPCDONE              YES FINISH IT AND DISPLAY SCREEN
         LA    R5,1(,R5)           ADD ONE LINE
         C     R5,DISSIZE          LIMITED TO SCREEN LINES
         BNL   ISPCREST            FINISH NO MORE LINES...
         C     R5,ISCSIZE          LIMITED TO SPLITED SCREEN?
         BNE   SCRLOPA             GO ON PUT THAT LINE TO ISPF
         B     ISPCREST
SCRLOPA  ST    R1,ISPC+8           ISPF SERVICE VARIABLE NAME FIELD
SCRLOOP  EQU   *
         C     R6,=F'0'            SBA SCANNING??
         BNE   NOSBA
         CLI   0(R9),X'11'         SET BUFFER ADDR CODE?
         BE    FINDSBA             YES
         LA    R9,1(,R9)           BUMP CHAR
         BCT   R7,SCRLOOP
         B     ISPCDONE
FINDSBA  EQU   *
         S     R7,=F'3'            LESS THREE SBA CHARS
         LA    R9,3(,R9)           SKIP SBA - ROW- COL CHARS
         CLI   0(R9),X'1D'         START FIELD?
         BNE   FINDCHR
         S     R7,=F'2'            LESS TWO SF CHARS
         LA    R9,2(,R9)           SKIP SF- CHAR
FINDCHR  ST    R9,ISPC+16          POINTER ADDR OF FIRST CHAR
         SR    R1,R1               CLEAR LENGTH COUNTER
CHARLOOP EQU   *
         LA    R9,1(,R9)           BUMP CHAR
         LA    R1,1(,R1)           INCREMENT ONE FOR LENGTH COUNTER
         CLI   0(R9),X'11'         SET BUFFER ADDR CODE?
         BE    STOPSBA             YES, SHOT IT TO ISPF SERVICE
         CLI   0(R9),X'1D'
         BNE   NOTSF
         MVC   0(2,R9),=CL2'  '
         LA    R9,2(,R9)
         LA    R1,2(,R1)
         S     R7,=F'1'
NOTSF    BCT   R7,CHARLOOP
         B     STOPSBA
ISPCREST LA    R9,BLANKS           FILL IN BLANKS
         LA    R6,80
         C     R5,=F'23'           STOP BY 23RD LINE
         BE    ISPCDONE
NOSBA    EQU   *
         ST    R9,ISPC+16          POINTER ADDR OF FIRST CHAR
         AR    R9,R6               ADD LENGTH OF LINE
         LR    R1,R6
STOPSBA  EQU   *
         C     R1,=F'80'           OVER 80 CHARS LONG ?
         BNH   UNDER80
         LA    R1,79               TRUNACATED TO 79 CHARS
UNDER80  ST    R1,ISPC             ISPF SERVICE LENGTH FIELD
         LA    R1,=C'VREPLACE'
         ST    R1,ISPC+4           ISPF SERVICE NAME FIELD
         LA    R1,ISPC
         ST    R1,ISPC+12          ISPF SERVICE LENGTH FIELD ADDR
         OI    ISPC+16,X'80'       END OF ISP SERVICE INDICATOR
         L     R1,ISCTPTR
         LA    R1,8(,R1)           NEXT VARIABLE NAME
         ST    R1,ISCTPTR
         ST    R9,SAVEPTR9
         ST    R7,SAVECTR7
*       CLI   SNAPSWT,X'00'
*       BNE   SNAPON
*       MVI   SNAPSWT,X'FF'
*NAPOPN  OPEN  (SNAPX,OUTPUT)
*NAPON  LA    R1,DSECT
*       ST    R1,QAREA
*       A     R1,=A(72+(ENDDSECT-DSECT))     AREA LENGTH
*       ST    R1,SNAP2
*       OI    SNAP2,X'80'  END OF SNAP LIST
*        LA    R9,SNAPX
*       LA    R2,QAREA
*       SNAP  ID=125,DCB=(9),LIST=(2)
         LA    R1,ISPC+4
         L     R15,=V(ISPLINK)
         BALR  R14,R15
         L     R9,SAVEPTR9
         L     R7,SAVECTR7
         C     R7,=F'0'
         BNL   ISPCLOOP
ISPCDONE EQU   *
         L     R1,540         TCBPTR
         L     R1,112(,R1)    TCBFSA
         L     R1,24(,R1)     R1 OF TCB
         L     R1,0(,R1)      TLD POINTER
         USING  TLD,R1
         CLC   TLDTBLID,=CL3'TLD'
         BNE   NOTLD1
         CLC   TLDTCBP(4),540  MATCH TO PSA TCB
         BNE   NOTLD1
         ST    R1,TLDPTR
         L     R5,TLDTSVP
         MVC   TLDENBL(8),124(R5) DEFAULT ENABLE VALUES
         CLI   WAITFLG,X'FF'            IS WAIT FLAGE ON?
         BNE   NORMDIS
         LA    R1,BUF
         LA    R0,22*80
         ICM   R1,8,=X'03'   FULLSCREEN CHARACHTER ASIS
         TPUT  (1),(0),R
         B     CALLDISX
NORMDIS  EQU   *
         OI    TLDSCRE,X'FC' ENABLE SCROLL AND FIND, CHANGE
         OI    TLDENBL2,X'40' ENABLE PRIMARY COMMAND
CALLDIS  ISPCALL ('DISPLAY',IPANEL,IERROR)
CALLDISX MVC   IPANEL(8),=CL8'ISPANEL'
*        CLI   SNAPSWT,X'00'
*        BNE   SNAPON2
*        MVI   SNAPSWT,X'FF'
*NAPOPN OPEN  (SNAPX,OUTPUT)
*NAPON2  L     R1,TLDPTR
*        ST    R1,QAREA
*        A     R1,=A(500)     AREA LENGTH
*        ST    R1,SNAP2
*        OI    SNAP2,X'80'  END OF SNAP LIST
*         LA    R9,SNAPX
*        LA    R2,QAREA
*        SNAP  ID=175,DCB=(9),LIST=(2)
         L     R1,TLDPTR
         L     R15,TLDRC       RETURNCODE
         LTR   R15,R15
         BNZ   WELDONE
         CLI   WAITFLG,X'FF'            IS WAIT FLAG ON?
         BE    NOENTRY
         MVI   WOPT,X'40'
         MVC   WOPT+1(50),WOPT
         CLI   TLDAID2,X'1A'       PA2 OR RESHOW CODE?
         BE    READCHAR           YES; IGNORE IT
         CLI   TLDAID2,X'1C'   ENTER PRESSED
         BE    WELDONE
         CLI   TLDAID2,X'03'
         BE    DONE
NXAIDX1  CLI   TLDAID2,X'05'   PFK5 PRESSED
         BNE   NXAID1
         MVC   WOPT(2),=C'R '
         B     WELENTRY
NXAID1   CLI   TLDAID2,X'06'   PFK6 PRESSED
         BNE   NXAID2
         MVC   WOPT(2),=C'W '
         B     WELENTRY
NXAID2   CLI   TLDAID2,X'07'   PKF7 PRESSED
         BNE   NXAID3
         MVC   WOPT(3),=C'?  '
         B     WELENTRY
NXAID3   CLI   TLDAID2,X'08'   PKF8 PRESSED
         BNE   NXAID5
         MVC   WOPT(3),=C'C  '
         B     WELENTRY
NXAID5   CLI   TLDAID2,X'0A'   PKF10 PRESSED
         BNE   NXAID6
         MVC   WOPT(6),=C'F '
         B     WELENTRY
NXAID6   CLI   TLDAID2,X'0B'   PKF11 PRESSED
         BNE   NXAID7
         ISPCALL ('VREPLACE','ZCMD',79,REPLY)
         B     WELENTRY
NXAID7   CLI   TLDAID2,X'1C'   ENTER PRESSED
         BE    WELDONE
NOTLD1   EQU   *
         ISPCALL ('DISPLAY',IPANEL,IERROR)
         L     R1,540         TCBPTR
         L     R1,112(,R1)    TCBFSA
         L     R1,24(,R1)     R1 OF TCB
         L     R1,0(,R1)      TLD POINTER
         USING  TLD,R1
         CLC   TLDTBLID,=CL3'TLD'
         BNE   NOTLD
         CLC   TLDTCBP(4),540  MATCH TO PSA TCB
         BNE   NOTLD
         ST    R1,TLDPTR
WELDONE  LR    R4,R15                     SAVE RETURN CODE
         ISPCALL ('VCOPY','ZCMD',60,WOPT,'MOVE')
         CH    R4,=H'8'                   END KEY PRESSED?
         BE    DONE
WELENTRY CLI   WOPT,C'E'                  END ENTERED?
         BE    DONE
         CLI   WOPT,C'B'                  END ENTERED?
         BE    DONE
*********************************************************************
*    NUMBER OF LINES PER SCREEN ALWAYS ALTERED AFTER EVERY SPLIT
*********************************************************************
         L     R1,TLDPTR         GET TLD PTR
         L     R5,TLDMPSLN      SCREEN LINES  FROM TLD
         S     R5,=F'3'         LESS FIRST THREE HEADINGS
         STH   R0,LPSCREEN        R0 = LINES PER SCREEN
         STH   R1,CPLINE          R1 = CHARACTERS PER LINE
         L     R1,TLDPTR
         LR    R5,R1
NOTLD    CLI   WOPT,C'='                  RETURN TO ISPF
         BE    DONE
         CLC   WOPT(16),=XL16'00'                 NULL ENTERED?
         BE    NUENTRY
         CLC   WOPT(16),=CL16' '                  BLANK ENTERED?
         BNE   ENTRY
NUENTRY  LA    R15,0
         B     NOENTRY
ENTRY    EQU   *                         CLEAR REPLY
NOENTRY  EQU   *
         L     R14,SAVER14
         BR    R14
         EJECT
***********************************************************************
*        END OF PROGRAM                                               *
***********************************************************************
NOCORE   MVC   SI@002B,=CL8'SI@002B'
         ISPCALL ('DISPLAY',LOTSBLNK,SI@002B)
         L     R13,SAVDSECT
         B     DONE
*TERMPUT  TPUT  (1),(0),R          PRINT ONE LINE ON HARDCOPY
         BR    R14                RETURN TO CALLER
         EJECT
***********************************************************************
*                                                                     *
*          SETUP AND INITIALIZE PARAMETER LIST FOR IKJSCAN            *
*                                                                     *
***********************************************************************
INITSCAN STM   R15,R4,SAVE154     SAVE REGS
         L     R3,CVTPTR          R3 = ADDR OF CVT
         L     R3,0(R3)           R3 = ADDR OF ADDR OF TCB
         L     R3,4(R3)           R3 = ADDR OF TCB
         USING TCB,R3
         ICM   R3,7,TCBJSCBB      R3 = ADDR OF JSCB
         ST    R3,SAVEJSCB        SAVE ADDR OF JSCB
         DROP  R3
         USING IEZJSCB,R3
         L     R4,JSCBPSCB        R4 = ADDR OF PSCB
         DROP  R3
         USING PSCB,R4
         L     R3,PSCBUPT         R3 = ADDR OF UPT
         ST    R3,SAVEUPT         SAVE ADDR OF UPT
         LA    R2,CSPLSAVE        R2 = ADDR OF CMD SCAN PARM LIST
         USING CSPL,R2
         ST    R3,CSPLUPT         SAVE UPT ADDR
         L     R3,PSCBRLGB        R3 = ADDR OF RELOGON BUFFER
         L     R3,256(R3)         R3 = ADDR OF ECT
         ST    R3,CSPLECT         SAVE ECT ADDR
         LA    R3,CPECB           R3 = ADDR OF FAKE ECB FOR THIS CP
         ST    R3,CSPLECB         SAVE ECB ADDR
         LA    R3,FLAGWORD        R3 = ADDR OF CSPL FLAG WORD
         ST    R3,CSPLFLG         SAVE FLAG ADDR
         LA    R3,CSOABLOK        R3 = ADDR OF CMD SCAN OUTPUT AREA
         ST    R3,CSPLOA          SAVE OUTPUT AREA ADDR
         LA    R3,CBUF            R3 = ADDR OF 'CMD BUFFER'
         ST    R3,CSPLCBUF        SAVE CBUF ADDR
         DROP  R2,R4
         LOAD  EP=IKJSCAN
         ST    R0,ADDRSCAN
         LM    R15,R4,SAVE154     RESTORE REGS 15 - 4
         BR    R14
         SPACE 2
         DS    0F
         EJECT
***********************************************************************
*                                                                     *
*                          C O N S D A T A                            *
*                                                                     *
*         FILLIN THE DATA LINE FOR A GIVEN CONSOLE                    *
*                                                                     *
***********************************************************************
CONSDATA STM   R0,R15,SAVECDAT    SAVE REGS
         L     R5,0(R1)           R5 = ADDR OF UCM
         USING UCMLIST,R5
         L     R6,UCMXB           R6 = ADDR OF RDCM
         USING DCMTSRT,R6
         MVC   CONNUM(48),BLANKS   BLANK OUT CONSOLE TYPE FIELD
         XR    R3,R3              CLEAR R3
         ICM   R3,1,UCMID         LOAD THE CONSOLE NUMBER
         CVD   R3,WORK            CONVERT TO DECIMAL IN WORK
         MVC   SCRATCH(4),PATTERN    MOVE IN EDIT PATTERN
         ED    SCRATCH(4),WORK+6     EDIT IN CONSOLE NUMBER
         MVC   CONNUM(2),SCRATCH+2   MOVE CONSOLE NUMBER INTO PLACE
         MVC   LOCATION(12),4(R1) MOVE IN CONSOLE LOCATION DESCRIPTION
         MVI   SLASH,C'/'
         MVC   STATUS(6),=CL6'INACTV' SET DEFAULT = 'INACTV'
         TM    UCMATR,UCMUF       IS THIS DEVICE ACTIVE?
         BNO   NOTACT             NO
         MVC   STATUS(6),=CL6'ACTIVE' SET STATUS = 'ACTIVE'
NOTACT   EQU   *
         TM    UCMDISP1,UCMDISPA  IS THIS A MASTER CONSOLE?
         BNO   AUTH               NO
         MVC   STATUS(6),=CL6'MASTER' YES
AUTH     TM    UCMAUTHA,UCMAUTH1  IS THIS CONSOLE SYSTEM AUTHORIZED?
         BNO   AUTH1              NO
         MVC   SYS(3),=CL3'SYS '  YES
AUTH1    TM    UCMAUTHA,UCMAUTH2  IS IT I/O AUTHOZRIZED?
         BNO   AUTH2              NO
         MVC   IO(3),=CL3'I/O'    YES
AUTH2    TM    UCMAUTHA,UCMAUTH3  IS IT CONS AUTHORIZED?
         BNO   AUTHDONE           NO
         MVC   CONS(3),=CL3'CON'  YES
AUTHDONE EQU   *
         LTR   R6,R6              IS THIS A GRAPHICS CONSOLE?
         BP    NOTHARD            YES
         MVC   STATUS(6),=CL6'HRDCPY'
NOTHARD  EQU   *
         L     R7,UCMUCB          R7 = ADDR OF UCB
         MVC   UNIT(3),13(R7)     MOVE UNIT ADDR INTO LINE
         L     R5,UCMALTEN        R5 = ADDR OF ALTERNATE UCM
         L     R7,UCMUCB          R7 = ADDR OF UCB
         MVC   ALTUNIT(3),13(R7)  MOVE UNIT ADDR INTO LINE
         SPACE
         LM    R0,R15,SAVECDAT    RESTORE REGS
         BR    R14
         DROP  R5,R6
         SPACE 2
         DROP  12
         EJECT
***********************************************************************
*                                                                     *
*                          A T T N E X I T                            *
*                                                                     *
*         TRAP USERS ATTENTION INTERRUPTS AND FLAG FOR RESET          *
*                                                                     *
***********************************************************************
ATTNEXIT LR    R7,R15             ESTABLISH
         USING ATTNEXIT,R7        ADDRESSABILITY.
         MVI   ATTNFLG,X'FF'      SET ATTN FLAG
         BR    R14                RETURN TO CALLER
         DROP  R7
         EJECT
***********************************************************************
*                                                                     *
*                         C O N S T A N T S                           *
*                                                                     *
***********************************************************************
MOD4TPUT DC    A(MOD4LEN)          LENGTH OF MOD4 TPUT
MOD2TPUT DC    A(MOD2LEN)          LENGTH OF MOD2 TPUT
*
*
FULLSCR  DC    X'03'               TPUT FULSCREEN FLAG
EDITFLG  DC    X'00'               TPUT EDIT FLAG
VIPWORD  DC    C'PIG'              VIP PASSWORD
*R41C1   DC    X'11F240'           3278-4  --  ROW 41, COL 1
*R42C1   DC    X'11F350'           3278-4  --  ROW 42, COL 1
*R43C1   DC    X'11F460'           3278-4  --  ROW 43, COL 1
PATTERN  DC    X'40202020'         EDIT PATTERN FIELD
DPATTRN  DC    X'4021204B20'       EDIT PATTERN FIELD
PAD      DC    C' '                PAD CHARACTER FOR MOVEBUFF MVC
         DS    0F
STAXLIST STAX  ATTNEXIT,MF=L       PARM LIST FOR ATTENTION TRAP
LOTSBLNK DC    CL90' '
         ORG   LOTSBLNK
BLANKS   DC    CL90' '
         SPACE 1
         DS    0F
         SPACE 1
WTOLOG   WTO   'XXXXXXX CMD:                                           *
                                                     ',ROUTCDE=(1),MF=L
         ORG   WTOLOG+4
LOGUSER  DS    CL7
         ORG   WTOLOG+17
LOGCMD   DS    CL80
         ORG
         SPACE 1
ONE      DC    H'1'               TO SET AX 1                      SP3
ZERO     DC    H'0'               TO SET AX 0                      SP3
CONASID  EQU   5                  'CONSOLE' ASID                   SP3
         SPACE 5
         LTORG
         EJECT
***********************************************************************
*                                                                     *
*                     ERROR AND WARNING MESSAGES                      *
*                                                                     *
***********************************************************************
ERRMSG1  DC    CL26'ERROR - CONSOLE UNDEFINED '
ERRMSG2  DC    CL26'ERROR - NON-NUMERIC VALUE '
ERRMSG3  DC    CL26'ERROR - INVALID COMMAND   '
ERRMSG4  DC    CL26'ERROR - NON-CRT CONSOLE   '
ERRMSG5  DC    CL26'WARNING - UCM TABLE FULL  '
ERRMSG6  DC    CL26'ERROR - TERMINAL INVALID  '
ERRMSG7  DC    CL26'ERROR - COMMAND RESTRICTED'
         SPACE 5
***********************************************************************
*                                                                     *
*                           USER HELP PAGE                            *
*                                                                     *
***********************************************************************
*HELP    DC    X'C1'               WCC
HELP     EQU   *
*        DC    X'115D7F'           SBA TO ROW 24, COL 80 (FSE 5.0)
*        DC    X'114040'           SBA TO ROW 1, COL 1
*        DC    X'3C404000'         FILL SCREEN WITH NULLS
         DC    X'114040',X'1DE8',C'  S P Y   ---   VERSION 3.1 - ISPF'
         DC    X'11C260',C' COMMAND  DESCRIPTION'
         DC    X'11C3F0'
         DC    X'11C540',C'  B     END SPY OR PFK3'
         DC    X'11C650',C'  C     SWITCH MONITOR TO CONSOLE 1'
         DC    X'11C760',C'  CXX   SWITCH MONITOR TO CONSOLE XX'
         DC    X'11C8F0',C'  DXX   SET DELAY TO XX TENTHS SECONDS'
         DC    X'114A40',C'  E     END SPY OR PFK3'
         DC    X'114B50',C'  F     FREEZE DISPLAY ON CURRENT PAGE'
         DC    X'114C60',C'  L     LINK TO SWAP PROGRAM (IF AVAILABLE)'
         DC    X'114DF0',C'  R     RELEASE DISPLAY OR PFK5'
         DC    X'114F40',C'  S     STATUS OF ALL CONSOLES OR PFK6'
         DC    X'115050',C'  W     START TIMER MODE FOR 30 SEC OR PFK6'
         DC    X'11D160',C'  WXX   START TIMER MODE FOR XX SECONDS'
         DC    X'11D2F0',C'  W0    START TIMER MODE UNTIL ATTN'
         DC    X'11D440',C'  ?     DISPLAY THIS PAGE OR PFK7'
         DC    X'11D550',C'  1     DISPLAY MODE 1 (TOP 22, BOTTOM 12)'
         DC    X'11D660',C'  2     DISPLAY MODE 2 (TOP 22, BOTTOM 22)'
*        DC    X'11D7F0'
         DC    X'11D940',C' HITTING INTERRUPT WILL STOP THE WAIT TIMER'
*        DC    X'115A50'
*        DC    X'115B60'
         DC    X'115CF0'        ROW 24, COL 1
         DC    C'HIT ENTER TO CONTINUE'
*        DC    X'115DC6'        ROW 24, COL 23
*        DC    X'1D40'
*        DC    X'1340'
*        DC    X'1DE8'
MARKER1  EQU   *
HLENGTH  EQU   MARKER1-HELP     LENGTH OF HELP TPUT
         SPACE 3
         SPACE 3
         EJECT
***********************************************************************
*                                                                     *
*                            U C M T A B                              *
*                                                                     *
*        THE UCMTAB TABLE IS BUILT AT SPY INITIALIZATION TIME.        *
*        ONE ENTRY IS FILLED IN FOR EACH CONSOLE THAT HAS BEEN        *
*        IOGENED INTO THE SYSTEM. THE 12 BYTE DESCRIPTION FIELD       *
*        ALLOWS YOU TO TAG EACH CONSOLE WITH SOME MNEMONIC THAT       *
*        IS EASIER TO REMEMBER THAN CONSOLE NUMBERS. IF UCMTAB IS     *
*        NOT DEFINED LARGE ENOUGH TO HOLD ALL THE CONSOLES, A         *
*        WARNING IS ISSUED BUT SPY CONTINUES ANYWAY.                  *
*                                                                     *
***********************************************************************
         DS    0F
UCMTABE  DC    A(TABEND)
         DS    0F
UCMTAB   DC    A(0),CL12' '
         DC    A(0),CL12'MASTER CONS '    CONSOLE 1
         DC    A(0),CL12'SERVICE CONB'    CONSOLE 2
         DC    A(0),CL12'ALT CONSOLE '    CONSOLE 3
         DC    A(0),CL12'DUMMY CONS  '    CONSOLE 4
         DC    A(0),CL12'DUMMY CONS  '    CONSOLE 5
         DC    A(0),CL12'DUMMY CONS  '    CONSOLE 6
         DC    A(0),CL12'SSS LEMES   '    CONSOLE 7
         DC    A(0),CL12'SSS DOLAN   '    CONSOLE 8
         DC    A(0),CL12'SSS MASTON  '    CONSOLE 9
         DC    A(0),CL12'SSS PERTELL '    CONSOLE 10
         DC    A(0),CL12'SSS INTERN  '    CONSOLE 11
         DC    A(0),CL12'LIBRARY CONS'    CONSOLE 12
         DC    A(0),CL12'HARDCOPY CNS'    CONSOLE 13
         DC    A(0),CL12'SSS COLOR   '    CONSOLE 14
         DC    A(0),CL12'MP TAPE CONS'    CONSOLE 15
         DC    A(0),CL12'            '    CONSOLE 16
         DC    A(0),CL12'            '    CONSOLE 17
         DC    A(0),CL12'            '    CONSOLE 18
         DC    A(0),CL12'MP NCC WEST '    CONSOLE 19
         DC    A(0),CL12'            '    CONSOLE 20
         DC    A(0),CL12'            '    CONSOLE 21
         DC    A(0),CL12'            '    CONSOLE 22
         DC    A(0),CL12'            '    CONSOLE 23
         DC    A(0),CL12'            '    CONSOLE 24
         DC    A(0),CL12'            '    CONSOLE 25
TABEND   EQU   *
         EJECT
***********************************************************************
*                                                                     *
*                           E Q U A T E S                             *
*                                                                     *
*     NOTE THAT A 'LINE' IS DEFINED AS 84 BYTES; THIS IS BECAUSE      *
*     DIDOCS BUILDS THE OPERATOR SCREEN BUFFER LINES AS 79 BYTES OF   *
*     TEXT + 5 CONTROL BYTES. THIS CONSISTS OF AN SBA (X'11XXYY')     *
*     AND AN ATTRIBUTE BYTE (X'1DXX').                                *
*                                                                     *
***********************************************************************
LEN9     EQU   9*80               NUMBER OF BYTES IN  9 LINES
LEN21    EQU   21*80              NUMBER OF BYTES IN 21 LINES
LEN22    EQU   22*80              NUMBER OF BYTES IN 22 LINES
LEN13    EQU   13*80              NUMBER OF BYTES IN 13 LINES
M2BUFLEN EQU   21*80              LENGTH OF BUFFER 3278-2
M4BUFLEN EQU   35*80              LENGTH OF BUFFER 3278-4
STATLEN  EQU   BUF-CLEAR+80*23    LENGTH OF 'STATUS' PAGE BUFFER
HEADLEN  EQU   BUF-HEADER         LENGTH OF HEADER
TRAILEN  EQU   ENDTRAIL-TRAILER   LENGTH OF TRAILER
MOD4LEN  EQU   M4BUFLEN           LENGTH OF TPUT FOR MOD4
MOD2LEN  EQU   LEN22              LENGTH OF TPUT FOR MOD2
ENDMOD2  EQU   BUF+M2BUFLEN       ADDR OF TRAILER FOR 3278-2
         PRINT NOGEN
SNAPX    DCB   DDNAME=SYSSNAP,BLKSIZE=882,DSORG=PS,LRECL=125,          X
               MACRF=(W),RECFM=VBA
         EJECT
***********************************************************************
         DS    0F
ISCBTAB  EQU   *
         DC   CL8'ISCR01'
         DC   CL8'ISCR02'
         DC   CL8'ISCR03'
         DC   CL8'ISCR04'
         DC   CL8'ISCR05'
         DC   CL8'ISCR06'
         DC   CL8'ISCR07'
         DC   CL8'ISCR08'
         DC   CL8'ISCR09'
         DC   CL8'ISCR10'
         DC   CL8'ISCR11'
         DC   CL8'ISCR12'
         DC   CL8'ISCR13'
         DC   CL8'ISCR14'
         DC   CL8'ISCR15'
         DC   CL8'ISCR16'
         DC   CL8'ISCR17'
         DC   CL8'ISCR18'
         DC   CL8'ISCR19'
         DC   CL8'ISCR20'
         DC   CL8'ISCR21'
         DC   CL8'ISCR22'
         DC   CL8'ISCR23'
         DC   CL8'XXXX'
         EJECT
*     THESE ARE THE DEFAULT NAMES (ALL 9 MOVED AS ONE BLOCK):
SI@002A$ DC    C'SI@002A '
SI@002B$ DC    C'SI@002B '
SI@002C$ DC    C'SI@002C '
SI@002D$ DC    C'SI@002D '
SI@E$    DC    C'SI@E '
SI@A$    DC    C'SI@A '
SIPANEL$ DC    CL8'SI@A '
SIERR$   DC    CL8' '
*     END OF THE DEFAULT NAMES
***********************************************************************
*        DATA AREA IN SPOOL FOR RE-ENTRANT AND REUSE APPROACHES       *
***********************************************************************
DSECT    DSECT
SAVEAREA DS    18F
SAVER8   DS    F
SAVE25   DS    4F
SAVECDAT DS    16F
SAVER12  DS    F
SAVER13  DS    F
SAVEPARM DS    F
TLDPTR   DS    F
ISPBUFA  DS    F
ISPLENG  DS    F
VRARRAY  DS    23F'1'
SAVE154  DS    6F
SAVEUPT  DS    F                   SAVE ADDR OF UPT
SAVEJSCB DS    F                   SAVE ADDR OF JSCB
CSPLBLOK DS    6F                  CMD SCAN PARAMETER LIST
CSPLSAVE DS    6F
MOVEBSAV DS    6F                 REG SAVE AREA - R4:R9            SP3
CPECB    DC    F'0'                FAKE ECB FOR THIS CP
FLAGWORD DC    F'0'
CSOABLOK DS    2F                  CMD SCAN OUTPUT AREA
CBUF     DC    AL2(84),AL2(0)
ADDRSCAN DS    A
         DS    0D
WORK     DS    D                   WORK AREA FOR PACKS
SCRATCH  DS    D                   SCRATCH AREA FOR CHAR. MANIP
WKAREA   DS    3D                         1ST F FOR NUMERICS IN ISPCALL
DSECTR13 DS    F WKAREA+24
ISPQBASE DS    F WKAREA+28
USERPARM DS    CL8
SWITCHES DS    XL1       .... ...1 = BYPASS SELECTION PANEL
*                        .... ..1. = JCL FOR A SUBOPTION HAS BEEN GEN'D
*                        .... .1.. = EDIT INSTEAD OF SUB ("/E")
*                        .... 1... = VAR "XJPARMS" NOT DEFINED
*                        ...1 .... = NO REMEMBERED PARAMS FOR THIS OPT
*                        ..1. .... = TRACE CALLS TO ISPLINK
*                        .1.. .... = CANCEL INSTEAD OF SUB ("/C")
MOD4FLG  DC    X'00'               X'FF' INDICATES 3278-4 IN USE
CRTFLAG  DC    X'FF'               X'FF' INDICATES CRT IN USE
ATTNFLG  DC    X'00'               X'FF' INDICATES ATTN WAS TRAPPED
TESTFLAG DC    X'00'               X'FF' INDICATES TEST MODE
WAITFLG  DC    X'00'               X'00' INDICATES NOT IN WAIT MODE
INTEGFLG DC    X'00'               X'FF' INDICATES 35-LINE 3066 CONSOLE
ISCERR   DC    X'00'               X'FF' INDICATES ISPF ERROR MESSAGE
VIPFLG   DC    X'FF'               X'FF' INDICATES VIP MODE
         DS    0H
ISPCC    DS    CL2                        FOR RET CODE ON DISPLAY ERROR
CONSOLE  DC    F'1'                CONSOLE TO BE LOOKED AT
OLDCONS  DC    F'1'                PREVIOUS CONSOLE NUMBER
TPUTLEN  DC    A(MOD2LEN)          LENGTH OF MOD 2 TPUT
TIMER    DC    F'30'               SECONDS LEFT ON TIMER
DELAY    DC    F'100'              DELAY FOR 100 HUNDREDTHS OF A SECOND
ANSWER   DS    F'0'                ADDRESS POINTER FOR EXTRACT
SASID    DS    F                  STORE FOR PREVIOUS SEC ASID      SP3
LOCDCM   DS    F                  ADDR OF GETMAINED AREA FOR TDCM  SP3
NUMUCMS  DC    H'0'
LPSCREEN DC    H'0'                LINES PER SCREEN
CPLINE   DC    H'0'                CHARACTERS PER LINE
CMDBUFF  DS    H,H,CL60                   LENGTH AND "SUBCOMMAND" FIELD
BPANEL   DS    CL8                        SUBOPT PANEL NAME
XOPT     DS    CL60                       ENTERED ON ISP@PRIM
WOPT     DS    CL60                       SUBOPTION
         DS    CL60                       SUBOPTION
OPERPRM  DC    A(OPERCMDL)         PARMLIST FOR 'COMMAND'
OPERPRM1 DC    XL1'80',AL3(OPERCN) SECOND PARM FOR 'COMMAND'
OPERCN   DC    F'0'                CONSOLE AUTHORITY
OPERCMDL DC    H'0'                COMMAND LENGTH
OPERCMD  DC    CL80' '             COMMAND TEXT
SI@002A  DS    (L'SI@002A$)C
SI@002B  DS    (L'SI@002B$)C
SI@002C  DS    (L'SI@002C$)C
SI@002D  DS    (L'SI@002D$)C
SI@E     DS    (L'SI@E$)C
SI@A     DS    (L'SI@A$)C
SISPANEL DS    (L'SIPANEL$)C
SIERROR  DS    (L'SIERR$)C
ECB      DS    F
TCBADDR  DS    F
***********************************************************************
*        SAVEAREA FOR RELOCATION TO ISPF                              *
***********************************************************************
***********************************************************************
*        CONSTANTS                                                    *
***********************************************************************
         SPACE 1
CMDALLOW DS    C' '
UNITXXX  DS    CL4' '
SVCRCM   DS    CL9' '
NOTR15   DS    CL8' '
IPANEL   DS   CL8' '
IERROR   DS   CL8' '
ISPC     DS   3D
         SPACE 1
         DS   0F
ISCTPTR  DS   F'0'
ISCSIZE  DS   F'0'
DISSIZE  DS   F'0'
         SPACE 2
***********************************************************************
*        VARIABLES                                                    *
***********************************************************************
         SPACE
CVTA     DS    D'0',X'0'               PLUS A GARBAGE BYTE
CVTB     DS    F'0'
         SPACE 1
CMND     DS    H'79',H'0'
CMNDBUF  DS    CL80' '
CMNDLEN  EQU   *-CMND
         SPACE 1
XUCMID   DS    X'01'          ********WAS X'0'---WYLBUR NEEDS '01'
         SPACE 2
REPLY    DS    CL80' '             REAL REPLY
         SPACE 1
SAVER14  DS    F'0'
SAVEPTR9 DS    F'0'
SAVECTR7 DS    F'0'
SAVDSECT DS    F'0'
SNAP1    EQU   *
QAREA    DC    A(*) DUMP                      AREA
SNAP2    DC    0F'0',X'80',AL3(*)
SNAPSWT  DC    X'00'
***********************************************************************
*        SCREEN FORMAT                                                *
***********************************************************************
MSGLINE  DS    CL80' '
         ORG   MSGLINE
LASTLINE DC    CL80' '            OPERATORS COMMAND INPUT LINE
         DS    15C
TIMELINE DS    CL79' '           FOR TIME STAMP
         DS    4C
***********************************************************************
*                                                                     *
*               DISPLAY SCREEN - TRAILER SECTION                      *
*                                                                     *
***********************************************************************
TRAILER  EQU   *
*CMDCTRL  DC    X'115A50'          SBA TO ROW 22, COL 1
*        DC    X'1DE8'            ATTR BYTE - PROTECTED, HIGH INTENSITY
*PHEADING DC    X'115B60'          SBA TO ROW 23, COL 1
*        DC    X'1DE8'            ATTR BYTE - PROTECTED, HIGH INTENSITY
HEADING  DC    CL1'C'
CONNUM   DC    CL2' 1'            CONSOLE NUMBER
         DC    CL1' '
LOCATION DC    CL12' '
         DC    CL2' '
UNIT     DC    CL3' '
SLASH    DC    CL1'/'
ALTUNIT  DC    CL3' '
         DC    CL2' '
STATUS   DC    CL6' '             MASTER CONSOLE
         DC    CL2' '
SYS      DC    CL4' '             SYS  AUTHORIZATION
IO       DC    CL4' '             I/O  AUTHORIZATION
CONS     DC    CL3' '             CONS AUTHORIZATION
         DC    CL3' '
TIME     DC    CL3' '             SECONDS REMAINING ON TIMER
         DC    CL1'/'
PAUSE    DC    CL3'1.0'           DELAY IN SECONDS
         DC    CL2' '
HEADING2 DC    CL2'M:'
FREEZE   DC    C'F'               FREEZE/RELEASE MODE
MODE     DC    CL1'2'             DISPLAY MODE 2/1
         DC    CL1' '
         DC    CL5'PAGE '
PAGE     DC    CL1'2'             PAGE NUMBER
USERLINE DC    CL13' '            USERS COMMAND INPUT LINE
ERROR    DC    CL66' '            ERROR MSG FIELD
ENDTRAIL EQU   *
         SPACE 5
***********************************************************************
*                  DISPLAY SCREEN - HEADER SECTION                    *
***********************************************************************
HEADER   EQU   *
CLEAR    EQU   *
FULLSCRN DS    C
***********************************************************************
*                 DISPLAY SCREEN IMAGE BUFFER SECTION                 *
***********************************************************************
SCREEN   EQU   *
BUF      DC    21CL80' '          OPERATORS SCREEN BUFFER
         DC    22CL80' '          PLUS EXTRA FOR 3278-4
SCRLEN   EQU   *-FULLSCRN
         DS    81C' '
ENDDSECT EQU   *
         DS    0F
TLD      DSECT LOGICAL DISPLAY  MAIN MEMORY TABLE
TLDTBLID DS    CL3             TABLE ID "TLD"
TLDID    DS    CL1             TLD  ID ( 0 1,2)
TLDNEXTP DS    CL4             NEXT TLD PTR
TLDSEWD1 DS    CL4             SERVICE CALL SEQ WORDS
TLDSEWD2 DS    CL4
TLDRC    DS    CL4             RETURN CODE
TLDTLDP  DS    F               THIS TLD PTR
         DS    CL8             RESERVED
TLDSYSP  DS    CL40            CONTROLLER TABLE PTRS
         ORG   TLD+32
TLDTCTP  DS    F               TCT PTR (TRANS TABLES)
TLDTDSP  DS    F               TDS PTR (SYS DATASETS)
TLDTKVP  DS    F               TKV PTR (KEY/VALUE TBL)
TLDTKWP  DS    F               TKW PTR (KEYWORD TBLS)
TLDTPLP  DS    F               TPL PTR (PANEL DEF LST)
TLDTSCP  DS    F               TSC PTR (COMMON SUBS)
TLDTSIP  DS    F               TSI PTR (SYS INTERFACE)
TLDTSVP  DS    F               TSV PTR (SYS INTERFACE)
         DS    2F              RESERVED
TLDPROTB DS    18F             PROCESSOR TABLE PTRS
         ORG   TLD+72
TLDMSGEP DS    F               MSG EXTENSION PTR
TLDDTAPT DS    F               DATA TABLE PTR
TLDVCBP  DS    F               VARIABLE CNTL BLK PTR
TLDFTLRP DS    F               FILE TAILORING PTR
TLDTFDEP DS    F               EDIT BACKUP TFD PTR
TLDTFKP  DS    F               TFK PTR (FUNCT/KEY)
TLDTLSP  DS    F               TLS PTR (LOGIC SCREEN)
TLDTPXP  DS    F               TPX PTR (PANEL DEF EXT)
TLDTRT0P DS    F               TRT ZEROS TABLE PTR
TLDTRT1P DS    F               TRT IDENTIFY TABLE PTR
TLDTUTLP DS    F               TUTORIAL/PANEL LIST PTR
TLDPOPTP DS    F               PRIM OPT (EXT) PTR
TLDPARMP DS    F               SYS ERROR (EXT) PTR
TLDDINFP DS    F               DIALOG INFOR (EXT) PTR
TLDDSERV EQU   16              TLDDINFP+16
TLDDSTYP EQU   30              TLDDINFP+30
         DS    F               RESERVED
TLDUSER1 DS    F               USER FIELD 1
TLDUSER2 DS    F               USER FIELD 2
TLDUSER3 DS    F               USER FIELD 3
TLDDISCR DS    23F             DISPLAY/SCREEN INTERFACE
         ORG    TLD+144
TLDFUNC  DS    CL1             KEY FUNCTION BITS
TLDNOPK  EQU   X'80'           NOP
TLDREDK  EQU   X'40'           REDISPLAY
TLDSPLK  EQU   X'20'           SPLIT
TLDSWPK  EQU   X'10'           SWAP
TLDCSRK  EQU   X'08'           CURSOR
TLDPRTHK EQU   X'04'           PRINT HIGH
TLDPRTLK EQU   X'02'           PRINT LOW
TLDNOPRK EQU   X'01'           NOP AND REDISPLAY
TLDFUNC2 DS    CL1             KEY FUNCTION BITS TWO
TLDLNEK  EQU   X'80'           LINE COMMAND
TLDCMDK  EQU   X'40'           PRIMARY COMMAND
TLDNOPMK EQU   X'20'           NOP WITH MESSAGE
TLDHLPK  EQU   X'10'           HELP
TLDRETK  EQU   X'08'           RETURN
TLDRESV2 EQU   X'07'           RESERVED
TLDFUNC3 DS    CL1             KEY FUNCTION BITS THREE
TLDENDK  EQU   X'80'           LINE COMMAND
TLDENTK  EQU   X'40'           PRIMARY COMMAND
TLDSMMK  EQU   X'20'           NOP WITH MESSAGE
TLDRESV3 EQU   X'1F'           RESERVED
TLDSCRK  DS    CL1             SCROLL KEYS
TLDSCRUK EQU   X'80'           SCROLL UP
TLDSCRDK EQU   X'40'           SCROLL DOWN
TLDSCRLK EQU   X'20'           SCROLL LEFT
TLDSCRRK EQU   X'10'           SCROLL RIGHT
TLDFNDK  EQU   X'08'           REPEAT FIND
TLDCHGK  EQU   X'04'           REPEAT CHANGE
TLDSCRSV EQU   X'03'           RESERVED
         DS    CL4             RESERVED
         ORG   TLD+152
TLDENBL  DS    CL1             ENABLED KEY FUNCTION BITS
TLDNOPE  EQU   X'80'           NOP
TLDREDE  EQU   X'40'           REDISPLAY
TLDSPLE  EQU   X'20'           SPLIT
TLDSWPE  EQU   X'10'           SWAP
TLDCSRE  EQU   X'08'           CURSOR
TLDPRTHE EQU   X'04'           PRINT HIGH
TLDPRTLE EQU   X'02'           PRINT LOW
TLDNOPRE EQU   X'01'           NOP AND REDISPLAY
TLDENBL2 DS    CL1             KEY FUNCTION BITS TWO
TLDLNEE  EQU   X'80'           LINE COMMAND
TLDCMDE  EQU   X'40'           PRIMARY COMMAND
TLDNOPME EQU   X'20'           NOP WITH MESSAGE
TLDHLPE  EQU   X'10'           HELP
TLDRETE  EQU   X'08'           RETURN
TLDRESE2 EQU   X'07'           RESERVED
TLDENBL3 DS    CL1             KEY FUNCTION BITS THREE
TLDENDE  EQU   X'80'           LINE COMMAND
TLDENTE  EQU   X'40'           PRIMARY COMMAND
TLDSMME  EQU   X'20'           NOP WITH MESSAGE
TLDRESE3 EQU   X'1F'           RESERVED
TLDSCRE  DS    CL1             SCROLL KEYS
TLDSCRUE EQU   X'80'           SCROLL UP
TLDSCRDE EQU   X'40'           SCROLL DOWN
TLDSCRLE EQU   X'20'           SCROLL LEFT
TLDSCRRE EQU   X'10'           SCROLL RIGHT
TLDFNDE  EQU   X'08'           REPEAT FIND
TLDCHGE  EQU   X'04'           REPEAT CHANGE
TLDSERSV EQU   X'03'           RESERVED
         DS    CL4             RESERVED
         ORG   TLD+160
TLDAID   DS    CL1             LOGICAL ATTENTION AID
TLDAID2  DS    CL1             LOGICAL ATTENTION AID PDF ONLY
         DS    CL2             RESERVED
TLDTLSX  DS    CL32            LOGICAL SCREEN (TLS)
         ORG   TLD+164
TLDCSR   DS    F               CURSOR OFFSET
TLDMDTCT DS    F               MODIFIED DATA TAG CNT
         DS    F               RESERVED
TLDTLSSZ DS    F               MAX SIZE
TLDTLSLN DS    F               MAX LINES
TLDTLSWD DS    F               MAX LINE WIDTH
TLDCLSLN DS    F               CURRENT LINES
TLDCLSWD DS    F               CURRENT LINE WIDTH
TLDPTPS  DS    8F              PHYSICAL SCREEN (TPS)
         ORG   TLD+196
TLDCPSLN DS    F               TLS IN TPS LINES
TLDCPSWD DS    F               TLS IN TPS LNE WIDTH
TLDMPSLN DS    F               MAX LINES
TLDMPSWD DS    F               MAX LINE WDTH
TLDTPSRW DS    F               TLS IN TPS LINE NUM
TLDTPSCL DS    F               TLS IN TPS COLUMN
         DS    4F              RESERVED
TLDMISC  DS    24F             MISCELLANEOUS INTERFACE
TLDBITS  DS    CL1             MISC FUNCTION BITS
TLDTUT   EQU   X'80'           TUTORIAL FLAG (TUT)
TLDNODSP EQU   X'40'           NO DISPLAY REQUESTED
TLDTFKLK EQU   X'20'           TFK LOCK BIT
TLDPRIOP EQU   X'10'           PRIM OPT FLAG (PMD)
TLDNOPDE EQU   X'08'           NO ERROR PANEL DISPLAY
TLDCPNLD EQU   X'04'           TLDCMENU IS A PANEL
TLDNEWAP EQU   X'02'           NEW APPL (DIR/DIP)
TLDIVOPT EQU   X'01'           INVALID OPT (DIP)
TLDBITS2 DS    CL1             MISC FUNCTION BITS
TLDOMENU EQU   X'80'           OLD MENU (DPR/TUT)
TLDCSERL DS    CL1             CSE RECURSION LEVEL
TLDSIMKY DS    CL1             SIM FUNCT KEY CODE
TLDPMDCD DS    F               PMD ENTRY PARAMETER
         ORG   TLD+240
TLDPMDTC DS    CL1             TYPE OF INVOKATION
TLDPMDIC DS    CL3             INPUT CODE
TLDPIFBP DS    F               PRIM INPUT FLS ATTR BYTE
TLDPIFSZ DS    F               PTR AND DATA LEN
TLDSC    DS    14F             SCROLL INTERFACE
         DS    F               RESERVED
TLDEBUID DS    CL1             EDIT BACKUP TFD ID
TLDTFKID DS    CL1             TFK ID (A B C)
         DS    CL2             RESERVED
TLDTEST  DS    CL4             TEST BITS
         DS    3F              RESERVED
TLDOMM   DS    CL48            OLD MENU/MSG FIELDS
         DS    2F              RESERVED
TLDPCODE DS    CL6             PROLOG CODE INTERFACE
TLDECODE DS    CL6             EPILOG CODE INTERFACE
TLDSA    DS    CL40            SAVEAREA INTERFACE
         DS    2F              RESERVED
TLDEXT   DS    CL160           OS DEPENDENT EXTENSION
         DS    CL40            RESERVED
         ORG   TLD+332         OLD MENU/MSG FIELDS
TLDOMMB  DS    CL1             MISC FUNCTION BITS
TLDALARM EQU   X'80'           ALARM BIT
TLDMERRC EQU   X'40'           MERR CALLING MHA
         DS    CL3             RESERVED
TLDMHABP DS    F               MENU HANDLER BUFFER PTR
         DS    F               RESERVED
TLDCMENU DS    CL8             CURRESNT MENU/PANEL
TLDPMENU DS    CL8             PREV MENU FROM CDISPL
TLDHELP  DS    CL8             CURR HELP (MEMEBR) NAME
TLDPMSG  DS    CL8             PREVIOUS MSG FROM CMSG
         DS    CL4             RESERVED
TLDEXTY  DS    CL160           OS DEPENDENT EXTENSIONS
         ORG   TLD+448
         DS    CL36            CONTROL/PROCESS INTERFACE
         ORG   TLD+448
TLDTCBP  DS    F               TCB PTR (TASK CNTL BLK)
TLDDRECB DS    F               DISPLAY REQUEST ECB
TLDPRECB DS    F               PROCESS REQUEST ECB
TLDTCECB DS    F               TASK COMPLETION ECB
TLDCCI   DS    F               CCI WORD
TLDSXECB DS    F               STAX POST ECB
TLDSXTCB DS    F               STAX POST TCB PTR
         DS    2F              RESERVED
TLDXSYSP DS    CL32            CONTROLLER TABLE PTRS
         ORG   TLD+484
TLDTXCP  DS    F               TXC PTR (TERM EXIT TBL)
TLDTCMP  DS    F               TCM PTR (TSO CMD TABLE)
         DS    6F              RESERVED
         DS    CL24            PROCESSOR TABLE PTRS
         ORG   TLD+516
TLDTFDCP DS    F               CONTROL CARD TFD PTR
TLDTFDLP DS    F               LISTING TFD PTR
TLDTADP  DS    F               TAD PTR (ALLOC DDNAMES)
TLDIOWAP DS    F               IOWA PTR (STACK CONTROL)
         DS    2F              RESERVED
         DS    CL20            MISCELLANEOUS INTERFACE
         ORG   TLD+540
TLDXBITS DS    CL2             MISC FUNCTION BITS
TLDSTAX  EQU   X'40'           CAT STAX FLAG
TLDSTAX6 EQU   X'20'           OPTION 6 STAX FLAG
TLDDFREE EQU   X'10'           CAT DD FREE SWITCH
         DS    CL2             RESERVED
TLDCSMAP DS    F               CSM AUTO STOR AREA PTR
TLDCFANM DS    CL8             LASTEST CFA NAME FROM DIR
         DS    F               RESERVED
         DS    CL48            RESERVED
         ORG   TLD+316
TLDTESTY DS    F               TSI SPF TEST FLAG
TLDTESTS DS    CL1             SYSTEM LEVEL TEST BITS
TLDTTIO  EQU   X'80'           ON =, TRACE TERM I/O
TLDSPF   EQU   X'40'           ON=SPF MODE
TLDTLOG  EQU   X'20'           ON=TRACE LOG AT TERM
TLDSTEST EQU   X'04'           ON=ALLOWSTAX ATTEN
TLDABEND EQU   X'02'           ON=ALLOW SUBTASK ABEND
TLDMSGMN EQU   X'01'           ON=MSG/MENU TESTING
TLDTESTP DS    CL1             PROC LEVEL TEST BITS
TLDPETFG EQU   X'80'           ON = PET EXECUTION
TLDTESTA DS    CL1             APPL LEVEL TEST BITS
TLDLGERR EQU   X'08'           ON=LOG ALLCSE ERRS
TLDERCON EQU   X'01'           ON=CSE ERR CONTINUE
TLDTESTF DS    CL1             FUNC LEVEL TEST BITS
TLDERRET EQU   X'80'           ON= CSE ERROR RETURN
TLDLGSRV EQU   X'08'           ON=LOG SERVICE CALLS
*                                                                     *
*                SYSTEM CONTROL BLOCK MAPPING DSECTS                  *
*                                                                     *
*     ALL MACROS EXCEPT FOR IEERDCM AND IEETDCM CAN BE FOUND IN       *
*     EITHER 'SYS1.MACLIB' OR 'SYS1.AMODGEN'. THE TWO EXCEPTIONS      *
*     ARE IN 'SYS1.APVTMACS'; THEY ARE ALSO DISTRIBUTED WITH THE      *
*     SOURCE TO 'SPY'.                                                *
*                                                                     *
***********************************************************************
         CVT   DSECT=YES          COMMUNICATIONS VECTOR TABLE
         SPACE 2
         IEECUCM FORMAT=NEW,DSECT=YES,LIST=YES
         SPACE 2
         IEERDCM ,                RESIDENT DISPLAY CONTROL MODULE
         SPACE 2
         IEETDCM ,                PAGEABLE DISPLAY CONTROL MODULE
         SPACE 2
         SPACE 2
         IEZJSCB ,                JOB STEP CONTROL BLOCK
         SPACE 2
         IKJCSOA ,                COMMAND SCAN OUTPUT AREA
         SPACE 2
         IKJCSPL ,                COMMAND SCAN PARAMETER LIST
         SPACE 2
         IKJPSCB ,                PROTECTED STEP CONTROL BLOCK
         SPACE 2
         IKJTCB  ,                TASK CONTROL BLOCK
         SPACE 2
         IKJUPT  ,                USER PROFILE TABLE
         SPACE 2
         END  ISP@SPY
//LKED EXEC  PGM=XEWL,PARM='MAP,LET,LIST,NCAL',REGION=96K,
//         COND=(8,LT,ASM)
//SYSLIN   DD  DSN=&&LOADSET,DISP=(OLD,DELETE)
//         DD  DDNAME=SYSIN
//SYSLMOD DD DISP=(SHR),UNIT=3350,
//   DSN=SYS2.PGMPROD.LINKLIB
//SYSUT1   DD  UNIT=SYSDA,SPACE=(CYL,(3,2)),DSN=&SYSUT1
//SYSPRINT DD  SYSOUT=*
//ISPLIB DD DSN=SYS1.V1R1M0.ISPLOAD,DISP=SHR,
//    VOL=SER=PPVOL3,UNIT=3350
//SYSMOD DD DSN=C6000A.DOR.LINKLIB2,DISP=SHR,UNIT=3350
//SYSOBJ DD DSN=C6000A.DOR.OBJQSP3,DISP=SHR,UNIT=3350
//SYSIN DD *
 INCLUDE ISPLIB(ISPLINK)
 INCLUDE SYSMOD(ASMTRACE)
 ENTRY ISP@SPY
 NAME ISP@SPY(R)
/*
./       ADD   NAME=LISTPTF
*//*-----------------------------------------------------------
*//* AUTHOR:  DAVID RIKER
*//*          COMPUTER DATA SYSTEMS, INC.
*//*          ONE CURIE COURT
*//*          ROCKVILLE, MD 20850
*//*          202-362-1160 OR 301-921-7000
*//*-----------------------------------------------------------
*//* TO DISPLAY UPDATED SYSMODS INFORMATION OF TARGET AND DLIB
*//* LIBRARIES CONTAINED LOAD MODULES FOR THE PURPOSE OF CHECKING
*//* ZAPPED OR UPGRADED MODULES WITH INFORMATION OF IBM SYSMOD NAME
*//* AND DATE.
*//*-----------------------------------------------------------
*//* IMPLEMENTED/FIXED BY DOR/CDSI ON 12/6/85 FOR:
*//*   1. CORRECTED ALGORITHM PROBLEM WHEN READ DIRECTORY, LISTPTF
*//*      SKIPS TOO MANY MEMBERS.
*//*   2. INCREASE CSECT TABLE TO 3000 (COULD TAKE 4 MIN CPU TIME
*//*       FOR A PROGRAM WITH OVER 2000 CSECTS.)
*//*   3. ADD ROUTINE TO REPORT LOAD MODULE ATTRIBUTES
*//*        ON DD "ATTRLIST" OUTPUT.
*//*-----------------------------------------------------------
*//* IMPLEMENTED/FIXED BY DOR/CDSI ON 10/8/86 FOR:
*//* 1. FINDESD AND CESD ROUTINES ARE COMPLETED REWRITEN TO
*//*    INCLUDE ANOTHER BLOCK CONTROL TO POINT CSECT TABLE TO
*//*    REDUCE LOOPING OR SEARCHING WHILE TRYING TO MATCH ESDID
*//*    BETWEEN CSECT AND DATA (ZAP, TRANSLATOR, OR USER). IT CUT
*//*    CPU TIME BY 95%.
*//* 2. NUMBER OF CSECTS ALLOWED WAS INCREASED FROM 3000 TO 4000.
*//*-----------------------------------------------------------
*//* EACH LOAD MODULE INFORMATION INCLUDE:
*//*   1. LINKAGE EDITOR PRODUCT NAME AND LINKED DATE
*//*   2. FOR EACH CSECT, TRANSLATOR/PLS PRODUCT NAME AND
*//*          TRANSLATED DATE
*//*   3. FOR EACH CSECT, UP TO 10 ZAPPED (HMASPZAP)
*//*          INFORMATION WITH DATE AND IDENTIFY
*//*          CONTROL STATEMENT MESSAGE (TRUNCATED TO 20 BYTES)
*//*   4. IBM SMP/PTF/SYSMOD UPDATED INFORMATION AND DATE
*//*   5. LOAD MODULE ATTRIBUTE INFORMATION  ON "ATTRLIST"
*//*-----------------------------------------------------------
*//* PARM='LC=60,M=(MOD1,MOD2,....,MOD3)'
*//*   WHERE:
*//*      LC=99 (LINE COUNT (DEFAULT=60))
*//*      M=(MODULE,...,MODULE)
*//*      M=ALL    ALL OF THE MEMBERS OF THE DSN
*//*      M=MODULE     SELECTED MODULE OF THE DSN
*//*      M=+2000   SKIP FIRST 2000 MEMBERS
*//*       NOTE:THE PROGRAM CUTS OFF AFTER 2000 MEMBERS DUE TO PGM
*//*                SIZES (CAN BE REMODIFIED AT YOUR OWN RISK)
*//*      M=*        SELECTED MODULE NAMES MATCHED
*//*                      WITH THE FIRST NUMBER OF BYTES ENDING
*//*                       WITN ASTERISK CHARACTER OR NOT.
*//*             (I.E.  IST*  AS ALL VTAM MODULES
*//*                    I*    AS ALL MODULE NAMES BEGIN WITH "I"
*//*                 OR IKJ*  AS ALL TSO MODULES)
*//*-----------------------------------------------------------
*        JCL SAMPLE TO RUN LISTPTF
*//LSYSMODS EXEC PGM=LISTPTF,PARM='LC=60,M=&MEM',REGION=2000K
*//STEPLIB DD DSN=XXXX,DISP=SHR,UNIT=3350
*//PDS DD DSN=&PREFIX..&DSN,DISP=SHR
*//CONTENTS DD SYSOUT=A,DCB=(RECFM=FBA,LRECL=121,BLKSIZE=2420)
*//ATTRLIST DD SYSOUT=A,DCB=(RECFM=FBA,LRECL=121,BLKSIZE=2420)
*//SYSUDUMP DD SYSOUT=A
*//SYSABEND DD SYSOUT=A
*//  PEND
*//**   VTAM MEMBERS
*//*VTAM EXEC PTFMEM,DSN=VTAMLIB,PREFIX='SYS1',MEM=IST
*//*VTAM EXEC PTFMEM,DSN=LPALIB,PREFIX='SYS1',MEM=IST
*//*VTAM EXEC PTFMEM,DSN=LINKLIB,PREFIX='SYS1',MEM=IST
*//*VTAM EXEC PTFMEM,DSN='CBIPO.LINKLIB',PREFIX='SYS1',MEM=IST
* -------------------------------------------------------------------
*   DOR/CDSI REVISED 10/7/86  - IMPROVED ALGORITHM TO USE ESDID
*      WHEN THERE IS A MODULE WHICH HAS A LARGE NUMBER OF CSECTS.
*      COMMONLY NCP/37X5 MODULES.  INCREASED TO 4000 ESDID ID'S.
* -------------------------------------------------------------------
* ABEND CODES  1111  JFCB READ INCORRECTLY
*              1112  TEMP WHEN DIR READ ERROR
*              1113  TEMP WHEN ESDID NOT MATCH WITH SYMTBL ESDID
*              1114  TEMP WHEN SYSTAB IS TOO SMALL;INCREASE SIZE
*              1115  ERROR WHEN ESDID IS OVER 4000; INCREASE SIZE
*              1116  ERROR WHEN ESDID IS OVER 4000; INCREASE SIZE
*     PRINT IDR  TO SHOW PTF UPDATED OF LINKLIB
*
         SPACE
         PRINT  GEN
LISTPTF  START
         USING *,R12
         B     @PROLOG-*(,15)
         DC    AL1(11),CL11'LISTPTF '
         DC    CL16' &SYSDATE &SYSTIME '
@SIZE    DC    AL1(1),AL3(@DATAL)
@PROLOG  STM   14,12,12(13)
         LR    R12,15
         LR    R4,R1
         L     R0,@SIZE
         GETMAIN R,LV=(0)
         LR    R8,R1
         USING @DATA,R8
         SPACE
         ST    R13,4(,R8)          CHAIN FORWARD
         ST    R8,8(,R13)          CHAIN BACK
         LR    R13,R8              SET SAVEAREA POINTER
         SPACE
         L     R0,=F'24000'     12*2000 MEMBERS
         GETMAIN R,LV=(0)
         LR    R9,R1
         LR    R1,R4
*        LA    R9,NAMBUF
         ST    R9,NAMBUFAD
*       NAMBUF FORMAT:
*       BYTE 0-7  NAME OF MODULE
         LA    R9,M1X
         ST    R9,XADDR
         MVC   PARMLCT(2),=CL2'60'
         LA    R9,60
         ST    R1,PARMPTR
         L     R1,0(0,R1)   GET PARM FLD
         LH    R10,R10
         LH    R10,0(0,R1)  GET THE PARM COUNT
         STH   R10,PARMLEN
         LTR   R10,R10    SEE IF PARM FLD EMPTY
         BZ    STARTUP     NO NEED TO CALCULATE COUNT
         BAL   R1,PARMPARM
PARMPTR  DC    F'0'           POINTER TO PO RECORD
PARMLEN  DC    H'0'           PARM LENGTH
PARMLCT  DC    CL2'60'        LINE COUNT
PBEGNPTR DC    F'0'           PARM TABLE BEGIN ADDRESS
PENDPTR  DC    F'0'           PARM TABLE END ADDRESS
PARMSKIP DC    F'0'           PARM TABLE END ADDRESS
PARMPARM L     R15,=V(PARM)
         BALR  R14,R15
         LA    R9,PARMLCT
         PACK  WORK,0(2,R9)
         CVB   R9,WORK  CONVERT INTO A USEABLE FORM
STARTUP  STH   R9,NLINES    LINES PER PAGE
         STH   R9,PCNT   THE INDEX MEMBER COUNTER
         SH    R9,H5  SUB 5 FM LINE COUNT
         STH   R9,NLINES1
         LA    R9,0
         STH  R9,LCNT
         STH  R9,XCNT
         STH  R9,PCNT
         MVI   FIRST,X'FF'   SET FIRST TIME FLAG
*   INSERT TIME DATE ON INDEX LINE
         TIME  DEC                GET DATE IN R1 IN FORM 00YYJJJF
         ST    R0,BADLNGTH        SAVE TIME WHILE YOU'RE AT IT
         LR    R2,R1              PUT IN R2 TO PASS TO DATE SUBROUTINE
         LA    R1,DATERSLT    PTR TO PTR TO DATE'S RESULT FIELD
         L     R15,=V(DATE)       IRSS DATE SUBROUTINE (DATECONV)
         BALR  R14,R15            CONVERT 00YYJJJF TO MM/DD/YY
         ED    TIMERSLT,BADLNGTH  EDIT INTO PAGE HEADER LINE BUFFER
         LA    R1,6   INITIALIZE
         STH   R1,XCNT   THE INDEX MEMBER COUNTER
         RDJFCB  (PODCB)    READ  J F C B  FOR   DSNAME
         LTR   R15,R15      TEST FOR A GOOD READ  JFCB
         BZ    JFCBOK      IF  ZERO    O K
         ABEND 1111,DUMP    SOMETHING IS WRONG  ABORT
JFCBOK   MVC   DSN(44),POJFCB  MOVE DSNAME  INTO THE TITLE
         MVC   DSN01(44),POJFCB  MOVE IN DSNAME INTO INDEX
     OPEN  (PODCB,,INDCB,(OUTPUT),ATTRDCB,(OUTPUT))
         PUT   INDCB,INDEX    INDEX TITLE
         L     R10,XTITLEA
         PUT   INDCB,(R10)    HEADER
         L     R10,XTITLEB
         PUT   ATTRDCB,(R10)    HEADER
         USING IHADCB,R10
         LA    R10,PODCB
*  ROUND UP BLKSIZE TO A MULTIPLE OF 8
         LH    R6,DCBBLKSI
         LA    R5,7
         AR    R6,R5
         OR    R6,R5
         XR    R6,R5
         LA    R6,0(0,R6)
         LR    R0,R6
         ST    R6,POBUFFSI
         LH    R6,DCBBLKSI
         LA    R7,80    SET LRECL TO 80 FOR DEBLOCKING
*  GET A BUFFER FOR INPUT
         GETMAIN R,LV=(0)
         ST    R1,PODECB+12
*  TEST FOR RECFM=FB
         TM    DCBRECFM,X'90' IS RECFM=FB
         BNO   SET     YES
         MVI   FBSW+1,X'00'  NO
         LH    R6,DCBBLKSI
         LH    R7,DCBLRECL
SET      SR    R3,R3   SET MEMBER COUNT TO ZERO
         L     R11,NAMBUFAD
         LA    R3,1(R3)   KEEP MEMBER COUNT
READIR   CLOSE PODCB
         MVC   ORG1(2),DCBDSORG  SAVE DCB DATA FROM INPUT DATA SET.
         MVC   FOR1(1),DCBRECFM
         MVC   REC1(2),DCBLRECL
         MVC   SIZ1(2),DCBBLKSI
         MVC   DCBDSORG(2),ORG2  SET DCB DATA TO READ DIRECTORY.
         MVC   DCBRECFM(1),FOR2
         MVC   DCBLRECL(2),REC2
         MVC   DCBBLKSI(2),SIZ2
         OPEN  PODCB
NEXREC   READ  DRDECB,SF,PODCB,BUFFER
         CHECK DRDECB
         LA    2,BUFFER
         AH    R2,BUFFER   DIR BLK COUNT
         ST    2,BUFEND            END OF THE  BUFFER
         LA    2,BUFFER+2
NEXMEM   C     2,BUFEND
         BNL   NEXREC    BRANCH TO GET NEXT RECORD
STONAM   EQU   *
         CLI   0(R2),X'FF'   END OF DIRECTORY
         BE    FINDSTO
         TM    11(R2),X'80'  ALIAS MEMBER
         BO    NEXTTRC       YES, IGNORE THIS MEMBER NAME
         L     R5,PBEGNPTR
         LTR   R5,R5
         BZ    FINDSTO       DEFAULT  NO PARMLIST
         CLI   1(R5),C'+'
         BNE   STOLOOP
         C     R3,PARMSKIP
         BH    STOLOOP
         B     NEXTTRC
STOLOOP  ICM   R4,1,0(R5)
         STC   R4,STOMOD+1
STOMOD   CLC   1(8,R5),0(R2)
         BE    FINDSTO
         CLC   1(3,R5),=CL3'ALL'
         BE    FINDSTO
         LA    R5,9(R5)
         CLI   0(R5),X'FF'
         BE    NEXTTRC
         B     STOLOOP
FINDSTO  EQU   *
         MVC   0(8,R11),0(R2)    STORE MEMBER NAME IN NAME BUFFER.
         MVC   MNAME(8),0(R2)    SET UP MEMBER NAME IN HEADER
         CLI   0(R2),X'FF'   END OF DIRECTORY
         BE    RESDCB
         BAL   R1,CLEAR2
         LA    R9,PRTBUFF+1
         L     R15,=V(ATTRPRT)    PRINT ATTRIBUTE OF LOAD MODULE
         BALR  R14,R15
         PUT   ATTRDCB,PRTBUFF
         BAL   R1,CLEAR2
         LA    R9,PRTBUFF+1
         L     R15,=V(ATTRPRT2)    PRINT ATTRIBUTE OF LOAD MODULE
         BALR  R14,R15
         PUT   ATTRDCB,PRTBUFF
         LA    R11,8(R11)        MOVE POINTER.
         LA    R3,1(R3)          KEEP MEMBER COUNT.
         C     R3,=F'4000' MAXIMUM MEMBERS THAT PGM HOLD
         BL    NEXTTRC
         MVC   0(8,R2),=XL8'FFFFFFFFFFFFFFFF' TREAT AS END OF DIRECTORY
         B     FINDSTO
NEXTTRC  LR    R6,R2             SAVE MEMBER ADDRESS
LTTRC    L     R5,8(0,R2)        TTRC TO REG. 5
         SLL   5,27
         SRL   5,26
         AR    2,5
         AH    2,CON12
         B     NEXMEM    GET THE NEXT MEMEBER
RESDCB   CLOSE PODCB
         ST    R3,TOTMEM
         C     R3,=F'0'
         BE    NOMEM
         SLL   R3,6        MULTIPLES OF 64
         LR    R0,R3
         GETMAIN R,LV=(0)
         ST    R1,NAMTAB2
         AR    R1,R3
         ST    R1,NAMEND2
         L     R3,TOTMEM
         MVC   DCBDSORG(2),ORG1
         MVC   DCBRECFM(1),FOR1
         MVC   DCBLRECL(2),REC1
         MVC   DCBBLKSI(2),SIZ1
         L     R6,NAMTAB2
         USING  PTFTAB,R6
         L     R11,NAMBUFAD
MVTAB    EQU   *
         C     R6,NAMEND2
         BNL   MVDONE
         MVI   0(R6),X'40' CLEAR TABLE
         MVC   1(63,R6),0(R6) CLEAR TABLE
         MVC   0(8,R6),0(R11)   MOD NAME
         CLI   0(R11),X'FF'     IS THAT ALL OF THE MEMBERS
         BE     MVDONE          END OF TRANSFER
         LA    R11,8(R11)
         LA    R6,64(R6)
         BCT   R3,MVTAB
MVDONE   L     R3,TOTMEM
         DROP R6
*        SR   R15,R15
*        B    EXITX
SICK     OPEN  PODCB
LOADAD   L     R11,NAMBUFAD      LOAD ADDRESS OF THE NAME BUFFER.
         CLI   0(R11),X'FF'  IS THAT ALL OF THE MEMBERS
         BNE   FIND2   GO GET ANOTHER
         BAL   R1,CLEAR1
         MVC   PRTBUFF(29),NODATA     NO  SYSIN  DATA
         PUT   INDCB,PRTBUFF
         B     CLOSE    GET OUT
FIND2    L     R11,NAMTAB2
         USING PTFTAB,R11
FIND     MVC   MNAME(8),PTFMOD    SET UP MEMBER NAME IN HEADER
         ST    R11,NAMTABS
         MVI   MODFLG,X'00'
         MVC   ESDIDX(2),=XL2'0FFF'      TO RESET TO SYMTAB ADDRESS
         FIND      PODCB,(R11),D
         LTR   R15,R15
         BNZ   FERR    FIND ERROR GO TO FERR
*****   CHK COUNT  TO SEE IF ENOUGH ROOM
         CLI   FIRST,X'FF'   IS IT THE FIRST TIME
         BNE   NOT1
         MVI   FIRST,X'00'    RESET THE FIRST TIME FLAG
         B     READPO     GET  THE DATA
NOT1     LH    R2,LCNT   GET LINE COUNT
         CH    R2,NLINES1    IS THERE ENUF ROOM FOR 5 LINES
         BNH   SPAGE    ENOUGH CONTINUE ON THIS PAGE
         B     READPO     GET  THE DATA
SPAGE    AH    R2,H3      UP COUNTER BY 3
         STH   R2,LCNT
         B     READPO     GET  THE DATA
FERR     EQU   *
         MVC   PRTBUFF+1(8),PTFMOD
*        MVC   PRTBUFF+10(47),NOMBR AND GO READ ANOTHER CARD
*        PUT   INDCB,PRTBUFF
         B     NEXT
READPO   L     R9,PODECB+12
         READ  PODECB,SF,PODCB,DUMMY,'S'
         CHECK PODECB
         L     R5,PODECB+16   GET IOB ADDRESS
         LH    R4,14(0,R5)    GET CSW RESIDUAL COUNT
         LR    R3,R6          GET BLKSIZE IN REG 8
         SR    R3,R4          ACTUAL BYTES READ IN REG 8
*****  REGISTER  R2   WILL CONTAIN  THE LCNT FOR THE ENTIRE ROUTINE PUT
         B     PUT2
PUT      LH    R2,LCNT
         CH    R2,NLINES
         BNH   PUTOK
         BAL   R4,PAGE    PAGE COUNT
*        MVC   CONT(8),CONTD      MOVE CONT'D TO PRINT LINE
*        MVI   CONT,C'*'   ASTERISK IT BACK AGAIN
*        MVC   CONT+1(7),CONT    ASTERISK REST OF 7 CHARS
         B     READPO
PUT2     EQU   *
PUTOK    CLI   0(R9),X'80'
         BE    CSECT
         STM   R1,R13,SAVER1
         CLI   0(R9),X'20'
         BNE   PUTNOOK
         ST    R9,MODPTR
         USING SYMTBL,R6
         BAL   R1,CESDPARM
MODPTR   DC    F'0'           POINTER TO PO RECORD
MODFLG   DC    X'0000'        FLAGS
ESDCNT   DC    H'0'           ESDID COUNTS
BEGNPTR  DC    F'0'           ESDID TABLE BEGIN ADDRESS
CURRPTR  DC    F'0'           NEXT ESDID ADDRESS (USE BY CESD ROUTINE)
ENDPTR   DC    F'0'           ESDID TABLE END ADDRESS
BTABPTR  DC    F'0'           ESDID POINTER TABLE ADDRESS
CESDPARM L     R15,=V(CESD)
         BALR  R14,R15
         MVI   MODFLG,X'FF'   ALREADY SAME MEMBER
         MVI   RECSWT,X'00'
         B     NXTPO
PUTNOOK  EQU   *
         CLI   TRASWT,X'FF'
         BE    ONTRACE
         MVI   TRASWT,X'FF'    TURN ON TRACE
*        CALL TRACE
ONTRACE  EQU   *
         CLI   PRTSWT,X'FF'
         BNE   NXTPO
         B     NOPRT
CSECT    STM   R1,R13,SAVER1
         SR    R6,R6
         IC    R6,1(R9)       PICK RECORD LENGTH
         S     R6,=F'2'
         ST    R6,IDRLEN
         LA    R6,3(R6)
         AR    R6,R9
         ST    R6,DATAEND
         MVC   CFLG(1),2(R9) COPY SUB TYPE INDICATOR
         NI    CFLG,X'0F' CLEAR HIGH ORDER BITS AND SAVE HALF BYTE
         TM    2(R9),X'80'   CHECK LAST RECORD OF  IDR
         BZ    CSECT2
         MVI   PRTSWT,X'FF' INDICATOR SHOWS END OF IDR RECORDS
CSECT2   EQU   *
         LA    R9,3(R9) BUMP TO BEGIN OF DATA
         CLI   CFLG,X'01'   HMASPZAP DATA
         BE    ZAPMOD
         CLI   CFLG,X'02'   LINKAGE EDITOR DATA
         BE    LKDMOD
         CLI   CFLG,X'04'   TRANSLATOR DATA
         BE    TRAMOD
         CLI   CFLG,X'08'   USER DATA (LINK. EDITOR IDENTIFY FUNCTION)
         BE    USEMOD
         B     NXTPO         ALL OTHERS IGNORED
PRINT    LA    R2,1(0,R2)   UP BY ONE
         STH   R2,LCNT
         PUT   INDCB,PRTBUFF
         MVI   PRTBUFF,X'40'   SINGLE SPACE
         B     NEXT
*
NOPRT    LM    R1,R13,SAVER1
         CLI   PRTSWT,X'FF'
         BNE   READPO
         MVI   PRTSWT,X'00'
         STM   R1,R13,SAVER1
         BAL   R2,INDMEM   PRINT MEMBERS AND IDRS BELONGS TO MEMBER
         LM    R1,R13,SAVER1
         B     NEXT   TO SAVE FURTHER SCANNING WITHIN MEMBER
NXTPO    LM    R1,R13,SAVER1
FBSW     B     READPO
*  DEBLOCK THE BUFFER
         AR    R9,R7          ADD LRECL TO POBUFF ADDR
         SR    R3,R7          SUB LRECL FROM BUFF SIZE
         CR    R3,R7
         BL    NXTPO
         B     PUT
ZAPMOD   EQU   *
         MVI   RECSWT,X'00'
         CLI   0(R9),X'00'
         BE    NOPRT
ZAPMODX  SR    R2,R2
         IC    R2,0(R9)
         N     R2,=F'63'   TREAT AS X'3F' (KEEP BITS 3-7)
         ST    R2,ZAPENTRS
         LA    R9,1(R9)   BUMP FLAG AND COUNT
ZAPMOD2  EQU   *
         BAL   R2,FINDESD ESDID ALWAYS ON FIRST BYTE OF R9
         B     ZAPFERR
         SR    R2,R2
         IC    R2,ZAPCNT
         LA    R2,1(R2)
         C     R2,=F'10'   MAX ZAPIDR PER ESDID
         BH    ZAPFERR
         STC   R2,ZAPCNT
         BCTR  R2,0
         SLL   R2,4      MULTIPLE OF 16 BYTES FOR EACH ZAPIDR
         LA    R3,ZAPIDR
         AR    R3,R2
         MVC   0(11,R3),2(R9)
ZAPFERR  EQU   *
         L     R3,ZAPENTRS
         BCTR  R3,0
         ST    R3,ZAPENTRS
         LTR   R3,R3
         BZ    NOPRT
         LA    R9,13(R9)      BUMP NEXT ZAP IDR DATA
         B     ZAPMOD2
LKDMOD   EQU   *
         MVC   PTFASM(15),0(R9)
         B     NOPRT
TRAMOD   EQU   *
*        CLI   TRASWT,X'FF'
*        BNE   TRACOFF
*        MVI    TRASWT,X'00'
TRACOFF  EQU    *
*        RECSWT = 01     TRANSLATOR WITH PLS (31 CHARS)
*        RECSWT = 02     TRANSLATOR WITHOUT PLS (18 CHARS)
*        RECSWT = 04     ESDID IS BEFORE RECORD BREAK AS SHORT
*        RECSWT = 08     ESDID IS AFTER REC BRK AND NEW REC (R9)
*        RECSWT = 00     NO RECORD BREAK
*        RECSWT+1 =      BYTES USED FROM PREVIOUS RECORD
         TM    RECSWT,X'01' RECORD SPLIT IN UNEVEN DATA LENGTH
         BO    TRAMBRK2
         TM    RECSWT,X'02' RECORD SPLIT IN UNEVEN DATA LENGTH
         BO    TRAMBRS2
         TM    RECSWT,X'04' RECORD SPLIT IN UNEVEN DATA LENGTH
         BO    TRAMBRE2
TRAMODU1 TM    RECSWT,X'08' RECORD SPLIT IN UNEVEN DATA LENGTH
         BZ    TRAMODU
         NI    RECSWT,X'F7'   KICK X'08' OFF
         LA    R7,IDRSAVE
         SR    R6,R6
         LR    R3,R9       LOAD NEXT ESDID ADDR
         IC    R6,RECSWT+1 LOAD BRK REC LENGTH
         SR    R3,R7       SUBTRACT FIRST ESDID ADDR
         SR    R3,R6       SUBTRACT BRK REC LENGTH
         L     R9,DATAADR2 GET NEW REC ADDR
         AR    R9,R3       BUMP TO NEXT ESDID
         MVC   DATAEND(4),DATAEND2 SWAP BACK OF NEW REC END ADDR
         L     R3,DATAEND
         SR    R3,R9
         C     R3,=F'0'
         BE    NOPRT        LAST IDR OF THE IDR RECORD
TRAMODU  ST    R9,DATAADR
*------  IDR REPEATER OF ESDID BEFORE TRANSLATOR DATA
TRAMODS  TM    0(R9),X'80'       LAST ESDID HAVE HIGH BIT ON
         BO    TRAMOD2
         L     R3,DATAEND
         SR    R3,R9
         LR    R7,R9
         C     R3,=F'3'
         BNH   PLS2A    SHORT ESDID AT END OF RECORD (REC BRK)
         LA    R9,2(R9)      BUMP NEXT DATA
         B     TRAMODS
*------  END OF IDR REPEATER OF ESDID BEFORE TRANSLATOR DATA
TRAMOD2  EQU   *
         MVC  IDRPLS(1),2(R9)     TRANSLATOR INDICATOR
* ---    RESET POINTER TO BEGIN WITH FIRST ESDID REPEATER
         L     R7,DATAADR
* ---    NEXT  POINTER TO CONTINUE WITH NEXT ESDID
TRAMOD2A CR    R9,R7
         BE    TRAMOD3      THE FIRST ESDID  WITH HIGH BIT ON
         OI    RECSWT,X'80' TURN ON SWITCH FOR HIGH BIT OFF
         L     R3,DATAEND
         SR    R3,R9
* ------ TO CHECK TYPE OF DATA FIELD FOR CONTAINING PLS DATA
         TM    IDRPLS,X'01'   PL/S FIELD ?
         BZ    NOPLS2A
         C     R3,=F'33' ONE WITH PLS DATA
         BNL   ESDIDIA
         B     PLS2A
NOPLS2A  C     R3,=F'18' ONE WITHOUT PLS
         BNL   ESDIDIA
* -----  IDR RECORD BREAKER  - FIRST RECORD ------
PLS2A    L     R3,DATAEND  END OF DATA ADDRESS
         SR    R3,R7       BEGIN OF FIRT ESDID
         STC   R3,RECSWT+1
         BCTR  R3,0
         STC   R3,TRAMVS+1
TRAMVS   MVC   IDRSAVE(255),0(R7) MOVE TO SAVE IDR UNTIL NEXT RECORD
         OI    RECSWT,X'04' ESDID AT BREAK
         ST    R7,SAVER7
         B     NXTPO
* -----  IDR RECORD BREAKER ---SECOND RECORD------
TRAMBRE2 EQU   *
         ST    R9,DATAADR2
         NI    RECSWT,X'FB' KICK X'04' OFF
         OI    RECSWT,X'08'
         LA    R7,IDRSAVE
         SR    R6,R6
         IC    R6,RECSWT+1     GET BYTE LENGTH
         BCTR  R6,0            LESS ONE BYTE
TRAMBRE3 LA    R2,255
         SR    R2,R6
         STC   R2,ESDMV+1
         AR    R6,R7
ESDMV    MVC   1(255,R6),0(R9)
         LA    R9,IDRSAVE
         MVC   DATAEND2(4),DATAEND
         LA    R3,IDRSAVE+255
         ST    R3,DATAEND
         B     TRAMODU
*------- ESDID WITH NO TRANSLATOR DATA
ESDIDIA  MVC   ESDIDX(2),0(R7)
         BAL   R2,FINDESDA    ESDID ALWAYS ON FIRST BYTE OF R9
         B     TRAFERR
         B     TRAMOD3A
*------- ESDID WITH  TRANSLATOR DATA
TRAMOD3  EQU   *
         L     R3,DATAEND
         SR    R3,R9
         LTR   R3,R3
         BZ    NXTPO
* ------ TO CHECK TYPE OF DATA FIELD FOR CONTAINING PLS DATA
         TM    2(R9),X'01'   PL/S FIELD ?
         BZ    NOPLS3A
         C     R3,=F'33' ONE WITH PLS DATA
         BNL   ESDID3A
         B     PLS2A IDR RECORD BREAKER
NOPLS3A  C     R3,=F'18' ONE WITHOUT PLS
         BNL   ESDID3A
         B     PLS2A IDR RECORD BREAKER
ESDID3A  BAL   R2,FINDESD ESDID ALWAYS ON FIRST BYTE OF R9
         B     TRAFERR2
         NI    RECSWT,X'7F'      TURN OFF BIT
TRAMOD3A TM    2(R9),X'01'   PL/S FIELD ?
         BZ    NOPLS
* ---TRANSLATOR WITH PLS DATA -------------------------------------
         L     R3,DATAEND
         SR    R3,R9
         C     R3,=F'33'
         BL    TRAMBRK
         MVC   TRANIDR(31),2(R9) OFFSET BY ESDID BYTES
         TM    RECSWT,X'80'
         BZ    TRAMOD4
TRAFERR  LA    R7,2(R7)
         B     TRAMOD2A
TRAMOD4  L     R3,DATAEND
         SR    R3,R9
         S     R3,=F'33'   TRANSLATOR LENGTH
         C     R3,=F'0'
         BNH   NOPRT       IDR RECORD IS DONE TO STORE
         LA    R9,33(R9)      BUMP NEXT DATA
* ------ END OF IDR RECORD  CHECKING  PERHAPS REQUIRED BREAKING
TRAMOD5  L     R3,DATAEND
         SR    R3,R9
         C     R3,=F'5'
         BH    TRAMODU1
         LR    R7,R9
         B     PLS2A       REQUIRED BREAK
TRAMBRK  EQU   *
         S     R3,=F'2'        LESS ESDID
         STC   R3,TRAMVC+1
TRAMVC   MVC   TRANIDR(31),2(R9)
         OI    RECSWT,X'01'
         STC   R3,RECSWT+1
         ST    R6,SAVER6
         B     NXTPO
TRAMBRK2 EQU   *
         L     R6,SAVER6
         LA    R3,32
         SR    R2,R2
         IC    R2,RECSWT+1
         SR    R3,R2
         AR    R6,R2          MOVE SYMTAB BY NO OF BYTES
         STC   R3,RECSWT+1
         BCTR  R3,0           LESS ONE BYTE TO MVC
         STC   R3,TRAMV2+1
TRAMV2   MVC   TRANIDR(31),0(R9)
         NI    RECSWT,X'FE'
         IC    R3,RECSWT+1
         AR    R9,R3               BUMP RECORD POSITION
         B     TRAMODU1
* ---TRANSLATOR WITHOUT PLS DATA ---------------------------------
NOPLS    EQU   *
         L     R3,DATAEND
         SR    R3,R9
         C     R3,=F'18'
         BL    TRAMBRS
         MVC   TRANIDR(16),2(R9) ESDID OFFSET BY 2 BYTES
         TM    RECSWT,X'80'
         BZ    TRAMOD42
         LA    R7,2(R7)
         B     TRAMOD2A
TRAMOD42 EQU     *
         L     R3,DATAEND
         SR    R3,R9
         S     R3,=F'18'    TRANSLATOR LENGTH
         C     R3,=F'0'
         BNH   NOPRT        END OF IDR RECORD FULLFILLED
         LA    R9,18(R9)      BUMP NEXT DATA
         B     TRAMOD5  CKECK END OF IDR RECORD
TRAMBRS  EQU   *
         S     R3,=F'2'        LESS ESDID
         STC   R3,TRAMVCS+1
TRAMVCS  MVC   TRANIDR(16),2(R9)
         OI    RECSWT,X'02'
         STC   R3,RECSWT+1
         ST    R6,SAVER6
         B     NXTPO
TRAMBRS2 EQU   *
         L     R6,SAVER6
         LA    R3,16
         SR    R2,R2
         IC    R2,RECSWT+1
         SR    R3,R2
         AR    R6,R2          MOVE SYMTAB BY NO OF BYTES
         STC   R3,RECSWT+1
         BCTR  R3,0           LESS ONE BYTE TO MVC
         STC   R3,TRAMVS2+1
TRAMVS2  MVC   TRANIDR(16),0(R9)
         NI    RECSWT,X'FD'
         IC    R3,RECSWT+1
         AR    R9,R3               BUMP RECORD POSITION
         B     TRAMODU1
* ---- INVALID ESDID CODE --  IGNORE THE ESDID DATA ---------------
TRAFERR2 NI    RECSWT,X'7F'      TURN OFF BIT
         TM    2(R9),X'01'   PL/S FIELD ?
         BZ    NOPLSXA
         C     R3,=F'33' ONE WITH PLS DATA
         BNL   ESDIDXA
         B     PLS2A IDR RECORD BREAKER
ESDIDXA  LA    R9,33(R9)      BUMP NEXT DATA
         B     TRAMODU1
NOPLSXA  C     R3,=F'18' ONE WITHOUT PLS
         BNL   ESDIDXB
         B     PLS2A IDR RECORD BREAKER
ESDIDXB  LA    R9,18(R9)      BUMP NEXT DATA
         B     TRAMODU1
* -----------------------------------------------------------------
USEMOD   EQU   *
*        RECSWT = 04     ESDID IS BEFORE RECORD BREAK AS SHORT
*        RECSWT = 08     ESDID IS AFTER REC BRK AND NEW REC (R9)
*        RECSWT = 00     NO RECORD BREAK
*        RECSWT+1 =      BYTES USED FROM PREVIOUS RECORD
         TM    RECSWT,X'04' RECORD SPLIT IN UNEVEN DATA LENGTH
         BO    USEMBRE2
USEMODU1 TM    RECSWT,X'08' RECORD SPLIT IN UNEVEN DATA LENGTH
         BZ    USEMODU
* ------- TO RESET ON NORMAL IDR RECORD AFTER BREAK IDR BEING STORED
         NI    RECSWT,X'F7'   KICK X'08' OFF
         LA    R7,IDRSAVE
         SR    R6,R6
         LR    R3,R9       LOAD NEXT ESDID ADDR
         IC    R6,RECSWT+1 LOAD BRK REC LENGTH
         SR    R3,R7       SUBTRACT FIRST ESDID ADDR
         SR    R3,R6       SUBTRACT BRK REC LENGTH
         L     R9,DATAADR2 GET NEW REC ADDR
         AR    R9,R3       BUMP TO NEXT ESDID
         MVC   DATAEND(4),DATAEND2 SWAP BACK OF NEW REC END ADDR
* ------- RESET TO NORMAL IDR RECORD POINTER ----------------------
USEMODU  ST    R9,DATAADR
         L     R3,DATAEND
         SR    R3,R9
         LTR   R3,R3
         BZ    NOPRT         END OF IDR RECORD
         C     R3,=F'5'
         BH    USESCHK
* -----  IDR RECORD BREAKER  - FIRST RECORD ------
USEMOP   L     R3,DATAEND  END OF DATA ADDRESS
         S     R3,DATAADR  BEGIN OF FIRT ESDID
         STC   R3,RECSWT+1
         BCTR  R3,0
         STC   R3,USEMVS+1
USEMVS   MVC   IDRSAVE(255),0(R9) MOVE TO SAVE IDR UNTIL NEXT RECORD
         OI    RECSWT,X'04' ESDID AT BREAK
         ST    R7,SAVER7
         B     NXTPO
* -----  IDR RECORD BREAKER ---SECOND RECORD------
USEMBRE2 EQU   *
         ST    R9,DATAADR2
         NI    RECSWT,X'FB' KICK X'04' OFF
         OI    RECSWT,X'08'
         LA    R7,IDRSAVE
         SR    R6,R6
         IC    R6,RECSWT+1     GET BYTE LENGTH
         BCTR  R6,0            LESS ONE BYTE
USEMBRE3 LA    R2,255
         SR    R2,R6
         STC   R2,UESDMV+1
         AR    R6,R7
UESDMV   MVC   1(255,R6),0(R9)
         LA    R9,IDRSAVE
         MVC   DATAEND2(4),DATAEND
         LA    R3,IDRSAVE+255
         ST    R3,DATAEND
         B     USEMODU
* -----  ESDID POINTER TO SYSMTAB AND STORE USER IDR
USESCHK  SR    R6,R6
         IC    R6,5(R9)
         A     R6,=F'6'
         CR    R3,R6
         BL    USEMOP
USESDID  BAL   R2,FINDESD ESDID ALWAYS ON FIRST BYTE OF R9
         B     USEFERR
         MVI   PRTSWT,X'FF'
         MVC   USERIDR(3),2(R9) DATE OF USER DATA
         SR    R3,R3
         IC    R3,5(R9)
         STC   R3,USERIDR+3   BUILD LENGTH FOR VARIABLE DATA
         A     R3,=F'6'
         ST    R3,USELEN
         BCTR  R3,0
         CH    R3,=H'20'
         BNH   USESDIK
         LA    R3,20        TRUNICATED TO 20 BYTES ON SYMTAB
USESDIK  STC   R3,MVCPTF+1    BUILD LENGTH
MVCPTF   MVC   USERIDR+4(7),6(R9)
* -----  CHECK THE IDR RECORD IF NEXT IDR IS NEED TO BREAK
         L     R3,DATAEND
         SR    R3,R9
         C     R3,=F'5'
         BNH   USEMOP      REQUIRED BREAK
         L     R3,USELEN
USEFOK   AR    R9,R3          BUMP NEXT DATA
         B     USEMODU1
USEFERR  EQU   *
         SR    R3,R3
         IC    R3,5(R9)
         A     R3,=F'6'
         B     USEFOK
FINDESD  EQU    *
         MVC   ESDIDX(2),0(R9)
FINDESDA NI    ESDIDX,X'7F'       KICK OUT HIGH ORDER BIT
         ST    R7,SAVER7          SAVE R7 FOR MULTPLY
         SR    R6,R6              CLEAR R6 AND R7
         LH    R6,ESDIDX
         C     R6,=F'0'
         BER   R2             ERROR
         C     R6,=F'4000'
         BH    ESDIDERR       ERROR
         SLL   R6,2           MULTIPLE OF FULLWORD(4 BYTES)       DOR
         A     R6,BTABPTR     ADD BEGIN OF EDID POINTER TABLE     DOR
         L     R6,0(R6)       PICK POINTER ADDRESS OF THAT ESDID
         LTR   R6,R6          = ZERO NO ESDID RECORD
         BZR   R2              ERROR
         L     R7,SAVER7
FINDESD2 CLC SYMESDID,ESDIDX
         BE    FINDOK
         BR    R2             ERROR
FINDERR  LA    R6,L'SYMENT(R6)
         CLI   0(R6),X'FF'
         BNE   FINDESD2
         BR    R2               ERROR
FINDOK   LA    R2,4(R2)
         BR    R2
         ABEND   1113,DUMP
ESDIDERR ABEND   1115,DUMP
         DROP   R6
NEXT     BAL   R1,CLEAR   CLEAR THE PRINT BUFFER
         L     R11,NAMTABS
         LA    R11,64(R11)        MOVE POINTER.
         CLI   0(R11),X'FF'    IS IT THE END
         BE    END      THAT'S  ALL FOLKS
         BCT   R3,FIND           CHECK MEMBER COUNT.
END      EQU   *
ENDDONE  BAL   R1,CLEAR1
         B     CLOSE
*
PAGE     CLI   FIRST,X'FF'  IS IT FIRST TIME THROUGH
         BE    PAGE1  YES  DON'T  PRINT THE INDEX LINE
*        BAL   R2,PRNTINDX
PAGE1    UNPK  PAGENO,PNO  GET THE NEXT PAGE NO.
         OI    PAGENO+3,X'F0'
         MVC   PAGEX(4),PAGENO
         AP   PNO,P1
         BR    R4
*
*
CLEAR    MVI   PRTBUFF,X'40'
         MVC   PRTBUFF+1(19),PRTBUFF
         BR    R1
CLEAR1   MVI   PRTBUFF+28,C' '        BLANK BACK OF BUFFER
         MVC   PRTBUFF+29(71),PRTBUFF+28  BLANK BUFFER
         BR    R1     RETURN
CLEAR2   MVI   PRTBUFF,C' '        BLANK BACK OF BUFFER
         MVC   PRTBUFF+1(120),PRTBUFF    BLANK BUFFER
         BR    R1     RETURN
*
*****  MODIFIED INDEX LINE PRINTING ROUTINE
INDMEM   LH    R1,XADDR+4    MEMBER COUNT
         MVI   PRNTSWT,X'00'
         BCT   R1,INDMEMX    SET UP TO PUT MEMBE  NAME INTO RIGHT SLOT
PRNTINDX LH    R1,XCNT        CHECK LINE COUNT
         CH    R1,NLINES       60 FOR R3
         BNH   INDXOK          LEXX THAN 60
         PUT   INDCB,INDEX      PRINT NEW HDR
         L     R3,XTITLEA
         PUT   INDCB,(R3)     HEADER
         LA    R1,6
         STH   R1,XCNT
INDXOK   EQU   *
         MVI   M1X,C' '
         MVC   M1X+1(132),M1X    BLANK OUT THE LINE
         LA    R1,M1X       FIRST INDEX MEMBER NAME
         ST    R1,XADDR     SAVE
         LH    R1,XADDR+6   H'10'
         STH   R1,XADDR+4   SAVE
         B     INDMEM1
INDMEMX  STH   R1,XADDR+4        NEXT MEMBER SLOT
INDMEM1  L     R1,XADDR          NEXT MEMBER SLOT
         ST    R1,PRTPTR
         ST    R2,SAVER2
         ST    R8,DSECPTR
         ST    R11,BEGPPTR
         L     R1,BEGNPTR
         ST    R1,BEGPSYM
         CNOP  0,4 TO ALIGN FOR FULLWORD BOUNDARY
         BAL   R1,PRNTPARM
         DS    0F
PRNTSWT  DC    F'0'
PRTPTR   DS    F
BEGPPTR  DS    F                       CURRENT SYM TBL ADDR
BEGPSYM  DS    F                       CURRENT SYM TBL ADDR
DSECPTR  DS    F
PSYMPTR  DS    F
PRNTPARM L     R15,=V(PRNT)
         BALR  R14,R15
*-----------------------------------------
         CLI   PRNTSWT,X'00'    END OF PRINTER FOR CSECT LINE
         BE    NOSMOD
         LH    R1,XCNT
         LA    R1,1(0,R1)          UP THE COUNT BY ONE
         STH   R1,XCNT        SAVE INDEX LINE COUNT
         PUT   INDCB,XLINE   PRINT INDEX LINE
*-----------------------------------------
         TM    PRNTSWT,X'02'    REPEAT PRINTER FOR CSECT LINE
         BO    PRNTINDX
         TM    PRNTSWT,X'01'    REPEAT PRINTER FOR ZAP LINE
         BO    PRNTINDX
NOSMOD   L     R2,SAVER2
*-----------------------------------------
INDMEM2  EQU   *
*-----------------------------------------
*        LA    R1,40(0,R1)       NEXT MEMBER
*        ST    R1,XADDR          SAVE
         BR    R2                RETURN
ERR      BAL   R1,CLEAR1
         MVC   PRTBUFF+1(29),ERRMES       MOVE IN ERROR MESSAGE
         PUT   INDCB,PRTBUFF
         ABEND   1112,DUMP
NOMEM    BAL   R1,CLEAR1
         MVC   PRTBUFF+1(29),NOMBR        MOVE IN ERROR MESSAGE
         PUT   INDCB,PRTBUFF
CLOSE    CLOSE (PODCB,,INDCB)
*------------ FREE CESD TABLE
         L     R0,ENDPTR           END OF TABLE
         L     R1,BEGNPTR          BEG OF TABLE
         SR    R0,R1              LENGTH OF TABLE
         FREEMAIN R,LV=(0),A=(1)
*------------ FREE PARM TABLE
         L     R0,PENDPTR          END OF TABLE
         L     R1,PBEGNPTR         BEG OF TABLE
         SR    R0,R1              LENGTH OF TABLE
         FREEMAIN R,LV=(0),A=(1)
EXITX    LR    R1,R13
         L     0,@SIZE
         L     13,4(,13)
         ST    15,16(,13)
         FREEMAIN R,A=(1),LV=(0)
         LM    14,12,12(13)
         BR    14
*        RETRN
         EJECT
FIRST    DC    X'00'    FIRST TIME FLAG  =X'FF'  IF SET FIRST TIME
PRTSWT   DC    XL2'0000'
RECSWT   DC    XL2'0000'
CFLG     DC    X'00'
TRASWT   DC    X'00'
IDRPLS   DC    X'00' TRANSLATOR INDICATOR
P1       DC    PL1'1'
PNO      DC    PL3'1'
NLINES   DC    H'60'   NO. LINES   DEFAULT IS  60
NLINES1  DC    H'0'      5 LESS THAN THE   NLINES PARAMETER
LCNT     DC    H'0'
XCNT     DC    H'0'   LINE COUNT OF INDEX
PCNT     DC    H'0'   LINE COUNT OF PTF INDEX
H3       DC    H'3'
H5       DC    H'5'
CON12    DC    H'12'
ESDIDX   DC    XL2'0FFF'
ESDIDY   DC    XL2'0000'
         DS    0F     FULLWORD BOUNDRY
NAMBUFAD DC    F'0'
DUMMY    DC    F'0'
XADDR    DC    A(*),H'1',H'1'
XTITLEA  DC    A(XTITLE)
XTITLEB  DC    A(XTITLE2)
         DS    0D
ORG1     DS    BL2
REC1     DS    BL2
SIZ1     DS    BL2
FOR1     DS    BL1
ORG2     DC    BL2'0100000000000000'
REC2     DC    BL2'0000000100000000'
SIZ2     DC    BL2'0000000100000000'
FOR2     DC    BL1'10000000'
EDMSK    DC    XL6'402020202021'
EDMSKM   DC    XL6'402020202120'
EDMSKV   DC    XL6'402020214B2020'
EDMSKH   DC    XL6'402020217A2020'
DSN      DC    CL45' ',CL40' ',C'PAGE ' DSN=20           54
PAGENO   DC    CL4' '                            109
NOMBR    DC    C' MEMBER NOT FOUND OR IO ERROR READING DIRECTORY'
ERRMES   DC    C' ERROR READING DIRECTORY '
NODATA   DC    C' ** SYSIN DATA NOT INPUT **'
*                12345678901234567890123456789012345
PAGEX    DC    CL6' '    INDEX LINE
INDEX    DC    CL1'1',8CL1'-'
DATERSLT DC    CL8'MM/DD/YY',CL2'  '
TIMERSLT DC    XL11'4021207A20207A20204B20'
         DC    C' - MEMBERS IN '
DSN01    DC    44CL1' ',8CL1'-',CL30' '
         LTORG
         DS    0F
INDCB    DCB   DSORG=PS,MACRF=PM,DDNAME=CONTENTS
ATTRDCB  DCB   DSORG=PS,MACRF=PM,DDNAME=ATTRLIST
PODCB    DCB   DSORG=PO,MACRF=R,DDNAME=PDS,EODAD=NOPRT,SYNAD=ERR,      X
               EXLST=POEXLST
POEXLST  DS    0F
         DC    BL1'10000111',AL3(POJFCB)
POJFCB   DC    22D'0'   176 BYTE AREA FOR J F C B
BUFFER   DS    128H
XTITLE   DC    C' MEMBER   <-- LINKED    DATE -->'
*                012345678901234567890123456789012345678901234567890
      DC    C' <- CSECT   TRANSLATED   DATE         PLS      DATE ->'
         DC    C' <-DATE   UPGRADED PTF      -->'
         DC    CL20' '
         DS    1H
XTITLE2  DC    C' LOAD MODULE ATTRIBUTES INFORMATION'
         DC    CL100' '
         DS    0F
         PRINT  NOGEN
         DCBD  DSORG=PO,DEVD=DA
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         SPACE
@DATA    DSECT
         DS    18F                 REGISTER SAVEAREA
DOUBLE   DS    D
LINKAREA DS    2F
SNAP1    EQU   *
QAREA    DC    A(*) DUMP                      AREA
SNAP2    DC    0F'0',X'80',AL3(*)
SNAPSWT  DC    X'00'
QUOTESWT  DC    X'00'
LEAVESW   DC    X'00'
         DS    0F
SAVER2   DC    F'0'
SAVER6   DC    F'0'
SAVER7   DC    F'0'
SAVER10  DC    F'0'
DATAADR  DC    F'0'
DATAADR2 DC    F'0'
DATAEND  DC    F'0'
DATAEND2 DC    F'0'
SAVER1   DC   18F'0'
TEMP     DC    F'0'
IDRLEN   DC    F'0'
USELEN   DC    F'0'
ZAPENTRS DC    F'0'
BUFEND   DC    F'0'
TOTMEM   DC    F'0'
NAMTAB2  DC    F'0'
NAMTABS  DC    F'0'
NAMEND2  DC    F'0'
WORKF    DC    F'0'
POBUFFSI DC    F'0'
WORK     DC    D'0'
SPACEW   DS    CL5
PRTBUFF  DC    131C' '
         DS    0F
IDRSAVE  DS    CL255
         DS    CL255
         DS    0F
XLINE    DS    C' '      INDEX LINE
M1X      DS    CL10' '   INDEX LINE
M2X      DS    CL10' '   INDEX LINE
M3X      DS    CL10' '   INDEX LINE
M4X      DC    CL10' '   INDEX LINE
M5X      DC    CL10' '   INDEX LINE
M6X      DC    CL10' '   INDEX LINE
M7X      DC    CL80' '   INDEX LINE
M8X      DC    CL10' '   INDEX LINE
M9X      DC    CL10' '   INDEX LINE
M10X     DC    CL36' '   INDEX LINE
         ORG   XLINE
         DS    CL1
PMODNME  DS    CL8
         DS    CL1
PLKED    DS    CL10
         DS    CL1
PLKEDVR  DS    CL2
         DS    CL1
PLKEDTE  DS    CL8
         DS    CL1
PCSECT   DS    CL8
         DS    CL1
PXTORNME DS    CL10
         DS    CL1
PXTVR    DS    CL2
         DS    CL1
PXTDATE  DS    CL8
         DS    CL1
PXPLSNAM DS    CL10
         DS    CL1
PXPLSVR  DS    CL2
         DS    CL1
PXPLSDTE DS    CL8
         DS    CL1
PUPDATE  DS    CL8
         DS    CL1
PPTFNAME DS    CL30
         DC    CL60' '
         DS    0D
BADLNGTH DC    D'0'
         DS    0D
MNAME    DC    CL8' '
*NAMBUF   DS    250D'0'
*         DS    250D'0'
*         DS    250D'0'
*         DS    250D'0'
*         DS    250D'0'
*         DS    250D'0'
*         DS    250D'0'
*         DS    250D'0'
@DATAL   EQU   *-@DATA
         SPACE
PTFTAB   DSECT
PTFMOD   DS   CL8
PTFASM   DS   CL10
PTFASMVR DS   CL2
PTFASDTE DS   PL3
PTFFEA   DS   CL10
PTFFEDTE DS   PL3
PTFSYSMO DS   CL8
PTFUPDTE DS   PL3
PTFRESV  DS   CL17
PTFLNGTH EQU  *-PTFTAB
         DROP R11
         DROP R12
         EJECT
         PRINT  GEN
         DS     0F
ATTRPRT  CSECT
         SAVE  (14,12),T,*
*      R1 = ADDR TO MODULE DIRECTORY ENTRY RECORD
*      R5 = ADDR TO FORST BYTE OF PRINT BUFFER
         LR    R12,R15
         USING ATTRPRT,R12
         LA    R11,4095(R12)   SECOND BASE
         LA    R11,1(,R11)     MAKE IT 4096 X'1000'
         USING ATTRPRT+4096,R11
         LA    R4,ATTRSAVE
         ST    R13,4(,R4)
         ST    R4,8(,R13)
         LR    R13,R4
         USING DIRAREA,R2
         LR    R5,R9
         MVC   0(8,R5),DIRNAME
         LA    R5,9(R5)
         TM    DIRATTR1+1,X'80'    LEVEL E ?
         BZ    NOTLVLE
         MVC   0(17,R5),=CL17'EDITED BY E-LEVEL'
         LA    R5,18(R5)
         B     OPENLINE
NOTLVLE  TM    DIRATTR1+1,X'02'    LEVEL F ?
         BZ    NOTLVLF
         MVC   0(17,R5),=CL17'EDITED BY F-LEVEL'
         LA    R5,18(R5)
         B     OPENLINE
NOTLVLF  TM    DIRATTR2,X'80'    OS/VS   ?
         BZ    NOLVLVS
         MVC   0(17,R5),=CL17'EDITED BY OS/VS  '
         LA    R5,18(R5)
         B     OPENLINE
NOLVLVS  MVC   0(18,R5),=CL18'EDITED BY UNKNOWN'
         LA    R5,18(R5)
OPENLINE TM    DIRATTR1,X'80'    RENT OR NOT RENT
         BZ    NOTRENT
         MVC   0(5,R5),=CL5'RENT'
         LA    R5,5(R5)
         B     ATTRBIT1
NOTRENT  MVC   0(8,R5),=CL8'NO-RENT'
         LA    R5,8(R5)
ATTRBIT1 TM    DIRATTR1,X'40'    REUS OR NOT REUS
         BZ    NOTREUS
         MVC   0(5,R5),=CL5'REUS'
         LA    R5,5(R5)
         B     ATTRBIT2
NOTREUS  MVC   0(8,R5),=CL8'NO-REUS'
         LA    R5,8(R5)
ATTRBIT2 TM    DIRATTR1,X'20'    OVLY OR NOT OVLY
         BZ    NOTOVLY
         MVC   0(5,R5),=CL5'OVLY'
         LA    R5,5(R5)
         B     ATTRBIT3
NOTOVLY  MVC   0(8,R5),=CL8'NO-OVLY'
         LA    R5,8(R5)
ATTRBIT3 TM    DIRATTR1,X'10'    TEST OR NOT TEST
         BZ    NOTTEST
         MVC   0(5,R5),=CL5'TEST'
         LA    R5,5(R5)
         B     ATTRBIT3
NOTTEST   MVC   0(8,R5),=CL8'NO-TEST'
         LA    R5,8(R5)
ATTRBIT4 TM    DIRATTR1,X'08'    LOAD OR NOT LOAD
         BZ    NOLOAD
         MVC   0(5,R5),=CL5'LOAD'
         LA    R5,5(R5)
         B     ATTRBIT5
NOLOAD   MVC   0(8,R5),=CL8'NO-LOAD'
         LA    R5,8(R5)
ATTRBIT5 TM    DIRATTR1,X'04'    BLOCK OR SCATTER
         BZ    BLOCK
         MVC   0(8,R5),=CL8'SCATTER'
         LA    R5,8(R5)
         B     ATTRBIT6
BLOCK    MVC   0(6,R5),=CL6'BLOCK '
         LA    R5,6(R5)
ATTRBIT6 TM    DIRATTR1,X'02'    EXEC  OR NOTEXEC
         BZ    NOTEXEC
         MVC   0(5,R5),=CL5'EXEC'
         LA    R5,5(R5)
         B     ATTRBIT7
NOTEXEC  MVC   0(8,R5),=CL8'NO-EXEC'
         LA    R5,8(R5)
ATTRBIT7 TM    DIRATTR1,X'01'    MULT  OR ONLY   TEXT REC
         BZ    ONLYTXT
         MVC   0(8,R5),=CL8'MULTTXT'
         LA    R5,8(R5)
         B     ATTRBIT9
ONLYTXT  MVC   0(8,R5),=CL8'ONLYTXT'
         LA    R5,8(R5)
ATTRBIT9 TM    DIRATTR1+1,X'40'    ORG=0 OR ORG>0
         BZ    ORGZERO
         MVC   0(9,R5),=CL9'ORIGIN>0'
         LA    R5,9(R5)
         B     ATTRBT10
ORGZERO  MVC   0(9,R5),=CL9'ORIGIN=0'
         LA    R5,9(R5)
ATTRBT10 TM    DIRATTR1+1,X'20'    ENT=0 OR ENT>0
         BZ    ENTZERO
         MVC   0(8,R5),=CL8'ENTRY>0'
         LA    R5,8(R5)
         B     ATTRBT11
ENTZERO  MVC   0(8,R5),=CL8'ENTRY=0'
         LA    R5,8(R5)
ATTRBT11 TM    DIRATTR1+1,X'10'    RLD=0 OR RLD>0
         BZ    RLDZERO
         MVC   0(7,R5),=CL7'RLD#>0'
         LA    R5,7(R5)
         B     RETATTR
RLDZERO  MVC   0(7,R5),=CL7'RLD#=0'
         LA    R5,7(R5)
RETATTR  DS    0H
         L     R13,4(,R13)
         RETURN (14,12),,RC=0 RESTORE REGS AND RETURN
         EJECT
ATTRSAVE     DS    9D
W1Y      DS    F              WORKARE1
W2Y      DS    F              WORKAREA2
ATTR     DS    H
         DS    0F
         LTORG
         DS    0F                          BOUNDARY OF FULLWORDS
         DROP R11
         DROP R12
         EJECT
         PRINT  GEN
         DS     0F
ATTRPRT2 CSECT
         SAVE  (14,12),T,*
*      R1 = ADDR TO MODULE DIRECTORY ENTRY RECORD
*      R5 = ADDR TO FORST BYTE OF PRINT BUFFER
         LR    R12,R15
         USING ATTRPRT2,R12
         LA    R11,4095(R12)   SECOND BASE
         LA    R11,1(,R11)     MAKE IT 4096 X'1000'
         USING ATTRPRT2+4096,R11
         LA    R4,ATTRSAV2
         ST    R13,4(,R4)
         ST    R4,8(,R13)
         LR    R13,R4
         USING DIRAREA,R2
         LR    R5,R9
         LA    R5,9(R5)
ATTRBT12 TM    DIRATTR1+1,X'08'    EDIT  OR NOTEDIT
         BZ    NOTEDIT
         MVC   0(5,R5),=CL5'EDIT'
         LA    R5,5(R5)
         B     ATTRBT13
NOTEDIT  MVC   0(8,R5),=CL8'NO-EDIT'
         LA    R5,8(R5)
ATTRBT13 TM    DIRATTR1+1,X'04'   TESTRAN=0 OR >0
         BZ    NOTESTX
         MVC   0(8,R5),=CL8'TESTRAN'
         LA    R5,8(R5)
         B     ATTRBT15
NOTESTX  MVC   0(10,R5),=CL10'NO-TSTRAN'
         LA    R5,10(R5)
ATTRBT15 TM    DIRATTR1+1,X'01'   REFR OR NOT REFRESHABLE
         BZ    NOTREFR
         MVC   0(8,R5),=CL8'REFRESH'
         LA    R5,8(R5)
         B     ATTB2T0
NOTREFR  MVC   0(8,R5),=CL8'NO-REFR'
         LA    R5,8(R5)
ATTB2T0 TM    DIRATTR2,X'20'   ALIGN2 OR NOT ALIGN2
         BZ    NOTALIGN
         MVC   0(7,R5),=CL7'ALIGN2'
         LA    R5,7(R5)
         B     ATTB2T3
NOTALIGN MVC   0(8,R5),=CL8'NO-ALIG'
         LA    R5,8(R5)
ATTB2T3 TM    DIRATTR2,X'10'   SSI OR NOSSI
         BZ    NOTSSI
         MVC   0(4,R5),=CL4'SSI'
         LA    R5,4(R5)
         B     ATTB2T4
NOTSSI   MVC   0(7,R5),=CL7'NO-SSI'
         LA    R5,7(R5)
ATTB2T4 TM    DIRATTR2,X'08'   AC=
         BZ    NOAC
         MVC   0(3,R5),=CL3'AC='
         LA    R5,3(R5)
         SR    R4,R4
         IC    R4,DIRAUTHC
         CVD   R4,W1X                   CONVERT BINARY TO PACKED
         OI    W2X+3,X'0F'
         UNPK  0(3,R5),W2X+2(2)
         LA    R5,4(R5)
         B     RMODE
NOAC     MVC   0(6,R5),=CL6'NO-AC'
         LA    R5,6(R5)
RMODE    TM    DIRINFO,X'10'   RMODE=24 OR RMODE=ANY
         BZ    RMODE24
         MVC   0(10,R5),=CL10'RMODE-ANY'
         LA    R5,10(R5)
         B     AMODE1
RMODE24  MVC   0(9,R5),=CL9'RMODE-24'
         LA    R5,9(R5)
AMODE1   TM    DIRINFO,X'0C'   AMODE=24,31 OR ANY
         BZ    AMODE124
         BM    AMODE131
         MVC   0(11,R5),=CL11'AMODE1-ANY'
         LA    R5,11(R5)
         B     AMODE2
AMODE124 MVC   0(10,R5),=CL10'AMODE1-24'
         LA    R5,10(R5)
         B     AMODE2
AMODE131 MVC   0(10,R5),=CL10'AMODE1-31'
         LA    R5,10(R5)
AMODE2   TM    DIRINFO,X'03'   AMODE=24,31 OR ANY
         BZ    AMODE224
         BM    AMODE231
         MVC   0(11,R5),=CL11'AMODE2-ANY'
         LA    R5,11(R5)
         B     RETATTR2
AMODE224 MVC   0(10,R5),=CL10'AMODE2-24'
         LA    R5,10(R5)
         B     RETATTR2
AMODE231 MVC   0(10,R5),=CL10'AMODE2-31'
         LA    R5,10(R5)
RETATTR2 DS    0H
         L     R13,4(,R13)
         RETURN (14,12),,RC=0 RESTORE REGS AND RETURN
         EJECT
ATTRSAV2     DS    9D
W1X      DS    F              WORKARE1
W2X      DS    F              WORKAREA2
         DS    0F
         LTORG
         DROP  R11
         DROP  R12
         EJECT
         PRINT  GEN
         DS    0F                          BOUNDARY OF FULLWORDS
DATE     CSECT
         SAVE  (14,12),T,*
*      R1 = ADDR FOR OUTPUT (DS CL8'MM/DD/YY')
*      R2 = R1 FROM THE TIME MACRO
         LR    R12,R15
         USING DATE,R12
         LA    R11,4095(R12)   SECOND BASE
         LA    R11,1(,R11)     MAKE IT 4096 X'1000'
         USING DATE+4096,R11
         LA    R3,DATESAVE
         ST    R13,4(,R3)
         ST    R3,8(,R13)
         LR    R13,R3
         USING PARMAREA,R1
*        L     R1,0(,R1)   GET ADDR FOR OUTPUT            *LACCD*
         ST    R2,W2                    STORE DATE (00YYDDDF)
         SR     R2,R2
         IC    R2,W2+1              PICK YY FROM 00YYDDDF
         SLL   R2,4                 SHIFT 00YY TO 0YY0
         O     R2,=X'0000900F' 0YY0 TO 9YYF
         ST    R2,OVERLAP
         MVC   WRKPKYR+1(2),OVERLAP+2
         OI    WRKPKYR,X'01'         009YYF TO 019YYF
         ZAP   WRKPKNUM(8),WRKPKYR(3)
         DP    WRKPKNUM(8),=PL1'4'   DIVISABLE BY FOUR
         ZAP   WRKLEAPS,WRKPKNUM(7)  SAVE QUOTIENT
         ZAP   WRKLEAPR,WRKPKNUM+7(1)  SAVE REMAINDER
         MVI   MONTHTBL+5,28            SETUP FEB NONLEAP YEAR
         CP    WRKLEAPR,=PL1'0'  IF ZEROS THEN ITS A LEAP YEAR
         BNE   NOLEAP
         MVI   MONTHTBL+5,29            SETUP FEB LEAP YEAR
NOLEAP   UNPK  MMDDYY(3),W2+1(2)           UNPK YR
         XC    W1(6),W1                  CLEAR YR FOR DAY RTN.
         CVB   R4,W1                    GET DAY
         LA    R5,MONTHTBL-4            SET BACK PTR
MONLUPE  LA    R5,4(R5)                 INCR THRU MON TBL
         SH    R4,0(R5)                 DROP DOWN THRU MONTBL
         BH    MONLUPE                  NOT YET, TRY AGAIN
         AH    R4,0(R5)                 ADD BACK THE DAY
         CVD   R4,W1                    MAKE
         OI    W2+3,X'0F'                  THE DAY
         UNPK  MMDDYY+5(3),W2+2(2)            PRINTABLE
         MVI   MMDDYY+5,C'/'            RESTORE SLASH
         MVC   MMDDYY+3(2),2(R5)          MOVE THE MONTH
         MVI   MMDDYY+2,C'/'  RESTORE SLASH
         MVC   THEDATE,MMDDYY         MOVE DATE TO USER
RETURN   DS    0H
         L     R13,4(,R13)
         RETURN (14,12),,RC=0 RESTORE REGS AND RETURN
         EJECT
         SPACE 2
MONTHTBL DS    0CL48
MTK      DC    H'31',C'01' JAN
         DC    H'28',C'02' FEB
         DC    H'31',C'03' MAR
         DC    H'30',C'04' APR
         DC    H'31',C'05' MAY
         DC    H'30',C'06' JUN
         DC    H'31',C'07' JLY
         DC    H'31',C'08' AUG
         DC    H'30',C'09' SEP
         DC    H'31',C'10' OCT
         DC    H'30',C'11' NOV
         DC    H'255',C'12' DEC
         SPACE 2
DATESAVE     DS    9D
W1       DS    F              WORKARE1
W2       DS    F              WORKAREA2
OVERLAP  DS    F
MMDDYY   DS    CL9
WRKPKYR  DS    PL3                YEAR TO BE CHECKED BY LEAP YEAR RTN
WRKPKNUM DS    PL8                GENERAL USE PACKED DECIMAL FIELD
WRKLEAPS DS    PL2                PACKED - YEAR / 4   - TRUNCATED
WRKLEAPR DS    PL2                PACKED - REMAINDER AFTER DIVIDE BY 4
         DS    0F
         LTORG
         DS    0F                          BOUNDARY OF FULLWORDS
         DROP R11
         DROP R12
         EJECT
         PRINT  GEN
         DS   0F
CESD     CSECT
         SAVE  (14,12),T,*
*      R1 = ADDR OF RECORD POINTER
         LR    R12,R15
         USING CESD,R12
         LA    R11,4095(R12)   SECOND BASE
         LA    R11,1(,R11)     MAKE IT 4096 X'1000'
         USING CESD+4096,R11
         LA    R3,CESDSAVE
         ST    R13,4(,R3)
         ST    R3,8(,R13)
         LR    R13,R3
         LR    R4,R1        SAVE R1
         USING PARMCESD,R4
         CLI   MODSWT,X'FF'
         BE    MODSKIP
         MVI   MODSWT,X'FF'
*      244 * 4000 = 976000 BYTES
MODOK    GETMAIN R,LV=976000           GET SYMBOL TABLE STORAGE
         ST    R1,SYMTBAD              SAVE SYMBOL TABLE ADDRESS
         ST    R1,BEGNSYM              SAVE SYMBOL TABLE ADDRESS
         ST    R1,CURRSYM              SAVE CURRENT SYMBOL ADDR
         A     R1,=F'976000'  DOR       COMPUTE END ADDR
         ST    R1,ENDSYM               STORE TBL END ADDR
*        4 * 4000 = 16000  BYTES
MODOKTB  GETMAIN R,LV=16000            GET ESDID POINTER TABLE STORAGE
         ST    R1,BTABSYM              SAVE ESDID POINTER TABLE ADDRESS
MODSKIP  EQU   *
         CLI   MODFLGX,X'00'                NEW MOD REQUEST
         BNE   SAMEMOD
         L     R1,SYMTBAD              RESET FOR NEW MOD
         ST    R1,CURRSYM
         ST    R1,BEGNSYM
         MVI   0(R1),X'FF'             TABLE END INDIC
SAMEMOD  EQU   *
         L     R6,MODPTRX
*
****************************************************************
*                                                              *
* PROCESS COMPOSITE ESD RECORDS. DATA FROM THESE RECORDS IS    *
* PLACED IN THE SYMBOL TABLE, AND IS USED TO CREATE PROGRAM    *
* ENTRY STATEMENTS, AND TO IDENTIFY THE NAMES OF EXTERNAL      *
* SYMBOLS USED BY THE PROGRAM.                                 *
*                                                              *
****************************************************************
*
CESDREC  EQU   *                       CESD RECORD PROCESSING
         L     R7,CURRSYM              GET SYMBOL TBL ADDR
         USING SYMTBL,R7
         LH    R10,4(R6)               GET ESD ID OF 1ST ITEM
         LH    R8,6(R6)                NBR BYTES OF ESD DATA
         SRL   R8,4                    COMPUTE NBR ENTRIES
         LA    R6,8(R6)                STEP TO 1ST RECORD ESD ITEM
CESDNXT  C     R7,ENDSYM               END OF TABLE
         BNL   SYMFULL                 YES, ERROR
         LA     R1,SYMLNGTH
         AR     R1,R7
         C     R1,ENDSYM               END OF TABLE
         BNL   SYMFULL                 YES, ERROR
         MVI   SYMENT,X'00'            CLEAR
         MVC   SYMENT+1(L'SYMENT),SYMENT
         MVC   EXTSYM,0(R6)            SYMBOL NAME
         MVC   TYPSYM,8(R6)            TYPE
         NI    TYPSYM,X'0F'            CLEAR BITS 0-3
         MVC   SYMIND,8(R6)            INDICATOR BYTE
         NI    SYMIND,X'0F'            CLEAR BITS 4-7
         TM    8(R6),X'14'             POSSIBLE ENTAB/SEGTAB
         BNO   CEMVAD                  NO
         TM    8(R6),X'03'             IS IT ENTAB/SEGTAB
         BNZ   CEMVAD                  NO
         MVC   TYPSYM(2),=X'0F00'      SHOW ENTAB/SEGTAB
CEMVAD   MVC   SYMADDR,9(R6)           ADDRESS OF SYMBOL
         MVC   SYMSEG,12(R6)           SEGMENT WHERE DEFINED
         MVC   SYMLENG,13(R6)          LENGTH OR LR ESD ID
         STCM  R10,3,SYMESDID          ESD ID
CESDPT   EQU   *
         LR    R1,R10                  ESDID
         C     R1,=F'4000'             MAXIMUM
         BNL   SYMFULL2
         SLL   R1,2                    MULTIPLE BY FULLWORD (4 BYTES)
         A     R1,BTABSYM              ADD BEGIN OF ESDID PTR TABLE
         ST    R7,0(R1)                SAVE ENTRY POINTER ADDRESS
         LA    R7,L'SYMENT(R7)         TO NEXT TBL ENTRY LOCATION
         LA    R10,1(R10)              ADD 1 TO ESD COUNTER
         STH   R10,MODCNTX
         LA    R6,16(R6)               TO NEXT ESD ITEM IN INPUT
         BCT   R8,CESDNXT              LOOP THRU INPUT RECORD
         MVI   0(R7),X'FF'             SET END OF TABLE INDIC
         ST    R7,CURRSYM              SAVE NEXT TABLE ADDR
RETCESD  DS    0H
         L     R13,4(,R13)
         RETURN (14,12),,RC=0 RESTORE REGS AND RETURN
         EJECT
         DROP  R7
SYMFULL  ABEND 1114,DUMP,STEP           ABEND
SYMFULL2 ABEND 1116,DUMP,STEP           ABEND
*
*
*
*                 *** DATA AND WORK AREAS ***
****************************************************************
*
* FOLLOWING FIELDS: COMMPARM THRU COMMEND ARE COMMON AREAS SHARED
* BY THIS, AND CALLED SUB-PROGRAMS. ALL CHANGES MUST BE COORDINTAED
* WITH ALL OTHER PROGRAMS.
*
****************************************************************
*
         DS    0D
COMMPARM EQU   *                       COMMON AREAS
MODSWT   DC    X'00'
ESDID    DC    X'0001'                 ESD ID OF SPECIFIED CSECT
ENDLBLNM DC    CL8' '                  SYMBOL FOR END STMT BEGIN POINTE
CURRLBL  DS    F                       CURRENT LABEL ENTRY ADDR
ENDLBL   DS    F                       @ END OF LABEL TBL
*
*
*
CESDSAVE DS 18F
SAVER11  DC    F'0'                    REGISTER 11
SAVER12  DC    F'0'                    REGISTER 12
NXTSYPTR DC    F'0'                    SYM TBL POINTER ADDR
ENDSYML  DC    F'38000'                SYM TBL END ADDR
SYMTBAD  DS    F                       SYMBOL TABLE ADDRESS
*
COMMEND  EQU   *
         LTORG
*
         SPACE 5
         DROP R11
         DROP R12
         EJECT
         PRINT  GEN
         DS    0F                          BOUNDARY OF FULLWORDS
PRNT    CSECT
         SAVE  (14,12),T,*
*      R1 = ADDR OF RECORD POINTER
         LR    R12,R15
         USING PRNT,R12
         LA    R11,4095(R12)   SECOND BASE
         LA    R11,1(,R11)     MAKE IT 4096 X'1000'
         USING PRNT+4096,R11
         LA    R3,PRNTSAVE
         ST    R13,4(,R3)
         ST    R3,8(,R13)
         LR    R13,R3
         LR    R4,R1        SAVE R1
*PARMPRNT DSECT
*PRNTSWTX DS    F
*PRTPTRX  DS    F
*BEGPPTRX DS    F                       CURRENT SYM TBL ADDR
*BEGPSYMX DS    F                       CURRENT SYM TBL ADDR
*DSECPTRX DS    F
*PSYMPTRX DS    F
         USING PARMPRNT,R4
         L     R8,DSECPTRX
         USING @DATA,R8
         L     R10,BEGPPTRX
         USING PTFTAB,R10
*------- REPEATED CONTROLLER
         MVI   PRNTSWTX+1,X'00'   CLEAR FLAGS
         L     R6,PSYMPTRX
         TM    PRNTSWTX,X'01'   REPEAT PRINTER FOR CSECT LINE
         BO    ZAPIDRY
         TM    PRNTSWTX,X'02'   REPEAT PRINTER FOR CSECT LINE
         BO    ESDIDA
*-----   MEMBER NAME   -------------------
         MVC   PMODNME,PTFMOD
*-----   LINKAGE EDITOR PRODUCT AND DATE LINKED -----
         MVC   PLKED,PTFASM
         MVC   WORKF+1(3),PTFASDTE
         CLC   PTFASM(8),=CL8' '
         BE    NOASM
         L     R2,WORKF
         LA    R1,PLKEDTE  POSITION OF XLINE
         L     R15,=V(DATE)
         BALR  R14,R15
* ------- CSECT REPEATER --------------------------------
NOASM    MVI   PRNTSWTX+1,X'00'   CLEAR FLAGS
TRAMODX  L     R6,BEGPSYMX
         USING  SYMTBL,R6
* -------CSECT NAME -------------------------------------
ESDIDA   MVC   PCSECT,EXTSYM
         CLC   TRANIDR(3),=XL3'000000'
         BE    NOXIDR
* ------ TRANSLATOR PRODUCT AND DATE --------------------
         OI    PRNTSWTX+1,X'80' TRANIDR IS NEEDED TO PRINT
         MVC   WORKF+1(3),TRANIDR+13
         MVC   PXTORNME,TRANIDR
         L     R2,WORKF
         C     R2,=F'0'
         BE    USEMODX
         LA    R1,PXTDATE POSITION OF XLINE
         L     R15,=V(DATE)
         BALR  R14,R15
         CLI   TRANIDR,X'01' SEE IF PLS IS TRANSLATED
         BNE   NOXIDR    NO PLS
* ------ PLS TRANSLATOR PRODUCT AND DATE --------------------
         MVC   WORKF+1(3),TRANIDR+28
         MVC   PXPLSNAM,TRANIDR+16
         L     R2,WORKF
         C     R2,=F'0'
         BE    USEMODX
         LA    R1,PXPLSDTE POSITION OF XLINE
         L     R15,=V(DATE)
         BALR  R14,R15
* -------------------------------------------------------
NOXIDR   EQU   *
USEMODX  CLC   USERIDR+4(3),=XL3'000000'
         BE    NOUIDR
* -------PTF UPDATED   ----------------------------------
SYSMODX  MVC   WORKF+1(3),USERIDR
         OI    PRNTSWTX+1,X'40' USERIDR IS NEEDED TO PRINT
         SR    R3,R3
         IC    R3,USERIDR+3
         BCTR  R3,0
         CH    R3,=H'20'
         BNH   MVUSERK
         LA    R3,20        TRUNICATED TO 20 BYTES ON SYMTAB
MVUSERK  STC   R3,MVUSER+1    BUILD LENGTH
MVUSER   MVC   PPTFNAME(7),USERIDR+4
         L     R2,WORKF
         C     R2,=F'0'
         BE    NOSMODX
         LA    R1,PUPDATE    POSITION OF XLINE
         L     R15,=V(DATE)
         BALR  R14,R15
NOUIDR   EQU   *
         TM    PRNTSWTX+1,X'C0'
         BZ    ZAPIDRY
         MVI   PRNTSWTX,X'01'
         ST    R6,PSYMPTRX
         B     RETPRNT
* ------- ZAPPED -------------------------------------------------
ZAPIDRY  EQU   *
         CLI   ZAPCNT,X'00'
         BE    NOZAPIDR
* ------- ZAPPED IDR ---------------------------------------------
         SR    R2,R2
         IC    R2,ZAPCNT
         BCTR  R2,0
         STC   R2,ZAPCNT
         SLL   R2,4      MULTIPLE OF 16 BYTES FOR EACH ZAPIDR
         LA    R3,ZAPIDR
         AR    R3,R2
         MVC   PCSECT,=CL8' >ZAPPED'
         MVC   WORKF+1(3),0(R3)
         MVC   PXTORNME(8),3(R3)
         L     R2,WORKF
         C     R2,=F'0'
         BE    PRTZAP
         LA    R1,PXTDATE    POSITION OF XLINE
         L     R15,=V(DATE)
         BALR  R14,R15
PRTZAP   MVI   PRNTSWTX,X'01'
         ST    R6,PSYMPTRX
         B     RETPRNT
*-------- NEXT CSECT----------------------
NOZAPIDR EQU   *
NOSMODX  LA    R6,L'SYMENT(R6)   NEXT ESDID
         ST    R6,PSYMPTRX
         MVI   PRNTSWTX+1,X'00'   CLEAR FLAGS
         CLI   0(R6),X'FF'       END OF SYMTBL
         BNE   ESDIDA
         MVI   PRNTSWTX,X'00'
RETPRNT  DS    0H
         L     R13,4(,R13)
         RETURN (14,12),,RC=0 RESTORE REGS AND RETURN
         EJECT
         DROP  R8
         DROP  R10
*
*
*
*                 *** DATA AND WORK AREAS ***
****************************************************************
*
* FOLLOWING FIELDS: COMMPARM THRU COMMEND ARE COMMON AREAS SHARED
* BY THIS, AND CALLED SUB-PROGRAMS. ALL CHANGES MUST BE COORDINTAED
* WITH ALL OTHER PROGRAMS.
*
****************************************************************
*
         DS    0D
COMMPRNT EQU   *                       COMMON AREAS
PRNTSAVE DC    18F'0'
*
*DOR DOR
*
COMMEPRT EQU   *
         LTORG
*
         SPACE 5
         DROP R11
         DROP R12
         EJECT
         PRINT  GEN
         DS    0F                          BOUNDARY OF FULLWORDS
PARM     CSECT
         SAVE  (14,12),T,*
*      R1 = ADDR OF RECORD POINTER
         LR    R12,R15
         USING PARM,R12
         LA    R11,4095(R12)   SECOND BASE
         LA    R11,1(,R11)     MAKE IT 4096 X'1000'
         USING PARM+4096,R11
         LA    R3,PARMSAVE
         ST    R13,4(,R3)
         ST    R3,8(,R13)
         LR    R13,R3
         LR    R7,R1        SAVE R1
         USING PARMPTAB,R7
         CLI   PRMSWT,X'FF'
         BE    PRMSKIP
         MVI   PRMSWT,X'FF'
PRMOK    GETMAIN R,LV=1009           GET PARM TABLE STORAGE
         ST    R1,BEGNPRM              SAVE PARM TABLE ADDRESS
         A     R1,=F'1009'  DOR       COMPUTE END ADDR
         ST    R1,ENDPRM               STORE TBL END ADDR
PRMSKIP  EQU   *
         L     R6,BEGNPRM
         MVI   0(R6),X'FF'             TABLE END INDIC
         LH    R5,PRMLENX
         LTR   R5,R5
         BZ    NOTPARM
         L     R1,PRMPTRX
         LA    R1,0(0,R1)
         L     R2,0(R1)
         LH    R4,0(0,R2)
         LA    R2,2(R2)
PARMLOOP CLI   0(R2),C','
         BNE   ANYMORE
         SH    R4,=H'01'
         LA    R2,1(R2)
ANYMORE  CH    R4,=H'00'
         BE    ENDPARMS
         CLC   0(3,R2),=C'LC='
         BE    LINECT
         CLC   0(2,R2),=C'M='
         BE    MEMEQU
         B     BADPARMS
LINECT   MVC   PRMLCTX(2),3(R2)
         LA    R2,5(R2)
         SH    R4,=H'05'
         B     PARMLOOP
MEMEQU   EQU   *
         SH    R4,=H'02'
         LA    R2,2(R2)
         CLC   0(1,R2),=C'('
         BNE   MEMEQU2
         SH    R4,=H'01'
         LA    R2,1(R2)
MEMEQU2  ST    R2,MEMBEGN
MEMLOOP  CLC   0(1,R2),=C','
         BE    MEMSEP
         CLC   0(1,R2),=C')'
         BE    MEMEND
         CLC   0(1,R2),=C'+'
         BE    MEMSKIP
         CLC   0(1,R2),=C'*'
         BNE    MEMSTAR
         MVI   MEMFLAG,X'01'
MEMSTAR  LA    R2,1(R2)
         SH    R4,=H'01'
         CH    R4,=H'00'
         BE    MEMEND
MEMSTAR2 CLI   MEMSWT,X'FF'
         BE    PARMLOOP
         B     MEMLOOP
MEMSKIP  MVI   MEMSKP,X'FF'
         B     MEMSTAR
MEMEND   MVI   MEMSWT,X'FF'
MEMSEP   LR    R3,R2
         S     R3,MEMBEGN
         BCTR  R3,0            DROP DELIMITER
         L     R5,MEMBEGN
         CLI   MEMFLAG,X'01'
         BNE   MEMMVCX
         MVI   MEMFLAG,X'00'
         BCTR  R3,0             DROP ASKERISK
MEMMVCX  STC   R3,MEMMVC+1
MEMMVC   MVC   1(8,R6),0(R5)
         STC   R3,0(R6)
         CLI   MEMSKP,X'FF'
         BE    MEMSKIP2
         LA    R6,9(R6)
         C     R6,ENDPRM
         BNL   PRMFULL
         MVI   0(R6),X'FF'             TABLE END INDIC
         CLI   MEMSWT,X'FF'
         BE    ENDPARMS
         LA    R2,1(R2)
         SH    R4,=H'01'
         ST    R2,MEMBEGN
         B     MEMSTAR2
SDATET   PACK  SDATE,6(5,R2)
         LA    R2,11(R2)
         SH    R4,=H'11'
         B     PARMLOOP
MEMSKIP2 EQU   *
         IC    R9,MEMMVC+1
         N     R9,=F'15'     TREAT AS X'0F'
         IC    R7,MEMSKPK+1
         N     R7,=F'240'    TREAT AS X'F0'
         OR    R7,R9
         STC   R7,MEMSKPK+1
         LR    R9,R6
MEMSKPK  PACK  MEMWORK,1(7,R9)
         CVB   R9,MEMWORK  CONVERT INTO A USEABLE FORM
         ST    R9,PRMXSKIP  LINES PER PAGE
         B     MEMSTAR2
BADPARMS EQU  *
         WTO  'PARMLIST INVALID PARMETER STRING JOB TERMINATED'
         B    RETPARM
*
NOTPARM EQU  *
         LH    R5,=CL2'60'   PRE SET LINES TO  60
         STH   R5,PRMLCTX
ENDPARMS EQU   *
RETPARM  DS    0H
         L     R13,4(,R13)
         RETURN (14,12),,RC=0 RESTORE REGS AND RETURN
         EJECT
PRMFULL EQU   *
         ABEND 1116,DUMP,STEP           ABEND
*
*
*
*                 *** DATA AND WORK AREAS ***
****************************************************************
*
* FOLLOWING FIELDS: COMMPARM THRU COMMEND ARE COMMON AREAS SHARED
* BY THIS, AND CALLED SUB-PROGRAMS. ALL CHANGES MUST BE COORDINTAED
* WITH ALL OTHER PROGRAMS.
*
****************************************************************
*
         DS    0D
COMPPARM EQU   *                       COMMON AREAS
PRMSWT   DC    X'00'
MEMSWT   DC    X'00'
MEMSKP   DC    X'00'
MEMFLAG  DC    X'00'
         DS    0F
MEMWORK  DC    D'0'
MEMBEGN  DC    F'0'
PARMSAVE DS 18F
*
COMPEND  EQU   *
         LTORG
         DROP R11
         DROP R12
         EJECT
PARMAREA DSECT
THEDATE  DS    CL8
         SPACE 5
*
*
*
SYMTBL   DSECT ,                       EXTERNAL SYMBOL TABLE ENTRY
SYMENT   DS    0CL244                 244 BYTE ENTRIES
EXTSYM   DS    CL8                     EXTERNAL SYMBOL NAME
TYPSYM   DS    XL1                     SYMBOL TYPE
*                        00=SD (NAMED CSECT)
*                        02=ER (EXTRN)
*                        03=LR (ENTRY)
*                        04=PC (UNNAMED CSECT)
*                        05=CM (COM)
*                        06=PR (PSEUDO REGISTER)
*                        07=NULL
*                        0A=WX (WXTRN)
*                        0F=ENTAB OR SEGTAB
SYMIND   DS    XL1                     INDICATOR
*                        BIT 0 = MAP
*                        BIT 1 = CHAIN
*                        BIT 2 = INSERT
*                        BIT 3 = DELETE/REPLACE
SYMADDR  DS    XL3                     SYMBOL ADDRESS (0 FOR ER, WX, NU
SYMSEG   DS    XL1                     SEGMENT ID (0 FOR ER, WX, NULL)
SYMLRID  DS    0XL2                    ESD ID OF DEF FOR LR
SYMLENG  DS    XL3                     LENGTH FOR SD, PC, CM, PR
*                        0 FOR ER, WX, NULL
SYMESDID DS    XL2                     ESD ID OF THIS ITEM
SDATE    DS    CL3
TRANIDR  DS    CL31
USERIDR  DS    CL30
ZAPCNT   DS    X'00'
ZAPIDR   DS    10CL16
SYMLNGTH EQU   *-SYMENT
*
*
*
PARMCESD DSECT
MODPTRX  DS    F
MODFLGX  DS    XL2
MODCNTX  DS    H
BEGNSYM  DS    F                       CURRENT SYM TBL ADDR
CURRSYM  DS    F                       CURRENT SYM TBL ADDR
ENDSYM   DS    F                       SYM TBL END ADDR
BTABSYM  DS    F                       ESDID POINTER TABLE ADDR
*
*
PARMPTAB DSECT
PRMPTRX  DS    F
PRMLENX  DS    XL2
PRMLCTX  DS    H
BEGNPRM  DS    F                       CURRENT SYM TBL ADDR
ENDPRM   DS    F                       SYM TBL END ADDR
PRMXSKIP DS    F                       SYM TBL END ADDR
*
*
PARMPRNT DSECT
         DS    0F
PRNTSWTX DS    F
PRTPTRX  DS    F
BEGPPTRX DS    F                       CURRENT SYM TBL ADDR
BEGPSYMX DS    F                       CURRENT SYM TBL ADDR
DSECPTRX DS    F
PSYMPTRX DS    F
DIRAREA  DSECT PARTITIONED ORGANIZATION DIRECTORY ENTRY BY LINK ED.
DIRNAME  DS    CL8 NAME OF LOAD MODULE
DIRTTR1  DS    CL3 RELATIVE TRACK ADDRESS OF MODULE  (BEGINNING)
DIRALIAS DS    CL1
DIRTTR2  DS    CL3 RELATIVE TRACK ADDRESS OF FIRST TEXT DATA
         DS    CL1 ALWAYS ZEROS
DIRTTR3  DS    CL3 RELATIVE TRACK ADDRESS OF NOTE DATA/SCATTER/XLAT REC
DIRNENTS DS    CL1 NO OF ENTRIES (0=NO OVERLAYS)
DIRATTR1 DS    CL2 MODULE ATTRIBUTES 1
DIRVRRQ  DS    CL2 TOTAL CONTIGUOUS VIRTUAL STAORAGE REQUIRED
DIRMOD   DS    CL1 FOR THE MODULE
DIRTXLEN DS    CL2 LENGTH IN BYTES OF FIRST TEXT RECORD
DIRMODL  DS    CL1 MODULE'S LENGTH
DIRENTPT DS    CL2 EDITOR ASSIGNED ENTRY POINT ADDRESS
DIRATTR2 DS    CL1 MODULE ATTRIBUTE 2
DIRINFO  DS    CL1 AMODE/RMODE INFORMATION
DIRRLD   DS    CL1 RLD COUNT
DIRAUTHL DS    CL1 AUTHORIZATION CODE LENGTH
DIRAUTHC DS    CL1 AUTHORIZATION CODE
         END   LISTPTF
./       ADD   NAME=LSTPDSMD
* PROGRAM TO LIST MEMBER INFORMATION IN ISPF FORMAT
* REMODIFIED BY DAVE RIKER OF COMPUTER DATA SYSTEMS INC
*  ONE CURIE COURT ROCKVILLE MD 20850 301-362-1160
* ABEND CODES  1111  JFCB READ INCORRECTLY
*              1112  TEMP WHEN DIR READ ERROR
         SPACE
LISTPDSM START
         USING *,R12
         B     @PROLOG-*(,15)
         DC    AL1(11),CL11'LISTPDSM'
         DC    CL16' &SYSDATE &SYSTIME '
@SIZE    DC    AL1(1),AL3(@DATAL)
@PROLOG  STM   14,12,12(13)
         LR    R12,15
         LR    R4,R1
         L     R0,@SIZE
         GETMAIN R,LV=(0)
         LR    R8,R1
         USING @DATA,R8
         SPACE
         SPACE
         ST    R13,4(,R8)          CHAIN FORWARD
         ST    R8,8(,R13)          CHAIN BACK
         LR    R13,R8              SET SAVEAREA POINTER
         SPACE
         LR    R1,R4
*POPRT    SAVREGS
         LA    R9,60   PRE SET LINES TO  60
         L     R1,0(0,R1)   GET PARM FLD
         LH    R10,R10
         LH    R10,0(0,R1)  GET THE PARM COUNT
         LTR   R10,R10    SEE IF PARM FLD EMPTY
         BZ    STARTUP     NO NEED TO CALCULATE COUNT
         LA    R9,2(0,R1)  GET ADDR OF PARM
         PACK    WORK,0(2,R9)
         CVB   R9,WORK  CONVERT INTO A USEABLE FORM
STARTUP  STH   R9,NLINES    LINES PER PAGE
         SH    R9,H5  SUB 5 FM LINE COUNT
         STH   R9,NLINES1
         MVI   FIRST,X'FF'   SET FIRST TIME FLAG
*   INSERT TIME DATE ON INDEX LINE
         TIME  DEC                GET DATE IN R1 IN FORM 00YYJJJF
         ST    R0,BADLNGTH        SAVE TIME WHILE YOU'RE AT IT
         LR    R2,R1              PUT IN R2 TO PASS TO DATE SUBROUTINE
         LA    R1,DATERSLT    PTR TO PTR TO DATE'S RESULT FIELD
         L     R15,=V(DATE)       IRSS DATE SUBROUTINE (DATECONV)
         BALR  R14,R15            CONVERT 00YYJJJF TO MM/DD/YY
         ED    TIMERSLT,BADLNGTH  EDIT INTO PAGE HEADER LINE BUFFER
         LA    R1,6   INITIALIZE
         STH   R1,XCNT   THE INDEX MEMBER COUNTER
         RDJFCB  (PODCB)    READ  J F C B  FOR   DSNAME
         LTR   R15,R15      TEST FOR A GOOD READ  JFCB
         BZ    JFCBOK      IF  ZERO    O K
         ABEND 1111,DUMP    SOMETHING IS WRONG  ABORT
JFCBOK   MVC   DSN(44),POJFCB  MOVE DSNAME  INTO THE TITLE
         MVC   DSN01(44),POJFCB  MOVE IN DSNAME INTO INDEX
     OPEN  (PRINTDCB,(OUTPUT),PODCB,,INDCB,(OUTPUT),INDCB2,(OUTPUT))
         PUT   INDCB,INDEX    INDEX TITLE
         PUT   INDCB,XTITLE   HEADER
         USING IHADCB,R10
         LA    R10,PODCB
*  ROUND UP BLKSIZE TO A MULTIPLE OF 8
         LH    R6,DCBBLKSI
         LA    R5,7
         AR    R6,R5
         OR    R6,R5
         XR    R6,R5
         LA    R6,0(0,R6)
         LR    R0,R6
         ST    R6,POBUFFSI
         LH    R6,DCBBLKSI
*         LA    R7,80    SET LRECL TO 80 FOR DEBLOCKING
*  GET A BUFFER FOR INPUT
*         GETMAIN R,LV=(0)
*         ST    R1,PODECB+12
*  TEST FOR RECFM=FB
         TM    DCBRECFM,X'90' IS RECFM=FB
         BNO   SET     YES
*        MVI   FBSW+1,X'00'  NO
         LH    R6,DCBBLKSI
         LH    R7,DCBLRECL
SET      SR    R3,R3   SET MEMBER COUNT TO ZERO
         LA    R11,NAMBUF
         LA    R3,1(R3)   KEEP MEMBER COUNT
READIR   CLOSE PODCB
         MVC   ORG1(2),DCBDSORG  SAVE DCB DATA FROM INPUT DATA SET.
         MVC   FOR1(1),DCBRECFM
         MVC   REC1(2),DCBLRECL
         MVC   SIZ1(2),DCBBLKSI
         MVC   DCBDSORG(2),ORG2  SET DCB DATA TO READ DIRECTORY.
         MVC   DCBRECFM(1),FOR2
         MVC   DCBLRECL(2),REC2
         MVC   DCBBLKSI(2),SIZ2
         OPEN  PODCB
         CALL TRACE
NEXREC   READ  DRDECB,SF,PODCB,BUFFER
         CHECK DRDECB
         LA    2,BUFFER
         AH    R2,BUFFER   DIR BLK COUNT
         ST    2,BUFEND            END OF THE  BUFFER
         LA    2,BUFFER+2
NEXMEM   C     2,BUFEND
         BNL   NEXREC    BRANCH TO GET NEXT RECORD
STONAM   MVC   0(8,R11),0(R2)    STORE MEMBER NAME IN NAME BUFFER.
         MVC   MNAME(8),0(R11)    SET UP MEMBER NAME IN HEADER
         CLI   0(R11),X'FF'  IS THAT ALL OF THE MEMBERS
         BE    RESDCB    THAT'S ALL FOLKS
         LR    R6,R2             SAVE MEMBER ADDRESS
         LA    R3,1(R3)          KEEP MEMBER COUNT.
         LA    R11,8(R11)        MOVE POINTER.
LTTRC    L     R5,8(0,R2)        TTRC TO REG. 5
         SLL   5,27
         SRL   5,26
         AR    2,5
         AH    2,CON12
         ST    R2,SAVEDIR
         BAL   R2,INDMEM
         L     R2,SAVEDIR
         B     NEXMEM    GET THE NEXT MEMEBER
RESDCB   CLOSE PODCB
         MVC   DCBDSORG(2),ORG1
         MVC   DCBRECFM(1),FOR1
         MVC   DCBLRECL(2),REC1
         MVC   DCBBLKSI(2),SIZ1
         SR   R15,R15
         B    EXITX
SICK     OPEN  PODCB
LOADAD   LA    R11,NAMBUF        LOAD ADDRESS OF THE NAME BUFFER.
         CLI   0(R11),X'FF'  IS THAT ALL OF THE MEMBERS
         BNE   FIND    GO GET ANOTHER
         BAL   R1,CLEAR1
         MVC   PRTBUFF(29),NODATA     NO  SYSIN  DATA
         PUT   PRINTDCB,PRTBUFF
         B     CLOSE    GET OUT
FIND     MVC   MNAME(8),0(R11)    SET UP MEMBER NAME IN HEADER
         BAL   R2,INDMEM
NEXT     LA    R11,8(R11)        MOVE POINTER.
         CLI   0(R11),X'FF'    IS IT THE END
         BE    END      THAT'S  ALL FOLKS
         BCT   R3,FIND           CHECK MEMBER COUNT.
END      BAL   R2,PRNTINDX   PRINT LAST INDEX
         B     CLOSE
HEADER   ST    R2,TEMP   SAVE REG R2
         BAL   R4,PAGE     SET UP FOR PAGE COUNT
         PUT   PRINTDCB,PRT5
         LA    R2,6    SET UP LINE COUNTER TO   SIX
         STH   R2,LCNT    SAVE THE LINE COUNTER FROM  PAGE
         L     R2,TEMP  RESTORE R2
SUBHDR   PUT   PRINTDCB,PRT4    SUB  HEADER
         BAL   R1,CLEAR   CLEAR PRINT BUFFER
         MVI   PRTBUFF,C'0'     MOVE IN SPECIAL CHAR TO SKIP LINE
         BR    R2
*
PAGE     CLI   FIRST,X'FF'  IS IT FIRST TIME THROUGH
         BE    PAGE1  YES  DON'T  PRINT THE INDEX LINE
         BAL   R2,PRNTINDX
PAGE1    UNPK  PAGENO,PNO  GET THE NEXT PAGE NO.
         OI    PAGENO+3,X'F0'
         MVC   PAGEX(4),PAGENO
         AP   PNO,P1
         BR    R4
*
*
CLEAR    MVI   PRTBUFF,X'40'
         MVC   PRTBUFF+1(19),PRTBUFF
         BR    R1
CLEAR1   MVI   PRTBUFF+28,C' '        BLANK BACK OF BUFFER
         MVC   PRTBUFF+29(71),PRTBUFF+28  BLANK BUFFER
         BR    R1     RETURN
*
*****  INDEX LINE PRINTING ROUTINE
INDMEM   LH    R1,XADDR+4    MEMBER COUNT
         BCT   R1,INDMEMX    SET UP TO PUT MEMBE  NAME INTO RIGHT SLOT
PRNTINDX LH    R1,XCNT        CHECK LINE COUNT
         CH    R1,NLINES       60 FOR R3
         BNH   INDXOK          LEXX THAN 60
         PUT   INDCB,INDEX      PRINT NEW HDR
         PUT   INDCB,XTITLE   HEADER
         LA    R1,6
INDXOK   LA    R1,2(0,R1)          UP THE COUNT BY TWO
         STH   R1,XCNT        SAVE INDEX LINE COUNT
         PUT   INDCB,XLINE   PRINT INDEX LINE
         PUT   INDCB2,XLINE
         MVI   M1X,C' '
         MVC   M1X+1(132),M1X    BLANK OUT THE LINE
         LA    R1,M1X       FIRST INDEX MEMBER NAME
         ST    R1,XADDR     SAVE
         LH    R1,XADDR+6   H'10'
         STH   R1,XADDR+4   SAVE
         B     INDMEM1
INDMEMX  STH   R1,XADDR+4        NEXT MEMBER SLOT
INDMEM1  L     R1,XADDR          NEXT MEMBER SLOT
         MVC   0(8,R1),MNAME     MEMBER NAME IN INDEX
         C     R5,=F'0'
         BE    INDMEM2
         ST    R2,SAVER2
         ST    R1,SAVER1
         ST    R10,SAVER10
*-----------------------------------------
         SR    R3,R3
         IC    R3,13(R6)        RELEASE NUMBER
         CVD   R3,WORK
         SR    R3,R3
         IC    R3,12(R6)        VERSION NUMBER
         SLL   R3,12
         O     R3,WORK+4
         ST    R3,WORK+4
         OI    WORK+7,X'0F'
         MVC   9(6,R1),EDMSKV
         ED    9(6,R1),WORK+5
*-----------------------------------------
         MVC   WORKF,16(R6) CREATED 00YYDDDF
         L     R2,WORKF
         LA    R1,17(R1)    BUMP ADDRESS
         L     R15,=V(DATE)
         BALR  R14,R15
*-----------------------------------------
         MVC   WORKF,20(R6) MODIFIED 00YYDDDF
         L     R2,WORKF
         LA    R1,10(R1)    BUMP ADDRESS
         L     R15,=V(DATE)
         BALR  R14,R15
*-----------------------------------------
         L     R1,SAVER1
         SR    R3,R3
         CVD   R3,WORK      MAKE 0000000F
         MVC   WORKF(2),24(R6)    HH.MM
         LH    R3,WORKF
         SLL   R3,4
         O     R3,WORK+4
         ST    R3,WORK+4
         OI    WORK+7,X'0F'
         MVC   36(6,R1),EDMSKH
         ED    36(6,R1),WORK+5
*-----------------------------------------
         L     R2,SAVER2
         L     R1,SAVER1
         L     R10,SAVER10
*-----------------------------------------
         MVC   WORKF(2),26(R6)  SIZE (NO OF LINES)
         LH    R3,WORKF
         CVD   R3,WORK
         MVC   43(6,R1),EDMSK
         ED    43(6,R1),WORK+5
*-----------------------------------------
         MVC   WORKF(2),28(R6)  INIT SIZE (NO OF LINES)
         LH    R3,WORKF
         CVD   R3,WORK
         MVC   50(6,R1),EDMSK
         ED    50(6,R1),WORK+5
*-----------------------------------------
         MVC   WORKF(2),30(R6)  MOD FIELD
         LH    R3,WORKF
         CVD   R3,WORK
         MVC   57(6,R1),EDMSKM
         ED    57(6,R1),WORK+5
*-----------------------------------------
         MVC   67(8,R1),32(R6)    USERID
*-----------------------------------------
INDMEM2  EQU   *
         MVC   76(44,R1),POJFCB    DATA SET NAME
*-----------------------------------------
         LA    R1,40(0,R1)       NEXT MEMBER
         ST    R1,XADDR          SAVE
         BR    R2                RETURN
ERR      BAL   R1,CLEAR1
         MVC   PRTBUFF+1(29),ERRMES       MOVE IN ERROR MESSAGE
         PUT   PRINTDCB,PRTBUFF
         ABEND   1112,DUMP
CLOSE    CLOSE (PODCB,,INDCB,,PRINTDCB)
*        L     R0,POBUFFSI
*        L     R1,PODECB+12
*        FREEMAIN R,LV=(0),A=(1)
EXITX    LR    R1,R13
         L     0,@SIZE
         L     13,4(,13)
         ST    15,16(,13)
         FREEMAIN R,A=(1),LV=(0)
         LM    14,12,12(13)
         BR    14
*        RETRN
         EJECT
FIRST    DC    X'00'    FIRST TIME FLAG  =X'FF'  IF SET FIRST TIME
P1       DC    PL1'1'
PNO      DC    PL3'1'
NLINES   DC    H'0'   NO. LINES   DEFAULT IS  60
NLINES1  DC    H'0'      5 LESS THAN THE   NLINES PARAMETER
H3       DC    H'3'
H5       DC    H'5'
LCNT     DC    H'0'
XCNT     DC    H'0'   LINE COUNT OF INDEX
CON12    DC    H'12'
TEMP     DC    F'0'
XADDR    DC    A(M1X),H'1',H'1'
BUFEND   DC    F'0'
SAVER1   DC    F'0'
SAVER2   DC    F'0'
SAVER10  DC    F'0'
SAVEDIR  DC    F'0'
WORKF    DC    F'0'
POBUFFSI DC    F'0'
DUMMY    DC    F'0'
WORK     DC    D'0'
         DS    0D
         DS    1H
BUFFER   DS    128H
ORG1     DS    BL2
REC1     DS    BL2
SIZ1     DS    BL2
FOR1     DS    BL1
ORG2     DC    BL2'0100000000000000'
REC2     DC    BL2'0000000100000000'
SIZ2     DC    BL2'0000000100000000'
FOR2     DC    BL1'10000000'
EDMSK    DC    XL6'402020202021'
EDMSKM   DC    XL6'402020202120'
EDMSKV   DC    XL6'402020214B2020'
EDMSKH   DC    XL6'402020217A2020'
         DS    0D
BADLNGTH DC    D'0'
PRT4     DC    C'0********  MEMBER NAME  XXXXXXXX  '
CONT     DC    C'********  ',65CL1' '      REST OF THE LINE
MNAME    EQU   PRT4+24   MEMBER NAME
CONTD    DC    CL8'CONT''D  '
         DS    0D
PRT5     DC    C'1',CL2' ',C'LISTING OF MEMBERS IN '
DSN      DC    CL45' ',CL40' ',C'PAGE ' DSN=20           54
PAGENO   DC    CL4' '                            109
         DS    0F
PRTBUFF  DC    109C' '
INDCB    DCB   DSORG=PS,MACRF=PM,DDNAME=CONTENTS
INDCB2   DCB   DSORG=PS,MACRF=PM,DDNAME=DIRLIST
PRINTDCB DCB   DSORG=PS,MACRF=PM,DDNAME=LISTING
PODCB    DCB   DSORG=PO,MACRF=R,DDNAME=PDS,EODAD=NEXT,SYNAD=ERR,       X
               EXLST=POEXLST
POEXLST  DS    0F
         DC    BL1'10000111',AL3(POJFCB)
POJFCB   DC    22D'0'   176 BYTE AREA FOR J F C B
NOMBR    DC    C' MEMBER NOT FOUND OR IO ERROR READING DIRECTORY'
ERRMES   DC    C' ERROR READING DIRECTORY     '
ENDTASK  DC    C' *****  TASK COMPLETED  *****'
NODATA   DC    C' *** SYSIN DATA NOT INPUT ***'
XTITLE   DC    C' MEMBER   VER.MOD CREATED   LAST MODIFIED'
*                012345678901234567890123456789012345
         DC    C'      SIZE  INIT    MOD    USER',CL50' '
*                9012345678901234567890123456789012345
PAGEX    DC    CL6' '    INDEX LINE
XLINE    DC    C' '      INDEX LINE
M1X      DC    CL10' '   INDEX LINE
M2X      DC    CL10' '   INDEX LINE
M3X      DC    CL10' '   INDEX LINE
M4X      DC    CL10' '   INDEX LINE
M5X      DC    CL10' '   INDEX LINE
M6X      DC    CL10' '   INDEX LINE
M7X      DC    CL80' '   INDEX LINE
*M8X      DC    CL10' '   INDEX LINE
*M9X      DC    CL10' '   INDEX LINE
*M10X     DC    CL36' '   INDEX LINE
INDEX    DC    CL1'1',8CL1'-'
DATERSLT DC    CL8'MM/DD/YY',CL2'  '
TIMERSLT DC    XL11'4021207A20207A20204B20'
         DC    C' - MEMBERS IN '
DSN01    DC    44CL1' ',8CL1'-'
         LTORG
NAMBUF   DC    250D'0'
         DC    250D'0'
         DC    250D'0'
         DC    250D'0'
         DC    250D'0'
         DC    250D'0'
         DC    250D'0'
         DC    250D'0'
         PRINT  NOGEN
         DCBD  DSORG=PO,DEVD=DA
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         SPACE
@DATA    DSECT
         DS    18F                 REGISTER SAVEAREA
DOUBLE   DS    D
LINKAREA DS    2F
SNAP1    EQU   *
QAREA    DC    A(*) DUMP                      AREA
SNAP2    DC    0F'0',X'80',AL3(*)
SNAPSWT  DC    X'00'
QUOTESWT  DC    X'00'
LEAVESW   DC    X'00'
SPACEW   DS    CL5
         DS    0F
@DATAL   EQU   *-@DATA
         SPACE
DATE     CSECT
         SAVE  (14,12),T,*
*      R1 = ADDR FOR OUTPUT (DS CL8'MM/DD/YY')
*      R2 = R1 FROM THE TIME MACRO
         LR    R12,R15
         USING DATE,R12
         LA    R11,4095(R12)   SECOND BASE
         LA    R11,1(,R11)     MAKE IT 4096 X'1000'
         USING DATE+4096,R11
         LA    R3,DATESAVE
         ST    R13,4(,R3)
         ST    R3,8(,R13)
         LR    R13,R3
         USING PARMAREA,R1
*        L     R1,0(,R1)   GET ADDR FOR OUTPUT            *LACCD*
         ST    R2,W2                    STORE DATE (00YYDDDF)
         SR     R2,R2
         IC    R2,W2+1              PICK YY FROM 00YYDDDF
         SLL   R2,4                 SHIFT 00YY TO 0YY0
         O     R2,=X'0000900F' 0YY0 TO 9YYF
         ST    R2,OVERLAP
         MVC   WRKPKYR+1(2),OVERLAP+2
         OI    WRKPKYR,X'01'         009YYF TO 019YYF
         ZAP   WRKPKNUM(8),WRKPKYR(3)
         DP    WRKPKNUM(8),=PL1'4'   DIVISABLE BY FOUR
         ZAP   WRKLEAPS,WRKPKNUM(7)  SAVE QUOTIENT
         ZAP   WRKLEAPR,WRKPKNUM+7(1)  SAVE REMAINDER
         MVI   MONTHTBL+5,28            SETUP FEB NONLEAP YEAR
         CP    WRKLEAPR,=PL1'0'  IF ZEROS THEN ITS A LEAP YEAR
         BNE   NOLEAP
         MVI   MONTHTBL+5,29            SETUP FEB LEAP YEAR
NOLEAP   UNPK  MMDDYY(3),W2+1(2)           UNPK YR
         XC    W1(6),W1                  CLEAR YR FOR DAY RTN.
         CVB   R4,W1                    GET DAY
         LA    R5,MONTHTBL-4            SET BACK PTR
MONLUPE  LA    R5,4(R5)                 INCR THRU MON TBL
         SH    R4,0(R5)                 DROP DOWN THRU MONTBL
         BH    MONLUPE                  NOT YET, TRY AGAIN
         AH    R4,0(R5)                 ADD BACK THE DAY
         CVD   R4,W1                    MAKE
         OI    W2+3,X'0F'                  THE DAY
         UNPK  MMDDYY+5(3),W2+2(2)            PRINTABLE
         MVI   MMDDYY+5,C'/'            RESTORE SLASH
         MVC   MMDDYY+3(2),2(R5)          MOVE THE MONTH
         MVI   MMDDYY+2,C'/'  RESTORE SLASH
         MVC   THEDATE,MMDDYY         MOVE DATE TO USER
RETURN   DS    0H
         L     R13,4(,R13)
         RETURN (14,12),,RC=0 RESTORE REGS AND RETURN
         EJECT
         SPACE 2
MONTHTBL DS    0CL48
MTK      DC    H'31',C'01' JAN
         DC    H'28',C'02' FEB
         DC    H'31',C'03' MAR
         DC    H'30',C'04' APR
         DC    H'31',C'05' MAY
         DC    H'30',C'06' JUN
         DC    H'31',C'07' JLY
         DC    H'31',C'08' AUG
         DC    H'30',C'09' SEP
         DC    H'31',C'10' OCT
         DC    H'30',C'11' NOV
         DC    H'255',C'12' DEC
         SPACE 2
DATESAVE     DS    9D
W1       DS    F              WORKARE1
W2       DS    F              WORKAREA2
OVERLAP  DS    F
MMDDYY   DS    CL9
WRKPKYR  DS    PL3                YEAR TO BE CHECKED BY LEAP YEAR RTN
WRKPKNUM DS    PL8                GENERAL USE PACKED DECIMAL FIELD
WRKLEAPS DS    PL2                PACKED - YEAR / 4   - TRUNCATED
WRKLEAPR DS    PL2                PACKED - REMAINDER AFTER DIVIDE BY 4
         DS    0F
         LTORG
         DS    0F                          BOUNDARY OF FULLWORDS
PARMAREA DSECT
THEDATE  DS    CL8
         SPACE 5
         END   LISTPDSM
./       ADD   NAME=LSTPDSML
* ABEND CODES  1111  JFCB READ INCORRECTLY
*              1112  TEMP WHEN DIR READ ERROR
         SPACE
LISTPDSM START
         USING *,R12
         B     @PROLOG-*(,15)
         DC    AL1(11),CL11'LISTPDSM'
         DC    CL16' &SYSDATE &SYSTIME '
@SIZE    DC    AL1(1),AL3(@DATAL)
@PROLOG  STM   14,12,12(13)
         LR    R12,15
         LR    R4,R1
         L     R0,@SIZE
         GETMAIN R,LV=(0)
         LR    R8,R1
         USING @DATA,R8
         SPACE
         SPACE
         ST    R13,4(,R8)          CHAIN FORWARD
         ST    R8,8(,R13)          CHAIN BACK
         LR    R13,R8              SET SAVEAREA POINTER
         SPACE
         LR    R1,R4
*POPRT    SAVREGS
         LA    R9,60   PRE SET LINES TO  60
         L     R1,0(0,R1)   GET PARM FLD
         LH    R10,R10
         LH    R10,0(0,R1)  GET THE PARM COUNT
         LTR   R10,R10    SEE IF PARM FLD EMPTY
         BZ    STARTUP     NO NEED TO CALCULATE COUNT
         LA    R9,2(0,R1)  GET ADDR OF PARM
         PACK    WORK,0(2,R9)
         CVB   R9,WORK  CONVERT INTO A USEABLE FORM
STARTUP  STH   R9,NLINES    LINES PER PAGE
         SH    R9,H5  SUB 5 FM LINE COUNT
         STH   R9,NLINES1
         MVI   FIRST,X'FF'   SET FIRST TIME FLAG
*   INSERT TIME DATE ON INDEX LINE
         TIME  DEC                GET DATE IN R1 IN FORM 00YYJJJF
         ST    R0,BADLNGTH        SAVE TIME WHILE YOU'RE AT IT
         LR    R2,R1              PUT IN R2 TO PASS TO DATE SUBROUTINE
         LA    R1,DATERSLT    PTR TO PTR TO DATE'S RESULT FIELD
         L     R15,=V(DATE)       IRSS DATE SUBROUTINE (DATECONV)
         BALR  R14,R15            CONVERT 00YYJJJF TO MM/DD/YY
         ED    TIMERSLT,BADLNGTH  EDIT INTO PAGE HEADER LINE BUFFER
         LA    R1,6   INITIALIZE
         STH   R1,XCNT   THE INDEX MEMBER COUNTER
         RDJFCB  (PODCB)    READ  J F C B  FOR   DSNAME
         LTR   R15,R15      TEST FOR A GOOD READ  JFCB
         BZ    JFCBOK      IF  ZERO    O K
         ABEND 1111,DUMP    SOMETHING IS WRONG  ABORT
JFCBOK   MVC   DSN(44),POJFCB  MOVE DSNAME  INTO THE TITLE
         MVC   DSN01(44),POJFCB  MOVE IN DSNAME INTO INDEX
         OPEN  (PRINTDCB,(OUTPUT),PODCB,,INDCB,(OUTPUT)) OPEN IT ALL
         PUT   INDCB,INDEX    INDEX TITLE
         PUT   INDCB,XTITLE   HEADER
         USING IHADCB,R10
         LA    R10,PODCB
*  ROUND UP BLKSIZE TO A MULTIPLE OF 8
         LH    R6,DCBBLKSI
         LA    R5,7
         AR    R6,R5
         OR    R6,R5
         XR    R6,R5
         LA    R6,0(0,R6)
         LR    R0,R6
         ST    R6,POBUFFSI
         LH    R6,DCBBLKSI
*         LA    R7,80    SET LRECL TO 80 FOR DEBLOCKING
*  GET A BUFFER FOR INPUT
*         GETMAIN R,LV=(0)
*         ST    R1,PODECB+12
*  TEST FOR RECFM=FB
         TM    DCBRECFM,X'90' IS RECFM=FB
         BNO   SET     YES
*        MVI   FBSW+1,X'00'  NO
         LH    R6,DCBBLKSI
         LH    R7,DCBLRECL
SET      SR    R3,R3   SET MEMBER COUNT TO ZERO
         LA    R11,NAMBUF
         LA    R3,1(R3)   KEEP MEMBER COUNT
READIR   CLOSE PODCB
         MVC   ORG1(2),DCBDSORG  SAVE DCB DATA FROM INPUT DATA SET.
         MVC   FOR1(1),DCBRECFM
         MVC   REC1(2),DCBLRECL
         MVC   SIZ1(2),DCBBLKSI
         MVC   DCBDSORG(2),ORG2  SET DCB DATA TO READ DIRECTORY.
         MVC   DCBRECFM(1),FOR2
         MVC   DCBLRECL(2),REC2
         MVC   DCBBLKSI(2),SIZ2
         OPEN  PODCB
*        CALL TRACE
NEXREC   READ  DRDECB,SF,PODCB,BUFFER
         CHECK DRDECB
         LA    2,BUFFER
         AH    R2,BUFFER   DIR BLK COUNT
         ST    2,BUFEND            END OF THE  BUFFER
         LA    2,BUFFER+2
NEXMEM   C     2,BUFEND
         BNL   NEXREC    BRANCH TO GET NEXT RECORD
STONAM   MVC   0(8,R11),0(R2)    STORE MEMBER NAME IN NAME BUFFER.
         MVC   MNAME(8),0(R11)    SET UP MEMBER NAME IN HEADER
         CLI   0(R11),X'FF'  IS THAT ALL OF THE MEMBERS
         BE    RESDCB    THAT'S ALL FOLKS
         LR    R6,R2             SAVE MEMBER ADDRESS
         LA    R3,1(R3)          KEEP MEMBER COUNT.
         LA    R11,8(R11)        MOVE POINTER.
LTTRC    L     R5,8(0,R2)        TTRC TO REG. 5
         SLL   5,27
         SRL   5,26
         AR    2,5
         AH    2,CON12
         ST    R2,SAVEDIR
         BAL   R2,INDMEM
         L     R2,SAVEDIR
         B     NEXMEM    GET THE NEXT MEMEBER
RESDCB   CLOSE PODCB
         MVC   DCBDSORG(2),ORG1
         MVC   DCBRECFM(1),FOR1
         MVC   DCBLRECL(2),REC1
         MVC   DCBBLKSI(2),SIZ1
         SR   R15,R15
         B    EXITX
SICK     OPEN  PODCB
LOADAD   LA    R11,NAMBUF        LOAD ADDRESS OF THE NAME BUFFER.
         CLI   0(R11),X'FF'  IS THAT ALL OF THE MEMBERS
         BNE   FIND    GO GET ANOTHER
         BAL   R1,CLEAR1
         MVC   PRTBUFF(29),NODATA     NO  SYSIN  DATA
         PUT   PRINTDCB,PRTBUFF
         B     CLOSE    GET OUT
FIND     MVC   MNAME(8),0(R11)    SET UP MEMBER NAME IN HEADER
         BAL   R2,INDMEM
NEXT     LA    R11,8(R11)        MOVE POINTER.
         CLI   0(R11),X'FF'    IS IT THE END
         BE    END      THAT'S  ALL FOLKS
         BCT   R3,FIND           CHECK MEMBER COUNT.
END      BAL   R2,PRNTINDX   PRINT LAST INDEX
         B     CLOSE
HEADER   ST    R2,TEMP   SAVE REG R2
         BAL   R4,PAGE     SET UP FOR PAGE COUNT
         PUT   PRINTDCB,PRT5
         LA    R2,6    SET UP LINE COUNTER TO   SIX
         STH   R2,LCNT    SAVE THE LINE COUNTER FROM  PAGE
         L     R2,TEMP  RESTORE R2
SUBHDR   PUT   PRINTDCB,PRT4    SUB  HEADER
         BAL   R1,CLEAR   CLEAR PRINT BUFFER
         MVI   PRTBUFF,C'0'     MOVE IN SPECIAL CHAR TO SKIP LINE
         BR    R2
*
PAGE     CLI   FIRST,X'FF'  IS IT FIRST TIME THROUGH
         BE    PAGE1  YES  DON'T  PRINT THE INDEX LINE
         BAL   R2,PRNTINDX
PAGE1    UNPK  PAGENO,PNO  GET THE NEXT PAGE NO.
         OI    PAGENO+3,X'F0'
         MVC   PAGEX(4),PAGENO
         AP   PNO,P1
         BR    R4
*
*
CLEAR    MVI   PRTBUFF,X'40'
         MVC   PRTBUFF+1(19),PRTBUFF
         BR    R1
CLEAR1   MVI   PRTBUFF+28,C' '        BLANK BACK OF BUFFER
         MVC   PRTBUFF+29(71),PRTBUFF+28  BLANK BUFFER
         BR    R1     RETURN
*
*****  INDEX LINE PRINTING ROUTINE
INDMEM   LH    R1,XADDR+4    MEMBER COUNT
         BCT   R1,INDMEMX    SET UP TO PUT MEMBE  NAME INTO RIGHT SLOT
PRNTINDX LH    R1,XCNT        CHECK LINE COUNT
         CH    R1,NLINES       60 FOR R3
         BNH   INDXOK          LEXX THAN 60
         PUT   INDCB,INDEX      PRINT NEW HDR
         PUT   INDCB,XTITLE   HEADER
         LA    R1,6
INDXOK   LA    R1,2(0,R1)          UP THE COUNT BY TWO
         STH   R1,XCNT        SAVE INDEX LINE COUNT
         PUT   INDCB,XLINE   PRINT INDEX LINE
         MVI   M1X,C' '
         MVC   M1X+1(99),M1X    BLANK OUT THE LINE
         LA    R1,M1X       FIRST INDEX MEMBER NAME
         ST    R1,XADDR     SAVE
         LH    R1,XADDR+6   H'10'
         STH   R1,XADDR+4   SAVE
         B     INDMEM1
INDMEMX  STH   R1,XADDR+4        NEXT MEMBER SLOT
INDMEM1  L     R1,XADDR          NEXT MEMBER SLOT
         MVC   0(8,R1),MNAME     MEMBER NAME IN INDEX
         C     R5,=F'0'
         BE    INDMEM2
*        CALL TRACE
         ST    R2,SAVER2
         ST    R1,SAVER1
         ST    R10,SAVER10
*-----------------------------------------
         SR    R3,R3
         IC    R3,13(R6)        RELEASE NUMBER
         CVD   R3,WORK
         SR    R3,R3
         IC    R3,12(R6)        VERSION NUMBER
         SLL   R3,12
         O     R3,WORK+4
         ST    R3,WORK+4
         OI    WORK+7,X'0F'
         MVC   9(6,R1),EDMSKV
         ED    9(6,R1),WORK+5
*-----------------------------------------
         MVC   WORKF,16(R6) CREATED 00YYDDDF
         L     R2,WORKF
         LA    R1,17(R1)    BUMP ADDRESS
         L     R15,=V(DATE)
         BALR  R14,R15
*-----------------------------------------
         MVC   WORKF,20(R6) MODIFIED 00YYDDDF
         L     R2,WORKF
         LA    R1,10(R1)    BUMP ADDRESS
         L     R15,=V(DATE)
         BALR  R14,R15
*-----------------------------------------
         L     R1,SAVER1
         SR    R3,R3
         CVD   R3,WORK      MAKE 0000000F
         MVC   WORKF(2),24(R6)    HH.MM
         LH    R3,WORKF
         SLL   R3,4
         O     R3,WORK+4
         ST    R3,WORK+4
         OI    WORK+7,X'0F'
         MVC   36(6,R1),EDMSKH
         ED    36(6,R1),WORK+5
*-----------------------------------------
         L     R2,SAVER2
         L     R1,SAVER1
         L     R10,SAVER10
*-----------------------------------------
         MVC   WORKF(2),26(R6)  SIZE (NO OF LINES)
         LH    R3,WORKF
         CVD   R3,WORK
         MVC   43(6,R1),EDMSK
         ED    43(6,R1),WORK+5
*-----------------------------------------
         MVC   WORKF(2),28(R6)  INIT SIZE (NO OF LINES)
         LH    R3,WORKF
         CVD   R3,WORK
         MVC   50(6,R1),EDMSK
         ED    50(6,R1),WORK+5
*-----------------------------------------
         MVC   WORKF(2),30(R6)  MOD FIELD
         LH    R3,WORKF
         CVD   R3,WORK
         MVC   57(6,R1),EDMSKM
         ED    57(6,R1),WORK+5
*-----------------------------------------
         MVC   67(8,R1),32(R6)    USERID
INDMEM2  LA    R1,40(0,R1)       NEXT MEMBER
         ST    R1,XADDR          SAVE
         BR    R2                RETURN
ERR      BAL   R1,CLEAR1
         MVC   PRTBUFF+1(29),ERRMES       MOVE IN ERROR MESSAGE
         PUT   PRINTDCB,PRTBUFF
         ABEND   1112,DUMP
CLOSE    CLOSE (PODCB,,INDCB,,PRINTDCB)
*        L     R0,POBUFFSI
*        L     R1,PODECB+12
*        FREEMAIN R,LV=(0),A=(1)
EXITX    LR    R1,R13
         L     0,@SIZE
         L     13,4(,13)
         ST    15,16(,13)
         FREEMAIN R,A=(1),LV=(0)
         LM    14,12,12(13)
         BR    14
*        RETRN
         EJECT
FIRST    DC    X'00'    FIRST TIME FLAG  =X'FF'  IF SET FIRST TIME
P1       DC    PL1'1'
PNO      DC    PL3'1'
NLINES   DC    H'0'   NO. LINES   DEFAULT IS  60
NLINES1  DC    H'0'      5 LESS THAN THE   NLINES PARAMETER
H3       DC    H'3'
H5       DC    H'5'
LCNT     DC    H'0'
XCNT     DC    H'0'   LINE COUNT OF INDEX
CON12    DC    H'12'
TEMP     DC    F'0'
XADDR    DC    A(M1X),H'1',H'1'
BUFEND   DC    F'0'
SAVER1   DC    F'0'
SAVER2   DC    F'0'
SAVER10  DC    F'0'
SAVEDIR  DC    F'0'
WORKF    DC    F'0'
POBUFFSI DC    F'0'
DUMMY    DC    F'0'
WORK     DC    D'0'
         DS    0D
         DS    1H
BUFFER   DS    128H
ORG1     DS    BL2
REC1     DS    BL2
SIZ1     DS    BL2
FOR1     DS    BL1
ORG2     DC    BL2'0100000000000000'
REC2     DC    BL2'0000000100000000'
SIZ2     DC    BL2'0000000100000000'
FOR2     DC    BL1'10000000'
EDMSK    DC    XL6'402020202021'
EDMSKM   DC    XL6'402020202120'
EDMSKV   DC    XL6'402020214B2020'
EDMSKH   DC    XL6'402020217A2020'
         DS    0D
BADLNGTH DC    D'0'
PRT4     DC    C'0********  MEMBER NAME  XXXXXXXX  '
CONT     DC    C'********  ',65CL1' '      REST OF THE LINE
MNAME    EQU   PRT4+24   MEMBER NAME
CONTD    DC    CL8'CONT''D  '
         DS    0D
PRT5     DC    C'1',CL2' ',C'LISTING OF MEMBERS IN '
DSN      DC    CL45' ',CL40' ',C'PAGE ' DSN=20           54
PAGENO   DC    CL4' '                            109
         DS    0F
PRTBUFF  DC    109C' '
INDCB    DCB   DSORG=PS,MACRF=PM,DDNAME=CONTENTS
PRINTDCB DCB   DSORG=PS,MACRF=PM,DDNAME=LISTING
PODCB    DCB   DSORG=PO,MACRF=R,DDNAME=PDS,EODAD=NEXT,SYNAD=ERR,       X
               EXLST=POEXLST
POEXLST  DS    0F
         DC    BL1'10000111',AL3(POJFCB)
POJFCB   DC    22D'0'   176 BYTE AREA FOR J F C B
NOMBR    DC    C' MEMBER NOT FOUND OR IO ERROR READING DIRECTORY'
ERRMES   DC    C' ERROR READING DIRECTORY     '
ENDTASK  DC    C' *****  TASK COMPLETED  *****'
NODATA   DC    C' *** SYSIN DATA NOT INPUT ***'
XTITLE   DC    C' MEMBER   VER.MOD CREATED   LAST MODIFIED'
*                012345678901234567890123456789012345
         DC    C'      SIZE  INIT    MOD    USER',CL50' '
*                9012345678901234567890123456789012345
PAGEX    DC    CL6' '    INDEX LINE
XLINE    DC    C' '      INDEX LINE
M1X      DC    CL10' '   INDEX LINE
M2X      DC    CL10' '   INDEX LINE
M3X      DC    CL10' '   INDEX LINE
M4X      DC    CL10' '   INDEX LINE
M5X      DC    CL10' '   INDEX LINE
M6X      DC    CL10' '   INDEX LINE
M7X      DC    CL56' '   INDEX LINE
*M8X      DC    CL10' '   INDEX LINE
*M9X      DC    CL10' '   INDEX LINE
*M10X     DC    CL36' '   INDEX LINE
INDEX    DC    CL1'1',8CL1'-'
DATERSLT DC    CL8'MM/DD/YY',CL2'  '
TIMERSLT DC    XL11'4021207A20207A20204B20'
         DC    C' - MEMBERS IN '
DSN01    DC    44CL1' ',8CL1'-'
         LTORG
NAMBUF   DC    250D'0'
         DC    250D'0'
         DC    250D'0'
         DC    250D'0'
         DC    250D'0'
         DC    250D'0'
         DC    250D'0'
         DC    250D'0'
         PRINT  NOGEN
         DCBD  DSORG=PO,DEVD=DA
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         SPACE
@DATA    DSECT
         DS    18F                 REGISTER SAVEAREA
DOUBLE   DS    D
LINKAREA DS    2F
SNAP1    EQU   *
QAREA    DC    A(*) DUMP                      AREA
SNAP2    DC    0F'0',X'80',AL3(*)
SNAPSWT  DC    X'00'
QUOTESWT  DC    X'00'
LEAVESW   DC    X'00'
SPACEW   DS    CL5
         DS    0F
@DATAL   EQU   *-@DATA
         SPACE
DATE     CSECT
         SAVE  (14,12),T,*
*      R1 = ADDR FOR OUTPUT (DS CL8'MM/DD/YY')
*      R2 = R1 FROM THE TIME MACRO
         LR    R12,R15
         USING DATE,R12
         LA    R11,4095(R12)   SECOND BASE
         LA    R11,1(,R11)     MAKE IT 4096 X'1000'
         USING DATE+4096,R11
         LA    R3,DATESAVE
         ST    R13,4(,R3)
         ST    R3,8(,R13)
         LR    R13,R3
         USING PARMAREA,R1
*        L     R1,0(,R1)   GET ADDR FOR OUTPUT            *LACCD*
        CALL TRACE
         ST    R2,W2                    STORE DATE (00YYDDDF)
         SR     R2,R2
         IC    R2,W2+1              PICK YY FROM 00YYDDDF
         SLL   R2,4                 SHIFT 00YY TO 0YY0
         O     R2,=X'0000900F' 0YY0 TO 9YYF
         ST    R2,OVERLAP
         MVC   WRKPKYR+1(2),OVERLAP+2
         OI    WRKPKYR,X'01'         009YYF TO 019YYF
         ZAP   WRKPKNUM(8),WRKPKYR(3)
         DP    WRKPKNUM(8),=PL1'4'   DIVISABLE BY FOUR
         ZAP   WRKLEAPS,WRKPKNUM(7)  SAVE QUOTIENT
         ZAP   WRKLEAPR,WRKPKNUM+7(1)  SAVE REMAINDER
         MVI   MONTHTBL+5,28            SETUP FEB NONLEAP YEAR
         CP    WRKLEAPR,=PL1'0'  IF ZEROS THEN ITS A LEAP YEAR
         BNE   NOLEAP
         MVI   MONTHTBL+5,29            SETUP FEB LEAP YEAR
NOLEAP   UNPK  MMDDYY(3),W2+1(2)           UNPK YR
         XC    W1(6),W1                  CLEAR YR FOR DAY RTN.
         CVB   R4,W1                    GET DAY
         LA    R5,MONTHTBL-4            SET BACK PTR
MONLUPE  LA    R5,4(R5)                 INCR THRU MON TBL
         SH    R4,0(R5)                 DROP DOWN THRU MONTBL
         BH    MONLUPE                  NOT YET, TRY AGAIN
         AH    R4,0(R5)                 ADD BACK THE DAY
         CVD   R4,W1                    MAKE
         OI    W2+3,X'0F'                  THE DAY
         UNPK  MMDDYY+5(3),W2+2(2)            PRINTABLE
         MVI   MMDDYY+5,C'/'            RESTORE SLASH
         MVC   MMDDYY+3(2),2(R5)          MOVE THE MONTH
         MVI   MMDDYY+2,C'/'  RESTORE SLASH
         MVC   THEDATE,MMDDYY         MOVE DATE TO USER
RETURN   DS    0H
         L     R13,4(,R13)
         RETURN (14,12),,RC=0 RESTORE REGS AND RETURN
         EJECT
         SPACE 2
MONTHTBL DS    0CL48
MTK      DC    H'31',C'01' JAN
         DC    H'28',C'02' FEB
         DC    H'31',C'03' MAR
         DC    H'30',C'04' APR
         DC    H'31',C'05' MAY
         DC    H'30',C'06' JUN
         DC    H'31',C'07' JLY
         DC    H'31',C'08' AUG
         DC    H'30',C'09' SEP
         DC    H'31',C'10' OCT
         DC    H'30',C'11' NOV
         DC    H'255',C'12' DEC
         SPACE 2
DATESAVE     DS    9D
W1       DS    F              WORKARE1
W2       DS    F              WORKAREA2
OVERLAP  DS    F
MMDDYY   DS    CL9
WRKPKYR  DS    PL3                YEAR TO BE CHECKED BY LEAP YEAR RTN
WRKPKNUM DS    PL8                GENERAL USE PACKED DECIMAL FIELD
WRKLEAPS DS    PL2                PACKED - YEAR / 4   - TRUNCATED
WRKLEAPR DS    PL2                PACKED - REMAINDER AFTER DIVIDE BY 4
         DS    0F
         LTORG
         DS    0F                          BOUNDARY OF FULLWORDS
PARMAREA DSECT
THEDATE  DS    CL8
         SPACE 5
         END   LISTPDSM
./       ADD   NAME=NCPTUNEP
//DORNCPT JOB (6000A,601,,99),'NCP TUNING',
//         MSGCLASS=M,CLASS=A,NOTIFY=DOR
/*ROUTE PRINT RMT55
/*ROUTE PUNCH RMT55
//*
//*   SAS PROGRAM TO READ THE SMF FILES FOR THE NCP TUNING STATISTICS
//*   RECORD FOR ACF/VTAM ACF/NCP.  NOTE THAT IN THE VTAM START-UP
//*   PROCEDURE MEMBER ATRSTRXX IN VTAMLST YOU MUST HAVE  TNSTAT,NOCNSL
//*   SPECIFIED.
//*               JIM OLEKSIW, NORTHEAST UTILITIES SERVICE COMPANY
//*         P.O. BOX 270, HARTFORD, CONNECTICUT 06101  (203-666-6911)
//*
//*       DAVID RIKER  COMPUTER DATA SYSTEMS INC
//*       ONE CURIE COURT ROCKVILLE MD 20850 (202-362-1160)
//*        FOR ACF VTAM VERSION 2
//*        REMODIFY ALGORITHM AND PROCS ADD 8-UP PLOTS
//*
//SAS  EXEC SAS,REGION=2000K,OPTIONS='LINESIZE=132,NODATE'
//SMFIN DD  DSN=SYS7.SMF.IPO1.DAILY(0),DISP=SHR
//      DD  DSN=SYS7.SMF.IPO1.DAILY(-1),DISP=SHR
//      DD  DSN=SYS7.SMF.IPO1.DAILY(-2),DISP=SHR
//      DD  DSN=SYS7.SMF.IPO2.DAILY(0),DISP=SHR
//      DD  DSN=SYS7.SMF.IPO2.DAILY(-1),DISP=SHR
//      DD  DSN=SYS7.SMF.IPO2.DAILY(-2),DISP=SHR
//*  SPREAD REPORTS FOR EACH SPECIFIED DAY FOR EASIER READING --
//DAY1   DD  SYSOUT=A
//DAY2   DD  SYSOUT=A
//DAY3   DD  SYSOUT=A
//DAY4   DD  SYSOUT=A
//DAY5   DD  SYSOUT=A
//DAY6   DD  SYSOUT=A
//DAY7   DD  SYSOUT=A
//DAY8   DD  SYSOUT=A
//DAY9   DD  SYSOUT=A
//DAY10  DD  SYSOUT=A
//DAY11  DD  SYSOUT=A
//DAY12  DD  SYSOUT=A
//DAY13  DD  SYSOUT=A
//DAY14  DD  SYSOUT=A
//DAY15  DD  SYSOUT=A
//DAY16  DD  SYSOUT=A
//DAY17  DD  SYSOUT=A
//DAY18  DD  SYSOUT=A
//DAY19  DD  SYSOUT=A
//DAY20  DD  SYSOUT=A
//DAY21  DD  SYSOUT=A
//DAY22  DD  SYSOUT=A
//DAY23  DD  SYSOUT=A
//DAY24  DD  SYSOUT=A
//DAY25  DD  SYSOUT=A
//DAY26  DD  SYSOUT=A
//DAY27  DD  SYSOUT=A
//DAY28  DD  SYSOUT=A
//DAY29  DD  SYSOUT=A
//DAY30  DD  SYSOUT=A
//DAY31  DD  SYSOUT=A
//SYSIN     DD  *
OPTIONS  MACROGEN MCOMPILE PS=60 SKIP=0 NODATE S=72 ERROR=3 ;
MACRO PLOT8UP;
**  LOAD PLT1 THRU PLT8 ARRAYS SO THAT THE HIT IS ASSOCATED WITH ;
**      CORRECT ROW AND COLUMN OF EACH SET;
DO OVER SAMP; * DO EIGHT SET OF SAMPLES;
    PO=HS;
    * CALCULATE FOR INTERVAL FOR EACH PLOT;
    IX=HS;
    IF INTER =< 20 THEN IVAL=1;                  * RANGE 0 TO   20;
     ELSE IF INTER =< 60  THEN IVAL=3;           * RANGE 0 TO   60;
      ELSE IF INTER =< 100 THEN IVAL=5;          * RANGE 0 TO  100;
      ELSE IF INTER =< 160 THEN IVAL=8;          * RANGE 0 TO  160;
       ELSE IF INTER =< 300 THEN IVAL=15;        * RANGE 0 TO  300;
        ELSE IF INTER =< 500 THEN IVAL=25;       * RANGE 0 TO  500;
         ELSE IF INTER =< 1000 THEN IVAL=50;     * RANGE 0 TO 1000;
          ELSE IF INTER =< 1500 THEN IVAL=75;    * RANGE 0 TO 1500;
           ELSE IF INTER =< 2000 THEN IVAL=100;  * RANGE 0 TO 2000;
            ELSE IVAL=200;                      * RANGE 0 TO 4000;
*     TOP INTERVAL: INTERVAL*21;
*  BOTTOM INTERVAL: -INTERVAL;
         PCT=IVAL*21;PCTD=-IVAL;
         INTER=0; * CLEAR FOR NEXT DATE;
  DO HX=1 TO 24; * DO 24 HOUR UNITS TO BE PLOT WITHIN ONE SET;
     SETX=INT(SAMP/IVAL);
     BKD=((20-SETX) * 24) + HX ;
     DO PA=BKD TO 504; * PLOT IT WITHIN A SET;
        PLOT='.';
        PA=505;
     END;
  END;
 END;
** PRINT CONTENTS OF PLOT CHART IN EIGHT SETS PER PAGE ;
PUT _PAGE_  @20 TITLE
    ' AS OF ' DATEX MMDDYY8. @;
   DO KTR1=0 TO 7 BY 4; /* 4 PLOT SETS ARE PRINTED PER LINE */
      PO=KTR1;
      *PRINT ROWS  NAME BANNERS ACCROSS PAGE;
      PUT /@;
         * PRINT CONTENTS OF ARRAYS PLT 1 THRU PLT8 ACROSS PAGE ONE
         * LINE AT A TIME;
         DO PK = 0 TO 20;
            PO=KTR1;
            DO KTR2 = 0 TO 3;
               PO + 1;
               PCT+PCTD;
               PTR = 24 * KTR2 + 9 * KTR2 ;
               PUT @PTR PCT 4. '×' @;
               DO KTR3 = 1 TO 24;
                  PA = 24 * PK + KTR3;
                  PTR1 = PTR + KTR3 + 4;
                  PUT @PTR1 PLOT @;
               END;
             END;
          PUT;
          END;
         DO KTR2= 0 TO 3;
            PTR = 24 * KTR2 + 9 * KTR2 + 4;
            PUT @PTR '+-------------------------' @;
         END;
         PUT ;
         * PRINT HOUR GUIDELINES  ACROSS PAGE;
         DO KTR2= 0 TO 3;
            PTR = 24 * KTR2 + 9 * KTR2 + 4;
            PUT @PTR ' 0..3..6..9.12..3..6..9.12' @;
         END;
         PUT ;
         * PRINT HOUR BANNERS ACROSS PAGE;
         DO KTR2 = 0 TO 3;
            PTR = 24 *KTR2 +9 * KTR2 + 4;
            PUT @PTR ' <--- AM ----><--- PM --->' @;
         END;
         PUT;
         * PRINT TITLE BANNERS ACCROSS PAGE;
         PO=KTR1;
         DO KTR2 = 0 TO 3;
            PO + 1;
            PTR = 24 *KTR2 +9 * KTR2 + 8;
            PUT @PTR PTITL $CHAR20.       @;
         END;
         PUT;
      END;
*  CLEAR PLOT AND SAMPLE FOR NEXT DATE;
DO OVER SAMP; * DO EIGHT SET OF SAMPLES;
    PO=HS;
  DO HX=1 TO 24; * DO 24 HOUR UNITS TO BE PLOT WITHIN ONE SET;
     SAMP=0;
     DO PA=1 TO 504; * CLEAR WITHIN A SET;
        PLOT=' ';
     END;
  END;
 END; %
MACRO PLOTDATA;
**  DEFINE ARRAYS OF SAMPLES;
**---- NCP TABLE ---- **;
ARRAY NCP   (DX)  $40 NCP1-NCP16;
ARRAY NCPH (DH)      NCPH1-NCPH16;
**---- NCP VALUE TABLE PER POINTER---- **;
ARRAY RMF1  (SX)  KA1-KA24;
ARRAY RMF2  (SX)  KB1-KB24;
ARRAY RMF3  (SX)  KC1-KC24;
ARRAY RMF4  (SX)  KD1-KD24;
ARRAY RMF5  (SX)  KE1-KE24;
ARRAY RMF6  (SX)  KF1-KF24;
ARRAY RMF7  (SX)  KG1-KG24;
ARRAY RMF8  (SX)  KH1-KH24;
ARRAY RMF9  (SX)  KI1-KI24;
ARRAY RMF10 (SX)  KJ1-KJ24;
ARRAY RMF11 (SX)  KK1-KK24;
ARRAY RMF12 (SX)  KL1-KL24;
ARRAY RMF13 (SX)  KM1-KM24;
ARRAY RMF14 (SX)  KN1-KN24;
ARRAY RMF15 (SX)  KO1-KO24;
ARRAY RMF16 (SX)  KP1-KP24;
ARRAY SAMPX (SS)  RMF1-RMF16;
* ---- SAMPLE FOR PLOT ---- ;
ARRAY RXX1  (HX)  SA1-SA24;
ARRAY RXX2  (HX)  SB1-SB24;
ARRAY RXX3  (HX)  SC1-SC24;
ARRAY RXX4  (HX)  SD1-SD24;
ARRAY RXX5  (HX)  SE1-SE24;
ARRAY RXX6  (HX)  SF1-SF24;
ARRAY RXX7  (HX)  SG1-SG24;
ARRAY RXX8  (HX)  SH1-SH24;
ARRAY SAMP  (HS)  RXX1-RXX8;
ARRAY PTITL (PO) $24 PTITL1-PTITL8;
**  DEFINE ARRAYS ;
ARRAY PLT1  (PA) $1 A1-A504;
ARRAY PLT2  (PA) $1 B1-B504;
ARRAY PLT3  (PA) $1 C1-C504;
ARRAY PLT4  (PA) $1 D1-D504;
ARRAY PLT5  (PA) $1 E1-E504;
ARRAY PLT6  (PA) $1 F1-F504;
ARRAY PLT7  (PA) $1 G1-G504;
ARRAY PLT8  (PA) $1 H1-H504;
ARRAY PLOT  (PO)    PLT1-PLT8;
** ARRAY FOR INTERVAL CONTROL OF EACH PLOT;
ARRAY IVAL  (PO)    IVAL1-IVAL8;
ARRAY PCT   (PO)    PCT1-PCT8;
ARRAY PCTD  (PO)    PCTD1-PCTD8;
** HIGHEST VALUE OF THE DAY FOR INTERVAL DECISION;
ARRAY INTER (IX)  INTER1-INTER8;
RETAIN INTER1-INTER8 IVAL1-IVAL8 PCT1-PCT8 PCTD1-PCTD8;
**  RETAIN ARRAYS ;
RETAIN
NCPH1-NCPH16 0
SA1-SA24 SB1-SB24 SC1-SC24 SD1-SD24 SE1-SE24 SF1-SF24
SG1-SG24 SH1-SH24
KA1-KA24 KB1-KB24 KC1-KC24 KD1-KD24 KE1-KE24 KF1-KF24
KG1-KG24 KH1-KH24
KI1-KI24 KJ1-KJ24 KK1-KK24 KL1-KL24 KM1-KM24 KN1-KN24
KO1-KO24 KP1-KP24 0
A1-A504 B1-B504 C1-C504
D1-D504 E1-E504 F1-F504 G1-G504 H1-H504 ;
RETAIN PTITL1-PTITL8 NCP1-NCP16;
%
*-------------------------------------------------------;
*                                                       ;
* MACRO TO DEFINE FILE STATEMENT FOR SPECIFIED DAY -----;
*                                                       ;
*-------------------------------------------------------;
MACRO PRTDATE;
DAYN=DAY(DATEX); * PUT PLOT INTO DAY SYSOUT FOR EASIER READING;
IF DAYN = 1 THEN FILE DAY1 PRINT NOTITLES;
ELSE IF  DAYN = 2 THEN FILE DAY2 PRINT NOTITLES;
ELSE IF  DAYN = 3 THEN FILE DAY3 PRINT NOTITLES;
ELSE IF  DAYN = 4 THEN FILE DAY4 PRINT NOTITLES;
ELSE IF  DAYN = 5 THEN FILE DAY5 PRINT NOTITLES;
ELSE IF  DAYN = 6 THEN FILE DAY6 PRINT NOTITLES;
ELSE IF  DAYN = 7 THEN FILE DAY7 PRINT NOTITLES;
ELSE IF  DAYN = 8 THEN FILE DAY8 PRINT NOTITLES;
ELSE IF  DAYN = 9 THEN FILE DAY9 PRINT NOTITLES;
ELSE IF  DAYN = 10 THEN FILE DAY10 PRINT NOTITLES;
ELSE IF  DAYN = 11 THEN FILE DAY11 PRINT NOTITLES;
ELSE IF  DAYN = 12 THEN FILE DAY12 PRINT NOTITLES;
ELSE IF  DAYN = 13 THEN FILE DAY13 PRINT NOTITLES;
ELSE IF  DAYN = 14 THEN FILE DAY14 PRINT NOTITLES;
ELSE IF  DAYN = 15 THEN FILE DAY15 PRINT NOTITLES;
ELSE IF  DAYN = 16 THEN FILE DAY16 PRINT NOTITLES;
ELSE IF  DAYN = 17 THEN FILE DAY17 PRINT NOTITLES;
ELSE IF  DAYN = 18 THEN FILE DAY18 PRINT NOTITLES;
ELSE IF  DAYN = 19 THEN FILE DAY19 PRINT NOTITLES;
ELSE IF  DAYN = 20 THEN FILE DAY20 PRINT NOTITLES;
ELSE IF  DAYN = 21 THEN FILE DAY21 PRINT NOTITLES;
ELSE IF  DAYN = 22 THEN FILE DAY22 PRINT NOTITLES;
ELSE IF  DAYN = 23 THEN FILE DAY23 PRINT NOTITLES;
ELSE IF  DAYN = 24 THEN FILE DAY24 PRINT NOTITLES;
ELSE IF  DAYN = 25 THEN FILE DAY25 PRINT NOTITLES;
ELSE IF  DAYN = 26 THEN FILE DAY26 PRINT NOTITLES;
ELSE IF  DAYN = 27 THEN FILE DAY27 PRINT NOTITLES;
ELSE IF  DAYN = 28 THEN FILE DAY28 PRINT NOTITLES;
ELSE IF  DAYN = 29 THEN FILE DAY29 PRINT NOTITLES;
ELSE IF  DAYN = 30 THEN FILE DAY30 PRINT NOTITLES;
ELSE IF  DAYN = 31 THEN FILE DAY31 PRINT NOTITLES;
%
*
               SAS PROGRAM TO READ
            ACF/VTAM TUNING STATISTICS
*   ;
DATA TUNE;
*         SEE SC27-0468-0   APPENDIX C-26     ;
LENGTH DEFAULT=4 TIME 8 ;
 INFILE SMFIN STOPOVER LENGTH=LENGTH COL=COL RECFM=VBS LRECL=32756;
*        DOCUMENTED IN ACF/VTAM INSTALLATION ;
  BEGIN=TIMEPART('07:00:00'T); END=TIMEPART('17:30:00'T);
* --------------------------------------------------- ;
*      UPDATED TUNE HISTORY TABLE;
* DATE    DELAY    MAXBUFR   IOBUF    VPACING   RESULT         ;
* 17JUN83   .1       12      768        0         ;
* 28JUN83  1.0       12      768        0         ;
* 29JUN83 10.0       25      768        0      BAD REPONSE TIME;
* 29JUN83  1.0       12      768        0         ;
* -------------------------------------------------------------;
   INPUT @2 SMF50RTY PIB1. @ ;
  DROP SMF50RTY TIME ;
   IF SMF50RTY NE 50 THEN DELETE ;
*        VSAM SMF FILE ORGANIZATION ;
*       SUBTRACT 4 FROM DISPLACEMENTS FOR
*              NON-VSAM SMF FILES ;
   INPUT @3 TIME     SMFSTAMP8.
         @7 DATEJ    PD4.
         @11 CPU_ID $4.
         @15 NCP_NAME $8.
         @23 NO_DLR   PIB4.
         @27 CHWR     PIB4.
         @31 CHRD     PIB4.
         @35 ATTN     PIB4.
         @39 RDATN    PIB4.
         @43 IPIU     PIB4.
         @47 OPIU     PIB4.
         @51 RDBUF    PIB4.
         @55 SLOWDOWN PIB4. ;
   DATE=DATEPART(TIME) ;
   HOUR=TIMEPART(TIME) ;
   HR =HOUR(HOUR);
   DATEX=DATEJUL(DATEJ);
   SNANAME=NCP_NAME ×× '/' ×× CPU_ID;
   IF HOUR < BEGIN OR HOUR > END THEN DELETE;
    ELSE DO;
   IF IPIU NE 0 THEN BUFFS_IN = RDBUF / IPIU ;
                ELSE BUFFS_IN=0;
   IF CHRD NE 0 THEN ATTNO    = ATTN / CHRD  ;
                ELSE ATTNO=0;
   IF IPIU NE 0 THEN VPAC_NO  = RDBUF / IPIU ;
                ELSE VPAC_NO=0;
   IF BUFFS_IN > 2 THEN FLAG='*';
                   ELSE FLAG=' ';
   END;
FORMAT HOUR  BEGIN  HOUR                             TIME5.;
FORMAT DATE                                         DATE5. ;
PROC SORT ; BY DATE HOUR;
DATA _NULL_; * PRINT BANNERS BY DAY MONTH AND YEAR;
*-------------------------------------------------------;
*                                                       ;
*-----   PRINT BANNERS OF DAY/MONTH/YEAR          ------;
*                                                       ;
*-------------------------------------------------------;
OPTIONS MISSING=' ';
**  DEFINE INPUT FILE;
SET  WORK.TUNE END=EOF; BY DATE HOUR;
IF LAST.DATE × EOF THEN DO;
LENGTH STR $ 20;
LENGTH STRM $ 20;
LENGTH YEAR $ 4;
DAYN=DAY(DATE); * PUT PAGE BANNER ON SYSOUT FOR EASIER READING;
MONTH=MONTH(DATE);YEAR=YEAR(DATE);
IF MONTH = 1        THEN STRM= '/JANUARY/' ×× YEAR ×× '/';
  ELSE IF MONTH = 2 THEN STRM= '/FEBRUARY/' ×× YEAR ×× '/';
  ELSE IF MONTH = 3 THEN STRM= '/MARCH/'    ×× YEAR ×× '/';
  ELSE IF MONTH = 4 THEN STRM= '/APRIL/'    ×× YEAR ×× '/';
  ELSE IF MONTH = 5 THEN STRM= '/MAY/'      ×× YEAR ×× '/';
  ELSE IF MONTH = 6 THEN STRM= '/JUNE/'     ×× YEAR ×× '/';
  ELSE IF MONTH = 7 THEN STRM= '/JULY/'     ×× YEAR ×× '/';
  ELSE IF MONTH = 8 THEN STRM= '/AUGUST/'   ×× YEAR ×× '/';
  ELSE IF MONTH = 9 THEN STRM= '/SEPTEMBER/' ×× YEAR ×× '/';
  ELSE IF MONTH = 10 THEN STRM= '/OCTOBER/'  ×× YEAR ×× '/';
  ELSE IF MONTH = 11 THEN STRM= '/NOVEMBER/' ×× YEAR ×× '/';
  ELSE IF MONTH = 12 THEN STRM= '/DECEMBER/' ×× YEAR ×× '/';
 IF DAYN = 1       THEN STR='(DAY1)/1'   ×× STRM;
ELSE IF  DAYN = 2 THEN  STR='(DAY2)/2'   ×× STRM;
ELSE IF  DAYN = 3 THEN  STR='(DAY3)/3'   ×× STRM;
ELSE IF  DAYN = 4 THEN  STR='(DAY4)/4'   ×× STRM;
ELSE IF  DAYN = 5 THEN  STR='(DAY5)/5'   ×× STRM;
ELSE IF  DAYN = 6 THEN  STR='(DAY6)/6'   ×× STRM;
ELSE IF  DAYN = 7 THEN  STR='(DAY7)/7'   ×× STRM;
ELSE IF  DAYN = 8 THEN  STR='(DAY8)/8'   ×× STRM;
ELSE IF  DAYN = 9 THEN  STR='(DAY9)/9'   ×× STRM;
ELSE IF  DAYN = 10 THEN STR='(DAY10)/10' ×× STRM;
ELSE IF  DAYN = 11 THEN STR='(DAY11)/11' ×× STRM;
ELSE IF  DAYN = 12 THEN STR='(DAY12)/12' ×× STRM;
ELSE IF  DAYN = 13 THEN STR='(DAY13)/13' ×× STRM;
ELSE IF  DAYN = 14 THEN STR='(DAY14)/14' ×× STRM;
ELSE IF  DAYN = 15 THEN STR='(DAY15)/15' ×× STRM;
ELSE IF  DAYN = 16 THEN STR='(DAY16)/16' ×× STRM;
ELSE IF  DAYN = 17 THEN STR='(DAY17)/17' ×× STRM;
ELSE IF  DAYN = 18 THEN STR='(DAY18)/18' ×× STRM;
ELSE IF  DAYN = 19 THEN STR='(DAY19)/19' ×× STRM;
ELSE IF  DAYN = 20 THEN STR='(DAY20)/20' ×× STRM;
ELSE IF  DAYN = 21 THEN STR='(DAY21)/21' ×× STRM;
ELSE IF  DAYN = 22 THEN STR='(DAY22)/22' ×× STRM;
ELSE IF  DAYN = 23 THEN STR='(DAY23)/23' ×× STRM;
ELSE IF  DAYN = 24 THEN STR='(DAY24)/24' ×× STRM;
ELSE IF  DAYN = 25 THEN STR='(DAY25)/25' ×× STRM;
ELSE IF  DAYN = 26 THEN STR='(DAY26)/26' ×× STRM;
ELSE IF  DAYN = 27 THEN STR='(DAY27)/27' ×× STRM;
ELSE IF  DAYN = 28 THEN STR='(DAY28)/28' ×× STRM;
ELSE IF  DAYN = 29 THEN STR='(DAY29)/29' ×× STRM;
ELSE IF  DAYN = 30 THEN STR='(DAY30)/30' ×× STRM;
ELSE IF  DAYN = 31 THEN STR='(DAY31)/31' ×× STRM;
IF DAYN = 1 THEN FILE DAY1 PRINT NOTITLES;
ELSE IF  DAYN = 2 THEN FILE DAY2 PRINT NOTITLES;
ELSE IF  DAYN = 3 THEN FILE DAY3 PRINT NOTITLES;
ELSE IF  DAYN = 4 THEN FILE DAY4 PRINT NOTITLES;
ELSE IF  DAYN = 5 THEN FILE DAY5 PRINT NOTITLES;
ELSE IF  DAYN = 6 THEN FILE DAY6 PRINT NOTITLES;
ELSE IF  DAYN = 7 THEN FILE DAY7 PRINT NOTITLES;
ELSE IF  DAYN = 8 THEN FILE DAY8 PRINT NOTITLES;
ELSE IF  DAYN = 9 THEN FILE DAY9 PRINT NOTITLES;
ELSE IF  DAYN = 10 THEN FILE DAY10 PRINT NOTITLES;
ELSE IF  DAYN = 11 THEN FILE DAY11 PRINT NOTITLES;
ELSE IF  DAYN = 12 THEN FILE DAY12 PRINT NOTITLES;
ELSE IF  DAYN = 13 THEN FILE DAY13 PRINT NOTITLES;
ELSE IF  DAYN = 14 THEN FILE DAY14 PRINT NOTITLES;
ELSE IF  DAYN = 15 THEN FILE DAY15 PRINT NOTITLES;
ELSE IF  DAYN = 16 THEN FILE DAY16 PRINT NOTITLES;
ELSE IF  DAYN = 17 THEN FILE DAY17 PRINT NOTITLES;
ELSE IF  DAYN = 18 THEN FILE DAY18 PRINT NOTITLES;
ELSE IF  DAYN = 19 THEN FILE DAY19 PRINT NOTITLES;
ELSE IF  DAYN = 20 THEN FILE DAY20 PRINT NOTITLES;
ELSE IF  DAYN = 21 THEN FILE DAY21 PRINT NOTITLES;
ELSE IF  DAYN = 22 THEN FILE DAY22 PRINT NOTITLES;
ELSE IF  DAYN = 23 THEN FILE DAY23 PRINT NOTITLES;
ELSE IF  DAYN = 24 THEN FILE DAY24 PRINT NOTITLES;
ELSE IF  DAYN = 25 THEN FILE DAY25 PRINT NOTITLES;
ELSE IF  DAYN = 26 THEN FILE DAY26 PRINT NOTITLES;
ELSE IF  DAYN = 27 THEN FILE DAY27 PRINT NOTITLES;
ELSE IF  DAYN = 28 THEN FILE DAY28 PRINT NOTITLES;
ELSE IF  DAYN = 29 THEN FILE DAY29 PRINT NOTITLES;
ELSE IF  DAYN = 30 THEN FILE DAY30 PRINT NOTITLES;
ELSE IF  DAYN = 31 THEN FILE DAY31 PRINT NOTITLES;
CALL BLOKHEAD(STR); *ASM PGM TO PRINT BLOCK HEAD PAGE;
     END;
RETURN;
PROC MEANS MAXDEC=2
DATA=TUNE(DROP=SNANAME DATEJ BEGIN END HOUR NCP_NAME CPU_ID);
BY DATE ;
PROC SORT ; BY CPU_ID;
PROC MEANS MAXDEC=2
DATA=TUNE(DROP=SNANAME DATEJ BEGIN END HOUR DATE NCP_NAME);
BY CPU_ID;
PROC SORT ; BY SNANAME;
PROC MEANS MAXDEC=2
DATA=TUNE(DROP=NCP_NAME DATEJ BEGIN END HOUR DATE CPU_ID);
BY SNANAME ;
PROC SORT DATA=TUNE; BY DATEX HR;
DATA _NULL_; * TOTAL # OF INBOUND ( TO VTAM) RECVD FROM 37X5;
OPTIONS MISSING=' ';
**  DEFINE INPUT FILE;
SET TUNE END=EOF; BY DATEX HR;
PLOTDATA;
**  ESTABLISH INPUT AND OUTPUT FILE;
IF HR = . THEN DELETE;
DO OVER SAMPX;
DO SX=HR TO 24;
* TUNE (KEEP= DATEX HR NCP_NAME CPU_ID IPIU BUFFS_IN RDBUF CHRD ATTNO
 SNANAME FLAG NO_DLR CHWR ATTN RDATN OPIU SLOWDOWN;
DO DX=1 TO 10;
IF NCP = '      ' THEN NCP=SNANAME;
IF NCP = SNANAME THEN DO;
   SS=DX;
   DH=DX;
   SAX=INT(IPIU);
   NCPH=MAX(NCPH,SAX);
   SAMPX=INT(SAX);
   DX=10;
   END;
END;
SX=24; END;
SS=60; END;
IF LAST.DATEX × EOF THEN DO;
PRTDATE;
RETAIN TITLE;
TITLE='SNA TUNE PERFORMANCE - TOTAL # OF INBOUND (TO VTAM FROM 37X5) ';
DO OVER SAMP;
PO=HS;
 DO DX=1 TO 10;
  DO OVER SAMPX;
  DH=DX;
    IF NCP ^= ' ' THEN PTITL='     ' ××  NCP;
                  ELSE  PTITL='     ';
     SS=DX;
     DO HX=1 TO 24;
        SX=HX;
        SAMP=SAMPX;
        IX=HS;INTER=MAX(INTER,SAMP);
        END;
     HS+1; PO=HS;
*    END;
     NCPH=0; *CLEAR FOR NEXT DAY;
   SS=60; END;
   IF PO=9 THEN DX=10;
  END;
  HS=8;
END;
PLOT8UP;
     END;
DATA _NULL_;* TOTAL # OF OUTPUT (FROM VTAM TO 37X5;
OPTIONS MISSING=' ';
**  DEFINE INPUT FILE;
SET TUNE END=EOF; BY DATEX HR;
PLOTDATA;
**  ESTABLISH INPUT AND OUTPUT FILE;
IF HR = . THEN DELETE;
DO OVER SAMPX;
DO SX=HR TO 24;
* TUNE (KEEP= DATEX HR NCP_NAME CPU_ID IPIU BUFFS_IN RDBUF CHRD ATTNO
 SNANAME FLAG NO_DLR CHWR ATTN RDATN OPIU SLOWDOWN;
DO DX=1 TO 10;
IF NCP = '      ' THEN NCP=SNANAME;
IF NCP = SNANAME THEN DO;
   SS=DX;
   DH=DX;
   SAX=INT(OPIU);
   NCPH=MAX(NCPH,SAX);
   SAMPX=INT(SAX);
   DX=10;
   END;
END;
SX=24; END;
SS=60; END;
IF LAST.DATEX × EOF THEN DO;
PRTDATE;
RETAIN TITLE;
TITLE='SNA TUNE PERFORMANCE - TOT # OF OUTBOUND (FROM VTAM TO 37X5) ';
DO OVER SAMP;
PO=HS;
 DO DX=1 TO 10;
  DO OVER SAMPX;
  DH=DX;
    IF NCP ^= ' ' THEN PTITL='     ' ×× NCP;
                  ELSE  PTITL='     ';
     SS=DX;
     DO HX=1 TO 24;
        SX=HX;
        SAMP=SAMPX;
        IX=HS;INTER=MAX(INTER,SAMP);
        END;
     HS+1; PO=HS;
*    END;
     NCPH=0; *CLEAR FOR NEXT DAY;
   SS=60; END;
   IF PO=9 THEN DX=10;
  END;
  HS=8;
END;
PLOT8UP;
     END;
DATA _NULL_; * TOTAL # OF VTAM BUFFERS USED FOR READ OPERATIONS;
OPTIONS MISSING=' ';
**  DEFINE INPUT FILE;
SET TUNE END=EOF; BY DATEX HR;
PLOTDATA;
**  ESTABLISH INPUT AND OUTPUT FILE;
IF HR = . THEN DELETE;
DO OVER SAMPX;
DO SX=HR TO 24;
* TUNE (KEEP= DATEX HR NCP_NAME CPU_ID IPIU BUFFS_IN RDBUF CHRD ATTNO
SNANAME FLAG NO_DLR CHWR ATTN RDATN OPIU SLOWDOWN;
DO DX=1 TO 10;
IF NCP = '      ' THEN NCP=SNANAME;
IF NCP = SNANAME THEN DO;
   SS=DX;
   DH=DX;
   SAX=INT(RDBUF);
   NCPH=MAX(NCPH,SAX);
   SAMPX=INT(SAX);
   DX=10;
   END;
END;
SX=24; END;
SS=60; END;
IF LAST.DATEX × EOF THEN DO;
PRTDATE;
RETAIN TITLE;
TITLE='SNA TUNE PERFORMANCE - READ ACF/VTAM BUFFERS - ';
DO OVER SAMP;
PO=HS;
 DO DX=1 TO 10;
  DO OVER SAMPX;
  DH=DX;
    IF NCP ^= ' ' THEN PTITL='     ' ×× NCP;
                  ELSE  PTITL='     ';
     SS=DX;
     DO HX=1 TO 24;
        SX=HX;
        SAMP=SAMPX;
        IX=HS;INTER=MAX(INTER,SAMP);
        END;
     HS+1; PO=HS;
*    END;
     NCPH=0; *CLEAR FOR NEXT DAY;
   SS=60; END;
   IF PO=9 THEN DX=10;
  END;
  HS=8;
END;
PLOT8UP;
     END;
DATA _NULL_;
OPTIONS MISSING=' ';
**  DEFINE INPUT FILE;
SET TUNE END=EOF; BY DATEX HR;
PLOTDATA;
**  ESTABLISH INPUT AND OUTPUT FILE;
IF HR = . THEN DELETE;
DO OVER SAMPX;
DO SX=HR TO 24;
* TUNE (KEEP= DATEX HR NCP_NAME CPU_ID IPIU BUFFS_IN RDBUF CHRD ATTNO
SNANAME  FLAG NO_DLR CHWR ATTN RDATN OPIU SLOWDOWN;
DO DX=1 TO 10;
IF NCP = '      ' THEN NCP=SNANAME;
IF NCP = SNANAME THEN DO;
   SS=DX;
   DH=DX;
   SAX=INT(BUFFS_IN*100); * SCALE: 1UNIT= .01;
   NCPH=MAX(NCPH,SAX);
   SAMPX=INT(SAX);
   DX=10;
   END;
END;
SX=24; END;
SS=60; END;
IF LAST.DATEX × EOF THEN DO;
PRTDATE;
RETAIN TITLE;
TITLE='SNA TUNE PERFORMANCE - BUFFER IN (RDBUF/IPIU) - SCALE: 1=.01 -';
DO OVER SAMP;
PO=HS;
 DO DX=1 TO 10;
  DO OVER SAMPX;
  DH=DX;
    IF NCP ^= ' ' THEN PTITL='     ' ×× NCP;
                  ELSE  PTITL='     ';
     SS=DX;
     DO HX=1 TO 24;
        SX=HX;
        SAMP=SAMPX;
        IX=HS;INTER=MAX(INTER,SAMP);
        END;
     HS+1; PO=HS;
     NCPH=0; *CLEAR FOR NEXT DAY;
   SS=60; END;
   IF PO=9 THEN DX=10;
  END;
  HS=8;
END;
PLOT8UP;
     END;
DATA _NULL_;
OPTIONS MISSING=' ';
**  DEFINE INPUT FILE;
SET TUNE END=EOF; BY DATEX HR;
PLOTDATA;
**  ESTABLISH INPUT AND OUTPUT FILE;
IF HR = . THEN DELETE;
DO OVER SAMPX;
DO SX=HR TO 24;
* TUNE (KEEP= DATEX HR NCP_NAME CPU_ID IPIU BUFFS_IN RDBUF CHRD ATTNO
SNANAME FLAG NO_DLR CHWR ATTN RDATN OPIU SLOWDOWN;
DO DX=1 TO 10;
IF NCP = '      ' THEN NCP=SNANAME;
IF NCP = SNANAME THEN DO;
   SS=DX;
   DH=DX;
   SAX=INT(CHWR);
   NCPH=MAX(NCPH,SAX);
   SAMPX=INT(SAX);
   DX=10;
   END;
END;
SX=24; END;
SS=60; END;
IF LAST.DATEX × EOF THEN DO;
PRTDATE;
RETAIN TITLE;
TITLE='SNA TUNE PERFORMANCE - CHANNEL WRITE (CHWR) - ';
DO OVER SAMP;
PO=HS;
 DO DX=1 TO 10;
  DO OVER SAMPX;
  DH=DX;
    IF NCP ^= ' ' THEN PTITL='    ' ×× NCP;
                  ELSE  PTITL='     ';
     SS=DX;
     DO HX=1 TO 24;
        SX=HX;
        SAMP=SAMPX;
        IX=HS;INTER=MAX(INTER,SAMP);
        END;
     HS+1; PO=HS;
*    END;
     NCPH=0; *CLEAR FOR NEXT DAY;
   SS=60; END;
   IF PO=9 THEN DX=10;
  END;
  HS=8;
END;
PLOT8UP;
     END;
DATA _NULL_;
OPTIONS MISSING=' ';
**  DEFINE INPUT FILE;
SET TUNE END=EOF; BY DATEX HR;
PLOTDATA;
**  ESTABLISH INPUT AND OUTPUT FILE;
IF HR = . THEN DELETE;
DO OVER SAMPX;
DO SX=HR TO 24;
* TUNE (KEEP= DATEX HR NCP_NAME CPU_ID IPIU BUFFS_IN RDBUF CHRD ATTNO
 SNANAME FLAG NO_DLR CHWR ATTN RDATN OPIU SLOWDOWN;
DO DX=1 TO 10;
IF NCP = '      ' THEN NCP=SNANAME;
IF NCP = SNANAME THEN DO;
   SS=DX;
   DH=DX;
   SAX=INT(CHRD);
   NCPH=MAX(NCPH,SAX);
   SAMPX=INT(SAX);
   DX=10;
   END;
END;
SX=24; END;
SS=60; END;
IF LAST.DATEX × EOF THEN DO;
PRTDATE;
RETAIN TITLE;
TITLE='SNA TUNE PERFORMANCE - CHANNEL READ (CHRD) - ';
DO OVER SAMP;
PO=HS;
 DO DX=1 TO 10;
  DO OVER SAMPX;
  DH=DX;
    IF NCP ^= ' ' THEN PTITL='     ' ×× NCP;
                  ELSE  PTITL='     ';
     SS=DX;
     DO HX=1 TO 24;
        SX=HX;
        SAMP=SAMPX;
        IX=HS;INTER=MAX(INTER,SAMP);
        END;
     HS+1; PO=HS;
*    END;
     NCPH=0; *CLEAR FOR NEXT DAY;
   SS=60; END;
   IF PO=9 THEN DX=10;
  END;
  HS=8;
END;
PLOT8UP;
     END;
DATA _NULL_;
OPTIONS MISSING=' ';
**  DEFINE INPUT FILE;
SET TUNE END=EOF; BY DATEX HR;
PLOTDATA;
**  ESTABLISH INPUT AND OUTPUT FILE;
IF HR = . THEN DELETE;
DO OVER SAMPX;
DO SX=HR TO 24;
* TUNE (KEEP= DATEX HR NCP_NAME CPU_ID IPIU BUFFS_IN RDBUF CHRD ATTNO
SNANAME FLAG NO_DLR CHWR ATTN RDATN OPIU SLOWDOWN;
DO DX=1 TO 10;
IF NCP = '      ' THEN NCP=SNANAME;
IF NCP = SNANAME THEN DO;
   SS=DX;
   DH=DX;
   SAX=INT(SLOWDOWN);
   NCPH=MAX(NCPH,SAX);
   SAMPX=INT(SAX);
   DX=10;
   END;
END;
SX=24; END;
SS=60; END;
IF LAST.DATEX × EOF THEN DO;
PRTDATE;
RETAIN TITLE;
TITLE='SNA TUNE PERFORMANCE - SLOWDOWN ANALYSIS ';
DO OVER SAMP;
PO=HS;
 DO DX=1 TO 10;
  DO OVER SAMPX;
  DH=DX;
    IF NCP ^= ' ' THEN PTITL='     ' ×× NCP;
                  ELSE  PTITL='     ';
     SS=DX;
     DO HX=1 TO 24;
        SX=HX;
        SAMP=SAMPX;
        IX=HS;INTER=MAX(INTER,SAMP);
        END;
     HS+1; PO=HS;
*    END;
     NCPH=0; *CLEAR FOR NEXT DAY;
   SS=60; END;
   IF PO=9 THEN DX=10;
  END;
  HS=8;
END;
PLOT8UP;
     END;
DATA _NULL_; * # OF TIMES THAT THE ATTENTION WAS INCLUDED IN THE
  ENDING STATUS ON A READ CHANNEL PGM;
* NO OF TIMES THAT AFTER READING DATA, WAS REQUESTED WITH AN ATTENTION
  TO READ MORE DATA;
OPTIONS MISSING=' ';
**  DEFINE INPUT FILE;
SET TUNE END=EOF; BY DATEX HR;
PLOTDATA;
**  ESTABLISH INPUT AND OUTPUT FILE;
IF HR = . THEN DELETE;
DO OVER SAMPX;
DO SX=HR TO 24;
* TUNE (KEEP= DATEX HR NCP_NAME CPU_ID IPIU BUFFS_IN RDBUF CHRD ATTNO
SNANAME FLAG NO_DLR CHWR ATTN RDATN OPIU SLOWDOWN;
DO DX=1 TO 10;
IF NCP = '      ' THEN NCP=SNANAME;
IF NCP = SNANAME THEN DO;
   SS=DX;
   DH=DX;
   SAX=INT(RDATN);
   NCPH=MAX(NCPH,SAX);
   SAMPX=INT(SAX);
   DX=10;
   END;
END;
SX=24; END;
SS=60; END;
IF LAST.DATEX × EOF THEN DO;
PRTDATE;
RETAIN TITLE;
TITLE='SNA TUNE PERFORMANCE - READ DATA WITH ATTN ANALYSIS ';
DO OVER SAMP;
PO=HS;
 DO DX=1 TO 10;
  DO OVER SAMPX;
  DH=DX;
    IF NCP ^= ' ' THEN PTITL='     ' ×× NCP;
                  ELSE  PTITL='     ';
     SS=DX;
     DO HX=1 TO 24;
        SX=HX;
        SAMP=SAMPX;
        IX=HS;INTER=MAX(INTER,SAMP);
        END;
     HS+1; PO=HS;
*    END;
     NCPH=0; *CLEAR FOR NEXT DAY;
   SS=60; END;
   IF PO=9 THEN DX=10;
  END;
  HS=8;
END;
PLOT8UP;
     END;
DATA _NULL_;
OPTIONS MISSING=' ';
**  DEFINE INPUT FILE;
SET TUNE END=EOF; BY DATEX HR;
PLOTDATA;
**  ESTABLISH INPUT AND OUTPUT FILE;
IF HR = . THEN DELETE;
DO OVER SAMPX;
DO SX=HR TO 24;
* TUNE (KEEP= DATEX HR NCP_NAME CPU_ID IPIU BUFFS_IN RDBUF CHRD ATTNO
SNANAME FLAG NO_DLR CHWR ATTN RDATN OPIU SLOWDOWN;
DO DX=1 TO 10;
IF NCP = '      ' THEN NCP=SNANAME;
IF NCP = SNANAME THEN DO;
   SS=DX;
   DH=DX;
   SAX=INT(ATTNO*100); * SCALE: 1=0.01UNITS;
   NCPH=MAX(NCPH,SAX);
   SAMPX=INT(SAX);
   DX=10;
   END;
END;
SX=24; END;
SS=60; END;
IF LAST.DATEX × EOF THEN DO;
PRTDATE;
RETAIN TITLE;
TITLE='SNA TUNE PERFORMANCE - ATTENTION (ATTN/CHRD)- SCALE: 1=.01';
DO OVER SAMP;
PO=HS;
 DO DX=1 TO 10;
  DO OVER SAMPX;
  DH=DX;
    IF NCP ^= ' ' THEN PTITL='     ' ×× NCP;
                  ELSE  PTITL='     ';
     SS=DX;
     DO HX=1 TO 24;
        SX=HX;
        SAMP=SAMPX;
        IX=HS;INTER=MAX(INTER,SAMP);
        END;
     HS+1; PO=HS;
*    END;
     NCPH=0; *CLEAR FOR NEXT DAY;
   SS=60; END;
   IF PO=9 THEN DX=10;
  END;
  HS=8;
END;
PLOT8UP;
     END;
DATA _NULL_;
OPTIONS MISSING=' ';
**  DEFINE INPUT FILE;
SET TUNE END=EOF; BY DATEX HR;
PLOTDATA;
**  ESTABLISH INPUT AND OUTPUT FILE;
IF HR = . THEN DELETE;
DO OVER SAMPX;
DO SX=HR TO 24;
* TUNE (KEEP= DATEX HR NCP_NAME CPU_ID IPIU BUFFS_IN RDBUF CHRD ATTNO
SNANAME FLAG NO_DLR CHWR ATTN RDATN OPIU SLOWDOWN;
DO DX=1 TO 10;
IF NCP = '      ' THEN NCP=SNANAME;
IF NCP = SNANAME THEN DO;
   SS=DX;
   DH=DX;
   SAX=INT(VPAC_NO*100);* SCALE: 1UNIT= .01;
   NCPH=MAX(NCPH,SAX);
   SAMPX=INT(SAX);
   DX=10;
   END;
END;
SX=24; END;
SS=60; END;
IF LAST.DATEX × EOF THEN DO;
PRTDATE;
RETAIN TITLE;
TITLE='SNA TUNE PERFORMANCE - VPAC_NO (RDBUF/IPIU) - SCALE 1=.001 -';
DO OVER SAMP;
PO=HS;
 DO DX=1 TO 10;
  DO OVER SAMPX;
  DH=DX;
    IF NCP ^= ' ' THEN PTITL='     ' ×× NCP;
                  ELSE  PTITL='     ';
     SS=DX;
     DO HX=1 TO 24;
        SX=HX;
        SAMP=SAMPX;
        IX=HS;INTER=MAX(INTER,SAMP);
        END;
     HS+1; PO=HS;
*    END;
     NCPH=0; *CLEAR FOR NEXT DAY;
   SS=60; END;
   IF PO=9 THEN DX=10;
  END;
  HS=8;
END;
PLOT8UP;
     END;
DATA _NULL_;
OPTIONS MISSING=' ';
**  DEFINE INPUT FILE;
SET TUNE END=EOF; BY DATEX HR;
PLOTDATA;
**  ESTABLISH INPUT AND OUTPUT FILE;
IF HR = . THEN DELETE;
DO OVER SAMPX;
DO SX=HR TO 24;
* TUNE (KEEP= DATEX HR NCP_NAME CPU_ID IPIU BUFFS_IN RDBUF CHRD ATTNO
SNANAME FLAG NO_DLR CHWR ATTN RDATN OPIU SLOWDOWN;
DO DX=1 TO 10;
IF NCP = '      ' THEN NCP=SNANAME;
IF NCP = SNANAME THEN DO;
   SS=DX;
   DH=DX;
   SAX=INT(ATTN);
   NCPH=MAX(NCPH,SAX);
   SAMPX=INT(SAX);
   DX=10;
   END;
END;
SX=24; END;
SS=60; END;
IF LAST.DATEX × EOF THEN DO;
PRTDATE;
RETAIN TITLE;
TITLE='SNA TUNE PERFORMANCE - ASYNC I/O ATTN INTERRRUPTS - ';
DO OVER SAMP;
PO=HS;
 DO DX=1 TO 10;
  DO OVER SAMPX;
  DH=DX;
    IF NCP ^= ' ' THEN PTITL='     ' ×× NCP;
                  ELSE  PTITL='     ';
     SS=DX;
     DO HX=1 TO 24;
        SX=HX;
        SAMP=SAMPX;
        IX=HS;INTER=MAX(INTER,SAMP);
        END;
     HS+1; PO=HS;
*    END;
     NCPH=0; *CLEAR FOR NEXT DAY;
   SS=60; END;
   IF PO=9 THEN DX=10;
  END;
  HS=8;
END;
PLOT8UP;
     END;
./       ADD   NAME=PRINTOF2
PRINTOFF TITLE 'IPO-SUPPLIED PRINT COMMAND                             C
                        '
* IMPLEMENTED BY DOR/CDSI 12/6/85                                  .DOR
*     FOR MICROFICHE PRINTING WITH BLOCKHEAD OF EACH MEMBER        .DOR
*  DAVID RIKER; COMPUTER DATA SYSTEMS, INC.;1 CURIE COURT;         .DOR
*    ROCKVILLE MD 20850;202-362-1160                               .DOR
*$DOC@*****************************************************************
*                                                                     *
*             MODULE NAME = PRINTOFF                                  *
*                                                                     *
*             DESCRIPTIVE NAME =  IPO SUPPLIED PRINT COMMAND FOR      *
*                TSO FOREGROUND EXECUTION                             *
*                                                                     *
*             COPYRIGHT = NONE                                        *
*                                                                     *
*             STATUS = RELEASE 01.0 OF IPO                            *
*                                                                     *
*             FUNCTION =                                              *
*                PRINTS A DATASET(S) WHICH IS SEQUENTIAL OR PARTIONED *
*                ALLOWING THE USER TO SPECIFY OUTPUT CLASS, COPIES,   *
*                DESTINATION AND HOLD/NOHOLD.  ALSO ALLOWS THE USER   *
*                TO SPECIFY LIST/NOLIST, PRINT/NOPRINT, VOLUME,       *
*                OR FOLD/NOFOLD.                                      *
*                LIST IF PDS MEMBER NAMES ARE ONLY TO BE LISTED.      *
*                PRINT IF PDS MEMBERS ARE ONLY TO BE PRINTED.         *
*                                                                     *
*                MODS=                                                *
*                .  NEW KEYWORD  BLOCK AND NOBLOCK TO INCLUDE     .DOR.
*                   BLOCKHEAD ON A PGE FOR MICROFICHE READING     .DOR.
*                .  NEW KEYWORDS FORMS, TRAIN (OR UCS), FCB,      .GTE.
*                   CAPS (ALIAS OF FOLD), ASIS (ALIAS OF NOFOLD), .GTE.
*                   TEXT (ASIS,UCS(TN)), PROG, AND NOHEADING.     .GTE.
*                .  NEW KEYWORDS ASA (FOR DATA SETS CONTAINING    .PRC.
*                   ASA CONTROLS BUT NOT MARKED AS SUCH),         .PRC.
*                   SNUM TO SUPPRESS SEQUENCE NUMBERS, AND        .PRC.
*                   NOMSG TO SUPPRESS TERMINAL MESSAGES.          .PRC.
*                .  CALL DEFAULT SERVICE ROUTINE.                 .GTE.
*                .  FREE INPUT DATA SET.                          .GTE.
*                .  REPLACE CVT MACRO WITH INLINE CODE SO         .PRC.
*                   ASSEMBLER DOES NOT NEED AMODGEN LIBRARY.      .PRC.
*                .  GTE MODS RE-TAGGED IN COLUMNS 67-71.          .PRC.
*                .  GTE MODS FROM CBT TAPE VERSION 92, 23JUL78.   .PRC.
*                   THIS WAS REPLACED ON  VERSION 128, 01OCT79    .PRC.
*                   WITH FURTHER GTE MODS NOT INCLUDED HERE.      .PRC.
*                .  PRC MODS BY BILL GODFREY,                     .PRC.
*                   PRC COMPUTER CENTER INC, MCLEAN VA.           .PRC.
*                                                                     *
*                OPERATION =                                          *
*                   BUILD PARS, DAIR, AND PUTLINE PARAMETER LISTS.    *
*                   CALL PARS TO PARSE COMMAND BUFFER.                *
*                   ALLOCATE DATASET AND DETERMINE IF PDS OR          *
*                      SEQUENTIAL.                                    *
*                   DETERMINE WHAT FUNCTIONS WERE TO BE PERFORMED     *
*                      FOR THIS DATASET IF PDS.                       *
*                   ALLOCATE SYSOUT DATASETS WHEN SOMETHING IS        *
*                      FOUND TO BE PRINTED.                           *
*                   PROCESS NEXT DATASET IN LIST.                     *
*                   AT END OF LIST CLOSE DATASETS AND FREE ANY        *
*                      SYSOUT DATASETS.                               *
*                   DATSETS WILL BE PRINTED AS EITHER VBA OR VBM.     *
*                                                                     *
*              NOTES =                                                *
*                                                                     *
*                 DEPENDENCIES = CHARACTER SET IS EBCDIC.  REASSEMBLE *
*                    IF A DIFFERENT CHARACTER SET IS NEEDED.          *
*                                                                     *
*                 RESTRICTIONS = DATASETS MUST HAVE LRECL LESS THAN   *
*                    255 AND MUST BE EITHER FIXED OR VARIABLE FORMAT. *
*                                                                     *
*                 REGISTER CONVENTIONS = STANDARD CONVENTIONS.        *
*                    REGISTERS 0 TO 10 = WORK REGISTERS               *
*                    REGISTER  11      = UNUSED                       *
*                    REGISTER  12      = ADDRESSABILITY TO PRINTOFF   *
*                                        CSECT                        *
*                    REGISTER  13      = SAVE AREA REGISTER AND       *
*                                        ADDRESSABILITY TO GETMAINED  *
*                                        WORK AREA                    *
*                    REGISTERS 14,15   = WORK REGISTERS               *
*                                                                     *
*                PATCH LABEL = PATCH (UNUSED AND INTIALIZED TO        *
*                   'ZAP*'S)                                          *
*                                                                     *
*                TSO COMMAND SYNTAX = PRINTOFF (DATASET LIST)         *
*                   CLASS(SYSOUT CLASS) DEST(USERID) COPIES(NUMBER)   *
*                   HOLD/NOHOLD LIST/NOLIST PRINT/NOPRINT FOLD/NOFOLD *
*                                                                     *
*             MODULE TYPE = PROCEDURE                                 *
*                                                                     *
*                PROCESSOR = ASM                                      *
*                                                                     *
*                MODULE SIZE = 5K BYTES                               *
*                                                                     *
*                ATTRIBUTES = SCHEDULER KEY 8, REENTRANT,             *
*                   PROBLEM PROGRAM STATE                             *
*                                                                     *
*             ENTRY POINTS = PRINTOFF (ONLY ENTRY POINT)              *
*                                                                     *
*                LINKAGE =                                            *
*                   FROM TERMINAL MONITOR PROGRAM AS A COMMAND        *
*                                                                     *
*             INPUT = REGISTER 1 POINTS TO COMMAND PROCESSOR          *
*                PARAMETER LIST MAPPED BY IKJCPPL MACRO               *
*                                                                     *
*             OUTPUT = NONE                                           *
*                                                                     *
*             EXIT - NORMAL = AT PROGRAM END VIA BRANCH REGISTER 14   *
*                                                                     *
*                OUTPUT = NONE                                        *
*                                                                     *
*                RETURN CODE = ZERO                                   *
*                                                                     *
*             EXIT - ERROR = NONE - PROGRAM WILL DISPLAY DECIMAL      *
*                RETURN CODE AND RETURN VIA BRANCH REGISTER 14        *
*                                                                     *
*                OUTPUT = NONE                                        *
*                                                                     *
*                RETURN CODE = ZERO                                   *
*                                                                     *
*             EXTERNAL REFERENCES =                                   *
*                                                                     *
*                ROUTINES = IKJPARS, DAIRFAIL, GNRLFAIL, PUTLINE,     *
*                           BLOCKSUB                                  *
*                                                                     *
*                DATA AREAS = NONE                                    *
*                                                                     *
*                CONTROL BLOCKS = CPPL, PPL, DAPL, DCB, DAPB, CVT,    *
*                   S99RBP, S99RB, S99TUPL, S99TUNIT, S99TUFLD,       *
*                   GFPARMS, DFPARMS, IOPL, IOPB                      *
*                                                                     *
*             TABLES = DATA AREA TO BE GETMAINED.  MAPPED BY DSECT    *
*                BEGINNING AT LABEL RDATD.                            *
*                                                                     *
*             MACROS = SAVE, GETMAIN, CALLTSSR, LINK, TPUT, FREEMAIN, *
*                   OPEN, PUT, GET, CLOSE, RDJFCB, IKJRLSA, DYNALLOC, *
*                   DCB, IKJPARM, IKJPOSIT, IKJKEYWD, IKJNAME,        *
*                   IKJSUBF, IKJIDENT, IKJENDP, IKJDAP08, IKJDAP18,   *
*                   IKJDAPL, IKJCPPL, IKJPPL, CVT, IEFZB4D0, IKJIOPL, *
*                   IEFZB4D2, DCBD, IKJEFFGF, IKJEFFDF, PUTLINE       *
*                                                                     *
*             CHANGE ACTIVITY = NONE                                  *
*                                                                     *
*             MESSAGES =                                              *
*                                                                     *
*                BOTH THE DARIFAIL AND GNRLFAIL SERVICE ROUTINES ARE  *
*                USED TO ISSUE MESSAGES.                              *
*                THOSE ISSUED BY THE COMMAND ARE FOUND FOLLOWING THE  *
*                LABEL GNRLERR AND ARE ISSUED USING PUTLINE.          *
*                                                                     *
*             ABEND CODES = NONE                                      *
*                                                                     *
*$DOC$*****************************************************************
*
PRINTOFF CSECT
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         SAVE  (14,12),,HARDCOPY.IPO.&SYSTIME_&SYSDATE SAVE REGISTERS
         LR    R12,R15                 LOAD REGISTER 12 WITH ENTRY
*                                      ADDRESS
         USING PRINTOFF,R12            ESTABLISH ADDRESSABILITY TO
*                                      PROGRAM CSECT
         LA    R11,4095(R12)           LOAD REGISTER 11 WITH ENTRY
*                                      ADDRESS 4095
         USING PRINTOFF+4095,R11       ESTABLISH ADDRESSABILITY TO THE
*                                      REST OF THE PROGRAM CSECT
         LR    R8,R1                   LOAD REGISTER 8 TO PRESERVE
*                                      POINTER TO COMMAND PROCESSOR
*                                      PARAMETER LIST
         GETMAIN R,LV=LDYNAMIC         GETMAIN DYNAMIC WORKAREA
         LR    R10,R1                  LOAD REGISTER 10 TO PRESERVE
*                                      POINTER TO WORKAREA
         ST    R13,4(R10)              STORE ADDRESS OF PREVIOUS
*                                      SAVEAREA
         ST    R10,8(,R13)             STORE ADDRESS OF CURRENT
*                                      SAVEAREA IN PREVIOUS SAVEAREA
         LR    R13,R10                 LOAD REGISTER 13 WITH ADDRESS OF
*                                      CURRENT SAVEAREA
         USING WORKAREA,R13            ESTABLISH ADDRESSABILITY TO
*                                      DYNAMIC WORKAREA
*
***********************************************************************
*                                                                     *
*        BUILD PARSE AND DAIR PARAMETER LISTS USING COMMAND           *
*           PROCESSOR PARAMETER LIST                                  *
*        INITIALIZE OUTPUT DATA CONTROL BLOCKS IN WORKAREA            *
*                                                                     *
***********************************************************************
*
         USING CPPL,R8                 ESTABLISH ADDRESSABILITY TO CPPL
         LA    R4,PPLSECT              LOAD ADDRESS OF PARSE PARAMETER
*                                      LIST
         USING PPL,R4                  ESTABLISH ADDRESSABILITY TO PPL
         LA    R6,DAPLSECT             LOAD ADDRESS OF DAIR PARAMETER
*                                      LIST
         USING DAPL,R6                 ESTABLISH ADDRESSABILITY TO DAPL
         LA    R5,IOPLSECT             LOAD ADDRESS OF PUTLINE
*                                      PARAMETER LIST
         USING IOPL,R5                 ESTABLISH ADDRESSABILITY TO IOPL
         L     R1,CPPLUPT              LOAD POINTER TO USER PROFILE
*                                      TABLE FROM CPPL
         L     R2,CPPLECT              LOAD POINTER TO ENVIRONMENT
*                                      CONTROL TABLE FROM CPPL
         SLR   R3,R3                   ZERO REGISTER 3
         ST    R3,ECB                  STORE REGISTER AS ECB FOR PPL
         LA    R3,ECB                  LOAD ADDRESS OF ECB
         STM   R1,R3,DFPLSECT          STORE UPT,ECT,ECB IN DFPL  .GTE.
         STM   R1,R3,PPLSECT           STORE ADDRESS OF UPT, ECT, AND
*                                      ECB IN PPL
         STM   R1,R3,DAPLSECT          STORE ADDRESS OF UPT, ECT, AND
*                                      ECB IN DAPL
         STM   R1,R3,IOPLSECT          STORE ADDRESS OF UPT, ECT, AND
*                                      ECB IN IOPL
         LA    R3,IOPB                 LOAD ADDRESS OF PUTLINE
*                                      PARAMETER BLOCK
         ST    R3,IOPLIOPB             STORE IOPB ADDRESS IN IOPL
         LA    R3,DFPBSECT             GET ADDRESS OF DFPB        .GTE.
         ST    R3,DFPLSECT+12          PUT IT IN THE DFPL         .GTE.
         USING  DFPB,R3                                           .GTE.
         LA     R2,DFPBDSL                                        .GTE.
         ST     R2,DFPBDSN                                        .GTE.
         LA     R2,DFPBQUA                                        .GTE.
         ST     R2,DFPBQUAL                                       .GTE.
         MVI    DFPBCODE,DFPB04                                   .GTE.
         MVC    DFPBPSCB,CPPLPSCB                                 .GTE.
         MVI    DFPBCNTL,DFPBRET                                  .GTE.
         XC     DFPBCAT(8),DFPBCAT                                .GTE.
         DROP    R3                                               .GTE.
         MVC   PPLPCL,PCLADDR          MOVE POINTER TO PARAMETER
*                                      CONTROL LIST INTO PPL
         LA    R2,PARSBACK             LOAD ADDRESS OF FULLWORD TO
*                                      CONTAIN ADDRESS OF PDE RETURNED
*                                      BY PARS
         ST    R2,PPLANS               STORE POINTER TO RETURN ADDRESS
         MVC   PPLCBUF,CPPLCBUF        MOVE POINTER TO COMMAND BUFFER
*                                      INTO PPL
         LA    R2,PPLUWA               LOAD ADDRESS OF USER WORK AREA
         ST    R2,PPLUWA               STORE ADDRESS IN PPL
         MVC   DAPLPSCB,CPPLPSCB       MOVE POINTER TO PSCB INTO DAPL
         DROP  R4,R5,R6,R8             DROP ADDRESSABILITY TO CPPL,
*                                      IOPL, DAPL, AND PPL
         MVC   OUTPUTA(OUTPUTAL),OUTPUTAC  MOVE ASA DCB CONSTANT INTO
*                                      ASA DCB IN WORKAREA
         MVC   OUTPUTM(OUTPUTML),OUTPUTMC  MOVE MACHINE DCB CONSTANT
*                                      INTO MACHINE DCB IN WORKAREA
*
***********************************************************************
*                                                                     *
*        CALLTSSR TO PARSE (ENTRY NAME IKJPARS)                       *
*        ON RETURN PARSBACK -> PDL                                    *
*        HANDLE ALL ERROR CODES RETURNED BY PARS                      *
*        IF NECESSARY CALL GENERAL FAIL SERVICE ROUTINE               *
*                                                                     *
***********************************************************************
*
         CALLTSSR  EP=IKJPARS,MF=(E,PPLSECT)
*                                      CALL PARS TO PARSE COMMAND
         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO
         BZ    GOODPARS                YES....GO TO GOOD PARS ROUTINE
         C     R15,FULL4               SEE IF RETURN CODE IS FOUR
         BE    RETURN                  YES....PARS ISSUED ERROR
*                                      MESSAGE.  GO CLEANUP AND RETURN
         C     R15,FULL20              SEE IF RETURN CODE IS TWENTY
         BE    RETURN                  YES....VALIDITY CHECKING
*                                      ROUTINE ISSUED ERROR MESSAGE.
*                                      GO CLEANUP AND RETURN
         XC    GFPARMS(GFLENGF),GFPARMS  INITIALIZE PARMLIST FOR
*                                      GENERAL FAIL TO ZEROS
         LA    R1,GFPARMS              LOAD ADDRESS OF PARMLIST
         ST    R1,GFPARMP              STORE ADDRESS AS POINTER TO
*                                      PARMLIST
         ST    R15,GFRCODE             STORE RETURN CODE IN PARMLIST
         LA    R1,GFPARSE              LOAD CALLER ID FOR PARS
         STH   R1,GFCALLID             STORE CALLER ID IN PARMLIST
         L     R1,SAVEAREA+4           LOAD ADDRESS OF PEVIOUS
*                                      SAVEAREA
         L     R1,24(R1)               LOAD POINTER TO CPPL
         ST    R1,GFCPPLP              STORE POINTER TO CPPL IN
*                                      PARMLIST
         LA    R1,ECB                  LOAD ADDRESS OF OPTIONAL ECB
         ST    R1,GFECBP               STORE POINTER TO ECB IN
*                                      PARMLIST
         SLR   R1,R1                   ZERO REGISTER 1
         ST    R1,ECB                  SET OPTIONAL ECB TO ZERO
         LINK  EP=IKJEFF19,MF=(E,GFPARMP)  LINK TO GENERAL FAIL SERVICE
*                                      ROUTINE TO HANDLE RETURN CODE
         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO
         BZ    RETURN                  YES....GO CLEANUP AND RETURN
         LR    R8,R15                  LOAD REGISTER 8 WITH RETURN
*                                      CODE
         BAL   R14,SETCODE             GO CONVERT CODE TO DECIMAL
         PUTLINE OUTPUT=(GNRLERR,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      GENERAL FAIL ERROR MESSAGE
         PUTLINE OUTPUT=(RETNCD,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DECIMAL RETURN CODE
         B     RETURN                  GO CLEANUP AND RETURN
*
***********************************************************************
*                                                                     *
*        SET UP ADDRESSABILITY TO PDL                                 *
*           AND LOAD REGISTER 6 WITH ADDRESS OF DSNAME PDE            *
*                                                                     *
***********************************************************************
*
GOODPARS DS    0H
         L     R9,PARSBACK             LOAD POINTER TO PARS ANSWER
         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY TO PDL
         MVC   PRCKW+0(1),ASAKW+1      SAVE 'ASA'                 .PRC.
         MVC   PRCKW+1(1),SNUMKW+1     SAVE 'SNUM'                .PRC.
         MVC   PRCKW+2(1),MSGKW+1      SAVE 'NOMSG'               .PRC.
         LA    R6,DSNAMES              LOAD POINTER TO DSNAME LIST
         MVI   VOLBIT,BLANK            BLANK OUT THE VOLUME WORK AREA
         MVI   BLKBIT,BLANK       BLANK OUT THE BLOCK WORK AREA.DOR
         MVC   VOLUME,VOLBIT           CONTINUE BLANKING THE VOLUME
         CLC   PBLOCK,HALF1        REQUIRED BLOCKHEADER           .DOR.
         BNE   CHKHEADB                                           .DOR.
         MVI   BLKBIT,X'FF'                                       .DOR.
CHKHEADB EQU   *                                                  .DOR.
         CLC   PVOL(2),HALF1           SEE IF VOLUME SPECIFIED
         BNE   CHKFOLD                 NO.....GO SEE IF FOLD IS DESIRED
         L     R7,SVOL                 LOAD POINTER TO VOLUME
         LH    R8,SVOL+4               LOAD LENGTH OF VOLUME
         BCTR  R8,0                    DECREMENT LENGTH FOR EXECUTE OF
*                                      MOVE
         EX    R8,MOVEVOL              MOVE VOLUME INTO WORK AREA
         OI    VOLBIT,HIGH             INDICATE VOLUME PRESENT
CHKFOLD  DS    0H
         CLC   PFOLD(2),HALF1          SEE IF FOLD SPECIFIED
         BNE   CHKHEAD                 NO.....GO LOOP THROUGH DSNAMES
         OI    VOLBIT,LOW              INDICATE FOLD PRESENT
CHKHEAD  DS    0H
         CLC   PHEAD(2),HALF1          SEE IF HEAD SPECIFIED
         BNE   NEXT                    NO.....GO LOOP THROUGH DSNAMES
         OI    VOLBIT,X'08'              INDICATE HEAD PRESENT
         DROP  R9                      DROP ADDRESSABILITY TO PDL
*
***********************************************************************
*                                                                     *
*        LOOP THROUGH DSNAME LIST RETURNED BY PARS                    *
*                                                                     *
***********************************************************************
*
NEXT     DS    0H
         LA    R1,PRINTI               LOAD POINTER TO DDNAME TO BE
*                                      FREED
         BAL   R2,FREEDD               BRANCH TO FREE ROUTINE
         LTR   R8,R8                   SEE IF RETURN CODE FROM FREE IS
*                                      ZERO
         BNZ   CLOSDCBS                NO.....GO CLOSE DCBS AND RETURN
         L     R5,0(R6)                LOAD POINTER TO DSNAME
         LH    R4,4(R6)                LOAD LENGTH OF DSNAME
         STH   R4,DFPBDSL                                         .GTE.
         TM    6(R6),X'40'             IS DSNAME IN QUOTES        .GTE.
         BO    GTENOQ                  YES, BYPASS DEFAULT        .GTE.
         BCTR  R4,0                    LENGTH MINUS 1 FOR EX      .GTE.
         MVC   DFPBNAME,BLANKS         PAD WITH BLANKS            .GTE.
         EX    R4,DFPBMVE              COPY DSNAME                .GTE.
         LA    R1,DFPLSECT                                        .GTE.
         MVC   DFPBQUA,=CL8'   '                                  .GTE.
         CALLTSSR  EP=IKJEHDEF                                    .GTE.
GTEDEF   LTR    R15,R15                                           .GTE.
GTEOK    LA     R5,DFPBNAME                                       .GTE.
         LH     R4,DFPBDSL                                        .GTE.
GTENOQ   DS    0H                                                 .GTE.
         STCM  R4,3,DSNLEN             STORE LENGTH OF DSNAME
         BCTR  R4,0                    DECREMENT LENGTH FOR EXECUTE OF
*                                      MOVE
         LA    R8,DAP08                LOAD ADDRESS OF DAPB FOR 08
         USING DAPB08,R8               ESTABLISH ADDRESSABILITY TO DAPB
         MVC   DAPB08(DAPB08L),DAPB08C MOVE CONSTANTS INTO DAPB
         LA    R1,DSNLEN               LOAD POINTER TO DSN BUFFER
         ST    R1,DA08PDSN             STORE POINTER TO DSN BUFFER IN
*                                      DAPB
         MVI   DSNBUF,BLANK            BLANK OUT THE DSNAME BUFFER
         MVC   DSNBUF+1(43),DSNBUF     FINISH BLANKING OUT THE BUFFER
         EX    R4,MOVEDSN              MOVE IN THE DSNAME
         TM    14(R6),HIGH             SEE IF MEMBER NAME IS PRESENT
         BNO   CHKPASS                 NO.....GO CHECK IF THERE IS A
*                                      PASSWORD
         L     R5,8(R6)                LOAD POINTER TO THE MEMBER NAME
         LH    R4,12(R6)               LOAD LENGTH OF MEMBER NAME
         BCTR  R4,0                    DECREMENT LENGTH FOR EXECUTE OF
*                                      MOVE
         EX    R4,MOVEMEM              MOVE IN THE MEMBER NAME
CHKPASS  DS    0H
         MVC   MEMNAME,DA08MNM         MOVE MEMBER NAME INTO HEADER 2
         TM    22(R6),HIGH             SEE IF PASSWORD IS PRESENT
         BNO   CHKVOL                  NO.....GO SEE IF VOLUME PRESENT
         L     R5,16(R6)               LOAD POINTER TO THE PASSWORD
         LH    R4,20(R6)               LOAD LENGTH OF PASSWORD
         BCTR  R4,0                    DECREMENT LENGTH FOR EXECUTE OF
*                                      MOVE
         EX    R4,MOVEPASS             MOVE IN THE PASSWORD
CHKVOL   DS    0H
         TM    VOLBIT,HIGH             SEE IF VOLUME IS PRESENT
         BNO   ALLOCDD                 NO.....GO ALLOCATE DATA SET
         MVC   DA08SER,VOLUME          MOVE IN THE VOLUME SERIAL
ALLOCDD  DS    0H
         SLR   R4,R4                   ZERO REGISTER 4
         ST    R4,ECB                  STORE REGISTER 4 AS ECB
         LA    R1,DAPLSECT             LOAD ADDRESS OF DAPL
         USING DAPL,R1                 ESTABLISH ADDRESSABILITY TO DAPL
         ST    R8,DAPLDAPB             STORE ADDRESS OF DAPB IN DAPL
         DROP  R1                      DROP ADDRESSABILITY TO DAPL
         CALLTSSR EP=IKJDAIR           CALL DAIR TO ALLOCATE DATASET
         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO
         BZ    OUTPUT                  YES....GO PRINT DATASET
         MVI   DFID+1,DFDAIR           SET DAIRFAIL ID TO INDICATE DAIR
         BAL   R2,DAIRFAIL             GO TO DAIRFAIL ROUTINE TO HAVE
*                                      ERROR MESSAGE PUT OUT
NOTPMESS DS    0H
         PUTLINE OUTPUT=(DSNNOTP,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DATASET NOT PRINTED MESSAGE
         B     EXITMSG                 GO PUT OUT DATASET AND MEMBER
*                                      NAMES
*
***********************************************************************
*                                                                     *
*        DETERMINE DATASET TYPE AND CALL PRINT ROUTINE                *
*                                                                     *
***********************************************************************
*
OUTPUT   DS    0H
         TM    DA08DSO,DSOPS           X'40' PHYSICAL SEQUENTIAL
         BO    PRINTIT                 YES....GO PRINT DATASET
         CLC   DA08MNM,BLANKS          SEE IF MEMBER NAME IS BLANK
         BNE   PRINTIT                 NO.....GO TREAT AS SEQUENTIAL
         TM    DA08DSO,DSOPO           X'02' PARTITIONED
         BO    SCROLLIT                YES....GO SCROLL DIRECTORY
         DROP  R8                      DROP ADDRESSABILITY TO DAPB
         PUTLINE OUTPUT=(NOTPSPO,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      NOT PARTITIONED OR SEQUENTIAL
*                                      MESSAGE
         B     NOTPMESS                GO PUT NOT PRINTED MESSAGE
*
***********************************************************************
*                                                                     *
*        READS RECORDS USING GET MOVE                                 *
*           AND ATTRIBUTES OF GIVEN DATASET                           *
*        WRITES THESE SAME RECORDS USING PUT MOVE                     *
*           AND THE INPUT DATASET ATTRIBUTES                          *
*                                                                     *
***********************************************************************
*
PRINTIT  DS    0H
         LA    R8,INPUT                LOAD POINTER TO INPUT DCB
         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB
         MVC   INPUT(INPUTL),INPUTC    MOVE INPUT DCB CONSTANT INTO
*                                      INPUT DCB IN WORKAREA
         MVC   OPENLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT
*                                      INTO OPEN LIST IN WORKAREA
         OPEN  ((R8),INPUT),MF=(E,OPENLST)  OPEN INPUT DCB
PRINTS   DS    0H                      BRANCH ADDRESS FOR PRINTING
*                                      MEMBERS
         TM    DCBOFLGS,DCBOFOPN       SEE IF DCB OPENED SUCCESSFULLY
         BNO   NOTPMESS                NO.....GO PUT OUT NOT PRINTED
*                                      MESSAGE
         TM    DCBRECFM,DCBRECU        SEE IF RECFM IS UNDEFINED
         BO    ERRORU                  NO.....GO PUT OUT ERROR MESSAGE
         BZ    ERRORU                  ZERO...NOT FIXED OR VARIABLE SO
*                                      GO PUT OUT ERROR MESSAGE
         CLC   DCBLRECL,HALF256        SEE IF LRECL IS GREATER THAN 256
         BH    ERRORL                  YES....GO PUT OUT RECORD LENGTH
*                                      MESSAGE
         LA    R9,LINE                 LOAD ADDRESS FOR INPUT
         SLR   R4,R4                   ZERO OUT REGISTER 4
         ST    R4,LENGTH               STORE ZERO IN LENGTH (PLUS 2
*                                      RESERVED BYTES) FIELD
         TM    DCBRECFM,DCBRECV        SEE IF RECFM IS VARIABLE
         BO    CHKCNTRL                YES....GO PUT OUT DSNAME
*                                      NO.....RECFM MUST BE FIXED
*                                      SO CONTINUE
         A     R9,FULL4                SET TO HAVE FIXED LENGTH
         LH    R4,DCBLRECL             LOAD LOGICAL RECORD LENGTH
         A     R4,FULL4                ADD 4 FOR LENGTH FIELD PREFIX
         CLI   PRCKW+1,1               'SNUM' FOR FIXED LENGTH    .PRC.
         BNE   *+10                    NO, SKIP NEXT 2 INSTR      .PRC.
         LA    R0,8                    LENGTH OF SEQUENCE NUMBERS .PRC.
         SR    R4,R0                   REDUCE LENGTH BY 8         .PRC.
         STH   R4,LENGTH               STORE IN LENGTH FIELD
CHKCNTRL DS    0H
         MVC   HEADER,HEADERC          MOVE HEADER INTO DATA AREA
         TM    DCBRECFM,DCBRECCM       SEE IF CONTROL IS MACHINE
         BNO   USEA                    NO.....GO TO USE ASA CONTROL
         LA    R5,OUTPUTM              LOAD ADDRESS OF OUTPUT DCB FOR
*                                      MACHINE CODE
         LA    R4,EJECTM               LOAD ADDRESS OF EJECT DATA
         MVI   HDRCNTL,SKIPM           MOVE INTO HEADER MACHINE CODE
*                                      FOR SPACE
         TM    48(R5),DCBOFOPN         SEE IF DCB IS ALREADY OPEN
         BO    PUTDSN                  YES....GO PUT OUT HEADERS
         LA    R3,PRINTM               LOAD POINTER TO PRINTM
         ST    R3,PTRPRINT
         LA    R14,PUTDSN              LOAD ADDRESS FROM RETURN FROM
*                                      SYSOUT ALLOCATION
         B     ALLOCOUT                GO TO ALLOCATE SYSOUT
USEA     DS    0H
         TM    DCBRECFM,DCBRECCA       SEE IF CONTROL IS ASA
         BO    GOODLENA                YES....GO SEE IF DCB IS OPEN
         CLI   PRCKW+0,1               'ASA'                      .PRC.
         BE    GOODLENA                YES, BRANCH                .PRC.
         A     R9,FULL1                SET GET AREA TO ALLOW FOR NO
*                                      CONTROL
         A     R4,FULL1                ADD ONE FOR A CONTROL BYTE
         STH   R4,LENGTH               STORE LENGTH IN PUT AREA
GOODLENA DS    0H
         LA    R5,OUTPUTA              LOAD ADDRESS OF OUTPUT DCB FOR
*                                      ASA CODE
         LA    R4,EJECTA               LOAD ADDRESS OF EJECT DATA
         TM    48(R5),DCBOFOPN         SEE IF DCB IS ALREADY OPEN
         BO    PUTDSN                  YES....GO PUT OUT HEADERS
         LA    R3,PRINTA               LOAD POINTER TO PRINTA
         ST    R3,PTRPRINT
         BAL   R14,ALLOCOUT            LOAD ADDRESS FOR RETURN AND GO
*                                      DO SYSOUT ALLOCATION
PUTDSN   DS    0H
         CLI   BLKBIT,X'FF'                                      .DOR.
         BNE   NOBLKHD                                           .DOR.
*    PARM FORMAT TO BLCKHEAD SUBROUTINE                          .DOR.
*    BYTE 0     DCB ADDRESS                                      .DOR.
*    BYTE 4-5   PARM LENGTH                                      .DOR.
*    BYTE 6-250 BLOCK HEAD STRING                                .DOR.
         LA    R1,PARMBLCK            (PRINTA),MEMBER            .DOR.
         ST    R5,0(R1)               SAVE DCB ADDRESS           .DOR.
         MVC   4(2,R1),=XL2'0011'      17 BYTES                  .DOR.
         MVC   6(9,R1),=CL9'(PRINTA),'                           .DOR.
         L     R15,PTRPRINT                                      .DOR.
         MVC   7(6,R1),0(R15)          MOVE PRINTI OR PRINTA     .DOR.
         MVC   15(8,R1),MEMNAME         PUT MEMBER NAME IN PARMLISTOR.
         L      R15,=V(BLOCKSUB)                                 .DOR.
         BALR   R14,R15                                          .DOR.
NOBLKHD  DS    0H                                                .DOR.
         PUT   (R5),(R4)               PUT OUT PAGE EJECT
         TM    VOLBIT,X'08'            TEST FOR NOHEAD            .GTE.
         BO    GTEHEAD                 NOHEAD                     .GTE.
         PUT   (R5),HEADER             PUT OUT PAGE 1 HEADER
         MVC   HEADER2,LDSNAME         MOVE LENGTH AND 'DSNAME=' INTO
*                                      INTO SECOND HEADER
         MVC   HEADER2+4(1),HDRCNTL    MOVE IN CONTROL BYTE
         CLI   MEMNAME,BLANK           SEE IF MEMBER NAME IS BLANK
         BE    NOMEM                   YES....NO NEED TO PUT IN PARENS
         MVI   OPENPRN,C'('            MOVE OPEN PAREN INTO DSNAME
         MVI   CLOSEPRN,C')'           MOVE CLOSE PAREN INTO DSNAME
         B     PUTHDR2                 GO PUT OUT HEADER 2
NOMEM    DS    0H
         MVI   OPENPRN,BLANK           MOVE BLANK INSTEAD OF OPEN AND
         MVI   CLOSEPRN,BLANK          CLOSE PARENS
PUTHDR2  DS    0H
         PUT   (R5),HEADER2            PUT OUT PAGE 1 HEADER 2
         MVC   HEADER2(4),SPACE        CHANGE HEADER 2 FOR PUT OF BLANK
*                                      LINE
         PUT   (R5),HEADER2            PUT OUT BLANK LINE
GTEHEAD  EQU   * .GTE.
         MVC   CNTLBYTE,HDRCNTL        MOVE IN SPACE AS CONTROL
*                                      CHARACTER
         TM    VOLBIT,LOW              SEE IF FOLD IS REQUESTED
         BO    FOLDIT                  YES....GO FOLD OUTPUT
         TM    DCBRECFM,DCBRECV        SEE IF RECFM IS VARIABLE
         BNO   COPYF                   NO.....GO HANDLE FIXED INPUT
         CLI   PRCKW+1,1               'SNUM'                     .PRC.
         BE    COPYS                   YES, BRANCH                .PRC.
         CLI   PRCKW+0,1               'ASA'                      .PRC.
         BE    COPYV                   YES, BRANCH                .PRC.
         TM    DCBRECFM,DCBRECCC       SEE IF THERE IS A CONTROL BYTE
         BZ    COPYVNO                 NO.....GO TO ADD CONTROL FOR
*                                      VARIABLE
COPYV    DS    0H
         GET   INPUT,(R9)              GET INPUT RECORD
         PUT   (R5),LINE               PUT OUT OUTPUT LINE
         B     COPYV                   GO GET NEXT RECORD
*
COPYVNO  DS    0H
         GET   INPUT,(R9)              GET INPUT RECORD INTO LINE+1
         SLR   R15,R15                 ZERO REGISTER 15 FOR INSERT
         ICM   R15,7,LENGTH+1          INSERT LENGTH AND RESERVED BYTE
         A     R15,FULL256             ADD 1 TO LENGTH
         STCM  R15,7,LENGTH            STORE LENGTH AND RESERVED BYTE
         MVC   CNTLBYTE,HDRCNTL        MOVE IN CONTROL SAVED IN HEADER
         PUT   (R5),LINE               PUT OUT LINE
         B     COPYVNO                 GO GET NEXT INPUT RECORD
*
COPYS    CLI   PRCKW+0,1               'ASA' RECFM V              .PRC.
         BE    COPYVS                  YES, BRANCH                .PRC.
         TM    DCBRECFM,DCBRECCC       SEE IF THERE IS A CONTROL  .PRC.
         BZ    COPYVNOS                NO.....GO TO ADD CONTROL   .PRC.
*                                                                 .PRC.
COPYVS   DS    0H                                                 .PRC.
         GET   INPUT,(R9)              GET INPUT RECORD           .PRC.
         MVC   8(4,R9),0(R9)           SHIFT PREFIX RIGHT 8       .PRC.
         LH    R15,8(,R7)              GET LENGTH                 .PRC.
         LA    R0,8                    LENGTH OF SEQUENCE NUM     .PRC.
         SLR   R15,R0                  REDUCE LENGTH BY 8         .PRC.
         STH   R15,8(,R9)              STORE NEW LENGTH           .PRC.
         PUT   (R5),LINE+8             PUT OUT OUTPUT LINE        .PRC.
         B     COPYVS                  GO GET NEXT RECORD         .PRC.
*                                                                 .PRC.
COPYVNOS DS    0H                                                 .PRC.
         GET   INPUT,(R9)              GET INPUT RECORD , LINE+1  .PRC.
         MVC   7(4,R9),0(R9)           LENGTH TO LINE+8           .PRC.
         LH    R15,7(,R9)              GET LENGTH FROM LINE+8     .PRC.
         LA    R0,7                    LENGTH OF SEQ NUM MINUS 1  .PRC.
         SLR   R15,R0                  REDUCE LENGTH              .PRC.
         STH   R15,7(,R9)              STORE NEW LENGTH           .PRC.
         MVC   CNTLBYTE+8,HDRCNTL      MOVE IN CONTROL            .PRC.
         PUT   (R5),LINE+8             PUT OUT LINE               .PRC.
         B     COPYVNOS                GO GET NEXT INPUT RECORD   .PRC.
*                                                                 .PRC.
COPYF    DS    0H
         GET   INPUT,(R9)              GET INPUT RECORD
         PUT   (R5),LINE               PUT OUT OUTPUT LINE
         B     COPYF                   GO GET NEXT RECORD
*
FOLDIT   DS    0H
         TM    DCBRECFM,DCBRECV        SEE IF RECFM IS VARIABLE
         BNO   FOLDF                   NO.....GO HANDLE FIXED INPUT
         CLI   PRCKW+1,1               'SNUM'                     .PRC.
         BE    FOLDS                   YES, BRANCH                .PRC.
         CLI   PRCKW+0,1               'ASA'                      .PRC.
         BE    FOLDV                   YES, BRANCH                .PRC.
         TM    DCBRECFM,DCBRECCC       SEE IF THERE IS A CONTROL BYTE
         BZ    FOLDVNO                 NO.....GO TO ADD CONTROL FOR
*                                      VARIABLE
FOLDV    DS    0H
         GET   INPUT,(R9)              GET INPUT RECORD
         LH    R15,LENGTH              LOAD LENGTH OF LINE
         SH    R15,HALF6               DECREMENT FOR EXECUTE
         EX    R15,FOLDLINE            EXECUTE FOLD OF LINE
         PUT   (R5),LINE               PUT OUT OUTPUT LINE
         B     FOLDV                   GO GET NEXT RECORD
*
FOLDVNO  DS    0H
         GET   INPUT,(R9)              GET INPUT RECORD INTO LINE+1
         SLR   R15,R15                 ZERO REGISTER 15 FOR INSERT
         ICM   R15,7,LENGTH+1          INSERT LENGTH AND RESERVED BYTE
         A     R15,FULL256             ADD 1 TO LENGTH
         STCM  R15,7,LENGTH            STORE LENGTH AND RESERVED BYTE
         MVC   CNTLBYTE,HDRCNTL        MOVE IN CONTROL SAVED IN HEADER
         LH    R15,LENGTH              LOAD LENGTH OF LINE
         SH    R15,HALF6               DECREMENT FOR EXECUTE
         EX    R15,FOLDLINE            EXECUTE FOLD OF LINE
         PUT   (R5),LINE               PUT OUT LINE
         B     FOLDVNO                 GO GET NEXT INPUT RECORD
*
FOLDS    CLI   PRCKW+0,1               'ASA' RECFM V              .PRC.
         BE    FOLDVS                  YES, BRANCH                .PRC.
         TM    DCBRECFM,DCBRECCC       SEE IF THERE IS A CONTROL  .PRC.
         BZ    FOLDVNOS                NO.....GO TO ADD CONTROL   .PRC.
*                                                                 .PRC.
FOLDVS   DS    0H                                                 .PRC.
         GET   INPUT,(R9)              GET INPUT RECORD           .PRC.
         MVC   8(4,R9),0(R9)           SHIFT PREFIX RIGHT 8       .PRC.
         LH    R15,8(,R7)              GET LENGTH                 .PRC.
         LA    R0,8                    LENGTH OF SEQUENCE NUM     .PRC.
         SLR   R15,R0                  REDUCE LENGTH BY 8         .PRC.
         STH   R15,8(,R9)              STORE NEW LENGTH           .PRC.
         SH    R15,HALF6               DECREMENT FOR EXECUTE      .PRC.
         EX    R15,FOLDLINS            EXECUTE FOLD OF LINE       .PRC.
         PUT   (R5),LINE+8             PUT OUT OUTPUT LINE        .PRC.
         B     FOLDVS                  GO GET NEXT RECORD         .PRC.
*                                                                 .PRC.
FOLDVNOS DS    0H                                                 .PRC.
         GET   INPUT,(R9)              GET INPUT RECORD , LINE+1  .PRC.
         MVC   7(4,R9),0(R9)           LENGTH TO LINE+8           .PRC.
         LH    R15,7(,R9)              GET LENGTH FROM LINE+8     .PRC.
         LA    R0,7                    LENGTH OF SEQ NUM MINUS 1  .PRC.
         SLR   R15,R0                  REDUCE LENGTH              .PRC.
         STH   R15,7(,R9)              STORE NEW LENGTH           .PRC.
         SH    R15,HALF6               DECREMENT FOR EXECUTE      .PRC.
         EX    R15,FOLDLINS            EXECUTE FOLD OF LINE       .PRC.
         MVC   CNTLBYTE+8,HDRCNTL      MOVE IN CONTROL            .PRC.
         PUT   (R5),LINE+8             PUT OUT LINE               .PRC.
         B     FOLDVNOS                GO GET NEXT INPUT RECORD   .PRC.
*                                                                 .PRC.
FOLDF    DS    0H
         LH    R4,LENGTH               LOAD LENGTH INTO REGISTER 4
         SH    R4,HALF6                SUBTRACT TO SET UP FOR EXECUTE
FOLDFLP  DS    0H
         GET   INPUT,(R9)              GET INPUT RECORD
         EX    R4,FOLDLINE             FOLD DATA
         PUT   (R5),LINE               PUT OUT OUTPUT LINE
         B     FOLDFLP                 GO GET NEXT RECORD
FOLDLINE OC    DATA(0),BLANKS          OC INSTRUCTION TO BE EXECUTED
FOLDLINS OC    DATA+8(0),BLANKS        OC INSTRUCTION TO BE EX    .PRC.
*
EXIT     DS    0H
         TM    DCBOFLGS,DCBOFOPN       SEE IF INPUT DCB IS OPEN
         BNO   EXITMSG                 NO....GO PUT OUT DATASET AND
*                                      MEMBER NAMES
         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT
*                                      INTO CLOSE LIST IN WORKAREA
         CLOSE ((R8),),MF=(E,CLOSLST)  CLOSE INPUT DCB
EXITMSG  DS    0H
         CLI   PRCKW+2,1               'NOMSG'                    .PRC.
         BE    CONTINUE                BYPASS MESSAGES IF 'NOMSG' .PRC.
         PUTLINE OUTPUT=(DSNMSG,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DATA SET NAME MESSAGE
*        LH    R4,4(,R6)               LOAD LENGTH OF DSNAME     *.GTE.
         LH    R4,DFPBDSL              LOAD LENGTH OF DSNAME      .GTE.
         A     R4,FULL4                INCREMENT LENGTH FOR PUTLINE
         SLL   R4,16                   SHIFT LENGTH TO HIGH ORDER BYTES
         STCM  R4,15,DSNLENP           STORE LENGTH OF PUTLINE
         PUTLINE OUTPUT=(DSNLENP,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DATA SET NAME MESSAGE
         TM    14(R6),HIGH             SEE IF MEMBER NAME IS PRESENT
         BNO   CONTINUE                NO.....GO CHECK FOR ANOTHER
*                                      DATASET NAME
         PUTLINE OUTPUT=(MEMMSG,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DATA SET NAME MESSAGE
         LH    R4,12(R6)               LOAD LENGTH OF MEMBER NAME
         A     R4,FULL4                INCREMENT LENGTH FOR PUTLINE
         SLL   R4,16                   SHIFT LENGTH TO HIGH ORDER BYTES
         STCM  R4,15,MEMNAMEL          STORE LENGTH OF PUTLINE
         PUTLINE OUTPUT=(MEMNAMEL,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      MEMBER NAME
         B     CONTINUE                GO CONTINUE WITH NEXT DATASET
         DROP  R8                      DROP ADDRESSABILITY TO INPUT DCB
ERRORL   DS    0H
         PUTLINE OUTPUT=(DSNISL,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DATASET NOT PRINTED DUE TO
*                                      RECORD LENGTH TOO LONG MESSAGE
         B     EXIT                    GO SEE IF INPUT DCB IS OPEN
ERRORU   DS    0H
         PUTLINE OUTPUT=(DSNISU,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DATASET NOT PRINTED DUE TO
*                                      UNDEFINED RECORD FORMAT MESSAGE
         B     EXIT                    GO SEE IF INPUT DCB IS OPEN
ERRI     DS    0H
         PUTLINE OUTPUT=(SYNADI,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DATASET NOT PRINTED DUE TO SYNAD
*                                      ERROR ON INPUT DATASET MESSAGE
         B     EXIT                    GO SEE IF INPUT DCB IS OPEN
ERRO     DS    0H
         PUTLINE OUTPUT=(SYNADO,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DATASET NOT PRINTED DUE TO
*                                      UNDEFINED RECORD FORMAT MESSAGE
         B     CLOSDCBS                GO CLOSE OPEN DCBS AND RETURN
*                                                                     *
***********************************************************************
*                                                                     *
*        READ THE DIRECTORY OF A PDS                                  *
*           THEN EITHER LIST MEMBER NAMES,                            *
*           PRINT MEMBERS,                                            *
*           OR LIST MEMBER NAMES AND PRINT MEMBERS                    *
*                                                                     *
***********************************************************************
*
SCROLLIT DS    0H
         ST    R6,SAVER6               SAVE REGISTER 6
         L     R9,PARSBACK             LOAD ADDRESS PARS ANSWER
         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY TO PDL
         CLC   PLIST,HALF2             SEE IF NOLIST SPECIFIED
         BL    CONTSCR                 LOW....CONTINUE WITH SCROLL
         CLC   PPRINT,HALF2            SEE IF NOPRINT SPECIFIED
         BE    CONTINUE                YES....SKIP SCROLL
         DROP  R9                      DROP ADDRESSABILITY TO PDL
CONTSCR  DS    0H
         LA    R8,DIRECT               LOAD POINTER TO DIRECTORY DCB
         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB
         MVC   DIRECT(DIRECTL),DIRECTC MOVE DIRECTORY DCB CONSTANT INTO
*                                      DIRECTORY DCB IN WORKAREA
         MVC   OPENLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT
*                                      INTO OPEN LIST IN WORKAREA
         OPEN  ((R8),INPUT),MF=(E,OPENLST)  OPEN DIRECTORY DCB
         TM    DCBOFLGS,DCBOFOPN       SEE IF DCB OPENED SUCCESSFULLY
         BNO   NOTPMESS                NO.....GO PUT OUT NOT PRINTED
*                                      MESSAGE
         DROP  R8                      DROP ADDRESSABILITY TO DCB
*                                                                     *
***********************************************************************
*                                                                     *
*        GETMAIN MEMBER TABLE FOR STORAGE OF DIRECTORY NAMES, ETC.    *
*           INITIALIZE TABLE                                          *
*                                                                     *
***********************************************************************
*
         L     R0,MEMDATL              LOAD LENGTH OF GETMAIN FOR
*                                      MEMBER TABLE
         LR    R2,R0                   SAVE IN REGISTER 2
         GETMAIN R,LV=(0)              GETMAIN MEMBER TABLE STORAGE
         ST    R1,MEMTABLE             SAVE ADDRESS OF MEMBER TABLE
         ST    R1,PRESENT              ALSO SAVE ADDRESS AS TABLE
*                                      IN USE
         LA    R3,0(R2,R1)             LOAD ADDRESS OF END OF TABLE
         ST    R3,ENDTABLE             STORE ADDRESS OF TABLE END
         SLR   R4,R4                   ZERO REGISTER 4
         ST    R4,0(R1)                STORE AS FIRST WORD OF MEMBER
*                                      TABLE
         LA    R4,8(R1)                LOAD REGISTER 4 AS POINTER TO
*                                      THE FIRST ENTRY
         USING MEMDSECT,R4             ESTABLISH ADDRESSABILITY TO
*                                      MEMBER TABLE DSECT
         SLR   R5,R5                   INITIALIZE MEMBER COUNT TO ZERO
*                                                                     *
***********************************************************************
*                                                                     *
*        READ DIRECTORY AND BUILD MEMBER TABLE                        *
*                                                                     *
***********************************************************************
*
GETDIR   EQU   *
         GET   (R8),DATA               GET A DIRECTORY BLOCK
         CLC   DATA,HALF12             SEE IF BLOCK IS UNUSED
         BL    FREEBLK                 YES....GO HANDLE DIRECTORY END
         LA    R9,DATA+2               LOAD POINTER TO FIRST DIRECTORY
*                                      ENTRY
         SLR   R7,R7                   ZERO REGISTER 7 FOR INSERT
         ICM   R7,3,DATA               INSERT LENGTH USED OF THIS BLOCK
         LA    R7,DATA-1(R7)           LOAD LAST USED BYTE OF BLOCK
UNBLOCK  DS    0H
         MVC   MEMNTTR,0(R9)           PUT NAME AND TTR IN TABLE
         MVC   CFIELD,11(R9)           PUT C FIELD IN TABLE
         CLI   MEMBER,HEXFF            SEE IF LAST MEMBER
         BE    FREEBLK                 YES....GO HANDLE DIRECTORY END
         IC    R6,CFIELD               INSERT CFIELD INTO REGISTER 6
         SLL   R6,27                   SHIFT OUT HIGH ORDER BITS
         SRL   R6,26                   SHIFT RIGHT TO GET LENGTH OF
*                                      USER DATA
         LA    R6,12(R6)               ADD STANDARD ENTRY LENGTH
         LA    R4,MEMSECTN             LOAD PINTER TO NEXT TABLE ENTRY
         LA    R5,1(R5)                INCREMENT NUMBER OF MEMBERS IN
*                                      TABLE
         C     R4,ENDTABLE             SEE IF END OF TABLE
         BL    NEXTNTRY                LOW.....GO PROCESS NEXT ENTRY
         LR    R0,R2                   LOAD LENGTH OF TABLE FOR GETMAIN
         GETMAIN R,LV=(0)              GET NEXT TABLE
         L     R14,PRESENT             LOAD REGISTER 14 WITH ADDRESS OF
*                                      LAST TABLE
         ST    R1,0(R14)               CHAIN MEMBER TABLES TOGETHER
         ST    R1,PRESENT              ALSO SAVE ADDRESS AS TABLE
*                                      IN USE
         LA    R3,0(R2,R1)             LOAD ADDRESS OF TABLE END
         ST    R3,ENDTABLE             STORE ADDRESS OF TABLE END
         SLR   R4,R4                   ZERO REGISTER 4
         ST    R4,0(R1)                STORE AS FIRST WORD OF MEMBER
*                                      TABLE
         LA    R4,8(R1)                LOAD REGISTER 4 AS POINTER TO
*                                      THE FIRST ENTRY
         STH   R5,4(R14)               STORE MEMBER COUNT IN OLD TABLE
         SLR   R5,R5                   INITIALIZE MEMBER COUNT TO ZERO
NEXTNTRY DS    0H
         BXLE  R9,R6,UNBLOCK           INCREMENT REGISTER 9 WITH
*                                      REGISTER 6 AND BRANCH
*                                      LESS THAN OR EQUAL TO
*                                      REGISTER 7 TO UNBLOCK
         B     GETDIR                  NO.....GO GET NEXT DIRECTORY
*                                      BLOCK
         DROP  R4                      DROP ADDRESSABILITY TO TABLE
*
***********************************************************************
*                                                                     *
*        LIST MEMBERS IF:                                             *
*           LIST SPECIFIED OR                                         *
*           BOTH PRINT AND NOLIST WERE NOT SPECIFIED                  *
*                                                                     *
***********************************************************************
*
FREEBLK  DS    0H
         MVC   OPENLST,OPENCLOS        MOVE CONSTANT INTO CLOSE LIST
         CLOSE ((R8),),MF=(E,OPENLST)  CLOSE DIRECTORY DCB
         L     R2,PRESENT              LOAD POINTER TO LAST TABLE
         STH   R5,4(R2)                STORE COUNT OF MEMBERS
         L     R4,MEMTABLE             LOAD POINTER TO FIRST TABLE
         CLC   4(2,R4),HALF0           SEE IF THERE WERE ANY MEMBERS
         BE    ENDMEMB                 ZERO...GO FREE MEMBER TABLE
         LA    R8,INPUT                LOAD POINTER TO INPUT DCB
         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB
         MVC   INPUT(INPUTL),INPUTC    MOVE INPUT DCB CONSTANT INTO
*                                      INPUT DCB IN WORKAREA
         MVC   OPENLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT
*                                      INTO OPEN LIST IN WORKAREA
         LA    R1,XLIST                LOAD ADDRESS OF EXIT LIST
         ST    R1,DCBEXLST             STORE ADDRESS OF EXIT LIST IN
*                                      DCB
         LA    R1,SEXIT                LOAD ADDRESS OF EODAD EXIT
         ST    R1,DCBEODAD             STORE ADDRESS EODAD IN DCB
         LA    R2,JFCBAREA             LOAD ADDRESS OF JFCBAREA
         ST    R2,XLIST                STORE ADDRESS IN EXIT LIST
         MVI   XLIST,X'87'             SET END OF LIST AND JFCB BYTE
         MVC   RDJL,OPENCLOS           MOVE OPEN(CLOSE) LIST CONSTANT
*                                      INTO READJFCB LIST IN
*                                      WORKAREA
         RDJFCB (INPUT,),MF=(E,RDJL)   READ JFCB INTO JFCBAREA
         MVC   JFCBELNM,8(R4)          MOVE MEMBER NAME INTO JFCB
         OI    JFCBIND1,JFCPDS         SET JFCB TO INDICATE PDS MEMBER
         MVI   JFCDSRG1,HEX00          SET JFCB TO REMOVE OTHER DSORG
*                                      INDICATORS
         OPEN  ((R8),INPUT),TYPE=J,MF=(E,OPENLST)  OPEN INPUT DCB
         L     R9,PARSBACK             LOAD ADDRESS PARS ANSWER
         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY TO PDL
         CLC   PLIST,HALF2             SEE IF NOLIST SPECIFIED
         BE    NOLIST                  YES....SKIP LISTING
         CLC   PLIST,HALF1             SEE IF LIST SPECIFIED
         BE    LISTIT                  YES....GO LISTIT
         CLC   PPRINT,HALF1            SEE IF PRINT SPECIFIED
         BE    NOLIST                  YES....SKIP LISTING
         DROP  R9                      DROP ADDRESSABILITY TO PDL
LISTIT   DS    0H
         MVC   HEADER,HEADERM          MOVE HEADER INTO DATA AREA
         TM    DCBRECFM,DCBRECCM       SEE IF CONTROL IS MACHINE
         DROP  R8                      DROP ADDRESSABILITY TO DCB
         BNO   SUSEA                   NO.....GO TO USE ASA CONTROL
         LA    R5,OUTPUTM              LOAD ADDRESS OF OUTPUT DCB FOR
*                                      MACHINE CODE
         LA    R4,EJECTM               LOAD ADDRESS OF EJECT DATA
         MVI   HDRCNTL,SKIPM           MOVE INTO HEADER MACHINE CODE
*                                      FOR SPACE
         TM    48(R5),DCBOFOPN         SEE IF DCB IS ALREADY OPEN
         BO    SPUTDSN                 YES....GO PUT OUT HEADERS
         LA    R3,PRINTM               LOAD POINTER TO PRINTM
         ST    R3,PTRPRINT
         LA    R14,SPUTDSN             LOAD ADDRESS FOR RETURN FROM
*                                      SYSOUT ALLOCATION
         B     ALLOCOUT                GO TO ALLOCATE SYSOUT
SUSEA    DS    0H
         LA    R5,OUTPUTA              LOAD ADDRESS OF OUTPUT DCB FOR
*                                      ASA CODE
         LA    R4,EJECTA               LOAD ADDRESS OF EJECT DATA
         TM    48(R5),DCBOFOPN         SEE IF DCB IS ALREADY OPEN
         BO    SPUTDSN                 YES....GO PUT OUT HEADERS
         LA    R3,PRINTA               LOAD POINTER TO PRINTA
         ST    R3,PTRPRINT
         BAL   R14,ALLOCOUT            LOAD ADDRESS FOR RETURN AND GO
*                                      DO SYSOUT ALLOCATION
SPUTDSN  DS    0H
         PUT   (R5),(R4)               PUT OUT PAGE EJECT
         PUT   (R5),HEADER             PUT OUT PAGE 1 HEADER
         MVC   HEADER2,LDSNAME         MOVE LENGTH AND 'DSNAME=' INTO
*                                      INTO SECOND HEADER
         MVC   HEADER2+4(1),HDRCNTL    MOVE IN CONTROL BYTE
         MVI   OPENPRN,BLANK           BLANK OUT MEMBER NAME
         MVC   MEMNAME(9),OPENPRN      FINISH BLANKING OUT MEMBER NAME
         PUT   (R5),HEADER2            PUT OUT PAGE 1 HEADER 2
         L     R2,MEMTABLE             LOAD ADDRESS OF FIRST TABLE
         MVC   LENGTH,HALF85           SET LENGTH TO 85 BYTES
         MVC   LENGTH+2,HALF0          ZERO RESERVED BYTES
         MVC   CNTLBYTE,HDRCNTL        MOVE IN HEADER CONTROL BYTE
*
***********************************************************************
*                                                                     *
*        LIST MEMBER NAMES                                            *
*                                                                     *
***********************************************************************
*
SCROLLER DS    0H
         LA    R10,50                  LOAD LINE COUNT
         ST    R2,PRESENT              SAVE ADDRESS OF CURRENT TABLE
         LH    R7,4(R2)                LOAD NUMBER OF MEMBERS IN TABLE
         LTR   R7,R7                   SEE IF THERE ARE ENTRIES
         BZ    NOLIST                  NO.....GO PRINT MEMBERS
         LA    R2,8(R2)                LOAD ADDRESS OF FIRST MEMBER
         USING MEMDSECT,R2             ESTABLISH ADDRESSABILITY TO
*                                      MEMBER TABLE ENTRY
LOOP1    DS    0H
         LA    R6,DATA                 LOAD ADDRESS OF OUTPUT BUFFER
         MVI   DATA,BLANK              BLANK OUT OUTPUT BUFFER
         MVC   DATA+1(79),DATA         FINISH BLANKING BUFFER
         TM    CFIELD,HIGH             SEE IF THIS IS AN ALIAS
         BZ    NOTALIAS                NO.....CONTINUE WITH MAIN NAME
         BAL   R14,LOOKLOOP            GO LOOK FOR MAIN NAME
NOTALIAS DS    0H
         MVC   2(8,R6),MEMBER          PUT MEMBER NAME IN OUTPUT BUFFER
         ST    R2,SAVER2               SAVE REGISTER 2
         LA    R3,2                    LOAD NUMBER OF COLUMNS LEFT
         LA    R8,1                    LOAD ENTRY NUMBER
LOOP2    LA    R8,50(R8)               LOAD POINTER TO NEXT COLUMN
*                                      ENTRY
         CR    R8,R7                   SEE IF VALID ENTRY
         BH    END2                    NO.....GO PRINT LINE
         LA    R2,600(R2)              LOAD POINTER TO MEMBER NAME
         LA    R6,30(R6)               LOAD POINTER TO NEXT OUTPUT
*                                      BUFFER LOCATION
         TM    CFIELD,HIGH             SEE IF THIS IS AN ALIAS
         BZ    NOTAL2                  NO.....CONTINUE WITH MAIN NAME
         BAL   R14,LOOKLOOP            GO LOOK FOR MAIN NAME
NOTAL2   DS    0H
         MVC   2(8,R6),MEMBER          PUT MEMBER NAME IN OUTPUT BUFFER
         BCT   R3,LOOP2                DECREMENT COLUMN COUNT
END2     DS    0H
         PUT   (R5),LINE               PUT OUT OUTPUT LINE
         L     R2,SAVER2               RELOAD REGISTER 2
         LA    R2,MEMSECTN             LOAD POINTER TO NEXT MEMBER NAME
         BCT   R10,MOREROW             DECREMENT ROW COUNT
         PUT   (R5),(R4)               PUT OUT PAGE EJECT WHEN ZERO
         B     LOOP3                   RESET COUNTERS
MOREROW  DS    0H
         BCT   R7,LOOP1                DECREMENT MEMBER COUNT FOR
*                                      CURRENT TABLE
LOOP3    L     R2,PRESENT              LOAD POINTER TO CURRENT TABLE
         L     R2,0(R2)                LOAD POINTER TO NEXT TABLE
         LTR   R2,R2                   SEE IF IT WAS THE LAST TABLE
         BNZ   SCROLLER                NO.....GO LIST OUT NEXT TABLE
*
***********************************************************************
*                                                                     *
*        PRINT MEMBERS IF:                                            *
*           PRINT SPECIFIED OR                                        *
*           BOTH LIST AND NOPRINT WERE NOT SPECIFIED                  *
*                                                                     *
***********************************************************************
*
NOLIST   DS    0H
         L     R9,PARSBACK             LOAD ADDRESS PARS ANSWER
         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY TO PDL
         CLC   PPRINT,HALF2            SEE IF NOPRINT SPECIFIED
         BE    ENDMEMB                 YES....GO SKIP PRINT
         CLC   PPRINT,HALF1            SEE IF PRINT SPECIFIED
         BE    CONTPRT                 YES....GO PRINT MEMBERS
         CLC   PLIST,HALF1             SEE IF LIST SPECIFIED
         BE    ENDMEMB                 YES....GO SKIP PRINT
         DROP  R9                      DROP ADDRESSABILITY TO PDL
CONTPRT  DS    0H
         L     R6,SAVER6               RESTORE REGISTER 6
         LA    R8,INPUT                LOAD ADDRESS OF INPUT DCB
         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB
         TM    DCBRECFM,DCBRECU        SEE IF RECFM IS UNDEFINED
         BO    ERRORU                  NO.....GO PUT OUT ERROR MESSAGE
         BZ    ERRORU                  ZERO...NOT FIXED OR VARIABLE SO
*                                      GO PUT OUT ERROR MESSAGE
         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT
*                                      INTO CLOSE LIST IN WORKAREA
         CLOSE ((R8),),MF=(E,CLOSLST)  CLOSE INPUT DCB
         DROP  R8                      DROP ADDRESSABILITY TO INPUT DCB
         CLI   PRCKW+2,1               'NOMSG'                    .PRC.
         BE    PRCNOM                  BYPASS MESSAGE IF 'NOMSG'  .PRC.
         PUTLINE OUTPUT=(PRTMSG,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DATASET PRINT MESSAGE
         LH    R4,4(R6)                LOAD LENGTH OF DSNAME
         A     R4,FULL4                INCREMENT LENGTH FOR PUTLINE
         SLL   R4,16                   SHIFT LENGTH TO HIGH ORDER BYTES
         STCM  R4,15,DSNLENP           STORE LENGTH OF PUTLINE
         PUTLINE OUTPUT=(DSNLENP,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DATA SET NAME MESSAGE
PRCNOM   EQU   *                                                  .PRC.
         L     R2,MEMTABLE             LOAD ADDRESS OF FIRST MEMBER
*                                      TABLE
         LH    R3,4(R2)                LOAD NUMBER OF MEMBERS IN TABLE
         LTR   R3,R3                   SEE IF THERE ARE ANY MEMBERS
         BZ    ENDMEMB                 NO.....GO TO END OF SCROLLER
         ST    R2,PRESENT              SAVE ADDRESS OF CURRENT TABLE
         LA    R2,8(R2)                LOAD POINTER TO MEMBER NAME
NEXTMEMB DS    0H
         TM    CFIELD,HIGH             SEE IF THIS IS AN ALIAS ENTRY
         BO    AGAIN                   YES....DO NOT PRINT IT
PRINTMEM DS    0H
         MVC   MEMNAME,MEMBER          MOVE MEMBER NAME INTO HEADER
         MVC   JFCBELNM,MEMBER         MOVE MEMBER NAME INTO JFCBAREA
         MVC   OPENLST,OPENCLOS        MOVE CONSTANT INTO OPEN LIST
         OPEN  ((R8),INPUT),TYPE=J,MF=(E,OPENLST)
*                                      OPEN INPUT DCB
         STM   R2,R3,SAVER2            SAVE REGISTERS 2 AND 3
         B     PRINTS                  GO PRINT MEMBER
SEXIT    DS    0H
         LM    R2,R3,SAVER2            RESTORE REGISTERS 2 AND 3
         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT
*                                      INTO CLOSE LIST IN WORKAREA
         CLOSE ((R8),),MF=(E,CLOSLST)  CLOSE INPUT DCB
AGAIN    DS    0H
         LA    R2,MEMSECTN             LOAD ADDRESS OF NEXT MEMBER
         BCT   R3,NEXTMEMB             BRANCH TO HANDLE NEXT MEMBER
         L     R14,PRESENT             ZERO...LOAD CURRENT TABLE
*                                      ADDRESS
         L     R2,0(R14)               LOAD ADDRESS OF NEXT TABLE
         LTR   R2,R2                   SEE IF ZERO, LAST TABLE
         BZ    ENDMEMB                 NO.....GO HANDLE END OF MEMBERS
         ST    R2,PRESENT              SAVE ADDRESS OF CURRENT TABLE
         LH    R3,4(R2)                LOAD NUMBER OF MEMBERS IN NEXT
*                                      TABLE
         LTR   R3,R3                   SEE IF ANY MEMBERS IN TABLE
         BZ    ENDMEMB                 NO.....GO HANDLE END OF MEMBERS
         LA    R2,8(R2)                LOAD POINTER TO MEMBER NAME
         B     NEXTMEMB                GO GET NEXT MEMBER
ENDMEMB  DS    0H
         L     R2,MEMTABLE             LOAD POINTER TO FIRST TABLE
FREETABS DS    0H
         LR    R1,R2                   LOAD AREA TO BE FREED
         L     R2,0(R2)                LOAD POINTER TO NEXT TABLE
         L     R0,MEMDATL              LOAD SIZE OF AREA TO BE FREED
         FREEMAIN R,LV=(0),A=(1)       FREE STORAGE GETMAINED FOR TABLE
         LTR   R2,R2                   SEE IF THERE WAS ANOTHER TABLE
         BNZ   FREETABS                YES....GO FREE NEXT TABLE
         L     R6,SAVER6               RESTORE REGISTER 6
         LA    R8,INPUT                LOAD POINTER TO INPUT DCB
         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB
         TM    DCBOFLGS,DCBOFOPN       SEE IF INPUT DCB IS STILL OPEN
         BNO   EXITMSG                 NO.....GO HANDLE NEXT DATASET
         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT
*                                      INTO CLOSE LIST IN WORKAREA
         CLOSE ((R8),),MF=(E,CLOSLST)  CLOSE INPUT DCB
         DROP  R8                      DROP ADDRESSABILITY TO DCB
         B     EXITMSG                 GO HANDLE NEXT DATASET
*                                                                     *
***********************************************************************
*                                                                     *
*        PUT OUT SYNAD ERROR MESSAGE,                                 *
*           GO FREE MEMBER TABLES, AND                                *
*           CONTINUE WITH NEXT DATASET                                *
*                                                                     *
***********************************************************************
*
SERRI    DS    0H
         PUTLINE OUTPUT=(SYNADI,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DATASET NOT PRINTED DUE TO SYNAD
*                                      ERROR ON INPUT DATASET MESSAGE
         B     ENDMEMB                 GO FREE MEMBER TABLES
*                                                                     *
***********************************************************************
*                                                                     *
*        SEARCH FOR MAIN NAME,                                        *
*           SAME TTR AND NOT AN ALIAS                                 *
*                                                                     *
***********************************************************************
*
LOOKLOOP DS    0H
         STM   R3,R4,SAVER3            SAVE REGISTERS 3 AND 4
         L     R3,MEMTABLE             LOAD ADDRESS OF FIRST TABLE
         USING MEMDSECT,R3             ESTABLISH ADDRESSABILITY TO
*                                      MEMBER ENTRY
LOOP4    DS    0H
         ST    R3,CURRENT              SAVE ADDRESS OF PRESENT TABLE
         LH    R4,4(R3)                LOAD NUMBER OF ELEMENTS IN TABLE
         LTR   R4,R4                   SEE IF THERE ARE ZERO ELEMENTS
         BZ    NOMAIN                  YES....GO HANDLE MAIN NOT FOUND
         LA    R3,8(R3)                LOAD ADDRESS OF FIRST MEMBER
LOOP5    DS    0H
         CLC   MEMTTR,8(R2)            SEE IF TTRS ARE THE SAME
         BE    SAMETTR                 YES....GO SEE IF IT IS AN ALIAS
ENDLP5   DS    0H
         LA    R3,MEMSECTN             LOAD ADDRESS OF NEXT MEMBER
         BCT   R4,LOOP5                DECREMENT MEMBER COUNT
         L     R3,CURRENT              LOAD ADDRESS OF THIS TABLE
         L     R3,0(R3)                LOAD ADDRESS OF NEXT TABLE
         LTR   R3,R3                   SEE IF IT WAS THE LAST TABLE
         BNZ   LOOP4                   NO.....GO CHECK NEXT TABLE
         B     NOMAIN                  GO HANDLE MAIN NOT FOUND
SAMETTR  DS    0H
         TM    CFIELD,HIGH             SEE IF THIS IS ALSO AN ALIAS
         BO    ENDLP5                  YES....GO LOOK FOR ANOTHER TTR
         MVC   11(8,R6),MEMBER         MOVE MEMBER NAME INTO OUTPUT
         B     ENDLOOK                 GO TO RETURN TO CALLER
NOMAIN   DS    0H
         MVC   11(8,R6),ALIAS          INDICATE THIS IS AN ALIAS
ENDLOOK  DS    0H
         LM    R3,R4,SAVER3            RESTORE REGISTERS 3 AND 4
         BR    R14                     RETURN TO CALLER
         DROP  R3                      DROP ADDRESSABILITY TO TABLE
*
CONTINUE DS    0H
         L     R6,24(R6)               LOAD POINTER TO NEXT DSNAME ON
*                                      CHAIN
         C     R6,ENDCHAIN             SEE IF END OF CHAIN IS REACHED
         BNE   NEXT                    NO.....GO DO NEXT DATASET NAME
CLOSDCBS DS    0H
         TM    INPUT+48,DCBOFOPN       SEE IF INPUT DCB IS STILL OPEN
         BNO   CHKOUTA                 NO.....GO CHECK DCB FOR ASA CODE
         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT
*                                      INTO CLOSE LIST WORKAREA
         LA    R5,INPUT                LOAD POINTER TO INPUT DCB
         CLOSE ((R5),),MF=(E,CLOSLST)  CLOSE INPUT DCB
CHKOUTA  DS    0H
         LA    R1,PRINTI               FREE INPUT DATASET         .GTE.
         BAL   R2,FREEDD               FREE INPUT DATASET         .GTE.
         TM    OUTPUTA+48,DCBOFOPN     SEE IF OUTPUT DCB FOR ASA WAS
*                                      OPENED
         BNO   CHKOUTM                 NO.....GO CHECK DCB FOR MACHINE
*                                      CODE
         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT
*                                      INTO CLOSE LIST WORKAREA
         LA    R5,OUTPUTA              LOAD POINTER TO ASA CODE DCB
         CLOSE ((R5),),MF=(E,CLOSLST)  CLOSE ASA CODE OUTPUT DCB
         LA    R1,PRINTA               LOAD ADDRESS OF PRINT DDNAME
         BAL   R2,FREEDD               GO FREE ASA CODE OUTPUT DDNAME
CHKOUTM  DS    0H
         TM    OUTPUTM+48,DCBOFOPN     SEE IF OUTPUT DCB FOR MACHINE
*                                      CODE WAS OPENED
         BNO   RETURN                  NO.....GO FREE GETMAINED AREAS
*                                      AND RETURN
         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT
*                                      INTO CLOSE LIST WORKAREA
         LA    R5,OUTPUTM              LOAD POINTER TO MACHINE CODE DCB
         CLOSE ((R5),),MF=(E,CLOSLST)  CLOSE MACHINE CODE OUTPUT DCB
         LA    R1,PRINTM               LOAD ADDRESS OF PRINT DDNAME
         BAL   R2,FREEDD               GO FREE MACHINE CODE OUTPUT
*                                      DDNAME
*
***********************************************************************
*                                                                     *
*        CLEANUP AREAS GETMAINED BY PARS,                             *
*           SET RETURN CODE, RESTORE REGISTERS AND                    *
*           RETURN TO CALLER                                          *
*                                                                     *
***********************************************************************
*
RETURN   DS    0H
         IKJRLSA PARSBACK              RELEASE AREAS GETMAINED BY PARS
         LR    R1,R13                  LOAD ADDRESS OF GETMAINED AREA
         L     R13,4(,R13)             RELOAD ADDRESS OF PREVIOUS SAVE
*                                      AREA
         LA    R0,LDYNAMIC             LOAD LENGTH OF GETMAINED AREA
         FREEMAIN R,LV=(0),A=(1)       FREE GETMINED AREA
         SLR   R15,R15                 ZERO REGISTER 15.  RETURN CODE
*                                      CODE WILL ALWAYS BE ZERO
         L     R14,12(,R13)            LOAD REGISTER 14 WITH RETURN
*                                      ADDRESS
         LM    R0,R12,20(R13)          RESTORE REGISTERS
         BR    R14                     RETURN
*
***********************************************************************
*                                                                     *
*        ROUTINE TO CONVERT NONZERO RETURN CODES TO DECIMAL           *
*           FOR DISPLAY                                               *
*                                                                     *
***********************************************************************
*
SETCODE  DS    0H
         CVD   R8,DEC                  CONVERT RETURN CODE TO DECIMAL
         UNPK  CONV(8),DEC(8)          UNPACK RETURN CODE
         MVZ   CONV+1(7),CONV          MOVE ZONES IN CONVERTED RETURN
*                                      CODE
         MVC   RETNCD(2),HALF12        MOVE LENGTH OF DATA FOR PUTLINE
         MVC   RETNCD+2(2),HALF0       MOVE IN ZEROES FOR PUTLINE
         BR    R14                     RETURN
*
***********************************************************************
*                                                                     *
*        FREE AND REALOCATE PRINTX FILE AS SYSOUT                     *
*                                                                     *
***********************************************************************
*
ALLOCOUT DS    0H
         STM   14,9,ALCSAVE            SAVE WORK REGISTERS
         LR    R1,R3                   LOAD POINTER TO DDNAME
         BAL   R2,FREEDD               BRANCH TO FREE ROUTINE
         LTR   R8,R8                   SEE IF RETURN CODE FROM FREE IS
*                                      ZERO
         BNZ   OPENFAIL                NO.....GO PUT OUT OPEN FAILED
         LA    R8,REQBLK               LOAD POINTER TO REQUEST BLOCK
         ST    R8,RBPTR                INITIALIZE REQUEST BLOCK POINTER
         MVI   RBPTR,S99RBPND          INDICATE END OF PARAMETER LIST
         USING S99RB,R8                ESTABLISH ADDRESSABILITY TO
*                                      REQUEST BLOCK
         MVC   S99RBLN(RBLEN),REQBLKC  INITALIZE RB
         LA    R1,TEXTPTRS             LOAD POINTER TO TEXT POINTERS
         ST    R1,S99TXTPP             STORE POINTER IN RB
         DROP  R8                      DROP ADDRESSABILITY TO RB
         USING S99TUPL,R1              ESTABLISH ADDRESSABILITY TO
*                                      TEXT UNIT POINTER LIST
         LA    R2,TEXTA                LOAD POINTER TO FIRST TEXT UNIT
         ST    R2,S99TUPTR             STORE POINTER IN TUPL
         USING S99TUNIT,R2             ESTABLISH ADDRESSABILITY TO
*                                      TEXT UNIT
         MVC   S99TUKEY(TEXTALEN),TEXTAC  INITIALIZE TEXT UNIT A
         MVC   S99TUPAR(8),0(R3)       MOVE IN PARAMETER (DDNAME)
         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT
*                                      POINTER
         LA    R2,TEXTB                LOAD POINTER TO TEXT UNIT B
         ST    R2,S99TUPTR             STORE POINTER IN TUPL
         MVC   S99TUKEY(TEXTBLEN),TEXTBC  INITIALIZE TEXT UNIT B
*
***********************************************************************
*                                                                     *
*        SET UP ADDRESSABILITY TO PDL                                 *
*           AND SEE IF SYSOUT CLASS/DEST ARE PRESENT                  *
*           ALSO FORMS/TRAIN/FCB/PROG.                            .GTE.
***********************************************************************
*
         L     R9,PARSBACK             LOAD ADDRESS PARS ANSWER
         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY TO PDL
         CLC   PCLASS(2),HALF1         SEE IF CLASS SPECIFIED
         BNE   NOCLASS                 NO.....GO CHECK FOR DESTINATION
         L     R7,SCLASS               LOAD POINTER TO SYSOUT CLASS
         MVC   S99TUPAR,0(R7)          MOVE CLASS INTO TEXT UNIT B
NOCLASS  DS    0H
         CLC   PDEST(2),HALF1          SEE IF DEST SPECIFIED
         BNE   NODEST                  NO.....GO CHECK FOR HOLD
         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT
*                                      POINTER
         LA    R2,TEXTC                LOAD POINTER TO TEXT UNIT C
         ST    R2,S99TUPTR             STORE POINTER IN TUPL
         MVC   S99TUKEY(TEXTCLEN),TEXTCC  INITIALIZE TEXT UNIT C
         L     R7,SDEST                LOAD POINTER TO DESTINATION
         LH    R6,SDEST+4              LOAD LENGTH OF DESTINATION ID
         STH   R6,S99TULNG             STORE LENGTH OF DEST IN TU
         BCTR  R6,0                    DECREMENT LENGTH FOR EXECUTE OF
*                                      MOVE
         EX    R6,MOVEDEST             MOVE DEST INTO TU
MOVEDEST MVC   S99TUPAR,0(R7)          MOVE TO BE EXECUTED
*
NODEST   DS    0H
         CLC   PHOLD(2),HALF1          SEE IF HOLD SPECIFIED
         BNE   NOHOLD                  NO.....GO CHECK FOR COPIES
         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT
*                                      POINTER
         LA    R2,TEXTDC               LOAD POINTER TO TEXT UNIT C
         ST    R2,S99TUPTR             STORE POINTER IN TUPL
NOHOLD   DS    0H
         CLC   PCOPIES(2),HALF1        SEE IF COPY SPECIFIED
         BNE   NOCOPY                  NO.....GO ZERO ECB
         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT
*                                      POINTER
         LA    R2,TEXTE                LOAD POINTER TO TEXT UNIT E
         ST    R2,S99TUPTR             STORE POINTER IN TUPL
         MVC   S99TUKEY(TEXTELEN),TEXTEC  INITIALIZE TEXT UNIT E
         L     R7,SCOPIES              LOAD POINTER TO COPY FIELD
         LH    R6,SCOPIES+4            LOAD LENGTH OF COPY FIELD
         BCTR  R6,0                    DECREMENT REGISTER 6 FOR EXECUTE
*                                      OF PACK INSTRUCTION
         EX    R6,PACKCOPY             EXECUTE PACK TO CONVERT COPIES
*                                      TO ZONED DECIMAL
         CVB   R6,DEC                  CONVERT ZONED TO BINARY
         STCM  R6,1,S99TUPAR           STORE NUMBER OF COPIES IN TU
NOCOPY   DS    0H
*********** START OF GTE MOD                                      .GTE.
         CLC   PFORMS(2),HALF1         SEE IF FORMS SPECIFIED     .GTE.
         BNE   NOFORMS                 NO.....GO CHECK TRAIN      .GTE.
         LA    R1,4(R1)                LOAD POINTER TO NEXT       .GTE.
*                                      TEXT UNIT POINTER          .GTE.
         LA    R2,TEXTI                LOAD PTR TO TEXT UNIT I    .GTE.
         ST    R2,S99TUPTR             STORE POINTER IN TUPL      .GTE.
         MVC   S99TUKEY(TEXTILEN),TEXTIC  INITIALIZE TEXT UNIT I  .GTE.
         L     R7,RFORMS               LOAD PTR TO FORMS FIELD    .GTE.
         LH    R6,RFORMS+4             LOAD LENGTH OF FORMS FIELD .GTE.
         STH   R6,S99TULNG             STORE LENGTH IN TUE        .GTE.
         BCTR  R6,0                    DECREMENT LENGTH           .GTE.
         EX    R6,MOVEDEST             MOVE FORMS INTO FIELD      .GTE.
NOFORMS  DS    0H                                                 .GTE.
         CLC   PTRAIN(2),HALF1         SEE IF TRAIN SPECIFIED     .GTE.
         BNE   NOTRAIN                 NO.....GO CHECK FCB        .GTE.
         LA    R1,4(R1)                LOAD POINTER TO NEXT       .GTE.
*                                      TEXT UNIT POINTER          .GTE.
         LA    R2,TEXTH                LOAD PTR TO TEXT UNIT G    .GTE.
         ST    R2,S99TUPTR             STORE POINTER IN TUPL      .GTE.
         MVC   S99TUKEY(TEXTHLEN),TEXTHC  INITIALIZE TEXT UNIT H  .GTE.
         L     R7,RTRAIN               LOAD PTR TO TRAIN FIELD    .GTE.
         LH    R6,RTRAIN+4             LOAD LENGTH OF TRAIN FIELD .GTE.
         STH   R6,S99TULNG             SAVE LENGTH OF FCBE        .GTE.
         BCTR  R6,0                    DECREMENT FOR EX           .GTE.
         EX    R6,MOVEDEST             MOVE FCB INTO TU           .GTE.
NOTRAIN  DS    0H                                                 .GTE.
         CLC   PFCB(2),HALF1           SEE IF FCB  SPECIFIED      .GTE.
         BNE   NOFCB                   NO.....GO ZERO ECB         .GTE.
         LA    R1,4(R1)                LOAD POINTER TO NEXT       .GTE.
*                                      TEXT UNIT POINTER          .GTE.
         LA    R2,TEXTG                LOAD PTR TO TEXT UNIT G    .GTE.
         ST    R2,S99TUPTR             STORE POINTER IN TUPL      .GTE.
         MVC   S99TUKEY(TEXTGLEN),TEXTGC  INITIALIZE TEXT UNIT G  .GTE.
         L     R7,RFCB                 LOAD POINTER TO FCB FIELD  .GTE.
         LH    R6,RFCB+4               LOAD LENGTH OF FCB FIELD   .GTE.
         STH   R6,S99TULNG             SAVE LENGTH OF FCB IN TUE  .GTE.
         BCTR  R6,0                    DECREMENT                  .GTE.
         EX    R6,MOVEDEST             MOVE FCB TO TU             .GTE.
NOFCB    DS    0H                                                 .GTE.
         CLC   PPROG(2),HALF1          SEE IF PROG SPECIFIED      .GTE.
         BNE   NOPROG                  NO.....GO ZERO ECB         .GTE.
         LA    R1,4(R1)                LOAD POINTER TO NEXT       .GTE.
*                                      TEXT UNIT POINTER          .GTE.
         LA    R2,TEXTJ                LOAD PTR TO TEXT UNIT J    .GTE.
         ST    R2,S99TUPTR             STORE POINTER IN TUPL      .GTE.
         MVC   S99TUKEY(TEXTJLEN),TEXTJC  INITIALIZE TEXT UNIT J  .GTE.
         L     R7,RPROG                LOAD PTR TO PROG FIELD     .GTE.
         LH    R6,RPROG+4              LOAD LENGTH OF PROG FIELD  .GTE.
         STH   R6,S99TULNG             SAVE LENGTH OF PROG IN TUE .GTE.
         BCTR  R6,0                    DECREMENT FOR MOVE         .GTE.
         EX    R6,MOVEDEST             MOVE PROG TO TU            .GTE.
NOPROG   DS    0H                                                 .GTE.
********* END OF GTE MOD                                          .GTE.
         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT
*                                      POINTER
         LA    R2,TEXTFC               LOAD POINTER TO TEXT UNIT F
*                                      PERMANENTLY ALLOCATED
*                                      ATTRIBUTE
         ST    R2,S99TUPTR             STORE POINTER IN TUPL
         MVI   S99TUPTR,S99TUPLN       INDICATE END OF TEXT UNIT
*                                      POINTER LIST
         DROP  R1,R2,R9                DROP ADDRESSABILITY TO DSECTS
         LA    R1,RBPTR                LOAD ADDRESS OF REQUEST BLOCK
*                                      POINTER
         DYNALLOC                      ISSUE DYNAMIC ALLOCATION SVC
         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO
         BNZ   ALCFAIL                 NO.....GO AND CALL DAIR FAIL
         MVC   OPENLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT
*                                      INTO WORKAREA
         OPEN  ((R5),(OUTPUT)),MF=(E,OPENLST)
*                                      OPEN OUTPUT DCB
         TM    48(R5),DCBOFOPN         SEE IF DCB OPENED SUCCESSFULLY
         BNO   OPENFAIL                NO.....GO PUT OUT OUTPUT DCB
*                                      NOT OPENED MESSAGE
         CLI   BLKBIT,X'FF'                                      .DOR.
         BNE   NOBLKHDA                                          .DOR.
*    BLOCKSUB REQUIRED TO OPEN DCB FIRST                         .DOR.
*    PARM FORMAT TO BLCKHEAD SUBROUTINE                          .DOR.
*    BYTE 0     DCB ADDRESS                                      .DOR.
*    BYTE 4-5   PARM LENGTH                                      .DOR.
*    BYTE 6-250 BLOCK HEAD STRING                                .DOR.
         LA    R1,PARMBLCK            (PRINTA),MEMBER            .DOR.
         ST    R5,0(R1)               SAVE DCB ADDRESS           .DOR.
         MVC   4(2,R1),=XL2'0011'      17 BYTES                  .DOR.
         MVC   6(9,R1),=CL9'(PRINTA),'                           .DOR.
         L     R15,PTRPRINT                                      .DOR.
         MVC   7(6,R1),0(R15)          MOVE PRINTI OR PRINTA     .DOR.
         MVC   15(8,R1),=CL8'MEMLIST '  PUT MEMBER NAME IN PARMLISTOR.
         L      R15,=V(BLOCKSUB)                                 .DOR.
         BALR   R14,R15                                          .DOR.
NOBLKHDA DS    0H                                                .DOR.
         LM    14,9,ALCSAVE            RESTORE REGISTERS
         BR    R14                     RETURN TO CALLER
ALCFAIL  DS    0H
         LA    R1,REQBLK               LOAD ADDRESS OF REQUEST
*                                      BLOCK
         MVI   DFID+1,DFSVC99          SET DAIR FAIL FOR SVC 99 ERROR
         BAL   R2,DAIRFAIL             LOAD ADDRESS OF OPEN FAIL AND
*                                      BRANCH TO DAIRFAIL ROUTINE
OPENFAIL DS    0H
         PUTLINE OUTPUT=(OPENMSG,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      OUTPUT DCB NOT OPEND MESSAGE
         S     R3,FULL4                GET POINTER TO PUTLINE DDNAME
         PUTLINE OUTPUT=((R3),SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DDNAME
         B     CLOSDCBS                GO CLOSE DCBS AND RETURN
*
***********************************************************************
*                                                                     *
*        INVOKE DAIR TO FREE FILENAME VIA CALLTSSR                    *
*           AND CHECK FOR ZERO RETURN CODE                            *
*                                                                     *
***********************************************************************
*
FREEDD   DS    0H
         SLR   R8,R8                   INITIALIZE REGISTER 8 TO ZERO
*                                      RETURN CODE
         MVC   DAP18(DAPB18L),DAPB18C  INITIALIZE DAIR PARAMETER BLOCK
*                                      18 (FREE BY DATASET)
         LA    R4,DAP18                LOAD ADDRESS OF DAPB
         USING DAPB18,R4               ESTABLISH ADDRESSABILITY TO
*                                      DAPB
         MVC   DA18DDN,0(R1)           MOVE DDNAME INTO DAPB
         SLR   R7,R7                   ZERO REGISTER 7
         ST    R7,ECB                  STORE REGISTER 7 AS DUMMY ECB
         LA    R1,DAPLSECT             LOAD ADDRESS OF DAPL
         USING DAPL,R1                 ESTABLISH ADDRESSABILITY TO DAPL
         ST    R4,DAPLDAPB             STORE ADDRESS OF DAPB IN DAPL
         DROP  R1,R4                   DROP ADDRESSABILITY TO DAPL AND
*                                      DAPB
         CALLTSSR EP=IKJDAIR           CALL DAIR TO FREE DDNAME
         C     R15,FULL28              SEE IF RETURN CODE IS 28
*                                      (DDNAME NOT ALLOCATED)
         BER   R2                      YES....GO CONTINUE PROCESSING
         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO
         BZR   R2                      YES....GO CONTINUE PROCESSING
         MVI   DFID+1,DFDAIR           SET DAIRFAIL ID TO INDICATE DAIR
*
***********************************************************************
*                                                                     *
*        INVOKE DAIRFAIL TO DISPLAY AN ERROR MESSAGE                  *
*                                                                     *
***********************************************************************
*
DAIRFAIL XC    DFPARMS(DFLEN),DFPARMS  INITIALIZE PARMLIST FOR DAIR
*                                      FAIL TO ZEROS
         ST    R1,DFDAPLP              STORE POINTER TO DAPL/RB IN
*                                      PARAMETER LIST
         ST    R15,RETCODE             STORE RETURN CODE
         LA    R1,RETCODE              LOAD ADDRESS OF RETURN CODE
         ST    R1,DFRCP                STORE POINTER TO RETURN CODE IN
*                                      PARAMETER LIST
         LA    R1,FULL0                LOAD ADDRESS OF FULLWORD OF
*                                      ZEROS
         ST    R1,DFJEFF02             STORE DUMMY POINTER TO IKJEFF02
*                                      IN PARMLIST
         LA    R1,DFID                 LOAD ADDRESS OF DAIR FAIL ID
*                                      FIELD
         ST    R1,DFIDP                STORE POINTER TO DFID IN
*                                      PARMLIST
         MVI   DFID,NOWTP              SET FOR NO WRITE TO PROGRAMMER
         L     R1,SAVEAREA+4           LOAD ADDRESS OF PEVIOUS
*                                      SAVEAREA
         L     R1,24(R1)               LOAD POINTER TO CPPL
         ST    R1,DFCPPLP              STORE POINTER TO CPPL IN
*                                      PARMLIST
         LINK  EP=IKJEFF18,MF=(E,DFPARMS)  LINK TO DAIR FAIL SERVICE
*                                      ROUTINE TO HANDLE RETURN
*                                      CODE
         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO
         BZR   R2                      YES....GO RETURN TO CALLER
         LR    R8,R15                  LOAD REGISTER 8 WITH RETURN CODE
         BAL   R14,SETCODE             GO CONVERT CODE TO DECIMAL
         PUTLINE OUTPUT=(DRFLERR,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DAIR FAIL ERROR MESSAGE
         PUTLINE OUTPUT=(RETNCD,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT
*                                      DECIMAL RETURN CODE
         BR    R2                      GO RETURN TO CALLER
*
******************** INSTRUCTIONS TO BE EXECUTED **********************
*
MOVEDSN  MVC   DSNBUF(0),0(R5)
MOVEVOL  MVC   VOLUME(0),0(R7)
PACKCOPY PACK  DEC(8),0(0,R7)
         USING DAPB08,R8
MOVEMEM  MVC   DA08MNM(0),0(R5)
MOVEPASS MVC   DA08PSWD(0),0(R5)
         DROP  R8
DFPBMVE  MVC   DFPBNAME(0),0(R5)   EXECUTED                       .GTE.
*
***************************** CONSTANTS *******************************
*
******************** DAIR CONTROL BLOCK CONSTANTS *********************
DAPB08C  DS    0F
         DC    X'0008'                 DA08CD
         DC    H'0'                    DA08FLG
         DC    H'0'                    DA08DARC
         DC    H'0'                    DA08CTRC
         DC    A(0)                    DA08PDSN
         DC    CL8'PRINTI  '           DA08DDN
         DC    CL8' '                  DA08UNIT
         DC    CL8' '                  DA08SER
         DC    F'0'                    DA08BLK
         DC    F'0'                    DA08PQTY
         DC    F'0'                    DA08SQTY
         DC    F'0'                    DA08DQTY
         DC    CL8' '                  DA08MNM
         DC    CL8' '                  DA08PSWD
         DC    X'08'                   DA08DSP1      SHR
         DC    X'08'                   DA08DSP2      KEEP
         DC    X'08'                   DA08DSP3      KEEP
         DC    X'08'                   DA08CTL       PERM
         DC    F'0'                    DA08DSO
         DC    CL8' '                  DA08ALN
DAPB08L  EQU   *-DAPB08C               LENGTH
         SPACE 2
DAPB18C  DS    0F
         DC    X'0018'                 DA18CD
         DC    X'0000'                 DA18FLG
         DC    H'0'                    DA18DARC
         DC    H'0'                    DA18CTRC
         DC    F'0'                    DA18PDSN
         DC    CL8'PRINTI'             DA18DDN
         DC    CL8' '                  DA18MNM
         DC    CL2' '                  DA18SCLS
         DC    X'08'                   DA18DPS2
         DC    X'10'                   DA18CTL
         DC    CL8' '                  DA18JBNM
DAPB18L  EQU   *-DAPB18C               LENGTH
         SPACE 2
INPUTC   DCB   DSORG=PS,MACRF=(GM),EODAD=EXIT,SYNAD=ERRI,DDNAME=PRINTI
INPUTL   EQU   *-INPUTC
*
OUTPUTAC DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=PRINTA,RECFM=VBA, X
               LRECL=256,BLKSIZE=3120
OUTPUTAL EQU   *-OUTPUTAC
*
OUTPUTMC DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=PRINTM,RECFM=VBM, X
               LRECL=256,BLKSIZE=3120
OUTPUTML EQU   *-OUTPUTMC
*
DIRECTC  DCB   DDNAME=PRINTI,DSORG=PS,MACRF=(GM),RECFM=U,BLKSIZE=256,  X
               SYNAD=SERRI,EODAD=FREEBLK
DIRECTL  EQU   *-DIRECTC
*
OPENCLOS OPEN  (,),MF=L
         SPACE 2
HEADERC  DS    0F
         DC    H'48'
         DC    H'0'
HDRCNTLC DC    C' '
         DC    CL43'**** TSO FOREGROUND HARDCOPY ****'
HEADERM  DS    0F
         DC    H'48'
         DC    H'0'
         DC    C' '
         DC    CL43'*** TSO FOREGROUND MEMBER LIST **'
LDSNAME  DS    0CL12
         ORG   LDSNAME
         DC    H'66'
         DC    H'0'
         DC    CL8' DSNAME='
EJECTM   DS    0F
         DC    H'5'
         DC    H'0'
         DC    X'8B'
EJECTA   DS    0F
         DC    H'5'
         DC    H'0'
         DC    C'1'
SPACE    EQU   EJECTA
         SPACE 2
FULL0    DC    F'0'
FULL1    DC    F'1'
FULL4    DC    F'4'
FULL20   DC    F'20'
FULL28   DC    F'28'
FULL256  DC    F'256'
PRINTILN DC    H'12',H'0'
PRINTI   DC    CL8'PRINTI'
PRINTALN DC    H'12',H'0'
PRINTA   DC    CL8'PRINTA'
PRINTMLN DC    H'12',H'0'
PRINTM   DC    CL8'PRINTM'
BLANKS   DC    256CL1' '
ALIAS    DC    CL8' *ALIAS*'
ENDCHAIN DS    0F
         DC    X'FF000000'
MEMDATL  DC    X'00'                   SUBPOOL NUMBER
         DC    AL3(1808)
HALF0    DC    H'0'
HALF1    DC    H'1'
HALF2    DC    H'2'
HALF6    DC    H'6'
HALF12   DC    H'12'
HALF85   DC    H'85'
HALF256  DC    H'256'
PATCH    DC    8CL4'ZAP*'
HEXFF    EQU   X'FF'
HIGH     EQU   X'80'
BLANK    EQU   X'40'
LOW      EQU   X'01'
JFCPDS   EQU   X'01'
HEX00    EQU   X'00'
SCLSA    EQU   C'A'
SKIPM    EQU   X'09'
DSOPS    EQU   X'40'
DSOPO    EQU   X'02'
NOWTP    EQU   X'00'
         SPACE 2
****************** POINTER TO PARS PARAMETER CSECT ********************
PCLADDR  DC    A(PARMTAB)
         SPACE 2
************************ PARS PARAMETER LIST **************************
         PRINT NOGEN                                              .PRC.
PARMTAB  IKJPARM  DSECT=IKJPARMD
DSNAMES  IKJPOSIT  DSNAME,LIST,USID,                                   X
               PROMPT='DSNAME',                                        X
               HELP='DSNAME TO BE PRINTED'
PCLASS   IKJKEYWD
         IKJNAME 'CLASS',SUBFLD=CLASSUB
PDEST    IKJKEYWD
         IKJNAME 'DEST',SUBFLD=DESTSUB
PHOLD    IKJKEYWD
         IKJNAME 'HOLD'
         IKJNAME 'NOHOLD'
PCOPIES  IKJKEYWD
         IKJNAME 'COPIES',SUBFLD=COPYSUB
PPRINT   IKJKEYWD
         IKJNAME 'PRINT'
         IKJNAME 'NOPRINT'
PBLOCK   IKJKEYWD
         IKJNAME 'BLOCK'        PRINT MEMBER IN BLOCKHEAD        .DOR.
         IKJNAME 'NOBLOCK'       FOR MICROFICHE READING          .DOR.
PLIST    IKJKEYWD
         IKJNAME 'LIST'
         IKJNAME 'NOLIST'
PHEAD    IKJKEYWD
         IKJNAME 'NOHEADING'                                      .GTE.
         IKJNAME 'HEADING'                                        .GTE.
PVOL     IKJKEYWD
         IKJNAME 'VOLUME',SUBFLD=VOLSUB
PFOLD    IKJKEYWD
         IKJNAME 'FOLD',ALIAS=('CAPS')
         IKJNAME 'NOFOLD',ALIAS=('ASIS')
PFORMS   IKJKEYWD
         IKJNAME  'FORMS',SUBFLD=SFORMS                          .GTE.
PTRAIN   IKJKEYWD
         IKJNAME  'TRAIN',SUBFLD=STRAIN,ALIAS=('UCS')            .GTE.
PFCB     IKJKEYWD
         IKJNAME    'FCB',SUBFLD=SFCB                            .GTE.
PPROG    IKJKEYWD
         IKJNAME    'PROG',SUBFLD=SPROG                          .GTE.
PTEXT    IKJKEYWD
         IKJNAME    'TEXT',INSERT='UCS(TN) ASIS'                 .GTE.
ASAKW    IKJKEYWD
         IKJNAME 'ASA'                                           .PRC.
SNUMKW   IKJKEYWD
         IKJNAME 'SNUM'                                          .PRC.
MSGKW    IKJKEYWD
         IKJNAME 'NOMSG'                                         .PRC.
*        B E G I N   S U B F I E L D S
CLASSUB  IKJSUBF
SCLASS   IKJIDENT 'CLASSNAME',LIST,FIRST=NONATNUM,MAXLNTH=1,           X
               PROMPT='CLASS NAME'
DESTSUB  IKJSUBF
SDEST    IKJPOSIT USERID,                                              X
               PROMPT='REMOTE STATION ID FOR THE DEST KEYWORD'
COPYSUB  IKJSUBF
SCOPIES  IKJIDENT 'COPIES',MAXLNTH=3,                                  X
               FIRST=NUMERIC,OTHER=NUMERIC,                            X
               PROMPT='1-3 DIGITS - NUMBER OF COPIES OF OUTPUT',       X
               HELP=('NUMBER OF COPIES OF PRINTOUT DESIRED')
VOLSUB   IKJSUBF
SVOL     IKJIDENT 'VOLUME',MAXLNTH=8,                                  X
               FIRST=ALPHANUM,OTHER=ALPHANUM,                          X
               PROMPT='VOLUME SERIAL FOR DATA SETS TO BE PRINTED',     X
               HELP=('VOLUME SERIAL WILL BE ASSUMED FOR ALL DATA SETS')
SFORMS   IKJSUBF
RFORMS   IKJIDENT 'FORMS',MAXLNTH=4,FIRST=ALPHANUM,               .GTE.X
               OTHER=ALPHANUM,                                    .GTE.X
               PROMPT='FORMS DESIGNATION FOR PRINTED OUTPUT',     .GTE.X
               HELP=('AN ALPANUMERIC STRING TO SPECIFY THE FORM') .GTE.
STRAIN   IKJSUBF
RTRAIN   IKJIDENT   'UCS',MAXLNTH=4,FIRST=ALPHANUM,               .GTE.X
               OTHER=ALPHANUM,                                    .GTE.X
               PROMPT='UCS   DESIGNATION FOR PRINTED OUTPUT',     .GTE.X
               HELP=('AN ALPANUMERIC STRING TO SPECIFY THE TRAIN') GTE.
SFCB     IKJSUBF
RFCB     IKJIDENT 'FCB',MAXLNTH=4,FIRST=ALPHANUM,                 .GTE.X
               OTHER=ALPHANUM,                                    .GTE.X
               PROMPT='FCB DESIGNATION FOR PRINTED OUTPUT',       .GTE.X
               HELP=('AN ALPANUMERIC STRING TO SPECIFY THE FCB')  .GTE.
SPROG    IKJSUBF
RPROG    IKJIDENT 'PROG',MAXLNTH=8,FIRST=ALPHA,                   .GTE.X
               OTHER=ALPHANUM,                                    .GTE.X
               PROMPT='PROG DESIGNATION FOR PRINTED OUTPUT',      .GTE.X
               HELP=('AN ALPANUMERIC STRING TO SPECIFY THE PROG') .GTE.
         IKJENDP
         PRINT GEN                                                .PRC.
         SPACE 2
****************************** MESSAGES *******************************
GNRLERR  DC    AL2(GNRLERRL),AL2(0)
         DC    C'AN ERROR WAS ENCOUNTERED IN THE GENERAL FAIL SERVICE RX
               OUTINE.  THE RETURN CODE FROM GNRLFAIL IS: '
GNRLERRL EQU   *-GNRLERR
*
DRFLERR  DC    AL2(DRFLERRL),AL2(0)
         DC    C'AN ERROR WAS ENCOUNTERED IN THE DAIR FAIL SERVICE ROUTX
               INE.  THE RETURN CODE FROM DAIR FAIL IS: '
DRFLERRL EQU   *-DRFLERR
*
OPENMSG  DC    AL2(OPENMSGL),AL2(0)
         DC    C'OUPUT PROCESSING IS BEING TERMINATED.  AN ERROR WAS ENX
               COUNTERED ATTEMPTING TO OPEN THE OUTPUT DATASET ASSOCIATX
               ED WITH DDNAME: '
OPENMSGL EQU   *-OPENMSG
*
DSNNOTP  DC    AL2(DSNNOTPL),AL2(0)
         DC    C'AN ERROR OCCURRED AND YOUR DATASET WAS NOT PRINTED'
DSNNOTPL EQU   *-DSNNOTP
*
DSNMSG   DC    AL2(DSNMSGL),AL2(0)
         DC    C'PROCESSING HAS BEEN COMPLETED FOR DATASET: '
DSNMSGL  EQU   *-DSNMSG
*
MEMMSG   DC    AL2(MEMMSGL),AL2(0)
         DC    C' MEMBER: '
MEMMSGL  EQU   *-MEMMSG
*
PRTMSG   DC    AL2(PRTMSGL),AL2(0)
         DC    C'MEMBERS WILL NOW BE PRINTED FOR DATASET: '
PRTMSGL  EQU   *-PRTMSG
*
NOTPSPO  DC    AL2(NOTPSPOL),AL2(0)
         DC    C'DATASET IS NOT SEQUENTIAL OR PARTITIONED AND WAS NOT PX
               RINTED.'
NOTPSPOL EQU   *-NOTPSPO
*
SYNADI   DC    AL2(SYNADIL),AL2(0)
         DC    C'A SYNAD ERROR OCURRED READING YOU INPUT DATASET AND ONX
               LY PART OF YOUR DATASET MAY HAVE BEEN PRINTED.'
SYNADIL  EQU   *-SYNADI
*
SYNADO   DC    AL2(SYNADOL),AL2(0)
         DC    C'A SYNAD ERROR OCURRED WRITING THE OUTPUT DATASET AND NX
               O MORE DATASETS WILL BE PRINTED.'
SYNADOL  EQU   *-SYNADO
*
DSNISU   DC    AL2(DSNISUL),AL2(0)
         DC    C'DATASET HAS UNDEFINED RECORD LENGTH AND WILL NOT BE PRX
               INTED.'
DSNISUL  EQU   *-DSNISU
*
DSNISL   DC    AL2(DSNISLL),AL2(0)
         DC    C'DATASET HAS RECORD LENGTH GREATER THAN 256.'
DSNISLL  EQU   *-DSNISL
         SPACE 2
************************ DSECTS (MAPPING MACROS) **********************
MEMDSECT DSECT
MEMNTTR  DS    CL11
         ORG   MEMNTTR
MEMBER   DS    CL8
MEMTTR   DS    CL3
CFIELD   DS    CL1
MEMSECTN EQU   *
         IKJDAP08
DAP08LEN EQU   *-DAPB08
         IKJDAP18
DAP18LEN EQU   *-DAPB18
         IKJDAPL
DAPLLEN  EQU   *-DAPL
         IKJCPPL
CPPLLEN  EQU   *-CPPL
         IKJPPL
PPLLEN   EQU   *-PPL
         IKJIOPL
IOPLLEN  EQU   *-IOPL
         IHADSAB
TIOEDDNM EQU   4           X'1C'(OFFSET) - X'18'(JOB STEP)
*        CVT                                                     *.PRC.
CVTPTR   EQU   16                                                 .PRC.
CVT      DSECT                                                    .PRC.
CVTMAP   EQU   *                                                  .PRC.
CVTPARS  EQU   CVTMAP+X'20C'                                      .PRC.
CVTDAIR  EQU   CVTMAP+X'2DC'                                      .PRC.
CVTEHDEF EQU   CVTMAP+X'2E0'                                      .PRC.
         IEFZB4D0
         IEFZB4D2
         IKJDFPL                                                  .GTE.
         IKJDFPB                                                  .GTE.
RBLEN    EQU   S99RBEND-S99RB
         PRINT NOGEN
         DCBD  DSORG=(PS,PO)
         PRINT GEN
         EJECT
******************** CONSTANTS FOR DYNAMIC ALLOCATION *****************
PRINTOFF CSECT
REQBLKC  DC    AL1(S99RBEND-S99RB),AL1(S99VRBAL),18AL1(0)
TEXTAC   DC    AL2(DALDDNAM),AL2(1),AL2(8),CL8'PRINT'  DDNAME
TEXTALEN EQU   *-TEXTAC
TEXTBC   DC    AL2(DALSYSOU),AL2(1),AL2(1),C'A'        SYSOUT CLASS
TEXTBLEN EQU   *-TEXTBC
TEXTCC   DC    AL2(DALSUSER),AL2(1),AL2(8),CL8'LOCAL'  DESTINATION
TEXTCLEN EQU   *-TEXTCC
TEXTDC   DC    AL2(DALSHOLD),AL2(0)              SYSOUT HOLD
TEXTDLEN EQU   *-TEXTDC
TEXTEC   DC    AL2(DALCOPYS),AL2(1),AL2(1),AL2(1)      SYSOUT COPIES
TEXTELEN EQU   *-TEXTEC
TEXTFC   DC    AL2(DALPERMA),AL2(0)              PERM ALLOCATION
TEXTFLEN EQU   *-TEXTFC
TEXTGC   DC    AL2(DALFCBIM),AL2(1),AL2(4),CL4'STD.'  FCB         .GTE.
TEXTGLEN EQU   *-TEXTCC                                           .GTE.
TEXTHC   DC    AL2(DALUCS),AL2(1),AL2(2),CL4'PN'      UCS         .GTE.
TEXTHLEN EQU   *-TEXTDC                                           .GTE.
TEXTIC   DC    AL2(DALSFMNO),AL2(1),AL2(2),CL4'STD.'  FORMS       .GTE.
TEXTILEN EQU   *-TEXTEC                                           .GTE.
TEXTJC   DC    AL2(DALSPGNM),AL2(1),AL2(8),CL8'PROG'  PROG        .GTE.
TEXTJLEN EQU   *-TEXTFC                                           .GTE.
*********************** DSECT FOR DYNAMIC WORKAREA ********************
WORKAREA DSECT
SAVEAREA DS    18F
ALCSAVE  DS    12F
         DS    0D
DEC      DS    2F
RETNCD   DS    F
CONV     DS    2F
IOPB     PUTLINE MF=L
DAP08    DS    0F
         ORG   DAP08+DAP08LEN
DAP18    DS    0F
         ORG   DAP18+DAP18LEN
DAPLSECT DS    0F
         ORG   DAPLSECT+DAPLLEN
PPLSECT  DS    0F
         ORG   PPLSECT+PPLLEN
IOPLSECT DS    0F
         ORG   IOPLSECT+IOPLLEN
DFPLSECT DS    4F                   SPACE FOR DFPL                .GTE.
DFPBSECT DS    5F                   SPACE FOR DFPB                .GTE.
         DS    H                    TO GET ALLIGNMENT             .GTE.
DFPBDSL  DS    H                    DSNAME LENGTH                 .GTE.
DFPBNAME DS    CL44                 DSNAME                        .GTE.
DFPBQUA  DS    CL8
ECB      DS    F
PTRPRINT DS    F
         DS    0F
PARMBLCK DS    CL256
BLKBIT   DS    XL1                            .DOR.
         DS    0F
PARSBACK DS    F
LINE     DS    0H
LENGTH   DS    H
         DS    H
CNTLBYTE DS    CL1
DATA     DS    CL256
HEADER2  DS    CL12
DSNAME   DS    CL44
OPENPRN  DS    CL1
MEMNAME  DS    CL8
CLOSEPRN DS    CL1
         ORG   DSNAME-4
DSNLENP  DS    CL2
DSNLEN   DS    CL2
DSNBUF   DS    CL44
         ORG   MEMNAME-4
MEMNAMEL DS    CL2
         ORG
HEADER   DS    CL48
         ORG   HEADER+4
HDRCNTL  DS    CL1
DFID     DS    CL2
         ORG
VOLBIT   DS    CL1
VOLUME   DS    CL8
MEMTABLE DS    F
ENDTABLE DS    F
CURRENT  DS    F
PRESENT  DS    F
COLUMN   DS    F
XLIST    DS    F
RDJL     RDJFCB (,),MF=L
JFCBAREA DS    44F
         ORG   JFCBAREA+44
JFCBELNM DS    CL8
         ORG   JFCBAREA+86
JFCBIND1 DS    CL1
         ORG   JFCBAREA+98
JFCDSRG1 DS    CL1
         ORG
SAVER6   DS    F
SAVER2   DS    2F
SAVER3   DS    2F
PRCKW    DS    F                                                  .PRC.
*
         PRINT NOGEN
*
INPUT    DCB   DSORG=PS,MACRF=(GM),EODAD=EXIT,SYNAD=ERRI,DDNAME=PRINTI
*
OUTPUTA  DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=PRINTA,RECFM=VBA, X
               LRECL=256,BLKSIZE=3120
*
OUTPUTM  DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=PRINTM,RECFM=VBM, X
               LRECL=256,BLKSIZE=3120
*
DIRECT   DCB   DDNAME=PRINTI,DSORG=PS,MACRF=(GM),RECFM=U,BLKSIZE=256,  X
               SYNAD=SERRI,EODAD=FREEBLK
*
OPENLST  OPEN  (,),MF=L
*
CLOSLST  CLOSE (,),MF=L
*
         PRINT GEN
*
RETCODE  DS    F
GFPARMP  DS    F
         IKJEFFGF
         IKJEFFDF
RBPTR    DS    F
REQBLK   DS    10F (WAS 5F)                                       .GTE.
TEXTPTRS DS    10F (WAS 5F)                                       .GTE.
TEXTA    DS    0F                                   DDNAME
         ORG   TEXTA+TEXTALEN
TEXTB    DS    0F                                   SYSOUT CLASS
         ORG   TEXTB+TEXTBLEN
TEXTC    DS    0F                                   DESTINATION
         ORG   TEXTC+TEXTCLEN
TEXTE    DS    0F                                   SYSOUT COPIES
         ORG   TEXTE+TEXTELEN
TEXTG    DS    0F                                   FCB           .GTE.
         ORG   TEXTG+TEXTGLEN                                     .GTE.
TEXTH    DS    0F                                   UCB           .GTE.
         ORG   TEXTH+TEXTHLEN                                     .GTE.
TEXTI    DS    0F                                   FORMS         .GTE.
         ORG   TEXTI+TEXTILEN                                     .GTE.
TEXTJ    DS    0F                                   PROG          .GTE.
         ORG   TEXTJ+TEXTJLEN                                     .GTE.
LDYNAMIC EQU   *-WORKAREA
         END
./       ADD   NAME=PTFSASL4
* SAS PROGRAM TO READ AND ANALYZE A PTF OUTPUT FROM SMPE ;
DATA SMPE (KEEP=TYPE STATUS FMID SYSMOD TSYSMOD RECTYPE
           RECDATE ACCDATE APPDATE LIBRARY ACTION)
     RMID    (KEEP= FMID ATYPE ASYSMOD ASYSNUM SYSMOD STATUS)
     MACS    (KEEP= FMID ATYPE ASYSMOD ASYSNUM SYSMOD STATUS)
     MODS    (KEEP= FMID ATYPE ASYSMOD ASYSNUM SYSMOD STATUS)
     SRCS    (KEEP= FMID ATYPE ASYSMOD ASYSNUM SYSMOD STATUS)
     REQS    (KEEP= FMID ATYPE ASYSMOD ASYSNUM SYSMOD STATUS)
     PRES    (KEEP= FMID ATYPE ASYSMOD ASYSNUM SYSMOD STATUS)
     SUPING  (KEEP= FMID ATYPE ASYSMOD ASYSNUM SYSMOD STATUS)
     HOLDERR (KEEP= FMID ATYPE ASYSMOD ASYSNUM SYSMOD STATUS)
     HOLDSYS (KEEP= FMID ATYPE ASYSMOD ASYSNUM SYSMOD STATUS);
  INFILE SMPELIST ;
OPTIONS LINESIZE=120  SORT=2 SORTSIZE=50K TIME=90   ;
LENGTH TYPE $8 STATUS $15 FMID $8  SYSMOD $8 TSYSMOD $8;
LENGTH ATYPE $4 ASYSMOD $8 ASYSNUM 4;
RETAIN STATUS  TYPE SYSMOD FMID ;
RETAIN RECDATE ACCDATE APPDATE;
RETAIN ATYPE ASYSMOD ASYSNUM;
DROP XEQU TIME YEAR DAY DATE ;
FORMAT TIME TIME8.
       RECDATE ACCDATE APPDATE DATE DATE7. ;
  INPUT @12 NYPE $4. @ ;    * LOOK FOR THE WORD 'TYPE' ;
  *---------------- TYPE ---------------------------;
  IF NYPE = 'TYPE' THEN DO ;
     INPUT @30 TYPE $8. @2 SYSMOD $8. ;
     RECDATE= ' '; ACCDATE= ' '; APPDATE= ' ';
     LASTYPE = TYPE ;
     RETURN; END;
   INPUT @12 TTATUS $7. @ ;
  *---------------- LASTUPD ------------------------;
     IF TTATUS = 'LASTUPD'  THEN DO ;
          RECTYPE = 'LASTUPD';
          INPUT @2 SYSMOD $8. ;
     RECDATE= ' '; ACCDATE= ' '; APPDATE= ' ';
     LASTYPE = 'LASTUPD';
          RETURN;
          END ;
  *---------------- LASTSUP ------------------------;
     IF TTATUS = 'LASTSUP'  THEN DO ;
          RECTYPE = 'LASTSUP';
          INPUT @30 TSYSMOD $8. ;
          OUTPUT SMPE ;
          RETURN;
          END ;
  *---------------- DELBY   ------------------------;
     IF TTATUS= 'DELBY '   THEN DO ;
          RECTYPE = 'DELETED';
          INPUT @30 TSYSMOD $8. ;
          OUTPUT SMPE ;
          RETURN ;
          END ;
 *---------------- RMID   ---------------------------------;
    IF TTATUS= 'RMID  '   THEN DO ;
          INPUT @30 TSYSMOD $8. ;
      IF FMID ^= TSYSMOD THEN DO;
     ATYPE='RMID'; ASYSMOD=TSYSMOD; ASYSNUM=1; OUTPUT RMID;
     END;
          RETURN ;
          END ;
 *---------------- SOURCEID -------------------------------;
     IF TTATUS= 'SOURCEI'   THEN DO ;
          RECTYPE = 'SRCID';
          INPUT @30 TSYSMOD $4. ;
          OUTPUT SMPE ;
          RETURN ;
          END ;
 *---------------- LIBRARIES ------------------------------;
     IF TTATUS= 'LIBRARI'   THEN DO ;
          RECTYPE = 'LIB';
          INPUT @30 LIBRARY $24. ;
          OUTPUT SMPE ;
          RETURN ;
          END ;
 *---------------- APPLY ZONE -----------------------------;
     IF TTATUS= 'APPLY Z'   THEN DO ;
          RECTYPE = 'APPZ';
          INPUT @30 TSYSMOD $8.;
          OUTPUT SMPE ;
          RETURN ;
          END ;
 *---------------- ACCEPT ZONE -----------------------------;
     IF TTATUS= 'ACCEPT '   THEN DO ;
          RECTYPE = 'ACCZ';
          INPUT @30 TSYSMOD $8.;
          OUTPUT SMPE ;
          RETURN ;
          END ;
 *---------------- REQ ------------------------------------;
     IF TTATUS = 'REQ  ' THEN DO;
        RECTYPE= 'REQ';
        NCNT=1; INPUT @30 TSYSMOD $8. @;
        OUTPUT SMPE;
        ASYSMOD = TSYSMOD; ASYSNUM=1; ATYPE='REQS'; OUTPUT REQS;
        REQ:INPUT +2 TSYSMOD $8. @;
            IF TSYSMOD ^= '        ' THEN DO;
            *  END OF PAGE AND HEADER TO BE IGNORE;
               IF TSYSMOD = 'GIMS ' THEN DO;
         REQPGE:INPUT; INPUT @30 TSYSMOD $8. @;
                IF TSYSMOD = '     ' THEN GO TO REQPGE;
                   ELSE DO; INPUT @28 XEQU $1. @28 @;
                    IF XEQU = '=' THEN RETURN; ELSE GO TO REQ;
                    END; END;
               OUTPUT SMPE; NCNT+1;
        ASYSMOD = TSYSMOD; ASYSNUM=1; ATYPE='REQS'; OUTPUT REQS;
               IF NCNT = 9 THEN DO; NCNT=0;
                  INPUT; INPUT @28 XEQU $1. @28 @;
                  IF XEQU = '=' THEN RETURN;
                     ELSE GO TO REQ;
                   END;
                GO TO REQ;
                END;
                ELSE DO; TSYSMOD= ' ';INPUT; RETURN; END;
         END;
 *---------------- SUPING ---------------------------------;
     IF TTATUS = 'SUPING ' THEN DO;
        RECTYPE= 'SUPI';
        NCNT=1; INPUT @30 TSYSMOD $8. @;
        OUTPUT SMPE;
        ASYSMOD = TSYSMOD; ASYSNUM=1; ATYPE='SUPI'; OUTPUT SUPING;
        SUPI:INPUT +2 TSYSMOD $8. @;
            IF TSYSMOD ^= '        ' THEN DO;
            *  END OF PAGE AND HEADER TO BE IGNORE;
               IF TSYSMOD = 'GIMS' THEN DO;
         SUPIPGE:INPUT; INPUT @30 TSYSMOD $8. @;
                IF TSYSMOD = '     ' THEN GO TO SUPIPGE;
                   ELSE DO; INPUT @28 XEQU $1. @28 @;
                    IF XEQU = '=' THEN RETURN; ELSE GO TO SUPI;
                    END; END;
               OUTPUT SMPE; NCNT+1;
        ASYSMOD = TSYSMOD; ASYSNUM=1; ATYPE='SUPI'; OUTPUT SUPING;
               IF NCNT = 9 THEN DO; NCNT=0;
                  INPUT; INPUT @28 XEQU $1. @28 @;
                  IF XEQU = '=' THEN RETURN;
                     ELSE GO TO SUPI;
                   END;
                GO TO SUPI;
                END; ELSE DO; TSYSMOD=' ';INPUT; RETURN; END;
         END;
 *---------------- PRE    ---------------------------------;
     IF TTATUS = 'PRE   ' THEN DO;
        RECTYPE= 'PRE';
        NCNT=1; INPUT @30 TSYSMOD $8. @;
        OUTPUT SMPE;
        ASYSMOD = TSYSMOD; ASYSNUM=1; ATYPE='PRES'; OUTPUT PRES;
        PRE:INPUT +2 TSYSMOD $8. @;
            IF TSYSMOD ^= '        ' THEN DO;
            *  END OF PAGE AND HEADER TO BE IGNORE;
               IF TSYSMOD = 'GIMS' THEN DO;
         PREPGE:INPUT; INPUT @30 TSYSMOD $8. @;
                IF TSYSMOD = '     ' THEN GO TO PREPGE;
                   ELSE DO; INPUT @28 XEQU $1. @28 @;
                    IF XEQU = '=' THEN RETURN; ELSE GO TO PRE;
                    END; END;
               OUTPUT SMPE; NCNT+1;
        ASYSMOD = TSYSMOD; ASYSNUM=1; ATYPE='PRES'; OUTPUT PRES;
               IF NCNT = 9 THEN DO; NCNT=0;
                  INPUT; INPUT @28 XEQU $1. @28 @;
                  IF XEQU = '=' THEN RETURN;
                     ELSE GO TO PRE;
                   END;
                GO TO PRE;
                END; ELSE DO; TSYSMOD=' ';INPUT;RETURN; END;
         END;
 *---------------- LAST   ---------------------------------;
     IF TTATUS = 'LAST  ' THEN DO;
        RECTYPE= 'LAST';
        NCNT=1; INPUT @30 TSYSMOD $8. @;
        OUTPUT SMPE;
        LAST:INPUT +2 TSYSMOD $8. @;
            IF TSYSMOD ^= '        ' THEN DO;
            *  END OF PAGE AND HEADER TO BE IGNORE;
               IF TSYSMOD = 'GIMS' THEN DO;
        LASTPGE:INPUT; INPUT @30 TSYSMOD $8. @;
                IF TSYSMOD = '     ' THEN GO TO LASTPGE;
                   ELSE DO; INPUT @28 XEQU $1. @28 @;
                    IF XEQU = '=' THEN RETURN; ELSE GO TO LAST;
                    END; END;
               OUTPUT SMPE; NCNT+1;
               IF NCNT = 9 THEN DO;
                  INPUT; INPUT @28 XEQU $1. @28 @;
                  IF XEQU = '=' THEN RETURN;
                     ELSE GO TO LAST;
                   END;
                GO TO LAST;
                END; ELSE DO; TSYSMOD=' ';INPUT; RETURN; END;
         END;
 *---------------- MAC    ---------------------------------;
     IF TTATUS = 'MAC  ' THEN DO;
        RECTYPE= 'MAC';
        NCNT=1; INPUT @30 TSYSMOD $8. @;
        OUTPUT SMPE;
        ASYSMOD = TSYSMOD; ASYSNUM=1; ATYPE='MAC'; OUTPUT MACS;
        MAC:INPUT +2 TSYSMOD $8. @;
            IF TSYSMOD ^= '        ' THEN DO;
            *  END OF PAGE AND HEADER TO BE IGNORE;
               IF TSYSMOD = 'GIMS' THEN DO;
        MACPGE:INPUT; INPUT @30 TSYSMOD $8. @;
                IF TSYSMOD = '     ' THEN GO TO MACPGE;
                   ELSE DO; INPUT @28 XEQU $1. @28 @;
                    IF XEQU = '=' THEN RETURN; ELSE GO TO MAC;
                    END; END;
               OUTPUT SMPE; NCNT+1;
        ASYSMOD = TSYSMOD; ASYSNUM=1; ATYPE='MAC'; OUTPUT MACS;
               IF NCNT = 9 THEN DO; NCNT=0;
                  INPUT; INPUT @28 XEQU $1. @28 @;
                  IF XEQU = '=' THEN RETURN;
                     ELSE GO TO MAC;
                   END;
                GO TO MAC;
                END; ELSE DO;TSYSMOD=' '; INPUT; RETURN; END;
         END;
 *---------------- MOD    ---------------------------------;
     IF TTATUS = 'MOD  ' THEN DO;
        RECTYPE= 'MOD';
        NCNT=1; INPUT @30 TSYSMOD $8. @;
        OUTPUT SMPE;
        ASYSMOD = TSYSMOD; ASYSNUM=1; ATYPE='MOD'; OUTPUT MODS;
        MOD:INPUT +2 TSYSMOD $8. @;
            IF TSYSMOD ^= '        ' THEN DO;
            *  END OF PAGE AND HEADER TO BE IGNORE;
               IF TSYSMOD = 'GIMS' THEN DO;
        MODPGE:INPUT; INPUT @30 TSYSMOD $8. @;
                IF TSYSMOD = '     ' THEN GO TO MODPGE;
                   ELSE DO; INPUT @28 XEQU $1. @28 @;
                    IF XEQU = '=' THEN RETURN; ELSE GO TO MOD;
                    END; END;
               OUTPUT SMPE; NCNT+1;
        ASYSMOD = TSYSMOD; ASYSNUM=1; ATYPE='MOD'; OUTPUT MODS;
               IF NCNT = 9 THEN DO; NCNT=0;
                  INPUT; INPUT @28 XEQU $1. @28 @;
                  IF XEQU = '=' THEN RETURN;
                     ELSE GO TO MOD;
                   END;
                GO TO MOD;
                END; ELSE DO;TSYSMOD=' '; INPUT; RETURN; END;
         END;
 *---------------- SRC    ---------------------------------;
     IF TTATUS = 'SRC  ' THEN DO;
        RECTYPE= 'SRC';
        NCNT=1; INPUT @30 TSYSMOD $8. @;
        OUTPUT SMPE;
        ASYSMOD = TSYSMOD; ASYSNUM=1; ATYPE='SRC'; OUTPUT SRCS;
        SRC:INPUT +2 TSYSMOD $8. @;
            IF TSYSMOD ^= '        ' THEN DO;
            *  END OF PAGE AND HEADER TO BE IGNORE;
               IF TSYSMOD = 'GIMS' THEN DO;
        SRCPGE:INPUT; INPUT @30 TSYSMOD $8. @;
                IF TSYSMOD = '     ' THEN GO TO SRCPGE;
                   ELSE DO; INPUT @28 XEQU $1. @28 @;
                    IF XEQU = '=' THEN RETURN; ELSE GO TO SRC;
                    END; END;
               OUTPUT SMPE; NCNT+1;
        ASYSMOD = TSYSMOD; ASYSNUM=1; ATYPE='SRC'; OUTPUT SRCS;
               IF NCNT = 9 THEN DO; NCNT=0;
                  INPUT; INPUT @28 XEQU $1. @28 @;
                  IF XEQU = '=' THEN RETURN;
                     ELSE GO TO SRC;
                   END;
                GO TO SRC;
                END; ELSE DO;TSYSMOD=' '; INPUT; RETURN; END;
         END;
 *---------------- HOLDERROR ------------------------------;
     IF TTATUS = 'HOLDERR' THEN DO;
        RECTYPE= 'HERR';
        NCNT=1; INPUT @30 TSYSMOD $8. @;
        OUTPUT SMPE;
        ASYSMOD = TSYSMOD; ASYSNUM=1; ATYPE='HERR'; OUTPUT HOLDERR;
        ASYSMOD = SUBSTR(SYSMOD,1,7) ×× '#';
        ASYSNUM=1; ATYPE='HOLD'; OUTPUT PRES;
        HERR:INPUT +2 TSYSMOD $8. @;
            IF TSYSMOD ^= '        ' THEN DO;
            *  END OF PAGE AND HEADER TO BE IGNORE;
               IF TSYSMOD = 'GIMS' THEN DO;
        HERPGE:INPUT; INPUT @30 TSYSMOD $8. @;
                IF TSYSMOD = '     ' THEN GO TO HERPGE;
                   ELSE DO; INPUT @28 XEQU $1. @28 @;
                    IF XEQU = '=' THEN RETURN; ELSE GO TO HERR;
                    END; END;
               OUTPUT SMPE; NCNT+1;
        ASYSMOD = TSYSMOD; ASYSNUM=1; ATYPE='HERR'; OUTPUT HOLDERR;
               IF NCNT = 9 THEN DO; NCNT=0;
                  INPUT; INPUT @28 XEQU $1. @28  @;
                  IF XEQU = '=' THEN RETURN;
                     ELSE GO TO HERR;
                   END;
                GO TO HERR;
                END; ELSE DO; TSYSMOD=' ';INPUT; RETURN; END;
        END;
 *---------------- HOLDSYSTEM -----------------------------;
     IF TTATUS = 'HOLDSYS' THEN DO;
        RECTYPE= 'HSYS';
        INPUT @23 HSYSTYPE $3. @;
        NCNT=1; INPUT @30 TSYSMOD $8. @;
        OUTPUT SMPE;
        ASYSMOD = TSYSMOD; ASYSNUM=1; ATYPE='HSYS'; OUTPUT HOLDSYS;
        ASYSMOD = SUBSTR(SYSMOD,1,7) ×× '^';
        ASYSNUM=1; ATYPE='HOLD'; OUTPUT PRES;
        HSYS:INPUT +2 TSYSMOD $8. @;
            IF TSYSMOD ^= '        ' THEN DO;
            *  END OF PAGE AND HEADER TO BE IGNORE;
               IF TSYSMOD = 'GIMS' THEN DO;
        HSYPGE:INPUT; INPUT @30 TSYSMOD $8. @;
                IF TSYSMOD = '     ' THEN GO TO HSYPGE;
                   ELSE DO; INPUT @28 XEQU $1. @28 @;
                    IF XEQU = '=' THEN RETURN; ELSE GO TO HSYS;
                    END; END;
               OUTPUT SMPE; NCNT+1;
        ASYSMOD = TSYSMOD; ASYSNUM=1; ATYPE='HSYS'; OUTPUT HOLDSYS;
               IF NCNT = 9 THEN DO; NCNT=0;
                  INPUT; INPUT @28 XEQU $1. @28  @;
                  IF XEQU = '=' THEN RETURN;
                     ELSE GO TO HSYS;
                   END;
                GO TO HSYS;
                END; ELSE DO;
                     TSYSMOD=' ';HSYSTYPE= ' ';INPUT;RETURN; END;
      END;
      DROP TTATUS NCNT  DT NYPE LASTYPE ;
  *---------------- STATUS  ------------------------;
     IF TTATUS = 'STATUS' THEN DO ;
        INPUT @30 STATUS $15. ;
          RETURN ;
          END ;
 *---------------- FMID   ---------------------------------;
     IF TTATUS = 'FMID' THEN DO ;
           INPUT @30 FMID $8. ;
          RETURN ;
          END ;
 *---------------- DATE/TIME ------------------------------;
     IF TTATUS = 'DATE/TI' THEN DO ;
           INPUT @12 DT $9. @ ;
           IF DT = 'DATE/TIME' THEN DO ;
             INPUT @22 ACTION $3. @30 YEAR 2.@33 DAY 3.@38 TIME TIME8.;
              IF YEAR > 79 AND DAY < 366  THEN DO;
                 *** THIS SELECTS A RANGE OF DATES **** ;
                 DATE = YEAR*1000 + DAY ;
                 DATE = DATEJUL(DATE) ;
                 END;
              IF ACTION = 'REC' THEN RECDATE= DATE;
              IF ACTION = 'APP' THEN APPDATE= DATE;
              IF ACTION = 'ACC' THEN ACCDATE= DATE;
              RETURN;
              END;
     END ; ELSE DO ; INPUT ; RETURN ; END ;
   RETURN ;
PROC SORT DATA=PRES   ; BY FMID ATYPE ASYSMOD SYSMOD;
PROC SORT DATA=REQS   ; BY FMID ATYPE ASYSMOD SYSMOD;
PROC SORT DATA=SUPING ; BY FMID ATYPE ASYSMOD SYSMOD;
PROC SORT DATA=HOLDERR; BY FMID ATYPE ASYSMOD SYSMOD;
PROC SORT DATA=HOLDSYS; BY FMID ATYPE ASYSMOD SYSMOD;
PROC SORT DATA=RMID   ; BY FMID ATYPE ASYSMOD SYSMOD;
PROC SORT DATA=MACS   ; BY FMID ATYPE ASYSMOD SYSMOD;
PROC SORT DATA=MODS   ; BY FMID ATYPE ASYSMOD SYSMOD;
PROC SORT DATA=SRCS   ; BY FMID ATYPE ASYSMOD SYSMOD;
DATA ASYSMOD;
  MERGE RMID MACS MODS SRCS;
     BY FMID ATYPE ASYSMOD SYSMOD;
DATA SYSMODX;
  MERGE  PRES REQS SUPING;
     BY FMID ATYPE ASYSMOD SYSMOD;
DATA HOLDS;
  MERGE   HOLDERR HOLDSYS;
     BY FMID ATYPE ASYSNUM ASYSMOD SYSMOD;
PROC SORT DATA=ASYSMOD; BY FMID ATYPE ASYSMOD SYSMOD;
PROC SORT DATA=HOLDS  ; BY FMID ATYPE ASYSMOD SYSMOD;
PROC SORT DATA=SYSMODX; BY FMID ATYPE ASYSMOD SYSMOD;
DATA ALLMODS;
  MERGE ASYSMOD HOLDS SYSMODX;
     BY FMID ATYPE ASYSMOD SYSMOD;
PROC SORT DATA=ALLMODS; BY FMID SYSMOD ATYPE ASYSMOD;
DATA _NULL_;
* SAS PROGRAM TO LIST ALL PRE WITH SYSMODS FROM SMPE ;
OPTIONS MISSING=' ';
**  DEFINE INPUT FILE;
SET ALLMODS END=EOF; BY FMID SYSMOD ATYPE ASYSMOD ;
**  RETAIN  ;
RETAIN PTR 20;
FILE PRINT HEADER=ALLMODS NOTITLES;
IF FMID = '   ' THEN DELETE;
IF   EOF   THEN PUT;
IF   FIRST.FMID THEN DO;
IF FMID ^= '   ' THEN
PUT _PAGE_;
PTR=20;
END;
IF FIRST.ATYPE   THEN DO;
   PUT;
   IF FIRST.SYSMOD THEN DO;
      STA=' '; STA2=' ';
      IF STATUS = 'REC  ACC  RGN' THEN STA='*';
      IF STATUS = 'REC  APP '     THEN STA2='$';
      PUT  @1 SYSMOD $CHAR8. STA STA2 @12 ATYPE @; END;
      ELSE PUT @12 ATYPE @;
   PTR=20; END;
 IF FIRST.ASYSMOD THEN DO;
  PUT @PTR ASYSMOD $8. @; PTR+10;
  IF PTR > 106 THEN DO; PUT ; PTR=20; END;
  END;
  RETURN;
ALLMODS:
PUT  FMID=
@30 ' LISTING BY SYSMOD '
' (STATUS: *=ACC $=APP; SUFFIX: #=HOLDERR ^=HOLDSYS)' ;
RETURN;
PROC SORT DATA=ALLMODS; BY FMID ASYSMOD ATYPE SYSMOD;
DATA _NULL_;
* SAS PROGRAM TO LIST ALL PRE WITH SYSMODS FROM SMPE ;
OPTIONS MISSING=' ';
**  DEFINE INPUT FILE;
SET ALLMODS END=EOF; BY FMID ASYSMOD ATYPE SYSMOD ;
**  RETAIN  ;
RETAIN PTR 20;
FILE PRINT HEADER=ALLMODS NOTITLES;
IF FMID = '   ' THEN DELETE;
IF   EOF   THEN PUT;
IF   FIRST.FMID THEN DO;
IF FMID ^= '   ' THEN
PUT _PAGE_;
PTR=20;
END;
IF FIRST.ATYPE   THEN DO;
   PUT;
   IF FIRST.ASYSMOD THEN DO;
      STA=' '; STA2= ' ';
      IF STATUS = 'REC  ACC  RGN' THEN STA='*';
      IF STATUS = 'REC  APP '     THEN STA='$';
      PUT  @1 ASYSMOD $CHAR8. STA STA2  @12 ATYPE @; END;
      ELSE PUT @12 ATYPE @;
   PTR=20; END;
 IF FIRST.SYSMOD THEN DO;
  PUT @PTR SYSMOD $8. @; PTR+10;
  IF PTR > 106 THEN DO; PUT ; PTR=20; END;
  END;
  RETURN;
ALLMODS: PUT  FMID=
@30 ' LISTING BY ASYSMOD/MAC/MOD/ETC '
' (STATUS: *=ACC $=APP; SUFFIX: #=HOLDERR ^=HOLDSYS)' ;
  RETURN;
* DOR DOR DOR ;
PROC SORT   DATA=PRES; BY FMID DESCENDING ASYSMOD SYSMOD;
DATA ACCEPT (KEEP= FMID ATYPE ASYSMOD ASYSNUM)
     ACNPRE (KEEP= FMID ATYPE ASYSMOD ASYSNUM);
LENGTH FMID $8 ATYPE $4 ASYSMOD $8 ASYSNUM 4;
LENGTH SYSMOD $8 ;
RETAIN PRESWT 0 SYSMOD ' ';
* SAS PROGRAM TO PRINT ALL PRE WITH ACCEPT FROM SMPE ;
OPTIONS MISSING=' ';
**  DEFINE INPUT FILE;
SET PRES END=EOF; BY FMID DESCENDING ASYSMOD SYSMOD;
**  DEFINE ARRAYS OF TABLES;
**---- ACC TABLE ---- **;
ARRAY ACC   (PX) $8 ACC1-ACC200;
ARRAY ACN   (PX)  ACN1-ACN200;
**----  TABLE ---- **;
ARRAY TAB1  (SX) $8  KA1-KA100;
ARRAY TAB2  (SX) $8  KB1-KB100;
ARRAY TAB3  (SX) $8  KC1-KC100;
ARRAY TAB4  (SX) $8  KD1-KD100;
ARRAY TAB5  (SX) $8  KE1-KE100;
ARRAY TAB6  (SX) $8  KF1-KF100;
ARRAY TAB7  (SX) $8  KG1-KG100;
ARRAY TAB8  (SX) $8  KH1-KH100;
ARRAY TAB9  (SX) $8  KI1-KI100;
ARRAY TAB10 (SX) $8  KJ1-KJ100;
ARRAY TAB11 (SX) $8  KK1-KK100;
ARRAY TAB12 (SX) $8  KL1-KL100;
ARRAY TAB13 (SX) $8  KM1-KM100;
ARRAY TAB14 (SX) $8  KN1-KN100;
ARRAY TAB15 (SX) $8  KO1-KO100;
ARRAY TAB16 (SX) $8  KP1-KP100;
ARRAY TABX  (SS)  TAB1-TAB16;
**  RETAIN ARRAYS ;
RETAIN ACCCNT PXCNT TOTCNT
ACN1-ACN200  PFX 0
ATYPE 'ACC'
ACC1-ACC200
KA1-KA100 KB1-KB100 KC1-KC100 KD1-KD100 KE1-KE100 KF1-KF100
KG1-KG100 KH1-KH100
KI1-KI100 KJ1-KJ100 KK1-KK100 KL1-KL100 KM1-KM100 KN1-KN100
KO1-KO100 KP1-KP100 '    ';
**  EOF PROCESSING ;
FILE PRINT NOTITLES;
IF  (LAST.FMID × EOF) THEN DO;
ATYPE='ACC';
IF (FMID ^= '    ' & ACCCNT ^= 0 ) THEN DO;
PUT / FMID=
 ' ACCEPT AND PRE  LISTING BY SYSMOD '
' (SUFFIX: #=HOLDERR ^=HOLDSYS) '
  ACCCNT= PXCNT=; ACCCNT=0; PXCNT=0;
DO OVER TABX;
  DO SS=1 TO 16;
    PTR=6;
    DO SX=1 TO 100;
    IF TABX = '    ' THEN DO;
     IF SX = 1 THEN SX=100;
        ELSE DO;
        PUT; SX=100; END;
     END;
       ELSE DO;
         IF SX=1 THEN PUT ' ACC>' @;
         PUT @PTR TABX $8. @;
         ASYSMOD=TABX; ASYSNUM=SS;OUTPUT ACCEPT;
         TOTCNT+1;
         PTR+10;
         IF PTR > 76 THEN DO; PUT; PTR=6; END;
         END;
     END;
   END;
   PUT TOTCNT=; TOTCNT=0;
   * ERASE TABLE FOR NEXT FMID;
   DO SS=1 TO 16;
   DO SX=1 TO 100;
   TABX= '     '; END;END;
   DO PX=1 TO 200;
    ACN=0;ACC='   ';END;
END;
PUT //;
PFX=0;
END;
END;
**  ESTABLISH INPUT AND OUTPUT FILE;
IF STATUS ^= 'REC  ACC  RGN ' THEN DELETE;
IF LAST.SYSMOD THEN DO;
   IF (ATYPE ^= 'PRES' & ASYSMOD ^= ' ' & PRESWT = 0) THEN DO;
*  PUT PRESWT= FMID= ATYPE= SYSMOD= ASYSMOD=;
   ASYSNUM=1; ASYSMOD=SYSMOD; ATYPE='ACNP';
   OUTPUT ACNPRE; END;
   ELSE PRESWT=0; END;
IF (ATYPE = 'PRES' × ATYPE = 'HOLD') THEN DO;
 IF ATYPE = 'PRES' THEN PRESWT=1;
* PUT 'REC: '  ASYSMOD=  SYSMOD=;
SWFX=0;
DO OVER TABX;
*------ SEARCH OF MATCHED SYSMOD;
  DO SS=1 TO 16;
   DO SX=1 TO 100;
      IF TABX = '      ' THEN SX=100;
      IF TABX = SYSMOD  THEN DO;
         PFX=SS; SWFX=1;
*        PUT 'TAB: '  SYSMOD=  TABX=  SS= SX= PFX= ;
         SS=16; SX=100; END;
      ELSE DO;
        IF (ASYSMOD ^= 'HOLDERR' & ASYSMOD ^= 'HOLDSYS') THEN DO;
           IF TABX = ASYSMOD  THEN DO;
           PFX=SS; SWFX=2;
 *         PUT 'TAB2: ' ASYSMOD=  TABX=  SS= SX= PFX= ;
           SS=16; SX=100; END;
        END;
      END;
   END;
  END;
*------ BUILT  UNMATCHED SYSMOD;
DO PX=1 TO 200;
IF ACC = '      ' THEN DO;
     ACC=SYSMOD;
     ACCCNT+1;
     IF SWFX = 0 THEN DO; PXCNT+1; PFX+1; END;
     ACN=PFX; END;
IF ACC = SYSMOD  THEN DO;
   SS=ACN;
   DO SX=1 TO 100;
      IF TABX = '      ' THEN TABX=SYSMOD;
      IF TABX = SYSMOD  THEN DO;
  *      PUT 'TAB1: '  SYSMOD=  ACC= TABX= PX= SS= SX= PFX= ACN=;
         SX=100; END;
   END;
   DO SX=1 TO 100;
      IF TABX = '      ' THEN TABX=ASYSMOD;
      IF TABX = ASYSMOD   THEN DO;
*        PUT 'TAB2: '  ASYSMOD=  ACC= TABX= PX= SS= SX= PFX= ACN=;
         SX=100; END;
   END;
  PX=200;
  END;
 END;
  DO PX=1 TO 200;
   IF ACC = '      ' THEN DO; ACC=ASYSMOD; ACCCNT+1; ACN=PFX; END;
   IF ACC = ASYSMOD   THEN DO;
*        PUT 'PXB2: '  ASYSMOD=  ACC=  PX= SS= SX= PFX= ACN=;
         PX=200;
         END;
  END;
 SS=16; SX=100;
END;
END;
RETURN;
* SAS PROGRAM TO PRINT ALL PRE WITH APPLY FROM SMPE ;
DATA APPLY (KEEP= FMID ATYPE ASYSMOD ASYSNUM)
     APNPRE(KEEP= FMID ATYPE ASYSMOD ASYSNUM);
LENGTH FMID $8 ATYPE $4 ASYSMOD $8 ASYSNUM 4;
LENGTH SYSMOD $8;
RETAIN PRESWT 0 SYSMOD ' ';
OPTIONS MISSING=' ';
**  DEFINE INPUT FILE;
SET PRES END=EOF; BY FMID DESCENDING  ASYSMOD SYSMOD;
**  DEFINE ARRAYS OF TABLES;
**---- APP TABLE ---- **;
ARRAY APP   (PX) $8 APP1-APP200;
ARRAY APN   (PX)  APN1-APN200;
**----  TABLE ---- **;
ARRAY TAB1  (SX) $8  KA1-KA100;
ARRAY TAB2  (SX) $8  KB1-KB100;
ARRAY TAB3  (SX) $8  KC1-KC100;
ARRAY TAB4  (SX) $8  KD1-KD100;
ARRAY TAB5  (SX) $8  KE1-KE100;
ARRAY TAB6  (SX) $8  KF1-KF100;
ARRAY TAB7  (SX) $8  KG1-KG100;
ARRAY TAB8  (SX) $8  KH1-KH100;
ARRAY TAB9  (SX) $8  KI1-KI100;
ARRAY TAB10 (SX) $8  KJ1-KJ100;
ARRAY TAB11 (SX) $8  KK1-KK100;
ARRAY TAB12 (SX) $8  KL1-KL100;
ARRAY TAB13 (SX) $8  KM1-KM100;
ARRAY TAB14 (SX) $8  KN1-KN100;
ARRAY TAB15 (SX) $8  KO1-KO100;
ARRAY TAB16 (SX) $8  KP1-KP100;
ARRAY TABX  (SS)  TAB1-TAB16;
**  RETAIN ARRAYS ;
RETAIN APPCNT PXCNT  TOTCNT
APN1-APN200  PFX 0
ATYPE 'APP'
APP1-APP200
KA1-KA100 KB1-KB100 KC1-KC100 KD1-KD100 KE1-KE100 KF1-KF100
KG1-KG100 KH1-KH100
KI1-KI100 KJ1-KJ100 KK1-KK100 KL1-KL100 KM1-KM100 KN1-KN100
KO1-KO100 KP1-KP100 '    ';
**  EOF PROCESSING ;
FILE PRINT NOTITLES;
IF (LAST.FMID × EOF) THEN DO;
ATYPE='APP';
IF (FMID ^= '   ' & APPCNT ^= 0) THEN DO;
PUT / FMID=
 ' APPLY AND PRE  LISTING BY SYSMOD '
' (SUFFIX: #=HOLDERR ^=HOLDSYS) '
 APPCNT= PXCNT=;APPCNT=0; PXCNT=0;
DO OVER TABX;
  DO SS=1 TO 16;
    PTR=6;
    DO SX=1 TO 100;
    IF TABX = '    ' THEN DO;
     IF SX = 1 THEN SX=100;
        ELSE DO;
        PUT; SX=100; END;
     END;
       ELSE DO;
         IF SX=1 THEN PUT ' APP>' @;
         PUT @PTR TABX $8. @;
         ASYSMOD=TABX; ASYSNUM=SS;OUTPUT APPLY;
         TOTCNT+1;
         PTR+10;
         IF PTR > 76 THEN DO; PUT; PTR=6; END;
         END;
     END;
   END;
   PUT TOTCNT=; TOTCNT=0;
   * ERASE TABLE FOR NEXT FMID;
   DO SS=1 TO 16;
   DO SX=1 TO 100;
   TABX= '     '; END;END;
   DO PX=1 TO 200;
    APN=0;APP='   ';END;
END;
PUT //  ;
PFX=0;
END;
END;
**  ESTABLISH INPUT AND OUTPUT FILE;
IF STATUS ^= 'REC  APP ' THEN DELETE;
IF LAST.SYSMOD THEN DO;
   IF (ASYSMOD ^= ' ' & PRESWT = 0) THEN DO;
*  PUT PRESWT= ATYPE= SYSMOD= ASYSMOD=;
   ASYSNUM=1; ASYSMOD=SYSMOD; ATYPE='APNP';
   OUTPUT APNPRE; END;
   ELSE PRESWT=0; END;
IF (ATYPE = 'PRES' × ATYPE = 'HOLD' ) THEN DO;
 IF ATYPE = 'PRES' THEN PRESWT=1;
*  PUT 'REC: '  ASYSMOD=  SYSMOD=;
SWFX=0;
DO OVER TABX;
*------ SEARCH OF MATCHED SYSMOD;
  DO SS=1 TO 16;
   DO SX=1 TO 100;
      IF TABX = '      ' THEN SX=100;
      IF TABX = SYSMOD  THEN DO;
         PFX=SS; SWFX=1;
 *        PUT 'TAB: '  SYSMOD=  TABX=  SS= SX= PFX= ;
         SS=16; SX=100; END;
      ELSE DO;
        IF (ASYSMOD ^= 'HOLDERR' & ASYSMOD ^= 'HOLDSYS')  THEN DO;
        IF TABX = ASYSMOD  THEN DO;
           PFX=SS; SWFX=1;
  *        PUT 'TAB: ' ASYSMOD=  TABX=  SS= SX= PFX= ;
           SS=16; SX=100; END;
      END;
     END;
   END;
  END;
*------ BUILT  UNMATCHED SYSMOD;
DO PX=1 TO 200;
IF APP = '      ' THEN DO;
     APP=SYSMOD;
     APPCNT+1;
     IF SWFX = 0 THEN DO; PXCNT+1; PFX+1; END;
     APN=PFX; END;
IF APP = SYSMOD  THEN DO;
   SS=APN;
   DO SX=1 TO 100;
      IF TABX = '      ' THEN TABX=SYSMOD;
      IF TABX = SYSMOD  THEN DO;
   *     PUT 'TAB1: '  SYSMOD=  APP= TABX= PX= SS= SX= PFX= APN=;
         SX=100; END;
   END;
   DO SX=1 TO 100;
      IF TABX = '      ' THEN TABX=ASYSMOD;
      IF TABX = ASYSMOD   THEN DO;
    *    PUT 'TAB2: '  ASYSMOD=  APP= TABX= PX= SS= SX= PFX= APN=;
         SX=100; END;
   END;
  PX=200;
  END;
 END;
  DO PX=1 TO 200;
   IF APP = '      ' THEN DO; APP=ASYSMOD; APPCNT+1; APN=PFX; END;
   IF APP = ASYSMOD   THEN PX=200;
  END;
 SS=16; SX=100;
END;
END;
RETURN;
* SAS PROGRAM TO PRINT ALL PRE  WITH HOLDDATA FROM SMPE ;
DATA PREALL (KEEP= FMID ATYPE ASYSMOD ASYSNUM);
LENGTH FMID $8 ATYPE $4 ASYSMOD $8 ASYSNUM 4;
LENGTH SYSMOD $8 ;
OPTIONS MISSING=' ';
**  DEFINE INPUT FILE;
SET PRES END=EOF; BY FMID DESCENDING ASYSMOD SYSMOD;
**  DEFINE ARRAYS OF TABLES;
**---- PRE TABLE ---- **;
ARRAY PRE   (PX) $8 PRE1-PRE200;
ARRAY PRN   (PX)  PRN1-PRN200;
**----  TABLE ---- **;
ARRAY TAB1  (SX) $8  KA1-KA80;
ARRAY TAB2  (SX) $8  KB1-KB80;
ARRAY TAB3  (SX) $8  KC1-KC80;
ARRAY TAB4  (SX) $8  KD1-KD80;
ARRAY TAB5  (SX) $8  KE1-KE80;
ARRAY TAB6  (SX) $8  KF1-KF80;
ARRAY TAB7  (SX) $8  KG1-KG80;
ARRAY TAB8  (SX) $8  KH1-KH80;
ARRAY TAB9  (SX) $8  KI1-KI80;
ARRAY TAB10 (SX) $8  KJ1-KJ80;
ARRAY TAB11 (SX) $8  KK1-KK80;
ARRAY TAB12 (SX) $8  KL1-KL80;
ARRAY TAB13 (SX) $8  KM1-KM80;
ARRAY TAB14 (SX) $8  KN1-KN80;
ARRAY TAB15 (SX) $8  KO1-KO80;
ARRAY TAB16 (SX) $8  KP1-KP80;
ARRAY TAB17 (SX) $8  KQ1-KQ80;
ARRAY TAB18 (SX) $8  KR1-KR80;
ARRAY TAB19 (SX) $8  KS1-KS80;
ARRAY TAB20 (SX) $8  KT1-KT80;
ARRAY TAB21  (SX) $8  LA1-LA80;
ARRAY TAB22  (SX) $8  LB1-LB80;
ARRAY TAB23  (SX) $8  LC1-LC80;
ARRAY TAB24  (SX) $8  LD1-LD80;
ARRAY TAB25  (SX) $8  LE1-LE80;
ARRAY TAB26  (SX) $8  LF1-LF80;
ARRAY TAB27  (SX) $8  LG1-LG80;
ARRAY TAB28  (SX) $8  LH1-LH80;
ARRAY TAB29  (SX) $8  LI1-LI80;
ARRAY TAB30  (SX) $8  LJ1-LJ80;
ARRAY TAB31  (SX) $8  MA1-MA80;
ARRAY TAB32  (SX) $8  MB1-MB80;
ARRAY TAB33  (SX) $8  MC1-MC80;
ARRAY TAB34  (SX) $8  MD1-MD80;
ARRAY TAB35  (SX) $8  ME1-ME80;
ARRAY TAB36  (SX) $8  MF1-MF80;
ARRAY TAB37  (SX) $8  MG1-MG80;
ARRAY TAB38  (SX) $8  MH1-MH80;
ARRAY TAB39  (SX) $8  MI1-MI80;
ARRAY TAB40  (SX) $8  MJ1-MJ80;
ARRAY TABX  (SS)  TAB1-TAB40;
**  RETAIN ARRAYS ;
RETAIN PRECNT PXCNT TOTCNT
PRN1-PRN200  PFX 0
ATYPE 'PRE'
PRE1-PRE200
KA1-KA80 KB1-KB80 KC1-KC80 KD1-KD80 KE1-KE80 KF1-KF80 KG1-KG80
KH1-KH80 KI1-KI80 KJ1-KJ80 KK1-KK80 KL1-KL80 KM1-KM80 KN1-KN80
KO1-KO80 KP1-KP80 KQ1-KQ80 KR1-KR80 KS1-KS80 KT1-KT80 '    ';
RETAIN
LA1-LA80 LB1-LB80 LC1-LC80 LD1-LD80 LE1-LE80 LF1-LF80 LG1-LG80
LH1-LH80 LI1-LI80 LJ1-LJ80 '    ';
RETAIN
MA1-MA80 MB1-MB80 MC1-MC80 MD1-MD80 ME1-ME80 MF1-MF80 MG1-MG80
MH1-MH80 MI1-MI80 MJ1-MJ80 '    ';
**  EOF PROCESSING ;
FILE PRINT NOTITLES;
IF  (LAST.FMID × EOF) THEN DO;
IF (FMID ^= '    ' & PRECNT ^= 0) THEN DO;
PUT / FMID=
 ' ALL PRE AND HOLD LISTING BY SYSMOD '
' (SUFFIX: #=HOLDERR ^=HOLDSYS) '
 PRECNT= PXCNT=; PRECNT=0; PXCNT=0;
DO OVER TABX;
  DO SS=1 TO 40;
    PTR=6;
    DO SX=1 TO 80;
    IF TABX = '    ' THEN DO;
     IF SX = 1 THEN SX=80;
        ELSE DO;
        PUT; SX=80; END;
     END;
       ELSE DO;
         IF SX=1 THEN PUT ' PRE>' @;
         PUT @PTR TABX $8. @;
         ASYSMOD=TABX; ASYSNUM=SS;OUTPUT PREALL;
         TOTCNT+1;
         PTR+10;
         IF PTR > 76 THEN DO; PUT; PTR=6; END;
         END;
     END;
   END;
   PUT TOTCNT=; TOTCNT=0;
   * ERASE TABLE FOR NEXT FMID;
   DO SS=1 TO 40;
   DO SX=1 TO 80;
   TABX= '     '; END;END;
   DO PX=1 TO 200;
    PRN=0;PRE='   ';END;
END;
PUT // ;
PFX=0;
END;
END;
**  ESTABLISH INPUT AND OUTPUT FILE;
IF (ATYPE = 'PRES' × ATYPE = 'HOLD') THEN DO;
* PUT 'REC: '  ASYSMOD=  SYSMOD=;
SWFX=0;
DO OVER TABX;
*------ SEARCH OF MATCHED SYSMOD;
  DO SS=1 TO 40;
   DO SX=1 TO 80;
      IF TABX = '      ' THEN SX=80;
      IF TABX = SYSMOD  THEN DO;
         PFX=SS; SWFX=1;
*        PUT 'TAB: '  SYSMOD=  TABX=  SS= SX= PFX= ;
         SS=40; SX=80; END;
      ELSE DO;
        IF (ASYSMOD ^= 'HOLDERR' & ASYSMOD ^= 'HOLDSYS') THEN DO;
        IF TABX = ASYSMOD  THEN DO;
           PFX=SS; SWFX=1;
*          PUT 'TAB: '  ASYSMOD=  TABX=  SS= SX= PFX= ;
           SS=40; SX=80; END;
      END;
    END;
   END;
  END;
*------ BUILT  UNMATCHED SYSMOD;
DO PX=1 TO 200;
IF PRE = '      ' THEN DO;
     PRE=SYSMOD;
     PRECNT+1;
     IF SWFX = 0 THEN DO; PXCNT+1; PFX+1; END;
     PRN=PFX; END;
IF PRE = SYSMOD  THEN DO;
   SS=PRN;
   DO SX=1 TO 80;
      IF TABX = '      ' THEN TABX=SYSMOD;
      IF TABX = SYSMOD  THEN DO;
*        PUT 'TAB1: '  SYSMOD=  PRE= TABX= PX= SS= SX= PFX= PRN=;
         SX=80; END;
   END;
   DO SX=1 TO 80;
      IF TABX = '      ' THEN TABX=ASYSMOD;
      IF TABX = ASYSMOD   THEN DO;
*        PUT 'TAB2: '  ASYSMOD=  PRE= TABX= PX= SS= SX= PFX= PRN=;
         SX=80; END;
   END;
  PX=200;
  END;
 END;
  DO PX=1 TO 200;
   IF PRE = '      ' THEN DO; PRE=ASYSMOD; PRECNT+1; PRN=PFX; END;
   IF PRE = ASYSMOD   THEN PX=200;
  END;
 SS=40; SX=80;
END;
END;
RETURN;
PROC SORT DATA=ACCEPT ; BY FMID ATYPE ASYSNUM ASYSMOD;
PROC SORT DATA=APPLY  ; BY FMID ATYPE ASYSNUM ASYSMOD;
PROC SORT DATA=ACNPRE ; BY FMID ATYPE ASYSNUM ASYSMOD;
PROC SORT DATA=APNPRE ; BY FMID ATYPE ASYSNUM ASYSMOD;
PROC SORT DATA=PREALL ; BY FMID ATYPE ASYSNUM ASYSMOD;
DATA SYSMODS;
  MERGE ACCEPT APPLY PREALL;
     BY FMID ATYPE ASYSNUM ASYSMOD;
DATA NOPRES;
  MERGE  ACNPRE APNPRE;
     BY FMID ATYPE ASYSNUM ASYSMOD;
PROC SORT DATA=SYSMODS; BY FMID ATYPE ASYSNUM ASYSMOD;
DATA _NULL_;
* SAS PROGRAM TO LIST ALL PRE WITH SYSMODS FROM SMPE ;
OPTIONS MISSING=' ';
**  DEFINE INPUT FILE;
SET SYSMODS END=EOF; BY FMID ATYPE ASYSNUM ASYSMOD;
**  RETAIN  ;
RETAIN PTR 6;
FILE PRINT HEADER=SYSMOD NOTITLES;
LENGTH TITLE $60;
IF  EOF   THEN PUT;
IF  FIRST.ATYPE  THEN DO;
IF ATYPE = 'ACC ' THEN TITLE = ' ACCEPT AND PRE LISTING ';
IF ATYPE = 'APP ' THEN TITLE = ' APPLY AND PRE LISTING ';
IF ATYPE = 'PRES' THEN TITLE = ' ALL  PRE LISTING WITH BACK SYSMODS';
IF FMID ^= '    ' THEN
PUT _PAGE_;
PTR=6;
END;
IF FIRST.ASYSNUM THEN DO;PUT; PUT  @1 ASYSNUM @; PTR=6; END;
  PUT @PTR ASYSMOD $8. @;
  PTR+10;
  IF PTR > 76 THEN DO; PUT  ; PTR=6; END;
  RETURN;
SYSMOD:
    PUT // FMID= @30 TITLE / ;
  RETURN;
PROC SORT DATA=NOPRES; BY FMID ATYPE ASYSNUM ASYSMOD;
DATA _NULL_;
* SAS PROGRAM TO LIST ALL PRE WITH SYSMODS FROM SMPE ;
OPTIONS MISSING=' ';
**  DEFINE INPUT FILE;
SET NOPRES END=EOF; BY FMID ATYPE ASYSNUM ASYSMOD;
**  RETAIN  ;
RETAIN PTR 6;
FILE PRINT HEADER=NOPRE NOTITLES;
LENGTH TITLE $60;
IF  EOF   THEN PUT;
IF  FIRST.ATYPE  THEN DO;
IF ATYPE = 'ACNP' THEN TITLE = ' ACCEPT WITH NO PRE LISTING ';
IF ATYPE = 'APNP' THEN TITLE = ' APPLY WITH NO PRE LISTING ';
IF FMID ^= '    ' THEN
    PUT _PAGE_;
PTR=6;
END;
IF FIRST.ASYSNUM THEN DO;PUT; PUT  @1 ASYSNUM @; PTR=6; END;
  IF FIRST.ASYSMOD THEN DO;
  PUT @PTR ASYSMOD $8. @;
  PTR+10;
  IF PTR > 76 THEN DO; PUT  ; PTR=6; END;
  END;
  RETURN;
NOPRE:
    PUT // FMID= @30 TITLE / ;
  RETURN;
./       ADD   NAME=PTFSAST
//DORSASPT JOB (XXXX,,9999),'SAS PTF',
//         CLASS=A,MSGCLASS=A,NOTIFY=DOR
//JOBCAT DD DSN=CATALOG.NCPVSM1.VVTAM01,DISP=SHR
//LST1    EXEC PGM=GIMSMP,REGION=4096K,       SMP/E
//             PARM='DATE=U'
//SMPCSI   DD  DSN=NCPD21DS.GLOBAL.CSI,DISP=SHR
//SMPOUT   DD  SYSOUT=*
//SMPRPT   DD  SYSOUT=*
//SMPLIST  DD  DSN=&&PTSRPT,UNIT=SYSDA,DISP=(,PASS),
//  DCB=(LRECL=121,RECFM=FB,BLKSIZE=9438),SPACE=(TRK,(50,20))
//SYSPRINT DD  SYSOUT=*
//SMPCNTL  DD  *
  SET BOUNDARY(GLOBAL) .               /* GLOBAL ZONE LIBRARIES */
  LIST FORFMID(HNC2100)
          SYSMODS  ALLZONES MAC MOD SRC.
/*
//*
//*  SAS PROGRAM TO READ OUTPUT OF SMPE "LIST SYSMODS PTF."
//*  USE YOUR SMPE PROC, OVERRIDING THE SMPLIST DDNAME
//*  SORT THE OUTPUT IN ANY MANNER, OR SELECT JUST
//*  FMIDS THAT YOU NEED.
//*  PICK OFF RANGES OF DATES, OR WHATEVER
//* ORIGIN: JIM OLEKSIW, NORTHEAST UTILITIES SERVICE COMPANY
//*                     P.O. BOX 270 HARTFORD, CONNECTICUT  06101
//*              (USED WITH SMP4)
//*-------------------------------------------------------------
//* REMODIFY: DAVE RIKER, COMPUTER DATA SYSTEMS, INC
//*                     ONE CURIE COURT, ROCKVILLE, MD 20850
//*-------------------------------------------------------------
//S1  EXEC SAS,REGION=1500K
//SMPELIST  DD DSN=&&PTSRPT,DCB=(LRECL=121,BLKSIZE=9438,RECFM=FB),
//            DISP=(OLD,PASS),UNIT=SYSDA
//FT12F001 DD SYSOUT=A
//SYSOUT   DD SYSOUT=A
//SYSIN DD  DSN=C6000A.DOR.PTFLIB(PTFSASL4),DISP=SHR,UNIT=3350
