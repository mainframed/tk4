AIRW     TITLE 'ACCOUNTING INFORMATION DATA-SET FULL PACKAGE.'
ZOPEN    START 0
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* * * * * * * * *                                     * * * * * * * * *
* * * * * * * * *       ACCOUNTING INFORMATION        * * * * * * * * *
* * * * * * * * *                                     * * * * * * * * *
* * * * * * * * *       DATA-SET FULL PACKAGE         * * * * * * * * *
* * * * * * * * *                                     * * * * * * * * *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
* AUTHOR :     P.A. MOINIL                                            *
* --------     COMPUTING CENTRE                                       *
*              J.R.C. - ISPRA ESTABLISHMENT                           *
*              21020 ISPRA (VA), ITALY                                *
*                                                                     *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*                                                                     *
* PURPOSE :    THIS IS THE FULL OPERATIONAL PACKAGE AVAILABLE         *
* ---------    TO MAINTAIN AND MANAGE DATA IN THE ACCOUNTING          *
*              INFORMATION DATA-SET, WHICH IS ACCESSED THROUGH        *
*              A DD-CARD CODED AS BELOW :                             *
*                                                                     *
*              //SYSACC   DD  DSN=...,DISP=SHR                        *
*                                          OLD                        *
*                                                                     *
*        N.B. - THE KEY (ARGUMENT OR INDEX) LENGTH IS ASSUMED TO      *
*               BE TWO BYTES (HALFWORD) LONG, AND MAY OR NOT BE       *
*               INCLUDED IN THE ACCOUNTING INFORMATIONS RECORD.       *
*                                                                     *
* MVS/XA :     MUST BE AMODE AND RMODE 24.                            *
* --------                                                            *
*                                                                     *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
         EJECT
* CALLING SEQUENCE : CALL ZOPEN,(A,B),VL
* ------------------            (A)
*
*        WHERE : A - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F
*                    BOUNDARY). VALUE IS ALWAYS PLACED IN REGISTER 15
*                    AND CAN BE :
*                    0 (ZERO) - THE DATA-SET IS CORRECTLY OPENED.
*                    + (POSITIVE) - ERROR NUMBER. THE DATA-SET IS
*                                   NOT OPENED.
*
*                B - IS THE EVENTUAL FOLLOWING KEYWORD (FORMAT CL4) :
*                    'DUMP' TO REQUEST A DUMP ON ERROR DETECTED BY THE
*                           ROUTINES (SYSUDUMP OR SYSABEND DD-CARD MUST
*                           BE PRESENT). THIS OPTION IS EFFECTIVE UNTIL
*                           THE CLOSE, AND THE ERROR NUMBER IS SET AS
*                           ABEND CODE.
*                    'ONLY' TO BYPASS THE EXCLUSIVE ENQUEUE OF THE
*                           DATA-SET WHEN THESE ROUTINES ARE USED ONLY
*                           IN READ (NO UPDATES TAKE PLACE). SO THE
*                           ZWRITE AND ZDELET ARE DISABLED.
*                    'BOTH' TO HAVE BOTH PREVIOUS ACTIONS.
*
* CALLING SEQUENCE : CALL ZREAD,(A,B,C),VL
* ------------------ CALL ZWRITE,(A,B,C),VL
*
*        WHERE : A - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F
*                    BOUNDARY). VALUE IS ALWAYS PLACED IN REGISTER 15
*                    AND CAN BE :
*                    0 (ZERO) - THE DATA RECORD IS CORRECTLY READ OR
*                               WRITTEN.
*                    + (POSITIVE) - ERROR NUMBER.
*
*                B - IS THE ARGUMENT (FORMAT HALWORD - H BOUNDARY).
*
*                C - IS THE DATA RECORD AREA (FORMAT CL... - SEE MACRO
*                    '$AIRD' FOR LENGTH).
*
* CALLING SEQUENCE : CALL ZCLOSE,(A),VL
* ------------------
*
*        WHERE : A - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F
*                    BOUNDARY). VALUE IS ALWAYS PLACED IN REGISTER 15
*                    AND CAN BE :
*                    0 (ZERO) - THE DATA-SET IS CORRECTLY CLOSED.
*                    + (POSITIVE) - ERROR NUMBER.
         EJECT
* CALLING SEQUENCE : CALL ZSEQR,(A,B,C),VL
* ------------------            (A,B)
*
*        WHERE : A - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F
*                    BOUNDARY). VALUE IS ALWAYS PLACED IN REGISTER 15
*                    AND CAN BE :
*                    0 (ZERO) - THE DATA RECORD IS CORRECTLY READ.
*                    + (POSITIVE) - ERROR NUMBER.
*                    -1 (MINUS ONE) - END OF DATA (END-OF-FILE).
*
*                B - IS THE DATA RECORD AREA (FORMAT CL... - SEE MACRO
*                    '$AIRD' FOR LENGTH).
*
*                C - IS THE ARGUMENT, OPTIONAL (FORMAT HALFWORD -
*                    H BOUNDARY).
*
* CALLING SEQUENCE : CALL ZDELET,(A,B),VL
* ------------------
*
*        WHERE : A - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F
*                    BOUNDARY). VALUE IS ALWAYS PLACED IN REGISTER 15
*                    AND CAN BE :
*                    0 (ZERO) - THE DATA RECORD IS CORRECTLY DELETED.
*                    + (POSITIVE) - ERROR NUMBER.
*
*                B - IS THE ARGUMENT (FORMAT HALFWORD - H BOUNDARY).
*
* CALLING SEQUENCE : CALL ZSTATE,(A,B),VL
* ------------------
*
*        WHERE : A - IS THE INDICATOR RESPONSE (FORMAT FULLWORD - F
*                    BOUNDARY). VALUE IS ALWAYS PLACED IN REGISTER 15
*                    AND CAN BE :
*                    0 (ZERO) - THE DATA-SET STATUS AREA IS LOADED.
*                    + (POSITIVE) - ERROR NUMBER.
*
*                B - IS THE STATUS RESPONSE AREA (FORMAT CL... -
*                    FULLWORD BOUNDARY - SEE MACRO '$AIRD' FOR LENGTH
*                    AND DESCRIPTION).
         EJECT
* ERROR NUMBER :     1 - ROUTINE OR DATA-SET TABLE DESTROYED.
* --------------     2 - SYSACC DD-CARD IS MISSING.
*                    3 - SYSACC UNIT IS NOT A DIRECT-ACCESS STORAGE.
*                    4 - SYSACC JFCB READ ERROR.
*                    5 - SYSACC DD-CARD INCORRECTLY CODED.
*                    6 - OBTAIN ERROR WHILE PROCESSING SYSACC VOLUME.
*                    7 - SYSACC DSCB FORMAT 1 ERROR DETECTED.
*                    8 - SYSACC DATA BLOCK EXCEEDS TRACK CAPACITY.
*                    9 - SYSACC DATA-SET SPACE TOO SHORT.
*                   10 - SYSACC DATA-SET OPEN ERROR.
*                   11 - NO STORAGE AVAILABLE TO READ DATA-SET TABLE.
*                   12 - SYSACC DATA-SET I/O ERROR WHILE READING TABLE.
*                   13 - SYSACC DATA-SET IS ALREADY OPENED.
*                   14 - SYSACC DATA-SET IS NOT OPENED.
*                   15 - READ REQUEST - ARGUMENT NOT FOUND.
*                   16 - READ/WRITE REQUEST - I/O ERROR.
*                   17 - SYSACC DATA-SET FULL, CANNOT ADD RECORD.
*                   18 - SYSACC DATA-SET I/O ERROR WHILE WRITING TABLE.
*                   19 - ROUTINE CALLING SEQUENCE OR ARGUMENT ERROR.
*                   20 - SYSACC DATA-SET WRONGLY OR NOT CATALOGED.
*                   21 - SYSACC DATA-SET IN USE FOR UPDATE BY SOMEBODY.
*                   22 - ONLY OR BOTH REQUESTED - ZWRITE NOT AVAILABLE.
*                   23 - ONLY OR BOTH REQUESTED - ZDELET NOT AVAILABLE.
*                   24 - UNAUTHORIZED ACCESS.
*                   25 - UNAUTHORIZED ACCESS TO ZWRITE.
*                   26 - UNAUTHORIZED ACCESS TO ZDELET.
         EJECT
        $AIRD  STA=YES
         EJECT
        $DEFREG
         SPACE 1
*---------------------------------------------------------------------*
*        AUTHORITY LEVELS DEFINITIONS.                                *
*---------------------------------------------------------------------*
         SPACE 1
LV0      EQU   0         REJECT LEVEL
LV5      EQU   5         DISPLAY SERVICES LEVEL
         SPACE 1
AUT98   $MDL@IX
         SPACE 1
*        MISCELLANEOUS DEFINITIONS.
         SPACE 1
OFF      EQU   X'0F'               NOP OPERATION SWITCH SETTING.
ON       EQU   X'F0'               BRANCH OPERATION SWITCH SETTING.
UCB3DACC EQU   X'20'               DIRECT ACCESS DEVICE TYPE.
         EJECT
        IEZBITS
         SPACE 2
        PRINT  NOGEN
         SPACE 1
TIODSECT DSECT
        IEFTIOT1
         SPACE 1
JFCDSECT DSECT
        IEFJFCBN LIST=YES
         SPACE 1
DSCDSECT DSECT
        IECSDSL1 (1)
         SPACE 1
        DCBD   DSORG=DA,DEVD=DA
         SPACE 1
ZOPEN    CSECT                     RESTORE ORIGINAL CSECT.
         SPACE 1
        PRINT  GEN
         EJECT
         ENTRY ZREAD
         ENTRY ZWRITE
         ENTRY ZCLOSE
         ENTRY ZSEQR
         ENTRY ZDELET
         ENTRY ZSTATE
         SPACE 1
         USING *,R15
         MVI   WTGO+3,ZPACK-*      SET ENTRY DISPLACEMENT (OPEN).
         B     WTGO                GO COMMON ENTRY.
         DROP  R15
         SPACE 1
         USING *,R15
ZREAD    MVI   WTGO+3,ZPACK-*      SET ENTRY DISPLACEMENT (READ).
         B     WTGO                GO COMMON ENTRY.
         DROP  R15
         SPACE 1
         USING *,R15
ZWRITE   MVI   WTGO+3,ZPACK-*      SET ENTRY DISPLACEMENT (WRITE).
         B     WTGO                GO COMMON ENTRY.
         DROP  R15
         SPACE 1
         USING *,R15
ZCLOSE   MVI   WTGO+3,ZPACK-*      SET ENTRY DISPLACEMENT (CLOSE).
         B     WTGO                GO COMMON ENTRY.
         DROP  R15
         SPACE 1
         USING *,R15
ZSEQR    MVI   WTGO+3,ZPACK-*      SET ENTRY DISPLACEMENT (SEQ.READ).
         B     WTGO                GO COMMON ENTRY.
         DROP  R15
         SPACE 1
         USING *,R15
ZDELET   MVI   WTGO+3,ZPACK-*      SET ENTRY DISPLACEMENT (DELETE).
         B     WTGO                GO COMMON ENTRY.
         DROP  R15
         SPACE 1
         USING *,R15
ZSTATE   MVI   WTGO+3,ZPACK-*      SET ENTRY DISPLACEMENT (STATUS).
         DROP  R15
         SPACE 1
WTGO     LA    R15,*-*(R15)        SET COMMON ENTRY ADDRESS.
         EJECT
ZPACK   $XENT  BASE=(R11,R12)
         SPACE 1
         LH    R9,MAXERR           SET ERROR NUMBER REGISTER.
         MVC   INDRA,ZEROS         GET INDICATOR RESPONSE ADDRESS.
         TM    3(R1),X'03'
         BNZ   ERR19
         MVC   INDRA(4),0(R1)
         CLC   IND(L'INDTB),INDTB  CONTROL ROUTINE INTEGRITY.
         BNE   ERR1
         LR    R15,R11             COMPUTE WHERE TO GO?
         BCTR  R15,0
         XR    R14,R14
         IC    R14,0(R15)
         SRL   R14,1
         B     *+L'*-(ZPACK-WTGO)+L'IND(R14) ENTER SELECTED ROUTINE.
         SPACE 1
IND      DC    XL2'0F0F'           IDENTIFIER.
         SPACE 1
         B     STATS               BRANCH ENTRIES VECTOR.
         B     DELETE
         B     SEQR
         B     CLOSE
         B     WRITE
         B     READ
         EJECT
SWOPEN   NOP   OPEN
         LR    R2,R1               CHECK CALLER VALIDITY.
        $EACM  REQAUT
         LR    R1,R2
         CLI   AUTLVL,LV0
         BE    ERR24
         OI    SWOPEN+1,ON         CLOSE THIS WAY AFTER CONTROL DONE.
OPEN     NOP   ERR13               DATA-SET ALREADY OPENED.
         XC    NSEQ(L'NSEQ),NSEQ   RESET SEQUENTIAL READ.
         TM    0(R1),X'80'         IS THERE A SECOND PARM.
         BO    OP1                 BRANCH IF NOT.
         TM    4(R1),X'80'
         BZ    ERR19               TOO MANY ARGUMENTS.
         L     R2,4(R1)
         CLC   0(L'KDUMP,R2),KDUMP
         BE    *+L'*+10
         CLC   0(L'KBOTH,R2),KBOTH
         BNE   *+L'*+4
         NI    SWDP+1,OFF          SET DUMP SWITCH.
         CLC   0(L'KONLY,R2),KONLY
         BE    *+L'*+10
         CLC   0(L'KBOTH,R2),KBOTH
         BNE   OP1
         OI    SWONLY+1,ON         SET ONLY READ SWITCH.
         OI    SWWRITE+1,ON        SET WRITE SWITCH.
         OI    SWDELET+1,ON        SET DELETE SWITCH.
         OI    SWENQ+1,ON          SET ENQ SWITCH.
         OI    SWDEQ+1,ON          SET DEQ SWITCH.
         LA    R1,DCBSR
         USING IHADCB,R1
         NI    DCBMACR2,255-DCBMRWRT-DCBMRIDW     RESET BDAM WRITE.
         DROP  R1
OP1     EXTRACT ATIOT,'S',FIELDS=(TIOT)
         LA    R8,DCBSR            SEARCH SYSACC DD-CARD.
         USING IHADCB,R8
         L     R2,ATIOT            GET TIOT ADDRESS.
         USING TIODSECT,R2
OP2      CLC   TIOELNGH(L'ZEROS),ZEROS  TEST END OF TIOT,
         BE    ERR2                DD-CARD NOT FOUND.
         CLC   TIOEDDNM(L'DCBDDNAM),DCBDDNAM TEST DD NAME,
         BE    OP3                 BRANCH IF THIS ONE.
         XR    R1,R1
         IC    R1,TIOELNGH
         ALR   R2,R1               NEXT DD ENTRY.
         B     OP2
         DROP  R2
OP3     DEVTYPE DCBDDNAM,DVTYP,DEVTAB
         DROP  R8
         CLI   DVTYP+2,UCB3DACC    TEST DIRECT-ACCESS STORAGE,
         BNE   ERR3                BRANCH IF NOT.
        RDJFCB (DCBSR)
         LTR   R15,R15             TEST COMPLETION CODE.
         BNZ   ERR4
         LA    R7,JF
         USING JFCDSECT,R7
         TM    JFCBIND2,JFCMOD     TEST DISP=SHR OR OLD CODED?
         BO    ERR5                BRANCH IF NOT.
         TM    JFCBIND2,JFCOLD
         BZ    ERR5                BRANCH IF NOT.
         TM    JFCBTSDM,255-JFCCAT CONTROL SYSACC DD-CARD CODE.
         BNZ   ERR5
JL1      EQU   JFCBLTYP-JFCFCBID
         OC    JFCFCBID(JL1),JFCFCBID
         BNZ   ERR5
JL2      EQU   JFCBCRDT-JFCBOTTR
         OC    JFCBOTTR(JL2),JFCBOTTR
         BNZ   ERR5
JL3      EQU   JFCBIND2-JFCBXPDT
         OC    JFCBXPDT(JL3),JFCBXPDT
         BNZ   ERR5
JL4      EQU   JFCBNVOL-JFCBUFNO
         OC    JFCBUFNO(JL4),JFCBUFNO
         BNZ   ERR5
JL5      EQU   JFCBVLCT-JFCBPQTY
         OC    JFCBPQTY(JL5),JFCBPQTY
         BNZ   ERR5
         CLI   JFCBVLCT,X'01'
         BNE   ERR5
         CLI   JFCBLTYP,JFCSL
         BNE   ERR5
         CLI   JFCBNVOL,X'01'
         BNE   ERR5
         CLI   JFCBSPTN,X'00'
         BNE   ERR5
         MVC   VOLNUM(L'VOLNUM),JFCBVOLS
         MVC   DSNM(L'JFCBDSNM),JFCBDSNM
         TM    JFCBTSDM,JFCCAT     IS DATA-SET CATALOGED?
         BZ    ERR20               BRANCH IF NOT.
         DROP  R7
        LOCATE CVLIST
         LTR   R15,R15             TEST COMPLETION CODE.
         BNZ   ERR20
         CLC   VOLNUM(L'VOLNUM),LOCAREA+6 VOLUME MATCH?
         BNE   ERR20
        OBTAIN DSCBAR
         LTR   R15,R15             TEST COMPLETION CODE.
         BNZ   ERR6
         LA    R6,WORKAREA-L'DS1DSNAM   CONTROL THE DSCB'S DEFINITIONS.
         USING DSCDSECT,R6
         CLC   DS1VOLSQ(L'DS1VOLSQ),CH1
         BNE   ERR7
         CLI   DS1NOEPV,X'01'
         BNE   ERR7
         CLI   DS1EXT1+1,X'00'
         BNE   ERR7
         CLC   DS1SCALO+1(L'DS1SCALO-1),ZEROS
         BNE   ERR7
         CLI   DS1KEYL,X'00'
         BNE   ERR7
         CLC   DS1RKP(L'DS1RKP),ZEROS
         BNE   ERR7
         CLC   DS1DSORG(L'DS1DSORG),DAORG
         BNE   ERR7
         CLI   DS1RECFM,DCBRECF
         BNE   ERR7
         CLC   DS1BLKL(L'DS1BLKL),RCL
         BNE   ERR7
         CLC   DS1LRECL(L'DS1LRECL),RCL
         BNE   ERR7
         XR    R2,R2
         IC    R2,DVTYP+3          GET UNIT TYPE.
         LH    R3,RCL              UNKEYED DATA BLOCK LENGTH.
         ICM   R3,B'1000',CH1+L'CH1-1
        TRKCALC FUNCTN=TRKCAP,TYPE=(R2),RKDD=(R3),REGSAVE=YES
         LTR   R15,R15             DOES RECORD FIT ON TRACK?
         BNZ   ERR8                BRANCH IF NOT.
         LR    R5,R0               NO. OF BLOCKS/TRACK.
         MVC   WORKD(L'DS1EXT1-2),DS1EXT1+2
         DROP  R6
         L     R1,WORKD+4          UPPER LIMIT(CCHH).
         S     R1,WORKD            LOWER LIMIT(CCHH).
         ST    R1,WORKD
         LH    R1,WORKD            GET NUMBER OF CYLINDERS.
         LTR   R1,R1
         BZ    *+L'*+4
         MH    R1,DVTYP+10         TRANSFORM CYL. IN TRACKS.
         LH    R2,WORKD+2          GET NUMBER OF TRACKS.
         LA    R3,1(R1,R2)         EXTENT TOTAL NR. OF TRACKS.
         XR    R2,R2
         MR    R2,R5               EXTENT TOTAL NR. OF BLOCKS.
         LR    R5,R3               SAVE ADDRESS FIRST OUT OF DATA-SET.
         LH    R4,RCL
         LH    R3,NAUT             GET NUMBER OF AUT. NR.
         AH    R3,NPRG             ADD NUMBER OF PRG. NR.
         ST    R3,NBT
         SRL   R3,3                COMPUTE NR. OF BYTES FOR MAP TABLE.
         TM    NBT+3,X'07'
         BZ    *+L'*+4
         AH    R3,CH1
         XR    R2,R2               COMPUTE NR. OF RECORDS FOR MAP TABLE
         DR    R2,R4
         LTR   R2,R2
         BZ    *+L'*+4
         AH    R3,CH1
         ST    R3,NBT              NR. OF MAP TABLE RECORDS.
         ST    R3,NBTSTA
         LR    R3,R5               TOTAL NR. OF DATA-SET RECORDS.
         S     R3,NBT              SUBTRACT NR. OF MAP TABLE RECORDS.
         ST    R3,MXNREC           ADDRESS FIRST MAP TABLE RECORD.
         SH    R3,NAUT             SUBTRACT NR. OF AUT.
         SH    R3,NPRG             SUBTRACT NR. OF PRG.
         BNP   ERR9
         SRL   R4,1                NR. OF ARG. IN 1 TABLE RECORD.
         XR    R1,R1
         LR    R2,R1
OP5      CLR   R2,R3               COMPUTE TABLE RECORDS NUMBER.
         BNL   OP6
         LA    R1,1(0,R1)
         AR    R2,R4
         BCT   R3,OP5
         B     ERR9
OP6      ST    R1,NRT              NR. OF TABLE RECORDS.
         ST    R1,NRTSTA
         ST    R3,NRTARG
SWENQ    NOP   OP7
         MVC   RNME(L'VOLNUM),VOLNUM
         LA    R1,RNME+L'VOLNUM-1
         CLI   0(R1),C' '
         BNE   *+L'*+8
         MVI   0(R1),C'.'
         BCT   R1,*-12
         LA    R1,DSNM+L'DSNM-1
         LA    R2,L'RNME+L'DSNM
         CLI   0(R1),C' '
         BNE   *+L'*+6
         BCTR  R1,0
         BCT   R2,*-10
         STH   R2,RNMEL
        ENQ    (QNME,RNME,E,(R2),SYSTEMS),RET=USE
         LTR   R15,R15             DATA-SET AVAILABLE FOR UPDATE?
         BNZ   ERR21               BRANCH IF NOT, IT IS IN USE.
         USING JFCDSECT,R7
OP7      OI    JFCBTSDM,JFCNWRIT   INHIBIT WRITE BACK.
         DROP  R7
SWONLY   NOP   OPONLY
        OPEN   (DCBSR,(UPDAT)),TYPE=J
         B     OPTEST
OPONLY  OPEN   (DCBSR,(INPUT)),TYPE=J
OPTEST   TM    DCBSR+DCBOFLGS-IHADCB,DCBOFOPN SUCCESSFULLY OPENED?
         BZ    ERR10               BRANCH IF NOT.
         SPACE 2
         L     R1,NRT
         LH    R0,RCL
         MR    R0,R0               COMPUTE AMONG OF CORE REQ.
         AH    R1,CH23
         SRL   R1,3
         SLL   R1,3                ROUND UP TO DOUBLE-WORD BOUNDARY.
         ST    R1,NMCORE
         LR    R2,R1
        GETMAIN EC,LV=(2),A=ATABLE
         LTR   R15,R15             TEST COMPLETION CODE.
         BZ    *+L'*+8
         BAS   R10,CLERR           NO STORAGE AVAILABLE.
         B     ERR11
         L     R2,ATABLE           CLEAR THE TABLE AREA.
         L     R0,NMCORE
         SRDL  R0,8
         SRL   R1,24
         LTR   R0,R0
         BZ    OP9
OP8      XC    0(256,R2),0(R2)
         LA    R2,256(0,R2)
         BCT   R0,OP8
OP9      LTR   R1,R1
         BZ    *+L'*+6
         BCTR  R1,0
         EX    R1,OPX
         EJECT
* DATA-SET TABLE AREA ORGANIZATION :
* ----------------------------------
*
*        ASSUME THAT THE TABLE AREA LENGTH IS N BYTES LONG.
*
*        +0      = FIRST ARGUMENT ADDRESS.
*        +4      = ARGUMENT LENGTH.
*        +8      = LAST ARGUMENT ADDRESS.
*        +12     = TABLE IDENTIFIER(X'0F0F').
*        +14     = ... ARGUMENTS ...
*                       (THE LOCATION OF THE ARGUMENT IS USED TO
*                       COMPUTE THE CORRESPONDING DATA RECORD ADDRESS
*                       IN THE DATA-SET).
*        +(N-2)  = TABLE IDENTIFIER(X'0F0F').
         SPACE 1
         L     R2,ATABLE           PREPARE TABLE AREA.
         LA    R3,14(0,R2)
         LR    R4,R2
         ST    R3,0(R2)            SET START TABLE ADDRESS.
         MVI   7(R2),2             SET ARGUMENT LENGTH.
         MVC   12(L'INDTB,R2),INDTB     SET CONTROL INDICATORS.
         AL    R2,NMCORE
         BCTR  R2,0
         BCTR  R2,0
         MVC   0(L'INDTB,R2),INDTB
         LH    R2,NAUT             FIRST ARG. TABLE RECORD ADDRESS.
         AH    R2,NPRG
         L     R1,NRT
         AR    R1,R2
         ST    R1,NRT
OP10     LR    R1,R2
         LR    R8,R3
         BAS   R10,RRD             READ TABLE RECORDS.
         B     *+L'*+8
         BAS   R10,CLERR           I/O ERROR.
         B     ERR12
         AH    R3,RCL              NEXT TABLE RECORD ADDRESS.
         LA    R2,1(0,R2)          NEXT RECORD ADDRESS.
         CL    R2,NRT              TEST IF ALL TABLE RECORDS READ.
         BL    OP10                BRANCH IF MORE.
         LM    R1,R2,0(R4)         GET TABLE SCAN POINTERS.
         SLR   R3,R2               ADDRESS OF LAST ARGUMENT.
OP11     CLC   0(2,R1),ZEROS       SEARCH THE TRUE TABLE END ADDRESS.
         BE    OP12
         BXLE  R1,R2,OP11
OP12     SLR   R1,R2               ADDRESS OF LAST ARGUMENT IN TABLE.
         ST    R1,8(R4)            SET ADDRESS OF LAST ARGUMENT.
         EJECT
         L     R1,NBT
         LH    R0,RCL
         MR    R0,R0               COMPUTE AMONG OF CORE REQ.
         AH    R1,CH11
         SRL   R1,3
         SLL   R1,3                ROUND UP TO DOUBLE-WORD BOUNDARY.
         ST    R1,MTCORE
         LR    R2,R1
        GETMAIN EC,LV=(2),A=MTABLE
         LTR   R15,R15             TEST COMPLETION CODE.
         BZ    *+L'*+8
         BAS   R10,CLERR           NO STORAGE AVAILABLE.
         B     ERR11
         L     R2,MTABLE           CLEAR THE TABLE AREA.
         L     R0,MTCORE
         SRDL  R0,8
         SRL   R1,24
         LTR   R0,R0
         BZ    OP14
OP13     XC    0(256,R2),0(R2)
         LA    R2,256(0,R2)
         BCT   R0,OP13
OP14     LTR   R1,R1
         BZ    *+L'*+6
         BCTR  R1,0
         EX    R1,OPX
         EJECT
* DATA-SET MAP TABLE AREA ORGANIZATION :
* --------------------------------------
*
*        ASSUME THAT THE MAP TABLE AREA LENGTH IS M BYTES LONG.
*
*        +0      = TABLE IDENTIFIER(X'0F0F').
*        +2      = ... MAP TABLE ...
*                       (EACH BIT REPRESENT THE PRESENCE OR ABSENCE
*                       OF THE CORRESPONDING AUTHORIZATION OR
*                       PROGRAMMER RECORD).
*        +(M-2)  = TABLE IDENTIFIER(X'0F0F').
         SPACE 1
         L     R2,MTABLE           PREPARE MAP TABLE AREA.
         LA    R8,2(0,R2)
         L     R4,NBT
         MVC   0(L'INDTB,R2),INDTB SET CONTROL INDICATORS.
         AL    R2,MTCORE
         BCTR  R2,0
         BCTR  R2,0
         MVC   0(L'INDTB,R2),INDTB
         L     R2,MXNREC           FIRST MAP TABLE RECORD ADDRESS.
OP15     LR    R1,R2
         BAS   R10,RRD             READ MAP TABLE RECORDS.
         B     OP16
         BAS   R10,CLERR           I/O ERROR.
         B     ERR12
OP16     AH    R8,RCL              NEXT MAP TABLE RECORD ADDRESS.
         LA    R2,1(0,R2)          NEXT RECORD ADDRESS.
         BCT   R4,OP15             LOOP UNTIL ALL RECORDS READ.
         OI    OPEN+1,ON           SET OPEN SWITCHES.
         NI    READ+1,OFF
         NI    WRITE+1,OFF
         NI    CLOSE+1,OFF
         NI    SEQR+1,OFF
         NI    DELETE+1,OFF
         NI    STATS+1,OFF
         OI    SWBACK+1,ON         CLOSE SWITCH WRITE BACK TABLE.
         OI    SWMT+1,ON           CLOSE SWITCH WRITE BACK MAP TABLE.
         XR    R9,R9               SET INDICATOR RESPONSE.
         B     EXIT
         SPACE 1
OPX      XC    0(*-*,R2),0(R2)
         EJECT
READ     B     ERR14               DATA-SET NOT OPENED.
         OI    SWRW+1,ON           SET READ SWITCHES.
         NI    SWWR+1,OFF
         B     RW1
WRITE    B     ERR14               DATA-SET NOT OPENED.
SWWRITE  NOP   ERR22               WRITE NOT ALLOWED.
SWCWRT   NOP   *+L'*+12
         CLI   AUTLVL,LV5
         BNH   ERR25
         OI    SWCWRT+1,ON         CLOSE THIS WAY AFTER CONTROL DONE.
         NI    SWRW+1,OFF          SET WRITE SWITCHES.
         OI    SWWR+1,ON
RW1      XC    NSEQ(L'NSEQ),NSEQ   RESET SEQUENTIAL READ.
         BAS   R10,CONTROL         CONTROL IDENTIFIERS.
         TM    0(R1),X'80'         TEST CALLING SEQUENCE.
         BO    ERR19
         TM    4(R1),X'80'
         BO    ERR19
         TM    8(R1),X'80'
         BZ    ERR19
         TM    7(R1),X'01'
         BNZ   ERR19
         LM    R7,R8,4(R1)         GET PARM. ADDRESSES.
         LH    R1,0(R7)            GET ARGUMENT. (AUT. OR PRG. NR.)
         LTR   R1,R1               TEST IF ARGUMENT VALID,
         BZ    ERR19               BRANCH IF NOT.
         BM    OVRAP               BRANCH IF .GT. AUT. AND PRG.
         CLC   0(2,R7),NAUTT       TEST IF AUT. NR. REQUEST,
         BL    RWDIR+L'RWDIR       BRANCH IF YES.
         BE    ERR19               BRANCH IF INVALID.
         CLC   0(2,R7),NPRGT       TEST IF PRG. NR. REQUEST,
         BL    RWDIR               BRANCH IF YES.
OVRAP    LM    R1,R3,0(R4)         GET TABLE SCAN POINTERS.
         CLR   R1,R3               TEST IF TABLE EMPTY,
         BH    SWRW                BRANCH IF YES.
RW2      CLC   0(2,R1),0(R7)       SEARCH ARGUMENT.
         BE    RW3
         BXLE  R1,R2,RW2
SWRW     B     ERR15               NOT FOUND.
         ST    R1,8(R4)            SET NEW LAST ARGUMENT ADDRESS.
         NI    SWBACK+1,OFF        OPEN SWITCH TO WRITE BACK TABLE.
RW3      LR    R6,R1
         SL    R1,0(R4)            COMPUTE RECORD ADDRESS.
         SRL   R1,1
         AL    R1,NRT
         NI    SWWD+1,OFF          OPEN SWITCH.
         B     SWWR
RWDIR    BCTR  R1,0                COMPUTE RECORD ADDRESS.
         BCTR  R1,0
         BAS   R10,COMPUTE         GET MAP TABLE BIT ADDRESS AND MASK.
         TM    SWWR+1,ON           TEST IF WRITE REQUEST,
         BO    RW4                 BRANCH IF YES.
         EX    R4,RTEST            TEST IF AUT. NR. EXIST,
         BZ    ERR15               BRANCH IF NOT, NOT FOUND.
         B     RW5
RW4      EX    R4,RTEST            TEST IF AUT.NR. WAS EXISTING,
         BO    RW5                 BRANCH IF YES, IT IS UPDATE.
         EX    R4,WBSET            SET NEW AUT. NR.
         NI    SWMT+1,OFF          OPEN SWITCH TO WRITE BACK MAP TABLE.
RW5      OI    SWWD+1,ON           CLOSE SWITCH.
SWWR     B     SWWD
         BAS   R10,RRD
         B     RW7
         B     ERR16
SWWD     B     WDIR
         CL    R1,MXNREC           TEST DATA-SET OVERFLOW,
         BL    RW6                 BRANCH IF NOT.
         ST    R3,8(R4)            SET PREVIOUS LAST ARGUMENT ADDRESS.
         B     ERR17               DATA-SET FULL.
RW6      MVC   0(2,R6),0(R7)       MOVE ARGUMENT IN TABLE.
WDIR     BAS   R10,RWR
         B     RW7
         B     ERR16
RW7      XR    R9,R9               SET INDICATOR RESPONSE.
         B     EXIT
         EJECT
CLOSE    B     ERR14               DATA-SET NOT OPENED.
         XC    NSEQ(L'NSEQ),NSEQ   RESET SEQUENTIAL READ.
         BAS   R10,CONTROL         CONTROL IDENTIFIERS.
         TM    0(R1),X'80'
         BZ    ERR19               TOO MANY ARGUMENTS.
SWBACK   B     SWMT                SKIP EVENTUALLY THE WRITE BACK TABLE
         L     R8,0(R4)            START TABLE ADDRESS.
         LH    R2,NAUT             FIRST TABLE RECORD ADDRESS.
         AH    R2,NPRG
CL1      LA    R5,3                RETRY COUNTER.
CL2      LR    R1,R2
         BAS   R10,RWR
         B     CL3
         BCT   R5,CL2              TRY AGAIN.
         NI    SWCL+1,OFF          SET CLOSE ERROR SWITCH.
CL3      AH    R8,RCL              NEXT TABLE RECORD ADDRESS.
         LA    R2,1(0,R2)          NEXT RECORD ADDRESS.
         CL    R2,NRT              TEST IF ALL TABLE RECORDS WRITEN.
         BL    CL1                 BRANCH IF MORE.
SWMT     B     CL7                 SKIP EVENTUALLY THE WRITE BACK TABLE
         L     R8,MTABLE           START MAP TABLE ADDRESS.
         LA    R8,2(0,R8)
         L     R2,MXNREC           FIRST MAP TABLE RECORD ADDRESS.
         L     R4,NBT
CL4      LA    R5,3                RETRY COUNTER.
CL5      LR    R1,R2
         BAS   R10,RWR
         B     CL6
         BCT   R5,CL5              TRY AGAIN.
         NI    SWCL+1,OFF          SET CLOSE ERROR SWITCH.
CL6      AH    R8,RCL              NEXT TABLE RECORD ADDRESS.
         LA    R2,1(0,R2)          NEXT RECORD ADDRESS.
         BCT   R4,CL4              LOOP UNTIL ALL RECORDS WRITEN.
CL7      BAS   R10,CLERR
         L     R2,NMCORE           FREE THE TABLE AREA.
        FREEMAIN E,LV=(2),A=ATABLE
         L     R2,MTCORE           FREE THE MAP TABLE AREA.
        FREEMAIN E,LV=(2),A=MTABLE
         NI    OPEN+1,OFF          SET CLOSE SWITCHES.
         OI    READ+1,ON
         OI    WRITE+1,ON
         OI    CLOSE+1,ON
         OI    SEQR+1,ON
         OI    DELETE+1,ON
         OI    STATS+1,ON
SWCL     B     *+L'*+8
         OI    SWCL+1,ON           SET BRANCH OPERATION.
         B     ERR18               I/O ERROR WHILE WRITING TABLE.
         OI    SWDP+1,ON           RESET DUMP SWITCH.
         XR    R9,R9               SET INDICATOR RESPONSE.
         B     EXIT
         EJECT
SEQR     B     ERR14               DATA-SET NOT OPENED.
         BAS   R10,CONTROL         CONTROL IDENTIFIERS.
         TM    0(R1),X'80'
         BO    ERR19               NOT ENOUGH ARGUMENTS.
         L     R8,4(R1)            GET PARM. ADDRESSES.
         XR    R7,R7
         TM    4(R1),X'80'
         BO    SQDIR
         TM    8(R1),X'80'
         BZ    ERR19               TOO MANY ARGUMENTS.
         TM    11(R1),X'01'
         BNZ   ERR19
         L     R7,8(R1)
SQDIR    CLC   NSEQ(L'NSEQ),ZEROS  TEST IF FIRST CALL,
         BNE   SQT                 BRANCH IF NOT.
         OI    SWSQ+1,ON           CLOSE SWITCH.
         XC    WORKD(2),WORKD      SET INITIAL AUT. NR. VALUE START.
SQT      CLC   NSEQ(L'NSEQ),NPRGT  TEST IF AUT. OR PRG. NR. REQUEST,
         BNL   SQ1                 BRANCH IF NOT.
SQN      LH    R1,WORKD            INCREMENT AUT. NR.
         LA    R1,1(R1)
         CH    R1,NAUTT            TEST IF AUT. NR. ENDED,
         BE    SQN+L'SQN           BRANCH IF YES.
         CH    R1,NPRGT            TEST IF AUT. AND PRG. NR. ENDED,
         BNL   SQE                 BRANCH IF YES.
         STH   R1,WORKD
         CLC   WORKD(2),NAUTT
         BNH   *+L'*+2
         BCTR  R1,0                COMPUTE RECORD ADDRESS.
         BCTR  R1,0
         BAS   R10,COMPUTE         GET MAP TABLE BIT ADDRESS AND MASK.
         EX    R4,RTEST            TEST IF AUT. NR. EXIST,
         BZ    SQN                 BRANCH IF NOT, GET NEXT.
         B     SQ4
SQE      NI    SWSQ+1,OFF          OPEN SWITCH.
         L     R4,ATABLE           GET TABLE AREA ADDRESS.
SQ1      LM    R1,R3,0(R4)         GET TABLE SCAN POINTERS.
         MVC   WORKD(L'CHM1),CHM1  PREPARE TABLE SCAN.
         XC    WORKD+4(L'WORKD-4),WORKD+4
         CLR   R1,R3               TEST IF TABLE EMPTY,
         BH    SQ3+L'SQ3           BRANCH IF YES.
SQ2      CLC   0(2,R1),NSEQ        SEARCH NEXT SEQUENTIAL ARGUMENT.
         BNH   SQ3
         CLC   0(2,R1),WORKD
         BNL   SQ3
         MVC   WORKD(2),0(R1)
         ST    R1,WORKD+4
SQ3      BXLE  R1,R2,SQ2
         L     R1,WORKD+4
         LTR   R1,R1               TEST IF END-OF-FILE,
         BNZ   SQ4                 BRANCH IF NOT.
         XC    NSEQ(L'NSEQ),NSEQ   RESET SEQUENTIAL READ.
         LH    R9,CHM1             SET END-OF-FILE INDICATOR.
         B     EXIT
SQ4      LTR   R7,R7               TEST IF ARGUMENT REQUESTED,
         BZ    *+L'*+6             BRANCH IF NOT.
         MVC   0(2,R7),WORKD       MOVE ARGUMENT.
         MVC   NSEQ(2),WORKD
SWSQ     B     SQ5
         SL    R1,0(R4)            COMPUTE RECORD ADDRESS.
         SRL   R1,1
         AL    R1,NRT
SQ5      BAS   R10,RRD
         B     *+L'*+4
         B     ERR16
         XR    R9,R9               SET INDICATOR RESPONSE.
         B     EXIT
         EJECT
DELETE   B     ERR14               DATA-SET NOT OPENED.
SWDELET  NOP   ERR23               DELETE NOT ALLOWED.
SWCDLT   NOP   *+L'*+12
         CLI   AUTLVL,LV5
         BNH   ERR26
         OI    SWCDLT+1,ON         CLOSE THIS WAY AFTER CONTROL DONE.
         XC    NSEQ(L'NSEQ),NSEQ   RESET SEQUENTIAL READ.
         BAS   R10,CONTROL         CONTROL IDENTIFIERS.
         TM    0(R1),X'80'         TEST CALLING SEQUENCE.
         BO    ERR19               NOT ENOUGH ARGUMENTS.
         TM    4(R1),X'80'
         BZ    ERR19               TOO MANY ARGUMENTS.
         TM    7(R1),X'01'
         BNZ   ERR19
         L     R7,4(R1)            GET PARM. ADDRESS.
         LH    R1,0(R7)            GET ARGUMENT.
         LTR   R1,R1               TEST IF ARGUMENT VALID,
         BZ    ERR19               BRANCH IF NOT.
         LA    R8,RECAI
         CLC   0(2,R7),NPRGT       TEST IF AUT. OR PRG. NR. REQUEST,
         BL    DELAP               BRANCH IF YES.
         LM    R1,R3,0(R4)         GET TABLE SCAN POINTERS.
DL1      CLC   0(2,R1),0(R7)       SEARCH ARGUMENT.
         BE    DL2
         BXLE  R1,R2,DL1
         B     ERR15               NOT FOUND.
DL2      NI    SWBACK+1,OFF        OPEN SWITCH TO WRITE BACK TABLE.
         OI    SWDL+1,ON           CLOSE SWITCH.
         CLR   R1,R3               TEST IF IT IS THE LAST ARGUMENT,
         BE    DL3                 BRANCH IF YES, DON'T MOVE IT.
         NI    SWDL+1,OFF          OPEN SWITCH.
         MVC   0(2,R1),0(R3)       MOVE LAST ARG. IN PLACE OF THIS.
DL3      XC    0(2,R3),0(R3)       CLEAR LAST ARG. JUST MOVED.
         LR    R0,R3               SET NEW LAST ARGUMENT ADDRESS.
         SLR   R0,R2
         ST    R0,8(R4)
         SL    R1,0(R4)            COMPUTE RECORD ADDRESSES.
         SRL   R1,1
         AL    R1,NRT
SWDL     B     DL4
         SL    R3,0(R4)
         SRL   R3,1
         AL    R3,NRT
         LR    R5,R1               SAVE RECORD ADDRESS.
         LR    R1,R3               READ LAST ARGUMENT RECORD.
         BAS   R10,RRD
         B     *+L'*+4
         B     ERR16
         LR    R1,R5               WRITE TO REPLACE RECORD.
         BAS   R10,RWR
         B     *+L'*+4
         B     ERR16
         LR    R1,R3
         B     DL4
DELAP    CLC   0(2,R7),NAUTT
         BE    ERR19               BRANCH INVALID.
         BNH   *+L'*+2
         BCTR  R1,0                COMPUTE RECORD ADDRESS.
         BCTR  R1,0
         BAS   R10,COMPUTE         GET MAP TABLE BIT ADDRESS AND MASK.
         EX    R4,RTEST            TEST IF AUT. NR. EXIST,
         BZ    ERR15               BRANCH IF NOT, NOT FOUND.
         LA    R0,X'FF'
         XR    R4,R0
         EX    R4,DBDEL            CANCEL AUT. NR. IN MAP TABLE.
         NI    SWMT+1,OFF          OPEN SWITCH TO WRITE BACK TABLE.
DL4      XC    RECAI(AUTLGTH),RECAI     CLEAR DELETED RECORD.
         BAS   R10,RWR
         B     *+L'*+4
         B     ERR16
         XR    R9,R9               SET INDICATOR RESPONSE.
         B     EXIT
         EJECT
STATS    B     ERR14               DATA-SET NOT OPENED.
         BAS   R10,CONTROL         CONTROL IDENTIFIERS.
         TM    0(R1),X'80'
         BO    ERR19               NOT ENOUGH ARGUMENTS.
         TM    4(R1),X'80'
         BZ    ERR19               TOO MANY ARGUMENTS.
         TM    7(R1),X'03'
         BNZ   ERR19
         L     R7,4(R1)            GET STATUS AREA ADDRESSES.
         USING STADSECT,R7
         LH    R1,NAUT
         ST    R1,STANAUT
         LH    R0,NPRG
         ST    R0,STANPRG
         AR    R1,R0
         L     R0,NRTARG
         ST    R0,STANARG
         AR    R1,R0
         L     R0,NRTSTA
         ST    R0,STANATB
         AR    R1,R0
         L     R0,NBTSTA
         ST    R0,STANMTB
         AR    R1,R0
         ST    R1,STATOTL
         XR    R6,R6               COMPUTE NO. OF USED AUT. REC.
         LA    R5,1
STATS1   LR    R1,R5
         BCTR  R1,0
         BAS   R10,COMPUTE
         EX    R4,RTEST
         BZ    *+L'*+4
         AH    R6,CH1
         AH    R5,CH1
         CH    R5,NAUTT
         BL    STATS1
         ST    R6,STAUAUT
         AH    R5,CH1
         XR    R6,R6               COMPUTE NO. OF USED PRG. REC.
STATS2   LR    R1,R5
         BCTR  R1,0
         BCTR  R1,0
         BAS   R10,COMPUTE
         EX    R4,RTEST
         BZ    *+L'*+4
         AH    R6,CH1
         AH    R5,CH1
         CH    R5,NPRGT
         BL    STATS2
         ST    R6,STAUPRG
         XR    R6,R6               COMPUTE NO. OF USED ARG. REC.
         L     R4,ATABLE
         LM    R1,R3,0(R4)
         CLR   R1,R3
         BH    STATS3
         LR    R6,R3
         SLR   R6,R1
         SRL   R6,1
         AH    R6,CH1
STATS3   ST    R6,STAUARG
         MVC   STADSNM,DSNM
         MVC   STAVLSR,VOLNUM
         MVC   STADSOR,=CL2'DA'
         MVC   STARECL,RCL
         DROP  R7
         XR    R9,R9               SET INDICATOR RESPONSE.
         B     EXIT
         EJECT
*        CLOSE AND DEQUEUE DATA-SET (LINK=R10).
         SPACE 1
CLERR   CLOSE  DCBSR
SWDEQ    NOPR  R10
         LH    R2,RNMEL
        DEQ    (QNME,RNME,(R2),SYSTEMS)
         BR    R10
         EJECT
*        COMPUTE ERROR NUMBER AND RETURN.
         SPACE 1
ERRM    NULL
         SPACE 1
ERR1     BCTR  R9,0      ROUTINE OR DATA-SET TABLE DESTROYED.
ERR2     BCTR  R9,0      SYSACC DD-CARD IS MISSING.
ERR3     BCTR  R9,0      SYSACC UNIT IS NOT A DIRECT-ACCESS STORAGE.
ERR4     BCTR  R9,0      SYSACC JFCB READ ERROR.
ERR5     BCTR  R9,0      SYSACC DD-CARD INCORRECTLY CODED.
ERR6     BCTR  R9,0      OBTAIN ERROR WHILE PROCESSING SYSACC VOLUME.
ERR7     BCTR  R9,0      SYSACC DSCB FORMAT 1 ERROR DETECTED.
ERR8     BCTR  R9,0      SYSACC DATA BLOCK EXCEEDS TRACK CAPACITY.
ERR9     BCTR  R9,0      SYSACC DATA-SET SPACE TOO SHORT.
ERR10    BCTR  R9,0      SYSACC DATA-SET OPEN ERROR.
ERR11    BCTR  R9,0      NO STORAGE AVAILABLE TO READ DATA-SET TABLE.
ERR12    BCTR  R9,0      SYSACC DATA-SET I/O ERROR WHILE READING TABLE.
ERR13    BCTR  R9,0      SYSACC DATA-SET IS ALREADY OPENED.
ERR14    BCTR  R9,0      SYSACC DATA-SET IS NOT OPENED.
ERR15    BCTR  R9,0      READ REQUEST - ARGUMENT NOT FOUND.
ERR16    BCTR  R9,0      READ/WRITE REQUEST - I/O ERROR.
ERR17    BCTR  R9,0      SYSACC DATA-SET FULL, CANNOT ADD RECORD.
ERR18    BCTR  R9,0      SYSACC DATA-SET I/O ERROR WRITTING BACK TABLE.
ERR19    BCTR  R9,0      ROUTINE CALLING SEQUENCE OR ARGUMENT ERROR.
ERR20    BCTR  R9,0      SYSACC DATA-SET WRONGLY OR NOT CATALOGED.
ERR21    BCTR  R9,0      SYSACC DATA-SET IN USE FOR UPDATE BY SOMEBODY.
ERR22    BCTR  R9,0      ONLY OR BOTH REQUESTED - ZWRITE NOT AVAILABLE.
ERR23    BCTR  R9,0      ONLY OR BOTH REQUESTED - ZDELET NOT AVAILABLE.
ERR24    BCTR  R9,0      UNAUTHORIZED ACCESS.
ERR25    BCTR  R9,0      UNAUTHORIZED ACCESS TO ZWRITE.
ERR26    BCTR  R9,0      UNAUTHORIZED ACCESS TO ZDELET.
         SPACE 1
ERRL     EQU   ((*-ERRM)/2)+1
         SPACE 1
SWDP     B     EXIT
         LR    R1,R9               SET ERROR NUMBER AS ABEND CODE.
        ABEND  (1),DUMP            DUMP OPTION SELECTED BY OPEN.
         SPACE 1
EXIT     L     R1,INDRA            SET INDICATOR RESPONSE.
         LTR   R1,R1
         BZ    *+L'*+4
         ST    R9,0(R1)
        $XRET  CC=(R9)
         EJECT
*        READ - WRITE ROUTINE.
*        ---------------------
*
*        R1 = PHYSICAL RECORD ADDRESS.
*        R8 = BUFFER/AREA ADDRESS.
*        R10 = LINK REGISTER.
*
*        RETURN +0 = NORMAL RETURN.
*               +4 = ERROR RETURN.
         SPACE 1
RRD      ST    R1,NREC
         LA    R1,DECBSR
        READ   (1),DI,DCBSR,(8),'S',0,NRECAD,MF=E
         B     RCH
RWR      ST    R1,NREC
         LA    R1,DECBSR
        WRITE  (1),DI,DCBSR,(8),'S',0,NRECAD,MF=E
RCH     CHECK  DECBSR
SWLRW    B     0(0,R10)            I/O ERROR SWITCH.
         OI    SWLRW+1,ON          SET BRANCH OPERATION.
        WTO    MF=(E,LWTO)
         B     4(0,R10)
         EJECT
*        CONTROL INTEGRITY ROUTINE.
*        --------------------------
*
*        R2 = WORK REGISTER.
*        R4 = TABLE AREA ADDRESS AT EXIT.
*        R10 = LINK REGISTER.
         SPACE 1
CONTROL  L     R2,ATABLE           GET TABLE AREA ADDRESS.
         CLC   12(L'INDTB,R2),INDTB     CONTROL IDENTIFIERS.
         BNE   ERR1
         LR    R4,R2
         AL    R2,NMCORE
         BCTR  R2,0
         BCTR  R2,0
         CLC   0(L'INDTB,R2),INDTB
         BNE   ERR1
         L     R2,MTABLE           GET MAP TABLE AREA ADDRESS.
         CLC   0(L'INDTB,R2),INDTB
         BNE   ERR1
         AL    R2,MTCORE
         BCTR  R2,0
         BCTR  R2,0
         CLC   0(L'INDTB,R2),INDTB
         BNE   ERR1
         BR    R10                 RETURN.
         SPACE 2
*        COMPUTE MAP TABLE BIT ADDRESS.
*        ------------------------------
*
*        R1 = AUT. NR. RECORD ADDRESS.
*        R2 = BYTE ADDRESS -2 IN MAP TABLE.
*        R3 = WORK REGISTER.
*        R4 = MASK BIT.
*        R10 = LINK REGISTER.
         SPACE 1
COMPUTE  LR    R2,R1
         SRDL  R2,3                COMPUTE BYTE DISPLACEMENT.
         SRL   R3,29               COMPUTE MASK DISPLACEMENT.
         AL    R2,MTABLE           COMPUTE BYTE ADDRESS IN MAP TABLE.
         LA    R4,X'80'
         SRL   R4,0(R3)            BUILD MASK BIT.
         BR    R10                 RETURN.
         EJECT
*        ERROR ANALYSIS ROUTINE (DCBSR).
         SPACE 1
RWERR   SYNADAF   ACSMETH=BDAM
         MVC   LWTO+4(72),56(R1)
         CLI   69(R1),C'*'         TEST UNSIGNIFICANT MESSAGE,
         BE    SYNAD2              BRANCH IF YES.
         CLI   8(R1),C' '          TEST IF BINARY INFORMATIONS,
         BE    SYNAD1              BRANCH IF NOT.
         UNPK  LWTO+4(7),9(4,R1)
         TR    LWTO+4(6),TRTAB-X'F0'
         MVI   LWTO+10,C','
         UNPK  LWTO+11(5),12(3,R1)
         TR    LWTO+11(4),TRTAB-X'F0'
         MVI   LWTO+15,C','
         B     SYNAD2
SYNAD1   MVC   LWTO+4(12),8(R1)    MOVE BLANKS.
SYNAD2  SYNADRLS
         NI    SWLRW+1,OFF         SET NOP OPERATION.
         BR    R14                 RETURN.
         SPACE 2
RTEST    TM    2(R2),*-*
WBSET    OI    2(R2),*-*
DBDEL    NI    2(R2),*-*
         EJECT
*        CONSTANTS AND WORK-AREAS.
         SPACE 1
WORKD    DC    D'0'
LOCAREA  DC    0D'0',XL120'00'     OVERLAP ON WORKAREA.
WORKAREA DC    0D'0',XL140'00',XL5'00',XL3'00'
DVTYP    DC    5F'0'
ATIOT    DC    A(*-*)
NMCORE   DC    A(*-*)
ATABLE   DC    A(*-*)
MTCORE   DC    A(*-*)
MTABLE   DC    A(*-*)
INDRA    DC    A(*-*)
ZEROS    DC    F'0'
MXNREC   DC    F'0'
NBT      DC    F'0'
NBTSTA   DC    F'0'
NRT      DC    F'0'
NRTSTA   DC    F'0'
NRTARG   DC    F'0'
REQAUT   DC    0F'0',BL1'00000000',AL3(MDL@IX),AL4(AUTLVL)
NREC     DC    0F'0',XL1'00'
NRECAD   DC    XL3'00'
JOBFILE  DC    0F'0',XL1'87',AL3(JF)
JF       DC    0F'0',XL176'00'
CVLIST  CAMLST NAME,DSNM,,LOCAREA
DSCBAR  CAMLST SEARCH,DSNM,VOLNUM,WORKAREA
LWTO    WTO    '                                                       1
                                ',ROUTCDE=11,DESC=7,MF=L
QNME     DC    CL8'EURACCNT'
RNME     DC    CL8'........'
DSNM     DC    CL44' '
VOLNUM   DC    CL6' '
RNMEL    DC    H'0'
CH1      DC    H'1'
CH11     DC    H'11'
CH23     DC    H'23'
CHM1     DC    H'-1'
NAUT     DC    0H'0',AL2(NAUTNO)
NAUTT    DC    0H'0',AL2(NAUTNO+1)
NPRG     DC    0H'0',AL2(NPRGNO)
NPRGT    DC    0H'0',AL2(NAUTNO+NPRGNO+2)
NSEQ     DC    H'0'
DAORG    DC    0H'0',AL1(DCBDSGDA,0)
RCL      DC    0H'0',AL2(AUTLGTH)
MAXERR   DC    0H'0',AL2(ERRL)
TRTAB    DC    C'0123456789ABCDEF'
KDUMP    DC    C'DUMP'
KONLY    DC    C'ONLY'
KBOTH    DC    C'BOTH'
AUTLVL   DC    XL1'0'
         EJECT
DCBSR   DCB    DSORG=DA,MACRF=(RIC,WIC),BFALN=D,BFTEK=S,KEYLEN=0,      1
               LIMCT=1,OPTCD=R,EXLST=JOBFILE,SYNAD=RWERR,DDNAME=SYSACC
         EJECT
        READ   DECBSR,DI,MF=L
         SPACE 2
RECAI    DC    (AUTLGTH)X'0'       RECORD WORK AREA.
         SPACE 2
INDTB    DC    XL2'0F0F'
         SPACE 2
         END
