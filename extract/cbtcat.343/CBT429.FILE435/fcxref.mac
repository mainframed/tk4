/* REXX    FCXREF     produces a side-by-side list  of member names
                      in a set of concatenated libraries.
           ×**-***-***-***-***-***-***-***-***-***-***-***-***-**×
           ×                                                     ×
           ×  WARNING: EMBEDDED COMPONENTS.                      ×
           ×              See text following TOOLKIT_INIT        ×
           ×                                                     ×
           ×**-***-***-***-***-***-***-***-***-***-***-***-***-**×

            Each library is LISTD'd to develop a list of members.
            This list is then annotated with an indicator of the
            source dataset, and the whole is sorted.  The resultant
            list is processed to provide one report line per member
            either with or without headers.  Three report formats
            are available:
              (a) with the member name positioned on the line
                  beneath the header for its origin dataset;
              (b) with member statistics positioned on the line
                  beneath the header for its origin dataset (STATS);
              (c) with the dataset number (only) appearing on the
                  line in a standard position (COMPACT).

            Because it makes each column so wide, STATS is practical
            only when the number of datasets being cross-referenced
            is fewer than 8.

            In rare instances, a large number of datasets allocated to
            a DDName may make the standard listing format impractical.
            Selecting COMPACT in this case provides a much narrower
            report style in which page 1 is devoted to merely listing
            the dataset names for which the list was done.  Subsequent
            pages list the member-name at the left margin, and next to
            it (a) numeric indicator(s) of the source dataset(s) in
            which it appears.  In this format, a count of how many
            datasets contain each member is also provided.

           Written by Frank Clarke

     Impact Analysis
.    SYSPROC   DFLTHLQ
.    SYSPROC   LA
.    SYSPROC   MEMBERS
.    SYSPROC   TRAPOUT

     Modification History
     19950504 fxc made output dataset FBA.
     19960514 fxc upgrade to REXXSKEL;
     19980302 fxc upgrade from v.960506 to v.19971030; DECOMM;
                  RXSKLY2K;
     19990908 fxc use MEMBERS to develop alias lists; drop E_ and F_;
                  enable call-from-READY;

*/ arg argline
address TSO                            /* REXXSKEL ver.19971030      */
arg parms "((" opts

signal on syntax
signal on novalue

call TOOLKIT_INIT                      /* conventional start-up     -*/
rc     = trace(tv)
info   = parms                         /* to enable parsing          */

call DEIMBED                           /*                           -*/
call A_INIT                            /*                           -*/

do forever
if ddn <> "" then do
   "NEWSTACK"
   "LA" ddn "((STACK"                  /* call LA, return stack      */
   pull dsnstr                         /* retrieve stack             */
   "DELSTACK"
   if monitor then say,
      "LA:" dsnstr
   dsn. = ""                           /* set up array               */
   dsn.0 = words(dsnstr)               /* how many dsnames ?         */
   do ii = 1 to dsn.0
      dsn.ii = "'"Word(dsnstr,ii)"'"
   end
   call B_STEM_PNL                     /* load to screen variables  -*/
   end

p_name = exec_name".PLIB"              /* de-imbedded panels         */
if sw.0interactive then do
   if sw.0do_hdr then hdr = "Y"
             else hdr = "N"
   ddn = ""
   address ISPEXEC "LIBDEF ISPPLIB DATASET ID("p_name") STACK"
   address ISPEXEC "DISPLAY PANEL(GETLIBS)"
   save_rc = rc
   address ISPEXEC "LIBDEF ISPPLIB"
   if save_rc = 8 then exit            /* user pushed PF3            */
   if ddn <> "" then iterate           /* re-do the loop             */
   sw.0do_hdr = hdr = "Y"
   call C_PNL_STEM                     /* convert panel variables   -*/
   end
   leave                               /* don't re-do the loop       */
end                                    /* forever                    */
rc = Outtrap("zz.")
address TSO "DELETE" exec_name".PLIB"
rc = Outtrap("OFF")
rc = trace("O"); rc = trace(tv)

                     /* no line-mode output when BROWSE is available */
if outdsn = "" & sw.inispf then,
   parse value 1                 exec_name".$TMP" with,
               sw.0interactive   outdsn  .

   /* COMPACT display puts the membername and count on each line and
      adds markers by dataset; STATS/normal show either member-stats
      or the member-name in each column. */
if outdsn <> "" then do
   outlen = (dsn.0 * (collen+1))  + margin

   outlen = Max(outlen,60)             /* never shorter than 60      */
   orig_msg = Msg("off")
   "DELETE" outdsn "SCR PURGE"
   "ALLOC FI(OUT) DA("outdsn") NEW CATALOG UNIT(SYSDA) SPACE(20 20)",
       " TRACKS RECFM(F B A) LRECL("outlen") BLKSIZE(0) REU"
   msg_stat = Msg(orig_msg)
   outop = "QUEUE"
   end
else outop = "SAY"

call D_LOAD_SORTIN                     /*                           -*/

say "Starting sort," midx "items."

rc = Outtrap("sort.")
"ALLOC FI(SORTOUT) DA(TEMPSRT) SHR REU"
"ALLOC FI(SYSOUT)  DUMMY  REU "

"ALLOC FI(SYSIN) NEW TRACKS SPACE(1) UNIT(SYSDA)",
       " LRECL(80) BLKSIZE(800) RECFM(F B) REU"
queue " SORT  FIELDS=(1,12,CH,A)"
"EXECIO" queued() "DISKW SYSIN (FINIS"

sortprm ="MSG=CC"                      /* suppress messages          */
address LINKMVS "SORT   sortprm"
"EXECIO    *      DISKR SORTOUT (STEM MLIST. FINIS"

"FREE  FI(SORTIN SORTOUT SYSOUT)"
"ALLOC FI(SYSIN)   DA(*) SHR REU"
"DELETE TEMPSRT SCR PURGE"
rc = Outtrap("off")

say "Finished sort," mlist.0 "items."

if sw.0compact then call HC_SHORTHDR; else, /*                      -*/
if sw.0stats then call HS_STATHDR      /*                           -*/
else call HA_STANDARD_HDR              /* gen report header lines   -*/

if lpp="" then,
if outdsn="" then pagelim = 22         /* 22 for term, 60 for print  */
else if \sw.0do_hdr then pagelim = 0
else pagelim = 60

call Q_COMPOSE                         /* finish report             -*/

if outdsn <> "" then do                /* output to dataset          */
   "EXECIO" queued() "DISKW OUT (FINIS"/* pump entire queue          */
   end
"FREE FI(OUT)"

if sw.0interactive & outdsn <> "" then,
   address ISPEXEC "BROWSE DATASET("outdsn")"

exit                                   /*@ FCXREF                    */
/*
.  ----------------------------------------------------------------- */
A_INIT:                                /*@                           */
   if branch then call BRANCH
   address TSO

   if parms="" then call HELP          /*                           -*/
   ddn=""                              /* guarantee values           */

   if SWITCH("ISPF") then,
   if \sw.inispf then do
      "ISPSTART CMD("exec_name argline")" /* Invoke ISPF             */
      exit
      end
   else sw.0interactive = "1"          /* ISPF was active            */
   else sw.0interactive = "0"          /* ISPF was not requested     */

   sw.0dup_only  = SWITCH("CONFLICTS")
   sw.0compact   = SWITCH("COMPACT")
   sw.0stats     = SWITCH("STATS")
   if sw.0stats & sw.0compact then do
      helpmsg = "STATS and COMPACT are mutually exclusive"
      call HELP                        /*                           -*/
      end
   else if sw.0stats then,             /* stats-display              */
           parse value "16 11" with collen margin .
   else if sw.0compact then,           /* presence-display           */
           parse value " 2 17" with collen margin .
   else parse value "10  2" with collen margin .  /* name-display    */

   ddn      = KEYWD("DDNAME")          /* Input via DDName ?         */
   outdsn   = KEYWD("OUTPUT")          /* Output to a dataset ?      */
   lpp      = KEYWD("LPP")             /* lines-per-page             */
   sw.0do_hdr = \SWITCH("NOHDR")       /* Headers or not ?           */
   kill_switch = "THE FOLLOWING ALIAS NAMES EXIST"

return                                 /*@ A_INIT                    */
/*
.  Convert variables of the form: dsn.1, dsn.2, ..., dsn.n ;
.  to variables of the form: dsn1, dsn2, ..., dsnn.
.  ----------------------------------------------------------------- */
B_STEM_PNL:                            /*@                           */
   if branch then call BRANCH
   address TSO

   list = dsn.1 dsn.2 dsn.3 dsn.4 dsn.5 dsn.6 dsn.7,
          dsn.8 dsn.9 dsn.10 dsn.11 dsn.12
   if list = "" then exit
   parse var list xrdsn1 xrdsn2 xrdsn3 xrdsn4 xrdsn5 xrdsn6,
                  xrdsn7 xrdsn8 xrdsn9 xrdsn10 xrdsn11 xrdsn12 .

return                                 /*@ B_STEM_PNL                */
/*
.  Convert variables of the form: dsn1, dsn2, ..., dsnn ;
.  to variables of the form: dsn.1, dsn.2, ..., dsn.n.
.  ----------------------------------------------------------------- */
C_PNL_STEM:                            /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   dsnstr = xrdsn1 xrdsn2 xrdsn3 xrdsn4 xrdsn5 xrdsn6 xrdsn7,
            xrdsn8 xrdsn9 xrdsn10 xrdsn11 xrdsn12
   if dsnstr = "" then exit            /* no DSNames                 */
   dsn.0 = Words(dsnstr)
   do i = 1 to dsn.0                   /* for each list item         */
      dsn.i = Word(dsnstr,i)           /* isolate                    */
      if Substr(dsn.i,1,1)  <>  "'" then,/* quoted ?                 */
         dsn.i = "'"Userid()"."dsn.i"'" /* no, attach userid.        */
   end
   dsnstr = ""                         /* clear work area            */
   do i = 1 to dsn.0
      dsnstr = dsnstr dsn.i            /* splice dsn to dsnstr       */
   end
   dsnstr = Translate(dsnstr," ","'" ) /* translate all quotes away  */

return                                 /*@ C_PNL_STEM                */
/*
.  ----------------------------------------------------------------- */
D_LOAD_SORTIN:                         /*@                           */
   if branch then call BRANCH
   address TSO

   parse value "0" with midx  lvls.           /* set up array        */

   "NEWSTACK"                          /* isolate prior queues       */
   do dsix = 1 to dsn.0                /* for all dsnames            */
      if Sysdsn(dsn.dsix) <> "OK" then,
         iterate                       /* skip it, get next dsn      */
      "NEWSTACK"
      "MEMBERS" dsn.dsix "((STACK LINE ALIAS"
      pull mbrlist
      "DELSTACK"

      lvls.dsix = Translate(Word(dsnstr,dsix)," ",".")   /* zap dots */

      do Words(mbrlist)                /* each member/alias          */
         parse var mbrlist   mbr  mbrlist      /* isolate mbrname    */
         if Right(mbr,3) = "(*)" then do   /* it's an ALIAS          */
            parse var mbr  mbr "("
            queue  mbr  dsix  "*"
            end                        /* ALIAS                      */
         else queue mbr dsix           /* not an ALIAS               */
      end
   end                                 /* dsix                       */

   midx  = queued()                    /* how many lines ?           */
   "ALLOC FI(SORTIN) DA(TEMPSRT) RECFM(F B) SPACE(5 2) TRACK NEW REU",
      " LRECL(16) BLKSIZE(0)"
   if rc > 4 then do
      "ALLOC FI(SORTIN) DA(TEMPSRT) SHR REU"
      end
   "EXECIO" midx "DISKW SORTIN (FINIS"
   "DELSTACK"                          /* restore prior queues       */

return                                 /*@ D_LOAD_SORTIN             */
/*
.  Build standard (not STATS, not COMPACT) header records:
.  " × ........ × ........ × ........ × ..etc"
.  that is: starts with " × " plus qualifier padded to l=10, repeat
.  for all datasets.
.  ----------------------------------------------------------------- */
HA_STANDARD_HDR:                       /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   slug       = Right("",collen)"×"
   sluglen    = Length(slug)

   base_line = " ×"Copies(slug,dsn.0)  /* leader = 2 bytes           */

   do ii = 1 to dsn.0
      rdsn.ii  = Reverse(lvls.ii)      /* CEXE TSET 54321TD, maybe ? */
   end

   more = "1"
   do while more

      more = "0"
      hdrline = base_line              /* start of line              */

      do ii = 1 to dsn.0
         parse var rdsn.ii tlvl rdsn.ii /* TSET maybe                */
         tlvl  = Reverse(tlvl)         /* TEST maybe                 */
         pos = ((ii-1) * sluglen) + 4  /* 4, 15, 26, 37, maybe       */
         hdrline = Overlay( Left(tlvl,8) , hdrline , pos , 8 )
         if rdsn.ii <> "" then more = "1" /* do another cycle        */
      end

      push hdrline                     /* place on top of the stack  */

   end                                 /* while more                 */

   hdrline = base_line                 /* start separator line       */
   hdrline = Translate(hdrline,"-"," ")
   hdrline = Translate(hdrline,"+","×")
   hdrline = Overlay(" ",hdrline,1,1)
   queue hdrline

   hidx = 0; hdr.=""                   /* set up array               */
   do queued()                         /* hdrlines in stack          */
      pull hdrline                     /* pull topmost               */
      hidx = hidx + 1                  /* increment index            */
      hdr.hidx = hdrline               /* load to array              */
   end
   hdr.1 = Overlay("1",hdr.1)          /* page eject                 */
   hdr.0 = hidx                        /* how many header lines ?    */

return                                 /*@ HA_STANDARD_HDR           */
/*
.  build header records:
.  This routine builds header records for the "COMPACT" display:
.  starts with "          ×    ×" plus room for dataset identifier,
.  padded to l=3, repeat for all datasets.  Total length = 17 + 3
.  per dataset.
.  ----------------------------------------------------------------- */
HC_SHORTHDR:                           /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   base_line = "          ×    ×"      /* leader = 16 bytes          */
   hdrline = base_line                 /* start of line              */
   sluglen = 3

   queue hdrline                       /* place on bottom of stack   */

   hidx = 0; hdr.=""                   /* set up array               */
   do queued()                         /* hdrlines in stack          */
      pull hdrline                     /* pull topmost               */
      hidx = hidx + 1                  /* increment index            */
      hdr.hidx = hdrline               /* load to array              */
   end
   hdr.1 = Overlay("1",hdr.1)          /* page eject                 */

   hdrline = Copies("-",outlen)        /* all dashes                 */
   hdrline = Overlay(base_line,hdrline) /* overlay bars              */
   hdrline = Overlay("×",hdrline,outlen) /* last char = bar          */
   hdrline = Translate(hdrline,"-"," ")
   hdrline = Translate(hdrline,"+","×") /* bars become pluses        */
   hdrline = Overlay(" ",hdrline,1,1)

   hidx = hidx + 1                     /* increment index            */
   hdr.hidx = hdrline                  /* add to array               */
   hdr.0 = hidx                        /* how many header lines ?    */
   call HCA_TITLE_PG                   /* put up dsn list           -*/

return                                 /*@ HC_SHORTHDR               */
/*
.    Since the headers do not indicate the dataset name, we need a
.    title page which cross-references the indicators "(12)" to the
.    dataset name, e.g.:
.        (12) =   "TTGTCBS.DOCLIB.BLG.LETTERS"
.    These lines have to be PUSHed onto the top of the stack so that
.    they are written first.
.  ----------------------------------------------------------------- */
HCA_TITLE_PG:                          /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   asa = " "
   do i = dsn.0 to 1 by -1             /* for each dataset           */
      line = asa"      ("Right(i,2)")  = "Word(dsnstr,i)
      push line                        /* WRITE                      */
   end

   asa = "1"
   line = asa"    Compact member cross reference "
   push line                           /* WRITE                      */

return                                 /*@ HCA_TITLE_PG              */
/*
.  build header records (STATS="1") :
.  This routine builds header records for the "STATS" display:
.  starts with "          ×" plus room for member statistics,
.  padded to l=16, repeat for all datasets.  Total length = 13 + 16
.  per dataset.
.  ----------------------------------------------------------------- */
HS_STATHDR:                            /*@                           */
   if branch then call BRANCH
   address TSO

   slug       = Right("",collen)"×"
   sluglen    = Length(slug)
   base_line = "          ×"Copies(slug,dsn.0) /* leader = 11 bytes  */

   do ii = 1 to dsn.0
      rdsn.ii  = Reverse(lvls.ii)      /* CEXE TSET 54321TD, maybe ? */
   end

   more = "1"
   do while more

      more = "0"
      hdrline = base_line              /* start of line              */

      do ii = 1 to dsn.0
         parse var rdsn.ii tlvl rdsn.ii /* TSET maybe                */
         tlvl  = Reverse(tlvl)         /* TEST maybe                 */
         pos = ((ii-1) * sluglen) + 13 /* 13, 30, 47     maybe       */
         hdrline = Overlay( Left(tlvl,8) , hdrline , pos , 8 )
         if rdsn.ii <> "" then more = "1" /* do another cycle        */
      end

      push hdrline                     /* place on top of the stack  */

   end                                 /* while more                 */

   hdrline = base_line                 /* start separator line       */
   hdrline = Translate(hdrline,"-"," ")
   hdrline = Translate(hdrline,"+","×")
   hdrline = Overlay(" ",hdrline,1,1)
   queue hdrline                       /* after headers              */

   hidx = 0; hdr.=""                   /* set up array               */
   do queued()                         /* hdrlines in stack          */
      pull hdrline                     /* pull topmost               */
      hidx = hidx + 1                  /* increment index            */
      hdr.hidx = hdrline               /* load to array              */
   end
   hdr.1 = Overlay("1",hdr.1)          /* page eject                 */
   hdr.0 = hidx                        /* how many header lines ?    */

return                                 /*@ HS_STATHDR                */
/*
.   input is a stack, MLIST., with entries of the form:
.                 NAME # {*}
.   sorted by name and #
.
.   Output (for STATS='0') is a line of 'n' 10-char compartments
.   separated by vertical bars.  'n' is not larger than the largest
.   '#'.  The 'name' is placed in a compartment as indicated by '#'.
.
.   Output (for STATS='1') is a line of 'n' 16-char compartments
.   separated by vertical bars.  'n' is not larger than the largest
.   '#'.  The member statistics are placed in a compartment as
.   indicated by '#'.  The membername is placed at the far left of
.   the line.
.
.   Output (for COMPACT='1') is a line of 'n' 2-char compartments
.   separated by blanks.  The dataset number is placed in a
.   compartment as indicated by '#'.  The membername and the number
.   of occurences is placed at the far left of the line.
.  ----------------------------------------------------------------- */
Q_COMPOSE:                             /*@                           */
   if branch then call BRANCH
   address TSO

   if sw.0stats then call QA_LMOPEN    /*                           -*/
   wait_for_enter="0"                  /* prompting switch           */
   line = base_line                    /* init                       */
   call QP_NEWPAGE                     /* first set of headers      -*/

   save_mbr = word(mlist.1,1)          /* avoid initial break        */
   if sw.0compact × sw.0stats then,    /* ... load 1st membername    */
      line = Overlay(save_mbr,line,2,8)

   ind = ""                            /* "*" if ALIAS               */
   occurs = 0                          /* members per line           */
   do mx = 1 to mlist.0                /* for each list item         */

      parse var mlist.mx mbr pos ind . /* get name and position      */
      if save_mbr <> mbr then do       /* if name break              */
         if sw.0compact then,
            line = Overlay(Right(occurs,2),line,13,2)
         if sw.0dup_only & occurs=1 then nop /* skip                 */
         else call QQ_PUMPLINE         /* write the line at break   -*/
         latest_date = ""
         line = base_line
         occurs = 0
         save_mbr = mbr                /* store new name             */
         if sw.0compact × sw.0stats then,
            line = Overlay(mbr,line,2,8)
         end                           /* if name break              */

      spot = ((pos-1) * sluglen) +  margin + 2

      if sw.0compact then,
         line = Overlay(Right(pos,2,0)××ind,line,spot-1,collen+1)
      else,
      if sw.0stats then do
         call QS_GET_STATS             /*                           -*/
         line = Overlay(Left(mstat,collen),line,spot,collen-2)
         end
      else,
         line = Overlay(Left(mbr,collen)××ind,line,spot,collen-2)
      occurs = occurs + 1              /* count it                   */

   end                                 /* mx                         */

   if sw.0compact then,
      line = Overlay(Right(occurs,2),line,13,2)

   if sw.0dup_only & occurs=1 then nop /* skip                       */
   else call QQ_PUMPLINE               /* write the line at break   -*/

   if sw.0stats then call QZ_LMCLOSE   /*                           -*/

return                                 /*@ Q_COMPOSE                 */
/*
.  ----------------------------------------------------------------- */
QA_LMOPEN:                             /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   do lmx = 1 to dsn.0
      "LMINIT DATAID(LMID"lmx") DATASET("dsn.lmx")"
      "LMOPEN DATAID("Value("LMID"lmx)")"
   end

   latest_date = ""

return                                 /*@ QA_LMOPEN                 */
/*
.  ----------------------------------------------------------------- */
QP_NEWPAGE:                            /*@                           */
   if branch then call BRANCH
   address TSO

   if wait_for_enter then pull         /* wait for KB enter          */
   if outdsn="" then do
      wait_for_enter="1"               /* was initially off          */
      "CLEAR"                          /* clear the screen           */
      end

   do hidx = 1 to hdr.0                /* for each header line       */
      if outop = "QUEUE" then,
         queue hdr.hidx ; else,
         say   hdr.hidx
   end
   linect = hdr.0                      /* indicate lines used        */

return                                 /*@ QP_NEWPAGE                */
/*
.  ----------------------------------------------------------------- */
QQ_PUMPLINE:                           /*@                           */
   if branch then call BRANCH
   address TSO

   if sw.0stats then call QQA_AGE      /* who's newest              -*/
   if linect = pagelim then call QP_NEWPAGE /* page break           -*/

   if outop = "QUEUE" then,
      queue line    ; else,
      say   line

   linect = linect + 1                 /* indicate line used         */

return                                 /*@ QQ_PUMPLINE               */
/*
.  Input is <latest_date>; find any stats slug which matches and tag
.  it with an * to indicate "most recent copy".
.  ----------------------------------------------------------------- */
QQA_AGE:                               /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   if occurs = 1 then return           /* nothing to compare         */
   if \Datatype(Left(latest_date,1),"W") then return  /* no stats    */

   rc = Trace("O"); rc = Trace(tv)

   complen = Length(latest_date)
   do ibx = 1 to dsn.0
      start = ((ibx-1) * sluglen) + 13
      mslug = Substr(line,start,complen)  /* acquire statistics      */
      if latest_date = mslug then,
         line = Overlay(">",line,start-1,1)  /* mark it              */
   end                                 /* ibx                        */

return                                 /*@ QQA_AGE                   */
/*
.  Input is <mbr> and <pos>; get ISPF statistics for <mbr> in dataset
.  dsn.<pos>; load to variable <mstat> and return.
.  ----------------------------------------------------------------- */
QS_GET_STATS:                          /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   "LMMFIND DATAID("Value("LMID"pos)") MEMBER("mbr")  STATS(YES)"
   mstat = zlmdate zlmtime             /* 02/27/98 15:22    l=14+2   */
   if mstat = "" then,
      if ind = "*" then mstat = "(alias)"
      else mstat = "(no stats)"
   if latest_date < mstat then,
      latest_date = mstat

return                                 /*@ QS_GET_STATS              */
/*
.  ----------------------------------------------------------------- */
QZ_LMCLOSE:                            /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   do lmx = 1 to dsn.0
      "LMCLOSE DATAID("Value("LMID"lmx)")"
      "LMFREE  DATAID(LMID"lmx")"
   end

return                                 /*@ QZ_LMCLOSE                */
/*
   Parse out the embedded components at the back of the source code.
.  ----------------------------------------------------------------- */
DEIMBED: Procedure expose,             /*@                           */
   exec_name ddnlist branch tv monitor
   trace O
   address TSO

   fb80po.0  = "NEW CATALOG UNIT(sysda) SPACE(5 5) TRACKS DIR(40)",
               "RECFM(F B) LRECL(80) BLKSIZE(0)"
   fb80po.1  = "SHR"                   /* if it already exists...    */
   ddnlist = ""

   lastln   = sourceline()
   currln   = lastln                   /*                            */
   if Left(sourceline(currln),2) <> "*/" then return

   currln = currln - 1                 /* previous line              */
   "NEWSTACK"
   do while sourceline(currln) <> "/*"
      text = sourceline(currln)        /* save with a short name !   */
      if Left(text,3) = ")))" then do  /* package the queue          */
         parse var text ")))" ddn mbr .   /* PLIB PANL001  maybe     */
         outdsn = exec_name"."ddn
         stat = Sysdsn(outdsn) = "OK"
         if \stat then do              /* doesn't exist              */
            "ALLOC FI("ddn") DA("outdsn") REU" fb80po.0
            "FREE  FI("ddn")"
            end                        /*                            */
         if Pos(ddn,ddnlist) = 0 then, /* doesn't exist              */
            ddnlist = ddnlist ddn      /* keep track                 */
         "ALLOC FI("ddn") DA("outdsn"("mbr"))  SHR REU"
         "EXECIO"  queued() "DISKW"  ddn "(FINIS"
         end                           /* package the queue          */
      else push text                   /* onto the top of the stack  */
      currln = currln - 1              /* previous line              */
   end                                 /* while                      */
   "DELSTACK"

return                                 /*@ DEIMBED                   */
/*
.  ----------------------------------------------------------------- */
LOCAL_PREINIT:                         /*@ customize opts            */
   if branch then call BRANCH
   address TSO


return                                 /*@ LOCAL_PREINIT             */
/*
.  ----------------------------------------------------------------- */
HELP:                                  /*@                           */
address TSO;"CLEAR"
if helpmsg <> "" then do ; say helpmsg; say ""; end
say "  FCXREF  :::::::::::::                                          "
say "       produces a side-by-side list of member names in a set of  "
say "       concatenated libraries.                                   "
say "                                                                 "
say "  SYNTAX :  FCXREF   <DDNAME input-filename>                     "
say "                     <OUTPUT output-dsname>                      "
say "                     <NOHDR>                                     "
say "                     <LPP lines-per-page>                        "
say "                     <ISPF>                                      "
say "                     <CONFLICTS>                                 "
say "                     <COMPACT × STATS>                           "
say "                                                                 "
say "  Parameters which may be specified:                             "
say "          <DDNAME ddname> :  the datasets associated with the    "
say "            specified ddname are examined to produce a           "
say "            cross-reference list of the member names.            "
say "                                                                 "
say "          <OUTPUT outdsn> :  the resultant report is written to  "
say "            DSN=outdsn.  This dataset will be deleted if it      "
say "            exists and recreated with an appropriate LRECL.  By  "
say "            default, output is to the monitor.                   "
say "                                                                 "
say "          <NOHDR> :  all header lines (except the initial set)   "
say "            are suppressed.                                      "
say "                                                                 "
say "          <LPP lines-per-page> specifies the page length.        "
say "                                                                 "
say "          <ISPF> :  causes FCXREF to run as an ISPF dialog.      "
say "                                                                 "
say "          <CONFLICTS> : instructs FCXREF to show only lines      "
say "            where a membername exists in more than one dataset.  "
say "                                                                 "
say "          <STATS>  :  the date and time of last modification is  "
say "            shown for each member.                               "
say "                                                                 "
say "          <COMPACT>:  for cases in which many datasets are to be "
say "            matched, listing the membernames side-by-side        "
say "            may produce a listing too wide to be printed.        "
say "            COMPACT formats the listing as follows:              "
say "              -- a header page is printed, listing all the       "
say "                 datasets and assigning an index number to each. "
say "              -- membernames are listed once down the left       "
say "                 margin with a count of occurrences.  The balance"
say "                 of the line consists of numeric references to   "
say "                 the datasets listed on the first page.          "
say "                                                                 "
say "            In COMPACT-mode, the LRECL of the output dataset is  "
say "               LR = 3x + 16, where x = number of datasets.       "
say "            The minimum LRECL is 60.                             "
say "                                                                 "
say "            In expanded-mode, the LRECL of the output dataset is "
say "               LR = 11x + 2, where x = number of datasets.       "
say "                                                                 "
say "            In STATS-mode, the LRECL of the output dataset is    "
say "               LR = 17x + 2, where x = number of datasets.       "
say "                                                                 "
say "            Therefore, if the number of datasets exceeds 7, STATS"
say "            will produce a dataset too wide to be printed:       "
say "                        ((8x17) + 2 = 138);                      "
say "            if the number of datasets exceeds 11, only a         "
say "            'compact' list will be printable:                    "
say "                        ((12x11) + 2 = 134);                     "
say "            if the number exceeds 39, a printable list cannot be "
say "            produced:                                            "
say "                        ((40x3) + 16 = 136).                     "
say "            In any case, if the number of partitioned datasets   "
say "            concatenated to a single DDName gets near 39, you    "
say "            have other more urgent problems.                     "
say "                                                                 "
pull
"CLEAR"
say "   Debugging tools provided include:                             "
say "                                                                 "
say "        MONITOR:  displays key information throughout processing."
say "                  Displays most paragraph names upon entry.      "
say "                                                                 "
say "        USEHLQ:   causes dataset prefix to be altered as         "
say "                  specified.  (Not used by" exec_name".)         "
say "                                                                 "
say "        NOUPDT:   by-pass all update logic.  (Not used by        "
say "                  "exec_name".)                                  "
say "                                                                 "
say "        BRANCH:   show all paragraph entries.                    "
say "                                                                 "
say "        TRACE tv: will use value following TRACE to place        "
say "                  the execution in REXX TRACE Mode.              "
say "                                                                 "
say "                                                                 "
say "   Debugging tools can be accessed in the following manner:"
say "                                                                 "
say "        TSO" exec_name"  parameters  ((  debug-options"
say "                                                                 "
say "   For example:"
say "                                                                 "
say "        TSO" exec_name " (( MONITOR TRACE ?R"
address ISPEXEC "CONTROL DISPLAY REFRESH"
exit                                   /*@ HELP                      */
/*
.  ----------------------------------------------------------------- */
BRANCH: Procedure expose,              /*@                           */
        sigl exec_name
   rc = trace("O")                     /* we do not want to see this */
   arg brparm .

   $a#y = sigl                         /* where was I called from ?  */
   do $b#x = $a#y to 1 by -1           /* inch backward to label     */
      if Right(Word(Sourceline($b#x),1),1) = ":" then do
         parse value sourceline($b#x) with $l#n ":" . /* Paragraph   */
         leave ; end                   /*                name        */
   end                                 /* $b#x                       */

   select
      when brparm = "NAME" then return($l#n) /* Return full name     */
      when brparm = "ID"      then do  /*        Return prefix       */
         parse var $l#n $l#n "_" .     /* get the prefix             */
         return($l#n)
         end                           /* brparm = "ID"              */
      otherwise
         say left(sigl,6) left($l#n,40) exec_name "Time:" time("L")
   end                                 /* select                     */

return                                 /*@ BRANCH                    */
/*
.  ----------------------------------------------------------------- */
DUMP_QUEUE:                            /*@ Take whatever is in stack */
   rc = trace("O")                     /*  and write to the screen   */
   address TSO

   "QSTACK"                            /* how many stacks?           */
   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */
   if stk2dump = 0 & queued() = 0 then return
   say "Total Stacks" rc ,             /* rc = #of stacks            */
       "Begin Stacks" tk_init_stacks , /* Stacks present at start    */
       "Stacks to DUMP" stk2dump

   do dd = rc to tk_init_stacks by -1  /* empty each one.            */
      say "Processing Stack #" dd "Total Lines:" queued()
      do queued();pull line;say line;end /* pump to the screen       */
      "DELSTACK"                       /* remove stack               */
   end                                 /* dd = 1 to rc               */

return                                 /*@ DUMP_QUEUE                */
/*
.  ----------------------------------------------------------------- */
KEYWD: Procedure expose info           /*@ hide all vars, except info*/
   arg kw
   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */
   if kw_pos = 0 then return ""        /* send back a null, not found*/
   kw_val = word(info,kw_pos+1)        /* get the next word          */
   info   = Delword(info,kw_pos,2)     /* remove both                */
return kw_val                          /*@ KEYWD                     */
/*
.  ----------------------------------------------------------------- */
KEYPHRS: Procedure expose,             /*@                           */
         info helpmsg exec_name        /*  except these three        */
   arg kp
   wp    = wordpos(kp,info)            /* where is it?               */
   if wp = 0 then return ""            /* not found                  */
   front = subword(info,1,wp-1)        /* everything before kp       */
   back  = subword(info,wp+1)          /* everything after kp        */
   parse var back dlm back             /* 1st token must be 2 bytes  */
   if length(dlm) <> 2 then            /* Must be two bytes          */
      helpmsg = helpmsg,
                "Invalid length for delimiter("dlm") with KEYPHRS("kp")"
   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/
      helpmsg = helpmsg,
                "No matching second delimiter("dlm") with KEYPHRS("kp")"
   if helpmsg <> "" then call HELP     /* Something is wrong         */
   parse var back kpval (dlm) back     /* get everything b/w delim   */
   info =  front back                  /* restore remainder          */
return Strip(kpval)                    /*@ KEYPHRS                   */
/*
.  ----------------------------------------------------------------- */
NOVALUE:                               /*@                           */
   say exec_name "raised NOVALUE at line" sigl
   say " "
   say "The referenced variable is" condition("D")
   say " "
   zsigl = sigl
   signal SHOW_SOURCE                  /*@ NOVALUE                   */
/*
.  ----------------------------------------------------------------- */
SHOW_SOURCE:                           /*@                           */
   call DUMP_QUEUE                     /* Spill contents of stacks  -*/
   if sourceline() <> "0" then         /* to screen                  */
      say sourceline(zsigl)
   rc =  trace("?R")
   nop
   exit                                /*@ SHOW_SOURCE               */
/*
.  ----------------------------------------------------------------- */
SS: Procedure                          /*@ Show Source               */
   arg  ssbeg  ssend  .
   if ssend = "" then ssend = 10
   if \datatype(ssbeg,"W") × \datatype(ssend,"W") then return
   address TSO "CLEAR"
   ssend = ssbeg + ssend
   do ssii = ssbeg to ssend ; say sourceline(ssii) ; end
   address TSO "CLEAR"
return                                 /*@ SS                        */
/*
.  ----------------------------------------------------------------- */
SWITCH: Procedure expose info          /*@                           */
   arg kw
   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */
   if sw_val then                      /* exists                     */
      info = Delword(info,Wordpos(kw,info),1) /* remove it           */
return sw_val                          /*@ SWITCH                    */
/*
.  ----------------------------------------------------------------- */
SYNTAX:                                /*@                           */
   errormsg = exec_name "encountered REXX error" rc "in line" sigl":",
                        errortext(rc)
   say errormsg
   zsigl = sigl
   signal SHOW_SOURCE                  /*@ SYNTAX                    */
/*
.  ----------------------------------------------------------------- */
TOOLKIT_INIT:                          /*@                           */
   address TSO
   info = Strip(opts,"T",")")          /* clip trailing paren        */

   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm,
                 as_invokt  cmd_env  addr_spc  usr_tokn
   parse value "" with  tv  helpmsg  .
   parse value 0   "ISR00000  YES"     "Error-Press PF1"    with,
               sw.  zerrhm    zerralrm  zerrsm

   if SWITCH("TRAPOUT") then do
      "TRAPOUT" exec_name parms "(( TRACE R" info
      exit
      end                              /* trapout                    */

   if Word(parms,1) = "?" then call HELP /* I won't be back          */

   "QSTACK" ; tk_init_stacks = rc      /* How many stacks?           */

   parse value SWITCH("BRANCH") SWITCH("MONITOR") SWITCH("NOUPDT") with,
               branch           monitor           noupdt    .

   parse value mvsvar("SYSNAME") sysvar("SYSNODE") with,
               #tk_cpu           node          .

   sw.nested    = sysvar("SYSNEST") = "YES"
   sw.batch     = sysvar("SYSENV")  = "BACK"
   sw.inispf    = sysvar("SYSISPF") = "ACTIVE"

   "NEWSTACK"
   "DFLTHLQ"  ; pull hlq.  hlqdata
   "DELSTACK"

   do while hlqdata <> ""
      parse var hlqdata site hlq.site hlqdata
   end

   tk_hlq  = KEYWD("USEHLQ")
   parse value tk_hlq hlq.node with hlq . /* default to prod         */
   parse value KEYWD("TRACE")  "O"    with   tv  .

   call LOCAL_PREINIT                  /* for more opts             -*/

return                                 /*@ TOOLKIT_INIT              */
/*
)))PLIB GETLIBS
)ATTR
  % TYPE(TEXT)  INTENS(HIGH) SKIP(ON)
  + TYPE(TEXT)  INTENS(LOW) SKIP(ON)
  _ TYPE(INPUT) INTENS(HIGH)
  " TYPE(TEXT)  COLOR(YELLOW) SKIP(ON)
  @ TYPE(TEXT)  INTENS(LOW)  COLOR(YELLOW) SKIP(ON)
  ! TYPE(INPUT) INTENS(HIGH) COLOR(PINK) CAPS(OFF) JUST(ASIS)
  $ TYPE(INPUT) INTENS(HIGH) CAPS(ON)  JUST(ASIS)
  # TYPE(TEXT)  INTENS(HIGH) SKIP(ON)
)BODY EXPAND(||)
@Unsupported |-| %Member Cross-Reference@ |-|
%COMMAND ===>_ZCMD

+   Output DSN ===>$OUTDSN
+  Page Length ===>$LPP+ (lines)
+    Headers ? ===>$Z+   (Y or N)
+
+      Specify input#DDNAME+===>$DDN     +
+  #or+enter/verify dataset names below:
%===>$XRDSN1
%===>$XRDSN2
%===>$XRDSN3
%===>$XRDSN4
%===>$XRDSN5
%===>$XRDSN6
%===>$XRDSN7
%===>$XRDSN8
%===>$XRDSN9
%===>$XRDSN10
%===>$XRDSN11
%===>$XRDSN12
+
)INIT
 .ZVARS = '(HDR)'
 &ZCMD = &Z
)PROC
 VER(&XRDSN1,DSNAME)
 VER(&XRDSN2,DSNAME)
 VER(&XRDSN3,DSNAME)
 VER(&XRDSN4,DSNAME)
 VER(&XRDSN5,DSNAME)
 VER(&XRDSN6,DSNAME)
 VER(&XRDSN7,DSNAME)
 VER(&XRDSN8,DSNAME)
 VER(&XRDSN9,DSNAME)
 VER(&XRDSN10,DSNAME)
 VER(&XRDSN11,DSNAME)
 VER(&XRDSN12,DSNAME)
 VER(&DDN,NAME)
 VER(&LPP,NUM)
 VER(&OUTDSN,DSNAME)
 &HDRA = TRUNC(&HDR,1)
 VER(&HDRA,LIST,Y,N)
    &NOHDR = TRANS(&HDR N,NOHDR Y,HDR)
 VPUT (XRDSN1 XRDSN2 XRDSN3 XRDSN4 XRDSN5 XRDSN6)
 VPUT (XRDSN7 XRDSN8 XRDSN9 XRDSN10 XRDSN11 XRDSN12)
)END
*/
