CONFIGXX TITLE 'Construct CONFIGxx Member'
*-------------------------------------------------------------------*
* Name            : CONFIGXX
*
* Function        : This program will construct the CONFIGxx member
*                   based on the active system.
*                   The idea being that this program is run when you
*                   are satisfied that the system has everything
*                   online that you need.
*
*                   The output is written to the PARMLIB DDName
*
* Example JCL     : //CONFIG   EXEC PGM=CONFIGXX
*                   //STEPLIB  DD   DISP=SHR,DSN=some.dataset
*                   //PARMLIB  DD   DISP=SHR,DSN=SYS1.PARMLIB(CONFIG00)
*
*
* IBM Macros Used : MODID, STORAGE, TIME, UCBSCAN, UCBDEVN, UCBINFO,
*                   OPEN, PUT, CLOSE
*                   DCB, CVT, IEFUCBOB, IOSDPATH, IARRCE, IHAASCB,
*                   IHAASXB, IHAACEE
*
* Attributes      : Amode(31)
*                   Rmode(24)
*                   NORENT
*                   NOREUS
*                   NOREFR
*                   AC(0)
*
* Register Usage  :
*
* R1  -
* R2  - Device Type Table
* R3  - Work
* R4  - UCB
* R5  - CVT
* R6  - RCE
* R7  - Work
* R8  - Work
* R9  - Path Info Array
* R10 - Branch and Link
* R11 - Branch and Link
* R12 - Base reg
* R13 - Workarea
* R14 -
*
*
*-------------------------------------------------------------------*
* Changes
* 02/11/1999  Rob Scott  Code Written                            V1.0
*-------------------------------------------------------------------*
*-------------------------------------------------------------------*
* Copyright : Scott Enterprise Consultancy Ltd
*-------------------------------------------------------------------*
CONFIGXX CSECT
CONFIGXX AMODE 31
CONFIGXX RMODE 24
         BAKR  R14,R0                 linkage stack
         LAE   R12,0(R15,0)           set R12 as base
         USING CONFIGXX,R12           address it
         MODID ,                      eyecatcher
GETWORK  EQU   *
*--------------------------------------------------------------------*
* Get some workarea storage and init to zeros.
*--------------------------------------------------------------------*
         STORAGE OBTAIN,              get the workarea storage         X
               LENGTH=WORKLEN,        this much                        X
               ADDR=(R13),            address in r13                   X
               SP=0,KEY=8,            subpool 0 storage key 8          X
               LOC=BELOW,             below the line                   X
               COND=NO                unconditional
         USING WORKAREA,R13           address workarea
         LR    R14,R13                Copy workarea address
         L     R15,=A(WORKLEN)        Get length of workarea
         XR    R0,R0                  Clear
         XR    R1,R1                  Clear
         MVCL  R14,R0                 Init to zeros
         MVC   4(4,R13),=C'F1SA'      set label in savearea
INIT     EQU   *
*--------------------------------------------------------------------*
* Open the PARMLIB dataset and write a comment indicating the
* time and date of the generation.
*--------------------------------------------------------------------*
         OPEN  (PARMLIB,(OUTPUT))     Open the dataset
         L     R5,CVTPTR              Get the CVT
         USING CVTMAP,R5              Address it
         TIME  DEC,TIMEDATE,          get time and date                X
               DATETYPE=YYYYMMDD,     ..in format yyyymmdd             X
               LINKAGE=SYSTEM
         MVC   OUTREC(80),BLANKS      Blank the time
         MVC   OUTREC(40),HEADER0     Copy in the header
         PUT   PARMLIB,OUTREC
         MVC   OUTREC(40),HEADER1     Blank the time
         MVC   OUTREC+2(34),=CL34'Generated by the CONFIGXX program'
         PUT   PARMLIB,OUTREC
         MVC   OUTREC(80),BLANKS      Blank the time
         MVC   OUTREC(40),HEADER1     Blank the time
         MVC   OUTREC+2(32),=CL32'     Date : yyyy/mm/dd'
         LA    R0,4                   Set length (yyyymmdd)
         LA    R1,TIMEDATE+8          Point to the hex
         LA    R15,UWORK              Point to the output
         BAL   R14,HEX2CHAR           Make printable
         MVC   OUTREC+14(4),UWORK     Copy in YYYY
         MVC   OUTREC+19(2),UWORK+4   Copy in MM
         MVC   OUTREC+22(2),UWORK+6   Copy in DD
         PUT   PARMLIB,OUTREC
         MVC   OUTREC(80),BLANKS      Blank the time
         MVC   OUTREC(40),HEADER1     Blank the time
         MVC   OUTREC+2(32),=CL32'     Time : hh.mm.ss'
         LA    R0,3                   Set length (hhmmss)
         LA    R1,TIMEDATE            Point to the hex
         LA    R15,UWORK              Point to the output
         BAL   R14,HEX2CHAR           Make printable
         MVC   OUTREC+14(2),UWORK     Copy in HH
         MVC   OUTREC+17(2),UWORK+2   Copy in MM
         MVC   OUTREC+20(2),UWORK+4   Copy in SS
         PUT   PARMLIB,OUTREC
         MVC   OUTREC(80),BLANKS      Blank the time
         MVC   OUTREC(40),HEADER1     Blank the time
         MVC   OUTREC+2(32),=CL32'     User : '
GETUSER  EQU   *
         L     R15,0(R5)              Get the TCB words
         L     R15,12(R15)            Get the ASCB
         L     R15,ASCBASXB-ASCB(R15) Get the ASXB
         L     R15,ASXBSENV-ASXB(R15) Get the ACEE address
         MVC   OUTREC+14(8),ACEEUSRI-ACEE(R15)
         PUT   PARMLIB,OUTREC
         MVC   OUTREC(40),HEADER0     Copy in the header
         PUT   PARMLIB,OUTREC
STAGE1   EQU   *
*--------------------------------------------------------------------*
* Stage One : Get the online CPUs and for each one write out
*             a "CPU (x)" record
*--------------------------------------------------------------------*
         L     R6,CVTPCCAT            Get the PCCAT
         XR    R3,R3                  Clear
LOOPPCCA EQU   *
         ICM   R8,B'1111',0(R6)       Is there a PCCA ?
         BZ    NOCPU                  No - ignore
         MVC   OUTREC(80),BLANKS      Yes - blank line
         MVC   OUTREC(7),CPU          Move in 'CPU (x)'
         STCM  R3,B'0001',UWORK       Store CPU number
         LA    R0,1                   Set length for HEX2CHAR
         LA    R1,UWORK               Point to input
         LA    R15,SWORK              Point to output
         BAL   R14,HEX2CHAR           Convert to hex
         MVC   OUTREC+5(1),SWORK+1    Move in the CPU number
         PUT   PARMLIB,OUTREC         Write it out
NOCPU    EQU   *
         LA    R3,1(R3)               Inc CPU count
         C     R3,=F'16'              last one ?
         BNL   STAGE2                 yes - exit
         LA    R6,4(R6)               Get next PCCA
         B     LOOPPCCA
STAGE2   EQU   *
*--------------------------------------------------------------------*
* Stage Two : Get the STOR value and write out a "STOR 0M-nnnM"
*             record
*--------------------------------------------------------------------*
         L     R15,CVTRLSTG           Get the Real Storage (K)
         LA    R15,1(R15)             Add one
         SRL   R15,10                 Divide by 1024 = Mb
         CVD   R15,DWORK              Convert to decimal
         MVC   UWORK(8),MASK          Copy in the mask
         ED    UWORK(8),DWORK+4       Make printable
         MVC   OUTREC(80),BLANKS      Blank the line
         MVC   OUTREC(8),STOR         Add 'STOR 0M-'
         MVI   UWORKLEN,8             Set max length of UWORK
         BAL   R10,STRIP              and strip leading chars
         LA    R1,OUTREC+8            Point to target area
         LA    R15,SWORK              Point to source
         XR    R14,R14                Clear
         IC    R14,SWORKLEN           Get the length
         BCTR  R14,R0                 -1 for execute
         EX    R14,MOVEDATA           Move it in
         XR    R14,R14                Clear
         IC    R14,SWORKLEN           Get the length
         AR    R1,R14                 Go to end of card
         MVI   0(R1),C'M'             add 'M' for Mb
         PUT   PARMLIB,OUTREC         Write out the record
STAGE3   EQU   *
*--------------------------------------------------------------------*
* Stage Three : Get the ESTOR value and write out a "ESTOR 0M-nnnM"
*--------------------------------------------------------------------*
         L     R6,CVTRCEP             get address of rce
         USING RCE,R6                 address it
         L     R15,RCEESPL            Get the # expanded frames
         SLL   R15,2                  x4 = amount in K
         SRL   R15,10                 Divide by 1024 = Mb
         CVD   R15,DWORK              Convert to decimal
         MVC   UWORK(8),MASK          Copy in the mask
         ED    UWORK(8),DWORK+4       Make printable
         MVC   OUTREC(80),BLANKS      Blank the line
         MVC   OUTREC(9),ESTOR        Add 'ESTOR 0M-'
         MVI   UWORKLEN,8             Set max length of UWORK
         BAL   R10,STRIP              and strip leading chars
         LA    R1,OUTREC+9            Point to target area
         LA    R15,SWORK              Point to source
         XR    R14,R14                Clear
         IC    R14,SWORKLEN           Get the length
         BCTR  R14,R0                 -1 for execute
         EX    R14,MOVEDATA           Move it in
         XR    R14,R14                Clear
         IC    R14,SWORKLEN           Get the length
         AR    R1,R14                 Go to end of card
         MVI   0(R1),C'M'             add 'M' for Mb
         PUT   PARMLIB,OUTREC         Write out the record
STAGE4   EQU   *
*--------------------------------------------------------------------*
* Stage Four  : Scan thru the UCBs and write out a "DEV (uuuu),(xx)"
*               record for each online device class
*--------------------------------------------------------------------*
         LA    R2,DEVTABLE            Point to device type table
LOOPDEVT EQU   *
         CLI   0(R2),X'FF'            End of table
         BE    RETURN                 Yes - finished
         MVC   OUTREC(80),BLANKS      Blank the line
         MVC   OUTREC(40),HEADER0     Write a header
         PUT   PARMLIB,OUTREC         Write the record
         MVC   OUTREC(40),HEADER1     Write a header
         MVC   OUTREC+2(22),1(R2)
         PUT   PARMLIB,OUTREC         Write the record
         MVC   OUTREC(40),HEADER0     Write a header
         PUT   PARMLIB,OUTREC         Write the record
         MVC   DEVCID(1),0(R2)        Copy in device class
         BAL   R11,GETUNITS           Loop thru the UCBs
         LA    R2,23(R2)              Point to next entry
         B     LOOPDEVT
RETURN   EQU   *
         CLOSE (PARMLIB)              Close the dataset
         STORAGE RELEASE,             free workarea storage            X
               LENGTH=WORKLEN,        this much                        X
               ADDR=(R13),            address in r13                   X
               SP=0,KEY=8,            subpool 0 storage key 8          X
               COND=NO                unconditional
         XR    R15,R15                Clear RC
         PR
*
GETUNITS EQU   *
*--------------------------------------------------------------------*
* Routine to loop thru the UCBs for a specified device class and
* locate online units.
*--------------------------------------------------------------------*
         LA    R4,UCBAREA             Point to copy of UCB
         USING UCBCMSEG,R4            address it
         XC    WORKUCB,WORKUCB        Clear UCB workarea
UNITSCAN EQU   *
         UCBSCAN COPY,                Perform UCBSCAN                  X
               WORKAREA=WORKUCB,      Use this workarea                X
               UCBAREA=UCBAREA,       Copy UCB here                    X
               CMXTAREA=CMXTAREA,     UCB Common extension             X
               DEVCID=DEVCID,         Only find this device class      X
               DEVN=0,                Start at beginning               X
               RANGE=ALL,             Include 4-digit devices          X
               DYNAMIC=YES            and dynamic UCBs
         C     R15,=F'4'              check rc
         BH    UNITSCAN               If RC > 4 ignore
         BE    UNITFINI               If RC = 4 then finished
         TM    UCBSTAT,UCBONLI        Is it Online ?
         BNO   UNITSCAN               No - get next
         MVC   VOLSER(6),UCBVOLI      Copy the Volser
         UCBDEVN DEVN=UNITADDR        Get the unit address
         XR    R1,R1                  Clear
         CLI   DEVCID,X'20'           Is it DASD ?
         BNE   NOTDASD                No - don't write volser
         LA    R1,VOLSER              Point to the volser
NOTDASD  EQU   *
         BAL   R10,DEVREC             Write a device record
         B     UNITSCAN
UNITFINI EQU   *
         BR    R11                    Return
*
STRIP    EQU   *
*-------------------------------------------------------------------*
* Routine to strip leading blanks from the UWORK field and place
* result in the SWORK field.
* UWORKLEN contained the source length
* SWORKLEN contained the result length
*-------------------------------------------------------------------*
         XR    R0,R0                  Clear
         IC    R0,UWORKLEN            Get max loop
         LA    R1,UWORK               Point to 1st char
         LA    R15,SWORK              Point to output area
         MVC   SWORK(8),BLANKS        Blank it out
         XR    R14,R14                Clear
STRIPCLI EQU   *
         CLI   0(R1),C' '             Is it a blank ?
         BE    STRIPBLK               Yes - no copy performed
         MVC   0(1,R15),0(R1)         No - copy the data in
         LA    R15,1(R15)             and adjust pointers...
         LA    R1,1(R1)
         LA    R14,1(R14)             add to chars copied
         BCT   R0,STRIPCLI            Loop for all
         B     STRIPEXT               and quit
STRIPBLK EQU   *
         LA    R1,1(R1)               Point to next input char
         BCT   R0,STRIPCLI            and loop round
STRIPEXT EQU   *
         STCM  R14,B'0001',SWORKLEN   Store length
         BR    R10
*
HEX2CHAR EQU   *
*--------------------------------------------------------------------*
* Convert a hex string to EBCDIC
* Regs on entry :
*   R0  :  Length of entry
*   R1  :  Hex string
*   R15 :  Output area
* Regs used within routine
*   R7  :  Work reg
*--------------------------------------------------------------------*
LEFTHALF EQU   *
         XR    R7,R7                  Clear
         ICM   R7,B'0001',0(R1)       Load up a byte (000000ab)
         SRL   R7,4                   Remove last 4 bits (0000000a)
LEFTNUM  EQU   *
         CH    R7,=H'9'               00000000 - 00000009 ?
         BH    LEFTLTTR               higher - must be A-F
         AH    R7,=H'240'             xlate to F0-F9
         B     LEFTDONE
LEFTLTTR EQU   *
         AH    R7,=H'183'             xlate to C1-C6
LEFTDONE EQU   *
         STCM  R7,B'0001',0(R15)      Store in token
         LA    R15,1(R15)             Point to next char
RGHTHALF EQU   *
         XR    R7,R7                  Clear
         ICM   R7,B'0001',0(R1)       Load up a byte (000000ab)
         SLL   R7,28                  Remove first 4 bits (b0000000)
         SRL   R7,28                  and reset           (0000000b)
RGHTNUM  EQU   *
         CH    R7,=H'9'               00000000 - 00000009 ?
         BH    RGHTLTTR               higher - must be A-F
         AH    R7,=H'240'             xlate to F0-F9
         B     RGHTDONE
RGHTLTTR EQU   *
         AH    R7,=H'183'             xlate to C1-C6
RGHTDONE EQU   *
         STCM  R7,B'0001',0(R15)      Store in token
         LA    R15,1(R15)             Point to next char
         LA    R1,1(R1)               Point to next token byte
         BCT   R0,LEFTHALF            Loop for all bytes
         BR    R14                    return
*
DEVREC   EQU   *
*-------------------------------------------------------------------*
* Routine to write a DEV record
* Regs on entry :
*  R1  : Pointer to a volser (or zero)
*  R4  : UCB address
* Regs used within routine :
*  R3  : Number of paths
*  R8  : Pointer within output record
*  R9  : PATH ARRAY from UCBINFO
*-------------------------------------------------------------------*
         MVC   OUTREC(80),BLANKS      Blank the line
         MVC   OUTREC(35),DEV         Setup the 'DEV' statement
         MVC   OUTREC+4(4),UNITADDR   copy in the unit address
         MVC   OUTREC+40(8),=C'Devtype='
         LTR   R1,R1                  Is there a volser ?
         BZ    DEVPATHS               No - ignore
         MVC   OUTREC+57(7),=CL7'Volser='
         MVC   OUTREC+64(6),0(R1)
DEVPATHS EQU   *
         LA    R0,4                   Length of UCBTYP
         LA    R1,UCBTYP              Point to device type
         LA    R15,OUTREC+48          Point to output area
         BAL   R14,HEX2CHAR           Convert to EBCDIC
         LA    R8,OUTREC+11           Point to first path in record
         UCBINFO PATHINFO,            Get path information             X
               PATHAREA=PATHAREA,     Put in this area                 X
               DEVN=UCBCHAN           Use the device addr in the UCB
         LA    R9,PATHAREA            Point to path area
         USING PATH,R9                address it
         ICM   R3,B'1111',PATH#CHPIDS Get number of paths
         LA    R9,PATHCHPID           Point to path array
         USING PATHCHPIDARRAY,R9      Address it
LOOPPATH EQU   *
         TM    PATHBITS,PATHLPM+PATHPAM Online ?
         BNO   NEXTPATH
         LA    R0,1                   set length for HEX2CHAR
         LA    R1,PATHCHPID+1         Point to path number
         LR    R15,R8                 Point to output area
         BAL   R14,HEX2CHAR           Write out CHPid
         MVI   2(R8),C','             add a comma
         LA    R8,3(R8)               Point to next path
NEXTPATH EQU   *
         LA    R9,28(R9)              Get next path
         BCT   R3,LOOPPATH            Loop for all
ENDPATH  EQU   *
         BCTR  R8,R0                  Go back a space
         MVI   0(R8),C')'
*
         PUT   PARMLIB,OUTREC         Write the record out
         BR    R10                    return
*
*-------------------------------------------------------------------*
* Constants, Variables and DSECTs
*-------------------------------------------------------------------*
*
MOVEDATA MVC   0(0,R1),0(R15)         Executed MOVE
         LTORG
*
PARMLIB  DCB   DDNAME=PARMLIB,MACRF=PM,DSORG=PS,RECFM=FB,LRECL=80
*
CPU      DC    CL7'CPU (x)'
STOR     DC    CL8'STOR 0M-'
ESTOR    DC    CL9'ESTOR 0M-'
DEV      DC    CL35'DEV(uuuu),(                        '
*
MASK     DC    XL8'4020202020202120'
BLANKS   DC    CL80' '
HEADER0  DC    CL40'*--------------------------------------*'
HEADER1  DC    CL40'*                                      *'
DEVTABLE DC    X'80',CL22'TAPE Device Section'
         DC    X'20',CL22'DASD Device Section'
         DC    X'41',CL22'CTC Device Section'
         DC    X'40',CL22'COMMS Device Section'
         DC    X'10',CL22'DISP Device Section'
         DC    X'08',CL22'UNITREC Device Section'
         DC    X'04',CL22'CHAR Device Section'
         DC    X'FF',CL22'***End of Table***'
*
WORKAREA DSECT
SAVEAREA DS    18F                    save area
DWORK    DS    D                      Packed work field
TIMEDATE DS    2D                     Area for Time+Date
DEVCID   DS    X                      Device class ID
UWORKLEN DS    X                      Length of UWORK
UWORK    DS    CL8                    Unpacked work field
SWORKLEN DS    X                      Length of SWORK
SWORK    DS    CL8                    Stripped field
OUTREC   DS    CL80                   PARMLIB record
         DS    0D
VOLSER   DS    CL6                    Volser
UNITADDR DS    CL4                    Unit address
         DS    0D
UCBRC    DS    F                      Return code from UCBSCAN
UCBRSN   DS    F                      Reason code from UCBSCAN
         DS    0D
UCBAREA  DS    CL48                   area to get UCB copy
UCBPAREA DS    CL48                   area to get UCB prefix copy
CMXTAREA DS    CL32                   area to get CMXT copy
WORKUCB  DS    CL100                  UCBSCAN workarea
         DS    0D
PATHAREA DS    CL256                  Area for path info
WORKLEN  EQU   *-WORKAREA
*
         CVT DSECT=YES,LIST=NO        CVT
         IEFUCBOB                     UCB
         IOSDPATH
         IARRCE
         IHAASCB
         IHAASXB
         IHAACEE
*
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         END
