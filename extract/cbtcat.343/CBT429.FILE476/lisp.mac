‹\INMR01








PLY   
  ARGS    
525   ASSQL   
L 
OLE   
  CEILING 
B1525   
  
PYENV 
5   COPYTREE
	
T 
DELQL   
5   
¦
  
ERROR   


ODEN



SIZE
	×







?ÿ





°
°



°Î



°Ð

MXDEFARG

°„
	×
SEB1525   MXDEFMAC
_

?°…
ST  
SEB1525   MXIF    


?° 
525   MXMVCALL



B1525   MXPROG2 


  MXRELÿ
B1525   MXSASSOC

TIME  
5   MXWOF   
B1525   NCONC   

NOTANY  
5   OPEN    
B1525   PARSBODY
C   
PEEKL   
5   PM1     
SEB1525   
ME  
PRINT   
5 ÿ

    
READ    
525   

UPQU
  REMQUAL 


UND   
  

D 
TRIM  

Â
  



UA


¦

	×

º

?	

ü



?

ì



?
	×



?




CRETF 

½

B1525   ZCCTBODY

Á
M 
B1525   ZCGBCALL
S
Ã
5   ZCGBUWP 
SEB1525   ZCGCLOS 

ZCGDEF  
525   ZCGEMIT 
SEB1525   ZCGENOUT

  ZCGEUWP 
525   ZCGGTARG
SEB1525   ZCGGTREG
GGTVAR
  ZCGIMEMQ
525   ZCGINLIN
SEB1525   
GLABEL
  ZCGMVINI
525   ZCGRECUR
S 
GSGOTO
  ZCGSTTRG
B1525   
C 
SDFSTR
5   ZCSRFS  
	
LD
ZEVDSUB 
5   
	
P 
ZEVSYM  

°
FPO 



OCON
	×




	


?ÿ






©§‹	×








	×
ZRMAPPLY

·
	×
SEB1525   ZRMCOMMA


?·µ
NOP 
SEB1525   ZXARFUN 


?
525   ZXCARCDR



B1525   ZXLIST  


  ZXMEMÿ
B1525   ZXNTH   

PROGN 
5   ZXRELOP 
B1525   ZXSETQ  

ZXVALUES
5   ZXZILGT 
B1525   ZXZMSASS
SEQ 
ÿÿÿÿÿÿÿÿ


*******************************************
                                      *
 Stark Draper Laboratory Inc.     *
                                *
                            *
*************************
r use under the interpreter only.  The compiler implements
cro that expands into the requisite number of calls

±
))
pend2 (zcar x) (append-list (cdr x)))))
	

;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
         All rights reserved.                                        *
                                                                 *
**************************************************************
; APPLY

  ((null l)               ; (apply #'foo)
LY"))
r l))
 a list" (zcar l)))
(apply #'foo list1 ... listn)
   (z nil

 l))
             (zerror "Last arg to APPLY not a list" (zcar l)))
d z (zcar l))
	

;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
         All rights reserved.                                        *
                                                                 *
**************************************************************
lly, this iÿ
osed to print out information about each symbol.
eele, 1984), p. 443.
ingp symbol-or-string)
 to APROPOS not a string or symbol" symbol-or-string))
blist) (cdr symbols))
)
d
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ; ; The following weeds out TWA's.
cause currently all function
portant) there is a
 an atom
 does  ; (or (symbol-plist (zcar symbols))
s))
ymbols)))
;;
	

;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
         All rights reserved.                                        *
                                                                 *
**************************************************************
GS
nname) returns:
 args

       (the #o776 is a hack used in Maclisp - don't question it)
 funname data) is not supported, but returns funname.
de funname's are supported at this time.
ecause of Macsyma.  Therefore, it also
he LOADFILE property, since it
;
****

;*                                                                     ÿ
 04/28/88 - Corrected bug in specification of *loadfile* variable.   *
                                                                 *
**************************************************************
clare ÿ
x)
ing process.
 function name" f))
 args cannot be updated" f d))
adfile))
Á
     (restarg (restarg x))
                (cons minargs #o776))
 nil minargs))

il)))
************************************
                               *
Draper Laboratory Inc.     *
                         *
                     *
******************
-------------------
===================
comparison (let ((x
    ; OK, which is it?
;;   ; (1) No :key?
 `(,@test item (zcar elt))
     ;;;   ; (2) :key applied instead of the CAR?
;
          ;;;                         `(,@key elt)))
   ;
t?
if key `(,@key (zcar elt))
(zcar elt)))
'm going with (3) - seems to be correct.
                      ))

      ((and (setq elt (zcar alist))
    (go true))

urn elt)))))
============
                      (test-not nil test-not?)
  (key nil key?)  ; what does :key do???
  ((and test? test-not?)
 to ASSOC"))
a list"ÿ
ll test-not) (funcall key) t)
      t)))
  (funcall key) nil)
il)))
l key) nil)
 
********************************
                           *
er Laboratory Inc.     *
                     *
                 *
**************
P (ASSOC A B :TEST #'EQL)
p (when y
      (eql x (zcar a)))
           (go loop))
	¶	¶
*******
  *
<

*********************************************************************

UAL)
**********
     *
   *

;*                                              ÿ
**********************************************************************

        (cond
al item (zcar elt)))
))
e 
*****************************************************************
                                                            *
right 1989 The Charles Stark Draper Laboratory Inc.     *
ghts reserved.                                        *
                                                  *
***********************************************
)
***********************************************************
                                                      *
1989 The Charles Stark Draper Laboratory Inc.     *
eserved.                                        *
                                            *
*****************************************

ents" 'boole))
s)))
     ÿ
q v (zilbool op v (zcar ints)))
ssembler code that corresponds to the following...
p int1 int2)
  (#B0001   (logand int1 int2))
t2))
int2)))
2))
(logior int1 int2)))
        (#B1010   (lognot int1))
 int2))
nt1 (lognot int2)))
       (#B1111   -1)


************************
                   *
atory Inc.     *
             *
         *
******
y has a
; a current special binding or global binding, and the value of
ing is not the "unbound" marker).
OUNDP calls ZEVSYM, it has the capability
ading process.  Compare FBOUNDP.
ed, this version of the function
ssembler-coded function
ence as well)
r
ÿ

  14,=A(symbol)
e handler knowsÿ
ranch to unbound-variable
ling mode
code
loading, there will have to be a different
oad to take place.  Obviously, if
 by simple reference to
OUNDP will be
a &aux b)
a symbol" a)
ecial" bindings only
	

;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
         All rights reserved.                                        *
                                                                 *
**************************************************************
iling (x &oÿ
 (integerp x) (integerp y))
                      x)
 8)))

*********************************************************************
                                                                *
Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
l rights reserved.                                        *
                                                      *
***************************************************
ÿ
 following bit settings:
Bit 30:     1 = append
ose 2 2 nil)
le (case (if (atom mode) mode (car mode))
t)         #b  00)
                     ((append á :append)       #b  11)
((:in :input)           #b  00)
 #b  01)

**********************************
                             *
aper Laboratory Inc.     *
                       *
                   *
****************
un clrscrn ()
££
*******
  *
<

*********************************************************************
CONCAT 
r OPS5.

a) (concatl a))
***************************************************
                                              *
 Charles Stark Draper Laboratory Inc.     *
                                        *
                                    *
*********************************
nil))    ; list to interned symbol
**********************************************************************
                                                                 *
 Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
ll rights reserved.                                        *
                                                       *
****************************************************
Iÿ
ntains the
;; All ZIL 1.3 code that needs to copy an environment should
nction.

nenv #'foo)))
,x nil))
NV.")
	
****************************************
                                   *
ark Draper Laboratory Inc.     *
                             *
                         *
**********************
There will have to be
syma
 (unless (symbolp a) (zerror "Arg 1 to COPY-SYMBOL not a symbol" aÿ
((z (make-symbol a)))
py-list (symbol-plist a)))
 line for deep binding.
 ÿ
        )
 deep binding.
;;
;;;;
     ;;;;; Copy the function definition... this code stinks, I know.
;;;
etq f (get a 'subr))
        ((setq f (get a 'expr))

 'macro) f))
 (setf (get z 'fexpr) f))
mplement the following line only if using function cells.
    ;;;;; (setf (symbol-function z) (symbol-function a))

will not be necessary with a full Common Lisp.
t   (x) `(append ,x nil))
,x) nil nil))
*************************************************
                                            *
harles Stark Draper Laboratory Inc.     *
                                      *
                                  *
*******************************
 complete copy of a LISP list.  This
tions in order to prevent
sts.
s (copy-tree (zcar x))
y-tree copytree)
****************************************************
                                               *
e Charles Stark Draper Laboratory Inc.     *
.                                        *
                                     *
**********************************
str))

************************************
                               *
Draper Laboratory Inc.     *
                         *
                     *
******************
.))

**********************************************************
                                                     *
989 The Charles Stark Draper Laboratory Inc.     *
served.                                        *
                                           *
****************************************
. ...DEF2... ...DEF3...) PROPERTY)
mpatibility with 1.5-style LISPs.

do (Í putprop f-name f-lambda-exp prop)))
 

ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
      All rights reserved.                                        *
                                                              *
***********************************************************
MAC"
or
RDRMACRO to define the
SUBR, which
„
me.

ample:
;
 (defun defrdrmacro fexpr (x)
ddr x))) (defrdmac (car x) (cadr x)))
ments - DEFRDRMACRO"))))
efun defrdmac (c f)
o* f (rdmac-symbol c))
 ((symbolp c) c)


**************
         *
     *
   *

 
LETE A B :TEST #'EQL)
 the object to be searched for.
a count of occurrences, default = deleteÿ
z)
n c
ount argument" c))
(return z))
.
tq n (cdr n))
 n))

À
²
***********************
                  *
tory Inc.     *
            *
        *
*****
on LISP (DELETE A B :TEST #'EQUAL)

rom.


Invalid DELQUAL count argument" c))

(sublist of b) ...
À

 (setq c (1- c)))
         (setq m n
oop)))
********************************************
                                       *
s Stark Draper Laboratory Inc.     *
                                 *
                             *
**************************
(defun ed (&optional a &aux (edds "SPFTEMPZ.ZILEDIT.LISP"))
…

(stringp a)  (clrscrn)
 (t (zerror "Arg to ED not a string (dsname) or symbol (function)" a))
)
datasÿ
e a new one
 data set.

dds 'out)
ile)
(princ " - definition of function "ÿ
 (terpri file)
pri file)
definition not found" file)
efined, compiled or internal subroutine)" file)
    (terpri file)


<
* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
        All rights reserved.                                        *
                                                                *
*************************************************************
.(zil-sour= ce-member zcsdfstr))
read file #.%%endread nil nil nil nil))
<
*                                                                     *
L (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
    All rights reserved.                                        *
                                                            *
*********************************************************
l-sourä ce-member zcsdfstr))
e #.%%eof nil nil nil nil))
***************************************************************
                                                          *
ght 1989 The Charles Stark Draper Laboratory Inc.     *
ts reserved.                                        *
                                                *
*********************************************
ms are EQUAL only if they are EQL.
  (eql a b)
car b))
	

;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
         All rights reserved.                                        *
                                                                 *
**************************************************************
; This is aÿ

efun equalp (a b)
(zilequal a b))
 a) (car b))
 (stringp b)
p a)

*******************************************
                                      *
 Stark Draper Laboratory Inc.     *
                                *
                            *
*************************
ommon Lisp compatible ERROR function.  It uses FORMAT
r message string.  However, it also attempts to
r ZIL (and Maclisp) calls to ERROR by
input is not in what appears to
; Reference: CLtL, 1st ed., pp. 429-430.
dest format-string args)

-string nil fs?) &rest args)
 (consp format-string)
))))
o-it format-string args))
atting error string"
rror-do-it (format-string args)
ndented-string (apply-format nil format-string args))))
nc-indented-string (string &aux (prefix ";Error: "))
  ((null (string-index string (nl)))
  (princ string))
ing))
             (when (eql c #\nl)

***********************************************************
                                                      *
1989 The Charles Stark Draper Laboratory Inc.     *
eserved.                                        *
                                            *
*****************************************
 
t

 usedÿ
of calling GET because
GET.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


-ZILCO '*interpretive-eval*
alization."
;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;
 no properties,
ions, etc.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;è ;;;;;

te at "top level".
****************************************************************
                                                           *
ight 1989 The Charles Stark Draper Laboratory Inc.     *
hts reserved.                                        *
                                                 *
**********************************************
rator a la NIL, viz.
p is true of all

apping funÿ
cond
t" lis))
            (when (setq lÿ
              (return t))
 &rest lists) ; case of multiple lists.

ists)
 passed to EVERY" list)))
(return t))
          (return nil))
  (go loop)))))


 ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
       All rights reserved.                                        *
                                                               *
************************************************************
ode (x)  ›   ;PRIN1-style interned symbols
)) (zilexpl (prin1-to-string x) t nil))
 t t))))
********************************************
                                       *
s Stark Draper Laboratory Inc.     *
                                 *
                             *
**************************
d symbols
  (princ-to-string x))
t            ; type is interned symbol
INC
**********************************************
                                         *
les Stark Draper Laboratory Inc.     *
                                   *
                               *
****************************
m characters
x))  (princ-to-string x))
   0            ; type is fixnum

****************************************
                                   *
ark Draper Laboratory Inc.     *
                             *
                         *
**********************
******************************
                         *
                     *
                   *
o K. Hvatum.   *
           *
*ÿ
) equality.
0f0)
pt (x y)
x))
      ((zerop y)
y, if (zerop x), it's supposed ÿ
his point.
                      ((or (dfloatp y) (dfloatp x))
xp (* y (log x))))
(* y (log (float x y))))) ; force sfloat
fixnump y)) (zerror "EXPT exponent not a fixnum or flonum" y))
       (if (or (zerop x) (= x 1))
              (do* ((k (1- (haulong y)) (1- k))
  (n x (if (logbitp k y)

       ((zerop k) n))))
            ;
        ; Note that this is supposed to return a
nal in CommB on LISP, but under the
urns a truncated integer.
 (/ 1 (expt x (minus y))))
****************************************************************
                                                           *
ight 1989 The Charles Stark Draper Laboratory Inc.     *
hts reserved.                                        *
                                                 *
**********************************************
; This function returns T if the symbol has some kind of
n (even a special form or macro).
nt function definition,
find one.
 even
boundp (a)
not a symbol" a)
erty a) t)

                     nil)
a)

***************
          *
.     *
    *
*

 x *features*) t nil)
**************************************************************
                                                         *
ht 1989 The Charles Stark Draper Laboratory Inc.     *
s reserved.                                        *
                                               *
********************************************
s is the "full macro expander".  It takes a LISP form and does a
odewalk, expanding any and all macros that it finds in it.
****************************************************************
        ÿ
vity:                                                    *
                                                     *
ial forms BLOCK, TAGBODÿ
ALUE-BIND, MULTIPLE-VALUE-LIST, THROW.         *
OG and RETURN removed.                     *
                                      ÿ
**************************************
new special form:
(2) Add it to ZILEVAL.
ZILCOTRN.
e it.
             x                              )
         (cons (fexpand-lambda (car x))
       (fexpand-args (cdr x)))  )
EXPAND: Invalid object in functional position" x))
o)

get (car x) 'fexpr)               x                              )
                  ÿ
           (fexpand-args (cdr x)))  )
x)
 (lambda   (list* (car x)

) will have to be deleted in favor of Common LISP
hich are probably going to be new
    (list (car x) (cadr x) (fexpand-lambda (caddr x))))
(warn "FEXPAND: Invalid form in functional position" x)
 "FEXPAND assuming it is to be macroexpanded.")
))))
   (or x (go end))
)))

 z)
 lambda list keyword" a))
    (&optional (cond
           ÿ
glist (car a))) z))
    (push (list (fexpand-arglist (car a))
expand (cadr a))) z))
(list* (fexpand-arglist (car a))
cadr a))
    (cond
      ((null (cdr a))
a))) z))
-arglist (car a))
                                 (cddr a)) z))))
                    ((atom a)       (push a z))
dr a))
               ((null (cddr a))
 (car a))
             (t
      ÿ
          (cddr a)) z))))


ond
glist (cadr a)) (cddr a)))))
car x)
list (car x) (fexpand-lambda (cadr x))))
protect
and-args (cdr x))))
ar x) (cadr x) (fexpand-args (cddr x))))

           (cons (car x)
(cdr x))))
   (fexpand-defun       (cdr x))))
                           (fexpand-tagbody     (cdr x))))
b+
 x))))ÿç
x)))))
 fexpand-cond (x)    ; x = ((a1) (b1 b2) (c1 c2 c3) ...)
args x))
ag?
m,


 (warn "FEXPAND found improper list ending in" x)
nc z x)))
x (go end))
er list ending in" x)
expand (car x)) z)
eturn (nreverse z))
glist) . body)
Ô
eÿ
x)
r x)))
       (fexpand-ÿ
car #'fexpand-tags x))
orm . body)
ist of

hat destructuring will be allowed in the arglist here.
-arglist (car x))
(form &aux m prop)
akes both
   ((not (and (consp form)
    (setq m (or (get (car form) (setq prop 'macro))
 (get (car form) (setq prop 'cmacro))))))
prop))))
)

rror "FEXPAND wants arg1 to FMAPCAR to be #'xxx, not" fun))
,list)  ; Jÿ
z)
  (when (atom ,list)
ing in" ,list)
 (push (,fun (zcar ,list‚ )) z)
        (go loop))))
**********************************************************
                                                     *
989 The Charles Stark Draper Laboratory Inc.     *
served.                                        *
                                           *
****************************************
, except that it always takes
***********************************************************
                                                      *
    ÿ
                                                *
urn only one value, no matter what we       *
 ZILFIX.           ï                      *
                                      *
***********************************
)
*************************************
                                *
 Draper Laboratory Inc.     *
                          *
                      *
*******************
ÿç
*******************
              *
 Inc.     *
        *
    *
*

**

;*         All rights reserved.                                        *
                                                                   *
****************************************************************
ZIL flavor syÿ

zil-source-member ZLVANLLA)))
member ZLFLVAUX)))
lavor-system-loaded ()
efargs zlflavor 0 0 nil)
nil)
   (warn "A FLAVORS system is already loaded.")
Herald.
princ "Loading ZIL's FLAVORS system.")
finitions of flavor functions/macros.
flavor functions.
-FLAVOR and its methods.
em-loaded) t)
)
******************************************
                                     *
Stark Draper Laboratory Inc.     *
                               *
                           *
************************
 y?
                    (float x)
             y)
 y))))

*****************************
                        *
Laboratory Inc.     *
                  *
              *
***********
IL, does NOT remove special form defs.
et (see FBOUNDP for more ruminations).
unless (symbolp x)
l" x))
ND special form" x))
 'fexpr)
o)
**************************************
                                 *
k Draper Laboratory Inc.     *
                           *
                       *
********************
…
ions that comprise it - all their names begin by convention
acters ZFM.
he form that
ed
         written.

he
teger to English word form.
 numeral form.ÿ
possibly others,
cide to write a function FORMATL as follows:
string args)
that FORMAT could be defined as:
args)
ike ERROR and Y-OR-N-P could be defined
s follows:
  (formatl t string args)
ndard

    handle that.  But probably we will have
g &rest args)
.. 
-P for

string) aÿ
 source version of
tically
val-when (eval)
open-file (l *loadfile*) (zildsni l)))
oadfile 1 (1- (index loadfile "(" #×)×#))))
nd "'" loadpds "(zfmpars)'"))
'"))
***************************************************
                                              *
 Charles Stark Draper Laboratory Inc.     *
                                        *
                                    *
*********************************
efun funcall (f &rest z)
	

;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
         All rights reserved.                                        *
                                                                 *
**************************************************************
is the 2-arÿ
num GCD efficiently.
rguments, is expanded
See ZMGCD.
*************************
                    *
                *
              *
          *
      *
*****
((and (fixnump a) (fixnump b))
 assembler-coded GCD.
(or (eql a 1) (eql b 1) (eql a -1) (eql b -1)) 1)

***********************************************************************
                                                                  *
) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
All rights reserved.                                        *
                                                        *
*****************************************************

ional (prefix "T")
          &aux      (counter *gentemp-counter*))
   (warn "Packageÿ
gp prefix)
fix))
one changes the oblist
y interned).
onsed onto
 c))
q a (intern (string-append prefix (tostring c))))
      )
{
;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

*********************
                *
ry Inc.     *
          *
      *
***
plode-character-frob x)))
t" x))
nump x)       (ebcdic x))
ar x 1))

***************************************
                                  *
rk Draper Laboratory Inc.     *
                            *
                        *
*********************
))
." package))
 

ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
      All rights reserved.                                        *
                                                              *
***********************************************************
is equivÿ
un intersection (a b)
ar a) b) (cons (zcar a) (intersection (cdr a) b)))
tersection (cdr a) b))) )

**********************
                 *
ory Inc.     *
           *
       *
****
ument - the source of input forms.
 Optional second argument - this is the output file
rinting is to be done.  If the unique value
fied for this, printing is bypassed.
foo(bar)") 'NOPRINT) is "silent".
pting string.
ompiled-environment ALIST
in the top-level
 compiled
This is now done by default, since EVAL with no second argument
ond argument of NIL) uses the current alist.
 has to be tested twice; both the READ and the EVAL
.  Also note ÿ
ile would cause the interpreter to
through) with a normal
 (END) is an end-of-input inÿ
e added to trap attention interrupts at
 attentions only if the
f the input
****************************************************************
                                                           *
ty:                                                    *
                                                     *
for multiple values.                             *
                                             *
********************************************
 (&optional f o p)   ; READ-EVAL-PRINT loop.
       +              ; As defined in Common LISP guide, Chapter 20
+       ÿ
        ; As defined in Common LISP guide, Chapter 20
; As defined in Common LISP guide, Chapter 20
ined in Common LISP gui+
n Common LISP guide, ÿ
on LISP guide, Chapter 20
guide, Chapter 20
hapter 20
 20

              (cterpri o))                 ; let thÿ
 loop                                    ; We must check for EOF after
                                     ; eval in case QUIT issued
eof f)                        ; Check for end of file
))                    ; If EOF, end the interpreter
                       ; Catch attention interrupts.
                   ; Catch LISP errors.
nÿ
nsure a new line.
s specified
mpt.
              (setq +++ ++)             ; Set +++.
+)               ; Set ++.
 to last read form.
ust-read form.
                             ; If READ successful...
f)                 ; If end of file on input
             ; then return.
ser typed (END)
test is
her
             then                         ; then finish
eturn t)              ;
           if                           ;
        ; Catch EVAL/PRINT errors.
 ; Evaluate form.
           ÿ
            (setq /// //)     ; Set ///.
       ; Set //.
val'd forms
                   (setq ** *)       ; Set **.
 * (car v))  ; Set * to last eval'd form.
        ; If NOPRINT specified,
; then don't print form.ÿç
(x v)    ; Else for each value ret'd,
    ; insure new output line
 print form.
            )                ;
f error before PRINT,
eanup stuff...
eanup stuff)
                           ;
       )                                   ;
             ;
) or EOF.
                        ;
 int» rpret)
*****************************************************
                                                *
he Charles Stark Draper Laboratory Inc.     *
d.                                        *
                                      *
***********************************
n LISP (INTERSECTION A B :TEST #'EQ).

a) b)))

********
   *


**********************************************************************
defun keywordify (xÿ
rd))

efload keywordify kwdify)
***************************************************************
                                                          *
ght 1989 The Charles Stark Draper Laboratory Inc.     *
ts reserved.                                        *
                                                *
*********************************************

st list (cdr list))
)
      ((a… tom list)

****************
           *
c.     *
     *
 *

	
**********
     *
 *

;***********************************************************************

ist and extracts all the variable
 signalled for bad lambda list keyword usage.
;; (llvars '(a (b . c) &optional (d ÿ
	
 &rest &body &aux &key &allow-other-keys))
(prog (z mode c c1 c3)
 ((atom bvl)         ; CDR of a dotted pair.
            (return z)))
m the lambda-list.
lambda list keyword
.lambda-list-keywords)
ist keyword" c))))
 ÿ
(go required-arg))
          ((&rest &body)  (go rest-arg))
ux-arg))
(zerror "Lambda list args following keyword" mode)))

q bvl (cdr bvl))
d

 c))))
     (setq z (nconc (llvars c3) z)))
o loop)
 c))
vars c1) z))
g



edp)
)
      ((aÿ
iedp nil))
iable var
l (cdr var))

    suppliedp (caddr c)))
 variable)

ÿç
*******************
              *
 Inc.     *
        *
    *
*
he file
;        specified as the symbol NOPRINT to suppress such printing.
;            Thus (LOAD "foo(bar)" 'NOPRINT) ÿ
      (well, almost silent, since the "Loading" message
appears).
OPRINT.
defun load (d &key (verbose            *load-verbose*)
rint              nil)
if (and (null if-does-not-exist)
il 

cterpri)
".")
    (read-eval-print f (if print nil 'noprint))
 t
***********************************************************
                                                      *
1989 The Charles Stark Draper Laboratory Inc.     *
eserved.                                        *
                                            *
*****************************************
e nil base?))

) (integerp base))
and (š integerp x) (sfloatp base))
base)))
 base not specified - take natural logarithm to base e

************************************
                               *
Draper Laboratory Inc.     *
                         *
                     *
******************
nder the interpreter only.  The compiler transforms
site number of calls to LAND.
ll x)
oop
ar x)))

**********************
                 *
ory Inc.     *
           *
       *
****
preter only.  The compiler transforms
 calls to LOR.

  (when (setq x (cdr x))
           (go loop))
j
*****
*

*                                                                     *
*******************************************************************

 compiler transforms

v)
(cdr x))
loop))
**********************************************************************
                                                                 *
 Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
ll rights reserved.                                        *
                                                       *
****************************************************
sÿ
pcar #'maknam-character-frob x)))
t a list" x))
 ((fixnump x)   z     (ebcdic x))
(getchar x 1))

********************************************
                                       *
s Stark Draper Laboratory Inc.     *
                                 *
                             *
**************************
currence of a
;;   binding if there was no binding on the alist.
ding, MAKUNBOUND changes the current binding cell
 "valueless".
 cells
          This consists of a BINDING property on the property
list ÿ
place this function
on to bash

ror "Argument to MAKUNBOUND is not a symbol" x))

           (rplacd binding (zilunbnÿ
d makunbou)
;;;;;;;;;;;
r* 'defvar))) ; Look at DEFVAR'd variables.
     ; If variable is on DEFVAR list
) 'defvar)))
 list.
r a (go tryglobal))        ; When alist exhausted, try global.
 x (caar a))          ; When variable ASSQ-located,
           ; we have to remove it...
ÿ
ious alist
..
  else         ÿ
    ; nothing to bash, so set new alist
 )
else                        ;
se bump down the alist
r to last cell.
e.

found by MAKUNBOUND" x c))
it
)                                ;
turn the variable itself.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ÿç
*******************
              *
 Inc.     *
        *
    *
*
) t)

   (when (setq lis (cdr lis))
     (return v))
ists) ; Case of multiple lists.
l (cdr lists)) (mapand1 fun (car lists)))

 to MAPAND" list)))
por #'null lists) (return v))
r #'car lists)))
ar #'cdr lists))

*************************
                    *
ratory Inc.     *
              *
          *
*******
funcall f x)))
**************************************************
                                             *
Charles Stark Draper Laboratory Inc.     *
                                       *
                                   *
********************************
st.
 not a list" lis))

½
mapc (fun &rest lists) ; Case of multiple lists.
    nil)
 (list listÿ
 "Non-list passed to MAPC" list)))
s))
 (mapcar #'car lists))
   (go loop)))))

<
* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
        All rights reserved.                                        *
                                                                *
*************************************************************
can1 (fun ÿ
is) (zerror "Argument 2 to MAPCAN not a list" lis))
        (setq v nil)
 lis))))
v))
ase of multiple lists.
lists)) (mapcan1 fun (car lists)))
      (unless (listp list)
CAN" list)))
'null lists) (return v))
car lists))))
)))))
********************************************************************
                                                               *
opyright 1989 The Charles Stark Draper Laboratory Inc.     *
 rights reserved.                                        *
                                                     *
**************************************************

le)
val-when (eval)
defun mapcar1 ÿ
 ((atom lis) (zerror "Argument 2 to MAPCAR not a list" lis))
 (v w)
(setq lis (cdr lis))

uncall fun (car lis)))))
      (return v))
&rest lists) ; Case of multiple lists.

ists)
st passed to MAPCAR" list)))
    (when (mapor #'null lists) (return v))
fun (!mapcar #'car lists))))

    (setq w (setf (cdr w)
r #'car lists)))))
o loop)

***
<

                                                                    *
*****************************************************************
 mapcon1 (fun ÿ
om lis) (zerror "Argument 2 to MAPCON not a list" lis))

lis)))
)
e of multiple lists.
sts)) (mapcon1 fun (car lists)))
    (unless (listp list)
N" list)))
ull lists) (return v))
         (setq lists (mapcar #'cdr lists))
fload car zcar)
***************************************************
                                              *
 Charles Stark Draper Laboratory Inc.     *
                                        *
                                    *
*********************************
ist.
L not a list" lis))
 
               (return v))
(fun &rest lists) ; Case of multiple lists.
il)
t lists)
-list passed to MAPL" list)))

s)
 
***********************************************************
                                                      *
1989 The Charles Stark Draper Laboratory Inc.     *
eserved.                                        *
                                            *
*****************************************
Case of 1 list.
nt 2 to MAPLIST not a list" lis))
(ncons (funcall fun lis)))
     ÿ
etf (cdr w)
nless (setq lis (cdr lis))


(car lists)))
st)
prog (v w)
rn v))
 (mapcar #'cdr lists))
lists) (return v))
ncons (zilapply fun lists))))
        (go loop)
Â
*************
        *
    *
  *
<

s.
ed.
s 'mapor (cdr x)) y z))
) (zilload 'mapor))
cond
ist" lis))
ll fun (car lis))
                   (go loop))))))))
n (car lis)))
         (go loop))

 ((null lists)       nil)
  (tÿ
           (zerror "Non-list passed to MAPOR" list)))
p (when (!mapor #'null lists) (return nil))
fun (mapcar #'car lÿ
ts (mapcar #'cdr lists))

or x (return v))
  (and v (return v))
Â
***************************
                      *
boratory Inc.     *
                *
            *
*********
sion of MAX.  MAX is implemented as
te number of calls to MAX2.
)
******************************************
                                     *
Stark Draper Laboratory Inc.     *
                               *
                           *
************************
--------------------------
==========================
 (let ((comparison (let ((x `(,@test item ,(if key `(,@key (zcar lisÿ
                                                `(zcar list)))))
            (if testnotp `(not ,x) x))))
g ()
mpaÿ
cdr list))
         (return list)))))
==================ÿ
st?)
                  (key nil key?))
 (zerror "Both :TEST and :TEST-NOÿ
stp list))
ot?
Ó
    (if key?
      (member-loop (funcall test)     nil           nil)))
ey?
member-loop (eql)              nil           nil)))))

*********
    *
*
<
***********************************************************************
;

eql x (zcar y))
   (go loop)))

;*                                                                     *
IL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
     All rights reserved.                                        *
                                                             *
**********************************************************
s equivÿ
**************************************************************
                                                         *
:                     ÿ
                                                   *
 compile into faster (?) code.                 *
                                     ÿ
******************************************
t)
 item (zcar list))


**********************************
                             *
aper Laboratory Inc.     *
                       *
                   *
****************

 not a macro.
rsion.
macroexpansion
o form,
fmacro set-macro-form (m form)

          (setq ,m (get (zcar ,g) 'macro)))))
      b
)
     (setq form (zevmapp m form 'macro))
eturn form)))
	Ò	Ò
*******
  *
<

*********************************************************************

OEXPAND (MEXPAND), which expands a macro form until
ot a macro.
he macroexpansion
 macro form,

)
               (setq ,m (get (zcar ,g) 'macro)))))
           b
1 (form &aux m)
(zevmapp m form 'macro)))

**********************
                 *
ory Inc.     *
           *
       *
****
of MIN.  MIN is implemented as
mber of calls to MIN2.
)
*************************************
                                *
 Draper Laboratory Inc.     *
                          *
                      *
*******************
 function builds a fresh evaluation environment,
;;
;; call this function.
st.
;
;
 progenv            - chain of PROG environments
n of LEXPR environments

         - Loÿ
t be added as time goes on...
nments described in ZEVMACS.
iables are not part of the eÿ
the globally accessible "SPECIAL-ALIST".
ote: These depend on the structure of the "environment" as
 ZEVMACS.
y to
le ZILAPPLY and ZILEVAL to use this new definition.
Check COPYENV, MKNEWENV, ZEVMACS, ZILAPPLY, and ZILEVAL
es to the structure of an ENVIRONMENT.
alistenv nil))
riable bindings
l                ; chain of LEXPR environments
ive SPECIAL variables
 FLET)
)
***************************************
                                  *
rk Draper Laboratory Inc.     *
                            *
                        *
*********************



 ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
       All rights reserved.                                        *
                                                               *
************************************************************
expander ÿ
**************************************
                                 *
                        ÿ
                           *
 keyword.              *
 the ASSOC family, *
h functions do   *
e list.      *
         *
********
)) ((:key d)))
tem list test key
est)

m))
)))
 itemvar)
function)))
call ,key ,itemvar)ÿ

       (cond
r)

***************
          *
.     *
    *
*

acro (x) (mxatoff x))
t) x))
     (off (mxatoff-off arglist))
MXATOFF" macro)))))
 :exit))
y)   (&rest arglist)  . body)
Ô
xit t) ...)  <== don't display "Exiting" message
 
             (arglist nil arglist?)
here quietp)
try))
ec))
))
pec)))
funspec) quietp (caddÿ
pec" funspec)))
ither
is not valid
fun #'(lambda (,(gensym) ,arglist) . ,body) ',quietp)
        ((entry :entry)
          'exit)
)))

zerror "Missing function name" 'off))
un where)
symbolp funspec)
c))
eÿ
) 2)
"Invalid OFF function spec" funspec)))
  ',(case where
     ((exit :eŽ xit)
 entry/exit spec" where)))))
******************************************************************
                                                             *
yright 1989 The Charles Stark Draper Laboratory Inc.     *
ights reserved.                                        *
                                                   *
************************************************
nder for the back quote.
 (mxbq a))
fload car zcar)
 ''×,× )


r ,x) (comma-dot)))))
               `(zmvector ,(mxbq (vlist x))))
   (mxbq-atom x))
x) (comma-at))
((eq (car x) (comma-dot))
"))
r x))                 (if   (is-a-splicer (car x))
              (mxbq-nconc x)
  x)))
adr x) (comma-at))

rs x)               (mxbq-nconc x))
ist  x))))
x)
))

)
     (and (eq a (comma-at))
ot in backquoted list"))
yntax error: ,. cannot follow dot in ÿ
plicer a) (return t))
defun mxbq-list (x)
ar a)
rse (cdr a))))))
      ; Embedded vectors are implicitly backquoted.
   `(zmvector ,(mxbq (vlist x))))
)
q (mxbq (cadr x))))
ly backquoted.
onc (x)
ÿ
cdr a)) ,(cadar a))
n mxbq-nconc1 (x)
mplicitly backqÿ
st x)))))
x) (comma))     `(list ,(cadr x)))
r x))) ; Must copy list.      ÿ
    ; OK to destroy the list.
 (cadr x)))))
kquoted.
pbq (f x)
om x)
 (funcall f x))


low dot in backquoted list"))
 x (cdr x))
{
********************************
                           *
er Laboratory Inc.     *
                     *
                 *
**************
.
SE X))

ent" macroname))
aseq)
ases
a ,thing))
cases))
clause a (car cases) macroname) z))
(caar caÿ
)
    (eq previous-cond 'otherwise)
))
Ä
 "Invalid case" macroname case))

    (setq e1 (case-equality (car d))))
ase-equality (car d))
dddr d))
y (cadr d))
 d)
 x) (stringp x))) d)
))
   (eq d 'otherwise))   `(t                          . ,s))
            `((,e1 ,a ',d)               . ,s))
`((ÿ
 ,a ',(car d))
))
                  ÿ
e3 ,a ',(caddr d)))  . ,s))
         . ,s))
  ((symbolp d) 'eq)
 'eql)
  'equal)))
*************************************************
                                            *
harles Stark Draper Laboratory Inc.     *
                                      *
                                  *
*******************************
 macro.
xdecf a b))
e increment
      ((-1) `(add1 ,place))
ement)))))
**********************************************
                                         *
les Stark Draper Laboratory Inc.     *
                                   *
                               *
****************************
AL MAX RST)
O 1)
EFARGS 'FROB NIL)   ... makes FROB totally undefined.
farg (fun min max rst)
fun ,min          minargs)
efprop ,fun ,rst          restarg)
)
rg inline predicate
)
Â
*************
        *
    *
  *
<

generates "Fast Loading Interpreted Code", i.e. a compiled file
ted forms.
;

ng:


f-print-out f-print-in)
)

 f-print-in (print i))
h nil (print (eval i))))
;
al c d) (mxdeffli a b c d))
 of the module to be compiled.
 file to be flicifiÿ
reexpand-macros? ; T if macros are to be expanded
          ; at compile time, else NIL.
 see what the FLIC'er is reading
efun ,flicname (&optional f-print-out f-print-in)
) 2)
odule " flicname "."))
orms-list flicload
bug?))

)) (terpri))
 ;; ... might have to change that "catch nil" for Common Lisp someday??



f file) (close file 'input) (return (nreverse z))))
rpri) (print f+
macroexpand ÿ
 (princ form)
 ((eq (car form) 'eval-when)
r form)))
        (go loop)))
; COMPILE - evaluate them NOW.
ed, so include them.
nclude them.
No args on eval-when"))

ogn . ,forms))
es)
forms)))
************************************************************
                                                       *
 1989 The Charles Stark Draper Laboratory Inc.     *
reserved.                                        *
                                             *
******************************************

 yields: (DEFUN FOO MACRO (NIL A B) (LIST 'SOMETHING 'WITH A 'AND B))
This expander handles both DEFMACRO (for top-level macro definition)
EFMACRÿ
read as follows:
FUN XDEFMACRO MACRO (X) (MXDEFMAC X))
is dependent on the
ange for
c dmname dmargs dmbody)
XDEFMACRO.
)         ; Macro name.
gs (zcaddr x))        ; Argument list.
 ; Everything else is the body.
dmname))
                 ,dmname macro (nil . ,dmargs) . ,dmbody))
É

*****************
            *
nc.     *
      *
  *
	
***********************************************************************
                                                                  *
s probably obsolete.  Supplanted by ZILCOMOÿ
ndles "real" module compiles.                               *
                                                        *
*****************************************************
rates a load module that loads in compiled forms and defs.
EFMODULE (A B &OPTIONAL C) (MXDEFMOD A B C))

ble function out of it that, when
rpreter, does the operations
led modules created
 is a maÿ
 include stuff defined by DEFMACRO's, so any
dule has to be made to generate both
or compilation) propertÿ
 definition to the
EFUN is of
 if a form is a DEFMACRO, this expandsÿ
ve.
e
 a DECLARE, is passed to the compiler as is.
 is ignored.
;  EVAL-WHEN (COMPILE) - evaluated by the compiler itself only.
(LOAD)    - processed as above.
 if the form is anything else, is set up to be executed at load time.
Example:
(foo)")
h1)ÿ
mac (x) `(frob ,x))   ;    3
ome random form)              ;    5

print "hello worÿ
                   ;    9
      ;   10
 (progn 
     ; 1
junk")                               ; 4 - expanded MAC
m)                          ; 5
      ; 6
                                      ; 9
o1 (x) (blah1))                      ; 1
               ; 2
anded DEFMACRO
fload frobnicate frobozz)                  ; 7
   (print "hello world"))                       ; 8
t the compiler sees after macro expansion, and will

t compile tÿ
ically scoped
 member memqual) ; We use an EQUAL test for MEMBER when
    ; searching for (FOO Bÿ
dname  ; the name of the module to be created.
the name of the file to be compiled.
           debug    ; T if debugging requÿ
 (((flist1 . flist2) (module-get-forms modname modload)))
 (terpri)

erpri)
compilable) forms follow:")

pri)
nc ,(string-append "Loading module "
                           ", "))
ile "
"))
modname ; Return the name of function itself as the value.
ist2   ; Forms procesÿ
 returns a CONS of 2 lists...
ich make up the main function
iler.
-get-forms (modname modload)ÿç
adlist)
 form (catch nil (read file)))
se file 'input)
omplist))))

(form)
exp (cond
     ((eq (zcar form) 'comment)   nil)
(go process-declare))
load))
((eq (zcar form) 'defvar)    (go process-defvar))
eval-when) (go process-eval-when))
process-ÿ
 (zcar form) 'macro))
go nexp))
     (return)
 either the compiled or the interpreted function definition
ate property of the symbol that names the function.
FOO)) or (DECLARE (NOCOMPILE (FOO BAR)ÿ
 will be on the "NOCOMPILE" list,
        (unless (cdr form) (go defun-error))
)
È
; Check type of DEFUN
             ((expr fexpr macro) (setq defun-prop (car defun-rest)
                               defun-rest (cdr defun-rest)))
                 (setq defun-prop 'expr))
           ; Figure out what to do with DEFUN
etqÿ
(expr   (if  (memq defun-func (get '*zilco* 'nocompile))
  then
ll load interpretiÿ
n-func)
 `(xdefun . ,(cdr form)) loadlist)
              (push
ubr ,defun-func))
                            loadlist)
mplist)
    (macro  (setq defun-rest (cdr defun-rest))ÿ
orm complist)
le.
n not compilable, will load interpretive definition of "
   )

                 (terpri)
) loadlist)
"))
expr-subr
           ÿ
            complist)
Î
                      `(,'ÿ
   complist)
       if (consp (cadr form))
n-func defun-prop) . defun-rest) form)
-error))
            then
ill load interpretive definition of ")


                              ',defun-prop)
)
                 (setq defun-name (concat defun-func " " defun-prop))
          (push `(putprop ',defun-func
fun-naÿ
                      ',defun-prop)
             (push `(defun ,defun-name . ,(cddr form)) complist)
 endif


rpri)
 complist)
(xdefload . ,(cdr form)) loadlist)
eturn)
 loadlist)
-progn
n)
	

    (let* (
ilep            (memq 'compile times))
emq 'load    timeÿ
É
dp    do (module-process-form f)
l)))

***
<

                                                                    *
*****************************************************************
 The macro expÿ
rning structure name in evaluator.
dr) produces...
        (defmacro kons-kar (xÿ
(x) `(vref ,x 2))
                                 (and (structp y)
                  (eq (vref y 0) 'kons))))
wing syntax is supported:
slot3 ...)
                            (constructor ...)
      (copier ...)
                               {array×tree})
ault-value)
      (slot3 default-value)
fault values are evaluated at MAKE-foo time.
AL-WHEN attribute defaults to (COMPILE EVAL).
CT can beÿ
me code to initialize the DEFSTRUCT
name.  If you want to include
ll be able to type in
, with the full
;     (defstruct (<name> ... (:eval-when (compile load eval)) ...) ...)
;       Otherwise the structure is for ÿ
    and structures will be built, but they cannot be processed by
-time hacking.
t function,
 to
ilarly for DEFSTRUCT-FUNCALL-METHOD, etc.
omewhat, especially when structures are changed
ent is not a symbol naming the structure type
tructure descriptor".
e STRUCTURE-DESCRIPTOR.
TOR +
thÿ
ef'n)

m will have exactÿ
ined type, including one for STRUCTURE-DESCRIPTOR
.. but like I said, not for a while yet ...
 info is stored (for now) on theÿ
ture.  All the property names shall begin
, which are documented as "reserved"
ROP of 'PROGLIB.ZIL.TEXT'.
ed by DEFSTRUCT:
CT info.
ed.
ent.
to
;                            notably by FLAVORS, for SEND.
RUCT-EVAL-METHOD    - a function invoked when one tries to
             EVAL a structure.
on invoked when one tries to
.
e
                           so-and-so (i.e. 2-argument TYPEP).
;; MXDEFSTR is not only theÿ
macro expander for the various macros generated by DEFSTRUCT, viz:
 (defun defstruct macro (x) (mxdefstr x))  ... Note, one arg, a list.
;;; (defmacro make-foo (&rest g00001)
g00001)) ... Note, 5 args.
)
;; (defmacro foo-p (g00001)
.. Note, 5 args.
essor 'foo 1 g00001))      ... Note, 5 args.
0001)
;


set-defÿ
nt arg 3 to be a symbol. Sorry."))
  (when ,value
======================Å ===================================

ot sname?) ; If only 1 arg


(predicate)   (mxdefstr-predicate   sname sparm sargs))
)    (mxdefstr-accessor    sname sparm sargs))
zerror "Invaliÿ
(original-args)
ation))
 stuff)))
 (if (atom type)
str-consify (cdr type))))

tor)
    (boa-constructor-arglist nil)
lt)
hen '(compile eval)) ; <== Note the default!!!!
    ; Validate the structure name.
(not (symbolp name))
Ð
'(
YPEP.  If you add new
to add thÿ
m character closure code
ct double-float

                      subr symbol vector
(zerror "Cannot use built-in type as DEFSTRUCT type name" name))

   ((:conc-name conc-name)
           ; (CONC-NAME) specified
dr value))           ; (CONC-NAME arg1)
                (case (car value)
(CONC-NAME NIL) or
specified
       (t
structor constructor)
      ; (CONSTRUCTOR) specified
    +
(Cÿ
            (setq constructor? t      ; (CONSTRUCTOR anything)
        constructor (car value))))
; (CONSTRUCTOR naÿ
          constructor (car value)
              boa-constructor-arglist (cadr value)))
                  ; (CONSTRUCTORÿ
error attr value))))
    ((null value)                  ; (COPIER) specified
ier? 'default))
g2 ...)
ar value))            ; (COPIER NIL) specified
)
    (setq copier? t
redicate predicate)
    ; (PREDICATE) specified
       ((not (null (cdr value)))      ; (PREDICATE arg1 arg2 ...)
 (mxdefstr-attr-error attr value))
; (PREDICATE NIL) specified
(t          ÿ
dicate? t
n eval-when)
EVAL-WHEN) specified
))      ; (EVAL-WHEN arg1 arg2 ...)
ue))
        (setq eval-when (car value)))))
   (isetq implementation 'array))  ; (ARRAY anything) specified
ree tree)
ed
ttr value))))
OPIER, etc.

concat name "-")))
etq constructor (concat "MAKE-" name)))

? 'defaÿ

 'tree)
            "DEFSTRUCT+
             name))
nformation defining the structure and hang it off
t of the structure name, under the
IES.
iation list
truct foo bar (baz 1) (frob (make-a-frob)))
in FOO having the DEFSTRUCT-PROPERTIES property of:
; ((conc-name        . "FOO-")
 ;;;  (constructor      . MAKE-FOO)

:BAR ÿ
                     (:FROB FROB (MAKE-A-FROB))))

etf (get name 'defstÿ
me)
     . ,constructor)
dicate        . ,predicate)
   ))
  ;;; the macro definers.
s)))
pe" name)

nt-function defined, then set up the
 the print method is
fied.
 object is a "foo" made by MAKE-FOO, so what can you do?
ÿ

e 'defstruct-documentation  documentation)
fstruct-funcallÿ
-eval-method    <nothing>)
thod   <nothing>)
othing>)
or?
   boa-constructor boa-constructor-arglist))
 (mxdefstr-define-copier name copier))
(mxdefstr-define-predicate name predicate))
ts))
slots) (nreverse z))
                                        conc-name
                  (car slots)
x)
`(eval-when (load) (eval ',original-args))
en (eval) ',name)
 (assq sprop (get sname 'defstruct-properties))
CT properties found" sname))))
  ((atomÿ
lue) (:name name value) ...)
 
olp x)        (list (keÿ
 (zerror "Illegal DEFSTRUCT slot identifier" x))
(car x)              (unkeywordify (car x))
                (cadr x)))
 (car x) (cadr x)))
)))
                    boa-constructor boa-constructor-aÿ
ald name constructor)
tor)
DEFSTRUCT-CONSTRUCTOR-MACRO property, used by the #S reader macro.
let* ((g (gensym))
-constructor

 (sÿ
'(lambda (x) `(',x ,(keywordify x)))
s boa-constructor-arglist))))))
rror "Error in BOAÿ
nstructor boa-constructor-arglist))
g)
mxdefstr 'constructor ',name nil ÿ
        (t
r 'constructor ',name nil ,h))))))
opier)
)
e ,g1 ,g2))))
str-constructor-or-copier 'constructor sname sparm sargs))
fstr-copier (sname sparm sargs)
e sparm sargs))
args
       (mxdefstr-get name 'slots))ÿç
(mxdefstr-get name 'implementation))
letbinds        nil)

(cdr x)
slot (or (assq (keywordify (car x)) slots)
ined slot name" maker (car x))))
ion constructors, skip initializations
;
mentation)

cons (car slot) slotsym) used-slots)
binds)))
inds
 Constructor:
; -->
y nil t 3)
      ;;; Copier:

 ((g00001 (array nil t 3)))

all t g00001 2 "2")
kind
(1+ (length slots)))
                      with temp
sq (car x) used-slots))
                           else
))))
ray nil t ,(1+ (length slots)))))
         ÿ
                      (z nil)
      )
;;; Skip unspecified sloÿ
ar x) used-slots))
 temp)) z))

;;; (make-foo :bar 1 :baz 2)
)
;;
dfoo) (cdr oldfoo))

    (constructor
      with temp
ots))
lse
 (let* ((g nil)
s ÿ
            (z nil)
            )
                 ÿ
ssq (caar x) used-slots))
                         `(,(mxdefstr-tree-access-function name y)
                       ,(or g (sÿ
      z)))))
      (t nil)))

; (let ((bar 1) (baz 2))
      ;;;            (vset g00001 1 bar)
baz)
opier:
->
d-foo)))
vset g00001 2 baz)
kind
       `(let ((,g (mkstruct ,(1+ (length slots)) ',name)))
   ,.(do ((xÿ
                         (z nil)
                     (temp)
          ((null x) (nreverÿ
                           (if (setq temp (assq (caar x) used-slots))
                         (cdr temp)
)))

        (push `(vset ,g ,y ,val) z))
           ,g)))

ots (cdr x))
        (z nil)
      )
Ñ
        (when (setq temp (assq (caar x) used-slots))
         (push `(vset ,g ,y ,(cdr temp)) z))
                     ,g)))
str-define-accessor (name conc-name slot index)
-name (cadr slot)))
sor)
',index ,g))))
lementation (mxdefstr-get name 'implementation)))

(mxdefstr-tree-access-function name index) ,sarg))
sarg ,index)))))
(case i 
index for DEFSTRUCT tree accessor" name i))))
dicate (name predicate)
redicate)
',name nil ,g))))
((implementation (mxdefstr-get name 'implementation)))


 1)
         (eq (arraycall t ,y 0) ',name)))))
rg))
s way to
(let ((y (gensym)))
p y) (eq (vref y 0) 'ÿ
me x)
EFSTRUCT definition generated" x)

cro ")
escape* *print-level* *print-length*))
 stream escape level)
evel ,level)

       (*print-level* ,level)
l *print-level*))

hod
f+

rrent print depth.
level *print-level*)
ault-print-strÿ
   :escape s

 a 0))
ons name (do ((slot slots (cdr slot))
                       (z nil)
   ((null slot) (nreverse z))

r (attr value)
       (cons attr value)))
ords
 
loop
  (mxdefstr-get-initializer bvl name)) ; Check validity
(nreconc z bvl)))
ambda-list.
st keyworÿ
-list-keywords)
word" c))))
   (go loop)
   ((nil)          (go required-arg))
onal-arg))
&aux)         (go aux-arg))

   )
c name) z)
l-arg
         c2 (mxdefstr-get-initializer c1 name)
           c3 nil))

¸
        c2 (cadr c)
))))ÿ



sh c z)

c
il))
 c2 (mxdefstr-get-initializer c1 name)

,(mxdefstr-boa-hack c1 name) ,c2) z)
(go loop)




 (var)
tform)
 )
e c
initform (mxdefstr-get-initializer ÿ
iedp? nil
r (car c)))
keywordify variable)
 variable name)
pliedp (caddr c)))
ddr var))
       (t
ord (car var)
           (cadr c)
ÿ
   suppliedp (caddr c)))
efstr-boa-hack variable name))
       ,.(if suÿ
suppliedp name))
       ) 

 (zerror "Destructuring not permitted in this BOA argument slot"
    name key))
eq (cadr slot) key)
rgument does not match any slot name" name key)
ò
*****
*

*                                                                     *
*******************************************************************


tra (a b c)
etq b `(,(car b) ,(gensym) ,(ge¾ nsym))))
  (t (zerror "Bad argument list for DEFTRANS" b))))
(lambda ,b . ,c) `',b) 'compiler-transform))
	

;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
         All rights reserved.                                        *
                                                                 *
**************************************************************
; The macroÿ
optional value documentation)
r macro (x) (mxdefvar x))
 d-val () `(cadr y))
-p  () `y)
)
(cdr x)))
-junk-p)  (zerror "Too many arguments" x))
l-p) (d-doc) (d-doc-p))))

((not doc?)
     (t
Á
stringp x)

*****************************************************************
                                                            *
right 1989 The Charles Stark Draper Laboratory Inc.     *
ghts reserved.                                        *
                                                  *
***********************************************
(defun desetq macro (x) (mxdesetq x))
 the DESETQ macro.
g or use &-forms;
; Changes fÿ
nd returns the last.
R.  If you want
Õ
   because it is very likely that someone will wish to
 argument into pieces that happens to be NIL.
le to do...
	

 (FOO BAR)) -->
      (CAR G00001)
      C (CDR (CAR (CDR G00001)))
1)))
un mxdesetq (x)


(car aÿ
tom a)                `(setq ,a ,b))
tructuring-setq a b) ,b))
x ,b))
 
turing ,a ,b))))
op (unless a (return z))

expand-destructuring (car a) `(car ,b)) z)
     b `(cdr ,b))

quote)
consp (cdr a))

******************************
                         *
 Laboratory Inc.     *
                   *
               *
************
sort-of expansions, not always exactly this way)
)
   ((ATOM I1) (SOME STUFF) (SOME VALUE))
O SOMETHING ELSE)
PROG ()
N (SOME STUFF) (SOME VALUE))))
ING ELSE)
O LOOP)))
G.:
(I3 A3ÿ
)
->
  (PROG ()
 (RETURN (PROGN (SOME STUFF) (SOME VALUE))))
        (DO SOMETHING ELSE)
B1 I3))

 macro (x) (mxdo x))
cro (x) (mxdo x))
times   (mxdotimes (cdr x)))
 ((do do*)  (mxdo-ijk  x))
))))
 (car arg))
(unless x (zerror "Missing args" macroname))
   (unless (cdr x) (zerror "Invalid syntax" arg))
 ÿ
              j ; the termination construct
 body
))

ration triples for initialization
 body (rest of the form) in for+
iteration triples for incremeÿ
)
l) (term nil))
 termination form" j)
`((return (progn . ,(cdr j)))))))
      ; Local variable list.
clarations.
     ; Iteration tag.
ermination test.
 forms.
     ,@body            ; Body.
setq-or-psetq);
 variables.

ar #'do-bind i))))               ; Initial binding of locals.
var (x)
(and (consp x) (cdr x) (ÿ
     (if (atom x)
   `(cond (,(car x) (return (progn . ,(cdr x))))))
do-incr (x setq-or-psetq)
setq . ,(nreverse v))))
) (cdr y) (cddr y))
ation form" y))
y) v))
(x) ; The old-style Maclisp DO.
x)
 (let*(
(do-split-body rest))
)

                         '(

                   ÿ
tq ,var ,repeat)

s:
 the termination pair
 of iteration triples for incrementing
cond
1  i j k l 'setq))

mxdo*-extract-declarations var k)


s two values:
 are special
;; (2) a copy ÿ
;;; First, locate any declarations in the body.  We won't take them
f there, but we do want to know which variables are
ein.  Any variables that are ÿ
al DO* variables must have
te places between
with leaving the original special
ecause SPECIAL declarations
nd we assume that
rther in
s
value-bind (nil declarations body pmxform pmxvalid)
rse-body b)

on)
q (car declaration) 'special)
n))
sh a d)))
es that need to be declared


y)))
***************************************ÿ
                                          *
                                      *
                                  *
*********************************
and x (cdr x))
x))        ; a = iteration spec, b = body
dr a)))
 (let (((v w r) a)    ; v = the step variable
= the list

 dÿ
o hold the list.
.
                ,ÿ
        . ,(mxdo-body `(not ,g)

                         (returnÿ
    )
                   (setq ,v (zcar ,g))
     ,@body

                  )
 
****

;*                                                                     *
**********************************************************************

d DOTIMES syntax"))

OTIMES variable definition" a))
iable
  ; r = the result, defaultÿ
-body b))
          (g (gensym))   ; a variable to hold the limit.
ym)))  ; a variable to hold the loop tag.
v)
)

                                `(
,r)
Ç
   (setq ,v (add1 ,v))
                        )
        (if (integerp w)
ambda (ÿ
**********************************
                             *
tion/body group.      +
                    §    *ÿç
****************************************
y)
all
.
(t                                   ; Else branch out to return...
d (,(mxdo-negate cond) . ,body)) . ,term)))) ; compiles ÿ
mxdo-negate (cond)
  (or (eq (car cond) 'not)
r cond)
**************************************
                                 *
m a body.                    *
      ÿ
************************
value-bind (nil pdecls pbody pmxform pmxvalid)
ody body)
)))
ody)))
******************************************
                                     *
Stark Draper Laboratory Inc.     *
                               *
                           *
************************
 for the "IF" macro.
 ELSE, ELSEIF, ENDIF keywords (actually not "keywords")
SE forms (mandated by Macsyma source code)
m on WHEN/UNLESS (ditto)
(if                   (mxif-if     (cdr x)))
hen   (cdr x)))
   ÿ
if-if (q)
 "Invalid IF syntax" `(if . ,q)))
f1 q)))
)
(,if ,then)))
efun mxif-when (x)

(when . ,x))
 `(cond (,(car x) . ,(cdr x))))))

((null (cdr x)) (warn "Missing UNLESS consequent" `(unless . ,x))
        `(cond ((null ,(car x)) nil)))
ar x)) . ,(cdr x))))))
h whatnext...)

;;;

r "Missing \"THEN\" in IF form" q))

 (cons (car q) truepath) (mxif2 whatnext))))))
 ENDIF
x THEN yyy ...
        ; If a then b
endif
rm ends with token other than \"ENDIF\"" q)+
; If a then b elseif ...
  ; If a then b else ...
turn (mxif1 (cddr q))))
endif)))

eturn `((t . ,(car stuff))))))
F\", or \"ENDIF\" in IF statement"))

car subl) into z

*****************
            *
nc.     *
      *
  *
	
(eval)
mxincf (place increment)
     ((1)  `(add1 ,place))
                     (t    `(ziladd ,place ,increment)))))

**************
         *
     *
   *

 


    (FORM 3)
M 1) (FORM 2) (FORM 3))

-OF-C))
;; )
;     ((LAMBDA (C) (FORM 1) (FORM 2) (FORM 3))
 VALUE-OF-B))
 LET  MACRO (X) (MXLET X))
 Destructuring is also supported.
(macname . macbody))
 (CDRÿ
     (and (car macbody) (atom (car macbody))))
ax" x))
        (mapcar #'leÿ
 (cdr macbody)                      ; The body
e (car macbody)) ; List of values
    ; LET or LET*

alues
(eq macname 'let*)   (let*-expand a b c))
 of MXLET" macname))))
 list of local variables

r a))  `(let ((,(car a) ,(car c))) . ,b))
decl newbody)
Â
ÿ
(atom x) x) (t (car x))))
) (cadr x)))

OR 04/28/86
a bug
eturns two values:
 that are special
y)
;
out of there, but we do want to know which ÿ
al therein.  Any variables that are declared
e local LET* variables must have
ropriate places between
get away with leaving the original special
ound, because SPECIAL declarations
NCES, and we assume that
icated further in
ugh this
ltiple-value-bind (nil declarations body pmxform pmxvalid)
    (parÿ
))))
ambda list vars from
m arg.
     (and (consp declaration)
ial)
                (and (memq variable loÿ
  (not (memq variable d))
)))
;; special in the currently enclosing LET.
re (special . ,d))))) ; To be NCONCed in.
    (setq body `((declare . ,declarations) . ,body)))
)))
;;;;;;;;;;
ROGs.
defun inner-let* (a b c g)

))
            (return ,(inner-let* (cdr a) b (cdr c) h)))
prog ,(let-locals ÿ
turn (progn . ,b)))))))
-locals x)
  nil)
r x)))ÿç
                          (let-locals (cdr x))))))
o longer needed now that full destructuring DEFUN
ompiler and interpretÿ
prog (auxforms z g de-vars de-forms)
    (if (atom (car a))

rms))
etq ,(car a) ,g) de-forms)
        (go loop)
if  auxforms
nreverse auxforms))
          endif
e-vars (nreverse de-forms)))))

t* var arglist))
l et-add-args (cdr var) arglist)))))
<
*                                                                     *
L (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
    All rights reserved.                                        *
                                                            *
*********************************************************
s SUBRÿ
LIST macro used only by the compiler).
(MXLIST X))
st (l)
*             (mxlist* (cdr l)))
 of MXLIST" (car l)))))

(l)
ll (cdr l)) `,(car l))
))
**************************************
                                 *
k Draper Laboratory Inc.     *
                           *
                       *
********************
;
 (defload the-real-mxloop mxloop)

cro.  LOOP macro unaffected.~2%")
x s))
e-op ()


 (lpstr-x s))))))))
) (loop-add-arÿ
 LOOP structure, passed around.
rom the LOOP form)
        initforms  ; the initÿ
ermination-test forms
   bodyforms  ; the body forms
       termforms  ; the termination forms
ways" or "never" specified
          initially  ; "Initially" forms
forms
 ; holds the LOOP structure
ent
       ; Tag to loop back to
loop (gensym))
                            (zerror "No LOOP operands"))
  :arglist   (list z)
 ; :testfÿ
yforms


   ))
     (go process-loop-binders))
inished))
nil s))

	
ally s)))
            (eq (caar a) 'return))
orms s)))
  ; Local variable list.
itialization forms.
y" forms.

  ÿ
verse (lpstr-bodyforms s)) ; Body forms.
forms s)) ; Increment forms.
Exit label.
.
   )
LY clauses.
ly s)
(setf (lpstr-initially s) (loop-do-stuff s)))
y (s)
LY form"))
; This section processes LOOP binder clauses.
s)
                        t)
                           t)
lly s)
            (loop-process-finally s)
stuff s))
LOOP action clauses.
   (a (this-ÿ
s))
s)
finally s)
)       (next-x)

ncing)    (loop-nconc-stuff z s))
oop-append-stuff z s))
z s))
  ((sum
    counting)    (loop-count-stuff z s))

   minimizing)  (loop-minimize-stuff z s))
ile-stuff s))
ways)      (setf (lpstr-boolean s) '(t))
ys-stuff s))
                (loop-never-stuff s))
an s) '(nil)ÿ
   ((if
loop-unless-stuff z s))
ed LOOP form" a)))))))
	
o-loop 
this-op))
-loop))
s-op) z)
n (nreverse z))))

fromtype fromto
m (more-op)) (zerror "LOOP: FOR syntax error" (more-op)))
(car (next-x syntax-error)))
(this-op))
(setq type 'in   byfun 'cdr))

 '=    byfun nil  ))
ar (next-x syntax-error)))
, look for TO or DOWNTÿ

                            byfun    'add1
ycond   '>
                       fromto   (car (next-x syntax-error)))
           (next-x generate-for-code))
ype 'downto
                     bycond   '<
ensym)

           (setq fromtype 'above
ub1
         tovar    (gensym)
xt+
ÿ
           byfun    'add1
                               tovar    (gensym)
     fromto   (ÿ
-x generate-for-code))
NTO y BY z ...)
tq by (car (next-x syntax-erroÿ
m) byfun (if (eq fromtype 'downto) '- '+)))

ond 
xt-x syntax-error)))
	
(eq (this-op) 'by)
-x)
(or (eq (car by) 'quote)
(setq byfun (cadr by)
yfun by

forms  auxforms                  incrforms
 (SETQ I (ÿ
DESETQ (I J) (CAR G)) ...(SETQ G (CDR G))
                  ...(SETQ I (CDR I))
I J) G)       ...(SETQ G ÿ
           ...(SETQ I (ADD1 I))
orms            incrforms

            (DESETQ (I J) G)
     ...(SETQ I M)
ETQ G M)
consp for))   (add-args (setq var (gensym))))
     (setq var for))
 thendo
orms s))
ms s))
ms s))
etq ,ÿ
 tovar)
ond
,var))
 
auxforms s)))
) (lpstr-incrforms s)))
rÿ
     `(funcall ,byvar ,var))
var ,byvar))
                ÿ
          ))
R I IN L --> (COND ((NULL G) (GO EXIT)))
 EXIT)))
 L DOWNTO M --> (COND ((< G M) (GO EXIT)))
(>= G M) (GO EXIT)))

h `(cond ((null ,var) (go ,(lpstr-exit s))))

         (lpstr-testforms s)))
r
	

stuff (s)
LOOP: WITH syntax error" (more-op)))
error)))
s-op))
=)
     (next-x generate-with-code)
one.
t.
no auxforms or incrforms.
       (push `(,(if (atom with) 'setq 'deÿ
tr-initforms s)))
P: Ran out of args following keyword")
P: WITH specified without initializer")
==========================================================
ata-type-p (x)
um short-float single-float
mber notype)))



listÿ
 arglist
(car var)
===================ÿ

rror)))
urn))
)))
))

NC syntax error")))
etq i (car (next-x syntax-error)))
pe-p (this-op)) (next-x return))
z (car (next-x syntax-error)))
                (add-args z))
-op)) (next-x))

ff (z s)
turn)
((eq (this-op)ÿ
         (next-x)
st-op) (loop-data-type-p (this-op)) (next-x))
nconc2 ,z (cons ,i nil))))
error")))
next-x syntax-error)))
p)) (next-x return))
-x syntax-error)))
    (add-args z))
x))
or "LOOP: PUSH syntax error")))
)
p-data-type-p (this-op)) (next-x return))
o) (setq z (car (next-x syntax-error)))
                         (add-args z))
e-p (this-op)) (next-x))
Á
tax error")))
car (next-x syntax-error)))
his-op)) (next-x return)+
(next-x syntax-error)) )ÿç

-type-p (this-op)) (next-x))
s))
       `(cond (,i (setq ,z (add1 ,z))))))
UNT syntax error")))
tuff ,z '> ,s))
'< ,s))
Å


n))



  (setq stuff `(cond
          ((,comp ,let ,z) (setq ,z ,let))))
,aux t ,z ,let))))
etq ,let ,i) ,stuff)))
AXIMIZE or MINIMIZE syntax error")))
(prog (i)
 `(return ,i))

ror)))
syntax-error
l-stuff (s)
)
 "LOOP: UNTIL syntax error")))
 j k)
(setq j (loop-action z t s))
ÿ
rn


x-error)
p) 'else))
s)))
) ,j))))
fun loop-always-stuff (s)
)
Ç
)
turn `(cond (,i (return nil))))
 error")))
ar (next-x syntax-error)))


*****************
            *
nc.     *
      *
  *
	
*******
  *
<

to the way the stack is handled in ZIL it doesn't pay.  It works    *
much better to do it this way.                            ÿ
                                                              *
***********************************************************

#'FOO (NCONC (MULTIPLE-VALUE-LIST (BAR))
E-LIST (BAZ))



zerror "Too few arguments" x))
)

                               args)))))))


 ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
       All rights reserved.                                        *
                                                               *
************************************************************
*********ÿ
                                                               *
 expander for the MULTIPLE-VALUE-PROG1 macro.              *
                        ÿ
******************************************************

(VALUES-LIST G00001))
-when (eval)

l x)       (zerror "Too few arguments" 'multiple-value” -prog1))
r x)) `(progn ,(car x)))
(,z) ,@(cdr x) (values-list ,z))
)
*************************************
                                *
 Draper Laboratory Inc.     *
                          *
                      *
*******************
***************************
                      *
ro.               *
                *
*************
)  -->
                  (SETQ A G00001 B G00002 C G00003)
0001)
xmvsetq x))
r (null y) (nÿ
ull (cddr y)))
s form) y)
vars))
atom vars)
      (unless (symbolp (car vars))
IPLE-VALUE-SETQ variable"
        (push (gensym) mvvars)
vvars ,form
)

                     )
) (nreverse z))
 z)
                                  ))
rs))))))
********************************************
                                       *
s Stark Draper Laboratory Inc.     *
                                 *
                             *
**************************
.
)
q pop1
           `(prog1 (car ,stack) (setf ,stack (cdr ,stack)))
e
ack))
     K         ))
q g2 (gensym))
else

                                                                     *
 (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
   All rights reserved.                                        *
                                                           *
********************************************************
macroÿ
******************************************
                                     *
                    ÿ
                               *
                           *
                       *
**********************
xpp x))
 nil (zilpp ',x))) (cdr x))

********
   *


**********************************************************************

***************************************************************
                                                          *
88.  Remember when PROG was a specÿ
                                                    *
*************************************************


et (case (car x)
let*)

dy    (or (cddr x)     (zerror "Missing body" x)))
e-value-bind (nil decls body mxform mxvalidp)

en decls (setq decls `((declare . ,decls))))
et ,arglist
))
****************************************
                                   *
ark Draper Laboratory Inc.     *
                             *
                         *
**********************
	
*****
*
<
* 06/13/88 - Support for multiple values.  The definition for PROG1   *
         with 1 argument had to be changed to insure that one     *
 ÿ
                                                            *
*********************************************************
prog1 (x)
 arguments" 'prog1))
 ((z (gensym)))
))
**************************************
                                 *
k Draper Laboratory Inc.     *
                           *
                       *
********************

<
* Change activity:                                              ÿ
                                                                    *
3/88 - Support for multiple values.  The definition for PROG2   *
   with 2 arguments had to be changed to insure that one    *

                                                      *
***************************************************
(x)
error "PROG2 requires at least 2 arguments."))
gn ,(car x) (values ,(cadr x))))
(lambda (,a) ,@(cddr x) ,a)

******************************
                         *
 Laboratory Inc.     *
                   *
               *
************
(DEFMACRO PSETQ (X) (MXPSETQ X))

01

  nil)
prog (y v templist setqsets setqvals)
        (or y (return

                           . ,(nreverse setqvals))))
rror "ÿ
   (push v templist)
qsets)
      (go loop)))))
*********************************************************
                                                    *
89 The Charles Stark Draper Laboratory Inc.     *
erved.                                        *
                                          *
***************************************
SHNEW macro,
******************
             *
   ÿ
       *
   *


                                                                     *
*********************************ÿ

          (mxpshnew a b c d))
ƒ
nd
(setq placevar place))
cevar ,place) bindings)))
'quote))
(push `(,itemvar ,item) bindings)))
       ((null key)
        (memq (car key) '(quote function)))

 kwds `(:key  ,key  . ,kwds)))
)
evar . ,kwds)
               ; Note - place not placevar
cevar))))))
******************************************************
                                                 *
The Charles Stark Draper Laboratory Inc.     *
ed.                                        *
                                       *
************************************
 PUSH macro.

 )
*********************************
                            *
per Laboratory Inc.     *
                      *
                  *
***************

           (PRINC "form=")
;                     (TERPRI)
rm1 form2) --> (PROGN
                (PRINC "form1=")
N1 form1))
               (CATCH NIL (PRIN1 form2))
)

dr x) (cdÿ
)
p
                        ä       "="))
il (prin1 ,(car forms))) z))

*

*         All rights reserved.                                        *
                                                                  *
***************************************************************
his is a genÿ
 that take multiple arguments.  For example...
ESSP 1 2) (LESSP 2 3) (LESSP 3 4))
ro form
tion
.g. (defun < macro (x) (mxrelop x 'lessp))

 "Too few arguments" macroname))
dr args)) `(,func . ,args))
mxrelop-let (args func)

bda (x) (or (car x) (cadr x))) llist))
;;;
 D E)
 (NIL E))
which would result in the following expansion:
;;     ÿ

(let ,letlist

) ,(cadr subargs)))))))
s on (cdr args) while (cdr subargs)
rgs)) into z
)))
xrelop-varpair (car subargs)))
elop-letlist (llist)
))

ym))
*********************************************************
                                                    *
89 The Charles Stark Draper Laboratory Inc.     *
erved.                                        *
                                          *
***************************************
the RETURN macro.
***********************
                  *
forÿ
            *
*********

`(return-from nil . ,(cdr x)))
*************************************************************
                                                        *
t 1989 The Charles Stark Draper Laboratory Inc.     *
 reserved.                                        *
                                              *
*******************************************
he SASSOC and SASSQ macros.
) (mxsassoc x))
sassoc (x)
equiredÿ
ssfun (case macroname
assq  'assq)
me))))

`(funcall ,x))


not take arguments.")
,f))))

;*                                                                     *
IL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
     All rights reserved.                                        *
                                                             *
**********************************************************
der forÿ
 time goes by.
d herein and
-when (eval)
(form &aux (x (cdr form)))
GN off the 2-arg SETF.  Esthetic only.
  ((null (cdr x))    (zerror "Missingÿ
r x))   (mxsetf1 (car x) (cadr x)))
       (z nil)
       (when (null (cdr args))
SETF" form))
fun mxsetf1 (a b)
  `(setq ,a ,b))
        (zerror "Invalid SETF place form" a))
                                (mxsetf1 (macroexpand a) b))
      (funcall (or (get (car a) 'setfmethod) ; Look for SETF method.
  ÿ
    (mxsetf-initialize)      ; maybe initialize SETF
get (car a) 'setfmethod); methods and retry.
                 ÿ
   a b))))
nes the SETF methods of the standard SETF-able functions.
 mxsetf-initialized ()
-initialized (x) ; Try not to use SETF here!

ze ()
car           #'setf-car      'setfmethod)
cdr      'setfmethod)

ist         #'setf-plist    'setfmethod)
ist    'setfmethod)

dr        #'setf-nthcdr   'setfmethod)
ef     'setfmethod)

        #'setf-salist   'setfmethod)
   'setfmeÿ
   (putprop 'cadr          #'setf-cadr     'setfmethod)
      #'setf-cdar     'setfmethod)
 'setfmethod)
 (putprop 'caadr         #'setf-caadr    'setfmethod)
    #'setf-cadar    'setfmethod)
setfmethod)
putprop 'cdadr         #'setf-cdadr    'setfmethod)
  #'setf-cddar    'setfmethod)
tfmethod)
tprop 'cddddr        #'setf-cddddr   'setfmethod)
t))))
 the form whose CAR is the place function
e value to insert in the place.
AZ))
g1: (GET 'FOO 'BAR)

nvalid SETF CAR syntax" a)
t evaluate it last.
a)) (cddr a))
acd ,(cadr a) ,b))   ; Return B but evaluate it last.
-plist (a b)
SYMBOL-PLIST syntax" a)

(zerror "Invalid SETF SYMEVAL syntax" a)

CIAL-ALIST syntax" a)
)
 SETF NTH syntax" a)

a)) (cdddr a))

ÿ
account.  If (SETF (NTHCDR N L) C) is specified where N is equal to
ither at macro expansion time (i.e. a constant) or at run time,
 it proceed at Ç run time, since it will generate a call toÿç

alue of the index at macroexpansion time if it is an integer.
((n (macroexpand (cadr a)))
          (if (integerp n)
     (zerror "Invalid NTHCDR index found by SETF expansion"
        n)
         ÿ

r a))
addr a) ,b)
ddr a))
,b)
a)) (cddddr a))
se
dr a)))
Â

    if   (or (setf-constantp b1) (setf-constantp a2))
    `(putprop ,a1 ,b1 ,a2)
) (setf-simplep a2))
    else                                  ; e.g. (SETF (GET S I) B)...
      (let ((s (gensym))
 ((,ÿ
,a2))                 ; must evaluate I next
b ,i)))))))  ; and B last
expanded.
 x)) (eq (car x) 'quote))))
roexpanded.
) '(car cdr zcar zcdr))
expand (cadr x))))))
(cdr a))) b)
) b)

defun setf-caaar (a b)
setf-caadr (a b)
-cadar (a b)
 (a b)


tf-cdr `(cdr (cdar . ,(cdr a))) b)
 `(cdr (cddr . ,(cdr a))) b)
r (cdddr . ,(cdr a))) b)
dddr . ,(cdr  a))) b)
************************************************************
                                                       *
 1989 The Charles Stark Draper Laboratory Inc.     *
reserved.                                        *
                                             *
******************************************
e SIGNP macro, as in Maclisp.
) (mxsignp a b))
(,c ,b))
,c))
        (N   `(not (zerop ,c)))
   (G   `(plusp ,c))
a))
**********************************************************
                                                     *
989 The Charles Stark Draper Laboratory Inc.     *
served.                                        *
                                           *
****************************************
 the TIME macro.
 msec.
*********************
    ÿ
              *
          *
en    *
    *
*


   (it (gensym))
 `(let (,r1 ,g1 ,r2 ,g2)
,g1 (gctime)

2 ,g1)
ec.  GC time=~D msec.~%" ,r2 ,g2)

          (princ "  GC time=")
 nc " msec."))

***************
          *
.     *
    *
*

SP 1.5 function.
l fil) (mxttab val fil))
(macroexpand xval)))
val)) ,xfil)))
**************************************************
                                             *
Charles Stark Draper Laboratory Inc.     *
                                       *
                                   *
********************************
LE.
2)
	
))
  (DO MORE STUFF)
                    )
       )
d.
e &rest fileopts) . body)

  &aux
opt)
 newbody mxform mxvalidp)
n mxvalidp (setq newbody (cons mxform (cdr newbody))))
setq declarations `((declare . ,declarations))))
ame ,openopt))
name var
rogn . ,newbody)
Â
***************************
                      *
boratory Inc.     *
                *
            *
*********
 is a Waterloo LISP 1.5 function.
tab (val &optional fil) (mxxtab val fil))

zgetfpo ,a) ,val) ,a))))
************************************************************
                                                       *
 1989 The Charles Stark Draper Laboratory Inc.     *
reserved.                                        *
                                             *
******************************************

; NCONC as a macro that expands into the requisite number of calls
NC2.
list (• x)
Ë
 (zcar x) (nconc-list (cdr x))))))
**********************************************************************
                                                                 *
 Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
ll rights reserved.                                        *
                                                       *
****************************************************
rç ce-member zcsdfstr))
e #.%%newlinep nil nil nil nil))
ember for XZILCO proc when "MACROS" not specified.

*

*         All rights reserved.                                        *
                                                                  *
***************************************************************
NOTANY" - anÿ
) returns t if foo-p is true of none
e element(s).
code,
is) ; case of 1 list.
gument 2 to NOTANY not a list" lis))
     (unless (funcall fun (car lis))
lis))
       (return nil)))))
le lists.
ny1 fun (car lists)))
listp list)

hen (zilapply fun (mapcar #'car lists))
    (setq lists (mapcar #'cdr lists))
 car zcar)
**********************************************
                                         *
les Stark Draper Laboratory Inc.     *
                                   *
                               *
****************************
 viz.
f at

la the mapping functions.
st.
VERY not a list" lis))
ncall fÿ
            (go loop))
)
»
ts)))
                  (zerror "Non-list passed to NOTEVERY" list)))

ply fun (mapcar #'car lists))
lists (mapcar #'cdr lists))

************************************
                               *
Draper Laboratory Inc.     *
                         *
                     *
******************
llowing bit settings:
t 30:      1 = append

ode)
    ((nil in input)         #b   0)
   #b   1)
           ((probe :probe)         #b 100)
          #b   0)
                (t (zerror "OPEN: Undefined type" mode)))))

***************
          *
.     *
    *
*

is (keys data &optional (a-list nil))
     (datlist data (cdr datlist))
(zcar datlist)) z))
atlist)

AIRLIS is longer than arg 2" keys data))
error "Arg 1 to PAIRLIS is not a proper list" keys))


******************************
                         *
 Laboratory Inc.     *
                   *
               *
************
********************
               *
           *
         *
CL   *
 *

;* This follows the tentative specification as of the end of 1987.     *
ee 'PROGLIB.CL1987.TEXT' for details.                              *
      ÿ
Currently there is no macroexpansion environment, and the    *
oexpansion done by PARSE-BODY is not aware of any        *
".  This restriction ÿ
xpansion environment situation.                    *
                                               *
************************************ÿ
ody                     ; a body of a LAMBDA et al.
nal
               documentation-allowed-p) ; T for DEFÿ
(let (
       (form               nil)

ation-allowed-p
     (not (null (cdr body)))
              (unless documentation
oÿ
go loop))
valid-expansion-p = nil
                ÿ
              (setq valid-expansion-p t))
eq (car form) 'declare))
))
-p nil)
)))
y one) or NIL
E
Ö
       valid-expansion-p ; T if form is macroexpansiosn of (car body)

ç
******************
             *
Inc.     *
       *
   *

ument
ernp)
;***********************************************************************
                                                                   *
c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
 All rights reserved.                                        *
                                                         *
******************************************************
ourï ce-member zcsdfstr))
/cr t))
rsymbol))

*********************
                *
ry Inc.     *
          *
      *
***
ed to by
Ì
1 2 nil)
o (1- n)

********
   *


**********************************************************************
defun pm (a &optionØ al f)
alues)
***********************************************
                                          *
rles Stark Draper Laboratory Inc.     *
                                    *
                                *
*****************************
macroexpand-1 a) f)

*********
    *
*
<
***********************************************************************
;;;
4/13/2000 for Y2K support:
2001" if this is 2000
s is 2000
(PPDATE (1901 2 3)) ==>   "February 3, 1901" any time
te (&optional (date (current-date)) &aux answer)
            (let (((year month day) date))
nd

                       "April "   "May "      "June "
           "July "    "August "   "September "
  "October " "November " "December "))
lid month" month))
ÿ
er
l-year (year)
 (current-date)ÿ
-DATE is still not Y2K compliant"
t*
century year))
essp thatyear windowyear)

ATE" year))))
*************************************************
                                            *
harles Stark Draper Laboratory Inc.     *
                                      *
                                  *
*******************************
 I'll make a better one soon.
***********************************
                              *
                            *
                        *
                    *
          ÿ
***************
ternal a o)

n pretty-print-internal (a o)
 (prin1 a o))
                     (pretty-print-interÿ
    (princ ")" o))

       (princ " . " o)
               (princ ")" o))
cddr a)))
tty-print-internal (zcadr a) o))
 (null (cddr a)))
     (pretty-print-internal (zcadr a) o))
nc "(" o)
nc ")ÿ
flat (a o)
zgetfpo o))
; a list was detecteÿ
            (zputfpo m o)
	
hen
set flag on
                 (neq (zcar c) 'lambda)

 (cddr b)))
 atom, e.g. ((FOO BAR) BAZ)
pos
        endif
lements of the form are lists,
ch other.
q b a)
ivalent to

      ;
             ÿ
hen (not (pp-atom-p (car b)))
           (setq m oldpos
when (setq b (cdr b))
                 (princ " . " o)
   else
           endif
he following predicate returns true if an object is either an atom
e form (QUOTE atom), i.e. 'atom.
 a)
  (atom (zcadr a)) ; This makes it false for (QUOTE '(list...))
ll (cddr a))
rint)
-print a o))
*******************************************************
                                                  *
 The Charles Stark Draper Laboratory Inc.     *
ved.                                        *
                                        *
*************************************
 `(string-substr (tostring (+ ,n 100)) 2))
e (current-time)) &aux answer)
((hour minute second) time))
 ÿ

   "12:00 Noon")
end
     ((zerop hour) 12)
 12))
":"
  (if (> hour 11) " P.M." " A.M.")))))))
 time passed to PPTIME" time)))
*******************************************************************
                                                              *
pyright 1989 The Charles Stark Draper Laboratory Inc.     *
rights reserved.                                        *
                                                    *
*************************************************
ce-member zcsdfstr))
princ)
***********************************************
                                          *
rles Stark Draper Laboratory Inc.     *
                                    *
                                *
*****************************
ERPRI) + PRIN1 + space.

	

;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
         All rights reserved.                                        *
                                                                 *
**************************************************************
is is like v ZIL PRINT, but uses PRINC rather than PRIN1.
intc (x &optional f)
	
***********************************
                              *
raper Laboratory Inc.     *
                        *
                    *
*****************
PRINTS object NIL) - creates a string like PRINC.
- creates a string like PRIN1.
*****************************************
                                      *
 the old PRINx-TO-STRING,         *
                              *
                            *
*************************
; Stream structures.
nless (bounÿ
ng of *print-...* vars
make-stream :identifier "Print String" :type 'string))
 (stream-output-function sÿ
 char) stringlist)))
  #'(lambda (string) (push string stringlist)))
m stream :escape escape)
 #.%%%princ))
code, no longer in use. ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
-when (compile eval)
nthesis")
;  (defvar lvp "#("              "left  vector    parenthesis")
p ")"               "right vector    parenthesis")
 "       "left  structure parenthesis")
ht structure parenthesis")
parenthesis")

(a)
)
endl (nreverse *printÿ
;   ((or (and (atom a) (not (vecp a)))
 (eq a (rmnil))
 a)     (prout #.lvp)
                 (prout #.rvp))
                (prins-flat (vlist a) s)

s)
             (prout #.rfp))
         (prins-flat a s)
un prins-flat (a s)
ins (zcar a) s)
ll a)
. ")
          (go loop)))))){
*********************************************************
                                                    *
89 The Charles Stark Draper Laboratory Inc.     *
erved.                                        *
                                          *
***************************************
zcsdfstr))
)
*************************************
                                *
 Draper Laboratory Inc.     *
                          *
                      *
*******************
and NIL if it doesn't.
)
name" file))
result (open upcase-file 'probe)))
   (when (< (msglevel) 3)
  (princ "Data set ")
          (princ " not found.")
ult))



(open file))
(close a))
*******************************************************
                                                  *
 The Charles Stark Draper Laboratory Inc.     *
ved.                                        *
                                        *
*************************************
sdfstr))
nil nil))
*********************************************
                                        *
es Stark Draper Laboratory Inc.     *
                                  *
                              *
***************************

ubr nil nil))
*************************************************
                                            *
harles Stark Draper Laboratory Inc.     *
                                      *
                                  *
*******************************
sp READ, not the Common Lisp READ.
  (defun read      (&optional file eof-error-p eofval recursive-p)
read file #.%%read nil eof-error-p eofval recursive-p))
 read-preserving-whitespace
ecursive-p)

ional fileÖ  eofval)
Â
***********************
                  *
tory Inc.     *
            *
        *
*****

e (eofval nil) (newlineval '#.crsymbol))
val newlineval))
****************************************************
                                               *
e Charles Stark Draper Laboratory Inc.     *
.                                        *
                                     *
**********************************
str))
 nil nil nil))
**************************************************
                                             *
Charles Stark Draper Laboratory Inc.     *
                                       *
                                   *
********************************
     (prog (z x)
   (unless (memq x z)
(setq a (cdr a))
verse z)))))
************************************************
                                           *
arles Stark Draper Laboratory Inc.     *
                                     *
                                 *
******************************
    (prog (z x)
  (unless (memql x z)
(setq a (cdr a))
verse z)))))
************************************************
                                           *
arles Stark Draper Laboratory Inc.     *
                                     *
                                 *
******************************
    (prog (z x)
  (unless (memqual x z)
n (setq a (cdr a))
reverse z)))))
**************************************************
                                             *
Charles Stark Draper Laboratory Inc.     *
                                       *
                                   *
********************************
ISP (REMOVE A B :TEST #'EQL)

 ; c = a count of occurrences, default = delete all occurrences.
g (d x z)
         (unless (fixnump c)
t argument" c))
 b (return ÿ


 (if z (rplacd d (cdr b))
Ä
 (ncons (zcar b)))
q z x))
tq b (cdr b))
***********************************************************************
                                                                  *
) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
All rights reserved.                                        *
                                                        *
*****************************************************
ivÿ
(a b &optional c)
st to delete it from.
urrences.

error "Invalid REMQUAL count argument" c))
turn b)))
 atomic b (sublist of arg2)
 then
)
           (setq z (cdr b)))
 else
x)
if

********************
               *
y Inc.     *
         *
     *
**

(if (atom (zcar l)) (zcar l) (reversall (zcar l)))

ersal)
***********************************************
                                          *
rles Stark Draper Laboratory Inc.     *
                                    *
                                *
*****************************

Â
**************************
                     *
oratory Inc.     *
               *
           *
********
t ()
.
*****
*

*                                                                     *
*******************************************************************
lude #.(zil-sour, ce-member zcsdfstr))
.%%rmmac nil nil nil nil))
**************************************************************
                                                         *
ht 1989 The Charles Stark Draper Laboratory Inc.     *
s reserved.                                        *
                                               *
********************************************
 (y nil y?))
erp y))
  x)
(values € q (- x (* q y))))
s q (- x q)))))
***************************************************
                                              *
 Charles Stark Draper Laboratory Inc.     *
                                        *
                                    *
*********************************
hallow binding is implemented, this version of the function
r, to be replaced by an assembler-coded function
piler-generated code sequence as well)
cell of the symbol.
rg>
bound symbols is to be supported:
M  reg,15,##ÿ
 to branch to unbound-warning
de pointed to by the unbound-variable-marker will have to
 was called to signal an unÿ
utoload the symbol value) or to issue
.  Probably it will have to
er 14 or not.
 symbol autoload,

ts to itself.  This includes T, NIL, and keywords by defa5 ult.
defun set (var val)

          ; Access only SPECIAL bindings

*

*         All rights reserved.                                        *
                                                                  *
***************************************************************
;; "SET-FEATÿ
set-feature (x)
must be a symbol)" x)
ad set-feature setfeat)
*************************************************************
                                                        *
t 1989 The Charles Stark Draper Laboratory Inc.     *
 reserved.                                        *
                                              *
*******************************************

Å
tnfeat)
*******************************************
                                      *
 Stark Draper Laboratory Inc.     *
                                *
                            *
*************************
ion takes 1 argument, a function spec, and makes the
rrent ZIL printer.  It interfaces to the
nge the current printer function.
 compiled.
etprt (f)
)

****************************************
                                   *
ark Draper Laboratory Inc.     *
                             *
                         *
**********************
n takes 1 argument, a function spec, and makes the
ent ZIL reader.  It interfaces to the
the current reader function.
iled.
ad (f)
	
 ½ c d e f)
****************************************************
                                               *
e Charles Stark Draper Laboratory Inc.     *
.                                        *
                                     *
**********************************
th Maclisp and Franz.  Not Common LISP.
(defmacro selfmacro () '(subr zrmself))
acro selfmacro () '(zilload 'zrmself))
	
  (defrdmac a c)     ; (SETSYNTAX '×?× 'MACRO #'(LAMBDA (X) ...))
macro a nil))) ; (SETSYNTAX '×?× 'MACRO NIL)
SYNTAX '×?× '8 SINGLE NIL)
YNTAX SINGLE" c)
ETSYNTAX type" b))))
	
****************************************
                                   *
ark Draper Laboratory Inc.     *
                             *
                         *
**********************
ing-left-trim (bag str)

**********************************************************************
                                                                 *
 Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
ll rights reserved.                                        *
                                                       *
****************************************************
 ÿ
true of at least one of the
rns foo-p thereof.
line code,
) ; case of 1 list.
gument 2 to SOME not a list" lis))
      (return (or (funcall fun ÿ
q lis (cdr lis))
 some (fun &rest lists) ; case of multiple lists.
     nil)
ist (list lists)
r "Non-list passed to SOME" list)))
ull lists) (return nil))
 lists)))
sts))

**************
         *
     *
   *

 
rgument.
l &optional f)
gument to SORT not a list" l))
r-list-ness in the loop, but that would
h.  However, I felt that at least
 flagged.
(setq a (zcar l))
                        (setq m nil v z)
null z)
                                         (lessp a (zcar z))))
                (if m (rplacd m (cons a z))
    (setq v (cons a z)))
     V              )
                        (go loop)))
                 (go loop))
Â
*************
        *
    *
  *
<

funcall f (car x) (car y))))
 y))))))
***************************************
                                  *
rk Draper Laboratory Inc.     *
                            *
                        *
*********************
remove (bag str)
tring-index bag char)
 (return (string-appendl (nreverse z)))))
ve)
***************************************
                                  *
rk Draper Laboratory Inc.     *
                            *
                        *
*********************
ing-right-trim (bag str)
reverse str))))
ÿç
*******************
              *
 Inc.     *
        *
    *
*
ring-right-trim bag
im strim)
*********************************************
                                        *
es Stark Draper Laboratory Inc.     *
                                  *
                              *
***************************
)

<
* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
        All rights reserved.                                        *
                                                                *
*************************************************************
lis  (a y)ÿ
      (t        (cons (sublis a (zcar y))
  (sublis a (cdr y)) ))))
 a)           z)
                 (t                  (sublis2 (cdr a) z) )))

****************
           *
c.     *
     *
 *

	

                    (sublisq a (cdr y)) ))L ))
          (cond ((null a)           z)
   (cdar a))
)
********************************
                           *
er Laboratory Inc.     *
                     *
                 *
**************
 X :TEST #'EQ).
to
isfies-the-test" part is conditional based on
atomic elements can never be EQL.
t not SUBSTQUA.
(if (eq old x) new x))
                  (kdr (substq new old (cdr x))))
eq kar (car x))
       x
	
*************************************
                                *
 Draper Laboratory Inc.     *
                          *
                      *
*******************
W OLD X :TEST #'EQL).
milar to
e "satisfies-the-test" part is conditional based on
e non-atomic elements can never be EQL.
QL, but not SUBSTQUA.
tom x) (if (eql old x) new x))
 x)))
(if (and (eq kar (car x))
                 x
car zcar)
***********************************************
                                          *
rles Stark Draper Laboratory Inc.     *
                                    *
                                *
*****************************
 (SUBST NEW OLD X :TEST #'EQUAL).
o be more similar to
½
 x)      x)
                  (kdr (substqual new old (cdr x))))
f (and (eq kar (car x))
        j                  x

Â
************
       *
   *
 *


 the primitive
efun sxhash (a)
      (z 0))

do ((i (1- (vlength a)) (1- i))
f a i)) z))
  (t           (zilhash a))))
ÿç
*******************
              *
 Inc.     *
        *
    *
*
to be evaluated.
bol other than T or NIL.

o longer
unbound, before we signal an error
              (1) If the variable is a keyword, we return thÿ
        variable itself as the value.  Since ZIL does not
  have a package system, a symbol is considered to
keyword if its first character is a colon.
 necessary.
e
                function names... if it is a string, the file
      of tÿ
t is evaluated as a form.  The AUTOVALUE
 be a symbol.
  Completely recoded to uÿ
e need to support the new autobinding feature
er.
;;            variable does not have a cÿ
  considered unbound.  Only the evaluator itself is
 assume other values (CSETQ, OBLIST, ALIST,

unction
;;; (and an inline-coded compiler-generated code sequence as well)
will load the value cell of the symbol and test it for
Something like this:
LUE(14)
ted by BOUNDP:
)
R  reg      ... or whatever, to branch to unbound-variable
 ... handling in error-signalling mode
sue the ICM to set c+
;
fun symeval (x)
          (cdr binding)
{
********************************
                           *
er Laboratory Inc.     *
                     *
                 *
**************
 terpri (&optional f)

**************
         *
     *
   *

 
ssary to convert the arguments to float before dividing.
anyhow, just to check the conversion algorithms.
ional (y nil y?))
 (integerp y))
         x)
      (values q (- x (* q y))))
values q (- x q)))))
********************************************************
                                                   *
9 The Charles Stark Draper Laboratory Inc.     *
rved.                                        *
                                         *
**************************************
csdfstr))
(zcread file #.%%tyi nil nil eofval newlineval))
®
****

ÿ
                                                                     *
******************************************************************
ude #.(zil-sour­ ce-member zcsdfstr))
 (eofval -1) (newlineval #/cr))
ineval))
********************************************
                                       *
s Stark Draper Laboratory Inc.     *
                                 *
                             *
**************************

 
********************************
                           *
er Laboratory Inc.     *
                     *
                 *
**************
	
fun typep (a &optional (b nil b?))

e argument.
º
um)
(stringp a)  'string)
 ((closurep a) 'closure)
 (vref a 0)))
-flavor-ÿ
))
               (t
tom)
ypep-2 (a b)
p b)    (typep-2-list a b))
      (zerror "Unknown second arg to Tÿ
(a b)
 (listp    a))
mbolp  a))
 flonum)     (floatp   a))
le-float
loat
))

ode)       (codep    a))
re)ÿ

r)  (characterp a))
 (eq (vref a 0) b)ÿ
e)
 
'(lambda (x) (typep-2 a x)) (cdr +
 (typep-2 a x)) (cdr b)))
((member)
all (cadr b) a) t nil))
   nil)))
***********************************************
                                          *
rles Stark Draper Laboratory Inc.     *
                                    *
                                *
*****************************
he same as Franz LISP UCONCAT.
, vectors or funargs)



 ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
       All rights reserved.                                        *
                                                               *
************************************************************
catl (a)

**********************
                 *
ory Inc.     *
           *
       *
****
  (x y)
(memql (zcar x) y) (union (cdr x) y))
  (cons (zcar x)
 x) y)))))
**********************************************
                                         *
les Stark Draper Laboratory Inc.     *
                                   *
                               *
****************************


      (t                 (cons (zcar x)
           (unionq (cdr x) y)))))
*********************************************************************
                                                                *
Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
l rights reserved.                                        *
                                                      *
***************************************************
ÿ
un unkeywordify (x)
cond
(symbolp x) x)


                                                                     *
 (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
   All rights reserved.                                        *
                                                           *
********************************************************
-soury ce-member zcsdfstr))
) (newlineval #/cr))
 
********************************
                           *
er Laboratory Inc.     *
                     *
                 *
**************
Â
**************************
                     *
oratory Inc.     *
               *
           *
********
 a message, and is therefore PRINC'd.
andom value, and is therefore
 be a list of random values, and is
hancement:  If the first arg is a list, all the elements in the
     list are printed in succession.
 to Common LISP, such that it will take the
 a format string, eventually.
fun warn (a &optional (b nil b?) &rest c)
cterpri)
ncÚ  a)
   (princ " - ")
(prin1 i))

<
* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
        All rights reserved.                                        *
                                                                *
*************************************************************
CLUDE
UDEF.
file FOO) ...)
)
Á
m NIL to (PROGN) to avoid the
at top level.
progn)

file (f file)
e)) z)))
)
file) (xinclude file))
***************************************************************
                                                          *
ght 1989 The Charles Stark Draper Laboratory Inc.     *
ts reserved.                                        *
                                                *
*********************************************

*

*         All rights reserved.                                        *
                                                                  *
***************************************************************
 compiles thÿ
*************************************
                                *
                           ÿ
                          *
luous initializations *
s involves two    *
o detect cases  *
e it is     *
places, *
ROG.  *
w *
<



;;;;;;;ÿ
 ; B = body, V = variable, S = target, E = environment
 setnillabel wayout save-tempcond)
ull v) (consp s) (zilcÿ
     nil))

Probably not useful for anything.
sett ,t ,v ,s))))   ; (AND)   -> T
 s e)))       ; (AND x) -> x
 e)))
p xf)                              ; (AND ... (NOT x) ...)
 (zccevcom (cadr xf)
out 'gonil)
D NOT
                        (setq setnillabel (gensym))))
f)
f +
ÿ
e a T
                                    ; (AND ... x ...)
               ÿ
If non-predicative
... x), then
or x,

                                             ; use what ZCCPRED ret'd.
                                         ;
yout 'gonil) (cdr a)) xf (car a))
(if   (eq wayout 'gonil)
dicative AND
a))
               (putprop exitlabel t 'forceniltest)
goto ,exitlabel)
xf)             ; (AND .. (foo-p x) y ..)
r setnillabel
)))
 ; (AND ..ÿ
  endif 
ar e)) t) ; All forms other than first
     ; are conditionally ÿ
 body `(label ,setnillabel nil nil))
o ,exitlabel))))
n (modq body `(label ,exitlabel ,v ,s))) 

***********
      *
  *
*


;;; If the variable is self-evaluating, then it is a constant.
iable is a "keyword", then it is a constant.
le, then use that.
t's a
 unbound variable, it may still be lexically known
 function (funarg).  We must scan the
s is the case.  Note that
g is applicable.
ever be passed to this routine.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
)
;
) ÿ
s))         ; If not, gen dummy code
)         ; See if self-evaluating
 ; If it is, get ÿ
 ; If it's a keyword (:FOO) or
therwise self-evaluating
 as a constant atom
al bindings, then compile it as
the variable is declared SPECIAL, we do it the same way
he code generator will tell if the binding has

hose must be compiled as if they were unbound, but the associated
s are marked... see ZILCOAUV.
gs (car e)))) ; If a bound variable
 (putprop (cdr a) t 'used)               ; Mark it referenced
 (cdr a) 'set)              ; If not set, force init'n
(cdr a) t 'mustinit))
 kind of "unbound variable"
t it will be

om & bindi™ ng 4 it
udocode for it
d
)
***************************************
                                  *
rk Draper Laboratory Inc.     *
                            *
                        *
*********************
binding and makes it SPECIAL, FLUID or whatever.
n atom for the variable, so code can be
le by name.
;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
fun zccbind (x type)
ÿ
type) (terpri)
for the variable
initialized.
enced.

get (cdr x) 'bindingtype))

**************
         *
     *
   *

 
****

;*                                      ÿ
**********************************************************************


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

¤
     (blkname)           ; the name of the block
 the body of the block
ody '(error "Missing block name" 'block)))
car bÿ
body `(error "Invalid block name" ,blkname)))
of the block for this contour.
name)

prop blkexit s 'rettarg)
tart to generate P-code.
	
progn blkbody nil `(goto ,blkexit) e)
 
bel code.
Â
***************************
                      *
boratory Inc.     *
                *
            *
*********
t of atoms
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
s))
;;;;;
ubrs)))   ; Find F if it is in list
    ; If so, return that subr
; Else create a new subr
air to symbol table
ecursive call
he  list
o call it
*********************************************
                                        *
es Stark Draper Laboratory Inc.     *
                                  *
                              *
***************************
ion inline.
************************
                   *
                 *
             *
         *
ions *ÿ
   *

;*            ever reÿ
            the SETQ-initialization-hacking scheme used in ZCCPROG.  *
        This also requires a new P-code form, CSETNIL, and a new *
    code generator module, ZCGCSNIL.ÿ
- Bug fix for tags that never return.                      *
                                                       *
***************************************************ÿ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
zil-source-member zilmacs))
;;;;;;;;;;;;;;;;;;;;;;;;;;;
                ; Arg 1 to CATCH = a tag (should be atom)
          ; Arg 2 to CATCH = form to be evaluated
  ; a label to be used by the generated code
 ÿ
and set locals.
atch))))

º
Q target.
.


x...
frame.

putprop label2 t 'referenced)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
valuated within the CATCH
n't have

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(e (cons (zccmkcec 'catch e) e)))
ed conditional because a THROW
 to contiÿ
ide being executed.
cprogn forms nil `(goto ,label1) e)
luate forms with
abel
	
rate label for THROW to go to.
l tell the code generator

***********************************************
                                          *
rles Stark Draper Laboratory Inc.     *
                                    *
                                *
*****************************
tion inline.
*************************
                    *
                  *
              *
          *
      *
ons *
*

*            ever referenced.  This is an extension of, and replaces, *
         the SETQ-initialization-hacking scheme used in ZCCPROG.  *
     This also requires a new P-code fÿ
   code generator module, ZCGCSNIL.                         *
ow that ZCGSTTRG has been upgraded to handle GONIL and  *
NIL to GO tags et al., ZCCCOND no longer has to     *ÿ
he contour structure to see if a (COND ... GO) or *
ETURN) optimization is valid.  However, it    *
MEMQ, since MEMQ is weird.                *
 and TAGBODY.                           *
RETURN removed.                     *
                                *
***ÿ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
cs))
;;;;
 tconstant valuep
itlabel (gensym))
'rettarg)
t (zilcovta s))))

car e)) save-tempcond)
y if a value is required
uated for a value)
nil (goto ,exitlabel))))
     (return nil))
IF-clause.
f (or (cdr a) valuep) (gensym) exitlabel))


onstant.
; Number, string, etc.
                (consp (cdr f1))
OTE anythinÿ
turn value of IF-clause.
tnil ,exitlabel) e))
er of optimizations
tq f1pred (if tconstant t (zccpred f1)))
               (null (cdr f2))

          branchlabel exitlabel a v s e))
 normal compilation of multiple THEN clauses.
d f2 branchlabel exitlabel a v s e)))
 (zilcec-tempcond (car e)) save-tempcond)
exitlabel ,v ,s))))
when (and (null v) (null s))

cdr a))


                        &aux weirdp p tag progexit retval blkname)
COND ... (s1 s2) ...), where s1 has already been processed by
            ZCCPRED tÿ
-weirdp s1))
) with a
; branch around code that would go tÿ
r ((AND ...) (GO ...)) - it generates worse code.
 if the IF-clause is "weird".
l to MEMQ, since
ot weirdp)

 p))              ; Get the tag
s1) nil (if p `(gonil    ,tag)) e)ÿç
   nil (if p `(gonotnil ,tag)) e))
st do the same processing as is done
 to AND INCLUDING the contour
rmanently conditional.
  ;
((NOT form) NIL) ...}
(NOT (ATOM X)) NIL).

has strange code generation.

evcom (cadr s1) nil `(gonil ,exitlabel) e))
riable variable) ...)
le) ...)
s1 s2 exitlabel nil
abel a v s e))
; try some more optimizationsÿ
       (cdr s2)            ; Skip if (RETURN-FROM) - syntax error
ll (cdddr s2))   ; Skip unless (RETURN-FROM blockname {x})
         (setq blkname (cadr s2))
     (setq progexit (cdr (assq blkname
lcec-return-tags (car e)))))))
 ((NULL form) (RETURN-FROM somewhere NIL)) ...)
(NOT form) (RETURN-FROM somewhere NIL)) ...}
-FROM x) and (RETURN-FROM x NIL) both work here.
f form is a predicate,

in this context usually means a call to MEMQ, since
de generation.
      (eqÿ
(zccevcom (cadr s1) nil `(gonil ,progexit) e)
ate a RETURN-FROM, we must do the same processing
TURN-FROM is seen.  All ÿ
ociated with the RETURN-FROM are marked
   ;
timize (COND ... (variable (RETURN-FROMÿ
  or (COND ...((SETQ ... variable form)
 somewhere variable))...)
imize-variable-reference s1 retval progexit t
     s1 s2 branchlabel exitlabel a v s e))
zations possible - generate normal code.
t s1 `(,s2) branchlabel exitlabel a v s e))))
ions possible - generate normal code.
,s2) branchlabel exitlabel a v s e))))
reference (form var label returnp
nchlabel exitlabel a v s e

ND ... ((SETQ ... variable form) ...) ...)
    (and (eq-car form 'setq)

r)))
te a RETURN-FROM, we must do the same processing as is
N-FROM is seen.  All contours upÿ
ed with the RETURN-FROM are marked permanently
  (when returnp
  ; No special optimizations possible - generatÿ

ccond-punt (s1 f2 branchlabel exitlabel a v s e)
n the "pair" is a constant like "T", skip
  Otherwise, compile first form
y.
 (if (notp s1)

iple THEN-clauses, compile them as an implicit PROGN.
THEN-clauses, as well as any subsequent IF-clauses,
uted.
r v s (cdr a)) `(goto ,exitlabel) nil) e))
nd (tag e)
 processing
p to AND


until (eq cec c)                    ; Note placement of UNTIL!!!


p (cadr x))))))
 (consp ,x) (eq (zcar ,x) ,y))
ariable, OK?")))
******************************************************
                                                 *
The Charles Stark Draper Laboratory Inc.     *
ed.                                        *
                                       *
************************************
 constant atomic or list values.

 one of the above)...
ÿ
list of lists.
;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;ÿ
efun zccconst (a v s e) ; A is the atom, V the variable, S the target,
                    ; E the environment
ull v) (null s)) ; Nothing to ÿ
 ,s))  ; Code generator will neutralize this anyhow.
etnil nil ,v ,s))
a)
small ,a ,v ,s))
gp a)) `(setatom ,(let ((q (zilcoadd a nil)))
          (putprop (cdr q) t 'real)
q) ,v ,s))
             `(error "Cannot compile object of this type" ,a))

*******************************
                          *
r Laboratory Inc.     *
                    *
                *
*************
*********************
                *
 occurs     *
          *
      *
***
;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 (b    ;  the (headless) body of the DECLARE form
variablÿ
get of the value (must be NIL)
          )

 them.
odq body `(error
)
;;;;;;;;;;;;;
evel-declare

bform within the DECLARE,
AR)
DECLARE subform" ,a)))

  (zccdcl-process-vardecl x (car a) e)))

  ÿ
  (terpri)
rdecl (a d e) ; process symbol declaration
rations recognizeÿ
able is a Common LISP dynamically scoped
tured by closures.  A SPECIAL
references it, which
s its value.
 be dynamically
ISP
; for a FLUID variable to be unbound ON ENTRYÿ
nces it (either for access or update).
)
 (t
ariable.
    (q))
dd the variable to the list of atoms.
We know it'll be really used.
pecial variable,
ƒ
declared -ÿ
cdr name) t 'specialdeclare) ; Mark this function.
declare (SPECIAL FOO) when FOO has already been
 vice versa) is an error.ÿ
al) 'fluid 'special))
Conflicting SPECIAL/FLUID declarations" ,a)))
t d)) ; Mark this occurrence special or ÿ
        (princ "DECLARE ")
)
red.")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;{
.
****

ÿ
                                                                     *
******************************************************************


 of the global compiler variable ZDEF.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ÿ
ember zilmacs))
;;;;;;;;;;;;;;;
 b (go error1))
; Function name.
zccevcom `',fsym nil `(arg (1 ,zdef)) e)

fsub)
 'zilxdef 'subrs)))
±
±
)
*****************************************************
                                                *
he Charles Stark Draper Laboratory Inc.     *
d.                                        *
                                      *
***********************************
function calls.
****************************
                       *

                 *
tializations *
s two    *
cases  *
   *


            code generator module, ZCGCSNIL.                         *
                                            ÿ
****************************************************************
‡
 user may have declared something inline or notinline.  E.Gÿ
d floating-point-p floatp)
 means that floatp has the BUILTIN property
TINLINE property.
ct on floating-point-p.
;
;
;;;;;;;;;ÿ
 args v s e)
rarg)
    c (let ((x (get funcÿ
 x) x nil))
       ; Eventually, the setting of "inline-ness" will be done
  ; by retrieving it from the current cÿ
clare (notinline ...)) will work.
 (and (get (or c func) 'builtin)
e))
                         (null v)
ultimate-target s e) t)))
y (via DEFLOAD), then
efined,
 own defaults.  If these don't exist, then punt.
  (or (if c (get c 'minargs))
)))
  ÿ
 'restarg))
setq lexprarg (or (if c (get c 'lexprarg))
func 'lexprarg)))ÿ
Can't optimize it!
   (if (< n minargs)
           `(error "Too few arguÿ
    else

 many arguments passed to function" ,func))
   )
   then
Function \"")
n.  Will be invoked via FUNCALL.")
utprop func t 'funcalled))
,args) v s e))
 name \"")
e a SUBR with ")
" argument." " arguments."))
rgs n)
.
           (remprop func 'restarg)    ; Set no &REST arg.

operty is an
.
,(cond
             (inline         'begininline)
       'begincall)) ,func ,n ,v ,s))
e arguments to the function.
s maxargs restarg lexprarg e)

ompile-tailrecur)); See macro definition.
ine ,func ,n ,v ,s))

 (modq body `(error "Function name not a symbol" ,func)))
nc) 'lambda)
n ---
or "Missing arglist in LAMBDA expression"
,args)))
non-NIL atom
expr.
                                  ; but to compile it like a
                  ; separate function
gs v s e)
if 
func)))
.
saved in pseudoglobal TAILRECUR so that the code generator can
 special variable bindings are to be maintained over
ÿ
ack usage
'(loop for p in (zilcec-bindings (car e)) ; Add local vars to list
sh p tailrecur)ÿ
                        ; Update list, then emit P-code.
recur ,func ,n ,v ,s))))

) (cdr func))
-valid-p  (zilcoarg temp-lambda-name lambda-args))
    (get temp-lambda-name 'parms))
lambda-name 'minargs))
axargs))
      (temp-lambda-lexprarg (get temp-lambda-name 'lexprarg)ÿ
da-exitlabel     (gensym))
bda e) e))
       (putprop lambda-exitlabel s 'rettarg)
lid-p
..
modq body
on"
    else
ull temp-lambda-lexprarg)
       then
ments passed to LAMBDA-ÿ
args etc.) . ,args)))
 call sequence.
; Generate code to evaluate the argumeÿ
environment is the one outside the lambda's env.
rgs args
       temp-lambda-minargs

emp-lambda-lexprarg
de to invoke the LAMBDA code inline.
ressing GO/RETURN stuff any more, because now the
.
                     ,temp-lambda-parms ,v ,s))
belÿ
a-parms)
ate code to initialize and bind all args, including
pplied-p argumentsÿ
ama temp-lambda-name lambda-exitlabel lambda-body e))
e the body of the lambda.
bda-exitlabel) e)
                           ,temp-lambda-parms ,v ,s))
y `(label    ,lambda-exitlabel ,v ,s))
inc "Warning: Uncompilable LAMBDA-expression argÿ
mbda-args)
.")
nt...
))
) ; end LET*
targ lexprarg e)
he function.

rguments, and then pass in the "not-supplied"
rgument.
 take the remaining arguments, CONS up a list out of
st as the final argument.
Ð
her args on the stack following it.
      (zccatom (length a) nil '(arg 1) e)
       for x in a

       do
   (modq body `(setopt nil nil (arg ,i))))
     (cond
     (let ((pair (car lparms)))
set)
      (remprop (cdr pair) 'mustinit)
tnÿ
evcom (car a) nil `(arg ,i) e)))

 (if restarg
                             nil `(arg ,i) e))
)
piled

rogated eventually here.
ue target of a target
ditional GOTO
Q or

         (null (get (cadr s) 'catch))     ; catch frame to worry about
 )                                   ; then you can go right thru
      (ultimate-target (get (cadr s) 'rettarg) e)

*********************************
                            *
per Laboratory Inc.     *
                      *
                  *
***************
horse compiles any form.  It outputs chunks of pseudocode.
 level, this is sandwiched between two layers of
ode (see COMPILE-BODY).
 er, compiled.
)
d operand is a "target" to which the result of the
o be assigned (typically an argument spec as


- a "CMACÿ
(CAR form) is a LAMBDA-expression, then...
e,
evaluate the form using ÿ
******************************************************************
                                                             *
vity:                                  ÿ
                                                       *
t for inline ASSQ and MEMQ.                        *
r VALUES and new special forms.                *
PROG and RETURN removed.                     *
                                         *
**************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ber zilmacs))
;;;;;;;;;;;;;
 ''×ÿ
)
(zccfarg 'subr ,b ,v ,s ,e))
cond


    ;
  ; Otherwise, check if form is ÿ
piler.  If it the unique object ZDEF, it's an internally
-lexical DEFUN.
(eq carb zdef)
	
of
; LAMBDA-expression and compile accordingly
n error if it's not a LAMBDA-expression).
))       (zccevcom-maybe-lambda b v s e))
acro, compile the macro expansion.
ro)
)
   ;
    ; was deÿ
unction call.
                             (zcceval carb (cdr b) v s e))
heck for all special forms.ÿ
cquote (cdr b) v s e))
s e))
eq carb 'block)           (zccblock (cdr bÿ
-from)     (zccretf  (cdr b)     e))
ody (cdr b) v s e))
))
q carb 'and)             (zccand   (cdr b) v s e))
        (zccor    (cdr b) v s e))
 (cdr b) v s e))
)
arb 'throw)           (zccthrow (cdr b) v s e))
ct)  (zccuwp   (cdr b) v s e))
dr b) vÿ

 'multiple-value-list)
s e))
      (zccmvbnd (cdr b) v s e))
all (cdr b) v s e))
v s e))
          (eq carb 'listify))    (zcclexfn carb (cdr b) v s e))
or (eq carb 'eq)
          (eq carb 'rplaca)
carb 'assq)


	
      (eq carb (comma-dot)))
backquotÿ
ad)
  (modq body
,carb)))
„
	
of the form may be a LAMBDA- or LABEL-ÿ
pilable.
what ZILCO used to do all the time with these things.
ar b) e) (cdr b) v s e)
m into another
lag
Now we try to compile the LAMBDA inline if possible.  Here's how:
If the CAR of the form is a LABEL-expression, do as before - we
nerate another function.
on, see if it is a
f iÿ
 ;
   (modq body
ion"
    (lambda (zcceval formcar formcdr v s e)) ;ZCCEVAL knows what to do
label  (zcceval (zcclamb formcar t e) formcdr v s e))

                    ,formcar))))))))
;***********************************************************************
                                                                   *
c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
 All rights reserved.                                        *
                                                         *
******************************************************
LE-ÿ
******************
             *
         *
       *
   *


	
  program  (toplevel = yes)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
s))
;;;
            l          ; L is a LAMBDA-expression
; (CAR L) is "LAMBDA"
gument variables

            alone      ; if not NIL, this is a standalone function
      e          ; environment (list of contours)
cond
F is to be "segmented", as requested
compile a segmented version of
egcount (and f (get f 'segmeÿ
(let ((newbody (zilcoseg f l segcount)))
                       (cterpri)
ersion of function ")
          (princ " being compiled:")
                      (terpri)
                        (terpri)
               (setq l newbody))))
(cddr l) e))
one e))
ression - ")
tion returns all the pseudocode for a function body.
s used by the compiler are local to here.
; Compile the body of the function
returnÿ
rocedure

 unbound special variÿ
nd lexical variables referenced by the fn
enced by the program
Ó
; internal LAMBDA-procedures compiled along with the rest
st of local variables active during tail recursion
ntually, push new "defun" contour onto "e" when doiÿ
setq body      (list nil)
o SUBRS list.
ction.
ist nil)
    subrs     (list nil)
l
wÿ
he argument list.
list of function args.
A argument list"ÿ
 )
rror "More than 255 required + optional args"
r name))))

        (putprop (cdr x) name 'owner))
arglist.
orms in the body as an implicit PROGN.
te "T" means generate the return value.
 ,main ,alone))
exical bindings were uncovered, add the atoms
" way by calling ZILCOADD on them.
s))
operty list to hang off the new thing
            (list
      'name              name

                  'fluid-unbounds    fluid-unbounds
             atoms
        'subrs             subrs
s

	

;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
         All rights reserved.                                        *
                                                                 *
**************************************************************
; "ZCCFARG"ÿ

 or (SUBR ...) must be a symbol
ression.
ing
is generated to build a compiled or interpreted
case may be.
st of 1 element - the function name.
ase meanings.
;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
fun zccfarg (u b v s e)
dr b) (go error1))
tc. expression.
 built.
or
   ((sÿ
             (go error2))         ; #'#<other> - error
da

sion

.
 '*zilco* 'special-forms))


normal)      ; and generate a compiled closure for it
ose-unknown)     ; otherwise make interpreted closure

make a SUBR.
n list

 +

     (modq subrs dottedpair)))     ; then add it to the list
    ,dottedpair ,v ,s)))     ; Generate CLOSURE or SUBR
ose-unknown

losure" "subr"))
 (putprop n t 'zilxclosed))
pile call to closure maker.
 "Invalid FUNCTION syntax" ,(cons u b)))
 body `(error "Invalid FUNCTION name" ,n))
modq body `(error "Function cannot be passed as argument" ,n))
 
(if (eq (car x) 'lambda)
     (or (cddr x) (go not-valid))
able.
o not-valid))
mbda-p (caddr x)))

sion"
ion-p (x)ÿ

(if (and c (symbolp c)) (get c 'minargs))
nargs)))
t))
*****************************************
                                    *
tark Draper Laboratory Inc.     *
                              *
                          *
***********************
e compiles functions which may be coded inline in
in all cases).
rgs to the function.
.
*********
    *
*
<
* 04/25/88 - Support for determination of superfluous initializations *
         of PROG ÿ
       new fields in the contour that are used to detect cases  *
   of a variable unconditionally being set before it is     *
ver referenced.  This is an exteÿ
 SETQ-initialization-hacking scheme used in ZCCPROG.  *
so requires a new P-code form, CSETNIL, and a new *
tor module, ZCGCSNIL.                         *ÿ
                                            *
*****************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
member zilmacs))
;;;;;;;;;;;;;;;;
 zccfast (f a v s e &aux (l (length a))
bound-thing* (gensym)))
a v s e) (zccfastbug f)))
ccfastbug f)))
)))
(rplacd (if (eql l 2) (zccfast-rplacd a v s e) (zccfastbug f)))
 (eql l 2) (zccfast-assq   a v s e) (zccfastbug f)))
(zccfast-memq   a v s e) (zÿ
vref   a v s e) (zccfastbug f)))
s e) (zccfastbug f)))
 
	
l))
)
 ; At least one of the args to EQ is a constant.
t the case where both are constant for now,
to be arg2.
m)) ---> (EQ (form) 'foo)
 v s e)
to EQ is the form (ZILUNBND), which represents the
   ;
 Onlyÿ
thing* v s e)
If neither argument to EQ is a constant, can't do a fast compile.
ore, in that case doÿ
2))
must be a constant.

mpile of EQ is supported for:

lp con)) ; This is why *unbound-thing* must be a gÿ
 incorrect use of EQ. Maybe you mean EQL or EQUAL?"
)
 arg nil '(arg (1 eq)) e)
1 ,v ,s))
===========================
((arg1 (zilcomex (car a) nil))
ÿ
	
do a fast compile.
Á
))
t worrying about the case where both are constant for now,
e constant one to be arg2.
  ; (EQL 'foo (form)) ---> (EQL (form) 'foo)
it arg2 (car con1) v s e)
   (t
'eql (list arg1 arg2) v s e))))))
orted for:
elf-evaluating and quoted symbols, the EQL is
at's equivalent.


mbol.  Converting to equivalent EQ"
t-eq-doit arg con v s e) ; Compile as fast (EQ arg1 arg2)
 con) (sÿ
 types
ninline eql 1 ,v ,s))
 `(inline (eql ,(zccfasÿ
robably incorrect use of EQL. Maybe you mean EQUAL?"
n))
=================
cons   ,a ,v ,s ,e))
ca ,a ,v ,s ,e))
a ,v ,s ,e))
do a "fast" compile for CONS/RPLACA/RPLACD
 ; constant or a locally bound variable.
first argument is.
xpand, we don't care

n do the "fast" compile.
cfaÿ
/R is a locally bound variable, we can also do

r-doit f arg1 tempÿ
ormal" compile.

f variablep con (zccfast-thing coÿ
s))
sed thing))
================================================ÿ

)

„
`(assq ,arg1 ,arg2))

 might be a local variable
ing variablename?
arg2 e))
Q something (+

             (eq (car arg2) 'special-alist))
) ; Only if it's being compiled inline
nil v s e))
e)
g 2 to ASSQ is a constant.  Now is it a valid association list?
not (do ((l (car con2) (cdr l)))
(when (atom l) (return nil))
                    (and (consp (car l))
lp (caar l))))
2 to ASSQ not a proper association list for ASSQ"
2))
all OK.
n2)) nil v s e)))))
)
sq)) e)
assq ,ÿ

=============================================
 e &aux temp)
mex (cadr a) nil))
   ; MEMQ something NIL?
 MEMQ is nil, suppressing call to MEÿ
   (zccevcom (zilcotrn `(progn ,arg1 nil) debug) v s e)
)
°
 ;
t-memq-doit arg1 temp t v s e))
(not-a-variablename)
)
s?

cÿ
MQ not a proper list of symbols"
st-memq-punt arg1 arg2 v s e))

))
`(begininline memq 1 ,v ,s))
 variablep (zccfast-mark-used tƒ hing))
,v ,s))
)
==============================================
s e)
adr a) nil))
hen
nvalid second arg to VREF" ,arg2))
gininline vref 1 ,v ,s))
         (modq body `(inline (vref ,arg2) 1 ,v ,s))

all

modq body `(inline vref 2 ,v ,s))      ; compile inline code
 )
==============
mex (car a) nil))
omex (caddr ÿ
))
`(error "Invalid second arg to VSET" ,arg2))
ody `(begininline vset 2 ,vÿ
)) e)
 `(inline (vset ,arg2) 2 ,v ,s))
odq body `(begininline vset 3 ,v ,s)) ; coÿ
m arg1 nil '(arg (1 vset)) e)   ; compile load of argument
 nil '(arg (2 vset)) e)   ; compile load of argument
(arg (3 vset)) e)   ; compile load of argument
 3 ,v ,s))      ; compile inline code
====================================================================
fun zccfast-thing (x)
  (and (fixnump x) (>= x -1) (<= x 255))
hing*)
  (putprop (cdr q) t 'real)
=======ÿ
ther a given argument is a locally bound
ot a dynamically bound one)
enerated, based
e

 ZCCATOM would have done.
arg e)
)
 (get (cdr z) 'set)
==================================================ß =============
 zccfastbug (f)
	
*************************************
                                *
 Draper Laboratory Inc.     *
                          *
                      *
*******************
ns.  It is similar to
ked, and
; which the code generator checks for specially.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
l-source-member zilmacs))
;;;;;;;;;;;;;;;;;;;;;;;;;
 (length args) 4)))    ; Gotta allow 4 extra stack slots.

))
        (modqÿ
dy '(setnil nil nil (arg (2 zilxfun))))
l (arg (3 zilxfun))))
)))
          (zccevcom (car args) nil `(arg (,i zilxfun)) e)
 (setq args (cdr args))
un n v s e))
*********************************************************************
                                                                *
Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
l rights reserved.                                        *
                                                      *
***************************************************
ÿ
EFUN.
LONE = NIL:  program  (toplevel = yes)
;;;;;;;;;;;;;;;ÿ
mber zilmacs))
;;;;;;;;;;;;;;
on definition
onsp f)                     ; A LAMBDA-expression
ne e))


 a function definition
compiler.
  ; (including macroexpansion and compiler transforms)
            ; to the function definition.
main alone e))
¤
 (terpri)
********************************************************
                                                   *
9 The Charles Stark Draper Laboratory Inc.     *
rved.                                        *
                                         *
**************************************
O" function.
*************************
                    *
  ÿ
              *
          *
o     *
    *
*

*            of a variable unconditionally being set before it is     *
         ever referenced.  This is an extension of, and replaces, *
     the SETQ-initialization-hacking scheme useÿ
   This also requires a new P-code form, CSETNIL, and a new *
ode generator module, ZCGCSNIL.                         *
                                                    *
***************************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
-source-member zilmacs))
;;;;;;;;;;;;;;;;;;;;;;;;;;
t
   (when p
      ;
ed
       ;
   for cec in e
              until (eq cec c)))))      ; Note placement of UNTIL!!!
¦
************************
                   *
atory Inc.     *
             *
         *
******
N arglist,
.
or lambda expression
enerated by

FORMS - the body of the function or lambda expression, which
must be scanned for declarations.
will eventually be being modified
bindings)
ÿ
nction will be
r the
;;; for any of ÿ
ll of them.  Furthermore, SPECIAL declarations will be
y in this function.
******************************ÿ
                             *
                         *
                     *
us initializations *
nvolves two    *
ect cases  *
t is     *
ces, *
 *

;* 06/23/88 - Support for PROG and RETURN removed.                     *
                                                                   *
**********ÿ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(include #.(zil-source-member zilmacs))
;;;;;;;;;;;;;;;;;;;;;;;;;+
s e

r e))
      )
that they can be
setf (zilcec-bindings cec)
tf (zilcec-specials cec)


(if (and (stringp (car forms)) (cdr forms)) (cdr forms) forms)
r b))
(car b) nil))
ished w/body.
conÿ
eclaration...
consp declaration)
        (modq bodyÿ
eclaration))
t of all DECLARE subforms and
 with the first

ND-IT, in accordance with CLtL'84, so that SPECIAL
ot attached to local bindings pertain to
ned in the lambda list.
ard is adopted, and
rdless of
 
ND-IT.  In this case, for correct operation,
ILCEC-BINDINGS as it existed before
gh that may not be strictly
on, variables that

             ÿ
CLARATION SUPPORT...NOT IMPLEMENTED YET                           .
                                                              .
rvasive declarations here   ÿ
ough all declarations and process all of them one way   .
pt for SPECIALs, done by ZCCLAMA-HACK-SPECIALS).    .
ted declarations to prepare to attach them +
                                         ©      .ÿç
                                                              .
...........................................................
ma-hack-specials llvars decls cec)
glist.
one
	

....

;.            ÿ
 Attach binding-related declarations (other than SPECIAL decls)      .
bindings for each "x" here.                                      .
orget to check global (top-leÿ
                                                           .
........................................................
  ; If this is an &OPTIONAL variable:
lied-p" variable,
ether
lization form, setting the variable,
e and (if present)
en (get (cdr x) 'optional)
                l (gensym))
s) nil)))
etf (zilcec-tempcond cec) t)
st s) nil)))
         ÿ
save-tempcond)
clama-bind-it x label decls e)
ecls e))
     ; save it for later use
    collect x into keyvars
UX variable,
cdr x) 'aux)
 ; If we encounter a variable which is some other variable's
d-p" or destructured variable, ignore it on this
handled it when we processed its "owner".
 'owned)
al") variables are just bound.  There is no
m since their values will be on the
ation time.

following:
geÿ
lue was supplied;
ble,
lied-p" variable.ÿ
te code to initialize
&REST list for
  (when keyvars
nil)))
modq body `(keys ,keyvars ,fun ,aok nil nil)))
 in keyvars do
))
              (putprop (cdr keysymbol) t 'real)
rop (cdr k) keysymbol 'keysymbol))
 k) 'suppliedp)
n s (modq body `(sett t ,(list s) nil)))
nal ,k ,l nil nil))
               (when s (modq body `(setnil nil ,(list s) nil)))
     (zccevcom (get (cdr k) 'init) (list k) nil e)
 l t 'referenced)
)
cclama-bind-it k label decls e)
label decls e))))
g the following:
able,

get (cdr a) 'init)))
      ((null init)
                      (remprop (cdr a) 'used)
prop (cdr a) 'mustinit)
,(list a) nil))

      (zcclama-bind-it a label decls e)))
here to move the call to ZCCLAMA-HACK-SPECIALS if the CL

; Return the body without the declarations.

(v (c© ar x))ÿç

       )
p (cdr x) cec 'contour)

 is named in a (DECLARE (SPECIAL ...))

e delete it from that list.
e variable is globally
t case.
in decls
         (memq v (cdr d))))
 #'eq)
         (setf (zilcec-specials cec)
s cec)))))
cate so.
ariable ÿ
hen sp (zccbind x 'special))
binding.
f the variable is reallÿ
ucturing form in the lambda list, generate the code to
dividual destructured variables and bind them
loop for dvar in (get (cdr x) 'destrvaÿ
var) 'init)))
          (remprop (cdr dvar) 'set)
d)
q body `(csetnil ,dvar ,(list dvar) nil))
  (t
ama-bind-it dvar label decls e)
ecials (llvars decls cec)
CIAL declaration local
list:
‡
may be considered superfluous.
t of specials, and also
h encompasses
de
 insure that in the form
et ((b "some-other-junk"))
   (foobar a)))
 LET-bound one.
al)
sq x llvars))
))
          )

-bindings cec) :test #'eq :key #'car))
en (assq x (zilcec-bindings cec))
indings cec)
ngs cec)
                                     collect b))))))))


************
       *
   *
 *


previously determined not
 LAMBDA-expression,
 has been

CFUNC (compile-subroutine) will flag it as an error.
*****************************************************ÿ
                                                         *
:                                                    *
                                                 *
d, setting of contour slots to suppress the    *
RETURN out of FUNARGS into the FUNARG-     *
now implemented here instead of in     *
is ÿ
 issues apply.  Some day,        *
/RETURN out of a funarg,     *
However, we will  ÿ
 the bindings,         *
cific technique    *
               *
             *
         *
******
; ALONE = NIL:  program  (toplevel = yes)
t for multiple base registers mandates that we
e enclosing function's BASEREG property
.  Sadly, there is no other way
s to be compiled with
have names.


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
             +
           ÿ
        ; passed through (funarg or pseudo-inline lambda),
   ; false if not (i.e. SUBR, like DEFUN).
      ; Give the LAMBDA-fuÿ
(eq (car x) 'label)
 (gentemp (concat (car name) " LAMBDA "))))
A-expression and compile it as a subroutiÿ
ide a new contour.
arg 'subr) e) e)))
rements of a
;
     ; Note that the variable list is not inherited across
r SUBR type contours.  The compiler needs to access
chain" to track down variables that are
st be "heap-allocated".
he "creator" is the

  ; is the same as the creator of the current contour.
 Because the compiler currently does not support the use
RETURN from inside fuÿ
(The interpreter supports it.)
))
 (zilcec-creator     new-cec) creatoÿ
ngs    new-cec) nil)



unless lamb

rnal procedures.
d its name to the list of function names.
ame)
e turn lname)
**********************************************************
                                                     *
989 The Charles Stark Draper Laboratory Inc.     *
served.                                        *
                                           *
****************************************
‡

tions inline.
 lisÿ
meanings.
;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;ÿ
efun zcclexfn (f a v s e)
rent function is a LEXPR.
 LEXPRness?
ror "Function call invalid in non-LEXPR" ,f)))
sed, assume first argument is NIL.
 so it can be analyzed here.
etq a '(nil))
;
 processing functions here.
-process-arg a v s e))
  (listify  (zcclexfn-process-listify a v s e))
d caller of ZCCLEXFN" f)))

 (a v s e)
ts" 'arg)))
cclexfn-procesÿ
ar a))                            ; (ARG) or (ARG NIL)
inline arg 0 ,v ,s))
  ((and (fixnump (car a))    ÿ
     (plusp (car a))
ne arg 0 ,v ,s))
   (t                                      ;ÿ
body `(begininline arg 1 ,v ,s)) ; compile as inline call
a) nil '(arg (1 arg)) e); compile load of argument
g 1 ,v ,s))      ; compile as inline (ARG ...)
=========================================================ÿ
un zcclexfn-process-setarg (a v s e)
dq body `(error "Too few arguments" 'setarg)))
 `(error "Too many arguments" 'setarg)))
    ; (SETARG n) where n is constant
(car a) 1024))
 (cadr a) nil '(arg (1 setarg)) e);compile load of argument
inline ÿ
          ; (SETARG anything-else)
s))  ;compile as inline call
compile load of argumeÿ
mpile load of argument
nline (SETARG ...)
=============================
e)
tify)))
  (unless (assq 'zilxlfy subrs)
'subrs)))
call
 (modq body `(inline listify 1 ,v ,s)) ; compile as inline (ARG ... )

**************************************
                                 *
k Draper Laboratory Inc.     *
                           *
                       *
********************
 is called to create a new compilation environment
ots are defined by the DEFSTRUCT for ZILCEC

***
<
*                                                                     *

                                                                *
 - As promised, setting of contour slots to suppress the    *
se of GO and Rÿ
losing PROG has been moved from here to ZCCLAMB.      *
LAMB for more details.                            *
                             ÿ
etermination of superfluous initializations *
variables to NIL.  This involves two    *
tour that are used to detect cases  *
onally being set before it is     *
n extension of, and replaces, *
 scheme used in ZCCPROG.  *
orm, CSETNIL, and a new *
                    *
                *
cture has     *
          *
      *
***
;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ec (type e)
nvironment).
ny of the fields in the current contour will be copied
- but not all.

ll replace these with copied lists or other stuff anyhow.
 ((old-cec (if e (car e)))
 (make-zilcec)))
ype) ; Assign requested type.
Always starts off as
onal by default.
me by default.
;***********************************************************************
                                                                   *
c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
 All rights reserved.                                        *
                                                         *
******************************************************
***ÿ
                                                         *
MULTIPLE-VALUE-BIND.                                 *
                  ÿ
************************************************
ing MULTIPLE-VALUE-BIND is that it is really
uld think of
DY2) (BODY3))
VALUE-LAMBDA (A B C) (DECL1) (BODY2) (BODY3))
e differences between this and true LAMBDA are:
gument is always received by the "procedure".
 are allowed in the argument list.
l destructuring support in the
 though Common LISP does
y similar to ZCCEVAL-CALL-LAMBDA.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ilmacs))
;;;;;;;;
   ; (mvbind)
dq body `(errÿ
let (((mvargs mvform . mvbody) b))

m args) (return 'error2))
ror1))))
 allowed in arglist"

n arglist"

  (mvbind-valid-p        (zilcoarg mvbind-name mvargs))
d-parms          (get mvbind-name 'parms))
  (gensym))
p)
           (multiple-value-bind . ,b))))
op mvbind-exitlabel v 'vartarg)
)
 ,(length mvargs) nil nil)))
     nÿ
rms)))
ple-value-bind e) e)))
ind-parms ,v ,s))
riables.
p (cdr x) name 'owner))
s off body.
el mvbody e))
 mvbody nil `(goto ,mvbind-exitlabel) e)
mvbind-exitlabel ,mvbind-parms ,v ,s))
vbind-exitlabel ,v ,s))

*

*         All rights reserved.                                        *
                                                                  *
***************************************************************
************ÿ
                                                                  *
rocesses MULTIPLE-VALUE-LIST.                                 *
                           ÿ
lue-list <form>)   ... CLtL, p. 135                     *
                                                    *
******************************************ÿ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
-source-member zilmacs))
;;;;;;;;;;;;;;;;;;;;;;;;
ll b)
not (null (cdr b)))
e-list . ,b))))

tprop l s 'rettarg)     ; Establish returned-value target.
mvlist)      ; Identify it as MULTIPLE-VALUE-LIST
er) ; RC eturn value must be in register 15.
 nil nil))
l ,v ,s))
*************************************************************
                                                        *
t 1989 The Charles Stark Draper Laboratory Inc.     *
 reserved.                                        *
                                              *
*******************************************
" or "NULL" function.
;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
efun zcÿ

 (NOT X), B = (X)
cond
dr b)  (modq body `(error "Too many arguments" (not/null . ,b))))
 (zccevcom `(cond (,(car b) nil) (t t)) v s e))))
²Q
*****
*

*                                                                     *
*******************************************************************
This compiles thÿ
****************************************
                                   *
                               ÿ
                             *
erfluous initializations *
This involves two    *
d to detect cases  *
fore it is     *
 replaces, *
CCPROG.  *
 new *
 *

;
;
;;;;;;;;;;;ÿ
 e) ; B = body, V = variable, S = target, E = environment
bel settlabel fallthrulabel wayout save-tempcond)
out (if (and (null v) (conÿ

,v ,s)))) ; (OR)   -> NIL
     ; (OR x) -> x
etq fallthrulabel (gensym))
en
   (putprop exitlabel v 'vartarg)

°
n
ayout 'gonotnil)
e
r a))
 else
    ÿ
bel
      endif)
 if non-predicativeÿ
. (NOT x))

cevcom (if (eq wayout 'gonil) xf (ÿ
  (if   (eq wayout 'gonotnil)
             else
en (if (null (cdr a))
                else
                     endif
null (cdr a))


or settlabel

itlabel)
  endif)
)


  (modq body `(sett t nil (goÿ
r e)) save-tempcond)
t as unconditional as
t does the
mstances
 ,s)))
 nil)))
***************************************************
                                              *
 Charles Stark Draper Laboratory Inc.     *
                                        *
                                    *
*********************************
¤
d returns an equivalent form by doing the following to it:
panding it
ns (NOT/NULL)

X))) --> (ATOM X)
;;;;;;;;;;;;ÿ


r form))) form)
ar form) 'macro))
omex form nil)))
¸
      )
g argument" not/null))
 `(error "Too many arguments" (not/null . ,notargs)))
t
)
'not)
               (list (car form) newarg)))))))

*****************
            *
nc.     *
      *
  *
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
include #.(zil-source-member zilmacs))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 body
ll (cdr b))  (zccevcom (car b) v s e))
il nil e)

*****************
            *
nc.     *
      *
  *
	

;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ÿ
b v s e) ; B is the body...
'(error "Missing argument" quote)))
rror "Too many arguments" quote)))
 s e))))
********************************************
                                       *
s Stark Draper Laboratory Inc.     *
                                 *
                             *
**************************
**********************************
                             *
                         *
                       *
********************
;;;;;;;;;;;;;;;;;;;;;;;;;




ss-return-from (car b) (cadr b) e))
rguments" (return-from . ,b))))))
orm e &aux p)

-FROM" ,rfname)))
 ; All contours up to AND INCLUDING the contour asÿ
TURN-FROM are marked permanently conditional.
p 'contour)
t)
	
***********************************
                              *
raper Laboratory Inc.     *
                        *
                    *
*****************
 It is implemented as a call to the "ZCCEVCOM" pseudocode
mately generate code to assign the return value
a store operation, retaining the value
found).
e
e and a symbol
nding.

<
* Change acÿ
                                                                    *
5/88 - Support for determination of superfluous initializations *
   of PROG and &AUX variabÿ
 new fields in the contour that are used to detect cases  *
a variable unconditionally being set before it is     *
ferenced.  This is an extension of, and rÿ
initialization-hacking scheme used in ZCCPROG.  *
uires a new P-code form, CSETNIL, and a new *
dule, ZCGCSNIL.                         *
                                      *
***********************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 zilmacs))
;;;;;;;;;;
(null b)
 (cdr ÿ
tq))))
            (compile-setq var val nil nil e) ; Not the last pair
 (go loop)
Last pair
efun compile-setq (var val v s e)
(symbolp var))
      (eq (pbind var) var))
var)))
zilcec-bindings (car e))))
  else
ding) t 'mustinit)
    ; Make a list of SETQ vars in case of nested SETQ assignments,
evaluate the form that SETQ's them.
 s e)
Y
 this to be the case, all contours from the current one down to

 the variable must not have the status of requiring
 
 )
setq) 'mustinit)))
          (loop for cec in e

          (zilcec-permcond cec))
               when (eq cec c)
q) t 'set)

**********************************************
                                         *
les Stark Draper Laboratory Inc.     *
                                   *
                               *
****************************
************************************
                               *
                           *
                         *
**********************
****************************
       ÿ
                     *
                 *
             *
           *
********
;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
cctbody (b v s e)
 new environment contour
the TABBODY can refer
 format
	
 (putprop tagexit s 'rettarg)
; Tell the generator to reserve stack space.
agexit ,v ,s))
 (ÿ
 (or (symbolp x) (integerp x)))
         do   (modq body `(error "Duplicate GO tag" ,x))
e collect (cons xÿ

xit label.
 tagexit  'progexit)
bel (car e)  'contour)
ontour.
ilcec-go-tags (car e))))
 the TAGBODY body...
 a label whose
generate code to evaluate the form.
     ((null form) nil)      ; Ignore NIL's in a TAGBODY bodyÿ
mbolp form)    ; Compile symbols as tags
e integers as tags
astform golist))))
 body `(label ,l nil nil))))
ymbol or integer - error
DY" ,form)))
  (setq laÿ
code without using the return value

 return NIL.  Note that tÿ
 things like all paths of a COND returning or going, etc.
d (consp lastform)

 out the BEGINTAG above for the code generator.
tagexit ,v ,s))
abel ,tagexit ,v ,s))
***********************************************************************
                                                                  *
) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
All rights reserved.                                        *
                                                        *
*****************************************************
mpÿ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
member zilmacs))
;;;;;;;;;;;;;;;;
)
 syntax" `(throw . ,b))))
om tag  nil '(throw tag) e)
   ))))
*******************************************
                                      *
 Stark Draper Laboratory Inc.     *
                                *
                            *
*************************
" special form inline.


----------------------×
 catch frame     ×
            ×
    ÿ
    ×

        STM   11,1,ÿ
     LA    14,label2           Address to return to after cleanup ×
ST    14,frame+12(,11)    Store into new frame               ×
 14,frame+0(,11)     Address of neÿ
,ZLCCATCH         Make it the active catch frame     ×
protected-form ...                              ×
in register r1 ...                         ×
     (for future multiple value support)×
Save return value in frame         ×
thru or branch from THROW     ×
ious catch frame address   ×
make previous active  ×
                 ×

         ×
    ×


------------------------------------------------------------------×#
he structure of the unwind-prÿ
'00')  Address of previous CATCH/UWP frame (zero if none)
  Saved register 11 (stack pointer from catcher)
egister 12 (base register from catcher)
 (to branch to following catch)
ariable binding stack)
ng stack)
H

               (during unwind, contains the tag being thrown to)
+x'20')  Return value stored from evaluating protected form
      (during unwind, contains return value from THROW)
	
********************************************************
       ÿ
                                                 *
                                             *
ag optimization.      ÿ
 RETURN out of UNWIND-PROTECT.         *
ion of superfluous initializations *
 to NIL.  This involves two    *
at are used to detect cases  *
ing set before it is     *
on of, and replaces, *
 used in ZCCPROG.  *
NIL, and a new *
           *
 is put  *
     *
 *

;
;
;;;;;;;;;;;;;;;;;ÿ
 e)
-forms        ; Arg 2 to UNWIND-PROTECT
l to be used by the generated coÿ
o be used by the generated code
used by the generated code

issing protected form" unwind-protect))))
q body

ls to be used in code generation.ÿç
need be set for the labels, for they are not
al ZILCO label handling.
ym)

prop label1 s 'rettarg) ; Info used when compiling VALUES.
P-code.
WP frame.
COND).
ected forms within an UNWIND-PROTECT are considered conditional
 a non-local exit may occur at any point, causing execution
eyond the scope of the protected forms without any of
ng executed.  This does not apply to cleanup
(let ((e (conÿ
(car e)) t)
l `(uwp ,label1) e)  ; Protected form.
 ,label3) e) ; Protected forÿ
rop label3 t 'referenced) ; Force generation.
l (uwp ,label1))) ; Process returns.
)        ; Evaluate cleanup forms.
))       ; Finish up UWP processing.
WP
**************************************
                                 *
k Draper Laboratory Inc.     *
                           *
                       *
********************
****************************
                       *
                   *
                 *
             *
         *

   *

;* is returnedÿ
                                                                     *
nge activity:                                                    *
                             ÿ
- Support for nested GO's.                                 *
es contour to validate PROG env. instead of PROGEXIT.  *
t for TAGBODY.                              ÿ
                                                 *
**********************************************
 removed, so no more "GO outside of PROG"
st get "GO tag undefined", because
, but there's no direct
ain, and it's
ent
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
urce-member zilmacs))
;;;;;;;;;ÿ
= environment
ond
b)
(setq x (car b)))
t a symbol or integer" x))
)))

NIL
¤°¤
******
 *

;*                                                                     *
********************************************************************

EVAL, except that the number of args is not checked.
sidered to be an "inline" function, since the
a call to the ZILSUBS routine
 Examples:
          ST    #0,xxx+0(,#11)
#0,xxx+4(,#11)

         LA    #1,xxx(,#11)        stack location of values
  #2,3                number of values
;          BALR  #14,#15             Call ZILVALS
VALUES <form>), where exactly one value is
LVALS can be optimized out,
 as a form returning
occurs in
½
   L     #15ÿ
           Force single-value return
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
r zilmacs))
;;;;;;;;;;;;;
dq body `(begininline values ,l ,v ,s))
 (i 1 (1+ i))
 `(arg (,i values)) e)


***************************
                      *
boratory Inc.     *
                *
            *
*********
;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ail (r) (zerop (get r 'usecount)))
**********************************************************************
                                                                 *
 Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
ll rights reserved.                                        *
                                                       *
****************************************************
*ÿ
                                                       *
erates code to (re)load additional base registers. *
en a function haÿ
                                             *
******************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ÿ
-member zilmacs))
;;;;;;;;;;;;;;;;;
  ((nil) (push nil codelist))
INGP. No longer valid."))
	
reg))
LA"   "7,4095(,12)"    "Load second base register.")
    (zcgenout nil "USING" `(,(cdr naym) "+4095,7")            nil))
(3
("6,7," ,g)  "Load additional base registers.")
zcgenout nil "USING" `(,(cdr naym) "+4096,7,6")          nil))

 ,g)  "Loadÿ
out nil "USING" `(,(cdr naym) "+4096,7,6,5")        nil))
"Invalid base register specification" b))
bel (b naym usingp &aux lbÿ
naym) (setq lbl1 (gensym)) 'baselabel)
)) "Branch around base adcons.")
       (3 (string-append "A(" (cdr naym) ÿ
            (cdr naym) "+4096)"))
aym) "+12288,"
                                   (cdr naym) "+4096)"))ÿ
cgenout lbl1 "DC" adcons nil)
t (cdr naym) 'baselabel)
 use.
nil "LA"    "7,4095(,12)"    "Load second base register.")

  (when (> b 2)
register.")
90,63 ")               nil))
 "5,4095(,6)"    "Load fourth base register.")
genout nil "USING" `(,(cdr naym) "+12285,5")             nil))
))
****************************************
                                   *
ark Draper Laboratory Inc.     *
                             *
                         *
**********************
************************
                  *
             *
          *
t... *
*
 ÿ

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 (prog
 being called

 the target of the value to be ÿ
n v s) a)
ush (car pdmax) argbase)  ; Base for function call arguments
r pdmax) pdmax)    ; Height of stack used
current top-of-stack.
*********************************************************************
                                                                *
Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
l rights reserved.                                        *
                                                      *
***************************************************
ÿ
                                               *
                                          *
               ÿ
***********************************
************************************
                              ÿ
                             *
                         *
                     *
                   *
               *
************
ariables (see ZILMACS).
sion out of an
 two
  recursion where no variable bindings need be changed, and one
recursion where variable bindings must be
this, we had to separate the
ng of the ÿ
some
or "pseudolexical".
********************
ted for by the garbage
HANGE THE OTHER!!
*******************
**********************
d on the size of the
 #ZBEG MACRO
*******************************************************
========================================================
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
il-source-member zilmacs))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
rgs adconp)
))

 stack (+ pdbas 12))         ; top of standard interface save
conp                      ; True if ZILSINT needs to be called

 (cdr alfatoms) (cdr numatoms) (cdr alllists)
       (or (cdr lists) (cdr atoms))
conp (and main (not alone)))
ain "ZLBPTRS" (gensym)))
ILATOM" nil     ))
" (gensym)))
arg in args
) 'position)) 4)))
(mapc #'assign-location (cdr subrs))
oms.
 to the main proc.
'assign-location (cdr alfatoms))
 new locations to atoms.
 
als (which will cause either ZILVSYM
-binding implÿ
broutines will have to
el for the subroutine addresses so
routines by ZILLOAD.
  (if (or (cdr subrs) (cdr special-unbounds)) (gensym) nil))
e generation.
initialize constants if required,
if required.
lues of free variables.
g code.

setq stackmax  (if (or (car special-asaved)
uid-asaved))
ck)

===========================================
l with aÀ  print name of *) means that anÿç
be inserted in column 72 as a continuation character
se a string there!
zsubrs zzzptrs zzzatoms zzzlists
e acsize)
xa     (or (get (car name) 'maxargs) nargs)
'restarg)
get (cdr name) 'zzzptrs )
    zzzlists (get (cdr name) 'zzzlists)
ize)
co*   ÿ
odelen
  (* 4 (quotient (+ #.(+ 25 3) (string-length (car name))) 4)))))
enout nil "TITLE"
ZIL 1.3'") nil)
yes))
gram
   '* )
ONE = NO: Main procedure of executable program
ZBEG" "MAIN=YES,TYPE=PROGRAM,"             '* )
MODE=24,AMODE=31,"                       '* )
nout nil nil `("PDSIZE=" ,pdsize ",") '* ))
ut nil nil `("VSSIZE=" ,vssize ",") '* ))
ut nil nil `("CSSIZE=" ,cssize ",") '* ))
 nil nil `("ACSIZE=" ,acsize ",") '* ))
s
 ÿ
r name) "#ZBEG" (if main "MAIN=YES,TYPE=FUNCTION,"
              "MAIN=NO,TYPE=FUNCTION,")   '* )
cgenout nil nil ÿ
f codelen 8)
   (zcgenout nil nil `("PTRS=" ,zzzptrs ",")                        '* )
incf codelen 16)
t nil nil `("ATOMS=" ,zzzatoms ",LISTS=" ,zzzlists ",") '* )
f (get (car name) 'lexprarg)
                               '* )
"MINARGS=" ,mina ",")                   '* )
ARGS=" ,maxa ",")                   '* )
=" ,(if rest t nil) ",")        '* )
 
	
il  "L"     "2,0(,1)"        "Get pointer to LEXPR arg.")
"L"     "2,##CDR(,2)"    "Get fixnum value thereof.")
LA"   "2,2"                    "Multiply it by 4.")
  `("0," ,zzzstksz "+4(2,1)")
termine max stack size.")
l error iÿ
inal stack frame.")
 stack frame.")
 pointer.")
 boundary

of inline adcons.  Thus, the 2-byte no-ÿ
enout nil  "NOPR"  "0"              "Insure fullword boundary.")
cf codelen 32)
  "Define maximum stack size.")

                               "Save stack and base registers.")
nil     "ST"    `("14," ,(+ pdbas 8) "(,1)")
                  "Save return register.")
"             "Set up base register.")
se HLASM will report a warning/error.
    ÿ
r name) ",12")
ability.")
ase.")
 additional base registers if applicable.
m) "EQU" `(,(cdr name) "+" ,codelen)
 code offset so far.")
estimated code offset.
=======================================
function and there are any constant atoms
ntained within, a call to intern them
one time only, on entry to the
andled by ZILINIT, so we
 cases stand-alone
, so this
ux sasaved1 fasaved1)
 oms must be initialized


zcgemit 4 () "L"   "15,ZLCSINT"          "Get address of ZILSINT.")

            "Address the list of pointers.")
                       "Call ZILSINT.")
ase registers ÿ
.
 (zcgemit 0 l2 "DS"  "0H"                                        nil)
emit 0 "*" " "  " "         "ÿ
§
 This must be done if:
les elsewhere,
 this

riginal alists on first entry
al exit therefrom.
special",
§
lrecur))
 )
address of special ALIST.")
     "Stoÿ
   (incf stack 4)
) "L"  "0,ZLCFALST"  "Get address of lexical ALIST.")
T" `("0," ,stack "(,11)"ÿ
ns 'falist stack))
pecials free-lexicals)
H" nil)
aved1 fluid-asaved)
==============================
erenced by the function,
ropriate alist and

unbounds))

 ; Begin unbound-variable-stack-slot-initialization code.
 () "L" "0,ZLCUNBND" "Load pointer to unbound object.")
bl)
f ÿ
)) 24)
                   (car var))))
 
                                      ; are referenced in this code
; Begin unbound-variable-retrieval code.
    "Code to retrieve lexical vaÿ
2 var ptr)
 (gensym)
       (m off       (+ m 256))
cgemit 6 () "XC" `(,m "(" ,l ",11)," ,m "(11)")
           "Set unbound pointers to zero.")
 "XC" `(,m "(256,11)," ,m "(11)")
Set unbound pointers to zero.")
it 4 () "LA" `("0," ,lng) "Load number of unbound variables.")
gemit 4 ()  "L"   "1,ZLCFALST"    "Get address of lexical alist.")
mit 2 lbl "CR"  "1,10"            "If not all variables bound,")
2 ()  "BER" "13"              "then signal error.")
2,##CAR(,1)"     "Get this alist pair.")
"     "Get Cÿ

(cdr var) 'location)
))
`("If variable " ,(if (> (string-length (car var)) 24)
                 (cdr var)
)
 lb1 (if (cdr ubl) (gensym) lb2)) "then...")
 ,ptr "(11)")   "check value on stack.")
    "If already set, ignore value.")
1)") "Else store value on stack.")
   "Continue searching alist")
ss no more vars to find.")
dr ubl))

               "then...")
ore valÿ
ore vars to find.")
 "L"  "1,##CDR(,1)"          "Get next pair in alist.")
  lbl                   "Continue searching alist.")ÿç
cgemit 0 lnf "DS" "0H"       "Unfound symbols have zero pointers.")
it 0 "*" " "  " "         "End code to retrieve lexical vars.")

; End of unbound-variable-retrieval code
===============================================
x)
===ÿ
ring-appendl (zilcoquo (explodec a)))
======================================
rlist)

******************************************************
                                                 *
The Charles Stark Draper Laboratory Inc.     *
ed.                                        *
                                       *
************************************
h variables on the alist if they are
to be used as free variables

ÿ
erty by ZCGBPROG, and ZCGSTTRG checks this via EQ.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
source-member zÿ
;;;;;;;;;;;;;;;;;;;;;;;;;
 the local variable being bound
a POPALIST property
involved
he new stack location if an ALIST must be saved
on used by ALIST processing
on if present
e dotted pair representing the variable symbol
ir representing the binding fun to call
able being processed
rty of binding
 (var lbl v s) a)
in another subr.
ALISTs.
;
*******
    *
*


            the corresponding FREEVARS list, even if it's never
really used.
to

PECIAL but was globally declared so, we make it look as+
cally declared the same way, for convenience.
(get (cdr var) 'bindingtype))
(return)) ; Do no more if not a "free" variable.
ode to put variable on special ALIST.
o it and tell where it was done.
  (setq p (car pdmax))             ; Get saved-alist stack offset.
 m (+ p 4))                 ; Get new top-of-stack offset.
   ÿ
ved (cons 'salist p))
f STACK stack.
  ; Set new high wÿ
ke exit label restore ALIST.
 address of special ALIST.")
     "Store on stack.")
ND"))
ST.
 
 Get saved-alist stack offset.
w top-of-stack offset.
ALIST stack.
x (cons m (cdr pdmax)))  ; Replace top of STACK stack.
)
  (putprop lbl p 'popfalist)      ; Make exit label restore ALIST.
  (zcgemit 4 () "L" "0,ZLCFALST"    "Get address of lexical ALIST.")
gemit 4 () "ST" `("0," ,p "(,11)")           "Store on stack.")
(setq binder '("ZLCFBND" . "ZILFBND"))
de generator ÿ
e CDR of the binding type is T.
before they are scoped
gtype))       ; SPECIAL or Fÿ
et the atom for the variable.
te specialness/fluidity.
)
cal variable in use as a free ")

 (car var))
")

pri)))
 is addressable by the code.
tion)ÿç

cial or fluid) variable, generate code to replace the value on
th a pointer to an Aÿ
lue.
dr pair) (car pair))
(cdr var) 'lexprarg)
 "Get LEXPR stack pointer.")
"Load value of " ,nam))
    `("Load value of " ,nam))
," ,(car binder))
inder) "."))
                                       `("Load address of " ,nam)ÿ
it 2 () "BALR" "3,15"             `("Call " ,(cdr binder) "."))
dr var) 'lexprarg)
t LEXPR stack pointer.")
• er to ALIST cell.")

ndif 
****************************************************************
                                                           *
ight 1989 The Charles Stark Draper Laboratory Inc.     *
hts reserved.                                        *
                                                 *
**********************************************
ode for BEGINLAM, which marks the start of an
he function position of a form.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
cs))
;;;;;;
lds info about the lambda
       v     ; an item toÿ
   ; the target of the value to be set


o assign offsets to the args.
(cdr arg) 'offset)
 (setf (get (cdr arg) 'position) nil)
or supplied-p args defined for the lambda,
ve to bump the top-of-stack pointer more, because no args
for these guys (ZCGSTTRG was bumping (CAR PDMAX)

 arg) 'aux)
ss (zerop m)
(car ÿ
 ; Increment the top element of stack PDMAX
           (setq stackmax m))) ; and reset the high water mark.
alist pointers.
 BIND requests
wise
cial (n.p.i.) is to be done with thÏ is pseudocontour.
special-asaved) ; Will be filled in by BIND requests later.
-asaved)   ; Will be filled in by BIND requests later.

*********************
                *
ry Inc.     *
          *
      *
***
*****

*                                              ÿ
*******************************************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
lude #.(zil-source-member zilmacs))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (l (car a)) ; the dummy exit label
 ;;; s          ; not used
cks on the exit label, so that code
unbinding/unwinding it has

te!  The abo¯ ve requires that ZCGBIND do RPLACA's on xxx-ASAVED to
maintain EQness, which ZCGSTTRG checks for.

**********
     *
 *

;***********************************************************************

                                                                    *
 module generates code to initialize an UNWIND-PROTECT frame.  *
                                    ÿ
OTECT frame looks just like a CATCH frame, except that *
ds longer and the tag slot contains hex zeroes.   *
                                             *
r details on the contents of this frame.  *
                                     *
*********************************
************************************
                               *
                           *
 ÿ
IND-PROTECT.         *
pport for        *
ains,        *
           *
       *
****
;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
wp (a)
code
v   ; not used
tion where the UWP frame will go
wing the UWP frame
 labels.
     (setq c (car pdmax))    ; UWP frame goes here on stack.
 (+ c 36))       ; Bump stack past UWP frame.
; Stack height.
 High water mark.
o-unstack l+
x specialÿ
e to build the UNWIND-PROTECT frame.
TCH"       "Get active catch frame.")
,11)") "Store into UWP fÿ
   "Get special ALIST.")
exical ALIST.")
 zeroes.")
 code.")
                                 "Store all into UWP frame.")
 4 () "LA" `("14," ,l2) "Where to return after cleanupÿ
 () "ST" `("14," ,(+ c 12) "(,11)")
       "Store into UWP frame.")
   "Address of UWP frame.")
ake active catch frame.")

                                                                     *
 (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
   All rights reserved.                                        *
                                                           *
********************************************************
*****ÿ
                                                    *
                                               *
                    ÿ
****************************************
L.
f args to ZILXFUN minus 1 for the fÿ
d stack slots) is multiplied by 4 to give
 occupied by arguments to
e is placed

                                                                     *
nge activity:                                                    ÿ
                                                               *
- More arguments to ZCGSTVRS.                              *
                                                       *
ÿ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
zil-source-member zilmacs))
;;;;;;;;;;;;;;;ÿ
b   ; the name of the function to be called or invoked
er of arguments passed to the function
alue if SETQ is involved

¤
   ) 
esv '\15))
ted pair with the function name and a symbol.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
broutines, such as CONS, accept arguments in
using the stack.  Generate code
ed as an inline routine, this does not apply.
ed because someday it will be needed for

       THEN
T '×1,2,× O '×(11)×)
ts from ÿ
 O '×(,11)×)
stack.×)
;;;;;;;;;;;;;;;;;;;;;;;ÿ

e
 (gensym) 'location)))
s of " ,(cdr b)))
LL hacking.
"2,2"           "Load zero argument count")
"2," ,(* (- n 5) 4))
ment count * 4")
 ,(* n 4))     "Load argument count * 4")
plement this some day...


   ÿ
15"                      `("Call " ,(car b)))
 value will be in register 15.
onal base registerÿ
 
nces to arguments as the target are resolved correctly.
q argbase (cdr argbase))   ; Pop ÿ
r pdmax))       ; Pop stack height
reg into SETQ variables if any.
register if any.
  (zcgrels '\14)        ; Free the register.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
e it for future reference.
 '\2))
;;;;;;
ÉÉ
******
 *

;*                                                                     *
********************************************************************
*****************ÿ
                                                                *
"                                                          *
                                ÿ
****************************************************
*****************************************************
                                               ÿ
                                              *
                                          *
CGSTVRS.                              *
                                    *
*********************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ilmacs))
;;;;;;;;
 function to make a closure out of
 if SETQ is ÿ
     r   ; a register to be used
 associated with the subr
  (desetq (b v s) a)
his register.
 '\14)
s a dotted pair with the function name andÿ
ar b) (car name))
                           c)
b) 'location)

      endif
t address of CONS.")
t lexical ALIST.")
e a closure.")
                `("Closure of " ,(string-substr (car b) 1 24)))
s point+
s nilÿ
  ; Set target to register if any.
gister.
'\14)        ; Free  the register.

<
* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
        All rights reserved.                                        *
                                                                *
*************************************************************
;;;;;;;;;;ÿ
 #.(zil-source-member zilmacs))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CSECT is actually (cdr — name).
genout nil "DS" `("(*-(" ,csect "+" ,offset "))X")" Check estimate")
ut nil "DS" `("((" ,csect "+" ,offset ")-*)X")" of code length")

*************************
                    *
ratory Inc.     *
              *
          *
*******
*********
   *
.
;**********************************************************************
;

* Created 04/25/88.                                                   *
                                                                  *
88 - Support for determination of superfluous initializations *
 ÿ
ew fields in the contour that are used to detect cases  *
variable unconditionally being set before it is     *
renced.  This isÿ
itialization-hacking scheme used in ZCCPROG.  *
res a new P-code form, CSETNIL, and a new *
le, ZCGCSNIL.                  ÿ
                                    *
*********************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ilmacs))
;;;;;;;;
pair describing the conditionally set variable
       s   ; the usual
(when debug
 b)))
before SETQ
L

***********************************************
                                          *
rles Stark Draper Laboratory Inc.     *
                                    *
                                *
*****************************
************************************
                              *
                         *
                      *
******************
************************
        ÿ
                 *
             *
         *
       *
****
;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
f  (a) ;
an item to receive the value if SETQ is involved
f the value to be set
location label for the V-con associated with the subr
 ) 
 always in this register.
    (zcgresv '\14)
 and a symbol.
   ÿ
 
"No SUBR for ZILXDEF!" b)))
address of " ,(cdrÿ
(cdr sub) 'location)
 ZILXDEF.")
                                 ÿ


;
zcgstvrs r v s t)    ; Store reg into SETQ varÿ
rg r s)        ; Set target to register if any.
; Free the register.
    (zcgrels '\2)         ; Free the register.
 ; Free the register.
*****************************************************************
                                                            *
right 1989 The Charles Stark Draper Laboratory Inc.     *
ghts reserved.                                        *
                                                  *
***********************************************
code for ENDLAM, which marks the end of an inline
function position of a form.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
)
;;;
NSYM used to hold info about the lambda
e arglist

etq (name parms v s) a)
 
saved (cdr fluid-asaved))
       (setq pdmax (cdr pdmax))     ; Pop stack height.
(cdr argbase)) ; Pop argument base stack.
¦
**********
     *
 *

;***********************************************************************

 for the emission of
es of output
;;

put via ZCGENOUT.
;;;;;;;;;;;;;;;;;;;;;;;;
.
Î

Ñ
  (* 8 (quotient (+ codelen 7) 8)))
	
bí ug
)
c operands)

*****************
            *
nc.     *
      *
  *
	
*
;* GEN-END                                                            *
                                           ÿ
***************************************************************
*********************************************************************
                                                          ÿ
 activity:                                                    *
                                                          *
ed setting of "uninterned" bit for symbols.           *
                                                    *
*************************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
-member ÿ
;;;;;;;;;;;;;;;;;;;
 zzzatoms zzzlists)
me) 'zzzsubrs)
sts (get (cdr name) 'zzzlists))
s in register 15.")
e exiting.
r fluid-asaved) 'falist)
 in ZCGEND"
 `("14," ,(cdar fluid-asaved) "(,11)")
  "Load stacked lexical ALIST ptr.")
       "Restore lexical ALIST.")
d)) ; Who cares?
(eq (caar special-asaved) 'salist)
not SALIST in ZCGEND"
it 4 () "L"  `("14," ,(cdar special-asaved) "(,11)")
   ÿ
 "14,ZLCSALST"       "Restore special ALIST.")
(cdr special-asaved)) ; Who cares?
            "Reset+
+ pdbas 8) "(,1)ÿ
eturn address.")
                                 "Restore stack and base registers.")
mit 2 ()      "BR"    "14"     ÿ
t 0 ()      "SPACE" 3                                      nil)
zzzstksz "EQU"  stackmax        "Maximum stack size used.")
    "DROP"  12                                ÿ
-baseregs)
  nil)
brs)
ers.")
            then
                 "DC"
                     `("Address of " ,(substr (car x) 1 24)))
se ; External function call - check name.
   ((a (car x))
    (unlessÿ
unction name \"")
(princ "\"; \"")
     (princ "\" substituteÿ
       (zcgemit 4 (get (cdr x) 'location)
                       `("V(" ,(cdr x) ")")
 point for " ,(substr (car x) 1 19)))

prop (cdr x) 'location))
rs "E") "EQU" "*"    "End of subroutines.")
en
 (zcgemit 0  `(,zzzsubrs "E") "EQU" "*"    "End of subroutines.")
 )

 else
ists "S") "DS" "0A" "Object pointers.")
ointerÿ
hose which
st
x in (cdr lists)
gend-output-offset x main))
 used by ZILSINT to do
 Note that symbols which are unbound  lexical variables are placedÿç
ÑÑ
; variables may analyze them properly.
op for x in (cdr numatoms) do (zcgend-output-offset x t))
 (ÿ
dr alfatoms)
car x) (cdr fluid-unbounds))

atoms."))
egisters.
(if zzzlists
   (dolist (x (cdr alllists))

s."))
s
                     ;           these are relocated by ZILSINT
p for x in (cdr fluid-unbounds) do(zcgend-output-offset x nil)ÿ
or x in (cdr atoms)
             do (zcgend-output-offset x nil))
gemit 0 `(,zzzlists "E") "EQU" "*"  "End of pointers."))
o-base-stuff) ; End ZCGEMIT's, adjust for base registers.
 )
n
(zcgend-gen-ÿ
nerate constant bignums.
 x) (cdr x)))
	
    (cdr numatoms))
 in (cdr alfatoms)
nd-gen-symbol (car x) (cdr x)))
nd DEFUN ZCGEND
***************
 (get (car name) 'basereg)))
  (when (> b 1)
              (when (> b 2)
6 nil)
           (zcgenout nil "DROP" 5 nil)
more-baseregs ()
***********************************************
uff ()
s to ÿ
ty
de the "DS 0D" above,
ode size          Nuÿ
             1  (12)
8193  - 12288                    3  (12,7,6)
      4  (12,7,6,5)
mpile the function.
 4096 we are
ns
;;; inserted into the code list by ZCGBASE.  Then...
is between 0 and 4096, no change required.
nd 8192,
‡
 switch to "LM 6,7,xxx" and have 2 adcons and a brancharound.
e is between 8193 and 12288,
ÿ
se we have to
f code size is between 12289 and 16384,
M 5,7,xxx", 3 aÿ
wn it.  Can't compile.
or x in codelist count (null x)))
    (lbl1)

   (incf codelen (* 4 (1+ n)))
q baseno 3)
88)
etq baseno 3)
8)
(when (> codelen 16384)
en 16384)
when (> codelen 16384)
 that we have determined the number of base registers,
tputting the code in CODELIST, generate
ters.
gensym))
 ((adcons
 "+8192,"
    (4 (string-append "A(… " f "+12288,"
   f "+8192,"ÿç
96)"))
bl2 "DS" "0H"   nil)
eno
gister."))
rs."))
))
            (car name)))))
 (cadr basecode)
aseno
 nil "USING " `(,f "+4096,7,6") nil))
6,7,6,5") nil))

aca c (case baseno
                     (3 `(nil "DROP" "7,6" nil))
`(nil "DROP" "7,6,5" nil)))))

))
g the
check that we are compuÿ
    "SPACE"  1     nil)
ted code offset.")

 nil      "DS"     "0D"  nil)
	
****
s.
found embedded in list of lists"))
aym))
t (cdr l) "DC" `(,.lcar ",A(0)") nil)
r l))
 dotted pair

+4)") nil)
 endif
e) (ncons "A(0)"))ÿ

(atom e)    (assoc    e numatoms))
e alllists))
ym ")"))
*********************
fixnump x1)
"DC" `("YL1(##FIXNUM),AL3(0),F'" ,x1 "'")     ÿ
È
##SFLOAT),AL3(0),F'" ,(mkfixnum x1) "'")
atp x1)
"Flonum " ,x1))
l)

*********************
 numlist biglen)
c x1)
numlist)))
                      `("Bignum " ,x1)
num"))
l)
 "'") "Bignum digit")



put-offset (x mainp)
"DC"
 ")")
           (cond
         ((stringp (car x))      "Offset of string")
(car x))      `("Offset of fixnum " ,(car x)))
      "Offset of bignum")
onum " ,(car x)))
      ÿ
   `("Offset of symbol " ,(car x)))
et of symbol...")))
*********************ÿ
tine generates constant symbols.
 to this routine.
'quoted)))
   nil))

YL1(##SYMBOL),7X'00'"                         nil)
 if we ARE generating the hash code of theÿç
the module at compile time.
 hash code?
t.
rned"
 ; else "uninterned" (e.g. a gensym)
FWGSYM)")
 x1) "'")        "Symbol hash code")
g-length (symbol-name x1)))
**************************************
ant strÿ
	
ild-string x2 (get x2 'quoted) (string-length x1)))
**********************ÿ
tine builds string text.  If the string text
mbler statement, a special routine
s an exception to the rule
d assembler code.
  (setq l (length q))
ing to fullword")
ing type bits")
ng length")
string)")))
)
p.
t-new-card
  ÿ
d 
        (princ (car q) 'code)
))
      (princ "'" 'code)      ; End this piece of the string
'code)         ; Go to next card
r (eq (car q) '×'×) (eq (car q) ÿ
 (car q) 'code)     ; Print it.
 must be another ' or &.

 name.

*****************
            *
nc.     *
      *
  *
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
include #.(zil-source-member zilmacs))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
perands comments)
bel))
ttab 15 'code)

est denoting continuation.
"*" 'code)
princ-list comments))
 endif

c x 'cod e)))))
****************************************************
                                               *
e Charles Stark Draper Laboratory Inc.     *
.                                        *
                                     *
**********************************
************************************
                              *
                         *
                      *
******************
;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;ÿ
fun zcgerror (a)
nc msg)
***" `("Error: " ,msg " - " É ,dta) nil)

****************
           *
c.     *
     *
 *


* ZCGETAG - processes the end of a TAGBODY.                          *
                                          ÿ
**************************************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#.(zil-source-member zilmacs))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
tually, this does absolutely nothing.


 ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
       All rights reserved.                                        *
                                                               *
************************************************************
*********ÿ
                                                        *
rates code that finishes up UNWIND-PROTECT forms.  *
                        ÿ
********************************************
**************************************************
                                       ÿ
                                           *
                                       *
TVRS.                              *
URN removed.                     *
e for CONS" compiler bug.    *
                         *
************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


 which UNWIND-PROTECT cleanup forms return
e value if SETQ is involved

egister to hold the return value from the protected form
(desetq (l2 v s) a)

ax))     ; Current stack height is frame.
15 if target is T.
	
")

(zcgemit 0 l2  "DS"  "0H"          "Continue if not called by THÿ
cgemit 4 () "L"  `(,r "," ,(+ c 32) "(,11)")
      "Load value from protected form.")
 register r gets released

les if any.
 )
****************************************
                                   *
ark Draper Laboratory Inc.     *
                             *
                         *
**********************
************************
                  *
             *
          *
     *
*
;ÿ
ZCGGTPRM (GEN-GETPARM)                                             *
LOC (GEN-GETLOCAL)                                            *
GEN-GETSMALL)   ÿ
                                                      *
R (GEN-GETVAR) still needs to be a separate      *
olves more complex code generatÿ
                                         *
*************************************
*******************************************
                                        *
                                    *
                                *
                              *
                          *
***********************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


 generator ÿ
nvolved
gister to be used


     ) 
target.

n s              ; If for effect only, skip the rest.
       ; If being used as an argument to a
nction, just store the NIL or T
Otherwise, get a different
the NIL or T register
          (setq r
      (eq (car s) 'arg))
tbst s)))
          (zcgload r b)      ; then load register from NIL or T.
…
  )
etq r (zcggtbst s)) ; Get a register to hold the result.
b)         ; Load aV ddress of object into register.
 nil)  ; Store reg into SETQ variables if any.
 ; Set target, if any, to register.

*****************************************
                                    *
tark Draper Laboratory Inc.     *
                              *
                          *
***********************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
source-member zilmacs))
;;;;;;;;;;;;;;;;;;;;;;;
ister number

" ,o "(,11)") `("Load argument " ,n))))
<
*                                                                     *
L (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
    All rights reserved.                                        *
                                                            *
*********************************************************
ST-REGÿ
********************
               *
           *
         *
CAR. *
 *

;***********************************************************************

	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 `(cadr ,x))
 
           (valuesp (and (eq inline-function 'values)
               (not (eql (third nextpcode) 1)))))
-ÿ
car s) 'arg)
e)
                ÿ
ar s) 'arg)
                                     (eq (cadr (arg-number s)) zdef)))
 (r)
inline-function
           zdefp

ons)
   (or (eql (arg-number s) 2) (zcgresv '\2)))

        (or
r
          (eq (probably-use15p (fifth nextpcode)) t))
  (and (eq inline-function 'values)
ly-use15p (fifth nextpcode)) t))
assq)
            (or (eq (car inline-function) 'rplaca)
      (eqÿ
probably-use15p (fifth nextpcode)) t))
)


       (setq lastarg r))
grels '\0)
         (or (eql (arg-number s) 1) (zcgrels '\1))
rg-number s) 2) (zcgrels '\2)))
values))
 


(if (consp s) (car s))
se15p (get (cadr s) 'rettarg)))
      ((throw)

*******************************
                          *
r Laboratory Inc.     *
                    *
                *
*************
ter.
;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;¼ 
reg ()

	±
************************
                   *
atory Inc.     *
             *
         *
******
********
  *

**********************************************************************

;*                                                               ÿ
 Change activity:                                                    *
                                                                 *
8 - More arguments to ZCGSTVRS.                              *
ÿ
********************************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.(zil-source-meÿ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 of a free variable from "ALIST"
 the code generator function
SETQ is involved
p  ; the atom pair representing the variable if SPECIAL
m pair representing the variable if FLUID
senting the variable
offset to be generated
 ; if subroutine ZILVSYM is needed
nerated for comments
d variable to get.
side effects, so do nothing if no V/S
nds))
 (zerror
id"
 - free vaÿ
register, preferably \15 if target is T.

special)
 (princ " variable ")
(string-length (car a)) 23) (cdr a) (car a)))
" ,o "(,11)")   "Get pointer to alist cell.")
R(,14)")        `("Get value of " ,varÿ
    ; If variable declared SPECIAL...
y exist, create it.
odq subrs (setq sub (zilcosym 'zilvsym 'subrs))))
 `(,r ",ZLCUNBND")     "If variable not bound")
lbl (gensym)) "then...")
ion)
<
  (zcgemit 4 () "L" `("15," ,(or (get (cdr sub) 'location)
                (putprop (cdr sub) (gensym) 'location)
   ÿ
1," ,(car pdmax) "(,11)") " get stack pointer")
5"  " call ZILVSYM")
sters if necessaryÿ
                                     " store binding cell on stack")
mit 4 () "L"   `(,r ",##CDR(,15)")      `("Get value of " ,var))
0 lbl "DS"  "0H"                 ]                        nil)
„
g r s)        ; Set target to register if any.

***************
          *
.     *
    *
*

de for ASSQ.
 principle
ot
ally, R3 is selected by this routine, based on the "s" argument.
his function must release registers R1 and R2, and return R3.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ÿ
include #.(zil-source-member zilmacs))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ux r3
                 (lb (gensym))
m))
zcgrels r2)
gemit ÿ
3 (zcggtbst s))
mit 2 () "LR" `("15," ,r2)                            com)
lb "CR"  "15,10"     ÿ
"14,15,##CAR(15)"                       com)
                             com)
)                 com)
         com)
m)
emit 2 lf "LR"  `(,r3 ",10")                       ›      com)
 "DS"  "0H"                                    com)
(when (eq r1 '\15) (zcgrels '\0))
››
******
 *

;*                                                                     *
********************************************************************

MQ.
e
ister 0 (although R1 could conceÿ
elease register R1, and return R2.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
zilmacs))
;;;;;;;;;;;
                                  (lc (gensym)))
;
ranch directly.  Otherwise, generate code to return the sublist
the value.
st like
 
 GOTO
 (car s) 'gonotnil))
   ;; (null ÿ
) 'progexit))     ;; ???

 (case g
notnil lo)
))
n1 s) (terpri)
c " is: ")
    (terpri)
 (consp x)
 list of ") (prin1 x) (princ " is: ")
prin1 (plist x))
(ZCGSGOTO S)=") (prin1 `(,g ,lo)) (terpri)
of ") (prin1 lo) (princ " is: ")
t lo))
    (zcgemit 4 () "B" lc                                     com)
t 4 lb +
E" lxÿ
,##CDR(," ,r2 ")")              com)
                     com)
          com)
                            com)
                 com)
 be used.
   )
x (gensym)))
)
(zcgemit 4 () "BE" lx                                    com)
() "L" `(,r2 ",##CDR(," ,r2 ")")              com)
r2 ",10")                          com)
                          com)
               com)

********************
               *
y Inc.     *
         *
     *
**
code requests.  These look
IN, except that
be used as return register is returned as the
;

Change activity:                                             ÿ
                                                                  *
88 - Support for fast inline ASSQ and MEMQ.                   *
                                                          *
*********************************************************
g are currently supported:
) where n is a fixnum.
 , n fixnumÿ
.
INLINE (EQ n) 1 v s)     - compiles (EQ arg1 n), n constant.
) 1 v s)    - compiles (EQÿ
  - compiles (CONS arg1 n), n simple.
(RPLACA arg1 n), n simple.
1 n), n simple.
ple.
 
 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 v s c)
ile
;      v   ; an item to receive the value if SETQ is involved
he target of the value to be set
e


             (null lastarg))
ull LASTARG problem.
(or (eql n 1) (go wÿ
eql n 1) (go wna-error)) (zcgineql    q v s c))
) (go wna-error)) (zcgincons   q v s c))
na-error)) (zcginrplaca q v s c))
ror)) (zcginrplacd q v s c))
zcginassq   q v s c))
mq   q v s c))
q v s c))
))
        (vset   (or (eql n 2) (go wna-error)) (zcginvset   q v sÿ
   (t      (zerror "No inline code generator for" b))

ng number of inline args" 'code) ; Force bad assembly

======================================================
e generator for (EQ arg1 n)
 NIL)         ÿ
 to T
    - quick compare to constant object represented
the dotted pair (xxx . yyy)
      &aux
    ((nil t) "CR")
         (ilen      (case q
Ë
 (case q
                ((t)       "8")
"ZLCUNBND")
                (onam      (cond
        "#<UNBOUND>")
)
                 (t                      (cdr q))))
 (zcgemit ilen () opcode `(,lastarg "," ,comparand)
         ÿ
nline code for EQ")
========================

mpare to small fixnum n
num or flonum
yy)
                   CLC 0(8,R1),#SFT+8 
  --> L   R1,X
0(8,R1),0(R14)
ump q)
,lastarg   ; ((
,(* q 8))
 ,q))
                                            `("Get number " ,(car q)))
gemit 6 () "CLC" `("0(8," ,lastarg "),0(14)")
                   "Inline code for EQL")
 s "Inlinÿ
================================
arg1 n)
1,X

                  L    R2,G12345 (address of Y)
ZLCCONS
 s c &aux r)
 () "!" "Register 1 not available for CONS" "ZCGINEXT")
1 not available to code generator for CONS")
Ö
  (warn "Register 2 not available to code generator for CONS")
 (eq lastarg (zcgresv '\1))
nline code for CONS"))
S.")
 (zcgemit 2 () "BALR" "14,15"   "Call ZILCONS.")
 (zcÿ
=============================================
or for (RPLACA arg1 n) and (RPLACD arg1 n)

AR(,R1)
,Y
a (q v s c)
 v s c)
carp &aux r)
 reg 10
(setq r (zcggtreg)) ; Otherwise, get any register
t arg2 into register
f carp ",##CAR(," #×)×# ",##CDR(,") ,lastarg ")")
 for " ,(if carp "RPLACA" "RPLACD")))


q) are:
xx . yyy)) - quick compare to constant object represented
    by the dotted pair (xxx . yyy)
code generation.
cginassq (q ÿ
or arg 2.
).
ad fast arg2.
"Load special ALIST."))
arg2" q)))
 reg.
============
e ZCGIMEMQ module for details of code generation.
 1 to MEMQ.
 q) (zerror "Bad thing passed to MEMQ as fast arg2" q))
etq r2 (zcggtbst s)) ; Set arg2/return reg (can't use register 0).
'\0)
 "Inline code for MEMQ") ; Returns return reg.
===================================================
enerator for (ARG n)
 q)
 '\2)
         c)
   (zcgemit 4 () "SRA"ÿ
 () "BCTR"  "2,0"                             c)
,ZLCCONS Cons"                 c)
                c)
   c)
  if (fixnump q)
  "14,0(,11)"                        c)
* q 4) "(,14)")         c)
q))
===============================
G
emit 4 () "L"    "14,0(,11)"                        c)
`(,r "," ,(* q 4) "(,14)")         c)
==+
· nerator for VREF
 r)
r ",##VECDAT+" ,(* q 4) "(," ,lastarg ")") c)
======================================ÿ
 code generator for VSET
setq r lastarg)

 ,(* q 4) "(," ,r1 ")") c)

                                                                    *
(c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
  All rights reserved.                                        *
                                                          *
*******************************************************
****ÿ
                                                   *
                                                               *
*******************ÿ
*******************************************************************
                                                              *
ivity:                            ÿ
                                                        *
rt for inline ASSQ and MEMQ.                        *
ments to ZCGSTVRS.                              *ÿ
 VALUES.                                      *
RP (CHARACTERP).                          *
                                      *
*************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 zilmacs))

.
 argcount)

            (,fun b v s com))
	
nction to be invoked inline
 the function
Ë
ister to be used


" inline-code form

dr)        (inline-call 1 zcggicdr))
ll 1 zcggizcar))

b 'plist)      (inline-call 1 zcggiplist))
ine-call 1 zcggifunfun))
nenv))
 ( (eq ÿ
st)   (inline-call 2 zcggistplst))
 2 zcggicons))
     ( (eq b 'atom)   ÿ
erp)    (inline-call 1 zcgginump))
 1 zcggiintp))
       ( (eq b 'floatp)     (inline-cÿ
dep)      (inline-call 1 zcggicodep))
all 1 zcggivecp))
igp

q b 'zerop   )   (inline-call 1 zcggizerop      ))
)   (inline-call 1 zcggiminusp     ))
-call 1 zcggievenp      ))
oddp       ))
   ))
  ÿ
 (eq b 'charp   )   (inline-call 1 zcggicharp      ))
vref)       (inline-call 2 zcggivref))
call 3 zcggivset)ÿ

(eq b 'values)     (zcggivalues b n v s com))
    (inline-call 0 zcggioblist))ÿ
 0 zcggisalist))

b 'rmnil)      (inline-call 0 zcggirmnil))
nline-call 1 zcggipbind))
tpbnd))
    ( (eq b 'setarg)     (inline-call 2 zcggisetarg))
tify)    (inline-call 1 zcggilistify))
ode generator for" b))
to be done before ZCGSTTRG, so that
 are resolved correctly.
p argument base stack
t
       (setq+
     (cond 
umes that no inline forms return
d change, you know what
); Store reg into SETQ variables if any.
et target to register if any.
targ)
 (when lastarg (zcgrels lastarg))
number of inline args" 'code) ; Force bad assembly
urn)
rning:")
 ")

de to pass argument to function.")
mpilerÿ

eturn)
ist . ,z))

o zcggizcar   (&rest z) `(zcggizcar/zcdr 'zcar . ,z))
&rest z) `(zcggizcar/zcdr 'zcdr . ,zÿ
ggizcar/zcdr 'cdr . ,z))
efun zcggicar (b v s com &aux r)
m))
t 4 () "BE" "*+8"                   com)  ; return self.
         "L"
r
zcar/zcdr (f b v s com &aux r)

#CAR(," ",##CDR(,") ,lastarg ")")
Iÿ
 com &aux r)
)
ist ",##PLIST(,"ÿ
Í
                        ; (
com)

(&rest z) `(zcggirpl nil . ,z))

tbst s))
gemit 4 ()
##CDR(,") ,r ")")
;
m &aux r)
 r (zcggtbst s))

 ")")
e code generator for SETPBIND
 (zcgresv '\0) ; Cannot use register 0 for CAR/CDR/etc.
))
4 ()
        com)
tor for FUNFUN/FUNENV
. ,z))
zcggifunref (offset b v s com &aux r)
bst s))
 ,offset "(," ,lastarg ")")
 code generator for OBLIST
etq r (zcggtbst s))

&aux r)

nbound (b v s com &aux r)
 ",ZLCUNBND") com)
(defun zcggirmnil (b v s com &aux r)
() "ÿ
ALIST - suppressed
(zcggtbst s))

aux r)
r
 zcggisetfal (b v s com &aux r)
" `(,r ",ZLCFALST") com)

zcgavail '\1)
ONS")

code generator for CONS")
 for CONS" "ZCGINLIN")
       (setq lastarg '\2)
zcggtarg (zcgresv '\1) 1) ; Pick up argument 1
 '\2))
mit 4 () "L" "15,ZLCCONS" com)
tq r (zcgresv '\15))
Inline code generator for ASSQ

etq r1 (zcggtreg))   ; Get arg1 register (can be anything at all)
r1 1)        ; Pick up stacked argument 1

r1 r2)
‡
gtarg r1 1)        ; Pick up stacked ÿ

x r)
emit 2 () "CR" `(,r "," ,lastarg) com)
e) v s com)
om (b v s com)
  (zcgipred '(bo bno) v s com)
	
rg "),##ATOM") com)
 generator for NUMBERP
CLÿ

 s com)
red '(bo bno) v sÿ

FLONUM") com)
ator for CODEP
("##TYPE(" ,lastarg "),##CODE") com)

zcgemit 4 () "TM" `("##TYPE(" ,lastarg "),##VECÿ
) v s com)
;
                    ,lastarg
              ,(cond
)
              ((eq b 'sfloatp)  "##SFLOAT")
q b 'dfloatp)  "##DFLOAT")
#BIGNUM")
                      ((eq b 'closurep) "##CLOSUR")
   ((eq b 'stringp)  "##STRING")
  "##VECTOÿ
                            ((eq b 'structp)  "##STRUCT")
                                              )) com)
 s com)
ith the
non-fixnum.  The code assumes that any argument is a
n this module are for a non-constant
ssumed to be a fixnum,
;;;

 is passed to the ZILXLFY routine as is.
om &aux r)
 (zcgrels '\0)
om)
mit 4 () "L"    "14,0(,11)"                          com)
   `(,r ",0(" ,r ",14)")                com)
rg (bÿ
rels '\0)
ls r1)
cgemit 4 () "SLA"  `ÿ
 "L"    "14,0(,11)"                          com)
",0(" ,r1 ",14)")               com)
 s com &aux r sub)
rror "Register 0 not available to code generator for LISTIFY"))
il '\1)
"))
       (zcgemit 2 () "LR" `("1," ,lastarg) com)
Y.
SUBR for ZILXLFY!")))
'location)
tion))
LA" `("0," ,(car argbase) "(,11)") com)
ÿ
 registers if necessary.
cgrels '\1)
 with the


; vector.  The cases in this module are for a non-constant
, which is assumed to be a fixnum, since
herwise.

 s com &aux r r1 r2)
inter to vector
cgrels '\0)

 (zcgemit 4 () "L"   `(,r2 ",##CDR(," ,ÿ
LA" `(,r2 ",2") com)
 com)
et (b v s com &aux r r1 r2)
q r1 (zcggtbst s)) ; Arg 1 - pointer to vector
 2 - pointer to index
t 1
 r2)
"SLA" `(,r2 ",2") com)
") com)
n zcÿ
            ; If (VALUES oneform)
 then
      (zilcomvp v sÿ
(zcgemit 2 () "LR" "15,15" com))  ; returned, suppress them.
 (t
(zcgresv '\2)
) "LA"  `("1," ,(car argbase) "(,11)") com)
it 2 () "XR" "2,2"       com)
  )
"0,0"        com)
ase name nil)  ;  Reload additional base register if necessary.
els '\0)
))
7,#reg),#SFT0 <-- YL1(##FIXNUM),AL3(0),AL3(0)
             BNE false


 assumption that it "is an error" for the argument to be
e code assumes+
work for fixÿ
For EVENP and ODDP, it "is an error" for the argument to
 integer.  Caveat compilator.
gle instruction like
ound test"
	
           BE  true
p (b v s com)
(zcgipred '(be bne) v s com)
P
                BNO false
mit 4 () "TM" `("4(" ,lastarg "),X'80'") com)
	
  7(#reg),X'01'

'01'") com)
neratorÿ
  true
  (zcgemit 4 () "TM" `("7(" ,lastarg "),X'01'") com)
s com)

          BE  true
 BNZ false
  #reg,10

gilistp (b v s com)
red `(bz bnz be gonotnil
"),##ATOM") ,com))
ator for PLUSP
  false

'80'
  ÿ
iplusp (b v s com)
(zcgipred `(bne be bo gonil
 "),#SFT0+1") ,coÿ
====================================================
-reg-from (inreg s com &aux outreg)
q outreg inreg))
 outreg (if s (zcggtbst s) (zc ggtreg)))h{
Ì

************************************
                               *
Draper Laboratory Inc.     *
                         *
                     *
******************
ion, formerly part of ZCGINLIN, has been made a separate
 it can be called from ZCGINEXT as well.
hich contains the result value of the
g compiled is for value.
ranch only.
o symbols representing the op codes
t of a comparison operation,
on TRUE and the CADR
            -  the usual meaning of the "V" argument.
e usual meanÿ
 of the assembler instruction.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
acs))
;;;;;;;
rg)

 (gensym)))
-out-logic branch-list) 'gonotnil)
         (zcgemit 4 () (cc-out-op branch-list) (or lt lf)ÿ
       (apply #'zcgemit (cc-emit-code branch-list))
 () (cc-false-op branch-list) lf                     com)
"LR" `(,r ",8    T")                             com)
" lx                                           com)
(,r ",10   NIL")                           com)
                                       com)

***********************************
                              *
raper Laboratory Inc.     *
                        *
                    *
*****************
code for the P-code "KEY" form.
rs> <funname> <aoksym> NIL NIL)
symbol.
 function FOO with lambda list

 <suppliedp3>)
;
f-key2(,11)
,offset-of-restarg(,11)
           ÿ
   CR   3,10
)
È
È

2,0
(,11)
passed but not in lambda list
ok because of allow-other
fset-of-key1(,11)
t-of-key1(,11)
          C    13,offset-of-key2(,11)
          ST   0,offset-of-key2(,11)
-3     DS   0H
  label-loop
abel-lÿ
L    15,ZLCKERR
 list
 processed by the SETÿ
 in the P-code.
;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+
cro chop (&rest args)
·
 a)  ; "V" and "S" not used.

 (label-error  (gensym))
cgemit 4 () "ST" `("13," ,(get (cdr k) 'offset) "(,11)")
 (chop "Set unbound " (car k)))
 label-loop "DS" "0H" nil)
ist.")
1)"   "2=keyword, 3=rest of list.")

 keyword value.")
st.")
eylabel))
cdr ks) 'location)
„
t 4 () "BE" kl "then go to seÿ
 'allow-other-keys-p)
 other keys allowed.")
oksym) 'location)
m) 'location)))
THER-KEYS")
 (zcgemit 4 () "BE" label-loop "then ignore bad keyword.")
restarg)
zcgemit 2 () "BALR" "14,15" "Call ZILKERR to handle key error.")
4 () "B" label-loop "If other keys allowed, continue.")
	
zcgemit 0 (get (cdr k) 'keylabel) "DS" "0H"
 " (get (cdr k) 'keyword)))
ord valueÿ
 value.")
 k)))

(zcgemit 2 ()         "XR" "0,0" "Show bad keyword list error.")
()         "L"  "15,ZLCKERR" "Get address of ZILKERR.")
BALR"  "14,15" "Call ZILKERR to handle / key error.")
 "DS" "0H" "End of keyword processing.")

*********
    *
*
<
***********************************************************************
;*******************ÿ
                                                                   *
ABEL                                                          *
                                   ÿ
*******************************************************
generates code for labels.
***************************************
                                    *
                                *
                            *
.                         *
                      *
                  *
ÿ
*************
;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;ÿ
fun zcglabel (a) ; Label (Gxxxxx)
on
s   ; the target of the value ÿ
ed for fall-through
be restored
red
    c   ; indicates that this is a CATCH/THROW label
f the original GO tag if any

allthru)
ist)

 A null label is used to create an explicit goto.
; Generate a label if it is non-NIL and one of the following is true:
TQ will be done here (V is non-NIL)
L)
erenced ÿ
 c)
      (when b
when tag
))))
o on.
cked ALIST pointer or two
   (zcgemit 4 () "L" `("14," ,yf "(,11)") "Load stacked alist pointer.")
zcgemit 4 () "ST" "14,ZLCFALST"            "Restore lexical alist.")
 (when ys
nter.")
.")
unstacked.
ditionally, extra base registers must be restored if necessary.
c
xs (car special-asaved))
   ÿ
 v s)
EL found non-CATCH thing on SPECIAL-ASAVED"
         (unless (ÿ
ist b) v s)
GLABEL found non-CATCH thing on FLUID-ASAVED"
           (setq special-asaved (ÿ
id-asaved (cdr fluid-asaved))
,(car pdmax) "(,11)")
us catch frame.")
 environment.")
 nil))
 ; Otherwise, pick a register and use it.
b 'register)) (zcggtreg)))
ables if any.
and z (zcgemit 0 z "DS" "0H" nil)) ; Gen fallthru label if any.
){
**********************************
                             *
aper Laboratory Inc.     *
                       *
                   *
****************
nerates the code to load the address of the object
e register indicated by R.
 object
  NIL  -  the atom NIL
num, being a small fixnum from the table
presenting a constant atom,
ly bound variable
rates code to load a small fixnum (i.e. a fixnum which
fixnum table").  A direct pointer into the
amples:

      LA  reg,#SFT+0*8
reg,#SFT+2*8
air is passed, the object represented
or a variable binding.
e the latter:
t doesn't have any of these properties, it must be a constant.
imilar code in ZCGGTLOC and ZCGSTATM, unless they've already
ified to call this routine.
 that no other registers
with the exception
ist of
For the above reason, unbound variables cannot be loaded by this
since the code sequence may involve execution of
r registers if the variable's binding
.
 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ond


) ,(* q 8))
um " ,q))
 o (zcgload-variable r q o)
q)))))))

                        (or (get (cdr q) 'position) (cdr q))
                (car q)))
               ((get (cdr q) 'lexprarg)
t LEXPR argument " ,m))

               (t
)))
 (if (alistboundp q)
 LEXPR stack pointer.")
alist cell.")ÿ
   c)
inter.")

it 4 () "L" `("14," ,o "(,11)")
nter to alist cell.")
         c)
           c)
                       &aux
                   ((consp   (car q)) "Get address of listÿ
                 ((symbolp (car q)) "Get symbol ")
    ((stringp (car q)) "Get string ")
 (car q)) "Get fixnum ")
Get bignum ")

                  ))
        —                             (< (flatc (car q)) 15))
                 `(,c1 ,(car q))
                    )

**********************
                 *
ory Inc.     *
           *
       *
****
******
*
;*                                              ÿ
This routine generates the code sequence required to prime a       *
al form that asks for multiple values.  It does this by       *
 stack location(s) to the place(s) where the values      *
ned, and initializing the bottommost to the contents  *
er (register 11) so that if nobody returns       *
ituation can be detected.                   *
                                         *
*************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
acs))
;;;;;;;
              ; Arg is # of stack slots.
        ; Current stack top.ÿ 
New stack top.
t high-water-mark.
le value slot.")
**************************************************************
                                                         *
ht 1989 The Charles Stark Draper Laboratory Inc.     *
s reserved.                                        *
                                               *
********************************************
 This subroutine generates code for the P-code "OPTIONAL" form.
ode merely checks an &optional arg to see if it has been
o, branches to the specified label (the code
follows ÿ
*******************************************************
                                                  *
                       ÿ
                                            *
 check as ZCGSTVRS does to see if the   *
 question, as well as any           *
ariable, is never referenced.     *
e is generated at all for     *
an initialization form.   *
                        *
*********************
;;;;;;;;;;;;;;;;;;;;;;;;;;
 
 
estion
o bÿ
       s   ; a SUPPLIED-P variable associated with the &optional var
 
r (not (memq (get ÿ
eeded b)
             (zcgopt-setq-needed s)))
†

                 `("If caller supplied " ,m))
            "then bypass optional init.")
un zcgopt-setq-needed (v)
init)))
**************************************
                                 *
k Draper Laboratory Inc.     *
                           *
                       *
********************
**********************
                *
                               *
*****************************
e binding environments on tail
ment where locals are


     in effect for the tail-recurring function.  Therefore, we
keep the alistÿ
 reestablishes the binding environment from
of execution.  To do this, a new
 to hold the alternate
ecursion.
nto
      "special" (i.e. they occur as free varÿ
iables around, you can't just come back reusing the same
 Where you lose with this strategy is when the
NARG (compiled lexical closure).  Y'see,
e wrong binding environment to be
function; even though the
 BINDINGS were not.
Therefore, we
of
      the alist at the point of execution, even when the only
ial" variÿ
NP" label, as described above, for this.
***************************************************
                        ÿ
                                            *
                                        *
STVRS.                              *
                                  *
*********************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
macs))
;;;;;;;;
  ; not used (should be the name of the function)
 arguments passed to the function

sed
frame pointer
 (ÿ
dr a)      )
done out of an environment which
lternate" branch-ÿ
cted by checking the stacks of
null entries, INCLUDING
es the alternate
ck of function arguments will be
-back, which involves
ment values
„
 the alist cell rather than the stack slot.
nt of lists of saved ALIST pointers.
ial-asaved
                   (loop for x in fluid-asaved
is (and x (eq (car x) 'falist)))))
g)
XPR's!")
r (get (cdr k) 'aux) (get (cdr k) 'owned))
 'position))ÿ
        ; Set input parameter "n"
        (loop for q in parms
get (cdr q) 'aux) (get (cdrÿ
)
",11)," ,(car argbase) "(11)")
function args to values.")

ither SPECIAL-ASAVED or FLUID-ASAVED;
oth for consistency.
         when (and x (eq (car x) 'catch))ÿç
 (setq cf (cdr x)))
f "(,11)") "Get previous catch frame.")
      "Restore catch environment.")

                 "Branch to implement tail recursion.")
k popping has to be done before ZCGSTTRG, so that
 as the target are resolved correctly.
gbase)) ; Pop argument base stack.
stack height.
rsion.é 
  (zcgrels r)           ; Free the register.
Ö¦Ö
******
 *

;*                                                                     *
********************************************************************
;;;;;;;;;;;;;;;;;ÿ
include #.(zil-source-member zilmacs))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
s a register, i.e. makes it avaiÿ
  (eq r '\10)
onal arg" need not be released.
  (if (zerop u)
gister " r)
ç
******************
             *
Inc.     *
       *
   *

;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
This reserves a register, i.e. makes it in uì se.
p r (1+ (get r 'usecount)) 'usecount)
rved
**********************************************
                                         *
les Stark Draper Laboratory Inc.     *
                                   *
                               *
****************************

gures out the ultimate label to branch to.  This is done by means
subsumption", in which (provided the V-target is nil)
 as follows:
NIL A ---> A: GOTO B           yields... GONIL B
       yields... GONIL B
L B
-> A: GONOTNIL B       yields... GONIL (GET B 'FALLTHRU)
 GONIL B       yields... GONOTNIL (GET B 'FALLTHRU)

TNIL B   does not yield GONOTNIL B
se a fallthrough to occur if the
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ÿ
(include #.(zil-source-member zilmacs))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
S is target of label, i.e. (GOxxx lll)
c g) s)            ; C = original GOTO/GONIL/GONOTNIL
       ; G = original target label
ve, should be (GOxxx lll)
g2) s2)         ; GOTO/GONIL/GONOTNIL of above
; target label of above

T ÿ
'vartarg)

e compatible, theÿ
((eq c c2)      (zcgsgoto s2)                                )
to)   s                                            )
t c (cadr (zcgsgoto (list c g2))t ))       )
(get g 'fallthru)
ru))) )
******************************************************
                                                 *
The Charles Stark Draper Laboratory Inc.     *
ed.                                        *
                                       *
************************************
This processes the (SETOPT ...) specification by storing the
 indicator (#13) into the argument stack.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ÿ
;;;;;;;;;;;;;;;;
      v   ; an item to receive the value if SETQ is involved
e target of theÿ
   ) 
specify a SETQ value!"))
NIL.

      )
 )
**************************************
                                 *
k Draper Laboratory Inc.     *
                           *
                       *
********************
 returned by function calls or evaluations.
*************************************************
                                            *
                                          *
                                      *
f into separately compiled        *

at caused erroneously       *
RN (AND P (GO L))).     *
              ÿ
-PROTECT.         *
initializing. *
e tag is  *
        *
    *
*
<
* 10/20/88 - Fix failure to release registers in THROW code gen.      *
                                                           ÿ
*****************************************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
include #.(zil-source-member zilmacs))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(cond
(eq s 't)      (set-t r)           ); Return with value in \15
    (zerrÿ
(s1 s2) s))
 arg cell on stack
nd store
me
 Test CC, branch on cond to label
rate list of multiple values
e bind of multiple values
or THROW
GSTTRG" s)))))))
****************
the caller. *
********
 `("15," ,r) "Set return value."))
*********************************************************
 value into the current UNWIND-PROTECT frame to be *
ution of the cleanup forms.                   *
hoÿ
***************************************
As part of the process of unstacking the UNWIND/PROTECT frame,
ment stack.
)
l (cdr xs) c))

(unless (and xf (eq (car xf) 'uwp) (eql (cdr xs) c))
TRG found non-UWP thing on FLUID-ASAVED" xf))
cial-asaved)
g NOP is purely for support of multiple values,
iple value support code that the value
ted by someone that is expecting
 "NOP" (get l1 'uwplabel) "(For multiple value support)")
) "ST" `(,r "," ,(+ c 32) "(,11)")
e return value in UWP frame.")
  "Start of cleanup forms.")
                                       "Get previous catch frame.")
t 4 () "ST" "14,ZLCCATCH"         "Restore catch environment.")
se name nil)ÿ
§
***********
      *
    *
*

* it may be a list.  For example:                                     *
                                                                  *
) - the old way, store value into argument 5 of a call fr+
                                                       ©      *ÿç


                                                                    *
rg (1 #.zdef))  - the new way, load register 1 with the arg.      *
                                                              *
***********************************************************
rg (r x)
desetq (n f) x)       ; (arg (n funcname))
; (arg n)
 'inline)
          (not (eql (caddr nextpcode) 1)))))
      (setq lastarg (if (eq r '\0) (zcggtreg) r)))


  (unless (eq r '\1)
t 4 () "L" `("1," ,r) "Load into register 1.")

 (car argbase)))
is argument.

   (if (> m stackmax)
mark accordingly.
)
e for fake FUNCALL args 1-4.
")

************************************************
frame and stores the value therein.       *
**************************************ÿ
he CATCH/THROW label.
here the CATCH frame will go
he CATCH frame
 frame goes here on stack.
st catch frame.
 (zcgemit 4 () "L"  "14,ZLCCATCH"       "Get active catch frame.")
zcgemit 4 () "ST" `("14," ,c "(,11)") "Store into catch frame.")
mit 4 () "ST" `(,r "," ,(+ c 24) "(,11)")
       "Store tag into catch frame.")
mit+
tÿ
4 () "STM" `("11,15," ,(+ c 4) "(11)")
        "Store into catch frame.")
    "Get throw tÿ
"(,11)")
e.")
                  "Load addressÿ
 "14,ZLCCATCH"      "Make active catch frame.")
 on the stack.
(if (> n stackmax)

(let ((x (cons 'catch c)))
 (push x fluid-asaved))    ; Push catch frame location.
********************************************************************
his generates a list of multiple values.                      *
**********************************************************
mvlist (r l &aux (tl (gensym)) c l2)
the stack slot pushed by MVINIT.
n of m.v. slot.
it label.
d.


) "LR" `("15," ,r)          "Load value into register." ))
) "C" `("11," ,c "(,11)")    "If multiple values returned")
E" tl                    "then..."       ÿ
 `("15," ,c "(,11)")  "load pointer to values list")
                  "Else no multiple values..." )
'\2)
 CONS = the value"  )
of ZILCONS"     )
NIL"        )
ist of 1" )
'\15)
***************
      ÿ
*******
is the number of multiple values being requested.
k slots to be used, w+
.
   ; Stack location of m.v. slot.
rguments
(t

etq m (+ c (* 4 n2)))     ; Top of multiple value stack slots.
base)            ; Base for arguments
 for stack control
Reset high water mark
ow MULTIPLE-VALUE-BIND."  )
ultiple values returned")
ues set. Else..."   )
 multiple value")
   ) 
IL = multiple value ",i))
il                          )
*************************ÿ
rocesses the THROW special form.                         *
*****************************************************
r s)
(set-throw-form r))
(throw ,s)))))
      (m (+ 4 c))
ck control
 water mark
.")
(eq r '\15)
rels r)
 stack.
 "NOPÿ
"   `("1," ,(car pdmax) "(,11)")
d THROW tag.")

mit 2 () "BR"  "15"               "Branch to ZILTHROW to throw.")
\1)
***********************************ÿ
ons related to generating branching code                 *
*****************************************************
 ; R = register, S = (condition label)
 or unconditional branching.
ative cases.
ial handling for predicative MEMQ - branching was done previously
n (eq cc 'memq)
ke a copy of the (condition label) so that it can be updated
in case it has to be, and to include a third field
rary label.
wing code determines if we are branching outside of a
e.g. GO or RETURN-FROM out of a LAMBDA).  If so,
e the alist to its previous state before
 the label toÿ
on't need to do this.
e a CURALIST property
EXIT property
operty.
        (cond
'progexit)) (get cur 'curalist))))
t we are branching to a point
olve one or more of

Processing an UNWIND-PROTECT cleanup form
he UNWIND-PROTECT frame)
SAVED and FLUID-ASAVED
 Each entry along
AVED: (SALIST ___)  ===> restore a special ALIST pointer
ALIST ___)  ===> restore a lexical ALIST pointer
H  ___) ÿ

UID-ASAVED must be the same.
 the indicated activityÿ
ointer or frame
must
hat the cleanup code can execute propeÿ

l))
 (eq fal (cdr cur))
D mismatch" cur))
    (zerror "FLUID-ASAVED and SPECIAL-ASAVED mismatch" cur))
etq x (car sal))
 (setq szz (cdr x)))


 s))

        ÿ
       (setq szz nil fzz nil cf nil))
ng on SPECIAL-ASAVED" x))))
 (case (car x)
           (catch  (comment do nothing - handled by sal))
 (uwp    (comment do nothing - handled by sal))
r "Bad thing on FLUID-ASAVED" x))))
bindings need to be unstacked, and this is not a branch
eady does its own unbinding, generate code to
the state they are in at the destination.
g 'popfalist)))
(get g 'popsalist)))
ames need to be unstacked, and this is not a branch
dy does its own unwinding, generate code to
o the state it was in at destination.
h)))
l Sÿ
unstacking stuff was done, S has
ere <gensym> is the
.
 try to optimize out chained GOTO's.
 GONOTNIL
et the "subsumed-goto" target.
       (princ "Dump of original branch label ")
       (terpri)
   (prin1 s)
g)
      (prin1 g)
pri)
t register associated with label.
that the label code exists.
he proper register.

      ; If different paths put value in
different registers, and the value
ing to be use+
est for NILÿ
nto register."))
±
we deleted the GOTO is theÿ
d by GOTOSAMELABEL),
n.
cterpri)
Ç
eq z g)

rwise you need the GOTO.
nconditional or conditional branch.
t 4 () "B" g (if tag
ng tag) 1 30))
(gen-branch-on-condition c g r tag)))
ed, process it.


zcgemit 4 () "L" `("14," ,f "(,11)")    "Get previous catch frame.")
t 4 () "ST" "14,ZLCCAÿ
efun unstack-falist-stuff (f r s)
() "L" `("14," ,f "(,11)")  "Load stacked alist pointer.")
" "14,ZLCFALST"            "Restore ÿ
ck-salist-stuff (f r s)
14," ,f "(,11)")  "Load stacked alist pointer.")
ALST"            "Restore special alist.")
ff (f r s)

 (zcgemit 4 () "ST" `(,r "," ,(+ f 32) "(,11)") "Store passed valuÿ
<
 (zcgemit 4 () "L"   `("15," ,(+ f 28) "(,11)")  "Address of cleanup.")
gemit 4 () "ST"  `("14," ,(+ f 12) "(,11)")"Store return address.")
tÿ
0 l  "DS"  "0H"                                          nil)
 (zcgemit 4 () "L"  `(,r "," ,(+ f 32) "(,11)")      "Restore value.")

==========
g is a label
e
NIL tag), it is compiled as i f it were
temp)
the case of (GONOTNIL tag), it is compiled as if it were

unction implements this by being called the first time
e unstacked, altering the contents of
 to (GOTO something <gensym>),
y be generated for a

cdr (assq (car s) '((gonil . gonotnil)
otnil . goÿ
tq newtag (setf (caddr s) (gensym)))
 label (won't do much).
  (gen-branch-on-conditioÿ
=========================================================
nch-on-condition (c g r tag &aux tl)
te condition code test.
the inline code.)
10") "Test value for NIL."))
t.
          (setq tl (gensym)))
artial condition test.")
(eq c 'gonotnil)
                             (if tag
`("If true (not NIL), go to "
str (tostring tag) 1 11))
ot NIÿ
                                (if tag
   `("If false (NIL), go to "
str (tostring tag) 1ÿ
 (NIL), branch."))

 


**************************************************ÿ


ing form (let L = the GOTO label):
X NIL (GOTO Y))
  with no intervening code between the labels.
 be checked.

 be "fallen through" to, even though it may not get used as
.
*
           ; ÿ
samelabel)
ation,
                  ; The statÿ
             ; (if there is one) must be...
    ; a label - we skip over things
at don't generate any code
dblock))
bel) (return nil))
goes to some Y and that
 we can continue
urn value.
ted we'd fall
IL but
  ;

ituationÿ
ay that the first statement would fall thru to X if the
t went nowhere, else would fall thru to the same
ment falls thru to.  Ifÿ
.) then the first statement would
falls thru to, which may
 (LABEL NIL ...) must be checked for, ÿ
eans that an unconditional GO throws
must be returned.
thing-but-goto a) (cdr r))
 
(((l v s) (cdr x)))
e (not NIL) and
forces
          (null (get l 'popfalist)); (either specially or lexically)
   (null (get l 'catch))    ; (e.g. SETQ, ALIST, CATCH) and
atoÍ m s))           ; if it itself GOTO's some followingÿç
          (eq (car s) 'goto)       ; label in a similar manner and
 (null (get (cadr s) 'gotag)) ; that label isn't a GO tag.
 (cadr s)                    ; then return that GOTO label
                    ; else return nil

***********
      *
  *
*




Now we search special-unbounds and flÿ
******************************************************************
                                                             *
vity:                                               ÿ
                                                       *
bug that caused T or NIL register to be loaded     *
ll to ZILVSET.                                 *
e to be set has never been referenced and    *
ECIAL or closed over), then suppress     *
alue.  Unfortunately, we can't       *
 aÿ
ated into this function and    *
                           *
eing returned in ÿ
ould end up          *
e eliminated.    *
CGSTVRS.     *
************
;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ÿ

))))
p)

zerror
d"
rror - free variable to be set not found" v)))
ter))
e - assigning to non-local ")
    (fp 'lex+
 variable ÿ
         ; If variable declared SPECIAL...
 ZILVSET doesn't already exist, create it.
et subrs))
	
<
  (zcgemit 4 () "C" "3,ZLCUNBND"        ÿ
emit 4 () "BE" (setq lb1 (gensym))       "then...")
r ",##CDR(,14)")  `("store into variable " ,m))
b2 (gensym))       "else...")
    nil)
ue")
                     (putprop (cdr a) (gensym) 'location)
            ))                " get address of symbol")
`("15," ,(or (get (cdr sub) 'location)
prop (cdr sub) (gensym) 'location)
   " ÿ
11)") " get stack pointer")

	
                 " store binding cell on stack")
!!
("Reload value of " ,m))
  nil)

(zcgemit 4 () "ST" `(,r ",##CDR(,14)")  `("Store iÿ
     endif
 pair, meaning a local assignment.
 (setq p (get (cdr v) 'position))
16)
(p                       ; A function argument.
v o m s mvp))
ÿ
 `("Store into variable " ,m))

 )
Õ
merly ZCGSTPRM.

   ;ÿç
r to LEXPR arg.")
 "14,0(,14)"        "Get pointer to alist cell.")
r ",##CDR(,14)")  `ÿ
it 4 () "ST" `(,r ",0(,14)")      `("Store LEXPR arg. " ,m))
  ((alistboundp v)
ure
t cell.")
 ,m))
variable
ion arg " ,m))
efun zcgstvrs-setq-needed (r v s mvp)
cdr v) 'mustinit)
omvp nil s))))
ariable never referenced - skip store
ause various optimizations
 ogrammer may

eferenced local variable ")
§
***********************
                  *
tory Inc.     *
            *
        *
*****
 it?
****************
          *
                       *
*******************
*************************
                      *
                  *
              *

        *
*****
;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ubr (a) ;
 of
   s   ; the target of the value to be set
d
      c   ; comments string
  (setq r (zcgresv '\15) ) ; Value is always in this register.
v '\1)
d address of " ,(cdr b)))
tion name and a symbol.
en

         (putprop (cdr b) (gensym) 'location)))
"1," ,l)                                 c)
    (zcgemit 4 () "L"    "15,ZLCCONS"         "Get address of CONS.")
(zcgemit ÿ
cgemit 2 () "BALR" "14,15"         "Call CONS to make a SUBR.")
it 4 () "MVI"  "##TYPE(15),##SUBR"
(string-substr (car b) 1+
e in register 15.
ariables if any.
.
       ; Free the register.
r.
**********************************************
                                         *
les Stark Draper Laboratory Inc.     *
                                   *
                               *
****************************
the "default ZIL printer", ZDPRINT,
  The file argument is assumed
eam" in this code).
ments:
  00160000
      00170000
       ÿ
es:             00190000
                    00200000
                      ÿ
/PRIN1)                       00220002
ERPRI/TERPRI)                     00230002
, 1 = slashify                       ÿ
ional, 1 = conditional                      00250002
request (ZGETFPO/ZPUTFPO)                       00260002
CRN request                                         ÿ
                                                          00280000
ude #.(zil-source-member zcsdfstr));
defvar lp  "("               "left  list      parenthesis")
 ")"               "right list      parenthesis")
       "left  vector    parenthesis")
t vector    parenthesis")
paÿ
s")
defvar rfp ">"               "right funarg    parenthesis")



" (string ,char)))
 temporary temporary
---------------------
(tyo char stream)
nc-string (string &optional stream)
string ,stream #.%%%princ))
yo ,char ,stream))
evel ,object ,stream nil))
rint-low-level ,object ,stream t))
=================================

) 'stream))
am))
   (zcpexec-prin1    object stream))
ect streamÿ
.%%%charpos  (zcpexec-charpos  object stream))
rscrn  object stream))
its)
                             (zcpexec-bits-operation bits)))))
ream)
 (zcpexec-prepare-stream stream)))
-princ    object (zcpexec-prepare-stream stream)))
      (zcpexec-prin1    object (zcpexec-prepare-stream stream)))
rpri
)
-stream stream)))
(zcpexec-prepare-stream stream)))
c-clrscrn  object (zcpexec-prepare-stream stream)))
"Unsupported ZCPEXEC operation for output file "
ring stream))
errorÿ
ation bits)
tring stream)))))

Ã
Ã
Ã
d "unknown (" (tostring bits) ")"))))
table*))
m)
c-stream-table* nil)
se*   nil))
))
       (unless (boundp '*print-level*)  (setq *print-level*  ni l))
 ÿç
ileid *zcpexec-stream-table*))
        (p
          (setq ÿ
ifier

   :output-function
                                         (write-char char fileid))
                       :princ-function
mbda (string)
ng fileid))
id stream) *zcpexec-stream-table*)))))
ror (stream fun message &optional (arg1 () arg1?)
                          (arg2 () arg2?)
                (arg3 () arg3?))
tream ")


arg3))
fmacro puntÿ
 (o)
cpexec-error stream ,(string o) "Unsupported operation")))
   ))
;
  (zcpexec-error stream "TYO" "Argument not a character" object))
or (stream-output-function stream)

     object
t #.eol)
s stream)))
nc (object stream)
	
eam 0 t))
am)
this implicitly when eol
 zcpexÿ
) #.eol)


ject))
id value for CHARPOS" object))
cpexec-error stream "CHARPOS" "Cannot set CHARPOS to this" object))
  (dotimes (i (- object (stream-chÿ
#\sp stream))
SCRN
=================================
   *print-case*
length*
-prin (object stream level escape)
)
cpprint-1 (object stream level escape)
cpprint-symbol object stream level escape))

É
mponents object stream level escape)))
ow-level (objeÿ

‡
   (funcall princfun string))ÿ
           (or (stream-output-function stream)
ror stream "PRINC"
n stream")))
    (lastchar  nil)
 on current line if appropriate ........
tringlen)
i))))
tream-charpos stream)   stringlen)
(defun zcpprint-symbol (object stream level escape)
ymbol-prin1 object stream)
)
ase*)
   (case ÿ
-upcase prrep))
(:capitalize (string-capitalize prrep))
nt-case* nil)
o NIL"


ep))
    )
s)) prrep))
r (char prrep i)
d
prrep 1 i) s))
 (when s (push (string pchar) s))))
prinÿ
ase)
tostring object t)))
ification always
„
    in front of the funny characters.  (This is a good
on, since such a slashifier is guaÿ
f maclispification of the readtable.)
 what ZILADMP does, and therefore
ADMP to slashify by
%princ (if (eql (char prrep 0) #\×)
  (case case
           (:downcase   (string-downcase prrep))
lize (string-capitalize prrep))
etq *print-case* nil)
id value for *PRINT-CASE*, resetting to NIL"

rint-with-components (object stream level escape)
vel* (>= level *print-level*))
   (zcpprint-lÿ
bject)
 ((funargp object)
 stream (1+ level) escape)
ted.
 stream (1+ level) escape))))
escape lp rp)
ength *print-length*))

int-1 (zcar object) stream level escape)
Ã

-1 object stream level escape))

ector (object stream level escape ldlm rdlm)
       (pl *print-length*)
rop vl)
pl))
    (zcpprint-1 (vref object count) stream level escape)

    (go loop)))
tructure (object stream level escape)
0) 'defstruct-print-method)))
escape)) ; escape not CL, use *print-è escape*
object stream level))
sp #.rsp))))
**************************************************
                                             *
Charles Stark Draper Laboratory Inc.     *
                                       *
                                   *
********************************
uld not be incremented when TYI calls
unction and gets back NIL.
RING to return an
REXEC is the function called by the "default ZIL reader", ZDREAD,
file argument is not a symbol.  The file argument is assumed
 (which is why we call it "stream" in this code).
, takes sixÿ
 operations on.
w.
  arg 4 = eof-error-p.

  =  Read an S-expression (READ)
....010  =  Unread a character (UNTYI)
PEEK)
haracter (PEEKCH)
request
Read a line of data (READLINE)
.1  =  Set reader macro
  Return reader macro character
=======================================
sdfstr))  ; Stream type defstruct.
===================================
m eofeÿ
,stream #.%%tyi nil ,eoferp ,eofval #.eol))
al arg stream eoferp eofval recursive-p)
il))
fmacro unread-char (arg &optional stream eofval)
fval nil))
ro zcrread-character-macro-function ÿ
ro-table *readtable*) ,char))
(char)
defmacro the-character (i)

i))
 ,i))
=====================================
 eoferp eofval recurp)
eam) (eq (vref stream 0) 'stream))
c-tyi      stream misc eoferp eofval recurp))

 stream misc eoferp eofval recurp))
xec-prepare-stream stream t)
eofval recurp)ÿ
 stream t)

#.%%readch   (zcrexec-readch ÿ
peekch   (zcrexec-peekch   stream misc eoferp eofval recurp))
   (zcrexec-eof      stream misc eoferp eofval recurp))
rexec-quit     stream misc eoferp eofval recÿ
c-newlinep stream misc eoferp eofval recurp))
ead  stream misc eoferp eofval recurp))
tream misc eoferp eofval recurp))
m misc eoferp eofval recurp))
 eoferp eofval recurp))
p eofval recurp))
c-readdl   (zcrexec-prepare-stream stream t)
    misc eoferp eofval recurp))
-bits-operation bits)
 ZCREXEC"ÿ
 ((symbolp stream)
xec-prepare-stream stream t)
eofval recurp))
 stream t)

                                misc eoÿ
k  (zcrexec-tyipeek  stream
ofval recurp))
recurp))
rp))

(#.%%read-delimited-list
re-stream stream t)
recurp))ÿç
ation for input file "
    (zcrexec-bits-operation bits)))))
e argument to "
 " (not symbol or stream)")
defun zcrexec-bits-operation (bits)
"       )
I"      )
"     )
    )
"   )
  )
)
)
D-DELIMITED-LIST")
bits) ")"))))
(leÿ

eam-unread-char stream) nil) ; clear it
       ; otherwiseÿ
am-input-function stream)
                        "No input operations possible on stream"))
    ))
etf (stream-eofp stream) t)
f-error stream "TYI")
-last-char stream) char)  ; Save for possible UNÿ
stream)
 zcrexec-tyipeek (stream arg eoferp eofval recurp)

ec-untyi stream c eoferp eofval recurp)
crexec-insure-readtable)
)
#.eof recurp)

whitespace)))
char stream eÿ
il eoferp #.eof recurp)
eof recurp)))
ef syntaxes c) :whitespace))+
            (zcrexec-tyi sÿ
 arg)
   (zcrexec-tyipeek stream nil eoferp #.eof recurp)))
f)
   (zcrexec-tyi stream nil eoferp #.eof recurp)))
"TYIPEEK"
(defun zcrexec-untyi (stream char eoferp eofval recurp)
am-last-char stream)))
am "UNTYI"

          "UNTYI character does not match" rchar char))
tream-unread-char stream) rchar)
l))))
((c (zÿ

            eofval)
 (stream misc eoferp ÿ
nil #.eof recurp)))
        (zcrexec-eof-error stream "PEEKCH")
  (ebcdic c t))))
ecurp)
ferp eofval recurp)
wlinep (stream misc eoferp eofval recurp)
.eol))
nd (not (zcrexec-newlinep stream misc eoferp eofval recurp))
p (stream-charpos stream)))
))

r stream "READLINE")
mÿ
l nil #.eol recurp)
          (zcrexec-tyi stream nil nil #.eol recurp))
l c #.eol)
rread-make-string stream))

d of file encountered"))
fval recurp)
misc eoferp eofval recurp)
n LISP reader.
;
ead stream nil nil eofval nil))
 READ would be:
p)
n read-reserving-whitespace
-p)
n zcrexec-read
-p)
exec-preserving-whitespace-p*
)
tream eofÿ
 "READ"
   object)))
og (x y z syntax attribuÿ
stream nil #.eof t))
oferp
                  "End of file encounteÿ
values eofval nil))))
ase syntax
)
 (:terminating-macro      (go step4-terminating))
inating-macro  (go step4-non-terminating))
        (go step5))

ntinuation-character (go stepz))
rread-bad-readtable-syntax x syntax stream)))
 chaÿ

tep4-non-terminating ; x is a non-terminating macro character
setq terminating niÿ
is a terminating macro character
;;;(go step4)
inating)
)
   (go step1))
values) nil)))))
      (setq y (read-char stream nil #.eof t))

n stream)

 
z  ; ZIL only ... x is a continuation character
ar stream nil #.eof t))
 by EOF - ignore it
   (go step10))
e - yes
))
e treat like constituent
        (zcrread-begin-token stream)
    (zcrread-add-to-token sÿ
 this point a token is being accumulated, and an even number
tiple escape characters have been encountered.
r stream nil #.eof t))
p10))
      (:whitespace             (go step8f))
      (go step8a))
             (:non-terminating-macro  (go step8a))
ape          (go step8b))
×# (go step9))
   #+ZIL (:continuation-character (go step8z))
     (zcrread-bad-readtable-syntax y syntax stream)))
constituent or non-terminating-macro character
case y)ÿ

har stream nil #.eof t))
xec-error stream "READÿ
tuent :alphabetic)
ape character
racter
tep8e ; y is a terminating macro character
m)

 y stream)
 y is a continuation character
eof t))
e it
on followed by newline - yes
har z stream)

	 berÿç
countered.
hen (eql y #.eof)
setq syntax (syntax-ÿ
ce             (go step9a))
))
-terminating-macro  (go step9a))
 step9b))

ation-character (go step9z))
d-readtable-syntax y syntax stream)))
ro or whitespace character
tituent :alphabetic)
scape character
     (when (eql z #.eof)
        (zcrread-add-to-token stream z :constituent :alphabetic)
ÿ
go step8)
-illegal-character-error y stream)
uation characteÿ
        (when (eql z #.eof) ; Continuation followed by EOF - ignore it
         (go step10))
 newline - yes
)
tep10 ; An entire token has been accumulated.
lisp-object stream))))
multiple-value-list

o reader macro function for character"
g char)))
m)
advector-index readvector))
vector))

 ((s (zilvtos (readvector-characters readvector) index)))
lldotp
)
rror stream "READ"
))))
  (case (vref attributeÿ
numericp nil)
 (:alphadigit
 (:dot
gal-character-error (the-character i) stream))
 (zcrexec-error stream "READ"
is character attribute"
cter i))
efun zcrread-begin-token (stream)
m)))
efun zcrread-add-to-token (stream char &optional
           (syntax (syntax-of char))
attribute (attribute-of char))
ectÿ
ector))
  (when (>= index length)
          (new-reaÿ
         (setf (readvector-index new-readvector) index)
length)
              (vref (readvector-cÿ
(vref (readvector-syntaxes new-readvector) i)
or-syntaxes readvector) i))
readvector) i)

tream-readvector stream) readvector)
vref (readvector-characters readvector) index) char)
advector-syntaxes   readvector) index) syntax)
-attributes readvector) index) attribute)
vector))
 (x stream)
"
dtable-syntax (x syntax stream)
    "Invalid ÿ
               (zcrread-hex x)
ad-hex (x)
d.
acro (stream mchar)

mchar)
renthesis) reader macro              ;)
zcrread-\(-macro (stream mchar)    ;)

           stream (rp) t t t)
              ;(
read-\)-macro (stream mchar)
arenthesis \")\""))
nÿ
 (values))
 zcrread-\,-macro (stream mchar)
        (#\@    ÿ
                '×,@×)
 the character.
)
te) reader macro
d-begin-token stream)
r stream nil #.eof t))
go eof-error))
stream)))
le-escape
          (cond
esc-error))
ream c nil nil))))
   (setq e (read-char stream nil #.eof t))
        ((eql e #.eof)
((eql e #.eol)
    (unreadÿ
 nil nil))))
m c nil nil)))))
tream "READ"
losing \""
AD"

lled only in 1 place, readvector will never be null.
am-readvector stream)))
               (readvector-index readvector))))
LIST processor
curp)
MITED-LIST"
og (z c thing needatom gotatom (eofval (ncons nil)))
etq c (peek-char t stream nil #.eof t))
)
ream) ; Consume the character.
    ÿ
 pair error - no object read following \".\""))
    (return z))
  (t
        :non-terminating-macro)
haracter.

       (go loop))
acro-values))
  (multiple-value-bind (object dotp)
ad-1 stream nil eofval t)
)

                     "Dot illegal outside dotted pair context"))
  (unless z


oop)

otatom
ed pair error - more than one object read following \".\""))
m
t)

of file encountered while reading list before finding delimiter"
           (string char))
acro
n conjunction
 only syntax supported is:
 BAR  --> BAR, only if feature FOO exists
ture FOO doesn't exist
 --> the fixnum corresponding to the character FOO.
 #/FOO.
.
essed in octal.
integer eƒ xpressed in hex.

 integer expressed in radix nn.
vector.
time evaluÿ
OO, which it's supposed to be


ollowed by a character, if set-dispatch-macro-character has been
or that character.

 .   #X00)

     (VT        .   #X0B)
TURN    .   #X0D)
  #X15)

    (FF        .   #X2C)
     .   #X2C)
X40)
   #Xÿ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(f mchar)
       (n (prog (d zÿ
ad-char f nil nil t)
                                "No dispatch character for #")))
     (setq d (digit-char-p c 10))
                 (return z))
»
r (zcrread-dispatch-macro-function (char-upcase c)ÿ
rexec-error f "READ"
ter following #"
)))
==================================
zcrexec-error f "READ"
 (symbol-name (concat "#" n (string c)))))
ÿ
 foo)
 c n))
===============+
oo) --> ...whÿ
od (f c n)
ead f nil t nil t)))
============================ÿ


(featurep 'zilco) ; If being read by the coÿ
Load-time evaluation (#,) not supported by ZIL compiler.")
rinc "Processing as read-time evaluation (#.).")
rp-period f c n) ; Process like #.
==========================================
feature, then whatever follows
en n (zcrsharp-n-error f c n))
crexec-read f nil t nil t) f)
 (t
nil t))
 then whÿ
(zcrsharp-n-error f c n))
read f nil t nil t) f)
rexec-read f nil t nil ÿ
ec-read f nil t nil t))))

 (x) (zcrsharp-eval-features x f)) (cdÿ
very #'(lambda (x) (zcrsharp-eval-features x f)) (cdr x)))
ot)
es (zcadr x) f))
arp-feature-error x f))))
ec-error f "READ" "Invalid feature specification form" x))
--> returns a character object (actually a fixnum)
o
n))
an impossible character object fixnum for CNTL-foo
conÿ
racter-representation f))
(f)
(let* ((r (zcrexecÿ
r-types)))
ngth r) 1) ; If it read 1 character
        (zcrexec-error f "READ"
aracter representation" r))))ÿç
)
rsharp-n-error f c n))

harp-radix f 16))
n)
; #36rfoobar ...
c-error f "READ" "Numeric modifier required for #R"))
 36))
(zcrsharp-radix f n))
eg? err)
eek-char nil f nil nil t)
                           "No digits following # with radix"
         ÿ
-char f) ; Throw away the peeked character.
 (case a

     ) 


d-char f) ; Throw away the peeked character.
nil #.eof t))
go loop)
ror f "READ"
                        radix (nreverse err)))
 z) z))
s produces a fixnum,
have more
;; #XFFFFFFFF  =  4294967295
harpÿ
 err)
l f nil nil t)
g #Z")))
ay the peeked character.
 count 8)
   "Too many hex digits in #Z consÿ

t (< weight 16))
tq z (+ weight (lsh z 4)))))
e peeked character.
 (if (eql a #.eof)

                              (nreverse err)))

hen n (zcrsharp-n-error f c n))
fun zcrsharp-comment-search (f)
     ; Search for other comment characters.
.eof t))
l k #.eof)              ; If end of file, terminate
))         ;ÿ
 got ×, we might have ×#.
next character.
l.
        ((eql k #\#)                ; If we got #, may be nested #×.
 (setq k (read-char f nil #.eof t))  ; Get next character.
k #\×) (go chk1)) ; If not #×, keep checkiÿ
arch f); Process nested comment group.
and then keep going.

 need it to read the list
 l i y)
 nil t nil t))

jects for #(, ignored" l)) ; )
º
f "READÿ
etq y (zcar l))
      (setq i (1+ i))
xec-read f nil t nil tÿ
efun zcrsharp-struct (f c n)
eql (peek-char nil f nil nil t) (lp))
st be followed by (.")) ; )
       (unless (and list (symbolp (car list)))
" "Invalid structure name in list" list))
struct-properties)
ucture" list))
ro)
constructor defined for this structure type"
t))
                  (z nil)
null x) (nreverse z))
         (when (null (cdr x))
"READ"
"
,(cadr x) z))))))
 beÿ
;;;
and we don't want to cause any "real" EBCDIC characters to
 like ASCII controÿ
character instead.
(make-list 256)))
^a is supposed to be the
n defined as part
ed.
    (setf (nth #\A  cflist) #X01) ; SOH
#X02) ; STX
f (nth #\D  cflist) #X37) ; EOT
Q
\G  cflist) #X2F) ; BEL
       (setf (nth #\I  cflist) #X05) ; HT
#X25) ; LF
f (nth #\L  cflist) #X0C) ; FF
É
flist) #X0F) ; SI
  (setf (nth ÿ
12) ; DC2
(nth #\T  cflist) #X3C) ; DC4

  cflist) #X26) ; ETB
      (setf (nth #\Y  cflist) #X19) ; EM
X3F) ; SUB
ket)
h #XBD cflist) #X1D) ; {I}GS (cntl-right-bracket)
cflist) #X1E) ; {I}RS
;;        (setf (nth #\`  cflist) #X40) ; SP
t) #\; ) ; ;
 (nth #\}  cflist) #\= ) ; =

cflist
hrow away the character following the #.
tion f)))
ec-errÿ
Ó
special *zcrexec-stream-table*))
or-reading-p)
tream-table*)
t* ((fileid stream)

etq stream (cdr p)))
ream
         (list 'file fileid (zildsni fileid))
    :type 'file
                        #'(lambda ()
d-char fileid nil nil))))
c-stream-table*)))))
tor stream)
)
aÿ
 (boundp '*readtable*)
crexec-create-readtable ()
ame 'default))

rexec-readtable*)
-whitespace-p* nil)
 ff. from page 336 of CLtL
ble*)))
whitespace)
n    :whitespace)
ab       :whitespace)
t a #/×         :multiple-escape)
cro) ; :non-terminating-macro

rminating-macro)
et a #/`         :terminating-macro)
acro)
    :continuation-character) ; cent sign
LtL
set a #/!·          :alphadigit)ÿç
:alphadigit)
    :alphadigit)
        :alphadigit)
a #/(  #×)×#  :alphadigit)
set a #/*         :alphadigit)
  (vset a #/0         :alphadigit)

t)
digit)
:alphadigit)
    :alphadigit)
)
igit)
alphadigit)
   :alphadigit)
       :alphadigit)
 #/^         :alphadigit)
et a #/`         :alphadigit)
 (vset a #/×         :alphadigit)

)

      :alphadigit)
c         :alphadigit)
a #/e         :alphadigit)
(vset a #/g         :alphadigit)
    (vset a #/i         :alphadigit)

t)
hadigit)
:alphadigit)
    :alphadigit)
t         :alphadigit)
a #/v         :alphadigit)
set a #/x         :alphadigit)
    (vset a #/z         :alphadigit)

t)
hadigit)
  :alphadigit)
      :alphadigit)
K         :alphadigit)
t a #/M         :alphadigit)
(vset a #/O         :alphadigit)
    (vset a #/Q         :alphadigit)
ÿ
git)
hadigit)
:alphadigit)
      :alphadigit)
	
*)))
     #'zcrread-\(-macro)
   (vset a #/;         #'zcrread-\;-macro)
d-\,-macro)
#/'         #'zcrread-\'-macro)

Ð
                 #'zcrsharp-vector)
harp-plus)
set a #\^                  #'zcrsharp-control)
       #'zcrsharp-minus)
)
                #'zcrsharp-quote)
rp-binary)ÿ
set a #\R                  #'zcrsharp-radix-n)
     #'zcrsharp-escape)

               #'zcrsharp-hex370)
py-readtable *zcrexec-readtable*
xes   *zcrexec-readtable*))
es *zcrexec-readtable*))
(readtable-character-macro-table *zcrexec-readtable*))
ro-table
e*))
 eoferp eofval recurp)
g or fixnum)
-readtable)
e*))ÿç
))
                          *zcrexec-readtable*))
le-syntaxes   *zcreÿ
       ((characterp misc)
nd (or (stringp misc) (symbolp misc))
ength misc) 1))

               "Invalid reader macro character"
      misc))))
vset cmtable  character nil)
xes character))

                 (declare (special *zcrexec-rmchar*))
 (funcall eoferp s)))


taxes   (readtable-syntaxes   *readtable*))
ributes *readtable*))
)
efun zcrexec-rmchar   (stream misc eoferp eofval recurp)
zcrexec-rmchar*))
 fun message &optional (arg1 ÿ
               (arg2 () arg2?)
     (arg3 () arg3?))
 (princ (stream-identifier stream))
ssage)
 (prin1 arg2))
ror `(,fun " failure"))
****************************************************************
                                                           *
ight 1989 The Charles Stark Draper Laboratory Inc.     *
hts reserved.                                        *
                                                 *
**********************************************
ogn
%xxx  -  bits for output stream functions
   00000000)
  #b   000ÿ
adch    #b   00000100)
%%eof       #b   00001000)
var %%newlinep  #b   0001ÿ
  (defvar %%readline  #b   01000000)

0)
0000000)
000000)
  #b   00000001)
erpri   #b   00000010)
%%%charpos  #b   00010000)
 (defvar eof -1)
#\( #×)×# )
l)

supprÿ
defines the structure of the STREAM data type.

type               ;ÿ
on called to get a character.
 to put a character.
jects in.
 last-char          ; Used by TYI and UNTYI.
Used by TYI and UNTYI.


readvector
                           (syntaxes   (make-vector length))
              (attributes (make-vector length))))
  (length)
taxes)
    (name)
     (attributes (make-vector 256 :illegal    ))
table)

 (c)

***************
          *
.     *
    *
*

sdfstr)) ; Stream structures.
Ö
crexec stream #.%%read-delimited-list chaÁ r t nil recurp))

***************
          *
.     *
    *
*

str)) ; Stream structures.
fun read-from-string (string &optional eoferp eofval
        &key (start 0)
ngth string))

make-stream :identifier string :type 'string))
am-input-function stream)
        (cond
           (setq char nil))
      (setq char (char string local-charpos))
ocal-charpos)))

ving-wÿ
 #.%%read preserve-whitespace eoferp eofval t)
 (charpos stream))
il nil nil nil))

;*                                                                     *
IL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
     All rights reserved.                                        *
                                                             *
**********************************************************
RROR
o as
is assumed to be a message, and is therefore PRINC'd.
ssumed to be a random ÿ
 arg is assumed to be a list of random values, and is


ror (&optional (a nil a?) (b nil b?) &rest c)
sglevel) 3)
        (if (atom a)
 (i a) (princ i)))
À
1 i))

***************
          *
.     *
    *
*

 function name
ased
AUTOLOAD property is a string, then it isÿ
 to be loaded.
is a form
esumed that the file or form,
nction name in question
erty is a symbol, then an attempt is made to
efinition from the system ZIL library.
n is searched for is the value of
e function symbol itself if

 the Aÿ
.  If it is a symbol, the AUTOLOAD property is retained;
tempt to load the compiled function fails, either
 function or an "undeÿ
he value of the optional second arg.
rty is skipped if an error occurs

luated in the default environment, NOT in the environment
he time of execution.
 return a SUBR.
 the works
*************************************************************
                                                        *
nged to set a flag while autoloading so that if       *
 is issued on the function while it is being      *
 autoload process will return NIL instead     *
rÿ
                                        *
*************************************
                +
 an unsuccessfÿ
o that more than one        *
.                       *
                    *
autoloading       *
stored        *
during    *
pletion *
    *
*
	
t ,f 'zil-no-autoload))
e minor drawback:
can have

PROPOS and GCTWA, depending on their implementation, may
y treat tÿ
LOAD property only reinforces the
t doesn't have any other
zevauto (f &optional e)

piled code.
he library.
loaded

'subr))); make it SUBR property of function
    ; If not found,
on lib

  (in-autoload-environment (load p))) ; Load autoload file.
)                      ; If list, form to be evaluated.
ronment (eval p))) ; Evaluate form.
OLOAÿ
 ; Other than symbol, remove it.
dicate autoload didn't fail.
         ; If functÿ
" f) ; then if an error is desired
gnal one, otherwise return.
ronment (&body body)
 t)  ; Suppress recursiveÿç
     ; autoload attempts.
c SPECIALs.
.
   (progn

et f 'autoload) p)  ; capability.

**

;*         All rights reserved.                                        *
                                                                   *
****************************************************************
;;; "ZEVDEFLDÿ
Ç
(X) (ZEVDEFLD X))
AUTO.
elp)              (zerror "Not at top level" 'defload))
 (cdr x))) (zerror "Too few arguments" 'defload))
     (zerror "Too many arguments" 'defload)ÿ
))
error "Argument 1 to DEFLOAD not a symbol" arg1))
„
 ; When DEFLOADing, delete all function definitions.
D, it's easy to skip REMPROP's when no PLIST.
mbol-plist arg1)))
g1 'expr)

)

**

;*         All rights reserved.                                        *
                                                                   *
****************************************************************
FUN - DEFUN fÿ
cess the DEFUN special form.

 invoked with an argument ofÿ
L))
À
at top level" 'defun))
l or (name type).
Ä
.

 e . z) r)
nd (symbolp f) (memq e '(expr fexpr macro)))
error))
else
  ; Function body.
endif 
  ;; Check function type and verify argument list if required,
te conflicting function types.
 specified, then give iÿ
ing NIL to

redictable behavior of GENSYM in the iÿ
onsp f)             ; (defun (foo bar) ... )
lid function name" f))

)      ; The actual function name
ADFILE.
Æ
ndard types...
is.
p f 'subr)     ;       Delete SUBR def if any.
   +
rÿ
st for FEXPR" a)
t, make 2-arg list.
 else
            (cddr a))
r FEXPR" a)

remprop f 'expr)     ;       Delete EXPR def if any.
  ;       Delete SUBR def if any.
It is erroneous if...
ic arglist, or
d there's
  then                           ;  but OK if 1st arg is NIL.ÿ
ror "Invalid argument list for MACRO" a)
therwise, leave as is.
 def if any.



st to insurG e that
 PLIST.


***
<

                                                                    *
*****************************************************************
 This functionÿ
 function.  Syntax is:
 Compiled "module" code passes a SUBR to this, providing for
g (at least with respect to fÿ
ed instead, then compiling of "modules"
ure to this function instead.


'fsubr)    ;  No!
*
)
*************************************
                                *
 Draper Laboratory Inc.     *
                          *
                      *
*******************
rocesses run-time DEFVAR.
(DEFVAR variable &optional value documentation)
;
 interpretive DEFVAR, and
s ZEVXVAR,
; initialization "thunk".  Since there should be a null lexical
nt associated with the "thunk", it can be passed as
 - no need to use FUNCTION to make a
defmacro d-var () `(zcar x))
c () `(zcaddrÿ
(cdr x))
)
p level" 'defvar))
)
junk-p) (zerror "Too many arguments" `(defvar . ,x)))
t `(lambda () ,(d-val)) (d-doc)))
bda () ,(d-val))))))


*************
        *
    *
  *
<

the initial macro and function definitions needed

***********
        *
    *
*
<
* 04/11/88 - Macro PUTDATA added.                                     *
/01/88 - VALUES-LIST added.  EXPR's for LIST, etc. removed.       *
3/88 - INTEGER-LENGTH added.                                    *
 - New special forms added:                                 *
LOCK, RETURN-FROM, TAGBODY, MULTIPLE-VALUE-LIST,        *
    ÿ
aneous additions to feature list, fixup of        *
PUSHNEW macros.                               *
 forms PROG and RETÿ
, PROG*, RETURN.                        *
E (XLATE), AT and OFF.              *
EAD-DELIMITED-LIST, CHARACTERP. *
                              *
***************************
 form:
t to ZILEVAL.

 ;;

½
;;; PROG and RETURN are macros now, not special forms....

n subr declare
lue-bind)
	
xdefun ,charÿ
ed list structure"
builds default ZIL library names based on
eing compiled.  Note that tÿ
T is loaded interpretively.

d "PROGLIB.ZIL." qual)


                              ; not ")"
     )
               "Source for ZEVINIT not a PDS member"
                      srcname)))))
 -5))
))
  (string-append srcbutl5 "." qual))
      (ÿ

or "Bad source for ZEVINIT" srcname)))))))
urce name of ~S~%" z)
itializing hack.
d ',var (cons ',var ,val)))
obally special variables.
ar *features* (list    ; Must be consed - users may add features.
           'ZIL     ; Of course.
ture.
            #+DRAPER  'DRAPER  ; Ditto.
command execution feature.

       'VF      ; Vector facility.
ollector.
                     'MULTIPLE-VALUES ; Multiple values.
  ÿ
FLAVORS         ; Object-oriented system.
    ; LOOP macro (not 100% complete).
oad-verbose*     ÿ
            nil ) ; Used by TRACE.
d by TRACE.
var *mxsetf-initialized* nil ) ;+
   nil ) ; What file a functio n came from.
 *zil-source-library* #.(libname "LISP"))
ibname "TEXT"))
p for f in '#.special-form-list do
t))
cro xdefun    (&rest z)  `(zevdefun ',z t))
`(zevdefld ',z t))

defmacro macro (x)  (mxdefmac x) )  ;  Generates XDEFUN.
uct macro (x)  (mxdefstr x) )
 )
 (x)  (mxdesetq x) )
 do*       macro (x)  (mxdo     x) )
x) )
ro (x)  (mxif     x) )
un let*      macro (x)  (mxlet    x) )
  x) )
acro (x)  (mxpp     x) )
efun prog*     macro (x)  (mxprog   x) )
g1  x) )
 macro (x)  (mxpsetq  x) )
xdefun setf      macro (x)  (mxsetf   x) )
f     x) )
ltiple-value-call  macro (x) (mxmvcall x))
o (x) (mxmvprg1 x))
 
      (a ÿ
 (b 1)) (mxincf   a b))
b))
tab     (a &optional b) ÿ
         `(not (eq ,a ,b))        )
(catch nil ,@z t)       )
                         `(zilprogv ,a ÿ
acro with-open-file ((a b &rest c) . z)
 c z))
prin1-to-string (a) `(prints ,a t  ))
;
 x) (zmadd x))
nce (&rest x) (zmsub x nil))
xdefun times      (&rest x) (zmmul x))
 x t))
rest x) (zmrem x))
nder  (&rest x) (zmrem x))
unÿ



lphacp )
       charup  )
symbol         copysym )
load copysymbol          copysym )

time )
p      dfloatp )
er-length      zilintln)
ad keywordify          kwdify  )

pand1)
     mkbignum)
flonum         mkflonum)
ad make-list           mklist  )
 (xdefload make-struct         mkstruct)
tor)
     parsbody)
ile          probef  )
 read-eval-print     intrprÿ
 (xdefload remove-duplicates   remdupql) ; (    ... :TEST #'EQL)
evappend           revappen)
efload set-feature         setfeat )
t)
 sfloatp )
nd       sappend )
tring-capitalize   scapital)
efload string-index        index   )

 sremove )
t-trim   srtrim  )
ing-substr       substr  )
load st¤ ring-trim         strim   )
ÿç
ucture           structur)
load symbol-name         pname   )

aluesl )
       sub1    )
ZIL.
             integerp)  ; FIXP == (OR FIXNUMP BIGP)
     last    )
lowing are implemented to be compatible with ÿ
e with Maclisp or Franz LISP, you must use the

xdefload remove        remql   )  ; (REMOVE ... :TEST #'EQL)ÿ
st         substql )  ; (REMOVE ... :TEST #'EQL)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
lity, use the following...
C  ... :TEST #'EQUAL)
 #'EQUAL)

subst     ÿ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
nt   macro (x) ''comment)
	
)
 ×,.× )
/CDR checking to be in effect
s ZCAR/ZCDR.
x) (car (cdr x)))
x) (cdr (cdr x)))
adr    (x) (car (car (cdr x))))

car x))))
x) (cdr (cdr (car x))))
xdefun caaaar   (x) (car (car (car (car x)))))
r (car (cdr x)))))
un caÿ
(car (car x)))))
 caddar   (x) (car (cdr (cdr (car x)))))
 (cdr x)))))
fun cdaadr   (x) (ÿ
 (cdr (car x)))))
n cddaar   (x) (cdr (cdr (car (car x)))))
r (cdr x)))))
cddddr   (x) (cdr (cdr (cdr (cdr x)))))
r x)))
 (zcar (cdr (cdr (cdr x)))))
r compatibility only...
xdefun zcdddr    (x) (cdr (cdr (cdr x))))
led - no need to define them as EXPR's.
z) z)
rest z) (mkbignum z))
Ñ
annot be implemented like =, >, <, >=, <=.
 a series of 2-operand tests connected
e same way as =, >, <, >=, <=.
‡

(a b) `(not (lessp    ,a ,b)))
 ,b)))
  x))

ds.
 (xdefmacro news     (&optional b)    `(zilhelp '$news ,b))
    (&rest x)        `(ziltrace ',x 'trace))
      `(ziltrace ',x 'untrace))
ff  x))
 macro (x)  (mxputdat x))

 (compile) ,z))
p   (a b c)             `(putprop ',a ',b ',c) )
a b &optional c d) (mxdefarg a b c d)     )
nal c d)ÿ
 (mxdefmod a b c)       )
le)))
nterface...
 zifasin )
 (xdefload exp      zifexp  )
we have 2-argument LOG
 zifsqrt )
 Common LISP compatibility...
defmacro first   (x) `(car ,x))
acro second  (x) `(cadr ,x))
macro fourth  (x) `(cadddr ,x))

r (cddddr ,x)))
;
op x '(zlarray) 'autoload))


	
) 'autoload))
e-flavor-instance-variables
      defwrapper
ncall-self
  make-instance
-self
	
ch  (a . b) `(catch ,a . ,b))

 (mxsassoc x))
er stuff ...

est c)) ((:key d)))
ly (&body body)
time x))

 ; (DEFUN (FOO COMPILER-TRANSFORM) (FORM ENV CON) ... body)
 ;
CON) ... body))
)

fmacro zil-source-member (member)
(" member ")'"))
orth)...
********************************************************************
                                                               *
opyright 1989 The Charles Stark Draper Laboratory Inc.     *
 rights reserved.                                        *
                                                     *
**************************************************

required) - a list of unevaluated arguments.
evaluation environment.
rog (v w)
ess (setq l (cdr l))
loop
zcar l) a nil))))
rn v))
*************************************************************
                                                        *
t 1989 The Charles Stark Draper Laboratory Inc.     *
 reserved.                                        *
                                              *
*******************************************
sed by the evaluator (ZILEVAL and ZILAPPLY).
 structure of the "environment" as
	
	
 ; Include evaluator macros.
GTAG replaced by BLOCKTAG and TAGBODYTAG.  See ZILEVAL.
(compile load eval)   ÿ
o bindenv (a) `(zcar ,a))         ; interpreter variables
(a) `(zcar (cdr ,a)))   ; chain of PROG environments
(zcar (cddr ,a)))  ; chain of LEXPR eÿ
car (cdddr ,a))) ; pervasive SPECIAL variables
(cdr (cdddr ,a))))  ; FLET functions
dr ,a)))) ; MACROLET macros
e current PROG
ody next to be executed
e return value
at RETURN/RETURN-FROM will throw to
dytag (p) ; a tag that GO will throw to
acro make-progenv ()
ngh s above!

 

ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
      All rights reserved.                                        *
                                                              *
***********************************************************
his funcÿ
(zevmapp <macroexp> <formarg> <property>)
 value of the MACRO or CMACRO property

;;;                   the macro expansion function <macroexp>
   <property> is the macro property name - MACRO or CMACRO
;; <macroexp> must be (LAMBDA arglist ÿ
 a cons whose CAR is NIL, then this is an extended
ed by DEFMACRO.  Apply it accordingly.
O arglist.  Apply it the old way.
or total CL eventually...)
pp (m form prop)
id macro property found" (car form) prop)
ar form)))
; if (lambda x ...)
 ...) ...)
ro
        )                          ;      apply like a macro

*******************************************************************
                                                              *
pyright 1989 The Charles Stark Draper Laboratory Inc.     *
rights reserved.                                        *
                                                    *
*************************************************
Ó
turns a binding cell holding the new value, i.e. a CONS whose
riable and whose CDR is the value.
error checkinÿ
e implements fake value cells
es.
e symbol.
probably

 do the job anyhow for lexically scoped varÿ
hen (compile load eval)

ial-alist)))
h the alist binding
bal binding "cell"
   (rplacd p val)         ; If found, bash it
tic proclaiming of a previously unbound variable as
t is not done here.  Such is done only for
r consistency with VAX NIL and
sitive tÿ
ecialp var)               ; No warn if declared special.
ng value to assumed new SPECIAL variable" var)
±
§
**********************************************
                                         *
les Stark Draper Laboratory Inc.     *
                                   *
                               *
****************************
tion that underlies evaluation of symbols in
MEVAL.
 binding in the form of a CONS cell, the CAR of which is that
the CDR of which is that value.
rty, we process it much like
it is a string, the
is evalÿ
Õ
ned.  It is the responsibility of the caller to signal an
 in this case for an uÿ
ng cell contains the "unbound marker",
e binding is valueless.
o be evaluated.
 to be a symbol other than T or NIL.
 symbol, no error check is done in
marily to be called by EVAL
 efficiency.  Use EVAL
ed is a symbol.
 use arg 1 from
e.
ue cells
 a
n ÿ
irely.  Only the evaluator's processing of symbols
ng", and probably doesn't even call ZEVSYM
ally scoped variaÿ
(defmacro specialp (var)
M doesn't check to see if a variable is SPECIALP.
aluator) should do that to see iÿ
place.
-alist)))  ; If binding found on alist,
 if binding is valueless
without a binding
ding
Ô
                   ;      then return without a binding
            ;      else return the binding
 "autoloading symbol", then
 and retry.
 )
le
f the AUTOVALUE property, as follows:
 string, tÿ

e evaluated.
or form,
on
r, this function removes
t is a string or
is skipped if an error occurs
NOTE: If a form is the value of the AUTOVALUE property, it is
ed in the default environment, NOT in the environment
 time of execution.

) (return nil)))
 file to be loaded.
                     ; If list, form to be evaluated.
nment (eval v)))
ble "ÿ
n t)
ind-protect
 SPECIALs.
s.
  (progn

**********************************************
                                         *
les Stark Draper Laboratory Inc.     *
                                   *
                               *
****************************
unction processes run-time DEFVAR.
e variable symbol (arg 1 to DEFVAR)
 constant initial value, or
no arguments which can
h an initial value
 whether the
r a

ntax of DEFVAR is:
)
 with no value...
inding,
the variable is proclaimed to be SPECÿ
 takes).
.
             of a CONS of the symbol with its new vaÿ
AR variable value ...) is specified...
ready has a SPECIAL binding,
          Otherwise, the variable is proclaimed to be SPECIAL
  (whatever form that takes).
ady SPECIALly bound,
ing, consisting

            value of the variable's DOCUMENTATION property.
   (The documentation is not added if the variable is
present in the enÿ
scheme implements fake value cells
riables.  This consists of a
 symbol.
obably be
s var to be special.
ains "unbound",
ll,
                   issuing a warning).
 'defvar) nonsense will be done.
ad)
 documentation (var)
evxvar (var &optional (thunkp nil thunkp?)
fun nil valfun?)
          &aux cell)

ror "Invalid DEFVAR variable" var))
Ö

ant BOUNDP to be autoloading in that case.  A good reason not to
 be autoloading (makes coÿ
we can have a non-autoloading BOUNDP especially
 After all, autoload avoidance seems to be the main reason I didn't
ll ZEVSYM here.  But another reason is tÿ
ess" binding, I want to know that.
list))   ; Variable already bound
   ; (locally or globally)
  then                               ; Not bound yet - assign it now.
 ;
lp var) t)
lfun?
                                (zilunbnd))))
          (setf (documentation var) doc))
ll) (ÿ
; Already DEFVAR'd without a value.
   (rplacd cell (if thunkp (funcall valfun) valfun)))

when (lessp (msglevel) 2)
             (prin1 var)
              ;
ar))
inc ".")
         (princ "The new value ")
          (if doc?
d."
)
;***********************************************************************
                                                                   *
c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
 All rights reserved.                                        *
                                                         *
******************************************************
eelÿ
lementation of FORMAT.
ut of the
;;; and processes ÿ
efstruct format
ec             nil)
 (subargs          nil)
)
 nil)
f 'f)) `(format-colon ,f))
n ,f))
(defvar format-radix-string "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ")
r format-char-reps



Ã
Ã
on-alphabetics
s (alpha-charÿ
nally (return (tostring (implode z)))))
l))
(defmacro format-call (char)ÿ
macro spec-char (x) `(car ,x))
cro spec-atsign (x) `(caddr ,x))

(car (format-stream ,f)))
tream ,f)))
everse (format-stream-string ,f))))

         :stream   (cond
ons 0 nil))
 dest)))
                :spec     spec
                  :args     args
      (zfmexec1 f)
args.
s" (format-string f) (format-args f)))

)
      (format-abort f)))          ; or ~^ has been processed
cess f)
))
       ; Get each element of spec.
   ; If it is a string
 suppressing
.

) (spec-colon s))
at-modifiers f)
e x
                                      (format-read-arg f)))
 ÿ
    (t   x)))
)
     ((#\&)     ÿ


))
ll f))
call o))
t-call r))
ormat-call t))
     (format-call ~))
     ((#\$)        (format-call $))


(format-call left-brace))
    ((#xAD        ; left bracket
)            (format-call left-bracket))
ll z)) ; For ZIL debugging only.

ll right- bracket))
 right-brace))
        (format-call >))
)
                        (format-string f)
g (spec-char s))))))
====================
 f) (cdr s))
    )
  ((stringp x) x)
rs (spec-modifiers x))
                     (if (spec-atsign x) "@" "")
g (spec-char x))))))
 x (cÿ
    ((null (car x)) nil)
uct-append z (string-append "'" (car x)))))
nstruct-append z (toÿ
 b)
)))
===
ror "Too few FORMAT args" (format-string f) (format-args f)))
ubargs f))

ar (format-subargs f))
n (format-args f)
ss a do (zerror "Unable to back up in FORMAT args"
   (format-string f) (format-args f))
 a)
============================================
ÿ
    ; Note: char is a 1-character string.
 (cond
               ÿ
-stream-string f)))

t-princ (object f)
est)  (push (prints object nil) (format-stream-string f)))
princ object nil))
rmat-prin1 (object f)
l dest)  (push (prints object t) (format-stÿ
  (prin1 object nil))
 format-terpri (f)
t)  (push (nl) (format-stream-string f)))

(dest (format-dest f)))
rmat-stream-offset f))
-column f)))
Á

null desÿ
===============================================================
ormat-compute-column (f)
ll dest) (format-computÿ
l))
rom-stream (f)
tring for efficiency
  (unless (fixnump (format-stream-offset f))
 column position cannot be determined inside this directive"
format-string f) (format-stream-offset f)))
(string-reverse s) (nl) (cr))))

set f)))))
============
fmacro format-%-a (f)
(f)
vesÿ
a PRIN1.
s (); otherwise as NIL.
ed not sweat it.
wise on the right.
 - inserts spaces on the right, if necessary, to make the
 least MINCOL columns.  The @ modÿ
nserted on the left rather than the right.

         until the total width is at least MINCOÿ
      after padding has been done up to MINPAD.



acter (must be a string).
n format-a-or-s (slashifyp f)
ormat-read-arg f)))

                  )
lashifyp
))
n format-a-or-s-full (arg f atsignp colonp slashifyp
   mincol colinc minpad padchar)
(null arg) colonp)
rints arg slashifyp)))
 (fmincol    (if (fixnump mincol)  mincol  0))
mp colinc)ÿ
))
     (unless atsignp (format-princ string f))
dchar f)
fmincol) do
tq size (+ size fcolinc)))

d (null arg) colonp)                (format-princ "()" f))
                        (format-prin1 arg f))
           (format-princ arg f))))
nd X directives, which format integers.
s commas to be printed between groups of 3 digits.
 to always be printed.
ol - inserts spaces on the left, if necessary, to make the
t least MINCOL columns.  If the number doesn't fit
ns, additional columns are used as needed.

efault is space " ".
must be a string).
ro format-%-d (f) `(ÿ
t-integer 2  ,f))
cro format-%-x (f) `(format-integer 16 ,f))
 f)
      ((mincol padchar commachar) (format-modifiers f))
cond
nil nil mincol nil nil padchar))
        (string     (format-integer-string (abs ÿ
    (fmincol    (if (fixnump mincol)    mincol    0  ))
char   (if (stringp padchar)   padchar   " "))
f (stringp commachar) commachar ","))
hen (×:×)

                loop (or e (go end))
e) z)
                 (push (car e) z)
 e)) (go end))
            (ÿ
 fcommachar z)
end  (return (string-appendl z)))))
(minusp arg)
                ((×@×)
g))))
                            fpadchar f)
tring f)))))))
zerop arg)
     (tostring arg)
    (> radix 1)
ing)))
ormat-string f) radix)
   (quotient arg)
 quotient) (string-appendl z))
dix)
(substr ÿ

iers:
ier
nal English number.
   prints arg as a Roman numeral.


 D, B, O and X formats.
uppress f)
-modifiers f)) f)
t-princ (if (×@×)
                      (zfmneng arg (×:×)))
	
ç
rol bits and represents
s a "pretty"
esent, @ speciÿ
the character is printed as a single byte of data
n.)
er values are defined.
suppress f)
 then
        (b (if (×@×) (caddr a) (cadr a)))
          (format-princ (or b (string arg)) f))
(when (×@×)
t-princ (string arg) f)
 P directive, which handles pluralization.
 a fixnum 1, otherwise prints nothing,

Ô
difier values are defined.
t-suppress f)
     (setÿ
ormat-princ (if (eql arg 1) "y" "ies") f))
   (t           (format-princ "s" f))))))
rective, which prints flÿ

 the field to be printed
the decimal point


w d k overflowchar padchar) (format-modifiers f))
tegerp arg)
((not (floatp arg))
har))
))))
(let* ( 
  (abs           (abs arg))
    ÿ
abs (format-expt-10 (- k))))
format-expt-10 k)))))
upzerointp   (and (+
 fstr) (format-flÿ
    arg
                          w
                                ÿ
           trimzerop
È
g-length fstr))
	
h w))
n (fixnump w)
    (format-princ (string-append istr "." fstr) f)))))
onum and returns a dotted pair of strings,
d the fractional part.

teger (truncate sarg))
            ((fixnump w) (format-guess-d integer arg signp w))
t nil)))
10 (1+ decprec)))
    (t                 #.(expt 10 16))))
truncate (* (- sarg integerÿ

>= fraction "2") ; Note: String comparison
and sup-zero-i-p (zerop integer))
etq integerstring (format-pad-integer integer lzlen)))
inusp arg)
(signp

n) 2)))
rim "0" fractionstring))
))
nstring)))
 (- w 1 (string-length (tostring integer)))))
usp ansÿ
nswer))))
defun format-expt-10 (k)
    (n 1 (* n 10))
     )
i))

al floating-point format.
char,padchar,exponentcharE
printed

;          k is a scale factor that defaults to zero
ers will be output.
ess f)
padchar exponentchar)
 (integerp arg)
    ((not (floatp arg))
l padchar))
                  overflowchar padchar exponentchar))))))
exponential

        (abs           (abs arg))
)
lusp fk) (1+ (- d fk)) d)ÿ
g . aexp) (format-adjust-for-exponent abs fk))
-pad-integer (abs aexp) e))
       (trimzerop     (not (fixnump fd))ÿ
ump w) (fixnump fd)
                     elength
usp arg) atsignp) 5 4)))
) (format-float-pair aarg
                                        atsignp
             w
                              nil
rimzerop
ilength       (string-length istr))
r))
         (cond

atp arg) "D")
 (cond
    (format-ouch w overflowchar f))
owchar)
w overflowchar f))
 (format-ouch (- w width) fpadchar f))
istr
             fstr
                            (if (minusp aexp) "-" "+")
                estr)
-integer (i l)
eading zeroes

end "-" (format-pad-integer (- i) (1- l))))
) l "0" nil -1))))
 This function returns a flonum which is equivalent to arg scaled
wn until the number of digits to the left of the decimal
ven amount.  ÿ
 get it into that shape.
 arg) (return '(0.0 . 0)))
 k) (not (eql k 1)))
s (i (1- k))
     (dotimes (i (- 1 k))


            (decf exponent)
arg ul)    (return (cons arg exponent)))
* arg 0.1))
(go loop)))))
s in
ormat:  ~w,d,e,k,overflowchar,padchar,exponentcharE
width of the field to be printed
t after the decimal point
inting tÿ

t n be an integer such that 10^(n-1) <= arg < 10^n.
if e is omitted.
omitted, first let q be the number of digits needed to print
ss of information and without leading or trailing
(min q (min n 7)).
is printed as if by the format directive
rF~ee@T
.

 modifier is specified to the ~F or ~E directive
cified to the ~G directive.
rmat-suppress f)
   ((w d e k overflowchar padchar exponentchar)
)
t arg))))
arg f nil nil nil w nil nil padchar))
n  (format-find-n arg))
      (ww (if (fixnump w) (- w ee) nil))
   ÿ
)))
(not (minusp dd)) (<= dd fd))
rflowchar padchar)ÿ
(format-exponential arg f (×@×) w fd e k
char padchar exponentchar)))))))))

10    <= arg < 10 .
arg) 0)
    (do (
  )
 10.0))

 print arg with no loss of
oes.
 $ directive, which prints flonums in

 print after the decimal point
 in the minimum number of digits to print before the
nt (default vÿ
o be printed
)
  ((d n w padchar) (format-mÿ
g)
oatp arg))
    (t
efun format-dollar (arg f atsignp colonp d n w padchar)
(fd            (if (fixnump d) d 2))
 1))
 (if (stringp padchar) padchar " "))
     (supzerointp   (zerop fn))

                 nil
                                    fd
    fn
                     supzerointp))
))
cond
tsignp      "+")
th         (+ ilengthÿ
w 100))
 fd fn -1)))
 nil)
sign f))
char f))
-princ (string-append istr "." fstr) f)))))
% directive, which prints newlines.

r (format-modifiers f)) 1))
This processes the & directive, which prints conditional newlines.
 prints n conditional newlines.
format-suppress f)
wÿ
(1- k))
esses the ~ directive, which prints tildes.
	
h (or (car (format-modifiers f)) 1) "~" f)))
 directive, which prints formfeeds.
½
uch (or (car (format-modifiers f)) 1) (ff) f)))
es the ? directive.
ess f)
  (if (@) (format-subargs f) (format-read-arg f)))
f
spec  fspec
        :subargs  flist))
@)
ubargs f) (format-subargs ?f))
sses the * directive.
press f)
 (or (car (format-modifiers f)) 0)
     (dotimÕ es (i (or (car (format-modifiers f)) 1))
)ÿç
    (format-read-arg f))))))

        (modifieÿ
length modifiers)
              (1 (eql 0 (car modifiers)))
difiers) (cadr modifiers)))
 (cadr modifiers))
difiers)))))
(×:×) '×:× t))))))
abulation.
 is
efault: ~1,1T     move it to column COLNUM + a multiple of COÿ
            (unless COLINC is zero, in which case no spaces
    are output in this case).

            smallest non-negative number of additional
paces necessary to move to a multiple of COLINC.
the defaults for COLREL and COLINC?  It doesn't
 make them ÿ
  Shouldn't it be a a column which
NC?)
iers f)))
olinc)
 format-tabulate-absolute (f colnum colinc)
f (fixnump colnum) colnum 1))
 1))

rop fcolinc)
" f)))))
ƒ
olinc  (if (fixnump colinc) colinc 1)) ; for defaults
format-ouch fcolrel " " f)
(num-cur (+ fcolrel (format-compute-column f)))
nder num-cur fcolinc)))
      ÿ
es the ( directive.        )
x o)
mp (setq o (format-st+
mat-compute-column ÿ
en (f)
           ((and (:) (@)) 'upcase)
all)
            'downcase)))
                   :stream (format-new-stream-for-lp f)
        :spec spec
 
ec newf)
 ~)"
and (consp u) (eql (car u) #×(×# #\)))
(format-process newf)
f (format-suppress newf) t))

mat-suppress f)

ring-upcase s)ÿ
ase s))
e s))
verify s #.format-non-alphabeÿ
        (i
-substr s 1 (1- i))
)
              ))


(format-subargs newf))
newf))
)
EBCDIC terminal users, cent sign and broken vertical bar
ted in place of left and right bracket.
ion)
ppress f))
) t))))
 (cdr (format-subspec f)))
pec))
lected nil)
ess (format-suppress f)
))
        (setq select (unless (format-su+
     (format-peek-arg newf)))
       ((not (null select))

ument.
 select (or (car (format-modifiers f))
rmat-suppress f)

ÿ
   (zerror

nsp u) (or (eqlÿ
      (eql (car u) #x6A))) ; broken v. bar
    (cond
ond
~; not allowed in FORMAT ~@LEFT_BRACKET directive"
string f)))
             ((spec-colon u)
    (fselectif (not selected))
t)
lect)))
 (if (×:×)
ACKET directive"
          (zerror "Misplaced ~:; in FORMAT ~LEFT_BRACKET directive"
                     (format-string f))))
  (incf count)
    (t
rt newf)
   ))
     (go loop)
          (setf (format-sÿ
    (setf (format-abort f) (format-abort newf))
 f) (format-subspec newf)))))
.
f ~{~}.  If so, suck up arg as format string
subspec f))))
t-braces-out-of-line f (spec-colon s))
))
mat-suppress f) () (zfmpars (format-read-arg f)))))
 f spec t colon2p)))
(cdr (format-subspec f))))
 
nless (format-suppress f)
rmat-read-arg f))))
(coÿ
                           :spec    (if out-of-line-p
                   spec
c f))

           (setf (format-args newf) arg)
f) arg))
ewf)))
ss newf)
)
s (listp arg)
rg))
rror "Arg to FORMAT ~:{ directive not a list" (car arg)))

rgs newf) (pop arg)))))
 out-of-line-p
       (zerror "FORMAT directive ~{ specified without ~}"
          (format-string f))))))
spec newf))
         (casÿ
 (return))
il)
turn))
 (go loop))
f-line-p colon2p (spec-colon s))
                       (not (eql maxrep 0))ÿ
l (if (×:×) arg (format-subargs newf))))
suppress newf) (format-suppress f)
ewf)     nil
                        (format-subspec newf)  spec)
etq k 1)
       (when (format-suppress newf) (return))
-subspec newf) spec)
(format-suppress newf)))
    (unless (format-suppress newf)
ewf) (fo  rmat-abort newf)))

   )
newf)))
unless (formÿ
rmat-subargs f)
f-line-p
)
 
available describe this directive
pacing must be
¸
l colinc minpad padchar) (format-modifiers f))
 mincol)  mincol  0))

stringp padchar) padchar " "))
     (newf (copy-format f :dest nil :stream nil
  :spec spec :subspec spec)))
spacing padlist padcount
s spacing-left-over
tstrlenÿ
rmat-stream newf) (cons "~<" (list ""))))
irectives to error out.
at-subspec newf)
ed without ~>"
 (setq s (if (consp u) (car u)))
É
                ((and (eql s #\;) (spec-colon u))
iseen

etq fitstring    (stream-to-string newf))
s (spec-modifiers u))
        (let ((string (stream-to-string newf)))
f totstrlen (string-length string))
gs))))
         )
  ÿ
   (otherwise
ormat-abort newf)
            ))
c newf)))

      ((null strings)
 (go finish))
          (setq padcount (1+ (length strings)))

tq padcount (length strings))
etq rightpadp t)
ength strings))

))
dp nil)
 )

incol fcolinc)))
n)
      spacÿ
strings (nreverse strings))
       (s spacing-between-segs spacing-between-segs)
left-over)
ghtpadp
 (incf k s))
strings))
                 (decf r))
          (incf k s)
            (incf k (string-length (car ss)))
less (eql k fmincol)
cessing ~< computing string length"

ng
                (ffitextra (if (fixnump fitextra) fitextra 0))
  (ffitlinel (if (fixnump fitlinel) fitlinel 72))
- ffiÿ
     (when (> (+ fmincol ffitextra) roomleft)
inc fitstring f))
               (if (ÿ
f)
     (unless (format-suppress f)
bargs newf)))

debugging only.
t-suppress f) (format-read-arg f)))

 (format t
.~%"))
fiers are ~S~%" (format-modifiers f))ÿ
flag is on~%"))
format t "~&Current column is ~S~%" col)

t of place.  They are handled correctly by code in the directive
or (, <, etc.
 directive error: ~RIGHT_BRACKET found but no ~LEFT_BRACKET active"ÿ
  (format-string f)))
T directive error: ~} found but no ~{ active"

 ~ÿ
nthesis (f)
        (format-string f)))
ORMAT directive eÿ
 (format-string f)))
====================
This function, called by the FORÿ
teger and returns the English-word form of the number.
e, it returns the ordinal form; otherwise it

ternational Dictionary, 1986
 (cond


)
  (zfmneng-number number ordinalp))))
nalp)
r ordinalp))
inalp))
))

((< number #.(** 10 12)) (zfmneng-billion           number ordinalp))
umber #.(** 10 15)) (zfmneng-trillion          number ordinalp))
 #.(** 10 18)) (zfmneng-qua+
(** 10 21)) (zfmneng-quinÿ
 10 24)) (zfmneng-sextillion        number ordinalp))
7)) (zfmneng-septillion        number ordinalp))
zfmneng-octillion         number ordinalÿ
neng-nonillion         number ordinalp))
decillion         number ordinalp))
illion       number ordinalp))
lion      number ordinalp))
     number ordinalp))
number ordinalp))
ber ordinalp))
rdinalp))
lp))
.
  ((< number #.(** 10 66)) (zfmneng-vigintillion      number ordinalp))
                      (zfmneng-punt              number ordinalp))

)
sic (number ordinalp)
first" "second" "third" "fourth" "fÿ
hth" "ninth" "tenth" "eleventh" "twelfth"
h" "fifteenth" "sixteenth"
")
       "eight" "nine" "ten" "eleven" "twelve" "thirteen"
n" "fifteen" "sixteen" "seventeen"


irt" "fort" "fift"
")))
ÿ
lp)))))
* ((q (quotient  number powerof10))

   (string-append k (if ordinalp (string-append word "th") word))
ing-append k word " " (zfmneng-number r ordinalp)))))
er-of-10-macro (power name)
name)) (number ordinalp)
er)
-of-10-macro  2 hundred)
r-of-10-macro  6 million)
›
illion)
 sextillion)
oÿ
macro 33 decillion)
-10-macro 39 duodecillion)
power-of-10-macrÿ
llion)
 septendecillion)
-10-macro 60 novemdecillion)
.

ORMAT ~R directive processor,
meral form of the number.
;; (e.g. IIII instead of IV); otherwise it returns the standard form.
 
  (zfmnrom-punt      number oldp))
" (zfmnrom (minus number) oldp)))
number oldp))
nrom-number (number oldp)
ls only
 ((< number 9)
(zfmnrom-ixÿ
number oldp))
< number 100)
(zfmnrom-c         number ÿ
 number oldp))
 ((< number 5000)
punt      number oldp))))
-to-string number))

1))

 (string-append digit1 digit2)))
OM-GENERATE"
n zfmnrom-i (number oldp)
efun zfmnrom-v (number oldp)
 "V" (zfmnrom-number r oldp))))
oldp "+
ent ÿ
ng-append (zfmnrom-generate "X" "L" q oldp)
ber r oldp))))
))
om-xc (number oldp)
p "LXXXX" "XC") (zfmnrom-number r oldp))))
)

           (zfmnrom-number r oldp))))
 (let ((r (- number 500)))
)))
   (string-append (if oldp "DCCCC" "CM") (zfmnrom-number r oldp))))
un zfmnrom-m (number oldp)
(remainder number 1000))
" nil q t)
ÿç
*******************
              *
 Inc.     *
        *
    *
*
ring parser (part of the new implementation of FORMAT).
ion takes 1 arg, a FORMAT string, and returns a parsed
format (n.p.i.) is a list of which each elemeÿ
a string, representing literal data
ng, of which the first is always present
:

 or NIL
;;;        is one of the following:
 - a one-character string, representing a "quoted" modifier
e symbol V, representing the presence of V or v
representing the presence of #
zed out, tÿ
;; For example:
;;;  ===>
#\A)
;;;  )
r
ey appear in the original FORMAT string.ÿ
tring start &optional end)
d ,start)))))
er string.
 (x)
 `(zerop (string-length ,x)))
)))
              (if (stringp (car ,z))
string-append (car ,z) ,g))

mbol-ÿ
 string detected by ZFMPARS" string)))
sign whitespace-eaten)
n 1)
    (when whitespaÿ
         (setq n
  #.(tostring (implode
wline #/null)))

      (spush (substring string n i) z) ; Add string to format spec.
r i (go finish))               ; End of string, ÿ
 (1+ i))                  ; Point to stuff following ~.
modifiers
the one-based index of the ~ introducer character.
…
   (case (getcharn string n) ; char following ~ or ,
                   (push (substr string (1+ n) 1) modifiers)
      (setq n (+ n 2)))
 modifiers)
            #\V)
   (setq n (1ÿ
string "-+0123456789" n))
       (push nil modifiers)
           (snum (substring ÿ
make-number snum))
 (unless (fixnump num)
RMAT modifier"
                           (push num modifiers)
etq n s)))))
g(n) should begin with "," ":" "@" or the
er itself.
ng FORMAT directive character" string))

                  (zerror "FORMAT syntax error" string))
(setq n (1+ n))
      ((#\:)
ring))
+ n))

                 (setf ÿ
                 (go extract-format-flags))
 is only one format modifier and it is NIL,
ers.  Otherwise,

             (null (cdr modifiers)))
   (nreverse modifiers)))
ing FORMAT directive character" string))
ective character.
e directive char.
e time.

a newline, ignores the newline and any following
aracters.
llowing
ne, leaves the newline in place, but any
§

line following tilde?
          (unless colon (setf whitespace-eaten t))
)
this time.
c to the format spec.
    (if (and (null colon) (null atsign))
                    (list c colon atsign))
ign modifiers))
n))

**************************************************
                                             *
Charles Stark Draper Laboratory Inc.     *
                                       *
                                   *
********************************
n 2 required.
for ZIL-based interactive applications
nterface.
string>
l            <string>
     :terpri-exit-function <function>
ction>
-init-function  <function>
;;          :expr-list-function   <function>
   <function>
 :good-eval-function   <function>
n>
ction     <function>
;;;;;;;;:grind-form-function  <function>

panel-library         is the panel data set where the paÿ
g-appl             describes the application, printed on SAVEs.
pl            describes the application in error messages.
unction  is called whenever a TERPRI is trapped.
 is called to initialize the FS environment.
lled to terminate the FS environment.
ch time prior to panel display.
ss inpÿ
ions from FS input
resh screen.
.
Õ
st-eval-function    is called to do processing after evaluation.
-function      is called to generateÿ
-function   is called on each output row before adding.
ion   is called to convert a form to an FS string.
===================================================+
)
lisp syntax
var writefilep '^R); Maclisp printer variable
    (defvar pt%princ     1)
erpri    2)
 (defvar pt%clrscrn  42)
defvar *high-intensity* (string #x0D))

f #.writefilep))
ion*
            *zÿ
verride*))
efmacro nullstringp (x)   `(zerop (string-length ,x)))
(x y) `(eql ,x ,y))
))
exec . ,args)))
F dialog service error"
"zerrlm"))))))
                &rest args &aux (g (gensym)))
     (if ,g (funcall ,g . ,args) ,retval)))
&body body)
nter*)
          (setprt *zil-current-printer*)

t (:conc-name nil))
ression      nil)
-size    ÿ
l-array-size* ""))
st      nil)
  "IN")
 nil)
il)



function    nil)
nil)
-eval-function     nil)
     nil)

=====================================================
 (&key
B.CMD.PANEL'")
  "ZFSEXEC")
  (terminate-function   nil)
nction  nil)

nction    nil)

F envÿ
et (
  panel-name)
g-appl f)           ÿ
)
ze-function f)  initialize-function)
te-function)
tf (echo-input-function f)  echo-input-function)
f)   expr-list-function)
Î
function f)   good-eval-function)
unction)
play-function f)     display-function)
put-row-function)
 (depth f))
entions
ÿ
===================================================================
un fszil-read-eval-print (f)
f)

                 (getinput f))
rint f)
nerate-display

(depth f) (current-row f) -1) (line-index f))ÿ
rray f) i) into z
„
zisput "fsmsg"
      (string-append "Row " (tostring (1+ (current-row f))ÿ
       " of " (tostring (line-index f))))

T section of panel.


srpos f) 0)))
ws.  Scrÿ
 get input from the user.
r(" (cursor f) ") csrpos(" (csrpos f) ")")
) t)
y error:~%~A - ~A"
zerrlm"))
etf (morep f) nil)
r f) (zisget "xcursor"))
erb (zisget "zverb"))
ll request
sa (fszil-scroll-amount f)))
        (if (minusp fsa) ; DOWN MAX?
0)

cursor f)
zil-down-max f)
\L ÿ
;;;;;;;;;;;(fszil-retrieve-form f))
  (when (setf (finger f) (input-list f))
f (car (finger f))ÿ
pop (finger f)) (fingerlist f))
f)) nil))
er f)) nil))))
-eql (cursor f) "FSDATA")
eq (finger f) t)
          (fszil-fetch-input f (car (finger f)) ÿ
 f)
tch-input f (car (finger f)) nil))
-fetch-input f (car (finger f)) t))))
ue" zverb)))
ent-row f) (line-index f))))



rocessing
ZCMD") " ," "" "\"\\"))))
 f) "IN")
e (car cmdlist))))
ü
"F" "FIND")ÿ
     (fszil-rfind  f cmdlist))
  f cmdlist))
         (string-append "Cÿ
       )
tring-append "A severe error occurred during the " cmd " command.")
)))
t f) nil)

       (getinput f)
f) 0))
t (f &aux (trapper
                                       (with-printer (print-trap f)
                                                 (funcall x)))))
(exprlist (fscall (expr-list-function f) (getinput f) trapper)))
input f) "")  ; Blank out for input next time
"))
os f) 0)
expression f expr fsdisplayp trapper)
              (fszil-ÿ
TENTION INTERRUPT ***"))
(lines-generated (- (line-index f) (inputx f)))
ine-index f) (current-row f))))
(lvline f))
 f) t))
)))
l display refresh"))
e (nreverse *print-trap-string-list*))

ate-expression (f expr fsdisplayp trapper
aux vals errorp attnp)
 save")
 +

ec "control display restore"))
) t)
nterrupt."
essed."
add-row f nil "")
append "An error occurred whiÿ
               " was evaluating your expression.")))
 f) 0)
displayp)
f)
) vals)))
sage "Display failed."
g "
 "'s display processing."))))
.
 
sput "zerrsm" smsg)
 (zisput "zerrhm" help)
clear-ispÿ
isput "zerralrm" "no")
2)")
=========
 (eq f t))
nless y (print-trap-hook-dispatch a b))
il-previous-printer* a w b))))
))
     (print-trap-hook-dispatch a b)
b)))
k-override*
%tyo    (setf (car *print-trap-string-list*)
pend (car *print-trap-string-list*)
tring a))))
             (string-append (car *print-trap-string-list*)
                   (princ-to-string a))))
rap-ÿ
ing-list*)
#.pt%terpri (when *zfs-terpri-function*
nt-trap-hook-overriÕ de* t))
function*ÿç
rap-string-list*))))
              t)
 (car *print-trap-stringÿ
-trap-string-list*)
new integer value or NIL to return current value
               (c (1+ (string-length (cÿ
                 )

                 (minusp a)
             (< a c))
 update value" a)
          (setf (car *print-trap-string-list*)
ormat nil "~VA" (1- a)
-string-list*))
st*)
    ÿ
a b)))))
========
bal variables.
(setq *zil-print-trap-hook-override* nil)
t printer trapping.
 (print-trap f) #'macsyma-print-trÿ
#'zmsprint)
ous-printer* #'zmsprint))
ok)
nter* #'zdprint)

ll (line-array f) "")
)
t available.
ntrol nondispl end")



 
       ") areaname(fsdata) depth(fslvlin)"))
efinition for panel" (panel-name f)))

d.

g-eql (zisget "zctact") "&YRFIND")
)
ec "tbadd ispcmds")))
          (zisput "zctact" "&YRFIND")
ds")))
ASSTHRU.
amount.
           (setq amt "PAGE")
o PAGE if not in profile.
the panel.
isput "FSDATA" "")                  ; Clear the dynamic area.
n fszilÿ
amt" (zisget "amt"))
"")


)))
(array-size f) #.*initial-array-size*ÿ
-vector new-array-size ""))
size f))
             (vref (line-array f) i))
ine-array f) new-line-array
)
79A"
   ;;;             (fscall (output-row-function f x) x))
d (if highp #.*high-intensity* #.*low-intensity*)
pad (fscall (output-row-function f x) x)
spÿ
ormat nil "~A~79,,,'*:@<~A~>"
                " Bottom of data "))

isput "IN" "")
f) 1))
t (f entry cursorposp)
 (cadr entry))
addr entry) 0)))
uotient (1- (csrpos f)) 80)))
  (error-ispf-message "Invalid cursor positio	 n."ÿç
    "The cursor is outside of the output data area."))
rent-row f) q))
;      (setf (cursor f) "IN")
fun fszil-down-max (f)
e f) -1))))
olla") 0)
ÿ
nreverse z))))
den line) (cdr cl))
 (!new-row!))
       (!new-row!)
loop do    (push " " z)
             until (zerop (remÿ
g (car cl)) z)
    (!new-row!)
=============================================ÿ
(f cmdlist &aux (c (cdr cmdlist)) n)
message "Missing operand."
s an operand."))
y operands."
d."))
sage "Invalid operand."
with LOCATE."))
etf (current-row f)
(defun fszil-rfind (f cmdlist)

-ispf-message "Enter a FIND command."
recede an RFIND request.")))
mdlist)))
process-find f (find-string f) 'next)
ing."
not (null (cddr c)))
         "The FIND command takes no more than two operands."))
 (car c) "*")
ring f)
 (error-ispf-message "No string defined."
FIND command has been executed.")))
ack-string (car c)))
               (if (cdr c) (cadr c) 'next)))))
g (x &aux (y (string-upcase x)))

             until (null (cdr cl))
   ÿ
cdr cl))) into z
ally (return (tostring (implode z)))))))
tr fdir &aux (dir ÿ
spf-message "Invalid string."
permitted.")

irst f fstr))
-ispf-message "Invalid operand."
AST (default is NEXT).")))))
setf (text-not-found f) t)
il-process-last (f fstr)
 f fstr t))
Â
±


(i))
data reached." "top."))
pcase (vref (ÿ

n fszil-process-prev (f fstr &optional firstorlastp)
) 'prev)
orlastp (text-not-found f))
(setf (find-pos f) 80))
(row (find-row f) (1- row))
 (string-reverse fstr))
    (i)
of data reached." "bottom."))
y f) row)))
          (string-upcase
tring-substr (vref (line-array f) row) 1 p)))
       1))
       (fszil-eureka f fstr row i)
l-eureka (f fstr row i
))
 f row	  i)ÿç
message
             " found.")
           (tostring (1+ rÿ
     (tostring (1- i))
"))
ux (pstr (prin1-to-string fstr)))
f (text-not-found f) nil)
string-length pstr) 12) "Text" pstr)
The requested text was not found anywhere in the output.ÿ
f (text-not-found f) t)
Text " pstr
))))

        (r (remainder n 80)))
etq q (1- q) r 80))

ind-pos f) r)
 (find-pos f) 0)))
s absolute row.  To sÿ
be absolute-row minus *fszil-current-row*.

and we have to scroll to bring it inÿ
rent-row f))))

        (setq srow (if (zerop row) 0 1))))
pos)))
ff))))
: SAVE dsname {old/mod}
ter data set name."
cified."))
nds."
(ÿ
ng-upcase (car c))              ; data set name
dr c)) 'old) ; disposition
 disp)
t)
rror-ispf-message "Invalid disposition."
LD or MOD (default is OLD).")
l)))))
**  ~A - Output for ~A - ~A  ~A  ***~3%"
serid) (pptime) (ppdate))
c (string-substr (vref (line-array f) i) 2 8W 0) file)
)
sage "Save successful."
sn)
*******************************************************************
                                                              *
pyright 1989 The Charles Stark Draper Laboratory Inc.     *
rights reserved.                                        *
                                                    *
*************************************************
ce-member zcsdfstr))
%%charpos)
***************************************************
                                              *
 Charles Stark Draper Laboratory Inc.     *
                                        *
                                    *
*********************************
of APPLY.  This routine was separated from the APPLY
in order to be able to specify the third and
w, as well as permitting the full

rgument 2 (required) - the list of (evaluated) arguments.
ional) - the lexical (fluid) evaluation environment.
) - the nameÿ
pseudolexical "environment" arg that gets passed around
ly an alist, but now a more complex object.
es:
ist,
;         take full environment objects.
G environments are passed
NCTION, non-local



other locations where fast CAR is desired and it is known that
gument won't be NIL.
****************************
                       *
                   *
       ÿ
d TAGBODY    *
d.       *
     *
   *

;
 (unless (listp sample-env)
 Recode ZILAPPLY!!!")
)) ; Include evaluator macros.
     ; the keyword name (:foo)
Ì
e keyword "supplied-p" argument
e assigned
o that callers of
ving
 (f ; the function to apply
ÿ
           (q f)    ; function name for error messages
                m        ; Temporary local variable.

    nil  ; What is this nonsense?  Deep-six it.
and closures are the only valid code objects...
.args...) - this is sort of irÿ
fficiency hacks in the interpreter
led functions or something.
                          )
...
  )

 (setq a (mknewenv nil))) up here.)
symbol-function)                  )
f the structure has a property that allows it to be invoked as a
on, then use that.  If that is the case, the associated
oked with arg1 being the instance of the structure
ng the args passed to apply.
tq m (get ÿ
      (zilapply m (cons f l) a q)                 )
of atoms (numbers, etc.) cannot be functions.
(zerror "Invalid form in ÿ
     f)                                  )
 LABEL expression...
 a fresh one, lexically speaking.
))
nsp (cdr f))
                              (zerror "Invalid LAMBDA lÿ
               (zilapply-lambda)                           )
(label)        (unless (and (consp (cdr f))
      (consp (cddr f)))
LABEL list" f))ÿç
                           )
form in functional position"

cal variables all together.
 are invalid - not functions.
 (x)
  (if (setq s (getl f '(macro ×SPECIAL FORM× fexpr)))
(zerror "Invalid to APPLY" (zcar s) f)

subr)      (zilxsub (zcadr s) l)                    )
       (zilapply (zcadr s)
                                   (mknewenv nil) ; lexical scoping
f dynamic scoping, would be......(mknewenv (bindenv a))
                   f)                             )
ILAPPLY-LAMBDA

ambda ...) ...), the PROG and ARG environments are retained.
he way an EXPR is applied - the PROG and ARG environments
  Lexical closures pass tÿ
for strange Common-LISPy results.

l)))
is a "lexpr".
ARG x))
 bvl to the number of args.
al "expr".
  (prog (newenv savespec locspecs lamspecs)
v a))
*************
        *
    *
*
<

          (setq lamsÿ
ind (docstring decls nbody mxform mxvalidp)
y lambody nil t)
y))
       (if (atom dcl)
             (case (car dcl)
        (dolist (dclarg (cdr dcl))
his when we bind...
                             ;; It's pervasively special for references
                        (push dclarg lamspecs)))))))
ation hacking.

re the
  ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Establish pervasively special declarations here
er than before bind.  In this way they don't
lization formÿ
d by 1988, even though

;;;;;;;;;;
d in a local SPECIAL
ocal bindings.
list, we don't care,
one the same
          ;
            ; there is a variable of the same name alreadyÿ
    ;
var (bindenv newenv))
                   (loop for binding in (bindenv newenv)
               unless (eq var (car binding))
 collect binding))))
riables for the environment.
nv newenÿ
;;;;;;;;;;;;;;;;;;;;;;
ake LAMSPECS side-effectable so that
LQ locally bound variabÿ
pecials without
       ;
vl (if lexprp (length l) l)
specs lamspecs nil)
   loop
l-alist) savespec)
null (cdr lambody))
           (multiple-value-prog1
 newenv nil)
        (zileval (zcar lambody) newenv nil)
 lambody))
Defined as a macro to keep local variables together.
rary corruption of the label's property list is

rves

     added to ÿ
s cruft.
 f)
     (progn (putprop lfun llaÿ
    ; This is what gets returned.
          (putprop lfun save-expr 'expr)

tes its binding component with
it from the lists
 the
fun zilapply-bind (bvl l q a locspecs lamspecs destructuring-p)
restarg c c1 c2 c3 aux-args-to-be-evaluated
p keylist)
l)         ; CDR of a dotted pair.
       (bind-error q
r syntax"))
Ö
      (if (llkeywdp c)       ; If it's a lambda list keyword
         (case c
             ((&rest &boÿ
     (go process-&aux))
               ((&allow-other-keys)
s-&allow-other-keys))
ist keyword" c)))
)          (go required-arg))
))
        (go aux-arg))
        (t (bind-error q "Misplaced lambda list keyword" mode)))

-p
   (setq bvl (cdr bvl))
                (zerror "Too few arguments" q)
darg c (zcar l))
  ÿ


addr c))))
bar gets evaluated in the environment built SO FAR by the BINDARG
d the evaluated value is bound to foo.
l l) (bindarg c1 (zileval c2 a nÿ
)
rg c3 t)
l))
(setq c1 c
q c1 (car c)
 . ,c2) aux-args-to-be-evaluated)
 loop)


r) 
 ((:var var) initform)
  (let (
orm)


               keyword (keyÿ
c)))
)
wordify var)))
r var))
     (t
rm (cadr c)
keyword (car var)))
o allow destructuring of &KEY vars.
variable)
;; (bind-error q "Invalid &KEY variable name" variable))
(and (symbolp suppliedp)

          (push (make-keychain

         initform   initform
                        value      keyspec
      (setqÿ
 (setq mode '&optional)
rocess-&aux
 (go loop)
REST arg" q))
    (go loop)
ec (ncons nil)) ;Unique arg to represent ÿ
r bvl))
&allow-other-keys)
r bvl))
as specified, then if there are any
;

othing - just ignore the extra subargs
(zerror "Too many arguments" q)))
      (when restarg
 keywoÿ
nreverse keylist))
r-keys was specified or
ed and is not NIL.
 on the CAR of NIL being NIL.
her-keys-p
          (car (getk l ':allow-otherÿ
)
(or p (go done))
    p (cdr p))
rror "Odd number of keyword arguments" q l))
:allow-other-keys)
            (go loop))

                       return x))
                (if allow-other-keys-p
 ÿ
  (go loop)
  (zerror "Key not defined" q k)
                +
pec)
             (setq p (cdr p))
done
th sup
                           (setf (keychain-value x)
           (zileval (keychain-initform x)
          a nil))
                else
               do
)
              when (keychain-suppliedp x)
arg (keychain-suppliedp x) sup)
e &AUX args if any.
..,
macro (which includes all other bindings plus those established
sly occurring &AUX args),
       (lÿ
    (bindarg c1 (zileval c2 a nil)))
arg (var val)
 
((null var)     nil)
              ; A symbol that is self-evaluating cannot be used
      ; as a lambda list variable.

         (bind-error q "Cannot use as lambda list arg" var))
   ((or (memq var locspecs)      ; Locally special?
 (specialp var))          ; Globally special?
          ; If the variable is locally or globally declared
 ; SPECIAL, delete it from the list of local bindings

         ;        SPECIAL, it would never have ended up on
;        the list of local bindings, so we could
onceÿ
rs of LOCSPECS.)
 consing, we do this only if
ame name already thÿ
ssq var (bindenv a))
                       (loop for binding in (bindenv a)
                 unless (eq var (cÖ ar binding))
          collect binding)))ÿç
s var val) (special-alist)))
Make "unspecial" by de-pervasive-specialing it.
 lamspecs) ; Must be side-effectable!!!
 val) (bindenv a)))))
ol" var))

                    (prin1 q)
             (princ "Unable to destructure into arg(s) ")
     (prin1 var)
rror "Cannot destructure value" val))
d var val q a locspecs lamspecs t))))
 (arg1 nil arg1?))
for "
         ,msg)))
     (zerror msg)))))
;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
EL expression, maybe the list is a macro
's try it out.
macro))
       (zilapply (macroexpand f) l a q)            )
recognized.  Do non-CL evaluation of CAR and try it.
         (zilapply-warning f)
<
                                            l a q)                  ÿ

sp (msglevel) 2)
on name ")
   u    (princ "Evaluating it for value to reapply.")



**************************
                     *
oratory Inc.     *
               *
           *
********
************************************
 of the compiler.  Note use of PROG to
cessed via the free variable
 as follows:
re: 
 Y (program) or N (function) for compatibility)
active) or N (debug mode not active)
program
 LISP source program.
erÿ
**********************
ng compiler for ZIL 1.2 to ZIL 1.3.
compiler to run iÿ
n of ZIL 1.3 code.
ff, etc.
********
À
the compiler.
n ")
ri) 
nc."
se only...
ZIL 1.3")
pri)
Ó
           ; Done via FUNCALL to allow ZILCOINT to be
 ; frequently recompiled without having to
he entire compiler each time.
tparm nil)))ÿ
-name (concatl (cddr parmlist)))
ar parmlist)
(F N)  'function)
     (t (zerror "Bad parmÿ


             Kind...............")

c  debug?)
     (catch 'zilcocom-error
-name kind debug?))
       (princ "*** Severe LISP error. ***")
)

                   0))
)
  (prD in1 comcode)

)

                                                                     *
 (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
   All rights reserved.                                        *
                                                           *
********************************************************
TANTSÿ
;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
coadd (a aa)   ; AA ÿ
l a) nil)                              ; Never add NIL to list
l)                              ; Never add T to list
tatom a))              ; Add A to lÿ
t a aa)) ))        ; Add A to list of lists

toms))
t
   (or (assoc a atoms)                    ; if not in our list
dq atoms dottedpair))           ; then add it to our list
                             ; Else not in global list
                        ; so add it to our list
                 ; (SYMBOLPAIR will also
ÿ
r)))
tq dottedpair (cons a (gensym)))         ; Always create a new list
ists dottedpairÿ
ists dottedpair)                  ; and also to global list
ottedpair) p 'referenced)    ; If directly referenced
                       ; then ÿ
                  ; Add CAR of pair to list
 nil))       ; Add CAR of pair to list
))      ; Show it's really used
   ; Add CDR of pair to list
Show it's really used
se...
m in the list to the list of atoms
 the list to the list of lists
onstants (l &aux q)
)) (setq q (zilcoadd (car l) nil))
dr q) t 'real)))
                     (if q (putprop (cdr q) t 'real))
(setq q (zilcoadd (cdr l) nil))
 t 'realì )))
utprop (cdr q) t 'real))
©
************************
                   *
atory Inc.     *
             *
         *
******
out of the argument list passed
O (A B C) ...)  results in call (ZILCOARG 'FOO '(A B C))
         which builds the following list:
 (C . G00003))
(GET 'G00002 'POSITION) ==> 2

  NIL - if there is an error in the argument list
 assigns properties to the named function:
d pairs constructed by this function
ÿ
gument if there is one, else NIL
he function is a LEXPR
lambda list.
It is
structuring works something like this:
llowing...
AUX (U 2))
      Plist of (CDR <--))
VARS ((A . G09)
                                          (C . G11)
                   (D . G12)
 G13)))
 3)
                         SUPPLIEDP (O? . G08))
 5)
(POSITION 7 OWNED T)
)
11)      (POSITION 10 OWNED T INIT (CDADR G01))
N 11 OWNEDÿ
IT (CDDDR G01))
	
 A) "a" A?))
          Plist of (CDRÿ
 KEY T KEYWORD :A INIT "a"
A? . G02))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ignore-list '(ignore ignored ignorable ignoreable
 *ignore* *ignored* *ignorable* *ignoreable*)
rg names that are not to generate

ructuring-vars*))
 argument list
mode opt aux auxvars restarg
st-ÿ
cturing-vars*)

: There is no possÿ
LEXPRARG" because (cdar argvars) is always a fresh gensym.
  (cond
                  (eq (pbind x) xÿ
princ "Error: ")
n invalid lambda list.")
n nil)))
))
rgs)
rs 'parms) ; Singleton, needn't nreverse.
rarg)
rn t)
om l)
             (go make-&rest-arg))
keywdp a) ; If it's a lambda list keyword
        (&optional         (go process-&optional))
 &body)     (ÿ
rocess-&aux))
                (&allow-other-keys (go process-&allow-other-keys))
         (t
ord: ")
                (return nil))))
e &REST.  If the mode was
TE-PARM.

s in lambda list.")
e-parm
n &optional or &aux mode.
ux
                      ((null init)

 (go bad-argument))
a (car a))
      (&optional
                     (cond
           (setq a (car a)))
             (go bad-argument))

   ((null (cddr init))
)
                (t
         (&key
                 (cond
         (setq a (car a)))
           (go bad-argument))
                    (setq a (car a) init (car init)))
(null (cÿ
„
            (t
     (t ; Mode not optiÿ
(setq init nil suppliedp nil))))
       (setq init nil suppliedp nil)))
 still a cons.  If it is still a cons
    (case mode
ars)
      (setq restarg (zilcoarg1 a nil nil))
            (push (cons a init) auxvars)
             (push (setq temp (zilcoarg1 a n '&optional init))
      argvars)
dp (setq temp2 (zilcoarg1 suppliedp nil nil))
push temp2 supvars)
suppliedp))
   +
aÿ
car a)))
ush (setq temp (zilcoarg1 a nil '&key init))
              (uÿ
 keyword is not a keyword: ")
  (terpri)
keyword 'keyword)
liedp nil nil))
                       (putprop (cdr temp) temp2 'suppliedp))
      (t

n nil)
	
ror: Duplicate \"&OPTIONAL\" in lambda list.")
        (return nil))
      "Error: \"&REST\" precedes \"&OPTIONAL\" in lambda list.")
   (terpri)
rinc

ncorrect.")ÿ
nc

orrect.")
      opt t)
       (go loop)
(princ "Error: Duplicate \"&AUX\" in lambÿ


(setq l (cdr l))
tq l (cdr l))
sing &REST arg in lambda list.")
o loop))
en (llkeywdp a)
t.")

      ÿ
   (princ
)
incorrect.")
incÿç
ambda list.")
orms may be incorrect.")
1- n)))
        restarg a)
   (when key

&key
in (setq min max))
ss-&allow-other-keys
 "Error: Duplicate \"&ALLOW-OTHER-KEYS\" in lambda list.")

allow-other-keys-p t)
process-return
    (setq restarg (zilcoarg1 (gensym) nil nil)))
n (1- n)))
rgs)

x)
restarg
 n 'position)

       (setq keyvars (nreverÿ
s do
ion)
; 
vars
 s in supvars do
 s) n 'position)
(push s argvars)
&AUX variables.
var . init) in (nreverse auxvars) do
         (push (zilcoarg1 var n '&aux init) argvars)
 ) 
    (when *destructuring-vars*
rse *desÿ
 do
on)
setq argvars (nreverse +
op for l on argvars
           )
pbind a) a))
               (princ " is an invaliÿ
  (terpri)
when (and (assq a (cdr l))

     (princ " is a duplicate lambda list argument.")
Å
 

rinc " is an invalid lambda list element.")
 nil)
ÿ

putprop a init 'init))
 'optional)
                (putprop a t    'key)
))
              (putprop a init 'ÿ
d v (atom v))
r null or a list, destructure.
       (get-destructuring-stuff p v)
-destructuring-stuff (p v) ; p = the pair, v = the de-form
(vars (build-destructure-list (car p) v nil))
p) (nreverse vars) 'destrvars)))

§
t so far
her-keys-p
hen (null b)
    (let (
           ÿ
         (push x c)
etq d (car b))
         (&optional       ÿ
(&rest &body)     (go destructure-&rest))
  (go destructure-&aux))
-&key))
eys))
ror: ")
upported lambda list keyword.")
     (throw 'lambda-list-errors nil))))
  then
  (setq init (cdr d) suppliedp nil)
       ((null init)
       ((or (atom init) (cdr init))

          (setq init (car init)))))
            (setq init (cdr d) suppliedp nil)
                 ((null init)
               ((atom init)
         ÿ
(car init)))
(psetq d (car d) init (car init)
edp (cadr init)))
gument))))
uppliedp nil)


))
    ((null (cddr init))
t)
           (t
  (t ; Mode not optional or aux, just required arg
 init nil suppliedp nil)))
dp nil)
(&key

    (setq keyword (keywordify (car d)) d (car d)))
yword (keywordify d)))
     (princ "Error:ÿ
 keyword)
s nil))
          (go continue)
„
estructured variables.
e horrible, especially for
rticularly for
 a
; rarely?  Common LISP doesn't even require it except for
nyhow.
  ((nil)     `(car ,a))
t)))
       (t
fter ")
    (throw 'lambda-list-errors nil))))
 mode '(&optional &aux &rest)))
           (ÿ
ush x *destructuring-vars*)
   (setq form g))
rm d c))
 nil)))

 c)))
 b (cdr b))
hen opt
ng lambda list."
hrow 'lambda-list-errors nil))
rror: \"&REST\" precedes \"&OPTIONAL\" in destructuring lambda list."
      )
l))
&OPTIONAL\" in destructuring lambda list."
rpri)
       ÿ
     (go continue)
      (princ
          )
s nil))
 (setq restform a))
      (when rest
ructuring lambda list."
   (throw 'lambda-list-errors nil))

         )
s may be incorrect.")
            rest t
           (princ
REST\"."ÿç
      (throw 'lambda-list-errors nil))
ure-&key
&KEY\" in destructuringÿ
i)

ntinue)
r-keys-p
structuring lambda list."
     (throw 'lambda-list-errors nil))

ent
n invalid destructuring lambda list element.")
hrow 'lambda-list-errors nil)

et ((x (zilcoarg1 restarg nil 'destructuring restform)))
x *ÿ
tform restarg)))
do
,g (getk ,restarg ÿ
                     (,g (car ,g))
)
                 (x (zilcoarg1 g ÿ
     (push x *destructuring-vars*)
                (setq ff g))
ure-list ff dd c))
getk ,restarg ',kk) t) (t nil)))
destructuring ff)))
                  (push x c)))

*******************************************************
                                                  *
 The Charles Stark Draper Laboratory Inc.     *
ved.                                        *
                                        *
*************************************
*********************************************
                                        *
                                    *
 ÿ
*******************************
 variable to the list of atoms and
riables.  Argumeÿ
e to be added
 creates an atom for the variable.
air to return to the caller.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
acs))
;;;;;
(let ((atompair (zilcoadd varname nil))  ; Create an atom for it
ing  nil)
's really used
d variables and to the
 ; Which list depends on whether the variable was declared to be
 or not (if it was not declared, it attains one of these
generally SPECIAL).
AL
ly SPECIAL, then mark the
 variable iÿ
ssociated binding FLUID so it'll get compiled
he name "FLUID" is a misnomer, but
ZIL in the bad old days.
red and unbound variable.
ecial or fluid, assign it
the default-binding
on time).
binding ...)) specification.
ompair special-freevars) ; Globally or locally special?
ame (zilcec-specials (car e))))

 e))   ; Heap-consed lexical funarg?

ec-bindings cec)))
 'fluid)
      (zerror "Binding has no owner" binding))))
    ÿ
ng ")
           (princ "Atompair: ")
         (terpri)
rin1 owner)
ms so far: ")
          (terpri)
(car owner) 'newatoms)
Ó
ing (cons varname (gensym)))
)
          (cterpri)
e, assuming ")
    (prin1 varname)
Î
    (modq body


at are unbound specials in this function.
inding, add thÿ
 this function.

 special-unbounds atompair)))ž 
-unbounds)
ng ; Return the "fake binding" pair.

*

*         All rights reserved.                                        *
                                                                  *
***************************************************************
ZILCOCOM"

 in file "SRC", contains inline code and
y "DEFUN").
h "DEFUN" encountered at the top level causes
compiled.
or a stand-alone function is to be createdÿ
operties are now recognized by the compiler at
well as CMACRO properties.  This means
 at compile time create macro
pilation; there is no
ported for
y

                                                                    *
ge activity:                                                    *
       ÿ
 Top-level PROGRAM transform now output to CTRN file.     *
port for PROG and RETURN removed.  ZCCFPRT absorbed.  *
                      ÿ
*************************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ource-member zilmacs))
;;;;;;;;;;;;;;;;;;;;;;;;
lfatoms numatoms alllists
debody
 kind debug)

       alfatoms
evars
   (setq c        (list nil)
al contour,
 e+
ÿ
s (list nil)
         alllists (list nil)
 intfuncs (listÿ
trn)
UNCALL will never default to NIL, always T.
be phased out, as AUTOSPECIAL ÿ
error-code)
'fname)
ny input


ally defined macros.")

 file.")
ch nil (top-level-compile a c exec fname e))
h
nil)
ads all
 functionsÿ
lcocom-process-module c exec fname e)

e on source input may be ÿ
level macros cannot generate this call.
etq a (read 'src)))
loop)))
go finish))
p)
-code) (go blowup))
    (princ  ";;; *** Compiler transformations generated follow ***"
        'ctrn)
 
we
   (dolist (x (cdr c))
	
(setqÿ
tput file is present,
(when ctrnp
 function definition.  of " 'ctrn)
 (terpri 'ctrn)ÿç
pprint cexpr 'ctrn)
ze the parameter list and establish the number of arguments
s
(princ "Error: Bad argument list for function ")
terpri)
  (princ "Initiating P-code phase of compilatÿ
ri)
 (if (cdr codebody) ; If top-level code was found
it should have been), compile a "program".
da () ,codebody) debug))
         z    ; transformed top-level program
 MAIN = YES
        (cons (zccmkcec 'defun e) e)))
terpri 'ctrn)
ctrn)
          ÿ
  (terpri 'ctrn)
se
 source code.")
owup)
iled
rror: Missing or invalid function definiÿ
)
¤
  (if debug (dump-compile m))
 program " "Main function "))

        ; Compile all subfunctions.
Don't compile macros.
function.
           (modq defuns y)

         (prin1 x)
get '*zilco* 'error-code) (go blowup))
ut))
   (terpri)
/pgm.
"function "))
;;; Generate code for all functioÿ
 (x (cdr defuns))
d for function ")
i))
ND" 'code)  ; Generate assembler END statement.
e 'code 'output)
(princ "Compilation terminated due to errors.")
ilcocom-error (get '*zilco* 'error-code))
****************************************************
oadlist complist)) ; for ZILCOMOD.
xec fname e)
setq form (read 'src)))
go check-it-out)
if   (or (eofÿ
 loadlist (nreverse loadlist)



                     (princ ,(string-append "Loading module "
                                      fnameÿ
     (terpri)
                       ,.loadlist  ; forms executed at load time
                  ',fname ; return name of function as valÿ
               )
     (terpri)
                   (terpri)
   (princ "Main (loadable) function follows:")

           (terpri)
"Other (ÿ
           (terpri)
ri))
         (princ "End moÿ


          (return)
       (go loop)
*********************************************************
nction handles anything (other than (END)) that can o† ccur
It is invoked recursively when a (PROGN ...)ÿç
untered, which specifies that all forms within it are
level (which enables DEFUN, etc.)
 at compile time
signifies a function definition.
evel things.
 ((a (zilcomex f t)))  ; top-level form after macro expansion
 ((atom a)                (princ "Ignoring atom ")
  (prin1 a)
                         (terpri))
q (car a)ÿ
  (zilcocom-defload (cdr a) fname e))
efun a c exec fname e))
a) c exec fname e))
                         (top-level-compile x c exec fname e)))
               (zilcocom-other a exec e)))))
a c exec fname e)
; COMPILE - let the compiler evaluate it itself.
;
      ((times . forms) a)
))
 (loop for f in forms
            when loadp    do (top-level-compile f c exec fname e)
    finally       (return nil))))
e)
ddr a)
 
 (unless (and func (symbolp func))
ction name - ")
lcoerr 12) ; Set erÿ
and exec (eq func fname))

    (terpri)
n nil))
; If the DEFUN was read from the macro file, assume it is a compile-time
FUN unless it is a DEFUN of a macro.
os (neq args 'macro))

dy) body))
body))
compiled - ")
eturn nil))
°
prin1 ftype)

; or a list of more than 1 argument where the first is NIL
ing generateÿ
If a macro definition
)))
unc)
 
 
ning: DEFUN overriding system definition fÿ
       (terpri)
'cautoload)
 ftype 'cexpr)       ; Don't lose these properties if
nc 'minargs)      ; a macro overrides a known ZIL
xargs)      ; function.  Someone may DEFLOAD
)      ; to the known function name.
user 'defined-by) ; Say defined by user.
     (princ "Error: Function ")
 multiply defined in file.")
       ÿ
ine the function to the compiler.
) ftype)


     (if program             ; then if program name already set
                   ; (may have been dÿ
ror: Duplicate main function ")
c " defined in input source.")
12)
func)
Add function to list of functions
 'cmacro) "Macro" "Function"))
    (prin1 func)

oerr 12)
ci+
¦ x)ÿç
 few arguments to DEFLOAD")
  if (cddr x)
(terpri)
ar x))
argument(s) to DEFLOAD")
  (when (eq (get (car x) 'defined-ÿ
DEFLOAD overriding system definition for ")
        (terpri)

    ;

oobarbazfrob (x) ...)
autoload)
prop (car x) (get (cadr x) 'predicate) 'predicate)
 (cadr x) 'compiler-transform)

eq program (car x)))
ction ")
ned.")
lse
         )
  (princ "Error: DEFLOAD not ÿ
name)
)
lid
(defun zilcocom-other (a exec e)
    (princ "Input other than function definition found.")
i)
rpri)
)

(prin1 (get m 'name))
 (pprint (symbol-plist m))
 follows:"
 begininlÿ
nline      tailrecur endlam))
       (get m 'tailrecur) nil nil)
:"
ws:"
ble follows:"
e follows:"
L variables follows:"
"Dump of non-local SPECIAL variables follows:"
unbounds)) nil nil)

l functions follows:"
PRINT"
 fact, it prints out any list in readable format.
msg l in out)

)
  ÿ
il)
o)  (setq n2 (setq n (sub1 n))))
 (car l))
 
;
generate a new name and
eneration is
;

***********
      *
  *
*


ven form is "constant"
IL if not, and a CONS whose CAR is the value of the

;        future may be set to the type of the constant.
eason, the environment E must be passed, in
declarations or other meaningful


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
fvar zilcocon-type nil "Eventually will be T or (TYPEP object)")
efun zilcocon (x e)
(pbind x) x))
on³ -type))
p (cdr x))

************************************************
                                           *
arles Stark Draper Laboratory Inc.     *
                                     *
                                 *
******************************
**************************************
                                 *
ial form, when it occurs     *
lled by ZILCOCOM.          *
                       *
********************
.
*********
    *
*
<
*                                                                     *
***************************************ÿ
.
Æ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  the (headless) body of the DECLARE form
am, NIL = function
)
ll when this module is
d from
e it may prove to be wiser to have
ouldÿ
.
cess (a exec e) ; a is a subform within the DECLARE,
          ; e.g. (Sÿ
) (declare-error "Illegal DECLARE subform " a))

                       (declare-prÿ
   ((pdsize
   (declare-process-size a exec))

                        (declare-process-prop (ÿ
     ; BASEREG is obsolete.
ocess-basereg (cdr a)))
s-segment (cdr a)))
nocompile (cdr a)))
'*zilco* 'unknown-declarations))
* 'unknown-declarations))
(princ "DECLARE (") (prin1 (car a))
y the ZIL compiler.")
))
***
*

                           ÿ
*******************************************************************

eclare-process-variable (a type e)
rs (list nil))
ror (string-append "Invalid DECLARE " type " variable")
)
ables.
Á
cial
modq special-freevars c)))
*********************************************************
                                                    *
ses xxSÿ
                                              *
*******************************************
size (a exec)
eclare-error "Missing declaration value" type))
 "Too many declaration values" type))
ion valid in PROGRAM only" type))
-value (car z)))
)
 
olp x)
      (xval (make-number (string-substr x 1 (1- xlen))))
ing-substr x xlen 1))
gerp xval))

f "M") (* xval #.(* 1024 1024)))
ecification" x)))))

*****
*

* e.g. (DECLARE (SEGMENT (FOO 2) (BAR 3) (BAZ 1)) ...)                *
                                                                  *
****************************************ÿ
defun declare-process-segment (a) ; process function segment declares

 "Invalid DECLARE SEGMENT spec" a))
(cond
DECLARE SEGMENT spec" a))
    (< num 1))
)
;***********************************************************************
                                                                   *
functÿ
                                                             *
RE (NOCOMPILE FOO BAR (BAZ SETFMETHOD) ... ) ... )       *
                    ÿ
****************************************************
r memqual) ; We use MEMBER with an EQUAL test.
compile (a) ;
l)
*****************************************************************
                                                  ÿ
ion processes miscellaneous properties of *ZILCO*.        *
 (AUTOFUNCALL T)) == (DEFPROP *ZILCO* T AUTOFUNCALL)  *
                                                  *
*************************************************
-prop (prop vals e)
ion value" prop))
ÿ
***********************************************************************
                                                                  *
acro reports on+
t true errorsÿ
nue in any case.                                          *
                                                      *
****************************ÿ
lare-error (arg1 &optional arg2)
stringp arg1)
   ((and (consp arg1)
)
               (zerror "Arg 1 to DECLARE-ERROR not a string" arg1)))))
gn (cterpri)
)
.
**

;*                                                                     *
.g. (DECLARE (BASEREG (FOO 2) (BAR 3) (BAZ 1)) ...)                *
        ÿ
**************************************************************
fun declare-process-basereg (a) ; process function basereg declares

rror "Invalid DECLARE BASEREG spec" a))
    (cond
valid DECLARE BASEREG spec" a))
     ((2 3 4) (putprop fun num 'basereg))
op fun 'basereg)) ; 1 is the default
nvalid DECLARE BASEREG spec" a)

***********************
                  *
tory Inc.     *
            *
        *
*****
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 zilmacs))
;;;;;;;;;;
de)))
ode 'error-code))))
*******************************************************
                                                  *
 The Charles Stark Draper Laboratory Inc.     *
ved.                                        *
                                        *
*************************************

;*                                                                     *
hange activity:                                                    *
 ÿ
8 - Support for determination of superfluous initializations *
of PROG and &AUX variables to NIL.  This involves two    *
fields in the coÿ
ariable unconditionally being set before it is     *
enced.  This is an extension of, and replaces, *
alization-hacking scheme used iÿ
es a new P-code form, CSETNIL, and a new *
e, ZCGCSNIL.                         *
GBODY.                           *
-LIST and MULTIPLE-VALUE-BIND. *
moved.                     *
                       *
**********************
;;;;;;;;;;;;;;;;;;;;;;;;;;;


rog
of the procedure currently being compiled
the programÿ
the pgm
m
onstant lists referenced bÿ
 invoked by the program
ong with the rest
sion time
label for tail recursion from a PROG with special vars
or maximum stack size
rator

  alone     ; T if program is a stand-alone function, NIL if executable
bas     ; offset into stack, past caller's args, of initial saves
  ; offset into stack, past initial saves, of locals & args
maximum stack size used at any point
m stack levels

ved ÿ
nt register if applicable
 ZCGEMIT
 (setq body      (gÿ
       parms     (get p 'parms)
-unbounds)
   atoms     (get p 'atoms)
     subrs     (get p 'subrs)
     tailrecur (get p 'tailrecur)
   zzzstksz  (gensym)

; Note that the following registers are never available...

 current pointer into the stack
3 - the common area pointer
Ä

tialized by ZCGBEGIN.
; PDMAX     is initialized by ZCGBEGIN.
CGBEGIN.
ID-ASAVED    is initialized by ZCGBEGIN.
ed by ZCGBEGIN.
olist (x regs) (putprop x 0 'ÿ

 (setq body (cdr body))
h generation, generate code for LAMBDA procsÿ
cdr procs))
r each thing in list.
e verb
gs))

    (endlam       (zcgelam  args))
  (call         (zcgcall  args))

gs))

    (ÿ
  (error        (zcgerror args))
etparm ;;;;;(zcggetit args)) ; formerly zcggtprm
args)) ; formerly zcÿ
gstatm
      (zcggetit args)) ; formerly zcgstnil
 ; formerly zcgsett

   (subr         (zcgsubr  args))
optional     (zcgopt   args))
ys         (zcgkey   args))
       (zcgmvini args))
 found by code generator"
tions moved to ZILMACS.
***********************************************************
                                                      *
1989 The Charles Stark Draper Laboratory Inc.     *
eserved.                                        *
                                            *
*****************************************
*******************************************
 initialization routine, called to establish
ts used by the compiler, and to perform
cros ÿ
********************************
**************************************
                    ÿ
                               *
                           *
tions.                 *
tions list.          *
MEMBER.          *
             *
           *
gs     *
   *
 *

            and added VALUES and VALUES-LIST.                        *
ÿ
      Removed THROW, which is now a special form.              *
- Added XLATE (a.k.a STRING-TRANSLATE) and ZFSEXEC.        *
 LDIFF, reader ÿ
ore reader-related functions, CHARP.                 *
CII.                                             *
                              ÿ
********************************************
ing a new built-in function:
(2) Add it to ZILMODS.
(4) Add it to help member $HELP.
w special form:
) Add it to ZILEVAL.
LCOTRN.
e it.
member $HELP.
;;;;;;;;;;;;;;;;;;;;;;


rg) body
trans ,fÿ
) (zerror "Too few arguments" ,z))
s" ,z))
)))))
.(progn 
bler labels.
                      zilopts zilpdsizÿ
             zilatoms zilatome zillists zilliste
t zilvsym zilxdef zilxlfy
ms.

(when (get x '×SPECIAL FORM×)
 x formlist))))
ial forms that will be defined to the compiler ~
 special-forms)
ine calls.
indÿ
         ; Accessor functions
; ZIL-only accessors
 functions
t"
 zilunbnd                              ; The "unbound marker"
                                ;ÿ
                           ; Fast call to common
                   ; List loopers
 the predicates
NGE THIS!!!
cates
         atom numberp symbolp fixnump floatp   ; Type predicateÿ
  consp listp
fixp integerp funargp
))
fun zilcoint (&aux (infuns '#.inline-funcs))
t up the function lists used by the compiler.
rved       'reserved)
 (putprop '*zilco* '#.special-forms  'special-forms)
e default binding technique to be SPECIAL.
.......)) can override this.
ing)
nds
nfuns
built-in in-line code.
NOTINLINE ...))
s
predicate)
are sometimes
te)


for standard LISP functions as shown below.
             (let (((fun min max rst) x))
min 'minargs)
             (putprop fun rst 'restarg)))
 1 nil)
        (alphacp  1 1 nil)


 (assql    2 2 nil)
 nil)
        (boundp   1 1 nil)
    1 1 nil)

 (charp    1 1 nil)
 nil)
      (codep    1 1 nil)
    2 2 nil)

cssize   0 0 nil)
 nil)
      (defrdmac 2 2 nil)
  2 3 nil)

 (ebcdic   1 2 nil)
 nil)
      (eq       2 2 nil)
  2 2 nÿ
 05/22/89
          (every    1 1 t  )
lode  1 1 nil)
l)
   (featurep 1 1 nil)
 2 nil)
          (fixp     1 1 nil)
atp   1 1 nil)

   (funcall  1 1 t  )
 1 nil)
        (gcmsg    0 1 nil)
sym   0 1 nil)

 (getk     2 3 nil)
 nÿ
        (haulong  1 1 nil)
de  1 1 nil)

 (intrq    2 2 nil)
 nil)
      (land     2 2 nil)
    2 2 nil)

llvars   1 1 nil)
 nil)
      (lognot   1 1 nil)
  2 2 nil)

makunbou 1 1 nil)
il)
      (memqual  2 2 nil)
1 1 1 nil)
           (minusp   1 1 nil)
atom   1 3 n† il)
il)ÿç
 2 nil)
        (mkstruct 2 2 nil)
vel 0 1 nil)

 (notevery 1 1 t  )
 nil)
        (null     1 1 nil)
t   0 0 nil)

 (parsbody 1 3 nil)
 nil)
      (plusp    1 1 nil)
    1 2 nil)

prefix   0 0 nil)
 nil)
      (prin1    1 2 nil)
  3 3 nil)
           (rÿ
readch   0 3 nil)
il)
    (remprop  2 2 nil)
  2 3 nil)
           (revappen 2 2 nil)
verse  1 1 nil)
il)
    (rot      2 2 nil)
2 2 nil)
           (salist   0 0 nil)
ppendl 1 1 nil)
)
    (setascii 0 1 nil)
2 3 nil)
         (setnfeat 1 1 nil)
list 2 2ÿ
)
  (sfloatp  1 1 nil)
1 nil)
         (sort     1 ÿ
emove  2 2 nil)
)
  (string   1 1 nil)
1 1 nil)
         (subrp    1 1 nil)
tql  3 3 nil)
)
  (symbolp  1 1 nil)
2 nil)
         (truncate 1 2 nil)
     0 3 nil)
À
(ÿ
2 nil)
       (upcase   1 1 nil)
   0 0 t  )
À
(verify   2 3 nil)
nil)
       (vset     3 3 nil)
   1 2 t  )

(zcprint  3 3 nil)
nil) ; READ-DELIMITED-LIST

 (zerop    1 1 nil)
evauto  1 2 nil)
l)
     (zevinit  0 0 nil)
 3 3 nil)
          (zevxvar  1 4 nil)
pars  1 1 nÿ
l)
   (zifasin  1 1 nil)
 1 nil)
          (zifsin   1 1 nil)
tan   1 1 nil)

   (zilcocon 2 2 nil)
         (zildsni  1 1 nil)
ump  1 1 nil)
À
  (zilfix   2 2 nil)
2 nil)
       (zilmul   2 2 nil)
   1 2ÿ
À
(zilsprt  1 1 nil)
nil)
       (zilunbnd 0 0 nil)
o  2 2 nil)

(zmstruct 1 1 nil)
nil)
          (peekb    1 1 nil)
eekl    2 3 nil)
l)
Õ
hey need to be made known to the compiler in case functional
 generated using them.
c    2 2 t  )
Àÿ
  (flatc    1 1 nil)
2 nil)
       (mapatomsÿ
an   1 1 t  )
À
(mapor    1 1 t  )
1 nil)
       (structur 0 0 t  )
   0 0 t  )
(def-1-arg-trans concatl     (x) `(zilimpl ,x t nil))
atl    (x) `(zilimpl ,x nil nil))
 ,x nil))
-trans make-number (x) `(mkatom ,x nil t))
`(mkatom ,x nil t))
f-1-arg-trans endp        (x) `(null ,x))
s implemented as open code because they take
an operand.
 (deftrans mapc     zxmap)
zxmap)
 mapcon  ÿ

ng functions are implemented under the compiler
often avoiding calls to ÿ
s.
trans boole   zxboole )
list  )

    (x) `(car (cdr . ,(cdr x))))
cdr x))))
ns caaar         (x) `(car (car (car . ,(cdr x)))))
(x) `(car (car (cdr . ,(cdr x)))))
ar . ,(cdr x)))))
))
cdadr         (x) `(cdr (car (cdr . ,(cdr x)))))
 `(cdr (cdr (car . ,(cdr x)))))
. ,(ÿ
dr x))))))
 
ns caaddr        (xÿ
        (x) `(car (cdr (car (car . ,(cdr x))))))
 `(car (cdr (car (cdr . ,(cdr x))))))
 (cdr (car . ,(cdr x))))))
r . ,(cdr x))))))
))))))
(deftrans cdadar        (x) `(cdr (car (cdr (car ÿ
 cdaddr        (x) `(cdr (car (cdr (cdr . ,(cdr x))))))
    (x) `(cdr (cdr (car (car . ,(cdr x))))))
dr (cdr (car (cdr . ,(cdr x))))))
cdr (car . ,(cdr x))))))
,(cdr x))))))


cdr (zcdr (zcdr . ,(cdr x)))))
r (zcdr . ,(cdr x))))))
,(cdr x))))


ithmetic functions implemented as macros.
 (x)   (zxaÿ
th (cdr x) 'zilsub   0))
mul   1))
deftrans remainder     (x)ÿ
 gcd           (x)   (zxarith (cdr x) 'gcd2     0))
     (x)   (zxarith (cdr x) 'ziladd   0))
rith (cdr x) 'zilmul   1))
'zilrem   1))

trans min           (x)   (zxarith (cdr x) 'min2 nil 'miÿ
 logand        (x)   (zxarith (cdr x) 'land    -1))
(x)   (zxarith (cdr x) 'lor      0))
(cdr x) 'lxor     0))
ual ))
             (x)   (zxrelop x 'lessp    ))
relop x 'nlessp   ))

 0)
ilsub 0))))
ll x)       1)
   (zxarith x 'zildiv 1))))
or Special Forms =============
s cond     zxcond )
rogn)
============ Compiler Transformations For Accessors ===============
ftrans car          zxcarcdr)
ns plist        zxcarcdr)
r         zxcarcdr)
Compiler Transformations For Predicates ==============
l    zxequal)

Compiler Transformations For Arithmetic Functions =========
eÿ
 (deftrans round    zxfix)
dd   zxbinop)

h      zxbinopÿ
)
ftrans log      zxlog   )
  zxsub1  )
===========
 )
======== Compiler Transformations For Arithmÿ
=== and Similar Functions that Can Be Constant-Folded =======
lambda (x) (putprop x 'zxarfun 'compiler-transform))
 alphacp
ep

    floatp
      haipart   ; at least until it has its own transform

as its own transform
; yes, chÿ
canner
   logcount
 own transform

2
         mkfixnum
      numberp
 slength
ymbolp
erify
ix
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
, may return an uninterned symbol
shing algorithm changes?
;;;;;;;;;;;;;;;;;;;
t beÿ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
char-downcase charup char-upcase downcase string-downcase
pend sappendl strinÿ
t-trim sremove string-remove
im strim string-trim
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ü ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Other Functions ============
ansforms have been defined.
 are automatically known as
 all DEFLOADed functions;
reof.
 is true that all interpreter macros are compilÿ
 all "officially" autoloaded functions are also
h the analogous feature.
        ;;;(when (setq y (get x 'macro))
p x y 'cmacro)
q y (get x 'autoload))
                     (putprop x y 'cautoload)
utprop x (get y 'builtin) 'inline)
 y 'predicate) 'predicate)
void GETL lossage
d for othersÿ
sform))

 this function are flagged

 ; True if system function
ue if system macro
special form
AVORS
¤
                    ))


;*                                                                     *
IL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
     All rights reserved.                                        *
                                                             *
**********************************************************
 like Mÿ
only to the compiler).
at is not
PUN".
Ô
.g. DEFMACRO).
ompiler at
eans
            definitions that are used in compilation; there is no
  way to avoid this.  CMACRO's are still supported fÿ
bility and as a means of defining compiler-only
 functions.  See ZCCEVAL.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



 &ÿ
                        form) ; Not a list
       form) ; Not a valid name
) ; Defined as fuÿ
macro))  ; It's a compiler macro
) ; It's a regular macro
a form seen at top level,
und inside code.
ne by
; only if the expansion of the form had failed.ÿ
al an error in that case.
c-lam m form prop tlvlp) tlvlp)
                                  form) ; Not a macro call
un app-mac-lam (m form prop tlvlp &aux z)
op)))
ether top-level or not, since BODY will be bound

cro expansion failed" form))
ailed" ,form))
**********************************************************************
                                                                 *
 Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
ll rights reserved.                                        *
                                                       *
****************************************************
nÿ
module"
; executed by typing (foo) under the interpreter, does the operations
ally expected byÿ
ILE.  In other words,
xpansion.  Note:
o any
 
f a form is a DEFUN, assigns the compiled definition to the
perty of the symbol.  Exception: if the DEFUN ÿ
 made known to the compiler only.
s to a DEFUN for a macro, so
 made known as a "free" variable to the
ted at load time.
 is.
L-WHEN, processed as follows:
e compiler itself only.
AL-WHEN (EVAL)    - ignored.
o be executed at load time.
this...
) (y) (hair))   ;    2
nk")                    ;    4
(defvar pi 3.1415926)     ÿ
   7
(eval-when (load)
val)
main function form will be (more or less):
.zdef foo1)                               ; 1
ROB×) 'frob)      ; 2
- expanded MAC
zevxvar 'pi 3.1415926)                               ...
(lambda () 3.1415926))       ; 6
       ; 7
foo
ess):
×BAZ FROB× (y) (hair))                 ; 2
 ,x)ÿ
             ; 6
eval-when (compile)
 )
ored
tes
	

      that DEFMACRO's evaluated at compile time create macro
initions that are used in compilation; there is nÿ
d this.  CMACRO's are still supported for
 means of defining compiler-only
e ZILCOMEX.
;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
oad member memqual) ; We use an EQUAL test for MEMBER when

loadlist complist))
-prop arglist defun-rest defun-name)
              ÿ
l)
q (car form) 'defload)   (go process-defload))
n)     (go process-defun))
-defvar))
      ((eq (car form) 'progn)     (go process-progn))
 (car form))
 (or (get (car form) 'macro)

                         (push form loadlist)))
process-defun     ; form = (defun ...)
e interpreted function definition
 that names the function.
s definition has

pecified, then the function will be on the "NOCOMPILE" list,
le the de  finition.

 (desetq (nil defun-func . defun-rest) form)
efun-error))
  ;
(setq defun-prop (car defun-rest)
n-rest (cdr defun-rest)))
expr))
o with DEFUN
            (case defun-prop
'*zilco* 'nocompile))
   (princ
f ")
  (terpri)
)
glist defun-func arglist))
      (princ
glist, "
;;                        )
;                        (terpri)
,(cÿ
    (push
unc))
                 lÿ

 (setq defun-rest (cdr defun-rest))

                 )
lable, will compile code to execute "
        (princ defun-func)
t into a macro."
;;;;;;;;;;;;;;;;;;; (push `(xdefun . ,(cdr form)) loadlist)
    (let* ((fexpr-subr (concat defun-func " FEXPR"))
      (fexpr-macro

                      `(,',fexpr-subr `,',x)))

                     ,(car defun-rest)
   . ,(cdr defun-rest))
             +
         (pÿ
fmacro . ,(cdr fexpr-macro))
                         (eval fexpr-macro); Also make macro def avail
               ))
dr form))
 defun-rest) form)
  (if  (member (cadr form) (get '*zilco* ÿ
                 (princ
e definition of ")
terpri)
               '(lambda . ,defun-rest) ; Note, no #'.
          ',defun-prop)
                             ; ZILCO will compile #'s.
tq defun-name (concat defun-func " " defun-prop))
tprop ',defun-func
                         (subr ,defun-name)
',defuÿ
(defun ,defun-name . ,(cddr form)) complist)
  )
(return)
alid DEFUN syntax: ")
turn)
ocess DECLARE right here & now.
n't wait for the compiler 2 C it.
	
complist)
orm (cdr form))
nc "Too few arguments - DEFVAR")

             loadlist))
xvar ',(car form)
)))
(ÿ
k (cadr form))
adlist))
ons 'defvar formÿ
       (push `(declare (special ,(car form))) complist)

      (return)
as follows:


     (compilep            (memqÿ
          (memq 'load    times))
 in forms
  when loadp    do (zilcomod f e)
 nil)))
nk (x)
onsp x) (eq (car x) 'quote)))
)
*************************************
                                *
 Draper Laboratory Inc.     *
                          *
                      *
*******************
***************************
                      *
                  *
                *
tiple       *
s.      *
      *
***
;;;;;;;;
;;;;;;;;;;;;;ÿ
vp (v s)
ll s)  nil) ; Not if evaluated for effect only.
 evaluated for return value.ÿ
 s1
get s2 'rettarg)))
           ((throw)
se nil))))))
************************************************
                                           *
arles Stark Draper Laboratory Inc.     *
                                     *
                                 *
******************************
 suitable for inclusion in an
mpersands are doubled.
character symbols.
;;;;;;;;;;;;;;;;;;;;;;;;;


with an oÿ
setq z (car a))           ; A character of the input atom.
eq z '\')       ; If it is a quote mark
r it is an ampersand

 a))
 the closing quote mark.

****************
           *
c.     *
     *
 *

tation", which is a means
eries of subfunctions
 the supply of
ollows:

are replaced with their bodies, which are
 body (a list of forms).
. (QUOTE something))
st form of
p (1) is no longer required, as the body has been
ompiler-transformed, and PROGN-flattened

  (a) Tÿ
he number of segments desired (specified in a DECLARE)
ng the total number of forms by this value.
he body are then used ÿ
t 1", "name segment 2", etc., which
c. of the flattened body.
 is replaced with one
eturn.
ts, otherwise a problem is
eferenced in the
d from ZCCFUNC with the following operands:
    funname    -  the symbol naming the function to segment.
bdaexp  -  the lambda expression being the function def.
ntno  -  the number of segments desired.
permissible for the number of segments to be 1.
 wish to separate the program code from
adÿ
*************************
                    *
                *+
              *ÿ
n warning.  *
        *
*****
;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
oseg (funname lambdaexp segmentno)

n-null arglist"
  . ,(segmentize funname bodd segmentno))))
 seg)
    ((> seg length)
1)
\ length seg)) 0 1)))))
       (s 0)
     z
))
g t s seglen))
          (setq s (1+ s))))
           (push `((labelÿ
                    (lambda () . ,(nreverse segment))))
Å

tten-body (mapcar #'fexpand bodd) t)
ave-last-form-p)

cond
              (and (eq (car x) 'quote)
    (consp (cdr x))))
orm-p)
                 nil)
'progn))
     j                       (eq l lastform)))
Ç
±
***********************
                  *
tory Inc.     *
            *
        *
*****
ropriate for an IBM external name.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
lmacs))
;;;;;;;;;
ympair-atoms f k) )
        (zerror "Invalid arg 2 to ZILCOSYM" K))))
 (f k)
)
 f)     (sympair-alpha   f k))

 a (assq f alfatoms))  ; If it's already an atom
                   ; then return existing pair
q f allsubrs) ÿ
s))  ; (could be found in either half)
gensym) atoms alfatoms) ; then create a symbol
                   ; else tryÿ
name f k) atoms alfatoms)

r name.
y a subr
sting pair
om currently exists
ame name as our
ded) subr
m


 ; Get list of all atoms for this function.
    ; At ÿ
oms numatoms)))
 (eql f (car m))      ; If the types match and values are equal
n m))                   +
    ; Else try next paÿ
2)
)
 (e l)
lodec f))
        (putprop g (zilcoquo e) 'quoted)
remprop g 'location)
      (putprop g t 'real))
)

un sympair-name (f k)
g (e l g)
 (if (and (eq k 'atoms)
  ÿ
ensym)
 not be zero

                      "@#$ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"))
 (< (car e) "0")                 ; First must be alpha or
ar e) '\#)               ;      ÿ
(substr f 1 3) "ZLC")); Name cannot begin with ZLC
(car e) '\G)      ;      or look like a GENSYM
tring-verify (string-substr f 1 6)
   "0123456789" 2))))
if
d)
 naming conflict between a subroutine name and an atom
ust be resolved in favor of the subroutine.
 name and the existing atom name.
  ; Create a new symbol for existing atom
ties to new symbol
rop g (get f1 'length)   'length)

 'indirect)
 atoms))
 (rplacd z g))
subr
))

************
       *
   *
 *

°
d it to the list in ZEVINIT.
 to FEXPAND.

piler transform implementer.  It takes a LISP form
dewalk, transforming ecah form within it.
ists of the following steps:
ng MACROEXPAND).
ing
, transform each argument
     If the result is a special form, transform the arguments
appropriate) via ZILCOTRN.
ion,
pplÿ
 of the form is a symbol, and it has an
 function, apply that
 CAR of the form dÿ
tion, we are finished.
 (2),
 (1).

nction name)
;;     locally bound variables (special or nonspÿ
ically available to the code
t in which the

s that may be present include:
 a return value (or values)
nt to a function
;;;       :predicate    will be used in a test for NIL
others...

;       pass +
vel functioÿ
valuable form.
********************
               *
             *
         *
es.  *
to *

;*            MULTIPLE-VALUE-BIND, MULTIPLE-VALUE-LIST, ÿ
 06/15/88 - Contexts improved to establish more reliably the times   *
        when multiple values might be returned from a form.      *
    Compiler transforms should assume that multiple values   *
  are possible when the context is one of the following:   *
:VALUE), (:RETURN), (:MVLIST), (:MVBIND)               *
t for PROG and RETURN removed.                     *
not trÿ
                                             *
******************************************
;;;;;;;;;;;;;;;;;;;;;ÿ
-member zilmacs))
;;;;;;;;;;;;;;;;;
ztran-debug*))
let ((dumcon '(:dummy)))
(ztran-lambda x nil dumcon)
n (oldform env con)
)
AND).
  (return form))
processing
om form)
st))

 form))
m (ztran-special-form form env con)))
n call, transforÿ
	
    ;;;       cannot be a macro, since MACROEXPAND took care
  of that already.  Since FEXPR+
he compiler is concerned, thi± s HAS toÿç
e a function call.

 ; end COND
;;;     transform the contents of the LAMBDA expression and
nsformations associated with LAMBDA to the form.
(consp (car form))
l)
nsform form env con))
       ;;;
    ÿ
 transforms its contents.
 form whose CAR is a
cur
   ;;; rules to it, much like a transformation function
d with a symbol.
ol, and it has an
t
orm))
   (unless (ok (setq newform (funcall xfun form eÿ
(return form))
an associated
     (t
) If the result of (3) is EQUAL to the result of (2),
.  Otherwise, repeat the process
     (cond

n
orm)


nc " transformed into ")
          (princ "... ")
prin1 newform)

m (form env con)
ormations to atoms.
ng evaluated for effect only, convert it to NIL.
e main processor of "effect-only" forms,
form as it transforms it.
  ;; No other transformations are applicable.
	
function applies appropriate transformations to
sforming the forms contained therein

;;; For example, a transformational rule for special form SETQ
d to thÿ
erty associated with the symbol SETQ.
form for the transformation.
efload declare)
          (ztran-lambda (cadr form) env nil)
hrow arg setarg listify)
m) env '(:argument))))
                (ztran-and-or         (cdr form) env con)))
    (cons (car form)
rm) env con)))
        (ztran-block          (cdr form) env con)))
s (car form)
con)))
(ztran-tagbody        (cdr form) env con)))
orm)

d ÿ
                           (ztran-setq           (cdr form) env con)))
ind-protect    (cons (car form)
ect (cdr form) enÿ
                   (ztran-defun          (cdr form) env con)))
       (cons (car form)
 form) env con)))
           (ztran-eval-when      (cdr form) env con)))

lue-list (cdr form) env con)))
ons (car form)
v con)))
.
 (prog (z clause)
ust in case of bad form.
m (setq clause (car form)))
t pass...
cons (ztran (car clause) env (cons ':predicate con)))
       (t
                 (ztran-progn (cdr clause) env con))
       ) 

prog (z)
c z form)))
cdr form))
)
s :setÿ
     (setq form (cdr form))
rm env con)
                     ÿ
                ;      or (foo fexpr (arglist) . body)
form) '(expr fexpr macro))
.
                                        env nil)
 is updated by lambda list processing.
env '(:value)))
form) #'(lambda (new) (setq env new))
env nil)

defvar (form env con);form = (varname value documentation)
orm))
       (ztran (caddr form) env '(:bind))
(ÿ
)
block (form env con)
ran-progn (cdr fÿ
)
ist* (car form) (ztran-args (cdr form) env '(:return))))))
tagbody (form env con)
(defun ztran-multiple-value-list (form env con)
st)))
hough &optional, etc. aren't permitted in the ÿ
BIND, we still transform it as if it was, to allow
ount of destructuring.  It isn't even
llowed in the arglist here.
t bindform . boddy) form)
med-arglist
))
bindform
ransformed-boddy
  )
ndform

ppropriate transformations to
ts.
 ;;; This function merelÿ
ociated with the function name (or for LAMBDA transforms).
g (z)
everse z)))
      (return (nreconc z form)))
m) env con) z))
)
his function applies appropriate transformations to
converting the LAMBDA expression
l form)
;
on merely prepares the form for the transformation
 does on forms that start with a
m" iÿ
AN doesn't call ZTRAN-LAMBDA directly for a form
his may get called from the FUNCTION

form)
st (cadr form) #'(lambda (new) (setq env new))
           env nil)


ms.
rm)
      form))))

argument list, by transforming the evaluable forms

'(lambda (new) (setq env new)))
  x env)))

 env)

   (go cont)ÿ
   (cond
 z))
a) new-updater env con)) z)ÿ
((oldenv env))
v con)
                (cddr a))
    (let ((oldenv env))
pdater env con)
                         (cddr a))
n (atom (caddr a))
ux
     (push a z))
-arglist (car a) new-updater env con))

 a) new-updater env con)
ind))
     (&key

(ztran-key (car a) pusÿ
       ((atom (cddr a))
list* (ztran-key (car a) pusher new-updater env con)
 (ztran (cadr a) oldenv '(:bind))
               z)))
     (push (list* (ztran-key (car a) pusher new-updater env con)
             (ztran (cadr a) oldenv '(:bind))
r a))
         (push (caddr a) env))))))
t a new-updater env con) z)))
     (go loop)
erse z))
d
unÿ
an-arglist (cadr a) updater env con)
ran-progn (form env con)
formations to
orms
on rules for PROGN.
formation
t of forms, NOT including any ÿ
TRAN-PROGN must NEVER return a null list.  In that way
rmations for COND clauses are avoided.
 form env con nil)
con)
  (return (nreconc z form)))
rm...
   (push (ztran (car form) env (cons ':predicate con)) z))
  (setq form (cdr form))
ch (form env con)
an-progn (cdr form) env con)))
)
)))
s is the tÿ
rm whose CAR is a LAMBDA expression (or LABEL
lent that can occur in functional
ules to the entire form.
s the LAMBDA expression.

ot contain any declarations,
 ;;; (PROGN . anything)
y applying transformation
is function returns)
     (args (cdr form))
 --> (PROGN . x)  if x contains no declarations
)
l (cadr funn))
,(cddr funn)))
e.
CK prÿ
xplicit and implicit PROGN, PROG,
sult is passed to ZXSEQOPT, the "sequential optimizer",
sformations (like SEÿ
 Note that ZXSEQOPT is invoked only once at

scon)
(zxseqopt (nreconc z boddy) env c on tagp)))ÿç
 tagp (atom (car boddy))) ; GO tag?
 ;
       ; If form transforms to an atom and is for effect onlÿ
 is useless, so discard it.
ull (cdr boddy)) con nil))
scon))
       ;
 ; to the PROGN into this block (i.e. "flatten out" the
N's).
setq z (nrë econc (cdr y) z)))  ;  "Flatten in" PROGN's.
 ; Otherwise, add the form.


************************
                   *
atory Inc.     *
             *
         *
******
f the value produced by a predicate
is not used, better code


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 (cond
                  (and (null (get (cadr s) 'vartarg))
(null (get (cadr s) 'popsalist))
popfalist))
                     (zilcovta (get (cadr s) 'rettarg))))
nil)))
******************************************
                                     *
Stark Draper Laboratory Inc.     *
                               *
                           *
************************
)
nil "~8,'0x" (zildump-asis (make-fixnum x))))
 . rh) (make-fixnum x)))
zildump-asis rh))))
stringp x)
  (cons (format nil "~2,'0x" (getcharn x i)) z))
i)
 cannot be dumped" (typep x) x))))
sp x)
	

;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
         All rights reserved.                                        *
                                                                 *
**************************************************************
e guts of tÿ
     See ZILAPPLY for discussion of the "environment" arg and
t affects FEXPR's and the "alist" arg to functions.
NV for discussion of the "ÿ
format needs to be changed.
*********************************
                            *
                          *
                      *
CK and TAGBODY    *
 changed.       *
            *
order   *
      *
  *
<
* 12/1ÿ
                                                                    *
*****************************************************************
;;
actually binding cells) for global variables.  This consists of a
 pair stored in the "PBIND" cell of the symbol.
ng is implemented for specials, someÿ
LAPPLY and ZILEVAL, not to mention
ds to be added to ZILAPPLY

he list in ZEVINIT.
ND.
5) Figure out how to compile it.

nclude evaluator macros.

 +

                    (evsymbol x a))                    )
inds of atoms (numbers, etc.) are self-defining.
       x      ÿ
d pair (CDR is a non-NIL atom), reject.
q . r) x)
"Invalid S-expression" x)    ÿ
e of evaluating (#.#'foo bar baz)
 are sort of irregular,
n the interpreter
r something.
ubr call.
       )
ly it.
                             (zevlist r a)
      (funenv q)
           )
-------------
er exist.
       )
-----------
 which

   (zilapply q (zevlist r a) a q)         )
 atom, but not a compiled code object,
o good (e.g. numbers are bad).
r "Invalid form in functional position" q)               )
 the form is a symbol, it's some kind of function name.
       (setq s (or (getl q '(macro ×SPECIAL FORM× exprÿ
            '(nil)))

and x) a toplevelp)  )
(car s) '×SPECIAL FORM×)
car (or r
t"

           (setq                (evsetq r a)                        )
      (and                 (evand r a)                         )
 (or               Å    (evor r a)                          )ÿç
.
           (block               (evblock r a)                       )
      (return-from         (evretfrom r a)                     )
   (tagbody             (evtagbody r a)                     )
o                  (evgo r a)                          )
on            (mkfunarg (car (or r
           ÿ
ssing argument"
n)))
	
)
             (defload             (zevdefld r toplevelp)              )
        (catch               (evcatch r aÿ
     (throw               (evthrow r a)                       )
(unwind-protect      (evuwp r a)                         )
                (evarg r a)                         )
             (evsetarg r a)                      )
        (evlistify r a)                     )
   (evevwhen r a toplevelp)            )
(car (or r
nt"


            (multiple-value-bind (evmvbind r a)                      )
            (t (zerror "Special form unknown to EVAL" q)))           )
;; Not a special formÿ
ynamic scoping, pass "a" instead of "nil" to ZILAPPLY in
for EXPR and FEXPR below.
(cadr s) (zevlist r a))       )
y (cadr s) (zevlist r a) nil q) )
y (cadr s)
)   )
--------
v a))))
--------
;
  (zileval x a toplevelp)                )
MBOL - evaluate symbol.
I+

e yet.

sed to this roÿ
-symbol-p x) x)
;;;;;;;;;;;;;;;;;
 
  ;; object, because that should be placed there only by MAKUNBOUND
ich is defined to work on special bindings only).
indenv a)))
pecial.
decls,
   (cdr (or (zevsym x)                  ; find the SPECIAL ÿ
      (zerror "Unbound SPECIAL variable" x))))
 search for a special binding.
oked by a compiled
 implicitly
+++
)))
 (t
evaluate special form COND

r "Invalid COND syntax" ÿ
il))
                   v
      (setq x (cdr x))
ecial form GO
           (zerror  "Missing argument" 'go)          )
       (zerror  "Too many arguments" 'go)        )
etq tag (car l)))
   (zerror  "Invalid GO tag" tag)            )
zerror  "GO outside of PROG" l)          )
m-tag-onward)
 (setq prog-body-from-tag-onward
ogbody env)))
    ÿ
         (throw (tagbodytag env)
t env)
ü
EVPROGN - evaluat e special form PROGNÿç
 (r a toplevelp)
p (cond
plevelp))) ; possible M.V.'s
toplevelp)           ; effect only
(go loop)))))))
n evsetq (r a)
tq var (car r))
»
setq r (cddr r))

 "Invalid SETQ variable" var))
ing" or "constant" - no support for those yet.
g" case was handledÿ
p x) (zerror "Cannot assign to this variable" x))
(zerror "Cannot assign to this variable" x))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ÿ
 current interpretive/lexical binding.


ar (specenv a)) ;  If it is in pervasive SPECIAL decls,
))        ;  or globally proclaimed SPECIAL,
  then call special-binding-modifier.
 a binding, never NIL.
; If not there, then assume a new SPECIAL variable.
turn a binding, never NIL.

s.  Note that this is not done

n the special-ÿ
 bound variables may be forced SPECIAL, since
gin with.
o warn if declared special
rn if dynamically bound
t has no value)

l))))))
 a)
))
           (when (null (zileval (car r) a nil))    ; testÿ
     (return nil))
 
ull r)
              (return (zileval (car r) a nil))) ; possible M.V.'s
(return
    ; test only
      (ÿ
;
few arguments" 'catch)        )
) r))
                                (evprogn form a nil)))          )
;
ond
)

     (throw (zileval tag a nil)
eval form a nil)))          )
 UNWIND-PROTECT
)  (zerror  "Too few arguments" 'unwind-protect))
  (let (((pf . cf) r))
al pf a nil)
l))))))
, ÿ
ple, Maclisp LISTIFY to be implemented
evarg (r a)
ARG outside of LEÿ

many arguments" 'arg)
)))
v)
 to ARG not NIL, T, or fixnum" n)))))))
inal-n)
      (minusp n))

 n (1- n))


 "Too few arguments" 'setarg))
'setarg))
f (null arg)ÿç
PR" r)
 (setq v (zileval (cadr r) a nil))
nth (1- n) env v n))
xnum" n))
 original-n)
         (minusp n))
inal-n))

p)))
fun evlistify (r a)

           (zerror "LISTIFY outside of LEXPR" r)
))
))
STIFY not a fixnum or NIL" n))

    (nthcdr l env)
 n)      nil)
           (a env (cdrÿ
                     ((or (null a) (> i n)) z)
etq z (nconc z (list (car a))))))

ile) ignored.
ated.
     (zerror "Misplaced EVAL-WHEN"))
al-when))
))
l (r a toplevelp)
" r))
valid declaration" declaration)
((special) (dolist (dclarg (cdr declaration))
(eÿ
     ))))
(not (symbolp var))
AL variable" var)ÿ
lp var) t)))
defun evblock (x a)
rror "Missing block name and for+
less (symbolp blockname)
name))
nent.
ag.
  (push p (progenv penv))          ; Add new PROG environment component.


v nil))))

locktag p)) nil)   ; Invalidate RETURN from this BLOCK.
rn (values-list (progvalue p)))
l form RETURN-FROM
 ( (null l)            (zerror "Missing block name" 'return-from))
l)        ÿ
 (setq bname (car l))))
 block name" bname))
ith btag
tag (eq bname (car btag)))
          (zerror "RETURN-FROM block inactive" bname))
(blocktag env)
               (multiple-value-list
 (cdr l) (cadr l) nil) a nil)
        ))
me)))))
efun evtagbody (x a &aux stmt p penv)
Return NIL if no forms.
nvironment component.
TAGBODY tag.
 tags.
y.
h p (progenv penv))          ; Add new PROG environment component.
wind-protect
   (setf (progrest pÿ
                (catch (tagbodytag p)
env nil)))

nvalidate GO to this TAGBODY.

list (r a)
e-value-list))
any arguments" 'multiple-value-list))
l (car r) a nil)))))
LUE-BIND
 (cdr r)))
  (let (((vars form . body) r))
 ((null v))
error "MULTIPLE-VALUE-BIND arglist not a proper list"
ars))
PLE-VALUE-BIND arglist cannot contain lambda list keywords"
    vaÿ
de, and to let the
s a form
      ;;; as if it weÿ
 NIL) &REST (NIL))
ALUE-LIST (VALUE-FORM)))
variable names
n ZIL.
;;; This works out as equivalent, if you think about it -
iables are set to NIL if not found in the
ny extras are swallowed up by the
uld work as a macro for
 want to CONS
lues
rks as the dummy &REST argument because:
GENSYM in the interpreter so that
tÿ
rg, the way the
(NIL) is a destructuring request that throws away
he &REST list anÿ
y
 `(,x nil))
              &rest (nil))
      a)

***********************************************************************
                                                                  *
) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
All rights reserved.                                        *
                                                        *
*****************************************************
c ÿ

consp x)   (prog (n)
Ó
        (when (setq x (cdr x))
                            (return (+ 3 n (zilflat x p)))
             (go loop)))
) (if (zerop (vlength x))
flat (vlist x) p))))
g-length " >"))
) (+ #.(+ (string-length "<STRUCT ")
>")
                  (zilflat (vlist x) p)))
string x p)))))
***************************************************
                                              *
 Charles Stark Draper Laboratory Inc.     *
                                        *
                                    *
*********************************
ut is invoked by a macro named HELP,
using (HELP) under ZIL without
e this way primarily so
n case one wishes
hich HELP info is desired.
	
************ÿ
                                                                  *
 activity:                                                    *
                           ÿ
dded support for new special forms pertaining to        *
, TAGBODY and multiple values.                      *
ns no values.                             ÿ
                                              *
*******************************************
help-library*))
       (unless (symbolp a)
 a))
                             (zilhelp-member-name a) ")'")))
ot (open helpmember :probe))
o HELP available for ")

       ÿ

           (zisexec "CONTROL DISPLAY REFRESH")
 (t       (tso "LIST "ÿ
          (princ a)
mber)
               for line = (readline fÿ
le)

r the following members of...")
 *zil-help-library* "'")
cumentation is contained in '")

 for a list of functions.
e>, where <name> is
»

ÿ
full screen news, (NEWS T).

 (let* ((autoloÿ
 (symbolp autoload))
name))
                  . "PLUS"    ÿ
          . "DIFFEREN")
. "TIMES"   )
T")
                              (\\                   . "REMAINDE")
                    (**                   . "EXPT"    )
          (^                    . "EXPT"    )
  (=                    . "ZILEQUAL")
              . "LESSP"   )
    . "GREATERP")
DD1"    )
Õ
                        (functions            . "$HELP"   )
          ÿ
      (let*                 . "LET"     )
t*                . "LIST"    )
        . "PROG"    )
. "EVALWHEN")
  )
                            (prin1-to-stÿ
                    (with-open-file       . "WITHOPEN")
          (return-from          . "RETURNFR")
(multiple-value-bind  . "MVBIND"  )
e-value-call  . "MVCALL"  )
st  . "MVLIST"  )
ROG1" )
»
))£{
r pair))
oadname 1 8))

***
<

                                                                    *
*****************************************************************
 The ZIL 1.3 Iÿ
T.
m initialization is now done from ZILINIT.

append ") - Compiled " (ppdate)))
 (HELP) for help, (EXIT) for exit.")
          ; Activate ABEND interception.
ng is not available while loading the INIT file
nd a (CATCH T ...) are coded therein).
 (string-upcase (getparm nil))))
    (princ "Loading INIT file ")
  (terpri)

"Loading INIT file.")
terpri)
i)
dling.
input.
 
"LISP interpreter (ZIL "+ )
rpri)
*****************************************
                                    *
tark Draper Laboratory Inc.     *
                              *
                          *
***********************
*************************
r modules.
**********
*************
        *
    *
*
<
* 04/06/88 - Added declarations for new module ZCCVALGO.              *
/10/88 - Removed ÿ
       PROGVARS, GOLIST, PROGEXIT                               *
 - Support for determination of superfluous initializations *
f PROG and &AUX variables to NILÿ
 fields in the contour that are used to detect cases  *
riable unconditionally being set before it is     *
nced.  This is an extension of, and replaces, *ÿ
ialization-hacking scheme used in ZCCPROG.  *
s a new P-code form, CSETNIL, and a new *
, ZCGCSNIL.                         *
ow part of ZCGSTVRS.              *
ts.                           *
XRELOP.                   *
ort BLOCK and TAGBODY.  *
es to support       *
                *
            ÿ
          *
      *
  *
*

ile)

esenting a body of pseudocode or whatever else.
of the list and NREVERSEing it later
o modq (x y) ; add a statement to the given list

if (atom x)
m)))
,g) 'not))))))
xx) form.
,x))
     ÿ
    (symbolp (car ,g))

 t))
    (putprop (cdr ,q) (gensym) 'location)))
oms alllists allsubrs alone argbase atoms body cc codelen
uid-asaved fluid-unbounds intfuncs ÿ
 pdbas pdmax procs program regs restofit
ecial-unbounds stack stackmax

r.

    type               ; DEFUN, LAMBDA, PROG, etc., etc.
            ; Contour of lexical encloser for funargs
       ; Locally bound variable bindings
ables declared SPECIAL
ÿ
       return-tags        ; (formerly PROGEXIT) BLOCK/PROG RETURNs
 lexpr-arg          ; Name of arg for LEXPR contour
     ; "Temporaÿ
   ; "Permanently conditional" flag  04/25/88
 Name of block for PROG/BLOCK
d by SPECIALS:
lared SPECIAL
rvasive-specials ; Variables pervasively declared SPECIAL
           ; (for references only, not bindinÿ
elds will be added as time goes on, mainly for ;;;
ations that will be supported..... ;;;
g maps the contents of the special variable CC.
tendedp (x) `(cddr ,x))
Þ
addr ,x))
(x) `(car (cddddr ,x)))
 ÿ
 ; 06/06/88
defargs ZCCCOND    4 4 nil)
   4 4 nil)

G    5 5 nil)

AMA    4 4 nil)
½
VLST   4 4 nil)
)
CQUOTE   4 4 nil)
TQ    4 4 nil)
OW   4 4 nil)   ; 06/13/88
  2 2 nil)
 1 nil)
fargs ZCGBEGIN   1 1 nil)
 1 1 nil)
fargs ZCGCALL    1 1 nil)
 2 2 nil)
1 1 nil)
args ZCGEMIT    5 5 nil)
1 1 nil)
efargs ZCGGETIT   1 1 nil)
  1 1 nil)
efargs ZCGIASSQ   5 5 nil)
T   5 5 nil)
(defargs ZCGKEY     1 1 nil)
    2 2 nil)

SV    1 1 nil)

SUBR    1 1 nil)

COCON   2 2 nil)

ILCOÿ
nil)  ; 06/16/88

COVTA   1 1 nil)
 2 nil)
omplete.")

G    4 4 nil)
À
CGEPROG   1 1 nil)
0 nil)
fargs ZCGLCVAR   1 1 nil)
   1 1 nil)
À

***********************************
                              *
raper Laboratory Inc.     *
                        *
                    *
*****************
ist file.

ÃÃ
*******
  *
<

*********************************************************************
»
*************************************
                                *
                            *
                          *
                      *
                  *
*****************
(f &optional o)
m f)             (zerror "Not a function or variable" f))
ambda) (pp-lambda f "#<anonymous function>" 'expr o))
 (pp-lambda (cddr f) (cadr f) 'expr o))
a function or variable" f))
alues, so nothing prints.

; (car z) = 'expr or 'subr

       (expr  (setq p t) (pp-lambda (cdr z) f 'expr o))
tq p (get f 'macro)) (pp-lambda p f 'macro o))
-lambda p f 'expr  o))

et ((val (symeval f)))
                                (neq val t)ÿ
        (or (symbolp val) (consp val))

  val)))
zerror "No interpretive function definition or value" f))
-lambda (bod nam typ out)

t (cadr bod))          ; Argument list.
o)
t)))))
UN ") ou+
      ÿ

out)
dr arglist)))

 arglist out))
  (t               (pprint arglist oÿ
op for i in (cddr bod) do   ; Function body.
 (princ " " out)
   ; (

***************************
                      *
boratory Inc.     *
                *
            *
*********
 for how this is used.
osure.
; SPECIAL-ALIST anyhow.
*******************************
                          *
                      *
                    *
                *
            *
***ÿ

ist (cdr varlist))
 ((null varlist))
allist (zcar vallist) (zilunbnd)))
-value-prog1
 )
*******************************************
                                      *
 Stark Draper Laboratory Inc.     *
                                *
                            *
*************************
;;;
mber of *ZIL-HELP-LIBRARY* to be tested
d
***********
      *
  *
<

 (with-open-file (file
p x)
           (string-append "'" *zil-help-library* "(" x ")'"))
    (t

 (file name)
ror "No examples found in doc" name))
ar (string-scan (readline file))) "Examples:")
n (plusp (setq count (ziltest-putdata file name)))
    (princ "There are ") (princ count)
entation or implementation.")

unt 0)
)

)
=x)
perly in V/S sÿ
ollowing
tested didn't set ZLCVSNXT, it will get clobbered by the
 ;
)
"))
 Must evaluate x before reading y, in case r+
that would change the evaluation of x.  A ÿ
ch returns different values depending on what

ound."))
right!")×#)
ion mismatch!")
   (prin1 =y)
   (prin1 =z)
p)))
lp a)
atp a)
0000 #z00000000)))
s (- a b)) #.(make-flonum #z3C100000)))
Æ
cdr b)))
)

*********
    *
*
<
***********************************************************************
;
<
* Change activity:                                                    *
                                   ÿ
7/88 - Support for multiple values.                             *
                                                            *
upport for AT and OFF.  See MXATOFF for details.  ÿ
                                                      *
***************************************************

rest x) `(ziltrace ',x 'untrace))


ÿ
defstruct trace
          function-code

 function-exit-quietp
atfor)
 functions

iltrace-entry  fl))  ; FL is a list (tfun efun quietp)
exit   fl))  ; FL is a list (tfun efun quietpÿ
 second arg to ZILTRACE" whatfor))))
ss (symbolp fn)
))
Õ
 (format t "~&Function ~S became untraced when redefined.~%"
  fn)

 ZILPP.
…
he-one (zi+
ce-functÿ
dr the-one)))

ace-assq (car tf))
m fl) (zerror "Invalid TRACE function list" fl))
iltrace-trace1 fl)
ux (ff nil)) ; This traces one functioÿ

¤
(case fp
 trace ~S ~A.~%" fp fn)
make-trace :function-name         fn
roperty     fp
                           :function-hook         nil
      :function-entry        nil
        nil
   ÿ
    :features              ff
da (&rest fa) (trace-encapsulate fs fa)))
(trace-function-hoÿ
         (remprop fn fp)
ere if an interrupt takes place,
ced.
      (ncons fn)))

 trace ~A, function not defined.~%" fn)
trace-encapsulate (fs fa &aux fv)
  ;;;(fp  (trace-function-property fs))

 fs))
try-quietp fs))
trace-features fs))
)
enter-features ff))
fn)))
ce-exit-featuÿ
trace (fl)

fl) (zerror "Invalid UNTRACE+
'ziltrace-untrace1 fl))))
f) ; This untraces one function.
 (cond
        ; There's an exposure here if an interrÿ
particularly if an EXPR is traced.
function-property (cdr the-one)))
-one)))


 function name being traced
non-NIL, suppress entry/exit message
nter (x f l q i)
 ~S.~%" i "" f))
 ~:S~&" i ""ÿ

 l))

exp quietp))
xit-function fn exp quietp))
 quietp)
    (setf (trace-function-entry        (cdr the-one)) exp)
unction-entry-quietp (cdr the-one)) quietp)

  ((ziltrace-trace1 fn)
	
iltrace-assq fn)))
        (cdr the-one)) exp)
e)) quietp)
was not being traced.~%" fn)
ltrace-Î make-exit-function fn exp quietp)))))

**

;*         All rights reserved.                                        *
                                                                   *
****************************************************************
*************ÿ
                                                                   *
member must be compiled as a MODULE.                           *
                            ÿ
**********************************************************
===========================================================
us array-fake-out package.

ant, a function used to access array information.
AY property is also given an SUBR property
ding the array to ZARRAY, and
of the array.
 arrays.
===========
*****************
            *
ions.   ÿ
ugh.  *
  *
	
 "Loading \"ZLARRAY\", ZIL's Maclisp-compatible array module.")
)
      name
          function
ar (zil-array-dimensions ,array)))
y)
         #'(lambda (array &rest args)
-function array) args))
l-array (array)
rray)))
 array" array)
rray dim1 val val?)

Çÿ
zil-array-dimension-1 array)))
 array"
array-data arrayÿ
))
 ((and (null dim1) (null dim2))
rp dim1))
il-array-name array) dim1))
ndex-2 specified for array"
r (minusp dim1) (>= dim1 (zil-array-dimension-ÿ
-range index-1 specified for array"
Ô
Out-of-range index-2 specified for array"
 dim2))
2)))
Î
array-handler (array dims)
ons array)))
      )
en (1+ rankÿ
((< rlen rank)
)))
)))
  (t (do (
imensions array)
      )
et (zil-array-data array) index val)
ay) index)))
              ((not (integerp dim))
 specified for array"

)
                     (zil-array-name array) dim))
            (incf index
 d))
      ÿ
a)
L must be defined before *ARRAY, since *ARRAY uses the SUBR
RAYCALL.
ycall ',type ,array  . ,dims))
e array &rest dims)
 (zil-array-function real-array) dims)))
(a b)
 subr #-ZILCO expr)
                 &aux (ndims (length dims))
array oldarray oldsubr arfun)
ay (get name 'array))
))
ize (case ndims
mÿ
 (adv (zcar dims)) (adv (zcadr dims))))
s (cdr dims))
)
ue (case type
         (flonum 0.0)
        (make-zil-array
     (make-vector size initial-value)
     :dimensions dims
)
  (case ndims
                       (arg2 nil arg2?)
)
s to array"
   (when argr
                  (zil-array-name zarray)))
ndler zarray arg1 arg2 arg2?)))
g1?)
              (arg3 nil arg3?)
           ÿ
ents to array"
      (when argr
                     (zil-ÿ
-handler zarray arg1 arg2 arg3 arg3?)))

e
funprop))
mprop name '#.funprop))
n end so gets found last
ist '#.funprop (zil-array-function newarray))))
mbda (a b) `(store ,a ,b)) 'setfmethod)
 of the array.
ct itself.
   `(let ((,g ,x))
             (zerror "Invalid array dimension specified" name ,g)))))
Æ
e . ÿ
 )
un mxstore (form value)
m)
tore-munge (cdr form) value))))

          (go xloop))

 when (null (cdr sub-args))
,value))
efun arraydims (array)
ype array)
e (array)
dims (array)
(defun array-dimension-n (dim array)
cond

1- dim) (zil-array-dimensions array))))))
vlist (zil-array-data (zil-array array))))
 &aux real-arrÿ
ayp value)
)
ue)))
  )
r fi))))
ray-data real-array))

l)) array)
* ((i 0 (add1 i))
vlength d))
t value)))         ; Note - no ZCAR here.
y)
or "Arg 2 to FILLARRAY not an array, vector or list" value))))
$	$
 (setq real-array (zil-array array))
 (warn "Can't do *REARRAY on this array" array)
  ÿ
ray 'array-save-subr)))
p array '#.funprop))
      (putprop arÿ
(null dims)                           ; Type but no dimensions.
-array-type real-array) type)
     (setq a (zil-array-data reaÿ
etq b (zilapply #'*array (list* array type dims)))
y-data (zil-array b)))  ; New array data.
       (setq e (vlength a))
À
    (vset c i (setq f (vref a i)))
 loop)
 (vset c i f)
))
*****************************************************
                                                *
he Charles Stark Draper Laboratory Inc.     *
d.                                        *
                                      *
***********************************
ember 1987
.


tructure consisting of the flavor methods,

ables it to beÿ
flavor stuff.  Instance variables are not closed over, but are
o the special variable binding environment using some very
	
*******
  *
<

                                                                    *
7/89 - Support for "(varname)" spec in DEFFLAVOR var list. ÿ
                                                              *
***********************************************************
e macro-defining hack for compile-time and run-time macros.
acro defmacro-for-all (name arglist . body)
arglist . ,body)
y)



ar *print-level*  t) ; Iÿ
----------------------------------------------------------------×#
ar *all-flavor-names* nil "List of all flavor names.")
sglevel* 1 "Message level for flavor meÿ
vor informational messages
nings and errors
 of a flavor instance object.
  #'(lambda (instance &rest args)
e-closure-object instance)
t-funcall-method)
-----------------
À

          (escape *print-escape*))
m ÿ
-----------------------------------------------------×#
*************************************************************
                 ÿ
unctions.                                             *
                                                  *
********************************ÿ
avor (flavor-name)
d as a flavor" flavor-name)))
ally message-method pairs).
ate methods for a flavor.
r &aux (mlist nil))

(zil-get-flavor flavorname))
)
 This collects instance variables.
change) to determine all the
nto the closure,

 lists:
ORDS
s are collected, the lists of required
 flavors are checked.
or &aux vlist klist ilist)
lavor)
e    in (flavor-instance-variables    f)
flavor-instance-keywords     f)
ance-initializers f)
        do (push variable    vlist)
klist)
 vlist) (nreverse klist) (nreverse ilist))
posite init plist.
 for instance
¦

tions.
…
alization values.
 (list nil)))
    (loop for subpliÿ
                  (zil-get-flavor flavorname)))
          (let (((indicator thunk) subplist))
plist indicator)
)))
NCE if the flavor
tialize-flavor (flavor
cluded-flavor-list)
the list of component flavors.  This is a list, not a tree.
ume that each component flavor has an already-built linear
onent flavors just like the one we are building.  It
 not necessary to descend further than 2
;
ÿ
  (terpri)
ll the component flavors.
ors flavor)
 (push c component-flavor-list)
nt-flavor-list
                           (ziÿ
 (memq x component-flavor-list)
-flavor-list)
avors flavor)

           (zil-get-flavor c)))
-flavor-list)

avor list of the flavor.
avor)
ke a linear tree-walking list of all the included flavors.
p for c in (flavor-component-flavor-list flavor)
n (flavor-included-flavor-list
r c))
        ÿ

cluded-flavor-list)
      (loop for x in (fÿ
       (zil-initialize-flavor
 c)))
               do (push x included-flaÿ
        (loop for x in (flavor-included-flavor-list
       (zil-get-flavor c))
r-list)
         )
t of the flavor.
        (nreverse included-flavor-list))
these two lists for ease of method-searching, etc.
r-all-flavor-list flavor)
            (flavor-component-flavor-list flavor)
ludÿ
flavor, indicate that this flavor
r list of dependent flavors.
l-flavor-list flavÿ
(memq (flavor-name flavor) (flavor-dependent-flavor-list f))
h (flavor-name flavor) (flavor-dependent-flavor-list f))
 
nt flavors, and build the combined methods for them.
age) in (zil-collect-primary-methods flavor)
regenerate-method flavor message)
nce variables for this flavor, as well as
initializers.
nce-keywords instance-initializers)
avor)

tf (flavor-all-instance-initializers flavor)instance-initializers)

operations flavor) nil)
(setf (flavor-initialized flavor) t)
*************ÿ
                                                             *
VOR-INSTANCE-VARIABLES:                                  *
                            º                          *ÿç
**********************************************************************

(let ((f (or (zil-get-flavor flavor-name)
 not defined, can't expand DECLARE-FLAVOR-INSTANCE-VARIABLES"
      flavor-name))))
nce-variables f)))
******ÿ
                                        *
                                    *
                     ÿ
*******************************
thod &rest methodargs)

***
<
*                                                  ÿ
*********************************************************************

vors &rest flavor-options)
ponent-flavors
vor-name instance-variables component-flavors
ons
sÿ
   instance-initializer-list
                        init-plist
t
   gettable-instance-variables
iables
           init-keywords
                        included-flavor-list
lla-flavor
               required-methods

ination-list
nstance-variables)
              flavor-name instance-variables))
-flavors)
  flavor-name component-flavors))
 list and the instance keyword list.
riables
heck-instance-variable flavor-name x
tance-variable-list)
x instancÿ
  else
        (zil-check-instance-variable flavor-name (car x)
                 instancÿ
ist)
   ((null (cdr x))
  ((or (atom (cdr x)) (cddr x))
e specification"
  (push `(subr (lambda () ,(cadr x)))
ist))))
me (car x))
e-keyword-list))
ble-list))
 instance-initializer-list))
 (loop for opt in flavor-options do
cond
 ((aÿ
specification" flavor-name opt))
 ovalue (cdr opt) ovalue? t)))
nce-variables
alue
(mark-gettable the-list))
 
                       instance-variable-list)))
 the-list)
able the-list)
    (:initable-instance-variables
e-specs ovalue? ovalue

-list))
value? ovalue nil))
ovalue? (zerror "No value permitted for this flavor option"

     (:included-flavors
   (:default-init-plist
"A value is re+
r-name oname¦ ))ÿç

?
                       flavor-nÿ
-variables ovalue)
s ovalue?
n"
methods ovalue)
alue?


(cdr ovalue))
on name must be specified"
e))
tside-accessible-instance-variables
nce-specs ovalue? ovalue
))
efmacro ,(concat flavor-name "-" var) (,g)
val-in-instance ,,g ',',var))
        )
            (zerror "A value is required for this flavor option"
             flavor-name oname))
        (unless (consp x)
to :METHOD-COMBINATION"
            (let (((type order . messages) x))
message in messages
bination-list)
cate message name specified for :METHOD-COMBINATION"
              flavor-name message)
                         (push (cons message (cons type order))
                        method-combination-list))))

      ÿ
ion not supported in ZIL"

 

O, which returns the value of FOO;
o a new value.
     for key in instance-keyword-lÿ
variables)
g)
thods)
defmethod (,flavor-name ,key) () ,var)
  )
 ;
andler) ,default-handler)
 :initable-instance-variables is specified,
ll the specified instance

 a flavor is created via MAKE-INSTANCE.
nit-plist only for variables that
FFLAVOR declarÿ
is actually a run-time list consisting of
" (argless lambda subrs).
=>

nce-variable-list
hunk in instance-initializer-list
stance-variables))
 `',key init-plist)
 ; The value of default-init-plist is a list of alternatingÿ
ue pairs.  For each pair, add it to the existing
ndicators and values as above.
st nil))
   (unless (cdr subplist)
default-init-plist"
indicator value) subplist))
         ÿ

cator initialized-keywords)
ec overridden by instancÿ
-name indicator)
           (newval `(subr (lambda () ,value))))
ewind init-plist)
               (push newind new-default-init-plist)
sh newval new-default-init-plist)))))
plist))

 component flavors,
(or no-vanilla-flavor
t))
avor-list vanilla-flavor)))

        ',instance-variable-list
ist
uded-flavor-list
   ',required-instance-variables

 . ,instance-initializer-list)
                      (list . ,default-init-plist)
methods
al-when (compile load eval) . ,outside-macros)
Ô
 ÿ
fun zil-create-flavor (flavor-name
es
omponent-flavorsÿ
              init-keywords
bles
method-combination-list
                          init-plist
list
e                         flavor-name
     instance-variables
ywords
      included-flavors             included-flavors
rds                init-keywords
quired-instance-variables
methods

  init-plist                   init-plist
       default-init-plist
flavor-initÿ
   (cond
or being redefined.  Old methods retained."
     (setq oldflavor (zil-+
mbined-methods z)
 must change!
or-primary-methods oldflavor))
           (flavor-before-methods oldflÿ
ethods z)
lavor-default-methods z)

hods oldflavor))
    (flavor-dependent-flavor-list oldflavor))
including flavor-initialized.
has other flavors depending
force them to be
them.
p foÿ
essp *flavor-msglevel* 2)
    (princ "Resetting flavor ")
-get-flavor f)))
(flavor-initialized (zil-get-flavor f)) nil)))
    (push flavor-name *all-flavor-names*)
rop flavor-name z 'flavor)
ark-gettable (x)
ble-instance-variables)
bles)))
da (x)
              (push x settable-instance-variables)))
fmacro mark-initable (x)
mq x initable-instance-variables)
ance-variables))
(x)

t-keywords))
nstance-variable (nam var lis)
nce variable sÿ
     (zerror "Duplicate instance variable" nam var)))
nstance-specs (ovalue? ovalue instance-variable-list)

t)
but not present in list"
  )
******************************************	 ***ÿç
                                                            *
                                                        *
                                                    *
***************************************************
ll defmethod
type?))
-type message-type?

ssage-type?
 message-namÿ
-type :primary)
(FOO BAR) ANOTHER-FUNCTION-NAME)
OD syntax (cannot specify fÿ
list body)

lavor-name
dify message-type) "")
     (unkeywordify message-name)
`(progn
thod ',flavor-name ',message-name ',message-type
r ,f))))))
essage-type f &aux z)
  (case message-type
message-name
               (rplacd z f)
       ÿ
          (:before
              (flavor-before-methods flavor)))
È
vor-before-methods flavor)))
     (if (setq z (assq message-name
thods flavor)))
ns message-name f)
            )
-name
          (rplacd z f)
                 (flavor-default-methods flavor)))
   (:wrapper
          (flavor-wrapper-methods flavor)))

-wrapper-methods flavor)))
        (zerror "Message type not supported by DEFMETHOD"
ÿ
rwise
          flavor-name message-type message-name)))
as already beenÿ
is message.
ods
end on this flavor
ialized),
ors.
te-method flavor message-name)
-flavor-list flavor)
              (when (flavor-initialized f)
nerate-method f message-name)))))
as the value of DEFMETHOD.
ion determines the combination type for a message of a
turns a cons of type and order.
e (flavor message-name
lavor)
t* ((f
 . ord)
)))
           nil)
rder ord tflavor flavornaÿ
  (unless (eq ord order)
* 3)
er keyword mismatch for message ")
ame)
in1 type)
       (terpri)
          (prin1 tflavor)
                      (prin1 order)
vor ")
  (princ " specifies ")
          (terpri)
 "Method generation failed for flavor "
r-namÌ e flavor)))
                      (when (lessp *flavor-msglevel* 3)
   (cterpri)
sage ")
     (terpri)
      (prin1 tflavor)
                  (prin1 type)
)
inc " specifies ")
     (terpri)
hod generation failed ÿ
ame flavor))))))

s it to the flavor (or replaces the eÿ
enerate-method (flavor message-name)
²
      (prin1 message-name)
flavor-name flavor))
tions flavor) nil)
nation-type flavor message-name)
unction-name argsymbol body)
combination and no before/after)
l-regenerate-daemon-method flavor message-name order))
enÿ
rate-or-method     flavor message-name order))
and-method    flavor message-name order))
method   flavor mÿ
enerate-inverse-list-method  flavor message-name order))
     (zerror "Unknown method combination type"
vor) message-name type))
  ((atom methoddef)
mbody) methoddef))
                   ,(zil-flavor-wrap flavor mesÿ
                          mname margs mbody)))

thods flavor))
  (push (cons message-name methodfun)
avor)))
function applies all wrappers to the generated code for the
od.
)

    )
 &aux mlisÿ
en (setq m (assq message
il-get-flavor f))))
r-first order, so that thÿ
la-flavor) goes on first, etc., and the
goes on last.
ined method code
od
or message-name ignored)
 these different kinds
(primary-method
       (before-method-list
-name))
vor message-name))
or message-name))
           (null after-method-list)
     ÿ
st the primary method...
       ;
      (combined-funcÿ

ify message-name)
    (args (gensym))
e
bda (x) (zil-make-method-call x args))
list)
od-call primary-method args)
-method-call x args))
      )))))))
order)
 flavor message-name order))
at (flavor-name flavor)
ÿ
 (gensym))
     (progn . ,(mapcar #'(lambda (x) (zil-make-method-call x args))
               +
vor message-n· ame order)

bined-function-name
 "-COMBINED-"
    "-OR-METHOD"))
ction-name
thod-call x args))
il-regenerate-and-method (flavor message-name order)
d-list
     (combined-function-name
 ÿ
             "-AND-METHOD"))
mbined-function-name
zil-make-method-ÿ

       (method-list
order))
vor)
name)
Á
r #'(lambda (x) (zil-make-method-call x args))
d-list)))))
me order)
thods flavor message-name order))
(concat (flavor-name flavor)
  (unkeywordify message-name)
       (args (gensym))
    )
 ; (funcall m1 arg1 (car arg2))
    ; (funcÿ
       ; or...
    ; (apply m2 (list arg1 (cadr arg2)))
 arg2)))
 ,args))
cking here...

 or something like that...?
 `(funcall ',(cdar m) ,arg1 (car ,a)) z))
cdr m))
               ((null m) (nreverse z)))))))
d-call (methodpair args)
m) 'zilxsub 'zilapply) ',m ,args)))
*****************************************
                                      *
                                  *
                              *
****ÿ
 (wa . wb) wz)
arg2 must be (arglist . body)"
sym)))
   `(let (((nil . ,',wa) ,,wargs)) ,,wz))))
*************************************************
                                  ÿ
                                          *
                                      *
***********************************
name &rest keyworded-arguments)
guments t))
                   &optional send-init-message-p area)
en (lessp *flavor-msglevel* 2)
area arg to INSTANTIATE-FLAVOR ignored: ")
     (princ " ")

ce)
e-values)
       (collecÿ
)
)
lize it.
lidity check the keyworded arguments.
by #'cddr
   (zerror "Not an initialization keyword ofÿ
  flavor-name (car k)))
of init-plist arguments to MAKE-INSTANCE"
plist))
ave been provided.
riable list.
ame in (cdr (flavor-all-flavor-list flavor))
et-flavor flavorname)))ÿç
or-required-instance-variables f)
-instance-variables flavor))
) reqlist)))
eqvar . reqflavorname) in reqlist


r ")
                (princ " was not found.")
    do (setq lost t)
            (zerror "Instantiation failed for flavor"
     (flavor-name flavor)))))
thods have been provided.
od ÿ
e in (cdr (flavor-all-flavor-list flavor))
lavor flavorname)))

           do (push (cons reqmsg flavorname) reqlist)))
loop with lost = nil
         when (lessp *flavor-msglÿ
            (princ "Method for message ")
               (princ " (required by flavor ")
orname)
nd.")
ly
led for flavor"


	
Keyword specified on call to MAKE-INSTANCE.
ication.

ault-init-pliÿ
nt implementation of ZIL-COLLECT-INIT-PLIST.)
init-plist (zil-collect-init-plist flavor))
ll-instance-variables    flaÿ
ywords     flavor)
r)
       (push (cond
plist key)) ; Specified on MAKE-INSTANCE ÿ

        (funcall initializer)); Specified in :DEFAULT-INIT-PLIST
   (ini
decl
nstance-values)
ethod:
.
contents of the flavor's default-init-plist.
ain component flavors' default-init-plists?)
Right ÿ
s from the instance variable specs in DEFFLAVOR.
y not right.  To correct this problem,
ult-init-plist separaÿ
ructure.
:init (flavor-combined-methods flavor)))
rg-plist))
avor))
unk) subplist))
                    (putprop init-plist (funcall thÿ


alled.  Obtain the pointer to the "joint" where this alist
ed".
ariables (cdr vars))
          (pair)
)ÿ
f (null z)
              (push pair z))))
 the instance.
ables onto
OGV because the bindings themselves need to be
ments.
s
s kind of complicated, but the point is that
ss you do this.
r-instance
    :closure-object
 savepop)
when (setq recp (cdr instance-joint))ÿç
push nil save-joint))
Å
                     (do ((subalist (special-alist) ÿ
                    ((null (cdr subalist)))
eq (cdr subalist) instance-alist)
-joint) subalist)
tance-joint))
(rplacd instance-joint (special-alist))
ist) instance-alist))
  ÿ
lf *flavor*))


 savepop

                   (setf (cdr saÿ
 (setf (special-alist) savealist))
it-message-p

ked from the closure built by MAKE-INSTANCE
uested by SEND.
(unless methodargs
name flavor)))
          (flavor-combined-methods flavor)))
ult-handler

             (flavor-name flavor)

************ÿ
                                *
                            *
                        *
***********************
ning primary :DAEMON methods.
method encountered
defun zil-combine-daemon-methods (flavor message &aux m)
or f in (flavor-all-flavor-list flavor)
            (assq message
zil-get-flavor f))))
ary :DAEMON method found for this message"
message)))
ped) methods.
order &aux mlist m)

 message
)))
ntyped) methods,
ll mlist)
etq m (assq message
-get-flavor f))))
Ë
vor) message))
ase-flavor-last    (nreverse mlist))
             (flavor-name flavor)
))
.

op for f in (flavor-all-flavor-list flavor)
ge
         do (push m mlist)
t method combination for combining AFTER methods.
ÿ
bine-after-methods (flavor message &aux mlist m)
flavor-list flavor)
      (flavor-a* fter-methods (zil-get-flavor f))))
)
************************************************************
                                                       *
 1989 The Charles Stark Draper Laboratory Inc.     *
reserved.                                        *
                                             *
******************************************
m - November 1987
-source-member zlflvstr))  ; Flavor defstruct.
le calls to SEND in this module.
all . ÿ
*********************
                *
            *
          *
*******
	
**

                                                   ÿ
********************************************************************

))
at t "~&~A~2%~S~2%" ,(string-append slot ":")
(concat "FLAVOR-" slot) flavor)))
me)
 ÿ
Â
       all-instance-keywords
   component-flaÿ
hods
ter-methods
      component-flavor-list
ll-flavor-list
ce-variables
t
-keywords

**************************
                       *
                     *
                 *
**************
(funcall self ,message . ,args))
s)
*******************************************
         ÿ
                                    *
                                *
************************ÿ
age)
******************************************************
                                       ÿ
                                               *
                                           *
****************************************
instance symbol value)

<

                                                                    *
*****************************************************************
defuÿ
tance :symeval-in-instance symbol no-error-p))
r SYMEVAL-IN-INSTANCE
ace value)
F syntax" place))

self
ods

***************
          *
.     *
    *
*

ucture of the type FLAVOR.
           instance-variables
ance-initializers
nce-keywords
vors
 primary-methods
          default-methods
flavor-list
           dependent-flavor-list
           required-methods
init-plist
      which-operations
 the sÿ
avor-instance ; An instance of a given flavor.
 ; The symbol that names the flavor.
ical closure that impÁ lements it.
<
*                                                                     *
L (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
    All rights reserved.                                        *
                                                            *
*********************************************************
; ZIL ÿ
*******************************************************
                                                  *
                     ÿ
                                            *
ple values.                             *
                                    ÿ
***********************************
*****************************************
                                    *
                                  *
                              *
                          *
                        *
*********************
           ; Load the FLAVORS functions.
bÿ
vstr)) ; Flavor defstruct.
                ; No instance variables
component flavorÿ
---------------------------------------------------------------------
he following is not active now, but will be when a true Common LISP
function is established - some ÿ
-------------------------------------
 escape)

 (
t-level* ,level)
))
      (princ ,ga ,gs)))))
 *print-escape*))
thod (vanilla-flavor :print-self)
                 (prindepth 0)
ape*))
epth)))
lprint (flavor-name *flavor*)  file level slashify-p)
         ÿ
lashify-p)
; Dunno what else to return.
------------------------ÿ
	
le prindepth slashify-p)

F method (depth) ignored by ZIL."
of flavor " file b)
   (zcprint " "                     file b)
          file b)
 self       ; Dunno what else to return.
method.

ms (flavor-component-flavor-list *flavor*))
vor-list *flavor*))
)
prin1 (flavor-name *flavor*))
 then
)
  ")
"It has no component flavors.")
cs
flavors:")
         ")
(princ "It has no included flavors.")
  (if alls
on flavors:")
c "         ")
     (princ "Thus, it has no other flavors.")
 )


sq var (special-alist))))
 binding (cdr binding) (zilunbnd))))

ndif 
	
nilla-flavor :get-handler-for)
lavor-combined-methods *flaÿ
NS method.
    ()
erations *flavor*)
r*))))
efmethod (vanilla-flavor :eval-inside-yourself)
orm)

est args)
*************************************************
                                              *
 for compatibility with the NIL           *
                                      *
       ÿ
*********************************
.
; message name.
          (&rest margs)
ng for :SEND-IF-HANDLES message"))
))))
lapply h margs)
HANDLED-P method.

*)) t nil)
anilla-flavor :equal)

 (vanilla-flavor :symeval-in-instance)
p)
  nil)
" ÿ

(cond
  (zerror "SET-INÿ
;


r :eval)
uated"
g NIL-implementation messages are not supported:
it-self, :select-nth, :store-nth,
{
*********************************
                            *
per Laboratory Inc.     *
                      *
                  *
***************
elements of a list.  Assumes:
;;; (DEFUN PLUS (&REST X) (ZMADD X))
erpreter only.  The compiler implements
d into the requisite number of calls
dd (x)
x))
etq v (ziladd v (zcar x)))
v))))
*****************************************
                                    *
tark Draper Laboratory Inc.     *
                              *
                          *
***********************
IV over elements of a list.    Assumes:
(ZMDIV X T))
is for use under the interpreter only.  The compiler implements
UOTIENT as macros that expand into the requisite number of
V.
(and onep
ro• g (v)
cdr x))
p))
******************************************************************
                                                             *
yright 1989 The Charles Stark Draper Laboratory Inc.     *
ights reserved.                                        *
                                                   *
************************************************
;;;
FUN = (&REST X) (ZMEQ X))
ly.  The compiler expands
L.
ing argument(s)" '=))
(zilequal (car x) (cadr x)))
q v (zcar x))
 (zilequal v (zcar x))
     (go loop))
n = (&rest x) (zmeq x))
******************************************************************
                                                             *
yright 1989 The Charles Stark Draper Laboratory Inc.     *
ights reserved.                                        *
                                                   *
************************************************

N GCD  (&REST X) (ZMGCD X))
only.  The compiler implements
site number ÿ
null x)
op
r x)))

***********************
                  *
tory Inc.     *
            *
        *
*****
of a list.  Assumes:
is is for use under the interpreter only.  The compiler expands
e requisite number of calls to GREATERP.
ond

 (v)
x (cdr x))
         (return nil))
))
 

************************
                   *
atory Inc.     *
             *
         *
******
 a list.  Assumes:
 is for use under the interpreter only.  The compiler expands
requisite number of calls to LESSP.

  t)
       loop
))
eturn nil))
(eval-when (eval)

***********
      *
  *
*


umes:
e under the interpreter only.  The compiler implements
t expands into the requisite number oÿ
efun zmmax (x)
   (setq v (zcar x))
 (setq v (max2 v (zcar x)))
	
***********************************
                              *
raper Laboratory Inc.     *
                        *
                    *
*****************
elements of a list.  Assumes:
;;

 MIN2.
))
(cdr x))

***********************************************************
                                                      *
1989 The Charles Stark Draper Laboratory Inc.     *
eserved.                                        *
                                            *
*****************************************

     (&REST X) (ZMMUL X))
 This is for use under the interpreter only.  The compiler implements
nd TIÿ
LMUL.
v)
dr x))
o loop))
;***********************************************************************
                                                                   *
c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
 All rights reserved.                                        *
                                                         *
******************************************************
"

rpreter only.  The compiler expands
 to NGREATERP.
(zerror "Missing argument(s)" '<=))
ddr x))
           (setq v (zcar x))
        (unless (ngreaterp v (zcar x))

(eval)

****

ÿ
                                                                     *
******************************************************************


 the interpreter only.  The compiler expands
 of calls to NLESSP.
Å
ull (cddr x))
½
           (unless (nlessp v (zcar x))

(eval)
®
****

ÿ
                                                                     *
******************************************************************


ST X) (ZMREM X))
compiler implements
uisite number of
turns n, not 1//n.

when (setq x (cdr x))
           (go loop))
	

;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
         All rights reserved.                                        *
                                                                 *
**************************************************************
; Not Commoî n Lisp, but for Macsyma only.
L since ASCII isn't really ASCII,


****************************
                       *
aboratory Inc.     *
                 *
             *
**********
syma.
&optional (msg nil msg?) (datum nil datum?) kwd)
(< (msglevel) 3)

  (dolist (i msg)
    (princ " ")))
- ")
          (cterpri)
inc kwd)
rpri )))
**********************************************************************
                                                                 *
 Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
ll rights reserved.                                        *
                                                       *
****************************************************
*ÿ
                                                       *
e printer - sensitive to ^W and ^R variables.      *
                ÿ
**********************************************
(defvar ttyoff '^W)
ource-member zcsdfstr))

#.ttyoff)
                  (if (eql b #.%%%charpos) 1 n8 il)
dprint a f b)
           (zdprint a w b)


                                                                    *
(c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
  All rights reserved.                                        *
                                                          *
*******************************************************
 kluÿ
ssed a list of characters
ters)

ince this one simulates Maclisp syntax,
ng can handle this.
ic?)
)
r (zcar a)) '/)
          c (ebcdic (zcar a)))) ; Assume always fÿ
((symbolp car)
t
(setq a (cdr a))

*******************************
                          *
r Laboratory Inc.     *
                    *
                *
*************
Macsyma.
BSTQUA,
efore, (ZMSSUBST NIL NIL X) is equivalent to (COPYTREE X)ÿ
 zmssubst (a b x)
        (cons (zmssubst a b (zcar x))
               ;(cdr x) ; <--- Prevents substing NIL tails.
          ;
se
                    ; substitution that way.
       ü                  (zmssubst a b (cdr x)))))))
·
*********
    *
*
<
***********************************************************************
;;;
umes:
RENCE (&REST X) (ZMSUB X NIL))
er only.  The compiler implements
d into the requisite number of
ub (x onep)


v (zcar x)))

************************
                   *
atory Inc.     *
             *
         *
******
 (c &optional f)

********
   *


**********************************************************************
;;
e purpose in life is to

; macros as in the following exampÿ
) (QUESTION-MARK-MACRO X)))
 (RDRMACRO '×?× (ZILLOAD 'ZRMAPPLY))
 (QUESTION-MARK-MACRO X)) '×?×)
acter ? to act as a reader macro
is the property of
MACRO*.
ile name.

Ý
****

ÿ
                                                                     *
******************************************************************
; This functionÿ
            This function now returns the expansion of a backquoted
    expression at read time, rather than at evaluation time.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ÿ
ld function definition (created a call to the ` macro)
)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
efun zrmbq (f) ; F is the file name passed by the READ function
f))
********************************************
                                       *
s Stark Draper Laboratory Inc.     *
                                 *
                             *
**************************
he reader macro , (comma).
 passed by the READ function
    (tyi f)            ; Throw away the character.
×,@×)

))
**************************************
                                 *
k Draper Laboratory Inc.     *
                           *
                       *
********************
der macro ' (QUOTE).
d by the READ function
ää
******
 *

;*                                                                     *
********************************************************************

urpose in life is to
aracter.
isp
le name being read.
er.
********************************************
                                       *
s Stark Draper Laboratory Inc.     *
                                 *
                             *
**************************
he reader macro #.
 #'FOO   --> (FUNCTION FOO)
s
--> evaluated value of FOO.
haracter FOO.
rrespinding to "CONTROL Y" if it existed.
n octÿ
eger expressed in hex.
   --> integer expressed in binary.
ry.
nts.
FOO.  Currently this is
ed to be
xtensions...
 FIXNUM expressed in hex.
r, if the symbol whose print name is that
property.  This property must be a
ame) much like a read macro.
ut READ.
(NULL      .   #X00)
 .   #X05)

ÿ
WLINE   .   #X15)
  #X16)

    (PAGE      .   #X2C)
     .   #X40)
LTMODE   .   #X100) ; "Invalidÿ
m (x)
ile name passed by the READ function
set to first non-numeric character read.
     loop
                            (zerror "No dispatch character for #")))
         (setq d (digit-char-p c 10))
                   (return z))
d))

(b (get a 'sharpmacro))
                (funcall b f n))
-quote   f n))
        ((eq a '\-)                   (sharp-minus   f n))
)       ÿ
    (sharp-comma   f n))
 f n))
((eq a '\^)            ÿ
              (sharp-octal   f n))
rp-hex     f n))

 '\×)                   (sharp-comment f n))
      (sharp-vector  f n))
0  f n))

=

Throw away the character following the #.


arpÿ

d f)))  ; Return NIL if error evaluating form.
==================ÿ
> ...whatever the value of (foo) is at load time ...
omma (f n)
 (featurep 'zilco) ; If being reaÿ
"Load-time evaluation (#,) not supported by ZIL compiler.")
princ "Processing as read-time evaluation (#.).")
-period f nil) ; Process like #.
========================================
ature, then whatever follows
arn "Numeric modifier not allowed for #+" n))
racter following the #.
res (read f)) (read f))
l))))

lowed for #-" n))
ond
                          (read f))))

 (mapor  #'sharp-eval-features (cdr x)))
sharp-eval-features (cdr x)))
ull (cddr x)))
 x)))
†

same as #/foo
modifier not allowed for #\\" n))
ng the #.
n impossible character object fixnum for CNTL-foo
rol (f n)
) ; Throw away the character following the ÿ
tion f))
nil f)))
(c (assq r '#.character-types)))
     (if (eql (string-length r) 1) ; If it read 1 character
     a


8))
Numeric modifier not allowed for #X" n))
#b1011 .ÿ
er not allowed for #B" n))
	
red for #R"))
 modifier for #R" n))
)
r)
l f nil #+ZIL13 nil)
adix" radix)))
  (go get1))
             (go next))
        (go next))
r-p a 36) (go ret))))
   (push (symbol-name (ebcdic a)) err)
 z radix)))))
       (go loop)
 digit(s) for radix " ,radix)
(ÿ
nn except that it always produces a fixnum,
, and therefore cannot have more
 example...

allowed for #Z" n))
(prog (a z count err)
eql (setq a (or (tyipeek nil f nil #+ZIL13 nil)
 (zerror "No digits following #Z")))
(tyi f)
           (zerror "Too many hex digits in #Z constant"))
(1+ count))
       (if (not (< weight 16))
)) err)
tyi f)
 (when err (zerror "Invalid hex digit(s)" (nreverse err)))
)

 away the character following the #.
        ; Sÿ
      ; See what we got.
, terminate.
 ×#.
(or (eql c #\#) (go chk1)) ; If not #, check as usual.
l)))          ; If ×# found, return to reader.
      ; If we got #, may be nested #×.
; Get next character.
hecking.
Ó
o loop)))))
't throw away the left parenthesis - we need it to read the list
(n
q l (read f))

warn "Too many objects for #(, ignored" l)) ; )
       ((null l)
  (zerror "ÿ
etq y (zcar l))
      (setq i (1+ i))
 f)))))
rted into
 We have NOT activated it.  #^ exists only because of Macsyma,
't want to cause any "real" EBCDIC characÿ
CII control characters.  So we let #^
instead.
 256)))
pposed to be the
as part
        ;
f (nth #\A  cflist) #X01) ; SOH
X
  cflist) #X37) ; EOT
      ÿ
) #X2F) ; BEL
tf (nth #\I  cflist) #X05) ; HT

  cflist) #X0C) ; FF
    (setf (nth #\N  cflist) #X0E) ; SO
F) ; SI
(nth #\Q  cflist) #X11) ; DC1

cflist) #X3C) ; DC4
      (setf (nth #\V  cflist) #X32) ; SYN
#X26) ; ETB
f (nth #\Y  cflist) #X19) ; EM
UB
;        (setf (nth #\\  cflist) #X1C) ; {I}FS
ist) #X1D) ; {I}GS (cntl-right-bracket)
1ÿ
(setf (nth #\`  cflist) #X40) ; SP
 ;
 cflist) #\= ) ;+
   (setf (nth ÿ
;;;  ))
cter following the #.
     (or (nth c '#.control-fa× keouts)
control spec" (ebcdic c))))){
*************************************************************
                                                        *
t 1989 The Charles Stark Draper Laboratory Inc.     *
 reserved.                                        *
                                              *
*******************************************
r transform for ADD1 (1+).
*************************************
                                *
       ÿ
                          *
                      *
                  *
*****************

 (cond
;;;;;;;;
rm.
;;;;;;
 (let* (

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
nt, perform the test at compile time.
numeric arg) occur, the compiler
 error and suppress
;;ÿ
rg
 (car carg)))
;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ((and (consp arg)
 (memq (car arg) '(sub1 1-)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; Otherwise, no transformations apply.  Return the original form.
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;( ;;;;;;;;;;;;;;;;;;;;;;;

***************************************************************
                                                          *
ght 1989 The Charles Stark Draper Laboratory Inc.     *
ts reserved.                                        *
                                                *
*********************************************
ler transform for AND.
****************************
                       *
         ÿ
                 *
es added to  *
MQ.      *
       *
****
body form formcon)
;; (AND) --> T
) --> x
; If for effect only (context is null):
 y))
ke
 tail)))
tq body tail)
(zilcocon form nil))
optimization this round
   ;ÿ

IL <more_forms>) --> (AND <forms> NIL)
   (warn `("AND forÿ
    (cdr body))
                    collect oldform
dform form)))))
orms> <more-forms>)
)))
m
ns apply
 
********************************
                           *
er Laboratory Inc.     *
                     *
                 *
**************
PEND.
ld MXAPPEND "macro" expander.
D2 FOO NIL) for idiomatic list-copy.
2) (zxappend1 (cdr l)))
nil)
l)) `(append2 ,(car l) ,(cadr l)))
l) ,(zxappend1 (cdr l))))))
***************************************************************
                                                          *
ght 1989 The Charles Stark Draper Laboratory Inc.     *
ts reserved.                                        *
                                                *
*********************************************
ler transform for all ZIL functions that always
onstant arguments, and that have no
hese include but are not limited to arithmetic functions.
purpose oÿ
on constants at compile time.
uality predicates cannot be
cate is not always
y test at


 should have their own.
sforms too!
ver occur
luded here - see ZXCARCDR.
will check the package
.  Right now
a
 vectors cannot be included here, since
ectors.  Anyhow, the same

 lists should be consed afresh whenever possible.
y to strings, but not now, since ZIL doesn't
we can transform stÿ
(eval)
   '(abs
   bigp
nsp
 ebcdic

rn
ansform
   integerp

es, checks print name only
r
gcount
n transform
        lxor      ; at least until it has its own transform
         minus
    make-bigÿ
num

        string-length
p

op
teger-length
;;;;;;;;;;;;
es?

t-folded, since some day strings will be mutable.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
p char-upcase downcase string-downcase
g-appendl scapital
-remove
Î
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
;;;;;;;;;;;;;;;;;;;;;;ÿ
guments are constant, perform the test at compile time.
 errors (like wrong # of arguments) occur, the compiler
mechanism will trap the error and supÿ

;
       (warn "Evaluating at compile time" xform)
)
;
.
;;;;;;

                                                                     *
 (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
   All rights reserved.                                        *
                                                           *
********************************************************
a genÿ
ultiple arguments.  For example...
(ZILADD 1 2) 3) 4)
med

                   (4) NIL if it's OK to have no operands
           (in which case the valueÿ
    (3) is returned); otherwise an error is
nalled if no operands are specified.
s optional, default = NIL.
er.  As such, the
rom
(x) (zxarith (cdr x) 'ziladd 0))
*********************************************
                                        *
                                    *
ÿ
.                             *
                          *
***************ÿ
onal needsargs)
              (zerror "Missing argument(s)" needsargs)
    iden))
) <=> n.
verse args) func iden))))
ond
c ,(zxarith-reverse (cdr args) func iden) ,(car args)))))

*************
        *
    *
  *
<

tly, inline code is always generated (except in the
n a call to ASSQ is generated, which
(eval-when (eval)
riable-p (x)       ; Please, x must be a symbol.
 xenv)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ere must be at least 2 arguments.  If there are fewer,
 is done.  However, if there are more, then GETK
r invalid keywords,
ich in the


let*ÿ
         (rest (cdddr xform))
    (test      (getk rest ':test))
))
 (if test 2 0)
                   (if key 2 0)))
env xcon arg1 arg2
                     (car test) (car test-not) (car key)
   test test-not key)))))
arg2
ü
                            test? test-not? key?)
zilcocon arg1 nil))
  (if test?     (zxassoc-confun test)))
soc-confun test-not)))


ument is such that more keys were
 the transformation.
 for the possi+
.
;;;;;;
dard or unexpected keyword args to ASSOC" xform)
;;;;;;;;;;;;;;;;;;;;;;;;;;;ÿ
  ;; If all arguments are constant, perform the test at compile time.


t)
 ckey)
pile time"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 If :TEST is #'EQ or 'EQ, and no other keywords are specified,
sform the call to ASSQ.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
t-not?)
    `(assq ,arg1 ,arg2))
;;;;;;;ÿ
, error.
;;;;;;;;;;;
 and :TEST-NOT keywordÿ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; Otherwise, transform the call to inline code.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ÿ
 (let (
       (arglist    nil)
ensym))


        (t
)
   (let ((g (gensym)))
 lambdalist)

'(eql)))
test)))
t arglist)
(funcall ,g)))))
test-not))
setq ftest `(funcall ,test-not))+
gensym)))
        (push g lambdalist)
     (cond

    (setq fkey `(funcall ,key)))

         (setq fkey `(funcall ,g)))))
 tÿ
erpretations.
 ,item (,@fkey (zcar ,elt)))))

st
            (cond

,true))
             (go ,loop))
     (return nil)))
turn ,elt))))
-confun (x)
 (null  (cddr x))
adr x)))


 ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
       All rights reserved.                                        *
                                                               *
************************************************************
 is the cÿ
e include:
;   ZILSUB - the 2-argument function underlying - or DIFFERENCE
the 2-argument function ÿ
unction underlying / or QUOTIENT
ing // or REMAINDER
; (1) Constant folding - evaluation of ÿ
ants at compile time
ing zero or
e appropriate
**************************
                     *
                 *
               *
           *
       *
****ÿ
ftrans zilsub zxbinop)
p)
    zxbinop)
xenv xcon &aux
                        (intfunp
'(zilrem ash lsh rot))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2 arguments.  If not, skip transform.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
))
         (arg2 (caddr xform))
    (carg2 (zilcocon arg2 nil))
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



ansformation.
;;;;;;;;;;;;;;;;
forming compile-time "
      (ziladÿ

    (zildiv "division")
                       (t  ÿ
rg2))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ne of the arguments is a constant, and theÿ
 transformations depend on the function.
argument must be of the correct type to
g out a constant of the wrong
rcions.
;;;;;;;;;;
;;;;;;;;;;


  (and carg2 (not (numberp (car carg2)))))
gument"ÿ
;;;;;;;;;;;;;;;;;
 x)
;;;;;;;;;;;;;;;;;;;;;;ÿ
              (or (and carg1 (not (integerp (car carg1))))
  (and carg2 (not (integerp (car carg2))))))
argument" xform))
;;;;;;;;;;;;;;;;;;;
0.0)  --> error
;;;;;;;;;;;;;;;;;;
             carg2 (zerop (car carg2)))
sion by zero" xform))
;;;;;;;;;;;;;;;;;;;;;
LSUB x 0)  --> (VALUES x)
 or 0.0
(LSH    x 0)  --> (VALUES x)
  ÿ
;;;;;;;;;;;;;;;;;;;;;;;;;;;
func
ues ,arg1))
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(ZILMUL 0 x)  --> not transformed, may go to 0 or 0.0
> not transformed, may go to 0 or 0.0
 ;; (LSH    0 x)  --> (PROGN x 0)
(ROT    0 x)  --> (PROGN x 0)
;;;;;;;ÿ
 (case func
           (zilsub               `(minus ,arg2))
h ash rot) `(progn ,arÿ
)
;


 ;; (ZILREM x 1)  --> (PROGN x 0)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   (case func
  (zilsub    `(sub1 ,arg1))
ildiv)  `(values ,arg1))
              (t         xform)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Â
 (ZILDIV x -1)  --> (MINUS x)
  ÿ

  `(sub1 ,arg1))
  (zilmul   `(minÿ
                (zilrem   `(progn ,arg1 0))
))
;;
transformed
transformed
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ÿ
eql arg1 -1)
))
form)))
;;;;;;;;;
nal form.
;;;;;;;;;;;;

**

;*         All rights reserved.                                        *
                                                                   *
****************************************************************
The compiler ÿ
LBOOL A B C) D)
the old MXBOOLE "macro" expander.
 &aux (args (cdr x)))
w arguments" x))
 (car args))

     ,(zxboole-reverse temp (reverse (cdr args))))))))
verse (op args)
car args)))
))))
****************************************
                                   *
ark Draper Laboratory Inc.     *
                             *
                         *
**********************
CDR, etc. - in general,
 
**

;*                                                                     *
********************************************************************

*

                ÿ
/20/88 - Support for multiple values.                             *
                                                              *
*******************************ÿ
(eval-when (eval)
  zxcarcdr)
rcdr)
)




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
s null (evaluated for effect only),
he CAR/CDR thereof.
R x) y) to be
re
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
`(values ,(cadr xform)))
;;;;;;;;;;;;;;;;;;;;;;;;
 Return the original form.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
°ª°ª
*******
  *
<

*********************************************************************

m xenv xcon)

     body (cdr xform))
 body) (return nil))

   (zerror "Invalid COND clause (not a list)" clÿ
r clause)
lause))
n possible
 ;; (COND (A B) (NIL FOO BAR) (C D)) --> (COND (A B) (C D))
l (car thencon))
 not executed due to false THEN clause"
 (return (cons head (remq clause tail))))
hen clause" is TRUE.
n "COND clauses skipped due to true THEN clause"

;; (COND ('TRUE FOO BAR)) --> (PROGN FOO BAR)
    --> 'TRUE
gn elseform))
 (COND (A B) (T FOO BAR))
m in tail
    until (eq oldform clause)))))))
 (cdr body))     ; Next clause
      ; No more optimizations apply

*************************************************************
                                                        *
t 1989 The Charles Stark Draper Laboratory Inc.     *
 reserved.                                        *
                                              *
*******************************************
r transform for EQUAL.
ond
;;;
©
;;;;
t* ((arg1 (cadr xform))
ilcocon arg1 nil))

 ;;
 then optimize the call.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ot carg2))
      ((and carg2 (not carg1))
 carg2)))
;;;;;;;;;
mpile time.
;;;;;;;;;;;;;;;;
ing EQUAL of two constants at compile time"
carg2))
;;ÿ
e, no transformations apply.  Return the original form.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
xform))))))


;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(eql ,arg ,carg))
;;;;;;;;;;;;;;;;;
 to call to EQ.
 (EQUAL NIL X)  --> (EQ X 'NIL) ; may be further transformed
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+
mbolp carg)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ions apply.  Return original form.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
§
***********************
                  *
tory Inc.     *
            *
        *
*****
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Cannot transform the following:
1.0F0
be 1 or 1.0 or 1.0F0
ASH would be possible
equires
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
*************************************************************
                                                        *

                                                  *
 multiple values.                             *
              ÿ
*****************************************

xpt)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; There must be exactly 2 arguments.  If not, skip transform.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ÿ
not (eql (length xform) 3))
 (arg1 (cadr xform))
ocon arg1 nil))

;;;;;;;;;;;;;;;
 at compile time.
, the compiler
s
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
         ÿ
(expt (car carg1) (car carg2)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
t-a-number x)

Í
-numeric first argument to EXPT" xform))
berp (car carg2))))
" xform))
r "Second argument to EXPT is a bignum" xform))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 (VALUES x)
;;;;;;;;;;;;;;

©
(G00001) (ZILMUL G00001 G00001)) (foo))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ÿ

ul ,g ,g)) ,arg1))))
;;;;;;;;;;;;;;;;;ÿ
urn the original form.
;;;;;;;;;;;;;;;;;;;;;;;;;
cal-variable-p (x)       ; Pleas  e, x must be a symbol.
(memq ,x xenv)))
******************************************************
                                                 *
The Charles Stark Draper Laboratory Inc.     *
ed.                                        *
                                       *
************************************
form for CEILING, FLOOR, ROUND, TRUNCATE.
****************************************************
                                               *
ÿ
                                         *
 values.                             *
               ÿ
********************************
context-p ()

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 be either 1 or 2 arguments.  If not, skip transform.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ÿ
er (length xform) '(2 3)))
 (car xform))
FIX=FLOOR
                                               (floor    . 4)
                                (ceiling  . 8)
                 (round    . 12)))
nvalid caller of ZXFIX" xform))))
(carg1 (zilcocon arg1 nil))
 (if arg2? (caddr xform) nil))
))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ility of multiple values being returned,
rm as is.
;;;;;;;;;;;;;;
    xform)
;;;;;;;;;;
, perform the
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1 (not arg2?))
       (funcall function (car carg1)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
nts, and they are both constant, perform
©
;;;;
le time" xform)



LFIX FOO 4)
  FOO) --> (ZILFIXÿ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
fix ,arg1 ,zilfixnum))
;;;;;;;;;;;;;;;;;;;;;;
eturn the original form.
;;;;;;;;;;;;;;;;;;;;;;;;;;;

*****************
            *
nc.     *
      *
  *
	
n (eval)
&aux (l (length xform)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
nts.  If not, skip transform.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 xform))
arg2 nil))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
e constant, perform the test at compile time.
ike wrong argument type) occur, the compiler
ill trap the error and suppress
;;;;;;;;ÿ
         ((and carg1 carg2)
g1 arg2)
;;;;;;;;;;;;;;;;;;;;;;;ÿ
©
.

Non-integer first argument to GCD" xform))
ntegerp (car carg2))))
" xform))
;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
rg2 0)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
	
;;;ÿ
CD2 x 1)  --> (PROGN x 1)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ((or (eql arg2 +
;;;;;;;;;;;;;;;;ÿ
Â
.

	
©
©
;;;;
<
*                                                                     *
L (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
    All rights reserved.                                        *
                                                            *
*********************************************************
e compÿ
ZXINTERN)

;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
) 2)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 2 arguments, issue warning about the second
convert to call to MKATOM.
 FOO T NIL)
;;;;;;;;;;;;;;
o INTERN ignored in ZIL" (caddr xform))



;Ä 
*************************************************************
                                                        *
t 1989 The Charles Stark Draper Laboratory Inc.     *
 reserved.                                        *
                                              *
*******************************************
piler transform for the LIST function.
;;
; used only for LIST*.
e (car 6 l)
zerror "Unknown caller of ZXLIST" (car l)))))
nd
 
********************************
                           *
er Laboratory Inc.     *
                     *
                 *
**************
 
**

;*                                                                     *
5/11/88 - Added constant-folding.                                  *
                                                               *
**************************************************************
log (xform xenv xcon &aux (l (length xform))
   (2argp (eql l 3)))
;;;;;;;;ÿ
ments.  If not, skip transform.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   xform)
     (arg2 (caddr xform)) ; may be NIL if not 2argp
n arg1 nil))

;;;;;;;;;;;;;;;;;;
st at compile time.
ccur, the compiler
uppress
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
not 2argp) carg2))
           (eval xform))
;;;;;;;;;;;;;;;;;;;;;;;;
 to call to ZIFLOG.
 ;;ÿ

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
erwise, no transfo› rmations apply.  Return the original form.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   (t xform))))))
*****************************************************
                                                *
he Charles Stark Draper Laboratory Inc.     *
d.                                        *
                                      *
***********************************
orm function for all of the
	
ss) body of the mapping macro call.

d code
This function replaces the old MXMAP mapping macro.
 ignore1 ignorÿ
             ; Macro name & body of macro call.
 mb)) ; Check args and get function name.
; List of lists.
locals.
z))))
            (zxmapc     f l g))

l g))
can   f l g))
    (zxevery    f l g))
ry          (zxnotevery f l g))
 (t                 (zerror "Unknown caller of ZXMAP" mf))))
; *** Helper functions ***
ation errors on map functions.
a constant function,

mb))                ; Two or more args required.
rguments" mf))
consp ff)
 (car ff) 'function)))
(or (atom (cdr ff))   ; (QUOTE), (QUOTE . FOO), etc.
     ; (QUOTE A B), etc.
	

 lam) 'lambda)
 " ,mf
          lam))

SETQ to set PROG list locals.
            ; (SETQ G1 L1 G2 L2 G3 L3)
                   ; or
    ; (SETQ V L1 G1 V G2 L2 G3 L3)
(cÿ
(nreverse z)))
(push (car l) z)
    (setq v nil)
h (car l) z)
s SETQ to CDR down all lists.
      ; (SETQ G1 (CDR G1)
                      ;       G3 (CDR G3))
                   ;
`(setq . ,(nreverse z)))
) z)))
bles.
2) (CAR G3))
) g)
==============
ensym)))
nd ((and . ,g)

f l g)
,(zxmap-initÿ
xmap-cars g))
¸
)) (d (gensym)) (e (gensym)ÿ
       ,(zxmap-init g l nil)
tq ,d (cons (,.f ,@g) nil))
                (t  (setq ,v ,d)))
      ,(zxmap-incr g)

(tag (gensym)))
»
s g)) nil))
(t  (setq ,v ,d)))
cr g)



))) (retuÿ
))
e the same transformation.
gs))

,g)
     ,(zxmap-incr g)
	
og (,v . ,g)
               (setq ,v (nconc2 ,v (,.f ,@g)))
g)
=
g))
((v (gensym)) (tag (gensym)))
      (prog ()
v))
    ÿ
v (gensym)) (tag (gensym)))
initialized to NIL by PROG
(and . ,g)
)
eturn ,v))))
ngth l)

(,v ,(car l)))
      (when (,.f (zcar ,v))

          (return nil))
et ((tag (gensym)))
ag (cond ((and . ,g)

urn t))))

))))
¸

(cdr ,v))
rn nil))
ry-m (f l g)
 l nil)
 g)) (return t))

l g)
any-m f l g))))
ensym)))
     ,tag
hen (setq ,v (cdr ,v))
          (return t))
efun zxnotany-m (f l g)
(zxmap-init g l nil)
@(zxmap-cars g)) (return nil))
   (go ,tag)))
;;;;;;;ÿ
solete. ***
in the

dless) body of the mapping macro call.
FUNVAR X) is expanded via (MXZMAP '(MAPCAR FUNVAR X))
p (xx)
error "Missing argument" F))
fied" F))
   ,(car x)
           )))))
 ) 'zmapl   )
aplist)
d )

ller of MXZMAP" mf))))
;; ;;;;;;;;;;;;;;;{
****************************************************
                                               *
e Charles Stark Draper Laboratory Inc.     *
.                                        *
                                     *
**********************************
APATOMS.
 2)
ist (,g (oblist) nil)
                  (eql (length f) 2)
r f) 'quote)
                     `(,(cadr f) ,g)
)))

***************
          *
.     *
    *
*

rently, inline code is always generated (except in the
when a call to MEMQ is generated, which


al-variable-p (x)       ; Please, x must be a symbol.
mq ,x xenv)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
hat there must be at least 2 arguments.  If there are fewer,
mation is done.  However, if there are more, then GETK
ror for invalid keywords,
il, which in the
on.
;;;;;;

)
          (test      (getk rest ':test))
st-not))
gth (+ (if test 2 0)
                         (if key 2 0)))
xform xenv xcon arg1 arg2
h
          test test-not key)))))
on arg1 arg2
-length
                                    test? test-not? key?)
carg1  (zilcocon arg1 nil))
ctest     (if test?     (zxmember-confun test)))
ot? (zxmember-confun test-not)))
nfun key)))
;ÿ
e &rest argument is such that more keys were
en suppress the transformation.
ay to allow for +
r-keys, etc.
;;;;;;;;;;;;;;;;;
rn "Nonstandard or unexpected keyword args to MEMBER" xform)


.
;;;;
 test?) ctest)
r (not key?) ckey)
t args at compile time"


 ;; then transform the call to MEMQ.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     (not test-not?)
'eq))
;;;;;;;;;ÿ
NOT specified, error.
;;;;;;;;;;;;;;;;;;;;;;;;
r "Both :TEST and :TEST-ÿ
))
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ÿ
   (t
sym))
     (item)

g1 (local-variable-p arg1))
    (let ((g (gensym)))
(push g lambdalist)
)))
         (setq list g))
t ctÿ
((local-variable-p test)
t
        (push g lamÿ
       (cond
  ((and test-not? (local-variable-p test-not))
 ,test-not)))
       (push test-not arglist)ÿç
list)
(ckey
y '(progn)))
ll ,key)))
key arglist)
funcall ,g)))))
test ,item (,@fkey (zcar ,list)))))
 x)))
list
                        (cond
                            (go ,true))
list (cdr ,list))
          ÿ
.(nreverse arglist)))))))
 ((and (consp x)
   (memq (car x) '(functi on quote)))
lcocon x nil))))
****************************************************
                                               *
e Charles Stark Draper Laboratory Inc.     *
.                                        *
                                     *
**********************************
rm function for MEMQUAL.
 and other Maclisp-compatibility-requiring
ransformed to MEMQUAL in order
OT a default ZIL transformation.  Code that wants to
st include the following:
 zxmemqua)
!
;
nd DEFTRANS don't get along with each other too well.
terpretive use, MEMBER is juÿ
in the compiler as well, until we made MEMBER
	
n zxmemqua (xform xenv xcon)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.  If not, punt transform.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
)

         (carg2 (zilcocon arg2 nil))

 ;;


Õ
   (warn "Evaluating MEMBER for 2 constant args at compile time"
    xform)
 used.")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
nly the first argument is a constant, ÿ
Q.
;;;;;
-to-memq xform))
;;;;;;;;;;;;;;;;;;
and it is a list of
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
rg2
ll l) t)
"Arg 2 to MEMBER is improper list" arg2)
))
 ÿ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ise, transform the call to a call to MEMQUAL.
;;;;;;;;;;;;;;;;ÿ
`(memqual ,arg1 ,arg2)))))))
ans `(memq . ,(cdr xform))))
mat t "~&Warning: converting ~SÆ  to ~S~%" xform ans))

***************************
                      *
boratory Inc.     *
                *
            *
*********

NC "macro" expander.
 (cdr l)))
   ((null (cdr l))  (car l))
 l)))

******************************
                         *
 Laboratory Inc.     *
                   *
               *
************


defvar *zxnth-threshold* 4
to CAR.")
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ((not (eql (length xform) 3))
     (arg1 (cadr xform))
zilcocon arg1 nil))

list operations,
s.
;;;
e time.
;;;;;;;;;;
 at compile time" xform)

 ;;
H x not-a-list)
;;;;;;;;;;;;;;;;;;;;
))
  (zerror "Invalid first argument to NTH" xform))
2 (not (listp (car carg2))))
TH" xform))
;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 (<= (car carg1) #.*zxnth-threshold*))
        (dotimesÿ
))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ions apply.  Return the origina+
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;
	
*************************************
                                *
 Draper Laboratory Inc.     *
                          *
                      *
*******************
	
**********
     *
   *

;*                                                                     *
**********************************************************************

n ()
 transform NTÿ
 
;;;;;;;;;;;
nsform.
;;;;;;;;;;;;

Ä
l))
not constant-folding list operations,
destructive operations.
;;;;;;;;;;;;;;;;;;;;;;;;;;
rm the test at compile time.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (warn "Evaluating at compile time" xform)
rg1) (car carg2)))
;;;;;;;;;;;;;;;;;;;
ative-fiÿ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 (not (and (fixnump (car carg1))
 (car carg1))))))
rm))
ror "Invalid second argument to NTHCDR" xform))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+
-> (VALUES x)
x)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
g1 0)
rg1) #.*zxnthcdr-threshold*))
dotimes (i (car carg1))
           f))
;;;;;;;;;;;;;;;;
e original form.
;;;;;;;;;;;;;;;;;;;

***********
      *
  *
*


*******************************************************
                                                  *
                                     ÿ
                                            *
 OR to COND in certain cases added to   *
on for weird things like MEMQ.      *
                                  *
*******************************
Ã
xform))
)
 tail)))
ORÿ
de in certain situations, like
(and (null xcon) (null (cddr tail)))
) ,(cadr tail))))ÿ
rm (car body))
Ñ
formcon)
timization to be done


wing constant " ,(car formcon))
loop for oldform in tail
                         until (eq oldform form)))))
rms> NIL <more_forms>) --> (OR <forms> <more-forms>)
eturn (cons head (remq form tail))))
q body (cdr body))     ; Next form
            ; No more optimizations apply
al)
***************************************************************
                                                          *
ght 1989 The Charles Stark Draper Laboratory Inc.     *
ts reserved.                                        *
                                                *
*********************************************
ler transform for PROGN.
***********************************
                              *
licit andÿ
erefore need not be     *
                    *
                *
that any      *
erted     *
r     *
    *
*

*     and making them arguments to this (explicit or implicit)        *
  PROGN so that they are subject to the same techniques.          *
                                                              *
*************************************************************
n zxprogn (xform xenv xcon)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
entsÿ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(null (cdr xform))
;;;;;;;;;;;;;;;;;;;ÿ
, return that argument without
 ;; e.g. (PROGN FOO) --> FOO
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
rm))
;;;;
orm.
;;;;;;;;;
*******************************************************************
                                                              *
pyright 1989 The Charles Stark Draper Laboratory Inc.     *
rights reserved.                                        *
                                                    *
*************************************************
ompiler transform for QUOTE.
rg)
;;;;;;;;;;;;;;;;;;
ip transform.ÿ
;;;;;;;;;;;;;;;;;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.
;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ment is such that quoting is not necessary,
the QUOTE.
  ;;
;
and (symbolp arg)
off
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 Otherwise, no transformations apply.  Return the original form.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 xform))² )
***********************************************
                                          *
rles Stark Draper Laboratory Inc.     *
                                    *
                                *
*****************************
r transform for relational operator
  For example...
 4))
            (2) the name of the primitive binary function
specified, the result is defined to be T.
p x 'lessp))
)

t (zxrelop-let args func)))))
 
st llist))
t))
) E) 'LESSP)
 LLIST   = ((NIL A) (NIL B) (G1 (C)) (G2 (D)) (NIL E))

 expansion:
ND (LESSP A B)
;;           (LESSP G2 E)))
op for subargs on newargs while (cdr subargs)
 
fun zxrelop-llist (args)

urnÿ
  z
                      ))))
i in llist
form)
quote))

**********************
                 *
ory Inc.     *
           *
       *
****
or "SETQ optimization"
***********************
                  *
                *
            *
*********
t is
ROGN, PROG, BLOCK, TAGBODY.
 optimizations relating to
  In particular, it
)
order to avoid unnecessary reloading of variables from memory when
still in regiÿ
ny "normal" compiler
is true if

this routine.  This function is expected to return a list of
ms (or the original first argument) in similar fashion.
qopt (xform xenv xcon tagp)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
TQ's in the body, no transformations apply
 may change in the future, but we
st some unnecessary consing.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
rm)
;;;;;
s that

;


z boddy)))
z))
ubst-setq-for-var (car boddy)
(cadr boddy)
           (cond
ar boddy) z))
(cddr boddy)))
   (push (car boddy) z)))
go loop)))))
  (eq (car x) 'setq)
dr x)))
for-var (setqform form tagp)

 foo) A  -->  (SETQ A foo)
vÿ
il)
      ;

      ;
)
ar form) ,x . ,(cddr form)))))
       (> flen 2))
SETQ B (SETQ A foo))
 (SETQ A foo)))
qform (caddr form) nil)))

((and (eq (car form) 'cond)
¤
    ;

car form) (,x . ,(cdadr form)) . ,(cddr form)))))
e-p (car form))
SETQ A foo))
)))
form) nil)))
      `(,(car form) ,x . ,(cddr form)))))
lid-function-name-p (form)g 
bda label))
 {
**********************************
                             *
aper Laboratory Inc.     *
                       *
                   *
****************
	
*****
*
<
***********************************************************************
 
xform xenv xcon)

;;;;;;;;;;;;;;;;;;;;;;;;;;;
e form NILÿ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;
pt to transform.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
flen)
;;;;;;;;;;;;;;;;;;;;
r than 2, break the

 it
;; optimizations relating to SETQ's (the PROGN will be eliminated
er transformations).
;;;;;;;;;;;;;;;;;;;;;;;;;
rm (cddr form))
rm)) z))
))))
;;;;;;
ities.
lue

;;;;;;;;;;;;;;;;;;;;;;;;;;
id non-self-evaluating name
))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 Otherwise, no transformations apply.  Return the original form.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;;;;;;
 (t xform))))
***************************************************
                                              *
 Charles Stark Draper Laboratory Inc.     *
                                        *
                                    *
*********************************
m for SUB1 (1-).
***************************
                      *
                    *
                *
            *
        *
*******
ftrans 1-     zxsub1)
d
;;;

;
* (
       )
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
erform the test at compile time.
ic arg) occur, the compiler
r and suppress
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 carg)))
;;;;;;;ÿ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(and (consp arg)
q (car arg) '(add1 1+)ÿ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Otherwise, no transformations apply.  Return the original form.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ˆ ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        (t xform))))))
**********************************************************
                                                     *
989 The Charles Stark Draper Laboratory Inc.     *
served.                                        *
                                           *
****************************************
ransform for TYPEP.
use (TYPEP X 'INTEGER)!!!
which compiles
	
**

                   ÿ
6/21/88 - Support for transforming (TYPEP 'foo).                   *
                                                               *
**********************************ÿ
un zxtypep (xform xenv xcon)
g xform xenv xcon))  ; TYPEP with 1 argument
env xcon))  ; TYPEP with 2 arguments
ypep-1arg (xform xenv xcon)
lcocon arg1 nil))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
is a constant, perform the test at compile time.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   (warn "Evaluating TYPEP of one constant at compile time"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
rmations apply.  Return the original form.
;;;;;;;;;;;;;;ÿ

½
  (carg2 (zilcocon arg2 nil))ÿ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
oth arguments are constant, perform the test at compile time.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ÿ
and carg1 carg2)
time"
ar carg2)))  ; Always T or NIL.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
rgument 1 is not,
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
carg1))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
no transformations apply.  Return the original form.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ases of (TYPEP <arg1> '<arg2>) where <arg2> is
compiled inline efficiÿ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   `(atom    ,arg))
      `(consp    ,arg))
fixnum)     `(fixnump  ,arg))
   ,arg))
   )            `(sfloatp  ,arg))
     )            `(dfloatp  ,arg))

)
        code)       `(codep    ,arg))
Å
g))
,aÿ
;;;;;;;;
 call.
;;;;;;;;;

**********************
                 *
ory Inc.     *
           *
       *
****
val-when (eval)
rm xenv xcon)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  If not, skip transform.
 there are
;; least not this time.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
)
(zilcocon arg nil))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
e argument is not in the form of a function that can
multiple values, transform the call to
without VALUEÿ
foo"
;;;;;;;
       (atom arg)   ; Argumeÿ

              (and (eq (get (car arg) 'defined-by) 'system)
   (get (car arg) 'builtin)
                    (neq (car arg) 'values)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

call for multiple values, transform the call to an
 itself, without VALUES.
;;;;;;;;;;;;;;;;;;;;;;;;;;;
                '(:dummy :value :return :mvlist :mvbind)))



;;
;***********************************************************************
                                                                   *
c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *
 All rights reserved.                                        *
                                                         *
******************************************************
e cÿ
t function underlying the = function.
ns zilequal zxzileq)
d
;;;
©
;;
t* ((arg1 (cadr xform))
ilcocon arg1 nil))

 ;;
 then optimize the call.
;;;;;;;;;;;;;;;;;;;;;;;;;;;
ot carg2))
      ((and carg2 (not carg1))
arg2)))
;;;;;;;;;
mpile time.
;;;;;;;;;;;;;;
g ZILEQUAL ofÿ
ar carg2))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
rwise, no transformations apÿ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   (t xform))))))
d
;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
arg) (zerop carg))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
tions apply.  Return original form.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

****************************
                       *
aboratory Inc.     *
                 *
             *
**********


ilgt (xform xenv xcon)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
arguments.  If not, skip transform.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

caddr xform))
ocon arg2 nil))
;;;;ÿ
rguments are constant, perform the test at compile time.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
and carg1 carg2)
compile time"
rp (car carg1) (car carg2)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;

      (zerop (car carg2)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ERP 0 x) --> (MINUSP x)
;;;;;;;;;;;;;;;;;;;;;;;;;;
berp (car carg1))
arg2))
;;;;;;
 l form.
;;;;;;;;;;;

*

*         All rights reserved.                                        *
                                                                  *
***************************************************************
his is the cÿ
ment function underlying the < function.
trans lessp zxzillt)
d
;;;
©
;;
t* ((arg1 (cadr xform))
ilcocon arg1 nil))

;;;;;;;;;;;;;;;;;;
est at compile time.
;;;;;;;;;;;;;;;;;;;;;;;
rn "Evaluating LESSP of two constants at compile time"
carg1) (car carg2))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; (LESÿ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (numberp (car carg2))
nusp ,arg1))
;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
nd carg1
 carg1)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ions apply.  Return the original form.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

*********************************
                            *
per Laboratory Inc.     *
                      *
                  *
***************
a.
;
hich we used to do in the compiler as well, until we made Aÿ
line - which we're trying to take advantage of now.
l)


  ;;
	
  (let* (ÿ
arg1 (zilcocon arg1 nil))

;;;;;;;;;;;;;;;;;;;;;;;
m the test at compile time.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(warn "Evaluating ASSQ for 2 constant aÿ
 xform)
Ë
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 first argument is a constant, and it is a symbol,
;
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ems, each of which is either NIL or a CONS whose CAR is a
se Aÿ
iler
 ;;       Actually, you won't get warned because we'll be calling
ZMSASSQ instead, abÿ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ((and carg2
   ((null l) t)
           (unless (or (null (caÿ
consp (car l))
                         (return nil))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ÿ
therwise, transform the call to a call to ZMSASSQ.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   (let ((ans `(zmsassq ,arg1 ,arg2)))
Ö
          ans)))))))
**********************************************************
                                                     *
989 The Charles Stark Draper Laboratory Inc.     *
served.                                        *
                                           *
****************************************
 for EQ, used in Macsyma.
y when necessary.
 of the compiler:
* niÿ
t

v xcon)
 arguments" form))

XNUM)
rg1) 2)
            (eq (car arg2) 'quote))
      ; 
   (eq-arg-is-not-a-number arg1)

     (let ((ans `(zmseq ,arg1 ,arg2)))
¤
         ans)))))
l x) t)


cadr x))))
key (flipargs ¿ t))
         (equal arg2 `(symeval ,arg1)))
 arg2 arg1 :flipargs nil))))
****************************************************************
                                                           *
ight 1989 The Charles Stark Draper Laboratory Inc.     *
hts reserved.                                        *
                                                 *
**********************************************
nsform for MEMQ, used in Macsyma.
s, but only when necessary.
st DEFLOADed to ZMSMEMQ.
 we made Mÿ
w.
un zxzmsmem (xform xenv xcon)
;;;;;;;;;;;;;;;;;;;;;;;;;ÿ
s.  If not, skip transform.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 (caddr xform))
lcocon arg2 nil))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 arguments are constant, perform the test at compile time.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(and carg1 carg2)
ompile time"
syma, ZMSMEMQ is being used.")
)
;
,
;;;;;;;;;;;;;;;;;;;;;;;;;;;
²
;;;;;;;;;;;;;;;;;;;;;
 and it is a list of
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ÿ
 carg2
ull l) t)
 "Arg 2 to MEMQ is improper list" arg2)
l))
  (return nil))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 call to a call to ZMSMEMQ.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
mq ,arg1 ,arg2)))
t t "~&Warning: converting ~S to ~S~%" xform ans))
	
