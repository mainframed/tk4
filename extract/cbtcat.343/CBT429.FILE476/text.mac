‹\INMR01








RITH  
  $ATTN   
525   $CALL   
ES
LIST  
  $COMPILE
B1525   
  
ORMS  
5   $HELP   

  
$MAP    
5   
°
  
$RMACRO 

	
    



ND  
×
§



¦

Èôÿ






©†



©



·	
©×
CODEP   

·
"
SEB1525   CONCAT  

Â?
PRI 
SEB1525   COPYTREE

Â"©

525   CURJDATE



B1525   DEFMACRO


  DEFTRÿ
B1525   DEFVAR  

LQL   
5   DESETQ  
B1525   DIFFEREN

DOLIST  
5   DOWNCASE
B1525   ECHO    
    
ENDP    
5   EOF     
SEB1525   
L   
ERROR   
5 ÿ

    
EXPLODE 
525   

UREP
  FIFTH   


XP    
  

  
AKUNBO

	¦
ON



  


À

ì

°¦
ô©Ø
Ë^



·É




ô 



Éô©½




GCOUNT

Ø

B1525   LOGNOT  

©
  
B1525   MAKNAM  

©
5   MAPC    
SEB1525   MAPCAR  

MAPLIST 
525   MAX     
SEB1525   MAX2    

  MEMQL   
525   MEXPAND 
SEB1525   MIN     
NARGS 
  MINUSP  
525   MKATOM  
SEB1525   
FLONUM
  MKLIST  
525   MKNUMBER
CT
DEL   
  MVBIND  
B1525   
1 
ONC   
5   NCONS   
Á
  
NOTANY  
5   
±
  
NUMBERP 


    



    







×ÿ






°‰



§



©

REMQL   

½Ã
§ü
SEB1525   RESTARG 


ü½
    
SEB1525   RMINIT  


×Ì
525   RPLACA  



B1525   SASSQ   


  SETABÿ
B1525   SETATTN 

TF    
5   SETNFEAT
B1525   SETPLIST

SETREAD 
5   SETSYNTA
B1525   SFLOATP 
P   
SIXTH   
5   SLENGTH 
SEB1525   
    
SQRT    
5 ÿ

M   
STRINGP 
525   

    
  SUBST   
	

B1    
  
©
Y 
RPRI  

Á
NG



  






©

ìÕ
"



ì·¦
·ì



ì·



©‚




ROP   

·½

B1525   ZEVAUTO 

°
R 
B1525   ZEVMAPP 

°Ô
5   ZGETFPI 
SEB1525   ZILADD  

ZILCLOSE
525   ZILDSNI 
SEB1525   ZILDUMP 

  ZILEVAL 
525   ZILFLAT 
SEB1525   ZILIMPL 
LINTLN
  ZILMUL  
525   ZILPKCH 
SEB1525   
LRDCH 
  ZILSPAD 
525   ZILSPRT 
  
LTEST 
  ZILUNBND
B1525   
C 
SPUT  
5   ZPUTFPI 
¦



********************************
         ×               ***
     ×               ***
   ×  L  I  S  P   ***
               ***
           ***
ON       ***
     ***
 ***
**

*       ZZZ              III     LLL               ×   ×   × \     ***
     ZZZ               III     LLL               ×   ×  ___ \    ***
ZZZ                III     LLL               ×   × /...\ \   ***
               III     LLL               ×   × ×.o.× ×   ***
           IIÿ
  Z      III     LLL            L  ×   × \___/ /   ***
     III     LLLLLLLLLLLLLLLL  ×   ×   ×  /    ***
IIIII   LLLLLLLLLLLLLLLLL  ×ÿ
                         ×               ***
****************************************
ion 1.3
l Rights Reserved
ers under the MVS
ommon LISP,
s
ed in ZIL.
ended as an
mended as
ird Edition) - Winston and Horn
the language, along with
 There aÿ
cially available book and a particular implementation like ZIL;
, the basic concepts of the language are generally the
 you should always refeÿ
ction in ZIL.

document:
in general.
   - Attention interrupt processing.
trary precision integers).
.
 What the compiler is looking for.
re defined.
ation on how files work in ZIL functions.
of FLAVORS object-oriented programming.
and objects that can be typed in.
e FORTRAN run-time library.
nÿ
rpreter on TSO.
Explanation of Maclisp-style LEXPR's.
les mapping funcÿ
ecution-time parameter options.
terface.
aracters.
ing the ISPF interface.

ithmetic functions in general
s follows:
er op single-float       --ÿ
   -->  double-float
     single-float op single-float  -->  single-float
ble-float  -->  double-float
-float
oat op double-float  -->  double-float
xnums and bignums, where the
nding on the
ts, the binary operation
 following the
 take only one argument, the type of the result is
he argument.  (Note that this is not true of
or which an integer argument produces a
L, the ÿ
ns, meaning that dividing one integer by another
integer result.
:
vert to single-float or double-float
ector/string space to build a bignum or double-float
ing-point overflow is not detected by‘  the code,
m check (0CC) abend.
e a zero result.
tyle array facility; it includes the *ARRAY, ARRAY,
, FILLARRAY, ARRAYDIMS and *REARRAY functions,
ction-call syntax of array references.
with vectors, which are native ZIL
nal, and their elements
 number of

 more efficient than arrays, at least in the current
 Arrays are present chiefly because
ray functions are autoloading, in that referencing one of
em all to become defined under the interpreter.
y of these, however, you must include
mpile)
 as they are implemented in
	
& ff.
y
 type ZIL-ARRAY which is created via
  An array has a fixed number of
the same number of subscripts
ts do not default; it is
ripts for an array
retical limit on
han two
aclisp supports four basic kinds of arrays - FIXNUM, FLONUM, T and NIL
ut in ZIL these are all processed identically, except for the way
data is initialized.  A FIXNUM array has all its elements
hen it is created; a FLONUM array has all its
en it isÿ
alized to NIL when they are
 the new array type


 a fixed number of fixnum arguments, which are its subscripts.  The
X), which normally refers to a functioÿ
o be a reference to a named array F with the single subscript
fected in ZIL by defining a SUBR property for F which
ccess (any existing function definition is saved
e array is "un-defined").
can reference an element of an array in the following ways:
 function call:  (arrayname dim1 dim2 ...)
ent of array F, analogous to the
Using the ARRAYCALL function (actually a macro):
dim1 dim2 ...)
 can't
 ÿ
ly a named array by name.  For example, if you have a named

e array by any oÿ
LL T 'FOO 2 2)
referred way to access an array, however, is ARRAYCALL, which
e of the above that works (or iÿ

	
 NOT evaluated, or
me1 and type2 ARE evaluated, are the functions used to
d unnamed arrays.  Either one creates an
e number of "dims") of the type
 FIXNUM or FLONUM).
which is

 the value of name1's ARRAY property, any existing function and array
itions for name1 are saved, and name1 is returned as the value


aximum index for a given dimension of length L is L-1.
re initialized to NIL, unless the array type
are initialized to 0) or Fÿ
0).

.
  a symbol that names a named array, or an unnamed array, or the value
he ARRAY property of another symbol.  If this object is not an
ror is signalled.  This function is used by most of the
ions to get hold of the actual array object that is

rwise NIL.  arg1 can

here type1 is NOT evaluated, or

  by array1.  If the number of arguments following array1 is equal to
 number of dimensions of the array, this returns the corresponding
of the array (unless all the dimension arguments are NIL, in
 entire vector of array elements is returned).  If the
folloÿ
the last argument is a value to which the
y is set, and that is also the
foo dim1 dim2 ... {nÿ
2 ... {newvalue}).  Note that for named
 quoted, or else it must be a
array.
orm that can be used to access an element
ets the corresponding element of
 be used to store array values.
FOO 2 2 'BAR)
CALL T 'FOO 2 2 'BAR)
'FOO 2 2) 'BAR)
en the following is permitted:

 (*REARRAY name1 &optional type2 &rest dims)
ÿ
me1 must be the name of a named array.
e array associated with name1.  Any
ame1 had is resÿ
 dim3 ...) is like (*ARRAY name1 type2 dim3 ...)
f the previously existing array named by
with the specified type and
ray associated with
 followed by
e.
ls array1 (a named or unnamed array)
of arg2, of whi excess
s used to fill
ray, its successive elements are used to fill in
rg2 were a list, except that if arg2 is too
rray1 are unchanged.  Row-major order
 Zil vector, its successive elements are used to fill in
me as if arg2 were a list, except that if arg2 is too
slots in array1 are unchanged.  Row-major order
rg2 is anything else, an error is signalled.
 value.
 returns a list of those elements.
e array (the product of its
 list in the same
e 0th element.
)
  elements are the lengths of the dimeÿ
#-DIMS array1)
nt because

ns the length of dimension num1 of array array2.  num1 must be
 If num1 is greater than the number of dimensions,
1 is not positive, NIL is returned.
  returns the type of array1.
ed arrays.
      ==> T
==>ÿ
) ==> 2
NIL
L NIL NIL NIL NIL ÿ
 NIL))            ==> #(A B C C C C)

==> (D E F C C C)
I J))))   ==> NIL
 1 2)     ==> (1 2)
 2))        ==> (1 2)
1
           ==> B2
 1 2) 'B3)                 ==> B3
 B3
             ==> B4
)                            ==> B5
=> B6
OO 1 2) 'B7)   ==> B7
 (APPLY 'FOO '(1 2)) 'B8)      ==> B8
=> B8
     ==> Tÿç
 (ARRAY-\#-DIMS 'BAR)        ==> 1
RRAY-DIMENSION-N 2 'BAR)  ==> NIL
RRAY-TYPE 'BAR)          ÿ
0 0 0 0 0 0 0 0)
         ==> (0 0 0 0 0 0)
Y 'FOO)            ==> (A B C D D D)
FOO
IXNUM 10)
==> 10
 ==> NIL
    ==> (A B C D D D D D D D)
  ==> NIL
(ARRAYCALL T 'FOO 3)        ==> 9
ys.
   ==> T
   ==ÿ
=> 3

C C C C)
 ==> (D E F C C C)
 I J (LIST I J))))   ==> NIL
FUNCALL A 1 2)            ==> (1 2)ÿ

                  ==> V1
RAYCALL T A 1 2)                  ==> V2
    ==> V3
 T A 1 2) 'V4)      ==> V4
È
           ==> V5
RAYP B))                ==> T

ÿ
 (ARRAY-TYPE B)              ==> FIXNUM
 0 0 0 0 0 0 0 0)
  ==> (0 0 0 0  0 0)
))            ==> (A B C D D D)
ollowing messages elicit responses from the ZIL user.
re documented along with the message.
A(BORT), R(ESUME), T(IME), H(ELP).
 as a result of pressing attention
Processing resumes as if no attention had occurred.
ocess is terminated, and control returns to

         the "top level".  The identity of the "top level" is
dependent upon the environment; normally, under the
r, this is thÿ
level is defined as the scope of a CATCH

er> - Time used so far is diÿ
  and the user is reprompted as above.
these options is displayed,
e.
ON-INTERRUPTIBLE PROCESS.  ABORTS WILL BE DEFERRED UNTIL PROCESS IS COMP

PA1); ZIL is currently in a section of code that cannot beÿ
ed (e.g. the garbage collector or the loader).  Responses are
ve.  However, if an abort is requested, the abort is
erruptible section of code is completed.  The
le, since in most cases the uninterruptible

esponse to message ZIL0051, a THROW to tag T
to resum, e at whatever was defined as the
D-EVAL-PRINT loop.
structure of bignums is as follows:
ing space which looks much like
e body of the bignum is
git of the bignum
rse order,
d using their absolute value, with the
 set to 1.  All other high-order
 zero.
never
ÿ
ost) word is never zero, since leading zero "bigits" are always
 (3) the minimum number of 31-bit "bigits" in a bignum is
n (-2147483647 ÿ
 which must be a fixnum.
nctions BIGLIST,
s of


 Before you read this, read member $COMPILE to understand the
nce between a PROGRAM and a FUNCTION.  The following
s to PROGRAMs only.  Note, however, that
PROGRAM, so the comments about
as wÿ
===========
CMD command
 you
)' - wherever your LISP program resides.
IL execution-time routines, the
 functions for evaluation.
sing the
A(your.library.name 'PROGLIB.ZIL.LOAD')
m string' FILE(ZILLIB)
g/ FILE(ZILLIB)
NVOKE to call
ish to
g
       command or ISPEXEC SELECT will work only if 'PROGLIB.ZIL.LOAD'
 is available to it, either through being allocated to ISPLLIB or

nclude a //STEPLIB DD statement to define these
ƒ
B DD DISP=SHR,ÿ
GLIB.ZIL.LOAD
 may be
       below for more informaÿ
nvoke a LISP PROGRAM - the proper
tically for you, with

's strictly for FUNCTIONs and MODULEs only.
s:


region size of 6144K; running with a larger region size will
s memory usage, but will leave more room for ZIL to load
cing the likelihood of out-of-storage abends.
remember that split screen mode also uses a lot
e other screen is in EDIT).  A similar
who have many sessions active.
 
ll
 is specified, GETPARM returns the null symbol (printed as ××).
ameter value may be paÿ
 CALL or XINVOKE command) or as TSO command operands
sed in the latter fashion, any leading blanks,
 are ignored.
er "\", then
 the

e.  For an explanation of this information, see member $PARM of
tation.
f you run in batch:
standard output file.
 however, you do not
inal is used
, ÿ
ill copy all terminal input and terminal output (with
 system messages) to this file.  If you are not
 or output, dribbÿ
other files you may need; you can use the
e input or output files.  However,
pened automatically by ZIL
as follows:
essible
  Furthermore, any DD name of the format ZILOyyÿ
utput functions (e.g. PRINT) that reference file "yyyy".
ems, it may be necessary to use this "pre-allocation"
e availability of sufficient virtual storage
xamples:
i(zilifoo) da(foobar.data) shr reuse
lable only if TSO/Extensions is
 You can also enter it while you are under ZIL, as follows:
alloc fi(zilifoo) da(foobar.data) shr reuse")
put file called FOO.  When you are in LISP,
 will read aÑ n S-expression from the

i(zilobar) da(foobar.data) old reuse
you are under ZIL, as follows:
ata) ÿ
 you are in LISP,
ression HI
 opened until they aÿ
ot worry about clobbering an output file
ame but is never used.
Examples:
 file name
(open "temp.data" 'out)) ; New file may or may not exist.

-OPEN-FILE.
.data'" 'in)
))))
-hairy-lisp-structure* outf))
de into the interpreter:

ÿ
 input and output (ZILI and ZILO), as well as the dribble file.
 use the XZIFILE and XZOFILE CLIST's to allocate files.  The
nds are equivalÿ
A(FOOBAR.DATA) SHR
OOBAR.DATA) OLD
ve.

 You must be hooked up to 'PROGLIB.CMD.CLIST' to use these CLIST's.

******************
             *
         *
       *
****
=====

	
erformance Improvement of More than 10%
==========================================

FULL support of
nsive
.
 bound, and the appropriate declarations should be added.

the behavior of some code will change if you do not
orrectly!
ZIL 1.2 code bÿ
e to the structure
Many common functions have different definitions - this has
 in cases where the ZIL 1.2 dÿ
r Common LISP.
amed, or
for LISP 1.5 syntactic constructs has been Dÿ
ISP source code should run just as well interpretively
ong as it does not use the old LISP 1.5-style
 on the function definitions that work
not run into a problem unless you
r to ZIL.
 the
erently.
 use the
    preceded by #+ZIL13 (or #-ZIL12) will be read under ZIL 1.3 only;
 form preÿ
  Note, however, that this will NOT enable LISP 1.5 syntactic
to be read; the ZIL 1.3 reader will not handle the $$
 EVEN if it is inside a +
======================ÿ
‡
single-float" and "double-float".  These correspond to the
on and double-precision formats of thÿ
  Floating-point numbers read into ZIL 1.3 are DOUBLE-PRECISION
t.  This means numbers with a decimal point and a
 exponent marker, or numbers with an
 
gle-precision flonums.
on flonums without
he number
n
ed precision is not supported.
rnÿ
le-float arguments;
eir arguments
version rules areÿ
e-float
op double-float  --> double-float
al second argument, which is
t.  If this argument
scendental
s expensive than double precision, both
.  However, double precision
s.  Note that some
ngle
============================================
SING

rinted in pieces, with the ZIL continuation character (the cent
the final position of each line.  The reader, when it sees
in the final position of a line, will process the
wing line asÿ
wlines.  (This does not apply to data
 the continuation characters may
the terminal.)
ings, bignums,
fixed-length records, the cent sign will be treated as a
racter if it occupies the last data column+
ECL=80 data set will recognize the cent § signÿç
tinuation character if it is in column 80 for unnumbered
lumn 72 for numbered data sets.
t sign will be treated as a
ast column of any record,
   The cent sign will NOT be treated as a continuation if it is
by a backslash, or if it is part of a comment field or
rt of a Lisp object being read in.
===================================
	
r may not bÿ
ing is NOT to be interpreted
th using it in
,
ailable; the ZIL system will treat the feature as any
function name would be treated.)
nger defined in ZIL 1.3.
 SPECIAL-ALIST,
e
 is obsolete.
The special significance of (DEFUN NIL ...) to the compiler
emoved.  It is now an error to attempt to define
e of NIL.
race ALL ZIL function calls
implementation of
ions
   is ÿ
 has been deleted.  In the future there should
le debugging facilities like EVALHOOK,
ollowing syntactic feÿ
 cause incorrect output in the reader:
nnO syntaxes for binary and octal
nnn)
	
    under ZIL 1.3, but are officially obsolete,
emoved:
CDR (retained for now, identical to CDR - both CDR and ZCDR
nto 1-instruction sequences, so ZCDR is no longer
ZCAR still is).
colon (known
in the
       they cannot be used in LAMBDA lists or be assigned values
ETQ.

       not PRIN1/PRINC followed by TERPRI.
r output, use of FORMAT is recommended.
akes keyword aÿ
old NOPRINT operand is not supported (although
y READ-EVAL-PRINT).
ING or MAKE-STRING.  The lattÿ
licts with the Common Lisp
es reused, it will
	
TYI, TYIPEEK...
ST - replaces ALIST
ven form
 
IBLE CHANGES TO OLD FUNCTIONS
tails.
, when specified with no arguments, puts you
porary dataset used to store
unctionname).
ou
TIONS REMOVED
ils to

      modules (in fact, the compiler no longer processes this
ion).  The compiler now determines the addressability
the code it is compiling and generates ÿ
 itself.  No programmer action is
, that a function whose generated object code is
 still cannot be compiled (unless it is
GMENT ...))).
d from
  programs can also be invoked under other ZIL programs via
KE function.  This means running the compiler under
PS5 under the compiler, etc.  The programs
and do not interact with each other,
rams< .
ÿç
relief
performance.
e collector canÿ
nline objects.  This means that
cause lossage
ll
string space is now allocated above the 16MB line.
 improvement, the default size of
ed to 1 megabyte.
rs -1 through 255,
o fixnums
s
 consing up fresh fixnums.  This will reduce the frequency of
collections and speed up some applications, particularly
rocess character objects.
anged; symbol headers are
an CONS space,
ements
   storingÿ
truction path length for internment of compiled symbols.
cellaneous enhancements have been made to the compiler
ter code sequences for coÿ
nce is faster by 10% or more.  However,
 and function loads may take
.  Yet for most
uding
 
 read it.
****************************************
                                   *
 FROM 1.1                      *
                             *
**************************
 code because:
used for
nctions have different definitions - this has
e the ZIL 1.1 definition did not agree
r Common LISP.
notably the
 run just as well interpretively under ZIL
e depeÿ
ost code will not run into a
negative (for example,
st).  Also, since
mewhat
ad
ALL compiled code must be recompiledÿ
    If you need to run code under both versions of ZIL, you can use
read conditionalization" facility in your source.  Any
+ZIL12 will be read under ZIL 1.2 only; any
ll be read under ZIL 1.1 only.

   Functions that formerly accessed and created "logical" atoms
work on and return fixnums.  The nnnQ and nnnB syntaxes,
upported, now create fixnums.  In any case, the
nn and #Onnn syntaxes are preferred
eÿ
ƒ
ted ZIL's extensibility, so it has been removed.
ble under the inÿ
.  The Common LISP DEFVAR
global variables.
S NOT
      (OBLIST) AND (ALIST)
IST) are identical to
feasible to

       Slashification is now built into the ZIL atom dumping and
ing routines.

ND "CLCDR" REMOVED, NO LONGER NEEDED
 return NIL by default in ZIL 1.2,
the compiler generates
CLCAR and CLCDR.
n), use
    G. "SETARGS" REMOVED, USE "DEFARGS"
ful underÿ
 that purpose, which means

     under the ZIL 1.2 iÿ
will some day be removed:
       Constants OBLIST and ALIST (replaced by (OBLIST) and (ALIST))
 for compile-time directives (replaced ÿ
S REDEFINED
AT.
     object they print, not NIL.
 INTERSECTION,
      ASSQ, MEMQ, DELQ, REMQ, INTRQ, UNIONQ, SUBLISQ, SUBSTQ
Q" TEST
ƒ
e functions, however, a means has been provided to
r mode for ASSOC, DELETE, MEMBER and
AND ÿ
ewiest incompatibility of all.
 EQUAL

esn't (too much of a pain to implement).
 FIRST INPUT LIST, NOT VALUE OF LAST
   This is not that important sincÿ
ffect.
       USES PRIN1 FORMAT; NEW FUNCTION "EXPLODEC" USES PRINC FORMAT
   Just like the Maclisp one.  Also see IMPLODE.
S NULL SYMBOL INSTEAD OF NIL WHEN NO PARM PRESENT
 ZIL1.1 returned NIL in this case was that it
ith null print names.  Now that these
ay it was supposed to in theÿç
y, it also works in "command processor"
MPLODE TAKES FIRST CHARACTERS ONLY OF ARGS, ALWAYS INTERNS
W FUNCTION "CONCATL" CREATED FOR COMPATIBILÿ

unctions that replaced the old IMPLODE were
emicompatibility in mind.
TS, NOT AN EVALUATED
PP FOR THE
havior.  Also, PP will print
  This makes it more
AND UNTRACE TAKE MULTIPLE UNEVALUATED ARGUMENTS,
TED) LIST

 how most LISPs do it.
 return logical

ing ZIL 1.1's reign,
GS
	
   development - it will be announced when it is ready.
S
 CHANGES TO OLD FUNCTIONS
URN NIL
    Note that CLCAR and CLCDR are dead.
RMS (IMPLICIT PROGN)
C. ERROR - TAKES &REST ARGS
t somwhere.


   "BIGP", "FIXNUMP", AND "INTEGERP" - THE LAST IS
O FIXP

S SLASHIFICATION
NEW OPTIONAL ARG SPECIFIES INITIAL ELEMENT
	
 Just like Franz LISP, etc.
TO NIL
BER OF STRINGS
want
  TSO with no args currently does nothing, just smiles at you.
OVED USABILITY FEATURES
LOAD property of a symbol may be a string representing
to be loaded automatically, or a list which is
 order to make the symbol become a
ts of creative
ETTY-PRINTING, DRIBBLING, EDITING OF FUNCTION DEFINITIONS
e life under the interpreter a lot easier.
a hard copy of your entire ZIL
put includeÿ

 typed in, etc.  Saves lots of typing.

A null symbol name (read in as ××) is now permissible.
 limited to 32767 bytes; both strings and
size only by the available
m.

 for most operations.
internal format of symbols has changed; symbol print names
e strings rather than chains of CONSes.  Fixnums
more space-efficient, each taking one
is has the following results:
quent and faster.
      Because of these changes, less CONS space is required in a
al ZILÿ
 heavily.  We plan to fine tune the allocation
ces as time goes on, and the amount
able at compile time ÿ
eter.
Õ
speed.  In many cases this gave us bÿ
nal validity checking; all the functions that access
or example, now signal an error if the format
invalid.
table

  executed.  This has the following benefits:
oad modules take up less disk space, sinceÿç
D (relocation dictionary) records should be shorter
mber.
     In addition, the process of interning symbols on theÿ
 been improved and should be faster.  This will also
for ZIL functions.
bal") variables under the interpreter now maintain
the property list via the VALUE indicator as
e itself with the actual value; thus
E property, not the CAR.
g entriÿ
	
      list, not at the end as before.
ally invoke DEFVAR, noÿ
cified.
mbler
essary to specify DCB information foré  file
batch).
.
************************************
                              *
Laboratory facilities.   *
                      *
UP (CLIST, HELP, *
is invoke   *
et to    *
    *


*******************************************************************
following CLIST's are available to all TSO users:
nvokes the ZIL interpreter directly.
ource file.
    XZIL      - invokes the ZIL ISPF interface.
ates a ZIL inÿ
      XZIFREE   - frees a ZIL input file.
ut file.
r users who
 name

allocated the rest as CONS space.  However,ÿ
o access files under ZIL, since the LOAD and OPEN functions can
ta sets directly.)
 enter:
ialog.  Option 3 runs the
anatory.  A tutorial
the interpreter with a minimum of fuss,
tarts up the ZIL interpreter
ne-mode terminal.
ELP) is
 availab« le LISP functions.
:
mation as well.
IME ZIL ABENDS, ERRORS AND MESSAGES ***
ode, here are some probable causes:
not disastrous; the most likely cause
ead from a partitioned data set
  002 is the code
ecords.
e other
‡
 Such abends should be reported immediately, and a dump should
ained where possible.
t was made to use the CAR or CDR of an atom in
cess an element of a vector with an
art of an obÿ
L considers this an
de.
         type, but the funcÿ
    coded for speed.
y called as
ile being referenced was properly
me may have been specified.
but did not really exist
mmand without
stent member name may have been specified
13 - file could not be accessed because it was protected by ACF2.
out-of-space condition on an output file.  Check that your code
t in a loop writing output.  You may have to recreate the
de of ZIL with a larger size.
file - no secondary allocation
bove foÿ
DS member.  See description
80A, 106, 878, etc. -
 to get enough
g a ZIL

      logical screen.  If you are usiÿ
 other active PIE sessions.  Otherwise, try restarting the ZIL
ion with a lower value for CSSIZE or VSSIZE.  If this does
y logging on with a larger region size, or increasin+
meter in your batch job.
he code listed is returned
cepting errors (a
gnalled by
with a
ote: At the present time, there is no in-depth documentation for the
eanings of those messages which are not self-evident (there's no
ÿ
 provided some time in the future.  However, most such
easily recognized and all are recoverable, with
nal errors deteÿ
.
.
(signal error).

 of fatal error messages, the display of these
opriate (MSGLEVEL n) function call.
-------------------------------------
-----------------------------------------------------------------
F  NO STORAGE AVAILABLE FOR ZIL INITIALIZATION.
RAMETER FIELD, INITIALIZATION PARAMETERS IGNORED.
, RECURSIVE INVOCATION NOT ALLOWED.
E, CANNOT BE OPENED.
 OPENED.
d.
  2  File name not a 1-4 character symbol.
me.
________.
  2  IKJEFF18 (DAIRFAIL) error - unable to display allocation failure me

2  OPEN: Member name specified but dataset not partitioned.
member name must be specified for data set ________.
 member not found in data set ________.
set to verify member name.
ned, or is empty.
not closable.
25  2  ISPF dialog services not available, cannot edit dataset.
r detected by ISPF EDIT, could not edit dataset.
ed, ABEND code ___, reason code ___.
 closing it first.

 2  ZIL ABEND AT ________ IN FUNCTION ________.
____, system/user code ___, reason code ___.
 EXCEPTION ÿ

0  NON-INTERRUPTIBLE PROCESS.  ABORTS WILL BE DEFERRED UNTIL PROCESS IS
.
AIN.
onal messages for attention help ***
N interface.
IT could not be loaded.
71  3  Not enough memory for inline compiled object pointer storage.
 Control stack overflow.  Possible infinite recursion.
T FOUND ON ZIL LOAD MODULE LIBRARY.
ERENCE NOT RESOLVED.
.
 0  CANNOT LOAD FUNCTION, NAME LONGER THAN 8 CHARACTERS.
- INVALID TASK LIBRARY OR STEPLIB DD SPECIFICATION.
 ENOUGH SYSTEM STORAGE.

____ LOADED AT ADDRESS ________.
  ________ LOAD FAILED, RMODE=ANY MODULE LOADED ABOVE 16 MB LINE.
______ LOAD FAILED, Nÿ
led function ________.
ossible.
00  1  GARBAGE COLLECTION INVOKED BYÿ
FAILED. NO MORE CONS CELLS AVAILABLE.
_ CONS CELLS FREE, _____ VSS BYTES FREE.
 TO CONS FOR GARBAGE COLLECTION.
CANNOT CONTINUE.
ERMINATED.
ˆ
ED.
.
ERMINATED.
Iÿ
Unbound variable ________ in compiled function ________.
uments passed to function ________.
ction ________.
…
  Invalid keyword list passed to function ________.
s passed by FUNCALL to ________.
L to ________.

___ NOT FOUND ON SYSTEM LIBRARY.

DOWN STACK FOLLOWS.
 reading file.
ad after end of file.
Missing closing delimiter at end of file.

acter following symbol delimiter.
2018  2  Internal error in reader macro processing.
lowing escape character.
  Period "." not in dotted pair.
uild striÿ
ing space available to create GENSYM.
.
UGH MEMORY TO EXPAND TABÿ
____ bytes of vector/string space.
SS is not a string.
lt.
 Command feature not available, TSO is not active.
rt argument to string.
Ó
 Requested command terminated due to attention.
ce available for FUNARG.
 AN ATOM.
LADMP: NOT ENOUGH MEMORY TO DUMP BIGNUM.
 THAN 2 WORDS.
5  1  ZILADMP: A WORD OTHER THAN THE LEAST SIGNIFICANT WORD OF A BIGNUM
IVE.ÿ
NOT NORMALIZED).
LOSURE).
 ZILADMP: THE MOST ÿ
OUS BUG, PLEASE REPORT.

ing space available to intern symb+
e oblist hash table size of ____¦ _.ÿç
000 interned symbols.  New symbol not interned, oblist hash table limit

t enough memory to perform trial division.
 warning message}
ot enough vector/string space to build object.
 detected.
 of bignum to float not supported.
rted.
  No vector/string space available to build double-float.

 and MODULES.

L for detÿ
UNCTION, PROGRAM or
it a background
AM is a LISP "top-level"ÿ
ted in sequence, optionally along with function and macro
s).  This produces a top-level load module which
d can be called from TSO or batch in thÿ
ore details), or invoked from ISPF's
compiler are examples of ZIL
UN's - function and macro definitions - of
on definition whose name matches the
iling.  This produces an NCAL
piled PROGRAM or being
ion under the
ZIL will
 you

else you wish, which is compiled into a function whose purpose is to
 contents of the source file you are compiling.  This produces
odule which can be ÿ
 function with no arguments.
 you call the module
once only.
hat
alogous to the Common LISP
E is analogous to
ng a PROGRAM
be
In this discussion, macro calls that expand into DEFUN's -
ACRO - are considered equivalent to DEFUN's that you
ee items (7) and (8) below for more info.)
 defining a function or macro whose name

 (not a macro -
e name
s
EN, or PROGNÿ
 forms, may occur in a file being compiled as a FUNCTION.
t have a DEFUN defining a function or macro whose name
e of the module you are comÿ
ON, the following apply:
ot embedded within


the PROG "shell" will make the above valid, but the
 by the compiler, not executed at run time.
may be coded within a PROGN; they will be
 actually at top level.
o associate LISP function
pilation (it performs
.  DEFLOAD may
tions.
UNNAME)ÿ
piled
 compiled function.  If the source file name is FUNNAME, you may
 actual main function ÿ
EFLOAD telling the compiler about it.
t top level (but see (7) and (8)).
o arguments, indicates end of
viously not required, but
t typed in from the
a similar
	
compiler options.  See member DECLARE for a full explanation
be specified.
pecial form
ƒ
de that the compiler is to evaluate in its own
omÿ
ave the following in your source:
(PRINT "Hello, I'm compiling your program now!")
iler will print tÿ
 now!"
t you are
er
 function that is notÿç
ot a "standard" ZIL function as can
ompiler converts the call to a
he function symbol to the
ode to call interpreted

d
    direct branch to the code), you can use DEFARGS.  For example:
 (DEFARGS SOMEFUNC 1 2)
called SOMEFUNC
SOMEFUNC (A &OPTIONAL B) ...)
all like
 to treat SOMEFUNC as an EXPR (actually a SUBR since it will be
dÿ
s required (any arguments omitted will be passed as
rguments and will be bound to their default
ote that the funÿ
t will become an external reference
st one alphabetic or national).
d with your PROGRAM if SOMEFUNCÿ
 If SOMEFUNC is referenced by
d OTHRFUNC, it will not
 (FUNCTIONS are
t calls

r that SOMEFUNC has a &REST argument, if it
 a &REST keyword in its lambda list,
mbda list,
 
   (DEFARGS SOMEFUNC 2 2)   ; 2 required, no optional, no &rest
S SOMEFUNC 2 5 T) ; 2 required,  3 optional,  1 &rest
 2 2 T) ; 2 required, no optional,  1 &rest
ave a DEFARÿ
tandard" functions (the ones every LISP user knows and loves).
ctions invoked via APPLY or FUNCALL,
her than #'FOO.
ternal functions).
at makes the
e".
s as

 the preferred way of defining globally bound
EFVAR is not supported when compiling a
EVAL-WHEN's, DECLARE's and other top-level forms may be
o calls that occur at top level, provided that the
them are defined preceding their calls in the
you had a macro MYDEF which expanded into a
the compiler to process, you would have
der:
    ÿ
ined by the DEFUN that MYDEF expanded into, as if you had
 level directly.
er top-level
ally at

  DEFUN's (perhaps something similÿ
) which you want the compiler to recognize as top-level
cannot generate more than one S-expression, but it
PROGN form to contain multiple forms.
 forms within a PROGN special form.
erpreted, since the
".
    For example:

 to specifying both of the above DEFUN's at top level.

tly there is no support for external FEXPR's (or, for that
SUBR's, that is to say compiled FEXPR's).
ions the compiÿ
itions.
	
     $DEFUN of this document. 
 DEFUN function is the basic function-defining technique.
iled program or function, it does not generate
 DEFUN a la interpretive mode,
.  For that reason,

 MACRO's on the fly (EXPR is the default format).
ÿ
mpiled code as SUBR's; MACRO's become
be expanded when they are
ported
although LEXPR's may be invoked via APPLY.
ds of DEFUN's are permitted.  However,
into equivalent MACRO definitiÿ
nd run time.
owing descriptions, "func" is the name given to the function
var1"..."varn" are symbols that represent varÿ
tion evaluation time, and the forms "form1",
dy of the function, which is evaluated
hed in accordance with the other
.
 
))

evaluated and bound to the corresponding parameter in the
unction.
Õ
ded in the argument list (see member LAMBDA of this documentation
formation).
emselves,
 other words, T and symbols whose print names begin with colons
 variable names.  Note that NIL is permissible as a
gument.  This interpretation is consisteÿ
where the argument is destructured
erit a value from that
ent list is a single non-null symbol,
which case the symbol is bound
valuated) arguments
In addition to Common LISP features, the following features of lambda
 are supported by both the interpreter and the compiler, for DEFUNs
MACROs:

 time:
UN ÿ
s valid only under the interpreter (in general) and creates a
irstvar" is bound to the list of (unevaluated) arguments
es bound to the cuÿ
 bindings in effect when the function is
ther than a lexical evaluation
se the environment
 your
gh "firstvar" is required, "alistvar" is optional.
ted, a dummy second argument is generated
tion, which cannot be referenced
s" are not valid in the argument list of a FEXPR.
...
 (under the interpreter) or defines a MACRO to
l expand macro calls and compile
ectly).  "var" is bound
 macro name, and

s implemented as a macro that expands into
o define macrÿ
o.)

owever, returns a value to tÿ
ated for their "side effects" only.  This is known

T FOO), X will be bound to the value of FOOÿ
(CAR (EVAL (CAR X) A)))
list (FOO).
type (FIRST FOO), X will be bound to the list (FOO) and
nd to:
e: (DEFMACRO FIRST (A) (LIST 'CAR A))
UN FIRST MACRO ... ) above.)
e same value - namely,
O.
cept
        Ñ   than NIL), which is bound to the number of (evaluated)ÿç
	

 (DEFUN (funcname fprop) ...) tells the interpreter to
fÿ
rty of the "funcname" symbol.  The
 are compiling a MODULE.
nd predicates teÿ
n a DEFUN
'BAR) (C 'BAZ C-SUPPLIED-P))
args C to BAZ and
g C was
structuring of arguments...e.g. (DEFUN FOO ((A B) C) ...)
st argument in a call to FOO being "destructurÿ
the CAR goes into A and the CADR goes into B.
otted pairs, and the destructuring may
ing and all the other lambda-list features are also
FMACRO.
ons between the various equality functions:
ments have the same memory address
al).
     Two lists are EQL only if they are EQ.
 have the same structure
DR's are EQUAL).
	
es are
sts if they are numerically equal.
 tests if their print names are
…
  are EQUALP.
rue if thÿ
e EQUALP.
 the Common LISP EQUALP.  Note that the EQUALP available
s of ZIL was closer to Zÿ
P EQL in that it can compare
n ZIL, strings are
tions
s the two-argument function underlying =.
he only equality predicate that
 to it that it cannot
  Two integers with the same value may not be EQ, but they
QL, EQUAL or =.
  1 1.0) ==> NIL
UALP 1 1.0) ==> T

 "foo")) ==> T  ; not in Common Lisp!
=> Tÿ
 (=      "foo" (string-append "foo")) ==> T
L
"FOO" "foo") ==> T
ts

B) '(A B)) ==> ("***ERROR***") ; =ÿ
 '(1 2)) ==> NIL
=> T
**") ; = can't compare lists
EQL    '(1 2) '(1.0 2.0)) ==> NIL
EQUALP '(1 2) '(1.0 2.0)) ==> T
") ; = can't compare lists
Q     (MAKNAM  '(A B C)) 'ABC) ==> NIL
> NIL
) 'ABC) ==> NIL
g symbols to strings
QL    (MAKNAM  '(A B C)) "ABC") ==> NIL
> NIL
)) "ABC") ==> T
)) ==> NIL
)) ==> NIL
=> ("***ERROR***") ; can't compare vectors
.0)) ==> NIL
 #(1.0 2.0 3.0)) ==> NIL
#(1 2 3) #(1.0 2.0 3.0)) ==> ("***ERROR***") ; can't compare
ç
ectly accessible from ZIL code, which
†
cters.  The syÿ
ow), and is used to locate the file via an EQ test.  Note
 of more than 4 characters cannot be used as a file
 two types of files:  input fÿ
input file or an output file depends wholly upon the
tion is using it.  Thus, the same symbol
an output file while referencing
ions.
 case the standard input or output file is used
or standard input or ZILO for standard
ne of these DDNAMES need not
rminal will be used
erminal will
MES
T   - in which case the TSO terminal is used (the DDNAME is ZILIT
 input and ZILOT for output).  If either ZILIT or ZILOT is
 it will ÿ
tandard input (ZILI) will be used;
output (ZILO) will be used.
 from 1 to 4 characters)ÿ
 DDNAME ZILIxxxx must
t when it is
ut
        opened for output when it is used in a function call.  All
ch files are automatically closed at ZIL program

files are removed from the ZIL system by the CLOSE function.
all cases, the file name operand of a function is optional
NIL), except where otherwise indicated.
operate on both input and output files:
 to a file and opens it.
does NOT take a file name as an argument, but
ZIL ÿ
.)
fi(zilifoo) da(foobar.data) shr reuse
available only if T+


taset FOOBAR.DATA.
 

to the dataset FOOBAR.DATA.
re referenced by function
ering an output file
d.
can

ILIFOO) DA(FOOBAR.DATA) SHR
OBAR) DA(FOOBAR.DATA) OLD
h.
      The XZIFREE and XZOFREE CLIST's will free ZIL files similarly.
ternatively, you may enter under ZIL:
nput))
ned
nd CLOSE.
or input
rted

tly, if a new dataset is created for an ouÿ
 RECFM=FB, LRECL=80, BLKSIZE=6160 are assigned.
termines dynamically whether the file is line
 1.  If the file is allocated to the terminal, it is neveÿ
to be line numbered.  This allows continuous typing of input
inal rows.
numerics in
ntire
r

variablÿ
 that in the case of concatenated data sets, the first record
st data set in the concatenation establishes the number
le concatenation.  Mosÿ

that is a bit different from what happens with non-LISP programs:
Input data is not necessarily folded +
llows exactly the same rules as inp
 ut from a data set.ÿç
Ö
wn logic to determine when you want to get out of an interactive
lse you may be stuck talking to your program forever (of
always attention out).
P filename).
e).
gramming paradigm familiar to users of
plementation is nearly identical
ual, plus one or two
tom of this item.)
 paper on
ALL-SELF

-VARIABLES,
and :DOCUMENTATION.
cified, then
.)
ced.
ÿ
ng in the SI package occur without the package
LAVOR is implemented as DESCRIBE-FLAVOR.
ymbols the firsÿ
is no "keyword package" in ZIL).
erpreter and the compiler
 a currently
sue a
 warning message may be ignored if you use keywords in the
SP manner.
wing
ll the FLAVORS functions and macros, and defines
s methods.  The :SEND-IF-HANDLES,
ethods, available in the NIL
 for VANILLA-FLAVOR.
 in an interpreted
l cause


have to spÿ
 the FLAVORS macros (DEFFLAVOR, DEFMETHOD, etc.)
that it can compile them correctly.  LOAD
s and macros are to be avÿ
rpreter, so that the user can use
e is designed to use FLAVORS
long as the autoloading
y).  EVAL is


stem, and cannot be used unless you bring in FLAVORS
ys.

it is defining, instantiating, and initializing components of
stem.  Many of these messages would be displayed the
nstantiated (e.g. via the first
alues:
tioÿ
3  -  suppress informational, warning and error messages.
r this variable is 1.
implemented yet, aÿ
 method functions constructed
owever, the individual
iled; in fact, the
ct rather than a
entation is that wrappers take effect at
FWRAPPER form causes automatic
rapper.

ents of the default-init-plist.  ZIL's implementation may
 in certain subtle respects where these are not
Machine documentation.
assing in the Lisp Machine"
Artificial Intelligence Laboratory, Nov. 1980
T/LCS/TR-311
cience, January 1984
ects that can be typed into the interpreter
nction):
parens,

   0, 17, 3., -1, 2147483647
 no longer supported for
stead.
  Double-float:         1.5, -2D3, .78, 3.1415926E-1
  1.5S0, -2F3
 strÿ

 strings are OK:  ""
, print-name, NIL, ÿ
re    (this prints as: ×Hi tHERE×)
hose print name is "01")
s as: ×Hi therE×)
 is "01")
        are NO LONGER SUPPORTED.
mbols.
t when
 typed in are interned on the object list (OBLIST).
ed as fullword values, but bignums exist too.
r double precision; the default is double.



(A . (B . (C . NIL))) is the same as (A B C).
orm) ... see $RMACRO for more information
about this andÿ
y reader macros.
g. 'A is same as (QUOTE A).
QUOTE (C))))
ted by the

nd the backquote `
ility, which
ented via the reader macro facility; other reader
ers may be defined by the user using
L is equivalent to ().
he interpreter.
ed to add
se EXCEPT in strings and
  '(a b (c) \d ×e× "f")  ===> (A B (C) ×d× ×e× "f")
nates a symbol name (unless it is a barred atom),
her cases...
r (hex
e.

in all numeric charactÿ
ormal atom characters and
ountered, the
part of

cters and
†
tc., with case preserved - with the single exception that
l function as escape characters.  Note that the bars
me itself, but merely the portion of the name
y.

¸
o\ÿ
nuation character
ll be printed
n) in the
t sign

   any newlines.  (This does notÿ
, although the continuation characters may appear when an
d out on the terminal.)
ng strings, bignums,
  For fixed-length records, the cent sign will be treated as a
n character if it occupies the last data column.  For
LRECL=80 data set will recognize the cent sign as
er if it is in column 80 for unnumbered data
ed data sets.
ted as a
cord,
he cent sign will NOT be treated as a continuation if it is preceded
backslash, or if it is part of a comment field or otherwise not
Lisp object being read in.
ve been lifted in ZIL 1.2:
 in symbol names.
ted and
y leÿ
ng space available to

xponent with more tÿ
ays evaluate to themselves,
colon ("keywords").
anings

mathematical functions, ZIL
rder to enable these
routine library
'SYS1.FORTLIB', need not be allocated at ZIL
subroutines are linkedited with ZIL
 time aÿ
elease 4, VS FORTRAN version 2, or a
rder to use these functions.
TRAN interface:
  LOG
 goes by.)
re used.
ion
 args are all < (monotonically decreasing).
>.
plies args together.
#    Unary minus, or subtracts all args in sequence.
ciprocal, or divides all args in sequence.
MAINDER.

           1-any#  Inverse of <.
merically equal, else NIL.
nt.
argument + 1.
ÿ
NIL.

any#  Applies fÿ
all known symbols with arg1 as substring.
ments of a LEXPR.
rg1 by arg2.
  (ASSOC '1 '((1 . A) (2 . B))) ===> (1 . A)
((A . B) (X . Y))) ===> (X . Y)
nt for function entry/exit.
Ô
  1       T if argument is a bignum, else NIL.
 a named block of forms or RETURN-FROM it.
olean op defined by arg1 to args 2, 3.
ound (has a value) else NIL.
rg2 element(s) of arg1.

 of CAR of arg 1.
        1       CAR of CDR of CDR of CDR of arg 1.
of CDR of ÿ
         1       (CAR '(A B C)) ===> A
ion to structured programming.
 as THROW tag (see THROW)ÿ
.
CDR of CAR of arg 1.
DR         1       CDR of CDR of CDR of +
 CDR of arg 1.
     1-2     Converts floating point to integer.
s fixnum character in arg1 indexed by arg2.
 a fixnum between 0 and 255, else NIL.
 #/A) ==> #/a
  1-2     Closes a file that was opened for input or output.
      T if arg is a compiled code closure, else NIL.
Clears the screen of your 3270 terminal.
SUBR or compiled closure, else NIL.
ts, returns 'COMMENT.
intÿ
         any#    Args in pairs, returns CADR of 1st whose CAR^=NIL.
     2       (CONS 'A '(B C D)) ===> (A B C D)
 is a non-null lisÿ
ed copy of a symbol.
es no CONSes.
Conditionally forces new line on ÿ
 year, month and day as list of 3 numbers.
 and Julian day as list of 2 numbers.
ime of day as list of 3 numbers.
arg 2 (default 1).
unction name.
 Defines a reader macro.

obal variable.
nt).
 if argument is a double-float, else NIL.
 all arguments (a - b - c - ...)
arg1 as a digit, else NIL.

es over a sequence of integers.
s EBCDIC character.
put file arg2.
under ISPF.
preter.
.
          0-1     T if end of file reached on input file, else NIL.
     2       T if arguments identical (same addr), else NIL.
      T if args have same type and contents, else NIL.
  T if arguments have same structure, else NIL.ÿç
   2       T if 2 arguments are similar, else NIL.
ts error message and throws to tag NIL.
ent.

   2-any#  T if every application of arg1 to lists is true.
     Terminates ZIL program, with optional return code.
   E to the arg1'th power.
× ×b× ×c× ×"×)
XPLODEN      1       (EXPLODEN "abc") ===> (129 130 131)
  Arg 1 to pÿ
 definition, else NIL.
NIL.
RSTN        2       List ofÿ
     1       Converts floating point arg 1 to integer.
T if argument is a fixnum, else NIL.
 fixnum or bignum, else NIL.
in object when PRINC'd.
ct when PRIN1'd.
nt.

       "Undefines" a function.
ssages with variable data.
 closure (see FUNCTION).
r args.
.
 Greateÿ
y of garbage collection messages.
 collection time in millisec.
ed symbol.
         2-3     Returns property value of arg 1's indicator arg 2.
     2       Returns arg2'th character of arg1 as symbol.
   Returns arg2'th character of arg1 ÿ
ns subplist of arg1 whose CAR is in list arg2
atom out of PARM field passed to program.
 branches to label arg 1.
than arg 2, else NIL.
g2 bits of arg1.
abs(arg1).
ation.
   1       T if specified input file exists, else NIL.
(IMPLODE '(A B C)) ===> ABC (interned symbol)
s arg 1 by arg 2 (default 1).
ÿ
aset arg 1.

RSECTION  2    ÿ
   2       Set intersection of two lists using EQ test.
 Calls program arg1 with parameter string arg2.
(A B C)) ===> (C)
 sublist of it.
SP         2       T if argument 1 is less than argument 2, else NIL.
T*     any#    Sets up local variables and evÿ
   any#    (LIST 'A 'B 'C) ===> (A B C)
) ===> (A B . C)
.

LLY       any#    Associates declarations with forms to evaluate.
   1-2     Logarithm of arg1 to base arg2 (default base E).
ny#    Logical AND of all its arguments.
th bit of arg2 is 1, else NIL.
ger (# of 0-bits if neg).
ts argumenÿ
t.

    any#    Various kindsÿ
 left (right if neg) of arg1 by arg2.
all repeatedly.
     1-3     (MAKNAM '(A B C)) ===> ABC ÿ
       "Undefines" a variable.
g 1 to elements of arg 2-n
l elements of arg 2-n.
e results together.
he results.
gether.
 2-n.

           1-any#  Returns the greatest of its arguments.
   (M+
 ==± => (B C)ÿç
 its arguments.
P        1       T if atom is negative, else NIL.
 an atom (symbol or number) ÿ
 of (arg 1) elements.
s.
ALUE-BIND   Binds args to multiple values aÿ
-CALL   Calls function with all values of forms passed.
 Returns list of multiple values of form.
t passes multiple values through.
ultiple values of a form.
s arguments).
       2       (NEQ A B) <=> (NOT (EQ A B))
of line reached on input file, else NIL.
is NIL, else NIL.
s are false.
false.
).
        2       The "n'th" element of a list, counting from zero.
   2       The "n'th" sÿ
1       Same as NOT.
num, else NIL.
symbols.

  T if specified output file exists, else NIL.
T if args evaluate without error, else NIL
name, opens it, returns a file.
rgument or NIL.
 arg3.
ol.

         1-2     Returns char from memory using arg 1 as pointer.
   ÿ
 2-3     Invokes PEEKC to build list of chars from memory.
    Same as SYMBOL-PLIST.
P         1       ÿ
etty-prints the macro expansion of its arg.
ts the macro expansion of its arg.


-1     A string containing formatted date.
s a LISP object.

TO-STRING 1     PRINC's arg 1 into a string.
 1 "readably" to output file & TERPRI's.
s is to output file and TERPRI's.
 string.
PRI.
    Same as PROBEF.
dsname, else NIL.
tatements.

        anyÿ
ny#    Evaluates all arguments, returns the second.
igns values to local variables in parallel.
o (CONS list1 arg2).
not already there.
bugging.
g 1.
Ð
  Quotient of all arguments (a / b / c / ...)
 random fixnum or flonum between 0 & arg1
xpression from input file.
 entire input file.
ut file.
¤
VE        2-3     (REMOVE '2 '(1 2 2 3 4 5)) ===> (1 3 4 5)
 1   (REMOVE-DUPLICATES '(F O O B A R)) ==> (F O B A R)
 Removÿ
O B A R)) ===> (F B A R)
 arg 1 as value.
 a value.
 X) Y).
VERSE       1       (REVERSE  '(A (B C) D)) ===> (D (B C) A)
      Bitwise rotate of fixnum arg1 ÿ
 rounded to the nearest integer.
g 1 with arg 2.

     0       Current terminal number of rows and  # of columns.ÿç

SETABEND      1       Controls whether ABENDS are to terminate ZIL.
     2       Replaces arguments of a LEXPR.

quare brackets are printed.
SETF          any#    Various kinds of assignments or alterations.
    1       Maÿ
ent 1 NOT a "feature".
to arg 2.
y.
          1       Sine of arg1.
for specified # of seconds.
 arg1 to lists is true.
rg2, makes new list.
 using fun arg2.
ng env.
 Makes a string out of a bunch of other strings.
a string out of a list of other strings.
rds in a string.
.
TRING-LEFT-TRIM 2    Trims characters from arg1 off beginning of arg2.
-LENGTH 1       Returns the length of a string.
 a stringÿ
a string.
2.
UBSTR 1-3     (STRING-SUÿ
 Translates a string from some chars to others.
haracters from arg1 from both ends of arg2.
a string to all uppercase.
345") ===> 4 (like PL/1)
 and returns string.
Ó
 any#    (STRUCTURE 'A 'B ...) makes a structure of type A.
     Executes SUBST using elements of association list.
 Like SUBLIS but uses EQ test instead of EQL.
g is a compiled code SUBR object, else NIL.
2 '(1 2 3)) ===> (1 1 3)
A A C)
    +
boÿ
st.
   1-2     EVAL for dynamically bound atoms only.
tabs mode on or oÿ
ms with tags (labels) you can GO to.

 Exits to CATCH that had tag argÿ
splays CPU time used in evaluating forms.
l arguments.
  any#    Activates tracing for selected functiÿ
onverts floating point to integer.
 as TSO command or CLIST.
rg 1 + 1).
 fixnum.
.
P         1-2     Returns type of arg1, or T if arg1 is type arg2.
      any#    (UCONCAT 'FOO 'BAR) ==> FOOBAR;uninterned symbol.
 1       Takes EBCDIC character and returns fixnum.
 union of two lists.  Uses EQL test.
ists.  Uses ÿ
he other args.
functions.
I.

      0       A string containing your TSO userid.
rns any number of multiple values.
ts of a list as multiple values.
ucture.

CTORP       1       T if arg 1 is a vector, else NIL.
ets all elements of vector arg1 to arg2.
ents (dimension) of a vector.
ector.
    3       Updates an element of a vector.
ing message.
er argsÿ
e.
        2       (XCONS A B) <=> (CONS B A)
utput file column by a rg 1.
IL.ÿç
ile.
      1-2     Sets current column to arg 1 in input file.
   Sets current coæ lumn to arg 1 in output file.
as ADD1
 
IB.ZIL.SOURCE(INIT)'.  This is no longer present, since
ruly optional.
 you start up.
s:
 1)   ; the default, suppresses informational messages.
suppressÿ
ses all messages (not recommended!).
collection messages, try:
lection messages
es

ich evaluate to themselves and thus caÿ
INIT file is loaded.
 enclose them

ÿç
******************
            *
ies.   *
    *

        the XZIL clist (from iÿ
     the ZIL primary option menu.  From there you can invoke      *
the interpreter, call a compiled LISP program, or do a       *
round or background compile.                 ÿ
                                                     *
*************************************************
eter, you may do either of the following:
.
*********************************
ul under the interpreter:
ly" by telling the
 coded by
Õ
    which ÿ
rpreter "cleanly" by simulating an
put file (you can specify
 some other file,

          exit from LISP code back to the operating system.  An
tional return code specification on EXITÿ
e for the caller (e.g. (EXIT 12) sets the

ontained in 'PROGLIB.ZIL.TEXT'.  (HELP FUNCTIONS) will
 list of available LISP functions.
the current message level.
ber between 0 and 3,
 terminal.
es
         to appear.
 of "ÿ
nts the
 - pretty-prints the function definition of "name" to a
ary LISP source data+
 edit it.  If therÿ
u are given a starting file
save it, the newly
d into
D is available only under ISPF.
**********************************
ollowing symbols are assigned values that are usÿ
e session:
ation by
value of *.
ys contains the last form typed in at top level.
s value of +.
ains the form currently being processed by the interpreter.
****************************************************************
ribble" Facility
fy a file (which
 input and
pecify
fications on the XZIL option 3 panel.
****************************> *******
 for more information on the

**********
    *


     PANEL, MSG, SKEL), all you need to do to use ZIL is invoke   *
the XZIL clist (from iÿ
 ZIL primary option menu.  From there you can invoke      *
rpreter, call a compiled LISP program, or do a       *
 background compile.                 ÿ
                                             *
*****************************************
batch, you can use the following JCL:

(see optional parameters below)
t here)
e EXEC statement:
   (nnnM, nnnK or nnn)
   (nnnM, nnnK or nnn)
  ÿ
N for new system, SYS=O for old system)
CLIB DD statement to pick up the
des in 'PROGLIB.Cÿ
ing the ZIL compiler...
ROGLIB.CMD.CNTL
OURCE='AAA1234.xxx.LISP(member)'ÿ
='AAA1234.xxx.LOAD'   <=== do not specify member name
function using the ZIL compiler...
P=SHR,DSN=PROGLIB.CMD.CNTL
L,



ame,PROG=M,LP=NCAL,
ber req if PDS
member name
.LISP(mymacros)'
.LISP(mymacros)'
 LISP macros+
ber names ÿ
UB1='AAA1234.xxx.LOAD'
D'
e libraries to resolve exÿ
r source program at linkedit
er names are not
ons of
ment to pick up the
IB.CMD.CNTL'.
style LEXPR's.  I.e., an EXPR with a non-NIL
onsidered to work like a LEXPR, in
valuated) arguments, and
ts.

ed to access LEXPR arguments:
e list.
self (this is unique to ZIL!).
he list.
RG n frob) ... sets (ARG n) to frob.  n must be a valid fixnum.
FY &optional n) ... returns the list of LEXPR args, if n is
           omitted or NIL.
irst n LEXPRÿ
 LEXPR args.
 PROG's.
guaranteed to work outside  of interpreted code.
ù

ON, MAPL, MAPLIST, MAPOR.
Aÿ
be one of the
 SUBR property).
TION ...),
(a list whose CAR is the atom LAMBDA).
ction must take the same number of
d (it may have optional
be permissible
s always evaluated when the function is applied; hence
s, FEXPR's, and FSUBR's are not permitted.
function when it is passed the name of a
 and compiled environments, but
should not be relied
name of an
rt
he interests of generating efficient code for the mapping
er possible, the specifications for the first
rently in the compiled and interpretive
nvironment, the first argument
ibed above,ÿ
the first
 -

e is generated which APPLY's the value of the first argument as a
	
†
bda that are bound outside of it.  However, when the form is
AMBDA is expanded inline anyhow, so lexical scoping
might be considered illegal, but we do it
compiler makes no distinction between (QUOTE x) and
t argument of a mapping function.
T create a closure or
	


) (CON+
PCARÿ
es wrong number of args):
A (X) (CONS X NIL)) SOME-LIST OTHER-LIST)
the function argumeW nt must be proper
otted pairs and lists ending
redictable results.
out.
******************************************
nological order, the latest first.
 and changes to the ZIL system.
**********************************
===================================
                            ===
ION ONLY FOLLOW           ===
                      ===
=====================
------------------------
URN MULTIPLE VALUES
--------------------
ow ÿ
at the first value
=======================================================
                  ÿ
NCORPORATED IN CURRENT VERSION FOLLOW         ===
                                          ===
=================================ÿ
--------------------------------------------
G FUNCTIONS
------------
le in ZIL:
m function
it easier to set "breakpoints" at functions from which you
trary code to see what is going on.
ul with these new functions.
ment for more information
	

------------------------------------------------
unction (and ÿ
 service request buffer
ercase is

or "select "), the buffer is left as is with respect to case.
ommands or program parameters with lowercase data
ELECT service.  If there are leading
rd SELECT, though, the
------------------------------------------------------------------
2/88 - MULTIPLE VALUES NOW SUPPORTED IN ZIL
--------------------------------------------
pport for multiple values, as documented in
 133-139.  This consists of the
forms:
-VALUE-LIST

VALUE-BIND

E-VALUE-BIND arglist for values you don't care about.
of this upgrade, THROW is now a special form rather
as necessary in orderÿ
code which has THROW compiled as a
isting code never tried
Note that although all of these workÿ
ay not be implemented the same way internally.  In particular,
E-LIST and MULTIPLE-VALUE-BIND are special forms in ZIL,
CALL is a macro.
 ZIL, since ZIL
 can be

ne value do so at this time, but support in this area is forthcoming.
he reader supports the return of zero values from a reader macro
ng the return of "nothing".  This should be used instead
fÿ
ne more point:  If you're interested in using multiple values to get
some consing and processing time, think again.  Only the use of
UE-BIND in compiÿ
 the CPU time required to determine if multiple values
y be greater than the time to CONS up a list of
-------------------------------ÿ
8 - NEW SPECIAL FORMS: BLOCK, TAGBODY, RETURN-FROM
PROG* (NEW) NOW MACROS, NOT SPECIAL FORMS
------------------------------------------
rms BLOCK, TAGBODY and RETURN-FROM are
mon LISP documentation for
ETURN or
"funarg" boundaries works under the interpreter but not
.ÿç
hich is considered
n converted

 PROG* (the "sequential binding" version of PROG) is available
-----------------------------------------------------------------------
 04/11/88 - NEW "PUTDATA" MACROÿ
---------------------------------------------------------
PUTDATA, has been added to ZIL.  This macro allows
ISP function to print out the values
any other expressions that
the PL/1
but it helps a little.
e member PUTDATA
--------------------------------------------
MBER" NOW 100% COMMON-LISP COMPATIBLE -
 :TEST-NOT, :KEY
-----------------
d syntax
 :TEST-NOT,ÿ
ASSOC and MEMBER always compile into inline code
ously), and ASSQ and MEMQ have had
terpretive versions.
Macsyma has not
------------------------------------------------------------------------

----------------------------------------------
urned 1.  This was inconsistent with Maclisp
.  (HAULONG 0) now returns 0.
ma code may have been
w.
----------------------------------------------------------------------

----------------------------------------------------------
n of FORMAT has been installed.  This version is a 100%
ion ofÿ
Furthermore, it corrects some errors
atting routines.
---------------------+
/28/88 - "TSO" FUNCÿ
-----------------------------------
as been installed.  Features:
 processing is contained
ds that ABEND or are interrupted by attention result in
error, rather than just returning a useless
is no longer a problem with executing commands whÿ
 ZIL module names (e.g. PRINT).  TSO will always
pack area and system link list for
 and task libraries
t feature.
ST,
 not.  Use XINVOKE or TSOEXEC in such cases.

ut now the error is flagged
--------------------------------------------
ND VARIABLES
---------------
 
  (STRING-CAPITALIZE x) -  maÿ
                  words within the string capitalized.
IL documentation for VCOPY and SCAPITAL,
ZIL, for more information.
sent in ZIL:
ualified
                           partitioned data set containing ÿ
                source code for the ZIL system.
 -  a string containing the fully-qualified
NOT single-quoted) name of the
 set containing the
tem.

 see membÿ
 ZIL.
------
H COMMON LISP, BUT LESS ÿ
RYTHING
    DOUBLE PRECISION FLOATING POINT IS THE DEFAULT
R, COMPILER, OPS5, MACSYMA ALSO INSTALL+
-------------------------------------° --
here!  For more information, consult 'PROGLIB.ZIL.TEXT'.
S tells what's different.
ormation.
 specified by the programmer via DECLARE.
ation.
 enclosing them between backslashes at th; e beginning of the PARM
See member $PARM for full explanation.

 pass a PARM string to your program; the GETPARM function will
nd make a symbol out of it.  Note that if no PARM string
PARM returns the null symbol (printed as ××).
e passed as a JCL-style PARM string (in
mand) or as TSO command operands
shionÿ
ever, there is no
L-style
sh character "\", thÿ
ameter up to the
nformation
on
...\
y
 of the numeric portion multiplied by 1024; if it ÿ
 the value of the numeric portion multiplied by 1048576
= 1024K).

ords are recognized:
n stack to be
 default
ÿ
e of the CONS space ("free list") to
.  If this is omitted, the

Ò
ue represents the TOTAL allocation, not to be confused
ACTIVE size of the space - seeÿ
ted above 16 megabytes if possible.
of the CONS space ("free list") to
his is omitted, the

    by CSSIZE) is in use, until it is determined (by the garbage
or) that more space is needed, at which time the ACSIZE
ed, provided that it does not exceed the CSSIZE
e only one of the values described here
.
e
‡
omitted, the default value of 1 megabyte (1024K) is used.
 this space is allocated in duplicate, due to the copying
tion schÿ
pecified value is required.
tes if possible.
for each DDNAME of the ÿ
 at ZIL initialization
as a ZIL file, an
ons so that

n TSO as follows:
=65536\initfile'

ZINT CLIST.
s,
rary) SHR REU
      LIB('PROGLIB.ZIL.LOAD') FILE(ZILLIB)
the function call (GETPARM T) would
ontÿ
rent ways;  the
 string
ation.
put

r",
he "default ZIL printer", set to be the "current ZIL
lizatÿ
LSPRT is the low-level function that takes a SUBR argument and makes
 new "current ZIL printer".
tion object and causÿ
Any function which is to act as the "current ZIL printer", including
T and ZDPRINT, takes three required arguments:
e printed, if applicable.
 fixnum built from the following boolean values:
 character object (TYO)
       ..10  =  control, not print (CTERPRI/TERPRIÿ
't slashify, 1 = slashify
	
  (DEFUN TYO     (X &OPTIONAL F) (ZCPRINT X F #b0000))  ; arg 3 =ÿ
FUN PRINC   (X &OPTIONAL F) (ZCPRINT X F #b0001))  ; arg 3 =  1
N1   (X &OPTIONAL F) (ZCPRINT X F #b0101))  ; arg 3 =  5
 &OPTIONAL F) (ZCPRINT X F #b0010))  ; arg 3 =  2
ÿ
t on calls to the above ZIL functions.
ons is affected by the setting
output is affecx ted except:
pt for functions written
sages
erty list is a list of an even number of elements (zero or more)
ing "indicators" and "values".  The indicators are, in
hough in theory they could be anythinÿ
LISP object.
ell of a

isembodied property list always has an odd number of elements.
 lists are destructively updated by replacing the value
with the preceding indicators, or by splicing a
nto the end.  Therefore, using a constant
s a very bad idea.
 invalid
n ÿ
m "place" refers to
in the
 list is treated ÿ
.  If "place" is not a symbol or a list, then an error is
where otherwise indicated.
roperty lists:
   returns the value associated with "indicator" on the property list
ed in "place".  If there is no "indicator" on the property list,
alue" (NIL if omitted) is returned.
	
indicator" the specified "value".  If "indicator" is already
ty list, its current value is replaced by "value".
indicator) value) is equivalent to the above
cepted Common Lisp way of setting
icator)
rom
lt value to "indicator".
mbol)
ll
)
 list "plist" and stores it in the property list
ust be a symbol.  No validiÿ
property list.  This function
L place indicator-list)
for one of the
Ô
nd indicator is the CAR of the return value, and the
he CADR thereof.
 of GET that is used to search a function
es.  It is not generally used on
and GETL, if "place" is neither a symbol nor a list, a warning
ssued and the default value is returned.  This is
lity with Maclisp, and is required for Macsyma
information on these and other functions that manipulate
e the members of this documentation that describe


 system itself and have special meanings.  Using these as property
rs can have untowardÿ
nts the Maclisp-compatible-array
here by *ARRAY, for example.
xisting ARRAY properties
efined.
itions
UTOLOAD - a value which tells the ZIL system how tÿ
  function definition of a symbol that doesn't have one yet.
E - a value which tells the ZIL system how to locate the
l value of a symbol that doesn't have one.  This is
 "symbol-autoloading", a feature unique to ZIL.
to store the "documentation string" associated
 DEFVAR (but not DEFUN at this time).
ÿ
FUN, for example.
ciated with

         there by DEFFLAVOR, for example.
file from which a function definition was
 DEFUN, for example.
a symbol, placed
ETHOD - the function used by the SETF macro to transform SETF
ls for that function into the appropriate codÿ
 - a function used by the reader to process the "#"
acter for reader macro characters defined
 SPECIAL - if non-null, indicates that the symbol with this +
       has been declared SPECIAL under the interpreter.  T© his isÿç
õ
n-null, the symbol with this property is
m to ZIL.  You cannot create
fÿ

†
  ZIL-NO-AUTOLOAÿ
        property has been determined to be undefined and that ZIL
   should not try to autoload it again.
ollowing properties are used byÿ
ue which tells the compiler how to locate the
on of a symbol that doesn't have one yet.
ition of a symbol placed there when the
	
          compiler sees a DEFMACRO.
 transform function associated
EFTRANS, for example.
ion the compiler

             knows about is a LEXPR.
 maximum number of arguments
e compiler knows about.
er of argumÿ
knows about.
T arg
on to the above, propertieÿ
T are reserved for use by DEFSTRUCT, and
haracters ZIL are also
 use them
ermore, many property names are used internally by the
cute code at compile time (i.e. using the
be careful not to rely on
nflict with the

ys.  Putting properties on these symbols may affect the system
t you wouldn't expect.
  *READERMACRO* - used to store reader macro definitions.
sed to store compiler attributes.
CREAD is the low-level interface to the "current ZIL reader",
D, TYI, TYIPEEK, READLINE, and many other routines.
ault ZIL reader", set to be the "current ZIL
n time but not otherwise called by
he low-level function that takes a SUBR argument and makes
ent ZIL reader".
ÿ
n which is to act as the "current ZIL reader", including
 takes six required arguments:
rg 2 = a fixnumÿ
ellaneous function-dependent data (e.g. char operand).
.
de up from the following bit sÿ
sion (READ)
character (UNTYI)
 Intern a character (READCH)
  ....1...  =  EOF request
  =  1 = set EOF/EOL, 0 = test EOF/EOL
ADLINE)
ro
 character
onal file eoferp eofval recurp)
 eofval recurp))
en the one

put functiÿ
 that calls these functions is affected by the setting
reader".
tention prompts (these alÍ ways come from the
ç
axes for
 functions may be used to define new reader macros.
tions for the ÿ

ader macro dispatches on the character following
unctions for the following coÿ
here it says that something "returns" something, that means
is returned to the reader, as if you had typed in
y; the resulting form is then processed by
 #'A --> (FUNCTION A) --> <#FUNARG A>.)
s (FUNCTION A).

#- (minus sign)   - #-A skips the next object if A is a "feature".
slash)    - #\A returns the fixnum equivalent of A.
 is the same as #\A, for Maclisp compatibility.
. ×# is a comment sequence (can be nested).
returns a vector containing foo, etc.
integer equal to hex nnn.
l to octaÿ
ary nnn.
eans
s a FIXNUM equal to hex ÿ
 complement value.
valuation)

†
cter.  The function works the same way as one used for DEFRDMAC,
 the (RMCHAR) function will return # and not the


                Examples:    'FOO --> (QUOTE FOO)
         '(A B C) --> (QUOTE (A B C))
on LISP backquote syntax, complete
@ ,. syntaxes are all
nitiÿ

e form that the backquote generates is significant when
  What it generates+
ot relevant.
AR))
   `(A ,B C) evaluates to the list (A (FOO BAR) C).
) evaluates to the list (A FOO Bÿ
mas) are extremely useful in coding
unctions that build LISP
nts are constant.
form (see above).
s for this are:
d the next
        #'FOO --> (FUNCTION FOO)
LAMBDA (X) X))
nd returns
n
.(LIST 'A 'B 'C) --> (A B C)
to select items based on
ature FOO isÿ
ch
ded to be used with code ported to multiple
st activate the desired feaÿ

                              then returns the item after that,
                  otherwise returns nothinÿ
gn) - if the next item read is NOT a feature,
hen returns nothing,
 after it.

    (2) A list (OR feat1 feat2 feat3 ...), such that at least one
of the "featn"'s is a "feature".
..), such that all of the
A list (NOT feat1) where feat1 is NOT a "feature".
features are currently present in ZIL:
LE-VALUÿ
installation, some or all of:
      In addition, under the interpreter, there is a ZILIN feature;
der the compiler, therÿ
OPS5 feature;
  #/  (with slash) or
lent of whatever
e following,ÿç
orresponding fixnum:
         HT, TAB          5     (i.e. hex 05)
  (i.e. hex 07)
 CR, RETURN      13     (i.e. hex 0D)
hex 15)
EED    37     (i.e. hex 25)

6     (an "invalid" value)
f the character

     #/A     is the same as the fixnum 193
same as the fixnum 64
lus the EBCDIC

                         (This is subject to change.)
osed toÿ
haracter type, which of course has no
d to make LISP code developed on
#× ... ×# - denotes a ÿ
 ... */, EXCEPT that the #× ... ×# syntax can be NESTED.  This
 easier to surround blocks of code (which may already
 with a bigger comment block.
INTEGERS, but allow them to
…
        (0 through 7 only) and builds an integer.
ats the following characters as hexadecimal digits
, A-F) and builds an integer.
acters as binary digits
er.
                digits (0-9, a-z, A-Z) and builds an integer.
  Any numeric base between 2 and 36 inclusive may
edÿ
c digits may be used.
.
  #x... is equivaÿ
 above:
fied

onal + or - sign can occur betÿ
digits.
ision
Õ
   integer -255.
ZIL 1.2 and
Õ
            A maximum of 8 hex digits can be specified, and
a sign is not permitted.  The value may be in
nt notation.  This format, a ZIL-only
o type in hex fixnums, and works
L 1.2.
        but #zFFFFFFFF = the integer -1
turns a veÿ
any number of elements from zero to the
 for which vector/string space is
build the vector.  The
r is equal to the
tor.  The
uding
s within the vector are not evaluated.
"foo") returns a vector of 5 elements.
ot be compiled.  Vectors must be
VECTOR or MKVECTOR function
   Other "dispatching" characters may be activated by placing a
on (something that can be APPLY'ed) on the SHARPMACRO
e character.  The function works the same way as
, except:
ric

         character.
will be the first
gnore it,
ction,
 you wish to define your own reader macros, you may refer to the
on for the functions DEFRDMAC, RDRM ACRO, RMCHAR and RMNIL
tion.
pecial forms in Zil:

  EVAL-WHEN
-BIND
 RETURN-FROM
ROW
e special forms, are
 in Common Lisp.  Also, some
cros in Zil.

 stake.  This may change in the future.
Ô
ion time.  Note that to bind these, you MUST include
or them - ZIL will not assume they are
version*            - a string identifying the current version
           of ZIL (i.e., "1.3").
ols naming "features"


           - identifies the current file being loaded,
   for a function's Lÿ
nternally by TRACE.
gentemp-counter*    - used internally by GENTEMP.
ed internally by SETF.
he library containing
the
                     include source members.  The dÿ
                   "PROGLIB.ZIL.LISP"  -  production
   "PROGLIB.ZIL.NLISP" -  test
 -  backup
taining a

                 easier to construct a dsname(member) string.
pÿ
         ZIL help information, used by the ZILHELP
unction (and, by extension, HELP).
nges the libraryÿ
rs.  The default is:
roduction
                  "PROGLIB.ZIL.ÿ
   Note that the string, although containing a
 qualified data set name, does not
otes.  This is to make it
name(member) string.
*******************************************************
                                                 *
n refers to Draper Laboratory facilities.   *
                                         *
ROGLIB in your XSETUP (CLIST, HELP, *
d to do to use ZIL is invoke   *
tside of ISPF) to get to    *
re you can invoke      *
am, or do a       *
  ÿ
          *
******
L,

 screen and use any other ISPF options you desire).
 will see is the ZIL primary optÿ

--------------
---------------------
         ×

--------------------------------------------------
- Display latest ZIL news
unction
 - Compile/assemble/link ZIL program/function online
ubmit JCL to compile/assemble/link ZIL program/function
Invoke compiled ZIL program
 8+ RELINK      - Link new copy of function into existing program
MBLE    - Asÿ
ay information about ZIL
 Press END key to terminate ZIL option.
t often will be (3), the in5 terpreter, which
 mind when "using LISP" is spoken of.
LISP functions or programs;
pers only.
ZIL Function Tracing ***
e by providing a
 the
„
CE   - activates tracing for all or selected LISP functions.
 deactivates tracing for all or selected functions.
ies processing done on entry to or exit from function
s a previous AT request
ly a tracing function)

compiled functions, when called by interpretive code)
t CANNOT be traced include:
evaluate theÿ
an be traced by

te list of these)
it is
UNTRACE, AT, OFF and PUTDATA,
.
is about to be executed, its name is displayed
ng with its (evaluated) argument
ts name is displayed next to the
t is returning.
ilities:
bar)

 (BAR . BAR)
trace foo cons)
as soonÿ
 and exit, and the particular AT that is specified
ect of the tracing.
BAR . BAR), T
data args))
Exit FOO: (1 . 1), T
a arg1))
t FOO: (1 . 1), T
 arg1))
 1) 

(1 . 1) 

)
exit, and
ill

¨ ))


:   (ABS arg1)

gative, the corresponding positive numbeÿ
therwise, arg1 is returned.
nt.
S 2)              ==> 2
  ==> 1.5

S -2147483648)    ==> 2147483648


ted) - a number.
um1 in radians.
terface is used to compute the
on flonum, the

er betwÿ
N subroutine library interface
 documentation for
    ==>   1.5707963267T 948966
OS 1)     ==>   0.0
(ACOS 0.5)   ==>   1.0471975511965979

	
cells) in

ZIL "program" is run.  See members $PARM and DECLARE of
or more information.
ce (as specified by
age collector)
doubled,

 this function with CSSIZE, which returns the total
f allocated CONS space.
1
evaluated) - a number.
(num1 + 1), of the same type as num1.
 equivalent to (+ n 1)
Errors signaled:

ADD1 2)              ==> 3
000000000000) ==> -999999999999
            ==> 4.5F0

valuated) - any LISP object.
Returns: 
rmed by
cessing:
 list2,

d as the value.
rmined by the keywords, if any, specified on
n Lÿ
e #'EQ, #'EQL or #'EQUAL
.  If :TEST is omitted, the default is #'EQL.
one of the MEMBER ÿ
ASSOC functions if the :KEY

                 MEMQL     for :Tÿ
        MEMQUAL   for :TEST #'EQUAL (or 'EQUAL)
e:  ASSQ      for :TEST #'EQ    (or 'EQ)
  for :TEST #'EQL   (or 'EQL)
ST #'EQUAL (or 'EQUAL)
s compared with the
red with
eyword specification.
 Compare PUSHNEW, which SETF's its second argument but is otherwise
l to ADJOIN.
 (A B C)
 C))               ==> (A B C)
 C)
1) X :KEY #'Cÿ
((A . 3) (A . 1))
IN '(B . 2) X :KEY #'CAR)     ==> ((B . 2) (A . 1))
          ==> (2.0 1.0)
JOIN 1.0 A :TEST #'EQ)    ==> (1.0 2.0 1.0)
 (2.0 1.0)

)

1 is alphÿ
:
haracter, T is returned; if arg1 is not in the range 0-255 or
on-alphabetic character,ÿ
g1 not a fixnum.
=> T
AR-P -1)   ==> NIL
 NIL
***") ; Not a fixnum.
.
 (AND &rest args)
ject.
st argument specified.
n is evaluated until one of them returns
wing arguments is bypassed.
 
 as a mini-conditional, e.g.:
 (IF condition1 THEN result).
ent to
).
              ==> T
  ==> NIL
 NIL
   (APPEND &rest lists)
                             (although the last argument need not be).
eturns: 
ts
 the last are copied (via repeated CONS), each
the last CAR of the copy of the
h no arguments, returns NIL.
", with each CAR of
tively alters its arguments.
er than the last one is not a proper list.
case, (APPEND atom), where atom is not a list, returns

ÿ
)           ==> (A B C)
COPY of X.
   ==> T
opied.
    ==> (B C)
Y Z))     ==> (A B C D E F)
(CDR W))              ==> NIL

1 list2)
ed, evaluated) - any LISP object, but generally a list.

s of argument 2.
(via repeated CONS) and the second
 the copy of the first
 copy of "list", with each CAR of
, which destructively alters the first argument.

t form of APPEND, used to implement

ll result.
 list,
L)           ==> NIL
A B C) NIL)      ==> (A B C)

D)
how a new copy of a list is made using APPEND2.
     ==> (A B ÿ
               ==> NIL
ing shows how the second argument to APPEND2 is NOT copied.
))               ==> (A)
 (APPEND2 X Y))      ==> (A B C)
ù
&rest lists2)

                      ÿ
 The result of applying the function specified by fun1 to the argument
made up of the elements of list2.
t (fun1) must be one of the followingÿ
ure.
name of a defined function.
tom LAMBDA).

  funarg under the interpreter, and a closure when compiled;
se is valid as the first argument to APPLY.
a function as follows:
EXPR (e.g. via DEFUN)

keÿ
d forms, which are not valid for these
If the symbol has no current function definition, it will be
a the ZEVAUTO funÿ
nt, to try to load a definition for the function.
UTOLOAD property, a compiled code function
ill be searched for; if it is foÿ
 of the symbol for future access.
part of the APPLY process.
nto a list by consing all
 the LIST* function
 been ALREADY
first
st.
f
CALLFUNK (F) (APPLY F '(1 2 3)))
he local variable F is
d to the

PLY F 1 2 3 ÿ
»
inition.
PLY.

)))    ==> (FOO BAR BAZ)
(APPLY #'CONS 'A '(B))             ==> (A . B)
      ==> (A . B)
" NIL)          ==> ("value-of-x" . "value-of-x")
trates lexical scoping.
DA (X) (CONS X A))
"value-of-a")
 
ng or symbol.
mbols that have string1
nterned symbols are searched to find those whose print names
 a substring.  If string1 is a symbol, its print name
 provides a kind of list of function or variable names that
quested string somewhere within them.
done; thus case is irrelevant to
he oblist.
 be returned.

t is interned
, such a
in the
r; some become interned
exhaustive
PROPOS is equivalent to Common LISP APROPOS-LIST (Common LISP
posed to display detailed info about each symbol found
.
al values will
ystem.
erned.
MQUAL ==> MEMQUAL      ;
ER ZIL-SOURCE-MEMBER)
OURCE-MEMBER)
RCE-MEMBER)

L, or an integer.
er representing the number of
PR.

rrently
s signaled:
se invalid.
 Results are unpredictable
member $LEXPR for information about LEXPR's.
OO X (LIST (ARG T) (ARG NIL) (ARG 1) (ARG 2)))   ==> FOO
   ==> ((BAR BAZ) 2 BAR BAZ)
: ARGS
luated) - a symbol.
 used anyhow.
ing:
 then:
s
‡
he 510 is octal 776)
is issued and NIL is
efinition,ÿ
 warning message is issued to the effect that changing the number of
f a function in ZIL is not possible, and fun1 is returned.
, if the value of the speÿ
the value of the LOADFILE property of fun1, to
rom which the ARGS request was issued
ma code files, which use ARGS in

.
hich exists in ZIL only to support Macsyma.
initions are not supported.
==> (NIL . 1)
    ==> (0 . 510)
for information on Maclisp-style arrays in ZIL.

ed, evaluated) - an integer.



hmetic shift operation is performed on the numeric contents of
place), with aÿ
Ö
e absolute value of the integer arg2.
t of N bits takes place, withÿ
g2.

 will be shifted out according to the rules ÿ
ruction - except if the result is a bignum, in which case it
 two's-complement long integer.
 not an integer.
ompare LSH, which does a logical shift.  ASH and LSH differ when
ative and a right shift is performed; ASH propagates the
fills in with zero bits on the left.
hich never produces a bignum.
¸

H -1 -1) Ö     ==> -1            ;  i.e. FFFFFFFF goes to FFFFFFFF

Æ
hich is the arcsine of num1 in radians.
 subroutine librarÿ
num1 is a single-precision flonum, the
otherwise the result is
	
tion requires the FORTRAN subroutine library interface
 member $FORTRAN of this documentation for
ples:
ASIN -1)    ==> -1.5707963267948966
SIN -0.5)  ==> -0.5235987755982989
") ==> ("***ERROR***")

ey test test-not key)

            ÿ
onal, evaluated) - a predicate function of two arguments.
, evaluated) - a predicate function of two arguments.
aluated) - an accessor funcÿ
e first dotted pair in alist2 whose CAR is equal to item1
est specified by the keywords;
g:
ir)
 pointer to it is returned.
returned pair as the "value"
ist, unless NIL is
ur in place of a dotted pair anywhere within alist2; when
it is skipped over and the search continues.
fied, a match occurs when an element of
 the CAR of.
ault #'eql)  - specifies a predicate function of two
  argumÿ
of each element of alist2. If the function
a non-NIL value, a match occurs.  The
t is always item1, andÿ
ays the CAR of the current
the :key function

                     arguments used when comparing item1 to each
              element of alist2. If the function returns
      NIL, a match occurs.  The first argument is
 always item1, and the second argument is
e CAR of the current element of
ey function applied if :key

                        that is applied to the CAR of each element of
                   alist2 before comparing it to item1 via the
  ÿ
       :key function is applied after CAR, NOT
ead of CAR.

-not keywords sÿ
 
patibility.  If Maclisp or Franz LISP compatibility is desired,
 equated with ZIL function ASSÿ
 and ASSQUAL for more info.
.

                   ==> NIL
 1)
. BAR) (BAZ . FROB) (BAZ . NICATE)))
    ==> (BAZ . FROB)
est is EQL.
(ASSOC 1.0 '((1 . A) (2 . B) (3 . C)))     ==> NIL
) (C)) :TEST #'EQL)      ==> (A)
==> (B)
A) (B) (C)) :TEST #'EQL)      ==> NIL
T #'EQL)  ÿ
ASSOC 'C '((A) (B) (C)) :TEST-NOT #'EQL)  ==> (A)
TEST-NOT #'EQL)  ==> (A)
    ==> NIL
	
(2) . B)))                ==> NIL
'EQUAL)  ==> ((2) . B)
SQ
any LISP object, but generally a symbol.
st in association list format
of dotted pairs).
se CAR is EQ to arg1;

hose CAR is EQ to arg1.  When the first such pair is found, the
t is returned.  The caller of ASSQ may use the CDR of the
he "value" of arg1 as found on the alist2 association
turnedÿ
 pair anywhere within alist2; when
the search continues.
±
not NIL or
P (ASSOC ... #TEST #'EQ).
test by default.
       ==> NIL
Q 'D '((A . 1) (B . 2) (C . 3)))     ==> NIL
 FROB) (BAZ . NICATE)))
. FROB)
ASSQ 1.0 '((1.0 . A) (2.0 . B) (3.0 . C)))      ==> NIL


d) - a list in association list format
a list ÿ
list2 whose CAR is EQL to arg1;
ng:
r)
ointer to it is returned.  The caller of ASSQL may use the CDR of the
ed pair as the "value" of arg1 as found on the alist2 association
ss NIL is returned, indicating no valÿ
 of a dotted pair anywhere within alist2; when
ed over and the search continues.

 Unpredictable results will occur if the second argument is not NIL or
t of dotted pairs.
t;
es:
 . 1) (B . 2) (C . 3)))    ==> (A . 1)
    ==> NIL
  ÿ
shows that the comparison test is EQL.
 (3.0 . C)))     ==> (1.0 . A)
> NIL
ç
t2)
d, evaluated) - a list in association list format
     (i.e. a lÿ
d pair in alist2 whose CAR is EQUAL to arg1;
 
t (dotted pair)
und, the
f the
n
y occur in place of a dotted pair anywhere within alist2; when
ase, it is skipped over and the search continues.
±
e arguments.
NIL or
but uses an EQ test;
	
(ASSQUAL 'A '((A . 1) (B . 2) (C . 3)))  ==> (A . 1)
B . 2) (C . 3)))  ==> NIL
CATE)))
 ;The following shows that the comparison test is EQUAL.
1 . A) (2 . B) (3 . C)))     ==> (1 . A)
 C)))   ==> NIL

c)
evaluated) - a symbol funname, list (funname),
pect) or (funname aspect quietÿ
g a function

‡
d associating the action specified by arglist and body with entry
 from the function.
ted for the function specified by
hat the default "Entering"
not specify otherwise.
s either entry or exit.
ore calls to the
ediately
is given, it defaults to entry.
n the onlyÿ
 exit from {funname}"
entation.
s
uted at entry to or exit from the function in addition to the
e.  If quietp is non-NIL, the "At..." message is
tion specified by arglist and body is
rglist maps the arguments to the function.  They may
 function's normal argument list, or any other
A &rest argument may be used to get the

 function returns a single value, an arglist of one variable is
 &rest argument may be used to get the list of all values
 of one value for functions that do not return

, or a subsequent AT may be used to replace an existing one.
rely ÿ
must be used to cancel tracing entirely for
naled:
Ã
TRACE, and UNTRACE.
n of tracing,
for displaying values.  See PUTDATA+
ls on how tracing and untracing
AT FOO)
all set a "breakpoint" at entry to FOO
"At entry to FOO" only.
 
                  that prints "At exit from FOO" only.
DATA A))       prints "At entry to FOO" and displays
          the value of the first argument to FOO.
INT A))   prints "At entry to FOO" and prints
 the value of the list of args to FOO.
 A))
                              upon entry, but does not print any
                    entry message.
s "At exit frÿ
value returned from FOO.
                             displays the list of values returned by
                        FOO ÿ
                 exit message.
nputs and outputs to a
ge of.

AT (FIB EXIT T) (V)
°
 2) (IN 1)
1)
IN 0) (OUT 1) (OUT 2) (IN 1) (OUT 1) (OUT 3) (OUT 8) (IN 4) (IN 3)
(IN 1) (OUT 1) (IN 0) (OUT 1) (OUT 2) (IN 1) (OUT 1) (OUT 3)
OUT 1) (IN 0) (OUT 1) (OUT 2) (OUT 5) (OUT 13) (IN 5)
IN 1) (OUT 1) (IN 0) (OUT 1) (OUT 2) (IN 1)
UT 1) (Iÿ
OUT 1) (OUT 2) (IN 1) (OUT 1)
(IN 3) (IN 2) (IN 1)
IN 2) (IN 1)
OUT 1)

) (IN 1) (OUT 1) (IN 0) (OUT 1) (OUT 2ÿ
IN 6) (IN 5) (IN 4) (IN 3) (IN 2) (IN 1) (OUT 1) (IN 0) (OUT 1)
1) (OUT 1) (OUT 3) (IN 2) (IN 1) (OUT 1) (IN 0) (OUT 1)
3) (IN 2) (IN 1) (OUT 1) (IN 0) (OUT 1) (OUT 2)
T 8) (IN 4) (IN 3) (IN 2) (IN 1) (OUT 1)ÿç
UT 2) (IN 1) (OUT 1) (OUT 3) (IN 2) (IN 1) (OUT 1)
UT 5) (OUT 13) (IN 5) (IN 4) (IN 3) (IN 2)
T 2) (IN 1) (OUT 1) (OUT 3) (IN 2)
OUT 5) (IN 3) (IN 2) (IN 1)
UT 3) (OUT 8) (OUT 21)
N 2) (IN 1)
IN 1)

 (IN 1) (OUT 1) (IN 0) (OUT 1) (OUT 2) (IN 1) (OUT 1) (OUT 3)
(OUT ÿ
) (IN 1) (OUT 1) (IN 0) (OUT 1) (OUT 2) (IN 1)
 (OUT 1) (IN 0) (OUT 1) (OUT 2) (OUT 5)
(OUT 1) (OUT 2) (IN ÿ
4) (IN 3) (IN 2) (IN 1)
) (IN 2) (IN 1)
(OUT 1)
)
N 2) (IN 1) (OUT 1) (IN 0) (OUT 1) (OUT 2) (OUT 5) (OUT 13) (OUT 34)
))
ATAN num1 num2)
ed, evaluated) - a number.
angent of num2/num1 in radians.
utine library interface is used to compute the value
 num2 are both single-precision flonums, or one
is a single-precision flonum, the result is
erwise the result is a double-precision


ce
er information.
.

0F0
ATAN 0.0   1)      ==> 0.0
   ==> 0.0
66
448
***")
  (ATOM arg1)
urns: 

an atom.  These include:

s:
ctions (RMNIL, ZILUNBND, etc.).
Notes:
              ==> T
        ==> T
> NIL
(ATOM (GET 'ATOM 'SUBR)) ==> T
on: BIGLIST
 - a bignum.
ody of the bignum in
ents of the list is dependent upon the internal implementation
See $BIGNUM for more information.
ignum.
o a bignum.
ST -2147483649) ==> (-2147483647 1)
unction: BIGNUM
, evaluated) - a fixnum.
xn's.
.
n

 t urn the bignum back into a list.
          ==> 2147483648


aluated) - any LISP object.
herwise NIL.
±
47, of
f
object is anÿ
           ==> NIL
 NIL
** 2 31))     ==> T
LOCK
valuated) - asymbol.
 

e value returned by the RETURN-FROM form becomes the return value.
ssing:
 The rest of the forms in the BLOCK constitute the body of the BLOCK,
e processed like an implicit PROGN.
during execution of the forms in
theÿ
eturned by the
owed
 this block, of coÿ
r block of the same name.
lock name.
 about RETURN-FROM and
which involve
 in
apparent in
is
rrences of RETURN-FROM:

URN-FROM BAR2 A))
)))))
RN-FROM NOGOOD 'Z))
N-FROM block name" error will be signalled.
1 2 3)                    ==> 3
 
 op1 arg2 arg3 &rest args)
n 0 and 15, inclusive.
ired, evaluated) - a fixnum.ÿ

rmed on

ied, the operation is performed in a
e operation is performed on
eration.  op1 specifies the Boolean operation
d 3 via a "truth table" as follows:
 223, "Common LISP: The Language",
, 1984.  However, the actual
the Maclisp manual.)
rg3 bit:  0   0   1   1
lue returned
__
 0   1   (logand arg2 arg3)
gnot arg2) arg3)
        0   0   1   0  ÿ
   0   1   1   arg2

     1   0   0   0   (lognot (logior aÿ
0   0   1   (lognot (logxor arg2 arg3))
 (lognot arg2)
g3)
      1   0   1   1   (logior arg2 (lognot arg3))
   1   0   (lognot (logand arg2 arg3))
1
e.
LE  0 #z0000FFFF #zF0F0F0F0)    ==> #z00000000
F0)    ==> #z0000F0F0
 (Bÿ
zF0F0F0F0)    ==> #z00000F0F
FFF
FFF #zF0F0F0F0)   ÿ
#z0F0F0000
#z0000FFFF #zF0F0F0F0)    ==> #zFFFF0000
 ==> #zFFFFF0F0
OLE 13 #z0000FFFF #zF0F0F0F0)  e   ==> #z0F0FFFFF
0F0F0)    ==> #zFFFF0F0F
	
(BOUNDP arg1)
	

 by arg1 must have a current SPECIAL binding
AR, or dynamically, e.g. via LET).
, if it has a valid AUTOVALUE
ked to see if a binding can
 returned.
 NIL, T or a keyword, BOUNDP may or may not be true,
ementation.
d and NIL
:
Q and SYMEVAL for more information.
LIST 'A NIL)                  ; Remove any funny properties.
)
BOUNDP '*FEATÿ
        ==> NIL
ECIAL A))
L

O) ==> NIL ; or T

uated) - a proper list.
urns: 
e
re copied, except for the last count2 elements. by
 the length of list1, NIL is returned.
not a proper list.
 
 C)
 
(BUTLAST '(A B C D) 0)  ==>  (A B C D)

uated) - a list.
t1.
der the interpreter only).
piled code; results are unpredictable

     #   ((E F)

ion: CAADR
- a list.
 
t of a list.
preter only).
esults are unpredictable
s:

list1)
 The CAR of the CAR of list1.
Ë
errors are detected in compiled code; results are unpredictable
d argument is passed.
 (CAAR NIL)            ==> NIL
tion: CADAR
 - a list.

e interpreter only).
code; results are unpredictable
s:
                ==> NIL
DDR
st.
.
 list.
 only).
 are unpredictable
 


 of the CDR of the CDR of list1.
turns the third eleÿ
rgument (under the interpreter only).
cted in compiled code; results are unpredictable
assed.
        ==> NIL

Returns: 
effect, this returns the second element of a liÿ

 errors are detected in compiled code; results are unpredictable
id argument is passed.

ion: CAR
list.
NIL.
rwise the contents of
aled:
 
f an invalid argument is passed.
tionally identical to CAR
ined.  This may
now

(CAR NIL)                ==> NIL
 B C D))         ==> A
 B))           ==> A

 
d) - one of the following:
t of one or more elements
ny LISP object.
h arg1 matches the first element,
member of it.

       (test1 consequent1 ... consequentn)
eqÿ


value; or T or OTÿ
aluated and compared (using EQL) to the constant
stn"s.  When it matches (via EQL or MEMBER)
ing the "testn" are evaluated asÿ
SE is skipped.
rrors signaled:
Notes:
e,
CASEQ, which is identical to CASE, and is available for
y.
SP
 A 
r five")
 ==> TESTCASE
"

four or fiveÔ "

forms)
m.
 The result ÿ
st form, unless a THROW specifying a tag EQ to tag1 is executed
ation of one of the forms, in which case case the value
W is returned.
 first.  A catch frame is then
ed like an implicit PROGN;
THROW occurs with a
tely terminated
is returned
last
acked by CATCH is removed when the forms evaluation
HROW occurs).  This frame is used to store the
ronment, including the current variable
e bindings are restored to the status
 function.
is
ith a mÿ
hes via EQ.
be.
ng evaluated is a funcÿ
y or indirectly.
n or by a
   results in a THROW to tag NIL.
d by the terminal user pressing
ts in a THROW to tag T.
all signalled errors.
o ZIL:
rs,
   can be disabled via SETABEND NIL).
rrupts fielded by the ZIL attention
ETATTN NIL).
r both
 fÿ
rom within a CATCH to outside the
ss it.
(CATCH 'FOO (THRO+
(CATCH 'ZZZ (THÿ
e CATCH tag - an error was signalled,
 In addition, an error message would appear at the user's terminal.
TCH '(FOO) (THROW '(FOO) 'BAR)ÿ
ROW tag was not EQ to the CATCH tag - error was signalled.
+ 'A 'B))                        ==> NIL
sing a THROW to NIL.
user's terminal.

 
ng:
only).
are unpredictable


DADR list1)
 
fect, this returns the CDR of thÿ
ignaled:
	
if an invalid argument is passed.
 D)))  ==> (D)
ZZ
ired, evaluated) - a list.
1.
 tÿ
iled code; results are unpredictable

==> NIL
tax:   (CDDAR list1)
rns: 
²

dictable
 '((A B C) (D E F) (G H I)))  ==> (C)
==> NIL
x:   (CDDDR list1)
s: 


ctable
(A B C D E))  ==> (D E)

st1 (required, evaluated) - a list.
R of list1.
nt (under tÿ
d in compiled code; results are unpredictable
ed.
         ==> NIL


y list1
otted
 "rest" of a list, i.e. a list of the second through last elements,
alue returned.  This is always a sublist of the original list
.  CDR of NIL or of a one-element list returns NIL.
 
errors are detected in compiled code; results are unpredictable
ÿ
NIL

)

1 (required, evaluated) - a number.

rg2, converted to an integer.
 of arg1 and the
the remainder, i.e. the difference
lue).ÿ
g2 such that a floating
s set to arg1.
an or equal to
er, itself is returned.
).
st integer; FLOOR,
 its argument;

result in integers whose value does not accuratelyÿ
art of the flonum.
own in these examples.
5)              ==> 2
            ==> 2
      ==> 2
==> 0
ÿ
(CEILING 0.2)              ==> 1
NG -1)               ==> -1
1.9)           ÿ
               ==> 0
         ==> 0
   ==> 1
  ==> -123
.5)     ==> 2147483648
G 2147483648.5)     ==> 2147483649
49
==> -2147483647
7483648.0)    ==> -2147483648

 -2147483649
      ==> -3
   ==> -3
ax:   (CHAR string1 index2)

x2'th character of string1, as a fixnum.
s used as a zero-based index into string1, where the characters
g are indexed from 0 to the string length minus 1.
ter is made into the fixnum representing the
.
d.
Invalid second argument (not a fixnum).
stinctions between the character extracting functions:
s one-based indexing, returns a symbol.
, returns a fixnum.

)           ==> #\o
      ==> NIL
==> #\B
#\R

(CHARDOWN arg1)
 
 
ng:
tself is returned; otherwise the equivalent lower-case fixnum

mples:


 (CHARACTERP arg1)
- any LISP object.
n integer between 0 and 255),
e argument is a fixnum, and its value is such that it can be
haracter" (i.e. it can fit in 8 bits), then T is
 returned.
racters are not a true data type in ZIL.  They are in Common LISP.
les:
> NIL
NIL

cterp 256)          ==> NIL
erp -255)         ==> NIL
2147483648)   ==> NIL
ace)      ==> T
  ==> T
T
haracterp #\?    )      ==> T
))  ==> T
 
ired, evaluated) - a fixnum.
e EBCDIC character which is the upper-case
resented by the fixnum arg1.
sent a lower-case alphabetic character,
uivalent upper-case fixnum
arg1 not a fixnum.
  ==> #/A
(CHAR-UPCASE 4000)   ==> 4000  ; unchanged.

ile1 (required, evaluated) - a file name.
 or one of the following symbols:
PUT, IN, OUT, APPEND.
cified by file1.  Whether the file is an
ermined by arg2.
 exists, iÿ
age associated with the file.
put or output file, since

open for output.
	
equivalent, as are OUT, OUTPUT and APPENÿ
ibility with the types specified on OPEN and
to the data set when it is closed).
specified with a leading colon
 and :OUT are equivalent.
argument, the CAR
d as above.
 (CLOSE F NIL)

RFUCIOUS))
n on ÿ
a file

you have previously ÿ
UT or 'OUT) and write to it again.
more files in order to make
cluding OPEN of
cond argument (not one of those listed above).
tandard input/output is not allowed).
e not correctly specified).
ion.
r Macsyma, CLOSE does not require the second argument.
CLOSE only files that were opened via the
er words, you cannot CLOSE files
ion).

+
O (equivalent to prev).
 (SETQ A (OPEN "'PROGLIB.ZIL.SOURCE(JUNK)'"))
)
:   (CLOSUREP arg1)

cessing:
rm
piled subroutine code and a pointer to the environment current at
he closure was created.
 ZILXSUB or ZILXFUN, but
In addition, they can be specified as the CAR of a list passed to EVAL.
Errors signaled:
orm in the interpretive environment
 it creates an object
edicate
ÿ
interpretive environment
SUREP (ZILLOAD 'CAR)) ==> NIL
nitialize SETF … setup



ure, whenever
 cleared.
s:
§

T if arg1 is some type of compiled code object or compiled closure,
e NIL.
 the types of compiled

   ==> NIL
nment
     ==> T
=> NIL ; dummy to initialize SETF setup
 T
COMMENT &rest args)

s treated as a comment, and does nÿ
ne.
ble, since
but not with the other constructs.
 out uses of COMMENT, but not
 a value!
 COMMENT
tax:   (CONCAT &rest args)
is not a list, vector,
 lexical closure.
me consists of args concatenated to
:
e

ly generated values for other types.  The resulting character
ncatenated together to build a symbol whose name is that
symbol is interned on the oblist.
 null print name is returned.
ructure, or funarg found as one of the arguments.
s a Fÿ
hich is identical to CONCAT except that it
 
 
 interned or uninterned symbols; and STRING-APPEND, which builds
her than symbols.


R
 'O))        ==> FOO
)                          ==> T   ; always interned.

1 (required, evaluated) - a proper list of atoms.
interned symbol whose print name consists of the atoms in the list
 by aÿ
e CAR's of arg1, which must be a non-null list of atoms, are
e character representations that they have when printed
e the actual print nÿ
esentations for numbers, and internally
he resulting character strings are
d symbol whose name is that
se a symbol with a null print name is
 
 
ZIL using
except that it
ent to (APPLY #'CONCAT x), but more efficient.
lent to (APPLY #'UCONCAT x), but more efficient.
 (CONCATL '(A))                ==> A

q > ×71.0foobar× ; A symbol.
; interned.

. clausen)
:
formn)
se
ditionally evaluated) - any LISP object.
ement of the first claÿ
 non-NIL value; NIL if no clauses satisfy this condition.


he clause are bypassed and processing continues with the next clause.
 result was non-NIL, then if this was the only element in the
he clause is a singleton list), that value is returnÿ
e COND; otherwise the remaining elements of the clause
ession and the last such value is returned as the
rs" are bypassed.

 is returned as the value of the COND function.
erally used as the first element of the
esÿ
e of the COND.

ELSE resultn).
se not a list).
     ==> B
'C))     ==> NIL
E2)
»
(COND ((EQ 'A 'B) 'TRUE1)
'FALSE)) ==> FALSE
E2)
=> A
Î
uired, evaluated) - any LISP object.
bject.
ÿ
 if arg2 is an atom, a
ial case of a
cessing:
t the new
and


Ä

(A)

aluated) - any LISP object.
null list or dotted pair), otherwise NIL.
ignaled:
          ==> NIL
  ==> T

unction: COPYENV
ated) - an evaluation environment.
nvironment which is a copy of env1.
s an evaluation environment which contains the same

ZIL function used by the evaluator to implement
 oÿ
ction will return the
e if you're
in ZIL.

 (COPYSYM symbol1 arg2)
rg2 (required, evaluated) - any LISP object, but generally T or NIL.
eturns: 
, with
ng:
.
be EQ to symbol1 or any other symbol.
ll be given a null property list.
bol1's property lisÿ
the property list of
PECIAL
	
	
erty list operations from side-effecting the property list of
ol.
(SETQ A (COPY-SYMBOL 'FOO NIL))    ==> FOO ; but not interned
                     ==> NIL

       ==> NIL
erned
            ==> (A B C D)
  (GET A 'A)                         ==> B
       ==> C
                 ==> B  ; not affected.
·
E list1)
: 
:
„
1).
re

 of inline
ially
 

B) C . D)
          ==> NIL
    ==> NIL

valuated) - a number.
 num1, where num1 is expressed in

1.  If num1 is a single-precision flonum, the
lonum; otherwise the result is
naled:
er than 823549.5625.
14220.125.

the FORTRAN subroutine library interface
AN of this documentation for
upported as arguments to this function.
 ==> 1.0


Returns: 
n
RM field, or in ÿ
 and DECLARE of
fuse this function with ACSIZE, which returns the total
urrently active CONS space.  CSP SIZE returns
ce allocated that may be called upon
 cells are used up after a

ptional file1)

t line
 Each invocation of CTERPRI causes a line to be written out to the
 output file if and only if there is data on the current
eturned as the value).  If no data hÿ
o operation is performed (NIL is
t character position is reset to 1 when CTERPRI is issued,
ne is cleared to blanks.
 object (not a symbol 4 characters or less).
located or could not be opened.
e information on file names.
current output line.
RINTER for more information on printing functions.
TERPRI)
 T                 current line of standard output, if it is not empty.
 (CTERPRI 'FOO) ...writes out the contents of the current line of
       output file FOO, if there is any data on it.
¦¦
NT-DATE)
nt date as the year,
he ÿ
a list is made of the 3 components.

p year

 while building the list, the date
ested before midnight
ar returned is a 4-digit year, as opposed to Zil prior to
t Y2K compliant and returned a 2-digit year.
E)     ==> (86 8 12)   ; on August 12, 1986
 ; on April 13, 2000
TE

ar and days.
 list is made of the 2 components.
±
ate
 the GC completed after midnight.
as opposed to Zil prior to
2-digit year.
stˆ  21, 1986
Â
    or:   (CURRENT-TIME)
enting the current time in hours,
	
2 components.
 a garbage collection occurs while building the list, the time
be inaccurate; but it will reflect•  the time before

ü
ç
ecrement2)
s to a
number.
crement2.
neral is any form acceptable
 or location specified by plaÿ
 value of decrement2, which defaults to 1 if not
ignaled:
 used.
s a macro that expands something like this:
 a b))
 A            ==> 9
-1)  ==> 7
cial Form: DECLARE
, not evaluated) - any LISP object.
essing:
IAL

are many clauses that can occur within a DECLARE,
ÿ
ZIL include those below.
MBDA, DEFUN, PROG,
CLARE
not be preceded by other kinds of forms, with the possible
mentation strings.

nterpreter that the variables (symbols) named herein are to be
 as "free" variables; i.e. other functions may refer to
ndings, these being true Common LISP "specialÿ
 A SPECIAL declaration at "top level" causes the affected variable
ngs to be treated as SPECIAL everywhere they are found.
eclaration within a form affects only those bindings
 by that form, unless the variables referenced
m, in which case the declaration
at form.  The actual
e involved.
    "Common LISP: The Language" in the section on declarations.
 top level, the recognized DECLARE clauses are:
- this claÿ
rein are to be compiled as "free"
tion.  The difference
erences to
les.
bindings of the variables affected.  This may produce unwanted
so use top-level DECLARE under the interÿ


must be an integer greater than zero.
ing the problem of compiling a function
in more than 16K of addressable
cify, for example,
compiler will automatically take the body of FOO and attempt
it up into 8 segments of approximately equal size.  In
of segments may be different; the compiler tries
each segment by dividing the total length
queÿ
first "flattens out"
ing the
 discarding all atÿ
h is the one that would be returned as a value.
of forms in the body as the basis for
 
  replaced by a body which contains n calls to internally
tions of no arguments (where n is less than or
gment count).  The internally generated
nction-name SEGMENT n×.
 the length of
 form
ts in such a way as to
ithin the 16K

ll argument list.
ome "free"
ey are
g

egmentation unless absolutely necessary,
ion call overhead that resulÿ
l when compiling a MODULE, which
e segmentation when

icit definition of FROB in the MODULE
ould be illegal!), the compiler
unction it builds to
 
   represented by "funcspec" is to be loaded interpretively rather
compiled.
ccur in
cspec"'s may be coded; each is either a symbol
ction name somewhere in the file being
e functi+
FUN (F² OO BAR) ...).
nction in question contains code
s fine interpreted.
bles that are

       the uncompiled code is called.
     specifies what the compiler is to do with a "free" ÿ
ence that has not been subject to a declaration.  The
T-BINDING SPECIAL), which means that the
rpreter in a similar situation)
IAL, and is compiled
e in
  to tell the compiler to treat such variable references as
terminÿ
s only, this specifies the
t initialization.
the
   This space is allocated above 16 megabytes if possible.
ZE value) - valid for PROGRAM's only, this specifies the total
he CONS space to be allocated at iniÿ
ted, the default value of 4 megabytes (4096K) is used.
s), fixnums, single-floats, and the header portions
s are allocated in this space.
location, not to be confused
 see ACSIZE below.
ssible.
he size of

 This value controls how much of the total CONS space (as specified
Sÿ
at more space is needed, at which time the ACSIZE
ided that it does not exceed the CSSIZE
ne of the valuesÿ

     vector/string space (the space used to build symbols, vectors,
ngs, double-floats, bignums andÿ
ization time.  If this is omitted, the default value of


actuality twice the specified virtual storagÿ
pace is allocated above 16 megabytes if possible.
 - This is no longer supported.  Valid for PROGRAM's
specify the size of memory to be reserved for
initialization time (i.e. NOT allocated to
 uses memory above the 16-megabyte
room for OS functions as much
ations are no longer present in ZIL 1.3:
code is compiled as if (AUTOFUNCALL T)
     AUTOSPECIAL - all ZIL 1.3 code is compiled as if (AUTOSPECIAL T)
         ÿ
nes the correct
 bytes
                 terminaÿ
       have to use segmentation (see above) to get your
nction to compile.
 a proper list).
ace where
rrors within DECLARE clauses (for example, object
in a SPECIAL clause).
 y z)
e 8M) (vssize 256K))

fun1     (required, not evaluated) - a symbol.
ated) - an integer or NIL.
.
Who knows?
  But it tells the compiler
 not defining in your
ly, when the compiler finds a call to a function that is not
 code, and it is not a "standard" ZIL function as can
entaÿ
tively apply the function symbol to the
ompiled code to call interpreted
ALL's.
BR and
 direct branch to the code), you can use DEFARGS.  For example:
RGS SOMEFUNC 1 2)
SOMEFUNC
TIONAL B) ...)
  (DEFUN PIG (A B) (CONS (SOMEFUNC A) B))
an EXPR (actually a SUBR since it will be
ibrary) with at least 1 and at
ted will be passed as
heir default
nform
 (i.e.  1-8 alphameric characters, first one alphabetic or national).

externally with a &REST keyword in its lambda list,
ds in its lambda list,
ples:
„
S SOMEFUNC 2 5 T) ; 2 required,  3 optional,  1 &rest
2 T) ; 2 required, no optionaÿ
:
t know about" funcname.  Any

Errors signaled:

4)
, not evaluated) - a data set name.
ISP object, generally T or NIL.
ject, generally T or NIL.
tion definition for it that evaluates all
	
e" file, i.e. a
 DEFFLIC is a macro that expands into a DEFUN, which defines arg1 as a
ion that evaluates a list ofÿ
tical to the forms found in the data set specified by
s follows:
Y.LISP(STUFF)")
erpreter, code
P(STUFF).

tion definition of FOO.
rate a load module that
 a MODULE.
arg3 is specified and non-NIL, then the forms are macroexpanded
 are added to the function; the default is to add them
xpanding them.
functionÿ
the
ation generated by DEFFLIC has 2 optional args, as follows:
ame &optional arg1 arg2ÿ
nvoked, then
l-print
rg2 is specified when the function is ÿ
rinted before evaluation is attempted on it.
FLIC is primarily for use with the compiler;
a ZIL source member FOO which contained
 another data set which contained

ands for "Fast Loading Interpreted Code."
rpretive DEFUN's et al. in a compiled
ated with READ.  It is especially
 of read-time evaluation,
 ha+
 ÿ
l compilation of a file with macro definitions does not
to the requestor when the compiled file is
s based, also, oÿ
of DEFUN that the ZIL compiler
s of function definitions
OCOMPILE ...))
e no such
now obsolete.  The functionality
d by DEFFLIC may be
tely describes
	
1 (required, not evaluated) - a symbol naming a function.
t evaluated) - a valid IBM-style symbol
8 characters or less, alphanumeric).
ciating with it the IBM-style external name specified
ssing:
rty of
call
 argument of APPLY), the AUTOLOAD property value is used, if present,
s to ZILLOAD, who searchesÿ
s no AUTOLOAD property, fun1 is used.)
s on fun1's property list are removed
L for sym2 is equivalent to
 be its own external
 given function name fun1 with
ws:
d in

igned to it
e the

 whose true name is longer.  For example, assume source file FOO is
mpiledÿ
ewhere in the file.  But you could also have this:
...)
s the compiler that Fÿ
e main function of the source file.
lid syntax (too few arguments, or args not both symbols).

less, all alphanumeric, first character not alphabetic).  In addition,
 the compiler, symbols beginning with the # character or the
reserved, since they would generate conflicts with
ls.

bol for the external name and report an error.  Under the
ction loading will fail.
uate one function with
ng assigned ONLY.
  
	

required, not evaluated) - a lambda list.
om or proper list.
 definition for it in the current
DEFMACRO is a macro that expands into a DEFUN that defines a macro.
ax is as foÿ
rm2 ... formn)
ng defined
s
when the macro is expanded,
on.
ly equivalent to:
 ,(CADR X)))
ures that
d be used to define macros when there must be a specificÿ
ts on the macro call, including none.
may be used as well, in the same way
a function, for macros which
dition, destructuring of
ied-p" variables for
ent which is bound to the macro call is not accessible
; if yÿ
 
n the MACRO property of the symbol specified by the first argument.
mples should illustraÿ
 B A))

alue of FOO's MACRO property.
tion, DEFMACRO does not
terpretive

he use of NIL as the macro name is invalid.
nvalid syntax (too few arguments, or invalid argument list).
 by DEFUN (q.v.).
e by a macro
ecified on macro call
&REST)
 +

perty list under
mpilable.

However, &WHOLE and &ENV are not supported at this time.

UN FIRST MACRO (X) (LIST 'CAR9  (CADR X)))
 returns the CAR of its one argument.
RST)            signals a "too few arguments" error.
als a "too many arguments" error.
*********************************************************************
                                                              *
on is obsolete.  Use INCLUDE while compiling a MODULE.  *
                                                    *
***********************************************

t ÿ
t name.
.
hat loads all theÿ
g:
er
rmat, including function definitÿ
ds into a list of forms bracketed by
ile and processed as follows:

hat, when executed by typing (foo)
s generally expected by
 a COMPILE-FILE
 invoked inside the ZIL interpreter, code is
ed function definitions and other forms
ch form from that file is
f the form is a macro call, the macro expansion is processed.
forms for which DEFMACRO's or DEFUN's that define
ncluded in the file itself, as long as
lls.

ction, as follows:
   places the compiled defiÿ
roperty of f, insuring that no conflicting
finitions are present.
cro known in the
 not
 f FEXPR ...)   places the interpretive definition of f on the
         FEXPR property of f, after a warning is issued
    that FEXPR's cannot be compiled.
tes an equivalent macro
nally in case there
e code.
 the
                  property of f, after a warning is issued that
          LEXPR's cannot be compiled.
compiÿ
l F.  Note that this is
ining such a

aration of the form (DECLARE (NOCOMPILE f ...)) or
 ... )) - the latter being intended for
e - the interpretive definition
opriate property.
s generated,
milar to

cuted in the variable binding environment active when the
evaluated (executed).  Thus, dynamic scoping is the
for compiled functions loaded in this manner.
r a DEFLOAD, the usual compiler processing
VAR or DEFLOAD is added to the
ÿ
he form is an EVAL-WHEN, the forms within are processed thusly:
HEN (COMPILE) - forms are evaluated by the compiler itself.
)    - forms arÿ
ignored.
g
enerated module
 is a function with no arguments.
EFMODULE:
 they are
ion
ght imagine, DEFMODULE is primarily for use with the
you would compile a ZIL source member FOO which
ULE form pointing to another data set which
e compiled.

EFMODULE call is quite useful as an AUTOLOAD property on the
are contained within - e.g.:
fprop bar (loadfoo) autoload)
ng a file  containing:


ar.
 compÿ
tively at load time.

ks like this...
baz frob) (y) (hair))   ;    2
(mac "junk")                    ;    4
 5
z)    ;    7
 8
-when (eval)
ulting form will be (more or less):
    (zevdsub 'foo1 (subr foo1))                 ; 1 - assign SUBR prop
putprop 'baz (subr (lambda (y) (hair))) 'frob)  ; 2
                          ; 4 - expanded MAC
                 ; 5
     (xdefload frobnicate frobozz)               ; 7
ÿ
           ; 1
d DEFMACRO
d frobnicate frÿ
print "hello world"))                       ; 8
e (zmfoo) under the interpreter, the following will
 be defined as a SUBR (compileÿ
e a compiled SUBR on its FROB property.
ver they are) will be executed.
iable with a value.
property.
he
val-when (eval)) forms are always ignored
 that function code is compiled with names where desirable and
sometimes (subr name) and sometimes (subr (lambda...)) is

rg1 arg2 arg3)
uired, not evaluated) - any LISP object.
y LISP object, generally ÿ
as been made the value of the property specified by
t of the atom specified by arg1.
 identical to (PUTPROP 'x 'y 'z).
d:
 member $PROP for information about property lists.
DEFPROP A B C)        ==> B
ç
un2)
xnum.

 char1, after assigning the function specified by fun2 to the character
ified by char1 as a reader macro.
tion is invoked to associate ÿ
piled code SUBR for the ZRMAPPLY function; this
READERMACRO* for a property whose indicator
ng the function of one argument to be
erty list of the atom *READERMACRO*
 it.
Ð
ecify a function that takes one argument; this argument is
 name currently in use by READ when it invokes the
es the reader macro code to access data from
tions like READ, READCH and PEEKCH.
der macro character as an atom,
f the function wishes to return "nothing" to the reader (i.e. have
r continuÿ
(e.g. via the form (VALUES)), or
he function is typically a symbol, a funarg (created by the FUNCTION
 form), or a LAMBDA or Lÿ
	

tion
 following characters are predefined:
)
tion for details on these.
fined thus:

ng will be returned by READ:
interpreter, this will be evaluated by EVAL
)
  (DEFRDMAC "?"  #'MYQRFUN)

args)
see description below.
f structurÿ
 of creating new data structures (essentially
CT is issued, a series of macro
 creating an object
in that
hether a given Lisp object is of that type.
r this definition:
es a type of object called a KONS, which consists of
nd KDR.  The following macros are defined

or which you can optionally
ts.  For Maclisp
thout

opy of an object of type KONS, for which you can optionally
lues for the KAR and KDR slots.  For Maclisp
 may ÿ
t true &key syntax in the
 returns T if arg1 is a KONS, and NIL otherwise.


pecified by kons1.
lue of the KAR slot of KONS kons1 tÿ
l2)
though DEFSTRUCT defines objects that are structures by default, it
 be used to define objects as trees (i.e. conses) ÿ
  There are many options; consult the Common Lisp
 details.  Not all of those options are
r.
 
Maximal syntax:
                {ARRAY × TREE}
ÿ
e} {arglist})}

      )
for the EVAL-ÿ
lized above (not including DEFSTRUCT, NIL, or values
ptionally be prefixed with a colon.  E.g.,
d.
	
aled:
oes NOT allocate any objects; it merely defÿ
uld use to create and manipulate them.  It does
that it can be used freely in both compiled
TYPEP object type) will return T for "object" created by DØ EFSTRUCT of
pe name "type", unless the ARRAY or TREE option was specified.

2)


not evaluated) - a symbol that names a function.
luated) - a list of either 1 or 3 symbols.
) - any LISP objects.
 for fun1.
nction.  The proper way to
N (COMPILE) ... )
compiler

 by fun2 becomes the compiler transform for fun1.
(DEFTRANS fun1 arglist2 &rest forms) syntax,
s constructed from arglist and forms
 elements, the function is
ist2 has 1 element, the function is
ere arg1 is the single
 symbols.
voked
ls
o try out the transformation.
wing steps:
2) If the result is an atom, do the appropriate processing
if any).
   to the function call via ZILCOTRN.
 transform the arguments
e CAR of the form is a LAMBDA expression,
LAMBDA expression and
the form.
ciated compiler transform function, apply that
 (2).
ler transform function, we are finished.
o the result of (2),
     from (1).

on name)
t of keywords describing the context in which the
d.  If this list is n+
  Possible
        will be used as a return value (or values)
be used as an argument to a function
 a variable
  ...and others...
nt.
    pass a LAMBDA expression, ZILCOTRN (but not iÿ
ctions) will transform a LAMBDA-expression
m.
 transformed - and 1 optional argument, which (if non-NIL)
g mode" so that you can see each step of the
 compiler's transformations
T) before

(i.e. is
is the value of the constant if it is (the CDR is reserved for
ements).
iler transform function execution
ation to be nullified.

COMPILE) ...)

 {arg2} arglist3 &rest forms)
mbol, or a list of 2 symbols.
PR, or MACRO.
     (not evaluated) - an atom or proper list.
(or (car name1)), after establishing a function definition for it
rent environment.
ils about defining functions.
he argument list.
A-expression on
 when
e
UN FOO (A B) (PRINT 'HI) (CONS B A))
INT 'HI) (CONS B A))
MACRO (X) (CONS X NIL))
e value of FOO's MACRO property.
tion-defining technique.
s not generate
…
occur at top ÿ
)

(too few arguments, or missiÿ
or list (symbol + property).
tion type).
r of arguments for FEXPR (not 1 or 2) or MAÿ
an FEXPR to the compiler.
defined at run time in a compiled program
e XDEFUN, XDEFMACRO or PUTPROP to
 on the symbol's property list.


o the name of the file being loaded.
 definitions as follows:
PR is being defined, any existing MACRO property is removed.
 being dÿ
 This insures correct execution of the defined function according to the
es of evaluation (see member $EVAL of this document for more

 A) (CAR (EVAL (CAR X¯ ) A)))
)))
{
(DEFVAR var1 &optional val2 doc3)
 symbol.
c3    (optional, not evaluateÿ
fter it has been established as a global variable in the
nment.
riable specified by var1 is already currentlÿ
d a warning message is issued; otherwise the variable is
VAR variable (this is done internally by creating a
th no value).  The variable does NOT become
f val2 is specified:
ntly bound, no action
e variable is
value

operty of the symbol var1.
†
ays SPECIAL bindings.
nd only when
ION.
 or too many arguments.

EFVAR may be issued more than once for ÿ
ue, if provided, is assigned only the first time, and then
ble is not bound yet.
new value via SETQ.
oes not have
ment
EFVAR FOO)         ==> FOO
und variable error.
> NIL
 that the value is not changed.
    7       ==> BAZ   ; SETQ has changed the value.
riable set by DEFVAR.")
   ==> NICK

 arg1 list2 &optional count3)
bject.
valuated) - an integer.
e elements of list2 except for those
ng:
is
, all occurrences of arg1 are removed from
 count3 occurrences of arg1 are
nts are removed.
ent of DELETE.
ered;
rrors signaled:

LISP
Õ
L via ÿ
.
 done as to the validity of the arguments.  Unpredictable
 if the second argumeÿ
all the "destructive" functions, DELETE should not be used
piled list, i.e. a list derived from compiling the
orm2 ...)).  This will cause furtherÿ
st to be incorrect.
e CAR of list2
ws:
THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG))
QUICK BROWN FOX JUMPS OVER LAZY DOG)
 (FOO) FOO BAR))
L, not EQUAL.
L, not EQ.
2 1 2 1) 1) ==> (2 1 2 1)
1ÿ
ed by DELETE.
                   ==> (A B C D E)

   ==> (B C D E)
X))      ==> (A B D E)
                     ==> (A B D  E)

1 list2 &optional count3)
t, but should be a symbol.
 count3 (optional, evaluatÿ
consisting of all the elements of list2 except for those
1.
 within list2 that is
 is omitted or NIL, all occurrences of arg1 are removed from
se, only the first count3 occurrences of arg1 are
s than 1, no elements are removed.
tructive equivalent of DELQ.
ist are considered;
Q.
IL).
test.
 checking is done as to the validity of the arguments.  Unpredictable
s willÿ
 
n-line compiled list, i.e. a list derived from compiling the
E (form1 form2 ...)).ÿ
onstant list to be incorrect.
t2 if the CAR of list2
as follows:
E '(THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG))
=> (QUICK BROWN FOX JUMPS OVER LAZY DOG)
R) (FOO) FOO BAR))
EQ, not EQUAL.
s EQ, not EQL.
X Y X Y X) 1) ==> (Y X Y X)
 'X '(X Y X Y X) 3) ==> (Y Y)
ed by DELQ.
                 ==> (A B C D E)

 ==> (B C D E)
       ==> (A B D E)
                ¤    ==> (A B D E)

1 list2 &optional count3)
t.
ated) - an integer.
ements of list2 except for those
	

l occurrences of arg1 are removed from
nt3 occurrences of arg1 are
are removed.
f DELQL.
 
ignaled:

, which is like DELQL but uses an EQUAL test.
 the validity of the arguments.  Unpredictable
ond ÿ
structive" functions, DELQL should not be used
i.e. a list derived from compiling the
 This will cause fuÿ
orrect.
2
 (SETQ Y (DELQL X Y))
 FOX JUMPS OVER THE LAZY DOG))
 JUMPS OVER LAZY DOG)



 1 2 1)
==> (2 2)

> (A B C D E)

(EQ X Y)                    ==> NIL
)
==> (A B D E)

al count3)
required, evaluated) - a proper list.
ger.
 except for those
2 is destructively altered.  Each atom found within list2 that is
rg1 is deleted from ÿ
es of arg1 are removed from
nces of arg1 are
.
.
-atomic elements are NOT recursively processed by DELQUAL.
ed:

ch is like DELQUAL but uses an EQL test.
validity of the arguments.  Unpredictable
 argument is not an atom or a proper
tive" functions, DELQUAL should not be used
. a list derived from compiling the
ÿ
ect.

(SETQ Y (DELQUAÿ
OWN FOX JUMPS OVER THE LAZY DOG))
FOX JUMPS OVER LAZY DOG)
BAR))

 (DELQUAL 1 '(1 2 1 2 1) 0) ==> (1 2 1 2 1)
2 1 2 1)
) 3) ==> (2 2)
	
     ==> (A B C D E)
                     ==> (A B C D E)
E)
A B D E)
         ==> (A B D E)


 - a symbol or list.
eturns: 
a series of
turing
arg2 in the argument list..ÿ
 a non-NIL symbol, DESETQ is identical to SETQ.
arg1 is DESETQ'd to the CAR of the value
ETQ'd to the CDR of the value of
 value of arg2 is ignored.  This
ment.
Errors signaled:
 (q.v.).
ts according to a
in
nymous LAMBDAs.
-keywords" are not supported by DESETQ.  If you need this sort
ity, you must use the destructuring provided by

red to generate calls to ZCAR for efficiency (meaning that you
 will never be "carred"), then you must effect this by
DEFLOAD CAR ZCAR)
ETQ (A B (C D) E . F) '(1 2 (3 4) 5 6 7))  ==> (1 2 (3 4) 5 6 7)
         A ==> 1
          D ==> 4

           A ==> 1

¸

 (DOUBLE-FLOAT-P arg1)
 
essinÿ
e SFLOATP, which returns T if its argument is a single-float;
ich returns T for any kind of flonum.
 ==> T
0) ==> T
NE)  ==> NIL
 
n)
- a number.
 all the arguments.
0 is returned.
r
nary minus of n.
 signaled:
Ç
ENCE)         ==> 0
-4
E 9 1 1.0) ==> 7.0
AR-P
DIGITCP char1 &optional (radix2 10))
xnum.
turns: 
ter
cified by radix2, else NIL.
whose EBCDIC value represents a "digit" in the
s "weight" is returned; this is a fixnum
 digit in that radix.  If char1 is
ÿ
 alphabetic characters (lower or upper case) and EBCDIC numerics
T-CHAR-P.
 fixnum betweenÿ
R-P #/9)    ==> 9     ; Default radix is 10.
 ; Default radix is 10.
0.
IT-CHAR-P #/9 16) ==> 9
  ==> NIL
DIGIT-CHAR-P 1)      ==> NIL
-P 999)    ==> NIL

 arg1 arg2 arg3 ... argn)
e first argument (a list of local variables with initialization
t specifications) is required.
lause) is required.
ny number of
tially evaluated) - a list of local variable clÿ
elements each, where the first element (not evaluated)
nd (evaluated) is the value to which the symbol
d the third (not evaluated) is a form
le is to be incremented.
ause, i.e.

 first returns a non-NIL value.
SP object.
cified by the second
at of DO is:ÿ
 valuen incrn))

's must be symbols and are ÿ
cts and are evaluated when the
"s are forms which are
consequentn"s, and
uence in the

nts, the second and/or third may be omitted.  Furthermoreÿ
t of arg1, a symbol may be specified; this is equivalent
ement.  In other words:
 (J) (K)) ...
...
arallel rather than sequentially.
riable in the environment present outside of the DO.
mented ÿ
t immediately before
 to previous
ed
 or invalid arguments).
 refer to a MACLisp or Common LISP

ROP I) J)
O FOO FOO FOO FOO)
ST
t of a local variable with an initialization
ations) is required.
t any number of
partially evaluated) - a local variable clause, i.e.
ts, where the first element (not evaluated)
ated) is the value to which the symbol
rd (evaluated) is the value to
 NIL).
s: 

he second element of arg2.
LIST is:
T iterates over elements of "list".  First "list" is evaluated,
 produce a list.  Then the forms in "body" are evaluated;
 executed once for each element (CAR)ÿ
able "var" bound to the element.  Then "var" is
a single form, NOT an implicit PROGN) is
lue returned from DOLIST.
after executing the body.
nate the loop and return

t a symbol).
 a proper list.
(FOO NIL))
==» > (D C B A)

ocal variable with an initialization
is required.
mber of
y evaluated) - a local variable clause, i.e.  a list of 2
re the first element (not evaluated) is a symbol, the
s a fixnum which the variable is compared to, and
he value to be returned (this is optional and
n (conditionally evaluated) - any LISP object.
third element of the list arg1, or NIL, after executing the
 the first element of arg1 bound to successive
ent of arg2.

 over a sequence of integers.  First "count" is
uce an integer.  Then the forms in "body"
executed once for each inteÿ
t" (exclusive), in order, with
te that if the value of
 all.)  At the
 was
nteger.  Then "result" (a single form, NOT an implicit PROGN) is
and the result is the value returned from DOTIMES.
tted, DOTIMES returns NIL after executing the body.
d within the body to terminate the loop and return

 Invalid variable name (not a symbol).
t is assumed to evaluate to a integer, or at least
, a run-time error will occur.
    (DO; TIMES (X 10 FOO) (PUSH X FOO)))
1 0)

tring1 (required, evaluated) - a string.
ntical to string1, except that all uÿ
placed with their lower-case equivalents.
 argument is not altered.
ls are acceptable.

nt vector/string space to build the result.
NG-UPCASE.
STRING-DOWNCASE "a")       ==> "a"
STRING-DOWNCASE "foo")     ==> "foo"

o o bar"
ntax:   (EBCDIC arg1 arg2)
rg2 (optional, evaluated) - any LISP object, but generally T or NIL.
urns: 
cter
must be a fixnum, is used as the 1-character EBCDIC
ol print name.  If the fixnum value is less
warning message is issued and a null
print name.
terned
t behavior), meaning that it will not be EQ to any other atom.
gnaled:
e Maclisp function ASCII, which is similar.  Of course,
 IBM 3ÿ
ion is defined as (EBCDIC arg1 T).
   ==> ×a×
he symbol whose printÿ
ymbol whose print name is a null
   ; not interned.
(EQ A 'F)                    ==> NILÑ 

file1 &optional file2 arg3)
name.
evaluated) - any LISP object,ÿ

cessing:
le2 is specified, it is made the "ECHO" fileÿ
e1 is echoed, character for character, onto output file file2.
 file cannot have more than one echo output file associated
e1 already has an echo file when (ECHO file1 file2)
g relationship is terminated.
oing takes place even if
  The default
ince

ile1 is
file2 is ÿ
st be reissued to reinstate echoing.
nput file object (not a symbol 4 characters or less).
ject (not a symbol 4 chaÿ
cated or could not be opened.
d not be opened.
n file names.
ut from standard input is to
llocated to the
bove.
s to
rminal.
¦
1)

f arg1 is omitted orÿ
d by the (ED 'symbolname) function, which is created as a new
t if it doesn't already exist.
s a data set name (similarly to
 ISPF editor is entered on
om ED is arg1.
n associated
and then
d,
lue is that returned by the LOAD function; if the dataset was notÿ
IL is returned and no load takes place.
e function definition is specified,
 with no LISP code in it
ÿ
ny valid

tion is availabÿ

r than 56 characters.
 running outside
 Facility


	
e typed in "on the fly" under ZIL.  To save a permanent copy,
e CREATE or REPLACE command of the ISPF editor.
 function definitions for functions
as functions that are
mode when you started ZIL, you will
 mode when ED enters ISPF.
ive ZIL session
o
g.
LISP"

e) is used, this dataset +
us contents are always ÿ
e previous contents of that data set.
returned T if the dataset was saved,
 so that you could type
t just edited

voked from within a LISP program (including
ked under ISPF via the XINVOKE command,
ices not being available.  For
y the ISPF option via
les:
retty-printed
s the ISPF editor on whatever you had put in that file
ED ! "cmd.clist(zlogon)")
der ZIL.
ax:   (EIGHTH list1)
rns: 
ents.
)).
 See CAR, CDR, etc.
 NIL
   ==> H
x:   (ENDP arg1)
Returns: 
	

d.
or may not be signaled
he recommended way of testing for the end of a list.  It
sts" only, not lists ending in an atom.
           ==> T
   ==> NIL
Syntax:   (ENDREAD &optional file1)
put file name.
he file specified by file1.
 the file block for the input file specified by
put functions (READ, READCH, etc.) initiate
s the effect of causing READCH to
ut operation against the file.
tested by NEWLINEP, but if
d cause NEWLINEP
 logical record will be read
urrent record that
he terminal, this causes unprocessed input
en typeÿ
ct (not a symbol 4 characters or less).
d or could not be opened.
rmation on file names.ÿ
esults in a TGET
on call

in the current input is not processed.  Since ZIL sees the
records with a length of 80, the input "flushing"
is.
	

ional file1)
Returns: 
ecified
e flag is on in the input file file1, T is returned;
ed.
 processing one or more READ/READCH/TYI caÿ
en reached, in order to prevent a "read after end of file" run-time
A NIL result returned by READ or READCH, or an "eofval" from
ignored if the end-of-file flag is on for the file in
rors signaled:
less).

 If the QUIT function has been issued against the file, EOF will

F 'FOO)      returns T if end-of-file has been reached on FOO.
ç
 arg1 (required,evaluated) - any LISP object.
y LISP object.
otherwise NIL.ÿ
ting arg1 is the same (the address is
epresenting arg2.  Two symbols
s created by a function
GENSYM).  Two numbers
ers, or EQL if
ssarily
	
out equality predicates.

X '(A B))      ==> (A B)
     ==> T
(A B)

unpredictable: either T or NIL}
EQ (MAKNAM  '(A B C)) 'ABC) ==> NIL

1 arg2)
d, evaluated) - any LISP object.
ontents of arg1 and arg2 areÿ
 If the arguments are EQ, regardless of type, the result is
. T is returned).
lt is
numbers, a numeric compare is performed of
ember that the types must match.
ing contents are compared.
es (including symbols and lists), the two arguments
d only if they are EQ.


»
      ==> NIL

L arg1 arg2)
quired, evaluated) - any LISP object.
ures of arg1 and arg2 are ideÿ
 the arguments are both atoms, EQUAL is equivalent to EQL.
s an atom and the other is a list, EQUAL returns NIL.
lists,
ve the same length.
 lists are EQUAL.
 wish to
 None.
 will recur until
nts that
ation about equality predicates.
      ==> T
==> T
Â
QUAL "A" "a")           ==> NIL
=> T
LIST 'A 'B))   ==> T
LP
y LISP object.
nal, evaluated) - any LISP object.
s of all the args are identical, else NIL.
LP, which takes exactly two args, the following holds.
s are EQ, regardless of type, the result is
ed).

 a numeric comparison is performed.
nverÿ
meric compare is done.
are is done on the
 to uppercase.
have the
are EQUALP.
e the
EQUALP.
 EQL.
s
cent pairs are compared); otherwise the result is NIL.
	
 equality predicates.
Lisp EQUALP.

tially considerably more expensive than any of the

ys been a ZIL function by that
.
         ==> NF IL
   ==> T

unction: ERROR
 (optional, evaluated) - any LISP object, but generally a string.
onal, evaluated) - any LISP object.
arg1 (and the other arguments, if non-NIL) is printed to
 file, a THROW to tag NIL is issued.
rgument is omitted, or is a list, control is passed to
coÿ
 for more information.
t does not contain
ments

as to provide an error prefix and appropriate indentation on
e error message.
MAT string with
he

o cause ZIL to signal an error.
or message, and the other
 error.
 the
kes place.

ne in ZIL
	

 file and siÿ
r another." A)  will print:
UE-OF-A
and signal an error.

) - an atom or proper list.
on list format

ding environment
	
that two evaluations
al argument
cified.
is nÿ
 to NIL, in which case the current
ironment (alist) is used.
cal variable bindinÿ
ed by this
 is

 detail.
argument is not NIL or
valuation environment to EVAL, you must use
les:
properties.
 Insure A not bound.
VAL '(QUOTE FOO))                 ==> FOO
  (EVAL 'A))                     ==> ("***ERROR***") ; unbound
value"))
 
	
x:   (EVAL-WHEN times &rest forms)
list of one or more of the
: COMPILE, LOAD, EVAL


 are evaluated as an implicit PROGN
list.

member of the times list, the forms are evaluated
by the compiler itself.
ms are compiled as
L, if specified, is ignored by the compiler.
 Missing times list.
ctives had to be coded via the %
 CDR of that list to be
ile still sÿ
L-WHEN (COMPILE) ...forms...)  construct is the
ler directives.

o the compiler and to compile-time macro expanders; for example,
 of SETF methods.  In cases like these, it is best to
ons in an (EVAL-WHEN (COMPILE LOAD EVAL) ÿ
g the running of the source code
re information, see member $COMPILE of this document.
 (EVAL-WHEN (COMPILE LOAD EVAL)
BAR (X) `(SOME EXPANSION WITH ,X)))
ource:
program now!")
ssage:

 arg1 (required, evaluated) - an integer.
s even (divisible by two), else NIL.
:
d in compiled code; results are unpredictable
ed.
IL
ion: EVERY
 evaluated) - a function that can be APPLY'ed.
a proper list.
: 
 function to successive elements (CAR's) of the other argument lists
 else T.
ment is applied to each of the
e other arguments, until
returns T) or a null
ERY returns
 
Y, NOTEVERY, and the mapping functions.

EGERP '(A B C D E))   ==> NIL
VERY #'INTEGERP '(A 2 3 4 5))   ==> NIL
> NIL
(A B C D))  ==> T
'(X Y Z) '(A B C D))  ==> NIL

ptional arg1)
urns: 
stem.
rol is returned to the
ogram.
eter,
riendly "I ended" message.
 be a fixnum and the
s.
is
ne.
return code
.
is function may be used in LISP programs to return non-zero return
ch may be tested in CLIST's or JCL.
 (compiÿ
diate termination of the
eter cleanly by


L)
de of 12 to the system.
eturns nonetheless.
 nonetheless.
yntax:   (EXP num1)
rns: 
ocessing:
 the
is a single-precision flonum; otherwise the result is
num.
he FORTRAN subroutine library interface
N of this documentation for
 fail for values of num1 about 174.673 or greater.

11714423

ODE arg1)
: 
r representation of arg1 asÿ

printed - as it looks via PRIN1.  Each character in this
hen used to build a symbol whose print namÿ
all of these symbols are interned on the oblist
a list, which is returned as the value.
	
entation
al argument to EXPLODE that
 symbols.  EXPLODE
ILEXPL, an

NIL) style exploding; EXPLODEC uses the latter.
ODE 'A)ÿ
(×7×) ; note that this is the symbol ×7×,
 the fixnum 7.
ll.
  ==> (×\×× ×a× × × ×b× ×\××)
(EXPLODE "abc")         ==> (×"× ×a× ×b× ×c× ×"×)
> (×a× ×b× ×c×)

bject.
ng to the

it has when it

single character, and all of these symbols are interned on the oblist
nsed together to form a list, which is returned as the value.
naled:
r but uses the representation
 (EXPLODEC 'A)     ==> (A)
   ==> (×7×) ; note that this is the symbol ×7×,
  ; not the ÿ
ll.
×× ×a× × × ×b× ×\××)
"abc")         ==> (×"× ×a×+  ×b× ×c× ×"×)
×b× ×c×)
yntax:   (EXPLODEN arg1)
	
esentation of arg1
arg1 is converted to the character representation which it has when it
inted - as it looks via PRINC.  Each character in this
n used to build a fixnum whose value is the EBCDIC
single character, and all of these fixnums are
t, which is returned as the value.
±
interned
 the PRINC-style
t creates
d
=> (193)
PLODEN NIL)    ==> (#\N #\I #\L)
×007×) ==> (240 240 · 247)
EXPT
1 (required,evaluated) - an integer or flonum.
 fixnum or flonum.
 (num1 ** num2).
 result is returned equivalent to 1
s an integer, this will be a
0) returns 1.

$ARITH for other errors.
rmation.ÿ
Y log(X)
re, flonum
…
r information.
  ==> 16
6)
 32)    ==> 4294967296
XPT 0 0)     ==> 1
Beware of using EXPT as a substitute for SQRT.
5.0
9999999999995
naccuracies creep in.

     3.0D0)  ==> 7.9999999999999984D0
T 2.0F0 3.0F0)  ==> 8.0000038F0

984D0

g1 (required, evaluated) - a symbol.
ing of whether the symbol specified by arg1 currently
ion.
 of the following:
by DEFUN or
 a compiled code defiÿ
s function.
at
he autoload process is invoked
  If this process fails
¤
returned.
bols which
e
function source file).
	
†
DP.  That does not count as a function definition for the
xÿ
     ==>  T
 ==>  NIL
FBOUNDP 'NEW-FUN@ CTION)    ==>  NIL
CTION

ired, evaluated) - any LISP object, but generally a symbol.

ing:

 T is returned; else NIL is returned.
e used in ÿ
es the next item
next item
be made to be FEATUREP byÿ
-NOFEATURE.
tation-
s
 documentation for more information on the use of "features".
naled:
ly present in ZIL:
  MULTIPLE-VALUES DESTRUCTURING-FLAVORS LOOP
erpreter, there is a ZILIN feature;
ture;
MACSYMA feature.
FEATUREP 'MACLISP)      ==> NIL
ROGN
==> Tæ 
                     ==> NIL
: FEXPAND
 an atom or proper list.
o the form specified by arg1, but
os have been expanded
Processing:

d forms that it knows occur in
s, it makes certain
ows about

acro definition known to the compiler) is a function that
ments.  In addition, function definitions inside
e expanded (note that '(Lÿ
nded, but #'(LAMBDA ...) will).
d by macroexpansion.
 any form or subform is not an

 (FOO X)))          ==> (BAR (FOO X))
==> (BAR (BAR X))
FOO 1))
(DEFMACRO M1 (X) `(M2 ,X))         ==> M1
 ==> M2
ACROEXPAND   '(M1 (M1 A)))           ==> (M3 (M1 A))
 A)))           ==> (M3 (M3 A))
: FIFTH
 list.
s less than 5 elements.
(CAR (CADDDR X)).
otes:
         ==> NIL
E))        ==> E

Returns: 
Processing:

L)                ==> NIL
C D))         ==> A
. B))           ==> A
N
- a fixnum.


 by
 
f list2.
gative.
 l) for n less than zero may be defined some day as returning
menÿ
N 0 '(A B C))      ==> NIL
A B C))      ==> (A B)
A B C))      ==> (ƒ A B C)


t converted to an integer.
, the nearest integÿ


 its argument to the nearest integÿ
nteger greater than or equal to its
e integer part of the flonum.
 Note that flonums whose exponent is large (in eiÿ
t in integers whose value does not accurately represent the
the flonum.
=> 1
1

(FIX 7E-4)     ==> 0

2147483647
        ==> 2147483648
47483649.5)   ÿ
647
  ==> -2147483648
83649.0)        ==> -21474836¤ 49

x:   (FIXNUMP arg1)


integer in the range -2147483648 thru 2147483647.
ange are bignums, of which BIGP is true.
to test if an object is an

NUMP 1.0F0)        ==> NIL
         ==> NIL
 ==> NIL
x:   (FIXP arg1)
eturns: 
 

te, since its meaning is unambiguous with respect to bignums.
is an integer in the range -2147483648 thru 2147483647.ÿ
f this range are bignums, of which BIGP is true.
e used to test if an object is an
es:

ONE)            ==> NIL
    ==> T
tax:   (FLATC arg1)

 print

ject is returned as the value.
otes:
rint
     ==> 3
 ==> 3
=> 11
2    ;  length of fixnum 12
f string "00012"

object.
s required to print
sing:
Ç
ne.
takes to print
)              ==> 3
           ==> 3
AR))     ==> 11
       ==> 2    ;  fixnum 12
"00012"
s function loads the ZIL FLAVORS system.
P $FLAVORS), or see the $FLAVORS

onal arg2)
valuated) - a flonum.
 
:
„
rned as a flonum.

self is returned.
 type as arg2
s a

     ==> 3.5

0F0)  ==> 3.0F0
	
LOATP arg1)
s: 
.

or single-float and double-float respectively.  (FLOATP X) is
(OR (SFLOATP X) (DFLOATP X)).

LOATP 1.0F0) ==> T
ú
&optional arg2)
al, evaluated) - a number.
arg1, or arg1 divided ÿ
is specified, the difference of arg1 and the
rg1 and arg2 are specified, the remainder, i.e. the difference
and (arg2 times the first value).
ified, arg1 is divided by arg2 such that a floating
.  Otherwise, the argument is set to arg1.
e nearest integer less than or equal to
 If the argument is integer, itself is returned.

 argument to the nearest integer;
er greater than or equal to its
teger part of the flonum.
e that flonums whose exponent is large (in either direction) may
ntÿ
flonum.
e examples.
     ==> 1
 ==> 1

(FLOOR -1.5)               ==> -ÿ
LOOR -1.2)               ==> -2
0.5)                ==> 0
              ==> 0
          ==> 0
    ==> 0
=> -1
 0
24
==> 2147483647
3648.5)       ==> 2147483648
FLOOR 2147483649.5)       ==> 2147483649
7483647
      ==> -2ÿ
R -2147483649.0)      ==> -2147483649
3650
> -4
3
Syntax:   (FMAKUNBOUND arg1)
ired, evaluated) - a symbol.
 current function or macro definition
‡
 is removed.
n, the

BOUND'ed.
ecial form (it is illegal to "undefine" these).
BOUND does not remove AUTOLOAD properties.  (Maybe it should.)
 that the argument to FMAKUNBOUND is evaluated.
N FOO! (X) NIL)   ==> FOO!
O!)ÿ
)    ==> ("***ERROR***") ; Cannot undefine ...
   ; Special forms cannot be killed.
 (FBOUNDP 'CAR)   †       ==> T    ; SUBR definition just gets reloaded.

est1 string2 &rest args)
 name (symbol), or a
quired, evaluated) - a sÿ
ject.
ine to the standard
ormatted line.
e
 line to the file dest1.
 "format directives" indicated by embedded
to the string according to the
prints the resultant
urns the
data
Ã
format-string" format-args ...) to
 NILÿ
matted.
 "Common LISP: The Language", pp. 385 & ff.
ORMAT is 100% complÿ
cation.
adchar,
rectives above.  Note that in caseÿ
a prefix modifier (by a preceding quote), a number is not
e versa.
> - causes following newline and/or whitespace toÿ
 depending on modifiers.
e>.  End of line is also equivalent.
           - selects one of a series of elements to be formattedÿ
     Note that cent sign may be used in place of left bracket,
and broken vertical bar may be used in place of right
on IBM 3270 keyboards.


 - conditionally generates a newline.
itable floatinÿ
s.

erates a newline.
       - generates a tilde.ÿ
         - formats in binary.
ible.
al floating-point.

s in octal.
 the specified radix, or English or Roman.
 prints.
ats in hexadecimal.  Note that X does NOT generate
it does in Maclisp.
lementation:
ing process.
lent to tilde

  with the unbroken vertical bar (hex 4F), which is the "formfeed"
e.
	

any Common LISPs.
for a tabulation
ing to a file,
plus 1) is
d by the ~:; directive inside a ~<...~> group,
ardless of the output destination.
rs - invalid FORMAT directives, etc.
d.  Undefined modifiers, for
y be ignored.
manuals:
ual (Burke, Carrette, Eliot)
fiÿ
 FROB bar"
following examples are taken from CLtL, pp. 385&ff.
(special x y n))

l "The answer is ~D." x)     ==> "The answer is 5."
s ~3D." x)    ==> "The answer isÿ
x) ==> "The answer is 005."
                                       ==> "The answer is 229,345,007."
at nil "Look at the ~A!" y)       ==> "Look at +
nil "Type ~:C to ~A."  #\D "delete all your f© iles")ÿç
   ==> "Type D to delete all your files."
" n)
here." n (= n 1))
R dog~:*~Ös are~; is~:;s are~| here." n)

ere are three puppies."
iesÿ
rmat nil "~D tr~:@p/~D win~:P" 1 3) ==> "1 try/3 wins"

   ==> FOO
14159"

0)      ==> "1234.00×******×?????ÿ
 ==>  "  0.01×  0.06×  0.01× 0.006×0.01×0.006"
t nil
   x x x x))       ==>  FOO
1×+.003D+03×  3.14D+0"
 -3.14D+0"

fun foo (x)
%G×~9,2G"
3.14D-2×314.2$-04×0.314D-01×  3.14D-2"
14    ×0.314    × 0.31    "
   ×  3.1    "
"
1.59)    ==> ÿ
>  "*********×314.0$+10×0.314D+13× 3.14D+12"
e:~{ ~S~}." '(fred harry jill))
"
rs: <A,1> <B,2> <C,3>."
 (c 3)))
@{ <~S,~S>~}." '(a 1) '(b 2) '(c 3))

 *print-level* *print-length*))
evel = ~D~|~@Ö print length = ~D~|"
h*))
o))
~S~^,~}~|.")
s: none."
il foo 'foo 'bar)       ==> "Items: FOO and BAR."
'baz)  ==> "Items: FOO, BAR, and BAZ."


oo~;bar~>")   ==> "  foo  bar"
ar "
<foobar~>")     ==> "ÿ
bar    "
nil "~? ~D" "<~A ~D>" '("Foo" 5) 7)     ==>  "<Foo 5> 7"
 "<~A ~D>" '("Foo" 5 14) 7)  ==>  "<ÿ
~A ~D>" "Foo" 5 7)       ==>  "<Foo 5> 7"
o" 5 14 7)    ==>  "<Foo 5> 14"
         ==>  "XIV xiv"
tected." n))  ==> F
==>  "One error detected."
 
arning~:P.~^ ~D error~:P.")
    ==> "Done."
 (format nil donestr 3 5)         ==> "Done. 3 warnings. 5 errors."
 ÿ
says this returns "Twenty-three."
> "Twenty-three"

str 23 "losers")  ==> "Twenty-three losers."
;~^~S~>" 'foo)       ==> "            FOO"
" 'foo 'bar)  ==> "FOO         ¯ BAR"
o 'bar 'baz)
 BAZ"
   (FOURTH list1)
: 
s.
naled:
:
=> NIL

ired,evaluated) - any LISP object.
terpreted lexical closure (funarg), otherwise NIL.

m (FUNCTION ...); this creates an object consisting of a
t that can be FUNCALL'ed or APPLY'ed and a pointer
t at the timeÿ
 or specified as the CAR of a list
	
 environment does not createÿ
 closure.  The predicate
 also MKFUNARG, the low-level function that builds funargs.

 the interpretive environment

nction: FUNCALL
uired, evaluated) - a function that can be APPLY'ed.
ated) - any LISP object.
 function specified by fun1 to the arguments
lt variable binding environment.
e environment, FUNCALL is an interface to APPLY
aY re valid functions.
±
Ð
ú
 
turns: 
ilt fromÿ
UREP is true of this object.
eted lexical closure object (known in ZIL as a funarg), built
 function) and the currÿ
 object.
ined and used, together
in compiled code),
ssion defines a
r
e evaluated by EVAL.

closure is an instance of a function invocation with its own
 environment, independent of the environment under
cation occurs.  This implements non-local
signaled:
L expr).
e eÿ
ng on the implementation.
nds into (FUNCTION x), e.g.:
)
e $MAP for information pertaining to the use of FUNCTION and QUOTE
pping functions.
 
rpreted lexical closure (funarg)
onent of funarg1.
nt not a funarg.
; results are unpredictable
function is used by APPLY, and should be used by nobody else.
ÿç

	
:

n invalid argument is passed.
d be used by nobody else.
  ==> FOO

 
llection to occur.
 so that itÿ
; when CONS detects the end
.  The dummy CONS
ignaled:
	
to take place
yntax:   (GCD &rest nums)

ssing:
of one argument returns the same argument.
-integer argument.
 0
==> 2
   ==> 1
 ==> 12
0)  ==> 12
   ==> 1
 ==> 1
=> 1
=> 1
 2
 1024)         ==> 512
00000000 -1024)        ==> 512

      ==> 2147483648
CD -2147483648 -2147483648) ==> 2147483648
> 1
==> 1
00) ==> 1
0000) ==> 1
        ==> 1
 -1000000000) ==> 512
000000 -2147483648) ==> 512
 GCD2
n integer.

Á
 argument.
 to implement calls to

CMSG
SP object, but generally T or NIL.
, T if garbage collection messages are currently
g1 is specified, arg1 after setting the
es on or off.
ollection messages are currently
ey are not, NIL is returned.
 display of garbage
rwise, the flag that controls the display of garbage
set to ÿ
 disables them.
xamples:
ion
 messages.

Returns: 
 of a
current ZIL sessÿ
 and incremented by each garbage collection
 the "job step elapsed time" at start
nd of GC.  The time values are
unction.
) is a cumulative value.  To time a particular GC, record the
ME) before and after, and take the difference. 
x
eturns: 
e
ÿ
ter (initially 1) is used to construct a symbol name,
from it and the GENSYM prefix (initially "G").
hich means thatÿ
eation of the symbol, the GENSYM counter is incremented.
l argument is specified, it is processed as follows:
r, it must be non-negative; thÿ
en used when the symbol is created; it
rementing until the counter
ecomes the new GENSYM prefix, and is used in
subsequent GENSYM's until the prefix
bol, the symbol's print name is used as for strings

re used to create the symbol name.
vector/string space to build the object.
er is converted to a decimal value of not less than
ading zeroes.
ve the same
l still
are
.
.
 unique GENSYMs will stilÿ
all that wonderful.
NSYM)       ==> G00008
SYM '100)  ==> G00100
OO00102
A (GENSYM))  ==> G00006
> T
   (GENTEMP &optional pfx1 arg2)
or symbol.
 
the "GENTEMP
y by
ially 0) is incremented and used to construct
 the GENTEMP prefix, and a symbol is built
mented until a symbol name is obtained
oblist (i.e. is not interned), and
 created.
 The second optional argument to GENTEMP is supported for compatibility
 other LISP's, but it is not used in ZIL at this time.
ÿ
 uninterned symbols.  The differences
 the fact that GENTEMP symbols
es not include ÿ
default prefix
==> T1
T3)          ==> T   ; GENTEMP6 's are always interned.
==> T4
es
P)           ==> T8
 
) - a symbol.
symbol.


ssing:
for an

 arg3 was omitted) is returned.
,ÿ
 list is treated like a
st" used in
essage is issuedÿ
n error, but is
aled:
See member $PROP for informatioÿ

      ==> NIL
                       ==> A

       ==> NIL
 'BAZ)                       ==> (FROB NICK ATE)
                ==> (FROB NICK ATE)
NIL
n test is EQ, not EQUAL or EQUALP.
  ==> X
1.0)                        ==> NIL
T '(A B C D E) 'A)  ==> NIL
E) 'C)  ==>  NIL
> NIL
T 1 2 3)            ==> 3    ;  with a warning message


ed) - a fixnum.
s an iÿ
ed index into string1, where the characters
 to the string length.
ich is always
 greater than the length of the string,
aled:
t (not a fixnum).
 character extracting functions:
returns a symbol.




string1 index2)
required, evaluated) - a fixnum.
ter of string1, as a ÿ
one-based index into string1, where the characters
 from 1 to the string length.
fixnum representing the
is out of bounds with respect to the string, the fixnum 0
 that there is no way to distinguish this case from
x 00) character being returned from inside
aled:
t (not a fixnum).
haracter extracting functions:
returns a symbol.

 
(b GETCHARN "foo" 0)       ==> #\NULL

nction: GETK
quired, evaluated) - a proper list.
ject, but generally a symbol.
, but generally T or NIL.
AR is the "value" associated with the
blist of arg1 whose CAR is EQ

f alternating
 "pair"
sent, the sublisÿ
f this list is the value found.  If the
t on the list, NIL is returned.
 or a list with an odd number oÿ
3 is omitted or NIL, an error
cified and non-NIL, the
ed:
).
perate on
nt
:A X :B Y :C Z) ':A)     ==>  (X :B Y :C Z)
 ==>  NIL
 Y :C Z) 'Y)      ==>  NIL
GETK '(:A X :B Y :C Z) 'Z)      ==>  NIL
>  NIL
AD LIST) 'X NIL)      ==>  ("***ERROR***")
==>  NIL
tax:   (GETL arg1 arg2)
 (required, evaluated) - a list.
roperty list of arg1 whose CAR is a properÿ
ements of arg2, or NIL if no such

cator-value "pair" for which the indicator is EQ to one oÿ
 arg2.
is
second element) is the property value.
ot present on the property list, NIL is
g property indicator in the property list determines
rder of the elements in arg2 is irrelevant.
 must bÿ
se the CDR of the list is
odied property list"
a symbol or a list, a ÿ
 actually should be an error,
.
NIL).

r1) returns "value1", etc.
          ==> A
'A '(FOO BAR BAZ (FROB NICK ATE)))

GETL 'A '(BAZ FOO BAR))            ==> (FOO BAR BAZ (FROB NICK ATE)ÿ
 'A '(BAZ))                    ==> (BAZ (FROB NICK ATE))
))               ==> NIL
.
0 Æ 3.0))            ==> NIL
: GETPARM
ed) - any LISP object, but generally T or NIL.
any LISP object, but generally T or NIL.
hose print name is taken from the parameter
unning ZIL program.
 background via JCL like the following:
,PARM='parm string'


 processorÿ
t invoke user programs, such as TEST,
mat.)

ing is passed to the program, or a null parm string
ns a symbol with a null print name.
 TSO command processor, GETPARM
irst non-delimiter character
d asis (not folded to
use unconditional
m.
†
e above paragraph, then GETPARM skips over all characters between
kslash and the next backslash, inclusive, returning the
m field starting from the character following the
 is no second backslash, a null string is
etweeÿ
tion specifications.
om is interned on the
ult behavior),
If the second argument is non-NIL, the atom building routine will
 convert the atom to a numeric type, according to its syntax
ction would interpret it.  If the sÿ
ys treated as a symbol (this is the default
d argument is specified, handling is
v.).
failure to build the result.
ring are used by each ZIL program in
ompiler, OPS5 and Macsyma all
	
that was specified (the "null symbol", ××, is returned when no INIT
in use).
own):
                  ==> ××
THERE.)'
bol.
TPARM NIL))  ÿ
 FOO ; interned.
           ==> T
 (GETPARM NIL NIL)          ÿ
M NIL T)              ==> 7 ; note - fixnum, not symbol.
invoked via XCMD (i.e. as a command processor) with
ne:
ar×
ollowing input line:
            ==> ×FOO BAR×

  ==> ×FOO BAR×
            ==> ××

ZILIN  \VSSIZE=1024K\foo bar

××

 
M)       ==> ×This doesÿ
\   This is a way to preserve leading blanks.
his is a way to preserve leading blanks.×
 Leading delimiters and comments are l ost.
ng delimiters and comments are lost.×
verything is retained.
is retained.×

ol or integer.
ntrol transfers to the form
 in the current PROG.
G.
o arg1 in the current PROG being evaluated.
 that form and subsequent forms.
;
ol to a tag in a PROG which is not the
the interpreter, this even works
produce some bizarre
a tag in a
rol

ECT to outside that form, the UNWIND-PROTECT cleanup forms
re control is passed to theÿ

outside of a PROG
y are lexically apparent in
sed as long as they
ng are
SOMETHING) (GO LOOP) (RETURN T))

NOT valid:
) (RETURN T))) (SUMFUNK))
led.
OOP (COND ((NULL A) (GO EXIT)))
     (SETQ A (CDR A))
                     ==> (5 4 3 2)
unction: GREATERP
est args)
arg2 (required, evaluated) - a number, string or symbol.
valuated) - a number, string or symbol.
nd strings:
r than its

receding arg,
kes exactly two args, the following holds:
gardless of type,ÿ

the types differ, the appropriate conversion is performed (see
H for conversion rules) and the ÿ
uments are strings or symbols, a character comparison is
tring text of the atoms, where the string text of
e.  Case is significant.
esult is T if there is only
creasing (adjacent
 NIL.
is a string or symbol and another is a number.
	
GREATERP 'AAA 'A)     ==> T
o" "bar") ==> T
T
 (> 9)                  ==> T
          ==! > T
> NIL
x:   (HAIPART arg1 arg2)
rg2 (required, evaluated) - a fixnum.
negative, an integer whose contents aÿ
rg1).  If arg2 is negative, a fixnum whose contents
rder bits of (ABS arg1).
han the number of significant bits in arg1
1) is returned.

IPART  7 2)       ==> 3
  ==> 9

arg1)

e of arg1.
wise the total number of bits in
us the number of leading
:
 Maclisp function.  Compare INTEGER-LENGTH (or ZILINTLN),
tion.  Note that INTEGER-LENGTH is different for

 -1)   ==> 1
  ==> 3
ONG #b0110110110)     ==> 9
 2147483648)       ==> 32
47483648)      ==> 32
2 60) -1)) ==> 60

a symbol.
IL.
ntation member of the
f arg1 is omitted or NIL, general help information is displayed.
1 is ZIL, member $@INTRO is displayed.
is displayed.
r of the
 is displayed.

r NIL,
rs signaled:

the global variable *ZIL-HELP-LIBRARY*, whose default value is:
IL.TEXT" for the production system;
m;
 although containing a fully qualified name,
.)
ing them via the HELP function.
ys the introduction to ZIL.
 line mode.
de.
rg1 arg2 ... argn)
 format must be one of the following:
m1 THEN form2 ENDIF)
orm2 ELSE form3 ENDIF)
orm1 THEN form2 ELSEIF form3 THEN ...
nt to (IF form1 THEN form2)
m1 THEN form2 ELSE form3)

llow as well, e.g.
 
Returns: 
cessing:
ÿ
st, as you might imagine, is non-NIL vs. NIL.
re non-NIL, NIL is returned.
THEN and that pÿ
e.
the value of the condition form following the IF is returned.
 no forms following an ELSE anÿ
s is a "feature" that will be removed eventually).

s into the corresponding COND:
B))
ELSE D E) --> (COND (A B C) (T D E))
(T B))
ug")
amples:
AR
IF T THEN 'FOO)       ==> FOO
 THEN 'TRU1 ELSE IF (= 3 3) THEN 'TRU2 ELSE 'TRU3 ENDIF)
    ==> TRU2

IFILEP file1)
s: 
 
Õ
t is made to open the file name consisting of 'ZILI' + the file
 all ZIL file accessing functions.  If such a fÿ
otherwise NIL is returned.  If any error occurs trying
the error is signalled; in other words, IFILEP
st" errors only.


 is closed under ZIL, issuing IFILEP against a closed
e the file to be reopened.
s return T.
to a
on)"))     s hould return T.
n: IMPLODE
- a proper list of atoms.
int name consists of the characters in the
nated to form a new atom name.
hich must be a non-null list of fixnums, strings
ed as follows:
ined.
 first character of its print name is obtained.
to build an interned symbol whose print name is
e concatenaÿ
print name is
 atoms (nested lists and vectors are not permitted).
fixnum, string or symbol wÿ
AM, which is identical but doesn't intern its symbol.
MPLODE is now called ZILIMPL; the IMPLODE described
Maclisp definition.
=> ××
==> FOO
   ==> ×abc×
                ==> T
 
 form acceptable to SETF which evaluates to a

e1, after it has been incremented by increment2.
ace1 is typically a variable, but in general is any form acceptable
irst argument to SETF.
remented by adding
 specified.
nt will fail if bad args are used.
ecrÿ
  (INCF a b)  --> (SETF a (+ a b))

       ==> 5

 dsn1  (required, not evaluated) - a data set name (string or symbol).
eturns: 
 dsn1.
lude LISP source code from
 a PROGN containing
lue.
led:
can be used under the compiler to incorporate source code
tions) only in locations that are subject ÿ
terpreter, INCLUDE functions
hich is identical to INCLUDE except that it
 The function XINCLUDE, which underlies INCLUDE and INCLUR DEF,
 actual expansion (i.e. it returns a PROGN list made
e file).  Direct use of XINCLUDE, while
rtain situations.
 
 name (string or symbol).
e forms in the dataset specified by dsn1.
F is a macro which allows you to include LISP source code from
set into other code; it expands into a PROGN containing
he data set, with NIL as the last value.
 the operation.
AD.
te source code

 to LOAD.
t
rlies INCLUDE S and INCLUDEF,
 a PROGN list made
while
ÿç
string1 string2 &optional index3)
onal index3)
uired, evaluateÿ
ixnum.
search beginning at
ng1 if

ched from either the beginning (if index3 is omitted,
 the offset specified by index3; when the firÿ
equal (in a case-sensitive character
one-based offset of that
oes not match any
g2 is null, a fixnum 0 is returned.  Other than that case,
urned when string1 is null.
ing of the entire string1,
 most string-handling functions, symbols are acceptable for
rst 2 arguments.
 string).
 (not a poÿ
o the PL/1 INDEX function; the optional
 PL/1, corresponds to a SHARE
PL/1 INDEX.
a SUBSTR
useful in parsing a string into a sequence of tokens.
 (INDEX "" "non-null-string")   ==> NIL
 0     ; Special case.
se.
==> 2
    ==> NIL
")      ==> 1
 examples show that (INDEX x y z) is NOT the same as
y).
 "blah blah blah" 5) "blah") ==> 2
     ; Search "foobar".
oobaru " only.
ly.

RP arg1)

cessing:
num is an integer in the range -2147483648 thru 2147483647.
 of this range are bignums, of which BIGP is true.
 be used to test if an object is a fixnÿ
ERP has a different definition in MAcsyma.  Use FIXP to get
nality under Macsyma.

TEGERP 'ONE)         ==> NIL
 2 31))    ==> T
 
ated) - a string.
d.
	
ame is string1.  The
ignaled:
           ).
      ==> A
)")            ==> ×(F O O)×
 (SETQ A (INTERN "FOO"))       ==> FOO

==> T
Syntax:   (INTERSECTION arg1 arg2)
g1 (required, evaluated) - a proper list.
per list.
occur in both arguments.
from the elements of the two arguments;
st argument, it will occur
n with respect
nt

 signaled:
validity of the arguments.
 second arguments
 NM IL '(A B C))              ==> NIL
=> NIL
0 3.0) '(2.0 3.0 4.0))  ==> (2.0 3.0)

le2 string3)
1 (optional, evaluated) - an input file name.
- an output file name, or the atom NOPRINT.
a string.
PRINT loop over file1
If sÿ
sion is read from file1; it is evaluated and the result is
(unless the value of file2 is NOPRINT, in which case
done).  This procesÿ
 the form (END) is read.
es are available to
ue printed by the READ-EVAL-PRINT ÿ
of *.
orm read by the READ-EVAL-PRINT loop.
.
 READ-EVAL-PRINT loop is currently
self, the value will be -.
ut file is used.
 is used.

ject.

   enabled).
a PRINC, which means that
want a promptiÿ
ust specify
.
ebcdic #\CR))
the : is actually a hex 0D.
ps (ebcdic #\NL)))
he value of PS.
of-file condition
ded the only
 form (END), when typed as is, is a termination signal to
  Since it is not actually a function, it cannot be
function or generated by a macro, and it can
-EVAL-PRINT is used in the interpretive environment to "load" a
 dataset (or PDS member) of interpretive function
whatever you wish.  It is generally assumed
been read yet; if it has,
nt input record and
ame filÿ
 second
et is loaded

lent and execute a READ-EVAL-PRINT
d input to standard output


s and evaluates, without printing, all
s on input file FOO.
put file BAR,
 OUT.
mpt
IL NIL #.(string-append "ZIL" (ebcdic #x0D)))
s a READ-EVAL-PRINT loop with a prompt of
ge return.
Syntax:   (INTRQ arg1 arg2)
ed, evaluated) - a proper list.
	
oth arguments.
lements of the two arguments;
t, it will occur
pect
l occur if it occurs more than once in one of the input lists.
 used is EQ.  Compare INTERSECTION, which uses the EQL test.
gnaled:
idity of the arguments.
cond arguments
(A B C)) P                   ==> NIL
==> NIL
0 3.0) '(2.0 3.0 4.0))  ==> NIL   ; Test is EQ.

Õ
                       characters in length.

.
m named by arg1

siding in
t and not NIL, it must be a string which is
 to be passed to the program.ÿ
string is used.
PPER CASE,
eturn code (register 15) when the program reÿ
d a fixnum containing the value to be returned
 This should be 0 if the command completed
gram abnormally terminates (ABENDs), a message is displayedÿ
 and INVOKE returns NIL as the value.
batch environments as well as
mands with this function, or programs that
 IEBCOPY).  (You must use the TSO
ssary, if you require
 is dependent upon the amount of system
e programÿ
orage, the program

t be a symbol, for then ÿ
llaneous system failures.
ames as compiled ZIL functions or other
tem will attempt to execute the ZIL
sults will occur.
ary, the link
rary

above, results are definitely not predictable.
E 'IEFBR14) ==> 0
y and
  will return the return code from IEBGENER.
4")
 (ISPFP)
he current environment,
r to the one performed by ISPLINK iÿ
environment, suitable for invoking dialog services.
ed; otherwise NIL is returned.
 than, for example, the
 NIL in certain
otably
 under ISPF.
SPF Version 2 must be installed to use this function.
 that ISPFP will falsely return T when ISPF dialog
e because of a subtasking environment that
ø  top of the task tree.  However,
on 2 Release 3 ISPQRY

KEYWORDP arg1)
turns: 

kage, and is printed with a leading colon.
s, so a symbol is considered to be a
rint name is a colon.
†
ng environment, nor can it be SETQ'd.

imal kind

P 123)     ==> NIL
T

)
 
t name of
f arg1 is already a "keyword", itself is returned.  Otherwise,
ncatenated with the print name of arg1 and a new
t name.
:

ith a colon is treated as a "keyword" in ZIÿ
emselves and cannot be used as lambda list arguments.
 (KEYWORDIFY 'A)          ==> :A
DIFY NIL)         ==> :NIL
DIFY "foo")       ==> ("***ERROR***")

function, such as can be created by a DEFUN.
ur where a function name is normally
NS X NIL)) 'FOO)
 (LAMBDA (X) (BAZ X X)))
AZ X X)).
ctioÿ

if the name of an EXPR had been specified in its place),
ts are evaluated anÿ
e bindings set accordingly.

id argument list, and arg2
e body of the function.
erally symbols which
 executed.  The
 evaluated

 following

owing are optional
 called.

 passed to the function than are
ONAL if any, an
ol following (ÿ
nd to the list of arguments
een set up.  If


 E))
ls an error (too few arguments).
o few arguments).
)         ==> (1 2 3 NIL NIL)
OO 1 2 3 4 5)     ==> (1 2 3 4 (5))
))
ils on compiling functions with &OPTIONAL or
 &BODY is synonymous with REST.
lowing are not arguments,
liary variables

s are
 also gÿ
keywords" and values.  In ZIL, a "keyword"
gins with a colon (this is to
", which are
s
ot necessary to quote them.
 &OPTIONAL, &AUX and
ence.

on: LAND
- a fixnum.

rg1 and arg2.

 LOGAND performs the logical AND function on any number of arguments.
Examples:
 4
LAST arg1)
 

h
hen that sublist is returned.
turned value is that
f one element.
rors signaled:
L)                  ==> NIL
'(A B . C))           ==> (B . C)
AST '((A B) (C D)))       ==> ((C D))

luated) - a proper list.
of the list specified by arg1.
atomic, itself is returned.
e list is returned.
CAR is not
 (LAÿ
.
Æ
> A
 D))           ==> D


a list.
t of arg1 that isÿ
 arg1.
ments of arg1 are collected by cdr'ing down arg1 until it
 (i.e. arg2 is found to be a subÿ
g1 is reached, and these elements are
g2 is not a sublist of arg1, then a copy of arg1 is created.
aled:
TQ X '(A B C D E F . G) Y (CDDDR X))
    ==> NIL
FF X Y)              ==> (A B C)
 . G)   ; EQUAL but not EQ
)            ==> (A B C D E F . G)
FF X (CDDR X))       ==> (A B)
	
ENGTH arg1)
: 
 specified by arg1.
counted and an integer is returned
n does not count all
 dotted pair, a list ending in a dotted pair, ÿ
 invalid and will cause an error to be signalled.

±

              ==> 1
)         ==> 2

  (< arg1 &rest args)
symbol.
ptionÿ
or symbols and strings:
cally less than its
se NIL.
 its preceding arg,
 takes exactly two args, the following holds:
 regardless of type, the result is

If the types differ, the appropriate conversion is performed (see
RITH for conversion rules) and the numeric compareÿ
arguments are strings or symbols, a character comparison is
e string text of the atoms, where the string text of
name.  Case is significant.
e result is T if there is only
 decreasing (adjacent
 NIL.
ÿ
	
SSP 'AAA 'A)        ==> NIL
az")    ==> T
T
< 1)                  ==> T
        ==> T
> T

 arg1 arg2 ... argn)
dings) is required;
number of
lly evaluated) - a list of local variable bindings, i.e.
ts each, where the first element is a symbol
is thÿ
 (conditionally evaluated) - any LISP object.
t of the arguments.

1
 "varn"'s must be variable names (symbols or destructuring
e not evaluated, the "valuen"'s areÿ
n the corresponding variables are bound, and the
cts and are evaluated in sequence in the
ariable/value pairs.
s (binding
a
ariable is initially bound to the value specified as the CDR
nt) of the binding specification, and becomes unbound
inates.
 LET, and are processed in succession, a la PROGN.  The value
ÿ
as LET, except that LET binds its variables
arallel binding.
vironment preseÿ
 environment present immediately before
h binding can refer to previous
Errors signaled:
	
whose expansion
OF-A)
(FORM 3))       -->   ((LAMBDA (A B)
RM 1)
               (FORM 3))
                        (SOME FUNC))
ed LET's (lambda-expressions).
refer to the appropriate
rce the variable binding strategies.
'(1 2 3 4))
  )
                       ==>  6
ETQ B "bò ")          ==> "b"
=>  (("a") "a")

:   (LIST &rest args)
uments may be specified.
urns: 
IST*:  a list (arg1 arg2 ... argm . argn), ending in a dotted
ir of the last 2 args.
 succession to build the list out of
ns a proper list; (LIST) returns NIL.
dotted pair; (LIST* a) returns a,
gnaled:

terpretive
new
creates an in-line constant list in the load module whose address is
  If the list may be modified during execution of the program,
the LIST form rather than the QUOTE form.
            ÿ
      ==> (A)
> ((A B) C)
==> (1 2 3 4 5 6 7)
         ==> A
 ==> ((A B) . C)
B C))
ú
rg1)
	
ctive LEÿ
arguments
ger, a list of the last arg1 arguments

e list of
ssued outside a LEXPR.
ecking is done in compiled code.  Resuÿ
argument is passed.

)
pecial y))
nil nil)         ==> NIL
     ==> (A B)
 (A)


  ': (a b c d))  ==> (B C D)
  '(a b c d))  ==> (A B C D)
: LISTP
 LISP object.
 
ate.

STP '(NIL))          ==> T
B C))        ==> T
½
arg1 (required, evaluated) - any LISP object.
g1 is a "lambda list keyword", otherwise NIL.
mbda lÿ
s an ampersand.  Lambda list keywords are exactly like
 that when they occur in lambda lists they
 represent variables.ÿ

e fact that a given symbol is LLKEYWDP does not necessarily mean
valid in a lambda list; an error is ÿ
& appears in a lambda list that is not
, &REST, &AUX, etc.).

 '&FOO)      ==> T
 NIL

uated) - a "lambda list" (an atom or list which
 is valid in the argument list position
LAMBDA expression).
(symbols) specified in bvl1.
t name variables (formal parameters) in the
e retÿ
 &AUX
 "supplied-p" arguments.
ually a destructurinÿ
arameters to
Errors signaled:
is function is used by ZIL when it ÿ
en parsing SPECIAL declarations in macros).
IL)          ==> NIL
 ==> (C B A)

EY K1 (K2 K3) ((:K4 K5) K6 K7)))   ==> (K5 K7 K2 K1)
(B1 . B2)) &REST (Z1 Z2 Z3)))
ú
ey verbose print if-does-not-exist)
bol.
ly T or NIL).
 generally T or NIL).
y LISP object (but generally T or NIL).
d :if-does-not-exist is given a valueÿ
y dsn1 does not exist, NIL.  Otherwise T, after
loop over the data set specified by dsn1.
ch should be a string, is interpreted as a data set ÿ
ormat (quoted or unquoted, member name present or
ll upper case is done automatically.
and opened for input.
s evaluated and the
nt is given
 is reached on the data set or the form (END) is read.
veÿ
he load operation identifying the data set
 given a value of NIL, the message
s determined by tÿ
initially T.
, which is
1
NIL, then LOAD will not error out if the data set can't be found.
t will just return NIL.
N and READ-EVAL-PRINT.
T are trapped.
rmination signal to LOAD.
embedded within
no operands.
equential
os,

isp(myfunc)")
RCE($CL)'" :PRINT T :VERBOSE NIL)
ro: LOCALLY
 
 provdes a way of associating declarations with one or more
having to provide a binding construct like LET or
gnaled:
                               ==> FOO
Á          ==> FOO

a number.
 A number which is the logarithm of num1, to the bÿ
ecified, otherwise to the base E.
utine library interface is used to compute the value.
ecision flonum and base2 is omitted, or num1 and
cision flonums, or one is an integer and the
num, the result is a single-precision
le-precision flonum.
ÿ
FORTRAN subroutine library interface
f this documentation for

  ==> 0.0
*")
1859880914
G 8 2.0F0)     ==> 2.999999F0
  ==> 2.999999F0
2.9999993203129022
99999991756494
	
tional, evaluated) - a fixnum.
e result of a logical AND operation performed on

s -1, which is an identity for this operation.
 arg not a fixnum.
    ==> -1
27
ú
rg1 arg2)
 (required, evaluated) - an integer.
ing on whether the argÿ
zero) is a 1 in arg2.
tion.
hat is on in the integer (expt 2 arg1ÿ
is on, then T is returned, else NIL is returned.
 two's-complement representation of arg2 is
g.
 not a integer.
   ==> T
IL
 (LOGBITP 2 1)            ==> NIL
0))    ==> 0
FUN FOO (X)
ONÿ
           ==> (T NIL T NIL NIL T)
 T)
IL
 
d, evaluated) - an integer.
an integer containing the number of 1-bits in
an integer containing the number of 0-bits
ation of arg1.

returnedÿ
counted, rather than the
n of arg2 is used to
ins 1-bits

             ==> 0
       ==> 1
   ==> 4
 31

LOGCOUNT (1+ (** 2 99)))  ==> 2
ke X'FFFFFFFF'
GCOUNT -2147483647)     ==> 30  ; like X'80000001'
    ==> 31  ; like X'80000000'
..FFFFFFFE FFFFFFFF'
 -2 99))) ==> 1
°
 argn (optional, evaluated) - a fixnum.
aining the result of a logical OR operation performed on
ion.
) returns 0, which is an identity for this operation.

) ==> 0
128 64) ==> 448
ÏÏ
quired, evaluated) - an integer
 the result of a complement operation performed on
tsÿ
nly operation.  If arg1 is negative, the
-complement representation.
²
les:
> #z0ff00ff0
	
LOGTEST arg1 arg2)
equired, evaluated) - an integer.
 on whether any of the 1-bits cÿ

quivalent to (NOT (ZEROP (LOGAND a b))).
not an integer.
Under Mask instruction.
NIL
(LOGTEST #b1111 #b10000) ==> NIL
ST #xf00f00f00f00f00f00f00f00
L
f)    ==> T
Syntax:   (LOGXOR &rest args)

ive or)

dentity for this operation.
	
) ==> 2730




Maclisp and NIL, but it has not become standardized in Common LISP
Some examples follow below.
eywords:
ywords
Y
RN
e INTO subkeyword)
subkeyword)
g built)
is synonymous with FOR.
where appropriate.
rations (... FOR X FIXNUM ...) are accepted but ignored.
:

llowing:
ual (Burke, Carrette, Eliot)
ures described therein,
resent.
ity
al sÿ
 B C) COLLECT (CONS X X))
 C))
            ==> (10ÿ
 IN '(A B C D E F G)
LY (RETURN (NREVERSE Z)))

    UNTIL (EQ (CAR X) 'E))
OP FOR X IN (OBLIST) ALWAYS (ATOM X)) ==> T
1 NEVER (> I 10)) ==> T

m.
m containing the result of a logical inclusive OR operaÿ
rg1 and arg2.

 LOGOR performs the logical OR function on any number of arguments.
amples:
1
H arg1 arg2)
 evaluated) - a fixnum.
t of a logical shift operation peÿ
 number of bits to shift (left if
essing:
of arg1
the
 with N being
ative, a right shift of N bits takes place, with N being
e of the fixnum arg2.
s returned.
s that
L or

 a fixnum.
 ASH and LSH ÿ
ASH propagates the

(LSH 10 2)      ==> 40
          ;  i.e. FFFFFFFF goes to FFFFFFFE
  ;  i.e. FFFFFFFF goes to 7FFFFFFF
unction: LXOR
ted) - a fixnum.

performed on arg1 and arg2.
peration.
otes:
tsk .
           ==> -5
	ñ	ñ
equired, evaluated) - a proper list of atoms.
terned symbol whose print name consists of the characters in the
iedÿ

r symbols, are converted as follows:
r equivalent is obÿ
Õ
hese are concatenated to build an uninterned symbol whose print name
string resulting from the concateÿ
se a symbol with a null print name is
 
 An object other than a fixnum, string or symbolÿ
s:
	
)                 ==> A
'(FOO BAR))           ==> FB

L
(MAKNUM arg1)
urns: 

erpreted as a

 use this.

uired, evaluated) - a symbol.
e current binding thereof (whether dynamicÿ


ng (as assigned by DEFVAR, for example).
undone.  Global bindings are always
DEFVAR binding, if one exists,
is context is NOT that the binding is removed;
 valueless.  This means that while the
ymbol will have no value.  If
hen when the current
effect ÿ
s:
BOUNDP, DEFVAR, SETQ and SYMEVAL for more information.


 

                           ==> ("***ERROR***") ; Unbound variable - A
et ((a 1) (b 2))
> T
nd 'a)
   (declare (special a))

          (push (if (boundp 'a) a nil) b)
) a nil) b)
    (nreverse b)

g1 arg2 ... argn)
 (required, evaluated) - a symbol or LAMBDA-expression.
uated) - a proper list.ÿ

ument

e function specified by the first argument is applied to each of the
s (CAR's) of the lists specified by the other arguments, until
sts is exhausted or a value of NIL is produced by thiÿ
the latter occurs, MAPAND returns NIL.
IL values when the function is applied,
 value produced by applying the
	

ast 1 list required).
ionÿ

 '(A B C D E F))    ==> T
AND #'EQ '(A B C) ÿ
NIL
EQ X 'FOO)) '(FOO FOO FOO))  ==> T
(FOO BAR BAZ))  ==> NIL

ÿç
	
turns: 
.
 be, except that
ignalled by fun1 or FUNCALL
unction like MAPATOMS that corÿ
 there should be one.
 #'(lambda (x)
       ((foo bar baz)
                         (t nil))))
§Ò
 At least 2 arguments must be specified.
 symbol or LAMBDA-expression.

 after applying the function specified by arg1 to the last
ists specified by the other arguments.
 specified by arÿ
 specified by the other arguments.  The first or
 as the value of the MAPC call.
ists is exhausted
used for its side effects and not for
rrors signaled:
st required).
r more information on what
les:
(cons x x) a)) '(1 2 3 4 5))
 . 5) (4 . 4) (3 . 3) (2 . 2) (1 . 1)))
'(lambda (x y) (push (+ x y) a)) '(1 2 3) '(10 20 30))
   ==> (33 22 11)
	
e.
 (MAPCAN arg1 arg2 ... argn)

ional, evaluated) - a proper list.ÿ
ist.
lts of the applications
he elements of the
ing:

is assumed that a list (which may be NIL) is returned by each
  The results are destructively attached via NCONC to
he values as they are generated, and returned
l.

nction and at least 1 list required).
 this documentation for more information on what
unction.
he
her than NIL or a proper list.
 the function calls, be
 (LAMBDA (X) X) -
 usage
PCAN #'(LAMBDA (X) (APPEND X NIL)) '((A B C)ú  (D E) (F) NIL (G H)))
                 ==>  (A B C D E F G H)
 x y) nil (list x y)))
)
 
least 2 arguments must be specified.
bol or LAMBDA-expression.
argn (optional, evaluated) - a proper list.
of values generated by the application of the function
t argument to the elements of the lists specified

lied to each of
uments.


f the lists is exhausted

Notes:
what
#'CAR '((A B) (C D) (E F)))  ==> (A C E)
X)) '(A B C D E))
  . D) (E . E))
E) (C . F))
PCAR #'(LAMBDA (A B C) (LIST A B C))
=> ((1 4 7) (2 5 8) (3 6 9))
: MAPCON
ents must be specified.
-expression.
l, evaluated) - a proper list.
ated by NCONC'ing the results of the applications
by the first argument to the sublists of the
arguments.
ment is applied to each of
e other arguments,
st non-NILÿ
ned by

 the value of the MAPCON ÿ
lists is exhausted
 NIL is returned as the value.
of arguments (function and at least 1 liÿ
See member $MAP of this documentation for more information on what
ded on a mapping function.
disastrous) if the
s an atom
to the results of the function calls, be
such as CDR or (LAMBDA (X) X)
 thereof; such usage
terminate.
B C D E))

      '(f o o b a r) '(r g o b a r))
ç
rgn)
valuated) - a symbol or LAMBDA-expression.
oper list.

null sublist of the shortest of the lists specified by the other
	
 of the sublists
ting with
e

NIL).
À
ber of arguments (function and at least 1 list required).

coded on a mapping function.
  (list
   a))
     (mapl #'(lambda (x y) (push (+ (car x) (car y)) a))
) '(10 201  30))
#'PRINT '(A B C D E))


T arg1 arg2 ... argn)
arg1 (required, evaluated) - a symbol or LAMBDA-expression.
evaluated) - a proper lisÿ

function
ied
ified by the first argument is applied to each of
e lists specified by the other arguments,
 and ending with the last non-NIL
s as they are generated, and

NIL).

 1 list required).
 for more information on what
ampleÿ
†
                   ==>  (T NIL NIL T NIL)
D E F)) ==>((A B C DÄ  E F) (B C E F) (C F))
	
 least 2 arguments must be specified.
mbol or LAMBDA-expression.
 argn (optional, evaluated) - a proper list.
t non-NIL of the values produced by applying the first argument
successive elements (CAR's) of the other argument lists;
e is generaÿ
st argument is applied to each of the
d by the other arguments, until
alue is produced by this
t generated value.
function is
MAPOR returns NIL, by definition.
mber of arguments (function and at least 1 list required).

 coded on a mapping function.
             ==> NIL
OM '(A B C D (E F)))   ==> T
MAPOR #'EQ '(A B C) '(A B C))    ==> T
=> T
 X) '(FOO BAR BAZ))   ==> FOO
 ==> BAR
§
½
tring or symbol.
, according to the ÿ
ATERP for how comparisons are done.  All the arguments to
patible types (i.e. no mixing alpha and numeric).

 (q.v.).

1 2 3)             ==> 3
 'B 'A 'R) ==> R

code object (SUBR or closure).
e maximum number of arguments that can be
 code object.
ader information, extracts the
ilds a fixnum containing
code objects are:
t function
 function-name)   - which loads the function from disk.
RGS.
osure.
 but is now useless.
nd it useful.ÿ

RINT.
(MAXARGS (ZILLOAD 'GC))     è    ==> 0
  ; after PRINT has been used.

rg2)
(required, evaluated) - a number, string or symbol.
he arg which has the grÿ

ents to


s to
unction: MEMBER

 evaluated) - a proper list.
function of two arguments.
tion of two arguments.
 of one argument.
osÿ

ied by list2 is searched for an element that is equal
found, a pointer ÿ
rned as the value.
n, e.g. in an

a match occurs when an element of
Æ
cifies a predicate function of two
 when comparing item1 to each
 the function returns a
rs.  The first
second

                      is specified).
es a predicate function of two
comparing item1 to each
unction returns
ument is

                         :key function applied if :key is specified).
key (no default)      - speÿ
                      that is applied to each element of list2
            before comparing it to item1 via the :test or
       :test-not function.  Note that the ÿ
nction is applied only to the element of
 to item1.
	
ot keywords specified.

R is, by default, implemented with an EQL test for Common LISP
ty.  If Maclisp or Franz LISP compatibility is desired,
ted with ZIL function MEMQUAL via the DEFLOAD special
MQUAL for more info.

BER 'ÿ
C D E F G))             ==> (D E F G)
   ==> (G)
 'A '(A B C) :TEST #ÿ
EQL)         ==> (B C)
(MEMBER 'D '(A B C) :TEST #'EQL)         ==> NIL
EST-NOT #'EQL)     ==> (B C)
(A B C)
'(A B C) :TEST-NOT #'EQL)     ==> (A B C)
 searched, unless :KEY is specified.
             ==> NIL
 (E F))
 4 5 6 7))                   ==> (3 4 5 6 7)
)                ==> NIL
(1 2) (3 4))

ect, but generally a symbol.

rg1;
ecified by list2 is searched for an element that is EQ to
found, a pointer to the sublist of list2 of which
ned as the value.
e.g. in an
(MEMQ B (MEMQ A L)) is non-NIL.
list.
 proper list.
.

Q 'A '(A B C D E F G))               ==> (A B C D E F G)
E F G))               ==> (D E F G)
 ==> (G)
ts are NOT recursively searched.
      ==> NIL
3.0 4.0 5.0 6.0 7.0))   ==> NIL
ction: MEMQL
uated) - any LISP object.

1;
ified by list2 is searched for an element that is EQL to
ound, a pointer to the sublist of list2 of which
ÿ
e.g. in an
(MEMQL B (MEMQL A L)) is non-NIL.

nd MEMQUAL, which is like MEMQL but uses an EQUAL test.

G))              ==> (A B C D ÿ
    ==> (D E F G)
L 'H '(A B C D E F G))              ==> NIL
ly searched.

7))               ==> (3 4 5 6 7)
=> NIL
ax:   (MEMQUAL arg1 list2)
t.
he first sublist (CDR) of list2 whose ÿ
 sublist exists.
rched for an element that is EQUAL to
the sublist of list2 of which

dering test.  In a list L, element A precedes element B if
AL A L)) is non-NIL.

hich is like MEMQL but uses an EQL test.
NIL)                         ==> NIL
  =ÿ
G)
D E F G))            ==> NIL

on test is EQUAL, not EQ or EQL.
   ==> (3 4 5 6 7)
)
x:   (MACROEXPAND arg1)
luated) - an atom or proper list.
ents the expansion of the macro cÿ

 it is assumed
h the
<
returned unchanged.
r the returned
are
 Also compare FEXPAND, which does a code-walking full macroexpansion
argument.
ist valid
ng
Unpredictable results will occur if the first argument is not an atom
roper list.
M1
1 A)))           ==> (M2 (M1 A))
(M3 (M1 A))

ACROEXPAND-1 arg1)
ed) - an atom or proper list.
 the expansion of the maÿ
Processing:
is assumed
e
MACRO property is used to expand the macro call.  Otherwise the list is
rned unchanged.
OEXPAND (aka
 not a
full macroexpansion
y is assumed to be a LAMBDA list valid
ot, it is APPLY'ed with a warning
 None.
ument is not an atom
M1 (ÿ
	
   '(M1 (M1 A)))           ==> (M3 (M1 A))
      ==> (M3 (M3 A
 ))

 (optional, evaluated) - a number, string or symbol.
The arg which has the smallest value, according to the ÿ
	
 arguments to
ric).
ed).

N 2 1)               ==> 1
" "G"  )   ==> "F"

 (required, evaluated) - a compiled code object (SUBR or closure).
ns: 

INARGS looks at the compiled code header information, extracts the
umber of arguments therefrom, and builds a fixnum containing

-name 'SUBR) - which gets the current function
it has been loaded.
 from disk.
ent not a compiled code object or closure.
 was formerly used by the evaluator, but is now useless.
d because someone somewhere might find it useful.ÿ
function uses this internally.
         ==> NIL ; to load CAR and PRINT.
 1   ; after CAR has been used.
MINARGS (GET 'PRINT 'SUBR))   ==> 1   ; after PRINT has been used.
(ZILLOAD 'READCH))    ==> 0
 MINUS
mber.
ltiplied by -1).
onding negative number of the same
onding positive number of
:
NUS 0)              ==> 0
        ==> 0.0F0
=> 3

NUS 2147483648)     ==> -2147483648

00000000
yntax:   (MINUSP arg1)
eturns: 
essing:

 if an invalid argument is passed.
 ==> NIL
SP 0.0)       ==> NIL
NIL
001F0) ==> T
yntax:   (MIN2 arg1 arg2)
 or symbol.

s
 are done.  The arguments to
g alpha and numeric).
ATERP (q.v.).
sed to implement calls to
ú
 arg2 arg3)
1 (required, evaluated) - a string.
ject, buÿ
, but generally T or NIL.
n-NIL, and string1 is syntactically
ted, looks like string1ÿ
tring1.
to build a new symbol
nly if arg2
n-NIL, then an attempt is made to build a
gnum), according to the syntax of
et it.  If the string is not
ed as for the case above,
.

argument is

.

e treated as part of a symbol name.
detected by the code, and may
oating-point underÿ
²
                    ).
gument and is a convenient way
nt of T.  MAKE-NUMBER

")        ==> ×hi there×
ts are never built.
d.
           ==> NIL
07" NIL NIL)     ==> ×007× ; an uninterned symbol.
  ==> 7     ; a fixnum.
ymbol.

    or:   (MAKE-BIGNUM list1)
st of at least 2 fixnums.
ixnums in lÿ
ndent upon the internal implementation
ormation.
st 2 fixnums.
position
have had the value -2147483648 (most negative fixnum)
ild bignum.
list.
 (MKBIGNUM '(1 2 3))          ==> 13835058059577131009
47 1))  ==> -2147483649
IXNUM
 flo1 (required, evaluated) - a flonum.
single-float, a fixnum created therefrom.
ted pair (CONS) of 2 fixnums created
 The value of flo1 is NOT converted; rather, the bitwise contents of
num value are inserted into the newly created fixnum(s).
ed:
the fixnum(s) back into a flonum.
rmalized form in ZIL.
0

 (#zC1180000 . #z00000000)


x2)
uated) - a fixnum.
	
specified, a double-float created from fix1 and fix2.

ts of the fixnum vaÿ
fix2 is omitted, the value of fix1 is inserted into the
-float.  Otherwise, the values of fix1 and fix2
oubleword which is inserted into tÿ
cases, the leftmost 8 bits
rm the mantissa
alized by adding a normalized floating-point zeroÿ
y to insure, among other things, the bitwise
ues.  Therefore, the resulting flonum
ation as the input fixnum;
 fix2, if applicable)
	
 MKFIXNUM will turn the flonum back into fixnum(s).  Note, however,

e value (see above).
 1.0F0
        ==> -1ÿ
UM #z40000000)        ==> 0.0F0
 ; note: normalized!
FIXNUM 1.0D0)             ==>ÿ
99 #z99999999) ==> 0.6D0
999999)
        ==> (#z00000000 . #z00000000) ;norma lized!


quired, evaluated) - an evaluation environment.
terpÿ
ose environment component is arg2.
	
valuator to process)  the FUNCTION special form.
 this function.

onal arg2)
valuated) - any LISP object.
, where n is the value of arg1, and all of
ocessing:
arg1,     urned
ed to arg2,
 case the list has no elements.
t not a fixnum, or negative.
equivalent and both acceptable names.
     ==> NIL
NIL NIL NIL NIL)
 
MKNEWENV &optional arg1)
g environment (alist).
hich contains the variable binÿ
, and default (null) entries

ins the

iable binding environment is a LEXICAL one, not the
le binding environment.


ent; however, the FUNENV function will return the
 an interpreted lexical closure if you're
uation environment looks like in ZIL.

g1)
a string.
ric atom which, ÿ
symbol whose print
 attempt is made to build a numeric atom (fixnum, flonum or bignum),
ng to the syntax of string1 as ÿ
he string is not syntactically numeric, then an uninterned
 whose print name is string1.
heses, dots, etc.) is not valid and will
l name.
y

 string1 not a string or symbol.
±
 fixnum.
BER "A")             ==> A
(MAKE-NUMBER "(F O O)")       ==> ×(F O O)× ; Lists are never built.
ETQ A (MKNUMBER "FOO"))     ==> FOO ; not interned.
      ==> N IL
TRUCT
)
valuated) - a symbol.
where n is the value of arg1, and the

ed
 except for the structure type, which is set to arg2.
valid, in which case the structure has no elements.
 and STRUCTP are true of structures.
 aÿ
build the structure, even after GC.
RUCT are equivalent and both acceptable names.
makes a structureô  out of a list.
 by the ZIL programmer.  Use
	
   (MAKE-VECTOR arg1 &optional arg2)

- any LISP object.
n is the value of arg1, and all of
:
  urned
g2,
e vector has no elements.
m.
or length is negative.
valent and both acceptable names.
=> #()
L NIL NIL)

g1 arg2)
ed, evaluated) - any LISP object.
ocessing:
ors signaled:
when creating new documentation.
     ==> ("***ERROR***")

LEVEL &optional arg1)
nd 3, or NIL.
ge level; if a non-NIL valuÿ
message level and is
is NIL or omitted, the current message level is

 message level.  The current message level is updated to this
argument value is returned as the value.
his:  Whenever a low-level ZIL function
the current message level against the
es whose severity level is less
ayed.
ational; displayed for information only, no error condition.
g; something unusual but not serious.
ing of an error (THROW to tag NIL).
at the ÿ
trivial informational messages
 2.
essage level is greateÿ
n are suppressed when the
gnaled:
, or 3).
tion of the ZIL
t subject
 of
EVEL.  See GCMSG.
sued by ZIL
 the severity levels associated with these
message level higher than 2 is not recommended.
EVEL)

1)ÿ
formational and warning messages;
rted.
                 ÿ
     garbage collection messages; this is not
 as it will result in errors being
ge being displayed.
ULTIPLE-VALUE-BIND
)
uired, evaluated)     - any LISP object.
 a list of zero or more declarations
orms to be executed.
e body, after setting up a binding
 list1, which are bound to
g:
…
s iÿ
eturned from form2 are assigned to these variables in
e following rules:
ning variables
riables, the excess values are
rns no values, all of the variables are
ingle value (for example, it
 all), then the first
f any) are
 environment.  Note
dy, and may
AL
the value of the special form.
ents.
nd at a non-destructuring level, or other error detected by
essing).
nment without creating
 information on how multiple values
ee Guy Steele's "Common LISP: The Language", pp. 133-139, for
 of multiple ÿ
is not defined in ZIL, returning more than
rted.
an
 the list via destructuring.  In any case, out of all the forms that
 multiple values, only MULTIPLE-VALUE-BIND in compiled code
t to cons in ZIL.
UES 1 2 3 4) (LIST A    ))
UES 1 2 3 4) (LIST A B  ))
ALUES 1 2 3 4) (LIST A B C))
 C D) (VALUES 1 2 3 4) (LIST A B C D))
UE-BIND (A B C D E) (VALUES 1 2 3 4) (LIST A B C D E))

L NIL NIL)
     ==> (1 NIL NIL)
 C))
ST A B C))
 (LIST#  A B C))
       (LIST A B C))

1 &rest forms)
ional, evaluated) - any LISP object.
rned by func1 when it is called with all the arguments
ng the forms and collecting all their multiple
essing:
d as a
th
are all retained in succession and passed to the function, whose return
e is the return value.  Thusÿ
on is the total of the numbers of values returned from all

rrors signalled by APPLY).
for information on how multiple values

ion of multiple values in LISP.  Although the constant
IT is not defined in ZIL, returning more than
pported.
 than
‡
est multiple values, only MULTIPLE-VALUE-BIND in compiled code
 not to cons in ZIL.
UES 1 2)v )    ==> (1 . 2)
(VALUES 'B 'C) 'D)
)

ny LISP object.
urned by form1, or a list ofÿ
not return multiple values.

e made into a list which is returned as theÿ
f form1 returns no values, NIL is returned.  If form1 returns
, a singleton list of that value is returned.
Missing argument.
nd VALUES-LIST for information on how multiple values
nction.
Õ
IPLE-VALUES-LIMIT is not defined in ZIL, returning more than
alues is not supported.
 more expensive than
 values ÿ
s that

IST 'A)              == > (A)

UES 1 2 3))  ==> (1 2 3)
PLE-VALUE-PROG1

red.
nts, after evaluating all
	
‡
e results of evaluating arg1 with the expectation that multiple
be returned are passed as the values of this form.
IPLE-VALUE-PROG1 is identical to PROG1 except that
duces ÿ
 returns a single value, as does PROG2.
w arguments (at least one is required).
ALUES-LIST for informÿ
tion.

-VALUES-LIMIT is not defined in ZIL,ÿ
ues is not supported.
ore expensive than
alues from
that
is guaranteed not to cons in ZIL.
T (PROG1 (VALUES 1 2) 'A 'B))  ==> (1)
E-PROG1 (VALUES 1 2) 'A 'B))
   ==> (1 2)
TQ
 not evaluated) - a list of variables.
 LISP object.
ter all the values returned by

ple values may be
 in list1
:

ss values are
l of the variables are
example, it
st
t to NIL.
igned
o few or too many argumeÿ
Q).
ding environment
T for information on how multiple valueÿ
 
anation of multiple values in LISP.  Although the constant
IMIT is not defined in ZIL, returning more than
t supported.
sive than
m
request multiple values, only MULTIPLE-VALUE-BIND in compiled code
teed not to cons in ZIL.
F G))    ==> NIL

E-SETQ (D E F) (VALUES 9))         ==> 9
S))           ==> NIL
 ==> NIL

l, evaluated) - a list
nt need not be).
nts (CAR's) of all the arguments

ument is RPLACD'd onto the last CAR of the preceding argument.
(with nÿ
ed.

ept for the
nt not a proper list.
tions, NCONC should not be used
ived from compiling the
use further

ument may be NIL.  Use SETQ to insure updating of thÿ
ollows:
              ==> NIL
 B C) '(D E F))   ==> (A B C D E F)
is altered by NCONC.
B C))             ==> (B C)
Q W (NCONC X Y Z))      ==> (A B C D E F)
 B’  C D E F)
              ==> (D E F)
ÿç

ted) - any LISP object, but generally a list.
consisting of tÿ

structively
 arg2 is atomic, a list endingÿ
APPEND2, which makes a copy of its first argument.

ument form of NCONC, used to implement calls ÿ
e.

ruct (QUOTE (form1 form2 ...)).  This will cause further
 in-line constant list to be incorrect.
ering of the first argument if the
nsure updating of the
2 X Y))
C2 NIL '(A B C))       ==> (A B C)

. B)
     ==> (A B C . D)
NC2.
      ==> (A B C)
                    ==> (A B C D E)
 E)
econd argument to NCONC2 is not copied.
=> (A)
 ==> (A B C)

ired, evaluated) - any LISP object.
otted pair) whose CAR is arg1 and whose CDR is NIL.
 (ÿ

es:
 (A)

evaluated) - any LISP object.


None.

        ==> NI² L
	
 file name.
on the input file specified

ed; otherwise NIL is returned.
his function call while
if end-of-line has
d without
 may


nput file is not allocated or could not be opened.
EADCH and TYI ÿ
ns.
H, READLINE, TYI, and ZILRDCH are currently the only functions
INEP to true.  ENDREAD will nÿ
EADCH, etc. to detect end-of-line and return NIL,
ll be true.
valent.
FOO.
EWS &optional arg1)
enerally T or NIL.
ne ZIL news if any.
TEXT', which contains the current ZIL
 if arg1 is omitted or NIL,
non-NIL.

 arg1 (required,evaluated) - any LISP object.
g1 is NIL, otherwise NIL.
None.
 
=> NIL
ç
.. argn)
È
 a proper listÿ
applying the first argument
ther argument lists
on specified by the first argÿ
's) of the lists specified by the other arguments, until
 exhausted (in which case NOTANY returns T) or a
y this application (in which case NOTANY
s are specified, NOTANY returns T.
±
 
INTEGERP '(A B C D E))  ==> T
(NOTANY #'INTEGERP '(A 2 3 4 5))  ==> NIL
==> NIL
) '(A B C D)) ==> NIL
#'EQ '(X Y Z) '(A B C D)) ==> T

OTEVERY arg1 arg2 ... argn)
t can be APPLY'ed.
ional, evaluated) - a proper ÿ
values produced by applying the first argument
ts (CAR's) of the other argument lists

he
 one of the lists is exhausted (in which case NOTEVERY returns NIL)
l value is produced by this application (in which case NOTEÿ
.
led:
 mapping functions.
     ==> NIL
ERP '(1 2 3 4 5))  ==> NIL
TEVERY #'INTEGERP '(1 2 3 4 E))  ==> T
=> T
C) '(A B C D)) ==> T
 #'EQ '(A B Z) '(A B C D)) ==> T
tion: NRECONC
luated) - a proper list.
enerally a list.
of arg1 in reverse order followed by
g:
rg1 is NIL, arg2 is returned.  Otherwise, arg1 is destructively

Compare REVAPPEND, which does not destroy its first argument.
naled:
l the "destrucÿ
mpiled list, i.e. a list derived from compiling the
form2 ...)).  This will cause further
t to be incorrect.
 argument if the
the
mples:
      ==> (A B C)
'(B))         ==> (A B)
 '(A B) '(C D))     ==> (B A C D)
 D)
ETQ X '(A B C))           ==> (A B C)
)
    ==> (A D E)
lowing shows how the second argument to NRECONC is not copied.
'(A))               ==> (A)
Z (NRECON‚ C X Y))      ==> (A B C)

RSE list1)
: 


pare REVERSE, which makes a copy of its argument.
±
  ==> NIL
  ==> (D C B A)
ollowing shows how NREVERSE destroys its argument.
          ==> (Z I L)
REVERSE X))       ==> (L I Z)


- a proper list.
fied by arg2, where aÿ

t specified by
s
,
led:
ot a proper list or NIL.
valent to (CAR list), it is not as
ays evaluated arithmetically.
  ==> A



arg1 arg2)
valuated) - a proper list.
list specified by arg2, wÿ
ro.
of the list specified by
the list is
to list,
is equivalent to (CDDR list),
argument not a fixnum, or is negative.
r NIL.
st), it is not as
thmetically.

NTHCDR 3 '(A B C))      ==> NIL

 
if arg1 is NIL, otherwise NIL.

:
))     ==> NIL

 arg1)

ms, bignums, single-floaÿ
signaled:
    ==> T
)    ==> NIL
ERP 1D1)    ==> T
'(1))   ==> NIL
	
he current list (oblist) of interned symbols.
t of all the currently interned symbols is returned.
	
the oblist.  Such actions have
be dangerous to the ZIL
on Lisp wayš  of accessing interned
of the (OBLIST) function
d LISP programmers
ature.
   (ODDP arg1)
: 
g:

n invalid argument is passed.
=> NIL
ODDP 10000000000000) ==> NIL
00000) ==> NIL

 not evaluated) - a symbol funname, list (funname),
me aspect),
          aspect is one of:  ENTRY, :ENTRY, EXIT, :EXIT

on specified by funname and the aspect.
ing specifiedÿ
xit) is cancelled.  This results in reversion of
t processing to the default tracing
r "Exiting" and the
n, it defaults to entry.
 or there is no AT
 does NOT

(not entry or exit).

d for examples of use.
g and untracing
(FOO ENTRY))
entry.
reakpoint for FOO exit.
LEP
le name.

n already open output
dy open output
g of
If such a file exists, T is returned; otherwise NIL is returned.
r occurs trying to process the file, the error is
 OFILEP suppresses "file does not exist"
d:
r more information on file names.
on remains around even after
ainst a closed
mples:
eturns T if a ddname ZILOFOO is allocated to a
et.
¸

 if all the forms are successfully evaluated without error;
occurred during evaÿ

error occurs
…
, OK returns T.

 to do something and tell whether an error


"A not set.")))   ==> "A not set." ; FOO not defined
s")            ==> FOO
     (RETURN A)
as defined
tax:   (OPEN arg1 &optional arg2)
et name (string or symbol).
following symbols:
PEND, PROBE.
me, after allocating the data set specified by arg1 and
ode specified by arg2.
s a data set name, else NIL.
a symbol or string, is interpreted as a data set
 (quoted or unquoted, member name present or
not PROBE, the data set is dynamically allocated and opened.
ermined by arg2 as follows:

opened ÿ
is assumed.

 a "keyword").  In othÿ
if a list is specified as the second argument, the CAR
ed to be the file type and is analyzed as above.
ivalent:
"foo.data" 'IN)
 (OPEN "foo.data" :INPUT)
(:INPUT FROBNICANT BARFUCIOUS))
data set is dynamically
 is returned;
ain lower and/or upper case characters;
per case internally.
ther a sequential
e (i.e. the
 (ÿ
be either a sequential
 (which need not
 created
us
ed as arg2 and the data set already exists, the
 so that data will be written afÿ
OUT or OUTPUT was specified as arg2
 be made empty when it is
 the beginning of the
as happened!
ed to be "not
member


fied.
o
ew, unique ZIL file allocation, so
eginning of the file.  Up to
 open by OPEN (it may be
being unabÿ
file names are maintained in a counter that starts at 0001 and is
d by 1.  The file name is always a 4-character symbol,
ontent.  No check is madeÿ

ted above).
 Syntax error in data set name or memberÿ
me was specified for an APPEND request
cannot open a PDS member as MOD).
t is not partitioned.
 The dataset is not sequential or partitioned, or an input request
 for a dataset that was never opened (is empty).
sed to verify or report on allocation.
 may not be errors if PROBE is
urned.
es.
 of Oÿ
ted for an output request, the
60 are assigned.  You
a set before
owing conditions, you should
er of the same PDS open for output
e PDS, and when they are
 same data)

les:
unc)")
UT) ; OK, because the dsname is always upcased.
d be like this:
P DO (READ A) UNTIL (EOF A)
„


 

em returns a
nts
ith no arguments returns NIL, by ÿ
-conditional, e.g.:
                            (IF (NOT condition1) THEN result).
nd2 ... condn result) is equivalent to
1 cond2 ... condn)) THEN result).

B 'C)           ==> A
      ==> NIL
TRUE
:   (PAIRLIS list1 list2 &optional alist3)
 - a proper list.
optional, evaluated) - a list of dotÿ
 A list consisting of dotted pairs of elements taken from list1 and
nsed onto alist3.
t2 are taken and made into dotted
he beginning of arg3

not a proper list.
es:
ds,
esulting alist.
j™ ect at all.
3) (B . 2) (A . 1))
                     ==> ((B . 2) (A . 1) (F . O) (O . NIL))

 &optional env2 docp3)

ed) - a macrÿ
 object, but generally T or NIL.
 (1) A documentation string, or NIL.
ons.
ded form of the first element of (3), or NIL.
oexpansion of (3), otherwise NIL.
d to parse the body of a LAMBDA or a macroÿ
 into a documentation string, declarations,
tation string or declarations.
 env2 is the macroexpansion environment.  Currently this ÿ
ed, so you can specify anything you want, preferably NIL.
if the body is not expected to contain a documentation
ocumentation string will be processed if present,
N.
n, they are ignored.
n the body as it searches for
d for dÿ
ly one documentation string is permitted per body, although it
ore, after, or between DECLARE forms.  Any other
art of the body.
g. by a
 form for compilation), it does not have access to any
ros (CMACRO's).  This means that if yÿ
 declarations, they must be
WHEN), just
value 4 consed with the CDR of
e 5 is non-NIL.  In

NIL NIL NIL NIL)
 X)) NIL T))
T)
             (DECLARE (FIXNUM I) (FLONUM J))
  ÿ
    NIL
                    ((SPECIAL X) (FIXNUM I) (FLONUM J))
         ((IF A B+

 
        (DECLARE (SPECIAL X))
              NIL
 is a doc string"
                  (FOOBAR)
                    T
E-VALUE-LIST
RE (SPECIAL X))
NIL
                    NIL

           FOOBAR)
                              T


tents of the value/binding cell of arg1.
s no global value (ÿ
s the "unbound marker" is returned.
f - see ZILUNBND.
"),
alue of the symbol
gument (under the interpreter only).
ted in compiled code; results are unpredictable
passed.
does NOT means that x is unbound.  However, if (PBIND x) returns x,
s self-evaluating.  This is a fair assumption that is used
l ZIL routines.
 intimately
 

e never been assigned values.
         ==> T
 ==> #.(zilunbÿ
"
_A)    ==> PBIND_A
" but no value
_B)         ==> #.(zilunbnd) ; the "unbound" marker
(PBIND 'PBIND_B)) ==> #.(zilunbnd)
 binding makes no difference.
PECIAL PBIND_B))
ECIAL binding makes no difference.
nction: PDSIZE
containing the total number of BYTES (not stack slots)
("push-down stack").
he PARM field, or in a DECLARE,
ARM and DECLARE of
ÿç
 arg1 (required, evaluated) - a fixnum.
e contents represent the contents of the fullword of
memory locationÿ
preted as a 31-bit address and is used as a pointer to
orage.
‡
erefore, 0C4 ABENDs are likely when using this function.
Ó

 arg1 (required, evaluated) - a fixnum.
e contents represent the contents of the BYTE of
ry location pÿ
ed as a 31-bit address and is used as a pointer to
e.
 PEEK, which returns a FULLWÿ
arg1 not a fixnum.
k the validity of the address.
his function.
       ; i.e. X'04'

 - a fixnum.
r NIL.
t the contents of the BYTE
 to by arg1.
s and is used as a pointer to
 is specified and not NIL, the symbol is interned on the
t is not.
compare PEEK, which load a BYTE and makes a FIXNUM out of it,
cÿ
 fixnum.
dity of the address.
on.
'04'
PEEKC (+ (PEEK #X10) #X154) T) ==> C  ; first byte of "CSDL    "

 file1 eofval2 newlineval3)
t file name.
eval3 (optional,ÿ
1 defaults to standard input (NIL).
 defaults to the symbol whose print name is hex 0D
urn).
acter read from the input
 is encountered while
e is encountered
<
and logical record (the ENDREAD and ZPUTFPI functions can change
e character is returned and made into a symbol, but the
pointer is NOT updated to point to the next
 to PEEKCH without an intervening READ

¤

	
 
ned instead of a character.
pointer has reached the end
rned instead of a
e status when PEEKCH is issued,
ed:
Specified input file is not allocated or ÿ
nd of file.
e names.
n such
s,
READCH has not been thoroughly examined.
ould return the same symbol that
NEWLINEP.
fferent
l (prefix))
      ÿ
.$$test" :out)
foo.$$test" :in))
PEEKCH FOO 'EOF 'NEWL+
            ==> #\Cÿ
      ==> #\?  ; prime for a character
E))  ==> ×f×
'EOF 'NEWLINE)  ==> ×f×      ; Swaÿ
 FOO 'EOF 'NEWLINE))  ==> ×o×

(SETQ A (PEEKCH FOO 'EOF 'NEWLINE))  ==> ×o×
  '×o×)     ==> T
racter.
                 '×b×)     ==> T
; Swallow the character.

  ==> ×a×      ; Swallow the character.

OO 'EOF 'NEWLINE)  ==> ×r×      ; Swallow the character.
eq (peekch foo) '× ×)
==> T
 ;
E)  ==> NEWLINE  ; Swallow the character.
F      ; Read the next one.
be no way to get PEEKCH to return EOF,
 new-line-processing.
*") ; Read after EOF.
KL
valuated) - a fixnum.
nal, evaluated) - any LISP object, but generally T or Nÿ

‡
tion pointed to by arg1.
 31-bit address and is used as a pointer to

.
blistÿ
this list into a symbol;
 into a string.
 
e address.

 × × ×)
 #'STRING-APPEND A)                ==> "NONAME  "
EK #X10) #X154) 8)) ==> (C S D L × × × × × × × ×)
               ==> ×CSDL    ×
 "CSDL    "

uired, evaluated) - a symbol.
g1.
.
).
unpredictable
PLIST are both acceptable names, for compatibility
 Maclisp.

  ==> NIL
  ==> NIL
 BAR
   ==> Bÿ
ATE) 'BAZ)  ==> (FROB NICK ATE)
ICK ATE) FOO BAR)
     ==> (FROB NICK ATE• )
ST A)              ==> (BAZ (FROB NICK ATE))
 NIL
PP
+ &rest args)
e sum of all the arguments.
cifÿ
rned.
	

         ==> 3

 ==> 9.0
ax:   (PLUSP arg1)
ns: 
ssing:
 
an invalid argument is passed.
IL
  ==> NIL
.0F0)    ==> NIL
PLUSP 3.14159)  ==> T

 LISP object.


g1 is macroexpanded by MACROEXPAND and then pretty-printed.  The
e is the standard output file.

loper.
1, which is like PM but uses MACROEXPAND-1.
A Bg  C))
le:
 
quired, evaluated) - a LISP object.
.
specified by arg1 is
rocessing:
ed.  The
	
venience of the ZIL developer.
ils.
es:
 the standard output file:

 arg1)

ocessing:

ent (under the interpreter only).
 in compiled code; results are 0 unpredictable
sed.
          ==> ""
  ==> "foobar"
tax:   (POP stack1 &optional place2)
valuates to a list.
ent to SETF.
stack1, but has been removed,
Processing:
acceptable
 the
 stack1 is stored back into stack1.
a symbol or form known to SETF.
k1 is assigned to be the
e2 will return
 on a push-down stack.


 into something similar to (SETF b (POP a)).
nt to POP is present in Niÿ
ut has never been documented anywhere but
that's why it's there to begin with.
 B C))      ==> (A B C)
STACK)                ==> A
 Z NIL)               ==> NIL
                    ==> (C)

„
ns: 
¤

If fun is a symbol, its interpretive function definition is printed.
is a lambda-expression, a fake DEFÿ
nted.  In either case, the output takes the form
 function definition.
 each fun is printed

ead back in as LISP code.
Furthermore, if the fun is a variable with a global value, a SETÿ
ld assign the value is printed.
ignaled by ZILPP are trapped).
s the function equivalent to the old PP of

dard output.
oo bar)
(pp foo)
ut file:
ú
	

 
rwise, date1 is
returned
lied as part of the datÿ
t it to a valid four-digit year.
on Lisp: The Language",
igit year.

  ==> "August 15, 1986"   ; on August 15, 1986
 "January 1, 2001"   ; on April 13, 2000
cember 31, 1999" ; on April 13, 2000
Function: PPRINT
RETTY-PRINT arg1 &optional file2)
bject.
 
on
 on the output file specified by file2 in such a way as
 asÿ
n as LISP code.
aled:
on on file names.
definitions.
tz)))
	
the exact format may vary, depending on the state of
 pretty-printer.
 
 list of 3 fixnums.
esented by time1 in "pretty" format.
omitted, the current time is used.  Otherwise, time1 is
 (hour minute second) in a format like that
E).
,

TIME)           ==> "5:30 P.M."         ; at 5:30 PM
))  ==> "1:01 A.M."
  ==> "12:00 Noon"
))  ==> "1:14 P.M."
	
SO PREFIX or NIL if not in a TSO environment.
reground, or in TSO in batch, a string whose contenÿ
used to qualify data set names (in batch, this returns a null
you have issued the TSO PROFILE command to set the
ther than TSO batch, PREFIX returns NIL.
 issing the TSO PROFILE command.


Pÿ
        if ZIL is run under TSO in batch
ix was not set by PROFILE command

 PREFIX(FOO)")
FLIST)
 (PUSH (PREFIX) PREFLIST)
)
   ("Changed prefix" "FOO" "No prefix" "")

red, evaluated) - any LISP object.
ile name.

on the current line
an change
nt to theÿ
Õ
man-readable form".
ters; the text of
acy of flonum values is not the greatest.
yped in directly (e.g. compiled code
 entities) will print
ot being able
 of an atom, or a dot or parenthesis,
nt line, and that printed
the TERPRI function
 line.
is always printed in full, never as a quote mark.
n dotted-pair notation if they contain a CONS
therwise they are printed in standard
ol print name longer than the output line length will
ext ÿ
 
ied output file is not allocated or could not be opened.
 See member $FILE fÿ
NTER for more information on printing functions.
s almost the same but prints objects in formats

urn A after printing...
he standard output file.
turned value)
RINC 'A               'FOO)
 'B 'C)     'FOO)
  'FOO)

file FOO.
tax:   (PRINT arg1 &optional arg2)
P object.
 

 on the

he current line and reset the
the next line.  Then the
r is incremented by
 this to PRIN1,
cter
lowing).
bol 4 ÿ
 not be opened.
 file names.
ions.
ich

...
 file.
on the standard output file as well; this will print on the next
ng the user to see:
 value will appear twice to the user.
  'FOO)
 (PRINT (LIST 'B 'C)    'FOO)
 string"      'FOO)
..
)
"¤ a string"

rg2)
evaluated) - an output file name.
been prinÿ
C is like PRINT, but prints out in PRINC-like form rather
rm.
 characters or less).
be opened.
 names.

Î

..
t file.

using the user to see:
s the value will appear twice to the user.
       'FOO)

C "aÿ
ting...
B . C)
   a string

opt2)
l, evaluated) - any LISP object, but generally T or NIL.

:

 if opt2 is specified andÿ

(PRINC-TO-STRING x)  is equivalent to (PRINTS x NIL).
is equivalent to (PRINTS x T).
on on how things are printed.
      ==> "A"
      ==> "7"
  ==> "foo"
°°

ated) - an output file name.
priÿ
rinted at the current character position on the current line
ile file2 (the TERPRI and ZPUTFPO functions can change
 current characterÿ
y following the last character written.
he object, where possible, will be
 object could be read in
eptions:

cts, structures, unrecognizable entities) will pÿ
> syntax.  This is defined as not being able

xtend past the end of the current line, and that printed
 shorter than the line length, the TERPRI function
he current line and start a new line.
L.
k.
 whose CDR is a non-NIL atom; otherwise they are printed in standard
rmat.
will
g.
characters or less).
opened.
names.

uman-readable" format.
)  are equivalent and return A after printing...

              'FOO)
    'FOO)

er printing...
	
	
E arg1)
ame.
ted by arg1 if it

ata set

.

is message, you might wishÿ
ors signaled:
 (null (prefix))
                          ==> NIL
 ==> "'CSD.CMD.CLIST(XSETUP)'"
L
.
r.
   (PROG varlist1 &rest forms)

sequent argument is required, but ÿ
 may be specified.
f symbols or
conditionally evaluated if a list) - a symbol or ÿ
 

URN (or RETURN-FROM NIL) becomes the return value.

  names local to the PROG.  Each is in one of the following forms:
 symbol   -  the variable named "symbol" is bound to NIL

 obtained by evaluating "form".  The environment
ich "form" is evaluated depends on whether
G* is being usÿ
mplate may be substituted for
 is destructured.
ng.
 
e PROG.
re
  specified in the argument list.
 constitute the body of the
llows:
 the form is a symbol, it is not evaluated, but kept
a GO form can branch to.
valuated, but kept
er words,

t is evaluated.
 above tyÿ
 and NIL is
tered by the execution of the special
tered during evaluation ÿ

‡
valuated, and processing continues from+
on of its argument and exit from the ÿ
alue.  If no RETURN statement is executed,
ely (until an error occurs) or
d.
to
 the same way as (RETURN ...).  See BLOCK and RETURN-FROM (member
f this documentation) for more information.
, except that PROG binds its variables
lel binding.
nvironment present outside of the
n ÿ
hat each binding can refer to previous
	
 arg1 not a list)ÿ
 is now a macro which expands into
ical to PROG except that it
d RETURN are valid as long as thÿ
is means that they will be processed as long as they
function evaluation.  The following are
	
 B C) (COND ((EQ A T) (GO LOOP)))
N B)))

ide of PROG" error will be signalled.
e information on restrictions
e which involve
yet)
mples:
            ==> NIL
 (COND ((NULÿ
     (SETQ A (CDR A))
=> (5 4 3 2)
 (C NIL)
(SETQ D (CAR B))


G* ((A (LIST A)) (B A)) (RETURN (LIST A B)))  ==>  (("a") ("a"))

 args)
e last of the arguments.
 in turn; since thÿ
se are generally
s
N returns NIL.
 be

OMPILE ...) used to be the traditional way to
 forms to the compiler; it is no longer
is without the 'COMPILE.  See
s:
            ==> A
)                 ==> C

list2 &rest forms)

ated) - any LISP fÿ
 SPECIAL variable binding environment

able
he corresponding values in the second argument, and revert to
 status when the PROGV is terminated.
r than the list of values,
urately,
If the list of values is longer than the list of variables,
s are ignored.
 of the
fied in varlist1 bound to the values in vallist2.  The
ed forms is returned as the value.
he bindings generated this
cular, they

ing a bindingÿ
ariable specs are

s a macro which expands
 should be kept


rgs)
ent is required.
aluating all of thÿ
ments are evaluated; since only the value of the first
re generally specified for their effect only.
irst argument is returned as the ÿ
few arguments (at least one is required).
eturns a single value, no matter what the first form
-PROG1, which returns all the values from
:
       ==> A

	
are required.
uating ÿ
nts are evaluated; since only the value of the second
e generally specified for their effect only.
cond argument is returÿ
few arguments (at least two are required).
returns a single value, no matter what the second form
UE-PROG1, which returns all the valueÿ
es:
         ==> B
'(C D)))          ==> A
   ==> (1)
x:   (PSETQ &rest args)
g1 (required, not evaluated) - a symbol.
SP object.
pecified by the odd-numbered
ed by the
f the even-numbered arguments are obtained, and then the
nted by the odd-numbered arguments are set to these
is is similar to SETQ, except for the fact
lel.  Thus, the value of a given
nment that takes place
 on variable binding.
number of arguments required).

(A 1) (B 2) (C 3))
  (0 0 0)
  (LIST A B C))       ½  ==>  (0 1 2)

aluated) - any LISP object.
 to SETF which


orm acceptable
t ofÿ
nto
" operation on a push-down stack.
gnaled:
mething like this:
 present time, the macro expansion does not guarantee 100%
aluation of the second argument.  ÿ


at although the GET will be evaluated only once
late the first GET into the
) may be
u may or may not be informed of the upgrade.
A '(FOO))          ==> (FOO)
                     ==> (BAR FOO)
A 'P)              ==> V
  'P)              ==> (BAZ . V)
o: PUSHNEW
  (required, evaluated) - any LISP object.
form acceptable to SETF which
a list.
ont of it if it is not
Ö

h is the value of place2,
 CONSed onto the
st is stored
er test is determined by the keywords, if any, specified on
NEW (using Common LISP keyword syntax).
ST   -  must be #'EQ, #'EQL oÿ
oth are optional.  If :TEST is omitted, the default is #'EQL.
is performed by one of the MEMBER functions if the :KEY
by one of the ASSOC functions if the :KEY
r 'CAR).
)
                      MEMQUAL   for :TEST #'EQUAL (or 'EQUAÿ
OC  functions are:  ASSQ      for :TEST #'EQ    (or 'EQ)
        ASSQL     for :TEST #'EQL   (or 'EQL)
QUAL   for :TEST #'EQUAL (or 'EQUAL)
e CAR of item1 is compared with the
, item1 is compared with
 
Notes:
arg,
 operation which adds an element to a set.
 the present time, the mÿ
ime evaluation of the second argument.  Thus, if you
 
(foo) and (bar) may be
if it is,

(PUSHNEW 'BAR A)       ==> (BAR FOO)
Ä
 FOO)
         ==> (V)
 'A 'P))     ==> (W V)
TQ X NIL)                       ==> NIL
=> ((A . 1))
USHNEW '(A . 3) X :KEY #'CAR)    ==> ((B . 2) (A . 1))
  ÿ
IL
 (2.0 1.0)
T #'EQ)  ==> (1.0÷  2.0 1.0)

     ==> (2.0 1.0 2.0 1.0)
UTDATA
uated) - any LISP form that can be evaluated.
r the forms and their values are printed on the standard outÿ
=B,C=D" format.
in turn on standard output, with
e.  Commas separate
.
ƒ
e.  To get multiline output, issue multiple PUTDATA's.
imarily foÿ
 expressions at various points in a
 inspired by the PL/1

ATA with no arguments is accepted and essentially

 macros.  See AT, OFF and $TRACE for exa“ mples of usage.

llowing being printed:

arg2 arg3)
valuated) - any LISP object.
ut generally a symÿ
 the value of the property specified by
m specified by arg1.
 property list is being manipulatÿ
gned, and arg3 is the name of
 is already an indicator on the property list of arg1,
e of the arg3 property is (destructively)
e indicator/value "pair" consisting
he beginning of the
s equivalent to doing (REMPROP arg1 arg3),
lices the indicator/value pair out
ly replaces the value
 will accept a first argument of a
 is treated like a property
sed in Maclisp.
er $PROP).
ty lists.

      ==> NIL
                         ==>ÿ
==> BAR
OB NICK ATE) 'BAZ) ==> (FROB NICK ATE)
> (BAZ (FROB NICK ATE) FOO BAR)

 'FROB 'BAZ)            ==> FROB
 FROB FOO BAR)
)                      ==> FROB
ion: QUIT
ated) - an input file name.
s forced on the file specified by arg1.
 set on in the file block for the input file specified by arg1
quent input functions (READ, READCH, etc.)  receive an
n.  Subsequent processing is dependent upon the

pon standard input.  This is one way of terminating the ZIL
ch reads, evaluates, and prints the values of forms
file until enÿ
id input file object (not a symbol 4 characters or less).
le is not allocated or could not be opened.
FILE for more information onÿ
unction (compiled or interpreted)
QUIT NIL) causes the
e EXIT,

but indicates end of
amples:
O)     forces end-of-file on the input file FOO.
µ
quired, not evaluated) - any LISP object.
rgument.
ÿ
r the QUOTE function,
ors signaled:
nt to (QUOTE (aÿ
 environment the former builds a new
executed, while the latter
le whose address is
of the program,
„
RO for more information on reader macros.
          ==> A
  ; note that this is a symbol.
UOTE A))  ==> (QUOTE A)
            ==> A
    ; note that this is a symbol.
            ==> (QUOTE A)
UOTIENT

in succession) of all the arguments.
nts are specified, 1 is returned.  If one argument is
OTIENT, that argument is returned; for /, the
rgument is returned.  Note that if the
te value is greater than 1, the
seless an operation.
rors signaled:

 ==> 5.0
(QUOTIENT 4)          ==> 4
      ==> 0.25
 
ositive fixnum or flonum.
n 0 and less than arg1.
umber of the same type between 0 and arg1
d, the internal random state is reset (i.e.
s returned.
 fixnum or flonum).
mples because the value returned by RANDOM is
, by definition.  However, the same
d by the same sequence of
	
(RDRMACRO arg1 arg2)
l or string, or
equired, evaluated) - a compileÿ

 character specified by arg1 as a reader macro.
arg2 is NIL, the reader macro definition for tÿ
g1 is removed from the read table.
 macro chain are updated with a
1 as a reader macro; when
 the compiled code
ed code SUBR must be a function that takes one argument;
und to the file name currently in use by READ
acro.  This enables the reader macro
 read, via functions like
uted under the environment active at the time that
 are not peÿ
acter as an atom,
 wishes to return "nothing" to the reader (i.e. have
ding with the next S-expreÿ
form (VALUES)), or
evel function, generally for internal use.
ther types of objects as reader

  (RDRMACRO  "?"  (ZILLOAD 'MYFUNK))
 
:

hat is returned only by the
or interpreted, are not
 macros using
 a reader macro definition is deleted, the syntax for
cter iÿ
.


Examples:
 (ZILLOAD 'QFOO))
ion:
the following is read in:
ned by READ:
will be evaluated by EVAL

le1 value2)
e2 (optional, evaluated) - any LISP object.
ession (atom or lÿ
e2 if end-of-file is encountered while scanning for an

 file file1 is read from the curÿ
 (the ENDREAD and ZPUTFPI functions can change these).
ng to the formats described in member $FORMS
 The returned S-expression (atom, list, or dottÿ
 it is not evaluated.  () and NIL are equivalent.
matched right parenthesis or misplaced period) is
ignalled.  If a syntax error occurs while
air, an error is signalled when the
ter how deep the nesting of
as found.
rator
determine if this was the case).  If the file is already in end-of-file
us when READ is issued, an error is signalled.
line" indicaÿ
om delimiter except when an
-of-line occurs while
er is inserted
d in all
tinuation character
ll be printed
n) in the
gn in
ollowing line as part of the object currently being read ÿ
ewlines.  (This does not apply to data read in from the terminal,
he continuation characters may appear when an object is
erminal.)
gnums,
ecords, the cent sign will be treated as a
pies the last data column.  For
ecognizÿ
or unnumbered data sets,
ariable-length records, the cent sign will be treated as a
acter if it occupies t+
maximum length.
f it is preceded
rwise not

ied input file is not allocated or could not be opened.
le.
d-of-file encountered before closing right
racter following escape character (backslash); i.e.,
hen a character was required.

is-should-never-happen" class of errors).
LE for more information on file names.
forms accepted by READ.
ÿ
cro.
ly characters with reader macros implemented by the system by
ser can define ÿ
.  A read table defining the separator and
eader macro characters is
The syntax of the / and \ charÿ
 to provide capability of reading LISP code written in Maclisp
isp-compatible reader.  The RMINIT function will restore
efault mode.  See RMMAC and RMINIT for more
acro definitions for the following characters are predefined:
 quote)
RMACRO in this documentation for details on these.
(READ)

 returns an S-expression from the input file FOO.
f-file is reached while reading FOO, then
IL.

          
      as above.
: READCH
 file1       (optional, evaluated) - an input file name.
al, evaluated) - any LISP object.
LISP object.

name is hex 0D
n interned symbol whose print name is a character read from the input
pecified by file1; or eofval2 if end-of-file is encountered while
or a character; or newlineval3 if end-of-line is encountered
for a charÿ
ead from the current character position
ZPUTFPI functions can change
o a symbol, and the
ext character.
never
r has reached the end
supplied) is
the current character pointer has reached the end
d, newlineval3 is returned instead of a
 call to READCH will return either
r end-of-file (note that the
 end-of-line condition
already in end-of-file status when READCH is issued,
	
acters or less).
d.
re information on file names.
 only functions that can cause
t file (see NEWLINEPÿ
allocated to the
cessed
turn true.  In other words, the firÿ
line".
rent
 ZIL, which had different


-file (file "$$foo.$$test" :out)
 (setq foo (open "$$foo.$$test" :in))
      ==> T
F 'NEWLINE)  ==> ×?×
F 'NEWLINE)  ==> ×o×
EOF 'NEWLINE)  ==> ×b×
EOF 'NEWLINE)  ==> ×r×
   unless (eq a '× ×)
foo)         Ì      ==> T
ç
al arg1)
ns: 
om

ecified by arg1 is in newline state, the next record
current input record is used.ÿ
e length is equal to the length of the
s the contents of the record
If the file has fixed-length records, all vaÿ
 have the same length (the LRECL of the file).  For files with
ngth record format, the value will have the length of
e value in the RDW minus 4).


when READLINE is issued,

fied input file is not allocated or could not be opened.
ile.
.
ause
 
has a variable-length
ears ago
ull (prefix))
                       ==> NIL
oo.$$test" :out)

e)

               ==> T
ine x)))
IME FOO)       ==> "Four score and seven"

EAD FOO)            ==> FATHERS
thosm e blanks did it
ME FOO)       ==> "NIL" ; because READLINE returned NIL


d) - an integer.
of all ÿ
ed, 1 is returned.
	

 
 10 3)      ==> 1
	t
(required, evaluated) - a proper list.
ing of all the elements of arg1, but with duplicate

e elements
¤
ments occur onlyÿ
elements of the list are considered;
 processed by REMDUPQ.
 an EQL test.
No checking is done as to the validity of the arguments.  Unpredictable
lts will occur if arg1 is not a proper list.
EQL, is used for the comparisons.
k as the first argument.
 F R O B)) ==> (F O B A R Z)
 ((F O O) (F O O) (B A R))
st is EQ, not EQUAL.
0 4.0 7.0 4.0 8.0)
not EQL.
yntax:   (REMDUPQL arg1)
	
th duplicate
built (through repeated CONS'ing) from the elements
 arg1.  If any element of the list is EQL
 it is not included; thus any such
d list.

re REMDUPQ, which is like REMDUPQL but uses an EQ test.
d:
 of the arguments.  Unpredictable
 list.
 O B š A R Z)
7.0 8.0)
B A R))

 (REMDUPQU arg1)
Returns: 
cate
hrough repeated CONS'ing) from the elements
If any element of the list is EQUAL
 not included; thus any such
.
-atomic elements are NOT recursively processed by REMDUPQU.
DUPQ, which is like REMDUPQU but uses an EQ test;
ike REMDUPQU but uses an EQL test.
±
redictable
es:
(REMDUPQU '(2.0 1.0 4.0 7.0 4.0 8.0))   ==> (2.0 1.0 4.0 7.0 8.0)
UPQU '((F O O) (F O O) (B A R)))   ==> ((F O O) (B A R))
ú
nal count3)
(required, evaluated) - a proper list.
eger.
ment 2 except for those
 
he list specified by thÿ
 structure that is EQL to the first argument is


.  If count3 is less than 1, no elements are removed.
ed, some list structure may be shared between list2

tomic elements are NOT recursively processed by REMOVE.
 which is the destructive equivalent of REMOVE.

 is, by default, implemented with an EQL test for Common LISP
 using the ZIL function REMQL.  If Maclisp or Franz LISP
sired, REMOVE may be equated with ZIL function
al ÿ
a, REMOVE performs an EQUAL test.
y of the arguments.  Unpredictable
 is not an atom orÿ
'(THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG))
 (QUICK BROWN FOX JUMPS OVER LAZY DOG)
R) (FOO) FOO BAR))
EQL, not EQUAL.
  ; Test is EQL, not EQ.
 (REMOVE 'X '(X Y X Y X) 1) ==> (Y X Y X)
Y Y X)

 (required, evaluated) - a symbol.
ect, but generally a symbol.

 list specified by the first argument.
is returned and the property
The indicator/ÿ
 is removed from the property list of the atom specified
nt.
 first argument of a list, inÿ
ke a property list.  This is the "disembodied property list"
.
 

                  ==> A
        ==> (FROB NICK ATE)
'A 'FOO)           ==> NIL
È
NIL
IL

1 list2 &optional count3)
t, but generally a symbol.
 count3 (optional, evaluatÿ
consisting of all the elements of argument 2 except for those
o argument 1.
 CONS'ing) from the elements
  Each atom found
 is
urrences of arg1 are removed from
 occurrences of arg1 are
 removed.
n list2
f the list are considered;
 by REMQ.
and DELQ, which is the destructive equivalent of REMQ.
 Commoÿ
d count argument (not a fixnum or NIL).
one as to the validity of the arguments.  Unpredictable
f the second argumentÿ
nd that EQ, not EQL, is used for the comparisons.
eral, will work as the first argument.
HE QUICK BROWN FOX JUMPS OVER THE LAÿ
(QUICK BROWN FOX JUMPS OVER LAZY DOG)
(FOO) FOO BAR))
ot EQUAL.
2.0 3.0 4.0 5.0)   ; Test is EQ, not EQL.
(X Y X Y X)
 2) ==> (Y Y X)
ú
l count3)
equired, evaluated) - a proper list.
er.
nt 2 except for those
Õ
 list specified by the ÿ
tructure that is EQL to the first argument is
 
list2.  Otherwise, only the first counÿ
 If count3 is less than 1, no elements are removed.
, some list structure may be shared between list2

mic elements are NOT recursively processed by REMQL.
h is like REMQL but uses an EQ test;
es an EQUAL test.
t a fixnum or NIL).
ty of the arguments.  Unpredictable
t is not an atom or a proper
milÿ
.
ZY DOG))
	
(FOO (FOO BAR) (FOO) FOO BAR) ; Test is EQL, not EQUAL.
 3 4 5))
'X '(X Y X Y X) 0) ==> (X Y X Y Xk )

Y)
  (REMQUAL arg1 list2 &optional count3)
any LISP object.
ptional, evaluated) - an integer.
 of all the elements of argument 2 except for those
ent 1.
ng) from the elements
atom found

nces of arg1 are removed from
urrences of arg1 are
oved.
st2

REMQUAL.
nd REMQL, which is like REMQL but uses an EQL test.
 
 checking is done as to the validity of the arguments.  Unpredictable
s will occur if the second argument is not an atom or a proper

e REMOVE/REMQ/REMQUAL/REMQUAL family.
(THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG))
(QUICK BROWN FOX JUMPS OVER LAZY DOG)
BAR) (FOO) FOO BAR))
 EQL.
is EQUAL, not EQ.
MQUAL 'X '(X Y X Y X) 1) ==> (Y X Y X)
X)
	
ed, evaluated) - a compiled code object (SUBR or closure).
 
 arg1 accepts &REST arguments.
 compiled code header information, extracts the
 returns T or NIL.
…
finition provided that it has been loaded.
hich loads the function from disk.
t a compiled code object oÿ
 created for parallelism with MAXARGS and MINARGS.
unction uses this internally.
 considered to take a
IL) NIL)         ==> NIL ; to load CAR and APPEND.
)     ==> NIL ; after CAR has been used.
NIL


al, evaluated) - any LISP object.
value.  The value of the first argument is the
tly active PROG, or BLOCK named NIL.
d only within a PROG, or a BLOCK named NIL.
nd the current PROG (or BLOCK named NIL) is
eturn ÿ

om within a lexical closure (FUNARG), which may produce
.  In compiled code, ÿ
RETURN transfers control from inside a form protected by
utside that form, the UNWIND-PROTECT cleanup forms
ROG is exited.
utside of a PROG or BLOCK named NIL
special form, but is now a macro that expands
 See PROG, which is now a macro that
 other things.
parent in
„
ccurrences of GO and RETURN:
P) (RETURN T))
OOP (PROG2 (PRINT A) (RETURN B)))
(ÿ
 (SUMFUNK NIL))
 
 X (CONS 'B X))
                           ==> (C B A)


) - any LISP object.
 value of arg2 is the
1.
me is EQ to name1 is
s omiÿ
thin a BLOCK.
 a
ETURN-FROM may exit ÿ
 closure (FUNARG), which may produce some
, RETURN-FROM may not branch out of a
nsfers control from inside a form pÿ
hat form, the UNWIND-PROTECT cleanup forms
exited.
ck name not active
is lexically apparent in
long as it is
 valid occurrences of RETURN-FROM:
-FROM FOO T))
Q A T) (RETURN-FROM BAR2 A))
-FROM BAR1))))))
ÿ
ching RETURN-FROM block name" error will be signalled.

  (SETQ X (CONSp  'B X))
URN-FROM FOO X)

D list1 list2)
luated) - a proper list.
generally a list.
 of argument 1 in reverse order

, in particular
, not
rst argument.

list,
NIL NIL)         ==> NIL
END '(A B C) NIL)    ==> (C B A)
 (REVAPPEND '(A) 'B)         ==> (A . B)
A C D)
ows how the second argument to REVAPPEND is NOT copied.
 w             ==> (A B)
REVAPPEND X Y))    ==> (B A C D)
ú
LL arg1)
oper list.
ent 1 in reverse orderÿ
ocessing:
ents
pare REVERSE, which reorders the top-ÿ
ly reverse them.
 No checking is done as to the validity of the argument.
ts will occur if the argument is not a proper list.
 (REVERSAL NIL)              ==> NIL
 (REVERSAL '(A B C D))       ==> (D C B A)
(D C) (B A))

.
se order.
ONS'ing) from the elements
st are NOT
ts argument;
²
Examples:
       ==> (A)
 B) (C D)))    ==> ((C D) (A B))
a list is made using REVERSE.

IL

ymbol whose print name is the current reader macro character.
:
…
 returned by the RMCHAR function.
of a reader macro processing
	
eference the macro character which triggered it.  Therefore,
lways interned on the oblist.
aracter associated with

AD, DEFRDMAC and RDRMACRO for more information

	
 
mples:
'(LAMBDA (X) (LIST (RMCHAR) (READ X))))
d in:
  (? FOO)
 EVAL

L, after restoring the read table to its default mode of operation.
essing:

r all characters.  This includes the forward and backward slash
 and \, which may have been changed by the RMMAC function.
ackslash \T  character, i.e. as a single escape.

our reader macro

s: 
	
sh characterÿ
ape.

 
t reader syntax, use the RMINIT function.  Note,
y results in the cancellation of any
mples:

ar  ==>   fOO\BAR
 
hich has special meaning to the reader.
AD function invokes a reader macro, it generally ÿ
y the macro as the value "read".  However, in some
wish to indicate that nothing was returned.
ansmit this wish back to the reader.
 object as a return value from
r object.  Thus the
Õ

.
ionality may be provided by a reader macro by
a the form (VAÿ
eases of ZIL
ocumentation on READ, DEFRDMAC and RDRMACRO for more information
acro processing.
n.
FRDMAC '×?× '(LAMBDA (X) (READ X) (RMNIL)))
 read in:
e result will be:

d, evaluated) - a fixnum.
urns: 
on
(left if positive, right if negative).
c rotate operation is performed on the numeric contents of
e), with arg2ÿ

e absolute value of the fixnum arg2.
e of N bits takes place, witÿ
2.

 a fixnum.
 of arg2 is greater than 31.
48  ; Standard way to get most negative fixnum.
 7) ==> -1

(required, evaluated) - a number.
 
2, rounded to the nearest integer.
rence of arg1 and the
ied, the remainder, i.e. the difference
st valuÿ
by arg2 such that a floating
ent is set to arg1.
est integer.
lute
gument lies exactly halfway between two integers (xxx.5), it
he next EVEN integer.

Ä
en integer algorithm breaks down in
turned due to the magnitude
:
UND 1)       ==> 1
UND 1.2)     ==> 1
D 1.2F0)   ==> 1
D -1.9)    ==> -2
NDÿ
OUND 0.5)     ==> 0
ND 0.5F0)   ==> 0
 -0)      ==> 0
D -0.2)    ==> 0
 -0.2F0)  ==> 0
UND 4.5)     ==> 4
UND 1.5)     ==> 2
D -1.5)    ==> -2
ND -4.5)    ==> -4



=> 10
==> 12
 ==> 13
ÿç

equired, evaluated) - any LISP object.
ment, with its ÿ

 i.e. the first argument becomes a CONS of the second
f the first argument, but withÿ
naled:

 an invalid argument is passed.
ns, RPLACA should not be used
ed from compiling the
further
xamples:
 C)

—¦—
1 (required, evaluated) - a cons (list or dotted pair).
uated) - any LISP object.
s ÿ
 argument destructively replaces the CDR of the first
st argument becomes a CONS of the CAR of the
rgument, but withÿ

ors are detected in compiled code; results are unpredictable
rgument is passed.
ould not be used
ling the
eferences to the in-line constant list to be inÿ



ÆÆ
ME)
(thousandths of a
 orÿ
ob step elapsed time" field of the
nverted to milliseconds.
IST variable

 be
ue at two different
 those points.
T

g:
nted


date this. But
ƒ
n changed via SETF of SPECIAL-ALIST.
e binding "alists": the
l alist" is used
ist" is
across LAMBÔ DA boundaries or captured by lexical closures.

&rest args)
 - a string.
nated to foÿ
pecified, a null string is returned.
not a string.
 arguments, symbols are
.

s, but makes a symbol.)  Use TOSTRING to ÿ
nto strings.
ist
   ==> ""
o" "bar" "baz") ==> "foobarbaz"
ion: STRING-APPENDL
ENDL list1)
turns: 
 form a
ing is returned.
contained within the list.
to (APPLY #'STRING-APPEND a), but faster.
ke strings as arguments, symbols are
n that case.
.  (This
n
bers, for example, into strings.
              ==> ""
DL '("foo" "bar" "baz"))   ==> "foobarbaz"

(required, evaluated) - any LISP object.
st in association list format
of dotted pairs).

g1;
	

nce this is a macro that expands into a call to ASSOC, it uses
lity test ASSOC uses.  SÉ ee ASSOC for more information.
ú

ated) - a list in association list format
e. a lisÿ
o arguments.
R matches arg1;
Processing:
d, fun3 is
	
tever equality test ASSQ uses.   See AÇ SSQ for more information.

NG-CAPITALIZE string1)
d, evaluated) - a string.
g1, except that aÿ
ails).
if necessary, is returned
anslated such that the first chaÿ
alphabetic, and the other
phabetic.
within
 Note that the national characters (@,#,$) are considered
or the purposes of STRING-CAPITALIZE.
tions, symbols are acceptable.
ing.

Compare STRING-UPCASE and STRING-DOWNCASE.
CAPITALIZE "")      ==> ""
APITALIZE "A")     ==> "A"
-CAPITALIZE "FOO")   ==> "Foo"
RING-CAPITALÿ
mmon LISP: The Language" follow.
llo "
EFenestraTION")
on"
ring-capitalize "DON'T!")            ==> "Don'T!"   ; not "Don't!"
apitalize "pipe 13a, foo16c")  ==> "Pipe 1» 3a, Foo16c"

: 

MVS GTSÿ
urn them as a pair of fixnums.  If this function is invoked in
onment, (0 . 132) will be returned.

size, which

 
list1)
 The second element of list1, or NIL if list1 has less than 2 elements.
Processing:

D NIL)                ==> NIL
D '(A B C D))         ==> B

al2)
ed) - any LISP object.
fied by var1 has been bouÿ
sing:

namic (SPECIAL) binding of the variable ÿ
 altered to refer to the (evaluated) second argument;
alue" of var1 is set to val2.
inding is not saved but
ntly bound, a global binding is created
he symbol may not be self-evaluating (NIL, T or a keyword).
t affect lexical (non-SPECIAL) bindings.
alid first argument.
al assignment function for
ET assignment is limited to the extent of the
ng diÿ
of the variable was "shadowed" by
red" in the same way as if
to a globally bound
 SET assigns a dynamic binding to a variable, it does not
e that variable to become globally declared

A.
 a  'set-a)         ; This sets global value of Z.
Z
	
(SETABEND arg1)
ally T or NIL.
truction to control the
) should occur.
urring in ZIL code will cause
ated.
 to
 of ZIL error.
routine cancelled ZIL's ESTAE).
oint operations may result in program checks
NIL) is specified, these will result in
L operations are uninterruptible (e.g. the garbage collector).
 occurs during such a process, the ZIL session is abnormally
no recovery is possible.
L via the INVOKE or TSO
file opens.³ 

ables abend handling.
ETARG
 integer.

been replaced by arg2.
naled:
 invalid.
 Results are unpredictable
mber $LEXPR for information about LEXPR's.
 X
  (¡ ARG T)))  ==> FOO

arg1)
NIL.
control the

red by the user
hed.
IL
bort the current process (which causes a THROW to tag T, which is
o be "top level" from the point of view of the user)
he current process as if attention had never been
errupt is entered at this point, ZIL is

e.g. the garbage collector).
process, the user's
tirely by
ds C invoked from ZIL via the TSO
ples:
s attention handling.
ACK
d, evaluated) - a fixnum between 0 and 255 inclusive.
ted) - a fixnum between 0 and 255 inclusive.
any LISP object, but generally T or NIL.
hanging the default characters used for printout of
ackets for files with tab expansion active
Processing:
L's
For files without the tab expansion feature, square brackets are
 isÿ
e
 above applies only to output generated by PRINC, i.e. without
n.  For PRIN1 outpÿ
 consistency.
 to determine
ts.
alized based on terminal type (for example, the characters
 display as brackets on a 3180, whereas the
play as brackets on a 3179).
nt, as for a remote terminal
will end up being
 use the characters arg1 and arg2 as left and
tively whenever writing to a file via PRINC
hat file, whether the file is a dataset
 is the character to be output for left square brackets.
 character to be output for right square brackets.
fied and non-NIL, requests that the change be
anslate table as well.  This will
 sent to the ÿ
is to let ZIL try to
e terminal,
	
 is connected to MVS via a 7171 controller, do:
  ; print "real" brackets, even to terminal
 a 3179 or a 3180:
let ZIL translate

example, terminal printout would be correct, but file prin+
correct.  This is why the former is preferred.  Use
har> <other weird hex char>) only in cases
your terminal but there is no
output will be bad

.  There's no way
so let
 defauÿ
L)
ied in all examples above.
etween 0 and 255.

are display of curly braces.  However, whenever ZIL displays
 correctly to the terminal, the linem  may be
l be transmitted properly as input.
 description above.
BUG
LISP object, but generally T or NIL.
ing ZIL debugging mode on or off.
 the flag that controls debugging mode is set off.
controls debugging mode is set on.
±
als an
standard output file.  No interactive debugging environment exists yet.
Examples:
lesÁ  debugging mode.
	
ymbol or one of a special
ee below).

bed by the form of the first argument.
cro that expands into code to execute a function that
e value or other entity associated with a
are recognized by SETF for the
oo bar) is equivalent to (SETQ foo bar).
 thÿ
LACA a b).
T  - (SETF (PLIST a) b)     like (SETPLIST a b).
 c)     like (RPLAÿ
ke (RPLACD (NTHCDR (SUB1 a) b) c)
SET a b c)
  - (SETF (GET a b) c)     like (ÿ
a)       like (SETALIST a)
imilarly to CAR and CDR.)
HOD property.

quivalent, because:
s value.
 c are

TF requires exactly two arguments).
 the above) for the first argument.
must match the typical syntax
n error.
der the compiÿ
nent of
`(CAR ,X))
 'BAR)
LE)
both into one form as follows:
CRO MYMACRO (X) `(CAR ,X))
en invoked by the compiler,
ironment; the
ls
ETQ if the first
y
as an error.  Use SETF with caution.
sually involves destructive
ic caveats apply.
a list
his may cause further references to the in-line constant list
t.

TF recognize a form by placing a
roperty of a functionÿ
the macro

(FOO BAR))    ==>   (FOO BAR)
SETF (CAR A) 'BAZ)    ==>   BAZ
SETF (CDR A) 'FROB)   ==>   FROB

                 ==>   (TYPE INPUT CAPS OFF JUST LEFT)
        ==>   (TYPE INPUT CAPS OFF JUST LEFT)
=>   OFF
      ==>   ON
EFT)
Syntax:   (SET-FEATURE arg1)
d, evaluated) - a symbol.
after arg1 has been added to it.
ures (which is the value of the global variable
a value which is EQ to arg1.  If one
 added to the list.
, which means that
EATUREP
URE (or SETNFEAT).

L12 (the latter identifies this as ZIL 1.2).  However, under the
here is a ZILCO feature as well.  (In fact, as a general
p-lÿ
TUREP 'ZIL)          ==> T
L13 CSDL DRAPER TSO MVS XA VF GC BIGNUM
CTURING FLAVORS LOÿ
RE 'FOO)
UM
FOO)          ==> T
 CSDL DRAPER TSO MVS XA VF GC BIGNUM
RING FLAVORS LOOP)

)
	
d from ÿ
ue of the global variable
 arg1.  If none
t.
ns
 for more information.
.
l ZIL environment, the only features present are ZIL and
dentifies this as ZIL 1.2).  However, under the
eature as well.  (In fact, as a general
 P there is a feature named P.)
e a "feature" that belongs
es:
    ==> (FOO ZILIN ZIL ZIL13 CSDL DRAPER TSO MVS XA VF GC BIGNUM
   MULTIPLE-VALUES DESTRUCTURING FLAVORS LOOP)
T
 Xd A VF GC BIGNUM


ed, evaluated) - a symbol.
 
nding cell of
 the contents of the value/binding cell
ntains.
r onÿ
lts are unpredictable
on is intended for internal use only, and is intimately
inding techniques. "  Do not depend on it!
les.  We don't want you fooling around with this.
©¡
arg1 (required, evaluated) - a symbol.
ty list.

g1; i.e. arg2

 error checking ÿ
 a non-atomic first argument is illegal and highly
ronment.
d.
lue1 indicator2 value2 ...)
", etc.
operty
 second argument will cause the GET, PUTPROP, and REMPROP functions
disastrously, as well as other functions (including EVAL)
 property list of the atom.
structively, SETPLIST
e compiled
E (form1 form2 ...)).  This will cause further references to the
onstant list to be incorrect.
BAZ (FROB NICK ATE)))
             ==> (FOO BAR BAZ (FROB NICK ATE))
 BAR
(FOO BAR))  ==> A
FOO)             ==> BAR
T 'A NIL)         ==> A
 'FOO)             ==> NIL

 
                           function of 3 arguments.
 SUBR that impleÿ
the "current ZIL printer".
y arg1 is made the "current ZIL printer" by
 SUBR wrapper inserted by ZILSPÿ
 access the current ZIL printer.
 as the "current ZIL
ow to specify the function to
w it is used.
ur printer function!!!!!!!).
ce to setting the "current ZIL printer".
s should use ZILSPRT and create a
printer".
C)))
; (i.e. the ones that are sensitive to the special variables
owever, ZILSPRT is the recommended way to do this.
  
ccur in pairs: arg1 and arg2.
.
heÿ
ch pair has been bound to the value specified by the second
pair.
urrent binding ofÿ
to refer to the
arg1 is set
g is not saved but
or in a compiled MODULE, if the
essage is issued and a
and set its value.
mpiled code

to its value before the next value is determined.
 the values are extracted before any
gnaled:
lid first argument.
a-list variables, this use is not
 to act in the way that
uages.
where;
ic
of a local SETQ assignment is limited to the extent of the
hen the binding disappears,ÿ
vious binding of the variable was
ing is "uncovered" in
 
may be shadowed by local bindings, but they remain until undone
ND (not recommended!).
 association list,
 and to
 CAR of a pair is a symbol and the CDR is its value.  Variable
ntry to a function or PROG are effected by pushing
ist; the previous alist pointer becomes
unction or PROG.
ocal variables,
that th+

    (SETQ A '(HI THERE))        ; ==> (HI THERE)
     ; ==> HI
·
)
))
         ; ==> (HI THERE)
) HI (HI THERE))
 THERE) (1 2 3))
the values of
 (X Y Z)
 "junk")
              ==> (XX YY ZZ)
bindings are sequential,

        ==>  (0 0 0)
  B)
À	À
required, evaluated) - a LISP object that can be invoked as a
               function of 6 arguments.
mpÿ
 ZIL reader".
e the "current ZIL reader" by
inserted by ZILSRÿ
ent ZIL reader.  This
 ZIL reader".
tion to
rrors signaled:
!!).
nt ZIL reader".
reate a

akes a fictional bunch of read functions active.
ecommended way to do this in this case.

 evaluated) - an association list
tted pairs).
e binding environment set to it.
L variable binding environment is replaced with arg1.

ain plÿ
extremely dangerous
F (SPECIAL-ALIST) arg1) is the preferred way to express this,
want to do it.
 depending

 (MAKUNBOUND 'A)           ==> A
TSALST '((A . 1) (B . 2)))

      ==> T
==> 3
. 3) (B . 2))
 
a one-character symbol, string or fixnum.
 or SINGLE.
s: 
ro
 is MACRO:
acter
se, the character specified by arg2 is associated with the
nction specified by arg3.  This is done via the
.
racter specified by arg2 is
 returns itself, so
uild a
  character as a one-character symbol name.  Naturally, this does
y when the character occurs in a string or is delimited
rtical bars.
or MACRO):
 NIL)
s signalled by DEFRDMAC or RDRMACRO (q.vÿ
Maclisp and Franz LISP function; in those dialects,
, but in ZIL these are the only ones
o DEFRDMAC and RDRMACRO
documentation on READ, DEFRDMAC and RMCHAR for more information
cro processing.
us:
Ä
will be returned by READ:
preter, this will be evaluated by EVAL
 
the following is read in:
, and then the symbol FOO.
r the interpreter
"  'MACRO NIL) will turn off processing of the ? macro.
RO NIL) will turn off processing of the ! macro.

uired, evaluated) - a list.
st1, or NIL if list1 has less than 7 elements.
ÿ
ee CAR, CDR, etc.

==> NIL
é
NGLE-FLOAT-P arg1)

nÿ
LOATP, which returns T if its argument is a double-float;
returns T for any kind of flonum.
 NIL
0) ==> NIL
NE)  ==> NIL
tax:   (SIGNP arg1 arg2)
GE, or G.

 NIL.
ds, T is returned:
---

                arg2 >= 0
that arg1 is NOT evaluated, but arg2 IS.
e.
ers don't use.

luated) - a number.
1, where num1 is expressed in
RTRAN subroutine library interface is used to compute the
If num1 is a single-precision flonum, the
m; otherwise the result is
d:
han 823549.5625.
0.125.
will successfully process.
FORTRAN subroutine library interface
f this documentation for
rted as arguments to this function.

5) ==> 0.479425538604203

required, evaluated) - a list.
ist1, or NIL if list1 has less than 6 elements.
XTH x) ÿ
 CAR, CDR, etc.
 
L
 
luated) - a positive fixnum.
IL system in a wait state for arg1 seconds.
MER macro instruction is issued to cause ZIL to wait for the
r of seconds before processing resumes.
ot a positive fixnum.
Function: STRING-LENGTH
NGTH arg1)
 

th of the string is returned as an integer.
 functions, a symbol is accepted for the
engÿ
:
ING-LENGTH "")    ==>  0
")  ==>  1

2)
g.
ing built by removing all characters present in bag1 from the
str2; in other words, leading characters are removed.

ing for charÿ
of str2 from the first character which is not part
rs signaled:

permitted; their print names are used in that case.  However, this
always returns a string.
 to be specified
d as a
È
ar")  ==> "foobar"
ING-LEFT-TRIM "fb" "foobar")  ==> "oobar"
==> "BAR"
ax:   (SOME arg1 arg2 ... argn)
 that can be APPLY'ed.
(optional, evaluated) - a proper list.
f the values produced by applying the first argument
elements (CAR's) of the other argument lists
 value thus generated.
the first argument is applied to each of the
pecified by the other arguments, until
n-NIL value is produced by this
 returns that value.
²
, NOTEVERY, and the mapping functions.
RP NILÿ
(SOME #'INTEGERP '(1 2 3 4 5))    ==> T
> T
))    ==> T
) '(A B C D))   ==> T
EQ '(A B Z) '(A B C D))   ==> T
NIL A NIL B NIL))  ==> FOO
: SORT
valuated) - a proper list.
 be APPLY'ed.
 list1 in order according to the

ecified by fun2.
s NIL or
 than the other in the desired sequence.
 comparison function defaults to LESSP.
lter the lÿ
led:
led by fun2 or FUNCALLing of fun2.
efficient to use LESSP thÿ
re defined to take any
ional binary
t
rectly rather than using FUNCALL.
t is a feature unique to ZIL,
ESSP works on
less
This may not be a terribly fast implementation of SORT, but it gets the
done.  No error checking is done on the list argument beyond
t it is not an atom.  In other words, specify a list
r will have unpredictable results.
7))              ==> (1 2 4 5 7 8)
 B F ÿ
 '("the" "quick" "yellow" "wolf")
 (STRING-LENGTH Y))))
 "yellow")

- a proper list.
ed.
order, such that the
ecified by fun2.
dicate function specified by fun2.
guments and returns NIL or
of one argument is

.


ng the opÿ
P, SORTCAR is less efficient than SORT
on) because it invokes SORT
ever, omitting
e to
R '((Q 1) (W 2) (E 3) (R 4))) ==> ((E 3) (Q 1) (R 4) (W 2))
O) (O)) #'GREATERP) ==> ((O) (O) (F))

ed) - a number.
num1.
 used to compute the
 the
le-precision flonum.
ot a nÿ
tine library interface
tation for
nts to this function.ÿ
SQRT 9.0F0) ==> 3.0F0
5889
SQRT 2.0)   ==> 1.4142135623730951

G-REMOVE bag1 str2)
aluated) - a string.
 
.
 scanned for
ing
°
ing.
in that it removes
 end.

tion always returns a string.
 a list to be specified for
 which isn't even a
ed, NIL is
ÿ
ING-REMOVE "" "foobar")       ==> "foobar"
 ==> "foobar"
E "fobra" "foobö ar")  ==> ""

")  ==> ""

1 (required, evaluated) - a string.
of all the characters in arg1 in reverse oÿ
rors signaled:
unctions that take strings as arguments, symbols are
names are used in that case.  However, this
ng.
ING-REVERSE "A")              ==> "A"
"oof"

tax:   (STRING-RIGHT-TRIM bag1 str2)
g1 (required, evaluated) - a string.
	
n bag1 from the
d.
s scanned from the end
ult is a substring
t bag.
g.
s, symbols are
 this
s not permit a list to be specified
, NIL is interpreted as a

RIGHT-TRIM ""  "foobar")  ==> "foobar"
 "foobar"ä 
TRIM 'RA  'FOOBAR ) ==> "FOOB"
on: STRING-SCAN
5 str6 list7)
list7)
valuated) - a string.           Default: " " (blank)
ted) - a string.           Default: ""  (null)
 a string.           Default: ""  (null)
tring.           Default: ""  (null)
           Default: ""  (null)
gs.  Default: NIL
e "words" orÿ
 scanned and broken up into "words" or "tokens"
ions of the optional arguments as follows:
fier, which is a "bag" of sÿ
e (in other words, the occurrence of any
hitespace bag" marks the end of a
e, " ," would specify that blanks and commÿ
racters.
only
haracters appear anywhere in the


    str1 that is found in this "bag" gets
ter string in the resulting list.
cify that the standard arithmetic
ingle-character strings.
cters.
         two-character string, which defines a "quote" character.  The
   first character of the string defines the character to be used
 quote strings, and thÿ
 for embedding the quote character in the string.  If
r string is specified, or the second character is
rst, the quote character is specifiedÿ
').  If the second character is a
, it is a "single escape"
is contained in the
  The string is constructed including the enclosing quotes and
ed embedded quotes or escape characters.  In this way the
 distinguish between quoted and unquoted strings,
le for unquoting the string him/herself.
d if the ending quote of a string is not
racter is not followed by something.
ied, no quote character is used.
ÿ
RTRAN

Common LISP strÿ
 null string, meaning no quoting.
ot a "bag") which signals the
terminated by
 in
    strings can be specified.
tr6 is "", this represents
	

  end of a comment.
"*/", this represents

        specified, comments can be terminated only by end of string.
 list7: a list of multiple-character tokens (strings of length 2 or
more).  Each of these, if encountered in the string being
nds up as a token in the result, regardless of
the indiviÿ
e (an exception is if the
 or partially in
 to
      Any null strings in the list7 list are ignored.
le, if list7 is ("**" "<=" ">=" "^=" "->"), this
d operators in PL/1 to be recognized
he default is NIL, the null list, meaning that no
 tokens are recognized.
uired string
ƒ
r in the output list).  No quoting or commenting
ens are recognized.
acters or comment
Errors signaled:
 list of strings.
of ar+
e s canning str1.ÿç
g str1.
ents, symbols are
is true of
nt 7.
ke Common LISP, ZIL does not permit a list to be specified
e symbols are permitted, NIL is interpreted as aÿ
aracters N, I and L.  Note, however, that
pecified as NIL, meaning no
 
                    ==> ("a+b*c")
" "+" "b" "*" "c")

 " "" "'")      ==> ("'don''t'")
on/'t'")
")
foo" "bar")
              ("a:=if" "b=c" "then" "d" "else" "e")
hen d else e" " " "=" "" "" "")
"c" "then" "d" "else" "e")
" "" "" '(":="))
"else" "e")
"/" "*bar")

o//*bar" " " "" "" "" "" '("//"))     ==> ("foo" "//" "*bar")
bar" " " "" "" "/*" "*/" '("//")) ==> ("foo/")
NKLIB(IEFBR14)'" "" "()'.") ==>
IB" "(" "IEFBR14" ")" "'")
)'." "'") ==>

-TRIM bag1 str2)
ed) - a string.
 
ends of str2; in other words, leading and trailing characters are

anned from both the
 that bag.  The
 is not
ag.
.
IM and
ke strings as arguments, symbols are
 in that case.  However, this
ike Common LISP, ZIL does not permit a list to be specified
 symbols are permitted, NIL is interpreted as a
cÿ
foob"
") ==> "foobar"
ra" "foobar") ==_ > ""
M " " " a b c ") ==> "a b c"
: STRING
 string, symbol, or character
nd 255 inclusive).
ecified by arg1, as appropriate.
g, the same string is returned.
ned.

ed:
s is a Common Lisp function, and should be used instead of the
TOSTRING oÿ
nvert more types of arguments to string format,
works only on "characters", always
½
f)      ==> "f"
64)   ==> " " ;
ull string
Syntax:   (STRINGP arg1)

ng:

(STRINGP #(#\F #\O #\O)) ==> NIL ; not a "vector of characters" in ZIL
ú
rg1)
 
s signaled:
re used to create structures.
        ==> NIL
RE 'A 'B 'C)) ==> T
TP (MAKE-FOO))           ==> T
on: STRUCTURE
ent must be specified.
 must be a symbol.
rst argument and whose elements are
ing:
ents
d
ed values.

 symbol.

DEFSTRUCT to define and manipulate structures.

equired, evaluated) - a list in association list format
         (i.e. a list of dotted pairs).
per list.
nt 2, with all occurrences
uments if they
g:
of
 level of the list, if it is EQL to the
the association list specifiÿ
CDR) of the alist pair is

itutions (a la SUBST) in the target list, wÿ

Errors signaled:
o the validity of the arguments.  Unpredictable
second argument is not an atom or a proper
 not NIL or a list of dotted pairs.
A) (FOX . WOLF) (DOG . CAT))
LAZY DOG))
Å
         ==> (I HAVE A CONTACT)
 I))
T)
  (SUBLISQ arg1 arg2)
n list format

t consisting of the elements of argument 2, with all occurrences
s (at any level) replaced by other arguments if they
ified by argument 1.
 repeated CONS'ing) from the elements of
gument.
 first element (CAR) of some pair in the association list specifÿ
 first argument, the second element (CDR) of the alist pair is
or said atom in the new list.
to" mappings used to

.e. ASSOC rather than ASSQ).
es:
able
¤

(THE QUICK BROWN FOX JUMPS OVÿ
ROWN WOLF JUMPS OVER A LAZY CAT)
 . I))
TACT)    ; Test is EQ, not EQL.
cial Form: SUBR
ated) - a symbol or LAMBDA-expression.
iler:
 is

ct for the
ÿ
ated.
 is
the same definiÿ
ignaled:
r).
OAD and ZILXSUB for more infor÷ mation about SUBRs.
defines a lexical closure.  SUBRs do not
evaluated, unlike closures.
 SUBRP
ISP object.
ct), otherwise NIL.
ect that can be returned only by the
l form in compiled code only.
ng a
s signaled:
)            ==> NIL
R))  ==> T
ntax:   (SUBST arg1 arg2 arg3)
ject.
È
ist consisting of the elements of arg3, with all occurrences
 level) replaced by arg1.
 returned as is.
ed CONS'ing) from the elements of
 found within the list
ted for it in the
ly substituted.
ignaled:
 form), used to do a full copy of a
se COPYÿ
an EQL test for Common LISP
f Maclisp or Franz LISP
ZIL function
nd
est.
table
±
OVER THE LAZY DOG))
ER A LAZY DOG)


         ==> (PUT (OLD BOTTLES) IN OLD BOTTLES)
2.0 3.0))    ==> (2.0 2.0 3.0)
on: SUBSTQ
aluated) - any LISP object.
t should be a symbol.
Returns: 
es
arg3 is an atom, it is returned as is.
 built (through repeated CONS'ing) from the elements of
y arg3.  For each atom found within the list
then arg1 is substituted for it in the
 list are reÿ
est.
 NIL form) will NOT do a full copy of a list structure
 for this purpose.
ments.  Unpredictable
m or a proper
 for the comparisons.
ond argument.
UMPS OVER THE LAZY DOG))
PS OVER A LAZY DOG)
 BAR))
	

QL arg1 arg2 arg3)
g2 (required, evaluated) - any LISP object, but should be a symbol.
quired, evaluated) - a proÿ
ng of the elements of arg3, with all occurrences
aced by arg1.
 is.
 from the elements of
n the list
n the
ed.
AL.
 NIL form) will NOT do a full copy of a list structure
EE for this purpose.
ments.  Unpredictable
m or a proper
BROWN ÿ
BROWN FOX JUMPS OVER A LAZY DOG)
R) (FOO) FOO BAR))
O BAR) BAR)
N OLD BOTTLES))
SUBSTQL 2.0 1.0 '(1.0 2.0 3.0))  ==> (2.0 2.0 3.0)
§©§
    or:   (SUBSTQUAL arg1 arg2 arg3)
ISP object.
mbÿ

at any level) replaced by arg1.
 it is returned aÿ
repeated CONS'ing) from the elements of
h atom found within the list
substituted for it in
ecursively
SUBSTQL, which uses EQL.
	

 a list ending in a sublist which matches
uted.  This is because the algorithm
utable.  This is how Common LISP
it works in NIL.
s.  Unpredictable
or a proper
BROWN FOX JUMPS OVER THE LAZY DOG))
OWN FOX JUMPS OVER A LAZY DOG)
R) (FOO) FOOÿ
FOO BAR) BAR)
UT (OLD BOTTLES) IN OLD BOTTLES))
E)

BSTR string1 index2 &optional length3)
&optional length3)
  (optional, evaluÿ
 a fixnum or NIL.
tarting at the character at
o the end if
ndexing is used.
d as
.  This exists to
tring

n index2 from the beginning are made into a string.
e length of the string from index2 to the end.
length3) characters of string1 starting at
made into a string.
x2 to the end.
, the portion
ength
uested lengthÿ
valid.

ed.

lid second argument (not a fixnum or NIL).
num or NIL).
BSTR function, and is most
e of negative values).
ument to similar
 "frob" -5)        ==> ""
frob" -3)        ==> "rob"
rob" -1)        ==> "b"
" 1)         ==> "frob"
b" 3)         ==> "ob"
5)         ==> ""
ob" 1 2)ÿ
rob" 3 1)       ==> "o"
3 -1)      ==> ""
)      ==> ""
   ==> "b"
yntax:   (SUB1 num1)
 a number.
 - 1), of the same type as
or more information.
mation.
s:
> 1.0F0
000000000000000000
00000000000000000000000000000
n: SXHASH
any LISP object.
r arg1.
he contents of arg1, such
lue generated for
 the
 
 function may be used in various hashing algorithms
s, etc.
umber

ic; it returns a raw value between 0 and 2147483647.
 terminate on circular or ÿ
ns in the implementation; actually this is
e in ZIL.
mory
†
ction.
rned by SXHASH is
itself.)
ntax:   (SYMBOLP arg1)

g:
ke
 interned symbols and some created uninterned ones.
l.

    ==> NIL
YMBOLP (GENSYM)) ==> T
 NIL    ; strings are not symbols
ction: SYMEVAL
ed) - a symbol.
f the symbol arg1.
d.
urrent global or dynamic "SPECIAL" binding for the symbol is
 value, if one exists, is returned.
ÿ
a
o value (either because there is no binding or
lue).
t encouraged.
:") to
longer supported.
Ò
her an object to be evaluated is a symbol or not.
 occur if arg1 is not a symbol.
                   ==> FOO
 (DEFVAR FOO 'BAR)                     ==> FOO
         ==> BAR
L 'BAZ)                        ==> ("***ERROR***")
             ; Error - unbound variable.
   ==> A
                                   ; Error - unbound variable.
                         ==> ("***ERROR***")
       ; Error - unbound variable.
ocal lexicÿ
***")
(LET ((A 'NEW-VALUE-OF-A))
                    ==> Nu EW-VALUE-OF-A
   ==> ("***ERROR***")
nd variable.
yntax:   (TABS arg1 &optional arg2)
SP object, but generally T or NIL.
le name.
ff for the output file
g1 is NIL, tabs mode is set off for output file arg2.
s set on for output file arg2.
 handles the following characters
 X'05'   (horizontal tab)
)
 
ust like any other character (subject to minimal character
terminal is the destination to prevent terminal
de is on,ÿ
ze of 8 positions, and both carriage return and
ne to be completed and a new line begun.
anslated to the correspoÿ
as used to change this).
 and OFF for other files.
e to TABS mode; all
ivalency.
mbol 4 characters or less).
not be opened.
n file names.
 square

      for the standard output file.
n for output file FOO.
TAGBODY
 evaluated if a list) - a symbol or a list.

 follows:
rm is a symbol, it is not evaluated, but kept
an branch to.
 kept
ntegers can be used as GO tags much as symbols can, for
th Maclisp.
 is ÿ
 end of the TAGBODY is reached, it is terminated and NIL is
its value.
 special
tion
symbol or integer) in
ext form to
ors signaled:
is valid as long as it are lexically apparent in
it will be processed as long as it
on.  The following are
SOMETHING) (GO LOOP))

	
AGBODY LAB (SUMFUNK))
.

erpreter but not (as yet) in compiled code.
)
D ((NULL A) (Gÿ O END)))
              (SETQ A (CDR A))
               (SETQ A B)
=> (5 4 3 2)
ntax:   (TAN num1)
ns: 

face is used to compute the
flonum, the
 a double-precision flonum.
ment.
e precision, abs(arg) greater than 3537118876014220.125.
e maximum that the FORTRAN subroutine library

erface
urther information.
tion.
ould

lid.
 where

AN -1) ==> -1.5574077246549023
F0) ==> 0.5463025F0
	
- an output file name.
 the output file specified by the
rocessing:
 the
line, a line of blanks is written out.
 is reset to 1 when TERPRI is issued,
ks.
<
mÿ
 (not a symbol 4 characters or less).
 or could not be opened.
mation on file nÿ
nting functions
valent and return NIL after writing the
dard output.
line of

evaluated) - a list.
IL if list1 has less than 3 elements.
 same as CADDR.


 
(THROW arg1 arg2)
ally a symbol.
: 
 the

ck is then
ne is

a matching tag, an error is signalled.
uses a THROW to NIL, a CATCH with
e exists.
aluation
e the

hey possessed upon entry to the CATCH function.
WIND-PROTEÿ
urned to the end of the CATCH.  If
of one of these cleanup

tag is generally a symbol, though it does not have to be.
ccur in one of the following ways:


  in a THROW to tag NIL.
he terminal user pressing
n a THROW to tag T.
standard
interruptions.
ered to be a
f the
haracters ZILnnnn, where nnnn is a 4-digit number between 0001 and
t numÿ
ro is issued.
that tag
Errors signaled:

›
onal, evaluated) - any LISP object.
last form, after printing out the CPU time and GC time
ÿ
GC time are saved, then the forms are
ence between the run time
 can use this

  If any of the forms error out during evaluation, you still
splayed.
me if any.
 before


s: 
o arguments are ÿ
at argument is returned.

:
     ==> 4

)             ==> 4
==> 27.0
 

P object, but generally T or NIL.
ks like the printed representation of arg1
IN1 otherwise).
on is to occur.
string, ÿ
ned.
lt containing the characters that arg1 would use when it is printed
.
g is built that contains enclosing
 preceding any double quotes

he symbol, plus vertical bars and backslashes where necessary to
k the way it would be read in.
o TOSTRING, a string is
e when it is printed
ist, vector or structure; these objects cannot be converted
is function.

MAKE-STRING,
ommon
hi ÿ
(TOSTRING 01          )    ==>  "1"
 there\""
   ==>  "×foo×"

fun (optional, not evaluated) - zero or more function names (symbols).
eturns: 
being

fied, the list of functions for which tracing is
ed; no other action is tÿ
h function name in this list
ll be done of
is
SUBR's can be traced; FEXPR's and MACRO's cannot.
mpiled code to compiled code cannot be
ed indirectly (via FUNCALL).
cing off.

g.
LTRACE for technical details on how tracing and untracing

being traced.
	
S.
   (TRUNCATE arg1 &optional arg2)
.
es:
 (2) If arg1 only is specified, the difference of arg1 and the
lue.


result is obtained.  Otherwise, the argument is set to arg1.
ument is float, the fractional portion of the value is
nteger portion is returned as an integer.
tself is returned.
±

s
ual to its argument.
 in ZIL 1.3.
ection) may

st value is shown in these exÿ

TRUNCATE 1.9)             ==> 1
TE 1.2)             ==> 1
1)              ==> -1
            ==> -1
        ==> 0
    ==> 0
> 0

RUNCATE -0.9)            ==> 0
E 7E-4)            ==> 0
123.45F0)       ==> -123
CATE 2147ÿ
3648
  ==> 2147483649
47483647.0)   ==> -21474ÿ

 -2147483648
83649.5)   ==> -2147483649
CATE -10 3)           ==> -3
E -9 3)            ==> -3
 TSO
tring (or symbol).
e from the TSO command or CLIST
concatenating the text
guments are concatenated to form a character string buffer which
to contain a valid TSO command or CLIST, and it is executed.
guments are specified, a null buffer is built and executed
 (at least at this time).
 when the command or CLIST
ST returnÿ
rned as the TSO

he TSO
 execute the ISPEXEC command with this function, or a CALL to
 requires APF authorization (like IEBCOPY).  (You can use
d to invoke the CALL command if you wanÿ
's should not contain TERMIN or ATTN
s function is dependent upon the amount of system
me that the TSO command is attempted to be
ient virtual storage, the TSO command

s, vectors, etc.).
 has abended or was attentioned out of.
lable for this function to work.  TSO/Extensions,
except to invoke TEST or APF authorized
haveÿ
n the system link pack area or system
they reside only in a STEPLIB
SO 'TIME) ; will diÿ

  ; will dynamically allocate ZIL input file FOO and return
 ==> 0  ; if the allocation was su– ccessful,
location was unsuccessful.
.ZIL.TEXT(" A ")'"))
;
 &optional arg2)
nal, evaluated) - an output file name.
ining the sum of arg1 plus 1ÿ
r pointer of the output file specified by arg2.
 ZPUTFPO function is invoked to update the current character
alue specified in the TTAB function is a zeÿ
formed into a 1-based column specification
See ZPUTFPO for more information.
ted by ZPUTFPO and ADD1 (q.v.).
ore information on file names.
t argument may cause
eme caution.
r TTAB:
PO (ADD1 N) FILE)
alent, and permit the current
laid wit€ h new data.
file FOO to 10.

valuated) - an input file name.
ect.
 

ine is encountered on file1, in which case newlineval3 is retuÿ
ocessing:
 position

 the current character pointer is updated to point to the next


neval3 argumÿ
(i.e. fixnum 13).  NEWLINEP is also set to true for the file.
the next call to TYI will return either the first
ne, or end-of-file (note thÿ
 by the end-of-line condition unless the
file is encountered while reading the file, eofval2 is
.  If eofval2 was not specified, a fixnum ÿ
file is already in end-of-file status when TYI is issued,
led.
 characters or less).
e opened.
or more information on file names.
e the only functions that can cause
an input file (see NEWLINEP).
e allocated to the terminal
accessed by READ,
er wordÿ
mpare READCH, which returns a symbol.
efix))
                ==> NIÿ
st" :out)
$test" :in))
OO 'EOF 'NEWLINE)     ==> NEWLINE
(TYI FOO 'EOF 'NEWLINE)     ==> #\f
(TYI FOO 'EOF 'NEWLINE)     ==> #\o
(TYI FOO 'EOF 'NEWLINE)     ==> #\a

   finally (return t))   ==> T
 get to a newline.
fault newline.
ile.
ax:   (TYIPEEK &optional arg1 file2 eofval3 newlineval4)
l, evaluated) - NIL, T or a fixnum between 0 and 255.
ated) - a file name.
newlineval4 (optional, evaluated) - any LISP object.
A fixnum representing a character read from file2, unless end of file
ountered on file2, in which case eofval3 is returned;ÿ
countered on file2, in which case newlineval4 is returned.

 
).  One character is returned and made into a fixnum, but the
ter pointer is NOT updated to point to the next
alls to TYIPEEK without an intervening
urnÿ
 the scan continues
 is NIL,
r
 newline and carriage return) are skipped over and the first
character to be "peeked" at is returned.  If arg1 is
teger between 0 and 255), charactÿ
g arg1 is found.
file, then if the
d; if the
D) is
han CR, in which case the CR is skipped and the next character read).
f end of file is encountered while reading the file, eofval2 isÿ
s the value.  If eofval2 was not specified, a fixnum -1 is
pplies no matter what the value of arg1 is.
nd-of-file status when TYI is issued,
are TYI, which is identical to TYIPEEK except that it updates
aracter pointer (and also causes "newline" to be set).
	
ified input fÿ
f file.
mes.
uch
Õ
 and UNTYI has not been thoroughly examined.
should return the same character that

H
"profile prefix(" (userid) ")"))

 file "~&?foobar a b c~%")
 t
NEWLINE)    ==> NEWLINE
 swallow first newline
or a character
I FOO 'EOF 'NEWLINE)     ==> #\f      ; Swallow the character.
(TYIPEÿ
\o      ; Swallow the character.
)) ==> #\o

NEWLINE)     ==> #\b      ; Swallow the character.
 FOO 'EOF 'NEWLINE)) ==> #\a
low the character.

ETQ A (TYIPEEK T FOO 'EOF 'NEWLINE))   ==> #\a ; skip over blanks
EOF 'NEWLINE)     ==> #\a      ; Swallow the characÿ
EEK #\c FOO 'EOF 'NEWLINE)) ==> #\c ; skip until c
   ==> #\c      ; Swallow the character.
foo) #\sp)

YIPEEK NIL FOO)           ==> #\cr
(TYIPEEK NIL FOO 'EOF 'NEWLINE) ==> NEWLINE
Nÿ
 ; Read the next one.
y to get TYIPEEK NIL to return
g.
EOF.
  (TYO char1 &optional file2)
tween 0 and 255.
Returns: 
inted on
character position on the current line
ZPUTFPO functions can change
ion is updated to point to the position
cter written.
a symbol 4 characters or less).
could not be opened.
on on file names.
functions.
nt b and return A after printing...
        on the standard output file.
Function: TYPEP
uired,evaluated) - any LISP object.
fier (see below).
tifying the type of arg1.
 specification
arg2 is omitted, one of the following symbols is returned,
typÿ
AT, STRING,
 an instance of a flavor, the name of the flavor is returned

.e. the zeroth element), provided that this is a valid symbol.
ture type is not a valid symbol, STRUCT is returned.
he type cannot be determined as oÿ
f arg2 is present, it must be a valid type specifier as follows:
symbol.
pe-specifier1 type-specifier2 ...)
2 ...)
 (SATISFIES function-of-one-argument)
urn T if:
at type:
_____________________________________________
ATOM
      SYMBOL              SYMBOLP
FLOAT, FLONUM       FLOATP
LOAT        SFLOATP
      BIGP
STRINGP
Á
  FUNARG              FUNARGÿ
ote: For compatibility and convenience, the following are accepted:
HORT-FLOAT for SINGLE-FLOAT
STRUCT for STRUCT
eroth element of arg1
ARACTER and arg1 is a fixnum between 0 and 255
 and (TYPEP arg1 x) is false
PEP arg1 xn) is true for ANY
 x2 ... ) and (TYPEP arg1 xn) is true for ALL
is a list (MEMBER x1 x2 ...) and arg1 is EQL to any of the
r, these are not evaluated, since they are already


rds,
signalÿ
tes:

eturn NIL.  On the otÿ
T, since all objects are assumed to satisfy type T.
TYPEP NIL)                        ==> SYMBOL
    ==> SYMBOL
. B))                   ==> LIST
NG
            ==> FIXNUM

                ==> DOUBLE-FLOAT
UM
            ==> FUNARG ; if interpreted
=> CLOSURE ; if compiled
TYPEP NIL 'SYMBOL)                ==> T
=ÿ
             ==> T
'(AND ATOM SYMBOL))      ==> T

    ==> NIL
YMBOL))           ==> NIL
(TYPEP 1.0F0 'FLOAT)           ÿ
  ==> T
              ==> T
0D0 'DOUBLE-FLOAT)        ==> T
> FOO
(TYPEP A)                          ==> FOO
  ==> T
() () )            ==> SHIP
(TYPEP A)
                 ==> T
 A 'STRUCTURE)               ==> T
LONUM)))   ==> T
ISFIES ZEROP))       ==> T
))   ==> NI+
ATISFIES  ZEROP))     ==> Tÿç
           ==> T
ARACTER)             ==> NIL
(TYPEP "a" 'CHARACTER)             ==> NIL
    ==> T
yntax:   (UCONCAT &rest args)
at is not a list, vector,
ted lexical closure.
nt name consists of args concatenated to
ssing:
y have
ls,
ernally generated values for other types.  The resulting character
re concatenated together to build a symbol whose name is that
 symbol is NOT interned on the oblist.
ith a null print name is returned.
r, structure, or funarg found as one of the arguments.
his isÿ
T except that it
which may be used to create numbers as well as
s; and STRING-APPEND,ÿ
amples:
  ==> A
==> ×foo×
ar") ==> ×71.0foobar×
TQ B (UCONCAT "F" "O" "O"))    ==> FOO
 NIL ; not interned.
TL
per list of atoms.
ame consists of the atoms in the list
rm a new atom name.
e a non-null list of atoms, are
hat they have when printed
r symbols, the text for
internally
s are

nt name is
oms (nested lists and vectors are not permitted).
e CONCATL, which ÿ
ed symbol.
ficient.
ficient.

 ==> FOOBAR
 
                  ==> NIL
NEBCDIC
a string or symbol whose text or print
1 character.
 of the single-character atom

is used to construct the fixnum which is its EBCDIC value.
aled:
es:
NEBCDIC (EBCDIC x)) does NOT return x if the value of x is not
 255.
a×)      ==> 129
24
(UNION arg1 arg2)
(required, evaluated) - a proper list.
ing all the elements of both argumÿ
t is constructed from the elements of the two arguments;
s once in each list argument, it will occur
arantee is given with respect
mes a given element
ut lists.
est.
ng is done as to the validity of the arguments.
ccur if the first and second arguments
s:

(UNION '(A B C) '(D E F))         ==> (A B C D E F)
E I O U)) ==> (B C D A E I O U)
)

g1 arg2)
, evaluated) - a proper list.
he elements of both argÿ
tructed from the elements of the two arguments;
 each list argument, it will occur
s given with respect
en element

²
 as to the validity of the arguments.
e first and second arguments

      ==> (A B C)
 '(A B C) '(D E F))         ==> (A B C D E F)
 U)) ==> (B C D A E I O U)


EYWORDIFY arg1)
 - a symbol.
e print name of
ing:
 interned symbol is created whose print name is equal to
rg1 without the initial colon.
mbol.
oes not have true
name starting
 evaluate

  ==> B
 TEST
	
required, evaluated) - any LISP object.
P object.
 args; otherwise, NIL.
e rest of the arguments are evaluated as an
st of them.  Otherwise processing
rors signalÿ
 the reverse test.

 NIL;
.
NTRACE &rest funs)
n names (symbols).
ivated for the functions named inÿ
rands are specified.
ing is deactivated for all function
d for each function name in
 to activate function tracing.
 not a symbol.
description of tracing and
 See ZILTRACE for technical details on how tracing and untracing
d.
s in the
ctivates tracing for function FOO.
racing for CAR, CDR, and CONS.
on: UNTYI
 
nal, evaluated) - an input file name.
LISP object.
turns: 
 or

in which case newlineval3 is returned.
r most recently read by TYI or TYIPEEK from the input
1 is returneÿ
YI or TYIPEEK will return the character
 magically placed back in the file.
acter.  If UNTYI is invokedÿ
 or TYIPEEK, an error is
nt is used as a check to insure that
hink you are.  If the character
 an error is signalled.
ect (not a symbol 4 characters or less).
ed or could not be opened.
t of sequence (see above).
ormation on file names.
efined, but the         se
Use at your own risk.
 (tso ("profile prefix(" (userid) ")"))
==> NIL
ormat fÿ
  t
e &aux a)
'eof 'newline)
(TEST-UNTYI FOO)          ==> (NEWLINE NEWLINE NEWLINE)
      ==> (#\? #\? #\?)
T-UNTYI FOO)          ==> (#\o #\o #\N o)
 #\o #\o)
        ==> (#\a #\a #\a)

:   (UNWIND-PROTECT protected-form &rest cleanup-forms)
(required, evaluated) - any LISP object.
P object.

rs during its evaluation, in which case the value returned by
 if an error) is returned.
uated first.  An UNWIND-PROTECT frame is created
ated; the frame is then deactivated
 cleanup-forms are evaluated.
rm a non-local exit of any
tected form to abort
nup forms are
s place as
 The UNWIND-PROTECT frame stacked by UNWIND-PROTECT is removed when the
uation of the protected form is complete (or when a non-local exit
 Thisÿ
luding the current variable binding environment; thus,
 restored to the status they possessed upon entry
de.
IND-PROTECT).
	
or perform otherwise essential codeÿ
r should occur.  See a Common LISP or other manual for more
he usefulness of UNWIND-PROTECT.
 the protected form or the
there is a PROG which
OTECT 'A 'B) ==> A ; Trivial case.
HROW 'FOO 'BAR) (PRINT "FROB"))) ==> BAR

rg1)


DIC bytes and


ç
SE string1)
 - a string.
at all lower-cÿ
 equivalents.

er, the returned value is alwÿ
nvalid first argument (not a string).
ild the result.
s:
 ==> "A"
 ==> "FOO"
r×)  ==> "FOO BAR"

O userid or NIL if not in a TSO environment.
eground, or in TSO in batch, a string whose contenÿ
hat you logon with (in batch, this may return a null
der which you submitted the job, depending on
her than TSO batch, USERID returns NIL.
.
	
on
 
st args)
ted) - any LISP object.
rguments, as multiple ÿ
 the first argument is

 (like
tly
‡
rned as multiple values - or, more accurately, as maÿ
 requested are returned.
the time that VALUES is
an tail-recursive
ate, or to set
of the

leÿ
ch returns all the elements of
 See Guy Steele's "Common LISP: The Language", pp. 133-139, for
on of multiple vaÿ
T is not defined in ZIL, returning more than
ported.
orm
eturn of a single value; this is useful in cases where form is
unction that normally returns more than one value
ctly one value only.
more expensive than
values from
hat
 is guaranteed not to cons in ZIL.
     ==> NIL

=> NIL
LIST (VALUES 1 2))       ==> (1 2)
==> (1 2 3)
 
t (required, evaluated) - a proper list.
pecified by the elements of list1, as multiÿ
 are not being requested, the CAR of list1 is returned,
IL.
cial form (like
hat directly
 in

lues as are being requested are returned.
ltiple values at the time that VALUES-LIST
 being executed in other than
o a funcÿ
alue returned is
returned as
).


teele's "Common LISP: The Language", pÿ
ltiple values in LISP.  Although the constant
efined in ZIL, returning more than

 just consing up a list of the values and extracting the values from
t via destructuring.  In any case, out of all the forms that
e values, only MULTIPLE-VALUE-BIND in compiled code
ons in ZIL.
S-LIST '(A))     ==> A
)) ==> A
-VA¶ LUE-LIST (VALUES-LIST '(1)))      ==> (1)
LIST '(1 2)))    ==> (1 2)
 (1 2 3)
ax:   (VCOPY arg1)

ts of arg1.

VECP).
ontiguous instances
d funargs
y
  ==> #(FOO BAR BAZ)
CTURE 'A 'B 'C)) ==> #.(STRUCTURE 'A 'B 'C)

uated) - any LISP object.
object, otherwise NIL.
an object which is composed of contiguous
.e. an object on which it is

 are all Vÿ
les:
    ==> T
  ==> T ; if interpreted;Á  NIL if compiled

r of arguments may be specified.
 

ified, and the elements are initialized to the specified values.
signaled:
…
nment, but in the compiled environment the former builds a new
he specified elements each time it is executed, while the
orted by the compiler (atÿ
dified during execution of the program, you
uild then dynamically from compiled
ECTOR)               ==> #()
 'A)            ==> #(A)
) 'C)     ==> #((A B) C)

 arg1)

 signaled:
P.
mples:
          ==> T
RE 'A 'B 'C)) ==> NIL

-VERIFY string1 string2 &optional index3)
ng2 &optional index3)
ing2 (required, evaluÿ
sitive fixnum.
cter within string1 that
th the search
ng1 if

String1 is searched from either the beginning (if iÿ
defaults to 1) or the offset specified by index3; when a
in string1 that is not a member of the set of
2 (in a case-sensitive character
 character within string1
acters that are
 the null string, NIL is always returned, as there are,
tÿ
ays returned, as, trivially,
string2.
tring1,
ng functions, symbols are acceptable for

id second argument (not a strinÿ
fixnum).
unction; the optional
s to a similar
hought of as a specification of a table of
t as the index of the first "bad"
useful in checking that
tively, it may

 third arg is NOT equivalent to specifying a SUBSTR
serve the examples.  This feature may be
equence of tokens.
 NIL
   ==> 1   ÿ
L
obar" "abor")       ==> 1     ; Stopped at "f".
   ==> 2
same as
)          ==> 4
ERIFY "foobar" "abfr" 1)        ==> 2     ; Search "foobar".
" "abfr" 2)        ==> 2     ; Search  u "oobar" only.
r" 3)        ==> 3     ; Search   "obar" only.
     ==> NIL   ; Search    "bar" only.

 evaluated) - a vector.

ssing:
 If the vector is of length zero, nothing is done to it.
:
FILL #(G ) 'FOO)           ==> #()
 (VFILL #(A B C) 'FOO)      ==> #(FOO FOO FOO)
>  #((1 2 3) (1 2 3) (1 2 3))
n: VLENGTH
- a vector-type object.
ber of elements in the vector
ctor.
ually the same as

y VECP).
 name is still
is an object composed of contiguous instances
, vectors, ÿ
r-type objects that satisfy
VLENGTH #(FOO BAR BAZ))       ==> 3
 (VLENGTH (MKVECTOR 10))  ‡       ==> 10
3
VLIST arg1)
Returns: 
1.
ments of arg1.
ct (does not satisfy VECP).
 object composed of contiguous instances
ectors, structures and funargs
e objects that satisfy
 #(FOO BAR BAZ))  ==> (FOO BAR BAZ)
LIST (MKVECTOR 10))   ==> (NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)
STRUCTURE 'A 'B 'C)) ==> (A B C)
tion: VREF
valuated) - a vector-type object.
	
g:

set values in the vector.

 Index out of range (negative or greater than the maximum index for
or, which is the length minus 1).
 is an object ÿ
ZIL, vectors, structures and funargs
or-type objects that satisfy
(SETQ V (MKVECTOR 5))    ==> ÿ
   ==> FOO
 BAZ
O BAR BAZ FROB NIL)
        ==> BAR


ype (element 0) of the structure, use TYPEP.
 0)   ==> A
 'C) 2)   ==> C

a vector-type object.
(required, evaluated) - any LISP object.
r setting the index2'th element of vector1 to its value.
 
tor are indexed from zero to the length minus 1.  arg3 replaceÿ
ponding value in the vector.
ector.
pe object).
 (negative or greater than the maximum index for
ngth minus 1).
 same function.
ous instanceÿ
rgs
the predicate VECP.
L NIL NIL NIL NIL)
       ==> BAR
 ==> FROB
O BAR BAZ FROB NIL)
        ==> BAR


e.
 a D® ECLARE,


	

) - any LISP object.
rguments, if non-NIL) are printed to
ssing:
Ë
ment is not NIL, it is assumed to be a random LISP
ritten to the standard output file via PRIN1,
 values.
more

 output file, and a THROW to
to be passed back to the
†
ent is the object in question that is being warned about.ÿ
ent message level is greater than 1, no writing to the
takes place.
pare ERROR, which does a THROW to tag NIL to signal an error.
o such action.
	
 NIL.
t:
 output file and return NIL.
HEN
 - any LISP object.
turns: 
 args.
tes and NIL is returned.
s an implicit
	
st.
B)
if (F) ret) urns other than NIL, prints A and B and
s FOO.
Syntax:   (WITH-OPEN-FILE (filevar dsn &optional options) &rest body)
ilevar - a symbol that can be used as a lambda list variable.
ta set name (string or symbol).

lue returned by the last of the body forms, with the variable
levar being bound to the file returned by opening dsnÿ
 
ding filevar to the file returned by OPEN.  It then evaluates
in body under this binding, closes the file, and
om the body.  It insures (via UNWIND-PROTECT)
ter what happens during executing of

es:ÿ
ted
fied by filevar can be declared SPECIAL if desired.
when (null (prefixÿ
  nil)                          ==> NIL
out)
                    ==> TRY-IT
ead f)

g1 &optional arg2)
ional, evaluated) - any LISP object, but generally T or NIL.

	
and
 not NIL, the symbol is interned on the
²
 performs the reverse operation.
0)        ==> ×    ×
ç

ed) - any LISP object.
hose CAR is arÿ
g1 arg2) is identical to (CONS arg2 arg1), except for the
n of the arguments.
llection errors.
      ==> (B . A)
==> (FOO)
tax:   (XDEFLOAD fun1 sym2)
.)
	
ialization routines).
EFLOAD, except that
.e. at other

DEFLD for more information.
EFMACRO
syntax is identical to that of DEFMACRO.)
t DEFMACRO returns.
NTERPRETIVE macro definition to occur
routines).
xcept that
 other

the same relationship to DEFUN, and may be used to
TIVE funcÂ tion definitions.
DEFUN
ntax is identical to that of DEFUN.)
blishing a function definition for that argument in the
t.
efinition to occur
 Under the interpreter, XDEFUN is identical to DEFUN, except that
e used in places where DEFUN is not allowed (i.e. at other
.
e DEFUN.
RO, and maÿ
s:
EVAL (CAR X) A)))


1 &optional val2 doc3)
 

n routines).
ept that

rs signalled:
AR for more information.
NCLUDE
) - a data set name (string or symbol).
sing the atom PROGN and all the forms in the dataset
th NIL as the last element.
data set specified by dsn1 are read and
a PROGN form with NIL as the
ould produce the
ors do not terminate the operation.
ected by OPEN and READ.
derlie’ s the INCLUDE and INCLUDEF
 not recommended but may

ING-TRANSLATE str1 bag2 bag3)
(required, evaluated) - a string.
 bag3 (required, evÿ
entical to string1, except that all characters occurring
d with their equivalents in bag2, respectively.
 input argument is not altered.
s, symbols are acceptable.

string).
ent vector/string space to build the result.
on is patterned after the PL/1 TRANSLATE built-in function.

E "Oobar" "Za" "Oo")  ==> "Zabar" ; watch out for case!


output file name.
 plus 1ÿ
utput file specified by arg2.
is invoked to retrieve the current character
on is invoked to updatÿ
 zero-based offset, which is
 by the macro expansion.
	
DD (q.v.).
 names.

 The following examples illustrate the macro expansion for XTAB:
3 FILE) --> (ZPUTFPO (ZILADD (ZGETFPO FILE) 3) FILE)
FPO (ZILADD (ZGETFPO FILE) N) FILE)
TAB 1 NIL) are equivalent, and cause the current
andard output to be "tabbed" over 1 space.
rrent column position of output file BAR
N  spaces.



 list.
 if the
lid argument (under the interpreter only).
re detected in compiled code; results are unpredictable
nt is passed.
iled code when
L.

 list1 (required, evaluated) - a list.
e CDR of the CDR of list1.
the third ÿ
ept that it is an error if the
ignaled:
	

te very efficient compiled code when
nt will never be NIL.
	
ADR list1)
	
 

 (under the interpreter only).
 compiled code; results are unpredictable
.
en
xamples:

d, evaluated) - a non-null list.
 list1.

r the interpreter only).
led code; results are unpredictable

 it is known that the argument will never be NIL.
AR '(A))               ==> A
 A2) (B1 B2))) ==> (A1 A2)
NIL)  is an error

any LISP object.
red, evaluated) - a fixnum.
depending on the caller.
unction that invokes the "current ZIL
default ZIL printer").
ify the function to
.
would not call ZCPRINT directly, unless you wanted to

slashify-p)
object file)))
Ì
 (if slashify-p #b0101 #b0001)))
amples.
ax:   (ZCREAD arg1 arg2 arg3 arg4 arg5 arg6)
 - a file object.
 evaluated) - any LISP object.
t.
ed) - any LISP object.
ng on the caller.
n that invokes the "current ZIL
ZIL reader").
tion to
rrors signaled:
all ZCREAD directly.  ZCREAD exists only
ndard ZIL input functions.

  (ZDPRINT arg1 arg2 arg3)
.
 - a fixnum.
e caller.
vokes the "default ZIL
nter").
n to
s signaled:
INT from a function you coded to
 wanted it to do
	
-p*
 arg2 arg3)))
Á
arg2 arg3 arg4 arg5 arg6)

ISP object.
ed, evaluated) - any LISP object.
ct.

"default ZIL reader"
‡
 as the "current ZIL reader", and how it is used.
 
ed input file is not allocated or could not be opened.
ou would generally call ZDREAD from a function you coded to replaÿ
urrent ZIL reader", if you wanted it to do "default" reader
ome paths.  For example:
g6)
o  arg2 arg3 arg4 arg5 arg6)
	

equired, evaluated) - a number.
lly zero, else NIL.
mericÿ
e; results are unpredictable
les:
1)        ==> NIL
(ZEROP 0.0001)    ==> NIL
T
ion: ZERROR
rg1 (optional, evaluated) - any LISP object, but generally a string.
ptional, evaluated) - any LISP object.
SP object.
ts, if non-NIL) is printed to
s issued.
essage, and is therefore
the first
argument is not NIL, it is assumed to be a random LISP
re written toÿ
he two values.
 be more
t
andard output file, and a THROW to
NIL to be passed back to the

argument is the object in question that was in error.
ssage level is greater than 2, no writing to the
place, but the THROW still occurs.
er than the error being requested!).
ve for a tag of NIL, this is considered to be a
ram is abended with a user code.  If the
first argument) begins with the
number between 0001 and
herwise a user
Q A 'VALÿ
r: Invalid argument - VALUE-OF-A
a THROW to tag NIL.
er printing
e.
  (ZEVAUTO sym1 &optional errp)
Æ
function definition could be foundÿ

function name
ed
TOLOAD property is a string, then it is the name of a
e loaded.
orm
 that the file or form,
defined as a
 an attempt is made to

 value of
 of
in the evaluatÿ
 a string or a list.  If it is a
however, if the attempt to
 NIL, ZEVAUTO
alled.
rs
f the AUTOLOAD property, it is
nment.  In other words,
evel.  In

oved during autoloading
restored

autoload property is removed anyhow.
 function (if errp is NIL).

wback:
fect of
is
mentation, may undesirab” ly treat these symbols as meaningful, when
 the ZIL-NO-AUTOLOAD property only reinforces the worthlessness
l (if it doesn't have any other features, that is).
¯¯

d) - T or NIL.
OADÿ
 run time.  arg1 is the argument
t of 2 symbols.
 level" (T)
²

EFLOAD, which can be used to invo÷ ke DEFLOAD at run
UN and XDEFMACRO).  The syntax is identical to
pands into a call to ZEVDEFLD.
on: ZEVDEFUN
luated) - a list.


st passed to DEFUN, with the CAR being the function name.
s whether DEFUN is being invoked at "top level" (T)
 See DEFUN for more information.
errors (invalid arg1).

XDEFUN, whic] h can be used to invoke DEFUN at run
 and XDEFMACRO).  The syntax is identical to
into a call to ZEVDEFUN.
VDSUB
) - a symbol.
Returns: 
n of sym1.
 in MODULE's that issue
2 as the SUBR
or macro definitions are removed from sym1

a COMPILED definition.
 closuü re, but ZIL

 arg1 (required, evaluated) - a list.


is the argument

or not (NIL).
d:
IL).
r.  Compiled calls
aces to.
t run
.
 
INIT)
ms initialization of the ZIL environment.  It defines
o definitions, and some funcÿ

rogram at


ion: ZEVLIST
aluated) - a list.
	
elements of list1.
ed in the evaluation environment
s returned.
is is an internal function used by the EVAL and APPLY.
	
EVMAPP mexp1 form2 prop3)
sion.
ated) - MACRO or CMACRO.
ng form2, using mexp1 as the macro expansion

 the MACRO or CMACRO property to be applied.
, which is the argument to the macro expansion

MBDA arglist ...)
n this is an extended
ordingly.
 way.
"
led:
d macro argument list generated by DEFMACRO is not
sp, because5  it cannot be applied by APPLY
day this may be straightened out.
FUNCALL to apply macro expansion
	
EVSET var1 val2)
red, evaluated) - any LISP object.
riable specified by var1 has beÿ

red to be val2;
 See SET for more details.
es:

umes that you have passed it
have not, results

evaluated) - a symbol.
BINDING (not the value) of the variable
ariable is unbound or bound to
 
 global or dynamic "SPECIAL" binding for the symbol is
ed, unlesÿ
e "unbound marker", in
ay be invoked if there is an AUTOVALUE
t currently have a
iable is the CDR of the binding.

ble

YM assumes that you have passed it
 bound symbol.
 property, as
n it is the name of a
VALUE property is a non-null list, then it is a form

n loaded or evaluated, will cause the variable name in question
fined.
ves
 a list. 
occurs
lue of the AUTOLOADÿ
nvironment.  In other words,
top level.  In
sible

 (required, evaluated) - a symbol.
t, or a function of no args.
g4 (required, evaluated) - a documentation string.
g1.
piled MODULE's.
 to ÿ
or
                          be called to establish an initial value
               (3) ÿ
            second argument is a constant or a
"thunk" (function of no arguments).
tation string.
ptional value documentation)
 no value...
,
riable is proclaimed to be SPECIAL
	
       its binding cell is filled in with a binding, consisting
   of a CONS of the symbol with its new value.
alue ...) is specified...
ECIAL binding,

that takes).
d,
              ÿ
  If there is a documentation string, it is made the
he variable's DOCUMENTATION property.
s not added if the variable iÿ
ment.)


 calls
 which can be used to invoke DEFVAR at run
FMACRO).  The syntax is identical to
 a call to ZEVXVAR.

        panel-library
t-appl
lize-function
el-init-function
 expr-list-function
    eval-expr-function
      bad-eval-function
       display-function
oÿ
-name           - a string identifying an ISPF display panel
       - a string identifying a partitioned MVS dataset.
   - a string deÿ
 describing the application.
t.
   - a function of 0 arguments.ÿ
guments.
nction   - a function of 2 arguments.
0 arguments.
eval-function   - a function of 2 arguments.
ion of 0 arguments.
display-function     - a function of 1 argument.
 function of 1 argument.
SEXEC"
   - "ZFSEXEC"
 keywords that identify functions are NIL, meaning
ot be used.
processes input and output,
til the ENDÿ
†
g loop which consists of:
-name keyword


processing the dialog input in accordanceÿ
 the caller, which will parse the input, process
ut, and generate an output display.
 in Lisp output which
er than
eywords are handled as follows:
ining the name of the ISPF display panel, as would be
EC "DISPLAY PANEL(...)" request.  If this keyword
 to "ZFSEXEC".  The panel must be similar to
which is available in the data set
 tutorial panels for the basic
NEL'ÿ
el-library for how the search for the panel name
ibrary
d MVS
is
single quotes must be included if the name is fully qualified (which
uld be if you want this applicatioÿ

rent ISPF panel setup, the :panel-library keyword is ignored.
found there, however, the data set specified by tÿ
d is hooked up (via the ISPF LIBDEF service)
, and the LIBDEF is undone at ZFSEXEC
-existing panel LIBDEFs will be
he case.
It is suggested that this
er with a version

d
escribing the application.  It should be brief,
This value getÿ
-exit-function
ments:
been

nction is called whenever a TERPRI is executed
s print trapper.  (Currently it does NOT
is executed, even if the CTERPRI
 this is the point at
, so the exit
  Purpose:  Since ZFSEXEC does not intercept READ operations, it has no
y of telling when the application will attempt to read input from
inal, and when the application does read input from the
ely unlocks the keyboard without sending out anyÿç
Therefore, if the application has a means of determining
 a READ is likely to follow, or if for any other
choing) it wants to do something with the
he exit.  Note that the exit cannot
 (e.g. it cannot prevent it
nitialize-function
  Arguments:
lable output
rvice.
 This functioÿ
t when ZFSEXEC starts up.
on which may or may not
 of the depth of
rameters
unction
:  None.
ed:  This function is called following termination of the
 when ZFSEXEC winds down following the ISPF "END"
…
ialization function.
 arguments, as follows:
rn value is not used.
e the panel display
lds are
perform additional panel INIT processing, such as
s of a sÿ
 perform the tasks normally

	
the user on the
ns:
   output display.
e dialog is about to
mand is
y

y input-retrieval (LEFT/RIGHT key) processing.
 way the input is displayed when it is echoed
/or to do additional processing (such as
liary file).  The contents of the
ormat and saved by the
 return value

dification, is echoed in high intensity on the output display.
st-function
nts:
É
t trapping function, used to capture all output.
 list of expressions parsed froÿ
 is a list of three objects:
t is reserved, and
each expression element is a Lisp object that
 be processed by the :eval-expr-function.
ession element is NIL if the "value"
ion is NOT to be displayed (via
 non-NIL value) if the
d:  This function is called when the dialog needs to process
put, which are assumed to be (possibly more than one)
typed in on the second input field.
o the format used by the application
rts disk or terminal input into
y be possibÿ
ns needs to be
ut string
	
ax
unless the code is executed under control of the "trapper" function
 as argument 2 to this function.  This shÿ
g lines:
 (let (expression-list)
bda ()
    ...
 null list is returned, resulting
is case, only the input is
hp-function
ents:  None.
SH" dialog service call is
nel fo+
valu e) ifÿç
lled:  This function is called after a process-and-display
ted for given user input, and before the panel
he new output.
er the decision
reen I/O,
e,
¤
f an input expression, which may involve screen clears or TSO output
causes full-screen mode to be turned off, an ISPF screenÿ
necessary in order to prevent the screen from being garbled.
on has the opportunity to override this to improve
 of screen destruction - in which case the
o view the correctly formatted screen.
aintain a global variable,
 do these screen
resh.
as if
of 3 arguments, as follows:
 processed ("evaluateÿ
ry on the expression list returned by

sion list returned by the :expr-listÿ
tput display is to be suppressed or not (NIL or a


ting") the
a Lisp
e

This function is called for each expression taken from
y the :expr-list-function, when the dialog needs
tÿ
takes care of error and attention handling.  The caller need
ut these.
ediate

assed as argument 3 to this function.  This should be done along
wing lines:
per)
'(lambda ()
     ...
sing is done, and thus
on

) A value specifying whether output display is to be suppreÿ
ot (NIL or a non-NIL value).


herefrom is non-NIL), before the display of the values, if any,
one.
"
val-functÿ
guments:  None.
 called:  This function is called when it has been determined
tion" done by the :eval-ÿ
second value returned
ing associated with unsuccessful "evaluation"
tting application variables.  There is
s, since an ISPF error message is
l-function
nts:  None.
alled:  This function is called after processing by the
n (whether successful or unsuccessful) and
.
t
ression, such as setting application variables.

) Thÿ
The return value is not used.
en it is time to display
er it has been
ose:  To display the value or values returned by each
been "evaluated" by the :eval-expr-function.
s 100% under control of the print ÿ
e to have Lisp print output go to
 
   message is generated if an error occurs.
provided, no output is displayed, except forÿç
ermediate output generated during "evaluation" and a
 

w row which is
 Returns:
s to
   same string or a modified version thereof.
ion is called whenever a new row is to
isplay, before the row is
sity attrÿ
he output line on the display,
 some other format, or

   padded with blanks to a length of 79 after it is passed through
nction.
to
s if an :output-row-function that merely returned the input
xecuted.
Notes:
ed
is is the underlying driver for ZIL-based interactive applications
 to use the full-screen interface.
ords, a dummy dialog (using the
s input from the user and
tput to display.
commÿ
lthough ZFSEXEC is designed to intercept all Lisp print operations
or low-level error messages or garbage collection messages),
ercept read operatiÿ
y is designed to behave like a top-level
ry Lisp code that issues read
interface that the
th (poorly).
plementation of ISPF
name           "XFSZIL"
'"
(string-append "ZIL Lisp " *version*)
          :initialize-function  #'fszil-user-initialize
e-function   nil
ut-function  nil
list
-expr-function   #'fszil-user-eval-expr
szil-user-good-eval
al-function   nil

 
(optional, evaluated) - an input file name.
representing the current character position of the
 arg1.
om the file block and
-based column value, and ranges from 1 to the logical
ut file.ÿ
.
 the standard input file.
r an input file is
 and TYI,

ied input file is not allocated or couÿ


  character pointer of the standard input file.
s the current character pointer of input file FOO.
Á§Á
Í
 A fixnum representing the current character position of the
ciÿ
obtained from the file block and
alue is a 1-based column value, and ranges from 1 to the logical
 of the output fiÿ
 standard output file (NIL), position 0 contains
haracter.  This value may be returned
t to that value and no PRIN1,
.
 the standard output file.
or an output file is
IN1 and TERPRI,
ed:
 Specified output file is not allocated or could not be openedÿ


          character pointer of the standard output file.
O) returns the current character pointer of output file FOO

 
number.

erlies PLUS and +.
rs signaled:
 
DD 1 2)     ==> 3
(ZILADD 1 2.0)   ==> 3.0
se of verification of

1 2147483646) ==> 2147483647
1 2147483648) ==> 2147483649
ADD 1 -2147483649) ==> -2147483648
(ZILADD 1 -2147483651) ==> -2147483650
)^4)) follows
026048) ==>

64247891967) ==>
ILADD ÿ
1
-1 0) ==> -1
47 2147483647) ==> 42ÿ
ADD -2147483647 2147483647) ==> 0
67294
47483648) ==> -1
47 -2147483648) ==> -4294967295

 -1
2147483648) ==> 4294967296
2147483648 2147483648) ==> 0

 -1) ==>  2147483646
 2147483648        -1) ==>  2147483647
7483648
 ÿ
(ZILADD        1  2147483647) ==>  2147483648
=>  2147483646
 -1  2147483648)+
648
483648) ==> -2147483649
ADD 1000000000000000000000000000000000000000
9999999999999) ==> 1
      999999999999999999999999999999999999999) ==> -1
37593543950336 -79228162514264337593543950335) ==> 1
37593543950336 79228162514264337593543950335ÿ
337593543950335 -79228162514264337593543950336) ==> -1
4337593543950335 79228162514264337593543950336) ==> 1
37593543950337 -79228162514264337593543950335) ==> 2
4337593543950337 79228162514264337593543950335) ==> -2
337593543950335 -79228162514264337593543950337) ==> -2
4337593543950335 79228162514264337593543950337) ==> 2
147483648) ==> 2147483647
ZILADD -4294967295 2147483648) ==> -2147483647
) ==> -2147483647
214748364ÿ
2147483646
00000000000000000000000000000000000000000000000000000000
000000000000000000000000ÿ
00000000000000000000000000000000000000000000000000000
            -100000000000000000000000000000000)
999999990000000000000000000000000000000ÿ
00000000000000000000000000000000000000
0000000000000000000000000000000)
0000000000000000000000000
00000000000000000000
0000000000000)
0000000
00
  ==>  99999999999999999999999999999900000000000000000000000000000000
 100000000000000000000000000000000000000000000000000000000000000
9999ÿ
                    100000000000000000000000000000000
0000000000000000000000000000000000000000000000000
9999999999000000000ÿ
    -100000000000000000000000000000000
00000000000000000000000000000000
0000000000000000000000000)
000000000000000000000š{
9900000000000000000000000000000000
000000000000000000000000000)
000000000000000000000

ired, evaluated) - an atom or proper list.
argument list.

rns: 
ment
hat fun1 must be.
 3)):
))
±
It has
nction name for error messages, which APPLY does not give you.
hand, it doesd  not have the flexible syntax of APPLY
ying the argument list.
t
 op1  (required, evaluated) - a fixnum between 0 and 15, inclusive.
quired, evaluated) - a fixnum.
ÿ
formed on

n operation
perations performed.
0 and 15 inclusive.
is the low-level 3-argument fuÿ

00FFFF #zF0F0F0F0)   ==> #z0000F0F0
 #zF0F00000
OL  4 #z0000FFFF #zF0F0F0F0)   ==> #z00000F0F
0F0)   ==> #z0000FFFF

FF #zF0F0F0F0)   ==> #z0F0F0000
F0FF0F0
#z0000FFFF #zF0F0F0F0)   ==> #zFFFFF0F0
   ==> #z0F0F0F0F
ILBOOL 14 #z0000FFFF #zF0F0F0F0)   ==> #zFFFF0F0F
0F0F0F0)   ==> #zFFFFFFFF
ILCLOSE
ted) - a file name.
 

essing.
contents
 for errors.
 member $FILE for more information on file names.
one.  Use CLOSE, not this internal function whose processing of
 change½  at any time.
IV
umber.
quotient of the two arguments (num1 / num2).
 is the low-level 2-argument function that underlies QUOTIENT and /
 member $ARITH for more information.
ero.
ember $ARITH for more information.
==> 3
)    ==> 2.5

	
ber name, if any)
essing:
.
 the string "*" is returned.  Otherwise file1 is accessed aÿ
, and opened if not already open, and the data set name and the
(if any) are retrieved from the JFCB for the file.
ed from both the dsname and the member, and
e name if a member is present.  Single
rs signaled:
this can't happen, can it?).
.

the file is closed under ZIL, issuing ZILDSNI against a closed
ll cause the file to be ÿ
ill normally return "*".
O.BAR".
PEN "'foo.bar(baz)'"))  will return "FO O.BAR(BAZ)".

le1 (required, evaluated) - a file name.
taining the actual data set name (and member name, if any)
ut fiÿ
follows:  If file1 is a terminal file (i.e.
ociated with the terminal by default),
e file1 is accessed ÿ
 the data set name and the
for the file.
r, and
e
id output file name.
 enough vector/string space to return string.
er $FILE for more information on file names.
e) allocation remains around even after
g ZILDSNO against a closed

NO (OPEN "foo.bar" 'out))  will return "ABC1234.FOO.BAR".
oo.bar'" 'out))  will return "FOO.BAR".
 ))  will return "FOO.BAR(BAZ)".
ction: ZILDUMP
ed) - a number or string.
ecimal representation of arg1.
m, a string of 8 hex characters representing the
eturned.
„
ÿ
 information about the internals of bignums.
 a string of 8 hex characters representing
aining the IBM/ÿ
acters represent the
 
the contents of the doublewordÿ
 is returned.  The first 2 hex characters represent the
he rest represent the mantissa.
aracters representing the
number of characters
rg1 string.
 
ex.
MP 4095)          ==> "00000FFF"
(ZILDUMP 2147483648)    ==> ("00000000" "00000001")
  ==> "80000000"
 1.0F0)         ==> "41100000"
DUMP " ")           ==> "40"
: ZILEDIT
 a data set name (string or symbol).
ing on whether the data set specified by arg1 was
tor has been invoked on it.
red on the data set whose name is specified
 T is returned; otherwise NIL is
ber name is specified, an ISPF member list
, this function is just like the
interface thereto.
set into tÿ
was entered under ISPF.
a LISP program
he Draper
SO/Extensions Authorized Service Facility, it will fail due to ISPF
ervices not being available.
 or a string, or a null string, or a strÿ
 
SPF or it is running under the TSO Authorized Service Facility
ronment where ISPF dialog services are temporarily
rrors detected by ISPF dialog services (data set not available, etc.).
otes:
n.
ny type of dataset, not just ZIL datasets.
ns.
 be put back into the same split screen mode when ZILEDIT enters ISPF.
The dí ata set is opened for output.  See HELP for OPEN for more
 on valid data set names.
")

 arg2)
y LISP object.
nal, evaluated) -ÿ
s of all the args are identical, else NIL.
QUAL, which takes exactly two args, the following holds.
nts are EQ, regardless of type, ÿ
rned).

ne argument is numeric and the other is NIL,
is a special case intended to handle
ters.)
d.
 member $ARITH for conversion rules) and the numeric compare is done.
If both arguments are strings or symbols, a comparison is performed on
print name or string text of the atoms.  Note that case remains
nt in this comparison.
 is signalled, since
h takes any number of args, the result is T if there is
all the argsÿ
; otherwise the result is NIL.
otes:

)         ==> NIL
  ==> T
Á
 (= 1.0 1.0)              ==> T
0 3.0 4.0)      ==> NIL
1 NIL)         ==> NIL

arg3)
quired, evaluated) - an evaluation environment.
 T or NIL.
evalation environment
ngs.
n is to be considered at "toÿ
ed:
ion that underlies EVAL.  It
onment to EVAL.

 
 LISP object, but generally T or NIL.
P object, but generally T or NIL.
ngle-character symbols or fixnums, corresponding to
tion of arg1 as printed out via PRINC or PRIN1.
1 is convÿ
nted - as it looks via either PRINC or PRIN1, depending on arg3.
haracter in this representation is then used to build either a
ter symbol or a fixnum, ÿ
gether to form a list, which is returned as the
s to NIL.  Processing is as follows, depending on the

is T, the objects generated are interned symbols.
objects generated are fixnums (characters).
rg3 is specified and non-NIL, the argument
t is printed out via PRIN1 (i.e. it is
sed as it looks when it is



ninterned
ned

PL '×007× 0   NIL) ==> (#\0 #\0 #\7)           ; all fixnums
 0   T  ) ==> (#\× Ë #\0 #\0 #\7 #\×)   ; all fixnums


 T or NIL.
ters ÿ
NIL, via PRIN1
racter positions taken up by the printed format
 the value.
LFLAT is the internal ZIL function that underlies FLATC and

P &optional arg1 arg2)
(optional, evaluated) - any LISP object, generally T or NIL.

specified by arg1.
d:
on that underlies HELP.
IMPL
d, evaluated) - a proper list of atoms.
P object, but generally T or NIL.
ject, but generally T or NIL.
me consists of the atoms in the list specified
nated to form a new atom name.
irst argument, which must be a non-null list of
character representations that they have
the actual print names for symbols,
tatioÿ
 resulting character
se name is that
th a null print nameÿ
IL, the resulting atom is interned on
ed (this is the default
er atom.
will
tax as the READ function would interpret it.  If the third
the atom created is always a symbol (this is

 true:
s

  In this case the setting of the second argument is significant.
ist notation (parentheses, dots, etc.) is not valid and will
ÿ
 by the code, and may
oint underflow is
signaled:
permitted).
    ==> A
      ==> FOOBAR
.
 (ZILIMPL '(F O O) T))     ==> FOO ; interned.
     ==> NIL
 0 7) NIL NIL)    ==> ×007× ; a symbol, not a fixnum.
T)      ==> 7     ; a fixnum.
n: INTEGER-LENGTH
 arg1)
ƒ
essing:
sent the

‡
ts are omitted.
:
s equivalenÿ
LENGTH 0) ==> 0
NTEGER-LENGTH 3) ==> 2

TH -3) ==> 2
TEGER-LENGTH #b1001001001) ==> 10
NTEGER-LENGTH 2147483647) ==> 31
NTEGER-LENGTH 2147483649) ==> 32
TEGER-LENGTH -2147483648) ==> 31
TEGER-LENGTH (** 2 60))            ==> 61
)     ==> 61
H (- (** 2 60)))        ==> 60
É
b
quired, evaluated) - a symbol (or string).
ed code object with the same name as arg1, if it exists in
ÿ
e 8-character load module name to be searched for from
f the first argument is not a string or a symbol,
characters, an ÿ
 in-memory module names; this table
sed modules that are likely
nds it, it returns
 If the module is not found this way, ZILLOAD then searches active
orage for the load module to see if it has already been
 it, it then proceeds to resolve the externalÿ
s (since these functions, if not resolved
oaded, may have been loaded in
rrently in memory, then the BLDL system service
irectory entry for the load module in the
 code of 8, meaning that either there
ry or not enough system storage
 processing probably cannot
 directory entry for
ts, ZILLOAD


the module is used to construct the compiled code object, which is the
 returned by ZILLOAD.
IL to indicate that the
esolve external references within the compiled code,
esolved by the linkage editor had the coÿ
  Each section of code contains a list of
 exists; these may refer to internal
 in turn have lists of external
ntire tree of external
ad process for
enever a
ternal reference cannot be resolved because the module cannot
OAD continues with the next one.  The pointer to the
compiled function is replaced with the address
that +
takÿ
 be caused by an
	

code object which is the return value.
 compiled function (the name of an internal ZIL routine was
BLDL error (the BLDL system serviÿ

amically under the interpreter.  The result is generally stored as
 of a symbol's SUBR property.
ed to execute the compiled code
LLOAD is invoked by the interpreter to resolve a function, it is
function's AUTOLOAD property if it has one and it is a
D special form is used to assign AUTOLOAD properties
interpreter.
 with them;
onment, the term "system library" refers to the task
 ZIL program was invoked, or the step library
ement in batch.  Thus, a zero return code
n to ZILLOAD ÿ
irectory entry came from an
stem link list or from
AD 'PUTPROP)  will locate thÿ
    compiled function and return a pointer to it.
ill return a pointer to the compiled code
ts the CAR function.
named COND, since
n NIL.
tax:   (ZILMUL num1 num2)
2 (required,evaluated) - a number.
 two arguments (num1 * num2).
el 2-argument function that underlies TIMES and *.
r more information.
 information.
	
.0
ollowing are included here for the purpose of verification of
MULTIPLY package.
>  12
) ==>   0
 -327ÿ
768) ==>  2147483648
67296          -1) ==> -4294967296
6
) ==>  4294967296
-1  4294967296) ==> -4294967296

=> -8589934592
         -1) ==>  8589934592
*           1 -8589934592) ==> -8589934592
-8589934592
       2) ==>  4294967294
2147483647           2) ==> -4294967294
94967294
83647) ==> -4294967294
     -2 -2147483647) ==>  4294967294
ÿ
 2) ==> -2147483648
      1073741824) ==>  2147483648

 ==>  2147483648
2147483647 -2147483647) ==> -4611686014132420609
==> -4611686014132420609
09

3648) ==> -4611686018427387904
27387904
3648           1) ==>  2147483648

=>  2147483648
   0) ==>  0
147483648) ==> -2147483648
         -1 -2147483648) ==>  2147483648

83649
 1) ==> -2147483649
3649    ÿ
 1  2147483649) ==>  2147483649

  2147483649
49) ==>  0
00000000  -1000000000) ==> -10000000000000000000
) ==> -10000000000000000000
00000000
000000 -10000000000) ==> -10000000000000000000
==> -10000000000000000000
000000
00000 -10000000000) ==> -100000000000000000000
==> -100000000000000000000
00000000
0000000000000000000000000000
) ==> -10000000000000000000000000000000000000000
000ÿ
0000000000000000000 -100000000000000000000) ==>  10000000000000000000000
0000000000
2993792
993792
792

(
(* -2147483648 -2147483648  2147483648) ==>  990352031428304219919299379
-2147483648 -2147483648 -2147483648) ==> -990352ÿ
4611686018427387903  4611686018427387903) ==>  2126764793255865395723754
37409
237540927630737409
647932558653957237540927630737409ÿç
4611686018427387903) ==>  21267647932558653957237540927630737409
000000000000000  100000000000000000000000) ==>  100000000000000000000000
00000000000000
1000000000000000000000000000000000000000000000
00000000000000000000000) ==> -100000000000000000000000000000000000000000
(* -10000000000000000000000 -100000000000000000000000) ==>  100Ó 0000000
0000000000000000000000000000
: ZILOPEN
ated) - a file name.
: 
sed

etermines the type of file access.  Its contents
 
 function underlies OPEN.
 names.
 whose proƒ cessing of

g1 arg2 arg3)
nal, evaluated) - any LISP object, but generally T or NIL.
valuated) -ÿ

d by arg1, or NIL if end-of-file or end-of-line is encountered
g for a character.
read from the current character position
 ZPUTFPI functions can change
to a symbol, but the
the next
READ
is identical to ZILPKCH except that it updates
er (and also causes "newline" to be set).
on-NIL, the generated symbol is "interned"
is not, in which case it will not be
3 is specified and is non-NIL, the character returned from the
lated to upper case before the symbol is built; otherwise
	

 has reached the end of the line) is encountered, NIL is
 a character.
 is issued,
id input file object (not a symbol 4 characters or less).
le is not allocated or could not be opened.
Notes:
ZILPKCH is designed for applications that need to do scanning in such
as not to "swallow up" a character in the input stream.  It is,
 perfect at this time, and its interaction with REAÿ
een thoroughly examined.
 NIL following the last
line, and also
 thus it may
eturns two
o do

lowing a ZILPKCH should return the same character that
the same atom if interning is not requested).
INEP; only ZILRD+
l (prefix))
                       ==> NIL
.$$test" :out)
foo.$$test" :in))
 (ZILPKCH FOO)                      ==> NIL ; newline
                  ==> #\CR ; swallow first newline
          ==> #\?  ; prime for a character
IL NIL)) ==> ×f×
'×f×)                  ==> T

       ==> T
 '×F×)                  ==> NIL
 
          ==> T
ç

ional, evaluated) - a file name.
 LISP functionÿ
rinted on the file specified by arg2.
symbol, its interpretive function definition is printed.
-expression, a fake DEFUN defÿ
ither case, the output takes the form
efinition.
ssigning
efinition specified by arg1 is printed
in such a way as to:

pretty printing."
a-expression.
its function definition may be a compiled code object).
n not a LAMBDA-expression.
ormation on file names.
1.1.  PP now takes
hem to
on definitions in output files, for
r a later ZIL session.
(zilpp 'foo 'out)
(cons b a))
 the standard output file:

ROGV varlist1 vallist2 closure3)
t of symbols.
losure3 (required, evaluatÿ
The value returned by executing closure3 in a SPECIAL variable binding
onment specified by varlist1 and vallist2.
V.
 the internal ZIL function that underlies PROGV, which is
acro which expands by turning the forms into a
 be kept in mind when compiling PROGV

rg2 arg3)
 evaluated) - any LISP object, but generally T or NIL.
ated) -ÿ
symbol whose print name is a character read from the input file
 arg1, or NIL if end-of-file or end-of-line is encountered
r a character.
 from the current character position
TFPI functions can change
 symbol, and the
 character.
s "interned"
not be
 the character returned from the
 symbol is built; otherwise
 (i.e. the current character pointer has reached
nd-of-line (i.e. the current character
ne) is encountered, NIL is
sed to determine
thÿ
ext
preceded by the end-of-line condition unless the file is empty).
 file is already ÿ
 signalled.
ymbol 4 characters or less).
not be opened.
$FILE for more information on file names.
 TYI are the only functions that can cause
t in an input file (see NEWLINEP).
ainst a file allocated to the
never been accessed by an
INEP will return
le is a
not change the current
lowing line of input from file FOO):
..
             ==> NIL
   AT2 (ZILRDCH 'FOO T  NIL)) ==> f

OO NIL T  Ò ) ==> F

m2)
d) - an integer.
num1 // num2).
unction that underlies REMAINDER.
 for a description of the
n, which is
uments are positive, the result is equivalent to the
on.
Second argument is zero.
otes:

-1

pad3 arg4 arg5)
ed, evaluated) - a non-negative fixnum.
cter (either ÿ
r a fixnum between 0 and 255).
 but generally T or NIL.
 0 or -1.
padded (using the character

s less than the length of string str1, in wÿ
length as str1 is returned).  The string contains the
ut to the length len2 using pad3 as the
IL, no truncation is done; the minimum length of the
be the length of str1.
len2 is less than
2
dding will be done, as follows:
be done on the right.  In
 
 words, ÿ
ng will be done on both sides.  In
	
.
s that take strings as arguments, symbols are
re used in that case.  However, this

ILSPAD "foo" 10 " " NIL  0)    ==> "   foo    "
)    ==> "       foo"
(ZILSPAD "foo" 10 " " T    0)    ==> "   foo    "
  -1)    ==> "       foo"

  ==> "foo"
" " T    0)     ==> "f"
ILSPAD 'something 20 "-" NIL 1) ==> "SOMETHING-----------"
ng 20 #/a NIL 1) ==> "SOMETHINGaaaaaaaaaaa"
) =Ç => "zzzzzzzzzzzzzzzzzzzz"
on: ZILSPKG
 - a symbol.
g1, which is actually not a
r or not the symbol
naled:
uld be SYMBOL-PACKAGE if Zil had packages, which it doesn't.

OO)        ==> T
 T
  (ZILSPRT arg1)
ct.
ified by arg1 as the
he SUBR specified by arg1 is made the "current ZIL printer" by
dress inserted in the field which is used by ZCPRINT
IL printer.
ction to
rrors signaled:
ed code object is a value that is returned only by the
Closures, whether compiled or interpreted, are not
 SETPRT to define the "current ZIL printer"
 be funcalled.
 
clisp-compatible Macsyma print functions active
sitive to the special variables
ˆ
ired, evaluated) - a compiled code SUBR object.
 after assigning the compiled code SUBR specified by arg1 as the
ÿ
 "current ZIL reader" by
sed by ZCREAD
ormation about ÿ
reader", and how it is used.

 only by the
 are not

  (ZILSRD (ZILLOAD 'MYREAD))
ompiler,
	·
num2)
d) - a number.
um1 - num2).
ction that underlies DIFFERENCE and
nformation.
tion.
Examples:

 
 
ied by arg1.
of a dataset containing only
ow).

tains test data following the word "Examples:" (which must be
 on the line and include the colon).
f three forms:  a LISP expression
ISP expression representing
one of these are
d compares it to the third,
he comparison is like
nd vectors).
	
("***ERROR***"), i.e. a list containing the string "***ERROR***".
 signaled:
in help library, or dataset doesn't exist).
 
 

 arg2)

          For PP,ÿ
ed) - one of the following symbols:
ACE, PP
nd UNTRACE are defined
ns information

 tracing and untracing, and by the ZILPP functiÿ
he definition of a function that is being traced.
ced functions is maintained as the value of
ich is like an association list of
ed:
for TRACE and UNTRACE).
See member $TRACE of this document for a description of tracing and
inds of functions can be traced.
tion: ZILUNBND
 known as the "unbound marker".                               .
ng:
…
alize the value/binding cells of symbols that have no
 Since the "unbound marker" looks like a list to ZIL whose CAR and
 t to itself, it is possible to test any binding for
g the CDR of the binding for EQness to
	
ÿ
ector1 length2)
required, evaluated) - a non-negative integer.
ng of length length2 cÿ
ssing:
tinuing
5

ctor1 not a vector.
h of vector1.
ave
y length2).


(ZILVTOS #(#\sp) 1)  ==> " "
 nil) 0)  ==>  ""
f"ÿ
TOS #(#\f #\o #\o #\b #\a #\r nil nil nil) 3)  ==>  "foo"
 #\o #\b #\a #\r nil nil nil) 4)  ==>  "foob"
 #\r nil nil nil)|  5)  ==>  "fooba"
nil nil) 6)  ==>  "foobar"
ZILXSUB
) - a compiled code object.

fied by arg1,
 placed
ction that executes compiled code objects
hough it is accessible to all users, it
	
 places them in successive stack locations.
ber of aÿ
 number of arguments that the compiled
 maximum value is greater than
 the list), NIL is
umber of times

ents to the compiled function and a poÿ
stack as the final argument.
ot re-evaluated,

 environment is saved and set to the value of the environment
he closure.
d by arg1,
ariable binding environment, if saved prior to calling the
tored.
or closure.
ny ÿ
ictable results will occur if the second argument is not a

argument
R) '(A B C))
rgument list
.
      (A NIL NIL).
	
ring (or symbol).
de from the ISPF dialog service
 concatenating the text
rguments are concatenated to form a character string buffer which
 to contain a valid ISPF dialog service request in ISPEXEC
is executed.
ase, UNLESS
of the
ÿ
er is built and executed as
is of course an error.
sed to invoke tÿ
have been
É
he ISPF dialog service is usedÿ
e returned as the ZISEXEC function value. This
tween 0 and 20.  Note, however, that
ly if ISPEXEC CONTROL ERRORS
will terminate the
invoke any ISPF dialog service that is supported by the
ocumented in the Dialog Services manuals for
 syntax is the same as for the ISPEXEC
"ISPEXEC" itself in the buffer;
name (DISPLAY, TBOPEN,
ion pool variables, which many ISPF
e ZISGET and ZISPUT functions.
alog service string (args cannot be converted to
PF dialog ÿ
 it is running under the TSO Authorized Service Facility
t where ISPF dialog services are temporarily
 
ONTROL ERRORS RETURN is active, a dialog service that fails
IL entirely.  The same will happen if a dialog error
d dialog under this facility, even if COÿ
 
may access the error by using the ZISGET function to retrieve the
ERRMSG, ZERRSM and/or ZERRLM.
ors return")

	

is arg1.
rieve the value of the ISPF
  Thus, the standard
 always returned as a string, regaÿ
 the ISPF dialog.
rned.
	
 variables updated by such services as VGET, DISPLAY, and table

on.
 string or symbol of from 1
 services not available; either ZIL is running outside
ing under the TSO Authorized Service Facility

(return code 20) returned from the VCOPY service.
ersion 2 must be installed to use this function.
RETURN is actiÿ
	
in the function
SGET 'foo) or (ZISGET "foo") ‡ returns the value of the ISPF dialog
foo.
   (ZISPUT arg1 arg2)
.


ervice is invoked to update the value of the ISPF
 is specified by arg1.
ng, regardless of the
 or structure.
ormation).
 dialog
AY.
function.
oÿ
id arg2 (a list, vector or structure).
le; either ZIL is running outside
horized Service ÿ
re temporarily
rned from the VREPLACE service.
nstalled to use this function.
, a VREPLACE service that fails
s:



or of (n) elements, where n is the length of arg1, and all of
re taken from thÿ
cated with the number of elements specified by the     urned
 and all of the elements are initialized to the
words, the list arg2 is convertÿ
id, in which case the vector has no elements.
arg1 not a proper list.
ter GC.
ples:

unction: ZPUTFPI
required, evaluated) - a fixnum.
name.
nter of the input file
ixnum value of arg1 replaces the current character position in the
k for the file specified by arg2, and is itself returned.
a ÿ
h of the input file.  If 0 is specified, the input
operations as if end-of-file had occurred.
e appears to all ÿ
value greater than the line length is specified, a new line
ced, but other results are unpredictable.
rrent input file pointer is:
 be re-read if the value is
urrent line to be skipped if the value is
mitted, defaults to NIL, which represents the sÿ

plicitly by input functions like READ, READCH and TYI.
	
ecified input file is not allocated or could not be opened.
ot a fixnum.
le names.
e

he
PUTFPI 10 'F OO)  sets the current column of input file FOO to 10.
UTFPI (ADD (ZGETFPI 'BAR) N) 'BAR)   causes the current column
osition of input file BAR to be "tabbed" over N spaces.

rg2)
ed) - an output file name.
rrent cÿ
essing:
n in the
	
Ö

e the current character pointer to poÿ
his technique may be used to set the print control
aracters are used).
 are unpredictable.
a new line

se data on the current line to be overlaid if the value is
or
itten data and the new location if the value is increased.
tted, defaults to NIL, which represents
heÿ
plicitly by output functions like PRINC, PRIN1, and TERPRI.
led:

ument not a fixnum.

ut-of-range value as the first aÿ
L environment.  Do so with extreme caution.
1) and (ZPUTFPO 1 NIL) are equivalent, and permit the current
ne of standard output to be overlaid with new d8 ata.
  sets the current column of output file FOO to 10.
O 'BAR) N) 'BAR)   causes the current column
file BAR to be "tabbed" over N spaces.
