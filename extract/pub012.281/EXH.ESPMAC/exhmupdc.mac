         MACRO
&NM      EXHMUPDC &IDR=NO,&ESD=NO
         GBLB  &MVS,&MVSSP,&MVSXA,&MVSESA,&OS390,&Z900          GP04234
         GBLC  &MODEL,&LOCAL,&SYSTEM
         LCLC  &SECTS,&SIZESD                                   GP99100
&SECTS   SETC  '&SYSECT'
&SIZESD  SETC  '(10000*LENESD)'  SIZE FOR ESD GETMAIN           GP03074
         AIF   ('&ESD' EQ 'NO').NOESD1
*
*        CESD SCAN SUBROUTINE
*
READCESD XC    ESDWORK(12),ESDWORK  CLEAR WORK AREA
READCESM TM    PDS2ATR2,PDS2NREP DOES MODULE CONTAIN ESD ENTRIES?
         MVC   MSGTEXT1,MSGNOESD
         BNZR  R14            NO, EXIT W/ ERROR
         CLC   PDS2TTRP,PDS2TTRT  START TTR SAME AS TEXT TTR ?
         BER   R14           YES; NO ESD ENTRIES
         STM   R14,R12,12(R13) SAVE REGISTERS
         MVI   MSGFG,0       NO ZAP/DISPLAY RECORD AVAILABLE     87201
         MVC   DRTTR(3),DIRTTR
         XC    IDRWORK,IDRWORK   CLEAR ASM IDR WORK SPACE        80158
         LA    R1,DIRBUFF
         ST@   R1,DRSLI-4,MVI=X'06'  READ DATA                   89275
         LA    R1,256
         ST@   R1,DRSLI,MVI=X'60'  CMD CHAIN / SILI              89275
         XFREE MODE=FW       FREE GETMAINED STORAGE             GP99100
         L     R3,=A(&SIZESD)  SET FOR LOTS OF STORAGE          GP99100
         XGET  (R3),R14,MODE=FW  SET FOR LARGE STORAGE REQUEST  GP99100
         LA    R15,LENESD    ENTRY LENGTH                       GP99100
         LR    R0,R14        START                              GP99100
         SR    R0,R15        LESS ONE ENTRY (TABLE EMPTY)       GP99100
         STM   R14,R0,ESDPTRS  SET BXLE POINTERS
         LR    R6,R14        POINT TO FIRST ONE JUST IN CASE
         SPACE 1
ESDEXCP  BAL   R9,DREAD
         B     SETERR42      SEE IF END OF EXTENT                81018
         B     ESDLAST
         CLI   DIRBUFF,X'40'  TEST SYM RECORD?
         BE    ESDEXCP        YES, SKIP RECORD
         AIF   ('&ESD' NE 'FULL').NOAID1                         80165
         CLI   DIRBUFF,X'80'   IDR DATA ?                        80158
         BE    ASIDR         YES; PROCESS IT                     80158
.NOAID1  CLI   DIRBUFF,X'20'  CESD RECORD?                       80158
         BNE   ESDLAST        NO
         LH    R2,DIRBUFF+4   RELATIVE # OF 1ST ESD ID
         N     R2,=X'0000FFFF'
         LA    R3,DIRBUFF+8   START OF ESD DATA
         LH    R5,DIRBUFF+6   LENGTH OF DATA IN BUFFER
         AR    R5,R3
         LA    R4,LENESD1     LENGTH OF ONE ENTRY
         SR    R5,R4
         SPACE 1
         USING ESDNAME,R3
ESDSCAN  IC    R0,ESDTYPE
         LA    R1,CODESEG     CHECK FOR SEGTAB/ENTAB
         NI    ESDTYPE,X'0F'
         NR    R0,R1
         CLI   ESDTYPE,4     PRIVATE COMMON?
         BE    ESDSCANF      YES; FINAGLE
         CLI   ESDTYPE,5     COMMON ?
         BNE   *+8           NO
ESDSCANF MVI   ESDTYPE,CODESD  YES; TREAT AS SD
ESDNUCX  TM    FLAGS+1,FALLESD SEARCH REQUEST?
         BZ    ESDMATCH       YES, SCAN ESD ENTRIES
         AIF   ('&ESD' EQ 'SHORT').ESDSHT2
         CR    R0,R1          THIS SEGTAB/ENTAB ENTRY?
         BE    ESDUSE1        YES
         CLI   ESDTYPE,CODESD SD ENTRY?
         BE    ESDUSE         YES
         CLI   ESDTYPE,CODELR LR ENTRY?
         BE    ESDUSE
.ESDSHT2 ANOP  ,
NEXTESD  LA    R2,1(,R2)     UP ESDID
         BXLE  R3,R4,ESDSCAN
         B     ESDEXCP        GET NEXT ESD RECORD
         DROP  R3
         USING ESDENTRY,R6
         SPACE 1
         AIF   ('&ESD' EQ 'SHORT').ESDSHT4
ESDUSE1  STC   R0,ESDTYPE-ESDENTRY(,R3)  RESTORE SEG/ENTAB
ESDUSE   BAL   R14,GETESD
         STH   R2,ESDID      SET ESD ID
         MVC   ESDNAME(LENESD1),0(R3) SAVE ESD ENTRY
         B     NEXTESD
.ESDSHT4 SPACE 1
ESDLAST  CLC   ESDPTR,ESDPTR2  ANY ENTRIES STASHED ?
         MVC   MSGTEXT1,MSGNOESD
         L     R14,12(,R13)
         BH    ESDEXIT        EXIT - NO ESD DATA AVAILABLE
         AIF   ('&ESD' EQ 'SHORT').ESDSHT6
         CLC   =C'IEANUC0',PDS2NAME  NUCLEUS ?
         BNE   ESDSOSRT      NO
         TM    PDS2ATR1,PDS2SCTR  SCATTER LOAD ?
         BZ    ESDNPROB      NO
*---------------------------------------------------------------------*
*  FOR OS/390, SCTR LOAD ADDRESSES DON'T MATCH LOAD ADDRESSES         *
*    IN THIS CODE, AMBLIST, OR LOADMAPS.                              *
*  USE THE LPA COMMAND TO GET CORRECT ADDRESSES.                      *
*---------------------------------------------------------------------*
         SPACE 1
*        SPECIAL RELOCATION CODE FOR NUCLEUS MEMBERS
*
         TM    FLAGS+1,FESDOFLO  ESD OVERFLOW ?
         BNZ   ESDNPROB      YES; SHOW PROBLEM EXISTS
         L     R6,ESDPTR     GET FIRST ESD ENTRY
         AIF   (&MVSESA).PASTNIP                                GP04234
         CLC   =C'NIP0',ESDNAME+4  CORRECT ENTRY ?               85319
         BE    ESDNUCLK      YES; NO NEED TO FLIP OVER IT        85319
         LM    R15,R1,ESDPTRS  GET START, INCREMENT AND END      91193
ESDNIPLK BXH   R15,R0,ESDNPROB  NO NIPPER                        91193
         CLC   =C'NIP0',ESDNAME+4-ESDENTRY(R15)  IS THIS IT ?    91193
         BNE   ESDNIPLK      NO; LOOK AGAIN                      91193
ESDNIPSW XC    ESDENTRY(LENESD),ESDENTRY-ESDENTRY(R15)           91193
         XC    ESDENTRY-ESDENTRY(LENESD,R15),ESDENTRY            91193
         XC    ESDENTRY(LENESD),ESDENTRY-ESDENTRY(R15)           91193
.PASTNIP ANOP  ,                                                GP03074
ESDNUCLK XC    WORKWORK,WORKWORK  CLEAR DB-WORD
         MVC   WORKWORK+2(2),PDS2SLSZ  GET SCATTER SIZE
         MVC   WORKWORK+6(2),PDS2TTSZ  AND TRTABLE SIZE
         LM    R4,R5,WORKWORK  GET COMBINED SIZE
         LA    R3,0(R4,R5)   SAVE LENGTH OF DATA TO BE READ      80159
         LA    R4,4(R4,R4)   SCTR+ADDRESS TABLE+4 ON TOP         80159
         LA    R4,4(R4,R5)   AND ONE MORE, JUST IN CASE         GP99100
         LR    R5,R4         COPY                               GP99093
         XGET  (R4),MODE=FW  GET MORE STORAGE                   GP99093
         LTR   R6,R1         TEST IF GOTTEN
         BNP   ESDNPROB
         AR    R5,R6         MAKE TOP BYTE+1
         SH    R5,H4         ALLOW FOR DUMMY WORD AT END         80159
         ST    R5,ESDTAB     SET TO FAIL IF UNREAD
         MVC   DRTTR(3),PDS2TTRN  SET TTR OF SCTR TABLE
         XR    R15,R15
         IC    R15,DRTTR+2
         BCTR  R15,0         SEARCH PREVIOUS
         STC   R15,DRTTR+2   SET BACK
ESDNREAX MVC   DRSLI-4(8),DRSLI+4  MAKE READ COUNT CCW ONLY      81018
         BAL   R9,DREAD      READ COUNT FIELD
         B     SETERR42      SEE IF END OF EXTENT                81018
         B     ESDNPROB      EOF ?
         MVI   DRSLI,X'40'   SET COMMAND CHAIN
ESDNREAD TM    DRSLI,X'40'   EXTENT END ENCOUNTERED ?            81018
         BZ    ESDNREAX      YES; REPOSITION                     81018
         LH    R0,DRNCCH+6   GET DATA FIELD                      81018
         STH   R0,DRSLI+2    SET NEW LENGTH                      81018
         SR    R5,R0         GET NEW INPUT ADDRESS
         CR    R5,R6         VALID ?
         BL    ESDNRED       NO; ASSUME DONE
         AH    R3,H4         ALLOW FOR CONTROL BYTES
         SR    R3,R0         GET RESIDUAL SIZE OF TABLE
         BM    ESDNRED       DONE ?
         ST@   R5,DRSLI-4,MVI=X'06'  MAKE READ DATA CCW          89275
         BAL   R9,DREAD      READ IT
         B     ESDNPROB      I/O ERROR
         B     ESDNPROB      EOF ?
         CLI   0(R5),X'10'   STILL SCATTER RECORD ?
         BNE   ESDNRED       NO
         LA    R5,4(,R5)
         ST    R5,ESDTAB     SAVE LAST ADDRESS PROCESSED
         LTR   R3,R3         ANY MORE TO READ ?
         BP    ESDNREAD      YES; READ AGAIN
ESDNRED  L     R5,ESDTAB     GET LAST ADDRESS PROCESSED
         A     R5,WORKWORK+4 GET SCTR TABLE
         ST    R5,ESDSCTR    SET IT
         A     R5,WORKWORK    GET END BYTE
         L     R1,EXW@STOR   GET GETMAIN ADDRESS                GP99102
         A     R1,4(,R1)     GET END                            GP99102
         SH    R1,=H'4'      LESS 4 BYTE DUMMY ENTRY            GP99102
         CR    R1,R5         MATCHES END ?
         BNE   ESDNPROB      NO; SOME ERROR                      80159
 AGO .PASTNTR
         L     R6,ESDPTR     GET NIP ENTRY BACK                  80159
         XC    DB,DB                                             80159
         MVC   DB+1(3),PDS2STOR  GET LOAD-MODULE LENGTH          80159
         MVC   DB+5(3),ESDLEN    GET NIP LENGTH                  80159
         LM    R14,R15,DB                                        80159
         LA    R14,0(,R14)   CLEAR SIZE                          80159
         ST    R14,0(,R1)    STORE IN DUMMY ENTRY                80159
         LA    R15,7(,R15)   ROUND NIP LENGTH                    80159
         N     R15,=X'00FFFFF8'                                  80159
         SR    R14,R15       GET NIP ADDRESS                     80159
         ST    R14,DB                                            80159
         MVC   ESDADDR,DB+1  SET NIP ADDRESS                     80159
         MVC   PDS2EPA,DB+1  ALSO SET NIP AS ENTRY ADDRESS       80159
.PASTNTR ANOP  ,
         L     R14,EXW@STOR  GET GETMAINED STORAGE               80159
         LA    R14,8(,R14)                                      GP99102
         L     R15,WORKWORK  GET SIZE OF ADDRESS TABLE           80159
         SRL   R15,2         CHANGE TO NUMBER OF ENTRIES         80159
         XR    R0,R0                                             80159
         BCTR  R0,0          MAKE CONSTANT FFFFFFFF              80159
ESDADCLR ST    R0,0(,R14)    INITIALIZE - NO ADDRESS             80159
         LA    R14,4(,R14)                                       80159
         BCT   R15,ESDADCLR  DO ALL                              80159
*        HOUSEKEEPING; THEN BUILD ADDRESS TABLE                  80159
         LM    R4,R5,ESDSCTR  GET SCATTER AND TRANSLATE ADDR     80159
         LA    R6,4          SET FIRST OFFSET TO PROCESS         80159
         L     R3,EXW@STOR   GET BASE OF ADDRESS LIST            80159
         LA    R3,8(,R3)                                        GP99102
 AGO .PASTADR
         LH    R1,2(,R5)     GET NIP INDEX                       80159
         N     R1,=X'0000FFFF'
         SLL   R1,2          MAKE INTO OFFSET                    80159
         AR    R1,R3         GET ADDRESS ENTRY                   80159
         MVC   0(4,R1),DB    PRESET NIP ADDRESS                  80159
.PASTADR ANOP  ,
         XR    R14,R14       CLEAR 'NEXT AVAILABLE' ADDRESS      80159
ESDADLOP LH    R2,0(R6,R5)   GET NEXT TT INDEX                   80159
         N     R2,=X'0000FFFF'
         SLA   R2,2          CHANGE INTO OFFSET                  80159
         BNP   ESDADINC      SKIP IF NULL                        80159
         L     R0,0(R2,R3)   GET ADDRESS TABLE ENTRY             80159
         LTR   R0,R0         ALREADY SET ?                       80159
         BNM   ESDADINC      YES; SKIP                           80159
         ST    R14,0(R2,R3)  SET NEW ADDRESS FOR THIS SD         80159
         AL    R14,4(R2,R4)  ADD NEXT SD ADDRESS                 80159
         SL    R14,0(R2,R4)  LESS CURRENT OLD SD = NEW SD ADDRESS
ESDADINC LA    R6,2(,R6)     BUMP TT OFFSET                      80159
         C     R6,WORKWORK+4 DONE ?                              80159
         BL    ESDADLOP      NO; DO AGAIN                        80159
*        NOW RELOCATE ALL ENTRIES                                80159
         LM    R3,R5,ESDPTR  GET ESD POINTERS                    80159
         LA    R6,0(R3,R4)   SKIP NIP; START WITH QFX            80159
         LM    R2,R3,ESDSCTR  LOAD SCTR AND TT ADDRESSES         80159
         L     R9,EXW@STOR   AND ADDRESS TABLE ADDRESS           80159
         LA    R9,8(,R9)                                        GP99102
ESDADHOC LH    R1,ESDID      GET CESD ID                         80159
         N     R1,=X'0000FFFF'
         SLL   R1,1          MAKE SCATTER TABLE OFFSET           80159
         LH    R1,0(R1,R3)   GET INDEX TO TRANSLATE TABLE        80159
         N     R1,=X'0000FFFF'
         SLL   R1,2          MAKE INTO OFFSET                    80159
         L     R0,0(R1,R9)   GET NEW ADDRESS                     80159
         CLI   ESDTYPE,CODELR  SD OR LR ENTRY ?                  80159
         BNE   ESDADST       SD; HAVE NEW ADDRESS                80159
         L     R15,ESDADDR-1  GET OLD LR ADDRESS                 80159
         SL    R15,0(R1,R2)   LESS OLD SD BASE                   80159
         ALR   R0,R15        NEW ADDRESS                         80159
ESDADST  ST    R0,DB                                             80159
         MVC   ESDADDR,DB+1  SET NEW ADDRESS                     80159
         BXLE  R6,R4,ESDADHOC                                    80159
         B     ESDNUCOK
ESDNPROB LA    R6,NUCNOMSG
         BAL   R9,PUTMSG     DISPLAY ERROR MSG
ESDNUCOK DS    0H            REMOVED - DEFER UNTIL LATER        GP99100
ESDSOSRT L     R6,ESDPTR     GET FIRST ENTRY
         LM    R4,R5,ESDPTR+4  GET LENGTH AND LAST ENTRY
         LR    R15,R5        COPY LAST ENTRY
         SR    R5,R4
         LR    R14,R4        COPY LENGTH
         CR    R15,R6        ONLY ONE ENTRY ?
         BNH   ESDOUT        YES; SKIP SORT
         LA    R2,ESDSWAP    SET SWAP ADDRESS FOR FAST BRANCH
         LA    R3,ESDSBUMP   SET BUMP ADDRESS
         LA    R9,ESDSCLC    SET CLC ADDRESS FOR NORMAL SORT
         TM    PDS2ATR1,PDS2OVLY  OVERLAY ?
         BNZ   *+8           YES
         LA    R9,ESDSCLAD   ELSE IGNORE REGIONS ON SORT
         TM    ESDFLAG,ESDFNAME  SORT BY NAME ?
         BZ    ESDSORT       NO
         LA    R9,ESDSCLNM   SORT BY CSECT NAME ONLY
ESDSORT  LA    R1,0(R4,R6)   SET NEXT ENTRY
         BR    R9            DO ESDSCLC OR ESDSCLNM
ESDSCLC  CLC   ESDSEG#,ESDSEG#-ESDENTRY(R1) CHECK ENTRY SEGMENT #S
         BLR   R3
         BHR   R2
ESDSCLAD CLC   ESDADDR,ESDADDR-ESDENTRY(R1)
         BLR   R3
         BHR   R2
         CLC   ESDTYPE,ESDTYPE-ESDENTRY(R1)
         BLR   R3
         BHR   R2
ESDSCLNM CLC   ESDNAME,ESDNAME-ESDENTRY(R1)
         BNHR  R3
ESDSWAP  XC    ESDNAME(LENESD),ESDNAME-ESDENTRY(R1)
         XC    ESDNAME-ESDENTRY(LENESD,R1),ESDNAME
         XC    ESDNAME(LENESD),ESDNAME-ESDENTRY(R1)
ESDSBUMP BXLE  R1,R14,0(R9)  SORT ANOTHER BY ADDR OR NAME
         BXLE  R6,R4,ESDSORT
.ESDSHT6 B     ESDOUT
         SPACE 1
         AIF   ('&ESD' EQ 'SHORT').ESDSHT8
GETESD   L     R6,ESDPTR2    GET CURRENT ENTRY
         L     R0,=A(&SIZESD)  GET ESD GETMAIN SIZE             GP99100
         A     R0,ESDPTR     PLUS STARTE SIZE                   GP99100
         A     R6,ESDPTR+4   MAKE NEXT ENTRY
         S     R0,ESDPTR+4   MAKE LAST FITTING ENTRY
         CR    R6,R0         WILL THIS ONE FIT ?
         BNH   GETESDOK
         LA    R6,ESDOFLOW   MAKE OVERFLOW MESSAGE
         BAL   R14,PUTLINE
         OI    FLAGS+1,FESDOFLO  SIGNAL OVERFLOW
         B     ESDLAST       SIGNAL END
GETESDOK ST    R6,ESDPTR2    SET NEW LAST ENTRY
         XC    ESDDATE,ESDDATE
         BR    R14           RETURN TO CALLER
NUCNOMSG MSG   'ERROR IN NUCLEUS RELOCATION'                     80165
.ESDSHT8 DROP  R6
         SPACE 2
         USING ESDNAME,R3
ESDMATCH CLI   ESDTYPE,CODESD VALID EXTERNAL SYMBOL?
         BE    ESDCHECK       YES
         CLI   ESDTYPE,CODELR ANOTHER VALID ENTRY
         BNE   NEXTESD        NO VALID, CONTINUE
ESDCHECK CLC   ESDNAME,DIRNAME  REQUESTED NAME?
         BNE   NEXTESD        NO
         CLI   ESDSEG#,1      IS SYMBOL IN ROOT SEGMENT?
         BNE   NEXTESD        NO, CONTINUE
         L     R1,ESDADDR-1   GET SYMBOL OFFSET
         LA    R1,0(,R1)
         ST    R1,24(,R13)    RETURN OFFSET IN REG 1
         SPACE 1
ESDOUT   L     R14,12(,R13)
         LA    R14,4(,R14)     ADJUST EXIT ADDRESS
         NI    FLAGS+1,X'FF'-FALLESD
         SPACE 1
ESDEXIT  LM    R15,R9,16(13) RESTORE REGISTERS EXCEPT R10        80028
         BR    R14            EXIT
         SPACE 2
*
*        ESD TABLE FORMAT
*
         SPACE 2
ESDDSECT DSECT ,
ESDNAME  DS    CL8            NAME OF EXTERNAL SYMBOL
ESDTYPE  DS    X              ESD TYPE
CODESD   EQU   X'00'          ENTERNAL DEFINATION
CODELR   EQU   X'03'          EXTERNAL REFERENCE
CODESEG  EQU   X'14'          OVERLAY SEGMENT TABLE
CODEENTB EQU   CODESEG        OVERLAY ENTRY TABLE
ESDADDR  DS    XL3            RELATIVE OFFSET
ESDSEG#  DS    X              SEGMENT NUMBER
ESDLEN   DS    XL3            LENGTH OF SD ENTRY
LENESD1  EQU   *-ESDNAME      LENGTH OF ESD DATA
ESDID    DS    XL2            RELATIVE ESD ID #
ESDDATE  DS    XL3           DATE OF ASSEMBLY/COMPILE
         AIF   ('&MODEL' NE '360').MALIGN                        80165
         DS    0F            ALIGNMENT FOR 360 TYPES             80165
.MALIGN  ANOP  ,                                                 80165
LENESD   EQU   *-ESDDSECT     LENGTH OF ENTRY
ESDENTRY EQU   ESDNAME,LENESD
&SECTS   CSECT ,
         DROP  R3                                                80158
         AIF   ('&ESD' NE 'FULL').NOAID2                         80165
         SPACE 2                                                 80158
*        THIS CODE OBTAINS ASSEMBLY/COMPILE IDR DATES IN THE WORST
*        POSSIBLE FASHION.  THE ONLY THING TO BE SAID ABOUT THE  80158
*        CODE IS THAT 1) IT WORKS  2) IT MAKES THE CODE FIT IN 4K
*        3) IBM SURE PICKED A CRUMMY WAY OF WRITING THE LIST     80158
*                                                                80158
ASIDR    TM    FLAGS+1,FALLESD  SPECIFIC REQUEST ?               80158
         BZ    ESDLAST       YES; QUIT NOW                       80158
         L     R5,IDRWORK    GET LENGTH OF EXISTING DATA         80158
         TM    DIRBUFF+2,X'04'   ASSEMBLY IDR ?                  80158
         BZ    ASIDRNXT      NO                                  80158
         TM    DIRBUFF+2,255-X'80'-X'04'  OTHER ?                80158
         BNZ   ASIDRNXT      YES; SKIP                           80158
         LA    R3,DIRBUFF+3  POINT TO START OF DATA              80158
         XR    R4,R4           CLEAR FOR IC                      80158
         IC    R4,DIRBUFF+1  GET LENGTH                          80158
         SH    R4,H2         LENGTH OF DATA                      80158
         BNP   ASIDRNXT      SKIP IF NONE                        80158
ASIDRLOP CH    R5,=H'18'     ENOUGH DATA FOR ONE ENTRY ?         80158
         BNL   ASIDRMSG      YES; PROCESS IT                     80158
         LTR   R4,R4         ANY DATA IN BUFFER ?                80158
         BNP   ASIDRNXT      NO; GO TO REFILL BUFFER             80158
         LA    R1,MSGTEXT1(R5)  FILL ADDRESS                     80158
         LA    R2,100        DESIRED FILL LENGTH                 80158
         CR    R4,R2         ENOUGH DATA FOR FULL FILL ?         80158
         BNL   *+6           YES                                 80158
         LR    R2,R4         USE ONLY WHAT'S AVAILABLE           80158
         SR    R4,R2         ADJUST LENGTH OF REMAINDER          80158
         EX    R2,ASIDRMVC   MOVE TEXT FROM BUFFER (L+1; TSK, TSK)
         AR    R3,R2         NEXT BUFFER ADDRESS AVAILABLE       80158
         AR    R5,R2         LENGTH OF AVAILABLE TEXT            80158
         B     ASIDRLOP      CHECK AGAIN                         80158
ASIDRMVC MVC   0(0,R1),0(R3)  FILL TEXT FROM BUFFER              80158
ASIDRMSG LM    R15,R1,ESDPTR  GET ESD POINTERS                   80158
         LH    R14,MSGTEXT1  GET SIGNED CESDID                   80158
         N     R14,=X'00007FFF'  STRIP SIGN                      80158
         USING ESDENTRY,R15  DECLARE IT                          80158
ASIDRTST CH    R14,ESDID     SAME CSECT ID ?                     80158
         BNE   ASIDRTSI      NO; TRY NEXT                        80158
         MVI   ESDDATE+2,X'0F'  FLAG AS DATE TO BE SET           80158
         LR    R15,R1        FORCE END OF LOOP                   80158
ASIDRTSI BXLE  R15,R0,ASIDRTST   TRY AGAIN                       80158
         TM    MSGTEXT1,X'80'  LAST LIST ENTRY ?                 80158
         BNZ   ASIDREOL      YES; GO TO FILL DATES               80158
         MVC   MSGTEXT1(116),MSGTEXT1+2  SHIFT LEFT              80158
         SH    R5,H2         ADJUST RESIDUAL LENGTH              80158
         B     ASIDRLOP      CHECK LENGTH AGAIN                  80158
ASIDREOL LM    R15,R1,ESDPTR  GET LIST POINTERS AGAIN            80158
ASIDREOT CLC   =X'00000F',ESDDATE  FILL DATE ENTRY ?             80158
         BNE   ASIDREOX      NO; BUMP                            80158
         MVC   ESDDATE,MSGTEXT1+15  MOVE DATE                    80158
ASIDREOX BXLE  R15,R0,ASIDREOT  DO ALL                           80158
         CLI   MSGTEXT1+2,0  SINGLE ENTRY ?                      80165
         BNE   ASIDREOV      NO;  PROCESS VARIABLE LIST          80165
         SH    R5,=H'18'     ADJUST RESIDUAL LENGTH              80158
         MVC   MSGTEXT1(100),MSGTEXT1+18  SHIFT OVER             80158
         B     ASIDRLOP      DO NEXT ENTRY, IF ANY               80158
         SPACE 1                                                 80165
ASIDREOV MVC   MSGTEXT1+3(103),MSGTEXT1+18  CLOBBER PRIOR ENTRY  80165
         SH    R5,=H'15'     SUBTRACT LIST ENTRY LENGTH          80165
         XR    R1,R1                                             80165
         IC    R1,MSGTEXT1+2  GET NUMBER OF LIST ENTRIES         80165
         BCTR  R1,0                                              80165
         STC   R1,MSGTEXT1+2                                     80165
         B     ASIDRLOP      REPROCESS LAST ENTRY                80165
         SPACE 1                                                 80158
ASIDRNXT ST    R5,IDRWORK    SAVE REMAINING TEXT LENGTH          80158
         TM    DIRBUFF+2,X'80'  LAST BLOCK ?                     80158
         BZ    ESDEXCP       NO; READ ANOTHER RECORD             80158
         B     ESDLAST       ELSE QUIT NOW                       80158
         DROP  R15                                               80158
.NOAID2  EJECT ,                                                 80158
.NOESD1  ANOP  ,
*
*        DIRECTORY READ SUBROUTINE
*
         SPACE 2
READDIR  ST    R14,DWFSAVE
         TM    FLAGS+1,F1STREAD IS THIS FIRST TIME?
         BZ    DEBLOCK        NO
         XI    FLAGS+1,F1STREAD
         XC    DRTTR,DRTTR
         MVI   DRTTR+2,1     SET FOR FIRST RECORD
         LA    R1,DIRBUFF
         ST@   R1,DRSLI-4,MVI=X'06'  READ DATA                   89275
         LA    R2,256
         ST@   R2,DRSLI,MVI=X'40'  COMMAND CHAIN                 89275
         SPACE 1
READDIR1 BAL   R9,DREAD      READ A BLOCK
         B     IOERROR
         B     READDIRX      EOF
         LA    R15,DIRBUFF
         LA    R0,2
         LH    R1,DIRBUFF
         CR    R1,R0         VALID LENGTH ?
         BL    IOERROR
         CLM   R1,3,DRLEN                                        85317
         BH    IOERROR
         LA    R1,DIRBUFF-1(R1)
         STM   R15,R1,DIRPTRS
         SPACE 1
DEBLOCK  LM    R15,R1,DIRPTRS
         BXH   R15,R0,READDIR1
         STM   R15,R1,DIRPTRS
         CLC   FF(8),0(R15)   LAST MEMBER?
         BE    READDIR3       YES
         MVC   DIRNAME(74),0(R15)
         NI    11(R15),X'1F'
         IC    R0,11(,R15)
         AR    R0,R0
         LA    R14,12
         AR    R0,R14
         STM   R15,R1,DIRPTRS
         LA    R15,8          EXIT OFFSET
         B     READDIR4
         SPACE 1
READDIR3 LA    R15,4          LAST MEMBER EXIT OFFSET
READDIR4 L     R14,DWFSAVE
         B     0(R14,R15)
         SPACE 1
READDIRX XR    R15,R15       EOF EXIT
         B     READDIR4
         SPACE 2
BLDLEXCP ST    R14,DWFSAVE   SAVE RETURN REGISTER
         XC    DRTTR,DRTTR
         MVI   DRTTR+2,1     SET FOR FIRST RECORD
         MVC   DRSLI-4(8),SCANTIC  MAKE TIC TO SCAN LIST
         BAL   R9,DREAD      SEARCH KEY LE
         B     BLDLEXER      ERROR
         B     BLDLEXER      EOF ?
         LA    R15,DIRBUFF   POINT TO BUFFER
         LA    R0,2          LENGTH LENGTH
         LH    R1,DIRBUFF    GET LENGTH
         CR    R1,R0         VALID LENGTH ?
         BL    BLDLEXER      NO; ERROR
         CLM   R1,3,DRLEN    TOO LARGE ?                         85317
         BH    BLDLEXER
         LA    R1,DIRBUFF-1(R1)  SET LAST BYTE
BLDLEXLP BXH   R15,R0,BLDLEXNF  NOT FOUND
         IC    R0,11(,R15)   GET LENGTH BITS
         N     R0,=F'31'     MASK LENGTH
         AR    R0,R0         DOUBLE
         AH    R0,H12        ADD
         CLC   DIRNAME,0(R15)  CHECK NAME
         BL    BLDLEXNF      NOT FOUND
         BH    BLDLEXLP      LOOK AT NEXT MEMBER
         MVC   DIRNAME(74),0(R15)  MOVE TEXT TO BLDL ENTRY       80165
         XR    R15,R15
BLDLEXEX L     R14,DWFSAVE
         BR    R14
         SPACE 1
BLDLEXER LA    R15,8         SET I/O ERROR
         B     BLDLEXEX
         SPACE 1
BLDLEXNF LA    R15,4         SET NOT FOUND
         B     BLDLEXEX
         EJECT
*
*        MEMBER NAME VALIDITY CHECK SUBROUTINE
         SPACE 2
TITMEMBR MVC   0(80,R10),REPLY    ECHO THE INPUT                GP04101
         AH    R10,LSIZE     UP A LINE
         SPACE 1
VERMEMBR MVC   MEMBERS,BLANKS  CLEAR MEMBER NAME FIELDS
         NI    FLAGS,255-FMEMBER1-FMEMBER2  SHOW NO MEMBERS
         CLI   0(R5),C' '    VALID COMMAND TERMINATION ?
         BE    MEMLOOK       YES
         CLI   0(R5),C','    ALTERNATE FORM ?
         BNE   CMDINVLD      NO; SHOW INVALID COMMAND
MEMLOOK  XLOOK T=MEMTAB        SKIP BLANKS AND COMMAS
         CLI   0(R5),C' '    ANY INPUT ?
         BER   R9            NO; RETURN
         LA    R14,MEMBER1   POINT TO FIRST MEMBER
         TM    FLAGS,FMEMBER1+FMEMBER2  TEST MEMBER FLAGS
         BOR   R9            BOTH - SET EXTRANEOUS DATA
         BM    MEMLOOK2      SECOND MEMBER
         OI    FLAGS,FMEMBER1
         B     MEMMOVE
MEMLOOK2 OI    FLAGS,FMEMBER2  SET SECOND MEMBER
         LA    R14,MEMBER2   POINT TO SECOND MEMBER
MEMMOVE  LA    R15,8         MOVE 8 BYTES MAX
         LA    R0,1          CONSTANT
         ST    R5,REPPTR     SAVE START OF ATTRIBUTE LIST
MEMMLOOP CLI   0(R5),C' '    END ?
         BE    MEMMOLD       YES; LOOK FOR MORE                  80358
         CLI   0(R5),C','
         BE    MEMMOLD       DITTO                               80358
         MVC   0(1,R14),0(R5)  MOVE A BYTE
         AR    R14,R0
         AR    R5,R0
         BCT   R15,MEMMLOOP  DO ANOTHER
         CLI   0(R5),C' '    PROPER END ?
         BE    MEMMOLD       YES; LOOK FOR ANOTHER               80358
         CLI   0(R5),C','    ALT. END ?
         BE    MEMMOLD                                           80358
         LA    R6,MEMTOOLN   SHOW MEMBER NAME TOO LONG
         B     ERRMSG
MEMMOLD  TM    FLAGS,FMEMBER2  DOING SECOND MEMBER ?             80358
         BNZ   MEMLOOK       YES                                 80358
         CLI   MEMBER1,C'*'  REQUEST FOR 'OLD' MEMBER ?          80358
         BNE   MEMLDFLT      NO; CHECK IT                        80358
         CLI   MEMBER1+1,C' '  ASTERISK ONLY ?                   80358
         BNE   MEMLDFLT      NO; CHECK IT                        80358
         CLI   MEMBOLD,C' '  PREVIOUSLY SUPPLIED ?               80358
         BNH   MEMLDFLT      NO                                  80358
         MVC   MEMBER1,MEMBOLD  REPLACE BY OLD MEMBER NAME       80358
MEMLDFLT LA    R1,MEMBER1                                        80358
         TRT   0(8,R1),NAMETRT  VALID NAME ?                     80358
         BZ    MEMLDOLD      YES; SAVE AS OLD NAME               80358
         CLI   0(R1),C' '    TRAILING BLANK ?                    80358
         BNE   MEMLOOK       NO; DO NOT SAVE BAD NAME            80358
MEMLDOLD MVC   MEMBOLD,MEMBER1  SAVE AS OLD NAME                 80358
         B     MEMLOOK       LOOK FOR MORE INPUT                 80358
MEMTAB   BTAB  ',',MEMLOOK,BASE=*  SKIP COMMAS
         BTAB  *END          AND NOTHING ELSE
         SPACE 2
NAMCHECK CLI   0(R1),C' '    NAME PRESENT ?
         BNH   NAMCHBAD      NO
         CLI   0(R1),C'0'    NUMERIC START ?
         BNL   NAMCHBAD
         CLI   7(R1),C'+'    SVC NAME ?
         BNE   *+8
         MVI   7(R1),X'C0'   REPLACE
         LR    R14,R1        SAVE MEMBER
         TRT   0(8,R1),NAMETRT  CHECK NAME
         BZR   R9            NAME OK
         CLI   0(R1),C' '    TRAILING BLANK ?
         BER   R9            YES; OK
NAMCHBAD MVC   REPLY,BLANKS
         MVC   REPLY+6(8),0(R14)  MOVE BAD MEMBER NAME
         LA    R6,MSGNMBAD
         B     ERRMSG
         AIF   ('&IDR' EQ 'NO').NOIDR
         EJECT
*
*        IDR SCAN SUBROUTINE
         SPACE 1
READIDR  MVC   DRTTR(3),DIRTTR  SET MEMBER TTR
         STM   R14,R12,12(R13)
         LA    R1,DIRBUFF
         ST@   R1,DRSLI-4,MVI=X'06'  READ DATA                   89275
         LA    R1,256
         ST@   R1,DRSLI,MVI=X'60'  CMD CHAIN / SILI              89275
         USING IDRENTRY,R6
         NI    FLAGS+1,X'FF'-FIDR-F1IDR-FIDSPLIT
         XC    LKEDDATE,LKEDDATE
         MVI   MSGFG,0       NO ZAP/DISPLAY RECORD AVAILABLE     87201
         XC    WORKWORK(8),WORKWORK   CLEAR ASM IDR WORK SPACE   80165
         LM    R3,R5,ESDPTRS   GET ESD POINTERS                  80165
         LR    R15,R3        GET START ADDRESS                   80165
         LA    R0,LENHSD     GET LENGTH OF COMPRESSED ENTRY      80165
         LR    R1,R15         MAKE NEW END ENTRY ADDRESS         80165
         SR    R1,R0                                             80165
         USING ESDENTRY,R3                                       80165
         USING HSDENTRY,R1                                       80165
IDRSQISH CLI   ESDTYPE,CODESD  SD ENTRY ?                        80165
         BNE   IDRSQINC      NO; SKIP                            80165
         AR    R1,R0         GET NEXT ENTRY                      80165
         MVC   HSDNAME,ESDNAME   MOVE NAME                       80165
         MVC   HSDID,ESDID   AND ESD ID                          80165
IDRSQINC BXLE  R3,R4,IDRSQISH  LOOP THROUGH ALL                  80165
         STM   R15,R1,ESDPTRS  SET NEW POINTERS                  80165
         DROP  R1,R3                                             80165
         LA    R14,BEGINESD  POINT TO I/O WORK SPACE            GP02257
         LA    R15,LENIDR    ENTRY LENGTH
         LR    R0,R14        COPY ADDRESS
         SR    R0,R15        SET FOR FIRST GETIDR
         STM   R14,R0,IDRPTRS  SET BXLE POINTERS
         LR    R6,R14        POINT TO FIRST ONE JUST IN CASE
         SPACE 1
IDREXCP  XC    DIRBUFF(4),DIRBUFF  JUST IN CASE
         BAL   R9,DREAD
         B     SETERR42      SEE IF END OF EXTENT                81018
         B     LASTIDR       TERM. ON EOF
         XR    R4,R4
         IC    R4,DIRBUFF+1  GET BYTE COUNT FOR THIS RECORD
         SH    R4,H2         ALLOW FOR LENGTH AND TYPE
         BNP   IDREXCP       SHORT; GET ANOTHER BLOCK
         TM    DIRBUFF,X'40'+X'20'  SYMBOL TABLE OR CESD RECORD ?
         BNZ   IDREXCP        YES, SKIP RECORD                   80165
         CLI   DIRBUFF,X'80'  IDR RECORD?
         BNE   LASTIDR        NO
         LA    R3,DIRBUFF+3   START OF IDR DATA
         LA    R5,DIRBUFF+2(R4) END OF BUFFER ADDRESS -1
         TM    DIRBUFF+2,X'80' LAST RECORD OF LOAD MODULE?
         BZ    *+8            NO
         OI    FLAGS+1,F1IDR  YES, SET STOP FLAG
         NI    DIRBUFF+2,X'0F' CLEAR MISC FLAGS
         CLI   DIRBUFF+2,IDRZAP IMASPZAP IDR RECORD?
         BE    ZAPIDR         YES
         CLI   DIRBUFF+2,IDRLKED LINKAGE EDITOR IDR RECORD?
         BE    LKEDIDR        YES
         CLI   DIRBUFF+2,IDRASM  ASSEMBLER/COMPILER IDR ENTRY ?  80165
         BE    ASMIDR        YES                                 80165
         CLI   DIRBUFF+2,IDRUSER USER-SUPPLIED IDR RECORD?
         BNE   NEXTIDR        NO, NEXT RECORD
         SPACE 1
*        PROCESS USER(SYSTEM) SUPPLIED IDR DATA
*
USERIDR  TM    FLAGS+1,FIDSPLIT  SPLIT IDR RECORD ?
         BZ    USERIDR2      NO; DO NORMALLY
         NI    FLAGS+1,255-FIDSPLIT
         L     R15,IDRWORK+4  GET TO ADDRESS FOR MOVE
         MVC   0(46,R15),0(R3)  MOVE TEXT AND THEN SOME
         BAL   R9,STASHIDR   PROCESS THE ENTRY
         L     R14,IDRWORK   GET PREVIOUS LENGTH
         XR    R1,R1
         IC    R1,MSGTEXT1+5  GET TEXT LENGTH
         LA    R1,6(,R1)     ADD OVERHEAD
         SR    R1,R14        GET BYTES IN THIS BLOCK
         BM    BADIDR        TOO BAD
         AR    R3,R1         SKIP TO NEXT BLOCK
         SR    R4,R1         ADJUST LENGTH
USERIDR2 LA    R14,6         SET FIXED OVERHEAD
         LTR   R4,R4         ANY LEFT ?
         BM    BADIDR        TOO BAD
         BZ    NEXTIDR       DO ANOTHER
         CR    R4,R14        LENGTH AVAILABLE ?
         BNL   USERIDR4      YES; GET REQUIRED LENGTH
USERIDR3 MVC   MSGTEXT1(46),0(R3)  MOVE WHATEVER
         LA    R5,MSGTEXT1(R4)  ADDRESS FOR NEXT MOVE
         STM   R4,R5,IDRWORK  SET LENGTH/ADDRESS FOR NEXT TIME
         OI    FLAGS+1,FIDSPLIT  SHOW SPLIT RECORD
         B     NEXTIDR
USERIDR4 CLI   5(R3),40      PROCESSABLE LENGTH ?
         BH    BADIDR
         XR    R1,R1
         IC    R1,5(,R3)     GET TEXT LENGTH
         AR    R1,R14        SET COMPLETE LENGTH
         CR    R1,R4         FITS IN THIS BLOCK ?
         BH    USERIDR3      NO; DO SPLIT
         MVC   MSGTEXT1(46),0(R3)  COPY IT AND THEN SOME
         AR    R3,R1         NEW RECORD
         SR    R4,R1         NEW LENGTH
         BAL   R9,STASHIDR   PROCESS THIS ENTRY
         B     USERIDR2      GET ANOTHER
         SPACE 1
STASHIDR CLI   MSGTEXT1+5,0  NULL ENTRY ?
         BER   R9            YES; IGNORE
         CLI   MSGTEXT1+5,40  VALID LENGTH ?
         BH    BADIDR        NO; TOO BAD
         BAL   R14,GETIDR    GET A SAVE AREA
         MVI   IDRTYPE,MYDRUSER      SET USER RECORD             80165
         MVC   IDRESDID,MSGTEXT1  SET CSECT ID
         LA    R1,MSGTEXT1+2  POINT TO DATE
         BAL   R14,SETIDRDT  CONVERT IT
         XR    R1,R1
         IC    R1,MSGTEXT1+5  GET LENGTH
         LA    R14,L'IDRDATA   INSERTION FOR NUCLEUS PROCESSING  80165
         CR    R1,R14        MAXIMUM LENGTH REDUCED              80165
         BNH   *+6                                               80165
         LR    R1,R14        TRUNCATE TO MAXIMUM SUPPORTED LENGTH
         BCTR  R1,0          SET FOR LATER EX
         STC   R1,IDRLDATA   SAVE LENGTH-1
         EX    R1,UIDMVC     MOVE TO SAVE AREA
         BR    R9            RETURN
         SPACE 1
BADIDR   LA    R6,MSGBDIDR   SHOW ERROR DURING IDR PROCESSING
         B     GETIDRMG      PUT MESSAGE AND QUIT
UIDMVC   MVC   IDRDATA(0),MSGTEXT1+6  MOVE TEXT
MSGBDIDR MSG   'ERROR IN IDR PROCESSING'
         SPACE 1                                                 80165
*        ASSEMBLER/COMPILER IDR RECORD SPLITTING                 80165
*                                                                80165
ASMIDR   L     R5,WORKWORK   GET LENGTH OF EXISTING DATA         80165
ASMIDLOP CH    R5,=H'18'     ENOUGH DATA FOR ONE ENTRY ?         80165
         BNL   ASMIDMSG      YES; PROCESS IT                     80165
         ST    R5,WORKWORK    SAVE FOR NEXT TIME                 80165
         LTR   R4,R4         ANY DATA IN BUFFER ?                80165
         BNP   NEXTIDR       NO; GO TO REFILL BUFFER             80165
         LA    R1,MSGTEXT1(R5)  FILL ADDRESS                     80165
         LA    R2,100        DESIRED FILL LENGTH                 80165
         CR    R4,R2         ENOUGH DATA FOR FULL FILL ?         80165
         BNL   *+6           YES                                 80165
         LR    R2,R4         USE ONLY WHAT'S AVAILABLE           80165
         SR    R4,R2         ADJUST LENGTH OF REMAINDER          80165
         EX    R2,ASIDRMVC   MOVE TEXT FROM BUFFER (L+1; TSK, TSK)
         AR    R3,R2         NEXT BUFFER ADDRESS AVAILABLE       80165
         AR    R5,R2         LENGTH OF AVAILABLE TEXT            80165
         B     ASMIDLOP      CHECK AGAIN                         80165
ASMIDMSG CLC   =X'8000',MSGTEXT1  RE-ENTRY ?                     80165
         BE    ASMIDEOL      YES; DO NOT ALLOCATE AGAIN          80165
         BAL   R14,GETIDR    GET AN IDR BUFFER                   80165
         MVC   IDRESDID,MSGTEXT1  COPY ESD ID                    80165
         NI    IDRESDID,X'7F'   KILL SIGN/FLAG BIT               80165
         LAT   R14,WORKWORK+4,,ASMIDSTE   SKIP IF SAVED          80165
         ST    R6,WORKWORK+4   SAVE FIRST IDR TO BE FIXED        80165
ASMIDSTE MVI   IDRLDATA,21-1   SET LENGTH-1 OF DATA              80165
         TM    MSGTEXT1,X'80'  LAST LIST ENTRY ?                 80165
         BNZ   ASMIDEOL      YES; GO TO FILL DATES               80165
         MVC   MSGTEXT1(116),MSGTEXT1+2  SHIFT LEFT              80165
         SH    R5,H2         ADJUST RESIDUAL LENGTH              80165
         B     ASMIDLOP      CHECK LENGTH AGAIN                  80165
ASMIDEOL LAT   R2,WORKWORK+4,ASMIDEOX  GET FIRST RECORD TO BE FIXED
ASMIDEOT LA    R1,MSGTEXT1+15   POINT TO DATE                    80165
         LA    R15,IDRDATE-IDRENTRY(,R2)  POINT TO OUTPUT        80165
         BAL   R14,SETLKDTE  CONVERT THE DATE                    80165
         MVI   IDRTYPE-IDRENTRY(R2),MYDRASM  IDENTIFY ENTRY      80165
         LA    R14,IDRDATA-IDRENTRY(R2)  POINT TO NAME FIELD     80165
         CLI   0(R14),C' '   FIRST TIME ?                        80165
         BE    *+8           YES; USE IT                         80165
         LA    R14,11(,R14)  ELSE POINT TO SECOND FIELD          80165
         MVC   0(10,R14),MSGTEXT1+3  MOVE COMPILER NAME          80165
         CR    R2,R6         DONE ALL RECORDS ?                  80165
         BH    ASMIDEOX      YES; QUIT                           80165
         A     R2,IDRPTR+4   GET NEXT ENTRY                      80165
         B     ASMIDEOT       AND FILL IT                        80165
ASMIDEOX CLI   MSGTEXT1+2,0  SINGLE ENTRY ?                      80165
         BNE   ASMIDEOV      NO;  PROCESS VARIABLE LIST          80165
         XC    WORKWORK+4(4),WORKWORK+4  ZERO NEW IDR POINTER    80165
         SH    R5,=H'18'     ADJUST RESIDUAL LENGTH              80165
         MVC   MSGTEXT1(100),MSGTEXT1+18  SHIFT OVER             80165
         B     ASMIDLOP      DO NEXT ENTRY, IF ANY               80165
ASMIDEOV MVC   MSGTEXT1+3(103),MSGTEXT1+18  CLOBBER PRIOR ENTRY  80165
         SH    R5,=H'15'     SUBTRACT LIST ENTRY LENGTH          80165
         XR    R1,R1                                             80165
         IC    R1,MSGTEXT1+2  GET NUMBER OF LIST ENTRIES         80165
         BCTR  R1,0                                              80165
         STC   R1,MSGTEXT1+2                                     80165
         MVC   MSGTEXT1(2),=X'8000'   SET RECURSION ENTRY        80165
         B     ASMIDLOP      REPROCESS ALL ENTRIES               80165
         SPACE 1
*        PROCESS IMASPZAP IDR RECORDS
         SPACE 1
ZAPIDR   XR    R2,R2
         NI    0(R3),X'3F'
         IC    R2,0(,R3)       GET COUNT OF IMASPZAP ENTRIES
         LA    R14,19        SET FOR MAX VALID COUNT
         CR    R2,R14        IS COUNT VALID ?
         BNH   *+6           YES
         LR    R2,R14        USE ONLY MAX
         LA    R3,1(,R3)
         LA    R2,1(,R2)       JUMP COUNT FOR LOOP
         B     ZAPIDR1
ZAPIDR2  BAL   R14,GETIDR
         MVC   IDRESDID,0(R3) MOVE ESDID TO IDR RECORD
         LA    R1,2(,R3)       ADDRESS OF DATE OF RECORD
         BAL   R14,SETIDRDT
         MVC   IDRDATA(8),5(R3)  MOVE DATA TO IDR RECORD
         MVI   IDRLDATA,8-1   SET LENGTH FOR COMPATIBILITY
         MVI   IDRTYPE,MYDRZAP   INDICATE IMASPZAP ENTRY         80165
         LA    R3,13(,R3)      JUMP DATA ADDRESS
ZAPIDR1  BCT   R2,ZAPIDR2     IF ANOTHER ENTRY THIS RECORD
         B     NEXTIDR        READ NEXT IDR RECORD
         SPACE 1
*        LINKAGE EDITOR IDR RECORD PROCESSOR
         SPACE 1
LKEDIDR  OI    FLAGS+1,FIDR
         LA    R1,12(,R3)      ADDRESS OF DATE
         LA    R15,LKEDDATE
         BAL   R14,SETLKDTE
NEXTIDR  TM    FLAGS+1,F1IDR  LAST IDR RECORD?
         BZ    IDREXCP        NO
         SPACE 1
LASTIDR  L     R6,IDRPTR     GET FIRST ENTRY
         LM    R4,R5,IDRPTR+4  GET LENGTH AND LAST ENTRY
         LR    R15,R5        COPY LAST ENTRY
         SR    R5,R4
         LR    R14,R4        COPY LENGTH
         CR    R15,R6        ONLY ONE ENTRY ?
         BNH   IDROUT        YES; SKIP SORT
         LA    R9,IDRSBUMP   SET FOR FAST BRANCH
IDRSORT  LA    R1,0(R4,R6)   SET NEXT ENTRY
IDRSCLC  CLC   IDRDATE,IDRDATE-IDRENTRY(R1)
         BNLR  R9            BUMP
         XC    IDRSTART(LENIDR1),IDRSTART-IDRENTRY(R1)
         XC    IDRSTART-IDRENTRY(LENIDR1,R1),IDRSTART
         XC    IDRSTART(LENIDR1),IDRSTART-IDRENTRY(R1)
IDRSBUMP BXLE  R1,R14,IDRSCLC
         BXLE  R6,R4,IDRSORT
IDROUT   LM    R14,R9,12(R13)  RESTORE EXCEPT R10                80028
         TM    FLAGS+1,FIDR   ANY IDR RECORDS?
         BZR   R14            NO
         B     4(,R14)        YES
         SPACE 1
GETIDR   L     R6,IDRPTR2    GET CURRENT ENTRY
         SLR   R15,R15                                           91193
         ICM   R15,3,DRMAXL   GET MODULE SIZE                    91193
         LA    R0,X'FFF'(R15,R7)  GET BASE +                     91193
         N     R0,=X'00FFF000'  KILL FLAG BYTE AND EXTRA         91193
         A     R6,IDRPTR+4   MAKE NEXT ENTRY
         S     R0,IDRPTR+4   MAKE LAST FITTING ENTRY
         CR    R6,R0         WILL THIS ONE FIT ?
         BNH   GETIDROK
         LA    R6,ESDOFLOW   MAKE OVERFLOW MESSAGE
GETIDRMG BAL   R14,PUTLINE
         B     LASTIDR       SIGNAL END
GETIDROK ST    R6,IDRPTR2    SET NEW LAST ENTRY
         MVC   IDRDATA,BLANKS  CLEAR FOR ASM IDR                 80165
         BR    R14           RETURN TO CALLER
         SPACE 2
SETIDRDT LA    R15,IDRDATE
SETLKDTE ST    R14,DWFSAVE
         UNPK  DB(7),0(4,R1)  UNPACK THE PRESUMED DATE
         CLI   DB+5,X'F9'    PACKED SIGN ?
         BNH   DATEBAD       NO; BAD DATE
         LA    R14,DB
         LA    R0,5          CHECK FOR FIVE NUMERICS
DATECHEK CLI   0(R14),C'9'   VALID NUMERIC ?
         BH    DATEBAD
         LA    R14,1(,R14)
         BCT   R0,DATECHEK
         B     DATEOK
DATEBAD  XC    0(3,R15),0(R15)  CLEAR OUTPUT
         L     R14,DWFSAVE
         BR    R14           QUIT
DATEOK   MVC   DAYTABLE,DAYMONTH
         XC    DB,DB
         LR    R14,R1
         TM    0(R14),1      ODD YEAR ?
         BNZ   DAYNTLIP      YES; NOT LEAP
         TM    0(R14),X'12'   THIS A LEAP YEAR?
         BM    DAYNTLIP       NO
         MVI   DAYTABLE+1,29  YES, FEB HAS 29 DAYS
DAYNTLIP MVC   2(1,R15),0(R14) YEAR RECORD CREATED
         MVC   DB+6(2),1(R14)
         CVB   R1,DB         GET RELATIVE DAYS IN BINARY
         LA    R14,DAYTABLE
         XR    R0,R0
DAYLOOP  IC    R0,0(,R14)      DAYS THIS MONTH
         SR    R1,R0          WITHIN THIS MONTH?
         BNP   DAYNOW
         LA    R14,1(,R14)
         B     DAYLOOP
DAYNOW   AR    R1,R0          GET DAY OF THE MONTH
         LA    R0,10
         MR    R0,R0
         CVD   R1,DB
         MVC   1(1,R15),DB+6
         LA    R1,DAYTABLE-1
         SR    R14,R1
         CH    R14,H12       VALID MONTH ?
         BH    DATEBAD       NO
         LA    R1,10
         MR    R0,R14
         CVD   R1,DB
         MVC   0(1,R15),DB+6
         L     R14,DWFSAVE
         BR    R14
         SPACE 2
IDRENTRY DSECT
IDRSTART EQU   *
IDRESDID DS    XL2
IDRTYPE  DS    X
IDRZAP   EQU   X'01'
IDRLKED  EQU   X'02'
IDRASM   EQU   X'04'                                             80165
IDRUSER  EQU   X'08'
MYDRZAP  EQU   3             INTERNAL CODES - HIST STARTS WITH ZAP
MYDRUSER EQU   2             THEN DOES USER DATA                 80165
MYDRASM  EQU   1             THEN ASM/COMP.                      80165
IDRDATE  DS    XL3
IDRLDATA DS    X
IDRZDATA DS    0CL8
*IDRDATA DS    CL40          OLD LENGTH                          80165
IDRDATA  DS    CL21          NEW LENGTH - REDUCED TO FIT NUCLEUS DATA
LENIDR1  EQU   *-IDRSTART
LENIDR   EQU   *-IDRENTRY
         SPACE 1                                                 80165
HSDENTRY DSECT ,             CONDENSED VERSION OF ESD LIST       80165
HSDNAME  DS    CL8           SD NAME                             80165
HSDID    DS    XL2           ESD ID                              80165
LENHSD   EQU   *-HSDNAME     LENGTH OF CONDENSED ENTRY           80165
&SECTS   CSECT ,
.NOIDR   AIF   ('&IDR' EQ 'NO' AND '&ESD' EQ 'NO').MEND          81018
         SPACE 1                                                 81018
SETERR42 CLI   DRECB,X'42'   END OF EXTENT ?                     81018
         BNE   4(,R9)        NO; REAL ERROR.  TREAT AS EOF       81018
         XR    R14,R14                                           81018
         XR    R15,R15                                           81018
         IC    R14,DRMBB     GET LAST EXTENT NUMBER              81018
         L     R1,DRDEB      GET DEB                             81018
         NUSE  DEB,R1                                            81018
         IC    R15,DEBNMEXT   GET MAXIMUM EXTENT NUMBER          81018
         DROP  R1                                                81018
         LA    R14,1(,R14)   UP CURRENT RELATIVE NUMBER          81018
         CR    R14,R15         STILL VALID ?                     81018
         BNL   4(,R9)        NO; ERROR.  TREAT AS EOF            81018
         LH    R14,DRTTR     GET PRIOR TT                        81018
         LA    R14,1(,R14)     UP TT                             81018
         SLL   R14,16        MAKE TT00                           81018
         ST    R14,DRTTR                                         81018
         BR    R9            RETRY I/O IN NEXT EXTENT            81018
.MEND    MEND  ,                                                 81018
