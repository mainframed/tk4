         MACRO
&TAG     SRCH  &TREE,&A=,&K=,&Y=,&N=,&NULL=,&T=,&REL=,                 X
               &SARG=,&EQUAL=,&UNEQUAL=,&TYPE=,&KEYL=
.*A000000                                                        Y02147
.*  THE MEANINGS OF THE PARAMETERS FOR THE SRCH MACRO-INSTRUCTION ARE *
.*  AS FOLLOWS:                                                       *
.*--------------------------------------------------------------------*
.*  &TREE  IS THE ADDRESS OF THE RADIX PARTITION TREE.                *
.*         IF "TREE" IS CODED, WHERE "TREE" IS A SUITABLE OPERAND FOR *
.*         A LOAD ADDRESS INSTRUCTION, THE THE MAIN STORAGE LOCATION  *
.*         SO SPECIFIED IS PRESUMED TO CONTAIN THE ADDRESS OF THE RPT *
.*         AS RETURNED BY THE STREE MACRO-INSTRUCTION.                *
.*                                                                    *
.*         IF "(GPR)" IS CODED, THEN THE INDICATED REGISTER HAS THE   *
.*         ADDRESS OF THE RPT IN IT.                                  *
.*                                                                    *
.*         THE TREE ADDRESS IS LOADED INTO REGISTER 1 BY THE SRCH     *
.*         MACRO, SO THAT IF "(1)" IS CODED NO LOAD OR LR IS          *
.*         GENERATED.                                                 *
.*                                                                    *
.*         IF THE PARAMETER IS NOT CODED, THE MNOTE "TREE PARAMETER   *
.*         MISSING, ASSUMED IN R1." IS GENERATED WITH SEVERITY O, AND *
.*         THE ADDRESS OF THE RPT IS ASSUMED TO BE IN REGISTER 1.     *
.*--------------------------------------------------------------------*
.*  &T     IS THE TYPE OF THE RPT. SEE THE DESCRIPTION OF THE STREE   *
.*         MACRO INSTRUCTION FOR THE COMPLETE LIST OF OPERATIONS      *
.*         AVAILABLE WITH THE DIFFERENT TYPES OF TREES.               *
.*                                                                    *
.*        THE ONLY ALLOWED WAYS TO CODE THE T-PARAMETER ARE:          *
.*        T=5 FOR TYPE 5 RPT.                                         *
.*        T=8 FOR TYPE 8 RPT.                                         *
.*        IF THE T-PARAMETER IS NOT CODED A DEFAULT OF T=8 IS SUPPLIED*
.*--------------------------------------------------------------------*
.*  &A    SPECIFIES THE ADDRESS OF THE RECORD OR CONTROL BLOCK        *
.*        CONTAINING THE KEY TO BE USED IN THE SEARCH.                *
.*        THE A-PARAMETER, TOGETHER WITH THE K-PARAMETER, DEFINES     *
.*        THE SEARCH KEY.                                             *
.*                                                                    *
.*        IF "A=ADDRESS" IS CODED, WHERE "ADDRESS" IS A MAIN STORAGE  *
.*        LOCATION, THEN THE ADDRESS OF THE FIRST BYTE OF THE RECORD  *
.*        IS FORMED WITH A LOAD ADDRESS INSTRUCTION.                  *
.*                                                                    *
.*        IF "A=(GPR)" IS CODED, THEN THE ADDRESS OF THE FIRST BYTE   *
.*        OF THE RECORD IS IN THE SPECIFIED REGISTER.                 *
.*                                                                    *
.*--------------------------------------------------------------------*
.*  &K     SPECIFIES THE SEARCH KEY, WHEN TAKEN IN COMBINATION WITH   *
.*         THE A-PARAMETER. AT LEAST ONE OF THESE TWO PARAMETERS MUST *
.*         ALWAYS BE CODED, OR THE MNOTE "A OR K MUST BE CODED." IS   *
.*         GENERATED, WITH A SEVERITY CODE OF 12.                     *
.*                                                                    *
.*         THE FOLLOWING COMBINATIONS ARE VALID:                      *
.*         --- --------- ------------ --- ------                      *
.*                                                                    *
.*         "K=(DISPLACEMENT,LENGTH)", WHERE "DISPLACEMENT" IS EITHER  *
.*         A RELOCATABLE EXPRESSION OR A SELF-DEFINING ABSOLUTE       *
.*         DECIMAL NUMBER SPECIFYING EITHER THE ADDRESS OF BYTE ZERO  *
.*         OF THE KEY OR THE DISPLACEMENT FROM THE ADDRESS SPECIFIED  *
.*         BY THE A-PARAMETER TO THE FIRST BYTE OF THE KEY.           *
.*         "LENGTH" IS AN ABSOLUTE EXPRESSION GIVING THE LENGTH OF    *
.*         THE KEY. FOR TYPE 5 RPT, "LENGTH" IS A DECIMAL NUMBER.     *
.*                                                                    *
.*         FOR TYPE 5 RPT, THE KEY LENGTH CANNOT BE GREATER THAN 16.  *
.*         FOR TYPE 8 RPT, THE KEY LENGTH CANNOT BE GREATER THAN 256. *
.*                                                                    *
.*         IF THE A-PARAMETER IS CODED, THE ADDRESS OF THE FIRST      *
.*         BYTE OF THE KEY IS FORMED BY ADDING THE DISPLACEMENT TO THE*
.*         ADDRESS FROM THE A-PARAMETER. THE DISPLACEMENT MUST NOT    *
.*         EXCEED 4095.                                               *
.*                                                                    *
.*         IF THE A-PARAMETER IS CODED AND THE K-PARAMETER IS NOT     *
.*         CODED, THE THE K-PARAMETER IS ASSUMED TO BE THE SAME AS THE*
.*         K-PARAMETER THAT WAS CODED IN THE STREE MACRO WHEN THE RPT *
.*         WAS CREATED.                                               *
.*--------------------------------------------------------------------*
.*  &Y     IS THE ADDRESS TO BRANCH TO IF THE SEARCH KEY IS EQUAL TO  *
.*         THE KEY FOUND BY THE SEARCH.                               *
.*         IF  "Y=(GPR)" IS CODED, THEN THE ADDRESS TO BRANCH TO IF   *
.*         THEY ARE EQUAL IS IN THE SPECIFIED GPR.                    *
.*         IF THE  Y-PARAMETER IS NOT CODED, THEN EXECUTION CONTINUES *
.*         WITH THE NEXT INSTRUCTION AFTER THE SRCH MACRO.            *
.*--------------------------------------------------------------------*
.*  &N     IS THE ADDRESS TO BRANCH TO IF THE SEARCH KEY IS NOT EQUAL *
.*         TO THE KEY FOUND BY THE SEARCH. IT IS CODED THE SAME WAY   *
.*         THE  Y-PARAMETER IS CODED.                                 *
.*         NOTE THAT IF THE RPT HAS NO ENTRIES IN IT THE SEARCH KEY   *
.*         IS CONSIDERED NOT EQUAL.                                   *
.*--------------------------------------------------------------------*
.*  &NULL  IS THE ADDRESS TO BRANCH TO IF THERE ARE NO SINKS IN THE   *
.*         RPT. IT IS CODED IN THE SAME WAY AS THE N AND Y            *
.*         PARAMETERS. IF BOTH THE NULL AND N  PARAMETERS ARE CODED   *
.*         AND THE RPT IS EMPTY A BRANCH TO THE NULL ADDRESS IS TAKEN.*
.*                                                                    *
.*--------------------------------------------------------------------*
.*  &REL   IS A QUALIFIER SPECIFYING THE RELATIONSHIP BETWEEN THE     *
.*         SEARCH KEY AND THE KEY TO BE FOUND.                        *
.*                                                                    *
.*         THE REL PARAMETER IS CODED AS FOLLOWS:                     *
.*                                                                    *
.*             **  **     **               **   **  **                *
.*            **  **       **             **  LT **  **               *
.*           **   **  MAX  **             **  LE **   **              *
.*           **   **       **             **  EQ **   **              *
.*   REL=    **  **   MIN   **       ,,  **   --  **  **              *
.*           **   **  ---  **         ,,  **  GE **   **              *
.*           **   **       **         ,,  **  GT **   **              *
.*            **  **  POV  **        ,,   ** POV **  **               *
.*             **  **     **        ,,     **   **  **                *
.*                                 ,,                                 *
.*                                                                    *
.*         THUS "REL=(MAX,LE)" IMPLIES A SEARCH FOR THE LARGEST KEY   *
.*         THAT IS LESS THAN OR EQUAL TO THE SEARCH KEY.              *
.*                                                                    *
.*         WHEN THE REL PARAMETER IS CODED THE KEY LENGTH MUST BE     *
.*         CODED EXPLICTLY IN THE K PARAMETER.                        *
.*--------------------------------------------------------------------*
.*         WHEN "REL=(MAX/MIN,POV)" IS CODED, A SEARCH IS MADE TO FIND*
.*         THE LARGEST OR SMALLEST PARTIAL ORDER VALUE.               *
.*         WHEN "REL=(POV,GE)" IS CODED A SEARCH TO FIND A PARTIAL    *
.*         ORDER VALUE THAT IS GREATER THAN OR EQUAL TO THE SEARCH    *
.*         KEY, BUT IS THE SMALLEST THAT CAN BE SO DETERMINED         *
.*         EFFICIENTLY (NOT NECESSARILY THE SMALLEST POSSIBLE).       *
.*--------------------------------------------------------------------*
.*         ONLY THE FOLLOWING COMBINATIONS ARE VALID:                 *
.*                                                                    *
.*         REL=(MAX,LT/LE/EQ/POV)                                     *
.*         REL=(MIN,EQ/GE/GT/POV)                                     *
.*         REL=(POV,GE) MEANS FIND MIN POV>=KEY.                      *
.*--------------------------------------------------------------------*
.*         REL=(POV,EQ) MEANS FIND POV FOR THE SINK ADDRESSED BY THE  *
.*         CURRENT SETTING OF THE CURSOR.                             *
.*--------------------------------------------------------------------*
.*  &SARG      THESE ARE ONLY PRESENT FOR COMPATIBILITY WITH EARLIER  *
.*  &EQUAL     VERSIONS, AND SHOULD NOT BE USED.                      *
.*  &UNEQUAL                                                          *
.*  &TYPE                                                             *
.*  &KEYL                                                             *
         GBLC  &IGABLST  THE BEGINNING OF THE LIST OF ENTRY POINTS FOR *
                         THE RPT OPERATIONS.
         GBLC  &IGASRCH
         GBLC  &IGADDR   THE ADDRESS OF THE MODULE IGARPTXX.
         GBLC  &IGARPT#  THE RADIX PARTITION TREE TYPE.
         GBLA  &IGAPATH(16)  PATH VECTOR IN BIG PARSE TREE.
         GBLA  &IGALEVL      PATH LENGTH TO ATOM IN PARSE TREE.
         GBLA  &IGALEFT(256)  LEFT EDGE FIELDS IN PARSE TREE.
         GBLA  &IGARGHT(256)  RIGHT EDGE FIELDS IN PARSE TREE.
         GBLA  &IGAX  EOP TRIPLE FOR THE BINARY PARSE TREE WITH
         GBLA  &IGAY  SUBTRACTION INVERTIBLE EDGES GENERATED BY
         GBLA  &IGAZ  THE MACRO-INSTRUCTION RPTDSECT.
         GBLA  &IGAKEYL  THE LENGTH OF THE SEARCH KEY.
         GBLC  &IGAGPV  BRANCH ENTRY OFFSET TO GET THE PARTIAL ORDER
.*                      VALUE FOR THE CURSOR-SELECTED SINK (TYPE 9 RPT)
         GBLC  &IGAPVS  BRANCH ENTRY OFFSET TO THE ROUTINE IN IGARPT01
.*                      TO SEARCH FOR A PARTIAL ORDER VALUE THAT IS
.*                      GREATER THAN OR EQUAL TO THE SEARCH KEY.
         GBLC  &IGAEOPV  THE OFFSET TO THE PATH CODE BYTE IN THE TYPE 8*
                         RPT HEADER FOR THE PATH TO THE SINK CURRENTLY *
                         SELECTED BY THE CURSOR.
         GBLC  &IGACNT5  THE OFFSET TO THE USE COUNTER IN THE TYPE 5   *
                         RPT HEADER.
         GBLC  &IGAMSK5  THE OFFSET TO THE TABLE OF MASKS FOR TYPE 5   *
                         RPT.
         GBLC  &IGATOP5  THE OFFSET TO THE RPT SOURCE IN THE TYPE 5 RPT*
                         HEADER.
         GBLC  &IGAMAX   THE OFFSET TO THE WORD CONTAINING THE MAXIMUM *
                         PARTIAL ORDER VALUE.
         GBLC  &IGAKEYW  THE OFFSET TO THE WORD CONTAINING THE ADDRESS *
                         OF THE WORK AREA FOR COLLECTING KEYS.
         GBLB  &IGAOKAY  ON IF THE PARSE IN RPTDSECT DID NOT FIND ANY  *
                SYNTAX ERRORS IN THE R PARAMETER LIST.
         LCLA  &I        A LOCAL VARIABLE FOR KEEPING TRACK OF THE     *
                         CURRENT ENTRY BEING SCANNED IN THE R PARAMETER*
                         LIST.
         LCLA  &LNG      THE LENGTH OF THE CURRENT DISPLACEMENT-LENGTH *
                         PAIR.
         LCLC  &X        JUST A LOCAL CHARACTER VECTOR FOR COLLECTING  *
                         OPERANDS.
         LCLB  &FINEQU   ON IF THE EQUATE "FIN&SYSNDX EQU *" MUST BE   *
                         GENERATED AT THE END OF THE MACRO EXECUTION.
         LCLB  &ERROR    THIS BIT IS TURNED ON WHENEVER AN MNOTE OF    *
                         SUFFICIENT SEVERITY IS GENERATED.
         LCLB  &KLMNOTE  ON WHEN THE KEY LENGTH EXCEEDS 256 BYTES.
         LCLA  &DSP      THIS IS USED FOR COLLECTING THE DISPLACEMENT  *
                         AS A NUMBER.
         LCLC  &FIELD    THIS IS USED TO HOLD THE FIELD OF AN (F,L)    *
                         PAIR WHILE GETTING THE L.
         LCLB  &XFER     ON TO GENERATE THE MOVES WHEN IT IS THE RIGHT *
               ITERATION THROUGH THE LOOP.
         LCLA  &KL             KEY LENGTH ARITHMETIC VARIABLE.
         LCLA  &TMPA     A LOCAL ARITHMETIC TEMPORARY.
         LCLB  &WORKEY   ON IF THE KEY IS COLLECTED AT IGAWORK.
         LCLB  &USING    THIS BIT IS TURNED ON WHEN A USING WITH       *
                         REGISTER R1 IS GENERATED.
         LCLB  &FIN      ON IF THE FIN&SYSNDX EQU * IS TO BE GENERATED *
                         AT THE END.
         LCLC  &P,&C,&S,&GOLEFT,&ITSMOP,&ITSEOP,&TREEHDR,&ARG,&EKER
         LCLC  &EKE,&TOOBAD,&FOUR,&O
         LCLC  &R1       GENERAL REGISTER 1.
         LCLC  &TMP      A TEMPORARY LOCAL CHARACTER VECTOR.
         LCLC  &TMP0     A LOCAL TEMPORARY CHARACTER VARIABLE.
         LCLC  &TMP1     A TEMPORARY LOCAL CHARACTER VECTOR.
         AIF   ((K'&SARG EQ 0)AND(K'&EQUAL EQ 0)AND(K'&UNEQUAL EQ 0)AND*
               (K'&KEYL EQ 0)).NEW
         AIF   (K'&KEYL EQ 0).OLDKLZ  SEE IF THE OLD KEY LENGTH IS NOT *
                         GIVEN.
&TAG     SRCH  &TREE,A=&SARG,Y=&EQUAL,N=&UNEQUAL,T=&T,TYPE=&TYPE,K=(0, *
               &KEYL),NULL=&NULL,REL=&REL
         AGO   .END
.OLDKLZ  ANOP
         AIF   (K'&SARG LE 2).OLDONE  SEE IF THE SEARCH ARGUMENT IS NOT*
                         OF THE FORM "D(GPR)".
         AIF   (NOT(('&SARG'(1,1) LE '9')AND('&SARG'(1,1) GE '0'))).OLD*
               ONE       SEE IF IT NOT OF THE FORM "D(GPR)".
.**********************************************************************
.* THE OLD SEARCH ARGUMENT IS SPECIFIED AS "D(GPR)", TRANSLATE THIS   *
.* INTO A GOOD NEW FORMAT VIA THE MACRO RECURSION FACILITY.           *
.**********************************************************************
         AIF   ('&SARG'(K'&SARG,1) NE ')').OLDONE  HOWEVER, FIRST CHECK*
                         IT FOR VALIDITY.
&I       SETA  (1)       LOOK FOR THE LEFT PARENTHESIS.
.OLDLOOP ANOP
&I       SETA  (&I+1)    EKE THE INDEX TO THE NEXT CHARACTER.
         AIF   (&I GT (K'&SARG)).OLDONE  SEE IF THERE ISN'T ANY LEFT   *
                         PARENTHESIS.
         AIF   ('&SARG'(&I,1) NE '(').OLDLOOP  SEE IF IT IS STILL      *
                         GOING.
&TMP0    SETC  '&SARG'(1,&I-1)  PICK UP THE DISPLACEMENT FIELD.
&TMP1    SETC  '&SARG'(&I,K'&SARG-(&I+1))  GET THE GPR WITH ITS        *
                         SURROUNDING PARENTHESES.
&TAG     SRCH  &TREE,A=&TMP1,K=(&TMP0,),Y=&EQUAL,N=&UNEQUAL,T=&T,      *
               TYPE=&TYPE,NULL=&NULL,REL=&REL
         AGO   .END      ALL DONE NOW.
.OLDONE  ANOP
&TAG     SRCH  &TREE,A=&SARG,Y=&EQUAL,N=&UNEQUAL,T=&T,TYPE=&TYPE,      *
               NULL=&NULL,REL=&REL
         AGO   .END      ALL DONE NOW.
.NEW     ANOP
.**********************************************************************
.* CHECK THE TYPE AND T PARAMETERS TO SEE IF A VALID RPT TYPE IS      *
.* SPECIFIED. IF NEITHER IS SPECIFIED, ASSUME IT IS TYPE 8 RPT. THE   *
.* TYPE IS PUT INTO THE GLOBAL VARIABLE &IGARPT# AT THE END OF THE    *
.* TYPE CHECKING SECTION.                                             *
.**********************************************************************
.RPT#    AIF   (K'&T EQ 0).RPT#TMT  SEE IF THE T PARAMETER IS CODED.
         AIF   (K'&TYPE EQ 0).RPT#TCK  USE THE T PARAMETER IF IT IS    *
                         CODED AND THE TYPE PARAMETER IS NOT CODED.
.**********************************************************************
.* BOTH THE T AND TYPE PARAMETERS ARE CODED; SEE IF THEY ARE THE SAME,*
.* AND IF THEY ARE NOT THEN USE T.                                    *
.**********************************************************************
         AIF   ('&T' EQ '&TYPE').RPT#TCK  IF THEY ARE THE SAME THEN USE*
                         T.
         MNOTE 4,'TYPE CONFLICT, ONLY T OR TYPE SHOULD BE CODED.'
.RPT#TCK ANOP
&IGARPT# SETC  '&T'      GET THE RPT TYPE.
         AGO   .RPT#CHK  GO TO CHECK THE VALIDITY OF THE RADIX         *
                         PARTITION TREE TYPE.
.**********************************************************************
.* THE T PARAMETER IS NOT CODED, SEE IF THE TYPE PARAMETER IS CODED.  *
.**********************************************************************
.RPT#TMT AIF   (K'&TYPE EQ 0).RPT#8  IF BOTH ARE LEFT OUT USE TYPE 8   *
                         RPT.
&IGARPT# SETC  '&TYPE'   SET THE TYPE TO THE TYPE THAT IS SPECIFIED BY *
                         THE TYPE PARAMETER.
         AGO   .RPT#CHK  GO CHECK IT FOR VALIDITY.
.RPT#8   ANOP
&IGARPT# SETC  '8'       SET THE RPT TYPE TO 8.
.RPT#CHK AIF   (('&IGARPT#' EQ '8')OR('&IGARPT#' EQ '5')OR('&IGARPT#' E*
               Q '4')).RPT#FIN
         MNOTE 4,'INVALID RPT TYPE, TYPE 8 ASSUMED.'
&IGARPT# SETC  '8'       TAKE THE DEFAULT TYPE 8 RPT.
.RPT#FIN ANOP
      RPTDSECT T=&IGARPT#,DS=0  DON'T GENERATE THE BIG DSECT.
.**********************************************************************
         AIF   (K'&TREE NE 0).CHKGPR  SEE IF THE TREE ADDRESS IS CODED.
         MNOTE 0,'TREE PARAMETER MISSING, ASSUMED IN R1.'
         AGO   .CHKTAG  GO CHECK THE LABEL TO SEE IF EQU * NEEDED.
.CHKGPR  ANOP
         AIF   (K'&TREE EQ K'&TREE(1)+2 AND N'&TREE EQ 1).LW1
&TAG     L     1,&TREE   LOAD ADDRESS OF PARAMETER LIST.
         AGO   .LW2
.LW1     ANOP
         AIF   ('&TREE' NE '(1)').LW1F  SEE IF THE TREE ADDR IS IN GPR1
.CHKTAG  ANOP
         AIF   (K'&TAG EQ 0).LW1B  SINCE THERE IS NO LR, DOES IT HAVE
.*                                 TO GENERATE THE LABEL EQU * ?
&TAG     EQU   *
.LW1B    AGO   .LW2      DONE WITH LABEL AND TREE.
.LW1F    ANOP
&TAG     LR    1,&TREE(1)
.**********************************************************************
.* THE TREE ADDRESS IS NOW IN REGISTER 1.                             *
.**********************************************************************
.LW2     AIF   ((K'&A NE 0)OR(K'&K NE 0)).LW3  MAKE SURE THAT EITHER
.*             THE A OR K PARAMETER IS CODED.
         MNOTE 12,'A OR K MUST BE CODED.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
.LW3     ANOP
&R1      SETC  '1'  REGISTER 1 FOR USING STATEMENT.
.*--------------------------------------------------------------------*
.*  BRANCH OUT TO THE VARIOUS SEARCHES HERE.                          *
         AIF   ('&IGARPT#' EQ '8').SRCH8  SEE IF THIS IS A TYPE 8 RPT.
         AIF   ('&IGARPT#' EQ '5').SRCH5  SEE IF THIS IS A TYPE 5 RPT.
         MNOTE 12,'INVALID RPT TYPE, NO TYPE &IGARPT#.'
         MEXIT
.*--------------------------------------------------------------------*
.* SRCH8, USING THE SUBROUTINE IN IGARPT01.                           *
.*                                                                    *
.*       FOR SRCH8:                                                   *
.* 0. LEFT AND RIGHT INVERTIBLE EDGES, 3 BYTES LONG, EITHER OF THE    *
.*    SUBTRACTION OR EXCLUSIVE-OR TYPE.                               *
.* 1. NO SUCCESSOR PAIRING.                                           *
.* 2. MAXIMUM OF A 256-BYTE KEY IS SUPPORTED.                         *
.* 3. THE FLAG BITS ARE STORED WITH THE PREDECESSOR VERTEX.           *
.* 4. SCANNING FUNCTIONS ARE SUPPORTED WITH INVERTIBLE EDGES.         *
.*--------------------------------------------------------------------*
.SRCH8   ANOP
.**********************************************************************
.* CHECK THE REL PARAMETER TO SEE IF A PARTIAL ORDER VALUE IS         *
.* INVOLVED.                                                          *
.**********************************************************************
         AIF   (K'&REL NE 0).NOTPOV  SEE IF THE REL PARAMETER IS NOT   *
                         CODED.
         AIF   (N'&REL NE 1).TWOREL  SEE IF THERE ARE TWO ELEMENTS IN  *
                         THE REL PARAMETER.
         AIF   ('&REL(1)' EQ 'POV').POVGET  SEE IS THE SEARCH IS JUST  *
                         TO GET THE POV FROM THE CURRENT CURSOR        *
                         SETTING, OR USING THE KEY (IF THERE IS ONE).
         AGO   .NOTPOV   IT IS NOT A PARTIAL ORDER VALUE SEARCH.
.TWOREL  ANOP
         AIF   (('&REL(1)' EQ 'POV')OR('&REL(2)' EQ 'POV')).ITSAPOV    *
                         SEE IF A PARTIAL ORDER VALUE IS INVOLVED.
.NOTPOV  ANOP
.**********************************************************************
.* GENERATE THE ADDRESS OF THE SEARCH ARGUMENT IN REGISTER ZERO FOR   *
.* THE SEARCH SUBROUTINE IN THE MODULE IGARPT01.                      *
.* IF THE K PARAMETER IS NOT CODED JUST GO DIRECTLY TO .CHKA AND USE  *
.* THE ADDRESS SPECIFIED BY THE A PARAMETER.                          *
.* IF THE K PARAMETER IS CODED AND DEFINES A KEY CONSISTING OF MORE   *
.* THAN ONE FIELD, COLLECT IT AT IGAWORK IN THE TREE HEADER. THEN PUT *
.* THE ADDRESS OF IGAWORK IN REGISTER 0 FOR THE SEARCH.               *
.**********************************************************************
         AIF   (K'&K EQ 0).CHKA  SEE IF THERE IS NO SEARCH KEY         *
                         SPECIFIED.
.**********************************************************************
.* THE K PARAMETER HAS BEEN CHECKED AT THIS POINT, AND IS NOT THE     *
.* EMPTY STRING.                                                      *
.**********************************************************************
.LOOPAIR ANOP
&XFER    SETB  (1)       FOR THE SRCH MACRO ALWAYS GENERATE THE MOVES  *
                         ON THE SINGLE PASS THROUGH THIS PART.
&IGAKEYL SETA  0         INITIALIZE THE RECORD LENGTH TO ZERO.
         AIF   (N'&K EQ 2).KHAS2  SEE IF THERE ARE EXACTLY TWO ELEMENTS*
                         IN K ON PARENTHESIS LEVEL ONE.
         AIF   (N'&K NE 1).KMIXED  SEE IF THERE ARE MORE THAN TWO      *
                         ELEMENTS, FOR IF SO THE LIST CONSISTS OF A    *
                         SERIES OF FIELD NAMES OR (D,L) PAIRS.
.**********************************************************************
.* K HAS ONLY ONE ELEMENT ON LEVEL 1. FIND OUT WHICH OF THE FOLLOWING *
.* CASES APPLIES, AND TAKE THE INDICATED ACTION:                      *
.* IN THE FOLLOWING DISCUSSION, )F" MEANS A FIELD NAME, "D" MEANS     *
.* DISPLACEMENT, "L" MEANS LENGTH, AND "X" MEANS ANY STRING. THE D AND*
.* L FIELDS MUST BE SELF-DEFINING TERMS,.                             *
.* IF:   THEN:                                                        *
.* K=F   ENTER THE ROUTINE AT .KMIXED TO PROCESS A LIST OF PAIRS OF   *
.*       F'S AND (D,L) PAIRS, SINCE THIS CASE WILL BE TREATED AS A    *
.*       SINGLE FIELD NAME BY THAT ROUTINE.                           *
.* K=(F) THIS IS AN ERROR, BECAUSE OF THE POSSIBLE FUTURE USE OF THIS *
.*       FORM TO INDICATE THE ADDRESS OF A LIST OF DISPLACEMENT-LENGTH*
.*       PAIRS IN A REGISTER.                                         *
.* K=L   L IS THE LENGTH OF THE RECORD TO BE INSERTED. THE A PARMAETER*
.*       MUST BE CODED FOR THIS TO BE VALID, BECAUSE OTHERWISE THERE  *
.*       IS NO WAY TO FIND OUT WHERE THE RECORD IS THAT IS TO BE      *
.*       INSERTED.                                                    *
.* K=(L) THIS IS AN ERROR, BECAUSE OF THE POSSIBILITY THAT IN THE     *
.*       FUTURE I WILL WANT TO PUT THE ADDRESS OF A LIST OF           *
.*       DISPLACEMENT-LENGTH PAIRS IN A REGISTER.                     *
.* K=((X)) ENTER THE .KMIXED ROUTINE, SINCE IT LOOKS LIKE A LIST OF   *
.*       DISPLACEMENT-LENGTH PAIRS WITH ONLY ONE PAIR.                *
.*       ANYTHING ELSE IS INVALID, AND PRODUCES THE MNOTE 12,'INVALID *
.*       R-PARAMETER.'                                                *
.**********************************************************************
         AIF   ('&K'(1,1) NE '(').KNOTLP  SEE IF THERE ARE NO          *
                         PARENTHESES AROUND THE OPERAND.
         AIF   ('&K'(1,2) EQ '((').KMIXED  SEE IF THIS IS THE CASE     *
                         K=((X)).
         MNOTE 12,'A REGISTER CANNOT BE SPECIFIED FOR THE LIST OF DISPL*
               ACEMENT-LENGTH PAIRS.'
&ERROR   SETB  1         SET THE ERROR FLAG ON.
         AGO   .KFIN     END THIS PART.
.**********************************************************************
.* THIS MUST BE ONE OF THE TWO CASES K=F OR K=L.                      *
.**********************************************************************
.KNOTLP  ANOP
         AIF   (((T'&K(1) NE 'M')AND(T'&K(1) NE 'N')AND(T'&K(1) NE 'O')*
               AND(T'&K(1) NE 'T')AND(T'&K(1) NE 'W')AND(T'&K(1) NE '$'*
               )AND(T'&K(1) NE 'U'))).KMIXED
.* THIS MUST BE THE CASE WHERE "R=L" IS CODED.                        *
         AIF   (T'&K(1) NE 'N').K1NOTN  SEE IF IT IS A SELF-DEFINING   *
                         FIELD.
.**********************************************************************
.* K=L IS CODED, AND L IS A SELF-DEFINING TERM. USE L FOR THE RECORD  *
.* LENGTH, BUT FIRST CHECK TO SEE IF THE A PARAMETER IS CODED. IF THE *
.* A PARAMETER IS NOT CODED IT IS AN ERROR.                           *
.**********************************************************************
&IGAKEYL SETA  (&K(1))   GET THE RECORD LENGTH FROM THE L OF THE K     *
                         PARAMETER.
         AIF   (K'&A EQ 0).K1AMT  SEE IF THE A PARAMETER HAS BEEN LEFT *
                         OUT.
         AIF   (&IGAKEYL GT 256).K1LERR  FOR THE NONCE ONLY TAKE FIELDS*
                         THAT ARE LESS THAN 257 BYTES LONG.
         AIF   (NOT &XFER).KFIN  SEE IF THIS IS THE MVC GENERATION     *
                         LOOP, OR JUST THE VALIDATION AND ADDING UP    *
                         FIELD LENGTHS LOOP.
         AIF   ('&A'(1,1) EQ '(').K1AGPR  SEE IF THE ADDRESS IS IN A   *
                         GPR.
         LA    0,&A      ADDRESS OF SEARCH KEY.
         AGO   .KFIN     ALL DONE NOW.
.K1AGPR  AIF   ('&A' EQ '(0)').KFIN  SEE IF THE SEARCH KEY ADDRESS IS  *
                         ALREADY IN REGISTER 0.
         LR    0,&A(1)   ADDRESS OF SEARCH KEY.
         AGO   .KFIN     GO TO THE END OF THE K PARAMETER PROCESSING.
.**********************************************************************
.* FOLLOWING ARE THE MISCELLANEOUS ERROR MNOTES FROM THE SINGLE       *
.* ELEMENT CASE OF THE K PARAMETER.                                   *
.**********************************************************************
.K2LERR  ANOP
.K1LERR  MNOTE 12,'THE LENGTH OF EACH FIELD DEFINED BY K CANNOT EXCEED *
               256 BYTES.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON SO THE MVC'S DON'T GET  *
                         GENERATED.
         AGO   .KFIN
.K1AMT   MNOTE 12,'THE A PARAMETER MUST BE CODED WITH K AS CODED.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .KFIN
.K1NOTN  MNOTE 12,'THE LENGTH MUST BE A SELF-DEFINING TERM FOR THE K PA*
               RAMETER.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .KFIN
.**********************************************************************
.* THE K PARAMETER HAS EXACTLY TWO ELEMENTS IN IT ON LEVEL 1. SEE IF  *
.* EITHER OF THESE TWO ELEMENTS STARTS WITH A LEFT PARENTHESIS, WHICH *
.* MEANS ONE OF THE CASES K=(X,(X)), K=((X),X), OR K=((X),(X)). IF IT *
.* IS ONE OF THESE CASES ENTER THE MIXED ROUTINE AT .KMIXED.          *
.* IF IT IS NOT ONE OF THOSE THREE CASES, THEN IT MUST BE ONE OF THE  *
.* CASES K=(F,F), K=(F,L), OR K=(D,L). NOTE THAT THE CASE K=(D,L) CAN *
.* BE CODED AS K=(,L).                                                *
.**********************************************************************
.KHAS2   AIF   (K'&K(2) NE 0).K2NOTMT  SEE IF THE SECOND ELEMENT IS THE*
                         EMPTY STRING. THIS IS NO GOOD.
         MNOTE 12,'THE SECOND ELEMENT OF A DISPLACEMENT-LENGTH PAIR MUS*
               T BE CODED.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .FIN      FORGET IT, CAN'T DO ANYTHING WITH AN EMPTY    *
                         STRING FOR THE LENGTH.
.K2DMT   ANOP
&DSP     SETA  (0)       SET THE DISPLACEMENT TO ZERO, SINCE IT IS     *
                         CODED AS THE EMPTY STRING.
         AGO   .K2MERGE  MERGE WITH THE CASE WHERE THE DISPLACEMENT IS *
                         NOT THE EMPTY STRING.
.K2NOTMT AIF   (K'&K(1) EQ 0).K2DMT  SEE IF THE DISPLACEMENT IS THE    *
                         EMPTY STRING.
         AIF   (('&K(1)'(1,1) EQ '(')OR('&K(2)'(1,1) EQ '(')).KMIXED   *
                         LOOK FOR ONE OF THE CASES K=(X,(X)), K=((X),  *
                         X), OR K=((X),(X)).
         AIF   (((T'&K(2) NE 'M')AND(T'&K(2) NE 'N')AND(T'&K(2) NE 'O')*
               AND(T'&K(2) NE 'T')AND(T'&K(2) NE 'W')AND(T'&K(2) NE '$'*
               )AND(T'&K(2) NE 'U'))).KMIXED
.* THE SECOND ELEMENT IS NOT A FIELD NAME, SO IT MUST EITHER BE ONE OF*
.* THE TWO CASES K=(F,L) OR K=(D,L), OR IT IS AN ERROR.               *
&IGAKEYL SETA  0         ALLOW THE CASE WHERE THE LENGTH IS LEFT OUT   *
                         WHEN THERE IS ONLY ONE DISPLACEMENT.
         AIF    (K'&K EQ 0).MERGEK2  SEE IF THE LENGTH IS ELIDED.
         AIF   ((T'&K(1) NE 'M')AND(T'&K(1) NE 'N')AND(T'&K(1) NE 'O')A*
               ND(T'&K(1) NE 'T')AND(T'&K(1) NE 'W')AND(T'&K(1) NE '$')*
               AND(T'&K(1) NE 'U')).K2F1
         AIF   (T'&K(1) EQ 'N').K2D  SEE IF THE DISPLACEMENT IS A SELF-*
               DEFINING TERM.
&I       SETA  (K'&K(1)) THE DISPLACEMENT IS NOT A SELF-DEFINING TERM,
.K2DCHK  AIF   (('&K(1)'(&I,1) LT '0')OR('&K(1)'(&I,1) GT '9')).K2DTYPE
&I       SETA  (&I+1)    SEE IF IT IS A DECIMAL NUMBER ANYWAY.
         AIF   (&I GT 0).K2DCHK  THIS IS NECESSARY BECAUSE OF THE WAY  *
               ASSEMBLER F DOES NOT RECORD THE CORRECT TYPE ATTRIBUTE  *
               OF OPERANDS PASSED IN A SUBLIST VIA MACRO-RECURSION.
         AIF   (K'&K(1) GT 4).K2DERR  SEE IF IT HAS TOO MANY DIGITS.
.K2D     ANOP
&DSP     SETA  (&K(1))   PICK UP THE DISPLACEMENT.
.K2MERGE ANOP
         AIF   (T'&K(2) EQ 'N').K2L  SEE IF IT IS A SELF-DEFINING TERM.
&I       SETA  (K'&K(2))  SET THE INDEX TO IT'S INITIAL VALUE.
         AIF   (K'&K(2) EQ 0).K2LERR SEE IF IT IS THE EMPTY STRING.
.K2LCHK  AIF   (('&K(2)'(&I,1) LT '0')OR('&K(2)'(&I,1) GT '9')).K2LTYPE
&I       SETA  (&I-1)    DECREASE THE INDEX TO THE NEXT CHARACTER.
         AIF   (&I GT 0).K2LCHK  SEE IF THERE ARE MORE TO CHECK.
         AIF   (K'&K(2) GT 4).K2LERR  SEE IF IT HAS TOO MANY DIGITS.
.K2L     ANOP
&IGAKEYL SETA  (&K(2))   GET THE LENGTH AS A NUMBER.
.MERGEK2 ANOP
         AIF   (&IGAKEYL GT 256).K1LERR  SEE IF THE LENGTH IS MORE THAN*
                         256 BYTES.
         AIF   (&DSP GT 4095).K2DERR  SEE IF THE DISPLACEMENT IS       *
                         GREATER THAN 4095.
         AIF   (K'&A EQ 0).K1AMT  SEE IF THE A PARAMETER IS LEFT OUT;  *
                         THAT IS BAD.
         AIF   (NOT &XFER).KFIN  SEE IF THIS IS THE MVC GENERATING LOOP*
                         OR NOT.
.**********************************************************************
.* THERE IS ONLY ONE FIELD SPECIFIED FOR THE KEY; PUT ITS ADDRESS IN  *
.* REGISTER 0 FOR THE SEARCH SUBROUTINE IN IGARPT01.                  *
.**********************************************************************
         AIF   ('&A'(1,1) EQ '(').K2AGPR  SEE IF THE ADDRESS IS IN A   *
                         GPR.
         AIF   (&DSP EQ 0).K2SZDSP  SEE IF THE DISPLACEMENT IS ZERO.
         LA    0,&DSP+&A  ADDRESS OF SEARCH KEY.
         AGO   .KFIN
.K2SZDSP LA    0,&A      ADDRESS OF SEARCH KEY.
         AGO   .KFIN     ALL DONE WITH THE A AND K NOW.
.K2AGPR  AIF   (&DSP EQ 0).K2RZDSP  SEE IF THE DISPLACEMENT IS ZERO.
         LA    0,&DSP&A  ADDRESS OF SEARCH KEY.
         AGO   .KFIN
.K2RZDSP AIF   ('&A' EQ '(0)').KFIN  SEE IF THE ADDRESS IS ALREADY IN  *
                         REGISTER 0.
         LR    0,&A(1)   ADDRESS OF SEARCH KEY.
         AGO   .KFIN     ALL DONE GETTING THE ADDRESS OF THE SEARCH KEY*
                         IN REGISTER 0.
.**********************************************************************
.* IT IS AN (F,L) PAIR, NOW SEE IF THE SECOND ELEMENT IS A VALID L.   *
.**********************************************************************
.K2F1    AIF   (T'&K(2) EQ 'N').K2F  SEE IF IT IS A SELF-DEFINING TERM.
&I       SETA  (K'&K(2))  SET THE INDEX TO IT'S INITIAL VALUE.
.K2FCHK  AIF   (('&K(2)'(&I,1) LT '0')OR('&K(2)'(&I,1) GT '9')).K2LTYPE
&I       SETA  (&I+1)    EKE THE INDEX TO THE NEXT CHARACTER.
         AIF   (&I GT 0).K2FCHK  SEE IF THERE ARE MORE TO CHECK.
         AIF   (K'&K(2) GT 4).K2LERR  SEE IF IT HAS TOO MANY DIGITS.
.K2F     ANOP
&IGAKEYL SETA  (&K(2))   GET THE LENGTH OF THE (F,L) PAIR.
         AIF   (&IGAKEYL GT 256).K1LERR  SEE IF THE LENGTH OF THE FIELD*
                         IS MORE THAN 256.
         AIF   (NOT &XFER).KFIN  SEE IF THIS IS THE MOVE GENERATION    *
                         LOOP.
         AIF   (K'&A EQ 0).AISNT  SEE IF A ISN'T.
         MNOTE 4,'THE A PARAMETER IS REDUNDANT.'
.AISNT   LA    0,&K(1)   ADDRESS OF SEARCH KEY.
         AGO   .KFIN     ALL DONE NOW, GO CHECK FOR THE MOVE GENERATION*
                         ITERATION.
.**********************************************************************
.* THE FOLLOWING ARE THE SUNDRY MNOTES FOR THE TWO ELEMENT CASE FOR   *
.* THE K PARAMETER.                                                   *
.**********************************************************************
.K2DERR  MNOTE 12,'DISPLACEMENT IN K PARAMETER CANNOT EXCEED 4095.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .KFIN
.K2DTYPE MNOTE 12,'THE DISPLACEMENT IN K MUST BE A SELF-DEFINING TERM.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON TO PREVENT THE MVC      *
                         GENERATION.
         AGO   .KFIN
.K2LTYPE MNOTE 12,'THE LENGTH IN K MUST BE A SELF-DEFINING TERM.'
&ERROR   SETB  1         SET THE ERROR FLAG ON.
         AGO   .KFIN
.**********************************************************************
.* THE K PARAMETER CONSISTS OF A LIST OF MIXED PAIRS OF FIELDS AND    *
.* DISPLACEMENT-LENGTH PAIRS. PICK OUT ALL THESE AND CHECK THEM FOR   *
.* VALIDITY, WHILE ADDING UP ALL THE LENGTHS OF THE INDIVIDUAL FIELDS *
.* FOR THE MOVES TO IGAWORK, AND (POSSIBLY) FOR USE IN THE REL        *
.* PARAMETER LATER.                                                   *
.**********************************************************************
.* THIS IS THE SECTION TO PROCESS A MIXED LIST OF FIELD NAMES AND (D  *
.* ,L) PAIRS. PARSE THE OPERAND USING THE PARSE IN THE RPTDSECT       *
.* MACRO-INSTRUCTION, AND CHECK THE VARIABLE &IGAOKAY TO SEE IF THERE *
.* ARE NO SYNTAX ERRORS IN THE K PARAMETER.                           *
.**********************************************************************
.KMIXED  ANOP
      RPTDSECT SCAN=PARSE,LIST=&K  PARSE THE OPERAND.
         AIF   (&IGAOKAY).KMXOK  SEE IF THE PARSE DETECTED BAD SYNTAX.
         MNOTE 12,'INVALID SYNTAX IN THE K PARAMETER.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .KFIN     CAN'T DO ANYTHING WITH THIS.
.**********************************************************************
.* THE SYNTAX APPEARS TO BE OK, NOW START SCANNING OUT THE ATOMS ONE  *
.* AT A TIME, ANALYZING EACH ONE INDIVIDUALLY IN CONTEXT WITH THE ONES*
.* ON EITHER SIDE OF IT.                                              *
.**********************************************************************
.KMXOK RPTDSECT SCAN=ISCAN  INITIALIZE FOR SUBSEQUENT SCANNING OF      *
                         ATOMS.
         L     15,(&IGAKEYW+&IGABLST)(,1)   ADDR OF W.A. TO COLLECT THE
         BALR  14,0      SEARCH KEY OR THE ADDRESS OF A ROUTINE IN THE
         LTR   0,15      MODULE IGARPT01 TO GET AN AREA TO USE FOR
&WORKEY  SETB  (1)       ON TO INDICATE THAT THE KEY HAS BEEN COLLECTED*
                         AT IGAWORK.
         BCR   4,15      COLLECTING THE SEARCH KEY.
.KMXMOR RPTDSECT SCAN=NEXT  GET THE CURSOR POSITIONED AT THE NEXT ATOM.
.KMXCHK  AIF   (&IGAX EQ 0).KFIN  SEE IF THERE ARE ANY MORE TO DO.
         AIF   (&IGALEVL EQ 2).KMXLVL2  SEE IF THIS ATOM IS ON LEVEL 2.
         AIF   (&IGALEVL LE 1).KMXL01  SEE IF THIS ATOM IS ON LEVEL 0  *
                         OR 1.
.**********************************************************************
.* THE CURRENT ATOM HAS TOO MANY LEVELS OF PARENTHESES AROUND IT, GIVE*
.* THE ERROR MESSAGE AND GO LOOK FOR THE NEX THING THAT CHANGES LEVEL *
.* 1 IN THE PATH VECTOR.                                              *
.**********************************************************************
&I       SETA  &IGAPATH(1)+1  SET &I TO THE CURRENT OPERAND NUMBER.
         MNOTE 12,'TOO MANY () LEVELS IN OPERAND &I OF R.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
.**********************************************************************
.* AN ERROR HAS BEEN DETECTED AND FLAGGED IN THE CURRENT OPERAND. SCAN*
.* OVER TO THE NEXT ATOM THAT IS NOT PART OF THE CURRENT ENTRY ON     *
.* LEVEL 1 IN THE PARAMETER.                                          *
.**********************************************************************
.SYNC    ANOP
&I       SETA  &IGAPATH(1)  SET &I TO THE INDEX OF THE OPERAND ON LEVEL*
                         1.
      RPTDSECT SCAN=NEXT  SET THE CURSOR TO THE NEXT ONE.
         AIF   (&IGAX EQ 0).KFIN  SEE IF THERE AREN'T ANY MORE.
         AIF   (&I EQ &IGAPATH(1)).SYNC  SEE IF IT IS STILL ON THE SAME*
                         ONE.
         AGO   .KMXCHK   FINALLY GOT THE NEXT ATOM, NOW GO CHECK IT FOR*
                         VALIDITY.
.**********************************************************************
.* THE CURRENT ATOM IS ON LEVEL 0 OR 1. THEREFORE IT SHOULD BE A VALID*
.* FIELD NAME; SEE IF IT IS.                                          *
.**********************************************************************
.KMXL01  ANOP
.KMX01   ANOP
&I       SETA  (1+&IGAPATH(1))  SET &I TO THE 1-ORIGIN INDEX OF THE    *
                         FIELD NAME ON LEVEL 1.
         AIF   ((T'&K(&I) NE 'M')AND(T'&K(&I) NE 'N')AND(T'&K(&I) NE 'O*
               ')AND(T'&K(&I) NE 'T')AND(T'&K(&I) NE 'W')AND(T'&K(&I) N*
               E '$')AND(T'&K(&I) NE 'U')).KMX01OK
         MNOTE 12,'OPERAND &I OF K DOES NOT HAVE THE PROPER TYPE ATTRIB*
               UTE.'
&ERROR   SETB  (1)       SET THE ERROR FLAG.
         AGO   .SYNC     GO POSITION THE CURSOR TO THE NEXT ONE.
.**********************************************************************
.* THE CURRENT ATOM LOOKS LIKE A VALIID FIELD NAME, GET ITS LENGTH    *
.* ATTRIBUTE AND SEE IF IT ACCEPTABLE.                                *
.**********************************************************************
.KMX01OK ANOP
&LNG     SETA  (L'&K(&I))  CAPTURE IT AS A NUMBER.
         AIF   (&LNG LE 256).KMX0LOK  SEE IF IT EXCEEDS 256.
         MNOTE 12,'THE LENGTH OF FIELD &I OF K EXCEEDS 256 BYTES.'
&ERROR   SETB  (1)       SET TEH ERROR FLAG.
         AGO   .SYNC     GO LOOK AT THE NEXT ONE.
.KMX0LOK ANOP
.**********************************************************************
.* NOW SEE IF THIS IS THE MOVE GENERATION ITERATION.                  *
.**********************************************************************
         AIF   (NOT &XFER).KX0M  GO IF THIS ISN'T THE MOVE GENERATION  *
                         ITERATION.
         MVC   &IGAKEYL.(&LNG,15),&K(&I)         MOVE SUBKEY.
.KX0M    ANOP
&IGAKEYL SETA  (&IGAKEYL+&LNG)  EKE THE CUMMULATIVE RECORD LENGTH.
         AIF   (&IGAKEYL LE 256).KMXMOR  SEE IF THE KEYL LENGTH IS     *
                         STILL LESS THAN 257.
         AIF   (&KLMNOTE).KMXMOR  SEE IF THE MNOTE HAS ALREADY BEEN    *
                         GENERATED.
&KLMNOTE SETB  (1)       SET THE BIT ON SO THE MNOTE ONLY GETS         *
                         GENERATED ONCE.
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         MNOTE 12,'KEY LENGTH EXCEEDS 256 BYTES.'
         AGO   .KMXMOR   GO LOKK FOR THE NEXT ONE.
.**********************************************************************
.* THE CURRENT ATOM IS ON LEVEL 2. IT MUST THEREFORE BE THE FIRST     *
.* ELEMENT IN ONE OF THE CASES (F,L) OR (D,L).                        *
.* FIND OUT WHETHER THE CURRENT ATOM IS AN F OR A D.                  *
.**********************************************************************
.KMXLVL2 ANOP
&X       SETC  '0'       SET THIS FOR THE CASE WHERE THE DISPLACEMENT  *
                         IS AN EMPTY STRING.
         AIF   (&IGAZ EQ 0).KMGDSP  GO IF IT IS AN EMPTY STRING, WHICH *
                         MEANS A DISPLACEMENT OF 0.
.**********************************************************************
.* SEE IF ALL THE CHARACTERS IN THE CURRENT ATOM ARE DIGITS 0 THROUGH *
.* 9, WHICH WOULD MAKE IT A SELF-DEFINING DECIMAL TERM.               *
.**********************************************************************
&I       SETA  0         INITIALIZE THE INDEX OF THE CURRENT CHARACTER *
                         IN THE ATOM.
.KMCONT  AIF   (('&K'(&IGALEFT(&IGAZ)+&I,1) LT '0')OR('&K'(&IGALEFT(&IG*
               AZ)+&I,1) GT '9')).KMNOTD
&I       SETA  (&I+1)    EKE THE INDEX.
         AIF   (&I LT &IGARGHT(&IGAZ)).KMCONT  KEEP GOING UNTIL ALL    *
                         DIGITS HAVE BEEN EXAMINED.
         AIF   (&IGARGHT(&IGAZ) GT 4).KMXBADD  SEE IF THE DISPLACEMENT *
                         HAS TOO MANY BYTES IN IT.
&X       SETC  '&K'(&IGALEFT(&IGAZ),&I)  GET THE DISPLACEMENT AS A     *
                         NUMBER.
.KMGDSP  ANOP
&DSP     SETA  (&X)      GET THE NUMBER NOW.
         AIF   (&DSP GT 4095).KMXDBAD  SEE IF THE DISPLACEMENT IS TOO  *
                         BIG.
.**********************************************************************
.* THE CURRENT ATOM IS A VALID DISPLACEMENT OF A (D,L) PAIR, AND ITS  *
.* ARITHMETIC VALUE IS IN THE APPROPRIATE RANGE OF VALUES FOR A       *
.* DISPLACEMENT. ITS VALUE HAS BEEN CAPTURED IN &DSP. NOW LOOK FOR THE*
.* CORRESPONDING L OF THE PAIR.                                       *
.**********************************************************************
&I       SETA  (&IGAPATH(1))  SAVE THE CURRENT ATOM LEVEL 1 INDEX.
      RPTDSECT SCAN=NEXT  POSITION THE CURSOR TO THE NEXT ATOM.
         AIF   (&IGAX EQ 0).KMXNOLL  SEE IF THERE ISN'T ANY L FOR IT   *
                         BECAUSE THERE AREN'T ANY MORE ATOMS.
         AIF   (&IGAPATH(1) NE &I).KMXNOL  SEE IF THE NEXT ATOM IS PART*
                         OF A DIFFERENT ELEMENT ON LEVEL 1.
         AIF   (&IGALEVL NE 2).KMXPRN  SEE IF THERE ARE TOO MANY LEVELS*
                         OF PARENTHESES.
         AIF   (&IGAZ EQ 0).KMXLBAD  SEE IF THE L ATOM IS THE EMPTY    *
                         STRING.
.**********************************************************************
.* THERE IS A NEXT ATOM IN THE SAME PAIR, NOW CHECK IT TO SEE IF IT IS*
.* A SELF-DEFINING DECIMAL TERM.                                      *
.**********************************************************************
&I       SETA  0  INITIALIZE THE INDEX OF THE CURRENT BYTE IN THE ATOM.
.KMCNT1  AIF   (('&K'(&IGALEFT(&IGAZ)+&I,1) LT '0')OR('&K'(&IGALEFT(&IG*
               AZ)+&I,1) GT '9')).KMXBADL
&I       SETA  (&I+1)    EKE THE INDEX TO THE NEXT BYTE.
         AIF   (&I LT &IGARGHT(&IGAZ)).KMCNT1  KEEP LOOKING UNTIL ALL  *
                         THE BYTES ARE EXAMINED.
         AIF   (&IGARGHT(&IGAZ) GT 4).KMXLERR  SEE IF THE LENGTH IS    *
                         MORE THAN 4 CHARACTERS.
&X       SETC  '&K'(&IGALEFT(&IGAZ),&IGARGHT(&IGAZ))  GET THE LENGTH.
&LNG     SETA  (&X)      TURN IT INTO A NUMBER.
         AIF   (&LNG GT 256).KMXLERR  SEE IF IT IS TOO BIG TO DO WITH  *
                         AN MVC.
.**********************************************************************
.* THE DISPLACEMENT OF THE DISPLACEMENT-LENGTH PAIR IS AT &DSP, AND   *
.* THE LENGTH IS AT &LNG. CHECK THE A PARAMETER TO SEE IF IT IS CODED,*
.* BECAUSE IF IT ISN'T CODED THERE IS NO WAY TO FIND OUT WHERE THE    *
.* RECORD REALLY IS.                                                  *
.**********************************************************************
         AIF   (K'&A EQ 0).KMXAMT  SEE IF IT ISN'T THERE.
.* NOW GENERATE THE MOVE OF THE FIELD IF THIS IS THE MOVE GENERATION  *
.* ITERATION.                                                         *
         AIF   (NOT &XFER).KMOVED  SEE IF IT ISN'T THE MOVE GENERATION *
                         ITERATION.
&X       SETC  ''        SET IT UP FOR THE ADDRESS IN A REGISTER.
         AIF   ('&A'(1,1) EQ '(').KMAGPR  GO IF THE ADDRESS IS IN A    *
                         REGISTER.
&X       SETC  '+'       SET IT UP FOR THE CASE EHERE THE ADDRESS IS   *
                         SUPPLIED IN THE FORM OF A LABEL.
.KMAGPR  MVC   &IGAKEYL.(&LNG,15),&DSP&X&A            MOVE SUBKEY.
.KMOVED  ANOP
&IGAKEYL SETA  (&IGAKEYL+&LNG)  EKE THE CUMMULATIVE RECORD LENGTH.
         AIF   (&IGAKEYL LE 256).STILLOK  SEE IF THE CUMMULATIVE KEY   *
                         LENGTH HAS GONE OVER 256 BYTES.
         AIF   (&KLMNOTE).STILLOK  SEE IF THE MNOTE HAS ALREADY BEEN   *
                         GENERATED.
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
&KLMNOTE SETB  (1)   SET IT ON SO THE MNOTE HAS ALREADY BEEN GENERATED.
         MNOTE 12,'KEY LENGTH IS TOO BIG   256 BYTES IS MAX.'
.STILLOK ANOP
.**********************************************************************
.* NOW SET THE CURSOR TO THE NEXT ATOM, AND SEE IF THE FIRST ELEMENT  *
.* IS PART OF THE SAME ELEMENT ON LEVEL 1 AS THE LAST (D,L) PAIR.     *
.**********************************************************************
&I       SETA  &IGAPATH(1)  PRESERVE THE CURRENT LEVEL 0 INDEX.
      RPTDSECT SCAN=NEXT  POSITION THE CURSOR TO THE NEXT ATOM.
         AIF   (&IGAX EQ 0).KFIN  GO IF THERE ISN'T ANY NEXT ATOM.
         AIF   (&I EQ &IGAPATH(1)).KMXSAME  SEE IF THE LEVEL 1 ELEMENT *
                         IN THE PATH VECTOR DIDN'T CHANGE.
         AGO   .KMXCHK   GO CHECK THE NEXT ATOM, IT ISN'T PART OF THE  *
                         LAST TWO.
.**********************************************************************
.* THE FOLLOWING ARE SUNDRY MNOTES FROM THE PROCESSING OF A LIST OF   *
.* MIXED PAIRS WHERE THE PAIRS ARE OF THE FORM (D,L).                 *
.**********************************************************************
.KMXSAME ANOP
&I       SETA  (&IGAPATH(1)+1)  SET &I TO THE CURRENT OPERAND #.
         MNOTE 12,'TOO MANY ELEMENTS IN SUBLIST OPERAND &I IN R.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .SYNC     GO LOOK FOR THE NEXT ONE.
.KMXAMT  ANOP
&I       SETA  (1+&IGAPATH(1))  GET THE CURRENT OPERAND NUMBER.
         MNOTE 12,'THE A PARAMETER MUST BE CODED TO USE A (D,L) PAIR FO*
               R K(&I).'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .SYNC     GO LOOK FOR THE NEXT ONE.
.KMXLERR ANOP
&I       SETA  (&IGAPATH(1)+1)  GET THE CURRENT OPERAND NUMBER.
         MNOTE 12,'THE LENGTH OF THE FIELD DEFINED BY K(&I) EXCEEDS 256*
                BYTES.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .SYNC     GO LOOK AT THE NEXT ONE.
.KMXBADL ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'THE LENGTH FOR K(&I) MUST BE A SELF-DEFINING DECIMAL*
                NUMBER.'
&ERROR   SETB  (1)
         AGO   .SYNC
.KMXLBAD ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'THE LENGTH FOR K(&I) CANNOT BE THE EMPTY STRING.'
&ERROR   SETB  (1)
         AGO   .SYNC
.KMXNOL  ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'LENGTH OF (D,L) PAIR MISSING IN K(&I).'
&ERROR   SETB  (1)
         AGO   .KMXCHK   GO CHECK THE CURRENT ATOM FOR VALIDITY.
.KMXNOLL ANOP
         MNOTE 12,'LENGTH OF LAST (D,L) PAIR IN K IS MISSING.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .KFIN
.KMXPRN  ANOP
&I       SETA  (&IGAPATH(1)+1)
         MNOTE 12,'TOO MANY () LEVELS IN K(&I).'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .SYNC
.KMXBADD ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'DISPLACEMENT IN K(&I) EXCEEDS 4 DIGITS.'
&ERROR   SETB  (1)
         AGO   .SYNC
.KMXDBAD ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'DISPLACEMENT IN K(&I) EXCEEDS 4095.'
&ERROR   SETB  (1)
         AGO   .SYNC
.**********************************************************************
.* THE CURRENT ATOM IS AN F OF A (F,L) PAIR.                          *
.**********************************************************************
.KMNOTD  AIF   (&IGARGHT(&IGAZ) LE 8).KMXBIGF  SEE IF THE STRING IS    *
                         BIGGER THAN 8 CHARACTERS.
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'FIELD NAME IN K(&I) IS BIGGER THAN 8 CHARACTERS.'
&ERROR   SETB  (1)
         AGO   .SYNC
.KMXBIGF ANOP
&FIELD   SETC  '&K'(&IGALEFT(&IGAZ),&IGARGHT(&IGAZ))  GET THE FIELD    *
                         NAME.
.* NOW TRY TO GET THE L OF THE (F,L) PAIR.                            *
&I       SETA  (&IGAPATH(1))  PRESERVE THE CURRENT LEVEL 1 INDEX.
      RPTDSECT SCAN=NEXT  POSITION THE CURSOR TO THE NEXT ATOM.
         AIF   (&IGAX EQ 0).KFLNOL  SEE IF THERE IS NO LENGTH BECAUSE  *
                         THERE ISN'T ANY NEXT ATOM.
         AIF   (&IGAPATH(1) NE &I).KFNOL  SEE IF THE NEXT ATOM IS NOT  *
                         PART OF THE SAME PAIR.
         AIF   (&IGALEVL NE 2).KFNOLL  SEE IF THE NEXT ATOM HAS TOO    *
                         MANY () LEVELS.
         AIF   (&IGAZ EQ 0).KFLMT  SEE IF THE LENGTH ATOM IS THE EMPTY *
                         STRING.
.**********************************************************************
.* THE CURRENT ATOM IS INDEED THE SECOND ELEMENT OF A (F,X) PAIR. NOW *
.* LET'S SEE IF X IS A VALID L.                                       *
.**********************************************************************
         AIF   (&IGARGHT(&IGAZ) GT 3).KFLLBAD  SEE IF THE LENGTH ATOM  *
                         IS MORE THAN 3 DIGITS.
&I       SETA  0         INITIALIZE THE INDEX OF THE CURRENT BYTE.
.KMXCNT2 AIF   (('&K'(&IGALEFT(&IGAZ)+&I,1) LT '0')OR('&K'(&IGALEFT(&IG*
               AZ)+&I,1) GT '9')).KFLBAD
&I       SETA  (&I+1)    STEP OVER TO THE NEXT DIGIT.
         AIF   (&I LT &IGARGHT(&IGAZ)).KMXCNT2  KEEP GOING UNTIL ALL   *
                         THE DIGITS HAVE BEEN SCANNED.
&X       SETC  '&K'(&IGALEFT(&IGAZ),&IGARGHT(&IGAZ))  EXTRACT THE      *
                         LENGTH.
&LNG     SETA  (&X)      CONVERT IT TO A NUMBER.
         AIF   (&LNG GT 256).KFBADL  SEE IF THE LENGTH EXCEEDS 256     *
                         BYTES.
.**********************************************************************
.* IT LOOKS LIKE A VALID (F,L) PAIR; GENERATE THE MOVE IF THIS IS THE *
.* MOVE GENERATION ITERATION.                                         *
.**********************************************************************
         AIF   (NOT &XFER).KMOVED  GO IF IT IS NOT THE MOVE ITERATION.
         MVC   &IGAKEYL.(&LNG,15),&FIELD         MOVE SUBKEY.
         AGO   .KMOVED   MERGE WITH THE COMMON PATH.
.**********************************************************************
.* THE FOLLOWING ARE SUNDRY MNOTES FOR THE (F,L) CASE IN A MIXED LIST.*
.**********************************************************************
.KFBADL  ANOP
&I       SETA  (&IGAPATH(1)+1)
         MNOTE 12,'LENGTH IN OPERAND &I OF K EXCEEDS 256 BYTES.'
&ERROR   SETB  (1)
         AGO   .SYNC
.KFLBAD  ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'THE LENGTH IN OPERAND K(&I) IS NOT A SELF-DEFINING D*
               ECIMAL NUMBER.'
&ERROR   SETB  (1)
         AGO   .SYNC
.KFLLBAD ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'LENGTH IN OPERAND K(&I) IS MORE THAN 3 DIGITS.'
&ERROR   SETB  (1)
         AGO   .SYNC
.KFLMT   ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'LENGTH IN OPERAND &I OF K CANNOT BE THE EMPTY STRING*
               .'
&ERROR   SETB  (1)
         AGO   .SYNC
.KFNOL   ANOP
         MNOTE 12,'LENGTH OF (F,L) PAIR IN OPERAND &I OF K IS MISSING.'
&ERROR   SETB  (1)
         AGO   .KMXCHK
.KFNOLL  ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'TOO MANY () LEVELS IN K(&I).'
         AGO   .SYNC
.KFLNOL  MNOTE 12,'LENGTH OF LAST (FIELD,LENGTH) PAIR IN K IS MISSING.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON TO PREVENT THE MOVES.
         AGO   .KFIN
.**********************************************************************
.KFIN    ANOP
         AGO   .LINK     GO LINK TO THE SRCH8 SUBROUTINE.
.**********************************************************************
.* THERE IS NO NEED TO COLLECT THE SEARCH KEY AT IGAWORK, BECAUSE THE *
.* THE K PARAMETER IS NOT CODED, AND THERE IS ONLY ONE FIELD.         *
.**********************************************************************
.CHKA    AIF   (K'&A EQ 0).ASARG  SEE IF THE ADDRESS IS OMITTED; IF IT *
                         IS GET IT OUT OF THE SEARCH ARGUMENT.
         AIF   ('&A'(1,1) EQ '(').AGPR  SEE IF THE ADDRESS IS IN A GPR.
         LA    0,&A  ADDRESS OF SEARCH KEY.
         AGO   .CHKAEND  GO TO THE END OF CHECKING THE A PARAMETER.
.AGPR    AIF   ('&A' EQ '(0)').CHKAEND  SEE IF IT IS ALREADY IN R0.
         LR    0,&A(1)   ADDRESS OF SEARCH KEY.
         AGO   .CHKAEND  ALL DONE NOW EXIT FROM CHECKING THE A         *
                         PARAMETER.
.ASARG   ANOP
.CHKAEND ANOP
.**********************************************************************
.* THE ADDRESS OF THE SEARCH KEY IS IN REGISTER 0, NOW LINK TO THE    *
.* SEARCH SUBROUTINE IN IGARPT01 FOR TYPE 8 RADIX PARTITION TREES.    *
.**********************************************************************
.LINK    ANOP
         L     15,(&IGABLST+&IGASRCH)(,1)  ADDRESS OF SEARCH ROUTINE.
         BALR  14,15     LINK TO THE APPROPRIATE SEARCH ROUTINE.
.**********************************************************************
.* CHECK THE REL PARAMETER FOR ANY ADDITIONAL ACTIONS THAT MUST BE DONE
.**********************************************************************
         AIF   (K'&REL EQ 0).FIN0  SEE IF THE REL PARAMETER IS CODED.
         MNOTE 12,'NONCE ERROR, REL NOT YET AVAILABLE.'
         AGO   .FIN0     SKIP THE REST.
.**********************************************************************
.*   CHECK THE REL PARAMETER FOR A PARTIAL ORDER VALUE SEARCH.        *
.**********************************************************************
.ITSAPOV ANOP
         AIF   (('&REL(1)' EQ 'POV')AND('&REL(2)' EQ 'GE')).POVSRCH
         AIF   (('&REL(1)' EQ 'MAX')AND('&REL(2)' EQ 'POV')).MAXPOV
.BADREL  MNOTE 12,'INVALID REL PARAMETER.'
         AGO   .FIN0  GO TO THE END OF THE SRCH MACRO.
.MAXPOV  AIF   (K'&NULL EQ 0).LOADMAX  SEE IF THE NULL IS CODED.
         TM    &IGAEOPV.(1),B'1001'  SEE IF THE TREE IS EMPTY.
         AIF   ('&NULL'(1,1) EQ '(').MXPVGPR
         BC    8,&NULL  BRANCH IF THE TREE IS EMPTY.
         AGO   .LOADMAX
.MXPVGPR BCR   8,&NULL(1)  BRANCH IF THE RPT IS EMPTY.
.LOADMAX L     0,&IGAMAX.(,1)   LOAD THE MAXIMUM PARTIAL ORDER VALUE.
         L     15,(&IGABLST+&IGAPVS)(,1)  ADDRESS OF POV SEARCH.
         BALR  14,15     SET CURSOR TO SINK WITH MAX POV.
         AGO   .FIN0  GO TO THE END OF THE SEARCH.
.**********************************************************************
.* SEARCH FOR A PARTIAL ORDER VALUE THAT IS GREATER THAN OR EQUAL TO  *
.* THE SEARCH ARGUMENT, BUT AS SMALL A VALUE AS CAN EFFICIENTLY BE    *
.* FOUND.                                                             *
.**********************************************************************
.POVSRCH AIF   ((K'&A EQ 0)AND(K'&K NE 0)).PVS01
         AIF   ((K'&A NE 0)AND(K'&K EQ 0)).PVS10
         AIF   ((K'&A EQ 0)AND(K'&K EQ 0)).PVS00
         AIF   ('&A'(1,1) EQ '(').PVS11R
         L     0,&A(1)+&K(1)  LOAD PARTIAL ORDER SEARCH KEY.
.PVS11RR L     15,(&IGABLST+&IGAPVS)(,1)  ADDRESS OF POV SEARCH.
         BALR  14,15     LINK TO POV SEARCH ROUTINE.
.PVSTEST AIF   (K'&NULL EQ 0).PVNNULL  SEE IF THE NULL IS CODED.
&TMP     SETC  ''  SET IT TO THE EMPTY VECTOR.
         AIF   ('&NULL'(1,1) NE '(').PVSNGPR  AGO IF NULL NOT A GPR.
&TMP     SETC  'R'  SET IT TO GENERATE A BCR.
.PVSNGPR TM    &IGAEOPV.(1),B'1001'  SEE IF THE TREE IS EMPTY.
         BC&TMP 8,&NULL(1)  BRANCH IF IT IS EMPTY.
.PVNNULL AIF   ((K'&Y EQ 0)AND(K'&N EQ 0)).FIN0  SEE IF EITHER Y OR N.
         LTR   15,15  TEST THE RETURN CODE.
         AIF   (K'&Y EQ 0).PVNOY  SEE IF THE Y PARAMETER NOT CODED.
&TMP     SETC  ''  SET IT UP TO GENERATE A BC.
         AIF   ('&Y'(1,1) NE '(').PVYBC  GO IF A BC IS GENERATED.
&TMP     SETC  'R'  SET IT UP TO GENERATE A BCR.
.PVYBC   BC&TMP 10,&Y(1)  BRANCH IF THE SEARCH FOUND ONE.
.PVNOY   AIF   (K'&N EQ 0).FIN0  GO IF N IS NOT CODED.
&TMP     SETC  ''
         AIF   ('&N'(1,1) NE '(').PVNBC  GO IF IT'S NOT IN A GPR.
&TMP     SETC  'R'  GET SET TO GENERATE A BCR.
.PVNBC   AIF   (K'&Y NE 0).PVNBCC  GO IF THE LTR IS ALREADY THERE.
         LTR   15,15  TEST THE RETURN CODE.
.PVNBCC  BC&TMP 4,&N(1)  BRANCH IF THERE IS NO QUALIFYING VALUE.
         AGO   .FIN0  THE SRCH MACRO IS FINISHED.
.PVS11R  L     0,&K(1)(,&A(1))  LOAD THE PARTIAL ORDER SEARCH KEY.
         AGO   .PVS11RR  GO DO THE SEARCH.
.PVS00   MNOTE 12,'PARTIAL ORDER SEARCH KEY NOT SPECIFIED.'
         AGO   .FIN0  FORGET, CAN'T DO ANYTHING.
.PVS10   AIF   ('&A' EQ '((0))').PVS11RR SEE IF IT'S ALREADY LOADED.
&TMP     SETC  ''
         AIF   ('&A'(1,1) NE '(').PVS10M
&TMP     SETC  'R'
.PVS10M  L&TMP 0,&A(1)  LOAD THE PARTIAL ORDER SEARCH KEY.
         AGO   .PVS11RR  GO DO THE SEARCH.
.PVS01   ANOP
&TMP     SETC  'R'  PREPARE TO GENEATE A LOAD REGISTER INSTRUCTION.
         AIF   ('&K(1)'(1,1) EQ '(').PVS01R
&TMP     SETC  ''
.PVS01R  L&TMP 0,&K(1)  LOAD THE PARTIAL ORDER SEARCH KEY.
         AGO   .PVS11RR  GO DO THE SEARCH.
.**********************************************************************
.* PARTIAL ORDER VALUE SEARCH. IF A SEARCH KEY IS SPECIFIED SET THE   *
.* CURSOR USING THE SEARCH KEY. IN ORDER FOR THE SEARCH TO BE         *
.* SUCCESSFUL THERE MUST BE AN EXACT MATCH BETWEEN THE SEARCH KEY AND *
.* ONE ALREADY IN THE TREE.                                           *
.**********************************************************************
.POVGET  ANOP
         AIF   ((K'&A EQ 0)AND(K'&K EQ 0)).GETPOV
         SRCH  (1),A=&A,K=&K,T=&IGARPT#  SET THE CURSOR.
.GETPOV  L     15,(&IGABLST+&IGAGPV)(,1)  ADDRESS OF GET POV.
         BALR  14,15     LINK TO GET POV FOR CURRENT SINK.
         AGO   .PVSTEST   GO TEST FOR EXITING BRANCHES, ETC..
.*--------------------------------------------------------------------*
.FIN0    ANOP
         AIF   (NOT(&FIN)).SRCH8ZZ  SEE IF THE FIN&SYSNDX EQU * SHOULD *
                         BE GENERATED.
FIN&SYSNDX EQU *
.SRCH8ZZ ANOP
         AIF   (NOT &USING).FIN  SEE IF A USING FOR R1 HAS BEEN        *
                         GENERATED; IF SO GENERATE THE CORRESPONDING   *
                         DROP.
         AGO   .FIN      SKIP AROUND SRCH5.
.**********************************************************************
.*   R E A D     O N L Y     S E A R C H  ------- S R C H 5.          *
.**********************************************************************
.*       FOR SRCH5:                                                   *
.* 0. ABSOLUTE 3-BYTE EDGE FIELDS WITH SUCCESSOR PAIRING.             *
.* 1. BIT 0 OF EACH WORD IS A ZERO FOR SINK WORDS AND A ONE FOR INNER *
.*    VERTICES.                                                       *
.* 2. BITS 1-7 OF EACH INNER VERTEX ARE THE BIT INDEX, THUS ALLOWING  *
.*    A MAXIMUM KEY OF 16 BYTES.                                      *
.* 3. NO SCAN FUNCTIONS ARE AVAILABLE WITH SRCH5.                     *
.* 4. SRCH5 IS READ-ONLY, IN THE SENSE THAT IT DOES NOT STORE INTO    *
.*    ANY MEMORY LOCATIONS, BUT USES REGISTERS 0, 1, 2, 3, 14, AND 15 *
.*    AS WORKING REGISTERS.                                           *
.*    SRCH5 CHECKS A USE COUNT AFTER TERMINATION TO SEE IF AN INSERT  *
.*    OR DELETE CHANGE THE TREE DURING THE TIME THE SEARCH WAS IN     *
.*    PROGRESS. THIS IS TO ALLOW THE VALIDITY OF SEARCHES PROCEEDING  *
.*    WHILE AN INSERT OR DELETE IS IN PROGRESS IN AN MP SITUATION.    *
.*--------------------------------------------------------------------*
.SRCH5   ANOP
&GOLEFT  SETC  'LOOP'.'&SYSNDX'     GENERATE THE LABELS FOR THE
&ITSMOP  SETC  'MOP'.'&SYSNDX'   READ-ONLY SEARCH LOOP.
&ITSEOP  SETC  'EOP'.'&SYSNDX'   XX
&TOOBAD  SETC  'MORE'.'&SYSNDX'
&O       SETC  '0'   JUST A ZERO DISPLACEMENT.
&EKE     SETC  '4'   DISPLACEMENT TO THE USE COUNTER.
&FOUR    SETC  '4'    A CONSTANT DISPLACEMENT 4.
&ARG     SETC  '0'  REGISTER TO HOLD THE SEARCH ARGUMENT.
&TREEHDR SETC  '1'  USE REGISTER 1 FOR THE TREEHDR ADDRESS.
&P       SETC  '2'   USE REGISTER 2 FOR THE PREDECESSOR.
&C       SETC  '3'   USE REGISTER 3 FOR THE PENULTIMATE VERTEX.
&EKER    SETC  '14'  REGISTER TO HOLD THE COUNTER DURING THE
.*                   READ-ONLY SEARCH.
&S       SETC  '15'     USE REGISTER 15 TO HOLD THE SINK WORD.
&USING   SETB  (1)       SET THE BIT ON TO INDICATE THAT A USING HAS   *
                         BEEN GENERATED FOR R1.
.**********************************************************************
.* THE FOLLOWING TABLE SHOWS THE VARIOUS COMBINATIONS AND             *
.* INTERPRETATIONS OF THE OPERANDS FOR SRCH WITH TYPE 5 TREES:        *
.**********************************************************************
.* A:    A=LABEL OR A=(GPR) MAY BE CODED.                             *
.* K:    K=, K=FIELDNAME, K=(FIELDNAME,LENGTH), OR K=(D,L) MAY BE     *
.*       CODED. IF "K=FIELDNAME" OR "K=(FIELDNAME,LENGTH)" IS CODED,  *
.*       THEN THE A PARAMETER DOES NOT HAVE TO BE CODED. IF A IS ALSO *
.*       CODED AN MNOTE WILL BE GENERATED.                            *
.*       THE MAXIMUM SIZE KEY THAT CAN BE ACCOMODATED FOR TYPE 5 TREES*
.*       IS 16 BYTES. THERE CAN ONLY BE ONE (D,L) PAIR FOR TYPE 5     *
.*       TREES, UNLIKE TYPE 8 TREES, WHERE THERE CAN BE AN ARBITRARY  *
.*       NUMBER.                                                      *
.*--------------------------------------------------------------------*
.* CHECK FOR THE VARIOUS ALLOWABLE COMBINATIONS OF THE KEYL AND SARG. *
.*--------------------------------------------------------------------*
.**********************************************************************
.* THE FOLLOWING ARE THE ONLY WAYS TO CODE THE A AND K PARAMETERS FOR *
.* TYPE 5 RADIX PARTITION TREES:                                      *
.* F MEANS A FIELD NAME WITH A LENGTH ATTRIBUTE.                      *
.* L MEANS A LENGTH, WHICH MUST BE A SELF-DEFINING TERM.              *
.* D MEANS A DISPLACEMENT, WHICH MUST EITHER BE THE EMPTY STRING OR A *
.*   SELF-DEFINING TERM.                                              *
.* GPR IS A GENERAL REGISTER NAME OR NUMBER.                          *
.* X MEANS ANY STRING OF CHARACTERS.                                  *
.*                                                                    *
.* COMBINATION:          MEANING:                                     *
.* ------------          --------                                     *
.* A=F,K=                F IS A LABEL, AND THE LENGTH OF THE KEY IS   *
.*                       THE SAME AS THE LENGTH OF F.                 *
.* A=F,K=L               F IS THE SEARCH KEY, AND L IS THE SEARCH KEY *
.*                       LENGTH (IT MUST BE A SELF-DEFINING TERM).    *
.* A=F,K=(,L)            SAME AS ABOVE.                               *
.* A=F,K=(D,L)           THE SEARCH KEY IS AT DISPLACEMENT D FROM THE *
.*                       BEGINNING OF THE FIELD F, AND IS L BYTES LONG.
.* A=(GPR),K=L           THE ADDRESS OF THE FIRST BYTE OF THE SEARCH  *
.*                       KEY IS IN THE INDICATED REGISTER, AND THE KEY*
.*                       IS L BYTES LONG.                             *
.* A=(GPR),K=(,L)        SAME AS ABOVE.                               *
.* A=(GPR),K=(D,L)       THE ADDRESS OF THE KEY IS FORMED BY ADDING   *
.*                       THE ADDRESS IN THE INDICATED REGISTER TO THE *
.*                       DISPLACEMENT D, AND THE KEY IS L BYTES LONG. *
.* A=,K=F                F IS THE SEARCH KEY, AND ITS LENGTH IS THE   *
.*                       SAME AS THE LENGTH OF F.                     *
.* A=,K=(F,L)            F IS THE SEARCH KEY, AND L IS ITS LENGTH.    *
.**********************************************************************
.*--------------------------------------------------------------------*
.**********************************************************************
.* IN THE FOLLOWING, THE SEARCH IS DONE FOR KEYS WITH 4 BYTES OR LESS.*
.* THE KEY IS PLACED IN REGISTER 0 JUST BEFORE THE MAIN SEARCH LOOP.  *
.* THE KEY IS RIGHT ALIGNED IN REGISTER ZERO, WITH ZEROS FILLED IN ON *
.* THE LEFT.                                                          *
.**********************************************************************
         AIF   (&ERROR).FIN5  SEE IF ANY ERRORS HAVE BEEN DISCOVERED   *
                         PRIOR TO THIS PART.
         AIF   ((K'&A EQ 0)AND(K'&K EQ 0)).FIN5  SEE IF NEITHER A NOR K*
                         IS CODED.
         AIF   (K'&K NE 0).S5KNOTZ  SEE IF K IS CODED.
.**********************************************************************
.* ONLY THE A PARAMETER IS CODED, SO IT MUST BE A FIELD NAME WITH A   *
.* LENGTH ATTRIBUTE IN ORDER TO BE VALID.                             *
.**********************************************************************
         AIF   (K'&A LE 4).NOTPP  SEE IF THE A PARAMETER IS CODED AS   *
                         "A=((GPR))". IF IT IS, THEN THE SEARCH KEY IS *
                         ALREADY LOADED INTO THE INDICATED REGISTER.
         AIF   ('&A'(1,2) NE '((').NOTPP  IF IT IS IN A REGISTER, THEN *
                         IT MUST BE RIGHT ALIGNED, WITH THE LEFT FILL  *
                         BITS BEING ZERO.
         AIF   ('&A' EQ '((0))').SRCH5Z  SEE IF IT IS EVEN ALREADY IN  *
                         REGISTER 0.
         LR    0,&A(1)   SEARCH KEY.
         AGO   .SRCH5Z   GOT THE SEARCH KEY IN REGISTER 0, NOW GO      *
                         GENERATE THE SEARCH.
.NOTPP   ANOP
         AIF   ('&A'(1,1) EQ '(').AGRNOK  SEE IF THE A PARAMETER IS    *
                         INCORRECTLY SPECIFIED IN A REGISTER.
         AIF   ((T'&A EQ 'M')OR(T'&A EQ 'N')OR(T'&A EQ 'O')OR (T'&A EQ *
               'T')OR(T'&A EQ 'W')OR(T'&A EQ '$')OR(T'&A EQ 'U')).ANOTF*
                         SEE IF A IS NOT A FIELD NAME.
&IGAKEYL SETA  (L'&A)    GET THE SEARCH KEY LENGTH.
         AIF   (K'&A GT 8).ATOOBIG SEE IF THE FIELD NAME IS BIGGER     *
                         THAN 8 CHARACTERS.
&FIELD   SETC  '&A'      GET THE FIELD NAME.
.S5LCHK  AIF   (&IGAKEYL GT 4).AFLGT4  SEE IF THE KEY LENGTH IS MORE   *
                         THAN FOUR BYTES.
         AIF   (&IGAKEYL GE 3).AFL34  SEE IF THE KEY LENGTH IS BIGGER  *
                         THAN TWO BYTES.
         AIF   (&IGAKEYL EQ 2).AFL2  SEE IF THE KEY LENGTH IS EXACTLY  *
                         TWO BYTES.
         AIF   (&IGAKEYL NE 1).NULLKEY  SEE IF THE KEY LENGTH IS ZERO.
.AFL1    SLR   0,0       THE SEARCH KEY
         IC    0,&FIELD  IS ONE BYTE LONG.
         AGO   .SRCH5Z   NOW GO GENERATE THE SRCH5 IN LINE.
.AFL2    LH    0,&FIELD  SEARCH KEY IS
         N     0,=XL4'0000FFFF'  TWO BYTES LONG.
         AGO   .SRCH5Z   NOW GO GENERATE THE SEARCH IN LINE.
.AFL3    L     00,&FIELD  3-BYTE SEARCH KEY.
         SRL   0,8  GET IT RIGHT ALIGNED.
         AGO   .SRCH5Z   GO GENERATE THE SEARCH LOOP.
.AFL34   AIF   (&IGAKEYL EQ 3).AFL3  SEE IF THE SEARCH KEY LENGTH IS   *
                         EXACTLY THREE BYTES.
         L     0,&FIELD  4-BYTE SEARCH KEY.
         AGO   .SRCH5Z   GO FINISH UP NOW.
.AFLGT4  AGO   .S5NONCE  CAN'T HAVE TYPE 5 KEYS BIGGER THAN 5 YET.
.**********************************************************************
.* THE K PARAMETER IS CODED, SEE IF THE A PARAMETER IS CODED TOO.     *
.**********************************************************************
.S5KNOTZ ANOP
         AIF   (K'&A NE 0).S5BOTH  SEE IF BOTH THE A AND K PARAMETERS  *
                         ARE CODED.
.**********************************************************************
.* ONLY THE K PARAMETER IS CODED. IT MUST BE ONE OF THE CASES K=F OR  *
.* K=(F,L). ANYTHING ELSE MUST BE WRONG.                              *
.**********************************************************************
         AIF   (N'&K GT 2).LOTSAK  SEE IF THERE ARE TOO MANY OPERANDS.
         AIF   (N'&K EQ 2).S5K2  SEE IF THERE ARE EXACTLY 2.
         AIF   ('&K'(1,1) EQ '(').S5K1P  SEE IF IT LOOKS LIKE A GPR.
         AIF   ((T'&K(1) EQ 'M')OR(T'&K(1) EQ 'N')OR(T'&K(1) EQ 'O')OR(*
               T'&K(1) EQ 'T')OR(T'&K(1) EQ 'W')OR(T'&K(1) EQ '$')OR(T'*
               &K(1) EQ 'U')).KINVF  SEE IF K IS A GOOD FIELD NAME.
         AIF   (K'&K GT 8).KBIGTAG  SEE IF THE FIELD NAME HAS TOO MANY *
                         CHARACTERS IN IT TO BE A VALID NAME.
&FIELD   SETC  '&K'      SET FIELD TO THE FIELD NAME.
         AGO   .S5LCHK   MERGE IN WITH THE OTHER LENGTH CHECK.
.**********************************************************************
.* THE K PARAMETER IS CODED AND THE A PARAMETER IS NOT CODED, AND THE *
.* K PARAMETER HAS EXACTLY TWO ELEMENTS IN IT. SEE IF K IS OF THE FORM*
.* (F,L). IF IT ISN'T IT IS AN ERROR.                                 *
.**********************************************************************
.S5K2    ANOP
         AIF   (T'&K(2) EQ 'N').S5K2N  SEE IF THE LENGTH IS A SELF-    *
                         DEFINING TERM.
&I       SETA  (K'&K(2))  SET THE INDEX TO IT'S INITIAL VALUE.
.K5LCHK  AIF   (('&K(2)'(&I,1) LT '0')OR('&K(2)'(&I,1) GT '9')).S5LERR
&I       SETA  (&I-1)    DECREASE THE INDEX TO THE NEXT CHARACTER.
         AIF   (&I GT 0).K5LCHK  SEE IF THERE ARE MORE TO CHECK.
         AIF   (K'&K(2) GT 4).S5LERR  SEE IF IT HAS TOO MANY DIGITS.
.S5K2N   ANOP
&IGAKEYL SETA  (&K(2))   GET THE LENGTH AS A NUMBER.
         AIF   (K'&K(1) GT 8).KBIGTAG  SEE IF IT HAS TOO MANY          *
                         CHARACTERS IN IT TO BE A VALID NAME.
&FIELD   SETC  '&K(1)'   GET THE FIELD NAME.
         AGO   .S5LCHK   MERGE IN WITH THE OTHER SEQUENCE.
.**********************************************************************
.* BOTH THE A AND K PARAMETERS ARE CODED.                             *
.**********************************************************************
.S5BOTH  ANOP
         AIF   ('&A'(1,1) EQ '(').S5BAISG  SEE IF THE A PARAMETER      *
                         SPECIFIES A GENERAL REGISTER.
         AIF   (N'&K GT 2).LOTSAK  SEE IF THERE ARE TOO MANY.
         AIF   (N'&K EQ 2).S5AK2  SEE IF THERE ARE EXACTLY 2.
         AIF   ('&K'(1,1) EQ '(').S5K1P  SEE IF IT LOOKS LIKE THE      *
                         DISPLACEMENT-LENGTH PAIR IS IN A GPR.
.**********************************************************************
.* THIS MUST BE THE CASE WHERE A=F,K=L.                               *
.**********************************************************************
         AIF   (T'&K EQ 'N').AFKL5OK  SEE IF THE LENGTH IS A           *
                         SELF-DEFINING TERM.
&I       SETA  (1)       SET THE INDEX TO ITS INITIAL VALUE.
.AFKL5CK AIF   (('&K'(&I,1) LE '0')OR('&K'(&I,1) GT '9')).S5LERR       *
                         CHECK THE LENGTH TO SEE IF IT IS REALLY A     *
                         NUMBER.
&I       SETA  (&I+1)    EKE THE INDEX OF THE NEXT CHARACTER TO BE     *
                         INSPECTED.
         AIF   (&I LT K'&K).AFKL5CK  KEEP ON LOOKING UNTIL ALL THE     *
                         CHARACTERS HAVE BEEN INSPECTED.
.AFKL5OK ANOP
&IGAKEYL SETA  (&K)      CAPTURE THE KEY LENGTH AS A NUMBER.
         AIF   (&IGAKEYL EQ 1).AFKL51  SEE IF THE KEY LENGTH IS ONE    *
                         BYTE.
         AIF   (&IGAKEYL EQ 2).AFKL52  SEE IF THE KEY LENGTH IS TWO    *
                         BYTES.
         AIF   (&IGAKEYL EQ 3).AFKL53  SEE IF THE KEY LENGTH IS 3      *
                         BYTES.
         AIF   (&IGAKEYL NE 4).S5NONCE  SEE IF THE KEY LENGTH IS FOUR  *
                         BYTES.
         L     0,&A                     SEARCH ARGUMENT.
         AGO   .SRCH5Z   GO DO THE ACTUAL SEARCH.
.AFKL51  SLR   0,0     KEY LENGTH IS ONE BYTE.
         IC    0,&A                 1-BYTE SEARCH KEY.
         AGO   .SRCH5Z   GO GENERATE THE ACTUAL SEARCH CODE.
.AFKL52  LH    0,&A              HALFWORD SEARCH KEY.
         AGO   .SRCH5Z   GO GENERATE THE SEARCH CODE.
.AFKL53  L     0,&A                  LOAD 3-BYTE SEARCH KEY.
         SRL   0,8       SHIFT IT OVER.
         AGO   .SRCH5Z   GO GENERATE THE REAL SEARCH.
.AFKL54  L     0,&A                   LOAD FULL-WORD SEARCH KEY.
         AGO   .SRCH5Z   GO GENERATE THE REAL SEARCH CODE.
.**********************************************************************
.* THIS MUST BE THE CASE WHERE A=F,K=(D,L).                           *
.**********************************************************************
.S5AK2   AIF   (T'&K(2) EQ 'N').S5K2N1 SEE IF THE LENGTH IS A SELF-    *
               DEFINING TERM.
         AIF   (K'&K(2) EQ 0).S5LERR  SEE IF IT IS THE EMPTY STRING.
&I       SETA  (K'&K(2))  SET THE INDEX TO IT'S INITIAL VALUE.
.K5LCHK1 AIF   (('&K(2)'(&I,1) LT '0')OR('&K(2)'(&I,1) GT '9')).S5LERR
&I       SETA  (&I-1)    DECREASE THE INDEX TO THE NEXT CHARACTER.
         AIF   (&I GT 0).K5LCHK1 SEE IF THERE ARE MORE TO CHECK.
         AIF   (K'&K(2) GT 4).S5LERR  SEE IF IT HAS TOO MANY DIGITS.
.S5K2N1  ANOP
&IGAKEYL SETA  (&K(2))   GET THE KEY LENGTH AS A NUMBER.
&DSP     SETA  0         SET THE DISPLACEMENT TO ITS DEFAULT VALUE.
         AIF   (K'&K(1) EQ 0).S5AK2D  SEE IF THE DISPLACEMENT FIELD IS *
                         ELIDED.
         AIF   ('&K(1)' EQ '0').S5AK2D  SEE IF IT IS ZERO.
         AIF   (T'&K(1) EQ 'N').PICK5D  SEE IF THE DISPLACEMENT IS A   *
                         SELF-DEFINING TERM.
&I       SETA  (K'&K(1))  SET THE INDEX TO IT'S INITIAL VALUE.
.CHECK5D AIF   (('&K(1)'(&I,1) LT '0')OR('&K(1)'(&I,1) GT '9')).S5DERR
&I       SETA  (&I-1)    DECREASE THE INDEX TO THE NEXT CHARACTER.
         AIF   (&I GT 0).CHECK5D  SEE IF IT GOT TO THE END.
         AIF   (K'&K(1) GT 4).S5DLONG  SEE IF IT HAS TOO MANY DIGITS.
.PICK5D  ANOP
&DSP     SETA  (&K(1))   GET THE DISPLACEMENT AS A NUMBER.
.S5AK2D  ANOP
.S5DLCHK ANOP
         AIF   (&IGAKEYL GT 4).S5DL5  SEE IF THE KEY LENGTH IS MORE    *
                         THAN 4 BYTES.
         AIF   (&IGAKEYL EQ 4).S5DL4  SEE IF THE KEY LENGTH IS 4 BYTES.
         AIF   (&IGAKEYL EQ 3).S5DL3  SEE IF THE KEY LENGTH IS 3 BYTES.
         AIF   (&IGAKEYL EQ 2).S5DL2  SEE IF THE KEY LENGTH IS 2 BYTES.
         AIF   (&IGAKEYL NE 1).NULLKEY  SEE IF THE KEY LENGTH IS ZERO.
.S5DL1   SLR   0,0       SEARCH KEY IS
         AIF   (&DSP EQ 0).S5DL1Z  SEE IF THE DISPLACEMENT IS ZERO.
         IC    0,&A                    ONE BYTE LONG.
         AGO   .S5DL1ZZ  SKIP AROUND THE OTHER INSERT CHARACTER        *
                         INSTRUCTION.
.S5DL1Z  IC    0,&DSP+&A        ONE BYTE LONG.
.S5DL1ZZ ANOP
         AGO   .SRCH5Z   GO DO THE IN LINE SEARCH.
.S5DL2   AIF   (&DSP EQ 0).S5DL2Z  SEE IF THE DISPLACEMENT IS ZERO.
         LH    0,&DSP+&A          HALFWORD
         AGO   .S5DL2ZZ  SKIP AROUND THE OTHER LOAD HALFWORD           *
                         INSTRUCTION.
.S5DL2Z  LH    0,&A           HALFWORD
.S5DL2ZZ ANOP
         N     0,=XL4'0000FFFF'  SEARCH KEY.
         AGO   .SRCH5Z   GO WRAP IT UP.
.S5DL3   AIF   (&DSP EQ 0).S5DL3Z  SEE IF THE DISPLACEMENT IS ZERO.
         L     0,&DSP+&A           THREE-BYTE SEARCH KEY.
         AGO   .S5DL3ZZ  SKIP THE OTHER LOAD INSTRUCTION.
.S5DL3Z  L     0,&A                 THREE-BYTE SEARCH KEY.
.S5DL3ZZ ANOP
         SRL   0,8       GET IT RIGHT ALIGNED.
         AGO   .SRCH5Z   GO DO THE IN-LINE SEARCH.
.S5DL4   AIF   (&DSP EQ 0).S5DL4Z  SEE IF THE DISPLACEMENT IS ZERO.
         L     0,&DSP+&A           4-BYTE KEY.
         AGO   .S5DL4ZZ  SKIP THE OTHER LOAD INSTRUCTION.
.S5DL4Z  L     0 &A                  4-BYTE KEY.
.S5DL4ZZ ANOP
         AGO   .SRCH5Z   GO FINISH IT UP.
.S5DL5   AGO   .S5NONCE  THIS IS ONLY FOR THE NONCE.
.**********************************************************************
.* BOTH THE A AND K PARAMETERS ARE CODED, AND A SPECIFIES A GPR.      *
.* THEREFORE IT MUST BE THE CASE WHERE A=(GPR),K=(D,L). NOTE THAT THE *
.* DISPLACEMENT CAN BE THE EMPTY STRING.                              *
.* ALSO THE CASE OF A=(GPR),K=L GOES ALONG WITH THESE.                *
.**********************************************************************
.S5BAISG ANOP
         AIF   (N'&K GT 2).LOTSAK  SEE IF K HAS TOO MANY OPERANDS.
         AIF   (N'&K EQ 2).S5AGK2  SEE IF K HAS EXACTLY 2 OPERANDS.
         AIF   ('&K'(1,1) EQ '(').S5K1P  SEE IF IT LOOKS LIKE A GPR.
         AIF   (T'&K NE 'N').S5LERR  SEE IF IT'S A SELF-DEFINING TERM.
.**********************************************************************
.* IT IS A=(GPR),K=L.                                                 *
.**********************************************************************
&IGAKEYL SETA  (&K)      GET THE KEY LENGTH AS A NUMBER.
&DSP     SETA  0         SET THE DISPLACEMENT TO ITS DEFAULT VALUE.
.S5GLCHK AIF   (&IGAKEYL GT 4).S5GL5  SEE IF THE KEY LENGTH EXCEEDS 4.
         AIF   (&IGAKEYL EQ 4).S5GL4  SEE IF IT IS EXACTLY 4 BYTES.
         AIF   (&IGAKEYL EQ 3).S5GL3  SEE IF IT IS EXACTLY 3 BYTES.
         AIF   (&IGAKEYL EQ 2).S5GL2  SEE IF IT IS EXACTLY 2 BYTES.
         AIF   (&IGAKEYL NE 1).S5LERR  SEE IF IT IS ZERO.
.S5GL1   SLR   0,0       1-BYTE KEY.
         IC    0,&DSP&A
         AGO   .SRCH5Z   GO FINISH UP.
.S5GL2   LH    0,&DSP&A  2-BYTE KEY.
         N     0,=XL4'0000FFFF'
         AGO   .SRCH5Z
.S5GL3   L     0,&DSP&A  3-BYTE KEY.
         SRL   0,8
         AGO   .SRCH5Z
.S5GL4   L     0,&DSP&A  4-BYTE KEY.
         AGO   .SRCH5Z   GO FINISH IT UP.
.S5GL5   AGO   .S5NONCE
.**********************************************************************
.* IT IS A=(GPR),K=(D,L).                                             *
.**********************************************************************
.S5AGK2  ANOP
         AIF   (T'&K(2) NE 'N').S5LERR   SEE IF IT'S NOT SELF-DEFINING.
&DSP     SETA  0         SET D TO THE DEFAULT VALUE.
&IGAKEYL SETA  (&K(2))   GET THE KEY LENGTH AS A NUMBER.
         AIF   (K'&K(1) EQ 0).S5GLCHK  SEE IF THE DISPLACEMENT IS THE  *
                         EMPTY STRING.
         AIF   (T'&K(1) NE 'N').S5DERR   SEE IF IT'S NOT SELF-DEFINING.
&DSP     SETA  (&K(1))   GET THE DISPLACEMENT AS A NUMBER.
         AGO   .S5GLCHK  MERGE WITH THE COMMON PATH.
.SRCH5Z  AIF   (&ERROR).FIN5  DON'T GENERATE THE SEARCH IF ERRORS HAVE *
                         BEEN DETECTED ALREADY.
&TOOBAD  L     &EKER,&IGACNT5.(,&TREEHDR)  LOAD THE USE COUNTER.
         LA    &P,&IGATOP5.(,&TREEHDR)  ADDRESS OF RPT SOURCE.
         LR    &C,&P     XX
         L     &S,&O.(&O,&C)
         CL    &S,&IGAMSK5.(,&TREEHDR)  SEE IF THERE ARE ZERO SINKS.
         BC    7,&GOLEFT+4
         BC    15,&ITSEOP
&GOLEFT L     &S,&O.(&O,&C)   LOAD THE SINK WORD OR THE NEXT INNER
         LTR   &S,&S          VERTEX AND TEST FOR THE END OF THE PATH.
         BC    10,&ITSEOP     BRANCH IF THE SINK WORD WAS LOADED.
&ITSMOP LR    &P,&C           CYCLE THE REGISTERS SO THAT THESE TWO
         LR    &C,&S          ARE ALWAYS CONSECUTIVE VERTICES.
         SRL   &S,24          GET THE BIT INDEX FIELD IN THE LOW ORDER.
         L     &S,(&IGAMSK5-X'80')(&TREEHDR,&S)  LOAD MASK TO TEST BIT.
         NR    &S,&ARG          TEST THE BIT.
         BC    8,&GOLEFT    BRANCH IF IT IS A ZERO TO THE LEFT PATH.
         L     &S,&FOUR.(&O,&C)  ENTER THE RIGHT SUBTREE BY LOADING
         LA    &C,&FOUR.(&O,&C)  THE PAIRED RIGHT SUCCESSOR AND
         LTR   &S,&S   MAKE THE CURRENT VERTEX ADDRESS IT.
         BC    4,&ITSMOP   BRANCH IF THE NEW VERTEX IS AN INNER VERTEX.
&ITSEOP  CL    &EKER,&IGACNT5.(,&TREEHDR)  CHECK THE COUNTER TO SEE IF
         BC    7,&TOOBAD   THE READ-ONLY SEARCH MUST BE DONE AGAIN.
         AGO   .FIN5
.AGRNOK  MNOTE 12,'SEARCH KEY LENGTH CANNOT BE DETERMINED WITH A IN A  *
               GPR AND NO K.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .FIN5     FINISH UP AND GET OUT.
.ANOTF   MNOTE 12,'THE FIELD DEFINED BY A HAS NOT A VALID LENGTH ATTRIB*
               UTE.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .FIN5     GET OUT NOW.
.ATOOBIG MNOTE 12,'FIELD NAME IN A PARAMETER IS TOO MANY CHARACTERS.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .FIN5     EXIT.
.NULLKEY MNOTE 12,'LENGTH OF SEARCH KEY DEFINED IS ZERO.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .FIN5     EXIT AFTER CLEANING UP.
.S5NONCE MNOTE 12,'NONCE ERROR, ONLY KEYS UP TO 4 BYTES ARE SUPPORTED.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .FIN5     FORGET IT FOR THE NONCE.
.LOTSAK  MNOTE 12,'TOO MANY OPERANDS IN THE K PARAMETER LIST.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .FIN5
.S5K1P   MNOTE 12,'THE DISPLACEMENT-LENGTH PAIR MAY NOT BE IN A GPR.'
&ERROR   SETB  (1)
         AGO   .FIN5
.KINVF   MNOTE 12,'FIELD IN K PARAMETER HAS INVALID LENGTH ATTRIBUTE.'
&ERROR   SETB  (1)
         AGO   .FIN5
.KBIGTAG MNOTE 12,'TOO MANY CHARACTERS IN FIELD NAME; ONLY 8 ALLOWED.'
&ERROR   SETB  (1)
         AGO   .FIN5
.S5LERR  MNOTE 12,'LENGTH IS NOT A SELF-DEFINING TERM IN K PARAMETER.'
&ERROR   SETB  (1)
         AGO   .FIN5
.S5DERR  MNOTE 12,'THE DISPLACEMENT IN THE K PARAMETER IS NOT A SELF-DE*
               FINING TERM.'
&ERROR   SETB  (1)
         AGO   .FIN5
.S5DLONG MNOTE 12,'K PARAMETER DISPLACEMENT HAS TOO MANY DIGITS.'
&ERROR   SETB  (1)
.FIN5    ANOP
         AIF   (NOT &USING).FIN  SEE IF THE DROP SHOULD BE GENERATED.
.*--------------------------------------------------------------------*
.*      T H E    E N D    O F    M A C R O    S R C H.                *
.*--------------------------------------------------------------------*
.FIN     ANOP
.END     ANOP
         MEND
