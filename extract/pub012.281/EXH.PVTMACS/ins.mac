         MACRO
&TAG     INS   &TREE,&A=,&R=,&#=,&T=,&C=,&SP=,&S=,&INSARG=,&MOVE=,     *
               &RECL=,&TYPE=
.************************* SEPTEMBER 27,1973.**************************
.* THE INS MACRO-INSTRUCTION ASSOCIATES A KEY WITH A RECORD ADDRESS BY*
.* CHANGING THE RADIX PARTITION TREE OF ASSOCIATIONS.                 *
.*                                                                    *
.* THE ADDRESS USED IS OBTAINED IN EITHER ONE OF TWO WAYS:            *
.*                                                                    *
.* 0:    IF THE A-PARAMETER IS CODED AND THE R-PARAMETER IS NOT CODED,*
.*       THE ADDRESS IS AS SPECIFIED BY THE A-PARAMETER.              *
.*                                                                    *
.* 1:    IF BOTH THE A AND R PARAMETERS ARE CODED, SPACE IS ALLOCATED *
.*       FOR THE RECORD VIA THE GSPACE MACRO-INSTRUCTION, THE RECORD  *
.*       IS MOVED TO THE AREA ALLOCATED, AND THE ADDRESS OF THE       *
.*       ALLOCATED AREA IS USED. BY CODING THE R-PARAMETER THE RECORD *
.*       IS DEFINED SO IT CAN BE COLLECTED AT THE ALLOCATED AREA.     *
.*       IN EITHER CASE, AFTER THE INS MACRO HAS BEEN SUCCESSFULLY    *
.*       EXECUTED THE ADDRESS USED FOR THE ASSOCIATION IS RETURNED IN *
.*       REGISTER 15 AS THE RETURN CODE. IF THE INSERT IS NOT         *
.*       SUCCESSFUL FOR SOME REASON, THE RETURN CODE IN REGISTER 15 IS*
.*       NEGATIVE.                                                    *
.*                                                                    *
.* THE DESCRIPTIONS OF THE PARAMETERS FOR THE INS MACRO ARE AS        *
.* FOLLOWS:                                                           *
.*                                                                    *
.* TREE: THIS SPECIFIES THE ADDRESS OF THE RADIX PARTITION TREE USED  *
.*       TO STORE THE KEY-ADDRESS ASSOCIATIONS. IT MAY BE CODED TO    *
.*       SPECIFY EITHER A MAIN STORAGE LOCATION CONTAINING THE ADDRESS*
.*       OF THE RPT OR IN PARENTHESES TO INDICATE A GENERAL REGISTER  *
.*       CONTAINING THE ADDRESS OF THE RPT. IF "(1)" IS CODED, NO LOAD*
.*       REGISTER INSTRUCTION IS GENERATED BY THE INS MACRO, AS THE   *
.*       ADDRESS IS ALREADY IN THE APPROPRIATE PARAMETER LIST         *
.*       REGISTER.                                                    *
.*       THE TREE PARAMETER MAY BE OMITTED, IN WHICH CASE THE ADDRESS *
.*       OF THE RPT IS ASSUMED IN GPR 1.                              *
.*                                                                    *
.* A:    THE A-PARAMETER SPECIFIES THE ADDRESS OF THE RECORD          *
.*       CONTAINING THE KEY TO BE USED FOR THE ASSOCIATION. THE RECORD*
.*       ADDRESS MAY BE EITHER A MAIN STORAGE LOCATION OR MAY BE IN A *
.*       REGISTER, INDICATED BY ENCLOSING THE REGISTER NAME OR # IN   *
.*       PARENTHESES. FOR EXAMPLE, IF "A=LABEL" IS CODED, "LABEL" IS  *
.*       TAKEN AS THE SYMBOLIC NAME OF THE MAIN STORAGE LOCATION      *
.*       CONTAINING THE RECORD. THE A PARAMETER MAY BE USED IN        *
.*       CONJUNCTION WITH THE R PARAMETER TO SPECIFY A SCATTERED      *
.*       RECORD TO BE COLLECTED INTO A SPACE PROVIDED VIA THE GSPACE  *
.*       MACRO-INSTRUCTION.                                           *
.*                                                                    *
.* R:    THE R-PARAMETER IS USED TO SPECIFY THE RECORD WHEN IT IS     *
.*       DESIRED THAT THE INS MACRO ALLOCATE AN AREA TO HOLD THE      *
.*       RECORD VIA THE GSPACE MACRO AND MOVE THE RECORD TO THE AREA  *
.*       ALLOCATED BEFORE INSERTING THE ASSOCIATION IN THE RPT.       *
.*       THERE ARE TWO MODES FOR CODING THE R PARAMETER; THE FIRST WAY*
.*       IS IN CONJUNCTION WITH THE A PARAMETER, AND THE SECOND IS    *
.*       WITHOUT CODING THE A PARAMETER. IF BOTH THE A AND R          *
.*       PARAMETERS ARE CODED, THEN THE A PARAMETER PROVIDES THE      *
.*       ADDRESS OF A BASE AREA FROM WHICH TO COLLECT THE RECORD, AND *
.*       THE R-PARAMETER SPECIFIES THE RECORD IN THE BASE AREA BY     *
.*       PAIRS OF DISPLACEMENTS AND LENGTHS, ENCLOSED IN PARENTHESES. *
.*       THE DISPLACEMENT-LENGTH PAIRS ARE CODED AS ((D,L),(D,L),...  *
.*       ,(D,L)), WHERE EACH DISPLACEMENT AND LENGTH IS ENCLOSED IN   *
.*       PARENTHESES, AND THE ORDER THE PAIRS APPEAR IN THE LIST IS   *
.*       THE ORDER IN WHICH THE RECORD IS COLLECTED.                  *
.*       EACH DISPLACEMENT AND LENGTH MUST BE A SELF-DEFINING DECIMAL *
.*       NUMBER.                                                      *
.*       FOR EXAMPLE, CODING "A=(8),R=((10,3),(6,9))" CAUSES THE      *
.*       RECORD TO BE COLLECTED FROM THE TWO FIELDS AT OFFSETS 10 AND *
.*       6 RESPECTIVELY FROM THE BASE ADDRESS IN GPR 8. NOTE THAT NO  *
.*       CHECK IS MADE FOR OVERLAPPING FIELDS.                        *
.*       IF THERE IS ONLY ONE DISPLACEMENT-LENGTH PAIR, IT MAY BE     *
.*       CODED WITH ONLY ONE SET OF ENCLOSING PARENTHESES INSTEAD OF  *
.*       TWO.                                                         *
.*                                                                    *
.*       IF THE R PARAMETER IS CODED AND THE A PARAMETER IS NOT CODED,*
.*       THE ELEMENTS IN THE LIST FOR THE R PARAMETER MAY BE CODED AS *
.*       ADDRESS-LENGTH PAIRS. IN THIS CASE, EACH ADDRESS MAY EITHER  *
.*       BE A MAIN STORAGE LOCATION, OR IN A REGISTER. EACH ADDRESS   *
.*       MUST BE A RELOCATABLE EXPRESSION IF IT NOT IN A REGISTER.    *
.*       INSTEAD OF THE ADDRESS-LENGTH PAIR, A LABEL MAY BE CODED, AS *
.*       LONG AS THE LABEL HAS A LENGTH ATTRIBUTE THAT CAN BE USED TO *
.*       OBTAIN THE LENGTH OF THE CORRESPONDING FIELD.                *
.*                                                                    *
.* T:    THE T-PARAMETER IS USED TO SPECIFY THE RADIX PARTITION TREE  *
.*       TYPE FOR THE INSERTION. THE T-PARAMETER MUST BE CODED AS A   *
.*       SINGLE SELF-DEFINING DECMIAL NUMBER WITHOUT LEADING ZEROS.   *
.*       IF THE T-PARAMETER IS NOT CODED, THE TYPE WILL BE OBTAINED   *
.*       FROM THE GLOBAL VARIABLE &IGATYPE (IF IT IS A VALID RPT      *
.*       TYPE). IF IT IS NOT A VALID TREE TYPE, A TYPE 8 IS SUPPLIED, *
.*       AND THE GLOBAL VARIABLE &IGATYPE IS SET TO 8.                *
.*                                                                    *
.*       THE PARAMETERS INSARG, MOVE, RECL, AND TYPE SHOULD NOT BE    *
.*       USED, AS THEY ARE ONLY PRESENT FOR COMPATIBILITY WITH EARLIER*
.*       VERSIONS OF THE INSERT MACRO.                                *
         GBLC  &IGABLST  THE OFFSET INTO THE TREE HEADER FOR THE LIST  *
                         OF RPT ENTRY POINTS.
         GBLC  &IGAINS
         GBLC  &IGARPT#  THE RADIX PARTITION TREE TYPE FROM EITHER THE *
                         T OR TYPE PARAMETER.
         GBLA  &IGARECL  THE LENGTH OF THE RECORD TO BE INSERTED BY THE*
                         INSERT MACRO-INSTRUCTION.
         GBLA  &IGALEFT(256)  LEFT INVERTIBLE SUBTRACTION EDGES FOR THE*
                         BINARY PARSE TREE.
         GBLA  &IGARGHT(256)  RIGHT INVERTIBLE SUBTRACTION EDGES FOR   *
                         THE BINARY PARSE TREE.
         GBLA  &IGAX     PENULTIMATE VERTEX ON PATH TO CURRENT ATOM    *
                         WHEN SCANNING.
         GBLA  &IGAZ     LAST INNER VERTEX ON PATH TO ATOM.
         GBLA  &IGAPATH(16)  PATH VECTOR FOR THE SCANNING OPERATIONS ON*
                         THE PARSE TREE.
         GBLA  &IGALEVL  NUMBER OF NESTED LEVELS OF PARENTHESES FOR    *
                         CURRENT ATOM.
         GBLB  &IGAOKAY  ON IF THE PARSE IN RPTDSECT DID NOT FIND ANY  *
                SYNTAX ERRORS IN THE R PARAMETER LIST.
         LCLA  &I        A LOCAL VARIABLE FOR KEEPING TRACK OF THE     *
                         CURRENT ENTRY BEING SCANNED IN THE R PARAMETER*
                         LIST.
         LCLA  &LNG      THE LENGTH OF THE CURRENT DISPLACEMENT-LENGTH *
                         PAIR.
         LCLA  &TMPA     USED TO REMEMBER &IGAPATH(&IGALEVL-1).
         LCLC  &RC       USED TO SET THE REQUEST MODE FOR THE GSPACE   *
                         MACRO TO CONDIRIONAL OR UNCONDITIONAL.
         LCLC  &X        JUST A LOCAL CHARACTER VECTOR FOR COLLECTING  *
                         OPERANDS.
         LCLB  &REQUEST  ON IF THE GSPACE REQUEST IS A CONDITIONAL     *
                         REQUEST.
         LCLB  &R1SAVED  ON IF REGISTER 1 IS SAVED THROUGH THE GSPACE  *
                         OPERATION.
         LCLB  &FINEQU   ON IF THE EQUATE "FIN&SYSNDX EQU *" MUST BE   *
                         GENERATED AT THE END OF THE MACRO EXECUTION.
         LCLB  &ERROR    THIS BIT IS TURNED ON WHENEVER AN MNOTE OF    *
                         SUFFICIENT SEVERITY IS GENERATED.
         LCLA  &DSP      THIS IS USED FOR COLLECTING THE DISPLACEMENT  *
                         AS A NUMBER.
         LCLC  &FIELD    THIS IS USED TO HOLD THE FIELD OF AN (F,L)    *
                         PAIR WHILE GETTING THE L.
         LCLB  &XFER     ON TO GENERATE THE MOVES WHEN IT IS THE RIGHT *
               ITERATION THROUGH THE LOOP.
.*A000000                                                        Y02147
.**********************************************************************
.* CHECK TO SEE WHETHER ANY OF THE OLD PARAMETERS ARE CODED, AND IF   *
.* THEY ARE THEN MAP THEM TO THE NEW PARAMETERS VIA MACRO RECURSION.  *
.**********************************************************************
.*                                                                    *
         AIF   ((K'&INSARG EQ 0)AND(K'&MOVE EQ 0)AND(K'&RECL EQ 0)).NEW*
                         GO IF NONE OF THE OLD PARAMETERS ARE CODED.
         AIF   (K'&RECL EQ 0).NORECL  SEE IF THE RECORD LENGTH IS NOT  *
                         CODED.
&TAG     INS   &TREE,A=&INSARG,T=&T,TYPE=&TYPE,R=(0,&RECL),C=1
         AGO   .FIN      ALL DONE, NOW EXIT.
.NORECL  ANOP
&TAG     INS   &TREE,A=&INSARG,T=&T,TYPE=&TYPE,C=1
         AGO   .FIN  ALL DONE NOW, EXIT FROM THE INS MACRO-INSTRUCTION.
.**********************************************************************
.* ALL FINISHED WITH COMPATIBILITY PROCESSING WITH THE OLD FORMATS,   *
.* NOW REALLY DO IT.                                                  *
.**********************************************************************
.NEW     ANOP
.**********************************************************************
.* CHECK TO SEE IF THE LABEL FIELD IS CODED AND GENERATE THE          *
.* APPROPRIATE EQUATE IF IT IS.                                       *
.**********************************************************************
         AIF   (K'&TAG EQ 0).NOTAG  GO AROUND THE EQUATE IF THE TAG IS *
                         NOT PRESENT.
&TAG     EQU   *         PROVIDE THE LABEL.
.NOTAG   ANOP
.**********************************************************************
.* CHECK THE TYPE AND T PARAMETERS TO SEE IF A VALID RPT TYPE IS      *
.* SPECIFIED. IF NEITHER IS SPECIFIED, ASSUME IT IS TYPE 8 RPT. THE   *
.* TYPE IS PUT INTO THE GLOBAL VARIABLE &IGARPT# AT THE END OF THE    *
.* TYPE CHECKING SECTION.                                             *
.**********************************************************************
.RPT#    AIF   (K'&T EQ 0).RPT#TMT  SEE IF THE T PARAMETER IS CODED.
         AIF   (K'&TYPE EQ 0).RPT#TCK  USE THE T PARAMETER IF IT IS    *
                         CODED AND THE TYPE PARAMETER IS NOT CODED.
.**********************************************************************
.* BOTH THE T AND TYPE PARAMETERS ARE CODED; SEE IF THEY ARE THE SAME,*
.* AND IF THEY ARE NOT THEN USE T.                                    *
.**********************************************************************
         AIF   ('&T' EQ '&TYPE').RPT#TCK  IF THEY ARE THE SAME THEN USE*
                         T.
         MNOTE 4,'TYPE CONFLICT, ONLY T OR TYPE SHOULD BE CODED.'
.RPT#TCK ANOP
&IGARPT# SETC  '&T'      GET THE RPT TYPE.
         AGO   .RPT#CHK  GO TO CHECK THE VALIDITY OF THE RADIX         *
                         PARTITION TREE TYPE.
.**********************************************************************
.* THE T PARAMETER IS NOT CODED, SEE IF THE TYPE PARAMETER IS CODED.  *
.**********************************************************************
.RPT#TMT AIF   (K'&TYPE EQ 0).RPT#8  IF BOTH ARE LEFT OUT USE TYPE 8   *
                         RPT.
&IGARPT# SETC  '&TYPE'   SET THE TYPE TO THE TYPE THAT IS SPECIFIED BY *
                         THE TYPE PARAMETER.
         AGO   .RPT#CHK  GO CHECK IT FOR VALIDITY.
.RPT#CHK AIF   (('&IGARPT#' EQ '8')OR('&IGARPT#' EQ '5')OR('&IGARPT#' E*
               Q '4')).RPT#FIN
         MNOTE 4,'INVALID RPT TYPE, TYPE 8 ASSUMED.'
.RPT#8   ANOP
&IGARPT# SETC  '8'       SET RPT TYPE TO THE DEFAULT.
.RPT#FIN ANOP
      RPTDSECT T=5,DS=NO
      RPTDSECT T=8,DS=NO
.**********************************************************************
.* INSERT INTO A TYPE 8 RADIX PARTITION TREE. FIRST CHECK TO SEE      *
.* WHETHER THE AREA TO HOLD THE NEW RECORD MUST BE ALLOCATED VIA THE  *
.* GSPACE MACRO-INSTRUCTION. IF THE R-PARAMETER IS CODED THEN THE AREA*
.* MUST BE ALLOCATED. IF THE AREA DOES NOT HAVE TO BE ALLOCATED GO    *
.* DIRECTLY TO .CHKA.                                                 *
.**********************************************************************
         AIF   (K'&R EQ 0).CHKA  SEE IF THERE IS NO RECORD SPECIFIED.
.**********************************************************************
.* CHECK TO SEE WHETHER THE TREE ADDRESS IS IN GPR 1 AND MUST BE      *
.* PRESERVED THROUGH THE GSPACE OPERATION.                            *
.**********************************************************************
         AIF   (K'&TREE EQ 0).TREEMT  GO IF THE TREE PARAMETER IS NOT  *
                         CODED.
         AIF   ('&TREE'(1,1) NE '(').TREEOK  SEE IF IT IS NOT IN A     *
                         REGISTER.
         AIF   ('&TREE' EQ '(1)').TREEMT  SEE IF IT IS SPECIFICALLY    *
                         SPECIFIED IN REGISTER 1.
         AGO   .TREEOK   IT IS APPARENTLY NOT IN REGISTER 1, ASSUME IT *
                         IS OK.
.TREEMT  ST    1,((4*1)+20-64*((2+1)/16))(,13)  SAVE R1.
&R1SAVED SETB  (1)       SET THE BIT ON TO INDICATE R1 WAS STORED      *
                         THROUGH THE GSPACE OPERATION.
.TREEOK  ANOP
.**********************************************************************
.* DETERMINE THE LENGTH OF THE AREA NEEDED FOR THE RECORD BY ADDING UP*
.* ALL THE INDIVIDUAL LENGTHS IN THE DISPLACEMENT-LENGTH PAIRS IN THE *
.* R-PARAMETER.                                                       *
.**********************************************************************
.* THE R PARAMETER HAS BEEN CHECKED AT THIS POINT, AND IS NOT THE     *
.* EMPTY STRING.                                                      *
.* THE FOLLOWING LOOP IS DONE TWICE; THE FIRST TIME THROUGH IT ONLY   *
.* CHECKS ALL THE R-PARAMETER ELEMENTS FOR VALIDITY AND ADDS UP ALL   *
.* THE FIELD LENGTHS FOR THE GSPACE, AND THE SECOND TIME THROUGH IT   *
.* GENERATES ALL THE MVC'S TO MOVE THE RECORD TO THE AREA ALLOCATED.  *
.* IF THE FIRST TIME THROUGH FINDS ERRORS, THEN THERE IS NO SECOND    *
.* TIME.                                                              *
.**********************************************************************
.LOOPAIR ANOP
&IGARECL SETA  0         INITIALIZE THE RECORD LENGTH TO ZERO.
         AIF   (N'&R EQ 2).RHAS2  SEE IF THERE ARE EXACTLY TWO ELEMENTS*
                         IN R ON PARENTHESIS LEVEL ONE.
         AIF   (N'&R NE 1).RMIXED  SEE IF THERE ARE MORE THAN TWO      *
                         ELEMENTS, FOR IF SO THE LIST CONSISTS OF A    *
                         SERIES OF FIELD NAMES OR (D,L) PAIRS.
.**********************************************************************
.* R HAS ONLY ONE ELEMENT ON LEVEL 1. FIND OUT WHICH OF THE FOLLOWING *
.* CASES APPLIES, AND TAKE THE INDICATED ACTION:                      *
.* IN THE FOLLOWING DISCUSSION, )F" MEANS A FIELD NAME, "D" MEANS     *
.* DISPLACEMENT, "L" MEANS LENGTH, AND "X" MEANS ANY STRING. THE D AND*
.* L FIELDS MUST BE SELF-DEFINING TERMS,.                             *
.* IF:   THEN:                                                        *
.* R=F   ENTER THE ROUTINE AT .RMIXED TO PROCESS A LIST OF PAIRS OF   *
.*       F'S AND (D,L) PAIRS, SINCE THIS CASE WILL BE TREATED AS A    *
.*       SINGLE FIELD NAME BY THAT ROUTINE.                           *
.* R=(F) THIS IS AN ERROR, BECAUSE OF THE POSSIBLE FUTURE USE OF THIS *
.*       FORM TO INDICATE THE ADDRESS OF A LIST OF DISPLACEMENT-LENGTH*
.*       PAIRS IN A REGISTER.                                         *
.* R=L   L IS THE LENGTH OF THE RECORD TO BE INSERTED. THE A PARMAETER*
.*       MUST BE CODED FOR THIS TO BE VALID, BECAUSE OTHERWISE THERE  *
.*       IS NO WAY TO FIND OUT WHERE THE RECORD IS THAT IS TO BE      *
.*       INSERTED.                                                    *
.* R=(L) THIS IS AN ERROR, BECAUSE OF THE POSSIBILITY THAT IN THE     *
.*       FUTURE I WILL WANT TO PUT THE ADDRESS OF A LIST OF           *
.*       DISPLACEMENT-LENGTH PAIRS IN A REGISTER.                     *
.* R=((X)) ENTER THE .RMIXED ROUTINE, SINCE IT LOOKS LIKE A LIST OF   *
.*       DISPLACEMENT-LENGTH PAIRS WITH ONLY ONE PAIR.                *
.*       ANYTHING ELSE IS INVALID, AND PRODUCES THE MNOTE 12,'INVALID *
.*       R-PARAMETER.'                                                *
.**********************************************************************
         AIF   ('&R'(1,1) NE '(').RNOTLP  SEE IF THERE ARE NO          *
                         PARENTHESES AROUND THE OPERAND.
         AIF   ('&R'(1,2) EQ '((').RMIXED  SEE IF THIS IS THE CASE     *
                         R=((X)).
         MNOTE 12,'A REGISTER CANNOT BE SPECIFIED FOR THE LIST OF DISPL*
               ACEMENT-LENGTH PAIRS.'
&ERROR   SETB  1         SET THE ERROR FLAG ON.
         AGO   .RFIN     END THIS PART.
.**********************************************************************
.* THIS MUST BE ONE OF THE TWO CASES R=F OR R=L.                      *
.**********************************************************************
.RNOTLP  ANOP
         AIF   (((T'&R(1) NE 'M')AND(T'&R(1) NE 'N')AND(T'&R(1) NE 'O')*
               AND(T'&R(1) NE 'T')AND(T'&R(1) NE 'W')AND(T'&R(1) NE '$'*
               )AND(T'&R(1) NE 'U'))).RMIXED
.* THIS MUST BE THE CASE WHERE "R=L" IS CODED.                        *
         AIF   (T'&R(1) NE 'N').R1NOTN  SEE IF IT IS A SELF-DEFINING   *
                         FIELD.
.**********************************************************************
.* R=L IS CODED, AND L IS A SELF-DEFINING TERM. USE L FOR THE RECORD  *
.* LENGTH, BUT FIRST CHECK TO SEE IF THE A PARAMETER IS CODED. IF THE *
.* A PARAMETER IS NOT CODED IT IS AN ERROR.                           *
.**********************************************************************
&IGARECL SETA  (&R(1))   GET THE RECORD LENGTH FROM THE L OF THE R     *
                         PARAMETER.
         AIF   (K'&A EQ 0).R1AMT  SEE IF THE A PARAMETER HAS BEEN LEFT *
                         OUT.
         AIF   (&IGARECL GT 256).R1LERR  FOR THE NONCE ONLY TAKE FIELDS*
                         THAT ARE LESS THAN 257 BYTES LONG.
         AIF   (NOT &XFER).RFIN  SEE IF THIS IS THE MVC GENERATION     *
                         LOOP, OR JUST THE VALIDATION AND ADDING UP    *
                         FIELD LENGTHS LOOP.
.* GENERATE THE MOVE OF THE RECORD TO THE AREA ALLOCATED VIA GSPACE.  *
         AIF   ('&A'(1,1) EQ '(').R1AGPR  SEE IF THE ADDRESS IS IN A   *
                         GPR.
         MVC   0(&IGARECL,1),&A  MOVE THE RECORD.
         AGO   .RFIN     ALL DONE NOW.
.R1AGPR  MVC   0(&IGARECL,1),0&A  MOVE THE RECORD.
         AGO   .RFIN     GO TO THE END OF THE R PARAMETER PROCESSING.
.**********************************************************************
.* FOLLOWING ARE THE MISCELLANEOUS ERROR MNOTES FROM THE SINGLE       *
.* ELEMENT CASE OF THE R PARAMETER.                                   *
.**********************************************************************
.R1LERR  MNOTE 12,'THE LENGTH OF EACH FIELD DEFINED BY R CANNOT EXCEED *
               256 BYTES.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON SO THE MVC'S DON'T GET  *
                         GENERATED.
         AGO   .RFIN
.R1AMT   MNOTE 12,'THE A PARAMETER MUST BE CODED WITH R AS CODED.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .RFIN
.R1NOTN  MNOTE 12,'THE LENGTH MUST BE A SELF-DEFINING TERM FOR THE R PA*
               RAMETER.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .RFIN
.**********************************************************************
.* THE R PARAMETER HAS EXACTLY TWO ELEMENTS IN IT ON LEVEL 1. SEE IF  *
.* EITHER OF THESE TWO ELEMENTS STARTS WITH A LEFT PARENTHESIS, WHICH *
.* MEANS ONE OF THE CASES R=(X,(X)), R=((X),X), OR R=((X),(X)). IF IT *
.* IS ONE OF THESE CASES ENTER THE MIXED ROUTINE AT .RMIXED.          *
.* IF IT IS NOT ONE OF THOSE THREE CASES, THEN IT MUST BE ONE OF THE  *
.* CASES R=(F,F), R=(F,L), OR R=(D,L). NOTE THAT THE CASE R=(D,L) CAN *
.* BE CODED AS R=(,L).                                                *
.**********************************************************************
.RHAS2   AIF   (K'&R(2) NE 0).R2NOTMT  SEE IF THE SECOND ELEMENT IS THE*
                         EMPTY STRING. THIS IS NO GOOD.
         MNOTE 12,'THE SECOND ELEMENT OF A DISPLACEMENT-LENGTH PAIR MUS*
               T BE CODED.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .FIN      FORGET IT, CAN'T DO ANYTHING WITH AN EMPTY    *
                         STRING FOR THE LENGTH.
.R2DMT   ANOP
&DSP     SETA  (0)       SET THE DISPLACEMENT TO ZERO, SINCE IT IS     *
                         CODED AS THE EMPTY STRING.
         AGO   .R2MERGE  MERGE WITH THE CASE WHERE THE DISPLACEMENT IS *
                         NOT THE EMPTY STRING.
.R2NOTMT AIF   (K'&R(1) EQ 0).R2DMT  SEE IF THE DISPLACEMENT IS THE    *
                         EMPTY STRING.
         AIF   (('&R(1)'(1,1) EQ '(')OR('&R(2)'(1,1) EQ '(')).RMIXED   *
                         LOOK FOR ONE OF THE CASES R=(X,(X)), R=((X),  *
                         X), OR R=((X),(X)).
         AIF   (((T'&R(2) NE 'M')AND(T'&R(2) NE 'N')AND(T'&R(2) NE 'O')*
               AND(T'&R(2) NE 'T')AND(T'&R(2) NE 'W')AND(T'&R(2) NE '$'*
               )AND(T'&R(2) NE 'U'))).RMIXED
.* THE SECOND ELEMENT IS NOT A FIELD NAME, SO IT MUST EITHER BE ONE OF*
.* THE TWO CASES R=(F,L) OR R=(D,L), OR IT IS AN ERROR.               *
         AIF   ((T'&R(1) NE 'M')AND(T'&R(1) NE 'N')AND(T'&R(1) NE 'O')A*
               ND(T'&R(1) NE 'T')AND(T'&R(1) NE 'W')AND(T'&R(1) NE '$')*
               AND(T'&R(1) NE 'U')).R2F1
         AIF   (T'&R(1) NE 'N').R2DTYPE  SEE IF THE FIRST ONE IS A     *
                         VALID DISPLACEMENT.
&DSP     SETA  (&R(1))   PICK UP THE DISPLACEMENT.
.R2MERGE ANOP
         AIF   (T'&R(2) EQ 'N').R2TSELF  SEE IF THE LENGTH IS A        *
                         SELF-DEFINING FIELD.
&I       SETA  (K'&R(2))  CHECK THE FIELD TO SEE IF IT ALL NUMERIC.
.R2LTKLP AIF   (('&R(2)'(&I,1) LT '0')OR('&R(2)'(&I,1) GT '9')).R2LTYPE*
                         SEE IF IT IS NOT ONE OF THE DIGITS 0-9.
&I       SETA  (&I-1)    STEP DOWN TO THE NEXT CHARACTER.
         AIF   (&I GT 0).R2LTKLP  SEE IF ALL THE CHARACTERS HAVE BEEN  *
                         CHECKED.
.R2TSELF ANOP
&IGARECL SETA  (&R(2))   GET THE LENGTH AS A NUMBER.
         AIF   (&IGARECL GT 256).R1LERR  SEE IF THE LENGTH IS MORE THAN*
                         256 BYTES.
         AIF   (&DSP GT 4095).R2DERR  SEE IF THE DISPLACEMENT IS       *
                         GREATER THAN 4095.
         AIF   (K'&A EQ 0).R1AMT  SEE IF THE A PARAMETER IS LEFT OUT;  *
                         THAT IS BAD.
         AIF   (NOT &XFER).RFIN  SEE IF THIS IS THE MVC GENERATING LOOP*
                         OR NOT.
.**********************************************************************
.* GENERATE THE MOVE OF THE RECORD TO THE AREA ALLOCATED FOR IT VIA   *
.* THE GSPACE MACRO-INSTRUCTION.                                      *
.**********************************************************************
         AIF   ('&A'(1,1) EQ '(').R2AGPR  SEE IF THE ADDRESS IS IN A   *
                         GPR.
         MVC   0(&IGARECL,1),&DSP+&A  MOVE THE RECORD.
         AGO   .RFIN
.R2AGPR  MVC   0(&IGARECL,1),&DSP&A  MOVE THE RECORD IN.
         AGO   .RFIN
.**********************************************************************
.* IT IS AN (F,L) PAIR, NOW SEE IF THE SECOND ELEMENT IS A VALID L.   *
.**********************************************************************
.R2F1    AIF   (T'&R(2) NE 'N').R2LTYPE  SEE IF THE SECOND ELEMENT IS A*
                         SELF-DEFINING TERM.
&IGARECL SETA  (&R(2))   GET THE LENGTH OF THE (F,L) PAIR.
         AIF   (&IGARECL GT 256).R1LERR  SEE IF THE LENGTH OF THE FIELD*
                         IS MORE THAN 256.
         AIF   (NOT &XFER).RFIN  SEE IF THIS IS THE MOVE GENERATION    *
                         LOOP.
         MVC   0(&IGARECL,1),&R(1)  MOVE THE RECORD.
         AIF   (K'&A EQ 0).RFIN  SEE IF THE A PARAMETER IS CODED.
         MNOTE 4,'THE A PARAMETER IS REDUNDANT.'
         AGO   .RFIN     ALL DONE NOW, GO CHECK FOR THE MOVE GENERATION*
                         ITERATION.
.**********************************************************************
.* THE FOLLOWING ARE THE SUNDRY MNOTES FOR THE TWO ELEMENT CASE FOR   *
.* THE R PARAMETER.                                                   *
.**********************************************************************
.R2DERR  MNOTE 12,'DISPLACEMENT IN R PARAMETER CANNOT EXCEED 4095.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .RFIN
.R2DTYPE MNOTE 12,'THE DISPLACEMENT IN R MUST BE A SELF-DEFINING TERM.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON TO PREVENT THE MVC      *
                         GENERATION.
         AGO   .RFIN
.R2LTYPE MNOTE 12,'THE LENGTH IN R MUST BE A SELF-DEFINING TERM.'
&ERROR   SETB  1         SET THE ERROR FLAG ON.
         AGO   .RFIN
.**********************************************************************
.* THE R PARAMETER CONSISTS OF A LIST OF MIXED PAIRS OF FIELDS AND    *
.* DISPLACEMENT-LENGTH PAIRS. PICK OUT ALL THESE AND CHECK THEM FOR   *
.* VALIDITY, WHILE ADDING UP ALL THE LENGTHS OF THE INDIVIDUAL FIELDS *
.* FOR THE GSPACE MACRO-INSTRUCTION LATER. GENERATE THE MVC'S IF THIS *
.* IS THE SECOND TIME THROUGH THE LOOP.                               *
.**********************************************************************
.**********************************************************************
.* THIS IS THE SECTION TO PROCESS A MIXED LIST OF FIELD NAMES AND (D  *
.* ,L) PAIRS. PARSE THE OPERAND USING THE PARSE IN THE RPTDSECT       *
.* MACRO-INSTRUCTION, AND CHECK THE VARIABLE &IGAOKAY TO SEE IF THERE *
.* ARE NO SYNTAX ERRORS IN THE R PARAMETER.                           *
.**********************************************************************
.RMIXED  ANOP
      RPTDSECT SCAN=PARSE,LIST=&R  PARSE THE OPERAND.
         AIF   (&IGAOKAY).RMXOK  SEE IF THE PARSE DETECTED BAD SYNTAX.
         MNOTE 12,'INVALID SYNTAX IN THE R PARAMETER.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .RFIN     CAN'T DO ANYTHING WITH THIS.
.**********************************************************************
.* THE SYNTAX APPEARS TO BE OK, NOW START SCANNING OUT THE ATOMS ONE  *
.* AT A TIME, ANALYZING EACH ONE INDIVIDUALLY IN CONTEXT WITH THE ONES*
.* ON EITHER SIDE OF IT.                                              *
.**********************************************************************
.RMXOK RPTDSECT SCAN=ISCAN  INITIALIZE FOR SUBSEQUENT SCANNING OF      *
                         ATOMS.
.RMXMOR RPTDSECT SCAN=NEXT  GET THE CURSOR POSITIONED AT THE NEXT ATOM.
.RMXCHK  AIF   (&IGAX EQ 0).RFIN  SEE IF THERE ARE ANY MORE TO DO.
         AIF   (&IGALEVL EQ 2).RMXLVL2  SEE IF THIS ATOM IS ON LEVEL 2.
         AIF   (&IGALEVL LE 1).RMXL01  SEE IF THIS ATOM IS ON LEVEL 0  *
                         OR 1.
.**********************************************************************
.* THE CURRENT ATOM HAS TOO MANY LEVELS OF PARENTHESES AROUND IT, GIVE*
.* THE ERROR MESSAGE AND GO LOOK FOR THE NEX THING THAT CHANGES LEVEL *
.* 1 IN THE PATH VECTOR.                                              *
.**********************************************************************
&I       SETA  &IGAPATH(1)+1  SET &I TO THE CURRENT OPERAND NUMBER.
         MNOTE 12,'TOO MANY () LEVELS IN OPERAND &I OF R.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
.**********************************************************************
.* AN ERROR HAS BEEN DETECTED AND FLAGGED IN THE CURRENT OPERAND. SCAN*
.* OVER TO THE NEXT ATOM THAT IS NOT PART OF THE CURRENT ENTRY ON     *
.* LEVEL 1 IN THE PARAMETER.                                          *
.**********************************************************************
.SYNC    ANOP
&I       SETA  &IGAPATH(1)  SET &I TO THE INDEX OF THE OPERAND ON LEVEL*
                         1.
      RPTDSECT SCAN=NEXT  SET THE CURSOR TO THE NEXT ONE.
         AIF   (&IGAX EQ 0).RFIN  SEE IF THERE AREN'T ANY MORE.
         AIF   (&I EQ &IGAPATH(1)).SYNC  SEE IF IT IS STILL ON THE SAME*
                         ONE.
         AGO   .RMXCHK   FINALLY GOT THE NEXT ATOM, NOW GO CHECK IT FOR*
                         VALIDITY.
.**********************************************************************
.* THE CURRENT ATOM IS ON LEVEL 0 OR 1. THEREFORE IT SHOULD BE A VALID*
.* FIELD NAME; SEE IF IT IS.                                          *
.**********************************************************************
.RMXL01  ANOP
.RMX01   ANOP
&I       SETA  (1+&IGAPATH(1))  SET &I TO THE 1-ORIGIN INDEX OF THE    *
                         FIELD NAME ON LEVEL 1.
         AIF   ((T'&R(&I) NE 'M')AND(T'&R(&I) NE 'N')AND(T'&R(&I) NE 'O*
               ')AND(T'&R(&I) NE 'T')AND(T'&R(&I) NE 'W')AND(T'&R(&I) N*
               E '$')AND(T'&R(&I) NE 'U')).RMX01OK
         MNOTE 12,'OPERAND &I OF R DOES NOT HAVE THE PROPER TYPE ATTRIB*
               UTE.'
&ERROR   SETB  (1)       SET THE ERROR FLAG.
         AGO   .SYNC     GO POSITION THE CURSOR TO THE NEXT ONE.
.**********************************************************************
.* THE CURRENT ATOM LOOKS LIKE A VALIID FIELD NAME, GET ITS LENGTH    *
.* ATTRIBUTE AND SEE IF IT ACCEPTABLE.                                *
.**********************************************************************
.RMX01OK ANOP
&LNG     SETA  (L'&R(&I))  CAPTURE IT AS A NUMBER.
         AIF   (&LNG LE 256).RMX0LOK  SEE IF IT EXCEEDS 256.
         MNOTE 12,'THE LENGTH OF FIELD &I OF R EXCEEDS 256 BYTES.'
&ERROR   SETB  (1)       SET TEH ERROR FLAG.
         AGO   .SYNC     GO LOOK AT THE NEXT ONE.
.RMX0LOK ANOP
.**********************************************************************
.* NOW SEE IF THIS IS THE MOVE GENERATION ITERATION.                  *
.**********************************************************************
         AIF   (NOT &XFER).RX0M  GO IF THIS ISN'T THE MOVE GENERATION  *
                         ITERATION.
         MVC   &IGARECL.(&LNG,1),&R(&I)  MOVE THE FIELD.
.RX0M    ANOP
&IGARECL SETA  (&IGARECL+&LNG)  EKE THE CUMMULATIVE RECORD LENGTH.
         AGO   .RMXMOR   GO LOKK FOR THE NEXT ONE.
.**********************************************************************
.* THE CURRENT ATOM IS ON LEVEL 2. IT MUST THEREFORE BE THE FIRST     *
.* ELEMENT IN ONE OF THE CASES (F,L) OR (D,L).                        *
.* FIND OUT WHETHER THE CURRENT ATOM IS AN F OR A D.                  *
.**********************************************************************
.RMXLVL2 ANOP
&X       SETC  '0'       SET THIS FOR THE CASE WHERE THE DISPLACEMENT  *
                         IS AN EMPTY STRING.
         AIF   (&IGAZ EQ 0).RMGDSP  GO IF IT IS AN EMPTY STRING, WHICH *
                         MEANS A DISPLACEMENT OF 0.
.**********************************************************************
.* SEE IF ALL THE CHARACTERS IN THE CURRENT ATOM ARE DIGITS 0 THROUGH *
.* 9, WHICH WOULD MAKE IT A SELF-DEFINING DECIMAL TERM.               *
.**********************************************************************
&I       SETA  0         INITIALIZE THE INDEX OF THE CURRENT CHARACTER *
                         IN THE ATOM.
.RMCONT  AIF   (('&R'(&IGALEFT(&IGAZ)+&I,1) LT '0')OR('&R'(&IGALEFT(&IG*
               AZ)+&I,1) GT '9')).RMNOTD
&I       SETA  (&I+1)    EKE THE INDEX.
         AIF   (&I LT &IGARGHT(&IGAZ)).RMCONT  KEEP GOING UNTIL ALL    *
                         DIGITS HAVE BEEN EXAMINED.
         AIF   (&IGARGHT(&IGAZ) GT 4).RMXBADD  SEE IF THE DISPLACEMENT *
                         HAS TOO MANY BYTES IN IT.
&X       SETC  '&R'(&IGALEFT(&IGAZ),&I)  GET THE DISPLACEMENT AS A     *
                         NUMBER.
.RMGDSP  ANOP
&DSP     SETA  (&X)      GET THE NUMBER NOW.
         AIF   (&DSP GT 4095).RMXDBAD  SEE IF THE DISPLACEMENT IS TOO  *
                         BIG.
.**********************************************************************
.* THE CURRENT ATOM IS A VALID DISPLACEMENT OF A (D,L) PAIR, AND ITS  *
.* ARITHMETIC VALUE IS IN THE APPROPRIATE RANGE OF VALUES FOR A       *
.* DISPLACEMENT. ITS VALUE HAS BEEN CAPTURED IN &DSP. NOW LOOK FOR THE*
.* CORRESPONDING L OF THE PAIR.                                       *
.**********************************************************************
&I       SETA  (&IGAPATH(1))  SAVE THE CURRENT ATOM LEVEL 1 INDEX.
      RPTDSECT SCAN=NEXT  POSITION THE CURSOR TO THE NEXT ATOM.
         AIF   (&IGAX EQ 0).RMXNOLL  SEE IF THERE ISN'T ANY L FOR IT   *
                         BECAUSE THERE AREN'T ANY MORE ATOMS.
         AIF   (&IGAPATH(1) NE &I).RMXNOL  SEE IF THE NEXT ATOM IS PART*
                         OF A DIFFERENT ELEMENT ON LEVEL 1.
         AIF   (&IGALEVL NE 2).RMXPRN  SEE IF THERE ARE TOO MANY LEVELS*
                         OF PARENTHESES.
         AIF   (&IGAZ EQ 0).RMXLBAD  SEE IF THE L ATOM IS THE EMPTY    *
                         STRING.
.**********************************************************************
.* THERE IS A NEXT ATOM IN THE SAME PAIR, NOW CHECK IT TO SEE IF IT IS*
.* A SELF-DEFINING DECIMAL TERM.                                      *
.**********************************************************************
&I       SETA  0  INITIALIZE THE INDEX OF THE CURRENT BYTE IN THE ATOM.
.RMCNT1  AIF   (('&R'(&IGALEFT(&IGAZ)+&I,1) LT '0')OR('&R'(&IGALEFT(&IG*
               AZ)+&I,1) GT '9')).RMXBADL
&I       SETA  (&I+1)    EKE THE INDEX TO THE NEXT BYTE.
         AIF   (&I LT &IGARGHT(&IGAZ)).RMCNT1  KEEP LOOKING UNTIL ALL  *
                         THE BYTES ARE EXAMINED.
         AIF   (&IGARGHT(&IGAZ) GT 4).RMXLERR  SEE IF THE LENGTH IS    *
                         MORE THAN 4 CHARACTERS.
&X       SETC  '&R'(&IGALEFT(&IGAZ),&IGARGHT(&IGAZ))  GET THE LENGTH.
&LNG     SETA  (&X)      TURN IT INTO A NUMBER.
         AIF   (&LNG GT 256).RMXLERR  SEE IF IT IS TOO BIG TO DO WITH  *
                         AN MVC.
.**********************************************************************
.* THE DISPLACEMENT OF THE DISPLACEMENT-LENGTH PAIR IS AT &DSP, AND   *
.* THE LENGTH IS AT &LNG. CHECK THE A PARAMETER TO SEE IF IT IS CODED,*
.* BECAUSE IF IT ISN'T CODED THERE IS NO WAY TO FIND OUT WHERE THE    *
.* RECORD REALLY IS.                                                  *
.**********************************************************************
         AIF   (K'&A EQ 0).RMXAMT  SEE IF IT ISN'T THERE.
.* NOW GENERATE THE MOVE OF THE FIELD IF THIS IS THE MOVE GENERATION  *
.* ITERATION.                                                         *
         AIF   (NOT &XFER).RMOVED  SEE IF IT ISN'T THE MOVE GENERATION *
                         ITERATION.
&X       SETC  ''        SET IT UP FOR THE ADDRESS IN A REGISTER.
         AIF   ('&A'(1,1) EQ '(').RMAGPR  GO IF THE ADDRESS IS IN A    *
                         REGISTER.
&X       SETC  '+'       SET IT UP FOR THE CASE EHERE THE ADDRESS IS   *
                         SUPPLIED IN THE FORM OF A LABEL.
.RMAGPR  MVC   &IGARECL.(&LNG,1),&DSP&X&A  MOVE SUBFIELD.
.RMOVED  ANOP
&IGARECL SETA  (&IGARECL+&LNG)  EKE THE CUMMULATIVE RECORD LENGTH.
.**********************************************************************
.* NOW SET THE CURSOR TO THE NEXT ATOM, AND SEE IF THE FIRST ELEMENT  *
.* IS PART OF THE SAME ELEMENT ON LEVEL 1 AS THE LAST (D,L) PAIR.     *
.**********************************************************************
&I       SETA  &IGAPATH(1)  PRESERVE THE CURRENT LEVEL 0 INDEX.
      RPTDSECT SCAN=NEXT  POSITION THE CURSOR TO THE NEXT ATOM.
         AIF   (&IGAX EQ 0).RFIN  GO IF THERE ISN'T ANY NEXT ATOM.
         AIF   (&I EQ &IGAPATH(1)).RMXSAME  SEE IF THE LEVEL 1 ELEMENT *
                         IN THE PATH VECTOR DIDN'T CHANGE.
         AGO   .RMXCHK   GO CHECK THE NEXT ATOM, IT ISN'T PART OF THE  *
                         LAST TWO.
.**********************************************************************
.* THE FOLLOWING ARE SUNDRY MNOTES FROM THE PROCESSING OF A LIST OF   *
.* MIXED PAIRS WHERE THE PAIRS ARE OF THE FORM (D,L).                 *
.**********************************************************************
.RMXSAME ANOP
&I       SETA  (&IGAPATH(1)+1)  SET &I TO THE CURRENT OPERAND #.
         MNOTE 12,'TOO MANY ELEMENTS IN SUBLIST OPERAND &I IN R.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .SYNC     GO LOOK FOR THE NEXT ONE.
.RMXAMT  ANOP
&I       SETA  (1+&IGAPATH(1))  GET THE CURRENT OPERAND NUMBER.
         MNOTE 12,'THE A PARAMETER MUST BE CODED TO USE A (D,L) PAIR FO*
               R R(&I).'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .SYNC     GO LOOK FOR THE NEXT ONE.
.RMXLERR ANOP
&I       SETA  (&IGAPATH(1)+1)  GET THE CURRENT OPERAND NUMBER.
         MNOTE 12,'THE LENGTH OF THE FIELD DEFINED BY R(&I) EXCEEDS 256*
                BYTES.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .SYNC     GO LOOK AT THE NEXT ONE.
.RMXBADL ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'THE LENGTH FOR R(&I) MUST BE A SELF-DEFINING DECIMAL*
                NUMBER.'
&ERROR   SETB  (1)
         AGO   .SYNC
.RMXLBAD ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'THE LENGTH FOR R(&I) CANNOT BE THE EMPTY STRING.'
&ERROR   SETB  (1)
         AGO   .SYNC
.RMXNOL  ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'LENGTH OF (D,L) PAIR MISSING IN R(&I).'
&ERROR   SETB  (1)
         AGO   .RMXCHK   GO CHECK THE CURRENT ATOM FOR VALIDITY.
.RMXNOLL ANOP
         MNOTE 12,'LENGTH OF LAST (D,L) PAIR IN R IS MISSING.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .RFIN
.RMXPRN  ANOP
&I       SETA  (&IGAPATH(1)+1)
         MNOTE 12,'TOO MANY () LEVELS IN R(&I).'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON.
         AGO   .SYNC
.RMXBADD ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'DISPLACEMENT IN R(&I) EXCEEDS 4 DIGITS.'
&ERROR   SETB  (1)
         AGO   .SYNC
.RMXDBAD ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'DISPLACEMENT IN R(&I) EXCEEDS 4095.'
&ERROR   SETB  (1)
         AGO   .SYNC
.**********************************************************************
.* THE CURRENT ATOM IS AN F OF A (F,L) PAIR.                          *
.**********************************************************************
.RMNOTD  AIF   (&IGARGHT(&IGAZ) LE 8).RMXBIGF  SEE IF THE STRING IS    *
                         BIGGER THAN 8 CHARACTERS.
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'FIELD NAME IN R(&I) IS BIGGER THAN 8 CHARACTERS.'
&ERROR   SETB  (1)
         AGO   .SYNC
.RMXBIGF ANOP
&FIELD   SETC  '&R'(&IGALEFT(&IGAZ),&IGARGHT(&IGAZ))  GET THE FIELD    *
                         NAME.
.* NOW TRY TO GET THE L OF THE (F,L) PAIR.                            *
&I       SETA  (&IGAPATH(1))  PRESERVE THE CURRENT LEVEL 1 INDEX.
      RPTDSECT SCAN=NEXT  POSITION THE CURSOR TO THE NEXT ATOM.
         AIF   (&IGAX EQ 0).RFLNOL  SEE IF THERE IS NO LENGTH BECAUSE  *
                         THERE ISN'T ANY NEXT ATOM.
         AIF   (&IGAPATH(1) NE &I).RFNOL  SEE IF THE NEXT ATOM IS NOT  *
                         PART OF THE SAME PAIR.
         AIF   (&IGALEVL NE 2).RFNOLL  SEE IF THE NEXT ATOM HAS TOO    *
                         MANY () LEVELS.
         AIF   (&IGAZ EQ 0).RFLMT  SEE IF THE LENGTH ATOM IS THE EMPTY *
                         STRING.
.**********************************************************************
.* THE CURRENT ATOM IS INDEED THE SECOND ELEMENT OF A (F,X) PAIR. NOW *
.* LET'S SEE IF X IS A VALID L.                                       *
.**********************************************************************
         AIF   (&IGARGHT(&IGAZ) GT 3).RFLLBAD  SEE IF THE LENGTH ATOM  *
                         IS MORE THAN 3 DIGITS.
&I       SETA  0         INITIALIZE THE INDEX OF THE CURRENT BYTE.
.RMXCNT2 AIF   (('&R'(&IGALEFT(&IGAZ)+&I,1) LT '0')OR('&R'(&IGALEFT(&IG*
               AZ)+&I,1) GT '9')).RFLBAD
&I       SETA  (&I+1)    STEP OVER TO THE NEXT DIGIT.
         AIF   (&I LT &IGARGHT(&IGAZ)).RMXCNT2  KEEP GOING UNTIL ALL   *
                         THE DIGITS HAVE BEEN SCANNED.
&X       SETC  '&R'(&IGALEFT(&IGAZ),&IGARGHT(&IGAZ))  EXTRACT THE      *
                         LENGTH.
&LNG     SETA  (&X)      CONVERT IT TO A NUMBER.
         AIF   (&LNG GT 256).RFBADL  SEE IF THE LENGTH EXCEEDS 256     *
                         BYTES.
.**********************************************************************
.* IT LOOKS LIKE A VALID (F,L) PAIR; GENERATE THE MOVE IF THIS IS THE *
.* MOVE GENERATION ITERATION.                                         *
.**********************************************************************
         AIF   (NOT &XFER).RMOVED  GO IF IT IS NOT THE MOVE ITERATION.
         MVC   &IGARECL.(&LNG,1),&FIELD  MOVE SUBFIELD.
         AGO   .RMOVED   MERGE WITH THE COMMON PATH.
.**********************************************************************
.* THE FOLLOWING ARE SUNDRY MNOTES FOR THE (F,L) CASE IN A MIXED LIST.*
.**********************************************************************
.RFBADL  ANOP
&I       SETA  (&IGAPATH(1)+1)
         MNOTE 12,'LENGTH IN OPERAND &I OF R EXCEEDS 256 BYTES.'
&ERROR   SETB  (1)
         AGO   .SYNC
.RFLBAD  ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'THE LENGTH IN OPERAND R(&I) IS NOT A SELF-DEFINING D*
               ECIMAL NUMBER.'
&ERROR   SETB  (1)
         AGO   .SYNC
.RFLLBAD ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'LENGTH IN OPERAND R(&I) IS MORE THAN 3 DIGITS.'
&ERROR   SETB  (1)
         AGO   .SYNC
.RFLMT   ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'LENGTH IN OPERAND &I OF R CANNOT BE THE EMPTY STRING*
               .'
&ERROR   SETB  (1)
         AGO   .SYNC
.RFNOL   ANOP
         MNOTE 12,'LENGTH OF (F,L) PAIR IN OPERAND &I OF R IS MISSING.'
&ERROR   SETB  (1)
         AGO   .RMXCHK
.RFNOLL  ANOP
&I       SETA  (1+&IGAPATH(1))
         MNOTE 12,'TOO MANY () LEVELS IN R(&I).'
         AGO   .SYNC
.RFLNOL  MNOTE 12,'LENGTH OF LAST (FIELD,LENGTH) PAIR IN R IS MISSING.'
&ERROR   SETB  (1)       SET THE ERROR FLAG ON TO PREVENT THE MOVES.
         AGO   .RFIN
.**********************************************************************
.RFIN    ANOP
         AIF   ((&XFER)OR(&ERROR)).MV#FIN  SEE IF THE MOVE GENERATION  *
                         LOOP MUST BE DONE THIS TIME.
&XFER    SETB  (1)       SET IT ON SO THE MOVES ONLY GET GENERATED ONCE
&RC      SETC  'C'
         AIF   (K'&C EQ 0).GSPACE  SEE IF THE CONDITIONAL PARAMETER HAS*
                         BEEN LEFT OUT.
         AIF  ((('&C' EQ 'C')OR('&C'(1,1) EQ 'Y')OR('&C'(1,1) EQ '1')))*
               .GSPACE   SEE IF IT IS A CONDITIONAL REQUEST.
&RC      SETC  ''        IT IS AN UNCONDITIONAL REQUEST.
.GSPACE  ANOP
        GSPACE R&RC,LV=&IGARECL,S=&S,SP=&SP  GET SPACE TO PUT RECORD.
         AIF   ('&RC' NE 'C').SKIPBNZ  SEE IF THE REQUEST IS COND.
         BNZ   SETR&SYSNDX BR IF ALLOCATION FAILED.
.SKIPBNZ AGO   .LOOPAIR  GO GENERATE THE MOVE OF THE RECORD.
.MV#FIN  ANOP
         LR    15,1      PUT THE RECORD ADDRESS IN R15.
         AIF   (NOT &R1SAVED).R1ISOK  SEE IF R1 WAS SAVED THROUGH THE  *
                         GSPACE OPERATION.
         L     1,((4*1)+20-64*((2+1)/16))(,13)  RESTORE R1.
.R1ISOK  AGO   .CHK#     NOW GO CHECK THE # PARAMETER.
.**********************************************************************
.* THERE IS NO NEED TO ALLOCATE A SPACE FOR THE RECORD VIA THE GSPACE *
.* MACRO-INSTRUCTION. GET THE ADDRESS OF THE RECORD IN REGISTER 15.   *
.**********************************************************************
.CHKA    AIF   (K'&A EQ 0).ASARG  SEE IF THE ADDRESS IS OMITTED; IF IT *
                         IS GET IT OUT OF THE SEARCH ARGUMENT.
         AIF   ('&A'(1,1) EQ '(').AGPR  SEE IF THE ADDRESS IS IN A GPR.
         LA    15,&A     ADDRESS OF THE RECORD TO INSERT.
         AGO   .CHKAEND  GO TO THE END OF CHECKING THE A PARAMETER.
.AGPR    AIF   ('&A' EQ '(15)').CHKAEND  SEE IF IT IS ALREADY IN R15.
         LR    15,&A(1)  INSERT ADDRESS.
         AGO   .CHKAEND  ALL DONE NOW EXIT FROM CHECKING THE A         *
                         PARAMETER.
.ASARG   ANOP
         MNOTE 12,'EITHER A OR R MUST BE CODED TO SPECIFY THE INS.ARG.'
.CHKAEND ANOP
.**********************************************************************
.* CHECK THE # PARAMETER TO SEE IF A DIFFERENT ADDRESS THAN THE ONE   *
.* FURNISHED BY THE A PARAMETER IS TO BEBUSED BY THE INSERT ROUTINE.  *
.**********************************************************************
.CHK#    AIF   (K'&# EQ 0).#ZORRO  SEE IF THE # PARAMETER IS CODED.
         AIF   ('&#'(1,1) EQ '(').#GPR  SEE IF THE # PARAMETER IS IN A *
                         GPR.
         L     0,&#      LOAD IN THE ERSATZ ADDRESS.
         AGO   .#FIN     ALL DONE WITH THE ERSATZ ADDRESS.
.#GPR    DC    ((30-&#(1))/16)AL1(X'18',&#(1))  LOAD THE ERSATZ ADDRESS*
                         IN GPR 0 UNLESS IT IS ALREADY IN GPR 0.
         AGO   .#FIN     ALL DONE WITH THE ERSATZ ADDRESS.
.#ZORRO  LR    0,15  # NOT CODED.
.#FIN    ANOP
.**********************************************************************
.* SEE IF THE REQUEST IS CONDITIONAL OR UNCONDITIONAL, AND CALL THE   *
.* APPROPRIATE ROUTINE IN THE MODULE IGARPT01.                        *
.**********************************************************************
         AIF   (K'&TREE EQ 0).INGPR1  SEE IF THE TREE ADDRESS IS       *
                         SPECIFIED.
         AIF   ('&TREE'(1,1) EQ '(').RPTGPR  SEE IF THE TREE ADDRESS IS*
                         IN A GPR.
         L     1,&TREE   LOAD THE ADDRESS OF THE RPT.
         AGO   .R1LOAD   SKIP AROUND THE GPR CASE.
.RPTGPR  LR    1,&TREE(1)  GET THE RPT ADDRESS.
.R1LOAD  ANOP
.INGPR1  ANOP
         L     14,(&IGABLST+&IGAINS)(,1)  ADDRESS OF INSERT ROUTINE.
.**********************************************************************
.* NOW GENERATE THE LINKAGE TO THE INSERT ROUTINE IN THE MODULE       *
.* IGARPT01.                                                          *
.**********************************************************************
&REQUEST SETB  (1)       SET THE REQUEST MODE TO CONDITIONAL.
         AIF   (K'&C EQ 0).LINKC  SEE IF IT IS A CONDITIONAL REQUEST.
         AIF (('&C'(1,1) EQ 'Y')OR('&C' EQ '1')OR('&C' EQ 'C')).LINKC  *
                         SEE IF IT IS A CONDITIONAL REQUEST.
&REQUEST SETB  (0)       SET THE REQUEST MODE TO UNCONDITIONAL.
         BALR  14,14     INDICATE UNCONDITIONAL TYPE 8 INSERT.
         AGO   .LINKFIN  ALL DONE WITH THE LINKAGE.
.LINKC   BAL   14,0(,14)  INDICATE CONDITIONAL INSERT.
.LINKFIN ANOP
         AIF   (K'&R EQ 0).FIN  SEE IF THE AREA WAS ALLOCATED VIA THE  *
                         GSPACE MACRO-INSTRUCTION.
         AIF   (NOT &REQUEST).FIN  SEE IF IT WAS AN UNCONDITIONAL      *
                         REQUEST.
&FINEQU  SETB  (1)       SET THE BIT ON TO GENERATE THE EQUATE AT THE  *
                         END OF THE MACRO EXECUTION.
         BC    10,FIN&SYSNDX  BRANCH IF THE INSERT WAS SUCCESSFUL.
         L     1,X'10'(,13)  PUT THE ADDRESS IN R1 TO FREE IT UP.
        FSPACE LV=&IGARECL,A=(1),SP=&SP,S=&S
SETR&SYSNDX LA 15,1      SET THE RETURN CODE NEGATIVE.
         LNR   15,15     SET THE CONDITION CODE ALSO.
.FIN     AIF   (NOT &FINEQU).END  SEE IF THE EQUATE MUST BE GENERATED.
FIN&SYSNDX EQU *         LABEL FOR THE BRANCH TO BRANCH TO.
.END     ANOP
         MEND
