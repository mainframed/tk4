         MACRO
&NAME    JDPARM &CONVERT=CHAR,&KEY=,&KEYDFLT=,&MAXLEN=,&MINLEN=1,      +
               &CONLEN=,&HIGH=2147483647,&LOW=0,&LEVNUM=1,&LEVLEN=,    +
               &CHOICE1=,&CHOICE2=,&CHOICE3=,&CHOICE4=,&CHOICE5=,      +
               &CHOICE6=,&CHOICE7=,&CHOICE8=,&REPEAT=0,            @H1C+
               &FSTCHAR=,&OTHCHAR=,&FSTSPEC=,&OTHSPEC=             @H3A
.**********************************************************************
.*                                                                    *
.*   MODULE NAME = IEFJDPRM                                        @H1C
.*                                                                    *
.*   DESCRIPTIVE NAME = JCL PARAMETER DEFINITION                      *
.*                                                                    *
.*   COPYRIGHT = 5740-XYN COPYRIGHT IBM CORP. 1982,1983,              *
.*                LICENSED MATERIAL - PROGRAM,                        *
.*                PROPERTY OF IBM, REFER TO COPYRIGHT                 *
.*                INSTRUCTIONS FORM G120-2083                         *
.*                                                                    *
.*   STATUS = OS/VS2 JBB1329                                          *
.*                                                                    *
.*   FUNCTION = JDPARM MACRO  GENERATES  THE SUBPARAMETER SECTION     *
.*              IN THE JDT TO BE ASSOCIATED WITH THE KEYWORD THAT     *
.*              WAS SPECIFIED IN THE PREVIOUS JDKEY MACRO.            *
.*                                                                    *
.*     NOTES = SPECIFY THE APOSTROPHE AND THE AMPERSAND AS         @H3A
.*             DOUBLE CHARACTERS FOR SPECIAL CHARACTERS.           @H3A
.*                                                                    *
.*      DEPENDENCIES = IF JDKEY MACRO IS INVOKED WITH CONVERT=     @H3A
.*                     REFERRAL, THEN  ALL THE  PARAMETERS FOR     @H3A
.*                     THAT KEYWORD MUST BE REFERRAL ALSO.  IF     @H3A
.*                     JDKEY IS  NOT REFERRAL, ONLY CONVERSION     @H3A
.*                     TYPES  CHAR, INTEGER,  HEX,  AND CHOICE     @H3A
.*                     WILL BE  SUPPORTED FOR PARAMETER TYPES.     @H3A
.*                                                                    *
.*      RESTRICTIONS = 1) THE  JDPARM MACRO  CAN  ONLY  FOLLOW        *
.*                     JDKEY, ENDSUB, JDSUB, OR ANOTHER JDPARM        *
.*                     MACRO.                                         *
.*                     2) IF JDPARM IS  INVOKED  WITHIN A LIST     @H3A
.*                     ITEM  DEFINITION, ONLY ONE  IS ALLOWED.     @H3A
.*                     THE  REPEAT  KEYWORD  MUST  BE  USED TO     @H3A
.*                     CREATE IDENTICAL LIST ITEM DEFINITIONS.     @H3A
.*                                                                    *
.*   ENTRY POINT = N/A                                                *
.*                                                                    *
.*   MODULE TYPE = MACRO                                              *
.*                                                                    *
.*     PROCESSOR = ASSEMBLER                                          *
.*                                                                    *
.*     INPUT = THE FOLLOWING MAY BE SPECIFIED AS PARAMETERS TO JDPARM *
.*                                                                    *
.*           PARAMETER          DESCRIPTION                           *
.*                                                                    *
.*           - &NAME            USED ONLY AS A LABEL ON THE OUTPUT    *
.*           - &CONVERT=        CONVERSION TYPE OF PARAMETER          *
.*           - &KEY=            KEY FOR THIS PARAMETER                *
.*           - &KEYDFLT=        DEFAULT VALUE FOR KEY                 *
.*           - &MAXLEN=         MAXIMUM LENGTH OF PARAMETER        @H1C
.*           - &MINLEN=         MINIMUM LENGTH OF PARAMETER        @H1A
.*           - &CONLEN=         CONVERSION LENGTH OF INTEGER          *
.*                              OR HEX DATA                        @H1A
.*           - &HIGH=           HIGH RANGE OF INTEGER                 *
.*                              OR HEX DATA                        @H1A
.*           - &LOW=            LOW RANGE OF INTEGER                  *
.*                              OR HEX DATA                        @H1A
.*           - &LEVNUM=         MAXIMUM NUMBER OF LEVELS FOR CHAR  @H1A
.*           - &LEVLEN=         MAXIMUM LENGTH OF EACH LEVEL       @H1A
.*           - &FSTCHAR=        FIRST CHARACTER TYPE DEFINITION    @H2A
.*           - &OTHCHAR=        OTHER CHARACTER TYPE DEFINITION    @H2A
.*           - &FSTSPEC=        SPECIAL FIRST CHARACTER DEFINITION @H3A
.*           - &OTHSPEC=        OTHER THAN THE FIRST DEFINITION    @H3A
.*           - &CHOICE1= THRU   CHARACTER STRINGS AND THEIR BYTE      *
.*             &CHOICE8=          VALUES DEFINED FOR PARAMETERS       *
.*           - &REPEAT=         MAKES DUPLICATIONS OF SAME PARAMETER  *
.*                              FUNCTIONS AND SPECIFICATIONS          *
.*                                                                    *
.*     OUTPUT = SUBPARAMETER SECTION FOR A PREVIOUS KEYWORD           *
.*                                                                    *
.*     INVOCATION = THE FOLLOWING CHART SHOWS WHAT KEYWORDS MAY       *
.*                  BE SPECIFIED WITH EACH TYPE OF CONVERSION:        *
.*                  (R=REQUIRED; O=OPTIONAL; N=NOT USED)              *
.*                                                                    *
.*     _________________________________________________________      *
.*     ×         ×       ×       ×         ×        ×          ×      *
.*     × KEYWORD × CHAR  ×  HEX  × INTEGER × CHOICE × REFERRAL ×      *
.*     ×_________×_______×_______×_________×________×__________×      *
.*     ×         ×       ×       ×         ×        ×          ×      *
.*     × KEY     ×   R   ×   R   ×    R    ×   R    ×    R     ×      *
.*     ×_________×_______×_______×_________×________×__________×      *
.*     ×         ×       ×       ×         ×        ×          ×      *
.*     × KEYDFLT ×   N   ×   N   ×    N    ×   O    ×    N     ×      *
.*     ×_________×_______×_______×_________×________×__________×      *
.*     ×         ×       ×       ×         ×        ×          ×      *
.*     × MAXLEN  ×   R   ×   R   ×    R    ×   N    ×    N     ×      *
.*     ×_________×_______×_______×_________×________×__________×      *
.*     ×         ×       ×       ×         ×        ×          ×      *
.*     × MINLEN  ×   O   ×   O   ×    O    ×   N    ×    N     ×      *
.*     ×_________×_______×_______×_________×________×__________×      *
.*     ×         ×       ×       ×         ×        ×          ×      *
.*     × CONLEN  ×   N   ×   R   ×    R    ×   N    ×    N     ×      *
.*     ×_________×_______×_______×_________×________×__________×      *
.*     ×         ×       ×       ×         ×        ×          ×      *
.*     × HIGH    ×   N   ×   O   ×    O    ×   N    ×    N     ×      *
.*     ×_________×_______×_______×_________×________×__________×      *
.*     ×         ×       ×       ×         ×        ×          ×      *
.*     × LOW     ×   N   ×   O   ×    O    ×   N    ×    N     ×      *
.*     ×_________×_______×_______×_________×________×__________×      *
.*     ×         ×       ×       ×         ×        ×          ×      *
.*     × LEVNUM  ×   O   ×   N   ×    N    ×   N    ×    N     ×      *
.*     ×_________×_______×_______×_________×________×__________×      *
.*     ×         ×       ×       ×         ×        ×          ×      *
.*     × LEVLEN  ×   O   ×   N   ×    N    ×   N    ×    N     ×      *
.*     ×_________×_______×_______×_________×________×__________×      *
.*     ×         ×       ×       ×         ×        ×          ×      *
.*     × FSTCHAR ×   O   ×   N   ×    N    ×   N    ×    N     ×      *
.*     ×_________×_______×_______×_________×________×__________×      *
.*     ×         ×       ×       ×         ×        ×          ×      *
.*     × OTHCHAR ×   O   ×   N   ×    N    ×   N    ×    N     ×      *
.*     ×_________×_______×_______×_________×________×__________×      *
.*     ×         ×       ×       ×         ×        ×          ×      *
.*     × FSTSPEC ×   O   ×   N   ×    N    ×   N    ×    N     ×      *
.*     ×_________×_______×_______×_________×________×__________×      *
.*     ×         ×       ×       ×         ×        ×          ×      *
.*     × OTHSPEC ×   O   ×   N   ×    N    ×   N    ×    N     ×      *
.*     ×_________×_______×_______×_________×________×__________×      *
.*     ×         ×       ×       ×         ×        ×          ×      *
.*     × CHOICE# ×   N   ×   N   ×    N    ×   R(1) ×    N     ×      *
.*     ×_________×_______×_______×_________×________×__________×      *
.*     ×         ×       ×       ×         ×        ×          ×      *
.*     × REPEAT  ×   O   ×   O   ×    O    ×   O    ×    O     ×      *
.*     ×_________×_______×_______×_________×________×__________×      *
.*     (1) NOTE: AT LEAST ONE CHOICE MUST BE SPECIFIED.               *
.*                                                                    *
.*   EXIT NORMAL =                                                    *
.*   CONDITION-NO ERRORS DETECTED                                     *
.*   OUTPUT    -NO MNOTE ISSUED. SEVERITY CODE=0.                     *
.*                                                                    *
.*   EXIT NORMAL =                                                    *
.*   CONDITION-ERROR CONDITION DETECTED BY THE JDPARM MACRO.          *
.*   OUTPUT    -INFORMATIONAL MNOTES WITH SEVERITY CODE 4             *
.*              ISSUED WHEN A PARAMETER SPECIFIED IS INCORRECT.       *
.*              THE SPECIFIED PARAMETER IS IGNORED AND/OR THE         *
.*              DEFAULT VALUE IS ASSUMED FOR THAT PARAMETER.          *
.*              (SEE MESSAGES BELOW)                                  *
.*                                                                    *
.*   EXIT ERROR =                                                     *
.*   CONDITION-SEVERE ERROR DETECTED BY THE JDPARM MACRO.             *
.*   OUTPUT    -ERROR MNOTES WITH SEVERITY CODE 12                    *
.*              ISSUED WHEN MACRO IS NOT INVOKED IN THE CORRECT       *
.*              ORDER (SEE RESTRICTIONS) OR CERTAIN VALUES FOUND      *
.*              MAY CAUSE SYSTEM ERRORS.  THE MACRO WILL ATTEMPT      *
.*              TO SCAN FOR ADDITIONAL ERRORS.                        *
.*              (SEE MESSAGES BELOW)                                  *
.*                                                                    *
.*   EXIT ERROR =                                                     *
.*   CONDITION-TERMINATING ERROR DETECTED BY THE JDPARM MACRO.        *
.*   OUTPUT    -ERROR MNOTE WITH SEVERITY CODE 16                     *
.*              ISSUED WHEN JDPARM MACRO IS INVOKED PRIOR TO          *
.*              THE JDTMAC MACRO OR THE CONVERSION SPECIFIED          *
.*              BY THIS MACRO IS INCONSISTENT WITH THE JDKEY       @H2A
.*              CONVERSION OF REFERRAL. THE MACRO EXPANSION WILL   @H2A
.*              BE TERMINATED AS A RESULT OF THE ERROR.               *
.*              (SEE MESSAGES BELOW)                                  *
.*                                                                    *
.*   EXTERNAL REFERENCES = JDSCAN MACRO IS USED FOR VALIDATION        *
.*                         OF CHOICE SYMBOL SPECIFICATIONS.           *
.*                         I.E., 1-8 CHARACTERS, FIRST CHARACTER      *
.*                         MUST BE ALPHABETIC OR NATIONAL (@,#,$);    *
.*                         2-7 MUST BE ALPHANUMERIC OR NATIONAL.   @R6A
.*                                                                    *
.*   TABLES = NONE                                                    *
.*                                                                    *
.*   MESSAGES = (MNOTES)                                              *
.*                                                                    *
.*   INFORMATIONAL MNOTES = CONVERT=CHAR                              *
.*    MNOTE 4,'CHOICE KEYWORDS FOR CONVERT=CHAR HAVE NO MEANING.      *
.*             CHOICE PARAMETERS ARE IGNORED'                      @R5A
.*    MNOTE 4,'FSTCHAR KEYWORD HAS MULTIPLE DEFINED                   *
.*             SUBPARAMETERS.'                                     @H2A
.*    MNOTE 4,'OTHCHAR KEYWORD HAS MULTIPLE DEFINED                   *
.*             SUBPARAMETERS.'                                     @H2A
.*                                                                    *
.*   INFORMATIONAL MNOTES = CONVERT=HEX                               *
.*    MNOTE 4,'CHOICE KEYWORDS FOR CONVERT=HEX HAVE NO MEANING.       *
.*             CHOICE PARAMETERS ARE IGNORED'                      @H1A
.*    MNOTE 4,'LEVNUM AND/OR LEVLEN FOR CONVERT=HEX HAVE NO MEANING.  *
.*             LEVNUM/LEVLEN PARAMETERS ARE IGNORED.'              @H1A
.*    MNOTE 4,'FSTCHAR AND/OR OTHCHAR FOR  CONVERT=HEX  HAVE NO       *
.*             MEANING. FSTCHAR/OTHCHAR PARAMETERS ARE IGNORED.'   @H2A
.*                                                                    *
.*   INFORMATIONAL MNOTES = CONVERT=CHOICE                            *
.*    MNOTE 4,'CONLEN NOT REQUIRED WITH CONVERT=CHOICE. CONLEN        *
.*             PARAMETER SET TO ONE'                               @R4C
.*    MNOTE 4,'MAXLEN PARAMETER IS NOT REQUIRED WITH CONVERT=CHOICE.  *
.*             MAXLEN SET TO EIGHT'                                @H1C
.*    MNOTE 4,'MINLEN PARAMETER IS NOT REQUIRED WITH CONVERT=CHOICE.  *
.*             MINLEN SET TO 1'                                    @H1A
.*    MNOTE 4,'LEVNUM AND/OR LEVLEN FOR CONVERT=CHOICE HAVE NO        *
.*             MEANING. LEVNUM/LEVLEN PARAMETERS ARE IGNORED.'     @H1A
.*    MNOTE 4,'FSTCHAR AND/OR OTHCHAR FOR CONVERT=CHOICE HAVE NO      *
.*             MEANING. FSTCHAR/OTHCHAR PARAMETERS ARE IGNORED.'   @H2A
.*                                                                    *
.*   INFORMATIONAL MNOTES = CONVERT=INTEGER                           *
.*    MNOTE 4,'CHOICE KEYWORDS FOR CONVERT=INTEGER HAVE NO MEANING.   *
.*             CHOICE PARAMETERS ARE IGNORED'                      @R5A
.*    MNOTE 4,'LEVNUM AND/OR LEVLEN FOR CONVERT=INTEGER HAVE NO       *
.*             MEANING. LEVNUM/LEVLEN PARAMETERS ARE IGNORED.'     @H1A
.*    MNOTE 4,'FSTCHAR AND/OR OTHCHAR FOR CONVERT=INTEGER HAVE NO     *
.*             MEANING. FSTCHAR/OTHCHAR PARAMETERS ARE IGNORED.'   @H2A
.*                                                                    *
.*   INFORMATIONAL MNOTES = CONVERT=REFERRAL                          *
.*    MNOTE 4,'CHOICE KEYWORDS FOR CONVERT=REFERRAL HAVE NO MEANING.  *
.*             CHOICE PARAMETERS ARE IGNORED'                      @H2A
.*    MNOTE 4,'MAXLEN AND/OR MINLEN FOR CONVERT=REFERRAL HAVE NO      *
.*             MEANING. MAXLEN/MINLEN PARAMETERS ARE PRESET.'      @H2A
.*    MNOTE 4,'LEVNUM AND/OR LEVLEN FOR CONVERT=REFERRAL HAVE NO      *
.*             MEANING. LEVNUM/LEVLEN PARAMETERS ARE IGNORED.'     @H2A
.*    MNOTE 4,'FSTCHAR AND/OR OTHCHAR FOR CONVERT=REFERRAL HAVE NO    *
.*             MEANING. FSTCHAR/OTHCHAR PARAMETERS ARE IGNORED.'   @H2A
.*                                                                    *
.*   INFORMATIONAL MNOTES = MISCELLANEOUS                             *
.*    MNOTE 4,'HIGH/LOW INVALID WITH CONVERT=&CONVERT.  HIGH/LOW      *
.*             PARAMETER IGNORED'                                     *
.*    MNOTE 4,'CONLEN NOT REQUIRED WITH CONVERT=&CONVERT. CONLEN      *
.*             PARAMETER SET TO MAXLEN KEYWORD PARAMETER.'         @R4A
.*    MNOTE 4,'KEYDFLT NOT REQUIRED WITH CONVERT=&CONVERT'         @R7A
.*                                                                    *
.*   ERROR MNOTES = CONVERT=CHAR                                      *
.*    MNOTE 12,'MAXLEN=&MAXLEN INVALID. MUST BE 1 TO 64 DECIMAL'   @H1C
.*    MNOTE 12,'MINLEN=&MINLEN INVALID. MUST BE 1 TO 64 DECIMAL'   @H1A
.*    MNOTE 12,'LEVNUM=&LEVNUM INVALID. MUST BE 1 TO 31 DECIMAL'   @H1A
.*    MNOTE 12,'LEVLEN=&LEVLEN INVALID. MUST BE 1 TO 64 DECIMAL'   @H1A
.*    MNOTE 12,'FSTCHAR=&FSTCHAR HAS AN INVALID NUMBER OF SUBPARA-    *
.*              METERS. ONLY 1 TO 4 ALLOWED.'                      @H3C
.*    MNOTE 12,'FSTCHAR=&FSTCHAR HAS INVALID SUBPARAMETERS. MUST BE   *
.*              ALL, ALPHABETIC, NUMERIC, NATIONAL, OR SPECIAL.'   @H3C
.*    MNOTE 12,'FSTCHAR=ALL IS NOT ALLOWED WITH ALPHABETIC, NUMERIC,  *
.*              NATIONAL, OR SPECIAL.'                             @H3C
.*    MNOTE 12,'EXPECTED SPECIAL CHARACTERS WERE NOT SPECIFIED FOR    *
.*              FSTCHAR=SPECIAL.'                                  @H3A
.*    MNOTE 12,'FSTSPEC SPECIFIES MORE PARAMETERS THAN THE MAXIMUM    *
.*              OF 16 ALLOWED.                                     @H3A
.*    MNOTE 12,'PARAMETER ''&FSTSPEC(&CTR)'' SPECIFIES MORE THAN      *
.*              THE ONE CHARACTER ALLOWED.'                        @H3A
.*    MNOTE 12,'OTHCHAR=&OTHCHAR HAS AN INVALID NUMBER OF SUBPARA-    *
.*              METERS. ONLY 1 TO 4 ALLOWED.'                      @H3C
.*    MNOTE 12,'OTHCHAR=&OTHCHAR HAS INVALID SUBPARAMETERS. MUST BE   *
.*              ALL, ALPHABETIC, NUMERIC, NATIONAL, OR SPECIAL.'   @H3C
.*    MNOTE 12,'OTHCHAR=ALL IS NOT ALLOWED WITH ALPHABETIC, NUMERIC,  *
.*              NATIONAL, OR SPECIAL.'                             @H3C
.*    MNOTE 12,'EXPECTED SPECIAL CHARACTERS WERE NOT SPECIFIED FOR    *
.*              OTHCHAR=SPECIAL.'                                  @H3A
.*    MNOTE 12,'OTHSPEC SPECIFIES MORE PARAMETERS THAN THE MAXIMUM    *
.*              OF 16 ALLOWED.                                     @H3A
.*    MNOTE 12,'PARAMETER ''&OTHSPEC(&CTR)'' SPECIFIES MORE THAN      *
.*              THE ONE CHARACTER ALLOWED.'                        @H3A
.*                                                                    *
.*   ERROR MNOTES = CONVERT=HEX                                       *
.*    MNOTE 12,'MAXLEN=&MAXLEN INVALID. MUST BE 1 TO 8 DECIMAL'    @H1A
.*    MNOTE 12,'MINLEN=&MINLEN INVALID. MUST BE 1 TO 8 DECIMAL'    @H1A
.*    MNOTE 12,'LOW=&LOW INVALID. MUST BE 0 TO 7FFFFFFF HEX'       @H1A
.*    MNOTE 12,'HIGH=&HIGH INVALID. MUST BE 0 TO 7FFFFFFF HEX'     @H1A
.*    MNOTE 12,'HIGH=&HHGH OR LOW=&HLOW INVALID. HIGH MUST BE GREATER *
.*             THAN OR EQUAL TO LOW VALUE.'                        @H1A
.*                                                                    *
.*   ERROR MNOTES = CONVERT=CHOICE                                    *
.*    MNOTE 12,'&CHOICE# VALUE NOT TWO HEX DIGITS'                    *
.*    MNOTE 12,'TWO SUBPARAMETERS EXPECTED WITH &CHOICE#: &NUM FOUND' *
.*    MNOTE 12,'CONVERT=CHOICE SPECIFIED BUT NO CHOICE OPTIONS        *
.*             SPECIFIED.'                                            *
.*    MNOTE 12,'KEY NOT SPECIFIED. DEFAULT KEY IGNORED'               *
.*    MNOTE 12,'&CHOICE# SPECIFIES INVALID CHARACTERS'             @R6A
.*    MNOTE 12,'&CHOICE# SPECIFICATION EXCEEDS 8 CHARACTERS'       @R6A
.*    MNOTE 12,'KEYDFLT=&KEYDFLT INVALID.  MUST BE TWO HEX DIGITS.'   *
.*                                                                    *
.*   ERROR MNOTES = CONVERT=INTEGER                                   *
.*    MNOTE 12,'MAXLEN=&MAXLEN INVALID. MUST BE 1 TO 10 DECIMAL'   @H1C
.*    MNOTE 12,'MINLEN=&MINLEN INVALID. MUST BE 1 TO 10 DECIMAL'   @H1A
.*    MNOTE 12,'MAXLEN=&MXLTH OR MINLEN=&MNLTH INVALID. MAXLEN MUST   *
.*             BE GREATER THAN OR EQUAL TO MINLEN'                 @H1A
.*    MNOTE 12,'HIGH=&PHGH OR LOW=&PLOW INVALID. HIGH MUST BE GREATER *
.*             THAN OR EQUAL TO LOW VALUE'                            *
.*                                                                    *
.*   ERROR MNOTES = CONVERT=REFERRAL                                  *
.*    MNOTE 12,'CONVERT=REFERRAL FOR  JDPARM MACRO,  BUT NOT JDKEY.   *
.*              JDKEY MUST BE REFERRAL OR JDPARM MUST NOT BE.'     @H2A
.*                                                                    *
.*   ERROR MNOTES = MISCELLANEOUS                                     *
.*    MNOTE 12,'KEY=&KEY INVALID. MUST BE 4 HEX DIGITS.'              *
.*    MNOTE 12,'THE KEY= PARAMETER IS REQUIRED BUT IS NOT SPECIFIED'  *
.*    MNOTE 12,'CONLEN=&CONLEN INVALID. MUST BE 1 TO 4 DECIMAL.'      *
.*    MNOTE 12,'JDPARM MACRO SPECIFIED OUT OF ORDER'                  *
.*    MNOTE 12,'CONVERT=&CONVERT INVALID. CONVERT=CHAR ASSUMED'       *
.*    MNOTE 12,'REQUIRED MAXLEN PARAMETER IS NOT SPECIFIED'        @H1C
.*    MNOTE 12,'REPEAT=&REPEAT INVALID.  MUST BE 0 TO 127 DECIMAL.'   *
.*    MNOTE 12,'JDPARM MACRO SPECIFIED MORE THAN ONCE FOR LIST        *
.*              ITEMS, THE USE OF THE REPEAT KEYWORD IS REQUIRED      *
.*              FOR DUPLICATION OF THE LIST ITEM SPECIFICATIONS.'  @H3A
.*                                                                    *
.*    MNOTE 16,'JDTMAC MACRO MUST BE FIRST MACRO SPECIFIED BUT IS NOT'*
.*    MNOTE 16,'CONVERT=&CONVERT INCONSISTENT WITH  JDKEY REFERRAL.   *
.*              JDPARM MUST BE REFERRAL OR JDKEY MUST NOT BE.'     @H2A
.*                                                                    *
.*   CHANGE ACTIVITY = H0,R1,R2,R3,R4,R5,R6,R7,R8,R9,RA,H1,H2,RB,  @RBA
.*                     H3                                          @H3A
.* $H0= EXTJCL  JBB1328 810315 PDC5: SUPPORT FOR EXTENDED JCL         *
.* $R1= PPP0007 JBB1328 810508 PDC5: REPEAT ERROR CONTINUATION     @R1A
.* $R2= PPP0008 JBB1328 810508 PDC5: TWO MNOTES FOR ONE ERROR      @R2A
.* $R3= PPP0009 JBB1328 810508 PDC5: MISSING EXPECTED MNOTE        @R3A
.* $R4= PPP0014 JBB1328 810508 PDC5: CONLEN= ERROR MNOTE CHANGES   @R4A
.* $R5= PPP0016 JBB1328 810508 PDC5: MISSING EXPECTED MNOTE        @R5A
.* $R6= PPP0017 JBB1328 810508 PDC5: MISSING EXPECTED MNOTE        @R6A
.* $R7= PPP0020 JBB1328 810508 PDC5: KEYDFLT= INCORRECT PROCESSING @R7A
.* $R8= PPP0028 JBB1328 810508 PDC5: MISSING EXPECTED MNOTE        @R8A
.* $R9= PPP0029 JBB1328 810508 PDC5: WRONG MNOTE ISSUED            @R9A
.* $RA= PPP0030 JBB1328 810508 PDC5: UNEXPECTED ASSEMBLER ERROR    @RAA
.* $H1= EXTJCL  JBB1328 811204 PDC5: SUPPORT FOR EXTENDED JCL      @H1A
.* $H2= EXTJCL  JBB1328 820330 PDC5: SUPPORT FOR EXTENDED JCL      @H2A
.* $RB= PPP0101 JBB1328 820521 PDC5: POSSIBLE ALIGNMENT ERROR      @RBA
.* $H3= EXTJCL  JBB1329 820611 PDC5: SUPPORT FOR EXTENDED JCL      @H3A
.*                                                                    *
.**********************************************************************
.* A 000000-999999                                                 @H0A
.* A REPEAT WAS DUPLICATING MNOTES WHEN THE PROCESSING SHOULD STOP @R1A
.* A GETTING TWO MNOTES FOR ONE ERROR ON CHOICE#= PARAMETER        @R2A
.* A NO MNOTE WAS RECEIVED FOR A BLANK SYMBOL ON CHOICE PARAMETER  @R3A
.* A MNOTE ADDED AND ANOTHER ONE CHANGED TO SUPPORT CONLEN= ERROR  @R4A
.* A NO MNOTE RECEIVED WHEN CHOICE KEYWORD SPECIFIED ON CONVERT=CHAR
.*   OR ON CONVERT=INTEGER.                                        @R5A
.* A NO MNOTE RECEIVED WHEN CHOICE SYMBOL IS SPECIFIED INCORRECTLY @R6A
.* A KEYDFLT= PARAMETER WAS NOT BEING IGNORED ON CONVERT=CHAR      @R7A
.* A NO MNOTE FOR KEYDFLT= PARAMETER WHEN NON-HEX DIGITS SPECIFIED @R8A
.* A MNOTE FOR KEY= WAS REALLY A KEYDFLT ERROR. BRANCH FROM AND TO
.*   LABEL WAS MISSPELLED.                                         @R9A
.* A WHEN KEY= KEYWORD PARAMETER IS INCORRECTLY SPECIFIED AND KEYDFLT=
.*   KEYWORD IS NOT SPECIFIED, KEY= GIVES THE CORRECT MNOTE, BUT AN
.*   AN ASSEMBLER ERROR IS ALSO GIVEN BECAUSE KEYDFLT WAS SET TO NULLS
.*   INSTEAD OF ZEROES.                                            @RAA
.* A HEX CONVERSION SUPPORT AND MINLEN= KEYWORD                    @H1A
.* A AUTOMATIC BYTE OFFSET CALCULATIONS AND BLOCK IDENTIFICATION   @H1A
.* D KEYWORD &BYTEOFF DUE TO AUTOMATIC PROCESSING                  @H1A
.* A NAME CONVERSION AND ITS ASSOCIATED KEYWORDS: LEVNUM & LEVLEN  @H1A
.* C LENGTH= KEYWORD TO MAXLEN= KEYWORD TO GO WITH MINLEN= KEYWORD @H1A
.* D NAME CONVERSION                                               @H2A
.* A REFERRAL CONVERSION AND GENERALIZED CONVERSION RULES CHECKING @H2A
.* A KEYWORDS--FSTCHAR= AND OTHCHAR= AS PART OF THE RULES CHECKING @H2A
.*   SUCH AS FOR TYPES-ALPHABETIC, NUMERIC, AND NATIONAL CHARS.    @H2A
.* D FULLWORD ALIGNMENT BOUNDARY OF DS 0F FROM DEFINITION.         @RBA
.* A GLOBAL BITS TO INDICATE THIS PARAMETER IS A LIST ITEM--EITHER @H3A
.*   FOR PARAMETERS (BIT SET IN JDKEY) OR SUBLISTS (SET IN JDSUB). @H3A
.* A SPECIAL CHARACTER CHECKING FOR CONVERT=CHAR.                  @H3A
.***-----------------------------------------------------------***
.***-----------------------------------------------------------***
.***     LOCAL AND GLOBAL VARIABLES USED IN THIS MACRO.        ***
.***-----------------------------------------------------------***
         LCLA  &LVNUM,&LVLEN        CONVERSION VARIABLES           @H1A
         LCLA  &MXLTH,&MNLTH,&CLEN  WORKING VARIABLES FOR MAXLEN,  @H1C
.*                            MINLEN, AND CONVERTED LENGTH OPTION  @H1C
.*---------------------------------------------------------------* @R6A
.*   GLOBALS USED FOR ERROR INDICATORS RETURNED FROM INTERNAL    * @R6A
.*   MACRO JDSCAN.                                               * @R6A
.*   &$ERRBAD IS THE INVALID CHARACTER ERROR BIT.                * @R6A
.*   &$ERRBIG IS THE GREATER THAN 8 CHARACTERS ERROR BIT.        * @R6A
.*---------------------------------------------------------------* @R6A
         GBLB  &$ERRBAD,&$ERRBIG                                   @R6A
.*---------------------------------------------------------------*
.*       LOCAL NUMERIC VARIABLES USED:                           *
.*       DKEY=KEY DKY=KEYDFLT                                    *
.*       PHGH=HIGH PLOW=LOW    FOR INTEGER CONVERSION            *
.*       HHGH=HIGH HLOW=LOW    FOR HEX CONVERSION                * @H1A
.*       THE FLAG BITS ARE: &D0 IS FOR DEFAULT                   *
.*                          &F# ARE FOR CONVERSION INDICATORS    *
.*                          F0=CHOICE; F1=CHAR; F2=INTEGER;      *
.*                          F3=HEX; F4=REFERRAL                  * @H2A
.*                          &S# ARE FOR SUBLIST INDICATORS       *
.*                          S0=SUBLIST DEFINED; S1=FIRST ELEMENT * @H1A
.*---------------------------------------------------------------*
         LCLB  &D0,&F0,&F1,&F2,&F3,&F4,&S0,&S1 FLAG BITS USED      @H1C
         LCLA  &PHGH,&PLOW       VARIABLES FOR HIGH AND LOW-INTEGER
         LCLC  &HHGH,&HLOW       VARIABLES FOR HIGH AND LOW-HEX    @H1A
         LCLC  &DKEY,&DKY        VARIABLES FOR KEY AND KEYDFLT
.*---------------------------------------------------------------* @H2A
.*       LOCAL VARIABLES USED FOR KEYWORDS->FSTCHAR AND OTHCHAR: * @H2A
.*       THE FLAG BITS ARE: C0 & O0 = ALL                        * @H2A
.*          FSTCHAR=C#      C1 & O1 = ALPHABETIC                 * @H2A
.*          OTHCHAR=O#      C2 & O2 = NUMERIC                    * @H2A
.*                          C3 & O3 = NATIONAL                   * @H2A
.*                          C4 & O4 = SPECIAL                    * @H3A
.*       &SUB CAN HOLD A MAXIMUM OF FOUR OF THESE WITH 'ALL'     * @H3C
.*            BEING MUTUALLY EXCLUSIVE.                          * @H3A
.*---------------------------------------------------------------* @H2A
         LCLB  &C0,&C1,&C2,&C3,&C4,&O0,&O1,&O2,&O3,&O4             @H3A
         LCLC  &SUB(4)           SUBLIST TO HOLD THE SELECTIONS    @H3C
.*---------------------------------------------------------------* @H3A
.*       VARIABLES USED WITH SPECIAL CHARACTER PROCESSING.       * @H3A
.*---------------------------------------------------------------* @H3A
         LCLA  &FPAD,&OPAD       KEEPS NUMBER OF PADDING ZEROES    @H3A
         LCLA  &#FSPEC,&#OSPEC   KEEPS COUNT OF PARAMETERS         @H3A
         LCLC  &FALL,&OALL       CONCATENATES THE SPECIAL CHARS    @H3A
.*---------------------------------------------------------------*
.*       LOCAL MISCELLANEOUS VARIABLES USED.                     *
.*---------------------------------------------------------------*
         LCLA  &CTR              VARIABLE COUNTER
         LCLA  &COUNT            USED FOR REPEAT FUNCTION
         LCLB  &REPSW            REPEAT BIT SWITCH FOR REPEAT OPTION
         LCLB  &ERRSW           ERROR SWITCH FOR CHOICE PROCESSING @R2A
         LCLB  &STOP             STOPS THE REPEAT PROCESSING TO    @R1A
.*                               ELIMINATE REDUNDANT MNOTES.       @R1A
.*---------------------------------------------------------------*
.*   CHOICE VARIABLES USED IN MACRO; &CHOICE# = MNOTE IDENTIFIER *
.*   &CH# = THE CHOICE; &VAL# = THE VALUE OF THE CHOICE          *
.*---------------------------------------------------------------*
         LCLA  &NUM             VARIABLE NUMBER HOLDER
         LCLC  &CHOICE#         HOLD THE CURRENT CHOICE BEING WORKED ON
         LCLC  &CH1,&CH2,&CH3,&CH4,&CH5,&CH6,&CH7,&CH8
         LCLC  &VAL1,&VAL2,&VAL3,&VAL4,&VAL5,&VAL6,&VAL7,&VAL8
.*---------------------------------------------------------------* @H1A
.*   GLOBAL DEFINITIONS                                          * @H1A
.*   &BYTEOFF AND &BLKID ARE USED BY JDVERB MACRO.               * @H1A
.*   &R1 BIT IS SET BY THE JDKEY MACRO--                         * @H2A
.*       INDICATES REFERRAL PROCESSING.                          * @H2A
.*   &L2 BIT IS SET BY THE JDKEY MACRO--                         * @H3A
.*       INDICATES LIST ITEM PARAMETERS.                         * @H3A
.*   &L3 BIT IS SET BY THE JDSUB MACRO--                         * @H3A
.*       INDICATES SUBLIST ELEMENT LIST ITEMS.                   * @H3A
.*---------------------------------------------------------------* @H1A
         GBLA  &BYTEOFF,&BLKID                                     @H1A
         GBLA  &BYTECTR          KEEPS TRACK OF BYTES USED IN SWB  @H1A
         GBLB  &R1               REFERRAL BIT FROM JDKEY MACRO     @H2A
         GBLB  &L2,&L3           LIST ITEM BIT FROM JDKEY OR JDSUB @H3A
.*---------------------------------------------------------------*
.*   GLOBALS USED BY ALL JDT MACROS                              *
.*   &LEN IS USED ON EQUATES TO DETERMINE THE LENGTH OF          *
.*     THE MACRO.                                                *
.*   &P1 AND &P2 ARE USED FOR PARAMETER COUNTERS.                *
.*   &P1 FOR IDENTIFYING THIS PARAMETER SECTION;                 *
.*   &P2 FOR IDENTIFYING NEXT PARAMETER SECTION;                 *
.*---------------------------------------------------------------*
         GBLA  &LEN,&P1,&P2
.*---------------------------------------------------------------*
.*   GLOBALS THAT MAY BE ACTIVE OR BE MADE ACTIVE IN THIS MACRO; *
.*   RESPECTIVELY: JDKEY, JDPARM, JDSUB, ENDSUB, JDVERB, ENDJDT, *
.*   AND JDTMAC.                                                 *
.*---------------------------------------------------------------*
         GBLB  &KACT,&PACT,&SPACT,&EPACT,&VACT,&EJACT,&JACT
.*---------------------------------------------------------------*
.*   THE ACTR IS SET UP TO HANDLE THE REPEAT FUNCTION. THE       *
.*   ASSEMBLER DEFAULT IS 4K BYTES. THE ACTR COUNTS THE NUMBER   *
.*   OF TIMES AIF'S AND AGO'S ARE USED. IN THIS MACRO THERE ARE  *
.*   APPROXIMATELY 300 OF THEM, SO ONLY ABOUT 13 PASSES ARE      *
.*   ALLOWED. WHAT IS NEEDED IS 300 TIMES THE NUMBER OF THE      *
.*   REPEAT FUNCTION (300 X N).                                  *
.*---------------------------------------------------------------*
.SETACTR ANOP
         ACTR  300*(&REPEAT+1)   PLUS ONE IN CASE REPEAT IS ZERO
.*---------------------------------------------------------------* @H3A
.*   THE FOLLOWING TEST IMPLICITLY CHECKS WHETHER OR NOT THE     * @H3A
.*   REPEAT KEYWORD WAS SPECIFIED. IF NEITHER LIST ITEM BIT ARE  * @H3A
.*   ON, THEN CONTINUE WITH MACRO. IF EITHER ONE IS ON (ONLY     * @H3A
.*   ONE CAN BE ON), THEN MAKE SURE MACRO DID NOT FOLLOW         * @H3A
.*   ANOTHER JDPARM MACRO. ONCE IN REPEAT MODE, THIS CODE WILL   * @H3A
.*   NOT BE EXECUTED AGAIN FOR THIS JDPARM MACRO INVOCATION.     * @H3A
.*---------------------------------------------------------------* @H3A
         AIF   (NOT &L2 AND NOT &L3).REPEAT                        @H3A
         AIF   (NOT &PACT).REPEAT                                  @H3A
.*---------------------------------------------------------------* @H3A
.*   LIST ITEMS WANTED, BUT ANOTHER JDPARM MACRO HAS BEEN        * @H3A
.*   INVOKED. THE REPEAT KEYWORD MUST BE USED FOR DUPLICATION    * @H3A
.*   OF LIST ITEMS-> MNOTE IT.                                   * @H3A
.*---------------------------------------------------------------* @H3A
       MNOTE 12,'JDPARM MACRO SPECIFIED MORE THAN ONCE FOR LIST ITEMS. +
                THE  USE OF THE  REPEAT  KEYWORD  IS REQUIRED FOR DUPLI+
               CATION OF THE LIST ITEM SPECIFICATIONS.'            @H3A
         AGO   .NOREP                                              @H3A
.*---------------------------------------------------------------*
.*   CHECK THAT THE JDPARM MACRO FOLLOWS THE CORRECT MACRO.      *
.*   THAT IS DONE BY CHECKING THE ACTIVE GLOBAL BIT.             *
.*   THE ONLY MACROS THAT ARE ALLOWED ARE: JDKEY, JDPARM, JDSUB, *
.*   ENDSUB, AND JDPARM DEFINED AS A SUBLIST.                    *
.*---------------------------------------------------------------*
.REPEAT  ANOP                    REPEAT FUNCTION RETURNS TO HERE
         AIF   (&KACT EQ 1).KEYACT   JDKEY ACTIVE; GO RESET KACT BIT
         AIF   (&PACT EQ 1 AND &SPACT EQ 1).SUBACT SUBLIST ACTIVE
         AIF   (&PACT EQ 1).CONT     JDPARM ACTIVE
         AIF   (&SPACT EQ 1).SPACT   JDSUB ACTIVE; GO SET SUBLIST BITS
         AIF   (&EPACT EQ 1).EPACT   ENDSUB ACTIVE; GO RESET EPACT BIT
.*---------------------------------------------------------------*
.*       CHECK TO SEE IF ANY OTHER MACROS HAVE BEEN INVOKED.     *
.*---------------------------------------------------------------*
         AIF   (&JACT EQ 0 AND &VACT EQ 0 AND &EJACT EQ 0).NOJDT
.*---------------------------------------------------------------*
.*   NONE OF THE CORRECT MACROS USED-> MNOTE IT.                 *
.*---------------------------------------------------------------*
         MNOTE 12,'JDPARM MACRO SPECIFIED OUT OF ORDER'
         AGO   .RESET
.*---------------------------------------------------------------*
.*   IF NO PREVIOUS JDT MACRO HAS BEEN INVOKED, THEN THIS MUST   *
.*   BE THE FIRST ONE. JDTMAC MACRO MUST BE FIRST-> MNOTE IT.    *
.*---------------------------------------------------------------*
.NOJDT   ANOP
       MNOTE 16,'JDTMAC MACRO MUST BE FIRST MACRO SPECIFIED BUT IS NOT'
         MEXIT
.*---------------------------------------------------------------*
.*   RESET APPROPRIATE GLOBAL BIT.                               *
.*---------------------------------------------------------------*
.RESET   ANOP
&JACT    SETB  0                 RESET THE JDTMAC GLOBAL ACTIVE BIT
&VACT    SETB  0                 RESET THE JDVERB GLOBAL ACTIVE BIT
&EJACT   SETB  0                 RESET THE ENDJDT GLOBAL ACTIVE BIT
         AGO   .CONT
.*---------------------------------------------------------------*
.*   SET OR RESET APPROPRIATE GLOBAL BITS                        *
.*---------------------------------------------------------------*
.KEYACT  ANOP
&KACT    SETB  0                 RESET JDKEY GLOBAL BIT
         AGO   .CONT             CONTINUE JDPARM MACRO DEFINITION
.SUBACT  ANOP
&S0      SETB  1                 SET SUBLIST DATA FLAG BIT
&S1      SETB  0       RESET THIS-IS-FIRST ELEMENT OF SUBLIST BIT
         AGO   .CONT             CONTINUE JDPARM MACRO DEFINITION
.SPACT   ANOP
&S0      SETB  1                 SET SUBLIST DATA FLAG BIT
&S1      SETB  1         SET THIS-IS-FIRST ELEMENT OF SUBLIST BIT
         AGO   .CONT             CONTINUE JDPARM MACRO DEFINITION
.EPACT   ANOP
&EPACT   SETB  0                 RESET ENDSUB GLOBAL BIT
.*---------------------------------------------------------------*
.*   .CONT LABEL IS ENTERED FROM CONTINUATION OF THE PREVIOUS    *
.*   CODE OR FROM THE REQUEST OF THE REPEAT KEYWORD FUNCTION.    *
.*---------------------------------------------------------------*
.CONT    ANOP
&PACT    SETB  1                 SET JDPARM GLOBAL BIT
&P1      SETA  &P1+1             UPDATE GLOBAL FOR NEXT PARM OFFSET
&P2      SETA  &P2+1             UPDATE GLOBAL FOR NEXT PARM OFFSET
&LEN     SETA  &LEN+1            LENGTH SETUP UPDATED OF MACRO OFFSET
.*---------------------------------------------------------------* @H2A
.*    CHECK FOR GLOBAL REFERRAL BIT FROM KEYWORD DEFINITION      * @H2A
.*    AND REFERRAL CONVERSION OF THIS MACRO. BOTH MUST BE        * @H2A
.*    DEFINED OR BOTH MUST NOT BE DEFINED.                       * @H2A
.*---------------------------------------------------------------* @H2A
         AIF   (&R1     AND '&CONVERT' NE 'REFERRAL').RFNOTE1      @H2A
         AIF   (NOT &R1 AND '&CONVERT' EQ 'REFERRAL').RFNOTE2      @H2A
         AGO   .BEGIN            BOTH ARE ON OR BOTH ARE OFF       @H2A
.*---------------------------------------------------------------* @H2A
.*    REFERRAL IN JDKEY SPECIFIED, BUT NOT JDPARM-> MNOTE IT.    * @H2A
.*    NO FURTHER PROCESSING WOULD BE MEANINGFUL, AS JDPARM IS    * @H2A
.*    BEING INVOKED FOR THE WRONG TYPE OF CONVERSION.            * @H2A
.*---------------------------------------------------------------* @H2A
.RFNOTE1 ANOP                                                      @H2A
         MNOTE 16,'CONVERT=&CONVERT INCONSISTENT WITH  JDKEY REFERRAL. +
               JDPARM MUST BE REFERRAL OR JDKEY MUST NOT BE.'      @H2A
         AGO   .BEGIN                                              @H2A
.*---------------------------------------------------------------* @H2A
.*    REFERRAL IN JDPARM SPECIFIED, BUT NOT JDKEY-> MNOTE IT.    * @H2A
.*    FURTHER PROCESSING MAY BE ATTEMPTED-JDKEY MAY HAVE BEEN    * @H2A
.*    INVOKED WITHOUT REFERRAL BEING SELECTED.                   * @H2A
.*---------------------------------------------------------------* @H2A
.RFNOTE2 ANOP                                                      @H2A
           MNOTE 12,'CONVERT=REFERRAL FOR JDPARM MACRO, BUT NOT JDKEY. +
               JDKEY MUST BE REFERRAL OR JDPARM MUST NOT BE.'      @H2A
&STOP    SETB  1                                                   @H2A
.*---------------------------------------------------------------*
.*       BEGIN JDPARM DEFINITIONS                                *
.*---------------------------------------------------------------*
.BEGIN   ANOP                                                      @H2A
B&LEN    EQU   *                 BEGIN JDPARM LENGTH DEFINITION
PM&P1    DC    AL2(E&LEN-B&LEN)  LENGTH OF PARAMETER SECTION
         DC    AL2(PM&P2-PM&P1)  OFFSET TO NEXT PARAMETER(ZERO IF NONE)
.*---------------------------------------------------------------*
.*       CHECK FOR TYPE OF CONVERSION DESIRED.                   *
.*---------------------------------------------------------------*
         AIF   ('&CONVERT' EQ 'CHAR').CHAR        CONVERT=CHAR
         AIF   ('&CONVERT' EQ 'HEX').HEX          CONVERT=HEX      @H1A
         AIF   ('&CONVERT' EQ 'CHOICE').CHOICE    CONVERT=CHOICE
         AIF   ('&CONVERT' EQ 'INTEGER').INTEGER  CONVERT=INTEGER
         AIF   ('&CONVERT' EQ 'REFERRAL').REFERRL CONVERT=REFERRAL @H2A
.*---------------------------------------------------------------*
.*   REFERRAL, HEX, CHOICE, INTEGER, OR CHAR OPTION NOT CHOOSEN->* @H2C
.*   MNOTE IT.                                                   *
.*---------------------------------------------------------------*
         MNOTE 12,'CONVERT=&CONVERT INVALID. CONVERT=CHAR ASSUMED'
&STOP    SETB  1                                                   @R1A
.*---------------------------------------------------------------* @H1A
.*      CONVERT=CHAR ROUTINE.                                    * @H2C
.*---------------------------------------------------------------* @H1A
.CHAR    ANOP                                                      @H2C
&F1      SETB   1                                                  @H2C
.*---------------------------------------------------------------* @H1A
.*  MAKE SURE NO CHOICES WERE SPECIFIED FOR CHARACTER CONVERSION.* @H2C
.*---------------------------------------------------------------* @H1A
  AIF ('&CHOICE1' EQ '' AND '&CHOICE2' EQ '' AND '&CHOICE3' EQ '' AND '+
               &CHOICE4' EQ '' AND '&CHOICE5' EQ '' AND '&CHOICE6' EQ '+
               ' AND '&CHOICE7' EQ '' AND '&CHOICE8' EQ '').FSTCHR @H2C
.*---------------------------------------------------------------* @H1A
.*   CHOICE#= WAS SPECIFIED WITH CONVERT=CHAR-> MNOTE IT.        * @H2C
.*---------------------------------------------------------------* @H1A
            MNOTE 4,'CHOICE KEYWORDS FOR CONVERT=CHAR HAVE NO MEANING. +
               CHOICE PARAMETERS ARE IGNORED'                      @H1A
.*---------------------------------------------------------------* @H2A
.*       FSTCHAR KEYWORD ROUTINE.                                * @H2A
.*  IF FSTCHAR WAS NOT SPECIFIED, THEN THE DEFAULT IS 'ALL'.     * @H2A
.*---------------------------------------------------------------* @H2A
.FSTCHR  ANOP                                                      @H2A
         AIF   ('&FSTCHAR' NE '').FSTCNT                           @H2A
&C0      SETB  1                 THIS IS THE 'ALL' DEFAULT BIT     @H2A
         AGO   .OTHCHAR          GO TEST FOR OTHCHAR KEYWORD       @H2A
.*---------------------------------------------------------------* @H2A
.*  GET THE NUMBER OF SUBPARAMETERS SUPPLIED (N'FSTCHAR).        * @H2A
.*---------------------------------------------------------------* @H2A
.FSTCNT  ANOP                                                      @H2A
&CTR     SETA  1                 START INDEX COUNTER               @H2A
&NUM     SETA  N'&FSTCHAR        MUST BE 1 TO 4                    @H3C
         AIF   (&NUM GE 1 AND &NUM LE 4).FSTLOOP                   @H3C
.*---------------------------------------------------------------* @H2A
.*     FSTCHAR DOES NOT HAVE 1 TO 4 SUBPARAMETERS-> MNOTE IT.    * @H3C
.*---------------------------------------------------------------* @H2A
         MNOTE 12,'FSTCHAR=&FSTCHAR HAS AN INVALID NUMBER OF SUBPARAMET+
               ERS. ONLY 1 TO 4 ALLOWED.'                          @H3C
&STOP    SETB  1                                                   @H2A
         AGO   .OTHCHAR          GO CHECK OTHCHAR KEYWORD          @H2A
.*---------------------------------------------------------------* @H2A
.*       FSTCHAR-SAVE EACH SUBPARAMETER SPECIFIED.               * @H2A
.*---------------------------------------------------------------* @H2A
.FSTLOOP ANOP                                                      @H2A
&SUB(&CTR) SETC '&FSTCHAR(&CTR)' GET EACH SUBPARAMETER             @H2A
         AIF    (&CTR EQ &NUM).FSTCONT                             @H2A
&CTR     SETA   &CTR+1           SET UP FOR NEXT SUBPARAMETER      @H2A
         AGO    .FSTLOOP         GO SAVE NEXT SUBPARAMETER         @H2A
.*---------------------------------------------------------------* @H2A
.*    CHECK EACH SAVED SUBPARAMETER FOR VALUE AND EXCLUSIVITY    * @H2A
.*    WITH ITSELF.                                               * @H2A
.*---------------------------------------------------------------* @H2A
.FSTCONT ANOP                                                      @H2A
         AIF   ('&SUB(&CTR)' EQ 'ALL' OR '&SUB(&CTR)' EQ 'ALPHABETIC'  +
               OR '&SUB(&CTR)' EQ 'NUMERIC' OR '&SUB(&CTR)' EQ         +
               'NATIONAL' OR '&SUB(&CTR)' EQ 'SPECIAL').TESTC0     @H3A
.*---------------------------------------------------------------* @H2A
.*   FSTCHAR HAS INVALID SUBPARAMETERS-> MNOTE IT.               * @H2A
.*---------------------------------------------------------------* @H2A
         MNOTE 12,'FSTCHAR=&FSTCHAR HAS INVALID SUBPARAMETERS. MUST BE +
               ALL, ALPHABETIC, NUMERIC, NATIONAL, OR SPECIAL.'    @H3A
&STOP    SETB  1                                                   @H2A
&C0      SETB  0                 ALL                               @H2A
&C1      SETB  0                 ALPHABETIC                        @H2A
&C2      SETB  0                 NUMERIC                           @H2A
&C3      SETB  0                 NATIONAL                          @H2A
&C4      SETB  0                 SPECIAL                           @H3A
         AGO   .OTHCHAR          GO TEST 'OTHER' KEYWORD           @H2A
.TESTC0  AIF   ('&SUB(&CTR)' NE 'ALL').TESTC1                      @H2A
         AIF   (&C0).FEXCLUD     HAS 'ALL' BEEN PREVIOUSLY SET?    @H2A
&C0      SETB  1                                                   @H2A
         AGO   .FUPCTR                                             @H2A
.TESTC1  AIF   ('&SUB(&CTR)' NE 'ALPHABETIC').TESTC2               @H2A
         AIF   (&C1).FEXCLUD     HAS ALPHA BEEN PREVIOUSLY SET?    @H2A
&C1      SETB  1                                                   @H2A
         AGO   .FUPCTR                                             @H2A
.TESTC2  AIF   ('&SUB(&CTR)' NE 'NUMERIC').TESTC3                  @H2A
         AIF   (&C2).FEXCLUD     HAS NUM BEEN PREVIOUSLY SET?      @H2A
&C2      SETB  1                                                   @H2A
         AGO   .FUPCTR                                             @H2A
.TESTC3  AIF   ('&SUB(&CTR)' NE 'NATIONAL').TESTC4                 @H3A
         AIF   (&C3).FEXCLUD     HAS NAT'L BEEN PREVIOUSLY SET?    @H3C
&C3      SETB  1                                                   @H2A
         AGO   .FUPCTR                                             @H3A
.TESTC4  AIF   (&C4).FEXCLUD     HAS SPECIAL BEEN PREVIOUSLY SET?  @H3A
&C4      SETB  1                                                   @H3A
.FUPCTR  ANOP                                                      @H2A
         AIF   (&CTR EQ 1).FSTTEST                                 @H2A
&CTR     SETA  &CTR-1            SET UP FOR NEXT SUBPARAMETER      @H2A
         AGO   .FSTCONT          DO NEXT SUBPARAMETER CHECKING     @H2A
.*---------------------------------------------------------------* @H2A
.*   A SUBPARAMETER HAS BEEN SPECIFIED MORE THAN ONCE-> MNOTE IT.* @H2A
.*---------------------------------------------------------------* @H2A
.FEXCLUD ANOP                                                      @H2A
     MNOTE 4,'FSTCHAR KEYWORD HAS MULTIPLE DEFINED SUBPARAMETERS.' @H2A
         AIF   (&CTR EQ 1).FSTTEST                                 @H2A
&CTR     SETA  &CTR-1            SET UP FOR NEXT SUBPARAMETER      @H2A
         AGO   .FSTCONT          DO NEXT SUBPARAMETER CHECKING     @H2A
.*---------------------------------------------------------------* @H2A
.*   TEST FOR EXCLUSIVITY AGAINST 'ALL' AND THE REST.            * @H2A
.*---------------------------------------------------------------* @H2A
.FSTTEST ANOP                                                      @H2A
         AIF   (&C0 EQ 0).FSTSPEC   'ALL' BIT OFF?                 @H3C
         AIF   (&C1 OR &C2 OR &C3 OR &C4).FEXERR   ERROR IF OTHERS @H3A
         AGO   .OTHCHAR             ONLY 'ALL' WAS ON--OKAY        @H2A
.*---------------------------------------------------------------* @H2A
.*     'ALL' EXCLUSIVITY TEST FAILED-> MNOTE IT.                 * @H2A
.*---------------------------------------------------------------* @H2A
.FEXERR  ANOP                                                      @H2A
         MNOTE 12,'FSTCHAR=ALL IS NOT ALLOWED WITH ALPHABETIC, NUMERIC,+
                NATIONAL, OR SPECIAL.'                             @H3A
&STOP    SETB  1                                                   @H2A
&C0      SETB  0                 ALL                               @H2A
&C1      SETB  0                 ALPHABETIC                        @H2A
&C2      SETB  0                 NUMERIC                           @H2A
&C3      SETB  0                 NATIONAL                          @H2A
&C4      SETB  0                 SPECIAL                           @H3A
         AGO   .OTHCHAR          GO TO OTHCHAR ROUTINE             @H3A
.*---------------------------------------------------------------* @H3A
.*       FSTSPEC CHECKING ROUTINE.                               * @H3A
.*  IF SPECIAL WAS NOT SPECIFIED, THEN GO TO THE OTHCHAR ROUTINE.* @H3A
.*---------------------------------------------------------------* @H3A
.FSTSPEC ANOP                                                      @H3A
         AIF   (&C4 EQ 0).OTHCHAR  NO SPECIAL PROCESSING?          @H3A
.*---------------------------------------------------------------* @H3A
.*  CHECK TO SEE IF FSTSPEC HAS PARAMETERS.                      * @H3A
.*---------------------------------------------------------------* @H3A
         AIF   ('&FSTSPEC' NE '').FSPCNT                           @H3A
.*---------------------------------------------------------------* @H3A
.*     SPECIAL KEYWORD DOES NOT HAVE PARAMETERS-> MNOTE IT.      * @H3A
.*---------------------------------------------------------------* @H3A
         MNOTE 12,'EXPECTED  SPECIAL  CHARACTERS  WERE  NOT  SPECIFIED +
               FOR FSTCHAR=SPECIAL.'                               @H3A
&STOP    SETB  1                                                   @H3A
&C4      SETB  0                 RESET SPECIAL CHARACTER BIT       @H3A
         AGO   .OTHCHAR          GO TO OTHCHAR ROUTINE             @H3A
.FSPCNT  ANOP                                                      @H3A
&#FSPEC  SETA  N'&FSTSPEC        GET THE NUMBER OF PARAMETERS      @H3A
         AIF   (&#FSPEC GT 16).FSPNOTE                             @H3A
&FPAD    SETA  16-&#FSPEC      SET THE NUMBER OF NON-SPECIAL CHARS @H3A
&CTR     SETA  0                 RESET COUNTER                     @H3A
.*---------------------------------------------------------------* @H3A
.*     THE FOLLOWING LOOP GETS ALL THE SPECIFIED PARAMETERS AND  * @H3A
.*     SCANS THEM TO INSURE EACH ONLY HAS ONE CHARACTER. THE     * @H3A
.*     APOSTROPHY AND AMPERSAND CHARACTERS NEED TO BE CHECKED    * @H3A
.*     INDIVIDUALLY.                                             * @H3A
.*---------------------------------------------------------------* @H3A
.FSPLOOP ANOP                                                      @H3A
&CTR     SETA  &CTR+1            DO EACH PARAMETER                 @H3A
         AIF   (&CTR GT &#FSPEC).OTHCHAR  ALL PARAMETERS SCANNED?  @H3A
         AIF   ('&FSTSPEC(&CTR)' EQ '''''' OR                          +
                '&FSTSPEC(&CTR)' EQ '&&').FSPAPAM                  @H3A
         AIF   (K'&FSTSPEC(&CTR) NE 1).FSP2BIG   NOT ONE CHAR?     @H3A
.FSPAPAM ANOP                                                      @H3A
&FALL    SETC  '&FALL.&FSTSPEC(&CTR)' CONCATENATE SPECIAL CHARS.   @H3A
         AGO   .FSPLOOP                                            @H3A
.*---------------------------------------------------------------* @H3A
.*     FSTSPEC SPECIFIED OVER THE MAXIMUM OF 16 PARMS-> MNOTE IT.* @H3A
.*---------------------------------------------------------------* @H3A
.FSPNOTE ANOP                                                      @H3A
        MNOTE 12,'FSTSPEC SPECIFIES MORE PARAMETERS THAN THE MAXIMUM OF+
                16 ALLOWED'                                        @H3A
&STOP    SETB  1                                                   @H3A
&C4      SETB  0                 RESET SPECIAL CHARACTER BIT       @H3A
         AGO   .OTHCHAR          GO TO OTHCHAR ROUTINE             @H3A
.*---------------------------------------------------------------* @H3A
.*  FSTSPEC SPECIFIES PARMS WITH MORE THAN ONE CHARS-> MNOTE IT. * @H3A
.*---------------------------------------------------------------* @H3A
.FSP2BIG ANOP                                                      @H3A
         MNOTE 12,'PARAMETER ''&FSTSPEC(&CTR)'' SPECIFIES MORE THAN THE+
                ONE CHARACTER ALLOWED.'                            @H3A
&STOP    SETB  1                                                   @H3A
&C4      SETB  0                 RESET SPECIAL CHARACTER BIT       @H3A
.*---------------------------------------------------------------* @H2A
.*       OTHCHAR CHECKING ROUTINE.                               * @H2A
.*  IF OTHCHAR WAS NOT SPECIFIED, THEN THE DEFAULT IS 'ALL'.     * @H2A
.*---------------------------------------------------------------* @H2A
.OTHCHAR ANOP                                                      @H2A
         AIF   ('&OTHCHAR' NE '').OTHCNT                           @H2A
&O0      SETB  1                 THIS IS THE 'ALL' DEFAULT BIT     @H2A
         AGO   .CHRMAX           GO TEST MAXLEN KEYWORD            @H2A
.*---------------------------------------------------------------* @H2A
.*  GET THE NUMBER OF SUBPARAMETERS SUPPLIED (N'OTHCHAR).        * @H2A
.*---------------------------------------------------------------* @H2A
.OTHCNT  ANOP                                                      @H2A
&CTR     SETA  1                 START INDEX COUNTER               @H2A
&NUM     SETA  N'&OTHCHAR        MUST BE 1 TO 4                    @H3C
         AIF   (&NUM GE 1 AND &NUM LE 4).OTHLOOP                   @H3C
.*---------------------------------------------------------------* @H2A
.*     OTHCHAR DOES NOT HAVE 1 TO 4 SUBPARAMETERS-> MNOTE IT.    * @H3C
.*---------------------------------------------------------------* @H2A
         MNOTE 12,'OTHCHAR=&OTHCHAR HAS AN INVALID NUMBER OF SUBPARAMET+
               ERS. ONLY 1 TO 4 ALLOWED.'                          @H3C
&STOP    SETB  1                                                   @H2A
         AGO   .CHRMAX           GO CHECK MAXLEN KEYWORD           @H2A
.*---------------------------------------------------------------* @H2A
.*       OTHCHAR-SAVE EACH SUBPARAMETER SPECIFIED.               * @H2A
.*---------------------------------------------------------------* @H2A
.OTHLOOP ANOP                                                      @H2A
&SUB(&CTR) SETC '&OTHCHAR(&CTR)' GET EACH SUBPARAMETER             @H2A
         AIF    (&CTR EQ &NUM).OTHCONT                             @H2A
&CTR     SETA   &CTR+1           SET UP FOR NEXT SUBPARAMETER      @H2A
         AGO    .OTHLOOP         DO NEXT SUBPARAMETER              @H2A
.*---------------------------------------------------------------* @H2A
.*    CHECK EACH SAVED SUBPARAMETER FOR VALUE AND EXCLUSIVITY    * @H2A
.*    WITH ITSELF.                                               * @H2A
.*---------------------------------------------------------------* @H2A
.OTHCONT ANOP                                                      @H2A
         AIF   ('&SUB(&CTR)' EQ 'ALL' OR '&SUB(&CTR)' EQ 'ALPHABETIC'  +
               OR '&SUB(&CTR)' EQ 'NUMERIC' OR '&SUB(&CTR)' EQ         +
               'NATIONAL' OR '&SUB(&CTR)' EQ 'SPECIAL').TESTO0     @H3A
.*---------------------------------------------------------------* @H2A
.*   OTHCHAR HAS INVALID SUBPARAMETERS-> MNOTE IT.               * @H2A
.*---------------------------------------------------------------* @H2A
         MNOTE 12,'OTHCHAR=&OTHCHAR HAS INVALID SUBPARAMETERS. MUST BE +
               ALL, ALPHABETIC, NUMERIC, NATIONAL, OR SPECIAL.'    @H3A
&STOP    SETB  1                                                   @H2A
&O0      SETB  0                 ALL                               @H2A
&O1      SETB  0                 ALPHABETIC                        @H2A
&O2      SETB  0                 NUMERIC                           @H2A
&O3      SETB  0                 NATIONAL                          @H2A
&O4      SETB  0                 SPECIAL                           @H3A
         AGO   .CHRMAX           GO TEST MAXLEN KEYWORD            @H2A
.TESTO0  AIF   ('&SUB(&CTR)' NE 'ALL').TESTO1                      @H2A
         AIF   (&O0).OEXCLUD     HAS 'ALL' BEEN PREVIOUSLY SET?    @H2A
&O0      SETB  1                                                   @H2A
         AGO   .OUPCTR                                             @H2A
.TESTO1  AIF   ('&SUB(&CTR)' NE 'ALPHABETIC').TESTO2               @H2A
         AIF   (&O1).OEXCLUD     HAS ALPHA BEEN PREVIOUSLY SET?    @H2A
&O1      SETB  1                                                   @H2A
         AGO   .OUPCTR                                             @H2A
.TESTO2  AIF   ('&SUB(&CTR)' NE 'NUMERIC').TESTO3                  @H2A
         AIF   (&O2).OEXCLUD     HAS NUM BEEN PREVIOUSLY SET?      @H2A
&O2      SETB  1                                                   @H2A
         AGO   .OUPCTR                                             @H2A
.TESTO3  AIF   ('&SUB(&CTR)' NE 'NATIONAL').TESTO4                 @H3A
         AIF   (&O3).OEXCLUD     HAS NAT'L BEEN PREVIOUSLY SET?    @H3C
&O3      SETB  1                                                   @H2A
         AGO   .OUPCTR                                             @H3A
.TESTO4  AIF   (&O4).OEXCLUD     HAS SPECIAL BEEN PREVIOUSLY SET?  @H3A
&O4      SETB  1                                                   @H3A
.OUPCTR  ANOP                                                      @H2A
         AIF   (&CTR EQ 1).OTHTEST                                 @H2A
&CTR     SETA  &CTR-1            SET UP FOR NEXT SUBPARAMETER      @H2A
         AGO   .OTHCONT          DO NEXT SUBPARAMETER              @H2A
.*---------------------------------------------------------------* @H2A
.*   A SUBPARAMETER HAS BEEN SPECIFIED MORE THAN ONCE-> MNOTE IT.* @H2A
.*---------------------------------------------------------------* @H2A
.OEXCLUD ANOP                                                      @H2A
     MNOTE 4,'OTHCHAR KEYWORD HAS MULTIPLE DEFINED SUBPARAMETERS.' @H2A
         AIF   (&CTR EQ 1).OTHTEST                                 @H2A
&CTR     SETA  &CTR-1            SET UP FOR NEXT SUBPARAMETER      @H2A
         AGO   .OTHCONT          DO NEXT SUBPARAMETER              @H2A
.*---------------------------------------------------------------* @H2A
.*   TEST FOR EXCLUSIVITY AGAINST 'ALL' AND THE REST.            * @H2A
.*---------------------------------------------------------------* @H2A
.OTHTEST ANOP                                                      @H2A
         AIF   (&O0 EQ 0).OTHSPEC   'ALL' BIT OFF?                 @H3C
         AIF   (&O1 OR &O2 OR &O3 OR &O4).EXOERR  ERROR IF OTHERS  @H3A
         AGO   .CHRMAX              ONLY 'ALL' WAS ON--OKAY        @H2A
.*---------------------------------------------------------------* @H2A
.*     'ALL' EXCLUSIVITY TEST FAILED-> MNOTE IT.                 * @H2A
.*---------------------------------------------------------------* @H2A
.EXOERR  ANOP                                                      @H2A
         MNOTE 12,'OTHCHAR=ALL IS NOT ALLOWED WITH ALPHABETIC, NUMERIC,+
                NATIONAL, OR SPECIAL.'                             @H3A
&STOP    SETB  1                                                   @H2A
&O0      SETB  0                 ALL                               @H2A
&O1      SETB  0                 ALPHABETIC                        @H2A
&O2      SETB  0                 NUMERIC                           @H2A
&O3      SETB  0                 NATIONAL                          @H2A
&O4      SETB  0                 SPECIAL                           @H3A
         AGO   .CHRMAX           GO TO MAX/MINLEN ROUTINE          @H3A
.*---------------------------------------------------------------* @H3A
.*       OTHSPEC CHECKING ROUTINE.                               * @H3A
.*  IF SPECIAL WAS NOT SPECIFIED, THEN GO TO THE CHRMAX ROUTINE. * @H3A
.*---------------------------------------------------------------* @H3A
.OTHSPEC ANOP                                                      @H3A
         AIF   (&O4 EQ 0).CHRMAX   NO SPECIAL PROCESSING?          @H3A
.*---------------------------------------------------------------* @H3A
.*  CHECK TO SEE IF OTHSPEC HAS PARAMETERS.                      * @H3A
.*---------------------------------------------------------------* @H3A
         AIF   ('&OTHSPEC' NE '').OSPCNT                           @H3A
.*---------------------------------------------------------------* @H3A
.*     SPECIAL KEYWORD DOES NOT HAVE PARAMETERS-> MNOTE IT.      * @H3A
.*---------------------------------------------------------------* @H3A
         MNOTE 12,'EXPECTED  SPECIAL  CHARACTERS  WERE  NOT  SPECIFIED +
               FOR OTHCHAR=SPECIAL.'                               @H3A
&STOP    SETB  1                                                   @H3A
&O4      SETB  0                 RESET SPECIAL CHARACTER BIT       @H3A
         AGO   .CHRMAX           GO TO MAX/MINLEN ROUTINE          @H3A
.OSPCNT  ANOP                                                      @H3A
&#OSPEC  SETA  N'&OTHSPEC        GET THE NUMBER OF PARAMETERS      @H3A
         AIF   (&#OSPEC GT 16).OSPNOTE                             @H3A
&OPAD    SETA  16-&#OSPEC      SET THE NUMBER OF NON-SPECIAL CHARS @H3A
&CTR     SETA  0                 RESET COUNTER                     @H3A
.*---------------------------------------------------------------* @H3A
.*     THE FOLLOWING LOOP GETS ALL THE SPECIFIED PARAMETERS AND  * @H3A
.*     SCANS THEM TO INSURE EACH ONLY HAS ONE CHARACTER. THE     * @H3A
.*     APOSTROPHY AND AMPERSAND CHARACTERS NEED TO BE CHECKED    * @H3A
.*     INDIVIDUALLY.                                             * @H3A
.*---------------------------------------------------------------* @H3A
.OSPLOOP ANOP                                                      @H3A
&CTR     SETA  &CTR+1            DO EACH PARAMETER                 @H3A
         AIF   (&CTR GT &#OSPEC).CHRMAX   ALL PARAMETERS SCANNED?  @H3A
         AIF   ('&OTHSPEC(&CTR)' EQ '''''' OR                          +
                '&OTHSPEC(&CTR)' EQ '&&').OSPAPAM                  @H3A
         AIF   (K'&OTHSPEC(&CTR) NE 1).OSP2BIG   NOT ONE CHAR?     @H3A
.OSPAPAM ANOP                                                      @H3A
&OALL    SETC  '&OALL.&OTHSPEC(&CTR)' CONCATENATE SPECIAL CHARS.   @H3A
         AGO   .OSPLOOP                                            @H3A
.*---------------------------------------------------------------* @H3A
.*     OTHSPEC SPECIFIED OVER THE MAXIMUM OF 16 PARMS-> MNOTE IT.* @H3A
.*---------------------------------------------------------------* @H3A
.OSPNOTE ANOP                                                      @H3A
        MNOTE 12,'OTHSPEC SPECIFIES MORE PARAMETERS THAN THE MAXIMUM OF+
                16 ALLOWED'                                        @H3A
&STOP    SETB  1                                                   @H3A
&O4      SETB  0                 RESET SPECIAL CHARACTER BIT       @H3A
         AGO   .CHRMAX           GO TO MAX/MINLEN ROUTINE          @H3A
.*---------------------------------------------------------------* @H3A
.*  OTHSPEC SPECIFIES PARMS WITH MORE THAN ONE CHARS-> MNOTE IT. * @H3A
.*---------------------------------------------------------------* @H3A
.OSP2BIG ANOP                                                      @H3A
         MNOTE 12,'PARAMETER ''&OTHSPEC(&CTR)'' SPECIFIES MORE THAN THE+
                ONE CHARACTER ALLOWED.'                            @H3A
&STOP    SETB  1                                                   @H3A
&O4      SETB  0                 RESET SPECIAL CHARACTER BIT       @H3A
.*---------------------------------------------------------------* @H1A
.*       MAXLEN AND MINLEN CHECKING ROUTINE.                     * @H2C
.*---------------------------------------------------------------* @H1A
.CHRMAX  ANOP                                                      @H2A
         AIF    ('&MAXLEN' NE '').CMAXVAL   SHOULD BE SPECIFIED    @H1A
.*---------------------------------------------------------------* @H1A
.*       MAXLEN NOT SPECIFIED-> MNOTE IT.                        * @H1A
.*---------------------------------------------------------------* @H1A
         MNOTE 12,'REQUIRED MAXLEN PARAMETER IS NOT SPECIFIED'     @H1A
&STOP    SETB  1                                                   @H1A
&MXLTH   SETA  1                 SET FOR FURTHER PROCESSING        @H1A
         AGO   .CRMIN            GO CHECK MINLEN                   @H1A
.*---------------------------------------------------------------* @H1A
.*       CHECK FOR MAXLEN VALUE OF 1 TO 64 DECIMAL.              * @H1A
.*---------------------------------------------------------------* @H1A
.CMAXVAL ANOP                                                      @H1A
         AIF   (&MAXLEN GE 1 AND &MAXLEN LE 64).CMAXOK             @H1A
.*---------------------------------------------------------------* @H1A
.*       MAXLEN NOT CORRECT VALUE OF 1 TO 64-> MNOTE IT.         * @H1A
.*---------------------------------------------------------------* @H1A
        MNOTE 12,'MAXLEN=&MAXLEN INVALID. MUST BE 1 TO 64 DECIMAL' @H1A
&STOP    SETB  1                                                   @H1A
&MXLTH   SETA  1                 SET FOR FURTHER PROCESSING        @H1A
         AGO   .CRMIN            GO CHECK MINLEN                   @H1A
.CMAXOK  ANOP                                                      @H1A
&MXLTH   SETA  &MAXLEN           GET MAXLEN PARAMETER VALUE        @H1A
.*---------------------------------------------------------------* @H1A
.*       CHECK FOR MINLEN VALUE OF 1 TO 64 DECIMAL.              * @H1A
.*---------------------------------------------------------------* @H1A
.CRMIN   ANOP                                                      @H1A
         AIF   (&MINLEN GE 1 AND &MINLEN LE 64).CMINOK             @H1A
.*---------------------------------------------------------------* @H1A
.*       MINLEN NOT CORRECT VALUE OF 1 TO 64-> MNOTE IT.         * @H1A
.*---------------------------------------------------------------* @H1A
        MNOTE 12,'MINLEN=&MINLEN INVALID. MUST BE 1 TO 64 DECIMAL' @H1A
&STOP    SETB  1                                                   @H1A
&MNLTH   SETA  1                 SET FOR FURTHER PROCESSING        @H1A
         AGO   .CMXMN            GO COMPARE MAXLEN TO MINLEN       @H1A
.CMINOK  ANOP                                                      @H1A
&MNLTH   SETA  &MINLEN           GET MINLEN PARAMETER VALUE        @H1A
.*---------------------------------------------------------------* @H1A
.*       CHECK FOR MAXLEN GREATER THAN OR EQUAL TO MINLEN VALUE. * @H1A
.*---------------------------------------------------------------* @H1A
.CMXMN   ANOP                                                      @H1A
         AIF   (&MXLTH GE &MNLTH).CMXMNOK                          @H1A
.*---------------------------------------------------------------* @H1A
.*       MAXLEN < MINLEN IS INVALID-> MNOTE IT.                  * @H1A
.*---------------------------------------------------------------* @H1A
         MNOTE 12,'MAXLEN=&MAXLEN OR  MINLEN=&MINLEN  INVALID.  MAXLEN +
               MUST BE GREATER THAN OR EQUAL TO MINLEN'            @H1A
&STOP    SETB  1                                                   @H1A
.*---------------------------------------------------------------* @H1A
.*       CHECK LEVNUM AND LEVLEN PARAMETER VALUES.               * @H1A
.*---------------------------------------------------------------* @H1A
.CMXMNOK ANOP                                                      @H1A
         AIF   (&LEVNUM GE 1 AND &LEVNUM LE 31).NSETNUM            @H1A
.*---------------------------------------------------------------* @H1A
.*       LEVNUM NOT 1 TO 31 DECIMAL-> MNOTE IT.                  * @H1A
.*---------------------------------------------------------------* @H1A
        MNOTE 12,'LEVNUM=&LEVNUM INVALID. MUST BE 1 TO 31 DECIMAL' @H1A
&STOP    SETB  1                                                   @H1A
&LVNUM   SETA  1                 SET LEVNUM FOR FURTHER PROCESSING @H1A
         AGO   .NCKLVL                                             @H1A
.NSETNUM ANOP                                                      @H1A
&LVNUM   SETA  &LEVNUM                                             @H1A
.NCKLVL  ANOP                                                      @H1A
         AIF   (&LVNUM EQ 1 AND '&LEVLEN' EQ '').NLEVDEF  DEFAULT  @H1A
         AIF   (&LEVLEN GE 1 AND &LEVLEN LE 64).NSETLEN            @H1A
.*---------------------------------------------------------------* @H1A
.*       LEVLEN NOT 1 TO 64 DECIMAL-> MNOTE IT.                  * @H1A
.*---------------------------------------------------------------* @H1A
        MNOTE 12,'LEVLEN=&LEVLEN INVALID. MUST BE 1 TO 64 DECIMAL' @H1A
&STOP    SETB  1                                                   @H1A
&LVLEN   SETA  1                 SET LEVLEN FOR FURTHER PROCESSING @H1A
         AGO   .HILO             GO CHECK HIGH, LOW, AND CONLEN.   @H1A
.NLEVDEF ANOP                                                      @H1A
&LVLEN   SETA   &MXLTH                                             @H1A
         AGO   .HILO             GO CHECK HIGH, LOW, AND CONLEN.   @H1A
.NSETLEN ANOP                                                      @H1A
&LVLEN   SETA  &LEVLEN                                             @H1A
         AGO   .HILO             GO CHECK HIGH, LOW, AND CONLEN.   @H1A
.*---------------------------------------------------------------* @H1A
.*      CONVERT=HEX ROUTINE.                                     * @H1A
.*---------------------------------------------------------------* @H1A
.HEX     ANOP                                                      @H1A
&F3      SETB  1                   SET HEX CONVERSION BIT          @H1A
         AIF    ('&MAXLEN' NE '').HMAXVAL   SHOULD BE SPECIFIED    @H1A
.*---------------------------------------------------------------* @H1A
.*       MAXLEN NOT SPECIFIED-> MNOTE IT.                        * @H1A
.*---------------------------------------------------------------* @H1A
         MNOTE 12,'REQUIRED MAXLEN PARAMETER IS NOT SPECIFIED'     @H1A
&STOP    SETB  1                                                   @H1A
&MXLTH   SETA  1                 SET FOR FURTHER PROCESSING        @H1A
         AGO   .HEXMIN           GO CHECK MINLEN                   @H1A
.*---------------------------------------------------------------* @H1A
.*       CHECK FOR MAXLEN VALUE OF 1 TO 8 DECIMAL.               * @H1A
.*---------------------------------------------------------------* @H1A
.HMAXVAL ANOP                                                      @H1A
         AIF   (&MAXLEN GE 1 AND &MAXLEN LE 8).HMAXLEN             @H1A
.*---------------------------------------------------------------* @H1A
.*       MAXLEN VALUE IS NOT IN THE RANGE OF 1 TO 8-> MNOTE IT.  * @H1A
.*---------------------------------------------------------------* @H1A
         MNOTE 12,'MAXLEN=&MAXLEN INVALID. MUST BE 1 TO 8 DECIMAL' @H1A
&STOP    SETB  1                                                   @H1A
&MXLTH   SETA  1                 SET MAXLEN VALUE                  @H1A
         AGO   .HEXMIN                                             @H1A
.HMAXLEN ANOP                                                      @H1A
&MXLTH   SETA  &MAXLEN           SET MAXLEN PARAMETER VALUE        @H1A
.*---------------------------------------------------------------* @H1A
.*       CHECK FOR MINLEN VALUE OF 1 TO 8 DECIMAL.               * @H1A
.*---------------------------------------------------------------* @H1A
.HEXMIN  ANOP                                                      @H1A
         AIF   (&MINLEN GE 1 AND &MINLEN LE 8).HMINLEN             @H1A
.*---------------------------------------------------------------* @H1A
.*       MINLEN VALUE IS NOT IN THE RANGE OF 1 TO 8-> MNOTE IT.  * @H1A
.*---------------------------------------------------------------* @H1A
         MNOTE 12,'MINLEN=&MINLEN INVALID. MUST BE 1 TO 8 DECIMAL' @H1A
&STOP    SETB  1                                                   @H1A
&MNLTH   SETA  1                 SET MINLEN VALUE                  @H1A
         AGO   .HMAXMIN          GO COMPARE MAXLEN TO MINLEN       @H1A
.HMINLEN ANOP                                                      @H1A
&MNLTH   SETA  &MINLEN           SET MINLEN VALUE                  @H1A
.*---------------------------------------------------------------* @H1A
.*       CHECK THAT MAXLEN IS GREATER THAN OR EQUAL TO MINLEN    * @H1A
.*---------------------------------------------------------------* @H1A
.HMAXMIN ANOP                                                      @H1A
         AIF   (&MXLTH GE &MNLTH).HEXCON  MAXLEN >= MINLEN?        @H1A
.*---------------------------------------------------------------* @H1A
.*       MAXLEN OR MINLEN VALUE IS INVALID-> MNOTE IT.           * @H1A
.*---------------------------------------------------------------* @H1A
         MNOTE 12,'MAXLEN=&MXLTH OR MINLEN=&MNLTH INVALID.  MAXLEN MUST+
                BE GREATER THAN OR EQUAL TO MINLEN VALUE.'         @H1A
&STOP    SETB  1                                                   @H1A
.*---------------------------------------------------------------* @H1A
.*       CHECK FOR CONLEN VALUE OF 1 TO 4 DECIMAL.               * @H1A
.*---------------------------------------------------------------* @H1A
.HEXCON  ANOP                                                      @H1A
         AIF   ('&CONLEN' GE '1' AND '&CONLEN' LE '4').HEXCLOK     @H1A
.*---------------------------------------------------------------* @H1A
.*       CONLEN VALUE INVALID; MUST BE 1-4 DECIMAL-> MNOTE IT.   * @H1A
.*---------------------------------------------------------------* @H1A
         MNOTE 12,'CONLEN=&CONLEN INVALID. MUST BE 1 TO 4 DECIMAL' @H1A
&STOP    SETB  1                                                   @H1A
&CLEN    SETA  1                                                   @H1A
         AGO   .HEXLOW           SKIP CHARACTER SET BIT ROUTINE    @H1A
.*---------------------------------------------------------------* @H1A
.*       CONLEN SPECIFIED OK, SET CONLEN VARIABLE                * @H1A
.*---------------------------------------------------------------* @H1A
.HEXCLOK ANOP                                                      @H1A
&CLEN    SETA  &CONLEN                                             @H1A
.*---------------------------------------------------------------* @H1A
.*       CHECK FOR LOW PARAMETER VALUE PROCESSING.               * @H1A
.*---------------------------------------------------------------* @H1A
.HEXLOW  ANOP                                                      @H1A
         AIF   (K'&LOW GE 0 AND K'&LOW LE 8).GETLNUM               @H1A
         AGO   .LOWNOTE          LOW TOO LARGE-GO MNOTE IT         @H1A
.GETLNUM ANOP                                                      @H1A
&CTR     SETA  1                 SET COUNTER TO FIRST DIGIT        @H1A
&NUM     SETA  K'&LOW            GET NUMBER OF DIGITS OF LOW VALUE @H1A
         AIF   (&NUM LT 8).LOWLOOP   LESS THAN 8 DIGITS?           @H1A
&CTR     SETA  2                 SET COUNTER TO SECOND DIGIT       @H1A
.*---------------------------------------------------------------* @H1A
.*       EXPLICITLY CHECK FIRST DIGIT OF LOW VALUE TO INSURE     * @H1A
.*       THAT IT IS NOT A NEGATIVE NUMBER (I.E. > 7FFFFFFF)      * @H1A
.*       IF THERE ARE EIGHT DIGITS SPECIFIED.                    * @H1A
.*---------------------------------------------------------------* @H1A
         AIF   ('&LOW'(1,1) GE '0' AND '&LOW'(1,1) LE '7').LOWLOOP @H1A
         AGO   .LOWNOTE                                            @H1A
.LOWLOOP ANOP                                                      @H1A
         AIF   ('&LOW'(&CTR,1) GE 'A' AND '&LOW'(&CTR,1) LE 'F' OR     +
                '&LOW'(&CTR,1) GE '0' AND '&LOW'(&CTR,1) LE '9').L @H1A
         AGO    .LOWNOTE                                           @H1A
.L       ANOP                                                      @H1A
&CTR     SETA  &CTR+1            SET COUNTER TO NEXT DIGIT         @H1A
         AIF   (&CTR GT &NUM).LOWDONE   FINISHED ALL DIGITS?       @H1A
         AGO   .LOWLOOP          NO, DO NEXT DIGIT.                @H1A
.*---------------------------------------------------------------* @H1A
.*       LOW VALUE INVALID; MUST BE 0 TO 7FFFFFFF-> MNOTE IT.    * @H1A
.*---------------------------------------------------------------* @H1A
.LOWNOTE ANOP                                                      @H1A
         MNOTE 12,'LOW=&LOW INVALID. MUST BE 0 TO 7FFFFFFF HEX'    @H1A
&STOP    SETB  1                                                   @H1A
&HLOW    SETC  '0'               SET HEX LOW VALUE TO ZERO         @H1A
         AGO   .HEXHIGH          GO CHECK THE HIGH RANGE VALUE     @H1A
.LOWDONE ANOP                                                      @H1A
&HLOW    SETC  '&LOW'            SET HEX LOW VALUE                 @H1A
.*---------------------------------------------------------------* @H1A
.*       CHECK FOR HIGH PARAMETER VALUE PROCESSING.              * @H1A
.*---------------------------------------------------------------* @H1A
.HEXHIGH ANOP                                                      @H1A
         AIF   ('&HIGH' NE '2147483647').HCKHIGH                   @H1A
&HHGH    SETC  '7FFFFFFF'        SET TO MAXIMUM DEFAULT VALUE      @H1A
         AGO   .HXCHC                                              @H1A
.HCKHIGH AIF   (K'&HIGH GE 0 AND K'&HIGH LE 8).GETHNUM             @H1A
         AGO   .HGHNOTE          HIGH TOO LARGE-GO MNOTE IT        @H1A
.GETHNUM ANOP                                                      @H1A
&CTR     SETA  1                 SET COUNTER TO FIRST DIGIT        @H1A
&NUM     SETA  K'&HIGH          GET NUMBER OF DIGITS OF HIGH VALUE @H1A
         AIF   (&NUM LT 8).HGHLOOP   LESS THAN 8 DIGITS?           @H1A
&CTR     SETA  2                 SET COUNTER TO SECOND DIGIT       @H1A
.*---------------------------------------------------------------* @H1A
.*       EXPLICITLY CHECK FIRST DIGIT OF HIGH VALUE TO INSURE    * @H1A
.*       THAT IT IS NOT A NEGATIVE NUMBER (I.E. > 7FFFFFFF)      * @H1A
.*       IF THERE ARE EIGHT DIGITS SPECIFIED.                    * @H1A
.*---------------------------------------------------------------* @H1A
         AIF ('&HIGH'(1,1) GE '0' AND '&HIGH'(1,1) LE '7').HGHLOOP @H1A
         AGO   .HGHNOTE                                            @H1A
.HGHLOOP ANOP                                                      @H1A
         AIF   ('&HIGH'(&CTR,1) GE 'A' AND '&HIGH'(&CTR,1) LE 'F' OR '&+
               HIGH'(&CTR,1) GE '0' AND '&HIGH'(&CTR,1) LE '9').H  @H1A
         AGO    .HGHNOTE                                           @H1A
.H       ANOP                                                      @H1A
&CTR     SETA  &CTR+1            SET COUNTER TO NEXT DIGIT         @H1A
         AIF   (&CTR GT &NUM).HGHDONE   FINISHED ALL DIGITS?       @H1A
         AGO   .HGHLOOP          NO, DO NEXT DIGIT.                @H1A
.*---------------------------------------------------------------* @H1A
.*       HIGH VALUE INVALID; MUST BE 0 TO 7FFFFFFF-> MNOTE IT.   * @H1A
.*---------------------------------------------------------------* @H1A
.HGHNOTE ANOP                                                      @H1A
         MNOTE 12,'HIGH=&HIGH INVALID. MUST BE 0 TO 7FFFFFFF HEX'  @H1A
&STOP    SETB  1                                                   @H1A
&HHGH    SETC  '7FFFFFFF'        SET HEX HIGH VALUE TO HIGH VALUE  @H1A
         AGO   .HXCHC                                              @H2C
.HGHDONE ANOP                                                      @H1A
&HHGH    SETC  '&HIGH'           SET HEX HIGH VALUE                @H1A
.*---------------------------------------------------------------* @H1A
.*       TEST HEX HIGH VALUE TO HEX LOW VALUE. (HIGH >= LOW)     * @H1A
.*---------------------------------------------------------------* @H1A
         AIF   ('&HHGH' GE '&HLOW').HXCHC                          @H1A
.*---------------------------------------------------------------* @H1A
.*       HIGH NOT GREATER THAN OR EQUAL TO LOW VALUE-> MNOTE IT. * @H1A
.*---------------------------------------------------------------* @H1A
        MNOTE 12,'HIGH=&HHGH OR LOW=&HLOW INVALID. HIGH MUST BE GREATER+
                THAN OR EQUAL TO LOW VALUE.'                       @H1A
&STOP    SETB  1                                                   @H1A
&HHGH    SETC  '7FFFFFFF'        SET HEX HIGH VALUE TO HIGH VALUE  @H1A
&HLOW    SETC  '0'               SET HEX LOW VALUE TO ZERO         @H1A
.*---------------------------------------------------------------* @H1A
.*       MAKE SURE NO CHOICES WERE SPECIFIED FOR HEX.            * @H1A
.*---------------------------------------------------------------* @H1A
.HXCHC   ANOP                                                      @H1A
  AIF ('&CHOICE1' EQ '' AND '&CHOICE2' EQ '' AND '&CHOICE3' EQ '' AND '+
               &CHOICE4' EQ '' AND '&CHOICE5' EQ '' AND '&CHOICE6' EQ '+
               ' AND '&CHOICE7' EQ '' AND '&CHOICE8' EQ '').HXLEV  @H1A
.*---------------------------------------------------------------* @H1A
.*   CHOICE#= WAS SPECIFIED WITH CONVERT=HEX-> MNOTE IT.         * @H1A
.*---------------------------------------------------------------* @H1A
       MNOTE 4,'CHOICE KEYWORDS FOR CONVERT=HEX HAVE NO MEANING. CHOICE+
                PARAMETERS ARE IGNORED'                            @H1A
.*---------------------------------------------------------------* @H1A
.*       MAKE SURE THAT LEVNUM AND LEVLEN WERE NOT SPECIFIED.    * @H1A
.*---------------------------------------------------------------* @H1A
.HXLEV   ANOP                                                      @H1A
         AIF   ('&LEVNUM' EQ '1' AND '&LEVLEN' EQ '').HXFSOT       @H2C
.*---------------------------------------------------------------* @H1A
.*   LEVNUM OR LEVLEN WERE SPECIFIED WITH HEX-> MNOTE IT.        * @H1A
.*---------------------------------------------------------------* @H1A
         MNOTE 4,'LEVNUM  AND/OR  LEVLEN FOR  CONVERT=HEX  HAVE NO MEAN+
               ING.  LEVNUM/LEVLEN PARAMETERS ARE IGNORED.'        @H1A
.*---------------------------------------------------------------* @H2A
.*       MAKE SURE THAT FSTCHAR AND OTHCHAR WERE NOT SPECIFIED.  * @H2A
.*---------------------------------------------------------------* @H2A
.HXFSOT  ANOP                                                      @H2A
         AIF   ('&FSTCHAR' EQ '' AND '&OTHCHAR' EQ '').BYTEOFF     @H2A
.*---------------------------------------------------------------* @H2A
.*   FSTCHAR OR OTHCHAR WERE SPECIFIED WITH HEX-> MNOTE IT.      * @H2A
.*---------------------------------------------------------------* @H2A
         MNOTE 4,'FSTCHAR AND/OR OTHCHAR FOR  CONVERT=HEX  HAVE NO MEAN+
               ING. FSTCHAR/OTHCHAR PARAMETERS ARE IGNORED.'       @H2A
         AGO   .BYTEOFF                                            @H2A
.*****************************************************************
.*   CONVERT=CHOICE ROUTINE; CHECKS TO SEE IF THE CHOICE WAS     *
.*   SELECTED- IF IT WAS:                                        *
.*---------------------------------------------------------------*
.*   A.  MAKE SURE THAT EXACTLY TWO SUBPARAMETERS WERE SPECIFIED *
.*   B.  CHECK TO SEE THAT THE SYMBOL FOR ANY CHOICES SPECIFIED  *
.*       IS VALID. THAT IS, DOES NOT EXCEED 8 CHARACTERS, AND    *
.*       DOES NOT CONTAIN INVALID CHARACTERS.                    *
.*   C.  MAKE SURE THAT THE VALUE IS EXACTLY TWO HEX DIGITS      *
.*   D.  IF THE LENGTH OF THE VALUE IS OKAY                      *
.*       1.  MAKE SURE THE DIGITS ARE HEX 0-9 AND A-F ONLY       *
.*   E.  IF THE CHOICE WAS NOT SPECIFIED THEN THE CHOICE WILL    *
.*       BE MADE ZEROES                                          *
.*****************************************************************
.* ROUTINES "A-E". THE DESCRIPTION OF THE ROUTINES ARE           *
.*                 AS FOLLOWS:                                   *
.*  A= AIF  (N'&CHOICE# NE 2).CHCERR  N MEANS COUNT # OF         *
.*       PARAMETERS.                                             *
.*  B= JDSCAN &CH# IS AN INTERNAL MACRO CALL TO SCAN THE SYMBOL. * @R6A
.*     ROUTINE "B" ALSO CHECKS THAT EACH PARAMETER IS NOT A      *
.*       BLANK, AS THE ASSEMBLER WILL ALLOW THEM:                *
.*     AIF  ('&CHOICE#(1)' NE '' AND '&CHOICE#(2)' NE '').CH#OK  *
.*  C= AIF  (K'&VAL# NE 2).BADVAL  K MEANS COUNT # OF CHARACTERS *
.*  D= AIF  ('&VAL#'(SUBSCRIPT1,SUBSCRIPT2) GE OR LE A HEX DIGIT *
.*  E= AIF  ('&CHOICE#' EQ '').ZCH#  BRANCH TO A ZEROING ROUTINE *
.*****************************************************************
.CHOICE  ANOP
&F0      SETB  1                 CHOICE FLAG BIT SET ON
.*---------------------------------------------------------------*
.*              C H O I C E   O N E   P R O C E S S I N G        *
.*---------------------------------------------------------------*
&CTR     SETA  1
         AIF   ('&CHOICE1' EQ '').ZCH1
&CHOICE# SETC  'CHOICE1'         IDENTIFIER FOR POSSIBLE MNOTE
&NUM     SETA  N'&CHOICE1        VARIABLE FOR MNOTE
         AIF   (N'&CHOICE1 NE 2).CHCERR
         AIF   ('&CHOICE1(1)' NE '' AND '&CHOICE1(2)' NE '').CH1OK @R3A
&NUM     SETA  1                 ONLY ONE PARAMETER SPECIFIED      @R3A
         AGO   .CHCERR                                             @R3A
.CH1OK   ANOP                                                      @R3A
&CH1     SETC  '&CHOICE1(1)'     CHOICE1 SELECTED
         AIF   ('&CH1' EQ '*').SCAN1  USED FOR REFER BACK PROCESS  @H1A
         JDSCAN &CH1             CHOICE1 SCAN                      @R6A
         AGO   .JDSCAN           GO TEST FOR ERROR RETURN BITS     @R6A
.SCAN1   ANOP                    RETURNS HERE IF NO ERROR          @R6A
&VAL1    SETC  '&CHOICE1(2)'     VALUE1 SELECTED
         AIF   (K'&VAL1 NE 2).BADVAL
         AIF   ('&VAL1'(1,1) GE '0' AND '&VAL1'(1,1) LE '9' OR         +
               '&VAL1'(1,1)  GE 'A' AND '&VAL1'(1,1) LE 'F').SECVAL1
         AGO   .BADVAL
.SECVAL1 AIF   ('&VAL1'(2,1) GE '0' AND '&VAL1'(2,1) LE '9' OR         +
               '&VAL1'(2,1)  GE 'A' AND '&VAL1'(2,1) LE 'F').CH2
         AGO   .BADVAL
.*---------------------------------------------------------------*
.*              C H O I C E   T W O   P R O C E S S I N G        *
.*---------------------------------------------------------------*
.CH2     ANOP
&CTR     SETA  &CTR+1
         AIF   ('&CHOICE2' EQ '').ZCH2
&CHOICE# SETC  'CHOICE2'         IDENTIFIER FOR POSSIBLE MNOTE
&NUM     SETA  N'&CHOICE2        VARIABLE FOR MNOTE
         AIF   (N'&CHOICE2 NE 2).CHCERR
         AIF   ('&CHOICE2(1)' NE '' AND '&CHOICE2(2)' NE '').CH2OK @R3A
&NUM     SETA  1                 ONLY ONE PARAMETER SPECIFIED      @R3A
         AGO   .CHCERR                                             @R3A
.CH2OK   ANOP                                                      @R3A
&CH2     SETC  '&CHOICE2(1)'     CHOICE2 SELECTED
         AIF   ('&CH2' EQ '*').SCAN2  USED FOR REFER BACK PROCESS  @H1A
         JDSCAN &CH2             CHOICE2 SCAN                      @R6A
         AGO   .JDSCAN           GO TEST FOR ERROR RETURN BITS     @R6A
.SCAN2   ANOP                    RETURNS HERE IF NO ERROR          @R6A
&VAL2    SETC  '&CHOICE2(2)'     VALUE2 SELECTED
         AIF   (K'&VAL2 NE 2).BADVAL
         AIF   ('&VAL2'(1,1) GE '0' AND '&VAL2'(1,1) LE '9' OR         +
               '&VAL2'(1,1)  GE 'A' AND '&VAL2'(1,1) LE 'F').SECVAL2
         AGO   .BADVAL
.SECVAL2 AIF   ('&VAL2'(2,1) GE '0' AND '&VAL2'(2,1) LE '9' OR         +
               '&VAL2'(2,1)  GE 'A' AND '&VAL2'(2,1) LE 'F').CH3
         AGO   .BADVAL
.*---------------------------------------------------------------*
.*              C H O I C E   T H R E E   P R O C E S S I N G    *
.*---------------------------------------------------------------*
.CH3     ANOP
&CTR     SETA  &CTR+1
         AIF   ('&CHOICE3' EQ '').ZCH3
&CHOICE# SETC  'CHOICE3'         IDENTIFIER FOR POSSIBLE MNOTE
&NUM     SETA  N'&CHOICE3        VARIABLE FOR MNOTE
         AIF   (N'&CHOICE3 NE 2).CHCERR
         AIF   ('&CHOICE3(1)' NE '' AND '&CHOICE3(2)' NE '').CH3OK @R3A
&NUM     SETA  1                 ONLY ONE PARAMETER SPECIFIED      @R3A
         AGO   .CHCERR                                             @R3A
.CH3OK   ANOP                                                      @R3A
&CH3     SETC  '&CHOICE3(1)'     CHOICE3 SELECTED
         AIF   ('&CH3' EQ '*').SCAN3  USED FOR REFER BACK PROCESS  @H1A
         JDSCAN &CH3             CHOICE3 SCAN                      @R6A
         AGO   .JDSCAN           GO TEST FOR ERROR RETURN BITS     @R6A
.SCAN3   ANOP                    RETURNS HERE IF NO ERROR          @R6A
&VAL3    SETC  '&CHOICE3(2)'     VALUE3 SELECTED
         AIF   (K'&VAL3 NE 2).BADVAL
         AIF   ('&VAL3'(1,1) GE '0' AND '&VAL3'(1,1) LE '9' OR         +
               '&VAL3'(1,1)  GE 'A' AND '&VAL3'(1,1) LE 'F').SECVAL3
         AGO   .BADVAL
.SECVAL3 AIF   ('&VAL3'(2,1) GE '0' AND '&VAL3'(2,1) LE '9' OR         +
               '&VAL3'(2,1)  GE 'A' AND '&VAL3'(2,1) LE 'F').CH4
         AGO   .BADVAL
.*---------------------------------------------------------------*
.*              C H O I C E   F O U R   P R O C E S S I N G      *
.*---------------------------------------------------------------*
.CH4     ANOP
&CTR     SETA  &CTR+1
         AIF   ('&CHOICE4' EQ '').ZCH4
&CHOICE# SETC  'CHOICE4'         IDENTIFIER FOR POSSIBLE MNOTE
&NUM     SETA  N'&CHOICE4        VARIABLE FOR MNOTE
         AIF   (N'&CHOICE4 NE 2).CHCERR
         AIF   ('&CHOICE4(1)' NE '' AND '&CHOICE4(2)' NE '').CH4OK @R3A
&NUM     SETA  1                 ONLY ONE PARAMETER SPECIFIED      @R3A
         AGO   .CHCERR                                             @R3A
.CH4OK   ANOP                                                      @R3A
&CH4     SETC  '&CHOICE4(1)'     CHOICE4 SELECTED
         AIF   ('&CH4' EQ '*').SCAN4  USED FOR REFER BACK PROCESS  @H1A
         JDSCAN &CH4             CHOICE4 SCAN                      @R6A
         AGO   .JDSCAN           GO TEST FOR ERROR RETURN BITS     @R6A
.SCAN4   ANOP                    RETURNS HERE IF NO ERROR          @R6A
&VAL4    SETC  '&CHOICE4(2)'     VALUE4 SELECTED
         AIF   (K'&VAL4 NE 2).BADVAL
         AIF   ('&VAL4'(1,1) GE '0' AND '&VAL4'(1,1) LE '9' OR         +
               '&VAL4'(1,1)  GE 'A' AND '&VAL4'(1,1) LE 'F').SECVAL4
         AGO   .BADVAL
.SECVAL4 AIF   ('&VAL4'(2,1) GE '0' AND '&VAL4'(2,1) LE '9' OR         +
               '&VAL4'(2,1)  GE 'A' AND '&VAL4'(2,1) LE 'F').CH5
         AGO   .BADVAL
.*---------------------------------------------------------------*
.*              C H O I C E   F I V E   P R O C E S S I N G      *
.*---------------------------------------------------------------*
.CH5     ANOP
&CTR     SETA  &CTR+1
         AIF   ('&CHOICE5' EQ '').ZCH5
&CHOICE# SETC  'CHOICE5'         IDENTIFIER FOR POSSIBLE MNOTE
&NUM     SETA  N'&CHOICE5        VARIABLE FOR MNOTE
         AIF   (N'&CHOICE5 NE 2).CHCERR
         AIF   ('&CHOICE5(1)' NE '' AND '&CHOICE5(2)' NE '').CH5OK @R3A
&NUM     SETA  1                 ONLY ONE PARAMETER SPECIFIED      @R3A
         AGO   .CHCERR                                             @R3A
.CH5OK   ANOP                                                      @R3A
&CH5     SETC  '&CHOICE5(1)'     CHOICE5 SELECTED
         AIF   ('&CH5' EQ '*').SCAN5  USED FOR REFER BACK PROCESS  @H1A
         JDSCAN &CH5             CHOICE5 SCAN                      @R6A
         AGO   .JDSCAN           GO TEST FOR ERROR RETURN BITS     @R6A
.SCAN5   ANOP                    RETURNS HERE IF NO ERROR          @R6A
&VAL5    SETC  '&CHOICE5(2)'     VALUE5 SELECTED
         AIF   (K'&VAL5 NE 2).BADVAL
         AIF   ('&VAL5'(1,1) GE '0' AND '&VAL5'(1,1) LE '9' OR         +
               '&VAL5'(1,1)  GE 'A' AND '&VAL5'(1,1) LE 'F').SECVAL5
         AGO   .BADVAL
.SECVAL5 AIF   ('&VAL5'(2,1) GE '0' AND '&VAL5'(2,1) LE '9' OR         +
               '&VAL5'(2,1)  GE 'A' AND '&VAL5'(2,1) LE 'F').CH6
         AGO   .BADVAL
.*---------------------------------------------------------------*
.*              C H O I C E   S I X   P R O C E S S I N G        *
.*---------------------------------------------------------------*
.CH6     ANOP
&CTR     SETA  &CTR+1
         AIF   ('&CHOICE6' EQ '').ZCH6
&CHOICE# SETC  'CHOICE6'         IDENTIFIER FOR POSSIBLE MNOTE
&NUM     SETA  N'&CHOICE6        VARIABLE FOR MNOTE
         AIF   (N'&CHOICE6 NE 2).CHCERR
         AIF   ('&CHOICE6(1)' NE '' AND '&CHOICE6(2)' NE '').CH6OK @R3A
&NUM     SETA  1                 ONLY ONE PARAMETER SPECIFIED      @R3A
         AGO   .CHCERR                                             @R3A
.CH6OK   ANOP                                                      @R3A
&CH6     SETC  '&CHOICE6(1)'     CHOICE6 SELECTED
         AIF   ('&CH6' EQ '*').SCAN6  USED FOR REFER BACK PROCESS  @H1A
         JDSCAN &CH6             CHOICE6 SCAN                      @R6A
         AGO   .JDSCAN           GO TEST FOR ERROR RETURN BITS     @R6A
.SCAN6   ANOP                    RETURNS HERE IF NO ERROR          @R6A
&VAL6    SETC  '&CHOICE6(2)'     VALUE6 SELECTED
         AIF   (K'&VAL6 NE 2).BADVAL
         AIF   ('&VAL6'(1,1) GE '0' AND '&VAL6'(1,1) LE '9' OR         +
               '&VAL6'(1,1)  GE 'A' AND '&VAL6'(1,1) LE 'F').SECVAL6
         AGO   .BADVAL
.SECVAL6 AIF   ('&VAL6'(2,1) GE '0' AND '&VAL6'(2,1) LE '9' OR         +
               '&VAL6'(2,1)  GE 'A' AND '&VAL6'(2,1) LE 'F').CH7
         AGO   .BADVAL
.*---------------------------------------------------------------*
.*              C H O I C E   S E V E N   P R O C E S S I N G    *
.*---------------------------------------------------------------*
.CH7     ANOP
&CTR     SETA  &CTR+1
         AIF   ('&CHOICE7' EQ '').ZCH7
&CHOICE# SETC  'CHOICE7'         IDENTIFIER FOR POSSIBLE MNOTE
&NUM     SETA  N'&CHOICE7        VARIABLE FOR MNOTE
         AIF   (N'&CHOICE7 NE 2).CHCERR
         AIF   ('&CHOICE7(1)' NE '' AND '&CHOICE7(2)' NE '').CH7OK @R3A
&NUM     SETA  1                 ONLY ONE PARAMETER SPECIFIED      @R3A
         AGO   .CHCERR                                             @R3A
.CH7OK   ANOP                                                      @R3A
&CH7     SETC  '&CHOICE7(1)'     CHOICE7 SELECTED
         AIF   ('&CH7' EQ '*').SCAN7  USED FOR REFER BACK PROCESS  @H1A
         JDSCAN &CH7             CHOICE7 SCAN                      @R6A
         AGO   .JDSCAN           GO TEST FOR ERROR RETURN BITS     @R6A
.SCAN7   ANOP                    RETURNS HERE IF NO ERROR          @R6A
&VAL7    SETC  '&CHOICE7(2)'     VALUE7 SELECTED
         AIF   (K'&VAL7 NE 2).BADVAL
         AIF   ('&VAL7'(1,1) GE '0' AND '&VAL7'(1,1) LE '9' OR         +
               '&VAL7'(1,1)  GE 'A' AND '&VAL7'(1,1) LE 'F').SECVAL7
         AGO   .BADVAL
.SECVAL7 AIF   ('&VAL7'(2,1) GE '0' AND '&VAL7'(2,1) LE '9' OR         +
               '&VAL7'(2,1)  GE 'A' AND '&VAL7'(2,1) LE 'F').CH8
         AGO   .BADVAL
.*---------------------------------------------------------------*
.*              C H O I C E   E I G H T   P R O C E S S I N G    *
.*---------------------------------------------------------------*
.CH8     ANOP
&CTR     SETA  &CTR+1
         AIF   ('&CHOICE8' EQ '').ZCH8
&CHOICE# SETC  'CHOICE8'         IDENTIFIER FOR POSSIBLE MNOTE
&NUM     SETA  N'&CHOICE8        VARIABLE FOR MNOTE
         AIF   (N'&CHOICE8 NE 2).CHCERR
         AIF   ('&CHOICE8(1)' NE '' AND '&CHOICE8(2)' NE '').CH8OK @R3A
&NUM     SETA  1                 ONLY ONE PARAMETER SPECIFIED      @R3A
         AGO   .CHCERR                                             @R3A
.CH8OK   ANOP                                                      @R3A
&CH8     SETC  '&CHOICE8(1)'     CHOICE8 SELECTED
         AIF   ('&CH8' EQ '*').SCAN8  USED FOR REFER BACK PROCESS  @H1A
         JDSCAN &CH8             CHOICE8 SCAN                      @R6A
         AGO   .JDSCAN           GO TEST FOR ERROR RETURN BITS     @R6A
.SCAN8   ANOP                    RETURNS HERE IF NO ERROR          @R6A
&VAL8    SETC  '&CHOICE8(2)'     VALUE8 SELECTED
         AIF   (K'&VAL8 NE 2).BADVAL
         AIF   ('&VAL8'(1,1) GE '0' AND '&VAL8'(1,1) LE '9' OR         +
               '&VAL8'(1,1)  GE 'A' AND '&VAL8'(1,1) LE 'F').SECVAL8
         AGO   .BADVAL
.SECVAL8 AIF   ('&VAL8'(2,1) GE '0' AND '&VAL8'(2,1) LE '9' OR         +
               '&VAL8'(2,1)  GE 'A' AND '&VAL8'(2,1) LE 'F').ANYCHC
.*---------------------------------------------------------------*
.*   BADVAL MNOTE SAYS THAT THE VALUE OF THE CHOICE OPTION       *
.*   IS NOT TWO HEX DIGITS OR THAT ONE OF THE DIGITS IS INVALID. *
.*   THE BAD CHOICE AND VALUE OPTIONS WILL BE SET TO ZEROES.     *
.*---------------------------------------------------------------*
.BADVAL  ANOP
         MNOTE 12,'&CHOICE# VALUE NOT TWO HEX DIGITS'
&ERRSW   SETB  1                  SET CHOICE ERROR SWITCH          @R2A
&STOP    SETB  1                                                   @R1A
.SCANBAD ANOP                     ROUTINE .JDSCAN BRANCHES HERE    @R6A
         AIF   (&CTR EQ 1).ZCH1
         AIF   (&CTR EQ 2).ZCH2
         AIF   (&CTR EQ 3).ZCH3
         AIF   (&CTR EQ 4).ZCH4
         AIF   (&CTR EQ 5).ZCH5
         AIF   (&CTR EQ 6).ZCH6
         AIF   (&CTR EQ 7).ZCH7
         AGO   .ZCH8
.*---------------------------------------------------------------*
.*   CHCERR MNOTE SAYS THAT THE CHOICE OPTION HAS TOO MANY       *
.*   SUBPARAMETERS SPECIFIED AND ONLY TWO ARE ALLOWED.           *
.*   THE BAD CHOICE AND VALUE OPTIONS WILL BE SET TO ZEROES.     *
.*---------------------------------------------------------------*
.CHCERR  ANOP
        MNOTE 12,'TWO SUBPARAMETERS EXPECTED WITH &CHOICE#: &NUM FOUND'
&ERRSW   SETB  1                  SET CHOICE ERROR SWITCH          @R2A
&STOP    SETB  1                                                   @R1A
         AIF   (&CTR EQ 8).ZCH8
         AIF   (&CTR EQ 7).ZCH7
         AIF   (&CTR EQ 6).ZCH6
         AIF   (&CTR EQ 5).ZCH5
         AIF   (&CTR EQ 4).ZCH4
         AIF   (&CTR EQ 3).ZCH3
         AIF   (&CTR EQ 2).ZCH2
.*---------------------------------------------------------------*
.*   THIS ROUTINE ZEROES OUT CHOICES NOT SPECIFIED               *
.*   OR ANY BAD SPECIFICATIONS OF THE CHOICE AND VALUE OPTIONS.  *
.*   THE 'VALUE' OF THE CHOICE OPTION IS NOT ACTUALLY ZEROED OUT *
.*   HERE, BUT WILL BE LATER, DETERMINED BY WHICH CHOICE IS HERE.*
.*   THEN RETURN  TO CHECK NEXT CHOICE.                          *
.*---------------------------------------------------------------*
.ZCH1    ANOP
&CH1     SETC  '0'               SET CHOICE1 TO ZEROES
         AGO   .CH2
.ZCH2    ANOP
&CH2     SETC  '0'               SET CHOICE2 TO ZEROES
         AGO   .CH3
.ZCH3    ANOP
&CH3     SETC  '0'               SET CHOICE3 TO ZEROES
         AGO   .CH4
.ZCH4    ANOP
&CH4     SETC  '0'               SET CHOICE4 TO ZEROES
         AGO   .CH5
.ZCH5    ANOP
&CH5     SETC  '0'               SET CHOICE5 TO ZEROES
         AGO   .CH6
.ZCH6    ANOP
&CH6     SETC  '0'               SET CHOICE6 TO ZEROES
         AGO   .CH7
.ZCH7    ANOP
&CH7     SETC  '0'               SET CHOICE7 TO ZEROES
         AGO   .CH8
.ZCH8    ANOP
&CH8     SETC  '0'               SET CHOICE8 TO ZEROES
.*---------------------------------------------------------------*
.*       CHECK TO SEE IF ANY VALID CHOICES WERE SELECTED.        *
.*       THE ERROR SWITCH WAS SET IF A PREVIOUS DIFFERENT MNOTE  * @R2A
.*       WAS ISSUED AND THE CHOICE(S) WERE SET TO ZEROES IN THE  * @R2A
.*       PROCESS, IN WHICH CASE THIS MNOTE WILL NOT BE ISSUED.   * @R2A
.*---------------------------------------------------------------*
.ANYCHC  ANOP                    ANY CHOICES AT ALL??
         AIF   (&ERRSW EQ 1).CHCSOK                                @R2A
         AIF   ('&CH1' EQ '0' AND '&CH2' EQ '0'  AND '&CH3' EQ '0' AND +
               '&CH4' EQ '0'  AND '&CH5' EQ '0'  AND '&CH6' EQ '0' AND +
               '&CH7' EQ '0' AND '&CH8' EQ '0').NOCHCS
         AGO   .CHCSOK          AT LEAST ONE CHOICE WAS SPECIFIED
.*---------------------------------------------------------------*
.* CONVERT=CHOICE BUT NO VALID CHOICES WERE SPECIFIED-> MNOTE IT.*
.*---------------------------------------------------------------*
.NOCHCS  ANOP
         MNOTE 12,'CONVERT=CHOICE SPECIFIED BUT NO CHOICE OPTIONS SPECI+
               FIED'
&STOP    SETB  1                                                   @R1A
.*---------------------------------------------------------------*
.*       CHECK TO SEE IF MAXLEN WAS SPECIFIED.                   * @H1C
.*---------------------------------------------------------------*
.CHCSOK  ANOP
         AIF   ('&MAXLEN' EQ '' OR '&MAXLEN' EQ '8').PRESET        @H1C
.*---------------------------------------------------------------* @H1C
.*       MAXLEN WAS NOT EQUAL TO 8-> MNOTE IT.                   * @H1C
.*---------------------------------------------------------------* @H1C
    MNOTE 4,'MAXLEN PARAMETER IS NOT REQUIRED WITH CONVERT=CHOICE.  MAX+
               LEN SET TO EIGHT'                                   @H1C
.PRESET  ANOP
&MXLTH   SETA  8                   MAXLEN IS SET TO 8 FOR CHOICE   @H1C
.*---------------------------------------------------------------* @H1A
.*       CHECK TO SEE IF MINLEN WAS SPECIFIED.                   * @H1A
.*---------------------------------------------------------------* @H1A
         AIF   ('&MINLEN' EQ '1').PRESET2                          @H1A
.*---------------------------------------------------------------* @H1A
.*       MINLEN WAS NOT EQUAL TO 1-> MNOTE IT.                   * @H1A
.*---------------------------------------------------------------* @H1A
         MNOTE 4,'MINLEN PARAMETER IS NOT REQUIRED WITH CONVERT=CHOICE.+
                MINLEN SET TO 1'                                   @H1A
.PRESET2 ANOP                                                      @H1A
&MNLTH   SETA  1                   MINLEN IS SET TO 1 FOR CHOICE   @H1A
.*---------------------------------------------------------------* @H1A
.*       MAKE SURE THAT LEVNUM AND LEVLEN WERE NOT SPECIFIED.    * @H1A
.*---------------------------------------------------------------* @H1A
         AIF   ('&LEVNUM' EQ '1' AND '&LEVLEN' EQ '').CHFSOT       @H1A
.*---------------------------------------------------------------* @H1A
.*   LEVNUM OR LEVLEN WERE SPECIFIED WITH CHOICE-> MNOTE IT.     * @H1A
.*---------------------------------------------------------------* @H1A
        MNOTE 4,'LEVNUM AND/OR LEVLEN FOR CONVERT=CHOICE HAVE NO MEANIN+
               G.  LEVNUM/LEVLEN PARAMETERS ARE IGNORED.'          @H1A
.*---------------------------------------------------------------* @H2A
.*       MAKE SURE THAT FSTCHAR AND OTHCHAR WERE NOT SPECIFIED.  * @H2A
.*---------------------------------------------------------------* @H2A
.CHFSOT  ANOP                                                      @H2A
         AIF   ('&FSTCHAR' EQ '' AND '&OTHCHAR' EQ '').HILO        @H2A
.*---------------------------------------------------------------* @H2A
.*   FSTCHAR OR OTHCHAR WERE SPECIFIED WITH CHOICE-> MNOTE IT.   * @H2A
.*---------------------------------------------------------------* @H2A
        MNOTE 4,'FSTCHAR AND/OR OTHCHAR FOR CONVERT=CHOICE HAVE NO MEAN+
               ING. FSTCHAR/OTHCHAR PARAMETERS ARE IGNORED.'       @H2A
         AGO   .HILO               CHECK FOR HIGH & LOW USAGE      @H2A
.*---------------------------------------------------------------*
.*   CONVERT=INTEGER ROUTINE.                                    *
.*---------------------------------------------------------------*
.INTEGER ANOP
&F2      SETB  1                 SET INTEGER FLAG BIT ON
.*---------------------------------------------------------------* @R5A
.*       MAKE SURE NO CHOICES WERE SPECIFIED FOR INTEGER.        * @R5A
.*---------------------------------------------------------------* @R5A
  AIF ('&CHOICE1' EQ '' AND '&CHOICE2' EQ '' AND '&CHOICE3' EQ '' AND '+
               &CHOICE4' EQ '' AND '&CHOICE5' EQ '' AND '&CHOICE6' EQ '+
               ' AND '&CHOICE7' EQ '' AND '&CHOICE8' EQ '').INLEV  @R5A
.*---------------------------------------------------------------* @R5A
.*   CHOICE#= WAS SPECIFIED WITH CONVERT=INTEGER-> MNOTE IT.     * @R5A
.*---------------------------------------------------------------* @R5A
         MNOTE 4,'CHOICE KEYWORDS FOR CONVERT=INTEGER HAVE NO MEANING. +
               CHOICE PARAMETERS ARE IGNORED'                      @R5A
.*---------------------------------------------------------------* @H1A
.*       MAKE SURE THAT LEVNUM AND LEVLEN WERE NOT SPECIFIED.    * @H1A
.*---------------------------------------------------------------* @H1A
.INLEV   ANOP                                                      @H1A
         AIF   ('&LEVNUM' EQ '1' AND '&LEVLEN' EQ '').INFSOT       @H2C
.*---------------------------------------------------------------* @H1A
.*   LEVNUM OR LEVLEN WERE SPECIFIED WITH INTEGER-> MNOTE IT.    * @H1A
.*---------------------------------------------------------------* @H1A
        MNOTE 4,'LEVNUM AND/OR LEVLEN FOR CONVERT=INTEGER HAVE NO MEANI+
               NG.  LEVNUM/LEVLEN PARAMETERS ARE IGNORED.'         @H1A
.*---------------------------------------------------------------* @H2A
.*       MAKE SURE THAT FSTCHAR AND OTHCHAR WERE NOT SPECIFIED.  * @H2A
.*---------------------------------------------------------------* @H2A
.INFSOT  ANOP                                                      @H2A
         AIF   ('&FSTCHAR' EQ '' AND '&OTHCHAR' EQ '').CKHG2LW     @H2A
.*---------------------------------------------------------------* @H2A
.*   FSTCHAR OR OTHCHAR WERE SPECIFIED WITH INTEGER-> MNOTE IT.  * @H2A
.*---------------------------------------------------------------* @H2A
       MNOTE 4,'FSTCHAR AND/OR OTHCHAR FOR CONVERT=INTEGER HAVE NO MEAN+
               ING. FSTCHAR/OTHCHAR PARAMETERS ARE IGNORED.'       @H2A
.*---------------------------------------------------------------*
.*       CHECK HIGH RANGE TO LOW RANGE                           *
.*---------------------------------------------------------------*
.CKHG2LW ANOP
&PLOW    SETA  &LOW              SET LOW INTEGER VALUE
&PHGH    SETA  &HIGH             SET HIGH INTEGER VALUE
         AIF   (&PHGH  GE  &PLOW).HIGHOK     HIGH >= LOW?
.*---------------------------------------------------------------*
.*       HIGH OPTION IS NOT >= LOW RANGE-> MNOTE IT.             *
.*---------------------------------------------------------------*
        MNOTE 12,'HIGH=&PHGH OR LOW=&PLOW INVALID. HIGH MUST BE GREATER+
                THAN OR EQUAL TO LOW VALUE'
&STOP    SETB  1                                                   @R1A
.*---------------------------------------------------------------*
.*       HIGH VALUE IS GREATER THAN OR EQUAL TO LOW VALUE.       *
.*       CHECK FOR CONLEN OPTION ROUTINE                         *
.*---------------------------------------------------------------*
.HIGHOK  ANOP
         AIF   ('&CONLEN' GE '1' AND '&CONLEN' LE '4').CLENOK
.*---------------------------------------------------------------*
.*  CONLEN VALUE IS NOT CORRECT; MUST BE 1-4 DECIMAL-> MNOTE IT. *
.*---------------------------------------------------------------*
       MNOTE 12,'CONLEN=&CONLEN INVALID. MUST BE 1 TO 4 DECIMAL.'
&STOP    SETB  1                                                   @R1A
&CLEN    SETA  1
         AGO   .IMAXLEN          CHECK MAXLEN                      @H1C
.*---------------------------------------------------------------*
.*       CONLEN SPECIFIED OK, SET CONLEN VARIABLE.               *
.*---------------------------------------------------------------*
.CLENOK  ANOP
&CLEN    SETA  &CONLEN
.IMAXLEN ANOP
         AIF    ('&MAXLEN' NE '').IMAXVAL   SHOULD BE SPECIFIED    @H1A
.*---------------------------------------------------------------* @H1A
.*       MAXLEN NOT SPECIFIED-> MNOTE IT.                        * @H1A
.*---------------------------------------------------------------* @H1A
         MNOTE 12,'REQUIRED MAXLEN PARAMETER IS NOT SPECIFIED'     @H1A
&STOP    SETB  1                                                   @H1A
&MXLTH   SETA  1                 SET FOR FURTHER PROCESSING        @H1A
         AGO   .INMIN            GO CHECK MINLEN                   @H1A
.*---------------------------------------------------------------* @H1A
.*       CHECK FOR MAXLEN VALUE OF 1 TO 10 DECIMAL.              * @H1A
.*---------------------------------------------------------------* @H1A
.IMAXVAL ANOP                                                      @H1A
         AIF   (&MAXLEN GE 1 AND &MAXLEN LE 10).IMAXOK             @H1A
.*---------------------------------------------------------------* @H1A
.*       MAXLEN NOT CORRECT VALUE OF 1 TO 10-> MNOTE IT.         * @H1A
.*---------------------------------------------------------------* @H1A
        MNOTE 12,'MAXLEN=&MAXLEN INVALID. MUST BE 1 TO 10 DECIMAL' @H1A
&STOP    SETB  1                                                   @H1A
&MXLTH   SETA  1                 SET FOR FURTHER PROCESSING        @H1A
         AGO   .INMIN            GO CHECK MINLEN                   @H1A
.IMAXOK  ANOP                                                      @H1A
&MXLTH   SETA  &MAXLEN           GET MAXLEN PARAMETER VALUE        @H1A
.*---------------------------------------------------------------* @H1A
.*       CHECK FOR MINLEN VALUE OF 1 TO 10 DECIMAL.              * @H1A
.*---------------------------------------------------------------* @H1A
.INMIN   ANOP                                                      @H1A
         AIF   (&MINLEN GE 1 AND &MINLEN LE 10).IMINOK             @H1A
.*---------------------------------------------------------------* @H1A
.*       MINLEN NOT CORRECT VALUE OF 1 TO 10-> MNOTE IT.         * @H1A
.*---------------------------------------------------------------* @H1A
        MNOTE 12,'MINLEN=&MINLEN INVALID. MUST BE 1 TO 10 DECIMAL' @H1A
&STOP    SETB  1                                                   @H1A
&MNLTH   SETA  1                 SET FOR FURTHER PROCESSING        @H1A
         AGO   .IMXMN            GO COMPARE MAXLEN TO MINLEN       @H1A
.IMINOK  ANOP                                                      @H1A
&MNLTH   SETA  &MINLEN           GET MINLEN PARAMETER VALUE        @H1A
.*---------------------------------------------------------------* @H1A
.*       CHECK FOR MAXLEN GREATER THAN OR EQUAL TO MINLEN VALUE. * @H1A
.*---------------------------------------------------------------* @H1A
.IMXMN   ANOP                                                      @H1A
         AIF   (&MXLTH GE &MNLTH).BYTEOFF                          @H1A
.*---------------------------------------------------------------* @H1A
.*       MAXLEN < MINLEN IS INVALID-> MNOTE IT.                  * @H1A
.*---------------------------------------------------------------* @H1A
         MNOTE 12,'MAXLEN=&MXLTH OR MINLEN=&MNLTH INVALID. MAXLEN MUST +
               BE GREATER THAN OR EQUAL TO MINLEN'                 @H1A
&STOP    SETB  1                                                   @H1A
         AGO    .BYTEOFF                                           @H1A
.*---------------------------------------------------------------* @H2A
.*      CONVERT=REFERRAL CONVERSION.                             * @H2A
.*---------------------------------------------------------------* @H2A
.REFERRL ANOP                                                      @H2A
&F4      SETB  1                                                   @H2A
.*---------------------------------------------------------------* @H2A
.*       MAKE SURE NO CHOICES WERE SPECIFIED FOR REFERRAL.       * @H2A
.*---------------------------------------------------------------* @H2A
  AIF ('&CHOICE1' EQ '' AND '&CHOICE2' EQ '' AND '&CHOICE3' EQ '' AND '+
               &CHOICE4' EQ '' AND '&CHOICE5' EQ '' AND '&CHOICE6' EQ '+
               ' AND '&CHOICE7' EQ '' AND '&CHOICE8' EQ '').REFLEV @H2A
.*---------------------------------------------------------------* @H2A
.*   CHOICE#= WAS SPECIFIED WITH CONVERT=REFERRAL-> MNOTE IT.    * @H2A
.*---------------------------------------------------------------* @H2A
         MNOTE 4,'CHOICE KEYWORDS FOR CONVERT=REFERRAL HAVE NO MEANING.+
                CHOICE PARAMETERS ARE IGNORED'                     @H2A
.*---------------------------------------------------------------* @H2A
.*       MAKE SURE THAT LEVNUM AND LEVLEN WERE NOT SPECIFIED.    * @H2A
.*---------------------------------------------------------------* @H2A
.REFLEV  ANOP                                                      @H2A
         AIF   ('&LEVNUM' EQ '1' AND '&LEVLEN' EQ '').RFFSOT       @H2A
.*---------------------------------------------------------------* @H2A
.*   LEVNUM OR LEVLEN WERE SPECIFIED WITH REFERRAL-> MNOTE IT.   * @H2A
.*---------------------------------------------------------------* @H2A
        MNOTE 4,'LEVNUM AND/OR LEVLEN FOR CONVERT=REFERRAL HAVE NO MEAN+
               ING. LEVNUM/LEVLEN PARAMETERS ARE IGNORED.'         @H2A
.*---------------------------------------------------------------* @H2A
.*       MAKE SURE THAT FSTCHAR AND OTHCHAR WERE NOT SPECIFIED.  * @H2A
.*---------------------------------------------------------------* @H2A
.RFFSOT  ANOP                                                      @H2A
         AIF   ('&FSTCHAR' EQ '' AND '&OTHCHAR' EQ '').REFMAX      @H2A
.*---------------------------------------------------------------* @H2A
.*   FSTCHAR OR OTHCHAR WERE SPECIFIED WITH REFERRAL-> MNOTE IT. * @H2A
.*---------------------------------------------------------------* @H2A
      MNOTE 4,'FSTCHAR AND/OR OTHCHAR FOR CONVERT=REFERRAL HAVE NO MEAN+
               ING. FSTCHAR/OTHCHAR PARAMETERS ARE IGNORED.'       @H2A
.*---------------------------------------------------------------* @H2A
.*       MAKE SURE THAT MAXLEN AND MINLEN WERE NOT SPECIFIED.    * @H2A
.*---------------------------------------------------------------* @H2A
.REFMAX  ANOP                                                      @H2A
         AIF   ('&MAXLEN' EQ '' AND '&MINLEN' EQ '1').RMXMN        @H2A
.*---------------------------------------------------------------* @H2A
.*   MAXLEN OR MINLEN WERE SPECIFIED WITH REFERRAL-> MNOTE IT.   * @H2A
.*---------------------------------------------------------------* @H2A
        MNOTE 4,'MAXLEN AND/OR MINLEN FOR CONVERT=REFERRAL HAVE NO MEAN+
               ING. MAXLEN/MINLEN PARAMETERS ARE PRESET.'          @H2A
.RMXMN   ANOP                                                      @H2A
&MXLTH   SETA  28                                                  @H2A
&MNLTH   SETA  1                                                   @H2A
.*---------------------------------------------------------------*
.*    CHECK TO SEE IF EITHER HIGH OR LOW WERE USED, ASSUMING     *
.*    THAT WHEN BOTH EXTREME VALUES ARE GIVEN THAT THE OPTIONS   *
.*    WERE NOT REALLY SPECIFIED BY THE USER. THIS TEST IS USED   *
.*    BY CHOICE, REFERRAL, AND CHARACTER ROUTINES.               * @H2C
.*---------------------------------------------------------------*
.HILO    ANOP
         AIF   ('&LOW' EQ '0' AND '&HIGH' EQ '2147483647').CKCONL
.*---------------------------------------------------------------* @H1C
.*       HIGH OR LOW WERE SPECIFIED FOR CHOICE, REFERRAL OR      * @H2C
.*             CHAR-> MNOTE IT.                                  * @H1C
.*---------------------------------------------------------------* @H1C
         MNOTE 4,'HIGH/LOW INVALID WITH CONVERT=&CONVERT.. HIGH/LOW PAR+
               AMETER IGNORED.'
.*---------------------------------------------------------------*
.*       CHECK TO SEE IF CONLEN OPTION SPECIFIED                 *
.*---------------------------------------------------------------*
.CKCONL  ANOP
         AIF   ('&CONLEN' EQ '').CONLOK
         AIF   (&F1 EQ 1 OR &F4 EQ 1).CONCHAR   CHAR OR REFERRAL   @H2C
.*---------------------------------------------------------------* @H1C
.*     CONLEN SPECIFIED, NOT USED FOR CHOICE. FOR CHARS          * @H1C
.*     CONVERSION THE CONLEN IS SET TO EQUAL MAXLEN OPTION.      * @H2C
.*     FOR REFERRAL CONVERSION THE CONLEN IS SET TO EQUAL MAXLEN * @H2A
.*     MINUS TWO.                                                * @H2A
.*     GET OUT VIA .BYTEOFF ROUTINE.                             * @H1C
.*---------------------------------------------------------------* @H1C
         MNOTE 4,'CONLEN NOT REQUIRED WITH CONVERT=CHOICE. CONLEN PARAM+
               ETER SET TO ONE'                                    @R4C
         AGO   .CONLOK                                             @R4A
.*---------------------------------------------------------------* @R4A
.*  CONLEN NOT REQUIRED FOR CONVERT=REFERRAL OR CHAR->MNOTE IT.  * @H2C
.*---------------------------------------------------------------* @R4A
.CONCHAR ANOP                                                      @R4A
         MNOTE 4,'CONLEN NOT  REQUIRED WITH  CONVERT=&CONVERT.. CONLEN +
               PARAMETER SET TO MAXLEN KEYWORD PARAMETER.'         @R4A
.CONLOK  ANOP
         AIF   (&F1).LENCLEN     CONLEN FOR CHARACTER              @H2C
         AIF   (&F4).REFCLEN     CONLEN FOR REFERRAL               @H2A
&CLEN    SETA  1             INITIALIZE CONLEN TO ONE FOR CHOICE
         AGO   .BYTEOFF     GO CHECK BYTE OFFSET
.LENCLEN ANOP
&CLEN    SETA  &MXLTH       SET CONLEN TO MAXLEN FOR CHARACTER     @H2C
         AGO   .BYTEOFF     GO CHECK BYTE OFFSET                   @H2A
.REFCLEN ANOP                                                      @H2A
&CLEN    SETA  &MXLTH-2     SET CONLEN TO MAXLEN-2 FOR REFERRAL    @H2A
.*---------------------------------------------------------------*
.*  CHECK TO SEE IF THE CONLEN PLUS BYTE OFFSET STEPS OVER       *
.*    THE 128 BYTE BOUNDARY SIZE.                                *
.*  THERE ARE ONLY 128 BYTES AVAILABLE FOR EACH SCHEDULER WORK   *
.*    BLOCK (SWB), THE LENGTH PLUS THE BYTE OFFSET CANNOT        *
.*    EXCEED THAT AMOUNT.                                        *
.*---------------------------------------------------------------*
.BYTEOFF ANOP
         AIF   (&CLEN+&BYTECTR LE 128).UPDATE                      @H1A
.*---------------------------------------------------------------* @H1A
.*       BYTE OFFSET OVERSTEPPED BOUNDARY OF 128-> RESTART       * @H1A
.*---------------------------------------------------------------* @H1A
.RESTART ANOP                                                      @H1A
&BYTECTR SETA  0                 RESTART OFFSET AT ZERO            @H1A
&BLKID   SETA  &BLKID+1          UPDATE BLOCK ID                   @H1A
.*---------------------------------------------------------------* @H1A
.*                  UPDATE THE BYTE OFFSET COUNTER               * @H1A
.*---------------------------------------------------------------* @H1A
.UPDATE  ANOP                                                      @H1A
&BYTEOFF SETA  &BYTECTR          GET BYTE OFFSET FOR OUTPUT        @H1A
&BYTECTR SETA  &BYTECTR+&CLEN    ADD CONLEN TO BYTE OFFSET
.*---------------------------------------------------------------*
.*  BOUNDARY STILL IN LINE; CHECK KEY AND DEFAULT VALUE FOR KEY  *
.*  OPTIONS. KEY=0000 IS DEFAULT; SPECIFICATION MUST BE          *
.*  0000 TO FFFF. THE FOLLOWING TRUTH TABLE SHOWS THE CHECKING.  *
.*            ×   KEY  × KEYDFLT ×     RESULTS                   *
.*            ×  BLANK ×  BLANK  ×  BOTH OPTIONS SET TO ZEROES   *
.*            ×  NON-B ×  BLANK  ×  CHECKS FOR VALID VALUE       *
.*            ×  BLANK ×  NON-B  ×  WARNS USER NO KEY SPECIFIED  *
.*            ×  NON-B ×  NON-B  ×  CHECKS FOR VALID VALUE       *
.*---------------------------------------------------------------*
.KEYCHK  ANOP
         AIF   ('&KEY' NE '').CONTKEY  IS KEY SPECIFIED?
.*---------------------------------------------------------------*
.*  KEY KEYWORD PARAMETER NOT SPECIFIED -> MNOTE IT.             *
.*---------------------------------------------------------------*
         MNOTE 12,'THE KEY= PARAMETER IS REQUIRED BUT IS NOT SPECIFIED'
&STOP    SETB  1                                                   @R1A
.CONTKEY ANOP
         AIF   ('&KEY' EQ '' AND '&KEYDFLT' EQ '').SKPDYN
         AIF   ('&KEY' NE '' AND '&KEYDFLT' EQ '').TESTDYN
         AIF   ('&KEY' EQ '' AND '&KEYDFLT' NE '').SETDEF
.*---------------------------------------------------------------*
.*  KEY=NON-BLANK AND KEYDFLT=NON-BLANK.                         *
.*  CHECK TO SEE THE CORRECT AMOUNT OF CHARACTERS ARE SPECIFIED. *
.*---------------------------------------------------------------*
&DKY     SETC  '&KEYDFLT'        SET UP DC VARIABLE                @R7M
         AIF   (K'&KEY NE 4).BADKEY      MUST BE 4 HEX DIGITS
&DKEY    SETC  '&KEY'            SET UP DC VARIABLE FOR POSSIBLE USE
         AGO   .CHKDYN           CHECK THE KEY DIGITS              @R8A
.*---------------------------------------------------------------* @R7A
.*       BRANCHES TO HERE FROM .CHKDYN OR .BADKEY ROUTINES VIA   * @R7A
.*       .TESTDYN ROUTINE (DKY WILL = 00) OR BY FALLING THROUGH  * @R7A
.*       THE PREVIOUS CODE (DKY WILL = KEYDFLT).                 * @R7A
.*---------------------------------------------------------------* @R7A
.DODFLT  ANOP                                                      @R8A
         AIF   ('&DKY' EQ '00').CONDEF                             @R7A
         AIF   (&F0 EQ 0).DEFNOTE   MNOTE IF CHOICE NOT SPECIFIED  @R7A
         AIF   (K'&KEYDFLT NE 2).BADDKEY MUST BE 2 HEX DIGITS      @R9C
&D0      SETB  1                 SET DEFAULT KEY BIT ON
         AGO   .CHKDFLT          CHECK THE KEY DEFAULT DIGITS      @R8A
.*---------------------------------------------------------------* @R7A
.*  WHEN KEYDFLT IS SPECIFIED WITH CONVERT=CHAR, INTEGER, HEX,   * @R7A
.*  OR REFERRAL, AN MNOTE IS GIVEN.                              * @H2C
.*---------------------------------------------------------------* @R7A
.DEFNOTE ANOP                                                      @R7A
         MNOTE 4,'KEYDFLT NOT REQUIRED WITH CONVERT=&CONVERT'      @R7A
&DKY     SETC  '00'              SET UP DC VARIABLE                @R7A
         AGO   .CONDEF           CONTINUE PROCESSING               @R7A
.*---------------------------------------------------------------*
.*     CHKDYN ROUTINE CHECKS THE 4 HEX DIGITS TO MAKE SURE THEY  *
.*     ARE 0-9 OR A-F VALID HEX DIGITS.                          *
.*---------------------------------------------------------------*
.CHKDYN  ANOP
         AIF   ('&KEY'(1,1) GE '0' AND '&KEY'(1,1) LE '9' OR           +
               '&KEY'(1,1)  GE 'A' AND '&KEY'(1,1) LE 'F').SECOND
         AGO   .BADKEY
.SECOND  AIF   ('&KEY'(2,1) GE '0' AND '&KEY'(2,1) LE '9' OR           +
               '&KEY'(2,1)  GE 'A' AND '&KEY'(2,1) LE 'F').THIRD
         AGO   .BADKEY
.THIRD   AIF   ('&KEY'(3,1) GE '0' AND '&KEY'(3,1) LE '9' OR           +
               '&KEY'(3,1)  GE 'A' AND '&KEY'(3,1) LE 'F').FOURTH
         AGO   .BADKEY
.FOURTH  AIF   ('&KEY'(4,1) GE '0' AND '&KEY'(4,1) LE '9' OR           +
               '&KEY'(4,1)  GE 'A' AND '&KEY'(4,1) LE 'F').DODFLT  @R8C
.*---------------------------------------------------------------*
.*     BADKEY ROUTINE SAYS THAT AT LEAST ONE OF THE 4 DIGITS IS  *
.*     INVALID OR AN INCORRECT AMOUNT OF CHARACTERS SPECIFIED.   *
.*---------------------------------------------------------------*
.BADKEY  ANOP
         MNOTE 12,'KEY=&KEY INVALID. MUST BE 4 HEX DIGITS.'
&STOP    SETB  1                                                   @R1A
&DKEY    SETC  '0000'            ZERO OUT BAD DEFINITION OF KEY
         AGO   .DODFLT                                             @R8A
.*---------------------------------------------------------------* @R8A
.*   CHKDFLT ROUTINE CHECKS THE 2 HEX DIGITS OF KEY DEFAULT      * @R8A
.*   TO MAKE SURE THEY ARE 0-9 OR A-F VALID HEX DIGITS.          * @R8A
.*---------------------------------------------------------------* @R8A
.CHKDFLT ANOP                                                      @R8A
         AIF   ('&DKY'(1,1) GE '0' AND '&DKY'(1,1) LE '9' OR           +
               '&DKY'(1,1)  GE 'A' AND '&DKY'(1,1) LE 'F').DFLTTWO @R8A
         AGO   .BADDKEY                                            @R8A
.DFLTTWO AIF   ('&DKY'(2,1) GE '0' AND '&DKY'(2,1) LE '9' OR           +
               '&DKY'(2,1)  GE 'A' AND '&DKY'(2,1) LE 'F').CONDEF  @R8A
.*---------------------------------------------------------------* @R8A
.*       BAD DEFAULT KEY ROUTINE SAYS THAT AT LEAST ONE OF THE 2 * @R8A
.*       DIGITS IS INVALID OR AN INCORRECT AMOUNT OF CHARACTERS  * @R8A
.*       SPECIFIED.                                              * @R8A
.*---------------------------------------------------------------* @R8A
.BADDKEY ANOP                                                      @R9C
         MNOTE 12,'KEYDFLT=&KEYDFLT INVALID.  MUST BE TWO HEX DIGITS.'
&STOP    SETB  1                                                   @R1A
&DKY     SETC  '00'              ZERO OUT BAD DEFAULT KEY
&D0      SETB  0                 RESET DEFAULT KEY BIT             @R8A
.*---------------------------------------------------------------*
.*  WHEN KEYDFLT IS SPECIFIED IT IS EXPECTED THAT KEY IS ALSO    *
.*---------------------------------------------------------------*
.SETDEF  ANOP                    KEY=BLANK AND KEYDFLT=NON-BLANK
         AIF   (&F0 EQ 0).NOTEDEF   MNOTE IF CHOICE NOT SPECIFIED  @H1C
         MNOTE 12,'KEY NOT SPECIFIED. DEFAULT KEY IGNORED'
&STOP    SETB  1                                                   @R1A
         AGO   .SKPDYN                                             @R7A
.*---------------------------------------------------------------* @R7A
.*  WHEN KEYDFLT IS SPECIFIED WITH CONVERT=CHAR, INTEGER, HEX,   * @R7A
.*  OR REFERRAL AN MNOTE IS GIVEN.                               * @H2C
.*---------------------------------------------------------------* @R7A
.NOTEDEF ANOP                                                      @R7A
         MNOTE 4,'KEYDFLT NOT REQUIRED WITH CONVERT=&CONVERT'      @R7A
         AGO   .SKPDYN                                             @R7A
.*---------------------------------------------------------------*
.*   CHECK TO SEE THE CORRECT AMOUNT OF CHARACTERS ARE SPECIFIED *
.*---------------------------------------------------------------*
.TESTDYN ANOP                    KEY=NON-BLANK AND KEYDFLT=BLANK
&DKY     SETC  '00'              ZERO OUT DEFAULT KEY; NOT USED    @RAA
         AIF   (K'&KEY NE 4).BADKEY      MUST BE 4 HEX DIGITS
&DKEY    SETC  '&KEY'            SET UP DC VARIABLE FOR POSSIBLE USE
         AGO   .CHKDYN           CHECK VALUE OF KEY
.SKPDYN  ANOP                    KEY=BLANK AND KEYDFLT=BLANK OR ERROR
&DKEY    SETC  '0000'            ZERO OUT KEY
&DKY     SETC  '00'              ZERO OUT DEFAULT KEY
.CONDEF  ANOP
         DC    XL2'&BLKID'       BLOCK ID                          @H1A
         DC    XL2'&DKEY'        KEY FOR THIS PARAMETER
         DC    XL1'&DKY'         DEFAULT VALUE FOR KEY
         DC    XL1'01'           VERSION NUMBER OF JDPARM SECTION
         DC    HL1'&MXLTH'       MAXIMUM LENGTH OF PARAMETER       @H1C
         DC    HL1'&MNLTH'       MINIMUM LENGTH OF PARAMETER       @H1A
         DC    HL1'&CLEN'        CONVERSION LENGTH
         DC    HL1'&BYTEOFF'     BYTE OFFSET INTO SCHEDULER WORK BLOCK
******************************************************************
*        CONVERSION BIT FLAG BYTE-                               *
*        THE BITS ARE: BIT   DESCRIPTION                         *
*                       0-   IF ON-CHOICE CONVERSION             *
*                       1-   IF ON-CHARACTER CONVERSION          *
*                       2-   IF ON-INTEGER CONVERSION            *
*                       3-   IF ON-HEX CONVERSION                * @H1A
*                       4-   IF ON-REFERRAL CONVERSION           * @H2C
******************************************************************
         DC    BL1'&F0&F1&F2&F3&F4.000'                            @H1C
******************************************************************
*        SUBLIST BIT FLAG BYTE-                                  *
*        THE BITS ARE: BIT   DESCRIPTION                         *
*                       0-   IF ON-THIS IS A SUBLIST             *
*                       1-   IF ON-THIS IS 1ST ELEMENT OF SUBLIST*
*                       2-   IF ON-THIS IS A LIST ITEM PARAMETER * @H3A
*                       3-   IF ON-THIS IS A LIST ITEM SUBLIST   * @H3A
******************************************************************
         DC    BL1'&S0&S1&L2&L3.0000'                              @H3A
******************************************************************
*        DEFAULT BIT FLAG BYTE-                                  *
*        THE BIT IS:   BIT   DESCRIPTION                         *
*                       0-   IF ON-DYNAMIC DEFAULT KEY           *
******************************************************************
         DC    BL1'&D0.0000000'  DEFAULT FLAG BYTE
****************************************************************** @H2A
*        FSTCHAR AND OTHCHAR BIT FLAG BYTES-                     * @H2A
*        THE BIT IS:   BIT   DESCRIPTION                         * @H2A
*                       0-   IF ON-ALL CHARACTERS ALLOWED        * @H2A
*                       1-   IF ON-ALPHABETIC CHARACTERS ALLOWED * @H2A
*                       2-   IF ON-NUMERIC CHARACTERS ALLOWED    * @H2A
*                       3-   IF ON-NATIONALS (@,#,$) ALLOWED     * @H2A
*                       4-   IF ON-SPECIAL CHARACTERS ALLOWED    * @H3A
****************************************************************** @H2A
         DC    BL1'&C0&C1&C2&C3&C4.000' FSTCHAR FLAG BYTE          @H3A
         DC    BL1'&O0&O1&O2&O3&O4.000' OTHCHAR FLAG BYTE          @H3A
         DC    XL1'00'           RESERVED BYTE                     @H2C
.*---------------------------------------------------------------*
.*       CHECK TO SEE WHAT BIT IS ON.                            *
.*---------------------------------------------------------------*
         AIF   (&F0 EQ 1).CHCDATA    CHOICE DATA
         AIF   (&F1 EQ 1).CHRDATA    CHARACTER DATA                @H2C
         AIF   (&F2 EQ 1).NUMDATA    INTEGER DATA
         AIF   (&F3 EQ 1).HEXDATA    HEX DATA                      @H1A
         AGO   .ENDLTH               MUST BE REFERRAL DATA         @H2C
.*---------------------------------------------------------------* @H1A
.*       SETUP AREA OF CHARACTER DATA.                           * @H2C
.*---------------------------------------------------------------* @H1A
.CHRDATA DC    HL1'&LVNUM'       MAXIMUM NUMBER OF LEVELS          @H2C
         DC    HL1'&LVLEN'       MAXIMUM LENGTH OF EACH LEVEL      @H1A
         DC    XL2'0000'         RESERVED                          @H1A
         AIF   (&C4 EQ 0).NOFSP  NO FIRST SPECIAL CHARACTERS?      @H3A
         DC    FL1'&#FSPEC'      NUMBER FIRST SPECIAL CHARACTERS   @H3A
         DC    CL&#FSPEC.'&FALL'        LIST OF FIRST SPECIAL CHAR @H3A
         AIF   (&#FSPEC EQ 16).OTHER                               @H3A
         DC    XL&FPAD.'00'                                        @H3A
         AGO   .OTHER                                              @H3A
.NOFSP   ANOP                                                      @H3A
         DC    FL1'0'            NUMBER FIRST SPECIAL CHARACTERS   @H3A
         DC    XL16'00'          LIST OF FIRST SPECIAL CHARACTERS  @H3A
.OTHER   ANOP                                                      @H3A
         AIF   (&O4 EQ 0).NOOSP  NO OTHER SPECIAL CHARACTERS?      @H3A
         DC    FL1'&#OSPEC'      NUMBER OTHER SPECIAL CHARACTERS   @H3A
         DC    CL&#OSPEC.'&OALL'        LIST OF OTHER SPECIAL CHAR @H3A
         AIF   (&#OSPEC EQ 16).RESERVE                             @H3A
         DC    XL&OPAD.'00'                                        @H3A
         AGO   .RESERVE                                            @H3A
.NOOSP   ANOP                                                      @H3A
         DC    FL1'0'            NUMBER OTHER SPECIAL CHARACTERS   @H3A
         DC    XL16'00'          LIST OF OTHER SPECIAL CHARACTERS  @H3A
.RESERVE ANOP                                                      @H3A
         DC    XL2'00'           RESERVED                          @H3A
         AGO   .ENDLTH                                             @H1A
.*---------------------------------------------------------------*
.*       SETUP AREA OF INTEGER AND HEX DATA.                     *
.*---------------------------------------------------------------*
.HEXDATA DC    XL4'&HHGH'        HIGH RANGE OF HEX DATA            @H1A
         DC    XL4'&HLOW'        LOW RANGE OF HEX DATA             @H1A
         AGO   .ENDLTH                                             @H1A
.NUMDATA DC    F'&PHGH'          HIGH RANGE OF INTEGER DATA
         DC    F'&PLOW'          LOW RANGE OF INTEGER DATA
         AGO   .ENDLTH
.*---------------------------------------------------------------* @R6A
.* CHOICE SYMBOL SCANNING COMES HERE TO CHECK FOR ANY ERROR BITS.* @R6A
.* IF ANY ARE ON, THEN THE APPROPRIATE MNOTE IS ISSUED.          * @R6A
.*---------------------------------------------------------------* @R6A
.JDSCAN  ANOP                                                      @R6A
         AIF   (&$ERRBAD EQ 1).BADCHC    INVALID CHARACTERS        @R6A
         AIF   (&$ERRBIG EQ 1).BIGCHC    GREATER THAN 8 CHARACTERS @R6A
.*---------------------------------------------------------------* @R6A
.*  THE SYMBOL FOR THE CHOICE SELECTED WAS SPECIFIED CORRECTLY.  * @R6A
.*  RETURN TO THE BRANCHED-FROM CHOICE PROCESSING.               * @R6A
.*---------------------------------------------------------------* @R6A
.SCANOK  ANOP                                                      @R6A
         AIF   (&CTR EQ 1).SCAN1         CHECK-                    @R6A
         AIF   (&CTR EQ 2).SCAN2             -EACH-                @R6A
         AIF   (&CTR EQ 3).SCAN3                 -CHOICE           @R6A
         AIF   (&CTR EQ 4).SCAN4                                   @R6A
         AIF   (&CTR EQ 5).SCAN5                                   @R6A
         AIF   (&CTR EQ 6).SCAN6                                   @R6A
         AIF   (&CTR EQ 7).SCAN7                                   @R6A
         AGO   .SCAN8                                              @R6A
.*---------------------------------------------------------------* @R6A
.*  THE SYMBOL FOR THE CHOICE SELECTED HAS INVALID CHARACTERS.   * @R6A
.*---------------------------------------------------------------* @R6A
.BADCHC ANOP                                                       @R6A
&ERRSW   SETB  1                 ERROR SWITCH SET FOR LATER USE    @R6A
         MNOTE 12,'&CHOICE# SPECIFIES INVALID CHARACTERS'          @R6A
&STOP    SETB  1                                                   @R1A
         AGO   .SCANBAD                                            @R6A
.*---------------------------------------------------------------* @R6A
.*  THE SYMBOL FOR THE CHOICE SELECTED EXCEEDS 8 CHARACTERS.     * @R6A
.*---------------------------------------------------------------* @R6A
.BIGCHC  ANOP                                                      @R6A
         MNOTE 12,'&CHOICE# SPECIFICATION EXCEEDS 8 CHARACTERS'    @R6M
&ERRSW   SETB  1                 ERROR SWITCH SET FOR LATER USE    @R6A
&STOP    SETB  1                                                   @R1A
         AGO   .SCANBAD                                            @R6A
.*---------------------------------------------------------------*
.*       SETUP AREA OF CHOICE DATA.                              *
.*---------------------------------------------------------------*
.CHCDATA ANOP
         AIF   ('&CH1' EQ '0').XLCH1
         DC    CL8'&CH1'         CHARACTER STRING FOR CHOICE ONE
         DC    XL1'&VAL1'        HEXADECIMAL DIGIT FOR VALUE ONE
         AGO   .CKCH2
.XLCH1   ANOP
         DC    XL8'00'           CHOICE ONE NOT USED
         DC    XL1'00'           VALUE ONE NOT USED
.CKCH2   AIF   ('&CH2' EQ '0').XLCH2
         DC    CL8'&CH2'         CHARACTER STRING FOR CHOICE TWO
         DC    XL1'&VAL2'        HEXADECIMAL DIGIT FOR VALUE TWO
         AGO   .CKCH3
.XLCH2   ANOP
         DC    XL8'00'           CHOICE TWO NOT USED
         DC    XL1'00'           VALUE TWO NOT USED
.CKCH3   AIF   ('&CH3' EQ '0').XLCH3
         DC    CL8'&CH3'         CHARACTER STRING FOR CHOICE THREE
         DC    XL1'&VAL3'        HEXADECIMAL DIGIT FOR VALUE THREE
         AGO   .CKCH4
.XLCH3   ANOP
         DC    XL8'00'           CHOICE THREE NOT USED
         DC    XL1'00'           VALUE THREE NOT USED
.CKCH4   AIF   ('&CH4' EQ '0').XLCH4
         DC    CL8'&CH4'         CHARACTER STRING FOR CHOICE FOUR
         DC    XL1'&VAL4'        HEXADECIMAL DIGIT FOR VALUE FOUR
         AGO   .CKCH5
.XLCH4   ANOP
         DC    XL8'00'           CHOICE FOUR NOT USED
         DC    XL1'00'           VALUE FOUR NOT USED
.CKCH5   AIF   ('&CH5' EQ '0').XLCH5
         DC    CL8'&CH5'         CHARACTER STRING FOR CHOICE FIVE
         DC    XL1'&VAL5'        HEXADECIMAL DIGIT FOR VALUE FIVE
         AGO   .CKCH6
.XLCH5   ANOP
         DC    XL8'00'           CHOICE FIVE NOT USED
         DC    XL1'00'           VALUE FIVE NOT USED
.CKCH6   AIF   ('&CH6' EQ '0').XLCH6
         DC    CL8'&CH6'         CHARACTER STRING FOR CHOICE SIX
         DC    XL1'&VAL6'        HEXADECIMAL DIGIT FOR VALUE SIX
         AGO   .CKCH7
.XLCH6   ANOP
         DC    XL8'00'           CHOICE SIX NOT USED
         DC    XL1'00'           VALUE SIX NOT USED
.CKCH7   AIF   ('&CH7' EQ '0').XLCH7
         DC    CL8'&CH7'         CHARACTER STRING FOR CHOICE SEVEN
         DC    XL1'&VAL7'        HEXADECIMAL DIGIT FOR VALUE SEVEN
         AGO   .CKCH8
.XLCH7   ANOP
         DC    XL8'00'           CHOICE SEVEN NOT USED
         DC    XL1'00'           VALUE SEVEN NOT USED
.CKCH8   AIF   ('&CH8' EQ '0').XLCH8
         DC    CL8'&CH8'         CHARACTER STRING FOR CHOICE EIGHT
         DC    XL1'&VAL8'        HEXADECIMAL DIGIT FOR VALUE EIGHT
         AGO   .ENDLTH
.XLCH8   ANOP
         DC    XL8'00'           CHOICE EIGHT NOT USED
         DC    XL1'00'           VALUE EIGHT NOT USED
.*---------------------------------------------------------------*
.*       END PARAMETER DEFINITIONS                               *
.*---------------------------------------------------------------*
.ENDLTH  ANOP
E&LEN    EQU   *                 END JDPARM LENGTH DEFINITION
.*---------------------------------------------------------------*
.*       CHECK TO SEE IF REPEAT OPTION WAS PREVIOUSLY SPECIFIED  *
.*---------------------------------------------------------------*
         AIF   (&REPSW EQ 1).REPON
.*---------------------------------------------------------------*
.*       REPEAT SPECIFIED, CHECK RANGE, MUST BE 0 TO 127.        *
.*---------------------------------------------------------------*
         AIF   (&REPEAT GE 0 AND &REPEAT LE 127).REPOK
.*---------------------------------------------------------------*
.*       REPEAT HAS INVALID VALUE-> MNOTE IT.                    *
.*---------------------------------------------------------------*
         MNOTE 12,'REPEAT=&REPEAT INVALID.  MUST BE 0 TO 127 DECIMAL.'
         AGO   .NOREP
.*---------------------------------------------------------------*
.*       REPEAT OPTION OK                                        *
.*---------------------------------------------------------------*
.REPOK   ANOP
&REPSW   SETB  1                 SET REPEAT SWITCH ON
&COUNT   SETA  &REPEAT           START COUNTER VALUE FROM REPEAT OPTION
.REPON   ANOP
.*---------------------------------------------------------------*
.*       CHECK TO SEE IF THE COUNTER RAN OUT (EQUAL ZERO)        *
.*       OR IF AN ERROR MNOTE HAS BEEN ISSUED--STOP PROCESSING.  * @H2A
.*---------------------------------------------------------------*
         AIF   (&COUNT EQ 0 OR &STOP EQ 1).NOREP                   @R1C
&COUNT   SETA  &COUNT-1          DECREMENT COUNTER FOR NEXT REPEAT
.*---------------------------------------------------------------* @H2A
.*       RESET FSTCHAR AND OTHCHAR BITS FOR REPEAT.              * @H2A
.*---------------------------------------------------------------* @H2A
&C0      SETB  0                                                   @H2A
&C1      SETB  0                                                   @H2A
&C2      SETB  0                                                   @H2A
&C3      SETB  0                                                   @H2A
&O0      SETB  0                                                   @H2A
&O1      SETB  0                                                   @H2A
&O2      SETB  0                                                   @H2A
&O3      SETB  0                                                   @H2A
         AGO   .REPEAT           GO REPEAT MACRO
.*---------------------------------------------------------------*
.*       REPEAT OPTION NOT USED OR COUNTER RAN OUT (EQUAL ZERO)  *
.*---------------------------------------------------------------*
.NOREP   ANOP
&REPSW   SETB  0                 RESET REPEAT SWITCH
         SPACE
         MEND
