         MACRO
&TAG  RPTDSECT &T=,&TYPE=,&LIST=,&SCAN=,&GEN=,&DS=NO
         GBLC  &IGAHVFC  THE OFFSET IN THE RPT HEADER TO THE ADDRESS OF*
                         THE FIXEDHDR FOR THE INNER VERTEX SPACE CHAIN.
         GBLC  &IGABLST  THE OFFSET INTO THE TREE HEADER FOR THE LIST  *
                         OF RPT ENTRY POINTS.
         GBLC  &IGAGKW   THE OFFSET IN THE IGARPT01 MODULE TO THE      *
                         ROUTINE TO GET A WORK AREA FOR COLLECTING     *
                         KEYS.
         GBLC  &IGABFIN  THE SIZE OF THE RESERVED LIST OF ENTRY POINT  *
                         ADDRESSES IN THE TREE HEADER.
         GBLC  &IGASCH8  THE OFFSET IN THE RPT MODULE FOR THE TYPE 8   *
                         SEARCH ROUTINE.
         GBLC  &IGADEL8  THE OFFSET IN THE IGARPT01 MODULE TO THE TYPE *
                         8 RPT DELETE ROUTINE.
         GBLC  &IGAINS8  THE OFFSET IN THE MODULE IGARPT01 TO THE      *
                         ROUTINE TO INSERT IN A TYPE 8 RPT.
         GBLC  &IGALSCN  THE OFFSET TO THE ROUTINE TO SCAN LEFT IN THE *
                         MODULE IGARPT01.
         GBLC  &IGARSCN  THE OFFSET TO THE ROUTINE TO SCAN RIGHT IN THE*
                         MODULE IGARPT01.
         GBLC  &IGASPV   THE OFFSET TO THE PARTIAL ORDER SEARCH ROUTINE*
                         IN THE MODULE IGARPT01.
         GBLC  &IGAPVG   THE OFFSET TO THE ROUTINE TO GET THE PARTIAL  *
                         ORDER VALUE FOR THE CURRENT SINK IN THE MODULE*
                         IGARPT01.
         GBLC  &IGAPVAJ   THE OFFSET TO THE ROUTINE TO ADJUST THE      *
                         PARTIAL ORDER VALUE FOR THE CURRENT SINK IN   *
                         THE IGARPT01 MODULE.
         GBLC  &IGADSP8  THE OFFSET TO THE ROUTINE TO DISPLAY A TYPE 8 *
                         RPT IN THE MODULE IGARPT01.
         GBLC  &IGASRCH,&IGAINS,&IGADEL,&IGAFTRE
         GBLC  &IGAKEYW  THE INDEX OF THE ADDRESS OF THE ROUTINE TO GET*
                         A WORK AREA FOR COLLECTING KEYS FOR SEARCH.
         GBLC  &IGASCNL,&IGASCNR,&IGAFSP
         GBLC  &IGAFSPS  OFFSET FOR THE BRANCH ENTRY TO THE FSPACE     *
                         PROGRAM WHEN THE SPACE CONTROL ADDRESS IS     *
                         CODED IN THE FSPACE MACRO-INSTRUCTION.
         GBLC  &IGAFSPF  BRANCH ENTRY OFFSET FOR FSPACE WITH A FIXED   *
                         LENGTH ENTRY USING A FIXEDHDR.
         GBLC  &IGAFS8,&IGAFS12,&IGAFS80  THE ENTRY POINTS TO RELEASE  *
               ENTRIES OF THE RESPECTIVE LENGTHS USING THE FIXEDHDR IN *
               A SPACE CONTROL AREA.
         GBLC  &IGASTRE,&IGAGSP
         GBLC  &IGAINS5,&IGADEL5
         GBLC  &IGAEOPV  THE OFFSET TO THE PATH CODE BYTE IN THE TYPE 8*
                         RPT HEADER FOR THE PATH TO THE SINK CURRENTLY *
                         SELECTED BY THE CURSOR.
         GBLC  &IGACNT5  THE OFFSET TO THE USE COUNTER IN THE TYPE 5   *
                         RPT HEADER.
         GBLC  &IGAMSK5  THE OFFSET TO THE TABLE OF MASKS FOR TYPE 5   *
                         RPT.
         GBLC  &IGATOP5  THE OFFSET TO THE RPT SOURCE IN THE TYPE 5 RPT*
                         HEADER.
         GBLC  &IGAMAX   THE OFFSET TO THE WORD CONTAINING THE MAXIMUM *
                         PARTIAL ORDER VALUE.
         GBLC  &IGADJPV    ENTRY OFFSET FOR PARTIAL ORDER ADJUSTMENT.
         GBLC  &IGAPVS     ENTRY POINT FOR PARTIAL ORDER SEARCH.
         GBLC  &IGAGPV     ENTRY OFFSET FOR GETTING PARTIAL ORDER VALUE
         GBLC  &IGAISP   BRANCH ENTRY OFFSET FOR SPACE CONTROL SETUP.
         GBLC  &IGAFRSC  BRANCH ENTRY OFFSET TO THE ROUTINE TO RELEASE *
                         A SPACE CONTROL AREA AND ALL OF ITS RELATED   *
                         SPACE VIA THE FREEMAIN MACRO-INSTRUCTION.
         GBLC  &IGAGSPF  BRANCH ENTRY OFFSET FOR FIXED LENGTH ENTRIES  *
                         USING A FIXEDHDR FROM THE GSPACE MACRO OR FROM*
                         INSIDE THE MODULE IGARPT01.
         GBLC  &IGAGSPS  BRANCH ENTRY OFFSET FOR VARIABLE LENGTH SPACE *
                         ALLOCATION WHEN THE SPACE CONTROL ADDRESS IS  *
                         CODED IN THE GSPACE MACRO-INSTRUCTION.
         GBLC  &IGAGS8,&IGAGS12,&IGAGS80  THE BRANCH ENTRY OFFSETS FOR *
                         THE ROUTINES TO ALLOCATE SPACE FOR THE        *
                         RESPECTIVE FIXED LENGTHS IN A SPACE CONTROL A.
         GBLC  &IGACON   THE OFFSET TO THE CONTANT AREA.
         GBLC  &IGANAME    THE NAME OF THE PROGRAM.
         GBLC  &IGADSP         BRANCH ENTRY FOR DSPRPT.
         GBLC  &IGAISCN  THE INDEX OF THE ADDRESS OF THE ROUTINE TO USE*
                         IN THE MODULE IGARPT01 TO INITIALIZE FOR      *
                         SUBSEQUENT SCANNING OPERATIONS FOR SOME RPT'S.
         GBLC  &IGADDR   THE OFFSET TO THE ADDRESS OF THE MODULE       *
                        IGARPT01 FROM THE BEGINNING OF THE TREE HEADER.
         GBLA  &IGALEFT(256)  GLOBAL INDEXED VARIABLE FOR LEFT EDGES
.*                             IN THE BINARY PARSE TREE.
         GBLA  &IGARGHT(256)   GLOBAL VECTOR FOR RIGHT EDGES.
         GBLB  &IGARL(256)     GLOBAL VECTOR FOR RIGHT/LEFT FLAGS.
         GBLB  &IGAIS(256)     GLOBAL VECTOR FOR INNER/SINK STATUS.
         GBLA  &IGAPATH(16)  PATH VECTOR TO ATOMIC ELEMENT IN PARSE.
         GBLA  &IGALEVL      PATH LENGTH TO ATOM IN PARSE TREE.
         GBLB  &IGAOKAY  GLOBAL FOR INDICATING VALID SYNTAX.
         GBLB  &IGAPGM   FOR USE IN IGARPTXX MODULES ONLY.
         GBLB  &IGALOAD  1 IF PGM IS LOADED VIA LOAD MACRO.
         GBLB  &IGAXTRN  1 IF THE EXTRN HAS BEEN GENERATED.
         GBLB  &IGALONE  ON FOR STAND-ALONE OPERATION OF THE RPTS      *
               COMPONENT FOR UNIT TESTING.
         GBLB  &IGAFTCH  ON TO FAKE OUT THE CVTRPT AND TCBRPT LOADS    *
                         WHEN THE RPTS COMPONENT IS BEING UNIT TESTED.
         GBLC  &IGARPT#  RADIX PARTITION TREE TYPE.
         GBLB  &RPTVNUM(16)    INDEXED GLOBAL LOGICAL VECTOR FOR C
.*                             CONTROLLING THE GENERATION OF DSECTS.
         GBLB  &IGASPDS  THIS BIT IS ON IF THE SPACE CONTROL DSECT HAS *
                         ALREADY BEEN GENERATED.
         GBLC  &IGASA0   OFFSET TO THE FIRST SAVE AREA.
         GBLC  &IGASA1   OFFSET TO THE SECOND SAVE AREA IN THE SPACE   *
                         CONTROL AREA.
         GBLC  &IGAS8    THE OFFSET TO THE 8-BYTE FREE SPACE CHAIN.
         GBLC  &IGAS12   THE OFFSET TO THE 12-BYTE FREE SPACE CHAIN.
         GBLC  &IGAS80   THE OFFSET TO THE 80-BYTE FREE SPACE CHAIN.
         GBLC  &IGASPZ   LENGTH OF THE SPACE CONTROL AREA.
         GBLA  &IGAMINP  THE MINIMUM SIZE NEEDED FOR A TYPE 8 TREE.
         GBLA  &IGAMINS  THE MINIMUM REFILL SIZE NEEDED FOR A TYPE 8.
         GBLA  &IGAX     TRIPLE FOR LEFT LIST SCAN OF THE BINARY PARSE
         GBLA  &IGAY     TREE THAT RESULTS FROM EXECUTING RPTDSECT WITH
         GBLA  &IGAZ     THE LIST PARAMETER CODED.
         LCLA  &N        A LOCAL TEMPORARY INDEX FOR SUBSCRIPTING
.*                       INDEXED VARIABLES.
.*A000000                                                        Y02147
.**********************************************************************
         LCLA  &X        STRING SCANNER.
         LCLA  &Y        LIMIT OF NUMBER OF ELEMENTS.
         LCLC  &CHAR     CURRENT LIST CHARACTER.
         LCLA  &P        PREDECESSOR OF CURRENT VERTEX IN PARSE TREE.
         LCLA  &C        CURRENT VERTEX IN PARESE TREE.
         LCLA  &S        SUCCESSOR OF CURRENT VERTEX IN PARSE TREE.
         LCLA  &NX       INDEX OF NEXT AVAILABLE VERTEX.
&IGAXTRN SETB  (0)   TURN OFF THE EXTRN SYMBOL IN STREE.
         AIF   (K'&GEN NE 0).GEN  GO IF THE GEN PARAMETER IS CODED.
         AIF   (K'&T EQ 0).OLDT  SEE IF THE NEW TYPE IS CODED.
&TAG  RPTDSECT TYPE=&T,LIST=&LIST,SCAN=&SCAN,DS=&DS,GEN=&GEN
         AGO   .FIN
.OLDT    ANOP
         AIF   (K'&TAG EQ 0).NOTAG  SEE IF THERE IS A LABEL ON IT.
&TAG     EQU   *
.NOTAG   ANOP
         AIF   ((K'&SCAN NE 0) OR (K'&TYPE NE 0)).GOOD  CHK 4 AT LEAST
.*                                                   1 OPERAND.
         MNOTE 12,'NO KEYWORDS CODED FOR RPTDSECT; &SCAN CODED.'
         MEXIT
.GOOD    ANOP
&IGARPT# SETC  '&TYPE'   SET THE RPT #.
         AIF   (K'&TYPE NE 0).VERSION  CHECK FOR RPT TYPE.
         AIF   (('&SCAN' EQ 'NEXT')OR('&SCAN' EQ 'ISCAN')).ITSCAN
         AIF   ('&SCAN' EQ 'PARSE').PARSE          CHECK FOR PARSE REQ.
         MNOTE 12,'SCAN PARAMTER INCORRECT IN RPTDSECT; &SCAN CODED.'
         MEXIT
.PARSE   ANOP
.*--------------------------------------------------------------------*
.*       PARSE THE LIST INTO A BINARY PARSE TREE.                     *
.*--------------------------------------------------------------------*
&X       SETA  (1)       SET &X TO THE INDEX OF THE FIRST CHARACTER IN
.*                       THE STRING TO BE PARSED.
&Y       SETA  (1+K'&LIST)     SET &Y TO THE INDEX OF THE FIRST
.*                             CHARACTER POSITION AFTER THE LAST
.*                             CHARACTER IN THE STRING TO BE PARSED.
&P       SETA  1         SET &P TO THE SOURCE OF THE PARSE TREE.
&C       SETA  1         SET &C TO THE SOURCE OF THE PARSE TREE.
&NX      SETA  1         SET &NX TO ONE LESS THAN THE NEXT AVAILABLE
.*                       VERTEX.
&IGARL(&C)     SETB      (0)   SET THE SOURCE TO A LEFT SUCCESSOR.
&IGAIS(&C)     SETB      (1)   SET THE SOURCE AS AN INNER VERTEX.
.**********************************************************************
.*       IS THERE A LEFT EDGE FROM THE CURRENT VERTEX?                *
.**********************************************************************
.ISLEFT  ANOP
         AIF   (&X EQ &Y).LEOS GO IF THE END OF STRING REACHED.
&CHAR    SETC  '&LIST'(&X,1)   EXTRACT THE CURRENT CHARACTER.
&X       SETA  (&X+1)          EKE THE INDEX TO THE NEXT CHARACTER.
         AIF   ('&CHAR' EQ '(').LLPAREN  AGO IF LEFT PAREN FOUND.
         AIF   ('&CHAR' EQ ')').LRPAREN  AGO IF RIGHT PAREN FOUND.
         AIF   ('&CHAR' EQ ',').LCOMMA   AGO IF COMMA FOUND.
.*--------------------------------------------------------------------*
.* THE LEFT EDGE GOES TO AN ATOMIC SYMBOL, COLLECT THE SYMBOL AND PUT *
.* THE LEFT EDGE OF THE CURRENT VERTEX GOING TO IT.                   *
.*--------------------------------------------------------------------*
&NX      SETA  (1+&NX)   ESTABLISH PLACE TO PUT THE DEFINITION OF ATOM.
&IGALEFT(&NX) SETA (&X-1)      INDEX OF FIRST CHARACTER OF ATOM.
.COLLECT ANOP
         AIF   (&X EQ &Y).STORE2       SEE IF EOS AFTER ATOM.
&CHAR    SETC  '&LIST'(&X,1)   PICK OUT THE NEXT CHARACTER.
&X       SETA  (&X+1)    EKE INDEX TO NEXT CHARACTER.
         AIF   ('&CHAR' EQ '(').STORE  AGO IF ATOM ALL COLLECTED.
         AIF   ('&CHAR' EQ ')').STORE  AGO IF ATOM ALL COLLECTED.
         AIF   ('&CHAR' NE ',').COLLECT  AGO IF ATOM NOT YET COLLECTED.
.STORE   ANOP
&IGARGHT(&NX) SETA (&X-(1+&IGALEFT(&NX)))  COMPUTE LENGTH OF ATOM.
&IGALEFT(&C) SETA (&NX-&P)  FILL IN LEFT EDGE TO ATOM.
&IGARL(&NX) SETB (0)     FLAG AS LEFT SUCCESSOR.
&IGAIS(&NX)  SETB (0)    FLAG AS A SINK.
         AGO   .RIGHTIN        INTERROGATE CHARACTER.
.STORE2  ANOP
&IGARGHT(&NX) SETA (&X-(&IGALEFT(&NX)))  COMPUTE LENGTH OF ATOM.
&IGALEFT(&C) SETA (&NX-&P)     FILL IN LEFT EDGE TO ATOM.
&IGARL(&NX) SETB (0)     FLAG ATOMIC VERTEX AS LEFT SUCCESSOR.
&IGAIS(&NX) SETB (0)     FLAG ATOMIC VERTEX AS A SINK.
         AGO   .REOS     GO TO RIGHT EOS SEQUENCE.
.*--------------------------------------------------------------------*
.* THE LEFT EDGE GOES TO AN EMPTY LIST, SINCE THE CURRENT CHARACTER   *
.* IS A COMMA.                                                        *
.*--------------------------------------------------------------------*
.LCOMMA  ANOP
&IGALEFT(&C) SETA (0-&P)  SET THE LEFT EDGE EMPTY.
         AGO   .MAKRGHT        GO ESTABLISH A RIGHT SUCCESSOR.
.*--------------------------------------------------------------------*
.* THERE IS A LIST FOR THE LEFT SUCCESSOR, BECAUSE THE CURRENT        *
.* CHARACTER IS A LEFT PARENTHESIS.                                   *
.*--------------------------------------------------------------------*
.LLPAREN ANOP
&NX      SETA  (&NX+1)   ESTABLISH A LEFT SUCCESSOR INNER VERTEX.
&IGARL(&NX) SETB (0)  MAKE NEW INNER VERTEX A LEFT SUCCESSOR.
&IGAIS(&NX) SETB (1)  MAKE NEW VERTEX AN INNER VERTEX.
&IGALEFT(&C) SETA (&NX-&P)     FILL IN LEFT SUBTRACTION INVERTIBLE EDGE
.*                             TO THE NEW LEFT INNER VERTEX.
&P       SETA  (&C)      TRACE THE EDGE TO THE NEW LEFT INNER VERTEX.
&C       SETA  (&NX)     XX
         AGO   .ISLEFT   GO BACK TO LOOK FOR A LEFT EDGE.
.*--------------------------------------------------------------------*
.* THERE IS NO LEFT EDGE, BECAUSE THE CURRENT CHARACTER IS A RIGHT    *
.* PARENTHESIS. NOW THE BACKPATH MUST BE TRACED TO THE MATCHING LEFT  *
.* PARENTHESIS.                                                       *
.*--------------------------------------------------------------------*
.LRPAREN ANOP
&IGALEFT(&C) SETA (0-&P)  SET LEFT INVERTIBLE SUBTRACTION EDGE EMPTY.
.RRPAREN ANOP
&IGARGHT(&C) SETA (0-&P)  ESTABLISH A NULL RIGHT EDGE TOO.
.*--------------------------------------------------------------------*
.* TRACE THE BACKPATH TO FIND THE FIRST LEFT SUCCESSOR ON THE WAY TO  *
.* THE SOURCE. THAT VERTEX SHOULD BE THE PREDECESSOR OF THE FIRST     *
.* VERTEX IN THE SUBLIST THAT STARTED WITH THE LEFT PARENTHESIS THAT  *
.* MATCHED THE CUURENT RIGHT PARENTHESIS.                             *
.*--------------------------------------------------------------------*
         AIF   (NOT &IGARL(&C)).RPISBAK  GO IF &C IS A LEFT SUCCESSOR.
.RPBACK  ANOP
&S       SETA  (&C)      CYCLE THE THREE VERTICES UP THE BACKPATH.
&C       SETA  (&P)      XX
&P       SETA  (&S-&IGARGHT(&C))  TRACE THE RIGHT EDGE BACKWARD.
         AIF   (&IGARL(&C)).RPBACK     TRACE UNTIL IT FINDS A LEFT SIDE
.*--------------------------------------------------------------------*
.RPISBAK ANOP
         AIF   (&C EQ 1).ERROR  SEE IF THE SOURCE WAS REACHED; I. E.
.*                              NO MATCHING LEFT PARENTHESIS.
&S       SETA  (&C)      TRACE THE EDGE BACK TO THE PREDECESSOR OF
&C       SETA  (&P)      THE FIRST LEFT SUCCESSOR FOUND ON THE
&P       SETA  (&S-&IGALEFT(&C))  BACKPATH.
         AGO   .ISRIGHT
.*--------------------------------------------------------------------*
.* THERE IS NO LEFT OR RIGHT EDGE, BECAUSE THE END OF THE STRING      *
.* HAS BEEN ENCOUNTERED.                                              *
.*--------------------------------------------------------------------*
.LEOS    ANOP
&IGALEFT(&C) SETA (0-&P)  SET LEFT INVERTIBLE EDGE NULL.
.REOS    ANOP
&IGARGHT(&C) SETA (0-&P)  SET RIGHT INVERTIBLE EDGE NULL.
         AIF   (NOT &IGARL(&C)).EOSBAK  CONTINUE UNTIL THE FIRST LEFT.
.EOSBACK ANOP
&S       SETA  (&C)      TRACE THE BACKPATH TO THE FIRST LEFT
&C       SETA  (&P)            SUCCESSOR.
&P       SETA  (&S-&IGARGHT(&C))
         AIF   (&IGARL(&C)).EOSBACK    CHECK FOR A RIGHT SUCCESSOR.
.EOSBAK  ANOP
         AIF   (&C NE 1).ERROR
&IGAOKAY SETB  (1)       INDICATE VALID SYNTAX.
         MEXIT
.**********************************************************************
.* IS THERE A RIGHT EDGE?                                             *
.**********************************************************************
.ISRIGHT ANOP
         AIF   (&X EQ &Y).REOS  GO IF END OF STRING REACHED.
&CHAR    SETC  '&LIST'(&X,1)   GET CURRENT CHARACTER.
&X       SETA  (&X+1)    EKE TO NEXT CHARACTER.
.RIGHTIN ANOP
         AIF   ('&CHAR' EQ ',').MAKRGHT
         AIF   ('&CHAR' EQ ')').RRPAREN
         AGO   .ERROR
.*--------------------------------------------------------------------*
.* THERE IS A RIGHT EDGE, THE CURRENT CHARACTER IS A COMMA.           *
.*--------------------------------------------------------------------*
.MAKRGHT ANOP
&NX      SETA  (&NX+1)   GET A PLACE FOR THE NEW RIGHT SUCCESSOR.
&IGARL(&NX) SETB (1)     INDICATE RIGHT SUCCESSOR.
&IGARGHT(&C) SETA (&NX-&P)  STORE RIGHT INVERTIBLE EDGE.
&IGAIS(&NX) SETB (1)     INDICATE AN INNER VERTEX.
&P       SETA  (&C)      TRACE OVER TO THE NEW RIGHT SUCCESSOR.
&C       SETA  (&NX)     XX
         AGO   .ISLEFT
.*--------------------------------------------------------------------*
.ERROR   ANOP
&IGAOKAY SETB  (0)       INDICATE INVALID SYSNTAX.
         MEXIT
.**********************************************************************
.ITSCAN  AIF   ('&SCAN' NE 'ISCAN').TRYNEXT  GO IF NOT 1ST INITIALIZE.
.* INITIALIZE FOR LEFT LIST SCANNING.                                 *
.*--------------------------------------------------------------------*
&IGAX    SETA  (1)       SET IT TO THE SOURCE.
&IGAY    SETA  (0)       SIGNAL THAT ISCAN HAS BEEN DONE.
&IGAZ    SETA  (0)       DON'T CAUSE ANY CONFUSION.
&IGALEVL SETA  (0)
         MEXIT
.*--------------------------------------------------------------------*
.*  COME HERE FOR THE REAL SCANNING, AFTER THE ISCAN.                 *
.*--------------------------------------------------------------------*
.TRYNEXT AIF   ('&SCAN' EQ 'NEXT').DONEXT
         MNOTE 12,'INVALID SCAN, NEXT OR ISCAN EXPECTED.'
&IGAZ    SETA  0         MAYBE IT WILL WORK ANYWAY.
         MEXIT
.DONEXT  AIF   (&IGAY NE 0).NOT1ST  CHECK FOR FIRST TIME.
.*--------------------------------------------------------------------*
.*  FIRST TIME INTO TREE FOR LEFT LIST SCAN.                          *
.*--------------------------------------------------------------------*
&IGAY    SETA  (1)       SET IT TO THE SOURCE.
         AGO   .CHKLEFT  GO LOOK AT THE LEFT SUBTREE.
.TREF    ANOP
&IGAPATH(&IGALEVL) SETA (&IGAPATH(&IGALEVL)+1)  EKE PATH VECTOR ELEMENT
         AGO   .TEDGF                           ON THE SAME LEVEL.
.TLEF    ANOP
&IGALEVL SETA  (1+&IGALEVL)  MAKE PATH VECTOR LONGER TO ATOM.
&IGAPATH(&IGALEVL) SETA (0)  SET PATH VECTOR ELEMENT TO ZERO.
.TEDGF   ANOP
&IGAX    SETA  (&IGAY)   CYCLE THE THREE DOWN THE PATH.
&IGAY    SETA  (&IGAZ)   XX
.CHKLEFT ANOP
&IGAZ    SETA  (&IGAX+&IGALEFT(&IGAY))  TRACE LEFT EDGE (IF THERE IS 1)
         AIF   (&IGAZ NE 0).TRYLEFT    SEE IF THERE WAS A LEFT EDGE.
         MEXIT
.TRYLEFT AIF   (&IGAIS(&IGAZ)).TLEF    SEE IF THE SINK WAS REACHED.
         AIF   (&IGARGHT(&IGAZ) NE 0).FINZ  SEE IF MT SINK.
&IGAZ    SETA  (0)       PRETEND EMPTY CHARACTER STRINGS AREN'T THERE.
.FINZ    MEXIT
.*--------------------------------------------------------------------*
.*   INSPECT THE RIGHT SUBTREE.                                       *
.*--------------------------------------------------------------------*
.CHKRGHT ANOP
.NOT1ST  ANOP
&IGAZ    SETA  (&IGAX+&IGARGHT(&IGAY))  GET RIGHT SUCCESSOR (IF ANY).
         AIF   (&IGAZ NE 0).TREF       GO IF THERE IS ONE.
.CHKTOP  AIF   (&IGAY EQ 1).SOURCE     SEE IF SOURCE REACHED FROM RIGHT
         AIF   (&IGARL(&IGAY)).TREB  GO IF Y IS RIGHT SUCCESSOR.
&IGAZ    SETA  (&IGAY)   TRACE THE LEFT EDGE BACKWARD.
&IGAY    SETA  (&IGAX)   BACKPATH TRACE.
&IGAX    SETA  (&IGAZ-&IGALEFT(&IGAY))  BACKTRACE LEFT EDGE.
&IGALEVL SETA  (&IGALEVL-1)  GO BACK TO NEXT LOWER LEVEL.
         AGO   .CHKRGHT
.TREB    ANOP
&IGAPATH(&IGALEVL) SETA (&IGAPATH(&IGALEVL)-1)  DECREASE ELEMENT IN PV.
&IGAZ    SETA  (&IGAY)   BACKAPTH TRACE VIA THE RIGHT EDGE.
&IGAY    SETA  (&IGAX)   XX
&IGAX    SETA  (&IGAZ-&IGARGHT(&IGAY))  TRACE LEFT INVERTIBLE EDGE BACK
         AGO   .CHKTOP
.SOURCE  ANOP
&IGAX    SETA  (0)  SET THE EOP TRIPLE ACCORDINGLY.
&IGAY    SETA  (0)  XX
&IGAZ    SETA  (0)       THE WHOLE TREE HAS BEEN PROCESSED.
         MEXIT
.**********************************************************************
.VERSION ANOP
&IGABLST SETC  'X''20'''  SET THE OFFSET INTO THE TREE HEADER FOR THE  *
                         LIST OF ENTRY POINTTS.
         AIF   (K'&GEN NE 0).GEN  SEE IF THE GEN PARAMETER IS CODED.
         AIF   ('&IGARPT#' EQ 'SPACE').SPACNTL  SHOULD THE SPACE CONTROL
                         DSECT BE GENERATED?
&N       SETA  (&IGARPT#)  CONVERT THE TREE TYPE TO A #.
         AIF   (&RPTVNUM(&N)).FIN  IF IT'S ALREADY DONE, SKIP IT.
         AIF   (('&DS' EQ 'NO')OR('&DS' EQ '0')).LETIT  SEE IF THIS IS *
                         NOT REALLY A REQUEST TO GENERATE THE DSECT.
&RPTVNUM(&N) SETB (1)          SET IT ON SO IT DOESN'T DO IT AGAIN.
.LETIT   ANOP
         AIF   (&N EQ 8).RPTV8
         AIF   (&N EQ 5).RPTV5
         MNOTE 12,'INVALID TREE TYPE SPECIFIED.'
         AGO   .FIN
.RPTV5   ANOP
&IGADDR  SETC  'X''00'''  THE OFFSET TO THE ADDRESS OF THE MODULE      *
                         IGARPT01 FROM THE BEGINNING OF THE TREE HEADER.

&IGATOP5 SETC  'X''04'''  THE OFFSET TO THE SOURCE OF THE TYPE 5 RPT IN*
                         THE TYPE 5 TREE HEADER.
&IGACNT5 SETC  'X''0C'''  THE OFFSET TO THE USE COUNTER IN THE TYPE 5  *
                         RPT HEADER.
&IGAMSK5 SETC  'X''80'''  OFFSET TO THE TABLE OF MASKS IN THE TYPE 5   *
                         RPT HEADER.
         AIF   (('&DS'(1,1) EQ 'N')OR('&DS'(1,1) EQ '0')).RPT5END      *
                         SEE IF THE DSECT IS NOT SUPPOSED TO BE        *
                         GENERATED THIS TIME.
IGARPTH5 DSECT 0         DSECT FOR SRCH5, INS5, DEL5.
IGADDR5  DC    F'0'  THE ADDRESS OF IGARPT01.
IGATOP5  DC    F'0'      SOURCE OF BINARY TREE.
IGAHVFC5 DC    F'0'      HEAD OF INNER VERTEX FREE CHAIN.
IGACNT5  DC    F'0'      COUNTER FOR READ-ONLY VALIDATION.
IGAKEYI5 DC    H'0'      INDEX OF KEY IN RECORD.
IGAKEYL5 DC    XL1'00'   THE NUMBER OF BYTES IN THE KEY.
IGASP5   DC    XL1'00'   THE SUBPOOL NUMBER FOR GETMAINS.
IGA5MARK EQU   *  THE BYTE JUST PAST THE LAST THING BEFORE THE B-LIST.
         DC    (&IGAMSK5-(IGA5MARK-IGARPTH5))XL1'00'  LEAVE ROOM.
IGAMASKS DC    128XL1'FF'  THIS IS FILLED IN BY STREE, TYPE=5.
IGAMASKZ EQU   *
         CNOP  0,8       MAKE IT ON A DOUBLE WORD BOUNDARY.
IGAFIN5  EQU   *         FIRST BYTE PAST HEADER.
IGATYP5S EQU   IGAFIN5-IGARPTH5  TREEHDR SIZE FOR TYPE 5 TREE.
&SYSECT CSECT
IGAZERO  EQU   0         JUST A ZERO.
IGABASE5 EQU   1         THE ADDRESS OF THE TREEHDR.
IGAP5    EQU   2         REGISTER CONTAINING ANTEPENULTIMATE VERTEX.
IGAC5    EQU   3         REGISTER CONTAINING THE PENULTIMATE VERTEX.
IGAS5    EQU   15        REGISTER CONTAINING THE SINK ADDRESS.
IGACREG5 EQU   14        REGISTER TO HOLD THE COUNTER DURING THE SEARCH
IGASARG5 EQU   0         REGISTER CONTAINING THE SEARCH ARGUMENT.
.RPT5END ANOP
.RPTV8   ANOP
&IGADDR  SETC  'X''00'''  THE OFFSET TO THE ADDRESS OF THE MODULE      *
                         IGARPT01 FROM THE BEGINNING OF THE TREE HEADER.

&IGAHVFC SETC  'X''14'''  OFFSET TO THE IV FREE SPACE BLOCK ADDRESS.
&IGANAME SETC  'IGARPT01'  THE NAME OF THE MODULE.
&IGASRCH SETC  'X''0'''
&IGAINS  SETC  'X''04'''  SET THE INDEX OF THE ENTRY POINT TO INSERT A *
                         KEY-ADDRESS PAIR IN THE RPT.
&IGADEL  SETC  'X''08'''  SET THE INDEX OF THE DELETE ENTRY POINT.
&IGADSP  SETC  'X''0C'''  SET THE INDEX OF THE ENTRY POINT TO DISPLAY  *
                         THE TREE.
&IGAKEYW SETC  'X''10'''  INDEX OF THE ENTRY POINT WORD FOR OBTAINING  *
                         THE ADDRESS OF THE KEY WORK AREA.
&IGAISCN SETC  'X''14'''  INDEX OF THE ENTRY POINT WORD TO INITIALIZE  *
                         FOR SCANNING.
&IGASCNL SETC  'X''18'''  ENTRY POINT FOR SCANNING LEFT.
&IGASCNR SETC  'X''1C'''  ENTRY POINT FOR SCANNING RIGHT.
&IGAPVS  SETC  'X''20'''  INDEX OF ENTRY POINT FOR PARTIAL ORDER VALUE *
                         SEARCH.
&IGAGPV  SETC  'X''24'''  INDEX OF ENTRY POINT ADDRESS FOR GETTING THE *
                         PARTIAL ORDER VALUE FOR THE CURRENT SINK.
&IGADJPV SETC  'X''28'''  ENTRY POINT ADDRESS FOR ADJUSTING THE PARTIAL*
                         ORDER VALUE FOR THE CURRENT SINK.
&IGABFIN SETC  'X''40'''  THE SIZE OF THE LIST OF ENTRY POINT WORDS IN *
                         THE RPT HEADER.
&IGASCH8 SETC  'X''0'''  THE OFFSET INTO THE IGARPT01 MODULE FOR THE   *
                         TYPE 8 RPT SEARCH ROUTINE.
&IGADEL8 SETC  'X''180'''  THE OFFSET TO THE TYPE 8 RPT DELETE ROUTINE *
                         IN THE IGARPT01 MODULE.
&IGADEL5 SETC  'X''2A0'''
&IGAINS5 SETC  'X''300'''  BRANCH ENTRY OFFSET FOR INSERT INTO A TYPE 5*
                         RPT.
&IGAINS8 SETC  'X''450'''  THE OFFSET TO THE TYPE 8 INSERT ROUTINE IN  *
                         THE IGARPT01 MODULE.
&IGALSCN SETC  'X''4B0'''  THE OFFSET TO THE ROUTINE TO SCAN LEFT IN   *
                         THE IGARPT01 MODULE.
&IGARSCN SETC  'X''4D0'''  THE OFFSET TO THE ROUTINE TO SCAN RIGHT IN  *
                         THE IGARPT01 MODULE.
&IGAISP  SETC  'X''640'''
&IGAFRSC SETC  'X''680'''
&IGAGSPS SETC  'X''780'''  LOCATION OF THE GSPACE ROUTINE FOR VARIABLE *
                         LENGTH AREAS WHEN THE SPCA IS PROVIDED.
&IGAGSP  SETC  'X''790'''
&IGAGS8  SETC  'X''900'''
&IGAGS12 SETC  'X''920'''
&IGAGS80 SETC  'X''940'''
&IGAGSPF SETC  'X''960'''
&IGAFSP  SETC  'X''9E0'''
&IGAFSPS SETC  'X''A40'''  ENTRY LOCATION FOR VARIABLE LENGTH          *
                         FSPACE WITH THE SPCA CODED.
&IGAFS8  SETC  'X''BC0'''  BRANCH ENTRY OFFSET FOR FIXED LENGTH FSPACE *
                         FOR 8 BYTES.
&IGAFS12 SETC  'X''BE0'''  BRANCH ENTRY OFFSET FOR FIXED LENGTH FSPACE *
                         FOR 12 BYTES.
&IGAFS80 SETC  'X''C00'''  ENTRY POINT FOR FSPACE FOR FIXED LENGTH 80  *
                         BYTES.
&IGAFSPF SETC  'X''C20'''  ENTRY POINT FOR FSPACE WITH A FIXEDHDR.
&IGASPV  SETC  'X''C40'''  THE OFFSET TO THE PARTIAL ORDER SEARCH      *
                         ROUTINE IN THE MODULE IGARPT01.
&IGAPVG  SETC  'X''D20'''  THE OFFSET TO THE ROUTINE TO GET THE PARTIAL*
                         ORDER VALUE FOR THE CURRENT SINK.
&IGAPVAJ  SETC 'X''DA0'''  THE OFFSET TO THE ROUTINE TO ADJUST THE     *
                         PARTIAL ORDER VALUE FOR THE CURRENT SINK.
&IGADSP8 SETC  'X''ED8'''  THE OFFSET TO THE ROUTINE TO DISPLAY A TYPE *
                         8 RPT.
&IGASTRE SETC  'X''EE8'''  ENTRY POINT TO SET UP A RADIX PARTITION     *
                         TREE.
&IGACON  SETC  'X''F00'''
&IGAGKW  SETC  'X''F90'''  OFFSET TO ROUTINE TO GET A KEY WORK AREA.
&IGAEOPV SETC  'X''04'''  THE OFFSET TO THE PATH CODE BYTE IN THE TYPE *
                         8 RPT HEADER.
&IGAMAX  SETC  'X''24'''  THE OFFSET TO THE WORD CONTAINING THE MAXIMUM*
                         PARTIAL ORDER VALUE.
         AIF   ('&IGARPT#' NE '8').FIN  SEE IF THIS IS NOT EVEN REALLY *
               A TYPE 8 RADIX PARTITION TREE.
         AIF   ('&DS'(1,1) EQ 'N').FIN  SEE IF THE DSECT SHOULD BE     *
                         GENERATED THIS TIME.
         AIF   ('&DS'(1,1) EQ '0').FIN  SEE IF IT ISN'T THIS TIME.
IGARPTH  DSECT 0  PARAMETER LIST FOR TREE ROUTINES.
IGADDR   DC    XL4'00'  THIS IS THE BASE ADDRESS OF THE PROGRAM.
IGAPT    DC    F'0'  THE ADDRESS OF THE TREE SOURCE DOUBLE WORD.
         ORG   IGAPT
IGAPATH  DC    XL1'00'  THE PATH CODE BYTE.
         DC    AL3(0)  ADDRESS OF THE SOURCE OF THE TREE.
IGANTPEN DC    XL4'00'   ADDRESS OF ANTEPENULTIMATE VERTEX ON PATH.
IGAPENLT DC    F'0'      ADDRESS OF PENULTIMATE VERTEX ON PATH.
IGAFARG  DC    F'0'  THE ADDRESS OF THE KEY OF THE RECORD FOUND BY SRCH
IGAHVFC  DC    F'0'  THE ADDRESS OF THE INNER SPACE FIXEDHDR.
IGAKEYL  DC    H'0'  THE LENGTH OF A KEY IN BYTES.
IGAKEYI  DC    H'0'  THE 0-ORIGIN INDEX OF THE FIRST BYTE OF THE KEY
*                    IN THE RECORD.
IGAMAP   DC    F'0'      THE ADDRESS OF THE SUBROUTINE TO MAP AN       *
                         ASSOCIATED # TO AN ADDRESS OF AN AREA         *
                         CONTAINING THE CORRESPONDING KEY.
IGA9FILL DC    F'0'      THE REFILL SUBPOOL AND LENGTH FOR TYPE 9      *
                         VARIABLE LENGTH SPACE ALLOCATION TREES.
         CNOP  0,4   IGAMAX IS ON A 4-BYTE BOUNDARY.
IGAMAX   DC    F'0'   MAXIMUM VALUE FOR PARTIALLY ORDERED TREES.
IGAVALUE DC    F'0'  THE PARTIAL ORDER VALUE FOR SEMILATTICE CONDITION.
IGAWORK  DC    F'0'  WORK AREA FOR TYPE 9 RPT POV.
IGAPOV   EQU   8  INDEX OF PARTIAL ORDER VALUE IN INNER VERTEX.
         ORG   IGARPTH+&IGABLST  PUT THE LIST OF THE ENTRY POINTS FOR  *
                         THE VARIOUS OPERATIONS IN THE RIGHT PLACE.
IGASRCH  DC    F'0'      THE ADDRESS OF THE SEARCH ROUTINE FOR THIS    *
                         TYPE RPT.
IGAINS   DC    F'0'      THE ADDRESS OF THE INSERT ROUTINE FOR THE RPT.
IGADEL   DC    F'0'      THE ADDRESS OF THE DELETE ROUTINE FOR THE RPT.
IGADSP   DC    F'0'      THE ADDRESS OF THE ROUTINE TO DISPLAY THE RPT.
IGAKEYW  DC    F'0'      EITHER THE ADDRESS OF THE WORK AREA TO COLLECT*
                         KEYS OR THE ADDRESS OF THE ROUTINE TO SET ONE *
                         UP.
IGAISCN  DC    F'0'  THE ADDRESS TO LINK TO TO INITIALIZE FOR SCANNING.
IGASCNL  DC    F'0'      THE ADDRESS OF THE SCAN LEFT ROUTINE.
IGASCNR  DC    F'0'      THE ADDRESS OF THE SCAN RIGHT ROUTINE.
IGAPVS   DC    F'0'      THE ADDRESS OF THE PARTIAL ORDER VALUE SEARCH *
                         ROUTINE.
IGAGPV   DC    F'0'      THE ADDRESS OF THE ROUTINE TO OBTAIN THE      *
                         PARTIAL ORDER VALUE FOR THE CURRENT SINK.
IGADJPV  DC    F'0'      THE ADDRESS OF THE ROUTINE TO ADJUST THE      *
                         PARTIAL ORDER VALUE FOR THE CURRENT SINK.
IGABFIN  EQU   *
         DC    (X'40'+IGABFIN-IGARPTH)XL1'00'  FILL OUT THE REST OF THE*
                         RPT ENTRY POINT AREA.
IGAFIN8  EQU   *  BYTE PAST TREE HEADER FOR TYPE 8 AND 9 RPT.
IGATYP8S EQU   IGAFIN8-IGARPTH  TREE HEADER SIZE FOR TYPE 8 AND 9 RPT.
IGANEBIT EQU   B'00010000'  FLAG BIT TO INDICATE SUBTREE CONTAINS
*                           UNEQUAL KEYS.
IGASTBIT EQU   B'00001000'  SUBTREE OF KNOWN ORDER SELECTION BIT.
IGARLBIT EQU   B'00000100'  RIGHT/LEFT SUCCESSOR FLAG BIT.
IGAT0BIT EQU   B'00000010'  LEFT INNER VERTEX FLAG BIT.
IGAT1BIT EQU   B'00000001'  INNER VERTEX RIGHT EDGE FLAG BIT.
&SYSECT  CSECT
         AIF   (NOT &IGAPGM).NOSHORT  SKIP THE SHORT LABELS IF NOT RPT.
         RASS  (APT,IGAPT,PATH,IGAPATH,FARG,IGAFARG)
         RASS  (HVFC,IGAHVFC,KEYL,IGAKEYL)
         RASS  (OFFSET,IGAKEYI,AP,IGANTPEN,AC,IGAPENLT)
         RASS  (TREEHDR,IGARPTH,KEYWORK,IGAWORK,VALUE,IGAPOV)
         RASS  (TREEFIN,IGAFIN8,TREESZ,IGATYP8S)
         RASS  (NE,IGANEBIT,IGAQBIT,IGASTBIT,Q,IGAQBIT,RL,IGARLBIT)
         RASS  (T0,IGAT0BIT,T1,IGAT1BIT,KEYI,IGAKEYI)
.NOSHORT ANOP
         AGO   .FIN      ALL DONE, NOW EXIT FROM RPTDSECT.
.SPACNTL AIF   (&IGASPDS OR ('&DS'(1,1) EQ 'N')).NOSPDS  SEE IF THE    *
                         DSECT SHOULD BE GENERATED, OR JUST THE GLOBAL *
                         VARIABLE SYMBOLS.
&IGASPDS SETB  (1)     SET THE BIT SO THAT IT ONLY GETS GENERATED ONCE.
IGASPCTL DSECT 0         SPACE CONTROL DSECT FOR THE FSPACE AND GSPACE *
                         MACRO-INSTRUCTIONS.
IGARPT9  DC    12F'0'    THE TREE HEADER FOR THE TYPE 9 SPACE CONTROL  *
                         FITS IN THESE 12 WORDS.
IGASPEDG DC    F'0' THIS IS THE HEAD OF THE DEFINITION WORD CHAIN FOR *
*              SPACE CONTROL AREAS FOR SUBPOOLS OTHER THAN SUBPOOL    *
*              ZERO. THIS IS ONLY THE HEAD OF THE CHAIN FOR THE SPACE *
*              CONTROL AREA FOR SUBPOOL ZERO, HOWEVER; IN THE SPACE   *
*              CONTROL AREA FOR THE OTHER SUBPOOLS IT IS THE ADDRESS  *
*              OF THE SPACE CONTROL AREA FOR SUBPOOL ZERO.            *
IGAROUND DC    XL4'FFFFFFF0'  THIS IS THE MASK TO USE FOR ROUNDING     *
                         REQUEST LENGTHS TO KEEP THE AREA ALLOCATED ON *
                         THE PROPER ADDRESSING BOUNDARY.
IGABLOCK DC    F'0'      THIS IS THE HEAD OF THE BLOCK CHAIN OF BLOCK  *
                         DEFINITION WORDS THAT DEFINE THE SPACE        *
                         OBTAINED IN GSPACE FOR REFILLS.
IGASPLNG DC    XL4'00000000'  THE SUBPOOL NUMBER AND LENGTH OF THE SPACE
                         CONTROL AREA.
IGASA0   DC    18F'0'    THIS IS THE INNER SPACE SAVE AREA.
IGASA1   DC    18F'0'    THIS IS THE OUTER SPACE SAVE AREA.
IGAS8    DC    4F'0'     THE FIXED LENGTH HEADER FOR THE FREE SPACE    *
                         CHAIN OF 8-BYTE ENTRIES.
IGAS12   DC    4F'0'     THE FIXEDHDR FOR THE 12-BYTE ENTRY FREE SPACE *
                         CHAIN.
IGAS80   DC    4F'0'     THE FIXEDHDR FOR THE 80-BYTE FREE SPACE CHAIN.
IGASPC   DSECT 0
IGANXSP  DC    F'0'  THE EDGE TO THE NEXT ONE.
IGASPADR DC    F'0'  THE ADDRESS OF THE SPACE CONTROL AREA. THE SUBPOOL*
                         NUMBER FOR THIS ONE IS IN THE LEFT BYTE OF THE*
                         ADDRESS.
IGASPFIN EQU   B'10000000'  THIS BIT IS ON FOR THE LAST EDGE IN THE    *
                         SPACE CONTROL AREA SUBPOOL CHAIN.
&SYSECT  CSECT
.NOSPDS  ANOP
&IGASA0  SETC  'X''40'''  THE OFFSET TO THE FIRST SAVE AREA IN THE SPACE
                         CONTROL AREA.
&IGASA1  SETC  'X''88'''  THE OFFSET TO THE SECOND SAVE AREA IN THE    *
                         SPACE CONTROL AREA.
&IGAS8   SETC  'X''D0'''  SET THE OFFSET FROM THE BEGINNING OF THE     *
                         SPACE CONTROL AREA TO THE FIXEDHDR FOR 8-BYTE *
                         ENTRIES.
&IGAS12  SETC  'X''E0'''  SET THE OFFSET TO THE FIXEDHDR FOR 12-BYTE   *
                         ENTRIES.
&IGAS80  SETC  'X''F0'''  SET THE OFFSET TO THE FIXEDHDR FOR 80-BYTE   *
                         ENTRIES.
&IGASPZ  SETC  'X''100'''  SET THE LENGTH OF THE SPACE CONTROL AREA.
         AGO   .RPTV8  ALMOST ALL DONE, EXCEPT FOR THE GLOBAL VARIABLES*
               FOR THE TYPE 8 AND 9 RADIX PARTITION TREES.
.**********************************************************************
.* COME HERE TO GENERATE MISCELLANEOUS GENERATA.                      *
.**********************************************************************
.GEN     AIF   ('&GEN(1)' EQ 'CVTRPT').LOADCVT  SEE IF THE SEQUENCE TO *
                         LOAD THE CVTRPT WORD SHOULD BE GENERATED.
         AIF   ('&GEN(1)' EQ 'TCBRPT').LOADTCB  SEE IF THE SEQUENCE TO *
                         LOAD THE TCBRPT WORD SHOULD BE GENERATED.
         AIF   ('&GEN(1)' EQ 'TCBRPTA').TCBADDR  SEE IF THE SEQUENCE TO*
                         GET THE ADDRESS OF THE TCBRPT WORD SHOULD BE  *
                         GENERATED.
         MNOTE 12,'INVALID GEN PARAMETER.'
         AGO   .FIN      FORGET IT, CAN'T DO ANYTHING WITH THIS.
.**********************************************************************
.* GENERATE THE CODE TO LOAD THE ADDRESS OF THE MODULE IGARPT01 FROM  *
.* THE CVTRPT WORD INTO THE REGISTER SPECIFIED BY THE SECOND ELEMENT  *
.* IN THE GEN PARAMTER.                                               *
.**********************************************************************
.LOADCVT ANOP
         AIF   (&IGAPGM).IGACVTL  SEE IF THIS IS THE IGARPT01 MODULE.
         AIF   (NOT(&IGALONE)).NOTLONE  SEE IF THIS IS REALLY IT.
&TAG     L     &GEN(2),=AL4(IGAFETCH)  ADDRESS OF THE FAKE TCBRPT WORD.
         BAL   &GEN(2),(X'10'+X'40'*(&GEN(2)-14))(,&GEN(2))  LINK TO   *
                         REPLACE THIS INSTRUCTION WITH A LOAD OF THE   *
                         ADDRESS OF IGARPT01.
         AGO   .GENFIN   ALL DONE GENERATING IT NOW.
.IGACVTL L     &GEN(2),ADDRESS  LOAD THE ADDRESS OF THE BEGINNING OF   *
                         THE MODULE IGARPT01.
         AGO   .GENFIN   ALL DONE NOW.
.NOTLONE ANOP
&TAG     L     &GEN(2),X'10'  CVT PTR.
         USING CVT,&GEN(2)
         L     &GEN(2),CVTRPT  ADDRESS OF IGARPT01.
         DROP  &GEN(2)
         AGO   .GENFIN
.**********************************************************************
.* GENERATE THE CODE TO LOAD THE TCBRPT WORD INTO THE REGISTER        *
.* SPECIFIED BY THE SECOND ELEMENT IN THE GEN PARAMETER.              *
.**********************************************************************
.LOADTCB ANOP
         AIF   (NOT &IGALONE).LTCBWRD  SEE IF THIS IS UNIT TEST.
         AIF   (&IGAPGM).IGATCBL  SEE IF THIS IS THE PROGRAM IGARPT01.
         MNOTE 12,'CAN''T GET THE TBCRPT STUFF.'
         AGO   .GENFIN   ALL DONE GENERATING IT NOW.
.IGATCBL ANOP
&TAG     BALR  &GEN(2),0
         AGO   .GENFIN
         USING *,&GEN(2)
         L     &GEN(2),=AL4(IGATCB)
         DROP  &GEN(2)
         AIF   ('&GEN(1)' EQ 'TCBRPTA').GENFIN
         L     &GEN(2),0(,&GEN(2))
         AGO   .GENFIN   ALL DONE NOW.
.LTCBWRD ANOP
&TAG     L     &GEN(2),X'10'  ADDRESS OF CVT.
         AGO   .GENFIN
         L     &GEN(2),0(&GEN(2))    ADDRESS OF TCB CHAIN.
         L     &GEN(2),X'04'(,&GEN(2))  CURRENT TCB ADDRESS.
         USING TCB,&GEN(2)
&CHAR    SETC  'A'       PREPARE FOR A LOAD ADDRESS INSTRUCTION.
         AIF   ('&GEN(1)' EQ 'TCBRPTA').NOWLOAD  SEE IF IT IS THE      *
                         ADDRESS OF THE TCBRPT WORD, OR THE ACTUAL     *
                         CONTENTS OF THE TCBRPT WORD.
&CHAR    SETC  ''        IT IS THE ACTUAL CONTENTS OF THE WORD.
.NOWLOAD L&CHAR &GEN(2),TCBRPT  LOAD IGA'S WORD.
         DROP  &GEN(2)
         AGO   .GENFIN   ALL DONE NOW.
.**********************************************************************
.* GENERATE THE ADDRESS OF THE TCBRPT WORD IN THE REGISTER SPECIFIED  *
.* BY THE SECOND ELEMENT OF THE GEN PARAMETER.                        *
.**********************************************************************
.TCBADDR ANOP
         AIF   (NOT &IGALONE).LTCBWRD  SEE IF THIS IS THE REAL THING,  *
                         AND NOT JUST UNIT TEST.
         AIF   (&IGAPGM).IGATCBL  SEE IF THIS IS THE MODULE IGARPT01.
         MNOTE 12,'CAN''T GET THE ADDRESS OF THE TCBRPT WORD.'
         AGO   .GENFIN   ALL DONE GENERATING IT NOW.
.GENFIN  AIF   ((NOT &IGALONE)OR &IGAFTCH).FIN  SEE IF THE IGAFETCH    *
                         CSECT IS NEEDED.
         AIF   (&IGAPGM).FIN  DON'T GENERATE IT IN THE IGARPT01 MODULE.
&IGAFTCH SETB  (1)       DON'T GENERATE IT MORE THAN ONCE.
IGAFETCH CSECT
IGACVT   DC    F'0'      THIS WILL BE THE ADDRESS OF THE MODULE        *
                         IGARPT01 AFTER IT IS LOADED.
&X       SETA  (14)      START BY GENERATING THE CODE FOR REGISTER 14.
.GOAGAIN ANOP
         ORG   IGAFETCH+X'10'+(X'40'*(&X-14))  ORIGIN TO THE CORRECT   *
                         OFFSET FOR THE BRANCH ENTRY.
&Y       SETA  8
.BCTRCTR BCTR  &X,0
&Y       SETA  (&Y-1)
         AIF (&Y GT 0).BCTRCTR GENERATE 8 BCTR INSTRUCTIONS TO BACK UP *
                         THE LINKAGE ADDRESS TO THE LOAD INSTRUCTION.
         ST    2,4(,&X)  SAVE REGISTER 2 ON TOP OF THE BAL INSTRUCTION.
         BALR  2,0       ESTABLISH ADDRESSABILITY.
         USING *,2
         STM   0,1,IGASAVE0  SAVE REGISTERS 0 AND 1.
         BAL   2,IGAGCVT  GO CHECK TO SEE IF THE MODULE IS LOADED.
         DROP  2
         BALR  1,0       GET BACK ADDRESSABILITY.
         USING *,1
         AIF   (&X EQ 14).XIS14  SEE IF &X IS FOURTEEN.
         L     0,IGA15AL1  LOAD THE INSTRUCTION "L 15,0(,15)".
         AGO   .XDONE    SKIP AROUND THE CASE FOR &X = 14.
.XIS14   L     0,IGA14AL1  LOAD THE INSTRUCTION "L 14,0(,14)".
.XDONE   ANOP
         L     2,4(,&X)  RESTORE REGISTER 2.
         ST    0,4(,&X)  OVERLAY THE BAL INSTRUCTION WITH A LOAD OF THE*
                         ADDRESS OF IGARPT01.
         LM    0,1,IGASAVE0  RESTORE REGISTERS ZERO AND ONE.
         BR    &X        RETUTN TO THE LOAD OF THE ADDRESS OF IGAFETCH.
         DROP  1
&X       SETA  (&X+1)    EKE THE REGISTER.
         AIF   (&X EQ 15).GOAGAIN  REPEAT IT FOR REGISTER 15.
         ORG   IGAFETCH+X'40'*2  ORIGIN TO THE RIGHT PLACE FOR THE     *
                         SUBROUTINE TO LOAD THE MODULE.
***********************************************************************
* FETCH THE CONTENTS OF THE CVTRPT WORD, WHICH IS JUST THE ADDRESS OF *
* THE MODULE IGARPT01. DO THIS BY LOOKING TO SEE IF THE MODULE HAS    *
* BEEN LOADED ALREADY, AND IF IT HASN'T THEN LOAD IT FIRST.           *
***********************************************************************
IGAGCVT  SLR   0,0
         BALR  1,0
         USING *,1
IGASL0   SL    1,IGASL0A
         DROP  1
         USING IGAFETCH,1
         CL    0,IGACVT  SEE IF THE MODULE IS ALREADY LOADED.
         BCR   8,2       RETURN IF IT IS ALREADY LOADED.
         LOAD  EP=IGARPT01  LOAD THE MODULE.
         DROP  1
         BALR  1,0
         USING *,1
IGASL1   SL    1,IGASL1A
         DROP  1
         USING IGAFETCH,1
         ST    0,IGACVT  STORE THE ADDRESS OF THE LOADED MODULE.
         DROP  1
         BR    2
         CNOP  0,8
IGASAVE0 DC    XL8'FFFFFFFFFFFFFFFF'
IGASL0A  DC    AL4(IGASL0-IGAFETCH)
IGASL1A  DC    AL4(IGASL1-IGAFETCH)
IGA14AL1 L     14,0(,14)
IGA15AL1 L     15,0(,15)
&SYSECT  CSECT
.FIN     ANOP
         MEND
