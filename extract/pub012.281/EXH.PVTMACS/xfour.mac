         MACRO
&ID      XFOUR &DUMMY,&TESTRAN=NO,&DIAG=NO,&LEVEL=1
         GBLC  &COMPNM                  COMPONENT NAME
         LCLC  &NM                      MODULE NAME
         JHEAD 'SYMBOL RESOLUTION PHASE MAIN LINE CONTROL',            ,
               PHASEID=&ID,                                            ,
               LEVEL=&LEVEL
&NM      SETC  '&COMPNM'.'&ID'
*TITLE-  ASSEMBLER SYMBOL RESOLUTION PHASE                            *
*                                                                     *
*FUNCTION/OPERATION-                                                  *
*        RESOLVE SYMBOLS FOR THE ASSEMBLY PHASE                       *
*        GENERATE THE EXTERNAL SYMBOL DICTIONARY (ESD)                *
*        PUNCH RECORDS GENERATED BY 'PUNCH' AND 'REPRO' STATEMENTS    *
*   BEFORE THE ESD                                                    *
         AIF   ('&TESTRAN' NE 'YES').PCH
*        PUNCH TESTRAN RECORDS                                        *
.PCH     ANOP
*                                                                     *
*ENTRY POINT-                                                         *
         ENTRY &NM.01                                                 *
*                                                                     *
*INPUT-                                                               *
*        A FILE CREATED BY THE MACRO GENERATOR PHASE CONSISTING OF    *
*   THE FOLLOWING TYPES OF RECORDS-                                   *
*        (1)  RECORDS GENERATED BY 'PUNCH' AND 'REPRO' STATEMENTS     *
*             BEFORE THE ESD                                          *
*        (2)  SYMBOL DEFINITIONS                                      *
*        (3)  SYMBOL REFERENCES                                       *
*        (4)  LITERALS                                                *
*        (5)  ASSEMBLER OPERATIONS AFFECTING THE ESD OR STORAGE       *
*             ASSIGNMENT (START, CSECT, DSECT, COM, DXD, ENTRY,       *
*             EXTRN, WXTRN, EQU, ORG, LTORG, CNOP, DC, DS, END)       *
*                                                                     *
*OUTPUT-                                                              *
*        'PUNCH' AND 'REPRO'  RECORDS ON THE PUNCH FILES              *
*        THE ESD ON THE PRINT AND PUNCH FILES                         *
*        THE SYMBOL FILE TO THE ASSEMBLY PHASE                        *
         AIF   ('&TESTRAN' NE 'YES').PCH2
*        TESTRAN RECORDS TO THE PUNCH FILES                           *
.PCH2    ANOP
*                                                                     *
*EXTERNAL ROUTINES-                                                   *
         AIF   ('&TESTRAN' NE 'YES').EXTRN
         EXTRN &COMPNM.X4N01,&COMPNM.X4E01,&COMPNM.X4S01,&COMPNM.X4V01
         AGO   .EXTRN1
.EXTRN   EXTRN &COMPNM.X4D01,&COMPNM.X4E01,&COMPNM.X4S01,&COMPNM.X4V01
.EXTRN1  ANOP
*             BLDESD-    BUILD CONTROL SECTION ENTRY IN ESD           *
*             DCSCAN-    EVALUATE DC/DS OPERANDS AND LITERALS         *
*             XDSCAN-    EVALUATE DXD OPERANDS                        *
*             ENTRY-     PROCESS ENTRY POINT SYMBOL                   *
*             EVAL-      EVALUATE EXPRESSION                          *
*             EXTRN-     PROCESS EXTERNAL REFERENCE SYMBOL            *
*             FIND-      FIND AN ENTRY IN THE SYMBOL TABLE            *
*             GETESD-    GET AN ESD ENTRY                             *
*             MAKESD-    OUTPUT THE ESD                               *
*             SUBSET-    SUBSET THE SYMBOL TABLE                      *
*                                                                     *
*        ROUTINES IN THE CONTROLLER TO PERFORM INPUT/OUTPUT AND OTHER *
*   SYSTEM DEPENDENT FUNCTIONS-                                       *
*             JCHECK-    WAIT FOR COMPLETION OF A JREAD OR JWRITE     *
*             JFRECORE-  RELEASE MAIN STORAGE ALLOCATED BY JGETCORE   *
*             JGETCORE-  ALLOCATE MAIN STORAGE FOR WORK AREA          *
*             JGETL-     READ LOGICAL RECORD (LOCATE MODE)            *
*             JNOTE-     PROVIDE RECORD POSITION                      *
*             JPOINT-    POSITION TO A RECORD                         *
*             JPUTL-     WRITE LOGICAL RECORD (LOCATE MODE)           *
*             JPUTM-     WRITE LOGICAL RECORD (MOVE MODE)             *
*             JREAD-     READ PHYSICAL RECORD                         *
*             JWRITE-    WRITE PHYSICAL RECORD                        *
*                                                                     *
*EXITS, NORMAL-                                                       *
*        EXITS TO THE CONTROLLER                                      *
*                                                                     *
*EXITS, ERROR-                                                        *
*        NONE                                                         *
*                                                                     *
*TABLES/WORK AREAS-                                                   *
*        WORK AREA ALLOCATED BY JGETCORE ROUTINE IN THE CONTROLLER    *
*                                                                     *
*ATTRIBUTES-                                                          *
*        REFRESHABLE                                                  *
*                                                                     *
*NOTES-                                                               *
*                                                                     *
         EJECT
         COPY  JCOMMON
         EJECT
         COPY  JTEXT
         EJECT
         COPY  ICOMMON
         EJECT
JTEXT    DSECT ,
         ORG   JTEXT                    OVERLAY
         COPY  RSYMRCD
         EJECT
* VS1 RELEASE 3.1 CHANGES
*A413300-413520                                                 OX00873
*C413600                                                        OX00873
*D257600                                                        OX04097
*C258400                                                        OX04097
*A478100-478400                                                 OY02611
*D479200                                                        OY02611
*A494700-495920                                                 OY02611
*A487700-487900,602100-602300                                  @OX07274
*C488000,602400                                                @OX07274
*C487900,586400,602100                                         @OX10361
*A586900-587100                                                @OX10361
*A338100-338320                                                @OY08064
*C337600                                                       @OY08064
*C341600                                                       @PI01040
*A342100-342200                                                @PI01040
*A257300                                                       @OY09620
*C255400,260000                                                @OY09620
*D478100-478200,495700-495920                                  @OX09723
*C478400,495200,608800                                         @OX09723
*A554900,558100,494900-495160,495700,608500-608700             @OX09723
*A309300-309800                                                @OY10603
*C256800                                                       @OZ07355
*C496000                                                       @AX14216
*C495120                                                       @AZ16488
*A448100,448200                                                @AZ18392
&NM.00   CSECT
         JMODID
         USING &NM.01,R12
&NM.01   DS    0H                       PHASE ENTRY
I        LA    R14,IIII                 DEFINE ENTRY
II       JSAVE BASE=NO                  PUSH REGISTERS
         BR    R14                      PROCEED
III      JRETURN                        PHASE EXIT
         AIF   ('&TESTRAN' NE 'YES').X4DA
         DC    A(&COMPNM.X4N01,&COMPNM.X4E01,&COMPNM.X4S01,&COMPNM.X4V0X
               1)                       EXTERNAL ROUTINE BASE
         AGO   .X4NA
.X4DA    DC    A(&COMPNM.X4D01,&COMPNM.X4E01,&COMPNM.X4S01,&COMPNM.X4V0X
               1)                       EXTERNAL ROUTINE BASE
.X4NA    ANOP
IIII     LR    R8,R12                   BASE REGISTER
         DROP  R12
         USING &NM.01,R8
         SPACE
*                        INITIALIZATION                               *
         SPACE
         LH    R11,=Y(MAXDBL)
         JGETCORE  MINDBL=MINDBL,MAXDBL=(R11)  GET STORAGE
         LR    R7,R10                   INITIALIZE COMMON AREA BASE
         XC    D0*256(256,R7),D0*256(R7)
         XC    D1*256(256,R7),D1*256(R7)
         XC    D2*256(256,R7),D2*256(R7)
         XC    D3*256(256,R7),D3*256(R7)
         XC    D4*256(256,R7),D4*256(R7)
         XC    D5*256(256,R7),D5*256(R7)
         XC    D6*256(256,R7),D6*256(R7)
         XC    D7*256(256,R7),D7*256(R7)
         MVC   SAVE(IIII-II),II         INITIALIZE COMMON
*
*        INITIALIZE WORK AREA FOR SYMBOL TABLE ROUTINES
*
         AR    R11,R10                  POINT TO END OF COMMON
         LR    R14,R11                  FIRST SYMBOL TABLE ENTRY
         LR    R15,R11                  X
         LH    R0,=H'-20'               INCREMENT
         LA    R1,ENDOFCOM+D20*D2       LAST SYMBOL TABLE ENTRY
         STM   R14,R1,SYMDIMEN          X
*
*        INITIALIZE WORK AREA FOR LITERAL PROCESSING
*
         LA    R10,ENDOFCOM             END-OF-COMMON
         LA    R11,ENDOFCOM+D20         FIRST LITERAL ENTRY
         STM   R10,R11,LATADD           ADDRESS OF ADJUSTMENT TABLE
*
*        INITIALIZE WORK AREA FOR ESD PROCESSING
*
         L     R15,=Y(D20*D16+D4,0)     BLOCK LENGTH
         LA    R14,ESDBLK1+D4           GET ADDRESS OF FIRST BLOCK
         STM   R14,R15,ESDBLK1          PUT IN PARAMETER FOR READ/WRITE
         LA    R14,ESDBLK2+D4           GET ADDRESS OF SECOND BLOCK
         STM   R14,R15,ESDBLK2          PUT IN PARAMETER FOR READ/WRITE
         MVI   HIDESDID,DSW             ORGIN OF DSECT ESDID
*
*        INITIALIZE WORK AREA FOR EXPRESSION EVALUATION ROUTINE
*
         LA    R14,TERMS                START OF TERMS STACK
         LA    R15,RLIST                START OF RELOCATABILITY STACK
         LA    R0,OPRNS-D1              START OF OPERATOR STACK
         STM   R14,R0,ATPTR             X
         TS    SELFDEFN                 ASSUMED INITIAL SETTING
         MVI   CLCLNG+D1,D1             LENGTH ATTRIBUTE OF ASTERISK
         SPACE
         LA    R14,ESDBLK1              ADDRESS OF ONE BLOCK
         LA    R15,ESDBLK2              ADDRESS OF OTHER BLOCK
         STM   R14,R15,JFWORD1          STORE BOTH
         MVC   NOTELIST(D8),JFWORD1     INITIALIZE FIRST ESD BLOCK
         MVC   NOTELIST+D9(D8),JFWORD2  INITIALIZE OTHER ESD BLOCK
         MVI   NOTELIST+L'JNOTEVAL,X'01'     X
         MVI   NOTELIST+L'JNOTEVAL*2+1,X'01' X
         LA    R6,ESDBLK1+D8            DUMMY POINTER
         SPACE
*TITLE-  GETNEXT                                                      *
*                                                                     *
*FUNCTION/OPERATION-                                                  *
*        THIS ROUTINE IS THE MAIN LINE CONTROL AND DRIVER FOR THE     *
*   SYMBOL RESOLUTION PHASE.  THIS ROUTINE GETS THE NEXT LOGICAL      *
*   RECORD FROM THE CURRENT INPUT FILE AND PASSES CONTROL TO ONE OF   *
*   THE FUNCTIONAL ROUTINES FOR PROCESSING.  THE FUNCTIONAL ROUTINE   *
*   SELECTED IS DEPENDENT UPON THE RECORD TYPE AND THE CURRENT MODE.  *
*   IF IN PASS ONE ASSIGNMENT MODE, THIS ROUTINE ALSO ADJUSTS THE     *
*   CURRENT LOCATION COUNTER AND SETS UP THE OPERAND COLUMN POINTER.  *
*                                                                     *
*INPUT-  NONE                                                         *
*                                                                     *
*OUTPUT- REGISTER R3 CONTAINS THE CURRENT LOCATION COUNTER VALUE.     *
*        REGISTER R4 IS A POINTER TO THE INPUT RECORD.                *
*        REGISTER R5 IS A POINTER TO THE OPERAND FILED.               *
*                                                                     *
         SPACE
GETNEXT  LH    R10,JINFILE              GET ADDRESS OF INPUT FILE
         JGETL FILE=(R10)               GET NEXT RECORD
         LR    R4,R11                   RECORD POINTER
         SR    R1,R1                    CLEAR REGISTER
         IC    R1,JTIOP1                GET RECORD TYPE
         AR    R1,R1                    GET INDEX
         LH    R2,MODE                  GET MODE
         L     R2,RADIX(R2)             GET RADIX
         SH    R2,D0(R1,R2)             GET ROUTINE VECTOR
         GOIF  (MODE1,MODE2)            SEE IF PASS 1 ASSIGNMENT MODE
         BNER  R2                       GO TO RESPECTIVE ROUTINES IF NO
* DO NOT MOVE INPUT RECORD IF SYMBOL OVERFLOW HAS NOT OCCURED
         GOIF IOFLO,OFF=DONTMOVE
* DO NOT MOVE REFERENCE RECORD
         GOIF JTIOP,JTSYMBL,EQ=DONTMOVE
         LH    R1,JTRLI                 RECORD LENGTH
         LA    R3,INPUTBUF              BUFFER ADDRESS
         CH    R1,ADMAXMVC              EXECUTE MOVE IF
         BNH   MOVEX                    LESS THAN MAX MOVE LENGTH
         SH    R1,ADMAXMVC              SUBTRACT MOVED BYTES
         MVC   D0(MAXMVC,R3),D0(R4)     MOVE MAX LENGTH
         LA    R4,MAXMVC(,R4)           BUMP FROM ADDRESS
         LA    R3,MAXMVC(,R3)           BUMP TO ADDRESS
MOVEX    BCTR  R1,R0                    MINUS ONE FOR EXECUTE
         EX    R1,MVCIM                 EXECUTE MOVE INSTRUCTION
         LA    R4,INPUTBUF              POINT TO LOGICAL RECORD
DONTMOVE GOIF  RFIELDX,OFF=LOCTR1       SKIP IF NO OPERAND
         LA    R5,RLNGA                 POINT TO OPERAND
         GOIF  RFIELDN,OFF=LOCTR        SKIP IF NO NAME
         LA    R5,RLNGB                 POINT TO OPERAND
LOCTR    SR    R1,R1                    CLEAR REGISTER
         IC    R1,CHAR1                 GET OPERAND LENGTH
         LA    R5,CHAR2(R1)             POINT TO END-OF-OPERAND
         ST    R5,OPNEND                NOTE IT
         SR    R5,R1                    POINT TO BEGINNING-OF-OPERAND
LOCTR1   GOIF  JDEF,OFF=(R2)            SKIP UPDATE LOCATION COUNTER
         SET   JDEF,OFF                 RESET INDICATOR
         L     R3,ELCTR                 GET CURRENT LOCATION COUNTER
         NC    RLCTR,RLCTR              SEE IF BYTES SKIPPED
         BZ    LOCTR2                   NO, PROCEED
         BAL   R9,ALIGN1                ALIGN TO HALFWORD BOUNDARY
         DC    H'-2,1'                  ALIGNMENT PARAMETERS
         AL    R3,RLCTR                 ADD NUMBER OF BYTES SKIPPED
         ST    R3,ELCTR                 UPDATE CURRENT LOCATION COUNTER
LOCTR2   MVC   RESDI(D6),EESDI          PASS CURRENT LOCATION COUNTER
         BR    R2                       GO TO RESPECTIVE ROUTINE
         SPACE
MAXMVC   EQU   256                      MAX MOVE LENGTH
ADMAXMVC DC    H'256'                   MAX MOVE LENGTH
MVCIM    MVC   D0(*-*,R3),D0(R4)        MOVE LOGICAL RECORD
         SPACE
INPC     LA    R10,HICESDID             GET PARAMETER
         MVC   XPARM,CSTPARM            PASS PARAMETERS
         GOTO  BLDESD                   BUILD ESD ENTRY
         LR    R6,R10                   MAKE CONTROL SECTION CURRENT
         AIF   ('&TESTRAN' NE 'YES').INPC
         BAL   R9,ESDPUNCH              OUTPUT TESTRAN ITEM
.INPC    B     EPILOGUE                 FINIS
         SPACE
SEARCH   GOIF  (RFIELDN,PRIORDEF),NOTMIX=TRANSFER
         LR    R10,R4                   PASS RECORD POINTER
         GOTO  FIND                     LOOKUP IN SYMBOL TABLE
         BNE   TRANSFER                 NOT FOUND
         GOIF  ESDNRSW,ON=TRANSFER      DEFER FLAGGING
         SET   PRIORDEF,ON              INDICATE PREVIOUSLY DEFINED
         B     TRANSFER                 OUTPUT RECORD
         SPACE
EOFIIS   SET   MODE1,OFF                INDICATE END OF SUBSTITUTION
         SET   IOFLO,ON                 INDICATE TABLE OVERFLOWED
         GOIF  STBLOFLO                 SEE IF SUBSETTED
         GOTO  SUBSET                   SUBSET
         L     R0,SYMDIMEN+D4           GET ADDRESS
         SH    R0,=H'1024'              MARGIN
         C     R0,LATEND                SEE IF OVERLAPPING LITERAL POOL
         BNL   GETNEXT                  ENOUGH ROOM
         MVI   JPRTONLY,JPRONLY         SET FLUSH CONDITION
         SET   (MODE1,MODE2),ON         SET EXIT CONDITION
         B     BUGOUT                   JUST LIKE IT SAYS
         SPACE
REHASH   GOIF  STBLOFLO                 SEE IF SUBSETTED
         GOTO  SUBSET                   SUBSET
         LR    R10,R4                   POINTER
         GOTO  ENTER                    ENTER IN SYMBOL TABLE
         B     GETNEXT                  FINIS
         SPACE
START    SR    R0,R0                    ZERO
         CH    R0,FSTCSECT              SEE IF FIRST CSECT
         BNE   CSECT                    ILLEGAL START IF NOT FIRST
         GOIF  RFIELDX,OFF=START1       NO OPERAND
         CLC   CHAR1(D2),=AL1(JCOMMA,JBLANK) LOOK FOR NULL OPERAND
         BE    START1                   A CLEAN START, VRRRRRRRROM
         GOTO  EVAL                     EVALUATE OPERAND
         BNZ   CSECT                    ERROR
         GOIF  LOCTREF,ON=CSECT         LOCATION COUNTER REFERENCE
         LA    R11,D7(,R11)             ROUND TO DOUBLE WORD BOUNDARY
         ST    R11,STARTLOC             SAVE
START1   OI    RFLGB,BIT0               INDICATE VALID START CARD
         SPACE
CSECT    L     R11,CSTPARM              GET PARAMETER
CSECT1   LA    R10,HICESDID             X
CSECT2   ST    R11,XPARM                PASS
         GOTO  BLDESD                   GO MAKE ESD ENTRY
         LR    R6,R10
         MVC   RESDI(L'RESDI+L'RLCTR),EESDI
         BAL   R9,WRITE2                WRITE CROSS-REFERENCE RECORD
         AIF   ('&TESTRAN' NE 'YES').CSECT
         BAL   R9,ESDPUNCH              OUTPUT TESTRAN ITEM
.CSECT   B     EPILOGUE                 FINIS
         SPACE
DSECT    L     R11,DSTPARM              GET PARAMETER
         LA    R10,HIDESDID
         B     CSECT2
         SPACE
COM      L     R11,COMPARM              GET PARAMETER
         B     CSECT1                   COMMON ROUTINE
         SPACE
REPRO    JPUNCH  SEQ=NO                 GET PUNCH BUFFER
         SR    R15,R15                  CLEAR REGISTER
         IC    R15,RESDI                GET OPERAND LENGTH
         LTR   R15,R15                  SEE IF LENGTH OF OPERAND ZERO
         BE    GETNEXT                  FINIS IF SO
         LR    R14,R15                  CLEAR REGISTER
         IC    R14,RFLDI                GET OUTPUT COLUMN POINTER
         BCTR  R14,0                    DECREMENT BY ONE
         BCTR  R15,0                    DECREMENT BY ONE
         AR    R11,R14                  POINT TO OUTPUT COLUMN
         EX    R15,REPRO1               MOVE IN OPERAND
         B     GETNEXT                  FINIS
REPRO1   MVC   D0(D0,R11),RESDI+D1      EXECUTED INSTRUCTION
         SPACE
PUNCH    LA    R2,D1                    INCREMENT
         SR    R3,R3                    ZERO REGISTER
         IC    R3,RESDI                 OPERAND LENGTH
         CLI   RESDI,D3                 CHECK IF NULLSTRING
         BL    GETNEXT                  ERROR IF SO
         AR    R3,R4                    POINT TO END OF OPERAND
         BCTR  R3,D0                    MINUS ONE
         LR    R5,R4                    POINT TO BEGINNING OF OPERAND
         CLI   D7(R5),JQUOTE            MUST BEGIN WITH A QUOTE
         BNE   GETNEXT                  ERROR IF NOT
PUNCH1   BXH   R5,R2,GETNEXT            POINT TO NEXT CHARACTER
PUNCH2   CLI   D7(R5),JQUOTE            SEE IF CHARACTER A QUOTE
         BNE   PUNCH6                   NOT A QUOTE
         BXLE  R5,R2,PUNCH4             A QUOTE, SEE IF PAIRED QUOTES
PUNCH3   JPUNCH  SEQ=NO                 DEL BY A TRAIL QUOTE
         LA    R4,D3(,R4)               GET OPERAND LENGTH
         SR    R5,R4                    GET LENGTH OF OPERAND
         BM    GETNEXT                  NULL QUOTES
         LA    R1,D9*D9-D2              79
         CR    R1,R5                    SEE IF MORE THAN 80 CHARACTERS
         BNL   PONCHO                   LESS THAN 80
         LR    R5,R1                    OPERNAD TOO LONG
PONCHO   EX    R5,PUNCH8                MOVE IN PUNCH OPERAND
         B     GETNEXT                  FINIS
PUNCH4   CLI   D7(R5),JQUOTE            SEE IF PAIRED QUOTES
         BNE   GETNEXT                   NOT PAIRED ', FINIS   @OZ07355
PUNCH5   BCTR  R3,D0                    OP IS 1 LESS           @OY09620
         LR    R1,R3                    POINT TO 2:ND OF PAIR   OX04097
         SR    R1,R5                    GET LENGTH OF OPERAND REMAINDER
         BM    GETNEXT                  NO ENDING QUOTE        @OY09620
         EX    R1,PUNCH9                MAKE PAIR TO APPEAR AS ONE
         B     PUNCH2                   LOOP
PUNCH6   CLI   D7(R5),JAMPER            SEE I& AN AMPERSAND
         BNE   PUNCH1                   JUST AN ORDINARY CHARACTER
         BXH   R5,R2,GETNEXT            POINT TO NEXT CHARACTER
         CLI   D7(R5),JAMPER            SEE IF PAINER AMPERSANDS
         BE    PUNCH5                   IT HAD BETTER BE
         B     GETNEXT                  OR OTHERWISE IT IS IN ERROR
PUNCH8   MVC   D0(D0,R11),D5(R4)        MOVE OPERAND ONTO CARD
PUNCH9   MVC   D7(D0,R5),D8(R5)         OVERLAP THE REDUNDANT ONE
         SPACE
DC       MVI   TYPECALL,DCCALL+DEFNAME  PARAMETER
         GOIF  (DSW2,CSW2),NONE=DC1     ESD SUPPRESSION
         OI    TYPECALL,NOESD           SUPPRESS ESD PROCESSING
DC1      GOIF  (RFIELDN,PRIORDEF),MIX=DC2    NAME PREVIOUSLY DEFINED
         SET   DEFNAME,OFF              NO NAME DEFINITION
DC2      GOTO  DCSCAN
         LH    R0,LATTRSAV
         GOIF  RFIELDN,OFF=DC3          SKIP IF NO NAME
         STH   R0,RLNGQ                 PASS
DC3      MVC   RFLGA,OPCNT+D1           NUMBER OF GOOD OPERANDS
B52      BAL   R9,WRITE2                WRITE RECORD
         B     EPILOGUE                 FINIS
         SPACE
DS       MVI   TYPECALL,DSCALL+DEFNAME+NOESD PARAMETER
         B     DC1                      VINTAGE
         SPACE
ENTRY    GOTO  ENTRY                    GO TO ROUTINE
         B     TRANSFER                 WRITE ON OUTPUT FILE
         SPACE
EXTRN    MVI   RTYPE,ETYPEER            TYPE
EXTRN1   MVI   RFLGB,ESDNRSW            SWITCH
         GOTO  EXTRN                    GO TO ROUTINE
         B     TRANSFER                 WRITE ON OUTPUT FILE
         SPACE
WXTRN    MVI   RTYPE,ETYPEWX            TYPE
         B     EXTRN1                   TREAT AS EXTRN
         SPACE
DXD      GOIF  RFIELDN,OFF=GETNEXT      LIKELY
         MVI   RFLGA,D0
         LR    R10,R4
         GOTO  FIND
         BNZ   DXD1
         GOIF  ENTRYSW,ON=DXD1
         SET   PRIORDEF,ON
DXD1     LA    R0,D1
         STH   R0,RLNGQ
         SR    R0,R0
         ST    R0,RLCTR
         GOIF  PRIORDEF,ON=B52
         GOIF  RFIELDX,OFF=B52
         MVC   XPARM,DXDPARM            PASS PARAMETERS
         LA    R10,HICESDID             PASS ESDID
         GOTO  BLDESD                   MAKE ESD ENTRY
         GOTO  XDSCAN                   SCAN OPERAND
         B     DC3                      BON VOYAGE
         SPACE
EQU      LA    R3,WRITE                 EXIT TIME ADDRESS
         XC    REFCOUNT,REFCOUNT        RESET COUNT            @OY10603
         XC    SYMCOUNT,SYMCOUNT        RESET COUNT            @OY10603
         XC    RESDI(D6),RESDI
         GOIF  RFIELDN,OFF=(R3)
         MVC   RLNGQ,=H'1'              LENGTH ATTRIBUTE OF *
         BAL   R2,EQU1                  EVALUATE EXPRESSION(S)
         GOIF  PRIORDEF,ON=(R3)         EXIT IF PREVIOUSLY DEFINED
         LR    R10,R4                   PASS POINTER
         GOTO  ENTER                    ENTER IN SYMBOL TABLE
         BER   R3                       OK
         SET   PRIORDEF,ON              INDICATE PREVIOUSLY DEFINED
         BR    R3                       GO ANYWAY
EQU1     GOIF  RFIELDX,OFF=(R2)         NO OPERAND, DEFAULT TO *
         CLI   CHAR1,JCOMMA             FIRST OPERAND PRESENT
         BE    EQU4                     YEAH
         GOTO  EVAL                     EVALUATE FIRST OPERAND
         BOR   R2                       SYNTACTIC ERROR
         BALR  R1,D0                    SAVE CONDITION CODE
         CLI   D0(R14),JBLANK           SEE IF VALID END OF OPERAND
         BE    EQU2                     YEAH
         CLI   D0(R14),JCOMMA           THIS IS OK ALSO
         BNER  R2                       OTHERWISE, A NO-NO
EQU2     LR    R5,R14                   COLUMN POINTER
         SPM   R1                       SET CONDITION CODE
         BL    EQU3                     BADDIE
         AIF   ('&TESTRAN' NE 'YES').EQUX
         BZ    EQUABS                   BRANCH IF ABSOLUTE OPND
         LA    R3,XREF3                 EXIT IF SIMPLY RELOCATABLE
EQUABS   STH   R10,RESDI                ESDID
         AGO   .EQUY
.EQUX    STH   R10,RESDI                ESDID
.EQUY    ST    R11,RLCTR                VALUE
EQU3     MVC   RLNGQ,IMPLNG             LENGTH ATTRIBUTE
         MVC   RFLGB,EVALSW1            TATTLE TALE
         CLI   CHAR1,JBLANK             END OF EVALUATION
         BER   R2                       YUP
EQU4     LA    R5,CHAR2                 POINT TO NEXT CHARACTER
         CLI   CHAR1,JCOMMA             NULL OPERAND
         BER   R2                       YES
         GOTO  EVAL                     EVALUATE SECOND OPERAND
         BE    EQU6                     OK                     @OY08064
         GOIF  NOTDEFN,OFF=(R2)         ERROR - UNDEF SYMB ?   @OY08064
         SET   EQUF1,ON                 MARK IT IN RECORD      @OY08064
         BR    R2                       AND RETURN             @OY08064
EQU6     EQU   *                                               @OY08064
         CLI   D0(R14),JBLANK           SEE IF PROPERLY DELIMITED
         BE    EQU5                     YES
         CLI   D0(R14),JCOMMA           THIS IS OK ALSO
         BNER  R2                       THIS ISN'T
EQU5     EQU   *                                               @OY01040
         SET   EQUF1,ON                 MARK IN CASE OF ERROR  @PI01040
         CL    R11,=F'65535'            SEE IF WITHIN ALLOWANCE@PI01040
         BHR   R2                       NOPE
         SET   EQUF1,OFF                ALL RIGHT              @PI01040
         STH   R11,RLNGQ                LANGTH ATTRIBUTE OVERRIDDEN
         BR    R2                       RETURN
         SPACE
CNOP     BAL   R9,ALIGN                 ALIGN TO HALFWORD BOUNDARY
         DC    H'-2,1'                  ALIGNMENT PARAMETERS
         ST    R3,RLCTR                 UPDATE CURRENT LOCATION COUNTER
         BAL   R9,XREF                  CROSS REFERENCE NAME FIELD
         AIF   ('&TESTRAN' NE 'YES').CNOPY
         BAL   R9,MISPUNCH              OUTPUT TESTRAN ITEM
.CNOPY   GOIF  RFIELDX,OFF=EPILOGUE     NO OPERAND, NO GOOD
         GOTO  EVAL                     EVALUATE FIRST OPERAND
         BNE   EPILOGUE                 MUST BE ABSOLUTE
         CLI   D0(R14),JCOMMA           SEE IF THERE'S A SECOND OPERAND
         BNE   EPILOGUE                 TUBE IT IF NONE
         LR    R2,R11                   SAVE VALUE OF FIRST OPERAND
         N     R11,=F'1'                SEE IF FIRST OPERAND IS ODD
         BNZ   EPILOGUE                 THAT'S ODD, TOO BAD
         LA    R5,D1(,R14)              POINT TO SECOND OF TWO OPERANDS
         GOTO  EVAL                     EVALUATE SECOND OPERAND
         BNE   EPILOGUE                 INVALID UNLESS IT'S ABSOLUTE
         CLI   D0(R14),JBLANK           LOOK FOR VALID DELIMITER
         BNE   EPILOGUE                 MUST BE A BLANK
         LCR   R10,R11                  ALIGNMENT MASK
         CL    R10,=F'-4'               FULLWORD
         BE    CNOP1                    SKIP IF SO
         CL    R10,=F'-8,4'             DOUBLEWORD
         BNE   EPILOGUE                 8
CNOP1    CLR   R2,R11                   FIRST OPERAND MUST BE SMALLER
         BNL   EPILOGUE                 OF THE TWO TO BE VALID
         NR    R3,R10                   TO SPECIFIED BOUNDARY
         AR    R3,R2                    ADD VALUE OF FIRST OPERAND
         C     R3,ELCTR                 THE RESULT SHOULD BE GREATER
         BNL   CNOP2                    THAN THE ORIGINAL VALUE
         AR    R3,R11                   OTHERWISE ADD ON SECOND OPERAND
CNOP2    ST    R3,ELCTR                 THIS IS THE NEW LOCATION
         B     EPILOGUE                 FINIS
         SPACE
ORG      BAL   R9,XREF                  CROSS REFERENCE NAME FIELD
         AIF   ('&TESTRAN' NE 'YES').ORGY
         BAL   R9,MISPUNCH              OUTPUT TESTRAN ITEM
.ORGY    LH    R10,JOUTFILE             OUTPUT FILE ADDRESS
         LA    R11,D12                  LENGTH OF RECORD
         JPUTL FILE=(R10),BUFREQ=(R11)  GET OUTPUT BUFFER
         GOIF  RFIELDX                  SEE IF THERE'S AN OPERAND
         LR    R4,R11                   RECORD POINTER
         MVC   JTRLI(D6),LOCRCD         ADJUSTMENT RECORD
         MVC   RESDI(D6),EESDI          CURRENT ESDID AND VALUE
         BZ    ORG1                     GO TO ORG BLANK
         CLI   CHAR1,JCOMMA             SEE IF NULL OPERAND
         BE    ORG1                     X
         GOTO  EVAL                     EVALUATE OPERAND
         BNH   EPILOGUE                 NOT SIMPLY RELOCATABLE
         CLI   D0(R14),JBLANK           CHECK FOR PROPER DELIMITER
         BNE   EPILOGUE                 BAD DELIMITER
         CH    R10,EESDI                SEE IF IN THIS CONTROL SECTION
         BNE   EPILOGUE                 OUT OF CONTROL, SECTIONWISE
         LTR   R11,R11                  SEE IF NEGATIVE
         BM    EPILOGUE                 NEGATIVE, OUT OF CONTROL
         CL    R3,EHILC                 SEE IF NECESSARY TO SAVE VALUE
         BNH   ORG2                     NOPE
         ST    R3,EHILC                 SAVE CURRENT LOCATION COUNTER
         B     ORG2                     CONTINUE
ORG1     L     R11,EHILC                GET SAVED HIGHEST ADDRESS
         CLR   R3,R11                   SEE IF HIGHER THAN CURRENT
         BNL   ORG3                     INEFFECTIVE
ORG2     ST    R11,ELCTR                MODIFY ADDRESS TO NEW VALUE
         ST    R11,RLCTR                PASS IN RECORD
ORG3     MVI   RFLGB,GOODORG            INDICATE ERROR FREE ORG
GOODORG  EQU   BIT0                     X
         B     EPILOGUE                 FINIS
         SPACE
SYMBL    LH    R14,REFCOUNT             GET COUNT
         CH    R14,SYMCOUNT             COMPARE TO TOTAL
         BNL   SYMBOL                   SKIP IF NOT APPLICABLE
         LA    R15,D1(,R14)             BUMP COUNT
         STH   R15,REFCOUNT             UPDATE COUNT
         SRDL  R14,D3                   FIRST SUBSCRIPT IN R14
         SRL   R15,D29                  SECOND SUBSCRIPT IN R15
         LA    R1,BIT0                  INITIAL MASK
         SRL   R1,D0(R15)               ADDRESS BIT
         LA    R15,VEETABLE(R14)        ADDRESS BYTE
         EX    R1,TMINST                SEE IF V-CON SYMBOL
         BZ    SYMBOL                   SKIP IF NOT
         OI    RNAME,BIT0               FUDGE
         SPACE
SYMBOL   LR    R10,R4                   PARAMETER
         GOTO  FIND                     LOOKUP IN SYMBOL TABLE
         BNE   TRANSFER                 NO FURTHER
         CLI   JSW0033,MODE2            MODE 1S                 OX00873
         BNE   SYMBOL05                 NO,BRANCH               OX00873
         TM    RNAME,BIT0               TEST IF VCON BIT ON     OX00873
         BO    TRANSFER                 YES                     OX00873
SYMBOL05 GOIF  ENTRYSW,ON=TRANSFER      UNDEFINED ENTRY SYMBOL  OX00873
         SET   DEFINED,ON               INDICATE DEFINED
         MVC   RFLGB,SFLGS              PASS FLAGS
         MVC   RESDI(L'RESDI+L'RLCTR),SESDI  PASS ESDID AND VALUE
         LA    R15,1                    PASS LENGTH ATTRIBUTE
         GOIF  ESDNRSW,ON=SYMBOL1       SEE IF EXTERNAL NAME
         LH    R15,SLNGQ                GET LENGTH ATTRIBUTE
SYMBOL1  STH   R15,RLNGQ                PASS LENGTH ATTRIBUTE
         GOIF  MODE1,OFF=SYMBOL2
         GOIF  MODE2,ON=ADJUST,ELSE=SYMBOL3
SYMBOL2  SET   PRIORDEF,ON
         NI    RNAME,BITFF-BIT0
SYMBOL3  MVI   JTIOP1,JTADJII
         B     TRANSFER                 OUTPUT RECORD
         SPACE
CXD      BAL   R9,ALIGN1                ALIGN TO FULLWORD BOUNDARY
         DC    H'-4,3'                  ALIGNMENT PARAMETERS
         LA    R1,D4                    LENGTH ATTRIBUTE
         AIF   ('&TESTRAN' NE 'YES').CXD
         ST    R3,RLCTR                 VALUE OF SYMBOL
         BAL   R9,XREF1                 CROSS-REFERENCE NAME, IF ANY
         SET   TDATA                    INDICATE TESTRAN ITEM TYPE
         BAL   R9,ANYPUNCH              OUTPUT TESTRAN ITEM
         LA    R10,D2                   LENGTH
         MVC   ORGBYTE(D2),=AL1(DTYPEA,D3)   DATA TYPE AND LENGTH
         BAL   R9,SYMPUNCH              OUTPUT TESTRAN ITEM
         B     EPILOGUE                 FINIS
         AGO   .CXD1
.CXD     B     MACHOP1                  SKIP
.CXD1    SPACE
CCW      BAL   R9,ALIGN                 ALIGN TO DOUBLEWORD BOUNDARY
         DC    H'-8,7'                  ALIGNMENT PARAMETERS
         LA    R1,D8                    LENGTH ATTRIBUTE
         AIF   ('&TESTRAN' NE 'YES').CCW
         ST    R3,RLCTR                 VALUE OF SYMBOL
         BAL   R9,XREF1                 CROSS-REFERENCE NAME, IF ANY
         SET   TCCW                     INDICATE TESTRAN ITEM TYPE
         BAL   R9,ANYPUNCH              OUTPUT TESTRAN ITEM
         B     EPILOGUE                 FINIS
         AGO   .CCW1
.CCW     B     MACHOP1                  SKIP
.CCW1    SPACE
MACHOP   BAL   R9,ALIGN                 ALIGN TO HALFWORD BOUNDARY
         DC    H'-2,1'                  ALIGNMENT PARAMETERS
         XC    REFCOUNT,REFCOUNT        ZERO REFCOUNT          @AZ18392
         XC    SYMCOUNT,SYMCOUNT        ZERO SYMCOUNT          @AZ18392
         GOIF  RFIELDN,OFF=MACHOP1      TEST IF NAME IS PRESENT
         LH    R1,RLNGQ                 LENGTH ATTRIBUTE
MACHOP1  ST    R3,RLCTR                 LOCATION COUNTER VALUE
         BAL   R9,XREF1                 CROSS-REFERENCE NAME, IF ANY
         AIF   ('&TESTRAN' NE 'YES').MACHOP
         SET   TMOP
         BAL   R9,MOPPUNCH              OUTPUT TESTRAN ITEM
.MACHOP  B     EPILOGUE                 FINIS
         SPACE
LITERAL  MVI   TYPECALL,LTCALL+NOESD    PASS PARAMETERS
         GOTO  DCSCAN                   DETERMINE LITERAL OBJECT LENGTH
         SR    R3,R3                    DISPLACEMENT
         LTR   R2,R15                   LENGTH OF LITERAL
         BZ    LITRPUT                  BAD IF ZERO OBJECT LENGTH
         N     R2,=F'7'                 GET MODULO SUM
         IC    R2,INDEX(R2)             USE IT TO GET INDEX VALUE
         SR    R14,R5                   FIND LITERAL SOURCE LENGTH
         BCTR  R5,0                     POINT TO LENGTH INDICATOR
         STC   R14,CHAR1                MODIFY LITERAL SOURCE LENGTH
         CH    R14,JLITLNG              SEE IF LONGER
         BNH   LITERAL4                 NOPE
         STH   R14,JLITLNG              SAVE LONGER LENGTH
LITERAL4 SR    R0,R0                    ZERO R2
         GOIF  DLOCTREF,OFF=LITERAL1    SKIP IF SO
         LA    R0,D6                    LOCATION COUNTER REFERENCED
LITERAL1 LA    R3,LATA8-D4(R2)          POINT TO RESPECTIVE CHAIN
LITERAL2 LR    R1,R3                    TUCK ON CHAIN
         L     R3,D0(,R1)               LOOK AT THE NEXT ENTRY
         LTR   R3,R3                    SEE IF AT THE END OF THE ROPE
         BZ    LITERAL3                 GO PUT IN ENTRY IF SO
         LTR   R0,R0                    IF LOCATION COUNTER REFERENCED
         BNZ   LITERAL2                 DON'T LOOK AT IT
         EX    R14,LITCLC               LOOK AT THIS LITERAL ENTRY
         BNE   LITERAL2                 SKIP IF NOT THE SAME
         L     R3,D4(,R3)               GET DISPLACEMENT OF THE ENTRY
         SLL   R14,D16                  LENGTH
         OR    R2,R14                   LENGTH
         B     LITRPUT                  PUT OUT THIS RECORD
LITERAL3 LM    R11,R12,LATADD           GET LITERAL POOL ADDR  @OX09723
         LA    R9,41(R12,R14)           ESTIMATE LENGTH OF ENTRY
         CL    R9,SYMDIMEN+4            SEE IF ENOUGH ROOM
         BH    LITRFULL                 NOT ENOUGH
         XC    D0(D4,R12),D0(R12)       ZERO CHAIN POINTER
         ST    R12,D0(,R1)              CHAIN POINTER
         L     R3,D0(R2,R11)            OBJECT LENGTH OF THIS CHAIN
         AR    R15,R3                   ADD ON LENGTH OF THIS LITERAL
         ST    R3,D4(,R12)              PUT ONE INTO THE LITERAL POOL
         ST    R15,D0(R2,R11)           THE OTHER IN ADJUSTMENT TABLE
         MVC   D10(D6,R12),EESDI        SAVE LOCATION COUNTER
         TM    XPARM,XDUMMY             TEST IF IN DSECT       @OX07274
         BZ    LITERAL5                 NO, CSECT              @OX07274
         OI    D8(R12),INDSECT          RESIDES IN DSECT       @OX10361
LITERAL5 STH   R0,D8(,R12)              INDICATE LOC COUNTER   @OX07274
         AR    R12,R0                   BUMP PAST LOCATION COUNTER
         EX    R14,LITMVC               MOVE IN LITERAL SOURCE
         AR    R12,R14                  POINT PAST LITERAL SOURCE
         SLL   R14,D16                  MOVE TO HIGH ORDER BYTE
         OR    R2,R14                   INSERT IN OUTPUT RECORD
         MVI   D11(R12),JBLANK          INSERT A BLANK
         LA    R12,D15(,R12)            ROUND TO FULLWORD BOUNDARY
         N     R12,=F'-4'               ROUND TO FULLWORD BOUNDARY
         LR    R11,R12                  SAVE CHAINPTR          @OX09723
         L     R10,LATEND               LOAD OLD PTR           @OX09723
         SR    R11,R10                  SEE IF RECORD          @OX09723
         C     R11,=F'41'               LONG ENOUGH            @OZ16488
         BNL   LITERAL6                 IF NOT LEAVE           @OX09723
         LA    R12,D4(R12)              MARGINE FOR SYMBOL TBL @OX09723
LITERAL6 ST    R12,LATADD+D4            SAVE ADDRESS OF NEXT   @OX09723,
                                        POOL ENTRY             @OX09723
         LA    R12,41(,R12)             LEAVE MARGINE          @AX14216
         ST    R12,SYMDIMEN+D12         LIMIT FOR SYMBOL TABLE
LITRPUT  LH    R10,JOUTFILE             GET OUTPUT FILE ADDRESS
         JPUTL FILE=(R10),BUFREQ=12     GET OUTPUT BUFFER
         STM   R2,R3,D4(R11)            PASS INDEX AND DISPLACEMENT
         MVC   D0(D5,R11),LITRCD        RECORD HEADER
         LH    R0,LATTR                 LENGTH ATTRIBUTE
         BCTR  R0,D0                    MINUS ONE
         STC   R0,D2(,R11)              TO RECORD
         MVC   D3(D1,R11),SYMCOUNT+D1   SYMBOL COUNT
         AIF   ('&DIAG' EQ 'NO').DUMP00
.DUMP00  B     EPILOGUE                 CLEANUP
LITRFULL SET   STBLOFLO,ON              INDICATE SYMBOL TABLE FULL
         BAL   R9,EPILOG                CLEANUP
         LH    R10,JOUTFILE             OUTPUT FILE ADDRESS
         LR    R11,R4                   OUTPUT RECORD POINTER
         JPUTM FILE=(R10),ADDR=(R11)    WRITE RECORD
         B     GETNEXT                  GET NEXT
         SPACE
ENDING   NC    LATA8(D16),LATA8         LITERAL POOL EMPTY
         BZ    LTORG2                   X
         LH    R10,FSTCSECT             ASCENDSION NUMBER
         LTR   R10,R10                  SEE IF ONE
         BZ    ENDING0                  CAN'T DO MUCH FOR THIS GUY
         SPACE
*NOTE-   THE FIRST CONTROL SECTION, IF ANY, IS RESUMED AT ITS HIGHEST *
*   ADDRESS WHEN END OF FILE IS DETECTED IN PASS 1 ASSIGNMENT MODE    *
*   AND THE LITERAL POOL IS NOT EMPTY.                                *
         GOTO  GETESD                   RESUMPTION
         LR    R6,R10                   RESUME SECTION
         AIF   ('&TESTRAN' NE 'YES').ENDING2
         BAL   R9,ESDPUNCH              OUTPUT TESTRAN ITEM
.ENDING2 ANOP
ENDING0  LH    R10,JOUTFILE             GET OUTPUT FILE ADDRESS
         JPUTM FILE=(R10),ADDR=LOCRCD   RESUMPTION RECORD
         LM    R2,R3,ELCTR              CURRENT AND HIGHEST SAVED
         CLR   R2,R3                    SEE WHICH IS GREATER
         BNH   GRRRRRRR                 R3 IS
         LR    R3,R2                    YOU'RE THE GREATEST
GRRRRRRR ST    R3,ELCTR                 SAVE
         MVC   D6(D6,R11),EESDI         PASS LOCATION COUNTER TO LINO
         SPACE
LTORG    BAL   R9,ALIGN1                ALIGN TO DOUBLEWORD BOUNDARY
         DC    H'-8,7'                  ALIGNMENT PARAMETERS
         GOIF  JTEOFII,EQUAL=LTORG2     SKIP IF FORCED LTORG
         ST    R3,RLCTR                 ADDRESS
         BAL   R9,XREF                  RECORD
         AIF   ('&TESTRAN' NE 'YES').LTORG
         BAL   R9,MISPUNCH              OUTPUT TESTRAN ITEM
.LTORG   ANOP
LTORG2   SR    R2,R2                    CLEAR REGISTER
         NC    LATA8(D16),LATA8         SEE IF CLEAN POOL
         BE    ENDING1                  SKIP IF NOT DIRTY POOL
         L     R10,LATADD               GET POINTER TO LITERAL TABLE
         LH    R14,EESDI                GET ESDID
         LR    R15,R3                   GET LOCATION COUNTER VALUE
         LM    R0,R3,D4(R10)            GET LITERAL TABLE
         AR    R0,R15                   ADDRESS OF 4-CHAIN
         AR    R1,R0                    ADDRESS OF 2-CHAIN
         AR    R2,R1                    ADDRESS OF 1-CHAIN
         AR    R3,R2                    ADDRESS OF END-OF-LITERAL-POOL
         AIF   ('&DIAG' EQ 'NO').DUMP02
.DUMP02  STM   R14,R2,D0(10)            LITERAL ADJUSTMENT TABLE
         ST    R3,ELCTR                 SAVE LOCATION COUNTER
LCSAVE   MVC   LOCTRSAV,EESDI           SAVE LOCATION COUNTER AND ESDID
         SET   LITEND,ON                TO INFORM LTDUMP       @OX09723
         LM    R2,R3,=F'-8,4'           INDEX
LTORG3   L     R5,LATA2(R2)             PASS ONE END OF A CHAIN
         BAL   R9,LTDUMP                DUMP OUT CHAIN
         BXLE  R2,R3,LTORG3             ONE CHAIN AT A TIME
         SET   LITEND,OFF                                      @OX09723
LCRESTOR MVC   EESDI(D6),LOCTRSAV       RESTORE ESDID AND VALUE
         L     R10,LATADD               RECLAIM ADDRESS
         LA    R2,D20                   LENGTH OF ONE LITERAL TABLE
         AR    R10,R2                   POINT TO NEXT TABLE
         LA    R11,D20(,R10)            POINT TO FRESH LITERAL POOL
         STM   R10,R11,LATADD           HERE WE GO AGAIN
         XC    LATA8(D16),LATA8         CLEAN OUT LITERAL POOL
         XC    D0(D20,R10),D0(R10)      CLEAR LITERAL TABLE
ENDING1  LH    R10,JOUTFILE             GET OUTPUT FILE ADDRESS
         LA    R11,D8                   RECORD LENGTH
         JPUTL FILE=(R10),BUFREQ=(R11)  GET BUFFER
         MVC   D0(D6,R11),EOFRCD        RECORD HEADER
         MVI   D4(R11),JTLTEND          RECORD TYPE
         STH   R2,D6(,R11)              PASS INCREMENT TO PASS II
         GOIF  JTEOFII,NOTEQ=EPILOGUE   SKIP IF NOT FORCED LTORG
         L     R14,LATADD               POINT TO THE END OF TABLES
         LA    R2,ENDOFCOM              POINT TO THE BEGINNING
         SR    R14,R2                   GET THE LENGTH
         LA    R3,LATA8                 POINT TO NEW ADDRESS OF TABLE
         LA    R4,LATA8(R14)            THE END OF NEW TABLE
         STM   R3,R4,LATADD             BEGINNING OF BOTH TABLES
         BNP   ENDOFILE                 DON'T MOVE IF NO LITERALS
ENDING2  BCTR  R14,0                    GET MOVE LENGTH
         EX    R14,LITMVC2              MOVE LITERAL ADJUSTMENT TABLE
         SRDL  R14,D8                   EXECUTED AMOUNT TO REGISTER 15
         SRL   R15,D24                  AMOUNT MOVED
         LA    R3,D1(R3,R15)            POINT TO NEXT SEGMENT
         LA    R2,D1(R2,R15)            POINT TO NEXT SEGMENT
         SLA   R14,D8                   AMOUNT REMAINING NOT MOVED
         BZ    ENDOFILE                 GO IF TASK COMPLETED
         B     ENDING2                  REPEAT IF NOT
         SPACE
LTDUMP   BALR  R14,R7                   SAVE REGISTERS
LTDUMP1  LTR   R4,R5                    SEE IF AT END-OF-CHAIN
         BZ    EXIT                     FINIS IF SO
         SR    R3,R3                    BUMP PAST LOC CNTR     @OX10361
         IC    R3,D9(,R4)               COMPUTE LENGTH TO-     @OX10361
         AR    R5,R3                    LITERAL TEXT IN REC    @OX10361
INDSECT  EQU   BIT0                     LIT DEF IN DSECT       @OX10361
         SR    R3,R3                    ZERO REGISTER
         GOIF  MODE2,ON=LTDUMP2         SKIP IF CHAINING MODE
         SR    R2,R2                    CLEAR REGISTER
         IC    R2,D10(,R5)              GET LITERAL SOURCE LENGTH
         LA    R2,D1(,R2)               LENGTH
         LA    R3,D13(,R2)              LENGTH
         LH    R10,JOUTFILE             GET OUTPUT FILE ADDRESS
         JPUTL FILE=(R10),BUFREQ=(R3)   GET OUTPUT BUFFER
         STH   R3,D0(,R11)              RECORD LENGTH
         MVC   D2(D6,R11),LOCRCD+D2     RECORD HEADER
         EX    R2,LITMVC1               MOVE IN LITERAL SOURCE
         LR    R3,R11                   SAVE POINTER
         MVI   TYPECALL,LTCALL+LTORGSCN PASS PARAMETERS
         CR    R4,R5                    SEE IF LOCATION COUNTER
         BE    LTDUMP3                  NO
         MVC   D6(D6,R11),D10(R4)       PASS LOCATION COUNTER
         B     LTDUMP3                  SKIP
LTDUMP2  MVI   TYPECALL,LTCALL+LTORGSCN+NOESD     PASS PARAMETERS
LTDUMP3  MVC   EESDI(D6),D10(R4)        LOCATION COUNTER
         TM    D8(R4),INDSECT           TEST IF REF IN DSECT   @OX10361
         BZ    LTDUMP4                  NO                     @OX07274
         MVI   TYPECALL,LTCALL+LTORGSCN+NOESD PASS PARAM       @OX07274
LTDUMP4  LA    R5,D11(,R5)              TEXT POINTER           @OX07274
         AIF   ('&DIAG' EQ 'NO').DUMP04
.DUMP04  GOTO  DCSCAN                   SCAN LITERAL SOURCE ONCE MORE
         MVI   TYPECALL,D0              CLEAR PARAMETER
         SR    R0,R0                    ZERO ZERO
         STH   R0,SYMCOUNT              RESET SYMBOL COUNT
         GOIF  (STBLOFLO,LITEND),NOTALL=LTDUMP5 USE LIT POOL   @OX09723
         LA    R5,D20(R4)               ADD 20 FOR X4S         @OX09723
         ST    R5,SYMDIMEN+D4           NEW POINTER            @OX09723
LTDUMP5  L     R5,D0(,R4)               GET CHAIN POINTER
         LTR   R3,R3                    SEE IF LENGTH ATTRIBUTE DEFINED
         BE    LTDUMP1                  SKIP IF NOT NEEDED
         IC    R0,LATTR+D1              GET LENGTH ATTRIBUTE
         BCTR  R0,D0                    MINUS ONE
         STC   R0,D2(,R3)               TO OUTPUT RECORD
         B     LTDUMP1                  TAKE IT FROM THE TOP
         SPACE
LTORGII  L     R14,LATADD               ADJUSTMENT TABLE ADDRESS
         AH    R14,RESDI                INCREMENT
         ST    R14,LATADD               UPDATE
         B     TRANSFER                 FINIS
         SPACE
LITRII   LH    R10,RESDI                ADJUSTMENT INDEX
         LTR   R10,R10                  SEE IF VALID DEFINITION
         BZ    TRANSFER                 BAD LITERAL
         L     R14,LATADD               LITERAL ADJUSTMENT TABLE
         L     R11,D0(R10,R14)          ADJUSTMENT FACTOR, POOL ADDRESS
         A     R11,RLCTR                LITERAL'S DISPLACEMENT IN CHAIN
         ST    R11,RLCTR                ADJUSTED LITERAL ADDRESS
         LH    R10,D2(,R14)             ESDID OF LITERAL POOL
         STH   R10,RESDI                ADJUSTED LITERAL ESDID
         AIF   ('&DIAG' EQ 'NO').DUMP06
.DUMP06  SPACE
ADJUST   LH    R10,RESDI                ESDID
         L     R11,RLCTR                OFFSET
         LM    R14,R1,ADJINDEX          ADJUSTMENT PARAMETERS
ADJUST2  BXLE  R14,R15,TRANSFER         STEP INDEX
         CH    R10,D0(R1,R14)           SEE IF ADJUSTMENT ENTRY
         BNE   ADJUST2                  GO AGAIN IF NOT
         LH    R10,D2(R1,R14)           GET ADJUSTED ESDID
         STH   R10,RESDI                PASS IN RECORD
         A     R11,D4(R1,R14)           ADD ADJUSTMENT FACTOR
         ST    R11,RLCTR                PASS IN RECORD
         SPACE
TRANSFER LH    R10,JOUTFILE             ADDRESS OF OUTPUT FILE
         LR    R11,R4                   OUTPUT RECORD ADDRESS
         JPUTM FILE=(R10),ADDR=(R11)    OUTPUT RECORD
         B     EPILOGUE                 CHECK SYMBOL TABLE OVERFLOW
         SPACE
ALIGN1   TM    JPARM2,JALGN             TEST ALIGN OPTION
         BZ    D4(,R9)                  RETURN TO MAINLINE IF OFF
ALIGN    LH    R0,D0(,R9)               GET ALIGN MASK
         AH    R3,D2(,R9)               EXCESS FOR ALIGNMENT
         NR    R3,R0                    ROUND TO SPECIFIC BOUNDARY
         AIF   ('&TESTRAN' NE 'YES').ALIGN
         LR    R0,R3                    GET NEW LOCATION COUNTER
         S     R0,ELCTR                 GET NUMBER OF BYTES SKIPPED
         MVC   ADDRESS,ELCTR+D1         ADDRESS
         ST    R3,ELCTR                 UPDATE CURRENT LOCATION COUNTER
         LA    R9,D4(,R9)               PASS RETURN ADDRESS
         BER   R9                       NO BYTES SKIPPED
         SET   TSPACE                   ORGINIZATION BYTE
         STC   R0,NAME                  LENGTH, NUMBER OF BYTES SKIPPED
         LA    R10,D5                   LENGTH OF SPACE RECORD
         B     SYMPUNCH                 PUT OUTPUT ONTO 'SYM' CARD
         AGO   .ALIGN1
.ALIGN   ST    R3,ELCTR                 UPDATE CURRENT LOCATION COUNTER
         B     D4(,R9)                  RETURN TO MAINLINE
.ALIGN1  SPACE
XREF     LA    R1,D1                    ASSUME LENGTH ATTRIBUTE IS ONE
XREF1    GOIF  RFIELDN,OFF=(R9)         BUG OUT IF NOT NAMED
         STH   R1,RLNGQ                 PASS LENGTH ATTRIBUTE
         BALR  R14,R7                   PUSH REGISTERS
         GOIF  PRIORDEF,ON=WRITE3       CHECK IF PREVIOUSLY DEFINED
         LR    R10,R4                   PASS RECORD POINTER
         GOTO  ENTER                    ENTER IN SYMBOL TABLE
         BE    WRITE3                   ENTERED SUCCESSFULLY
         SET   PRIORDEF,ON              INDICATE SYMBOL ALREADY DEFINED
         B     WRITE3                   SNEAK IN THE BACK DOOR
         AIF   ('&TESTRAN' NE 'YES').WRITE
XREF3    BAL   R9,MISPUNCH              OUTPUT TESTRAN ITEM
.WRITE   SPACE
WRITE    LA    R9,EPILOGUE              DEFINE EXIT
WRITE1   GOIF  RFIELDN,OFF=(R9)         GIVE UP IF NOT NAMED
WRITE2   BALR  R14,R7                   PUSH REGISTERS
WRITE3   LA    R2,D24                   CROSS-REFERENCE RECORD LENGTH
         GOIF  RFIELDN,ON=RECL22        TEST IF NAME IS PRESENT
         LA    R2,D12                   RECORD LENGTH WITHOUT NAME
RECL22   LH    R10,JOUTFILE
         LR    R11,R2
         JPUTL FILE=(R10),BUFREQ=(R11)
         SH    R2,=AL2(D3)              GET MOVE LENGTH
         EX    R2,MOVEREC               MOVE RECORD TO OUTPUT FILE
         STH   R2,D0(,R11)
         MVI   JTIOP1-JTRLI(R11),JTADJII
         B     EXIT                     RETURN
MOVEREC  MVC   D2(,R11),D2(R4)          MOVE RECORD TO OUTPUT FILE
         SPACE
EPILOGUE BAL   R9,EPILOG                CLEANUP ROUTINE
         B     GETNEXT                  CONTINUE
EPILOG   BALR  R14,R7                   SAVE REGISTERS
         GOIF  STBLOFLO,OFF=GET         IS SYMBOL TABLE FULL
         GOIF  MODE1,ON=GET
         GOIF  MODE2,ON=GET             CHECK IF 1S MODE
         SET   MODE2,ON                 CHANGE MODE
         LM    R2,R3,=F'-8,4'           LOAD UP WITH INDEX
         EX    R0,LCSAVE                SAVE LOCATION COUNTER
EPILOOP  L     R5,LATA2(R2)             GET ONE END OF CHAIN
         BAL   R9,LTDUMP                DUMP OUT THE SYMBOLS
         BXLE  R2,R3,EPILOOP            DO IT TO ALL FOUR CHAINS
         EX    R0,LCRESTOR              RESTORE LOCATION COUNTER
         LH    R10,JOUTFILE             GET OUTPUT FILE ADDRESS
         JPUTM FILE=(R10),ADDR=EOFRCD   PUT OUT AN END-OF-FILE RECORD
GET      GOIF  INOTE,OFF=EXIT
         SET   INOTE,OFF                RESET CONDITION
         LH    R10,JINFILE              GET INPUT FILE ADDRESS
         JPOINT  FILE=(R10),ADDR=INOTEVAL,NEXT=GET
         B     EXIT                     FINIS
         SPACE
MAKESD   GOTO  MAKESD                   GO TO MAKE ESD
         B     GETNEXT
         SPACE
ENDOFILE LH    R10,JOUTFILE             GET OUTPUT FILE ADDRESS
         LA    R11,EOFRCD               POINT TO END-OF-FILE
         JPUTM FILE=(R10),ADDR=(R11)    WRITE ONE LAST RECORD
BUGOUT   LH    R10,JOUTFILE             GET FILE ADDRESS
         JPOINT  FILE=(R10),NEXT=START  POINT TO BEGINNING OF FILE
         LH    R10,JINFILE              GET ADDRESS OF CURRENT INPUT
         MVC   JINFILE,JOUTFILE         OLD OUTPUT FILE BECOMES INPUT
         STH   R10,JOUTFILE             OLD INPUT FILE BECOMES OUTPUT
         JPOINT  FILE=(R10),NEXT=START  POINT TO BEGINNING OF OUTPUT
         AIF   ('&DIAG' EQ 'NO').DUMP08
.DUMP08  SET   (MODE1,MODE2),FLIP       CHANGY, CHANGY
         GOIF  (MODE1,MODE2),MIX=GETNEXT,ALL=MAKESD
         LR    R10,R7                   POINT TO COMMON
         JFRECORE  ADDR=(R10)           FREE IT UP
         B     III                      PHASE EXIT
         AIF   ('&TESTRAN' EQ 'NO').TEST80
         EJECT
*TITLE-  ESDPUNCH                                                     *
*                                                                     *
*FUNCTION/OPERATION-                                                  *
*        FORMAT TESTRAN ITEMS FOR ROUTINE 'SYMPUNCH'.                 *
*                                                                     *
*INPUT-  REGISTER R6 POINTS TO AN ESD CONTROL SECTION ENTRY.          *
*                                                                     *
*OUTPUT- TESTRAN ITEMS IN STORAGE FOR ROUTINE 'SYMPUNCH'.             *
*                                                                     *
         SPACE
MISPUNCH SET   TMIS                     ORGANIZATION BYTE
MOPPUNCH GOIF  (RFIELDN,PRIORDEF)       TEST
         BNMR  R9                       RETURN
ANYPUNCH LA    R10,D4                   LENGTH OF ITEM ASSUMED
         MVC   ADDRESS,RLCTR+D1         ADDRESS
         GOIF  RFIELDN,OFF=SYMPUNCH     FINISHED IF NO NAME
         MVC   NAME,RNAME               MOVE NAME
         IC    R10,RFLDI                GET NAME LENGTH BITS
         N     R10,=F'7'                KEEP LENGTH BITS ONLY
         LA    R10,D5(,R10)             LENGTH OF ITEM CONFIRMED
         B     STORELNG                 CONTINUE
ESDPUNCH CLC   XSSAV,EESDI              SEE IF ACTUAL
         BER   R9                       YEAH
         MVC   XSSAV,EESDI              SAVE
         LA    R10,D4                   LENGTH
         MVC   ORGBYTE,ETYPE            ORGINIZATION BYTE
         TR    ORGBYTE,=AL1(TCSECT,0,0,0,TCSECT,TCOM,0,0,TDSECT)
         XC    ADDRESS,ADDRESS          ADDRESS
         CLI   ENAME,JA                 SEE IF NAMED
         BL    SYMPUNCH                 NAMELESS
         MVC   NAME,ENAME               MOVE IN NAME
         LA    R10,EITEM+D13            POINT TO LAST CHARACTER
LOOPLOOP BCTR  R10,0                    LOOK AT NEXT CHARACTER
         CLI   ENAME-EITEM-D5(R10),JBLANK    SEE IF PADDED
         BE    LOOPLOOP                 LOOP ON FALSIES
         SR    R10,R6                   FIND THE LENGTH OF THE NAME
STORELNG LA    R1,BIT4-D5(,R10)         RIG MASK
         EX    R1,SOKITUMI              INDICATE NAME PRESENT
         TR    NAME,JTRTABLE            TRANSLATE NAME
         SPACE
SYMPUNCH STM   R9,R1,TERMS              SAVE REGISTERS
         GOTO  SYMPUNCH                 GO TO OUTPUT ROUTINE
         LM    R9,R1,TERMS              RESTORE REGOSTERS
         BR    R9                       RETURN
         SPACE
SOKITUMI XI    ORGBYTE,D0               EXECUTED INSTRUCTION
.TEST80  SPACE
         DS    0F
CSTPARM  DC    AL1(ESDNRSW+CSECTSW+DSECTSW+XENTRY,ETYPEPC,ETYPESD,0)
DSTPARM  DC    AL1(ESDNRSW+DSCOMSW+DSECTSW+XDUMMY,ETYPEDS,ETYPEDS,CSW)
COMPARM  DC    AL1(ESDNRSW+DSCOMSW+CSECTSW,ETYPECM,ETYPECM,CSW)
DXDPARM  DC    AL1(ESDNRSW+DSCOMSW+DSECTSW,ETYPEXD,ETYPEXD,DSW)
EOFRCD   DC    H'8',AL1(JPSOP,0,JTEOFII,0)   END-OF-FILE RECORD
LOCRCD   DC    HL2'12',AL1(JPSOP,0,JTADJII,0),HL2'0'   LITERAL DC
LITRCD   DC    HL2'12',AL1(JPSOP,0,JTLITII,0)     LITERAL RECORD HEADER
INDEX    DC    AL1(4,16,12,16,8,16,12,16)    LITERAL HASH INDEX
TMINST   TM    D0(R15),D0               EXECUTED INSTRUCTION
LITCLC   CLC   D10(D0,R3),CHAR1         EXECUTED INSTRUCTION
LITMVC   MVC   D10(D0,R12),CHAR1        EXECUTED INSTRUCTION
LITMVC1  MVC   D12(D0,R11),D10(R5)      EXECUTED INSTRUCTION
LITMVC2  MVC   D0(D0,R3),D0(R2)         EXECUTED INSTRUCTION
         SPACE
RADIX    DC    A(IA,IS,IIS,IIA)         MODES
IA       EQU   *-2*JTPREP               PASS 1 ASSIGNMENT MODE
         ORG   IA+2*JTPREP              TABLE INDEX
         DC    Y(IA-REPRO)              ROUTINE VECTOR
         ORG   IA+2*JTPPCH              TABLE INDEX
         DC    Y(IA-PUNCH)              ROUTINE VECTOR
         ORG   IA+2*JTINPC              TABLE INDEX
         DC    Y(IA-INPC)               ROUTINE VECTOR
         ORG   IA+2*JTPMOP              TABLE INDEX
         DC    Y(IA-MACHOP)             ROUTINE VECTOR
         ORG   IA+2*JTEND               TABLE INDEX
         DC    Y(IA-GETNEXT)            ROUTINE VECTOR
         ORG   IA+2*JTDXD               TABLE INDEX
         DC    Y(IA-DXD)                ROUTINE VECTOR
         ORG   IA+2*JTEQU               TABLE INDEX
         DC    Y(IA-EQU)                ROUTINE VECTOR
         ORG   IA+2*JTORG               TABLE INDEX
         DC    Y(IA-ORG)                ROUTINE VECTOR
         ORG   IA+2*JTCNOP              TABLE INDEX
         DC    Y(IA-CNOP)               ROUTINE VECTOR
         ORG   IA+2*JTCCW               TABLE INDEX
         DC    Y(IA-CCW)                ROUTINE VECTOR
         ORG   IA+2*JTDC                TABLE INDEX
         DC    Y(IA-DC)                 ROUTINE VECTOR
         ORG   IA+2*JTDS                TABLE INDEX
         DC    Y(IA-DS)                 ROUTINE VECTOR
         ORG   IA+2*JTSTART             TABLE INDEX
         DC    Y(IA-START)              ROUTINE VECTOR
         ORG   IA+2*JTCSECT             TABLE INDEX
         DC    Y(IA-CSECT)              ROUTINE VECTOR
         ORG   IA+2*JTDSECT             TABLE INDEX
         DC    Y(IA-DSECT)              ROUTINE VECTOR
         ORG   IA+2*JTCOM               TABLE INDEX
         DC    Y(IA-COM)                ROUTINE VECTOR
         ORG   IA+2*JTENTRY             TABLE INDEX
         DC    Y(IA-ENTRY)              ROUTINE VECTOR
         ORG   IA+2*JTEXTRN             TABLE INDEX
         DC    Y(IA-EXTRN)              ROUTINE VECTOR
         ORG   IA+2*JTWXTRN             TABLE INDEX
         DC    Y(IA-WXTRN)              ROUTINE VECTOR
         ORG   IA+2*JTCXD               TABLE INDEX
         DC    Y(IA-CXD)                ROUTINE VECTOR
         ORG   IA+2*JTLTORG             TABLE INDEX
         DC    Y(IA-LTORG)              ROUTINE VECTOR
         ORG   IA+2*JTLITR              TABLE INDEX
         DC    Y(IA-LITERAL)            ROUTINE VECTOR
         ORG   IA+2*JTSYMBL             TABLE INDEX
         DC    Y(IA-SYMBL)              ROUTINE VECTOR
         ORG   IA+2*JTEOFII             TABLE INDEX
         DC    Y(IA-ENDING)             ROUTINE VECTOR
         ORG   IA+2*JTADJII             TABLE INDEX
         DC    Y(IA-TRANSFER)           ROUTINE VECTOR
         ORG   IA+2*JTPASS              TABLE INDEX
         DC    Y(IA-TRANSFER)           ROUTINE VECTOR
         ORG   ,                        END-OF-TABLE
IS       EQU   *-2*JTPMOP               PASS 1 SUBSTITUTION MODE
         ORG   IS+2*JTPMOP              TABLE INDEX
         DC    Y(IS-SEARCH)             ROUTINE VECTOR
         ORG   IS+2*JTEND               TABLE INDEX
         DC    Y(IS-TRANSFER)           ROUTINE VECTOR
         ORG   IS+2*JTDXD               TABLE INDEX
         DC    Y(IS-SEARCH)             ROUTINE VECTOR
         ORG   IS+2*JTEQU               TABLE INDEX
         DC    Y(IS-SEARCH)             ROUTINE VECTOR
         ORG   IS+2*JTORG               TABLE INDEX
         DC    Y(IS-SEARCH)             ROUTINE VECTOR
         ORG   IS+2*JTCNOP              TABLE INDEX
         DC    Y(IS-SEARCH)             ROUTINE VECTOR
         ORG   IS+2*JTCCW               TABLE INDEX
         DC    Y(IS-SEARCH)             ROUTINE VECTOR
         ORG   IS+2*JTDC                TABLE INDEX
         DC    Y(IS-SEARCH)             ROUTINE VECTOR
         ORG   IS+2*JTDS                TABLE INDEX
         DC    Y(IS-SEARCH)             ROUTINE VECTOR
         ORG   IS+2*JTSTART             TABLE INDEX
         DC    Y(IS-SEARCH)             ROUTINE VECTOR
         ORG   IS+2*JTCSECT             TABLE INDEX
         DC    Y(IS-SEARCH)             ROUTINE VECTOR
         ORG   IS+2*JTDSECT             TABLE INDEX
         DC    Y(IS-SEARCH)             ROUTINE VECTOR
         ORG   IS+2*JTCOM               TABLE INDEX
         DC    Y(IS-SEARCH)             ROUTINE VECTOR
         ORG   IS+2*JTENTRY             TABLE INDEX
         DC    Y(IS-ENTRY)              ROUTINE VECTOR
         ORG   IS+2*JTEXTRN             TABLE INDEX
         DC    Y(IS-SEARCH)             ROUTINE VECTOR
         ORG   IS+2*JTWXTRN             TABLE INDEX
         DC    Y(IS-SEARCH)             ROUTINE VECTOR
         ORG   IS+2*JTCXD               TABLE INDEX
         DC    Y(IS-SEARCH)             ROUTINE VECTOR
         ORG   IS+2*JTLTORG             TABLE INDEX
         DC    Y(IS-SEARCH)             ROUTINE VECTOR
         ORG   IS+2*JTLITR              TABLE INDEX
         DC    Y(IS-TRANSFER)           ROUTINE VECTOR
         ORG   IS+2*JTSYMBL             TABLE INDEX
         DC    Y(IS-SYMBL)              ROUTINE VECTOR
         ORG   IS+2*JTEOFII             TABLE INDEX
         DC    Y(IS-ENDOFILE)           ROUTINE VECTOR
         ORG   IS+2*JTADJII             TABLE INDEX
         DC    Y(IS-TRANSFER)           ROUTINE VECTOR
         ORG   IS+2*JTPASS              TABLE INDEX
         DC    Y(IS-TRANSFER)           ROUTINE VECTOR
         ORG   ,                        END-OF-TABLE
IIS      EQU   *-2*JTSYMBL              PASS 2 SUBSTITUTION MODE
         ORG   IIS+2*JTSYMBL            TABLE INDEX
         DC    Y(IIS-SYMBOL)            ROUTINE VECTOR
         ORG   IIS+2*JTEOFII            TABLE INDEX
         DC    Y(IIS-EOFIIS)            ROUTINE VECTOR
         ORG   IIS+2*JTLITII            TABLE INDEX
         DC    Y(IIS-TRANSFER)          ROUTINE VECTOR
         ORG   IIS+2*JTLTEND            TABLE INDEX
         DC    Y(IIS-TRANSFER)          ROUTINE VECTOR
         ORG   IIS+2*JTADJII            TABLE INDEX
         DC    Y(IIS-TRANSFER)          ROUTINE VECTOR
         ORG   IIS+2*JTPASS             TABLE INDEX
         DC    Y(IIS-TRANSFER)          ROUTINE VECTOR
         ORG   IIS+2*JTSYMII            TABLE INDEX
         DC    Y(IIS-REHASH)            ROUTINE VECTOR
         ORG   ,                        END-OF-TABLE
IIA      EQU   *-2*JTSYMBL              PASS 2 ADJUSTMENT MODE
         ORG   IIA+2*JTSYMBL            TABLE INDEX
         DC    Y(IIA-SYMBOL)            ROUTINE VECTOR
         ORG   IIA+2*JTEOFII            TABLE INDEX
         DC    Y(IIA-BUGOUT)            ROUTINE VECTOR
         ORG   IIA+2*JTLITII            TABLE INDEX
         DC    Y(IIA-LITRII)            ROUTINE VECTOR
         ORG   IIA+2*JTLTEND            TABLE INDEX
         DC    Y(IIA-LTORGII)           ROUTINE VECTOR
         ORG   IIA+2*JTADJII            TABLE INDEX
         DC    Y(IIA-ADJUST)            ROUTINE VECTOR
         ORG   IIA+2*JTPASS             TABLE INDEX
         DC    Y(IIA-TRANSFER)          ROUTINE VECTOR
         ORG   ,                        END-OF-TABLE
         SPACE
         MEND
