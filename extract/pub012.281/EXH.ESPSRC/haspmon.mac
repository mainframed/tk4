HASPMON  TITLE 'HASP-4 MONITOR'
         PRINT NOGEN
*
*
*   HASPMON - A MONITOR OF HASP 4 SPOOL UTILIZATION, CONSOLE/SPOOL
*             BUFFER USAGE, AND I/O AND JOB ACTIVITY
*
*   HASPMON IS COMPOSED OF TWO PROGRAMS: HASPMON (MONITORS HASP) AND
*   HASPRINT (FORMATS AND PRINTS HASPMON OUTPUT).
*
*   SAMPLE JCL ---
*     //HASPMON EXEC PGM=HASP4MON,REGION=20K
*     //STEPLIB  DD ...
*     //HASPSTAT DD DSN=&&STAT,UNIT=WORK,DISP=(,PASS),SPACE=(TRK,1)
*     //SYSPRINT DD SYSOUT=A
*     //SYSUDUMP DD SYSOUT=A
*     //HASPRINT EXEC PGM=HASPRINT,REGION=30K
*     //STEPLIB  DD ...
*     //HASPSTAT DD DSN=&&STAT,DISP=(OLD,DELETE)
*     //SYSPRINT DD SYSOUT=A
*     //SYSUDUMP DD SYSOUT=A
*
*   WRITTEN AT OHIO STATE (?) FOR HASP 3.1
*
*   UPDATED FOR HASP 4 AT NASA-GSFC BY FRANK PAJERSKI (301) 982-4672
*
*   MODIFIED TO OUTPUT MONITOR DATA AT 10 MINUTE INTERVALS  (AUG, 1978)
*                                   BY BRUCE LELAND   (805) 982-5447
*   01NOV77-
*    . COMMENTS ADDED
*    . &BUFNUM REPLACED &MINBUF TO HANDLE THOSE HASPS WITH &MINBUF
*      SET VERY HIGH TO FORCE BUFFER USAGE MESSAGE AT START-UP TIME
*    . $OUTPUT COMBINES $PRINT AND $PUNCH (HASP 3 JQE FLAGS) ---
*      NOTE THIS MEANS THAT OUTPUT WAIT CAN NO LONGER BE DECIPHERED
*      TWIXT PRINT AND PUNCH
*    . &NUMTPES AND &NUMCONS SYMBOLIC PARAMETERS FOR HASP 3 DELETED
*    . SET LINE-COUNT IN 'PRINT' FOR 54 LINES/PAGE
*
         SPACE 2
         MACRO
&NAME    $DISABLE
&NAME    MODESET ENABLE=NO
         MEND
         SPACE 1
         MACRO
&NAME    $ENABLE
&NAME    MODESET ENABLE=YES
         MEND
         EJECT
         COPY  $GLOBAL
         SPACE 2
         GBLA  &BUFNUM       NUMBER OF BUFFERS IN USE BY HASP
         SPACE 2
HASPMON  CSECT
         SPACE 2
&BUFNUM  SETA  170           *** SET THIS A FEW MORE THAN IN USE ****
         SPACE 2
         COPY  $HASPGEN
         SPACE 2
         $HASPCB BUFFER,CMB,DCT,DCB,DEB,UCB,TED,JQE,HCT,PCE,DOC=NO
         TITLE 'HASP-4 MONITOR'
*
*   START HERE . . .
*
         PRINT ON,NOGEN
         SPACE 2
         USING *,R13,R9,R12           /ABL (ADDED BASE REG 9)
*****    USING HASP,R11
SAVEAREA DC    9D'0'
TABCLEAR ST    R0,0(,R1)           CLEAR ONE WORD
         BXLE  R1,R2,TABCLEAR      NOW DO THE REST
MONLOOP  LM    R1,R2,ALSTATB       GET A($ALSTATB,F'50')
         L     R3,0(,R1)           GET NUM OF ALLOC T.G.S
         MR    R2,R2                TIMES 50 FOR SCALING
         D     R2,4(,R1)           DIVIDED BY NUMBER OF TOTAL T.G.S
         SLL   R3,2                ADJUST FOR FULL WORD COUNTER
         L     R1,SPOOL(R3)        GET PROPER COUNTER
         A     R1,=F'1'            ADD ONE TO IT
         ST    R1,SPOOL(R3)          AND SAVE IT
         SRL   R3,1                CONVERT TO PERCENT
         ST    R3,SAMPUSE@           AND SAVE IT
         LH    R2,$COMMCT          FREE CMB BUFFERS
         ST    R2,SAMPCMBF
         SLL   R2,2                SET FOR PROPER NNDEX
         L     R1,CONBUF(R2)       GET THE RIGHT COUNTER
         A     R1,=F'1'             ADD ONE TO IT
         ST    R1,CONBUF(R2)         AND SAVE IT
         SR    R2,R2               SET COUNTER TO
         BCTR  R2,0                 MINUS ONE
         $DISABLE ALL              DISABLE
         LA    R1,$BUFPOOL-(BUFCHAIN-BUFDSECT) START OF SPOOL BUFS
BUFA     L     R1,BUFCHAIN-BUFDSECT(,R1)
         A     R2,=F'1'            ADD ONE TO COUNTER
         LA    R1,0(,R1)           ZERO POSSIBLE FLAGS IN H.O.B.
         LTR   R1,R1               IF NOT ZERO
         BNZ   BUFA                 THEN LOOP SOME MORE
         $ENABLE ALL               TURN IRH LOOSE
         ST    R2,SAMPBUFP         FREE BUFFERS
         LA    R1,&BUFNUM           CHECK FOR MORE
         CR    R1,R2                AND USE
         BNL   *+6                  MINIMUM
         LR    R2,R1                IF TOO MANY
         SLL   R2,2                EACH ENTRY IS 4 BYTES LONG
         L     R1,BUF(R2)          GET THE COUNTER
         A     R1,=F'1'             ADD ONE
         ST    R1,BUF(R2)            AND SAVE IT
         SR    R1,R1               ZERO FOR IC
         LH    R1,$EXCPCT          GET CURRENT I/O COUNTER
         CH    R1,=H'40'           IF COUNT GTR 40
         BNH   *+8                  THEN USE
         LH    R1,=H'40'            40 INSTEAD
         SLL   R1,2                SET INDEX
         L     R2,IO(R1)           GET COUNTER
         A     R2,=F'1'             ADD ONE
         ST    R2,IO(R1)             AND SAVE IT
         IC    R1,$XEQACT          JOBS IN OS XEQ
         SLL   R1,2                FOR INSEX
         L     R2,XEQ(R1)          GET THE COUNT
         A     R2,=F'1'             ADD ONE
         ST    R2,XEQ(R1)            AND SAVE IT
         LA    R4,DCT              ADDRESS OF COUNTERS
         LA    R2,$DCTPOOL-(DCTCHAIN-DCTDSECT)  SET FOR FIRST LOAD
         USING DCTDSECT,R2
MDCTA    L     R2,DCTCHAIN         GET A POINTER
         CLI   DCTDEVTP,DCTOLAY    IF THE OVERLAY DCT
         BE    MDCTEND              WE ARE ALL DONE
         TM    DCTSTAT,DCTINUSE    IS THE DEVICE BEING USED
         BZ    MDCTB                IF NOT THEN DONT COUNT
         L     R5,0(,R4)           GET THE COUNTER
         A     R5,=F'1'             ADD ONE TO IT
         ST    R5,0(,R4)             AND SAVE IT
MDCTB    LA    R4,4(,R4)           NEXT COUNTER ADDRESS
         B     MDCTA               NOW GO LOOP
         DROP R2
MDCTEND  NULL
*        GET HEAD POSITION FOR ACTIVE SPOOLS
         LA    R1,$DACKPT          SPOOL CHECKPOINT FIELD
         LA    R2,&NUMDA           NUMBER OF SPOOLS GENED FOR HASP
         L     R3,AMTTR            ADDRESS OF TABLE
         L     R4,$TEDADDR         ADDRESS OF TED
         USING TEDDSECT,R4
MTTRA    CLI   0(R1),X'00'         IF ZERO THIS
         BE    MTTREND              SPOOL IS NOT USED
         L     R5,200(,R3)         COUNT THIS
         A     R5,=F'1'             USE OF
         ST    R5,200(,R3)           THE SPOOL
         L     R6,TNCH             GET LAST SEEK MTTR
         LA    R6,0(,R6)           CLEAR EXTENT NUMBER
         SRDL  R6,40               ZERO R6, THROW AWAY 'R' OF TTR
         D     R6,TNTC             FIND CYLINDER NUMBER
         N     R7,=F'-8'  WAS -4   GROUP 0-3,4-7, ETC   (FOR 2314'S)
         SRL   R7,1                DIVIDE BY TWO       **  FOR
         CH    R7,=H'196'          GREATER THAN 392?   **     3330'S
         BL    *+8                 NO, BRANCH          **
         LH    R7,=H'196'          USE THE EQUIVALENT OF 392
         L     R5,0(R3,R7)         GET THE COUNT
         A     R5,=F'1'             ADD ONE TO IT
         ST    R5,0(R3,R7)           AND SAVE IT
MTTREND  LA    R1,6(,R1)           INC TO NEXT CKPT
         LA    R3,204(,R3)          NEXT SPOOL TABLE
         LA    R4,TEDSIZ(R4)        AND NEXT TED
         BCT   R2,MTTRA            NOW SPIN FOR ALL SPOOLS
         DROP  R4
         IC    R1,$STATUS          GET $STATUS
         SRL   R1,1                 SAVE ONLY
         SLL   R1,25                BITS 0 THRU 6
         LA    R2,RDRPEND          START HERE
MISCLOOP ALR   R1,R1               SET CC AND SHIFT LEFT
         BC    8,MISCEND           END IF ZERO, NO CARRY
         BC    12,MISCLUP          B IF NO CARRY
         L     R3,0(,R2)           GET THE COUNTER
         A     R3,=F'1'             ADD ONE TO IT
         ST    R3,0(,R2)            AND SAVE IT
MISCLUP  LA    R2,4(,R2)           POINT TO NEXT COUNTER
         B     MISCLOOP            CONTINUE
MISCEND  EQU   *
         SR    R2,R2               ZERO R2   $XEQ
         LR    R3,R2               AND R3    $OUTPUT (OR $HARDCOPY)
         LR    R4,R2                AND R4   $SETUP (LOCAL QUEUE)
         $DISABLE ALL
         LA    R0,4                SET THE COUNT INC
         L     R1,$JQENT           GET THE START OF THE QUEUE
         BAL   R6,*+8              SET RETURN INTO R6 AND SKIP 1ST LOAD
         L     R1,QUECHAIN(R1)     DOWN THE CHAIN
         LA    R1,0(,R1)           ZERO POSSIBLE FLAGS IN H.O.B.
         LTR   R1,R1               IF QUE IS EMPTY
         BZ    QUEND                THE EXIT
         TM    QUETYPE(R1),QENTBY  IF THIS ENTRY IS ACTIVE
         BOR   R6                   THEN SKIP IT
         TM    QUETYPE(R1),X'70'   LOCAL JCL-SCAN QUEUE ?
         BNO   *+8           NO
         AR    R4,R0         UP COUNT
         BR    R6            RETURN
         TM    QUETYPE(R1),$XEQ    IS THIS CORRECT
         BZ    *+8                 IF NOT TRY ANOTHER
         AR    R2,R0               INC WHEN FOUND
         BR    R6                  SPIN
         TM    QUETYPE(R1),$OUTPUT+$HARDCPY  PRINT OR PUNCH?
         BZ    *+8                 NO, TRY ANOTHER
         AR    R3,R0               INC WHEN FOUND
         BR    R6                  SPIN
         TM    QUETYPE(R1),$SETUP  JCLCHECK OR $SETUP QUEUE?
         BZR   R6                  SPIN IF NOT
         AR    R4,R0               INC WHEN FOUND
         BR    R6                  SPIN
QUEND    $ENABLE ALL               DONT NEED IT ANY MORE
         LA    R0,1                SET INC
         L     R6,AQXEQ            GET COUNT TABLE ADDRESS
         L     R1,0(R2,R6)         GET THE COUNTER
         AR    R1,R0                ADD ONE TO IT
         ST    R1,0(R2,R6)           AND STORE IT BACK
         L     R6,AQOUTPUT
         L     R1,0(R3,R6)
         AR    R1,R0
         ST    R1,0(R3,R6)
         L     R6,AQJCLCK
         L     R1,0(R4,R6)
         AR    R1,R0
         ST    R1,0(R4,R6)
         SPACE 2
         LA    R3,$HASPWT     BEGINNING OF FIELD
         LA    R0,1           COUNT INCREMENT
         LA    R1,4           LOCATION INCREMENT
         IC    R6,$HASPECF    DECODE THE HASP EVENT WAIT FIELD
         SLL   R6,24          SHIFT TO SIGN POSITION
WAITBIT  ALR   R6,R6          BIT SET?
         BZ    WAITEND        NO -- AND NO MORE ARE EITHER
         BM    *+14           NO, BRANCH
         L     R5,0(,R3)      YES, INCREMENT
         AR    R5,R0                        THIS
         ST    R5,0(,R3)                        COUNTER
         AR    R3,R1          NEXT COUNTER
         B     WAITBIT        DO THE NEXT BIT
WAITEND  DS    0H
         SPACE 2
         L     R1,COUNT       UPDATE COUNT
         A     R1,=F'1'
         ST    R1,COUNT
         SR    R0,R0
         D     R0,=F'8'
         M     R0,=F'8'
         C     R1,COUNT       SAMPLE FOR MONITOR OUTPUT EVERY 8
         BNE   LATER          NOT THIS ONE, BRANCH
         SPACE 5
*     SAMPLING FOR OUTPUT DURING MONITORING
         L     R2,COUNTS
         A     R2,=F'1'       SAVE THIS SAMPLE COUNT
         ST    R2,COUNTS
         SR    R1,R1
         IC    R1,$XEQACT        JOBS IN O/S EXECUTION
         ST    R1,SAMPOSX
         IC    R1,$ACTIVE        ACTIVE HASP FUNCTIONS
         ST    R1,SAMPACTF
         LH    R1,$EXCPCT        ACTIVE HASP I/O COUNT
         ST    R1,SAMPAIO
         $DISABLE ALL
         LA    R1,$TPBPOOL       FIRST AVAILABLE RJE BUFFER
         LA    R2,40             LINK TO NEXT BUFFER
         BAL   R3,COUNTBF
         ST    R4,SAMPFRJE
         LA    R1,$BUSYQUE       CMB'S QUEUED FOR I/O
         SR    R2,R2
         BAL   R3,COUNTBF
         ST    R4,SAMPCMBI
         LA    R1,$LOGQUE        CMB'S QUEUED FOR LOG PROCESSOR
         SR    R2,R2
         BAL   R3,COUNTBF
         ST    R4,SAMPCMBL
         LA    R1,$COMMQUE       CMB'S QUEUED FOR COMMAND PROC
         SR    R2,R2
         BAL   R3,COUNTBF
         ST    R4,SAMPCMBP
         LA    R1,$DOMQUE        CMB'S QUEUED FOR ACTION
         SR    R2,R2
         BAL   R3,COUNTBF
         ST    R4,SAMPCMBW
         LA    R1,$SMFFREE       FREE SMF BUFFER QUEUE
         SR    R2,R2
         BAL   R3,COUNTBF
         ST    R4,SAMPSMFF
         LA    R1,$SMFBUSY       SMF BUFFERS QUEUED FOR I/O
         SR    R2,R2
         BAL   R3,COUNTBF
         ST    R4,SAMPSMFB
         $ENABLE ALL
         L     R1,$JOTABLE       GET NUMBER OF FREE JOE'S
         LH    R4,4(,R1)         (FROM JOTFREC)
         ST    R4,SAMPJOE
*
         L     R5,UCBSTRT              START OF PSEUDO DEVICE LIST
         LA    R3,SAMPPSDO-4           SAMPLE START ADDRESS - 4
         XC    SAMPPSDO(16),SAMPPSDO   CLEAR THE FOUR SAMPLE LOCATIONS
UCBLOOP  LA    R5,2(,R5)               UCB LIST POINTER
         LH    R6,0(,R5)               NEXT UCB BASE
         LTR   R6,R6                   VALID UCB ADDRESS?
         BZ    UCBLOOP                 NO -- EMPTY POINTER -- LOOP
         BM    ENDUCB                  NO -- END OF LIST -- BRANCH
         TM    11(R6),X'01'            FREE PSEUDO DEVICE?
         BZ    UCBLOOP                 NO, BRANCH
         TM    3(R6),X'08'             ALLOCATED BY O.S.?
         BO    UCBLOOP                 YES, BRANCH
         SR    R2,R2
         IC    R2,19(,R6)              DEVICE TYPE CHARACTER
         C     R2,=F'8'                POSSIBLE HASP PSEUDO DEVICE?
         BH    UCBLOOP                 NO, IGNORE
         IC    R2,PSEUDO(R2)           TRANSLATE TO A TABLE INDEX
         LTR   R2,R2                   HASP PSEUDO DEVICE?
         BZ    UCBLOOP                 NO, BRANCH
         L     R1,0(R2,R3)             INCREMENT
         A     R1,=F'1'                         PSEUDO DEVICE
         ST    R1,0(R2,R3)                                   TYPE COUNT
         B     UCBLOOP                 TRY THE NEXT ONE
ENDUCB   DS    0H
         SPACE 3
         USING PCEDSECT,R5
         LA    R5,$PCEORG-(PCENEXT-PCEDSECT)
         LA    R0,1                    COUNTER INCREMENT
         LA    R1,4                    SAMPLE LOCATION INCREMENT
         XC    SAMPPCE(56),SAMPPCE     CLEAR THE SAMPLE LOCATIONS
         SR    R7,R7                   PCEEWF BIT DECODE REGISTER
PCELOOP  L     R5,PCENEXT              NEXT PCE ADDRESS
         LTR   R5,R5                   END OF CHAIN?
         BZ    PCEDONE                 YES, BRANCH
         LA    R3,SAMPPCE              FIRST SAMPLE LOCATION
         LH    R6,PCEEWF               EVENT WAIT FIELD
         SRL   R6,2                    DROP BOTTOM TWO BITS
         SRDL  R6,14                   SAVE NEXT FOURTEEN
NEXTBIT  ALR   R7,R7                   BIT SET?
         BZ    PCELOOP                 NO -- NO MORE ARE EITHER
         BM    *+14                    NO, BRANCH
         L     R6,0(,R3)               INCREMENT
         AR    R6,R0                            THIS
         ST    R6,0(,R3)                            COUNTER
         AR    R3,R1                   INCREMENT SAMPLE LOCATION
         B     NEXTBIT                 DO THE NEXT BIT
PCEDONE  DS    0H
         DROP  R5
         SPACE 4
         LA    R1,LCNT/4         NUMBER OF ITEMS
         LA    R2,SAMPLE         CURRENT DATA VALUE POINTER
MINMAX   L     R15,0(,R2)        CURRENT DATA VALUE
         C     R15,LCNT(,R2)     NEW MIN?
         BNL   *+8               NO, BRANCH
         ST    R15,LCNT(,R2)
         C     R15,LCNT*2(,R2)   NEW MAX?
         BNH   *+8               NO, BRANCH
         ST    R15,LCNT*2(,R2)
         A     R15,LCNT*3(,R2)   TOTAL
         ST    R15,LCNT*3(,R2)        OCCURANCES
         LA    R2,4(R2)          NEXT DATA ITEM
         BCT   R1,MINMAX         REPEAT UNTIL DONE
LATER    L     R1,COUNT            GET THE SAMPLE COUNTER
         C     R1,MAXSAMP          ENOUGH TIME?
         BNL   EXIT                YES, STOP
         L     R2,PECB             GET ADDRESS OF STOP ECB
         TM    0(R2),X'40'         WERE WE STOPPED
         BO    EXIT                EXIT IF YESS
         SR    R0,R0               PREPARE FOR DIVIDE
         D     R0,=F'1000'         TIME TO WRITE A SAMPLE?
         LTR   R0,R0
         BNZ   *+8
         BAL   R2,OUTCOUNT
         STIMER WAIT,BINTVL=F50    WAIT ABIT
         TM    $STATUS,$SYSEXIT    IF HASP IS TERMINATING
         BO    EXIT                 THEN WE SHOULD DO LIKEWISE
         B     MONLOOP              THEN CONTINUE
EXIT     TIME  DEC                 GET THE ENDING TIME
         STM   R0,R1,TIMEOFF        AND SAVE IT FOR THE REPORT
         BAL   R2,OUTCOUNT
         MVC   JOBNOS+2(2),$JOBNO  LAST JOB NUMBER
         WRITE DECB,SF,STAT,COUNT,TABLEN  SAVE THE INFO
         CHECK DECB                SEE IF IT WENT OK
RETURN   CLOSE (STAT,,SYSPRINT)
         L     R13,4(,R13)
         RETURN (14,12),RC=0
OUTCOUNT MVC   HEADER+7(6),=X'402020202120'
         L     R1,COUNT
         CVD   R1,DOUBLE
         ED    HEADER+7(6),DOUBLE+5
         PUT   SYSPRINT,HEADER
         LA    R3,LCNT/4           NUMBER OF OUTPUT ENTRIES
         LA    R4,ENTRIES          TEXT ENTRIES
         LA    R5,SAMPLE
OUTEACH  MVC   PRINT(L'ENTRIES),0(R4)
         L     R1,0(,R5)
         CVD   R1,DOUBLE
         MVC   PRINT+35(4),=X'40202120'
         ED    PRINT+35(4),DOUBLE+6           CURRENT
         L     R1,LCNT(,R5)
         CVD   R1,DOUBLE
         MVC   PRINT+47(4),=X'40202120'
         ED    PRINT+47(4),DOUBLE+6           MIN
         L     R1,LCNT*2(,R5)
         CVD   R1,DOUBLE
         MVC   PRINT+59(4),=X'40202120'
         ED    PRINT+59(4),DOUBLE+6           MAX
         L     R1,LCNT*3(,R5)
         M     R0,=F'10'       FOR SCALING
         D     R0,COUNTS       TAKE THE AVERAGE
         CVD   R1,DOUBLE
         MVC   PRINT+72(7),=X'40202021204B20'
         ED    PRINT+72(7),DOUBLE+5           AVERAGE
         LA    R5,4(,R5)
         LA    R4,L'ENTRIES(,R4)
         PUT   SYSPRINT,PRINT
         MVC   PRINT(133),PRINT-1
         BCT   R3,OUTEACH
         BR    R2
         SPACE 4
COUNTBF  SR    R4,R4          RETURN REGISTER
         L     R1,0(,R1)      BUFFER BASE
         B     BUFFS+4        SKIP FIRST TIME
BUFFS    L     R1,0(R2,R1)    NEXT BUFFER
         LA    R1,0(,R1)      CLEAR HI-BYTE
         LTR   R1,R1          END OF CHAIN?
         BZR   R3             YES, QUIT
         A     R4,=F'1'       BUFFER COUNT
         B     BUFFS          TRY THE NEXT ONE
         EJECT
*
*   AREAS FOR SAMPLING DURING HASP MONITORING (ONCE EVERY EIGHT CYCLES)
*
*
         DS    0F
SAMPLE   DC    XL128'00'      ACTUAL SAMPLE HOLD AREA
LCNT     EQU   L'SAMPLE
MIN      DC    128X'7F'       MINIMUM OCCURRENCE
MAX      DC    XL128'00'      MAXIMUM OCCURRENCE
AVG      DC    XL128'00'      TOTALS POSITIONS
*
SAMPUSE@ EQU   SAMPLE+00     ...SOURCE:  $ALSTATB
SAMPOSX  EQU   SAMPLE+04     ...SOURCE:  $XEQACT
SAMPACTF EQU   SAMPLE+08     ...SOURCE:  $ACTIVE
SAMPAIO  EQU   SAMPLE+12     ...SOURCE:  $EXCPCT
SAMPBUFP EQU   SAMPLE+16     ...SOURCE:  $BUFPOOL
SAMPSMFF EQU   SAMPLE+20     ...SOURCE:  $SMFFREE
SAMPSMFB EQU   SAMPLE+24     ...SOURCE:  $SMFBUSY
SAMPJOE  EQU   SAMPLE+28     ...SOURCE:  $JOTTABLE AND JOTFREQ
SAMPFRJE EQU   SAMPLE+32     ...SOURCE:  $TPBPOOL
SAMPCMBI EQU   SAMPLE+36     ...SOURCE:  $BUSYQUE
SAMPCMBL EQU   SAMPLE+40     ...SOURCE:  $LOGQUE
SAMPCMBP EQU   SAMPLE+44     ...SOURCE:  $COMMQUE
SAMPCMBW EQU   SAMPLE+48     ...SOURCE:  $DOMQUE
SAMPCMBF EQU   SAMPLE+52     ...SOURCE:  $COMMCT
SAMPPSDO EQU   SAMPLE+56     ...SOURCE:  UCB CHANNEL D
*        EQU   SAMPLE+60     ...SOURCE:  UCB CHANNEL D
*        EQU   SAMPLE+64     ...SOURCE:  UCB CHANNEL D
*        EQU   SAMPLE+68     ...SOURCE:  UCB CHANNEL D
SAMPPCE  EQU   SAMPLE+72     ...SOURCE:  PCE $POSTED
*        EQU   SAMPLE+76     ...SOURCE:  PCE WAIT FOR A BUFFER
*        EQU   SAMPLE+80     ...SOURCE:  PCE WAIT FOR A TRACK
*        EQU   SAMPLE+84     ...SOURCE:  PCE WAIT FOR A JOB
*        EQU   SAMPLE+88     ...SOURCE:  PCE WAIT FOR A UNIT
*        EQU   SAMPLE+92     ...SOURCE:  PCE WAIT FOR A CHECKPOINT
*        EQU   SAMPLE+96     ...SOURCE:  PCE WAIT FOR CMB OR SMF BUFFER
*        EQU   SAMPLE+100    ...SOURCE:  PCE WAIT FOR JOT SERVICE
*        EQU   SAMPLE+104    ...SOURCE:  PCE WAIT FOR AN OPERATOR REPLY
*        EQU   SAMPLE+108    ...SOURCE:  PCE WAIT FOR I/O
*        EQU   SAMPLE+112    ...SOURCE:  PCE WAIT FOR WORK
*        EQU   SAMPLE+116    ...SOURCE:  PCE WAIT FOR A $S COMMAND
*        EQU   SAMPLE+120    ...SOURCE:  PCE WAIT FOR A DDT OR UCB
*        EQU   SAMPLE+124    ...SOURCE:  PCE WAIT FOR AN OVERLAY AREA
         EJECT
*                   12345678901234567890123456
ENTRIES  DC    CL26'-PERCENT SPOOL UTILIZATION'
         DC    CL26' JOBS IN O/S EXECUTION    '
         DC    CL26' ACTIVE HASP FUNCTIONS    '
         DC    CL26' ACTIVE HASP I/O COUNT    '
         DC    CL26'-FREE HASP BUFFERS        '
         DC    CL26' FREE SMF BUFFERS         '
         DC    CL26' SMF BUFFS QUEUED FOR I/O '
         DC    CL26' FREE JOE''S              '
         DC    CL26' FREE TP BUFFERS          '
         DC    CL26'-CMB''S QUEUED FOR I/O    '
         DC    CL26' CMB''S QUEUED FOR LOGGING'
         DC    CL26' CMB''S QUEUED FOR COMMAND'
         DC    CL26' CMB''S QUEUED FOR ACTION '
         DC    CL26' CMB''S FREE              '
         DC    CL26'-FREE SYSOUT=A UCB''S     '
         DC    CL26' FREE SYSOUT=B UCB''S     '
         DC    CL26' FREE  DD *  UNITS        '
         DC    CL26' FREE INTRDR''S           '
         DC    CL26'-PCE''S POSTED            '
         DC    CL26' WAIT -- BUFFER           '
         DC    CL26' WAIT -- DISK SPACE       '
         DC    CL26' WAIT -- JOB              '
         DC    CL26' WAIT -- UNIT             '
         DC    CL26' WAIT -- CHECKPOINT       '
         DC    CL26' WAIT -- CMB OR SMF BUFFER'
         DC    CL26' WAIT -- JOT SERVICE      '
         DC    CL26' WAIT -- OPERATOR RESPONSE'
         DC    CL26' WAIT -- INPUT/OUTPUT     '
         DC    CL26' WAIT -- WORK             '
         DC    CL26' WAIT -- $S COMMAND       '
         DC    CL26' WAIT -- DDT OR UCB       '
         DC    CL26' WAIT -- OVERLAY AREA     '
         EJECT
ONEBLK   DC    C' '                TO CLEAR PRINT
PRINT    DC    CL133' '
*                  0  1  2  3  4  5  6  7  8  PSUEDO DEVICE / UNIT
PSEUDO   DC    AL1(00,12,08,00,00,16,00,00,04)   CORRESPONDENCE TABLE
DOUBLE   DS    D
*
STAT     DCB   DDNAME=HASPSTAT,DSORG=PS,RECFM=U,MACRF=W,               +
               BLKSIZE=TABLEN
SYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,RECFM=FBA,LRECL=133,           +
               BLKSIZE=133,MACRF=(PM)
         SPACE 8
HEADER   DC    CL50'1SAMPLE 12345                LAST COUNT   MIN COUN'
*                   12345678901234567890123456789012345678901234567890
         DC    CL83'T   MAX COUNT   AVERAGE COUNT'
ALSTATB  DC    F'0',F'50'
PECB     DC    F'0'      SAVE FOR A(STOP ECB)
UCBSTRT  DC    F'0'      FIRST LIST POINTER FOR HASP PSEUDO DEVICES - 2
COUNTS   DC    F'0'      SAMPLES TAKEN FOR OUTPUT DURING MONITORING
F50      DC    F'50'     1/2 SECOND BETWEEN SAMPLES
MAXSAMP  DC    F'3000'   SAMPLES DESIRED (ABOUT 1/2 HOUR)
        SPACE 2
         LTORG
        PRINT  GEN
         EJECT
COUNT    DC    F'0'
RDRPEND  DC    F'0'
ALMSGSW  DC    F'0'
DRAINED  DC    F'0'
CKPTACT  DC    F'0'
JITCKPT  DC    F'0'
SYSEXIT  DC    F'0'
JOTCKPT  DC    F'0'
JOBNOS   DC    F'0'
$HASPWT  DC    8F'0'
TIMEON   DC    2F'0'
TIMEOFF  DC    2F'0'
BASE     DC    A(*)
ASPOOL   DC    A(SPOOL)
AMTTR    DC    A(MTTR)             SPOOL HEAD POSITION
ACONBUF  DC    A(CONBUF)
ABUF     DC    A(BUF)
AIO      DC    A(IO)
AXEQ     DC    A(XEQ)
AQXEQ    DC    A(QXEQ)
AQOUTPUT DC    A(QOUTPUT)
AQJCLCK  DC    A(QJCLCK)
ADCT     DC    A(DCT)
AEND     DC    A(END)
&TEMP    SETA  (&NUMRDRS+&NUMPRTS+&NUMINRS+&NUMPUNS)*2
&TEMP    SETA  &TEMP+&MAXXEQS+2
&TEMP    SETA  &TEMP+&NUMLNES+&NUMTPBF+(&NUMRJE*2)+4
         AIF   (&NUMTPPU EQ 0).NORTMPU
&TEMP    SETA  &TEMP+&NUMRJE
.NORTMPU ANOP
$DCT     DC    &TEMP.CL12' '       SAVE FOR DEVICE NAMES
SPOOL    DS    51F
CONBUF   DS    (&NUMWTOQ+1)F
BUF      DS    (&BUFNUM+1)F
IO       DS    41F
XEQ      DS    (&MAXXEQS+2)F
DCT      DS    &TEMP.F
&TEMP    SETA  &NUMDA*51           50 CYLINDER GROUPS PLUS ONE COUNT
MTTR     DS    &TEMP.F
QXEQ     DS    (&MAXJOBS+1)F
QOUTPUT  DS    (&MAXJOBS+1)F
QJCLCK   DS    (&MAXJOBS+1)F
END      DS    0F
TABLEN   EQU   *-COUNT
         ORG   SPOOL
         EJECT
         PRINT NOGEN
         DROP  R9,R12
         USING *,R10
MONINIT  STM   R14,R12,12(R13)     SAVE OS REGS
         LR    R10,R15             SET THE BASE
         L     R12,=A(SAVEAREA)    ESTABLISH HASPMON BASE
         ST    R13,4(,R12)         SAVE AREA LINKAGE
         ST    R12,8(,R13)         *
         LR    R13,R12             *
         LA    R9,4095             SECOND BASE REGISTER
         LA    R9,1(R9,R13)
         LA    R12,4095(,R9)
         LA    R12,1(,R12)
         L     R1,0(,R1)           ADDRESS OF PARM
         LH    R2,0(,R1)           PARM LENGTH
         LTR   R2,R2               ANY PARM?
         BZ    NOPARM              NO, BRANCH
         SR    R3,R3
         SR    R15,R15
NEXT     IC    R3,2(R1)            NEXT DIGIT
         C     R3,=F'240'          NUMERIC?
         BL    NOPARM              NO, USE DEFAULT TIME
         N     R3,=F'15'           MASK OFF ZONE
         MH    R15,=H'10'          ACCUMULATE IN R15
         AR    R15,R3              ADD IN LAST DIGIT
         A     R1,=F'1'            DO ALL
         BCT   R2,NEXT                   DIGITS
         MH    R15,=H'1000'        PARM*1000 IS # OF SAMPLES DESIRED
         ST    R15,MAXSAMP         UPDATE MAXSAMP
NOPARM   L     R11,16              A(CVT)
         L     R11,X'14C'(,R11)    POINTER TO HASP 4.0 HCT
         LTR   R11,R11             IS HASP 4.0 THERE?
         BNZ   NOTEND              YES, BRANCH
NOHASP   WTO   'HASP4MON ABORT -- COULD NOT FIND THE HASP TCB',       XX
               ROUTCDE=(11)
         ABEND 1
NOTEND   S     R11,=F'8'
         MODESET KEY=ZERO
         CLC   0(5,R11),=CL8' V 4.0'
         BE    ITISHASP
         WTO   ' V 4.0 LITERAL NOT FOUND',ROUTCDE=(11)
         ABEND 2
ITISHASP EXTRACT SPOOL,FIELDS=(COMM) FIND STOP ECB
         L     R1,SPOOL            GET THE A(A(ECB)
         MVC   PECB,0(R1)          SAVE ADDRESS IN OUT CODE
         LA    R11,0(,R11)         DROP THE TOP ADDRESS BYTE
*     FIND SPOOL ALLOC STATS
         MVC   *+8(2),$PURGER+2    MOVE D1,B1 OF B $PURGER INSTRUCTION
         LA    R1,0                **** REG ONE SET TO A($PURGER)
         LA    R3,300(,R1)         LOOK FOR 300 BYTES
         LA    R2,2                 TWO BYTES AT A TIME
         CLI   0(R1),X'50'         LOOK FOR THE FIRST ST INSTRUCTION
*                                  B1,D1 POINTS TO $ALSTATB
         BE    FOUND               SIERRA HOTEL
         BXLE  R1,R2,*-8           SPIN
         WTO   'HASPMON - UNABLE TO FIND $ALSTATB'
         B     RETURN
FOUND    MVC   *+8(2),2(R1)        MOVE B1,D1
         LA    R1,0                *** SAME AS LA R1,$ALSTATB
         ST    R1,ALSTATB          SAVE IT FOR LATER
         LA    R4,$DCT             ADDRESS FOR DEVICE NAMES
         LA    R2,$DCTPOOL-(DCTCHAIN-DCTDSECT)
         USING DCTDSECT,R2
LDCTA    L     R2,DCTCHAIN         GET A POINTER
         CLI   DCTDEVTP,DCTOLAY
         BE    LDCTEND             END IF OVERLAY
         CLI   DCTDEVTP,DCTDA      IS IT SPOOL DCT
         BNE   LDCTB               NO, MOVE NAME
         MVC   0(5,R4),=C'SPOOL'   MAKE NAME SPOOL
         B     LDCTC               INC BEFORE LOOPING
LDCTB    LR    R3,R2                     COPY THE DCT POINTER
         MVC   0(8,R4),DCTDEVN           DEVICE NAME
         MVC   9(3,R4),=C'***'           UNDEFINED UCB
         CLC   DCTDEVN(2),=C'RM'         REMOTE DEVICE?
         BNE   NOTRMT                    NO, BRANCH
         TM    DCTPSTAT,DCTSINON         SIGNED ON?
         BNO   NOUCB                     NO, BRANCH
         L     R3,DCTDCB-DCTDSECT(,R2)   LINE ADDRESS
NOTRMT   L     R3,DCTDCB-DCTDSECT(,R3)   DCB ADDRESS
         TM    48(R3),X'10'  DCB OPEN ?
         BZ    NOUCB         NO; SKIP
         L     R3,DCBDEBAD-DCBDSECT(,R3) DEB ADDRESS
         CLC   DEBTCBAD+1-DEBDSECT(3,R3),=F'0'  VALID TCB ADDRESS?
         BE    NOUCB                     NO, BRANCH
         LH    R3,DEBUCBAD+2-DEBDSECT(,R3)  UCB ADDRESS
         LTR   R3,R3                     GOOD ADDRESS?
         BZ    NOUCB                     NO, BRANCH
         MVC   9(3,R4),UCBNAME-UCBDSECT(R3)
NOUCB    DS    0H
         DROP  R2
LDCTC    LA    R4,12(,R4)          INC NAME POINTER
         B     LDCTA               LOOP
LDCTEND  EQU   *
         L     R3,16             PREPARE TO SEARCH UCB'S
         L     R3,X'28'(,R3)     UCB START ADDRESS
         BCTR  R3,0              SUBTRACT
         BCTR  R3,0                      TWO
THISONE  LA    R3,2(,R3)         NEXT UCB ADDRESS POINTER
         LH    R2,0(,R3)         NEXT UCB POINTER
         LTR   R2,R2             ANY UCB?
         BZ    THISONE           NO -- NULL ENTRY -- LOOP
         BM    ABEND10           NO -- END OF LIST -- ERROR
         TM    11(R2),1          UCBATI WITH 1 BIT ?
         BZ    THISONE           NOT A PSEUDO DEVICE ADDRESS, BRANCH
         S     R3,=F'2'          BACK UP ONE LOCATION
         ST    R3,UCBSTRT        SAVE THIS POINTER LIST LOCATION
         B     OPENFILE
ABEND10  WTO   'PSEUDO DEVICES NOT FOUND -- HASPMON ABEND',ROUTCDE=(11)
         ABEND 10
OPENFILE OPEN  (STAT,(OUTPUT),SYSPRINT,(OUTPUT))
         TM    STAT+48,X'10'       DID IT OPEN
         BO    ITOPENED            YEP
OPENERR  WTO   'HASPMON OR SYSPRINT - FILE NOT OPENED'
         B     RETURN
ITOPENED TIME  DEC                 SAVE THE TIME
         STM   R0,R1,TIMEON         THAT THIS THING STARTED
         MVC   JOBNOS(2),$JOBNO    FIRST JOB NUMBER
         TM    SYSPRINT+48,X'10'
         BNO   OPENERR
         SR    R0,R0               ZERO FOR CLEAR CORE ROUTINE
         L     R1,ASPOOL           ADDRESS TO START AT
         LA    R2,4                INDEX FOR BXLE
         L     R3,AEND             WHERE TO
         BCTR  R3,0                 STOP
         B     TABCLEAR            GO INTO NORMAL CODE
         SPACE 2
         LTORG
         ORG
         SPACE 2
         END   MONINIT
./  ADD  NAME=HASP4PRT
HPRT     TITLE 'HASP MONITOR - PRINTER'   ASSEMBLE WITH 'BATCH' OPTION
         PRINT NOGEN
*
*
*   HASPRINT - FORMAT AND PRINT HASPMON OUTPUT PASSED VIA
*              DDNAME 'HASPSTAT'
*
*   NOTE: MODULE "HASPRINT" IS COMPOSED OF CSECTS "HASPRINT"
*         AND "PRINT"
*
*   FRANK PAJERSKI  NASA-GSFC  01NOV77
*
         PRINT OFF
         COPY  $GLOBAL
         PRINT ON,GEN
         SPACE 2
         GBLA  &BUFNUM       NUMBER OF BUFFERS IN USE BY HASP
         SPACE 2
HASPRINT CSECT
         SPACE 2
&BUFNUM  SETA  170           --- SET THIS A FEW MORE THAN IN USE ---
         SPACE 2
         PRINT OFF
         COPY  $HASPGEN
         TITLE 'HASP MONITOR - PRINTER'
         PRINT ON,NOGEN
         SPACE 2
         SAVE  (14,12),,*
         BALR  R12,0               ESTABLISH BASE REGISTER
         USING *,R12
         LA    R1,SAVEA            A(SAVE AREA)
         ST    R1,8(,R13)          LINKAGE . . .
         ST    R13,4(,R1)
         LR    R13,R1
         USING SAVEA,R13
         OPEN  (STAT,(INPUT))      OPEN THE SAVED FILE
         READ  DECB,SF,STAT,STATS,'S'
         CHECK DECB                MAKE SURE IT WORKS
         CLOSE STAT
         LA    R11,BASE            GET TABLE BASE FOR
         L     R10,BASE             COMPUTATION OF NEW ADDRESSES
         SR    R10,R11             RELOCATION FACTOR
         LCR   R10,R10             MAKE THE LOGIC EASIER
         LA    R3,ASPOOL           START THERE
         LA    R5,AEND              ENDING HERE
         LA    R4,4                 FOUR BYTES AT A TIME
ADJUST   L     R6,0(,R3)           GET AN ADDRESS
         AR    R6,R10               ADJUST IT
         ST    R6,0(,R3)             AND SAVE IT
         BXLE  R3,R4,ADJUST        GO UNTIL DONE
*
         LA    R2,SUBSPOOL         SPOOL ALLOCATION SUBTITLE
         LA    R3,PERCENT
         BAL   R11,SETITLE         SET TITLE,SUBTTL1, AND SUBTTL2
         L     R10,ASPOOL          A(ALLOCATION STATS)
         LA    R9,51               SET 51 LINES
         MVI   INC,X'2F'            WITH INCREMENTS OF 2
         BAL   R11,SETPERCT        CREATE THE LINE
*
         MVI   INC,X'1F'           INCREMENT BY ONLY ONE
         MVC   PERCENT+1(9),=CL9'   COUNT'
         LA    R1,SUBCONBF         SET SUBTITLE1,SUBTITLE2, PAGE EJECT
         L     R4,ACONBUF          A(FREE CONSOLE BUFFER COUNTS)
         LA    R7,&NUMWTOQ+1       DO THIS MANY TIMES
         LA    R6,(&NUMWTOQ*4)(,R4)   END OF WTO BUFFER COUNT AREA
         BAL   R8,SETLESS          WRITE THE STATS
*
         LA    R1,SUBBUF           A(BUFFER FREE STATS)
         L     R4,ABUF             A(THE TABLE
         LA    R7,&BUFNUM+1        THERE WILL BE THIS MANY BUFFERS
         LA    R6,(&BUFNUM*4)(,R4)   END OF FREE BUFFER TABLE
         BAL   R8,SETLESS          WRITE THE STATS
*
         LA    R2,SUBIO            CONCURRENT IO SUBTITLE
         LA    R3,PERCENT
         BAL   R11,SETSUB1         SET SUBTITLE1,SUBTITLE2, PAGE EJECT
         L     R10,AIO             A(IO TABLE)
         LA    R9,41               ONLY 41 TIMES
         BAL   R11,SETPERCT        WRITE THE STATS
*
         LA    R2,SUBXEQ           SUBTITLE FOR ACTIVE XEQS
         LA    R3,PERCENT
         BAL   R11,SETSUB1         SET SUBTITLE1,SUBTITLE2, PAGE EJECT
         L     R10,AXEQ            A(XEQ COUNT)
         LA    R9,&MAXXEQS+2       THIS MANY TIMES
         BAL   R11,SETPERCT        WRITE THE STATS
*
         LA    R2,SUBDCT           SUBTITLE FOR DCT STATUS
         LA    R3,SUB2DCT          SUBTITLE 2
         BAL   R11,SETSUB1         SET SUBTITLE1,SUBTITLE2, PAGE EJECT
         LA    R5,$DCT             A(NAME TABLE)
         L     R6,ADCT             A(IN USE TABLE)
         L     R9,AMTTR            STOP HERE
         BCTR  R9,0                 HERE
         LA    R8,4                USE THIS FOR THE BXLE INC
DCTLOOP  MVC   LINE+40(12),0(R5)   SAVE THE NAME AND ADDRESS
         L     R3,0(,R6)           GET THE ACTIVE COUNT
         LTR   R3,R3               DELETE
         BP    NACTDCT                   INACTIVE
         CLC   =C'RM',0(R5)                      REMOTE
         BE    INCR5                                   RDR, PRT & PUN
         CLC   =C'LI',0(R5)  LINE ?
         BE    INCR5         YES; SKIP
NACTDCT  M     R2,=F'10000'        GET TO HUNDREDTH OF A PERCENT
         D     R2,COUNT            *
         CVD   R3,DBLE             TO DECIMAL FOR PRINT
         MVC   LINE+60(7),=X'402021204B2020' SET EDIT MASK
         ED    LINE+60(7),DBLE+5   EDIT THE PERCENTAGE
         BAL   R11,PRNTLINE        GO PRINT THE LINE
         CLC   0(5,R5),=C'SPOOL'   SPOOL DCT
         BNE   INCR5               NO, BRANCH
         LTR   R3,R3               USED THIS SPOOL DCT?
         BNZ   INCR5               YES, BRANCH
         LR    R1,R6
         SH    R1,=H'12'           BACK UP THREE
         OC    0(12,R1),0(R1)      ANY OF THOSE THREE SPOOLS USED?
         BZ    *+12                NO, BRANCH
INCR5    LA    R5,12(,R5)          POINT TO NEXT NAME
         BXLE  R6,R8,DCTLOOP       SPIN FOR ALL DCTS
         MVC   BASE,COUNT          SAVE COUNT AROUND TTR PRINT
         MVC   PERCENT+1(9),=CL9'     CYL'
         MVI   INC,X'8F'           SET INCREMENT TO 4
         L     R5,AMTTR            A(SPOOL HEAD POSITION TABLE
         LA    R6,&NUMDA           SET FOR MAX
MTTRLP   IC    R3,SPOOLNUM         INC
         LA    R3,1(,R3)            THE SPOOL
         STC   R3,SPOOLNUM           NAME
         L     R10,200(,R5)        GET THE COUNT THIS SPOOL
         LTR   R10,R10             IF ZERO THIS SPOOL
         BZ    MTTRLAST             WAS NEVER UP
         ST    R10,COUNT           SET COUNT FOR PERCENT RUUTINE
         LR    R10,R5              SET ADDRESS OF TABLE
         LA    R2,SUBMTTR          A(SUBTITLE1
         LA    R3,PERCENT          A(SUBTITLE2
         BAL   R11,SETSUB1         SET SUBTITLE1,SUBTITLE2, PAGE EJECT
         LA    R9,50               FIFTY ENTRIES IN THE TABLE
         BAL   R11,SETPERCT        WRITE THE STATS
         L     R3,200(,R5)         GET THE COUNT AGAIN
         CVD   R3,DBLE             TO P.D.
         MVC   LINE+45(26),SPLCOUNT SET MSG
         MVI   LINE,C'-'           SET TO DOUBLE SPACE
         ED    LINE+45(7),DBLE+5   ENTER THE COUNT
         BAL   R11,PRNTLINE        PRINT THE COUNT
MTTRLAST EQU   *
         LA    R5,204(,R5)         TO NEXT TABLE
         BCT   R6,MTTRLP           SPIN FOR ALL GENED SPOOLS
*
         MVC   PERCENT+1(9),=CL9'   COUNT'
         MVC   COUNT,BASE          RESTORE FOR $STATUS
         MVI   INC,X'1F'           SET TO SINGLE SPACE
         L     R4,AQXEQ            A(XEQ QUEUE STATS)
         BAL   R8,SETQUE           WRITE THESE STATS
*
         MVC   SUBQUE+64(9),SUBPRINT SET SUBTITLE
         L     R4,AQOUTPUT         SET FOR PRINT
         BAL   R8,SETQUE           WRITE THESE STATS
*
         MVC   SUBQUE+64(9),SUBJCLCK SET SUBTITLE
         L     R4,AQJCLCK          A(JCLCK QUE STATS)
         BAL   R8,SETQUE           WRITE THESE STATS
*
         LA    R2,LINE             SET FOR BLANK SUBTITLE
         LR    R3,R2               ALSO FOR THE SECOND
         BAL   R11,SETSUB1         SET SUB1,SUB2, AND PAGE EJECT
         MVC   LINE+40(50),MISC    SET A SORT OF SUBTITLE
         BAL   R11,PRNTLINE        AND PRINT IT
         LA    R2,MISCTAB          START HERE
         LA    R3,(MISCLINE-MISCTAB)/35  FOR THIS MANY
         LA    R6,RDRPEND          START OF TABLE
         MVI   LINE,C'-'           TRIPLE SPACE FIRST
MISCLOOP MVC   LINE+30(35),0(R2)   SET MESSAGE
         L     R5,0(,R6)           GET A COUNTER
         CVD   R5,DBLE             CONVERT OCCURRENCES TO DECIMAL
         MVC   LINE+81(8),SPLCOUNT
         ED    LINE+81(8),DBLE+5   MAKE PRINTABLE
         M     R4,=F'10000'        SCALE FOR PERCENT
         D     R4,COUNT
         CVD   R5,DBLE
         MVC   LINE+70(7),=X'402021204B2020' SET EDIT MASK
         ED    LINE+70(7),DBLE+5   EDIT THE PERCENTAGE
         BAL   R11,PRNTLINE        GO PRINT IT
         MVI   LINE,C'0'           SET FOR DOUBLE SPACE
         LA    R2,35(,R2)          INC MSG POINTER
         LA    R6,4(,R6)            ALSO COUNTER POINTER
         BCT   R3,MISCLOOP         NOW LOOP
*
         LA    R3,2                BLANK LINE COUNTER
         LA    R11,*+4
         MVI   LINE,C'-'
         BCT   R3,PRNTLINE         SIX BLANKS
         MVI   LINE,C'0'
         MVC   LINE+30(33),=CL33'HASP EVENT WAIT FIELD   $HASPECF'
         MVC   LINE+70(20),=CL20'PERCENT OCCURRENCES'
         BAL   R11,PRNTLINE
         MVI   LINE,C'-'           TRIPLE SPACE NEXT
         LA    R6,$HASPWT            FIRST WAIT STORAGE PLACE
         LA    R3,(WTEND-WTLINE)/35  NUMBER OF PRINT LINES
         LA    R2,WTLINE             FIRST PRINT LINE
WTLOOP   MVC   LINE+30(35),0(R2)     NEXT TEXT
         L     R5,COUNT              MAXIMUM COUNT
         S     R5,0(,R6)             SAMPLE
         CVD   R5,DBLE
         MVC   LINE+81(8),SPLCOUNT   OUTPUT THE ACTUAL SAMPLE
         ED    LINE+81(8),DBLE+5
         M     R4,=F'10000'          CONVERT TO PERCENT
         D     R4,COUNT
         CVD   R5,DBLE
         MVC   LINE+70(7),=X'402021204B2020' SET EDIT MASK
         ED    LINE+70(7),DBLE+5     EDIT THE PERCENTAGE
         BAL   R11,PRNTLINE          PRINT THE LINE
         MVI   LINE,C'0'             DOUBLE SPACE OTHER LINES
         LA    R2,35(,R2)            NEXT TEXT START ADDRESS
         LA    R6,4(,R6)             NEXT SAMPLE START LOCATION
         BCT   R3,WTLOOP             REPEAT FOR ALL SAMPLES
*
         MVI   LINE,C'-'           SET FOR DOUBLE SPACE
         BAL   R11,PRNTLINE        SET TWO BLAANK LINES
         MVI   LINE,C'-'           SET TO DOUBLE SPACE
         BAL   R11,PRNTLINE        DO IT AGAIN
         MVC   LINE+30(36),SAMSG   SAMPLE COUNT MSG
         L     R1,COUNT            GET THE SAMPLE COUNT
         CVD   R1,DBLE              MAKE IT P.D.
         ED    LINE+56(10),DBLE+4  EDIT COUNT INTO MSG
         BAL   R11,PRNTLINE         AND PRINT IT
***      ENTER CODE HERE TO SET TIME ON AND TIME OFF
         MVC   LINE+30(61),ONMSG   SET MSG AND MASK FOR TIME ON
         ED    LINE+38(7),TIMEON+5 TIME ON TO MSG
         OI    TIMEON+3,X'0F'      SET FOR UNPACK
         ED    LINE+55(11),TIMEON   AND PUT IT INTO MSG
         LH    R1,JOBNOS           HASP JOB
         CVD   R1,DBLE                     NUMBER AT START
         ED    LINE+85(6),DBLE+5                          OF MONITORING
         MVC   LINE+64(2),=X'4040' BLANK THOUSANDS POSITION
         MVI   LINE,C'-'           SET FOR DOUBLE SPACE
         BAL   R11,PRNTLINE        NOW PRINT IT
         MVC   LINE+30(61),ONMSG   SET FOR TIME OFF
         MVC   LINE+36(2),=C'FF'   CHANGE 'ON' TO 'OFF'
         MVC   LINE+53(2),=C'FF'   CHANGE 'ON' TO 'OFF'
         ED    LINE+38(7),TIMEOFF+5 SET THE DATE
         OI    TIMEOFF+3,X'0F'     SET TO P.D
         ED    LINE+55(11),TIMEOFF NOW ADD THE TIME OFF
         LH    R1,JOBNOS+2         HASP JOB
         CVD   R1,DBLE                     NUMBER AT END
         ED    LINE+85(6),DBLE+5                        OF MONITORING
         MVC   LINE+64(2),=X'4040' BLANK THOUSANDS POSITION
         MVI   LINE,C'0'           SET TO DOUBLE SPACE
         BAL   R11,PRNTLINE         AND PRINT THE LINE
         L     R13,4(,R13)
         RETURN (14,12),T,RC=0
*
SETPERCT ZAP   CNT,=P'0'           SET INITIAL COUNT
         LR    R8,R11              SAVE RETURN AROUND PRINT ROUTINE
PERCNTA  MVC   LINE+5(4),=X'40202120'  SET COUNT MASK
         ED    LINE+5(4),CNT       EDIT IN THE COUNT
         L     R3,0(,R10)          GET COUNT FOR THIS INTERVAL
         MVC   LINE+124(9),=X'4020202020202120'
         CVD   R3,DBLE             DISPLAY THIS COUNT FIELD
         ED    LINE+124(9),DBLE+4
         M     R2,=F'10000'        TO 1/100 PERCENT
         D     R2,COUNT            DIVIDED BY TOTAL SAMPLES
         CVD   R3,DBLE             MAKE IT READY FOR EDIT
         MVC   LINE+114(7),=X'402021204B2020' SET EDIT MASK
         ED    LINE+114(7),DBLE+5  EDIT THE PERCENTAGE
         SR    R2,R2               CLEAR THE REMAINDER
         LA    R3,50(,R3)          ADD 1/2 UNIT
         D     R2,=F'100'          MAKE IT STRAIGHT PERCENT
         LTR   R3,R3               IS THERE ANYTHING
         BZ    PERLOOP             SKIP STARS IF NO
         MVI   LINE+11,C'*'        SET ONE STAR
         BCT   R3,*+8              SUB ONE, SKIP IF MORE TO ADD
         B     PERLOOP             EXIT, ONE STAR WAS ENOUGHT
         CH    R3,=H'99'           GREATER THAN 98%
         BL    *+8                 NO, BRANCH
         LH    R3,=H'99'           USE 99%
         BCTR  R3,0                SET FOR MOVE
         STC   R3,*+5              SET LENGTH
         MVC   LINE+12,LINE+11     MOVE THE REST OF THE STARS
PERLOOP  BAL   R11,PRNTLINE        GO PRINT THE LINE
         AP    CNT,INC             INCREMENT THE COUNT
         LA    R10,4(,R10)         POINT TO NEXT FIELD
         BCT   R9,PERCNTA          LOOP UNIIL DONE
         LR    R11,R8              RESTORE RETURN REG
         BR    R11                  AND RETURN
*
SETITLE  LA    R1,TITLPARM         GET THE PARMS
         L     R15,=V(TITLE)        AND THE ADDRESS OF THE ROUTINE
         BALR  R14,R15             GO SET THE TITLE
SETSUB1  ST    R2,SUBPARMS         SAVE A(SUB TITLE)
         LA    R1,SUBPARMS         GET THE ADDRESS OF THE PARMS
         L     R15,=V(SUBTTL1)     GET THE ADDRESS
         BALR  R14,R15             SET THE SUBTITLE
SETSUB2  ST    R3,SUBPARMS         SAVE ADDRESS OF SUB TITLE
         LA    R1,SUBPARMS         A(PARM)
         L     R15,=V(SUBTTL2)     ADDRESS OF THE ROUTINE
         BALR  R14,R15             DOIT
         MVI   LINE,C'1'           SET FOR PAGE EJECT
PRNTLINE LA    R1,PRNTPARM         A(PRINT PARMS)
         L     R15,=V(PRINT)       A(PRINT ROUTINE)
         BALR  R14,R15             PRINT THE LINE
         MVI   LINE,C' '           BLANK OUT THE
         MVC   LINE+1(131),LINE     ENTIRE LINE
         BR    R11                 RETURN TO THE CALLER
*
SETQUE   LA    R7,&MAXJOBS         MAX FOR BCT LOOP
         LA    R6,(&MAXJOBS*4)(,R4) A(LAST THING IN STAT TABLE
         LA    R1,SUBQUE
SETLESS  LA    R5,4                DECREMENT AMOUNT
         ST    R1,CURRHDR
         ZAP   CNT,=P'0'           INITIALIZE THE DISPLAY COUNTER
         OC    0(4,R6),0(R6)       IS THE LAST ITEM ZERO?
         BZ    SETQLP1             YES, BRANCH
         SR    R6,R5               NO, BACK UP ONE (WILL BE
         BCT   R7,SETQLP2            RE-ADJUSTED LATER)
         BR    R8
SETQLP1  OC    0(4,R6),0(R6)       THIS ITEM ZERO?
         BNZ   SETQLP2             NO, START PRINT HERE
         SR    R6,R5               SUBTRACT 4
         CH    R7,=H'7'            DO AT LEAST THE FIRST SEVEN ITEMS
         BL    SETQSTRT
         BCT   R7,SETQLP1          SPIN UNTIL DONE
         BR    R8                  RETURN IF ONLY ZERO
SETQLP2  OC    4(4,R4),4(R4)       NEXT ITEM ZERO?
         BNZ   SETQSTRT            NO, BRANCH
         AP    CNT,INC             IGNORE THIS ITEM
         AR    R4,R5               ADD 4
         BCT   R7,SETQLP2          TRY NEXT ONE
         BR    R8                  RETURN IF ALL ZERO
SETQSTRT L     R2,CURRHDR          SET SUBTITLE
         LA    R3,PERCENT          AND SECOND SUBTITLE
         BAL   R11,SETSUB1         SET THE SUBTITLES AND PAGE EJECT
         LA    R9,2(,R7)           SET MAX FOR PRINT LOOP
         LR    R10,R4               STARTING HERE
         LR    R11,R8              SET RETURN FOR SETPERCNT
         B     SETPERCT+6          NOW DO IT
         EJECT
         LTORG
         PRINT NOGEN
STAT     DCB   DDNAME=HASPSTAT,MACRF=(R),DSORG=PS
         PRINT GEN
CURRHDR  DC    A(0)
TITLPARM DC    A(TITLINE,*+4)
         DC    A(L'TITLINE)
SUBPARMS DC    A(0,F132)
PRNTPARM DC    A(LINE,F132)
F132     DC    F'132'
TITLINE  DC    C' 370/158 HASP 4.0 -- STATISTICS  '
SUBSPOOL DC    CL50' ',CL82'SPOOL UTILIZATION'
PERCENT  DC    CL10'  % USE',100C'-',CL22'   PERCENT OCCURRENCES'
SUBCONBF DC    CL50' ',CL82'FREE CONSOLE BUFFERS'
SUBBUF   DC    CL50' ',CL82'FREE SPOOL BUFFERS'
SUBIO    DC    CL50' ',CL82'ACTIVE HASP I/O'
SUBXEQ   DC    CL50' ',CL82'JOBS IN O/S EXECUTION'
SUBDCT   DC    CL50' ',CL82'DEVICE CONTROL TABLE STATUS'
SUB2DCT  DC    CL41' ',CL91'DEVICE ADDRESS       % ACTIVE'
LINE     DC    CL132' '
SUBMTTR  DC    CL132'                    SPOOL 0 HEAD POSITION'
SPOOLNUM EQU   SUBMTTR+26
SUBQUE   DC    CL50' ',CL82'JOBS AWAITING EXECUTION'
SUBPRINT DC    CL9'OUTPUT'
SUBJCLCK DC    CL9'JCLCHK'
SPLCOUNT DC    X'4020206B20212040',C'SAMPLES THIS SPOOL'
SAMSG    DC    C'NUMBER OF SAMPLES THIS RUN',X'40206B2020206B202120'
MISCTAB  DC    CL35'O/S READER PENDING                 '
         DC    CL35'ALL AVAILABLE FUNCTIONS COMPLETE   '
         DC    CL35'SYSTEM HAS BEEN $DRAINED           '
         DC    CL35'CHECKPOINT IS IN PROGRESS          '
         DC    CL35'CHECKPOINT JOB INFORMATION TABLE   '
         DC    CL35'HASP SYSTEM IN TERMINATION         '
         DC    CL35'CHECKPOINT JOB OUTPUT TABLE (JOT)  '
MISCLINE EQU   *    12345678901234567890123456789012345
WTLINE   DC    CL35'HASP POSTED                        '
         DC    CL35'WAITING FOR A BUFFER               '
         DC    CL35'WAITING FOR A TRACK                '
         DC    CL35'WAITING FOR A JOB                  '
         DC    CL35'WAITING FOR A UNIT                 '
         DC    CL35'WAITING FOR A CHECKPOINT           '
         DC    CL35'WAITING FOR A CMB OR SMF BUFFER    '
         DC    CL35'WAITING FOR JOT SERVICE            '
WTEND    EQU   *
MISC     DC    CL30'HASP SYSTEM   $STATUS',CL20'PERCENT OCCURRENCES'
ONMSG    DC    C'DATE ON ',X'4020204B202120'
         DC    C'  TIME ON ',X'4021207A20204B20204B204040'
         DC    C'  HASP JOB NUMBER',X'402020202120'
CNT      DC    PL2'0'
INC      DC    PL1'0'
SAVEA    DC    9D'0'
DBLE     DC    D'0'
         SPACE 2
STATS    DC    0D'0'
COUNT    DC    F'0'
RDRPEND  DC    F'0'
ALMSGSW  DC    F'0'
DRAINED  DC    F'0'
CKPTACT  DC    F'0'
JITCKPT  DC    F'0'
SYSEXIT  DC    F'0'
JOTCKPT  DC    F'0'
JOBNOS   DC    F'0'
$HASPWT  DC    8F'0'
TIMEON   DC    2F'0'
TIMEOFF  DC    2F'0'
BASE     DC    A(0)
ASPOOL   DC    A(0)
AMTTR    DC    A(0)
ACONBUF  DC    A(0)
ABUF     DC    A(0)
AIO      DC    A(0)
AXEQ     DC    A(0)
AQXEQ    DC    A(0)
AQOUTPUT DC    A(0)
AQJCLCK  DC    A(0)
ADCT     DC    A(0)
AEND     DC    A(0)
&TEMP    SETA  (&NUMRDRS+&NUMPRTS+&NUMINRS+&NUMPUNS)*2
&TEMP    SETA  &TEMP+&MAXXEQS+2
&TEMP    SETA  &TEMP+&NUMLNES+&NUMTPBF+(&NUMRJE*2)+4
         AIF   (&NUMTPPU EQ 0).NORTMPU
&TEMP    SETA  &TEMP+&NUMRJE
.NORTMPU ANOP
$DCT     DC    &TEMP.CL12' '       SAVE FOR DEVICE NAMES
SPOOL    DS    51F
CONBUF   DS    (&NUMWTOQ+1)F
BUF      DS    (&BUFNUM+1)F
IO       DS    41F
XEQ      DS    (&MAXXEQS+2)F
DCT      DS    &TEMP.F
&TEMP    SETA  &NUMDA*51           50 CYLINDER GROUPS PLUS ONE COUNT
MTTR     DS    &TEMP.F
QXEQ     DS    (&MAXJOBS+1)F
QOUTPUT  DS    (&MAXJOBS+1)F
QJCLCK   DS    (&MAXJOBS+1)F
END      DS    0F
TABLEN   EQU   *-COUNT
         SPACE 2
         END   HASPRINT
./       ADD   NAME=HASPRIN2
HPR2     TITLE 'HASP MONITOR - PRINTER - COMMON PRINT ROUTINE'
*
*        THIS ROUTINE ALLOWS SIMPLE ACCESS TO SYSPRINT FOR AN
*        ASSEMBLY LANGUAGE PROGRAM, WITHOUT THE NECESSITY FOR
*        CONTINUOUS MONITORING OF CARRIAGE CONTROL CHARACTERS,
*        LINE COUNTS, ETC.
*
*        CALLING SEQUENCES ...
*
*        CALL  PRINT,(TEXT,NLEN)  PRINT ONE LINE.
*
*              WHERE TEXT IS AN ARRAY CONTAINING THE OUTPUT, AND
*              NLEN IS A FULLWORD INTEGER VARIABLE CONTAINING THE COUNT
*              (IN BYTES) OF THE RECORD TO BE PRINTED.
*
*        CALL  TITLE,(TEXT,NLEN)  ESTABLISH PAGE TITLE.
*              WHERE DEFINITIONS ARE AS ABOVE.
*
*        FORMAT --
*
*        1. ALL PRINT LINES MUST CARRY ASA CARRIAGE CONTROL CHARACTERS.
*           ONLY '1', '0', AND ' ' ARE SUPPORTED.
*
*        2. THE USER MUST SUPPLY A SYSPRINT DD.  IF DIFFERENT VALUES
*           ARE NOT SUPPLIED ON THIS DD, DCB=(RECFM=FA,BLKSIZE=133).
*
*        ERROR EXITS --
*
*        1. IF NO SYSPRINT DD IS SUPPLIED, AN ON-LINE MESSAGE AND AN
*          ABEND (USER=100) ARE PRODUCED.
*
*        2. IF AN I/O ERROR OCCURS, AN ON-LINE MESSAGE AND AN ABEND
*          (USER 200) ARE PRODUCED.
*
         EJECT
PRINT    CSECT
         SPACE 2
         ENTRY TITLE              ALTERNATE ENTRY WITH PAGE TITLE.
         ENTRY SUBTTL1            ALTERNATE ENTRY TO FILL FIRST SUBTTL.
         ENTRY SUBTTL2            ALTERNATE ENTRY TO FILL 2ND SUBTITLE.
         SPACE 2
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         SPACE 2
         PRINT NOGEN
         SAVE  (14,12),,*
         USING *-14,R12                ESTABLIST BASE REGISTER
         LR    R12,R15                 ..
         LA    R2,SAVE                 SATISFY LINKAGE CONVENTIONS
         ST    R2,8(,R13)              ..
         ST    R13,4(,R2)              ..
         LR    R13,R2                  ..
         LM    R2,R3,0(R1)        PICK UP PARAMETERS.
         L     R3,0(,R3)          PICK UP BYTE COUNT.
         LA    R4,133             MAXIMUM ALLOWED COUNT.
         CR    R3,R4              IS COUNT GREATER THAN ALLOWED...
         BNH   *+6                NO. USE USER VALUE.
         LR    R3,R4              YES. USE MAXIMUM VALUE.
         LTR   R3,R3              IS COUNT NEGAITVE OR ZERO...
         BP    *+6                NO. USE PRESENT VALUE.
         LR    R3,R4              YES. SUPPLY DEFAULT.
         BCTR  R3,0               REDUCE FOR MOVE CHARCTERS.
         LA    R4,BUFFER          ESTABLISH 'TO' FIELD FOR MOVE.
         EX    R3,MVC             MOVE THE DATA INTO THE BUFFER.
*
         LA    R4,DCB             IS THE DCB OPEN...
         USING IHADCB,R4
         TM    DCBOFLGS,X'10'
         BO    OPENOK             YES. OMIT OPEN PROCESSING.
*
         TIME  DEC                     R0=HHMMSSTH, R1=00YYDDDC.
         ST    R1,WORK1                TAKE DATE.
         MVI   WORK1+2,X'0F'           INSERT SIGN FOR CONVERSION.
         UNPK  WORK2(3),WORK1+1(2)     GIVES EBCDIC YY0.
         MVC   DATE+9(2),WORK2         MOVE YY OF PREVIOUS CONVERT.
         TM    WORK1+1,X'1'  ODD YEAR ?
         BNZ   NOLEAP        YES; NOT LEAP
         TM    WORK1+1,X'12'  MULTIPLE OF 4 ?
         BM    NOLEAP        NO
LEAP     MVI   DATETBL+9,X'9C'         ALLOW FOR 29 DAYS IN FEB.
NOLEAP   ST    R1,WORK1                TAKE DATE.
         LA    R2,DATETBL              BASE ADDRESS OF TABLE.
DATELOOP CP    WORK1+2(2),3(2,R2)
         BNH   DATEOUT                 WE HAVE THE RIGHT MONTH.
         SP    WORK1+2(2),3(2,R2)      REDUCE BY NO. OF DAYS/MONTH.
         LA    R2,5(,R2)               MOVE DOWN TABLE.
         B     DATELOOP                RETURN TO CHECK NEXT MONTH.
*
DATEOUT  MVC   DATE(3),0(R2)           MOVE MONTH NAME INTO DATE.
         UNPK  DATE+4(2),WORK1+2(2)    UNPACK DAY OF MONTH.
         OI    DATE+5,X'F0'            SUPPRESS SIGN.
         CLI   DATE+4,X'F0'            ZERO-SUPPRES THE DATE.
         BNE   *+8
         MVI   DATE+4,X'40'
         MVC   TITLBUFF+99(11),DATE
*
         ST    R0,WORK1                DEVELOP HOUR, MOD 12.
         MVI   WORK1+1,X'0F'
         CP    WORK1(2),=PL2'120'
         BL    *+8
         MVI   TIME+6,C'P'
         CP    WORK1(2),=PL2'130'
         BL    *+10
         SP    WORK1(2),=PL2'120'
         UNPK  WORK2(3),WORK1(2)
         MVC   TIME(2),WORK2
         CLI   TIME,C'0'
         BNE   *+8
         MVI   TIME,C' '
*
         ST    R0,WORK1                DEVELOP MINUTE.
         MVI   WORK1+2,X'0F'
         UNPK  WORK2(3),WORK1+1(2)
         MVC   TIME+3(2),WORK2
         MVC   TITLBUFF+89(8),TIME
*
         OPEN  (DCB,OUTPUT)       OPEN OUR DCB.
         TM    DCBOFLGS,X'10'
         BO    OPENOK             DCB IS OPEN.
*
         WTO   '*** INVALID OR MISSING SYSPRINT DD ***'
         ABEND 100,DUMP,STEP      KILL THE JOB.
         DROP  R4
*
OPENOK   CLI   BUFFER,C'1'        DID THE USER REQUEST PAGE SKIP...
         BE    EJECT
         LH    R2,LINECNT         NO. TRY TO FIT LINE ON THIS PAGE.
         BCTR  R2,0               REDUCE LINE COUNT BY ONE.
         CLI   BUFFER,C'0'        DID THE USER REQUEST A LINE SKIP...
         BNE   *+6
         BCTR  R2,0               REDUCE LINE COUNT BY ONE.
         LTR   R2,R2              CHECK RESULTING COUNT.
         BM    EJECT
         STH   R2,LINECNT         LINE WILL FIT.
*
PUT      PUT   DCB,BUFFER         OUTPUT ONE PRINT LINE.
         MVI   BUFFER,C' '        CLEAR THE BUFFER.
         MVC   BUFFER+1(132),BUFFER
         LH    R2,LINECNT
         L     R1,4(,R13)         FIND SAVE AREA REGISTER 1
         ST    R2,24(R1)               TO HOAX RETURNX INTO FILLING IT.
         L     R13,4(,R13)             RESTORE PREVIOUS SAVE AREA PTR
         RETURN (14,12),T,RC=0
*
EJECT    PUT   DCB,TITLBUFF       OUTPUT THE PAGE TITLE.
         PUT   DCB,SUBTTL         FIRST SUBTITLE
         PUT   DCB,SUBTTL+133     SECOND SUBTITLE
         MVI   BUFFER,C' '
*
         LA    R2,52              REMAINING LINES/PAGE.
         STH   R2,LINECNT
         AP    PAGECNT(2),=PL2'1' INCREMENT PAGE COUNT.
         MVC   TITLBUFF+117(4),=X'40202120'
         ED    TITLBUFF+117(4),PAGECNT
         B     PUT                RETURN TO OUTPUT TEXT LINE.
*
SYNAD    WTO   '*** SYSPRINT I/O ERROR ***' SYSPRINT ERROR.
         ABEND 200,DUMP,STEP
*
*
         USING *,R15              DCB EXIT ROUTINE.
         USING IHADCB,R1
EXIT     MVI   DCBRECFM,B'10000100' RECFM=FA
         STM   R2,R5,SAV               SAVE REGISTERS
         LH    R3,DCBLRECL             MAKE BLKSI A MULTIPLE OF LRECL
         SR    R4,R4                   ..
         LH    R5,DCBBLKSI             ..
         CR    R3,R5                   ..
         BL    FFFIX                   ..
         MVC   DCBBLKSI,DCBLRECL       DEFAULT BLKSI TO LRECL
         B     ENDEXIT
FFFIX    DR    R4,R3
         MH    R5,DCBLRECL             ..
         STH   R5,DCBBLKSI             REPLACE BLKSI IN DCB
         CLC   DCBBLKSI,DCBLRECL       CHECK FOR BLOCKING
         BE    ENDEXIT
         OI    DCBRECFM,B'00010000'    TURN ON BLOCKING FLAG
ENDEXIT  LM    R2,R5,SAV               RESTORE REGISTERS
         BR    R14                     RETURN TO OPEN PROCESSING
SAV      DC    4F'0'                   SAVE AREA
         DROP  R1,R15
*
TITLE    DS    0F
         USING *,R15
         B     *+10                    BRANCH AROUND CONSTANTS
         DC    AL1(5),CL5'TITLE'       CONSTANTS
         STM   R14,R12,12(R13)         SAVE REGISTERS
         DROP  R15
         USING *-14,R12                ESTABLISH BASE REGISTER
         LR    R12,R15                 ..
         LA    R2,SAVE                 SATISFY LINKAGE CONVENTIONS
         ST    R2,8(,R13)              ..
         ST    R13,4(,R2)              ..
         LR    R13,R2
         MVI   TITLBUFF+1,C' '    CLEAR THE TITLE BUFFER.
         MVC   TITLBUFF+2(84),TITLBUFF+1
         LM    R2,R3,0(R1)        PICK UP PARAMETERS.
         L     R3,0(,R3)          PICK UP BYTE COUNT.
         LA     R4,85             MAXIMUM FOR TITLE.
         CR    R3,R4              IS COUNT GREATER THAN ALLOWED...
         BNH   *+6                NO. USE USER VALUE.
         LR    R3,R4              YES. USE MAXIMUM VALUE.
         LTR   R3,R3              IS COUNT NEGAITVE OR ZERO...
         BP    *+6                NO. USE PRESENT VALUE.
         LR    R3,R4              YES. SUPPLY DEFAULT.
         BCTR  R3,0               REDUCE FOR MOVE CHARCTERS.
         LA    R4,TITLBUFF+1      ESTABLISH 'TO' FIELD FOR MOVE.
         EX    R3,MVC             MOVE THE DATA INTO THE BUFFER.
         SR    R3,R3              FORCE PAGE EJECT ON NEXT CALL.
         STH   R3,LINECNT
         MVI   SUBTTL+1,C' '      CLEAR SUBTITLES.
         MVC   SUBTTL+2(256),SUBTTL+1
         MVC   SUBTTL+258(8),SUBTTL+257
         L     R13,4(,R13)             RESTORE PREVIOUS SAVE AREA PTR
         RETURN (14,12),T,RC=0
*
SUBTTL1  DS    0F
         USING *,R15
         B     *+12                    BRANCH AROUND CONSTANTS
         DC    AL1(7),CL7'SUBTTL1'     CONSTANTS
         STM   R14,R12,12(R13)         SAVE REGISTERS
         DROP  R15
         USING *-16,R12                ESTABLISH BASE REGISTER
         LR    R12,R15                 ..
         LA    R2,SAVE                 SATISFY LINKAGE CONVENTIONS
         ST    R2,8(,R13)              ..
         ST    R13,4(,R2)              ..
         LR    R13,R2                  ..
         MVI   SUBTTL+1,C' '
         MVC   SUBTTL+2(256),SUBTTL+1  CLEAR ALL SUBTITLES.
         MVC   SUBTTL+258(8),SUBTTL+257
         LM    R2,R3,0(R1)        PARAMETERS
         L     R3,0(,R3)          COUNT
         LA    R4,132             MAXIMUM = 132
         CR    R3,R4              TOO MANY...
         BNH   *+6                OK
         LR    R3,R4              USE MAXIMUM IF TOO BIG
         LTR   R3,R3              NEG OR ZERO
         BNP   *+14               NOT OK, FORGET THE WHOLE THING.
         BCTR  R3,0
         LA    R4,SUBTTL+1        WHERE TO PUT DATA
         EX    R3,MVC             MOVE
         L     R13,4(,R13)             RESTORE PREVIOUS SAVE AREA PTR
         LM    R14,R12,12(R13)         RESTORE REGISTERS
         MVI   12(R13),X'FF'           SET RETURN INDICATOR
         SR    R15,R15                 CLEAR RETURN CODE
         BR    R14                     RETURN TO CALLER
*
SUBTTL2  DS    0F
         SAVE  (14,12),,SUBTTL2
         USING *-16,R12                ESTABLISH BASE REGISTER
         LR    R12,R15                 ..
         LA    R2,SAVE                 SATISFY LINKAGE CONVENTIONS
         ST    R2,8(,R13)              ..
         ST    R13,4(,R2)              ..
         LR    R13,R2                  ..
         MVI   SUBTTL+134,C' '
         MVC   SUBTTL+135(131),SUBTTL+134 CLEAR SECOND SUBTITLE
         LM    R2,R3,0(R1)        PARAMETERS.
         L     R3,0(,R3)
         LA    R4,132             MAXIMUM = 132
         CR    R3,R4              TOO MANY
         BNH   *+6
         LR    R3,R4              MAX IF TOO BIG
         LTR   R3,R3
         BNP   *+14               NOT OK, FORGET IT
         BCTR  R3,0
         LA    R4,SUBTTL+134      WHERE DATA GOES.
         EX    R3,MVC             MOVE
         L     R13,4(,R13)             RESTORE PREVIOUS SAVE AREA PTR
         RETURN (14,12),T,RC=0
         SPACE 2
DCB      DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=(PM),LRECL=133,RECFM=FA, *
               SYNAD=SYNAD,EXLST=EXTLST
         SPACE 2
SAVE     DC    18F'0'             REGISTER SAVE AREA.
WORK1    DC    F'0'
WORK2    DC    F'0'
EXTLST   DC    X'85',AL3(EXIT)    EXIT DURING OPEN.
LINECNT  DC    H'0'               LINES REMAINING THIS PAGE.
MVC      MVC   0(0,R4),0(R2)
BUFFER   DC    CL133' '           PRINT LINE IMAGE.
SUBTTL   DC    CL200'0',CL66' '
TITLBUFF DC    CL111'1',C'- PAGE   1'
DUMMY    DC    CL20' '            DUMMY FOR PUT.
PAGECNT  DC    PL2'1'
DATE     DC    C'MMM DD,19YY'
TIME     DC    C'HH.MM AM'
DATETBL  DC    C'JAN',PL2'31',C'FEB',PL2'28',C'MAR',PL2'31',C'APR'
         DC    PL2'30',C'MAY',PL2'31',C'JUN',PL2'30',C'JUL',PL2'31'
         DC    C'AUG',PL2'31',C'SEP',PL2'30',C'OCT',PL2'31',C'NOV'
         DC    PL2'30',C'DEC',PL2'31'  MONTHS AND DAYS PER MONTH.
         SPACE 2
         LTORG
         SPACE 2
         PRINT NOGEN
         DCBD  DSORG=QS
         SPACE 2
         END
