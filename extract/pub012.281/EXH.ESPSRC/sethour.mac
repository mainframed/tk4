SETHOUR TITLE 'UPDATE TOD CLOCK AND CLOCKxx MEMBER'
         PUNCH ' ORDER SETHOUR(P) '    MAKE DUMPS EASIER        GP04095
         PUNCH ' SETCODE AC(1)    '    PRIVIED                  GP04095
*---------------------------------------------------------------------*
* PROGRAM: SETHOUR           FROM CBT 465, FILE 639                   *
* AUTHOR : HUNTER ZHOU, GUANGHUI.ZHOU@SOBEYS.COM                      *
* UPDATE : MAY, 2003                                                  *
* DESCRIPTION: UPDATE TOD CLOCK BY ONE HOUR, AND UPDATE CLOCKxx       *
*---------------------------------------------------------------------*
* INSTALLATION                                                        *
* ============                                                        *
*  1. THE PROGRAM WILL BE RUN IN SUPERVISOR MODE.                     *
*     THE LOADLIB PDS MUST BE IN MVS APF AUTHORIZED LIST.             *
*     SUCH AS APF LIST IN SYS1.PARMLIB(PROGXX)                        *
*  2. OPTIONALLY, THE LOADLIB CAN BE PUT IN MVS LINKLST               *
*     IN SYS1.PARMLIB(PROGXX).                                        *
*     THE PROGRAM IS REENTRENT PROGRAM AND CAN BE ALSO LOADED         *
*     INTO LPA LIST (SYS1.PARMLIB(LPALSTXX))                          *
*  3. COMPILE REQUIREMENTS.                                           *
*     THE LINKEDIT OPTION MUST USE 'RENT,A(1)'.                       *
*     THE COMPILE OPTION IS GIVEN IN PARM.C='SYSPARM(parameter)':     *
*       .NORTHERN, NORTHERN HEMISHPERE or empty                       *
*                                                                     *
*        This is a default option to tell the program to run in       *
*     northern hemisphere.                                            *
*                                                                     *
*       .SOUTHERN or SOUTHERN HEMISPHERE                              *
*                                                                     *
*        This tells the program to run in southern hemisphere.        *
*     The difference of hemisphere is the TOD clock change for        *
*     daylight saving time is reverse as follows:                     *
*     Northern Hemisphere (North America, Europe, Asia):              *
*        In Spring: set 1 hour ahead                                  *
*        In Fall:   set 1 hour back                                   *
*                                                                     *
*     Southern Hemisphere (South America, Australia, Africa)          *
*        In Spring: set 1 hour back                                   *
*        In Fall:   set 1 hour ahead                                  *
*                                                                     *
*     Example 1: Compile for Northern Hemishpere (default)            *
*                                                                     *
*     //jobcard here.                                                 *
*     //COMPILE EXEC ASMACL,PARM.L='LIST,RENT,AC(1)'                  *
*     //C.SYSIN   DD DISP=SHR,DSN=SP2487.ASM.SOURCE(SETHOUR) <--ASM   *
*     //C.SYSLIB  DD DISP=SHR,DSN=SYS1.MACLIB                         *
*     //          DD DISP=SHR,DSN=SYS1.MODGEN                         *
*     //L.SYSLMOD DD DISP=SHR,DSN=SYS1.USER.LINKLIB   <==APF LIBRARY  *
*     //L.SYSIN   DD *                                                *
*       NAME SETHOUR(R)                                               *
*     /*                                                              *
*                                                                     *
*     Example 2: Compile for Southern Hemishpere:                     *
*                                                                     *
*     //jobcard here.                                                 *
*     //COMPILE EXEC ASMACL,PARM.L='LIST,RENT,AC(1)',                 *
*     //        PARM.C='SYSPARM=(SOUTHERN HEMISHPERE)'                *
*     //C.SYSIN   DD DISP=SHR,DSN=SP2487.ASM.SOURCE(SETHOUR) <--ASM   *
*     //C.SYSLIB  DD DISP=SHR,DSN=SYS1.MACLIB                         *
*     //          DD DISP=SHR,DSN=SYS1.MODGEN                         *
*     //L.SYSLMOD DD DISP=SHR,DSN=SYS1.USER.LINKLIB   <==APF LIBRARY  *
*     //L.SYSIN   DD *                                                *
*       NAME SETHOUR(R)                                               *
*     /*                                                              *
*  4. THE USER TO RUN THIS PROGRAM MUST HAVE ENGOUGH AUTHORITY.       *
*     THE SECURITY SOFTWARE WILL CHECK THE AUTHORITY OF THE USERID    *
*     IF HE HAS THE AUTHORITY TO ISSUE THE MVS COMMAND.               *
*                                                                     *
*---------------------------------------------------------------------*
* USER GUIDE                                                          *
* ==========                                                          *
*  The SETHOUR will update the current TOD clock by one hour,         *
*  and update CLOCKxx member in current system.                       *
*                                                                     *
*  This is used for time saving at April and October each year.       *
*  The program will issue the SET CLOCK system command to set         *
*  the new clock.                                                     *
*                                                                     *
*  The program will get the current TOD clock from system.            *
*  Depends on the parameter given in EXEC PARM, update the TOD        *
*  clock one hour foreward or backward.                               *
*                                                                     *
*  The date will be also changed at following situations:
*   1. Parameter is one hour foreward and the current hour is 23.     *
*   2. Parameter is one hour backward and the current hour is 00.     *
*  This does not apply for Janurary 1 and December 30 because it      *
*  it will change the year. So DO NOT run this program between        *
*  23PM December 30 and 01AM Janurary 1.                              *
*                                                                     *
*  The program will automatically locate your CLOCKxx member in       *
*  system. Normally the member will be SYS1.PARMLIB(CLOCK00).         *
*  The program will first find the CLOCK suffix xx, and search        *
*  the system PARMLIB PDS given in your LOADxx.                       *
*                                                                     *
*  The TIMEZONE statement in CLOCKxx will be updated according to     *
*  EXEC PARM parameters.                                              *
*  For example, if your current time zone in CLOCKxx member is:       *
*      TIMEZONE W.00.00.00                                            *
*  and you use PARM='+1' to run this program in April, this           *
*  time zone statement in CLOCKxx will be changed to:                 *
*      TIMEZONE E.01.00.00                                            *
*                                                                     *
*  PARAMETERS                                                         *
*  ----------                                                         *
*  The parameter is given in EXEC PARM. Here are the valid options:   *
*  According to the compile time SYSPARM option for southern or       *
*  Northern hemisphere, the PARM option will have different           *
*  meaning:                                                           *
*                                                                     *
*  1. +1                                                              *
*     This option to tell the program set TOD clock one hour          *
*     ahead, no matter where the system is.                           *
*                                                                     *
*  2. -1                                                              *
*     This option to tell the program set TOD clock one hour          *
*     back, no matter where the system is.                            *
*                                                                     *
*  3. SPRING×SUMMER                                                   *
*     These options tell program to set clock in Spring.              *
*     It can be used in April.                                        *
*                                                                     *
*     For Northern Hemisphere, it will set clock one hour ahead.      *
*     For Southern Hemisphere, it will set clock one hour back.       *
*                                                                     *
*     Example: Run following step in first Sunday morning in April:   *
*     //SETCLK  EXEC PGM=SETHOUR,PARM=SUMMER                          *
*     //SYSPRINT DD  SYSOUT=*                                         *
*                                                                     *
*  4. FALL×AUTUMN×WINTER                                              *
*     These option tell program to set clock in fall.                 *
*     It can be used in October.                                      *
*                                                                     *
*     For Northern Hemisphere, it will set clock one hour back.       *
*     For Southern Hemisphere, it will set clock one hour ahead.      *
*                                                                     *
*     Example: Run following step in last Sunday morning in October:  *
*     //SETCLK  EXEC PGM=SETHOUR,PARM=FALL                            *
*     //SYSPRINT DD  SYSOUT=*                                         *
*                                                                     *
*  5. AUTO                                                            *
*     These option tell program to set clock according to current     *
*     month, as follows:                                              *
*     . If current month is between Janurary and June, it will be     *
*       the same as parameter SPRING.                                 *
*     . If current month is between July and December, it will be     *
*       the same as parameter FALL,                                   *
*                                                                     *
*     AUTO option is useful when you need use the same JCL BATCH      *
*     for both April and October.                                     *
*                                                                     *
*     Example:                                                        *
*     You can use following step to change system clock in            *
*     both April and October.                                         *
*                                                                     *
*     //* update time by according current month                      *
*     //SETCLK  EXEC PGM=SETHOUR,PARM=AUTO                            *
*     //SYSPRINT DD  SYSOUT=*                                         *
*                                                                     *
*  6. HELP                                                            *
*     Show the help messages. If there is no PARM given, the help     *
*  message will also be displayed.                                    *
*                                                                     *
*                                                                     *
*  PERFORMANCE                                                        *
*  -----------                                                        *
*  There will be slight time difference (less than 1 second)          *
*  because TOD clock is changed via MVS command SET CLOCK.            *
*  You should give this TOD change job higher performance goal        *
*  to ensure minimum time difference.                                 *
*                                                                     *
*  To do so, you may need to verify your workload manager to          *
*  ensure the performance will be high enough. If you are running     *
*  workload manager goal mode, you must not run this job in           *
*  discretionary service classes.                                     *
*                                                                     *
*                                                                     *
*  CLOCK SENSITIVE SOFTWARE                                           *
*  ------------------------                                           *
*  Because some software products are sensitive to system clock,      *
*  especially when you TOD clock one hour back.                       *
*  You mey need to restart and wait one hour after the new clock      *
*  is set.                                                            *
*                                                                     *
*  To make this procedure automatic, you may use my AUTOIPL package   *
*  to restart these sensitive software. The AUTOIPL can be downloaded *
*  from file #623 in http://www.cbttape.org.                          *
*                                                                     *
*  Example:                                                           *
*                                                                     *
*  //*************************************************************    *
*  //* Stop CLOCK sensitive software                                  *
*  //STOPSW   EXEC PGM=IKJEFT01,PARM=AUTOIPL                          *
*  //STEPLIB  DD   DISP=SHR,DSN=SYS1.USER.LINKLIB <==AUTOIPL loadlib  *
*  //SYSEXEC  DD   DISP=SHR,DSN=SYS1.USER.REXXLIB <==AUTOIPL rexxlib  *
*  //SYSTSPRT DD   SYSOUT=*                                           *
*  //SYSTSIN  DD   DUMMY                                              *
*  //SYSIN    DD   *                                                  *
*    WTOH('STOP SOFTWARE FOR TIME CHANGE')  #issue highlight WTO      *
*    P RMF                                                            *
*    P TMONMVS                                                        *
*    P TMVSLFS                                                        *
*    WAIT                                                             *
*    P TMVSMSTR                                                       *
*    P TMVSHUB                                                        *
*  /*                                                                 *
*  //*************************************************************    *
*  //* Change TOD clock and CLOCKxx member                            *
*  //SETCLK   EXEC PGM=SETHOUR,PARM=AUTO                              *
*  //SYSPRINT DD   SYSOUT=*                                           *
*  //*************************************************************    *
*  //* Wait one hour before start CLOCK sensitive software            *
*  //* This is required to change TOD clock one hour back in October, *
*  //* and optional to changing TOD clock one hour ahead in April.    *
*  //WAIT     EXEC PGM=WAIT,PARM=3600        wait 3600 seconds        *
*  //*************************************************************    *
*  //* Start CLOCK sensitive software                                 *
*  //STARTALL EXEC PGM=IKJEFT01,PARM=AUTOIPL                          *
*  //STEPLIB  DD   DISP=SHR,DSN=SYS1.USER.LINKLIB                     *
*  //SYSEXEC  DD   DISP=SHR,DSN=SYS1.USER.REXXLIB                     *
*  //SYSTSPRT DD   SYSOUT=*                                           *
*  //SYSTSIN  DD   DUMMY                                              *
*  //SYSIN    DD   *                                                  *
*    WTOH('START SOFTWARE FOR TIME CHANGE')  #issue highlight WTO     *
*    S TMVSHUB                                                        *
*    S TMVSMSTR         #it will also start TMONMVS and TMVSLFS       *
*    S RMF                                                            *
*    WTOH('TIME SAVING CHANGE IS COMPLETED')                          *
*  //*                                                                *
*                                                                     *
*---------------------------------------------------------------------*
*---------------------------------------------------------------------*
* END OF DESCRIPTION OF THE PROGRAM                                   *
*---------------------------------------------------------------------*
* PROGRAM DESIGN                                                      *
* ==============                                                      *
* REGISTERS ASSIGNMENT                                                *
* --------------------                                                *
* CONSTANT REGISTERS THROUGH THE WHOLE PROGRAM:                       *
*  R12: BASE ADDRESS                                                  *
*  R11: SECOND BASE ADDRESS                                           *
*  R13: ADDRESSING FOR DYNAMIC STORAGE                                *
*                                                                     *
* FOLLOWING REGISTERS WILL BE MODIFIED WHILE CALLING MVS MACROS:      *
*   R0, R1, R14, R15                                                  *
*                                                                     *
* FOLLOWING REGISTERS WILL BE USED WITH THEIR PURPOSE:                *
*   R9 : WORK                                                         *
*   R8 : WORK                                                         *
*   R7 : WORK, SOURCE ADDR IN MVCREC                                  *
*   R6 : WORK, TARGET ADDR IN MVCREC                                  *
*   R5 : WORK, LENGTH IN MVCREC                                       *
*   R5 : WORK                                                         *
*   R3 : CALLING SECOND-LEVEL SUB-ROUTINES                            *
*   R2 : CALLING FIRST-LEVEL SUB-ROUTINES                             *
*                                                                     *
* PROGRAM LOGIC                                                       *
* -------------                                                       *
*  1. SETUP THE RE-ENTRENT PROGRAM ENVIRONMENT                        *
*     ALLOCATE THE WORK STORAGE(DSA)                                  *
*  2. INITIALIZE WORK STORAGE                                         *
*    .READ EXEC PARM                                                  *
*    .INITIAL MVS COMMAND BUFFER                                      *
*    .INITIAL DYNAMIC ALLOCATION BUFFER                               *
*    .INITIAL DYNAMIC ALLOCATION DCB/DCBE/OPENLISTS                   *
*  3. VALIDATE EXEC PARM                                              *
*  4. ISSUE SET CLOCK COMMAND TO CURRENT SYSTEM.                      *
*    .PREPARE EXTEND CONSOLE ENVIRONMENT                              *
*    .GET CURRENT SYSTEM TOD CLOCK (LOCAL TIME)                       *
*    .UPDATE SET CLOCK COMMAND BUFFER ACCORDING TO EXEC PARM          *
*     UPDATE HOUR (AND DAY OF YEAR IF REQUIRED) IN SET CLOCK          *
*    .ISSUE UPDATED SET CLOCK COMMAND (WITH DATE AND TIME)            *
*  5. GET THE NEW TIME ZONE                                           *
*    .GET CURRENT SYSTEM GMT CLOCK                                    *
*    .GENERATE NEW TIMEZONE STATEMENT ACCORDING TO LOCAL AND GMT      *
*     CLOCK                                                           *
*  6. FIND CURRENT CLOCKxx MEMBER                                     *
*     GET CLOCKxx SUFFIX FROM CVT-ECVT-ECVTIPA-IPACLOCK-IPAPDE        *
*     SEARCH ALL PARMLIB FOR CLOCKxx MEMBER                           *
*       . GET PARMLIB FROM CVT-ECVT-ECVTIPA-IPAPLIB@-IPAPLI           *
*       . ALLOCATE PARMLIB VIA DYNALLOC                               *
*       . OPEN PARMLIB PDS                                            *
*       . SEARCH CLOCKXX USING BLDL MACRO                             *
*       . CLOSE PARMLIB                                               *
*       . DEALLOCATE PARMLIB VIA DYNALLOC                             *
*  7. TEST THE TIME ZONE STATEMENT IN CURRENT CLOCKxx                 *
*       . ALLOCATE THE PARMLIB WITH CLOCKxx VIA DYNALLOC              *
*       . OPEN THE MEMBER WITH READ DCB                               *
*       . READ AND SCAN ALL RECORDS                                   *
*       . TEST TIMEZONE STATEMENT, UPDATE IT IF NOT THE SAME AS       *
*         THE NEW TIME ZONE STATEMENT IN STEP 6.                      *
*       . CLOSE CLOCKxx DD                                            *
*       . DEALLOCATE CLOCKxx VIA DYNALLOC                             *
*  8. UPDATE THE CLOCK MEMBER IF REQUIRED.                            *
*       . ALLOCATE THE PARMLIB WITH CLOCKxx VIA DYNALLOC              *
*       . OPEN THE MEMBER WITH WRITE DCB                              *
*       . WRITE ALL RECORDS                                           *
*       . CLOSE CLOCKxx DD                                            *
*       . DEALLOCATE CLOCKxx VIA DYNALLOC                             *
*  9. CLEAN UP.                                                       *
*       . READ THE RETURN CODE                                        *
*       . FREE ALLOCATED STORAGE                                      *
*       . RETURN TO THE CALLER                                        *
*                                                                     *
*---------------------------------------------------------------------*
         PRINT NOGEN         SAVE A TREE
SETHOUR  CSECT
SETHOUR  AMODE 31
SETHOUR  RMODE ANY
*---------------------------------------------------------------------*
* DEFINE REGISTER EQUALS USING IBM STANDARD MACRO YREGS               *
*---------------------------------------------------------------------*
* LOCAL CONSTANTS
         LCLC  &INIDDNM,&HEMISPH
&INTDDNM SETC  'SYSTMPDD'      INITIAL DD NAME IN ALL DCB
&HEMISPH SETC  '&SYSPARM'      HEMISPHERE: NORTHERN OR SOUTHERN
         AIF   ('&HEMISPH' NE ''         AND                           X
                '&HEMISPH' NE 'NORTHERN' AND                           X
                '&HEMISPH' NE 'SOUTHERN' AND                           X
                '&HEMISPH' NE 'NORTHERN HEMISPHERE' AND                X
                '&HEMISPH' NE 'SOUTHERN HEMISPHERE').SYSPERR
         AGO   .ASTART
.SYSPERR MNOTE 12,'The SYSPARM must be NORTHERN or SOURTHER or empty.'
         AGO   .END
.ASTART  ANOP
         YREGS
*---------------------------------------------------------------------*
* BUILD LINKAGE CONVENTION:                                           *
*---------------------------------------------------------------------*
* ESTABLISH ADDRESSABILITY, USING R15 AS TEMPORARY BASE REGISTER
         USING SETHOUR,R15           R15 IS CURRENT ADDRESS, USING IT
         B     START              BRANCH AROUND CONSTANTS
         DC    C' PROGRAM NAME(SETHOUR)'        MODULE IDENTIFIER
         DC    C' COMPILE TIME(&SYSDATE &SYSTIME)'
         DC    C' SETHOUR: UPDATE TOD CLOCK IN TIME SAVING CHANGE.'
         DC    C' JCL EXEC PARM SYNTAX:'
         DC    C' HELP: SHOW HELP MESSAGE.'
         DC    C' +1: SET ONE HOUR AHEAD.'
         DC    C' -1: SET HOUR BACKWARD.'
         DC    C' AUTO: Use +1 if current month<July, Otherwiae -1.'
         DC    C' Example: //SETCLK EXEC PGM=SETHOUR,PARM=AUTO   '
         DC    C' Design: Hunter Zhou, guanghui.zhou@sobeys.com '
BASE2REG DC    A(SETHOUR+4096)    Second base register
BASE3REG DC    A(SETHOUR+8192)    Second base register
START    DS    0H
         SAVE  (14,12)            ; SAVE CALLER'S REGISTERS USING SAVE
         L     R11,BASE2REG       second base register
         L     R10,BASE3REG       third  base register
         LR    R12,R15            Change base registers
         DROP  R15                Tell assembler
         USING SETHOUR,R12,R11,R10
*---------------------------------------------------------------------*
* SAVE THE PARAMETER REGISTER FROM R1 TO R7 BEFORE GETMAIN
*---------------------------------------------------------------------*
         LR    R7,R1              ;SAVE ADDR OF PARM TO R7
         LR    R8,R13             ;SAVE CALLER'S ADDRESS
*---------------------------------------------------------------------*
* DYNAMICALLY ALLOCATE STORAGE FOR DATA AREAS
*---------------------------------------------------------------------*
         GETMAIN RU,LV=STORLEN,LOC=BELOW ;OBTAIN STORAGE FOR DATA AREAS
         LR    R13,R1             ;ADDR OF ENTRY POINT
         USING DSA,R13            ;USING R11 AS STOR ADDRESSING REGS.
         ST    R8,SAVEAREA+4      ;SET OUR BACKWARD LINK
         ST    R13,8(R8)          ;SET CALLER'S FORWARD LINK
*---------------------------------------------------------------------*
* INITIALIZE BUFFERS
*---------------------------------------------------------------------*
         BAL   R2,INITIAL         ;INITIALIZE BUFFERS
         CLI   RETCODE,X'00'      ;TEST RETURN CODE
         BNE   RETURN
*---------------------------------------------------------------------*
* VALIDATE THE PARM
         BAL   R2,READPARM        ;CALL READ/VALIDATE PARAMETER
         CLI   RETCODE,X'00'      ;TEST RETURN CODE
         BNE   RETURN
         CLI   FLGTERM,YES        ;NEED TO STOP THE PROGRAM?
         BE    RETURN             ;YES, THEN STOP THE PROGRAM
* CALL MAIN FUNCTION
* PROCESS OF SYSTEM CLOCK
         BAL   R2,RUNSTCLK        CALL MVS COMMAND SET CLOCK
         CLI   RETCODE,X'00'      ;TEST RETURN CODE
         BNE   RETURN
* PROCESS OF PARMLIB CLOCKxx MEMBER
         BAL   R2,GETTZ           GET NEW TIME ZONE INFORMATION
         CLI   RETCODE,X'00'      ;TEST RETURN CODE
         BNE   RETURN
         BAL   R2,GETCLKMB        GET CURRENT SYSTEM CLOCKxx LOCATION
         CLI   RETCODE,X'00'      ;TEST RETURN CODE
         BNE   RETURN
         BAL   R2,TSTCLKMB        TEST CLOCKxx TIMEZONE STATEMENT
         CLI   RETCODE,X'00'      ;TEST RETURN CODE
         BNE   RETURN
         BAL   R2,UPDCLKMB
         B     RETURN
*---------------------------------------------------------------------*
*  RETURN LINKAGE                                                     *
*---------------------------------------------------------------------*
RETURN   EQU   *
         BAL   R2,TERMPROG        ;FREE ALLOCATED STORAGE
         XR    R9,R9              ;CLEAR R9
         IC    R9,RETCODE       ;LOAD RETURN CODE TO R9
         L     R11,SAVEAREA+4     ;LOAD CALLER'S ADDRESS
         FREEMAIN RU,LV=STORLEN,A=(R13)        ; FREE ALLOCATED STOR
         LR    R13,R11            ; COPY RETURN CODE TO R15
         LR    R15,R9             ; COPY RETURN CODE TO R15
         RETURN (14,12),RC=(15)   ;RESTORE CALLER'S REGS AND RETURN
*---------------------------------------------------------------------*
* ROUTINE: INITIAL
* DESCRIPTION: INITIALIZE ALL BUFFERS
* INPUT:
*    R2  : RETURN CONTROL
* RETURN :
*---------------------------------------------------------------------*
INITIAL  EQU    *
         MVI   RETCODE,X'00'      ;RESET RETURN CODE
         LA    R8,DSA+DSALEN      ;LOAD DTABLE ADDRESS
         ST    R8,DRECAREA        ;SAVE DTABLE ADDRESS INTO DRECAREA
*---------------------------------------------------------------------*
* SAVE THE PARAMETER TO PRIVATE STORAGE (PARM AND PARMLEN)
*---------------------------------------------------------------------*
         L     R7,0(R7)           ;LENGTH OF PARM
         LH    R5,0(R7)           ;LENGTH OF PARM
         LA    R7,2(,R7)          ;POINT AT DATA
         STH   R5,PARMLEN         ;COPY THE PARAMETER LENGTH TO PARMLEN
         LTR   R5,R5              ; TEST IF PARM IS ZERO
         BZ    INIT1000           ; IF NO PARM, SKIP TO COPY PARM
         BCTR  R5,0               ;DECREMENT LENGTH BY 1
         LA    R6,PARM            ;
         EX    R5,MVCREC          ; COPY PARAMETER
*---------------------------------------------------------------------*
* INITIALIZE STORAGE AREA WITH CONSTANT DATA
*---------------------------------------------------------------------*
* GET THE JOBNAME AS TEMPORARY CONSOLE NAME
INIT1000 EQU   *
         MVI   FLGTERM,NO         DO NOT STOP THE PROGRAM
         LA    R3,TIOTA
         EXTRACT (R3),'S',FIELDS=(TIOT),MF=(E,EXTRMFL) JOB NAME INFO
         L     R3,TIOTA           TIOT ADDRESS
         USING TIOT1,R3           TIOT ADDRESSABILITY
         MVC   HCCONSNM,TIOCNJOB  COPY THE JOBNAME AS CONSOL NAME
         DROP  R3
* INITIALIZE THE DATA BUFFERS
         MVC   SETCLK(SETCLKL),SETCLKC COPY THE SET CLOCK COMMAND
         MVC   DATEBUF(DATEMDLL),DATEMDL COPY DATE EDIT PATTERN
         MVC   WTOLIST(WTOMDLL),WTOMDL ;COPY THE MVC MODEL TO MVCCMD
* INITIALIZE THE DYNAMIC ALLOCATION BUFFERS
         MVC   TUALC(TUALCML),TUALCM     COPY TEXT UNIT CONTENTS
         MVC   TUUALC(TUUALCML),TUUALCM COPY UNALLOCATE TEXT UNITS
         MVI   MSGBUFCC,C' '            SET MESSAGE CC BYTE
* INITIALIZE THE DCBS
* PARMLIB READ  DCB
         MVC   PRMLIB(CPRMLIBL),CPRMLIB    COPY THE DCB TO BELOW 16M
         MVC   PRMOPLST(CPRMOPLL),CPRMOPL  COPY THE OPEN LIST TO BL 16M
* CLOCKxx READ  DCB
         MVC   CLRDCB(CCLRDCBL),CCLRDCB    COPY DCB
         MVC   CLRDCBE(DCBE$LEN),CCLRDCBE  COPY DCBE
         MVC   CLROPLST(CCLROPLL),CCLROPL
         LA    R4,CLRDCBE
         ST    R4,CLRDCB+(DCBDCBE-IHADCB)  UPDATE DCBE IN DCB
         LA    R4,CLRDCB
         ST    R4,CLROPLST+4               UPDATE DCB IN OPEN LIST
* CLOCKxx WRITE DCB
         MVC   CLWDCB(CCLWDCBL),CCLWDCB    COPY DCB
         MVC   CLWDCBE(DCBE$LEN),CCLWDCBE  COPY DCBE
         MVC   CLWOPLST(CCLWOPLL),CCLWOPL
         LA    R4,CLWDCBE
         ST    R4,CLWDCB+(DCBDCBE-IHADCB)  UPDATE DCBE IN DCB
         LA    R4,CLWDCB
         ST    R4,CLWOPLST+4               UPDATE DCB IN OPEN LIST
* SYSPRINT DD
         MVC   SPRDCB(CSPRDCBL),CSPRDCB    COPY DCB
         MVC   SPRDCBE(DCBE$LEN),CSPRDCBE  COPY DCBE
         MVC   SPROPLST(CSPROPLL),CSPROPL
         LA    R4,SPRDCBE
         ST    R4,SPRDCB+(DCBDCBE-IHADCB)  UPDATE DCBE IN DCB
         LA    R4,SPRDCB
         ST    R4,SPROPLST+4               UPDATE DCB IN OPEN LIST
* LOCATE THE DDNAME ADDRESS IN PRMLIB DCB
         LA    R4,PRMLIB                 LOAD DCB ADDRESS
         LA    R5,CPRMLIBL               LOAD DCB LENGTH
         LA    R6,PRMDDLOC               LOAD DDLOC ADDRESS STORAGE
         BAL   R3,FNDDLOC                CALL FIND DDNAME LOCATION
* LOCATE THE DDNAME ADDRESS IN CLRDCB
         LA    R4,CLRDCB                 LOAD DCB ADDRESS
         LA    R5,CCLRDCBL               LOAD DCB LENGTH
         LA    R6,CLRDDLOC               LOAD DDLOC ADDRESS STORAGE
         BAL   R3,FNDDLOC                CALL FIND DDNAME LOCATION
* LOCATE THE DDNAME ADDRESS IN CLWDCB
         LA    R4,CLWDCB                 LOAD DCB ADDRESS
         LA    R5,CCLWDCBL               LOAD DCB LENGTH
         LA    R6,CLWDDLOC               LOAD DDLOC ADDRESS STORAGE
         BAL   R3,FNDDLOC                CALL FIND DDNAME LOCATION
* INITIALIZE THE FLAGS
         MVI   FLGUCLKM,NO               UPDATE CLOCKxx FLAG TO NO
* INITIALIZE THE SYSPRINT DD
         MVI   MSGID,MSGINIT      ;INITIALIZE SYSPRINT DD
         BAL   R4,WRITELOG
* SHOW WELCOME MESSAGES
         MVI   MSGID,MSG001I
         BAL   R4,WRITELOG
         MVI   MSGID,MSG002I
         BAL   R4,WRITELOG
         MVI   MSGID,MSG003I
         BAL   R4,WRITELOG
* SHOW HEMISPHERE INFORMATION.
         AIF  ('&HEMISPH' NE 'SOUTHERN HEMISPHERE' AND                 X
               '&HEMISPH' NE 'SOUTHERN').AINORTH
         MVI   MSGID,MSG032I
         AGO   .AIEND
.AINORTH ANOP
         MVI   MSGID,MSG031I
.AIEND   ANOP
         BAL   R4,WRITELOG
INIT9000 EQU   *
         BR     R2
*
*---------------------------------------------------------------------*
* ROUTINE: TERMPROG
* DESCRIPTION: INITIALIZE ALL BUFFERS
* INPUT:
*    R2  : RETURN CONTROL
* RETURN :
*---------------------------------------------------------------------*
TERMPROG EQU   *
* TEST THE RETURN CODES FOR LAST MESSAGE
         CLI RETCODE,X'00'
         BE  TERM1000
         CLI RETCODE,X'04'
         BE  TERM2000
         MVI MSGID,MSG026I
         B   TERM5000
* STOP NORMALLY
TERM1000 EQU   *
         MVI MSGID,MSG024I
         B   TERM5000
* STOP WITH WARN MESSAGE
TERM2000 EQU   *
         MVI MSGID,MSG025I
         B   TERM5000
* CLOSE SYSPRINT
TERM5000 EQU   *
         BAL R4,WRITELOG
         MVI MSGID,MSGTERM      ;CLOSE SYSPRINT DD
         BAL R4,WRITELOG
         BR  R2
*---------------------------------------------------------------------*
* ROUTINE: FNDDLOC
* DESCRIPTION: FIND DDNAME LOCATION IN SPECIFIC DDNAME
* INPUT:
*    R3  : RETURN CONTROL
*    R4  : DCB ADDRESS
*    R5  : DCB LENGTH
*    R6  : ADDRESS TO BE SAVED TO
* RETURN :
*---------------------------------------------------------------------*
FNDDLOC EQU    *
* LOCATE THE DDNAME ADDRESS IN PRMLIB DCB
         AR    R5,R4                     THE LAST POSITION OF DCB
         LA    R7,8                      LENGTH OF THE DDNAME
         SR    R5,R7                     LAST POSSIBLE DDNAME ADDRESS
FNDD1000 EQU   *
         CLC   0(8,R4),SYSTMPDD          FIND THE INITIAL DDNAME
         BE    FNDD1200
         LA    R4,1(0,R4)                MOVE TO NEXT BYTE
         CR    R4,R5                     REACH AT THE END OF DCB?
         BL    FNDD1000                  NO, CONTINUE TO TEST NEXT ONE
FNDDERR  EQU   *
         MVI   RETCODE,X'0C'             SET THE RETURN CODE 12
         MVI   MSGID,MSG004I
         BAL   R4,WRITELOG
         B     FNDD9000
FNDD1200 EQU   *
         ST    R4,0(R6)                  SAVE THE DDNAME LOCATION
FNDD9000 EQU   *
         BR    R3
*
*---------------------------------------------------------------------*
* ROUTINE: RUNSTCLK
* DESCRIPTION: UPDATE TOD CLOCK MAIN PROCEDURE
* INPUT:
*    R2  : RETURN CONTROL
* RETURN :
*    R15 : 0 SUCCESS
*          8 UNSUCCESS
*---------------------------------------------------------------------*
RUNSTCLK EQU    *
*---------------------------------------------------------------------*
* PARPARE OPERPARM
*---------------------------------------------------------------------*
         LA    R8,OPERDATA            ADDRESS OF OPERPARM AREA
         USING MCSOPPRM,R8            IEZVG111 DSECT ADDRESSABILITY
         XC    MCSOPPRM(MCSOPLEN),MCSOPPRM  CLEAR THE OPERPARM AREA
***********************************************************************
* OVERRIDE THE CONSOLE ATTRIBUTES SPECIFIED IN THE USER PROFILE
* OF THE SECURITY PRODUCT BY TURNING ON BIT MCSOVRDY IN THE MCSOP DATA
* AREA. REQUEST THE HARDCOPY ATTRIBUTE (TO RECEIVE HARDCOPY MESSAGE SET
***********************************************************************
         OI    MCSOFLAG,MCSOVRDY      OVERRIDE CONSOLE ATTRIBUTES
         OI    MCSOMISC,MCSOHDCY      REQUEST THE HARDCOPY ATTRIBUTE
         DROP  R8                     DROP ADDRESSABILITY OF IEZVG111
*
*---------------------------------------------------------------------*
* CALL MGCRE TO ISSUE MVS COMMAND
*---------------------------------------------------------------------*
         MODESET MF=(E,MODESUP)    ;SUPERVISOR STATE, KEY 0
***********************************************************************
* ACTIVATE AN EXTENDED MCS CONSOLE WHOSE NAME IS CONTAINED IN A FIELD
* CALLED HCCONSNM.  THE ATTRIBUTES OF THE EXTENDED MCS CONSOLE ARE
* CONTAINED IN A FIELD CALLED OPERDATA, MAPPED BY IEZVG111.  THE
* CONSOLE WILL HAVE ITS MESSAGES DELIVERED ON A FIRST-IN-FIRST-OUT
* BASIS.  THE SYSTEM WILL POST A MESSAGE ECB CALLED HCMECB.
* THE ADDRESS OF THE OUTPUT AREA THAT CONTAINS THE
* ADDRESS OF THE MCS CONSOLE STATUS AREA IS CONTAINED IN A FIELD
* CALLED HCSTATUS.  THE ADDRESS OF THE ALET THAT IDENTIFIES THE ADDRESS
* OR DATA SPACE THAT CONTAINS THE MCS CONSOLE STATUS AREA IS
* CONTAINED IN A FIELD CALLED HCSTATAL.
* THE SYSTEM RETURNS THE CONSOLE ID IN THE FIELD CALLED HCCONSID.
* THE SYSTEM RETURNS A RETURN CODE AND A REASON CODE IN FIELDS
* CALLED HCRETC AND HCRNC, RESPECTIVELY.
***********************************************************************
         MCSOPER REQUEST=ACTIVATE,  ACTIVATE THE CONSOLE               X
               NAME=HCCONSNM,                                          X
               TERMNAME=HCCONSNM,                                      X
               OPERPARM=OPERDATA,                                      X
               MSGDLVRY=FIFO,                                          X
               MSGECB=HCMECB,                                          X
               MCSCSA=HCSTATUS,                                        X
               MCSCSAA=HCSTATAL,                                       X
               CONSID=HCCONSID,                                        X
               RTNCODE=HCRETC,                                         X
               RSNCODE=HCRSNC,                                         X
               MF=(E,MCSOPPL)
***********************************************************************
         BAL   R3,UPSETCLK            UPDATE HOUR WITH GIVEN -1 OR +1
***********************************************************************
         LA    R4,SETCLK             ;LOAD THE SETHOUR ADDRESS
SETCMD   MGCRE TEXT=(R4),            ;CALL MVS COMMAND MGCRE           X
               CONSNAME=HCCONSNM,MF=(E,MGCAREA)
         MCSOPER REQUEST=DEACTIVATE,CONSID=HCCONSID,ABTERM=NO,         X
               RTNCODE=HCRETC,RSNCODE=HCRSNC
         MODESET MF=(E,MODEPROB)    ;BACK TO NORMAL STATE
*SHOW COMMAND INFORMATION
* SHOW THE PARM IN LOG
         MVI MSGID,MSG028I
         BAL R4,WRITELOG
         MVI MSGID,MSGCUST
         LH  R5,SETCLK               LOAD THE COMMAND LENGTH
         LA  R6,MSGBUFTX+8
         LA  R7,SETCLKCM             JUST COPY THE COMMAND
         BCTR R5,0
         EX  R5,MVCREC               COPY THE PARM TO MSG BUFFER
         LA  R5,9(0,R5)              LOAD THE PARM LENGTH+8
         STC R5,MSGBUFLN
         BAL R4,WRITELOG
         BR   R2
*---------------------------------------------------------------------*
* ROUTINE: READPARM
* DESCRIPTION: READ AND VALIDATE PARAMETER FROM JCL EXEC PARM
* INPUT:
*    R2  : RETURN CONTROL
*  PARM  : THE PARAMETER TEXT
*PARMLEN : THE PARAMETER TEXT LENGTH
* RETURN :
* RETCODE: 0 VALID PARAMETER
*          4 NO PARAMETER
*          8 INVALID PARAMETER
*---------------------------------------------------------------------*
READPARM EQU *
         MVI RETCODE,X'00'
         LH  R5,PARMLEN
         LTR R5,R5
         BZ  PARMWARN
* SHOW THE PARM IN LOG
         MVI MSGID,MSGCUST
         MVC MSGBUFTX(32),=CL32'STZ010I The given EXEC PARM is: '
         LH  R5,PARMLEN
         LA  R6,MSGBUFTX+32
         LA  R7,PARM
         BCTR R5,0
         EX  R5,MVCREC               COPY THE PARM TO MSG BUFFER
         LA  R5,33(0,R5)              LOAD THE PARM LENGTH+8
         STC R5,MSGBUFLN
         BAL R4,WRITELOG
* VERIFY THE PARM
         LH  R5,PARMLEN
         LA  R6,PARM
         LA  R8,X'06'                LOAD THE MAXIMUM PARM LENGTH
         CR  R5,R8                   LENGTH > 6?
         BH  PARMERR
         LA  R5,PARMLEN              LOAD THE ADDRESS OF PARMLEN
         CLI 1(R5),X'02'
         BE  PARMCP2
         CLI 1(R5),X'04'
         BE  PARMCP4
         CLI 1(R5),X'06'
         BE  PARMCP6
         MVI RETCODE,X'08'
         B   PARMERR
PARMCP2  CLC 0(2,R6),OPTM1
         BE  PARMMINS
         CLC 0(2,R6),OPTP1
         BE  PARMPLUS
         B   PARMERR
PARMCP4  CLC 0(4,R6),OPTFALL
         BE  PARMMINS
         CLC 0(4,R6),OPTAUTO
         BE  PARMAUTO
         CLC 0(4,R6),OPTHELP
         BE  PARMHELP
         B   PARMERR
PARMCP6  CLC 0(6,R6),OPTAUTM
         BE  PARMMINS
         CLC 0(6,R6),OPTWNTR
         BE  PARMMINS
         CLC 0(6,R6),OPTSPRG
         BE  PARMPLUS
         CLC 0(6,R6),OPTSUMR
         BE  PARMPLUS
         B   PARMERR
* AUTO:
* if month < 06, then use +1, otherwise use -1
PARMAUTO EQU *
         TIME  DEC,DATELCL,LINKAGE=SYSTEM,    GET TIME/DATE AT DATELCL X
               MF=(E,TIMELST),DATETYPE=YYYYMMDD
         CLI DATELCL+10,X'06'     COMPARE MONTH WITH 06 (JUNE)
         BH  PARMMINS             IF HIGHER, JULY OR LATER, THEN USE -1
* +1
PARMPLUS EQU *
         MVI SETCPLUS,YES
         B   PARMOK
* -1
PARMMINS EQU *
         MVI SETCPLUS,NO
* PARM IS VALID , SHOW THE PARM INFORMATION
PARMOK   EQU *
* FOR PARM +1 AND -1, BYPASS CHECKING HEMISHPERE
         CLI 1(R5),X'02'    PARM LENGTH IS 2?
         BE  PARMOKA        YES, BYPASS HEMISPHERE CHECKING
         AIF  ('&HEMISPH' NE 'SOUTHERN HEMISPHERE' AND                 X
               '&HEMISPH' NE 'SOUTHERN').APNORTH
* REVERSE THE VALUE FOR SOURTHERN HEMISPHERE.
         XI  SETCPLUS,YES
.APNORTH ANOP
PARMOKA  EQU *
         CLI SETCPLUS,YES
         BNE PARMOKM
PARMOKP  EQU *
         MVI MSGID,MSG029I
         B   PARMOKS
PARMOKM  EQU *
         MVI MSGID,MSG030I
PARMOKS  EQU *
         BAL R4,WRITELOG
         B   PARMEND
* NO PARM
PARMWARN EQU *
         MVI MSGID,MSG022I
         MVI RETCODE,X'04'
         BAL R4,WRITELOG
         B   PARMHELP
* INVALID PARM
PARMERR  EQU *
         MVI MSGID,MSG023I
         BAL R4,WRITELOG
         MVI RETCODE,X'08'
* SHOW HELP MESSAGES
PARMHELP EQU *
         MVI FLGTERM,YES
         BAL R3,SHOWHELP
PARMEND  EQU *
         BR  R2
*---------------------------------------------------------------------*
*---------------------------------------------------------------------*
* ROUTINE: UPSETCLK
* DESCRIPTION: UPDATE SET CLOCK COMMAND BUFFER
* INPUT:
*    R3  : RETURN CONTROL
* RETURN : UPDATED SET CLOCK DATELCL WITH NEW HOUR OR DATE
* DATELCL: TIME & DATE HHMMSSthmiju0000 0YYYYDDD00000000
*                       0 1 2 3 4 5 6 7  8 9 0 1 2 3 4 5
*---------------------------------------------------------------------*
UPSETCLK EQU   *
         ZAP   HOURBUF,P0              ;CLEAR HOUR DECIMAL BUFFER
         ZAP   MINBUF,P0               ;CLEAR MINUTE DECIMAL BUFFER
         ZAP   SECBUF,P0               ;CLEAR SECOND DECIMAL BUFFER
         ZAP   STHBUF,P0               ;CLEAR SECOND/100 DECIMAL BUFFER
         ZAP   DAYBUF,P0               ;CLEAR DAY  DECIMAL BUFFER
* GET GMT TIME
         TIME  DEC,DATEGMT,LINKAGE=SYSTEM,   GET TIME/DATE IN DATEGMT  X
               MF=(E,TIMELST),DATETYPE=YYYYDDD,ZONE=GMT
* GET LOCAL TIME
         TIME  DEC,DATELCL,LINKAGE=SYSTEM,    GET TIME/DATE AT DATELCL X
               MF=(E,TIMELST),DATETYPE=YYYYDDD
         MVC   HOURBUF(1),DATELCL     COPY THE HOUR BYTE TO DEC BUFFER
         MVC   MINBUF(1),DATELCL+1    COPY THE MINUTE
         MVC   SECBUF(1),DATELCL+2    COPY THE SECOND
         MVC   STHBUF(1),DATELCL+3    COPY THE SECOND/100
         MVC   DAYBUF(2),DATELCL+10   COPY THE DAY OF YEAR
         CLI   SETCPLUS,YES           NEED +1?
         BE    UPDT3000               YES, PROCESS PLUS
* PROCESS -1
         CLI   DATELCL,X'00'          AT 00am?
         BE    UPDT1000               YES, UPDATE HOUR AND DATE
         SP    HOURBUF,P10            SUBTRACT HOUR BY 1
         B     UPDT2000
UPDT1000 EQU   *
         MVI   HOURBUF,X'23'          UPDATE HOUR TO 23
         SP    DAYBUF,P10             SUBTRACT DAY BY 1
UPDT2000 B     UPDT5000
* PROCESS +1
UPDT3000 EQU   *
         CLI   DATELCL,X'23'          AT 23pm?
         BE    UPDT4000               YES,UPDATE HOUR AND DATE
         AP    HOURBUF,P10            SUBTRACT HOUR BY 1
         B     UPDT5000
* UPDATE DATE AND HOUR
UPDT4000 EQU   *
         MVI   HOURBUF,X'00'          UPDATE HOUR TO 00
         AP    DAYBUF,P10             SUBTRACT HOUR BY 1
* ADJUST THE CLOCK BY 1 SECOND, RULES:
* TEST THE SECOND/100 BYTE
*   .IF SECOND/100 BYTE<50 (0.5 SECOND), NO SECOND ADJUSTMENT.
*   .OTHERWISE ADD 1 SECOND TO CURRENT CLOCK
*       IF SECOND!=59, JUST ADD SECOND BY 1, AND JUMP OUT
*       IF SECOND==59, SET SECOND=0,
*       IF MINUTE!=59, ADD MINUTE BY 1, AND JUMP OUT
*       IF MINUTE==59, SET MINUTE=0,
*       IF HOUR!=23, ADD HOUR BY 1, AND JUMP OUT
*       IF HOUR==23, SET HOUR=0, ADD YTD BY 1.
*
* PROCESS SECOND
UPDT5000 EQU   *
         MVC   DATELCL(1),HOURBUF     COPY THE UPDATED HOUR BYTE
         MVC   DATELCL+10(2),DAYBUF   COPY THE UPDATED DAY BYTE
         CLI   DATELCL+3,X'50'        COMPARE SECOND/100
         BL    UPDT6000               <50(0.5 SECOND), THEN SKIP CHANGE
         CLI   DATELCL+2,X'59'        TEST SECOND=59?
         BE    UPDT5100               YES, PROCESS MINUTE
         AP    SECBUF,P10             OTHERWISE ADD SECOND BY 1
         B     UPDT6000               AND CONTINUE UPDATE
* PROCESS MINUTE WHEN SECOND==59
UPDT5100 EQU   *
         ZAP   SECBUF,P0              SET SECOND TO 0.
         CLI   DATELCL+1,X'59'        TEST MINUTE=59?
         BE    UPDT5200               YES, PROCESS HOUR
         AP    MINBUF,P10             OTHERWISE ADD MINUTE BY 1
         B     UPDT6000               AND CONTINUE UPDATE
* PROCESS HOUR WHEN MINUTE==59
UPDT5200 EQU   *
         ZAP   MINBUF,P0              SET MINUTE TO 0.
         CLI   DATELCL,X'23'          TEST HOUR==23?
         BE    UPDT5300               YES, PROCESS HOUR
         AP    HOURBUF,P10            OTHERWISE ADD HOUR BY 1
         B     UPDT6000               AND CONTINUE UPDATE
* PROCESS DAY WHEN HOUR==23
UPDT5300 EQU   *
         ZAP   HOURBUF,P0             SET HOUR TO 0.
         AP    DAYBUF,P10             ADD YTD BY 1
         B     UPDT6000               AND CONTINUE UPDATE
* UPDATE DATELCL
UPDT6000 EQU   *
         MVC   DATELCL(1),HOURBUF     COPY THE HOUR BYTE
         MVC   DATELCL+1(1),MINBUF    COPY THE MINUTE BYTE
         MVC   DATELCL+2(1),SECBUF    COPY THE SECOND BYTE
         MVC   DATELCL+10(2),DAYBUF   COPY THE DAY BYTE
* FORMAT THE TIME AND DATE IN SET CLOCK COMMAND BUFFER
UPDT9000 EQU   *
         ED    TIMEFMT(9),DATELCL
         ED    DATEFMT(10),DATELCL+8
         MVC   SETCLKDT(8),DATEFMT+2
         MVC   SETCLKTM(8),TIMEFMT+1
         BR    R3
*---------------------------------------------------------------------*
* ROUTINE: GETTZ
* DESCRIPTION: GET THE NEW TIME ZONE FOR UPDATED TIME
* INPUT:
*    R2  : RETURN CONTROL
* RETURN :
*  TZSTMT: UPDATED CLOCKxx TIMEZONE STATEMENT FOR UPDATED TIME
*
*---------------------------------------------------------------------*
GETTZ    EQU   *
         MVC   TZSTMT(TZMDLL),TZMDL        COPY TIMEZONE STATEMENT
         MVC   TZHRDEC(TZHRMDLL),TZHRMDL   COPY THE HOUR EDIT MODEL.
         ZAP   GMTYTD,P0
         ZAP   LCLYTD,P0
         ZAP   GMTHOUR,P0
         ZAP   LCLHOUR,P0
         ZAP   TZDELTA,P0
* GMT AND LOCAL TIME ARE RETRIEVED IN SUB-ROUTINE UPSETCLK.
*
* COPY THE HOUR AND YTD (0YYYYDDD)
         MVC   GMTHOUR(1),DATEGMT
         MVC   GMTYTD(4),DATEGMT+8
         MVC   LCLHOUR(1),DATELCL
         MVC   LCLYTD(4),DATELCL+8
* COMPARE THE YTD
         CP    GMTYTD,LCLYTD              COMPARE YTD
         BE    GETT2000                   GMT DAY = LCL DAY
         CP    GMTYTD,LCLYTD              COMPARE YTD
         BH    GETT1000                   GMT DAY > LCL DAY
         B     GETT1200                   OTHERWISE GMT DAY < LCL DAY
* PROCESS GYTD > LYTD
GETT1000 AP    GMTHOUR,P240               ADD GMT HOUR BY 24
         B     GETT2000
* PROCESS GYTD < LYTD
GETT1200 AP    LCLHOUR,P240               ADD LOCAL HOUR BY 24
         B     GETT2000
* PROCESS GYTD = LYTD, COMPARE HOUR
GETT2000 CP    GMTHOUR,LCLHOUR            COMPARE HOUR
         BE    GETT5000                   GMT = LOCAL HOUR
         CP    GMTHOUR,LCLHOUR            COMPARE HOUR
         BH    GETT2200                   GMT > LOCAL HOUR
         B     GETT2400                   GMT < LOCAL HOUR
* PROCESS GMT > LOCAL HOUR
GETT2200 MVI   TZWORD,C'W'              WEST
         ZAP   TZDELTA,GMTHOUR
         SP    TZDELTA,LCLHOUR
         B     GETT3000
* PROCESS GMT < LOCAL HOUR
GETT2400 MVI   TZWORD,C'E'              EAST
         ZAP   TZDELTA,LCLHOUR
         SP    TZDELTA,GMTHOUR
         B     GETT3000
* FORMAT THE HOUR
GETT3000 EQU   *
         ED    TZHRDEC,TZDELTA           EDIT THE TZDELTA TO TZHRDEC
         MVC   TZHOUR(2),TZHRDEC+1   COPY THE NEW HOUR IN TIMEZONE
GETT5000 EQU   *
         MVI   MSGID,MSG005I
         BAL   R4,WRITELOG
         MVI   MSGBUFLN,X'1B'
         MVC   MSGBUFTX+8(19),TZSTMT+2
         MVI   MSGID,MSGCUST
         BAL   R4,WRITELOG
         BR    R2
*---------------------------------------------------------------------*
* ROUTINE: GETCLKMB
* DESCRIPTION: GET PARMLIB DATASET AND MEMBER FOR CURRENT CLOCKxx
*  STEPS:
*  1. FIND THE CURRENT CLOCK SUFFIX FROM ECVT/IPA
*  2. FIND THE PARMLIB DATASET NAME CONTAINS THIS CLOCK MEMBER
*
* INPUT:
*    R2  : RETURN CONTROL
* RETURN :
*  CLKPMMBR : the CLOCKxx member name
*  CLKPMDSN : The PARMLIB with member name
*---------------------------------------------------------------------*
GETCLKMB EQU   *
* Find CLOCKxx in current system
         STM   R0,R15,SVLVL1        SAVE ALL REGISTERS
         MVI   FLGFNDMB,NO          NOT FIND THE MEMBER
GETC1000 EQU   *
         MVC   CLKPMMBR,CLKMBNM     COPY THE INITIAL CLOCK MEMBER NAME
         L     R4,X'10'             GET CVT
         USING CVTMAP,R4            ADDRESSABILITY FOR CVT
         L     R5,CVTECVT           GET ECVT
         USING ECVT,R5              ADDRESSABILITY FOR ECVT
         L     R6,ECVTIPA           GET ECVTIPA
         USING IPA,R6               ADDRESSABILITY FOR IPA
         LA    R7,IPACLOCK          LOAD THE START OF CLOCK
         USING IPAPDE,R7            ADDRESSABILITY FOR IPAPDE
         L     R8,IPAPDESA          CLOCK PDE (PARM DESC ELEMENT)
         MVC   CLKPMSFX(2),0(R8)    COPY THE CLOCK MEMBER SUFFIX
         DROP  R4,R5,R7
         MVI   MSGID,MSGCUST
         MVC   MSGBUFTX(35),=CL35'STZ034I The active CLOCK member is '
         MVC   MSGBUFTX+35(8),CLKPMMBR
         LA    R4,43
         STC   R4,MSGBUFLN
         BAL   R4,WRITELOG
* the CLOCKxx is stored in CLKPMMBR
* Find PARMLIB which contain the member CLOCKxx in current system
         LA    R8,10                LOAD THE MAXIMUM PARMLIB CARD IMGS
         LA    R5,IPAPLIB           LOAD THE FIRST PARMLIB CARD IMAGE
         USING IPRMLIB,R5           MAP IT WITH IPRMLIB DSECT
GETC2000 EQU   *                    LOOP TO SCAN ALL PARMLIBS
         MVC   CLKPMDSN(44),IPMLDSN COPY THE CURRENT PARMLIB DSN
         CLI   IPMLDSN,C' '         IS THE DSN EMPTY?
         BE    GETC3400             YES, SKIP TO THE END
         TM    IPMLLFLG,IPAPLUSE    TEST IF PARMLIB IS IN USE OR NOT.
         BNO   GETC2500             NO, SKIP THIS PARMLIB CARD IMAGE
*
         MVI   MSGID,MSGCUST
         MVC   MSGBUFTX(34),=CL34'STZ035I Search active clock member'
         MVC   MSGBUFTX+34(19),=CL19' in system PARMLIB '
         MVC   MSGBUFTX+53(44),CLKPMDSN
         LA    R4,97
         STC   R4,MSGBUFLN
         BAL   R4,WRITELOG
*
* CALL DYNALC TO ALLOCATE THIS PARMLIB
         MVI   DSDISP,DISPSHR       TELL ALLOCAT DSN WITH SHR
         LA    R4,CLKPMDSN          LOAD THE DATASET NAME ADDRESS
         BAL   R3,DYNALC            CALL DYNALC TO ALLOCATE THE DATASET
         CLI   RETCODE,X'00'        RETURN CODE IS 0?
         BNE   GETCERR
         MVC   PRMDDNAM(8),ALCDD         SAVE THE DDNAME
         L     R4,PRMDDLOC
         MVC   0(8,R4),ALCDD        UPDATE THE DCB WITH DDNAME
* CALL BLDL TO LIST THE MEMBER INFORMATION
         OPEN  PRMLIB,MF=(E,PRMOPLST)
         LA    R4,1                 SET THE NUMBER OF MEMBERS TO 1
         STH   R4,BLDMBNB
         LA    R4,32                SET THE LENGTH OF BUFFERS TO 32
         STH   R4,BLDMBLN
         MVC   BLDMBNM(8),CLKPMMBR  COPY THE MEMBER NAME
         LA    R4,PRMLIB
         LA    R7,BLDLBUF
         BLDL  (R4),(R7)
         LTR   R15,R15              RETURN CODE IS 0?
         BNE   GETC2200             NON-ZERO, NOT FOUND IN THIS PARMLIB
         MVI   FLGFNDMB,YES         FIND THE MEMBER
* UNALLOCATE THE PARMLIB DDNAME
GETC2200 EQU   *
PRMDDEOF EQU   *
         CLOSE PRMLIB,MF=(E,PRMOPLST)
         LA    R4,PRMDDNAM          LOAD THE DD NAME TO R4
         BAL   R3,DYNUNALC          CALL DYNAMIC UNALLOCATE
         CLI   FLGFNDMB,YES         FIND THE PARMLIB WITH MEMBER?
         BE    GETC3000             YES, JUMP OUT OF THE LOOP
         MVI   MSGID,MSGCUST
         MVC   MSGBUFTX(34),=CL34'STZ036W Active clock member is not'
         MVC   MSGBUFTX+34(19),=CL19' in system PARMLIB '
         MVC   MSGBUFTX+53(44),CLKPMDSN
         LA    R9,97
         STC   R9,MSGBUFLN
         BAL   R4,WRITELOG
GETC2500 EQU   *
         LA    R5,64(0,R5)          GET NEXT PARMLIB CARD IMAGE
         BCT   R8,GETC2000          SCAN NEXT PARMLIB CARD IMAGE
         CLI   FLGFNDMB,YES         FIND THE PARMLIB WITH MEMBER?
         BNE   GETC7000             NO, SHOW ERROR
* PREPARE THE DATASET NAME+ MEMBER NAME
GETC3000 EQU   *
         MVI   MSGID,MSGCUST
         MVC   MSGBUFTX(36),=CL36'STZ037I Active clock member is found'
         MVC   MSGBUFTX+36(19),=CL19' in system PARMLIB '
         MVC   MSGBUFTX+55(44),CLKPMDSN
         LA    R9,99
         STC   R9,MSGBUFLN
         BAL   R4,WRITELOG
         DROP  R5,R6
         LA   R6,CLKPMDSN+43     MOVE TO THE END OF DATASET BUFFER
         LA   R7,44              LOAD MAXMIMUM LENGTH OF THE BUFFER
GETC3100 EQU  *
         CLI  0(R6),C' '         IS THIS SPACE?
         BNE  GETC3200           NO, OUT OF LOOP
         BCTR R6,0               MOVE TO PREVIOUS CHAR
         BCT  R7,GETC3100        TEST THE PREVIOUS CHAR
         BE   GETCERR            BUFFER IS FULL OF SPACE!
GETC3200 EQU  *
         MVI  1(R6),C'('          (
         MVC  2(8,R6),CLKPMMBR    COPY THE MEMBER NAME
         LA   R6,9(0,R6)
         LA   R7,8
GETC3300 EQU   *
         CLI  0(R6),C' '         IS THIS SPACE?
         BNE  GETC4000           NO, OUT OF LOOP
         BCTR R6,0               MOVE TO PREVIOUS CHAR
         BCT  R7,GETC3300        TEST THE PREVIOUS CHAR
* END OF SEARCH
GETC3400 EQU  *
         MVI   MSGID,MSGCUST
         MVC   MSGBUFTX(36),=CL36'STZ038I End of system PARMLIB search'
         LA    R9,36
         STC   R9,MSGBUFLN
         BAL   R4,WRITELOG
         BE   GETC7000
GETC4000 EQU   *
         MVI  1(R6),C')'          )
*
         MVI   MSGID,MSGCUST
         MVC   MSGBUFTX(31),=CL31'STZ021I The active clock member'
         MVC   MSGBUFTX+31(19),=CL19' in your system is '
         MVC   MSGBUFTX+50(44),CLKPMDSN
         LA    R9,94
         STC   R9,MSGBUFLN
         BAL   R4,WRITELOG
         B     GETC9000
GETC7000 EQU   *
         MVI   MSGID,MSG033I
         BAL   R4,WRITELOG
         MVI   RETCODE,X'0C'     SET THE RETURN CODE 12
         B     GETC9000
GETCERR  EQU   *
         MVI   RETCODE,X'0C'     SET THE RETURN CODE 12
GETC9000 EQU   *
         LM    R0,R15,SVLVL1        RESTORE ALL REGISTERS
         BR    R2
*---------------------------------------------------------------------*
* ROUTINE: TSTCLKMB
* DESCRIPTION: GET PARMLIB DATASET AND MEMBER FOR CURRENT CLOCKxx
*  STEPS:
*  3. ALLOC THE CLOCKxx MEMBER WITH READ
*  4. OPEN THE CLOCKxx MEMBER
*  5. READ THE CLOCKxx MEMBER
*  6. CLOSE THE CLOCKxx MEMBER
*  7. COMPARE TIMEZONE STATEMENT WITH NEW TIMEZONE STATEMENT
*     UPDATE THE FLAG FLGUPCLK
* INPUT:
*    R2  : RETURN CONTROL
* RETURN
*    FLGUPCLK: YES OR NO
*---------------------------------------------------------------------*
TSTCLKMB EQU   *
         MVI   MSGID,MSGCUST
         MVC   MSGBUFTX(35),=CL35'STZ030I Test if required to update '
         MVC   MSGBUFTX+35(44),CLKPMDSN
         LA    R9,79
         STC   R9,MSGBUFLN
         BAL   R4,WRITELOG
* READ CLOCKxx in current system
* DYNAMICALLY ALLOCATE CLOCK MEMBER
         L     R8,DRECAREA
         USING DTABLE,R8
         MVI   DSDISP,DISPSHR       TELL ALLOCAT DSN WITH SHR/READ
         LA    R4,CLKPMDSN          LOAD THE DATASET NAME ADDRESS
         BAL   R3,DYNALC            CALL DYNALC TO ALLOCATE THE DATASET
         CLI   RETCODE,X'00'        RETURN CODE IS 0?
         BNE   TSTCAERR
         MVC   CLRDDNAM(8),ALCDD    SAVE THE DDNAME
         L     R4,CLRDDLOC          LOAD DD NAME ADDRESS IN DCB
         MVC   0(8,R4),ALCDD        UPDATE DDNAME IN DCB
* OPEN THE DDNAME
         OPEN  (CLRDCB,(INPUT)),MODE=31,MF=(E,CLROPLST)
         TM    CLRDCB+(DCBOFLGS-IHADCB),DCBOFOPN OPEN SUCCESS?
         BNO   TSTCOERR             NO, JUMP TO ERROR PROCESSING
         MVI   MSGID,MSGCUST
         MVC   MSGBUFTX(37),=CL37'STZ031I Current statements in member'
         MVC   MSGBUFTX+37(44),CLKPMDSN
         LA    R9,81
         STC   R9,MSGBUFLN
         BAL   R4,WRITELOG
         LA    R6,CLKMBBUF          LOAD THE RECORD BUFFER ADDRESS
         XC    CLKMBCTR,CLKMBCTR
         XC    CLKMBRTZ,CLKMBRTZ
         XR    R5,R5                COUNTER
         MVI   MSGID,MSGCUST
TSTC1000 EQU   *
         GET   CLRDCB,0(R6)
* SHOW CURRENT TIMEZONE STATEMENT
         MVC   MSGBUFTX+8(80),0(R6)
         LA    R7,88
         STC   R7,MSGBUFLN
         BAL   R4,WRITELOG
* TEST THE RECORD
         CLC   0(9,R6),TZKEYW       TEST THIS IS TIMEZONE STATEMENT
         BNE   TSTC3000
         LA    R9,8(0,R6)           LOAD THE TIMEZONE STATEMENT
         LA    R7,72(0,R6)          LOAD THE STATEMENT END
TSTC2000 EQU   *                    SKIP ALL LEADING SPACES
         LA    R9,1(0,R9)           MOVE TO NEXT BYTE
         CR    R9,R7
         BNL   TSTCTZER
         CLI   0(R9),C' '
         BE    TSTC2000
* TEST THE STATMENT
         STH   R5,CLKMBRTZ          RECORD LOCATION OF THE STATEMENT
         CLC   0(4,R9),TZWORD       JUST COMPARE TZWORD AND HOUR
         BE    TSTC3000             IF THEY ARE THE SAME, SKIP IT
* UPDATE THE STATEMENT
         MVC   0(4,R9),TZWORD       UPDATE TIMEZONE WORD AND HOUR
         MVI   FLGUCLKM,YES         UPDATE  FLAG TO YES
*
* CONTINUE UNTIL EOF
TSTC3000 EQU   *
         LA    R5,1(0,R5)           INCREADE RECORD COUNTER
         LA    R9,CLKMBMAX
         CR    R5,R9
         BNL   TSTCRCER             JUMP TO ERROR PROCESSING
         LA    R6,80(0,R6)          MOVE TO NEXT BUFFER
         B     TSTC1000
TSTCRCER EQU   *
         MVI   MSGID,MSG010I
         BAL   R4,WRITELOG
         MVI   RETCODE,X'0C'
         B     CLKDDEOF
TSTCTZER EQU   *
         MVI   MSGID,MSG011I
         BAL   R4,WRITELOG
         MVI   RETCODE,X'0C'
         B     CLKDDEOF
CLKDDERR EQU   *
         MVI   RETCODE,X'0C'
         MVI   MSGID,MSG012I
         BAL   R4,WRITELOG
CLKDDEOF EQU   *
         STH   R5,CLKMBCTR
         CLOSE CLRDCB,MODE=31,MF=(E,CLROPLST)
         LA    R4,CLRDDNAM          LOAD THE DD NAME TO R4
         BAL   R3,DYNUNALC          CALL DYNAMIC UNALLOCATE
         B     TSTC9000
TSTCOERR EQU   *
         MVI   RETCODE,X'0C'
         MVI   MSGID,MSG013I
         BAL   R4,WRITELOG
         B     TSTC9000
TSTCAERR EQU   *
         MVI   RETCODE,X'0C'
         MVI   MSGID,MSG014I
         BAL   R4,WRITELOG
         B     TSTC9000
TSTC9000 EQU   *
         DROP  R8
         BR    R2
*---------------------------------------------------------------------*
* ROUTINE: UPDCLKMB
* DESCRIPTION: GET PARMLIB DATASET AND MEMBER FOR CURRENT CLOCKxx
*  STEPS:
*  9. ALLOC THE CLOCKXX MEMBER WITH WRITE
* 10. OPEN THE CLOCKXX MEMBER
* 11. WRITE THE CLOCKXX MEMBER
* 12. CLOSE THE CLOCKXX MEMBER
* INPUT:
*    R2  : RETURN CONTROL
* RETURN
*---------------------------------------------------------------------*
UPDCLKMB EQU   *
         CLI   FLGUCLKM,YES       NEED TO UPDATE THE CLOCK MEMBER?
         BE    UPDC0100           YES, THEN UPDATE
         MVI   MSGID,MSG015I
         BAL   R4,WRITELOG
         B     UPDC9000
*
* write CLOCKxx in current system
* DYNAMICALLY ALLOCATE CLOCK MEMBER
UPDC0100 EQU   *
         MVI   MSGID,MSG016I
         BAL   R4,WRITELOG
         MVI   DSDISP,DISPSHR       TELL ALLOCAT DSN WITH OLD/WRITE
         LA    R4,CLKPMDSN          LOAD THE DATASET NAME ADDRESS
         BAL   R3,DYNALC            CALL DYNALC TO ALLOCATE THE DATASET
         CLI   RETCODE,X'00'        RETURN CODE IS 0?
         BNE   UPDCAERR
         MVC   CLWDDNAM(8),ALCDD    SAVE THE DDNAME
         L     R4,CLWDDLOC          LOAD DD NAME ADDRESS IN DCB
         MVC   0(8,R4),ALCDD        UPDATE DDNAME IN DCB
* OPEN THE DDNAME
         OPEN  (CLWDCB,(OUTPUT)),MODE=31,MF=(E,CLWOPLST)
         TM    CLWDCB+(DCBOFLGS-IHADCB),DCBOFOPN OPEN SUCCESS?
         BNO   UPDCOERR             NO, JUMP TO ERROR PROCESSING
         L     R8,DRECAREA          LOAD THE DTABLE DSECT ADDRESS
         USING DTABLE,R8
         MVI   MSGID,MSG009I
         BAL   R4,WRITELOG
         LA    R6,CLKMBBUF        LOAD THE RECORD BUFFER ADDRESS
         LH    R5,CLKMBCTR          LOAD THE RECORD COUNTER
         MVI   MSGID,MSGCUST
UPDC1000 EQU   *
* SHOW NEW TIMEZONE STATEMENT
         LA    R7,88
         STC   R7,MSGBUFLN
         MVC   MSGBUFTX+8(80),0(R6)
         BAL   R4,WRITELOG
* SAVE THE RECORD
         PUT   CLWDCB,0(R6)         SAVE CURRENT RECORD
         LA    R6,80(0,R6)          MOVE TO NEXT RECORD
         BCT   R5,UPDC1000
         CLOSE CLWDCB,MODE=31,MF=(E,CLWOPLST)
         LA    R4,CLWDDNAM          LOAD THE DD NAME TO R4
         BAL   R3,DYNUNALC          CALL DYNAMIC UNALLOCATE
         MVI   MSGID,MSGCUST
         MVC   MSGBUFTX(37),=CL37'STZ042I Following member is updated:'
         MVC   MSGBUFTX+37(44),CLKPMDSN
         LA    R9,81
         STC   R9,MSGBUFLN
         BAL   R4,WRITELOG
         B     UPDC9000
UPDCOERR EQU   *
         MVI   RETCODE,X'0C'
         MVI   MSGID,MSG018I
         BAL   R4,WRITELOG
         B     TSTC9000
UPDCAERR EQU   *
         MVI   RETCODE,X'0C'
         MVI   MSGID,MSG019I
         BAL   R4,WRITELOG
         B     TSTC9000
UPDC9000 EQU   *
         DROP  R8
         BR    R2
*---------------------------------------------------------------------*
* ROUTINE: DYNUNALC
* DESCRIPTION: DYNAMICALLY UNALLOCATE THE DDNAME
* INPUT:
*  R3      : RETURN CONTROL
*  R4      : DDNAME TO BE UNALLOCATED
*
*---------------------------------------------------------------------*
DYNUNALC EQU  *
         STM  R0,R15,SVLVL2      SAVE ALL REGISTERS
         MVC  TUUALC(TUUALCML),TUUALCM COPY UNALLOCATE TEXT UNITS
         MVC  UALCDD(8),0(R4)     COPY THE DATASET NAME
         LA 0,50                 AMOUNT OF STORAGE REQUIRED FOR THIS
         GETMAIN R,LV=(0)            THE STORAGE NECESSARY FOR THE RE
         LR R8,R1                SAVE THE ADDRESS OF THE RETURNED STO
         USING S99RBP,R8         ESTABLISH ADDRESSABILITY FOR S99RBP
         LA R4,S99RBPTR+4        POINT FOUR BYTES BEYOND START OF S99
         USING S99RB,R4          ESTABLISH ADDRESSABILITY FOR RB DSEC
         ST R4,S99RBPTR          MAKE 'RBPTR' POINT TO RB.
         OI S99RBPTR,S99RBPND    TURN ON THE HIGH-ORDER BIT IN RBPTR.
         XC S99RB(RBLEN),S99RB   ZERO OUT 'RB' ENTIRELY.
         MVI S99RBLN,RBLEN       PUT THE LENGTH OF 'RB' IN ITS LENGTH
         MVI S99VERB,S99VRBUN    SET VERB CODE FIELD TO UNALLOCATE
         LA R5,S99RB+RBLEN       POINT PAST 'RB' TO START OF TUP LIST
         USING S99TUPL,R5        ESTABLISH ADDRESSABILITY FOR TEXT UN
         ST R5,S99TXTPP          STORE ADDRESS OF TUP LIST IN THE RB.
* SETUP RETURN DDNAME TEXT UNIT
         LA R6,TUUALC            GET ADDRESS OF FIRST TEXT UNIT
         ST R6,S99TUPTR          AND STORE IN TUP LIST.
* SETUP LAST TEXT UNIT
         OI S99TUPTR,S99TUPLN    TURN ON HIGH-ORDER BIT IN LAST TUP L
* INVOKE DYNALLOC TO PROCESS THE REQUEST
         LR R1,R8                PUT ADDRESS OF REQUEST BLOCK POINTER
         DYNALLOC
         LTR R15,R15
         BZ DYNA9000
         STC R15,RETCODE         SAVE THE RETURN CODE
         B  DYNA9000
DYNUERR  EQU *
         STC R15,RETCODE         SAVE THE RETURN CODE
         MVI MSGID,MSG020I
         BAL R4,WRITELOG
         MVI RETCODE,X'0C'       SET THE RETURN CODE 12.
DYNU9000 EQU *
         LM  R0,R15,SVLVL2      SAVE ALL REGISTERS
         DROP R4,R5,R8
         BR    R3
*---------------------------------------------------------------------*
* ROUTINE: DYNALC
* DESCRIPTION: DYNAMICALLY ALLOCATE THE DATASET
* INPUT:
*  R3      : RETURN CONTROL
*  R4      : ADDRESS OF DATASET NAME: MAXIMUM 44 BYTES
*  DSNDISP : DATASET DISPOSITION: DISPOLD×DISPMOD×DISPNEW×DISPSHR
*
*---------------------------------------------------------------------*
DYNALC   EQU  *
         STM  R0,R15,SVLVL2      SAVE ALL REGISTERS
         LR   R9,R4              KEEP A COPY OF DATASET NAME
         XR   R5,R5
         ICM  R5,1,DSDISP        COPY DSDISP
         MVC  TUALC(TUALCML),TUALCM INITIALIZE TEXT UNIT CONTENTS
         MVC  DSNAME(44),0(R4)   COPY THE DATASET NAME
         STCM R5,1,DSDISP        RESTORE DISP
*
* GET THE ACTUAL LENGTH OF DATASET BY REMOVE TRAILING SPACES.
         LA   R4,DSNAME+43       MOVE TO THE END OF DATASET BUFFER
         LA   R5,44              LOAD MAXMIMUM LENGTH OF THE BUFFER
DYNA1000 EQU  *
         CLI  0(R4),C' '         IS THIS SPACE?
         BNE  DYNA1500           NO, OUT OF LOOP
         BCTR R4,0               MOVE TO PREVIOUS CHAR
         BCT  R5,DYNA1000        TEST THE PREVIOUS CHAR
         BE   DYNAERR            BUFFER IS FULL OF SPACE!
DYNA1500 EQU  *
         LA   R5,1(0,R5)
         STH  R5,DSNAMEL         UPDATE THE DATASET LENGTH
* TEST IF THERE IS A MEMBER NAME IN DATASET NAME
DYNA2000 EQU  *
         CLI  0(R4),C')'         THE LAST BYTE IS ')' ?
         BNE  DYNA3000           NO, NORMAL DATASET
         LA   R6,0               MEMBER NAME LENGTH
         LA   R8,8               MAXIMUM LENGTH
DYNA2200 EQU  *
         BCTR R4,0               MOVE TO PREVIOUS LOCATION
         CLI  0(R4),C'('         BEGIN OF MEMBER?
         BE   DYNA2400           YES, PROCESS THE MEMBER NAME
         LA   R6,1(0,R6)         ADD MEMBER LENTH BY 1
         CR   R6,R8              EXCEED 8?
         BNH  DYNA2200           NO, CONTINUE TO TEST NEXT CHAR
         B    DYNAERR            MEMBER NAME LENGTH EXCEED 8.
DYNA2400 EQU  *
* UPDATE THE DATASET NAME WITHOUT MEMBER NAME
         SR   R5,R6
         BCTR R5,0
         BCTR R5,0
         BCTR R5,0
         STH  R5,DSNAMEL         UPDATE THE DATASET LENGTH
* COPY THE MEMBER NAME TO MEMBER TEXT UNIT
         STH  R6,ALCMEML         SAVE THE MEMBER NAME LENGTH
         LR   R5,R6
         BCTR R5,0
         LA   R7,1(0,R4)         LOAD THE MEMBER ADDRESS
         LA   R6,ALCMEM
         EX   R5,MVCREC          COPY THE MEMBER NAME
* PROCESS DYNAMIC ALLICATION PARAMETER LISTS.
* PREPARE REQUEST BLOCK
DYNA3000 EQU  *
         LA R0,80                AMOUNT OF STORAGE REQUIRED FOR THIS
         GETMAIN R,LV=(R0),LOC=BELOW   STORAGE NECESSARY FOR THE RE
         LR R8,R1                SAVE THE ADDRESS OF THE RETURNED STO
         USING S99RBP,R8         ESTABLISH ADDRESSABILITY FOR S99RBP
         LA R4,S99RBPTR+4        POINT FOUR BYTES BEYOND START OF S99
         USING S99RB,R4          ESTABLISH ADDRESSABILITY FOR RB DSEC
         ST R4,S99RBPTR          MAKE 'RBPTR' POINT TO RB.
         OI S99RBPTR,S99RBPND    TURN ON THE HIGH-ORDER BIT IN RBPTR.
         XC S99RB(RBLEN),S99RB   ZERO OUT 'RB' ENTIRELY.
         MVI S99RBLN,RBLEN       PUT THE LENGTH OF 'RB' IN ITS LENGTH
         MVI S99VERB,S99VRBAL    SET THE VERB CODE FIELD TO ALLOCATIO
         LA R5,S99RB+RBLEN       POINT PAST 'RB' TO START OF TUP LIST
         USING S99TUPL,R5        ESTABLISH ADDRESSABILITY FOR TEXT UN
         ST R5,S99TXTPP          STORE ADDRESS OF TUP LIST IN THE RB.
* SETUP DATASET NAME TEXT UNIT
         LA R6,TUALC             GET ADDRESS OF DSN    TEXT UNIT
         ST R6,S99TUPTR          AND STORE IN TUP LIST.
         LA R5,S99TUPL+4         GET ADDRESS OF NEXT TUP LIST ENTRY.
* SETUP MEMBER  NAME TEXT UNIT
         LH R6,ALCMEML           TEST IF THE MEMBER LENGTH IS 0?
         LTR R6,R6
         BZ DYNA3200             YES, SKIP THE MEMBER TEXT UNIT
         LA R6,TUAMEM             GET ADDRESS OF DSN    TEXT UNIT
         ST R6,S99TUPTR          AND STORE IN TUP LIST.
         LA R5,S99TUPL+4         GET ADDRESS OF NEXT TUP LIST ENTRY.
DYNA3200 EQU  *
* SETUP STATUS TEXT UNIT
         LA R6,TUASTS            GET ADDRESS OF STATUS TEXT UNIT
         ST R6,S99TUPTR          AND STORE IN TUP LIST.
         LA R5,S99TUPL+4         GET ADDRESS OF NEXT TUP LIST ENTRY.
* SETUP RETURN DDNAME TEXT UNIT
         LA R6,TUARTDD           GET ADDRESS OF STATUS TEXT UNIT
         ST R6,S99TUPTR          AND STORE IN TUP LIST.
* SETUP LAST TEXT UNIT
         OI S99TUPTR,S99TUPLN    TURN ON HIGH-ORDER BIT IN LAST TUP L
* INVOKE DYNALLOC TO PROCESS THE REQUEST
         LR R1,R8                PUT ADDRESS OF REQUEST BLOCK POINTER
         DYNALLOC
         LTR R15,R15             ALLOCATE SUCCESSFUL?
         BZ  DYNA9000            YES, RETURN TO THE CALLER.
         DROP R4,R5,R8
DYNAERR  EQU *                   ERROR PROCESSING
         STC R15,RETCODE         SAVE THE RETURN CODE
         MVI MSGID,MSG021I
         BAL R4,WRITELOG
DYNA9000 EQU *
         LM  R0,R15,SVLVL2      SAVE ALL REGISTERS
         BR    R3
*======================================================================
*---------------------------------------------------------------------*
* ROUTINE: WRITELOG
* DESCRIPTION: WRITE LOG TO SYSPRINT DD, OR WTO MESSAGE IF NO SYSPRINT
* INPUT:
*    R4  : RETURN CONTROL
*  MSDID : MESSAGE ID TO BE DISPLAYED
*        : 00 FOR INITIALIZE, OPEN SYSPRINT
*        : FF FOR CLEAN UP, CLOSE  SYSPRINT
* RETURN
*---------------------------------------------------------------------*
WRITELOG EQU   *
         STM  R0,R15,SVLVL3      SAVE ALL REGISTERS
         CLI  MSGID,MSGINIT      INITIALIZE THE LOG?
         BE   WTLG5000
         CLI  MSGID,MSGTERM      INITIALIZE THE LOG?
         BE   WTLG6000
         CLI  MSGID,MSGCUST      MESSAGE IS PROVIDED IN MESSAGE BUFFER?
         BE   WTLG4000
* SEARCH MESSAGE INDEX FOR GIVEN MESSAGE ID IN MSGID
         LA   R5,MSGIDX-5        LOAD THE START OF THE TABLE
WTLG1000 EQU  *
         LA   R5,5(0,R5)         MOVE TO NEXT INDEX RECORD
         CLC  0(1,R5),MSGID      COMPARE THE MESSAGE WITH GIVEN ID
         BE   WTLG2000
         CLI  0(R5),MSGIXEND     GET THE END OF THE TABLE?
         BNE  WTLG1000           NO, CHECK NEXT RECORD
         B    WTLG9000           YES, SHOW ERROR: NOT FIND MESSAGE
* PROCESS MESSAGE ID
WTLG2000 EQU  *
         XR   R7,R7              CLEAR R7
         ICM  R7,15,1(R5)        LOAD THE MESSAGE ADDRESS
         LH   R5,0(R7)           LOAD THE MESSAGE LENGTH
         LA   R7,2(0,R7)         LOAD THE MESSAGE BODY POSITION
         STC  R5,MSGBUFLN        SAVE THE MESSAGE LENGTH TO MSGBUFLN
         BCTR R5,0
         LA   R6,MSGBUFTX        COPY TO MESSAGE BUFFER
         EX   R5,MVCREC          COPY MESSAGE TO SYSPRINT MSG BUFFER
* PROCESS CUSTOMIZED MESSAGE
WTLG4000 EQU  *
* CLEAN ALL REST OF BUFFER WITH SPACES
         XR   R5,R5
         ICM  R5,1,MSGBUFLN      LOAD MESSAGE BUFFER LENGTH
         LA   R7,MSGBUFTX        LOAD THE MESSAGE ADDRESS
         AR   R7,R5              MOVE TO THE END OF MESSAGE
         MVI  0(R7),C' '         SET BYTE AFTER LAST AS SPACE
         LR   R6,R5
         LA   R5,131             MAXIMUM RECORD LENGTH
         SR   R5,R6              GET THE RECORD REST LENGTH
         BCTR R5,0
         BCTR R5,0
         LR   R6,R7              COPY THE END POSITION
         LA   R6,1(0,R6)         MOVE TO NEXT BYTE
         EX   R5,MVCREC          CLEAN REST BUFFER WITH SPACES.
* TEST IF SYSPRINT PROVIDED
         CLI  FLSYSPRT,YES       IS SYSPRINT PROVIDED?
         BNE  WTLG4500           NO, USE WTO MESSAGE
* SYSPRINT PROVIDED
         CP   MSGCTR,P0          PAGE BREAKER?
         BE   WTLG4100
         CP   MSGCTR,P50         PAGE BREAKER?
         BNE  WTLG4200
         ZAP  MSGCTR,P0          RESET THE COUNTER
* LINE BREAKER
WTLG4100 MVI  MSGBUFCC,C'1'      SET CC BYTE TO SPACE
         B    WTLG4300
* NORMAL LINES
WTLG4200 EQU  *
         MVI  MSGBUFCC,C' '
WTLG4300 EQU  *
         AP   MSGCTR,P1
         PUT  SPRDCB,MSGBUFCC    WRITE THE MESSAGE TO SYSPRINT
         B    WTLG9000
WTLG4500 EQU  *
         XR   R5,R5
         ICM  R5,1,MSGBUFLN      LOAD MESSAGE BUFFER LENGTH
         STH  R5,MSGBUF          STORE THE MESSAGE LENGTH
         LA   R6,MSGBUF
         WTO  TEXT=(R6),MF=(E,WTOLIST)
         B    WTLG9000
* INITIALIZE
WTLG5000 EQU  *
         MVI  FLSYSPRT,NO
         OPEN (SPRDCB,(OUTPUT)),MODE=31,MF=(E,SPROPLST)
         LTR  R15,R15
         BNZ  WTLG5500
         MVI  FLSYSPRT,YES
         ZAP  MSGCTR,P0          RESET THE MESSAGE COUNTER
WTLG5500 B    WTLG9000
* CLEAN
WTLG6000 EQU  *
         CLI  FLSYSPRT,YES
         BNE  WTLG9000
         CLOSE SPRDCB,MODE=31,MF=(E,SPROPLST)
WTLG9000 EQU  *
         LM  R0,R15,SVLVL3      SAVE ALL REGISTERS
         BR    R4
*---------------------------------------------------------------------*
* ROUTINE: SHOWHELP
* DESCRIPTION: SHOW HELP MESSAGES
* INPUT:
*    R3  : RETURN CONTROL
* RETURN
*---------------------------------------------------------------------*
SHOWHELP EQU   *
         LA    R5,200         THE FIRST HELP MESSAGE ID
         LA    R6,MSGHLPE     THE LAST HELP MESSAGE ID
         SR    R6,R5          TOTAL MESSAGES
         LA    R6,1(0,R6)     ADD 1 FOR TOTAL NUMBER OF MESSAGES
SHLP1000 EQU   *
         STC   R5,MSGID       SET CURRENT MESSAGE ID
         BAL   R4,WRITELOG    CALL WRITELOG TO SHOW CURRENT MESSAGE ID
         LA    R5,1(0,R5)     MOVE TO NEXT MESSAGE ID
         BCT   R6,SHLP1000
         BR    R3
*---------------------------------------------------------------------*
*  DATA  AREAS                                                        *
*---------------------------------------------------------------------*
*  LIST FORMS OF MVS MACROS                                           *
*---------------------------------------------------------------------*
MODESUP  MODESET MODE=SUP,KEY=ZERO,MF=L    ;SUPERVISOR STATE
MODEPROB MODESET MODE=PROB,KEY=NZERO,MF=L  ;PROBLEM STATE (NORMAL)
MGCAREA  MGCRE   MF=L                      ;MGCRE
*---------------------------------------------------------------------*
*  MVC INSTRUCTIONS FOR DATA STORAGE                                  *
*---------------------------------------------------------------------*
MVCREC   MVC   0(0,R6),0(R7)      ;COPY RECORD FROM R7 to R6,length R5
WTOMDL   WTO   TEXT=,MF=L
WTOMDLL  EQU   *-WTOMDL           ;LENGTH OF WTO MODEL
*---------------------------------------------------------------------*
* SET CLOCK COMMAND MODEL
SETCLKC  DS    0F
         DC    AL2(SETCLKCL)
SETCLKT  DC    C'SET DATE=YYYY.DDD,CLOCK=HH:MM:SS'
SETCLKL  EQU   *-SETCLKC          ; PATTERN LENGTH
SETCLKCL EQU   *-SETCLKT          ; SET CLOCK COMMAND LENGTH
* CONSTANT PACKET NUMBERS
P590     DC    PL2'590'      MINUTE AND SECOND IN 59
P240     DC    PL2'240'      HOURS IN 24
P50      DC    PL2'50'       PAGE BREAKER LINES
P10      DC    PL2'10'       1 IN HOUR/MINUTE/SECOND/SECOND/100 PACKED
P1       DC    PL1'1'
P0       DC    PL1'0'
* FLAG OPTIONS: YES OR NO
YES      EQU   X'01'
NO       EQU   X'00'
* DATE FORMAT IN SET CLOCK COMMAND
DATEMDL  DC    XL10'F021202020204B202020'     0YYYY.DDD
* TIME FORMAT IN SET CLOCK COMMAND
TIMEMDL  DC    XL9'F021204B20204B2020'        HH.MM.SS
DATEMDLL EQU   *-DATEMDL
*
* HOUR FORMAT IN CLOCKXX STATEMENT
TZHRMDL  DC    XL4'F0212020'
TZHRMDLL EQU   *-TZHRMDL
* CLOCKxx TIME ZONE STATEMENT MODEL
TZMDL    DS    0D                                               GP04095
         DC    AL2(TZMDLTL)                   LENGTH OF THE STATEMENT
TZMDLT   DC    C'TIMEZONE W.00.00.00'         STATEMENT
TZMDLTL  EQU   *-TZMDLT                       STATEMENT LENGTH
TZMDLL   EQU   *-TZMDL                        TIMEZONE MODEL LENGTH
*
CLKMBNM  DC    CL8'CLOCK00 '
*
* DYNAMIC ALLOCATION STORAGE
* REQUEST BLOCK LENGTH
RBLEN    EQU (S99RBEND-S99RB)
* DATASET DISPOSITIONS
DISPOLD  EQU X'01'
DISPMOD  EQU X'02'
DISPNEW  EQU X'04'
DISPSHR  EQU X'08'
* TEXT UNIT FOR DATASET NAME ALLOCATION: RETURN DD NAME
* ALLOCATE UNIT TEXT MODEL
TUALCM   DS 0D
         DC AL2(DALDSNAM)        TEXT UNIT OF DATASET NAME
         DC XL2'0001'            # MUST BE 1
         DC XL2'002C'            DATASET NAME LENGTH (44)
         DC CL44' '              DATASET NAME
         DC AL2(DALRTDDN)                     RETURN DD NAME
         DC XL2'0001'
         DC XL2'0008'
         DC CL8'        '                     DD NAME
         DC AL2(DALMEMBR)        OPTIONAL MEMBER NAME FOR PDS
         DC XL2'0001'
         DC XL2'0000'            DEFAULT MEMBER LENGTH IS 0: NO MEMBER
         DC CL8'        '                     DD NAME
         DC AL2(DALSTATS)        TEXT UNIT OF DATSET STATUS
         DC XL2'0001'            #   MUST BE 1
         DC XL2'0001'            LEN MUST BE 1
         DC XL1'08'              PARM: 01-OLD, 02-MOD, 04-NEW, 08-SHARE
TUALCML  EQU  *-TUALCM           THE LENGTH OF TEXT UNIT MODEL
         SPACE
* UNALLOCATE UNIT TEXT MODEL; BY DD NAME
TUUALCM  DS 0D
TUUALCDD DC AL2(DUNDDNAM)        UNALLOCATE BY DD NAME
         DC XL2'0001'            #MUST BE 1
         DC XL2'0008'            LENGTH OF THE DDNAME
         DC CL8'        '        DD NAME
TUUALCML EQU *-TUUALCM
*---------------------------------------------------------------------*
* CONSTANT DCB/DCBE/OPENLIST
*---------------------------------------------------------------------*
* PARMLIB CONSTANT DCB/DCBE/OPENLIST
*---------------------------------------------------------------------*
CPRMLIB  DCB   DSORG=PO,                                               X
               MACRF=R,                                                X
               DDNAME=&INTDDNM,                                        X
               EODAD=PRMDDEOF,                                         X
               SYNAD=PRMDDEOF
CPRMLIBL EQU   *-CPRMLIB               LENGTH OF SYSPRINT DCE
* PARMLIB  OPEN LIST FORM
CPRMOPL  OPEN  CPRMLIB,MF=L
CPRMOPLL EQU   *-CPRMOPL               LENGTH OF THE OPENLIST
*---------------------------------------------------------------------*
* CCLRDCB  CONSTANT DCB/DCBE/OPENLIST
* CCLRDCB: CONSTANT DCB FOR CLOCKxx DATASET WITH READ ONLY
*---------------------------------------------------------------------*
CCLRDCB  DCB   DSORG=PS,                                               X
               MACRF=GM,                                               X
               DDNAME=&INTDDNM,                                        X
               RECFM=FB,                                               X
               LRECL=80,                                               X
               DCBE=CCLRDCBE
CCLRDCBL EQU   *-CCLRDCB               LENGTH OF THE OPENLIST
CCLRDCBE DCBE  RMODE31=BUFF,EODAD=CLKDDEOF,SYNAD=CLKDDERR
CCLROPL  OPEN  (CCLRDCB,(INPUT)),MODE=31,MF=L
CCLROPLL EQU   *-CCLROPL               LENGTH OF THE OPENLIST
* CCLWDCB: CONSTANT DCB FOR CLOCKxx DATASET WITH WRITE
CCLWDCB  DCB   DSORG=PS,                                               X
               MACRF=PM,                                               X
               DDNAME=&INTDDNM,                                        X
               RECFM=FB,                                               X
               LRECL=80,                                               X
               DCBE=CCLWDCBE
CCLWDCBL EQU   *-CCLWDCB               LENGTH OF THE OPENLIST
CCLWDCBE DCBE  RMODE31=BUFF
CCLWOPL  OPEN  (CCLWDCB,(OUTPUT)),MODE=31,MF=L
CCLWOPLL EQU   *-CCLWOPL               LENGTH OF THE OPENLIST
* CSPRDCB: CONSTANT DCB FOR SYSPRINT WITH WRITE
CSPRDCB  DCB   DSORG=PS,                                               X
               MACRF=PM,                                               X
               DDNAME=SYSPRINT,                                        X
               RECFM=FBA,                                              X
               LRECL=132,                                              X
               DCBE=CSPRDCBE
CSPRDCBL EQU   *-CSPRDCB               LENGTH OF THE OPENLIST
CSPRDCBE DCBE  RMODE31=BUFF
CSPROPL  OPEN  (CSPRDCB,(OUTPUT)),MODE=31,MF=L
CSPROPLL EQU   *-CSPROPL               LENGTH OF THE OPENLIST
* CONSTANT FOR EXEC PARM OPTIONS
SYSTMPDD DC    CL8'&INTDDNM'           INITIAL DD NAME
OPTFALL  DC    CL4'FALL'               PARM OPTION: FALL
OPTAUTO  DC    CL4'AUTO'               PARM OPTION: AUTO
OPTP1    DC    CL2'+1'                 PARM OPTION: -1
OPTM1    DC    CL2'-1'                 PARM OPTION: +1
OPTAUTM  DC    CL6'AUTUMN'             PARM OPTION: AUTUMN
OPTWNTR  DC    CL6'WINTER'             PARM OPTION: WINTER
OPTSPRG  DC    CL6'SPRING'             PARM OPTION: SPRING
OPTSUMR  DC    CL6'SUMMER'             PARM OPTION: SUMMER
OPTHELP  DC    CL4'HELP'               PARM OPTION: HELP
*************************************************************
* MESSAGE INDEX TABLE
MSGIDX   DS    0C
*              MSGID    MESSAGE TEXT LOCATION
*              ======== =======================
         DC    AL1(MSG001I),AL4(MSG001)        01
         DC    AL1(MSG002I),AL4(MSG002)        02
         DC    AL1(MSG003I),AL4(MSG003)        03
         DC    AL1(MSG004I),AL4(MSG004)        04
         DC    AL1(MSG005I),AL4(MSG005)        05
         DC    AL1(MSG006I),AL4(MSG006)        06
         DC    AL1(MSG007I),AL4(MSG007)        07
         DC    AL1(MSG008I),AL4(MSG008)        08
         DC    AL1(MSG009I),AL4(MSG009)        09
         DC    AL1(MSG010I),AL4(MSG010)        0A
         DC    AL1(MSG011I),AL4(MSG011)        0B
         DC    AL1(MSG012I),AL4(MSG012)        0C
         DC    AL1(MSG013I),AL4(MSG013)        0D
         DC    AL1(MSG014I),AL4(MSG014)        0E
         DC    AL1(MSG015I),AL4(MSG015)        0F
         DC    AL1(MSG016I),AL4(MSG016)        10
         DC    AL1(MSG017I),AL4(MSG017)        11
         DC    AL1(MSG018I),AL4(MSG018)        12
         DC    AL1(MSG019I),AL4(MSG019)        13
         DC    AL1(MSG020I),AL4(MSG020)        14
         DC    AL1(MSG021I),AL4(MSG021)        15
         DC    AL1(MSG022I),AL4(MSG022)        16
         DC    AL1(MSG023I),AL4(MSG023)        17
         DC    AL1(MSG024I),AL4(MSG024)        18
         DC    AL1(MSG025I),AL4(MSG025)        19
         DC    AL1(MSG026I),AL4(MSG026)        1A
         DC    AL1(MSG027I),AL4(MSG027)        1B
         DC    AL1(MSG028I),AL4(MSG028)        1C
         DC    AL1(MSG029I),AL4(MSG029)        1D
         DC    AL1(MSG030I),AL4(MSG030)        1E
         DC    AL1(MSG031I),AL4(MSG031)        1F
         DC    AL1(MSG032I),AL4(MSG032)        20
         DC    AL1(MSG033I),AL4(MSG033)        20
         DC    AL1(MSG200I),AL4(MSG200)
         DC    AL1(MSG201I),AL4(MSG201)
         DC    AL1(MSG202I),AL4(MSG202)
         DC    AL1(MSG203I),AL4(MSG203)
         DC    AL1(MSG204I),AL4(MSG204)
         DC    AL1(MSG205I),AL4(MSG205)
         DC    AL1(MSG206I),AL4(MSG206)
         DC    AL1(MSG207I),AL4(MSG207)
         DC    AL1(MSG208I),AL4(MSG208)
         DC    AL1(MSG209I),AL4(MSG209)
         DC    AL1(MSG210I),AL4(MSG210)
         DC    AL1(MSG211I),AL4(MSG211)
         DC    AL1(MSG212I),AL4(MSG212)
         DC    AL1(MSG213I),AL4(MSG213)
         DC    AL1(MSG214I),AL4(MSG214)
         DC    AL1(MSG215I),AL4(MSG215)
         DC    AL1(MSG216I),AL4(MSG216)
         DC    AL1(MSG217I),AL4(MSG217)
         DC    AL1(MSG218I),AL4(MSG218)
         DC    AL1(MSG219I),AL4(MSG219)
         DC    AL1(MSG220I),AL4(MSG220)
         DC    AL1(MSG221I),AL4(MSG221)
         DC    AL1(MSG222I),AL4(MSG222)
         DC    AL1(MSG223I),AL4(MSG223)
         DC    AL1(MSG224I),AL4(MSG224)
         DC    AL1(MSG225I),AL4(MSG225)
         DC    AL1(MSG226I),AL4(MSG226)
         DC    AL1(MSG227I),AL4(MSG227)
         DC    AL1(MSG228I),AL4(MSG228)
         DC    AL1(MSG229I),AL4(MSG229)
         DC    AL1(MSG230I),AL4(MSG230)
         DC    XL5'0000000000'                LAST INDEX RECORD
MSGIDXL  EQU   *-MSGIDX
* END OF MESSAGE INDEX TABLE
***********************************************************
* MESSAGE BODY TABLE
MSG001   DC  AL2(MSG001L)
MSG001T  DC  C'STZ001I Welcome to SETHOUR program.'
MSG001I  EQU X'01'
MSG001L  EQU *-MSG001T
*
MSG002   DC  AL2(MSG002L)
MSG002T  DC  C'STZ002I Design: Hunter Zhou, guanghui.zhou@sobeys.com.'
MSG002I  EQU X'02'
MSG002L  EQU *-MSG002T
*
MSG003   DC  AL2(MSG003L)
MSG003T  DC  C'STZ003I Purpose: Set System TOD Clock, '
         DC  C'and update the PARMLIB CLOCKxx member.'
MSG003I  EQU X'03'
MSG003L  EQU *-MSG003T
*
MSG004   DC  AL2(MSG004L)
MSG004T  DC  C'STZ004E Program failed to locate DDNAME in DCB.'
MSG004I  EQU X'04'
MSG004L  EQU *-MSG004T
*
MSG005   DC  AL2(MSG005L)
MSG005T  DC  C'STZ020I The new time zone for updated clock will be:'
MSG005I  EQU X'05'
MSG005L  EQU *-MSG005T
*
MSG006   DC  AL2(MSG006L)
MSG006T  DC  C'STZ021I The active CLOCKxx member in your system is:'
MSG006I  EQU X'06'
MSG006L  EQU *-MSG006T
*
MSG007   DC  AL2(MSG007L)
MSG007T  DC  C'STZ030I Test if the CLOCKxx is required to be updated.'
MSG007I  EQU X'07'
MSG007L  EQU *-MSG007T
*
MSG008   DC  AL2(MSG008L)
MSG008T  DC  C'STZ031I The old statements in active clock member:'
MSG008I  EQU X'08'
MSG008L  EQU *-MSG008T
*
MSG009   DC  AL2(MSG009L)
MSG009T  DC  C'STZ032I The new statements in active clock member:'
MSG009I  EQU X'09'
MSG009L  EQU *-MSG009T
*
MSG010   DC  AL2(MSG010L)
MSG010T  DC  C'STZ033E ERROR: There are more than 50 records '
         DC  C'in current CLOCKxx member!'
MSG010I  EQU X'0A'
MSG010L  EQU   *-MSG010T
*
MSG011   DC  AL2(MSG011L)
MSG011T  DC  C'STZ034E There is a error while reading TIMEZONE '
         DC  C'statement in active clock member:'
MSG011I  EQU X'0B'
MSG011L  EQU   *-MSG011T
*
MSG012   DC  AL2(MSG012L)
MSG012T  DC  C'STZ035E ERROR: Failed to read current CLOCKxx member.'
MSG012I  EQU X'0C'
MSG012L  EQU   *-MSG012T
*
MSG013   DC  AL2(MSG013L)
MSG013T  DC  C'STZ036E ERROR: Failed to open current CLOCKxx member '
         DC  C'with read.'
MSG013I  EQU X'0D'
MSG013L  EQU   *-MSG013T
*
MSG014   DC  AL2(MSG014L)
MSG014T  DC  C'STZ037E ERROR: Failed to dynamically allocate current '
         DC  C'CLOCKxx member.'
MSG014I  EQU X'0E'
MSG014L  EQU   *-MSG014T
*
MSG015   DC  AL2(MSG015L)
MSG015T  DC  C'STZ040I It is not required to update CLOCKxx member.'
MSG015I  EQU X'0F'
MSG015L  EQU   *-MSG015T
*
MSG016   DC  AL2(MSG016L)
MSG016T  DC  C'STZ041I This active clock member is required to be '
         DC  C'updated.'
MSG016I  EQU X'10'
MSG016L  EQU   *-MSG016T
*
MSG017   DC  AL2(MSG017L)
MSG017T  DC  C'STZ042I The current active clock member is updated.'
MSG017I  EQU X'11'
MSG017L  EQU   *-MSG017T
*
MSG018   DC  AL2(MSG018L)
MSG018T  DC  C'STZ043E ERROR: Failed to open current CLOCKxx member '
         DC  C'with write.'
MSG018I  EQU X'12'
MSG018L  EQU   *-MSG018T
*
MSG019   DC  AL2(MSG019L)
MSG019T  DC  C'STZ044E ERROR: Failed to dynamically allocate current '
         DC  C'CLOCKxx member with write.'
MSG019I  EQU X'13'
MSG019L  EQU   *-MSG019T
*
MSG020   DC  AL2(MSG020L)
MSG020T  DC  C'STZ050E ERROR: There is an error while dynamically '
         DC  C'deallocating following dataset:'
MSG020I  EQU X'14'
MSG020L  EQU   *-MSG020T
*
MSG021   DC  AL2(MSG021L)
MSG021T  DC  C'STZ060E ERROR: There is an error while dynamically '
         DC  C'allocating following dataset:'
MSG021I  EQU X'15'
MSG021L  EQU   *-MSG021T
*
MSG022   DC  AL2(MSG022L)
MSG022T  DC  C'STZ011W WARN: There is no EXEC PARM given.'
MSG022I  EQU X'16'
MSG022L  EQU   *-MSG022T
*
MSG023   DC  AL2(MSG022L)
MSG023T  DC  C'STZ012E ERROR: The EXEC PARM is invalid!'
MSG023I  EQU X'17'
MSG023L  EQU   *-MSG022T
*
MSG024   DC  AL2(MSG024L)
MSG024T  DC  C'STZ100I The SETHOUR program is finished normally.'
MSG024I  EQU X'18'
MSG024L  EQU   *-MSG024T
*
MSG025   DC  AL2(MSG025L)
MSG025T  DC  C'STZ101W The SETHOUR program is finished normally with '
         DC  C'warning messages.'
MSG025I  EQU X'19'
MSG025L  EQU   *-MSG025T
*
MSG026   DC  AL2(MSG026L)
MSG026T  DC  C'STZ102E The SETHOUR program is finished abnormally.'
MSG026I  EQU X'1A'
MSG026L  EQU   *-MSG026T
*
MSG027   DC  AL2(MSG027L)
MSG027T  DC  C'STZ010I The given EXEC PARM is:'
MSG027I  EQU X'1B'
MSG027L  EQU   *-MSG027T
*
MSG028   DC  AL2(MSG028L)
MSG028T  DC  C'STZ023I Following MVS system command has been issued:'
MSG028I  EQU X'1C'
MSG028L  EQU   *-MSG028T
*
MSG029   DC  AL2(MSG029L)
MSG029T  DC  C'STZ014I Program will set system clock one hour ahead.'
MSG029I  EQU X'1D'
MSG029L  EQU   *-MSG029T
*
MSG030   DC  AL2(MSG030L)
MSG030T  DC  C'STZ015I Program will set system clock one hour back.'
MSG030I  EQU X'1E'
MSG030L  EQU   *-MSG030T
*
MSG031   DC  AL2(MSG031L)
MSG031T  DC  C'STZ016I This program is built for Northern Hemisphere.'
MSG031I  EQU X'1F'
MSG031L  EQU   *-MSG031T
*
MSG032   DC  AL2(MSG032L)
MSG032T  DC  C'STZ017I This program is built for Southern Hemisphere.'
MSG032I  EQU X'20'
MSG032L  EQU   *-MSG032T
*
MSG033   DC  AL2(MSG033L)
MSG033T  DC  C'STZ018E Cannot find the active CLOCKxx member.'
MSG033I  EQU X'21'
MSG033L  EQU   *-MSG033T
* HELP MESSAGES
MSG200   DC  AL2(MSG200L)
MSG200T  DC  C'Help Message for SETHOUR program.'
MSG200I  EQU X'C8'
MSG200L  EQU   *-MSG200T
*
MSG201   DC  AL2(MSG201L)
MSG201T  DC  C'The SETHOUR will update the current TOD clock by one '
         DC  C'hour, and update CLOCKxx member in current system.'
MSG201I  EQU X'C9'
MSG201L  EQU   *-MSG201T
*
MSG202   DC  AL2(MSG202L)
MSG202T  DC  C'This program can be used for time saving change in '
         DC  C'both April and October each year.'
MSG202I  EQU X'CA'
MSG202L  EQU   *-MSG202T
*
MSG203   DC  AL2(MSG203L)
MSG203T  DC  C'Parameters'
MSG203I  EQU X'CB'
MSG203L  EQU   *-MSG203T
*
MSG204   DC  AL2(MSG204L)
MSG204T  DC  C'The parameter is given in EXEC PARM. '
         DC  C'Here are the valid options: '
MSG204I  EQU X'CC'
MSG204L  EQU   *-MSG204T
*
MSG205   DC  AL2(MSG205L)
MSG205T  DC  C'1. +1'
MSG205I  EQU X'CD'
MSG205L  EQU   *-MSG205T
*
MSG206   DC  AL2(MSG206L)
MSG206T  DC  C'   Set clock one hour ahead, '
         DC  C'no matter where the system is.'
MSG206I  EQU X'CE'
MSG206L  EQU   *-MSG206T
*
MSG207   DC  AL2(MSG207L)
MSG207T  DC  C' '
MSG207I  EQU X'CF'
MSG207L  EQU   *-MSG207T
*
MSG208   DC  AL2(MSG208L)
MSG208T  DC  C'2. -1'
MSG208I  EQU X'D0'
MSG208L  EQU   *-MSG208T
*
MSG209   DC  AL2(MSG209L)
MSG209T  DC  C'   Set clock one hour back, '
         DC  C'no matter where the system is.'
MSG209I  EQU X'D1'
MSG209L  EQU   *-MSG209T
*
MSG210   DC  AL2(MSG210L)
MSG210T  DC  C' '
MSG210I  EQU X'D2'
MSG210L  EQU   *-MSG210T
*
MSG211   DC  AL2(MSG211L)
MSG211T  DC  C'3. SPRING×SUMMER'
MSG211I  EQU X'D3'
MSG211L  EQU   *-MSG211T
*
MSG212   DC  AL2(MSG212L)
MSG212T  DC  C'   Tell program to set clock in Spring. '
         DC  C'It can be used in April.'
MSG212I  EQU X'D4'
MSG212L  EQU   *-MSG212T
*
MSG213   DC  AL2(MSG213L)
MSG213T  DC  C'   For Northern Hemisphere, '
         DC  C'it will set clock one hour ahead.'
MSG213I  EQU X'D5'
MSG213L  EQU   *-MSG213T
*
MSG214   DC  AL2(MSG214L)
MSG214T  DC  C'   For Southern Hemisphere, '
         DC  C'it will set clock one hour back.'
MSG214I  EQU X'D6'
MSG214L  EQU   *-MSG214T
*
MSG215   DC  AL2(MSG215L)
MSG215T  DC  C' '
MSG215I  EQU X'D7'
MSG215L  EQU   *-MSG215T
*
MSG216   DC  AL2(MSG216L)
MSG216T  DC  C'4. FALL×AUTUMN×WINTER'
MSG216I  EQU X'D8'
MSG216L  EQU   *-MSG216T
*
MSG217   DC  AL2(MSG217L)
MSG217T  DC  C'   Tell program to set clock in Fall. '
         DC  C'It can be used in October.'
MSG217I  EQU X'D9'
MSG217L  EQU   *-MSG217T
*
MSG218   DC  AL2(MSG218L)
MSG218T  DC  C'   For Northern Hemisphere, '
         DC  C'it will set clock one hour back.'
MSG218I  EQU X'DA'
MSG218L  EQU   *-MSG218T
*
MSG219   DC  AL2(MSG219L)
MSG219T  DC  C'   For Southern Hemisphere, '
         DC  C'it will set clock one hour ahead.'
MSG219I  EQU X'DB'
MSG219L  EQU   *-MSG219T
*
MSG220   DC  AL2(MSG220L)
MSG220T  DC  C' '
MSG220I  EQU X'DC'
MSG220L  EQU   *-MSG220T
*
MSG221   DC  AL2(MSG221L)
MSG221T  DC  C'5. AUTO'
MSG221I  EQU X'DD'
MSG221L  EQU   *-MSG221T
*
MSG222   DC  AL2(MSG222L)
MSG222T  DC  C'   Set clock one hour ahead or back automatically '
         DC  C'according to current month.'
MSG222I  EQU X'DE'
MSG222L  EQU   *-MSG222T
*
MSG223   DC  AL2(MSG223L)
MSG223T  DC  C'   If current month is between Janurary and June, '
         DC  C'it will set clock as Spring, otherwise as Fall.'
MSG223I  EQU X'DF'
MSG223L  EQU   *-MSG223T
*
MSG224   DC  AL2(MSG224L)
MSG224T  DC  C'   Example: Run this step for both April and '
         DC  C'October'
MSG224I  EQU X'E0'
MSG224L  EQU   *-MSG224T
*
MSG225   DC  AL2(MSG225L)
MSG225T  DC  C'   //SETCLK  EXEC PGM=SETHOUR,PARM=AUTO'
MSG225I  EQU X'E1'
MSG225L  EQU   *-MSG225T
*
MSG226   DC  AL2(MSG226L)
MSG226T  DC  C'   //SYSPRINT DD SYSOUT=*'
MSG226I  EQU X'E2'
MSG226L  EQU   *-MSG226T
*
MSG227   DC  AL2(MSG227L)
MSG227T  DC  C' '
MSG227I  EQU X'E3'
MSG227L  EQU   *-MSG227T
*
MSG228   DC  AL2(MSG228L)
MSG228T  DC  C'6. HELP'
MSG228I  EQU X'E4'
MSG228L  EQU   *-MSG228T
*
MSG229   DC  AL2(MSG229L)
MSG229T  DC  C'   Show this help message.'
MSG229I  EQU X'E5'
MSG229L  EQU   *-MSG229T
*
MSG230   DC  AL2(MSG230L)
MSG230T  DC  C' '
MSG230I  EQU X'E6'
MSG230L  EQU   *-MSG223T
MSGHLPE  EQU X'E6'    THE LAST HELP MESSAGE ID
*
*---------------------------------------------------------------------*
*  DSECT DATA, ALLOCATED DYNAMICALLY, USING R13.                      *
*---------------------------------------------------------------------*
DSA      DSECT
SAVEAREA DS    18F                ;REGISTER SAVE AREA
SVLVL1   DS    16F                ;REGISTER SAVE AREA ROUTINE LEVEL 1
SVLVL2   DS    16F                ;REGISTER SAVE AREA ROUTINE LEVEL 2
SVLVL3   DS    16F                ;REGISTER SAVE AREA ROUTINE LEVEL 3
DRECAREA DS    F                  ;DTABLE STORAGE ADDRESS
RETCODE  DS    XL1                ;RETURN CODE
* TIME MACRO LIST FORM
TIMELST  TIME  LINKAGE=SYSTEM,MF=L   TIME LIST FORM
* EXEC PARM INFORMATION
PARMLEN  DS    AL2                ;THE LENGTH OF THE PARM
PARM     DS    CL126              ;PARAMETER FROM
*---------------------------------------------------------------------*
* SET CLOCK PARM
SETCPLUS DS    X                   01 FOR +1, 00 FOR -1
* SET CLOCK COMMAND BUFFER
* SETCLKC  DC    'SET DATE=YYYY.DDD,CLOCK=HH:MM:SS'
SETCLK   DS    0F
         DS    AL2(SETCLKL)
SETCLKCM DS    CL9                 SET DATE=
SETCLKDT DS    CL8                 YYYY.DDD
         DS    CL7                 ,CLOCK=
SETCLKTM DS    CL8                 HH:MM:SS
* LOCAL TIME & DATE
DATELCL  DS    CL16   TIME MACRO: HHMMSSthmiju0000 0YYYYDDD00000000
* GMT   TIME & DATE
DATEGMT  DS    CL16   TIME MACRO: HHMMSSthmiju0000 0YYYYDDD00000000
* DATE AND TIME IN TEXT FORMAT
DATEBUF  DS    0D
DATEFMT  DS    XL10               0YYYY.DDD
TIMEFMT  DS    XL9                HH.MM.SS
HOURBUF  DS    XL2                PACKED DECIMAL BUFFER FOR HOUR HH
MINBUF   DS    XL2                PACKED DECIMAL BUFFER FOR MINUTE
SECBUF   DS    XL2                PACKED DECIMAL BUFFER FOR SECOND
STHBUF   DS    XL2                PACKED DECIMAL BUFFER FOR SECOND/100
DAYBUF   DS    XL3                PACKED DECIMAL BUFFER FOR DAY DDD
*---------------------------------------------------------------------*
* GET TIME ZONE BUFFERS
* LOCAL TIME & DATE AREA
GMTYTD   DS    XL5                PACKED BUFFER FOR 0YYYYDDD0C
LCLYTD   DS    XL5                PACKED BUFFER FOR 0YYYYDDD0C
GMTHOUR  DS    XL2                PACKED BUFFER FOR GMT HOUR HH0C
LCLHOUR  DS    XL2                PACKED BUFFER FOR LCL HOUR HH0C
TZDELTA  DS    XL2                PACKED TIME ZONE HOUR DELTA HH0C
TZHRDEC  DS    CL4                DECIMAL FORMAT EDITED BY TZHRMDL
* CLOCKxx TIME ZONE STATEMENT MODEL
TZSTMT   DS    0D
         DS    AL2                LENGTH OF TIMEZONE STATEMENT
TZKEYW   DS    CL9                TIMEZONE
TZWORD   DS    CL1                W OR E
         DS    CL1                .
TZHOUR   DS    CL2                00
         DS    CL6                .00.00
* END OF TIME ZONE STATEMENT
*---------------------------------------------------------------------*
* CLOCKxx member name
CLKPMDSN DS    CL44               CONBINED DATASET AND MEMBER NAME
* CLOCK MEMBER
CLKPMMBR DS    0CL8               CLOCK MEMBER NAME OF CLOCKXX
CLKPMPFX DS    CL5                CLOCK
CLKPMSFX DS    CL2                XX
         DS    C                  SPACE
FLGFNDMB DS    XL1                FLAG TO TELL IF FIND THE MEMBER
FLGUCLKM DS    XL1                FLAG TO TELL IF NEED TO UPDATE CLOCK?
*---------------------------------------------------------------------*
*TIOT AREA FOR JOB INFORMATION
TIOTA    DS    F                  TIOT ADDRESS
*MCSOPER REQUIRED DATA STOREAGE
         DS    0F
OPERDATA DS    CL(MCSOPLEN)
HCCONSNM DS    CL8
HCCONSID DS    CL4
HCSTATUS DS    A
HCSTATAL DS    F
HCMECB   DS    F
HCRETC   DS    F
HCRSNC   DS    F
*---------------------------------------------------------------------*
* DYNAMIC ALLOCATION STORAGE
* INPUT TO SUBROUTINE DYALC: DSNAME, DSDISP
* TEXT UNIT DEFINITIONS
TUALC    DS 0D
*TEXT UNIT DATASET NAME DSNTU
TUADSN   DS XL2
         DS XL2
DSNAMEL  DS XL2
DSNAME   DS CL44
*TEXT UNIT RETURNED DD NAME RETDDN
TUARTDD  DS XL2
         DS XL2
ALCDDL   DS XL2
ALCDD    DS CL8                   DD NAME FILLED BY DYNALLOC
*TEXT UNIT PDS MEMBER NANE
TUAMEM   DS XL2
         DS XL2
ALCMEML  DS XL2
ALCMEM   DS CL8
*TEXT UNIT STATUS STATUSTU
TUASTS   DS XL2
         DS XL2
         DS XL2
DSDISP   DS XL1
*---------------------------------------------------------------------*
* DYNAMIC DEALLOCATION STORAGE
TUUALC   DS 0D
*TEXT UNIT RETURNED DD NAME
TUUALDD  DS XL2
         DS XL2
UALCDDL  DS XL2
UALCDD   DS CL8
* END OF TIME ZONE STATEMENT
*---------------------------------------------------------------------*
*---------------------------------------------------------------------*
* PDS MEMBER PROCESSING BUFFERS
BLDLBUF  DS 0F
BLDMBNB  DS XL2
BLDMBLN  DS AL2
BLDMBNM  DS CL8
BLDTTR   DS XL3
BLDK     DS XL1
BLDZ     DS XL1
BLDC     DS XL1
         DS CL32
* END OF PDS MEMBER PROCESSING BUFFERS
*---------------------------------------------------------------------*
         MCSOPER MF=(L,MCSOPPL)
EXTRMFL  EXTRACT MF=L                      ;EXTRACT JOB NAME INFO
WTOLIST  WTO   TEXT=,MF=L
* MESSSAGE ID TO PASS TO WRITELOG ROUTINE
MSGID    DS    XL1
FLSYSPRT DS    XL1                FLAG IF SYSPRINT PROVIDED
FLGTERM  DS    XL1                FLAG IF NEED TO TERMINATE THE PRORAM.
* MESSAGE BUFFER
* IF FOR WTO, THE FIRST 2 BYTES WILL SET TO MESSAGE LENGTH
* IF FOR SYSPRINT, THE FIRST BYTE IS LENGTH, SECOND BYTE IS C' '
MSGBUF   DS    0H
MSGBUFLN DS    XL1
MSGBUFCC DS    XL1
MSGBUFTX DS    CL131              ;SYSPRINT MESSAGE BUFFER
MSGCTR   DS    PL2                ;MESSAGE COUNTER
* FLAGS FOR MESSAGE
MSGINIT  EQU   X'00'              INITIALIZE MESSAGE SYSPRINT
MSGTERM  EQU   X'FF'              TERMINATE MESSAGE SYSPRINT
MSGCUST  EQU   X'FE'          MESSAGE IS PROVIDED IN MSGBUF, NOT MSGID
MSGIXEND EQU   X'00'                   END OF MESSAGE INDEX TABLE TAG
*---------------------------------------------------------------------*
* THE DCB MUST BE ALLOCATED BELOW 16MB LINE,
* SO THE GETMAIN FOR THIS DSECT MUST CODE LOC=BELOW
* THE DCBE WILL POINT TO THE CONSTANT DCBE AS IT WILL NOT BE CHANGED.
* SYSPRINT DCB/OPEN LIST FORM
*---------------------------------------------------------------------*
         DS    0F
PRMLIB   DS    XL(CPRMLIBL)       PARMLIB DCB WORK AREA
         DS    0F
PRMOPLST DS    XL(CPRMOPLL)       PARMLIB OPEN WORK AREA
PRMDDNAM DS    CL8                THE DDNAME IN PRMLIB DCB
PRMDDLOC DS    A                  ADDRESS OF THE DDNAME IN PRMLIB DCB
* CLOCKxx READ DCB
         DS    0F
CLRDCB   DS    XL(CCLRDCBL)       DCB FOR QSAM
         DS    0F
CLRDCBE  DS    XL(DCBE$LEN)       DCBE FOR QSAM
         DS    0F
CLROPLST DS    XL(CCLROPLL)       OPEN LIST
CLRDDNAM DS    CL8                THE DDNAME IN DCB
CLRDDLOC DS    A                  ADDRESS OF THE DDNAME IN DCB
* CLOCKxx WRITE DCB
         DS    0F
CLWDCB   DS    XL(CCLWDCBL)       DCB FOR QSAM
         DS    0F
CLWDCBE  DS    XL(DCBE$LEN)       DCBE FOR QSAM
         DS    0F
CLWOPLST DS    XL(CCLWOPLL)       OPEN LIST
CLWDDNAM DS    CL8                THE DDNAME IN DCB
CLWDDLOC DS    A                  ADDRESS OF THE DDNAME IN DCB
* SYSPRINT DCB
         DS    0F
SPRDCB   DS    XL(CSPRDCBL)       DCB FOR QSAM
         DS    0F
SPRDCBE  DS    XL(DCBE$LEN)       DCBE FOR QSAM
         DS    0F
SPROPLST DS    XL(CSPROPLL)       OPEN LIST
* DCBE LENGTH
DCBE$LEN EQU   DCBEEND-DCBE       DCBE length
*---------------------------------------------------------------------*
DSALEN   EQU   *-DSA              ;LENGTH OF DATA AREA, USING R13
********************************************************************
* DUMMY SECTION: DATA TABLE, USING R8 DYNAMICALLY
********************************************************************
*---------------------------------------------------------------------*
* CLOCKxx MEMBER BUFFER: EACH RECORD HAS 80 BYTES LONG
DTABLE   DSECT
CLKMBBUF DS    CL4000             THE CLOCK MEMBER BUFFER MAX 40 LINES
CLKMBMAX EQU   50                 MAXIMUM RECORDS: 50
CLKMBCTR DS    XL2                THE TOTAL NUMBER OF RECORDS
CLKMBRTZ DS    XL2                THE LOCATION OF TIMEZONE RECORD
*---------------------------------------------------------------------*
DTABLEN  EQU   *-DTABLE
STORLEN  EQU   DSALEN+DTABLEN     TOTAL STORAGE TO BE ALLOCATED.
*
*---------------------------------------------------------------------*
* PARMLIB DSECT: PARMLIB CARD IMAGE MAPS, USED BEFORE OS/390 R10
* THIS DSECT IS USED TO MAP THE DATA AREA OF IPAPLIB IN
* MACRO IPAIPA.
* EACH SYSTEM PARMLIB WILL HAVE A DATA AREA MAPPED BY THIS
* DSECT, THIS IS USED TO ACCESS ALL SYSTEM PARMLIB DATASETS.
*
IPRMLIB  DSECT
IPMLDSN  DS    CL44      PARMLIB dataset name
         DS    CL1       Reserved
IPMLLVOL DS    CL6       PARMLIB VOLSER
         DS    CL12      Reserved
IPMLLFLG DS    1BL1      PARMLIB usage flags
IPMLIBL  EQU  *-IPRMLIB  LENGTH OF PRMLIB (64 bytes)
*---------------------------------------------------------------------*
*  SYSTEM DSECTS AND MACROS                                           *
*---------------------------------------------------------------------*
*  SYSTEM DSECTS FOR MGCRE SYSTEM COMMANDS
         IEZVG111
         IEZMGCR
*  SYSTEM DSECTS FOR JOBNAMES
         IHAPSA
         IHAASCB
         IEFTIOT1
*  SYSTEM DSECTS FOR SYSTEM IPL/PARMLIB INFORMATION
         CVT      DSECT=YES       Communication table
         IHAECVT  DSECT=YES       Extended CVT
         IHAIPA   DSECT=YES       IPA
         IEFZPMAP DSECT=YES       Logical PARMLIB MAP
*  SYSTEM DSECTS FOR DYNAMIC ALLOCATION
         IEFZB4D0
         IEFZB4D2
*  SYSTEM DSECTS FOR DCB/DCBE
*        'Data Control Block (DCB)'
         DCBD  DSORG=PS,DEVD=DA
*        'DCB Extension (DCBE)'
         IHADCBE
*---------------------------------------------------------------------*
*  END OF PROGRAM                                                     *
*---------------------------------------------------------------------*
.END     END   SETHOUR
