RMT3     TITLE 'HASP REMOTE WORKSTATION PROGRAM FOR MVS/JES2' UF099
*                                                             UF099
* THE HASP SYSTEM AS DISTRIBUTED BY IBM INCLUDED A STAND-     UF099
* ALONE HASP/RMT 360 PROGRAM.  THAT PROGRAM WAS MODIFIED BY   UF099
* THE UNIVERSITY OF IOWA AS FOLLOWS:                          UF099
*   1. RUN UNDER THE OPERATING SYSTEM / 360 IN ONE REGION OR  UF099
*      PARTITION OF MVT OR MFT.                               UF099
*   2. UTILIZE STANDARD WTO AND WTOR FOR CONSOLE COMM.        UF099
*   3. SUPPORT FOR READER, PRINTER AND PUNCH VIA OS/BTAM.     UF099
*                                                             UF099
* THE ABOVE PROGRAM WAS FURTHER MODIFIED AT THE NERDC AS      UF099
* FOLLOWS:                                                    UF099
*   1. RUN UNDER MVS/JES2 OR MVS/JES2/NJE.                    UF099
*   2. CONSOLE COMMUNICATION THROUGH OS MODIFY INTERFACE.     UF099
*   3. ADD ROUTCDE=11 TO MESSAGES.  TP MESSAGES WILL HAVE     UF099
*      ROUTCDE=8.                                             UF099
*   4. TERMINATE IF READER BLKSIZE=0 (OLD SYSTEM LOOPED).     UF099
*                                                             UF099
* CONSOLE COMMUNICATIONS OPERATE IN THE FOLLOWING MANNER:     UF099
*   BY DEFAULT, ALL MESSAGE TRAFFIC TO THE REMOTE GOES TO     UF099
*   ROUTCDE=11, WITH COMMAND INPUT COMMING THROUGH THE READER UF099
*   VIA /*$ COMMAND CARDS.                                    UF099
*   IF THE LOCAL OPERATOR DESIRES TO COMMUNICATE WITH THE     UF099
*   HOST SYSTEM THROUGH THE WORK STATION PACKAGE, HE DOES SO  UF099
*   VIA A MODIFY COMMAND, AFTER WHICH TIME ALL MESSAGES WILL  UF099
*   BE DIRECTED TO THE CONSOLE THAT THE MODIFY WAS ISSUED     UF099
*   FROM.  ANY FURTHER MODIFY COMMANDS FROM OTHER CONSOLES    UF099
*   WILL CAUSE MESSAGES FROM THE HOST SYSTEM TO BE DIRECTED   UF099
*   TO THE LAST CONSOLE TO USE THE MODIFY INTERFACE.          UF099
*                                                             UF099
         EJECT ,                                              UF099
* SAMPLE JOB SETUP:                                           UF099
*                                                             UF099
*  //RMT360 JOB ,JACK,CLASS=Z,REGION=64K
*  /*JOBPARM TIME=5
*  //GO     EXEC  PGM=RMT360,
*  // PARM='80 LINEPSWD                                        RMTPSWD'
*  //STEPLIB  DD  DSN=NER.S685.PGMLIB,DISP=SHR
*  //PRINTR   DD  SYSOUT=A
*  //PUNCH    DD  SYSOUT=A
*  //SYSPRINT DD  DUMMY
*  //SYSUDUMP DD  SYSOUT=A
*  //ADAPTR   DD  UNIT=0C9
*  //*READR   DD  UNIT=00C,DCB=BLKSIZE=80
*  //READR    DD  DATA,DLM=')('
*  /*$TR80.PR1,S=N
*  //J1 JOB ,JACK
*  // EXEC PGM=IEFBR14
*  )(
*                                                             UF099
* NOTES:                                                      UF099
*   1.  THIS PROGRAM SHOULD BE RUN AT A HIGH PRIORITY SO THAT UF099
*       THE HAND-SHAKING ON THE COMMUNICATION LINE CAN BE     UF099
*       DONE WHEN REQUIRED.                                   UF099
*   2.  THE TIME AND LINE CUTOFF PARAMETERS SHOULD BE HIGH    UF099
*       ENOUGH TO PREVENT UNEXPECTED ABENDS.                  UF099
*   3.  SINCE THERE IS NO WAY FOR THE PROGRAM TO DETECT THE   UF099
*       FAILURE OF THE HOST PROCESSOR, THE LOCAL OPERATOR     UF099
*       SHOULD NOTE IF LARGE QUANTITIES OF LINE TIMEOUT       UF099
*       MESSAGES APPEAR, AND TERMINATE THE PROGRAM.           UF099
*   4.  THIS PROGRAM CONTAINS A BUILT-IN SIGN-ON CARD, BUT    UF099
*       GETS THE SIGN-ON INFORMATION FROM THE PARM FIELD OF   UF099
*       THE EXEC CARD.  THIS INFORMATION IS COPIED DIRECTLY   UF099
*       AFTER THE WORD "REMOTE" ON THE /*SIGNON CARD, AND CAN UF099
*       CONTAIN ANY NEEDED INFORMATION.                       UF099
*   5.  THE SYSPRINT DD CARD IS USED FOR DEBUGGING PURPOSES,  UF099
*       AND SHOULD NORMALLY BE LEFT AS DD DUMMY.  IF          UF099
*       SPECIFIED AS SYSOUT=A, ALL COMMUNICATIONS I/O WILL BE UF099
*       LOGGED AS FOLLOWS:                                    UF099
*       1.  FIRST 21 BYTES (UNPACKED) OF BUFFER.              UF099
*       2.  LAST 7 BYTES OF CSW.                              UF099
*       3.  FIRST 3 BYTES OF ECB.                             UF099
*       EVERY BUFFER IS LOGGED BEFORE IT IS SENT TO JES2, AND UF099
*       EACH BUFFER RETURNED FROM JES2 IS LOGGED.             UF099
*   6.  THE PROGRAM WILL TERMINATE ITSELF IF ITS LINE IS      UF099
*       DRAINED AT THE HOST PROCESSOR.  THE LOCAL OPERATOR    UF099
*       MAY ALSO TERMINATE THE PROGRAM WITH AN OS STOP        UF099
*       COMMAND (P RMT360), OR MODIFY COMMAND (F RMT360,EOJ). UF099
*   7.  THE MODIFY COMMAND INTERFACE MAY BE USED TO ENTER     UF099
*       COMMANDS TO THE HOST SYSTEM (F RMT360,$DI).           UF099
*       ANY INFORMATION ENTERRED BY THE LOCAL OPERATOR WILL   UF099
*       BE SENT TO THE HOST SYSTEM WILL THE FOLLOWING         UF099
*       EXCEPTIONS:                                           UF099
*       1.  EOJ.  THIS WILL TERMINATE EXECUTION OF THE        UF099
*           PROGRAM.  BEFORE ISSUING THIS COMMAND, THE        UF099
*           OPERATOR SHOULD VERIFY THAT ALL STREAMS ARE       UF099
*           QUIESCED.                                         UF099
*       2.  HOT.  BEFORE STARTING ANY INPUT STREAM            UF099
*           PROCESSING, THE "HOT" COMMAND CAN BE ISSUED TO    UF099
*           SPECIFY THAT AFTER END-OF-FILE IS REACHED, THE    UF099
*           PROGRAM WILL ISSUE ANOTHER READ FOR STARTING THE  UF099
*           NEXT INPUT STREAM.  THIS MAKES THE READER ALWAYS  UF099
*           OPEN.  "HOT" SHOULD ONLY BE SPECIFIED IF THE      UF099
*           CARD READER IS ASSIGNED DIRECTLY (UNIT=00C).      UF099
*       3.  NOT.  THIS CAN BE ISSUED TO MAKE THE READER       UF099
*           NOT-HOT, SO THAT AFTER END-OF-FILE THE READER     UF099
*           WILL BE PERMANENTLY CLOSED.                       UF099
*   8.  AN EXPLANATION OF THE COMMUNICATIONS ADAPTER ERROR    UF099
*       MESSAGES MAY BE FOUND IN A BOX AT THE END OF THE      UF099
*       ASSEMBLY.                                             UF099
*                                                             UF099
         EJECT ,                                              UF099
*                                                             UF099
* ANY QUESTIONS OR COMMENTS ON THIS PROGRAM SHOULD BE         UF099
* DIRECTED TO:                                                UF099
*                                                             UF099
*   JACK SCHUDEL                                              UF099
*   NORTHEAST REGIONAL DATA CENTER   (UF)                     UF099
*   ROOM 233 SPACE SCIENCES RESEARCH BUILDING                 UF099
*   UNIVERSITY OF FLORIDA                                     UF099
*   GAINESVILLE, FL 32611                                     UF099
*   (904) 392-4601                                            UF099
*                                                             UF099
         EJECT ,                                              UF099
         MACRO
&N       POST  &R
         AIF   ('&R'(1,1) EQ '(').PAR
&N       LA    1,&R
         AGO   .PARN
.PAR     ANOP
&N       LR    1,&R
.PARN    ANOP
         SR    0,0
         SVC   2
         MEND
         SPACE 5
     TITLE 'H A S P / R T P  *MACRO DEFINITIONS*(MODEL 20 INSTS.)'
*
*****   BAS    *****          BRANCH AND STORE
*
         MACRO
&NAME    BAS   &R,&LOC
         GBLA  &MACHINE
&NAME    NULL
         AIF   (&MACHINE NE 20).ANOT20
         DC    X'4D'
         DC    AL1(&R*16)
         DC    S(&LOC)
         AGO   .END
.ANOT20  ANOP
         BAL   &R,&LOC
.END     MEND
         SPACE 4
*
*****   BASR   *****          BRANCH AND STORE (R)
*
         MACRO
&NAME    BASR  &R1,&R2
         GBLA  &MACHINE
&NAME    NULL
         AIF   (&MACHINE NE 20).ANOT20
         DC    X'0D'
         DC    AL1(&R1*16+&R2)
         AGO   .END
.ANOT20  ANOP
         BALR  &R1,&R2
.END     MEND
         SPACE 4
*
*****   CIO    *****          CONTROL I/O
*
         MACRO
&NAME    CIO   &A,&B
         GBLA  &MACHINE
&NAME    NULL
         AIF   (&MACHINE NE 20).ANOT20
         DC    X'9B'
         DC    AL1(&B)
         DC    S(&A)
         AGO   .END
.ANOT20  ANOP
         BAL   R7,$IOSIM
         DC    X'9B'
         DC    AL1(&B)
         DC    S(&A)
.END     MEND
         EJECT
*
*        DIALS                     READ MOD 20 DIALS
*                                  DATA 1,2 IN LOC 252
*                                  ADDRESS 1,2,3,4 IN 253-254 DEC
         MACRO
&NAME    DIALS &NULL
&NAME    DS    0H
         DC    X'83000300' 
         MEND
         SPACE 4
*
*****   HPR    *****          HALT AND PROCEED
*
*
         MACRO
&NAME    HPR   &NUM
         GBLA  &MACHINE
&NAME    NULL
         AIF   (&MACHINE NE 20).ANOT20
         DC    X'9900',S(&NUM)
         AGO   .END
.ANOT20  ANOP
.END     MEND
         SPACE 4
*
*****   TIOB   *****          TEST I/O AND BRANCH
*
*
         MACRO
&NAME    TIOB  &A,&B
         GBLA  &MACHINE
&NAME    NULL
         AIF   (&MACHINE NE 20).ANOT20
         DC    X'9A'
         DC    AL1(&B)
         AIF   ('&A' EQ '*').A2
         DC    S(&A)
         AGO   .END
.A2      ANOP
         DC    S(*-2)
         AGO   .END
.ANOT20  ANOP
         MNOTE 12,'***ERROR*** INVALID 360 INSTRUCTION'
.END     MEND
         EJECT
         SPACE 16
*
*****   XIO    *****          TRANSFER I/O
*
*
         MACRO
&NAME    XIO   &A,&B
         GBLA  &MACHINE
&NAME    NULL
         AIF   (&MACHINE EQ 20).A20
         MNOTE 12,'***ERROR*** INVALID 360 INSTRUCTION'
.A20     ANOP
         MVC   &A,&B     XIOXIOXIOXIOXIOXIO
         ORG   *-6       XIOXIOXIOXIOXIOXIO
         DC    X'D0'     XIOXIOXIOXIOXIOXIO
         ORG   *+5       XIOXIOXIOXIOXIOXIO
.END     MEND
 TITLE 'H A S P / R T P  *MACRO DEFINITIONS*(SYSTEM DEPENDENT AIDS)'
*
*        $AA                       ADD ADDRESS TO REGISTER(CONSTANT)
*
         MACRO
&NAME    $AA   &REG,&AMT
         GBLA  &MACHINE
         AIF   (&MACHINE EQ 20).A1
&NAME    LA    &REG,&AMT.(&REG)
         MEXIT
.A1      ANOP
&NAME    AH    &REG,=Y(&AMT)
         MEND
         SPACE 1
*
*****    $ACON  *****              DEFINE AN ADDRESS CONST
*
         MACRO
&NAME    $ACON &ADDR
         GBLA  &HICORE
         AIF   (T'&ADDR EQ 'O').ZERO BR IF OPERAND OMITTED
         AIF   (&HICORE GT 32).FULL  BR IF ADDR WILL EXCEED 32K
         AIF   ('&ADDR'(1,1) NE '(').RA
&NAME    DC    Y&ADDR
         MEXIT
.RA      ANOP
&NAME    DC    Y(&ADDR)
         MEXIT
.FULL    ANOP
         AIF   ('&ADDR'(1,1) NE '(').RB
&NAME    DC    A&ADDR
         MEXIT
.RB      ANOP
&NAME    DC    A(&ADDR)
         MEXIT
.ZERO    ANOP
         AIF   (&HICORE GT 32).FULLZ BR IF ADDR WILL EXCEED 32K
&NAME    DC    Y(0)
         MEXIT
.FULLZ   ANOP
&NAME    DC    A(0)
         MEND
         SPACE 1
*
*        $ACONS                    DEFINE STORAGE FOR ADDRESS CONSTANT
*
         MACRO
&NAME    $ACONS &NULL
         GBLA  &HICORE
         AIF   (&HICORE GT 32).FULL
&NAME    DS    H
         MEXIT
.FULL    ANOP
&NAME    DS    F
         MEND
         EJECT
*
*****    $BCTR *****               BRANCH ON COUNT (RR)
*
*
         MACRO
&NAME    $BCTR &RA,&RB
         GBLA  &MACHINE
         AIF   (&MACHINE NE 20).S360
         AH    &RA,=H'-1'
         AIF   ('&RB' EQ '0' OR '&RB' EQ 'R0').END
         BCR   7,&RB
.END     MEXIT
.S360    ANOP
         BCTR  &RA,&RB
         MEND
         SPACE 4
*
*        $BITOFF                   TURN CORRESPONDING BIT OFF
*
         MACRO
&NAME    $BITOFF &A,&B,&R
         GBLA  &MACHINE
         AIF   (&MACHINE EQ 20).A1
&NAME    OC    &A,&B
         XC    &A,&B
         MEXIT
.A1      ANOP
&NAME    $OC   &A,&B
         LH    &R,&A
         SH    &R,&B
         STH   &R,&A
         MEND
         SPACE 4
*
*        $CA                       COMPARE REG TO STORAGE
*
         MACRO
&NAME    $CA   &REG,&ADDR
         GBLA  &HICORE
         AIF   (&HICORE LE 32).C1
&NAME    C     &REG,&ADDR
         MEXIT
.C1      ANOP
&NAME    CH    &REG,&ADDR
         MEND
         EJECT
*
*****   $CCW   *****          DEFINE A CHANNEL COMMAND WORD
*
         MACRO
&NAME    $CCW  &OP,&AD,&BITS,&CT
&NAME    DC    0D'0',AL1(&OP),AL3(&AD),AL1(X'&BITS'),AL3(&CT) CCW
         MEND
         SPACE 1
*
******   COUNT *****          A DEBUG MACRO TO COUNT EVENTS
*
*
         MACRO
&NAME    COUNT &COM
         GBLA  &DEBUG
         AIF   (&DEBUG EQ 0).END
&NAME    AP    *+10(6),=X'1C'
         B     *+10
         DC    XL6'0C'
         MNOTE *,'COUNT OF &COM ***************'
.END     MEND
         SPACE 1
*
****     $LA                       LOAD ADDRESS MACRO FOR 20'S
*
*
         MACRO
&NAME    $LA   &REG,&LOC
         GBLA  &MACHINE
         AIF   (&MACHINE NE 20).NOT20
&NAME    LH    &REG,=Y(&LOC)
         MEXIT
.NOT20   ANOP
&NAME    LA    &REG,&LOC
         MEND
         SPACE 1
*
*        $LMHA                     LOAD AND MULTIPLY HALF WORD ADDRESS
*                                  ASSUMES SMALL NUMBERS AND NOT ZERO
         MACRO
&NAME    $LMHA &REG1,&REG2,&ADDR1,&ADDR2
         GBLA  &MACHINE
         AIF   (&MACHINE EQ 20).S1
&NAME    LH    &REG1,&ADDR1
         MH    &REG1,&ADDR2
         MEXIT
.S1      ANOP
&NAME    SR    &REG1,&REG1
         LH    &REG2,&ADDR2
         AH    &REG1,&ADDR1
         AH    &REG2,=H'-1'
         BH    *-8
         MEND
         EJECT
*
******  $LOAD  *****               LOAD MACRO
*
*
         MACRO
&NAME   $LOAD  &REG,&ADDR
&NAME    L     &REG,&ADDR                                         U0019
         MEND
         SPACE 4
*
*****    $LTR  *****               LOAD REGISTER AND SET CC
*
*
         MACRO
&NAME    $LTR  &RA,&RB
         GBLA  &MACHINE
         AIF   (&MACHINE NE 20).S360
         AIF   ('&RA' EQ '&RB').RSAME
         SR    &RA,&RA
         AR    &RA,&RB
         MEXIT
.RSAME   ANOP
&NAME    AH    &RA,=H'0'
         MEXIT
.S360    ANOP
&NAME    LTR   &RA,&RB
         MEND
         SPACE 4
*
*****    $OC   *****               STORAGE-TO-STORAGE OR
*
*
         MACRO
&NAME    $OC   &A,&B
         GBLA  &MACHINE
&NAME    NULL  *
         AIF   (&MACHINE NE 20).S360
*        NOTE THAT THIS IS A VERY RESTRICTIVE
*        SIMULATION OF THE 'OC' INSTRUCTION FOR THE MODEL 20
         MVC   *+7(1),&B
         OI    &A,*-*
         MVC   *+7(1),&B+1
         OI    &A+1,*-*
         MEXIT
.S360    ANOP
         OC    &A,&B
         MEND
         EJECT
*
*****   NULL   *****          DEFINE A SYMBOLIC LOCATION
*
*
         MACRO
&NAME    NULL
         AIF   ('&NAME' NE '').X
         MEXIT
.X       ANOP
&NAME    DS    0H
         MEND
         SPACE 4
*
***** $RESTORE *****     RESTORE SAVED REGISTERS
*
*
         MACRO
&NAME    $RESTORE &R1,&RN,&LOC
         GBLA  &MACHINE
         LCLA  &A,&B,&C
         LCLC  &D,&E
         AIF   (&MACHINE NE 20).M30
&NAME    NULL
&D       SETC  '&R1'(2,K'&R1-1)
&A       SETA  &D
&D       SETC  '&RN'(2,K'&RN-1)
&B       SETA  &D
&C       SETA  0
.N       LH    R&A,&LOC+&C
&C       SETA  &C+2
&A       SETA  &A+1
         AIF   ('R&A' LE '&RN').N
         MEXIT
.M30     ANOP
&NAME    LM    &R1,&RN,&LOC
         MEND
         SPACE 4
*
*        $SA                       SUBTRACT ADDRESS
*
         MACRO
&NAME    $SA   &REG,&ADDR
         GBLA  &HICORE
         AIF   (&HICORE GT 32).S1
&NAME    SH    &REG,=Y(&ADDR)
         MEXIT
.S1      ANOP
&NAME    S     &REG,=A(&ADDR)
         MEND
         EJECT
         SPACE 6
*
*****   $SAVE  *****          SAVE REGISTERS
*
*
         MACRO
&NAME    $SAVE &R1,&RN,&LOC
         GBLA  &MACHINE
         LCLA  &A,&B,&C
         LCLC  &D,&E
&NAME    NULL
         AIF   (&MACHINE NE 20).N20
&D       SETC  '&R1'(2,K'&R1-1)
&A       SETA  &D
&D       SETC  '&RN'(2,K'&RN-1)
&B       SETA  &D
&C       SETA  0
.N       STH   R&A,&LOC+&C
&C       SETA  &C+2
&A       SETA  &A+1
         AIF   ('R&A' LE '&RN').N
         AGO   .END
.N20     STM   &R1,&RN,&LOC
.END     MEND
         SPACE 6
*
*****   SPSW   *****          SET PSW
*
*
         MACRO
&NAME    SPSW  &LOC
         GBLA  &MACHINE
&NAME    NULL
         AIF   (&MACHINE NE 20).ANOT20
         DC    AL4(&LOC) SPSWSPSWSPSWSPSWSPSWSPSWSPSWSPSWSPSWSPSW
         ORG   *-4       SPSWSPSWSPSWSPSWSPSWSPSWSPSWSPSWSPSWSPSW
         DC    X'8100'   SPSWSPSWSPSWSPSWSPSWSPSWSPSWSPSWSPSWSPSW
         ORG   *+2       SPSWSPSWSPSWSPSWSPSWSPSWSPSWSPSWSPSWSPSW
         AGO   .END
.ANOT20  ANOP
         LH    R7,&LOC+2
         LPR   R7,R7
         BR    R7
.END     MEND
         EJECT
*
*****   $SSM   *****          CONTROL MACHINE INTERRUPT STATUS
*
*
         MACRO
&NAME   $SSM   &MASK
         GBLA  &MACHINE
         AIF   (&MACHINE NE 20).X
&NAME    SPSW  *+4 
         AIF   ('&MASK' EQ '0').OFF
         DC    AL2(X'0100')
         DC    Y(*+2)
         AGO   .END
.OFF     ANOP
         DC    AL4(*+4)
         AGO   .END
.X       ANOP
&NAME    DS    0H                                                 U0019
.END     MEND
         SPACE 4
*
*        $STO                      STORE REG INTO ADDRESS CONSTANT
*
         MACRO
&NAME   $STO  &REG,&ADDR
&NAME    ST    &REG,&ADDR                                         U0019
         MEND
         SPACE 4
*
*****    $SUB  *****               SUBTRACT MACRO
*
*
         MACRO
&NAME    $SUB  &REG,&ADDR
         GBLA  &HICORE
         AIF   (&HICORE GT 32).FULL  BR IF ADDR WILL EXCEED 32K
&NAME    SH    &REG,&ADDR
         MEXIT
.FULL    ANOP
&NAME    S     &REG,&ADDR
         MEND
         EJECT
         SPACE 6
*
*****    $TRACE  *****      TRACE PROGRAM FLOW
*
*
         MACRO
&NAME    $TRACE &TYPE=,&SSM=YES
         GBLA  &MACHINE
         GBLA  &TRACE
&NAME    NULL
         AIF   (&TRACE EQ 0).NONE
         AIF   (&MACHINE NE 20).TRACE
         BASR  12,12 *****************S U P E R T R A C E *************
         AGO   .TRACE1
.TRACE   ANOP
         SVC   X'CC' *****************S U P E R T R A C E *************
.TRACE1  ANOP
         DC    H'0'  *****************S U P E R T R A C E *************
         AIF   ('&SSM' NE 'YES').NOSSM
         $SSM  FF
.NOSSM   ANOP
.NONE    MEND
         SPACE 6
*
*****    $WCON  *****   DEFINE CONSTANT FOR MACHINE WORD SIZE
*
*
         MACRO
&NAME    $WCON &ADDR
         GBLA  &HICORE
         LCLA  &T
&T       SETA  &HICORE
&HICORE  SETA  64
&NAME    $ACON &ADDR
&HICORE  SETA  &T
         MEND
 TITLE 'H A S P / R T P  *MACRO DEFINITIONS*(DATA MANAGEMENT)'
         SPACE 10
*
** $CHAIN  -  ADD AN ITEM TO THE END OF A CHAIN
*
*
         MACRO
&NAME    $CHAIN &SOC,&R,&SSM
         LCLC  &WR
&NAME    NULL
&WR      SETC  'R8'
         AIF   ('&R' NE 'R8').ROK
&WR      SETC  'R9'
.ROK     ANOP
         AIF   ('&SSM' NE '').NOSSM
         $SSM  0
.NOSSM   ANOP
         $TRACE SSM=NO
         AIF   ('&SOC'(1,1) NE '(').NORM
&WR      SETC  '&SOC(1)'
         AGO   .REG
.NORM    ANOP
         $STO  &WR,$CHNTEMP
         L     &WR,=A(&SOC)                                       U0019
.REG     ANOP
         CLC   0(4,&WR),=F'0'                                     U0019
         BE    *+12
         L     &WR,0(0,&WR)                                       U0019
         B     *-14                                               U0019
         ST    &R,0(0,&WR)                                        U0019
         MVC   0(4,&R),=F'0'                                      U0019
         AIF   ('&SOC'(1,1) EQ '(').REGA
         $LOAD &WR,$CHNTEMP
.REGA    ANOP
         AIF   ('&SSM' NE '').END
         $SSM  FF
.END     MEND
         EJECT
         SPACE 8
*
*        $CHECK                    CHECKS FOR I/O COMPLETION
*
         MACRO
&NAME    $CHECK &PRE,&ERR,&EOF,&T=
         GBLA  &MACHINE,&A
         LCLC  &R
&R       SETC  '&PRE'
         AIF   ('&T' EQ '').R4
&R       SETC  '&T'
.R4      ANOP
         AIF   (&MACHINE NE 20).R1
&A       SETA  &A+1
&NAME    MVC   $&PRE.COMM1+2(2),&PRE.ACN&A
&PRE.LOC&A TIOB $&PRE.COMM1+4,&R.BUSY
         AIF   ('&ERR' EQ '').R2
         TIOB  &ERR,&R.ERROR
         AIF   ('&EOF' EQ '').R2
         TIOB  &EOF,&R.EOF
.R2      ANOP
         MEXIT
.R1      ANOP
&NAME    BAL   R14,$IOCK
         AIF   ('&ERR' EQ '').R3
         TM    TCTECB,X'02'                                       U0019
         BO    &ERR                                               U0019
         AIF   ('&EOF' EQ '').R3
         TM    TCTECB,X'01'     IS IT EOF                         U0019
         BO    &EOF                                               U0019
.R3      ANOP
         MEND
         EJECT
         SPACE 6
*
** $DCHAIN  -  REMOVE THE FIRST ITEM FROM A CHAIN
*
*
         MACRO
&NAME    $DCHAIN &SOC,&R,&SSM,&EMPTY=
         GBLA  &MACHINE
         GBLA  &HICORE
         LCLA  &L
&NAME    NULL
         AIF   ('&SSM' NE '').NOSSM
         $SSM  0
.NOSSM   ANOP
         AIF   (&HICORE GT 32).CLC
&L       SETA  2
         CLI   &SOC,0
         AGO   .CLCEND
.CLC     CLC   &SOC,=F'0'
&L       SETA  4
.CLCEND  ANOP
         AIF   ('&SSM' EQ '').BREL
         AIF   ('&EMPTY' EQ '').BREL
         BE    &EMPTY
         AGO   .BREL1
.BREL    BE    *+14
.BREL1   ANOP
         $LOAD &R,&SOC
         MVC   &SOC.(&L),0(&R)
         AIF   ('&SSM' NE '').END
         AIF   (&MACHINE NE 20).NOCC
         MVI   *+16,X'31'
         BNZ   *+8
         MVI   *+8,X'01'
.NOCC    ANOP
         $SSM  FF
         MEXIT
         AIF   ('&EMPTY' EQ '').END
         BE    &EMPTY
.END     MEND
         EJECT
         SPACE 6
*
** $FREE  -  ADD AN ITEM TO THE BEGINING OF A CHAIN
*
*
         MACRO
&NAME    $FREE &SOC,&R,&SSM
&NAME    NULL
         AIF   ('&SSM' NE '').NOSSM
         $SSM  0
.NOSSM   ANOP
        $TRACE SSM=NO
         MVC   0(4,&R),&SOC                                       U0019
         ST    &R,&SOC                                            U0019
         AIF   ('&SOC' NE '$TANKPOL').NONTANK
         MVI   $TPGETCM+1,X'F0'    OPEN TPGET GATE
.NONTANK ANOP
         AIF   ('&SSM' NE '').END
         $SSM  FF
.END     MEND
         SPACE 6
*
*        $GETTNK                   GET A TANK AND POST COMPLETION
*
         MACRO
&NAME    $GETTNK &PRE,&REG,&REGA,&EMPTY=WAIT
         GBLA  &MACHINE
         AIF   ('&EMPTY' EQ 'WAIT').A1
&NAME    $DCHAIN &PRE.CTTANK,&REG,ENBL,EMPTY=&EMPTY
         AGO   .A2
.A1      AIF   (&MACHINE EQ 20).A3
&NAME    BAL   R14,$GETTNK 
         MEXIT
.A3      ANOP
&NAME    $DELAY &PRE,TYPE=SETUP,TIME=LONG
         $DCHAIN &PRE.CTTANK,&REG,ENBL,EMPTY=&PRE.CTRTN
         $OPEN &PRE,&REGA
.A2      $TCTPOST &PRE,&REGA
         MEND
         EJECT
         SPACE 4
*
*          $INTREQ                 INTERVENTION REQUIRED
*
         MACRO
&NAME    $INTREQ &PRE,&COM,&PREVLOC=
         GBLA  &MACHINE,&CONSOLE
         AIF   (&MACHINE EQ 20).R1
&NAME    MVI   &PRE.CTECB,TCTBUSY 
         AIF   ('&PREVLOC' EQ '').R3
         B     &PREVLOC
         MEXIT
.R1      ANOP
         AIF   (&CONSOLE EQ 0).R2
&NAME    OI    &PRE.CTSTAT,TCTSTOP 
         $SSM  0
         MVI   $LOGINFO+2,&PRE.ADR 
         $LOG  XUNITCHK
         $SSM  FF
         $DELAY &PRE,TIME=SHORT,TYPE=SETUP
         TM    &PRE.CTSTAT,TCTSTOP 
         BO    $&PRE.COMM1+4 
         AGO   .R5
         MEXIT
.R2      ANOP
&NAME    HPR   &PRE.ADR 
.R5      AIF   ('&PREVLOC' EQ '').R3
         B     &PREVLOC
.R3      MEND
         SPACE 4
*
*****   $LOG   *****          LOG A COMMUNICATIONS ERROR
*
*
         MACRO
&NAME    $LOG  &TYPE,&SAVE
&NAME    NULL
         AIF   ('&SAVE' NE 'SAVE').DOIT
        $STO   R15,$LOGSAVE
.DOIT    BAS   R15,$LOG
         DC    AL2(&TYPE*(LOGEND-LOGDSECT))
         AIF   ('&SAVE' NE 'SAVE').END
        $LOAD  R15,$LOGSAVE
.END     MEND
         EJECT
         SPACE 6
*
*        $PUT                      GIVES TANK TO COMPRESSION ROUTINES
*
         MACRO
&NAME    $PUT  &PRE,&ADDR
         GBLA  &A
         GBLA  &MACHINE
         AIF   (&MACHINE EQ 20).M20
&NAME    LA    R8,&ADDR 
         BAL   R14,$PUT
         MEXIT
.M20     ANOP
&A       SETA  &A+1
&NAME    MVC   $&PRE.COMM1+2(2),&PRE.ACN&A
         BAS   R14,$PUT 
&PRE.LOC&A BAS   R14,$PUTA
         $ACON (&ADDR)
         $ACON (&PRE.TCT) 
         B     $&PRE.COMM1+4       RETURN TO COMMUTATOR
         MEND
         SPACE 6
*
*****    $SIO  *****          START FOR /360 MACHINES
*
         MACRO
&NAME    $SIO  &CCW
&NAME    BAL   R15,$SIO
         DC    AL4(&CCW)
         MEND
         EJECT
*
*        $READ                     INITIATES I/O ON UNIT REC DEV
*
         MACRO
&NAME    $READ &PRE,&AREA,&BASE,&CTADDR=,&OP=,&T=R,&S=
         GBLA  &RDEV(7)
         GBLA  &UDEV(7)
         GBLA  &MACHINE,&A
         GBLB  &R(8)
         LCLC  &LOP,&ADDR
         AIF   (&MACHINE NE 20).R1
&A       SETA  &A+1
         AIF   ('&CTADDR' EQ '').R2
         MVC   &PRE.LOC&A+5(1),1+&CTADDR
.R2      ANOP
&ADDR    SETC  '0'
         AIF   ('&AREA' EQ '').R10
&ADDR    SETC  '&AREA'
         AIF   ('&AREA' NE '(R8)').R3
         STH   R8,&PRE.LOC&A+2
         AGO   .R10
.R3      AIF   ('&BASE' EQ '').R10
         AH    R8,=Y(&AREA-&BASE)
         STH   R8,&PRE.LOC&A+2
.R10     ANOP
&LOP     SETC  '&PRE'.'OPCODE'
         AIF   ('&OP(1)' EQ '' OR '&OP(2)' NE '').R4
&LOP     SETC  '&OP(1)'
.R4      ANOP
&NAME    MVC   $&PRE.COMM1+2(2),&PRE.ACN&A
         AIF   ('&T' EQ 'R').R12
         AIF   ('&PRE' NE 'U' AND '&PRE' NE 'R').R12
         AIF   (&UDEV(1) NE 2560 AND &R(7)).R12
         CIO   UPOC,USTACK 
.R12     ANOP
         AIF   ('&S' EQ '').R14
&S       DS    0H
.R14     ANOP
&PRE.LOC&A XIO &ADDR.(&LOP+1),&PRE.CT
         BC    7,$&PRE.COMM1+4
         AIF   ('&T' NE 'R' OR '&PRE' NE 'R').R13
         AIF   (&RDEV(1) NE 2560 AND &R(7)).R13
         CIO   RPOC,RSTACK 
.R13     MEXIT
.R1      ANOP
         AIF   ('&CTADDR' EQ '').R6
         MVC   &PRE.CTCCWCT+1(1),1+&CTADDR
.R6      ANOP
         AIF   ('&AREA' EQ '').R7
         AIF   ('&AREA' EQ '(R8)').R8
         LA    R8,&AREA            *** DESTROYS R8
.R8      ANOP
         ST    R8,&PRE.CTCCW
.R7      ANOP
         AIF   ('&OP(1)' EQ '' OR '&OP(2)' NE '' AND &R(2) AND         C
               &R(3)).R9
         AIF   ('&OP(2)' EQ '').R11
         MVC   &PRE.CTCCW,&OP(1)
&NAME    BAL   R14,$XIOA
         MEXIT
.R11     MVI   &PRE.CTCCW,&OP(1)
&NAME    BAL   R14,$XIOA
         MEXIT
.R9      ANOP
&NAME    BAL   R14,$XIO
         MEND
         SPACE 6
*
*        $WRITE                    INITIATES I/O ON UNIT REC DEV
*
         MACRO
&NAME    $WRITE &PRE,&AREA,&BASE,&CTADDR=,&OP=,&S=
&NAME    $READ &PRE,&AREA,&BASE,CTADDR=&CTADDR,OP=&OP,T=W,S=&S
         MEND
 TITLE 'H A S P / R T P  *MACRO DEFINITIONS*(TASK MANAGEMENT)'
         SPACE 20
*
*        $CLOSE                    CLOSE COMMUTATOR GATE AND EXIT
*
         MACRO
&NAME    $CLOSE &PRE
         GBLA  &MACHINE
         AIF   (&MACHINE EQ 20).A1
&NAME    B     $CLOSTCT 
         MEXIT
.A1      ANOP
&NAME    NI    $&PRE.COMM1+1,X'0F' 
         B     $&PRE.COMM1+4 
         MEND
         EJECT
*
*        $DELAY                    WAIT ONE TIME AROUND COMMUTATOR
*                                  ESTABLISH REENTRY POINT
         MACRO
&NAME    $DELAY &PRE,&ADR,&TYPE=BRANCH,&TIME=SHORT,&PREVLOC=*
         GBLA  &MACHINE,&A
         LCLC  &COM
&COM     SETC  '&ADR'
         AIF   ('&ADR' NE '').R3
&COM     SETC  '&PRE'
.R3      ANOP
&A       SETA  &A+1
         AIF   (&MACHINE NE 20).R1
&NAME    MVC   $&COM.COMM1+2(2),&PRE.ACN&A
         AIF   ('&TYPE' EQ 'BRANCH').R10
         AIF   ('&TIME' EQ 'SHORT').R5
&PRE.LOC&A NI  $&COM.COMM1+1,X'0F' 
         AGO   .R7
.R10     AIF   ('&TIME' EQ 'SHORT').R5
         NI    $&COM.COMM1+1,X'0F' 
.R5      ANOP
         AIF   ('&TYPE' NE 'BRANCH').R2
         B     $&COM.COMM1+4
         AGO   .R2
.R1      ANOP
&NAME    MVC   &COM.CTENTY(2),&PRE.ACN&A
         AIF   ('&TYPE' EQ 'BRANCH').R9
         AIF   ('&TIME' EQ 'SHORT').R6
&PRE.LOC&A $LOAD R8,&COM.CTCOM 
         NI    1(R8),X'0F'
         AGO   .R8
.R9      AIF   ('&TIME' EQ 'SHORT').R6
         $LOAD R8,&COM.CTCOM 
         NI    1(R8),X'0F'
.R6      ANOP
         AIF   ('&TYPE' NE 'BRANCH').R2
         B     &COM.CTRTN
.R2      ANOP
&PRE.LOC&A EQU &PREVLOC
.R8      ANOP
.R7      ANOP
         MEND
         EJECT
*
*        ENDPROC                   USED TO BUILD REENTRY PTS TO
*                                  PROCESSORS
         MACRO
         $ENDPROC &PRE
         GBLA  &A
         LCLA  &B
&B       SETA  1
.E2      AIF   (&B GT &A).E1
&PRE.ACN&B DC  S(&PRE.LOC&B)
&B       SETA  &B+1
         AGO   .E2
.E1      ANOP
         MEND
         SPACE 6
*
*        $OPEN                     OPENS THE DESIGNATED COMMUTATOR
*
         MACRO
&NAME    $OPEN &PRE
         GBLA  &MACHINE
         AIF   (&MACHINE EQ 20).R1
&NAME    $LOAD R9,&PRE.CTCOM 
         OI    1(R9),X'F0'
         MEXIT
.R1      ANOP
&NAME    OI    $&PRE.COMM1+1,X'F0'
         MEND
         SPACE 6
*
*        $TCTPOST                  POST $TPGET TO QUE MORE TANKS
*
         MACRO
&NAME    $TCTPOST &PRE,&REG
&NAME    LH    &REG,&PRE.CTTNKLM 
         $BCTR &REG,0
         STH   &REG,&PRE.CTTNKLM
         OI    &PRE.CTSTAT,TCTACT 
         OI    $TPGETCM+1,X'F0' 
         MEND
 TITLE 'H A S P / R T P  *GLOBAL SYMBOL AND STORAGE MACROS* $CONFIG'
*
*        $CONFIG                   SETS GLOBALS AND CREATES EQUATES
*
         MACRO
&NAME    $CONFIG
         GBLA  &MACHINE,&PDEV(7),&RDEV(7),&UDEV(7),&WDEV(1),&A,&B,&S(7)
         GBLA  &D,&T,&NUMPRT,&NUMRDR,&NUMPUN,&CONSOLE,&WTOSIZE
         GBLA  &LOCCOM
         GBLB  &R(8)
         GBLC  &PADR(7),&RADR(7),&UADR(7),&WADR(1)
         AIF   (&MACHINE NE 20).SS1
*        &R(6) SET TO 0 THIS IS A MOD 20
PADR     EQU   &PADR(1) 
RADR     EQU   &RADR(1) 
UADR     EQU   &UADR(1) 
&R(6)    SETB  0                   SYSTEM IS A MOD 20
.SS1     ANOP
&A       SETA  1
         AIF   (&PDEV(1) EQ 0).SETPRT
.PLOOP   AIF   (&PDEV(&A) NE 1443).SKPP4
*        EQUATES FOR 1443 PRINTER SUPPORT
P1443    EQU   X'01' 
P14431   EQU   X'01' 
PF1443   EQU   X'20' 
         AGO   .SKPP3
.SKPP4   AIF   (&PDEV(&A) NE 1403).SKPP5
*        EQUATES FOR 1403 PRINTER SUPPORT
         AIF   (&MACHINE EQ 20).SKPP6
P1403    EQU   X'01' 
P14031   EQU   X'01' 
PF1403   EQU   X'20' 
         AGO   .SKPP3
.SKPP6   ANOP
POPCODE  EQU   X'40' 
PBUSY    EQU   X'40' 
PERROR   EQU   X'41' 
         AGO   .SKPP3
.SKPP5   AIF   (&PDEV(&A) NE 2203).SKPP3
*        EQUATES FOR 2203 PRINTER SUPPORT
POPCODE  EQU   X'40' 
PBUSY    EQU   X'40' 
PERROR   EQU   X'41' 
.SKPP3   ANOP
&A       SETA  &A+1
         AIF   (&A GT 7).SETPRT
         AIF   (&PDEV(&A) EQ 0).SETPRT
&T       SETA  0
&B       SETA  1
.SKPP2   AIF   (&PDEV(&A) NE &PDEV(&B)).SKPP1
&T       SETA  1
.SKPP1   ANOP
&B       SETA  &B+1
         AIF   (&B LT &A).SKPP2
         AIF   (&T EQ 0).PLOOP
         AGO   .SKPP3
.SETPRT  ANOP
&NUMPRT  SETA  &A-1
RSIZE    EQU   80                  LENGTH OF CARD
&A       SETA  1
&D       SETA  0
         AIF   (&RDEV(1) EQ 0).SETRDR
         AGO   .SKPR20
.RLOOP   AIF   (&RDEV(&A) NE 1442).SKPR6
*        EQUATES FOR 1442 READ SUPPORT &R(1) SET TO 0
&R(1)    SETB  0                   NON DUAL READER ON SYSTEM
R1442    EQU   X'42' 
R14421   EQU   X'42' 
RF1442   EQU   X'00' 
         AGO   .SKPR5
.SKPR6   AIF   (&RDEV(&A) NE 2501).SKPR7
*        EQUATES FOR 2501 READ SUPPORT &R(1) SET TO 0
&R(1)    SETB  0                   NON DUAL READER ON SYSTEM
         AIF   (&MACHINE EQ 20).SKPRA1
R2501    EQU   X'02' 
R25011   EQU   X'02' 
RF2501   EQU   X'00' 
         AGO   .SKPR5
.SKPRA1  ANOP
ROPCODE  EQU   X'12' 
RBUSY    EQU   X'10' 
RERROR   EQU   X'11' 
REOF     EQU   X'14' 
         AGO   .SKPR5
.SKPR7   AIF   (&RDEV(&A) NE 2520).SKPR8
*        EQUATES FOR 2520 READ SUPPORT &R(1) SET TO 0
&R(1)    SETB  0                   NON DUAL READER ON SYSTEM
         AIF   (&MACHINE EQ 20).SKPRA5
R2520    EQU   X'42' 
R25201   EQU   X'42' 
RF2520   EQU   X'00' 
         AGO   .SKPR5
.SKPRA5  ANOP
ROPCODE  EQU   X'22' 
RSTACK   EQU   X'20' 
RBUSY    EQU   X'20' 
RERROR   EQU   X'21' 
REOF     EQU   X'24' 
RPOC     EQU   X'02' 
         AGO   .SKPR5
.SKPR8   AIF   (&RDEV(&A) NE 2540).SKPR9
*        EQUATES FOR 2540 READ SUPPORT &R(1) SET TO 0
&R(1)    SETB  0                   NON DUAL READER ON SYSTEM
R2540    EQU   X'42' 
R25401   EQU   X'42' 
RF2540   EQU   X'00' 
         AGO   .SKPR5
.SKPR9   AIF   (&RDEV(&A) NE 2560).SKPR10
*        EQUATES FOR 2560 READ SUPPORT &R(1) SET TO 0
&R(1)    SETB  0                   NON DUAL READER ON SYSTEM
ROPCODE  EQU   X'22' 
RBUSY    EQU   X'20' 
RERROR   EQU   X'21' 
REOF     EQU   X'24' 
RPOC     EQU   X'02' 
RSTACK   EQU   X'20' 
         AGO   .SKPR5
.SKPR10  AIF   (&RDEV(&A) NE 25200).SKPR11
*        EQUATES FOR 2520 DUAL READ/PUNCH SUPPORT &R(2) SET TO 0
&R(2)    SETB  0                   2520 DUAL READ/PUNCH ON SYSTEM
         AIF   (&MACHINE EQ 20).SKPRA2
R25200   EQU   X'C2' 
R252001  EQU   X'49' 
R252002  EQU   X'02' 
R252003  EQU   X'23' 
RF25200  EQU   X'20' 
         AGO   .SKPR5
.SKPRA2  ANOP
ROPCODE  EQU   X'22' 
RBUSY    EQU   X'20' 
RERROR   EQU   X'21' 
REOF     EQU   X'24' 
UEOF     EQU   X'24' 
UOPCODE  EQU   X'24' 
UBUSY    EQU   X'22' 
UERROR   EQU   X'23' 
         AGO   .SKPR5
.SKPR11  AIF   (&RDEV(&A) NE 14420).SKPR12
*        EQUATES FOR 1442 DUAL READ/PUNCH SUPPORT &R(3) SET TO 0
&R(3)    SETB  0                   1442 DUAL READ/PUNCH ON SYSTEM
R14420   EQU   X'02' 
R144201  EQU   X'41' 
RF14420  EQU   X'20' 
         AGO   .SKPR5
.SKPR12  AIF   (&RDEV(&A) NE 25600).SKPR5
*        EQUATES FOR 2560 DUAL READ/PUNCH SUPPORT &R(7) SET TO 0
&R(7)    SETB  0                   2560 DUAL READ/PUNCH ON SYSTEM
ROPCODE  EQU   X'22' 
RBUSY    EQU   X'20' 
RERROR   EQU   X'21' 
REOF     EQU   X'24' 
RPOC     EQU   X'02' 
RSTACK   EQU   X'20' 
UOPCODE  EQU   X'27' 
UPOC     EQU   X'03' 
USTACK   EQU   X'21' 
UBADPOC  EQU   X'04' 
UNSTACK  EQU   X'22' 
&NUMRDR  SETA  1
&NUMPUN  SETA  0
&D       SETA  0
         AGO   .LOOKWTO
.SKPR5   ANOP
&A       SETA  &A+1
         AIF   (&A GT 7).SETRDR
         AIF   (&RDEV(&A) EQ 0).SETRDR
.SKPR20  ANOP
&B       SETA  1
&S(&A)   SETA  0
.SKPR2   AIF   ('&RADR(&A)' EQ '&UADR(&B)').SKPR1
&B       SETA  &B+1
         AIF   (&B LE 7).SKPR2
.SKPR13  AIF   (&A EQ 1).RLOOP
&T       SETA  0
&B       SETA  1
.SKPR4   AIF   (&RDEV(&A) NE &RDEV(&B)).SKPR3
&T       SETA  1
.SKPR3   ANOP
&B       SETA  &B+1
         AIF   (&B LT &A).SKPR4
         AIF   (&T EQ 0).RLOOP
         AGO   .SKPR5
.SKPR1   ANOP
&RDEV(&A) SETA &RDEV(&A)*10
&UDEV(&B) SETA &UDEV(&B)*10
&D       SETA  &D+1
&S(&A)   SETA  &B
         AGO   .SKPR13
.SETRDR  ANOP
&NUMRDR  SETA  &A-1
&A       SETA  1
         AIF   (&UDEV(1) EQ 0).SETPUN
.ULOOP   AIF   (&UDEV(&A) NE 1442).SKPU4
*        EQUATES FOR 1442 PUNCH SUPPORT &R(8) SET TO 0
&R(8)    SETB  0                   SINGLE POCKET 1442 ON SYSTEM
         AIF   (&MACHINE EQ 20).SKPU5
U14421   EQU   X'81' 
U1442    EQU   X'81' 
UF1442   EQU   X'20' 
         AGO   .SKPU3
.SKPU5   ANOP
UOPCODE  EQU   X'36' 
UBUSY    EQU   X'32' 
UERROR   EQU   X'33' 
         AGO   .SKPU3
.SKPU4   AIF   (&UDEV(&A) NE 2520).SKPU6
*        EQUATES FOR 2520 PUNCH SUPPORT &R(5) SET TO 0
&R(5)    SETB  0                   NON DUAL PUNCH DEVICE ON SYSTEM
         AIF   (&MACHINE EQ 20).SKPU7
U2520    EQU   X'41' 
U25201   EQU   X'41' 
UF2520   EQU   X'20' 
         AGO   .SKPU3
.SKPU7   ANOP
UOPCODE  EQU   X'26' 
UBUSY    EQU   X'22' 
UERROR   EQU   X'23' 
         AGO   .SKPU3
.SKPU6   AIF   (&UDEV(&A) NE 2540).SKPU8
*        EQUATES FOR 2540 PUNCH SUPPORT &R(4) SET TO 0
&R(4)    SETB  0                   2540 PUNCH ON SYSTEM
U2540    EQU   X'41' 
U25401   EQU   X'41' 
UF2540   EQU   X'20' 
         AGO   .SKPU3
.SKPU8   AIF   (&UDEV(&A) NE 2560).SKPU3
*        EQUATES FOR 2560 PUNCH SUPPORT &R(5) SET TO 0
&R(5)    SETB  0                   NON DUAL PUNCH DEVICE ON SYSTEM
UOPCODE  EQU   X'27' 
UBUSY    EQU   X'20' 
UERROR   EQU   X'21' 
UPOC     EQU   X'03' 
USTACK   EQU   X'21' 
UBADPOC  EQU   X'04' 
UNSTACK  EQU   X'22' 
.SKPU3   ANOP
&A       SETA  &A+1
         AIF   (&A GT 7).SETPUN
         AIF   (&UDEV(&A) EQ 0).SETPUN
&T       SETA  0
&B       SETA  1
.SKPU2   AIF   (&UDEV(&A) NE &UDEV(&B)).SKPU1
&T       SETA  1
.SKPU1   ANOP
&B       SETA  &B+1
         AIF   (&B LT &A).SKPU2
         AIF   (&T EQ 0).ULOOP
         AGO   .SKPU3
.SETPUN  ANOP
&NUMPUN  SETA  &A-1
.LOOKWTO ANOP
         AIF   (&WDEV(1) EQ 0).SKPSETW
*        EQUATES FOR OPERATOR CONSOLE SUPPORT
WSIZE    EQU   &WTOSIZE            LENGTH OF CONSOLE PRINT LINE
         AIF   (&MACHINE EQ 20).SKP1
W1052    EQU   X'09' 
W10521   EQU   X'09' 
W10522   EQU   X'0A' 
WF1052   EQU   X'20' 
WREAD    EQU   X'0A' 
         AGO   .SETWTO
.SKP1    ANOP
*        &LOCCOM SET TO 1 *LOCAL COMMAND SUPPORT IS REQUIRED*
&LOCCOM  SETA  1
WREAD    EQU   X'E1'               READ OPCODE FOR CONSOLE
WREQ     EQU   X'E3' 
WENABLE  EQU   X'E2' 
WOPCODE  EQU   X'E3' 
WBUSY    EQU   X'E0' 
WERROR   EQU   X'E2' 
.SETWTO  ANOP
&CONSOLE SETA  1
.SKPSETW MEND
 TITLE 'H A S P / R T P  *GLOBAL SYMBOL AND STORAGE MACROS*  DEFTCT'
*
*        DEFTCT                    DEFINE TCT SYMBOLS FOR
*                                  DSECT AND ABS ADDRS
         MACRO
         DEFTCT &PRE
         GBLA  &LOCCOM,&CONSOLE
         GBLA  &MACHINE,&CCT,&A,&UDEV(7)
         GBLB  &R(8)
         LCLC  &SIZ
&SIZ     SETC  '&PRE'
         AIF   ('&PRE' NE 'U').TCTUDF
&SIZ     SETC  'R'
.TCTUDF  ANOP
&PRE.TCT DS    0H
         AIF   (&MACHINE EQ 20).TCTSKP1
&PRE.CTSTRT DS CL2 
&PRE.CTENTY DS CL2 
&PRE.CTRTN DS  CL4 
&PRE.CTCCW DS  CL1 
&PRE.CTDATA DS AL3 
&PRE.CTFLAG DS CL1 
&PRE.CTOPCOD DS CL1 
&PRE.CTCCWCT DS AL2 
&PRE.CTSENSE DS AL2 
&PRE.CTUCB DS  AL2 
&PRE.CTECB DS  CL1 
&PRE.CTALTOP DS CL1 
&PRE.CTSAV1 $ACONS , 
.TCTSKP1 ANOP
&PRE.CTNEXT $ACONS , 
&PRE.CTFCS DS  AL2 
&PRE.CTRCB DS  CL1 
&PRE.CTSTAT DS CL1 
&PRE.CTCOM $ACONS , 
         AIF   (&LOCCOM EQ 0).TCT4
&PRE.CTID DS   CL2 
.TCT4    ANOP
         AIF   (NOT(&R(2) AND &R(3) AND &R(7))).TCT1
&PRE.CTINRCB EQU &PRE.CTRCB 
.TCT1    AIF   (&R(2) AND &R(3) AND &R(7)).TCT2
&PRE.CTINRCB DS CL1 
.TCT2    ANOP
         AIF   ('&PRE' EQ 'R' AND &R(2) AND &R(3) AND &R(7)).TCTSKP3
*
*        NORMAL DEVICE EXTENTION
*
&PRE.CTTANK $ACONS , 
&PRE.CTBUFER $ACONS , 
*
*              TNKLM,TNKCT AND BUFLM,BUFCT MUST APPEAR IN SEQ AND STRT
*                                  ON HALF WORD BOUNDARIES
&PRE.CTTNKLM DS CL1 
&PRE.CTTNKCT DS CL1 
&PRE.CTBUFLM DS CL1 
&PRE.CTBUFCT DS CL1 
.TCTSKP3 AIF   ('&PRE' NE 'W' AND '&PRE' NE 'R' AND ('&PRE' NE 'U'     C
               OR &R(2) AND &R(3))).TCTSKP2
         AIF   ('&PRE' EQ 'W' AND &CONSOLE EQ 0).TCTSKP2
*
*        TANK EXTENTIONS FOR READER AND CONSOLE PROCESSORS
*
&PRE.CTTANK1 $ACONS , 
&PRE.CTTRCB1 DS CL1 
&PRE.CTTSRC1 DS CL1 
&PRE.CTTCT1 DS H 
&PRE.CTTDTA1 DS CL(&SIZ.SIZE+&CCT)
         AIF   ('&PRE' EQ 'W').TCTSKP2
&PRE.CTTANK2 $ACONS , 
&PRE.CTTRCB2 DS CL1 
&PRE.CTTSRC2 DS CL1 
&PRE.CTTCT2 DS H 
&PRE.CTTDTA2 DS CL(&SIZ.SIZE+&CCT)
.TCTSKP2 AIF   ('&PRE'  NE  'U'  OR &R(4)  AND ( NOT &R(6) OR &R(2)    C
               AND &R(3))).TCTSKP4
&PRE.CTHOLD $ACONS , 
.TCTSKP4 ANOP
         MEND
 TITLE 'H A S P / R T P  *GLOBAL SYMBOL AND STORAGE MACROS* $GENBUFS'
         SPACE 10
*
*****    $GENBUFS   ***** GENERATE PSEUDO BUFFER POOL
*
         MACRO
         GIVEN
         GBLA  &NUMBUFS
         LCLA  &A
         SPACE 3
&A       SETA  1
.ABUF    ANOP
$BUF&A   EQU   $1STBUF+(&A-1)*(BUFEND-BUFBEGIN)
&A       SETA  &A+1
         AIF   (&A LE &NUMBUFS).ABUF
         EJECT
         MEND
 TITLE 'H A S P / R T P  *GLOBAL SYMBOL AND STORAGE MACROS* $GENCOM'
*
*        $GENCOM                   GENERATES ALL COMMUTATOR ENTRIES
*
         MACRO
&NAME    $GENCOM
         GBLA  &NUMRDR,&NUMPUN,&CONSOLE,&MACHINE,&NUMPRT,&PRTCONS
         GBLA  &UDEV(7)
         LCLA  &A
         LCLC  &ENT
&ENT     SETC  'COM'
         AIF   (&MACHINE NE 20).COMA
&ENT     SETC  'RTN'
.COMA    ANOP
&NAME    NULL
$CONTCOM NOP   $CONTROL 
$TPGETCM NOP   $TPGET 
&A       SETA  1
.C1      AIF   (&A GT &NUMPRT).C2
$PCOMM&A NOP   $P&ENT&A 
&A       SETA  &A+1
         AGO   .C1
.C2      ANOP
&A       SETA  1
.C3      AIF   (&A GT &NUMRDR).C4
$RCOMM&A B     $R&ENT&A 
&A       SETA  &A+1
         AGO   .C3
.C4      ANOP
&A       SETA  1
.C5      AIF   (&A GT &NUMPUN).C6
         AIF   (&UDEV(&A) GT 9999).C8
$UCOMM&A NOP   $U&ENT&A 
         AGO   .C9
.C8      AIF   (&MACHINE NE 20).C9
$UCOMM1  EQU   $RCOMM1
.C9      ANOP
&A       SETA  &A+1
         AGO   .C5
.C6      ANOP
         AIF   (&CONSOLE NE 1 AND &PRTCONS EQ 0).C7
$WCOMM1  NOP   $W&ENT.1 
$WTORCOM B     WTORPROC                                           U0019
.C7      ANOP
$COMCOM  NOP   $COMSUP 
         NOP   $INTRUPT                                           U0019
WTORECK  L     R1,ECBPCIB          POINTER TO MODIFY ECB       UF099
         TM    0(R1),X'40'         TEST FOR POSTED             UF099
         BZ    RDRECBCK                                           U0019
         XC    WTORECB,WTORECB                                    U0019
         OI    $WTORCOM+1,X'F0'                                   U0019
RDRECBCK TM    RDRECB,X'40'                                       U0019
         BO    RDRDONE                                            U0019
PCHECBCK TM    PCHECB,X'40'                                       U0019
         BO    PCHDONE                                            U0019
PRTECBCK TM    PRTECB,X'40'                                       U0019
         BO    PRTDONE                                            U0019
ADAECBCK TM    ADAECB,X'40'                                       U0019
         BO    ADADONE                                            U0019
TIMECHK  TM    TIMECB,X'40'                                       U0019
         BO    TIMEDONE                                           U0019
ALLCHK   CLC   $START(36),$ALLOFF   ARE ALL BRANCHES NO-OPED?     U0019
         BNE   $START               IF NO GO AROUND AGAIN         U0019
         WAIT  1,ECBLIST=ECBLIST    WAIT FOR SOMEBODY             U0019
         B     WTORECK              GO FIND WHO WOKE US UP        U0019
RDRDONE  OI    $RCOMM1+1,X'F0'                                    U0019
         L     R8,RDRECB+16               LOAD IOB ADDRESS        U0019
         OC    RCTECB,12(R8)              OR IN CSW STATUS        U0019
         NI    RCTECB,X'EF'               TURN OFF BUSY           U0019
         B     PCHECBCK                                           U0019
PCHDONE  OI    $UCOMM1+1,X'F0'      OPEN GATE                     U0019
         L     R8,PCHECB+16         GET IOB ADDRESS               U0019
         OC    UCTECB,12(R8)        OR IN CSW STATUS              U0019
         NI    UCTECB,X'EF'         TURN OFF BUSY                 U0019
         B     PRTECBCK                                           U0019
PRTDONE  OI    $PCOMM1+1,X'F0'      OPEN GATE                     U0019
         L     R8,PRTECB+16         GET IOB ADDRESS               U0019
         OC    PCTECB,12(R8)        OR IN CSW STATUS              U0019
         NI    PCTECB,X'EF'       RESET BUSY FLAG                 U0019
         B     ADAECBCK                                           U0019
ADADONE  OI    $COMCOM+5,X'F0'    OPEN GATE                       U0019
         B     GOLOGIT                                            U0019
LOGITBK  XC    ADAECB,ADAECB      CLEAR ECB                       U0019
         B     TIMECHK                                            U0019
TIMEDONE XC    TIMECB,TIMECB                                      U0019
         B     $TIMBACK           GO SEND RESPONSE TO HASP        U0019
         DS    0F                                                 U0019
ECBLIST  DC    A(RDRECB)           ECBLIST                        U0019
         DC    A(PCHECB)            .     .     .                 U0019
         DC    A(TIMECB)             .     .     .                U0019
ECBPCIB  DC    A(0)                POINTER TO MODIFY ECB       UF099
         DC    A(PRTECB)               .     .     .              U0019
         DC    X'80'                    .     .     .             U0019
         DC    AL3(ADAECB)               .     .     .            U0019
$ALLOFF  NOP   $CONTROL         DUMMY COMMUTATOR                  U0019
         NOP   $TPGET               TO COMPARE FOR ALL NO-OPS     U0019
         NOP   $PCOM1                 -                           U0019
         NOP   $RCOM1                     -                       U0019
         NOP   $UCOM1                      -                      U0019
         NOP   $WCOM1                       -                     U0019
         NOP   WTORPROC                      -                    U0019
         NOP   $COMSUP                        -                   U0019
         NOP   $INTRUPT                        -                  U0019
GOLOGIT  STM   14,15,KRSAV                                        U0019
         L     R14,CBUFFER                                        U0019
         LA    R14,7(R14)                                         U0019
         BAL   R15,KLOGIT                                         U0019
         LM    R14,R15,KRSAV                                      U0019
         B     LOGITBK                                            U0019
KRSAV    DC    2F'0'                                              U0019
WTORECB  DC    F'0'                                               U0019
         B     &NAME
         MEND
 TITLE 'H A S P / R T P  *GLOBAL SYMBOL AND STORAGE MACROS* $GENTANK'
         SPACE 10
*
*****   $GENTANK   *****     GENERATE DECOMPRESSION TANKS
*
*
         MACRO
&NAME    $GENTANK
         GBLA  &NUMTANK,&TEMP,&CCT,&PRTSIZE
         LCLA  &TEMP1
&TEMP    SETA  1
.TANK    ANOP
&TEMP1   SETA  &TEMP+1
$TANK&TEMP $ACON $TANK&TEMP1
         DC    AL1(0) 
         DC    AL1(0) 
         DC    AL2(0) 
         DC    &PRTSIZE.C' ' 
         DC    (&CCT)C' ' 
&TEMP    SETA  &TEMP+1
         AIF   (&TEMP LE &NUMTANK).TANK
$TANK&TEMP1 EQU 0 
&NAME    EQU   $TANK1 
         MEND
 TITLE 'H A S P / R T P  *GLOBAL SYMBOL AND STORAGE MACROS* $GENTCT'
*
*        $GENTCT MACRO             GENERATE A TCT
*
         MACRO
&NAME    $GENTCT &PRE,&FCS,&RCB,&ADR,&DEV,&TLM,&BLM,&ACS,&ACB
         GBLA  &LOCCOM,&CONSOLE
         GBLA  &A,&B,&MACHINE,&T,&CCT,&D
         GBLB  &R(8)
         AIF   ('&PRE' EQ 'U' AND '&DEV' GT '9999').TCT12
         AIF   (&MACHINE EQ 20).TCT1
         CNOP  6,8
$&PRE.COM&A BALR R7,0 
.TCT1    ANOP
$TCT&B   DS    0H 
         AIF   (&A NE 1).TCT2
*
*        SYMBOLIC DEFINITIONS USED BY PROCESSOR TO REFER TO TCT
*
         AIF   (&D LT 2).TCTORG
&PRE.CTDSECT DSECT
         DEFTCT &PRE
HASPRTP  CSECT
         AGO   .TCT2
.TCTORG  ANOP
         DEFTCT &PRE
         ORG   $TCT&B
.TCT2    ANOP
*
*        STORAGE ALLOCATION AND INITIAL VALUES FOR TCT
*
&B       SETA  &B+1
&NAME    DS    0H
         AIF   (&MACHINE EQ 20).TCT11
         B     $&PRE.RTN1 
         B     $&PRE.COMM&A.+4 
         DC    X'0',AL3(*-*),AL1(&PRE.F&DEV),AL1(&PRE&DEV),AL2(80)
         DC    H'0' 
         DC    X'&ADR' 
         DC    X'00' 
         DC    AL1(&PRE&DEV.1)
         $ACON , 
.TCT11   ANOP
         $ACON ($TCT&B)
         DC    AL2(&FCS)
         DC    AL1(&RCB)
         DC    AL1(TCT&DEV)
         $ACON ($&PRE.COMM&A) 
         AIF   (&LOCCOM EQ 0).TCT6
         DC    C'&PRE.&A' 
.TCT6    ANOP
         AIF   (&R(2) AND &R(3) AND &R(7)).TCT3
         DC    AL1(&ACB)
.TCT3    ANOP
         AIF   ('&PRE' EQ 'R' AND &R(2) AND &R(3) AND &R(7)).TCT4
*        NORMAL EXTENTION TO TOTAL CONTROL TABLE
         $ACON , 
         $ACON , 
         DC    AL1(&TLM)
         DC    X'00' 
         DC    AL1(&BLM)
         DC    X'00' 
.TCT4    AIF   ('&PRE' NE 'R' AND '&PRE' NE 'W').TCT5
         AIF   ('&PRE' EQ 'W' AND &CONSOLE EQ 0).TCT5
*        INPUT TANKS FOR READER AND CONSOLE
         $ACON ,
         DC    AL1(&ACB)
         DC    X'80' 
         DC    H'80' 
         DC    CL(&PRE.SIZE+&CCT)' '
         AIF   ('&PRE' NE 'R').TCT13
         $ACON ,
         DC    AL1(&ACB)
         DC    X'80' 
         DC    H'80' 
         DC    CL(&PRE.SIZE+&CCT)' '
.TCT5    AIF   (  NOT ('&PRE' EQ 'U' AND '&DEV' EQ '2540' OR  &R(6)    C
               AND  '&PRE' EQ  'R' AND ('&DEV' EQ '25200' OR '&DEV'    C
               EQ '14420'))).TCT13
         $ACON (1) 
         MEXIT
.TCT12   AIF   (&A NE 1).TCT13
         AIF   (&D EQ 1).TCTOG
&PRE.CTDSECT DSECT
         DEFTCT U
HASPRTP CSECT
         AGO   .TCT13
.TCTOG   ANOP
         ORG   $TCT&T
         DEFTCT U
         ORG
.TCT13   MEND
 TITLE 'H A S P / R T P  *GLOBAL SYMBOL AND STORAGE MACROS* $LOGENT'
         SPACE 12
*
*****    $LOGENT *****             GENERATE A LOG TABLE ENTRY
*
*
         MACRO
&NAME    $LOGENT &ID=,&CLASS=,&TEXT=
         GBLA  &LOGID
&LOGID   SETA  &LOGID+1
&ID      EQU   &LOGID
&NAME    DS    0H
         DC    AL1(&ID)
         DC    AL1(&CLASS)
         DC    H'0'
         DC    CL(L'LOGTEXT)&TEXT
         MEND
         PRINT ON
         TITLE 'H A S P / R J E  * GLOBAL DEFINITIONS * '
         SPACE 10
         GBLA  &RMTID              REMOTE'S IDENTIFICATION
         GBLA  &TPBFSIZ            COMMUNICATIONS ADAPTER BUFFER SIZE
         GBLA  &MLBFSIZ            MULTI-LEAVING BUFFER SIZE
         GBLA  &NUMBUFS            NUMBER OF CA BUFFERS
         GBLA  &NUMTANK            NUMBER OF DECOMPRESSION TANKS
         GBLA  &MACHINE            TYPE OF MACHINE FOR THIS ASSEMBLY
         GBLA  &SUBMOD             SUB-MODEL NUMBER IF MODEL 20
         GBLA  &LINESPD            COMMUNICATION LINE SPEED
         GBLA  &DEBUG              DEBUG MODE SWITCH
         GBLA  &TRACE              TRACE MODE
         GBLA  &CORESIZ            MODEL 20 CORE SIZE
         GBLC  &XPARENT            TRANSPARENCY FEATURE INDICATOR
         GBLA  &ERRMSGN            MAX NUM ERROR MESSAGES QUEUED
         GBLA  &ERRTXTL            LENGTH OF TEXT FOR ERR MSG+1
         GBLA  &HICORE             MAXIMUM STORAGE ADDRESS IN HRTP
         GBLA  &HRTPORG            PROGRAM ORIGIN
         GBLA  &CMPTYPE            COMPRESSION TECHNIQUE UTILIZED
         GBLA  &CCT                IDENTICAL CHARACTER COMPRESSION CT
         GBLA  &REP                PATCH LOADER SWITCH
         GBLA  &TEMP               TEMPORARY SET SYMBOL
         GBLA  &TEMP2              2ND TEMP SET SYMBOL
         GBLA  &A,&B               TEMPORARY VARIABLES
         GBLA  &LOGCLAS
         GBLA  &LOGID              ERROR LOG ID ASSIGNMENT
         GBLA  &NUMPRT
         GBLA  &NUMRDR
         GBLA  &NUMPUN
         GBLA  &CONSOLE
         GBLA  &PRTSIZE            MAXIMUM LENGTH OF PRINT LINE
         GBLA  &WTOSIZE            LENGTH OF CONSOLE INPUT AREA
         GBLA  &PRTCONS            OPTION FOR PRINTING MESSAGES
         GBLA  &LOCCOM             LOCAL COMMAND OPTION
         GBLA  &HOME               INDICATOR FOR HOME LOOP TESTING
         GBLA  &CFCS               CONTROL RECORD FCS
         GBLA  &PFCS(7)            FUNCTION MASK DEFINITIONS
         GBLA  &RFCS(7)            FUNCTION MASK DEFINITIONS
         GBLA  &UFCS(7)            FUNCTION MASK DEFINITIONS
         GBLA  &WFCS(1)            FUNCTION DEFINITIONS
         GBLA  &CRCB               CONTROL RECORD CONTROL BYTE
         GBLA  &PRCB(7)            STREAM DEFINITIONS
         GBLA  &RRCB(7)            STREAM DEFINITIONS
         GBLA  &URCB(7)            STREAM DEFINITIONS
         GBLA  &WRCB(1)            STREAM DEFINITIONS
         GBLA  &CTLM               CONTROL RECORD TANK LIMITS
         GBLA  &PTLM(7)            NUM PRINTER TANK LIMITS
         GBLA  &UTLM(7)            NUM PUNCH TANK LIMITS
         GBLA  &WTLM(1)            CONSOLE TANK LIMITS OUTPUT ONLY
         GBLA  &CBLM               CONTROL RECORD BUFFER LIMITS
         GBLA  &PBLM(7)            NUM PRINTER BUFFER LIMITS
         GBLA  &UBLM(7)            NUM PUNCH BUFFER LIMITS
         GBLA  &WBLM(1)            NUM CONSOLE LIMITS
         GBLA  &PDEV(7)            DEVICE TYPE FOR PRINTERS
         GBLA  &RDEV(7)            DEVICE TYPE FOR READERS
         GBLA  &UDEV(7)            DEVICE TYPE FOR PUNCHES
         GBLA  &WDEV(1)            DEVICE TYPE FOR CONSOLE
         GBLA  &OFCS(1)            OPERATOR COMMAND FCS
         GBLA  &ORCB(1)            OPERATOR COMMAND RCB
         GBLA  &D                  NUMBER OF DUAL READ/PUNCH DEVICES
         GBLA  &S(7)               READ/PUNCH CROSS REFERENCE
         GBLA  &T                  CONFIGURATION WORK VARIABLE
         GBLA  &L                  LENGTH ATTRIBUTE OF ADDR CONSTANTS
         GBLB  &R(8)               READER/PUNCH LOGIC FLOW VARIABLE
         GBLC  &PADR(7)            DEVICE ADDRESSES OF PRINTERS
         GBLC  &RADR(7)            DEVICE ADDRESSES OF READERS
         GBLC  &UADR(7)            DEVICE ADDRESSES OF PUNCHES
         GBLC  &WADR(1)            DEVICE ADDRESSES OF CONSOLE
         GBLC  &ADAPT              COMMUNICATIONS ADAPTER
         GBLC  &NUM
         GBLC  &GEN
         ACTR  500
         TITLE 'H A S P / R J E  *HASPGEN VARIABLES*  '
         SPACE 5
*
*                   CONFIGURATION VARIABLES
*
&RMTID   SETA  13 *****************REMOTE'S IDENTIFICATION
&MACHINE SETA  30                  MODEL OF REMOTE TERMINAL CPU
&SUBMOD  SETA  2                   SUB-MODEL 2 (MODEL 20)
&LINESPD SETA  2000                COMMUNICATION LINE SPEED
&CORESIZ SETA  64 *****************AMOUNT OF CORE AVAILABLE TO PROGRAM
&XPARENT SETC  'YES'               ADAPTER TRANSPARENCY FEATURE
&HICORE  SETA  &CORESIZ            HIGHEST CORE LOCATION AVAILABLE
&HRTPORG SETA  X'80'               ORIGIN OF PROGRAM
&ERRMSGN SETA  10                  MAX NUM ERROR MSG QUEUED
&ERRTXTL SETA  13                  LENGTH OF TEXT + BLANK
*
*        CONFIGURATION
*
&PDEV(1) SETA  1403                PRINTER 1 MACHINE NUMBER
&PDEV(2) SETA  0                   PRINTER 2 MACHINE NUMBER
&PDEV(3) SETA  0                   PRINTER 3 MACHINE NUMBER
&PDEV(4) SETA  0                   PRINTER 4 MACHINE NUMBER
&PDEV(5) SETA  0                   PRINTER 5 MACHINE NUMBER
&PDEV(6) SETA  0                   PRINTER 6 MACHINE NUMBER
&PDEV(7) SETA  0                   PRINTER 7 MACHINE NUMBER
&PADR(1) SETC  '00E'               PRINTER 1 ADDRESS
&PADR(2) SETC  '00F'               PRINTER 2 ADDRESS
&PADR(3) SETC  'FFF'               PRINTER 3 ADDRESS
&PADR(4) SETC  'FFF'               PRINTER 4 ADDRESS
&PADR(5) SETC  'FFF'               PRINTER 5 ADDRESS
&PADR(6) SETC  'FFF'               PRINTER 6 ADDRESS
&PADR(7) SETC  'FFF'               PRINTER 7 ADDRESS
&RDEV(1) SETA  2540                READER 1 MACHINE NUMBER
&RDEV(2) SETA  0                   READER 2 MACHINE NUMBER
&RDEV(3) SETA  0                   READER 3 MACHINE NUMBER
&RDEV(4) SETA  0                   READER 4 MACHINE NUMBER
&RDEV(5) SETA  0                   READER 5 MACHINE NUMBER
&RDEV(6) SETA  0                   READER 6 MACHINE NUMBER
&RDEV(7) SETA  0                   READER 7 MACHINE NUMBER
&RADR(1) SETC  '00C'               READER 1 ADDRESS
&RADR(2) SETC  'FFF'               READER 2 ADDRESS
&RADR(3) SETC  'FFF'               READER 3 ADDRESS
&RADR(4) SETC  'FFF'               READER 4 ADDRESS
&RADR(5) SETC  'FFF'               READER 5 ADDRESS
&RADR(6) SETC  'FFF'               READER 6 ADDRESS
&RADR(7) SETC  'FFF'               READER 7 ADDRESS
&UDEV(1) SETA  2540                PUNCH 1 MACHINE NUMBER
&UDEV(2) SETA  0                   PUNCH 2 MACHINE NUMBER
&UDEV(3) SETA  0                   PUNCH 3 MACHINE NUMBER
&UDEV(4) SETA  0                   PUNCH 4 MACHINE NUMBER
&UDEV(5) SETA  0                   PUNCH 5 MACHINE NUMBER
&UDEV(6) SETA  0                   PUNCH 6 MACHINE NUMBER
&UDEV(7) SETA  0                   PUNCH 7 MACHINE NUMBER
&UADR(1) SETC  '00D'               PUNCH 1 ADDRESS
&UADR(2) SETC  'FFF'               PUNCH 2 ADDRESS
&UADR(3) SETC  'FFF'               PUNCH 3 ADDRESS
&UADR(4) SETC  'FFF'               PUNCH 4 ADDRESS
&UADR(5) SETC  'FFF'               PUNCH 5 ADDRESS
&UADR(6) SETC  'FFF'               PUNCH 6 ADDRESS
&UADR(7) SETC  'FFF'               PUNCH 7 ADDRESS
&WDEV(1) SETA  1052                CONSOLE MACHINE NUMBER
&WADR(1) SETC  '01F'               CONSOLE ADDRESS
&ADAPT   SETC  '020'               ADDRESS OF COMMUNICATIONS ADAPTER
         AIF   (&HICORE GT 32).HISKP1
&L       SETA  2                   LENGTH ATTRIBUTE OF ACONS
         AGO   .HISKP
.HISKP1  ANOP
&L       SETA  4                   LENGTH ATTRIBUTE OF ACONS
.HISKP   ANOP
&R(1)    SETB  1                   NO NON DUAL READER
&R(2)    SETB  1                   NO DUAL 2520
&R(3)    SETB  1                   NO DUAL 1442
&R(4)    SETB  1                   NO 2540 PUNCH
&R(5)    SETB  1                   NO NON DUAL PUNCH
&R(6)    SETB  1                   NOT MOD 20
&R(7)    SETB  1                   NO DUAL 2560
&R(8)    SETB  1                   NO SINGLE POCKET 1442
&PRTSIZE SETA  132                 MAXIMUM PRINT LINE SIZE
&WTOSIZE SETA  120                 LENGTH OF CONSOLE INPUT AREA
*
*                   INTERNAL VARIABLES
*
&NUMBUFS SETA  8                   NUMBER OF TP BUFFERS
&TPBFSIZ SETA  516 ****************DEFAULT BUFFER SIZE
&MLBFSIZ SETA  400                 MULTI-LEAVING BUFFER SIZE      V03.1
&TPBFSIZ SETA  &MLBFSIZ            TRANSMISSION BUFFER SIZE
&TPBFSIZ SETA  &TPBFSIZ+&TPBFSIZ-&TPBFSIZ/2*2    FORCE BUFSIZE EVEN
&NUMTANK SETA  5                   NUMBER OF DECOMPRESSION TANKS
&CMPTYPE SETA  2                   COMPRESSION TECHNIQUE INDICATOR
*                                  (0 = NO COMPRESSION )
*                                  (1 = TRAILING BLANK ELIMINATION )
*                                  (2 = BLANK COMPRESSION ONLY )
*                                  (3 = COMPRESS ALL IDENTICAL CHARS )
&CCT     SETA  4                   MINIMUM EQUAL CHARACTERS TO COMPRESS
&LOGCLAS SETA  0                   LOWEST ERROR SEVERITY TO LOG
&GEN     SETC  'GEN'                                              U0019
&PRTCONS SETA  0                   PRINT CONSOLE MESSAGES OPTION
&LOCCOM  SETA  0                   LOCAL COMMAND OPTION
&HOME    SETA  0                   HOME LOOP OFF
*
*        FUNCTION CONTROL MASKS FOR TCTS
*
&CFCS    SETA  X'0000'             CONTROL RECORD PROCESSOR
&PFCS(1) SETA  X'0800'             PRINTER 1
&PFCS(2) SETA  X'0400'             PRINTER 2
&PFCS(3) SETA  X'0200'             PRINTER 3
&PFCS(4) SETA  X'0100'             PRINTER 4
&PFCS(5) SETA  X'0008'             PRINTER 5
&PFCS(6) SETA  X'0004'             PRINTER 6
&PFCS(7) SETA  X'0002'             PRINTER 7
&UFCS(1) SETA  X'0001'             PUNCH 1
&UFCS(2) SETA  X'0002'             PUNCH 2
&UFCS(3) SETA  X'0004'             PUNCH 3
&UFCS(4) SETA  X'0008'             PUNCH 4
&UFCS(5) SETA  X'0100'             PUNCH 5
&UFCS(6) SETA  X'0200'             PUNCH 6
&UFCS(7) SETA  X'0400'             PUNCH 7
&WFCS(1) SETA  X'0040'             CONSOLE
&OFCS(1) SETA  X'0000'             OPERATOR COMMAND FCS
&RFCS(1) SETA  X'0800'             READER FUNCTION 1
&RFCS(2) SETA  X'0400'             READER FUNCTION 2
&RFCS(3) SETA  X'0200'             READER FUNCTION 3
&RFCS(4) SETA  X'0100'             READER FUNCTION 4
&RFCS(5) SETA  X'0008'             READER FUNCTION 5
&RFCS(6) SETA  X'0004'             READER FUNCTION 6
&RFCS(7) SETA  X'0002'             READER FUNCTION 7
*        RECORD CONTROL BYTES
*
&CRCB    SETA  X'80'               CONTROL RECORD CONTROL BYTE
&PRCB(1) SETA  X'94'               STREAM 1 PRINT RECORDS
&PRCB(2) SETA  X'A4'               STREAM 2 PRINT RECORDS
&PRCB(3) SETA  X'B4'               STREAM 3 PRINT RECORDS
&PRCB(4) SETA  X'C4'               STREAM 4 PRINT RECORDS
&PRCB(5) SETA  X'D4'               STREAM 5 PRINT RECORDS
&PRCB(6) SETA  X'E4'               STREAM 6 PRINT RECORDS
&PRCB(7) SETA  X'F4'               STREAM 7 PRINT RECORDS
&URCB(1) SETA  X'95'               STREAM 1 PUNCH RECORDS
&URCB(2) SETA  X'A5'               STREAM 2 PUNCH RECORDS
&URCB(3) SETA  X'B5'               STREAM 3 PUNCH RECORDS
&URCB(4) SETA  X'D5'               STREAM 3 PUNCH RECORDS
&URCB(4) SETA  X'C5'               STREAM 4 PUNCH RECORDS
&URCB(5) SETA  X'D5'               STREAM 5 PUNCH RECORDS
&URCB(6) SETA  X'E5'               STREAM 6 PUNCH RECORDS
&URCB(7) SETA  X'F5'               STREAM 7 PUNCH RECORDS
&WRCB(1) SETA  X'91'               MESSAGE TO TERM OPERATOR
&ORCB(1) SETA  X'92'               OPERATOR COMMAND RCB
&RRCB(1) SETA  X'93'               STREAM 1 TO HASP
&RRCB(2) SETA  X'A3'               STREAM 2 TO HASP
&RRCB(3) SETA  X'B3'               STREAM 3 TO HASP
&RRCB(4) SETA  X'C3'               STREAM 4 TO HASP
&RRCB(5) SETA  X'D3'               STREAM 5 TO HASP
&RRCB(6) SETA  X'E3'               STREAM 6 TO HASP
&RRCB(7) SETA  X'F3'               STREAM 7 TO HASP
*
*        THE FOLLOWING VALUES REPRESENT THE LIMIT OF QUEUING
*        FOR EACH INDICATED DEVICE.
*        THE 'BL' VALUES REPRESENT THE MAXIMUM NUMBER OF BUFFERS
*        FROM HASP WHICH WILL BE QUEUED ON THE DEVICE.
*        THE 'TL' VALUES REPRESENT THE NUMBER OF DECOMPRESSED
*        RECORDS WHICH WILL BE QUEUED.NOTE THAT SINCE ONE
*        DECOMPRESSED RECORD WILL ALWAYS BE IN PROCESS,THE DEVICE
*        WILL REQUIRE ONE TANK MORE THAN THE TANK LIMIT(A 2540
*        PUNCH REQUIRES 2 MORE FOR ERROR RECOVERY PURPOSES).
*
         SPACE 3
*
*        DECOMPRESSION TANK LIMITS
*
*              PRINTERS
&PTLM(1) SETA  1                   PRINTER 1-DECOMPRESSION LIMIT
&PTLM(2) SETA  &PTLM(1)            PRINTER 2-DECOMPRESSION LIMIT
&PTLM(3) SETA  &PTLM(1)            PRINTER 3-DECOMPRESSION LIMIT
&PTLM(4) SETA  &PTLM(1)            PRINTER 4-DECOMPRESSION LIMIT
&PTLM(5) SETA  &PTLM(1)            PRINTER 5-DECOMPRESSION LIMIT
&PTLM(6) SETA  &PTLM(1)            PRINTER 6-DECOMPRESSION LIMIT
&PTLM(7) SETA  &PTLM(1)            PRINTER 7-DECOMPRESSION LIMIT
*              PUNCHES
&UTLM(1) SETA  1                   PUNCH 1 - DECOMPRESSION LIMIT
&UTLM(2) SETA  &UTLM(1)            PUNCH 2 - DECOMPRESSION LIMIT
&UTLM(3) SETA  &UTLM(1)            PUNCH 3 - DECOMPRESSION LIMIT
&UTLM(4) SETA  &UTLM(1)            PUNCH 4 - DECOMPRESSION LIMIT
&UTLM(5) SETA  &UTLM(1)            PUNCH 5 - DECOMPRESSION LIMIT
&UTLM(6) SETA  &UTLM(1)            PUNCH 6 - DECOMPRESSION LIMIT
&UTLM(7) SETA  &UTLM(1)            PUNCH 7 - DECOMPRESSION LIMIT
*              CONSOLE
&WTLM(1) SETA  &NUMTANK-2          CONSOLE DECOMPRESSION LIMIT
*              CONTROL RECORD PROCESSOR
&CTLM    SETA  &NUMTANK            CONTROL DECOMPRESSION LIMIT
*
*        BUFFER QUEUING LIMITS
*
*              PRINTERS
&PBLM(1) SETA  2                   PRINTER 1-BUFFER QUEUING LIMIT
&PBLM(2) SETA  &PBLM(1)            PRINTER 2-BUFFER QUEUING LIMIT
&PBLM(3) SETA  &PBLM(1)            PRINTER 3-BUFFER QUEUING LIMIT
&PBLM(4) SETA  &PBLM(1)            PRINTER 4-BUFFER QUEUING LIMIT
&PBLM(5) SETA  &PBLM(1)            PRINTER 5-BUFFER QUEUING LIMIT
&PBLM(6) SETA  &PBLM(1)            PRINTER 6-BUFFER QUEUING LIMIT
&PBLM(7) SETA  &PBLM(1)            PRINTER 7-BUFFER QUEUING LIMIT
*              PUNCHES
&UBLM(1) SETA  2                   PUNCH 1 - BUFFER QUEUING LIMIT
&UBLM(2) SETA  &UBLM(1)            PUNCH 2 - BUFFER QUEUING LIMIT
&UBLM(3) SETA  &UBLM(1)            PUNCH 3 - BUFFER QUEUING LIMIT
&UBLM(4) SETA  &UBLM(1)            PUNCH 4 - BUFFER QUEUING LIMIT
&UBLM(5) SETA  &UBLM(1)            PUNCH 5 - BUFFER QUEUING LIMIT
&UBLM(6) SETA  &UBLM(1)            PUNCH 6 - BUFFER QUEUING LIMIT
&UBLM(7) SETA  &UBLM(1)            PUNCH 7 - BUFFER QUEUING LIMIT
*              CONSOLE
&WBLM(1) SETA  3                   CONSOLE BUFFER QUEUING LIMIT
*              CONTROL RECORD PROCESSOR
&CBLM    SETA  &NUMBUFS            CONTROL BUFFER QUEUING LIMIT
.NOSETCS ANOP
         PRINT &GEN
 TITLE ' L O A D E R  --  PUNCHES M/20 OR NON 20 LOADER DECKS'
         SPACE 20
         AIF   (&MACHINE EQ 20).LOAD20
         AGO   .SKIP
.LOAD20  ANOP
         PUNCH '}+
               K{
.SKIP    ANOP
 TITLE 'G L O B A L   S Y M B O L   D E F I N I T I O N S'
         SPACE 3
HASPRTP  START 0
*
*                   DEBUGGING VARIABLES
*
&DEBUG   SETA  1
&TRACE   SETA  0                   NO TRACE DEGRADATION
&REP     SETA  1                   PATCH MODE ON
*
*        CONFIGURATION DEPENDENT EQUATES
*
         $CONFIG
&A       SETA  1
*
*        SYMBOLIC DEFINITIONS USED TO REFER TO TCT LOCATIONS
*        ** SEE GLOBAL STORAGE FOR UNIQUE PROCESSORS EQUIVALENT DEFS
*
TCTDSECT DSECT
         DEFTCT T                  DEFINE TCT SYMBOLS
*
*        TCTSTAT BIT DEFINITIONS
*
TCT1403  EQU   X'08'               TCT STATUS FLAGS FOR 1403, SW ON
TCT1443  EQU   X'08'               TCT STATUS FLAGS FOR 1443, SW ON
TCT2203  EQU   X'08'               TCT STATUS FLAGS FOR 2203, SW ON
TCT2501  EQU   X'00'               TCT STATUS FLAGS FOR 2501
TCT2520  EQU   X'00'               TCT STATUS FLAGS FOR 2520
TCT25200 EQU   X'01'               TCT STATUS FLAGS FOR 2520 DUAL
TCT1442  EQU   X'08'               TCT STATUS FLAGS FOR 1442
TCT14420 EQU   X'02'               TCT STATUS FLAGS FOR 1442 DUAL
TCT2540  EQU   X'04'               TCT STATUS FLAGS FOR 2540
TCT25600 EQU   X'02'               TCT STATUS FLAGS FOR 2560 DUAL
TCT2560  EQU   X'00'               TCT STATUS FLAGS FOR 2560
TCT1052  EQU   X'10'               TCT STATUS FLAGS FOR 1052
TCT2152  EQU   X'10'               TCT STATUS FLAGS FOR 2152
TCTREL   EQU   X'04'               INTERLOCK RELEASE REQ FOR CONSOLE
TCTDUAL  EQU   TCT14420+TCT25200   EITHER DUAL DEVICE
TCTOPEN  EQU   X'80'               TCT OPEN BIT
TCTACT   EQU   X'40'               ACTION REQUIRED ON THIS TCT
TCTREQ   EQU   X'08'               CONSOLE REQUEST BIT
TCTPRTSW EQU   X'08'               PRINTER AVAILABLE FOR CONSOLE
TCTSTOP  EQU   X'20'               TCT IS IN STOPPED STATE
*                                  .S COMMAND REQUIRED TO START UP
*        TCTUCB BIT DEFINITIONS
         SPACE 2
TCTNOINT EQU   X'80'               NO INTERRUPTS ON DEVICE ALLOWED
         SPACE 2
*        DUMMY TCT DEVICE DEFINITIONS FOR CTLTCT
         SPACE 2
C0       EQU   X'00'               DUMMY OPCODE FOR CONTROL
C01      EQU   X'00'               DUMMY OPCODE FOR CONTROL
CF0      EQU   X'00'               DUMMY FLAGS FOR CCW
TCT0     EQU   0                   DUMMY DEVICE STATUS
         SPACE 2
***      TCTECB BIT DEFINITIONS
         SPACE 2
TCTBUSY  EQU   X'10'               DEVICE BUSY BIT
         SPACE 2
***      TCTSENSE BIT DEFINITIONS (FIRST BYTE)
         SPACE 1
TCTINREQ EQU   X'40'               INTERVENTION REQUIRED BIT
         SPACE 2
 TITLE '                                   COMMUNICATIONS BUFFER DSECT'
         SPACE 20
BUFDSECT DSECT                     TRANSMISSION BUFFER DSECT
BUFBEGIN DS    0F                  BEGINNING OF THE BUFFER
BUFCHAIN $ACON 0                   BUFFER CHAIN FIELD
BUFCOUNT DS    H                   COUNT OF BYTES TO TRANSMIT
BUFSTAT  DS    C                   BUFFER STATUS BYTE
BUFSTART DS    CL2                 TRANSMISSION CONTROL BYTES
BUFBCB   DS    C                   BLOCK CONTROL BYTE
BUFFCS   DS    CL2                 FUNCTION CONTROL SEQUENCE
BUFDATA  DS    (&TPBFSIZ-5)C       DATA PORTION OF TP BUFFER
BUFEND   DS    0F                  FULL ALIGNMENT FOR THE NEXT
         SPACE  8
*
*              BUFFER STATUS BIT DEFINITIONS
*
         SPACE 2
BUFFAKE  EQU   X'01'               DUMMY BUFFER INDICATOR
BUFRESP  EQU   X'02'               RESPONSE ONLY IN BUFFER
BUFNAK   EQU   X'04'               NAK RESPONSE BEING SENT
BUFTEXT  EQU   X'08'               BUFFER CONTAINS TEXT INFORMATION
BUFUCHEK EQU   X'10'               UNIT CHECK EXPECTED
 TITLE '                                   DECOMPRESSION TANK DSECT'
         SPACE 20
TANKDSEC DSECT                     UNIT RECORD TANK DSECT
TANKCHN  $ACON ,                   TANK CHAIN FIELD
TANKRCB  DS    C                   TANK RECORD CONTROL BYTE
TANKSRCB DS    C                   TANK SUB-RECORD CONTROL BYTE
TANKCNT  DS    H                   COUNT OF DATA BYTES IN TANK
TANKDATA DS    CL&PRTSIZE          DATA AREA IN THE TANK
         SPACE 20
 TITLE '                                 LOG TABLE DSECT'
         SPACE 20
LOGDSECT DSECT                     LOG DESECT
LOGID    DS    C                   LOG IDENTIFICATION
LOGCLASS DS    C                   SEVERITY  CODE OF MESSAGE
LOGCOUNT DS    H                   COUNT OF TOTAL ERRORS
LOGTEXT  DS    CL(&ERRTXTL-1)      TEXT OF MESSAGE
LOGEND   DS    0C                  END OF DSECT
 TITLE ' H A S P / R J E  *ORIGIN AND LOAD CONTROL*'
         SPACE 5
HASPRTP  CSECT
*OLD*    AIF   (&MACHINE EQ 20).ORG20
 TITLE 'H A S P / R J E  *SYMBOLIC REGISTER DEFINITIONS* '
HASPRJE  EQU   *
         AIF   (&MACHINE EQ 20).EIGHTR  SKIP FIRST 8 REGS IF 360/20
R0       EQU   0                   *
R1       EQU   1                   *
R2       EQU   2                   *
R3       EQU   3                   *
R4       EQU   4                   *
R5       EQU   5                   *
R6       EQU   6                   *
R7       EQU   7                   *
.EIGHTR  ANOP                      MODEL 20 BEGIN
R8       EQU   8                   *
R9       EQU   9                   *
R10      EQU   10                  *
R11      EQU   11                  *
R12      EQU   12                  *
R13      EQU   13                  *
R14      EQU   14                  *
R15      EQU   15                  *
TCTR     EQU   7                   TCT BASE REGISTER
         SPACE 3
*
*              REGISTER ASSIGNMENTS AND/OR TYPICAL ASSIGNMENTS
*
         SPACE 3
*              R15 = WORK REG (SECONDARY LINK OR PARAMETER REGISTER)
*              R14 = LINK REG
*              R13 = BUFFER POINTER
*              R12 = RESERVED
*              R11 = WORK
*              R10 = WORK
*              R9  = WORK
*              R8  = PARAMETER REGISTER
         AIF   (&MACHINE EQ 20).X1
*              R7  = WORK          READER ONLY
*              R6  = WORK
*              R5  = WORK
*              R4  = WORK
*              R3  = BASE REGISTER
*              R2  = BASE REGISTER
*              R1  = BASE REGISTER
*              R0  = ALTERNATE PARAMETER REG
.X1      AIF   (&MACHINE EQ 20).BASOK1
         STM   14,12,12(13)         STANDARD                      U0019
         BALR  R3,0                      LINKAGE                  U0019
         USING *,R3,R4,R5,R6                   STUFF              U0019
         LA    R4,4095                              -             U0019
         LA    R4,1(0,R4)                            -            U0019
         LA    R5,0(R4,R4)                            -           U0019
         LA    R6,0(R4,R5)                   -                    U0019
         AR    R6,R3                          -                   U0019
         AR    R5,R3                           -                  U0019
         AR    R4,R3                            -                 U0019
         L     R1,0(R1)     GET PARM POINTER                      U0019
         LH    R2,0(R1)     LOAD PARM BYTE COUNT                  U0019
         SH    R2,=H'1'     REDUCE BY 1 FOR MOVE INST.            U0019
         STC   R2,PARMOV+1  PUT COUNT IN MOVE INST.               U0019
PARMOV   MVC   SIGNON(1),2(R1)  MOVE THE PARM TO SIGNON CARD      U0019
         OPEN  (READR)                                            U0019
         OPEN  (ADAPTR)                                           U0019
         OI    ADAPTR+44,X'0C'       NO OS ERROR RECOVERY ON ADAPTU0019
         OPEN  (PUNCH,(OUTPUT))                                   U0019
         OPEN  (P,(OUTPUT))                                       U0019
         OPEN  (PRINTR,(OUTPUT))                                  U0019
         ST    13,KSAV13        SAVE 13 FOR OS RETURN             U0019
         SR    R10,R10                                            U0019
         LH    R11,READR+62   GET BLKSIZE FROM DCB                U0019
         LTR   R11,R11             CHECK FOR BLKSIZE=0         UF099
         BZ    BADBLOCK            YES, ABORT                  UF099
         D     R10,=F'80'      CHECK THAT BLOCK SIZE IS           U0019
         LTR   R10,R10            A MULTIPLE OF 80                U0019
         BNZ   BADBLOCK        IF NOT GO QUIT                     U0019
         SR    R0,R0                                              U0019
         LH    R0,READR+62     GET BLKSIZE FROM DCB FOR GETMAIN   U0019
         GETMAIN R,LV=(0)                                         U0019
         ST    R1,RDRECB+12    SAVE BUFFER ADDRESS IN DECB        U0019
         B     INEWTABL                                           U0019
BADBLOCK WTO   'READER BLOCK SIZE NOT A MULTIPLE OF 80',       UF099   +
               ROUTCDE=11                                      UF099
         B     EOJ  GO HOME SON..YOU BLEW IT                      U0019
         AGO   .BASOK2
.BASOK1  ANOP
         USING HASPRJE-&HRTPORG,0,1,2,3 PROVIDE FOR 16K
         DS    (X'24')C            SPACER FOR MODEL 20
.BASOK2  ANOP
         AIF   (&CONSOLE EQ 0 AND &PRTCONS EQ 0).ERRLOG
KSAV13   DC    F'0'                                               U0019
         DS    0D                                                 U0019
TIMEXIT  STM   14,12,12(13)      SAVE TIME REGS                   U0019
         ST    13,12(15)         SAVE REG 15                      U0019
         B     30(15)            BRANCH AROUND CONSTANTS          U0019
         DC    F'0'              R15 SAVE AREA                    U0019
         DC    A(TIMECB)       TIME ECB POINTER                   U0019
         L     13,12(15)       RESTORE REGS FOR RETURN FROM TIMER U0019
         LM    14,12,12(13)      _                                U0019
         BR    14                 END OF TIME EXIT                U0019
         L     11,16(15)       LOAD POINTER TO ECB                U0019
         MVI   5(11),X'00'     CLEAR SWITCH                       U0019
         CLI   4(11),X'FF'     CHECK OTHER SWITCH                 U0019
         BE    20(15)          IF THERE HAS BEEN LINE ACTIVITY SINU0019
         LR    8,15              LAST STIMER, DONT POST..OTHERWISEU0019
         POST  (11)                 POST TIMECB TO HANDSHAKE WITH U0019
         LR    15,8       BACK TO RETURN                          U0019
         B     20(15)                                             U0019
 TITLE 'ERROR MESSAGE LOG TABLE'
         SPACE 10
         AIF   (&ERRMSGN GE 8).ERRLOGA
&ERRMSGN SETA  8
.ERRLOGA ANOP
         SPACE 5
*
*        ERROR MESSAGE LOG TABLE AND POINTERS
*
         SPACE 3
$LOGTAB  DS    &ERRMSGN.XL4        ERROR MESSAGE LOG TABLE
$LOGEND  $ACON (*)                 END OF LOG TABLE
$LOGOUT  $ACON ($LOGTAB-4)         ADDRESS OF LAST MESSAGE WRITTEN
$LOGLAST $ACON ($LOGTAB-4)         ADDRESS OF LAST MESSAGE LOGGED
.ERRLOG  ANOP
         TITLE 'H A S P / R T P  * C O M M U T A T O R  *  '
         SPACE 12
         PRINT GEN
$START   $GENCOM
         PRINT &GEN
         SPACE 3
$CHNTEMP $ACON 0                   DISABLED TEMPORARY WORK
$LOGINFO DC    A(0)                INFORMATION TO BE LOGGED
$LOGSAVE $ACON 0                   $LOG REG SAVE AREA
$COMDCOM DS    0C
$INPCOM  DS    0C
$DATCOM  DS    0C
$ROUCOM  DS    0C
 TITLE 'CONTROL PROCESSOR TOTAL CONTROL TABLE  --  C T C T'
         PRINT GEN
         SPACE 10
&B       SETA  1                   SET SYMB TO CHAIN TCTS TOGETHER
&A       SETA  1
&D       SETA  1                   SIGNAL ORG TO GENTCT
$CTLTCT  $GENTCT C,&CFCS,&CRCB,FFF,0,&CTLM,&CBLM,&CFCS,&CRCB CONT TCT
&A       SETA  1
&D       SETA  &CONSOLE            SIGNAL DSECT OR ORG TO GENTCT
         AIF   (&CONSOLE EQ 0 AND &PRTCONS EQ 0).TCTWTO
 TITLE 'CONSOLE TOTAL CONTROL TABLE  -- W T C T'
$CONTCT  $GENTCT W,&WFCS(&A),&WRCB(&A),&WADR(&A),&WDEV(&A),&WTLM(&A),  C
               &WBLM(&A),&OFCS(&A),&ORCB(&A) CONSOLE TCT
.TCTWTO  ANOP
&D       SETA  &NUMPRT             SIGNAL DSECT OR ORG TO GENTCT
.TCTPRTL AIF   (&A GT &NUMPRT).TCTPRT
 TITLE 'PRINTER TOTAL CONTROL TABLES'
         $GENTCT P,&PFCS(&A),&PRCB(&A),&PADR(&A),&PDEV(&A),&PTLM(&A),  C
               &PBLM(&A),&PFCS(&A),&PRCB(&A) PRINTER TCT
&A       SETA  &A+1
         AGO   .TCTPRTL
.TCTPRT  ANOP
&A       SETA  1
&D       SETA  &NUMRDR             SIGNAL DSECT OR ORG TO GENTCT
.TCTRDRL AIF   (&A GT &NUMRDR).TCTRDR
 TITLE 'READER TOTAL CONTROL TABLES'
         AIF   (&S(&A) NE 0).TCTRDR1
         $GENTCT R,&RFCS(&A),&RRCB(&A),&RADR(&A),&RDEV(&A),0,0,        C
               &RFCS(&A),&RRCB(&A) READER TCT
         AGO   .TCTRDR2
.TCTRDR1 ANOP
&T       SETA  &S(&A)
         $GENTCT R,&UFCS(&T),&URCB(&T),&RADR(&A),&RDEV(&A),&UTLM(&T),  C
               &UBLM(&T),&RFCS(&A),&RRCB(&A) DUAL READER TCT
&T       SETA  &B-1
.TCTRDR2 ANOP
&A       SETA  &A+1
         AGO   .TCTRDRL
.TCTRDR  ANOP
&A       SETA  1
&D       SETA  &NUMPUN             SIGNAL DSECT OR ORG TO GENTCT
.TCTPUNL AIF   (&A GT &NUMPUN).TCTPUN
 TITLE 'PUNCH TOTAL CONTROL TABLES  --  U T C T'
         $GENTCT U,&UFCS(&A),&URCB(&A),&UADR(&A),&UDEV(&A),&UTLM(&A),  C
               &UBLM(&A),&UFCS(&A),&URCB(&A) PUNCH TCT
&A       SETA  &A+1
         AGO   .TCTPUNL
.TCTPUN  ANOP
 TITLE 'MISCELLANEOUS GLOBAL STORAGE'
$TCT&B   EQU   0 
         PRINT &GEN
         SPACE 3
.NOGTCTS ANOP
*
*              E R R O R  L O G  T A B L E
*
LOGTABLE DS    0H
         ORG   *+X'92'             ORG OVER THE LOG TABLE
$ERRTAB  EQU   LOGTABLE-LOGEND+LOGDSECT ERROR LOG TABLE FOR CE
 SPACE 3
*
*                  BEGINNING OF QUEUE CHAINS
*
 SPACE 3
$TEMP    DC    H'0'                GLOBAL TEMPORARY WORK
$BUFPOOL $ACON $1STBUF             BUFFER POOL CHAIN CONTROL WORD
$TANKPOL $ACON $1STTANK            TANK QUEUE CONTROL WORD
$OUTBUF  $ACON 0                   XMISSION BUFFER CHAIN CTL WORD
$CORESIZ $ACON 0                   SYSTEM MEMORY SIZE
$FCSOUT  DS    0H                  OUTGOING FUNCTION CONTROL SEQUENCE
         DC    X'8FCF'             ALL FUNCTIONS PERMITTED
$FCSIN   DC    X'8FCF'             INCOMING FCS FROM HASP
         AIF   (&MACHINE NE 20).N20CON
$WAITCON DC    H'160'              DELAYING CONSTANT FOR MOD 20
         AGO   .N30CON
.N20CON  ANOP
$WAITCON DC    H'1500'             DELAYING CONSTANT FOR MODEL 30
.N30CON  ANOP
 TITLE '$ C O N T R O L  -- INPUT CONTROL RECORD PROCESSOR  '
*
*
$CRTN1   NULL
$CCOMM1  EQU   $CONTCOM
CFLAGS   EQU   0                   DUMMY CCW
COPCODE  EQU   0                   DUMMY CCW
*
$CONTROL NULL  *                   ENTRY POINT
        $LA    R13,$CTLTCT         GET CONTROL TCT
         USING TCTDSECT,R13        *
        $DCHAIN TCTTANK,R8,NOSSM   GET A TANK OF DATA
         BNZ   MPROCESS            BR IF GOTTEN
         MVI   $CONTCOM+1,0        NONE... CLOSE ENTRY
         B     $CONTCOM+4          AND EXIT
*
*              PROCESS A CONTROL RECORD
*
         SPACE 3
MPROCESS NULL  *                   *
         $TCTPOST T,R10            SHOW TANK GOTTEN
         DROP  R13                 DONE FOR NOW
         USING TANKDSEC,R8         *
         UNPK  MTEMP+1(1),TANKRCB(1) SWAP DIGITS
         NI    MTEMP+1,7           TURN OFF CONTROL BIT        UF099
         LH    R10,MTEMP           GET CTL FUNCTION TYPE
         AR    R10,R10             DOUBLE IT
         $LA   R9,MCONTTAB-2       START OF CTL TYPE TABLE
         AR    R9,R10              R9 = CORRECT TABLE ENTRY
         LH    R9,0(0,R9)          R9 = CONTROL ADDRESS
         STH   R9,*+6              ENTER ROUTINE
         B     *-*
         EJECT
*
*              SUBROUTINE TO FIND TCT CORRESPONDING TO SRCB FUNCTION
*                R14=RETURN , CC NE 0 -R13 CONTAINS TCT,CC=0-NOT FOUND
         SPACE 3
MTCTFIND NULL  *                   ENTRY POINT
        $LA    R13,$TCT1           FIRST TCT
         USING TCTDSECT,R13        ADDRESSABILITY
MNEXTTCT NULL  *                   *
         CLC   TCTRCB,TANKSRCB     IS THIS CORRECT TCT
         BE    MTCTOK              BR IF YES
         AIF   (&R(2) AND &R(3) AND &R(7)).MDUAL
         CLC   TCTINRCB,TANKSRCB   TEST FOR CORRECT TCT HERE
         BE    MTCTOK              BR IF YES
.MDUAL   ANOP
        $LOAD  R13,TCTNEXT         NO... TO NEXT
        $LTR   R13,R13             IS THIS ALL...
         BNZ   MNEXTTCT            BR IF MORE
         BR    R14                 RETURN WITH COND. CODE = 0
MTCTOK  $LTR   R14,R14             SET COND. CODE NON-ZERO
         BR    R14                 AND RETURN
         EJECT
         SPACE 5
*
*              SUBROUTINE TO $TPPUT AN ANSWERING CTL RECORD
*                   R8 = TANKADDR
         SPACE 3
MPUT     NULL  *                   ENTRY POINT
         BAS   R14,$TPPUT          GO PUT RECORD
         BNZ   MEXIT               EXIT IF ACCEPTED
         MVC   $CONTCOM+2(2),MREPUTA    SET COMUTATOR RE-ENTRY
        $STO   R8,MTANK            SAVE TANK ADDR
         B     $CONTCOM+4          EXIT TO COMUTATOR
MREPUT   NULL  *                   RETRY PUTTING RECORD
        $LOAD  R8,MTANK            RESTORE TANK ADDR
         BAS   R14,$TPREPUT        TRY IT
         BZ    $CONTCOM+4          CYCLE IF STILL NOT ACCEPTED
MEXIT    NULL  *                   ENTRY AT END OF PROCESSING
        $FREE  $TANKPOL,R8,NOENB   FREE TANK
         MVC   $CONTCOM+2(2),MCONTROL     RESET COMUTATOR
         B     $CONTROL            AND TRY NEXT TANK
MTANK   $ACON  0                   TANK REG STORAGE
MTEMP    DC    H'0'                TEMP STORAGE (HI-BYTE ALWAYS ZERO)
MREPUTA  DC    S(MREPUT)           COMMUTATOR ADJUSTMENT ADDR
MCONTROL DC    S($CONTROL)         COMMUTATOR ADJUSTMENT ADDR
MCONTTAB NULL  *                   CONTROL TYPE BRANCH TABLE
*        DC    S(MC0)         000  RESERVED
         DC    S(MC1)         001  START FUNCTION REQUEST
         DC    S(MC2)         010  START FUNCTION PERMISSION
         DC    S(MC3)         011  RESERVED
         DC    S(MC4)         100  RESERVED
         DC    S(MC5)         101  RESERVED
         DC    S(MC6)         110  RESERVED
         DC    S(MC7)         111  GENERAL CONTROL TYPE
         EJECT
         SPACE 3
*
* MC0          CONTROL RECORD , TYPE = 000 (RESERVED)
*
         SPACE 3
*
*              RESERVED FOR FUTURE USE
*
MC0      EQU   MEXIT               TO DEFINE SYMBOL
         SPACE 3
*
* MC1          CONTROL RECORD , TYPE = 001(REQUEST TO START FUNCTION)
*
         SPACE 3
MC1      NULL  *                   *
*
         BAS   R14,MTCTFIND        GO FIND TCT
         BNZ   MTCTSET             BR IF FOUND
        $TRACE SSM=YES
         B     MEXIT               IGNORE REQUEST
MTCTSET  NULL  *                   CORRECT TCT FOUND
         NI    TCTSTAT,255-TCTOPEN SHOW USE
         MVZ   TANKRCB,=X'A0'      CHANGE REQUEST TO PERMISSION
         B     MPUT                AND SEND IT
         SPACE 3
*
* MC2          CONTROL RECORD , TYPE = 010(PERMISSION TO START FCN)
*
         SPACE 3
MC2      NULL  *                   ENTRY POINT
        $TRACE SSM=YES
         BAS   R14,MTCTFIND        GO LOOK-UP TCT
         BZ    MEXIT               IGNORE IF NOT FOUND
        $LOAD  R14,TCTCOM          GET COMUTATOR ENTRY
         MVI   1(R14),X'F0'        OPEN IT
         NI    TCTSTAT,255-TCTOPEN SHOW OPEN
         B     MEXIT               AND EXIT
         SPACE 3
*
* MC3          CONTROL RECORD , TYPE = 011 (RESERVED)
         SPACE 3
MC3      EQU   MEXIT               NOT YET DEFINED
         SPACE 3
*
* MC4          CONTROL RECORD , TYP = 100 (RESERVED)
*
         SPACE 3
MC4      EQU   MEXIT               NOT YET DEFINED
         SPACE 3
*
* MC5          CONTROL RECORD , TYPE = 101 (RESERVED)
*
         SPACE 3
MC5      EQU   MEXIT               TO DEFINE SYMBOL
*                                  FUNCTION IS NOT YET SUPPORTED
         SPACE 3
*
* MC6          CONTROL RECORD , TYPE = 110(RESERVED)
*
         SPACE 3
*
*              THIS CONTROL TYPE IS CURRENTLY UNDEFINED BUT IS
*              RESERVED FOR FUTURE USE.
*
MC6      EQU   MEXIT               TO DEFINE SYMBOL
         SPACE 3
*
* MC7          CONTROL RECORD , TYPE = 111 (GENERALIZED CONTROL)
*                                          (TYPE INDICATED IN SRCB)
*
         SPACE 3
MC7      DS    0H                  ENTRY POINT                 UF099
         CLI   TANKSRCB,X'C2'      DISCONNECT SEQUENCE?        UF099
         BE    EOJ                 YES, SHUT DOWN THE REMOTE   UF099
         SPACE 1                                               UF099
         B     MEXIT               ELSE TREAT AS NOT SUPPORTED UF099
         SPACE 3
         DROP  R8,R13
         PRINT &GEN
         AIF   (&NUMPRT EQ 0).PRTNSKP
 TITLE '$ P R T N 1  --  PRINT SERVICE PROCESSOR'
&A       SETA  0
*
*        BASE REGISTER ASSIGNMENT
*
         USING TANKDSEC,R8
         AIF   (&NUMPRT EQ 1).PSK1
         USING PCTDSECT,TCTR
.PSK1    ANOP
         WRITE PRTECB,SF,PRINTR,PRTLINE,'S',,,,,MF=L              U0019
$PRTN1   NULL
PNEXT    EQU   *                   BASIC LOOP
         $GETTNK P,R8,R9,EMPTY=WAIT GET NEXT TANK TO PRINT
         CLI   TANKCNT+1,0         TEST FOR END OF JOB
         AIF   (&PRTCONS EQ 0).PSK5
         BNE   PTSTRCB             IF NOT ZERO COUNT TEST TYPE
         OI    PCTSTAT,TCTPRTSW    SET PRINTER AVAILABLE
         OI    $WCOMM1+1,X'F0'     TURN ON CONSOLE COMMUTATOR GATE
         MVC   TANKRCB(TANKDATA-TANKRCB+1),=AL1(&WRCB(1),X'B1',0,1,64)
*                                  SET TO PRINT BLANK LINE AND EJECT
         OI    PCTSTAT,TCTREL      SET SUPPRESS EJECT FLAG
PTSTRCB  CLC   TANKRCB,PCTRCB      IS IT PRINTER RCB
         BNE   PSETCC              IF NOT SET UP FOR PRINT CONSOLE
         TM    PCTSTAT,TCTPRTSW    TEST FOR PREVIOUS PRINT CONSOLE
         BZ    PSETCC              IF NOT SET UP FOR NORMAL PRINT
         MVI   TANKSRCB,X'B1'      SET FOR IMMEDIATE SKIP
         NI    PCTSTAT,255-TCTPRTSW TURN SWITCH OFF
         TM    PCTSTAT,TCTREL      IS SUPPRESS EJECT FLAG ON
         BZ    PSETCC              IF NOT GO ON AND EJECT
         MVI   TANKSRCB,X'80'      PREPARE FOR SEPARATOR PAGE
PSETCC   DS    0H
         AGO   .PSK5A
.PSK5    ANOP
         BE    PFREE               FREE THE TANK IF END OF JOB
.PSK5A   ANOP
         CLI   TANKSRCB,X'8E'      LOOK FOR CHANGE IN FORMS
         AIF   (&CONSOLE EQ 0).PSK5B
         BE    PFREE               IGNORE THIS LINE IF FORMS MSG
         MVI   PRTLINE+1,C' '                CLEAR                U0019
         MVC   PRTLINE+2(131),PRTLINE+1            PRINTLINE      U0019
         LH    R9,TANKCNT                    SET NUM OF BYTES     U0019
         SH    R9,=H'1'                         INTO              U0019
         STC   R9,IOMOV+1                           MOVE INST     U0019
         AGO   .PSK5C
.PSK5B   BNE   *+8                 SKIP SRCB MODIFICATION IF NO
         MVI   TANKSRCB,X'91'      INSERT PRINT AND EJECT SRCB
.PSK5C   ANOP
IOMOV    MVC   PRTLINE+1(132),TANKDATA       MOVE DATA TO PRINT   U0019
*
*        SET UP CARRIAGE CONTROL
*
*OLD*    AIF   (&MACHINE EQ 20).PSK2
         ST    R8,TANKSV                                          U0019
         IC    R9,TANKSRCB         PICK UP CARRIAGE CONTROL INFO
         SLL   R9,3                ALIGN CC BITS FOR OPCODE
         STC   R9,PRTLINE                                         U0019
         TM    TANKSRCB,PSKIMM     TEST FOR SKIP IMMEDIATE
         BZ    KNOTIMM               IF NOT AN IMMEDIATE SPACE, GOU0019
         OI    PRTLINE,PCCOP         MOVE IMMEDIATE PRINT CODE IN U0019
         STM   R13,R2,IOSAV          DO IMMEDIATE                 U0019
         LA    R13,SAVEAREA               PRINT I/O               U0019
         MVI   PCTECB,X'10'          SHOW PRINT BUSY              U0019
         WRITE PRTECB,SF,PRINTR,PRTLINE,'S',,,,,MF=E              U0019
         LM    R13,R2,IOSAV                                       U0019
         $CHECK P                     WAIT FOR ECB TO BE POSTED   U0019
         STM   R13,R2,IOSAV                                       U0019
         LA    R13,SAVEAREA                                       U0019
         CHECK PRTECB          DO OS CHECK                        U0019
         LM    R13,R2,IOSAV                                       U0019
         XC    PRTECB,PRTECB    NOW CLEAR ECB                     U0019
         IC    R9,=AL1(POPCODEI)                                  U0019
KNOTIMM  STC   R9,PRTLINE              STORE CONTROL CHARACTER    U0019
         STM   R13,R2,IOSAV                                       U0019
         OI    PRTLINE,X'01'           OR IN 1 TO MAKE CTL CHAR COU0019
         LA    R13,SAVEAREA                                       U0019
         MVI   PCTECB,X'10'             SHOW PRINT BUSY           U0019
         WRITE PRTECB,SF,PRINTR,PRTLINE,'S',,,,,MF=E              U0019
         LM    R13,R2,IOSAV                                       U0019
         $CHECK P                      WAIT FOR ECB TO BE POSTED  U0019
         STM   R13,R2,IOSAV                                       U0019
         LA    R13,SAVEAREA                                       U0019
         CHECK PRTECB          DO OS CHECK FOR VOLUME SWITCH,ETC  U0019
         LM    R13,R2,IOSAV                                       U0019
         XC    PRTECB,PRTECB              DO OS CHECK             U0019
         L     R8,TANKSV                                          U0019
         B     PFREE                                              U0019
PRTLINE  DC    CL133' '                                           U0019
TANKSV   DC    F'0'                                               U0019
         S     R8,=A(TANKDATA-TANKDSEC)                           U0019
PFREE    $FREE $TANKPOL,R8,ENBL    RELEASE THE TANK ENABLED
         B     PNEXT               PRINT NEXT LINE
         AIF   (&NUMPRT EQ 1).PRTN1
         DROP  TCTR
.PRTN1   ANOP
         $ENDPROC P                END OF PRINT PROCESSOR
*
*        EQUATES FOR PRINT PROCESSOR
*
PSKIMM   EQU   X'20'               SRCB FLAG TO SKIP IMMEDIATE
         AIF   (&MACHINE EQ 20).PSK4
POPCODEI EQU   X'09'               PRINT OP-CODE SPACE 1 AFTER
PFLAGS   EQU   X'20'               NO CHAINING,SUPPRESS WRONG LENGTH CK
POPCODE  EQU   X'01'               CCW PRINT LINE OPCODE NO SPACE
PCCOP    EQU   X'03'               CARRIAGE CONTROL OP-CODE
         AGO   .PRTNSKP
.PSK4    ANOP
PCT      EQU   132                 LINE LENGTH AS ASSEMBLED
PCTCCWCT EQU   PCTCCW+4            LOCATION OF COUNT FIELD
PCTRTN   EQU   $PCOMM1+4           LOCATION OF NEXT COMMUTATOR ENTRY
.PRTNSKP ANOP
         AIF   (&NUMRDR EQ 0).RRTNSKP
 TITLE ' $ R R T N 1  -- INPUT SERVICE PROCESSOR'
&A       SETA  0
*
*        INPUT SERVICE PROCESSOR
*
*        GENERATION LOGIC VARIBLE MEANINGS
*        &R(1) = 0 FOR 1442,2501,2520,2540,2560 READ DEVICES
*        &R(2) = 0 FOR 2520 READ/PUNCH DEVICES
*        &R(3) = 0 FOR 1442 READ/PUNCH DEVICES
*        &R(6) = 0 FOR MOD 20
*        &R(7) = 0 FOR 2560 READ/PUNCH DEVICE
         AIF   (&NUMRDR EQ 1).RRTN1                     1+2+3+6+7
         USING RCTDSECT,TCTR       WE HAVE MULTIPLE READ TCTS
.RRTN1   AIF   (&R(7)).RRTN2
         USING TANKDSEC,R8         DATA TANKS FOR 2560 PUNCH ROUTINE
.RRTN2   ANOP                                           1+2+3+6+7
         READ  RDRECB,SF,READR,RCTTDTA1,'S',,,,,MF=L              U0019
$RRTN1   NULL                      INITIAL ENTRY AT IPL TIME
RDSTART  DS    0H                  ENTRY AFTER EOF, LOOP FOR DUAL PUNCH
         AIF   (&R(2) AND &R(3) OR NOT &R(6)).RRTN18
         MVI   RCTCCWCT+1,80       MAKE SURE COUNT IS 80
.RRTN18  ANOP
         USING TCTDSECT,TCTR                                      U0019
READ1    STM   R13,R2,IOSAV                                       U0019
         LA    R13,SAVEAREA                                       U0019
         MVI   RCTECB,X'10'       SHOW READER BUSY                U0019
         READ  RDRECB,SF,,,'S',,,,,MF=E                           U0019
         LM    R13,R2,IOSAV                                       U0019
RCK1     $CHECK R     WAIT FOR ECB TO BE POSTED                   U0019
         MVC   READR+33(3),=AL3(RDEOF1)  SET EOF ADDRESS          U0019
         STM   R13,R2,IOSAV                                       U0019
         LA    R13,SAVEAREA                                       U0019
         CHECK RDRECB    DO OS CHECK                              U0019
         LM    R13,R2,IOSAV                                       U0019
         CLI   RDRECB,X'7F'                                       U0019
         BE    TLEN1    IF 7F CONTINUE                            U0019
         CLI   RDRECB,X'41'                                       U0019
         MVC   RDRECB,=F'0'   CLEAR ECB                           U0019
         BNE   RDERR1       IF NOT 41 TREAT AS IO-ERR             U0019
         L     R1,RDRECB+16   GET IOB ADDRESS                     U0019
         CLC   12(2,R1),=X'0C40' TEST FOR CE DE IL IN CSW  STATUS U0019
         BNE   RDERR1    IF NOT TREAT AS IO-ERR                   U0019
         AIF   (&R(2) AND &R(3) OR &R(1)).RRTN3           (2+3)*1
         TM    RCTSTAT,TCTDUAL     TEST FOR SINGLE FEED DUAL DEVICE
         BZ    ROPEN               IF NOT GO AHEAD OPEN THE SERVICE
.RRTN3   AIF   (&R(2) AND &R(3)).RRTN4                        2+3
         CLC   RCTTDTA1(80),RCTTDTA2 CHECK FOR ALL BLANK CARD
         BE    RTESTPUN            LOOK FOR PUNCH DATA IF BLANK
.RRTN4   AIF   (&R(2) OR &R(3)).RRTN5
         TM    RCTSTAT,TCT25200    DO WE HAVE A 2520 READ/PUNCH
         BZ    ROPEN               IF NOT NO NEED TO STACKER SELECT
.RRTN5   AIF   (&R(2) OR NOT &R(6)).RRTN6                          2*-6
         $WRITE R,OP=R252003       SELECT POCKET 1 FOR READ JOB STREAM
         MVI   RCTOPCOD,R252002    SET UP FOR READING CARDS
.RRTN6   ANOP                                           1+2+3+6+7
TLEN1    BAL   R14,TESTLEN    GO CHECK BLOCK LENGTH               U0019
         MVC   RCTTDTA1(80),0(R8)  MOVE CURRENT REC TO IO AREA    U0019
ROPEN    $LA   R8,RCTTANK1         LOCATE TANK IN PARAMETER REG
         AIF   (&HOME EQ 1).RHOME
         BAS   R14,$TPOPEN         REQUEST HASP TO RECEIVE STREAM
         BZ    RREOPEN             IF NOT SENT TO HASP WAIT
         AIF   (&LOCCOM EQ 0).RRTN7A
         NI    RCTID,255-C' '      PREVENT OPERATOR ACTION
.RRTN7A  AIF   (&MACHINE EQ 20).RRTN7
         MVC   RCTTCT1,=H'80'     RESET LENGTH                    U0019
         $DELAY R,TIME=LONG,TYPE=BRANCH WAIT FOR HASP TO RESPOND
         NI    RCTUCB,255-TCTNOINT ENABLE INTERRUPTS ON DEVICE
         AGO   .RRTN8
.RRTN7   ANOP                                            -(1+2+3)
         $DELAY R,TIME=LONG,TYPE=BRANCH WAIT FOR HASP TO RESPOND
.RRTN8   AIF   (&LOCCOM EQ 0).RRTN8A
         OI    RCTID,C' '          ALLOW OPERATOR ACTION
.RRTN8A  ANOP
*              WE MUST GO BACK TO COMMUTATOR FOR GATE TO BE OPENED
.RHOME   ANOP
RDLOOP   DS    0H                  BASIC READ LOOP
         MVC   RCTTCT1,=H'80'     RESET LENGTH                    U0019
         $PUT  R,RCTTANK1         SEND THE TANK TO HASP           U0019
         L     R8,RDRREC      GET RECORD POINTER                  U0019
         LA    R8,80(R8)      BUMP TO NEXT RECORD                 U0019
         ST    R8,RDRREC      SAVE IT FOR POSTERITY               U0019
         C     R8,BLOCKEND    IS IT TIME TO DO A REAL READ        U0019
         BNE   RDEBLOCK       NOPE..GO USE THIS RECORD            U0019
RDERR    STM   R13,R2,IOSAV                                       U0019
         LA    R13,SAVEAREA                                       U0019
         MVI   RCTECB,X'10'       SHOW READER BUSY                U0019
         READ  RDRECB,SF,,,'S',,,,,MF=E                           U0019
         LM    R13,R2,IOSAV                                       U0019
RCHECK   $CHECK R            WAIT FOR ECB TO BE POSTED            U0019
         MVC   READR+33(3),=AL3(RDEOF)   SET INITIAL EOF ADDR     U0019
         STM   R13,R2,IOSAV                                       U0019
         LA    R13,SAVEAREA                                       U0019
         CHECK RDRECB    DO OS CHECK                              U0019
         LM    R13,R2,IOSAV                                       U0019
         CLI   RDRECB,X'7F'    WAS READ OK                        U0019
         BE    TSTLEN       IF 7F GO TEST LENGTH                  U0019
         CLI   RDRECB,X'41'   CHECK FOR  X'41' AND WLR            U0019
         MVC   RDRECB,=F'0'   CLEAR ECB                           U0019
         BNE   RDERR          IF NOT TREAT AS UNCORRECTIBLE ERROR U0019
         L     R1,RDRECB+16    GET IOB ADDRESS                    U0019
         CLC   12(2,R1),=X'0C40'  TEST FOR CE DE IL IN CSW STATUS U0019
         BNE   RDERR          IF NOT TREAT AS UNCORRECTIBLE ERROR U0019
TSTLEN   BAL   R14,TESTLEN     CHECK BLOCK LENGTH                 U0019
RDEBLOCK MVC   RCTTDTA1(80),0(R8)  MOVE CORRECT REC TO IOAREA     U0019
         B     RDLOOP                                             U0019
RDEOF    LM    R13,R2,IOSAV                                       U0019
         MVC   RDRECB,=F'0'   CLEAR ECB AFTER EOF                 U0019
         MVC   RCTTCT1,=F'0'   SET END OF FILE INDICATOR          U0019
         $DELAY R,TYPE=SETUP       PREPARE FOR REJECT ON SENDING
         $LA   R8,RCTTANK1         PUT TANK ADDR IN PARAMETER REG
         BAS   R14,$TPPUT          SEND TO HASP EOF SIGNAL
         BNZ   RDEOF2       OPEN WENT OK...CONTINUE               U0019
         MVI   $RCOMM1+1,X'00'   CLOSE GATE                       U0019
         MVI   RDRWFB,X'FF'   SHOW WAITING FOR BUFFER             U0019
         B     $RCOMM1+4      GO WAIT FOR A BUFFER                U0019
         AIF   (&R(2) AND &R(3)).RRTN9                      2+3
         MVI   RCTTDTA2,C' '       INSERT A BLANK IN THE DATA AREA
         MVC   RCTTDTA2+1(79),RCTTDTA2  BLANK REST. USED FOR COMPARE
.RRTN9   AIF   (&MACHINE EQ 20).RRTN10                     -(6+7)
RDEOF1   EQU   *                                                  U0019
         LM    R13,R2,IOSAV   RESTORE REGS                        U0019
         MVC   RDRECB,=F'0'   CLEAR ECB                           U0019
RDEOF2   EQU   *                                                  U0019
         OI    RCTECB,TCTBUSY      SET READER BUSY FOR WAITING
         MVI   RDRWFB,X'00'    RESET WAITING FOR BUFFER SW        U0019
         AIF   (&R(2) OR &R(1) AND &R(3)).RRTN11          2*(1+3)
         TM    RCTSTAT,TCT25200    TEST FOR DUAL 2520
         BZ    RDSTART             IF NO GO TO START OF ROUTINE
.RRTN11  AIF   (&R(2)).RRTN10                                -6*2
         MVI   RCTOPCOD,R25200     RESET THE INITIAL READ OPCODE
.RRTN10  AIF   (&R(7)).RRTN14                                   7
         B     RDEOF1              ATTEMPT TO PUNCH
         AGO   .RRTN15
.RRTN14  ANOP                                                  -7
         MVI   $RCOMM1+1,X'00'      CLOSE GATE                    U0019
         STM   R13,R2,IOSAV                                       U0019
         LA    R13,SAVEAREA                                       U0019
         CLOSE (READR)                                            U0019
         LM    R13,R2,IOSAV                                       U0019
HOTONE   B     $START                HOT READER SWITCH            U0019
         STM   R13,R2,IOSAV                                       U0019
         LA    R13,SAVEAREA                                       U0019
         OPEN  (READR)              READER RE-OPENED IF HOT       U0019
         LM    R13,R2,IOSAV                                       U0019
         B     READ1                    READER WAS SPECIFIED      U0019
.RRTN15  ANOP                                           1+2+3+6+7
RREOPEN  MVI   RDRWFB,X'FF'      SHOW WAITING FOR BUFFER          U0019
         $DELAY R,TIME=LONG,TYPE=BRANCH                           U0019
         MVI   RDRWFB,X'00'      RESET WAITING FOR BUFFER         U0019
         B     ROPEN                  GO TRY REOPEN               U0019
RDERR1   $INTREQ R,RDR,PREVLOC=READ1 PREPARE TO WAIT ON OPERATOR, READ
TESTLEN  LH    R8,READR+62     GET BLKSIZE FROM DCB               U0019
         MVC   RDRECB,=F'0'    CLEAR ECB                          U0019
         L     R1,RDRECB+16    GET IOB ADDRESS                    U0019
         LH    R9,14(R1)       GET RESIDUAL CNT FROM CSW          U0019
         SR    R8,R9           CALCULATE BYTES READ               U0019
         L     R2,RDRECB+12    GET BUFFER ADDRESS                 U0019
         ST    R2,RDRREC       SAVE FOR DEBLOCK ROUTINE           U0019
         AR    R8,R2      BUF ADDR + BYTES READ = BUFEND + 1      U0019
         ST    R8,BLOCKEND    SAVE FOR DEBLOCKING RTN             U0019
         TM    13(R1),X'40'    CHECK 2ND STATUS BYTE FOR BAD LENGTU0019
         BC    8,ITSOK         RETURN IF IT IS OK                 U0019
         LTR   R9,R9        IS RESIDUAL COUNT 0                   U0019
         BZ    BADLENTH  IF SO ITS A TOO-LONG BLOCK               U0019
         SR    R8,R8    IF RESID IS EVEN MULTIPLE OF 80,          U0019
         D     R8,=F'80'        IT IS AN OK SHORT BLOCK.          U0019
         LTR   R8,R8                                              U0019
         BNZ   BADLENTH                                           U0019
ITSOK    L     R8,RDRREC       SET UP FOR MOVE UPON RETURN        U0019
         BR    R14             RETURN TO CALLER                   U0019
BADLENTH WTO   'INCORRECT BLOCK LENGTH ON READER..READER CLOSED', 99   +
               ROUTCDE=11                                      UF099
         MVI   HOTONE+1,X'F0'       NOTHOT IT                     U0019
         B     RDEOF2   CLOSE READER AND LET OTHER STUFF GO ON    U0019
RDRREC   DC    A(0)                                               U0019
BLOCKEND DC    A(0)                                               U0019
         AIF   (&R(7)).RRTN12                                   7
RDEOF1   $GETTNK R,R8,R9,EMPTY=RTEST NO CARDS TO READ TRY PUNCHING
         CLI   TANKCNT+1,0         TEST FOR END OF JOB
         BE    RDFREE              FREE THE TANK IF END OF JOB
RDPUNCH  $WRITE R,TANKDATA,TANKDSEC,OP=UOPCODE,CTADDR=TANKCNT,S=RDPCH
         $CHECK R,RDPUNCHA         CHECK IF OK, PUNCH AGAIN IF NOT
         LH    R8,RDPCH+2          PICK UP I/O AREA
         SH    R8,=Y(TANKDATA-TANKDSEC) GET TO START OF TANK
RDFREE   $FREE $TANKPOL,R8,ENBL    FREE THE TANK
         LH    R8,RDCTR            LOAD READ TIMER COUNT
         AH    R8,=H'-1'           SUBTRACT 1
         STH   R8,RDCTR            SAVE RESULTS
         BNE   RDEOF1              IF NOT ZERO CONTINUE PUNCHING
         MVC   RDCTR,RDCT          REPLENISH MAX COUNT
RTEST    MVC   RDCTRR,RDCTAR       SET UP FOR MULTIPLE READ TESTS
RTESTB   $DELAY R                  WAIT ONE TIME AROUND
         XIO  RCTTDTA1(ROPCODE+1),RCT TRY READING
         BC    7,RDTESTA           IF NO START DEC COUNT
         CIO   RPOC,RSTACK         STACK THE CARD
         $CHECK R,RDERR1,RDTESTA   CHECK FOR COMPLETION
         B     ROPEN               IF IN OK OPEN UP INPUT SERVICE
RDTESTA  LH    R8,RDCTRR           LOAD READ TEST COUNT
         AH    R8,=H'-1'           REDUCE
         STH   R8,RDCTRR           SAVE RESULTS
         BNE   RTESTB              WAIT SOME MORE
         B     RDEOF1              TRY PUNCHING
RDPUNCHA CIO   UBADPOC,UNSTACK     SELECT BAD POCKET
         B     RDPUNCH
RDCT     DC    H'100'              CONSTANTS FOR DELAY OF READ TEST
RDCTR    DC    H'100'              WHILE PUNCHING
RDCTAR   DC    H'190'              DELAY TO RECOGNIZE
RDCTRR   DC    H'190'              INPUT STREAM
         AGO   .RRTN13
.RRTN12  AIF   (NOT &R(6)).RRTN12A
         AGO   .RRTN13
.RRTN12A ANOP
RDEOF1   EQU   RDSTART             IGNORE EOF
.RRTN13  AIF   (&R(2) AND &R(3)).RRTN16                             2+3
*
*        ROUTINE TO PREPARE TO PUNCH CARDS ON A DUAL READ/PUNCH DEVICE
*
RTESTPUN NULL
         AIF   (&MACHINE EQ 20).RRTN19
         MVI   RCTECB,0            REMOVE DEVICE END INDICATION
RTEST    TM    RCTECB,DEVEND       TEST FOR DEVICE END
         BO    RDSTART             OPERATOR INSERTED NEW CARDS IF YES
         AGO   .RRTN20
.RRTN19  AIF   (&CONSOLE EQ 0).RRTN21
         OI    RCTSTAT,TCTSTOP     SET STOP STATUS
RTEST    TM    RCTSTAT,TCTSTOP     TEST FOR OPERATOR RESPONSE
         BZ    RDSTART             OPERATOR RESPONDED
.RRTN20  ANOP
         CLI   RCTTNKCT,0          TEST FOR A PUNCH TANK AVAILABLE
         BNE   $URTN1              IF SO PREPARE TO PUNCH
         $DELAY R,TYPE=BRANCH,TIME=LONG,PREVLOC=RTEST WAIT, LOOP BACK
         AGO   .RRTN16
.RRTN21  ANOP
         $DELAY R,TIME=SHORT,TYPE=SETUP PREPARE FOR WAIT
         BAS   R14,$DIAL           REQUEST DIAL READING
         DC    Y(RADR*2+$DIALTAB)                                 V03.1
         B     RTEST               IF NO RESPONSE TEST FOR TANK
         B     RDSTART             OPERATOR RESPONDED
RTEST    MVC   RADR*2+$DIALTAB(2),=Y(YODNULL) REPLACE TABLE ELEMENT
         CLI   RCTTNKCT,0          TEST FOR TANK
         BNE   $URTN1              PUNCH CARD IF TANK
         B     $RCOMM1+4           WAIT IF NO TANK
.RRTN16  ANOP
         AIF   (&NUMRDR EQ 1).RRTN17
         DROP  TCTR
.RRTN17  ANOP
         $ENDPROC R                END OF READ PROCESSOR
         AIF   (&MACHINE NE 20).RRTNSKP
*
*        INPUT PROCESSOR EQUATES
*
RCT      EQU   80                  LENGTH OF CARD
RCTRTN   EQU   $RCOMM1+4           LOCATION OF NEXT COMMUTATOR ENTRY
.RRTNSKP ANOP
         AIF   (&NUMPUN EQ 0).URTNSKP
 TITLE '$ U R T N 1  --  PUNCH SERVICE PROCESSOR'
&A       SETA  0
*
*        PUNCH SERVICE PROCESSOR
*
*        GENERATION LOGIC VARIABLE MEANINGS
*        &R(2) = 0 FOR 2520 READ/PUNCH DEVICES
*        &R(3) = 0 FOR 1442 READ/PUNCH DEVICES
*        &R(4) = 0 FOR 2540 PUNCH DEVICES
*        &R(5) = 0 FOR 2520,2560 PUNCH DEVICES
*        &R(6) = 0 FOR MOD 20
*        &R(7) = 0 FOR 2560 READ/PUNCH DEVICE
*        &R(8) = 0 FOR 1442 SINGLE POCKET PUNCH DEVICES
         USING TANKDSEC,R8
         USING TCTDSECT,TCTR                                      U0019
         WRITE PCHECB,SF,PUNCH,PUNCHOUT,'S',,,,,MF=L              U0019
         AIF   (&NUMPUN EQ 1).URTN1
         USING UCTDSECT,TCTR
.URTN1   ANOP                                               2+3+4+5+6+8
$URTN1   NULL                      INITIAL ENTRY AT IPL TIME,DUAL PUNCH
USTART   DS    0H                  LOOP ENTRY TO CONTINUE PUNCHING
         $GETTNK U,R8,R9,EMPTY=WAIT GET OUTPUT TANK WITH PUNCH RECORD
         CLI   TANKCNT+1,0         TEST FOR END OF JOB
         BE    UFREE               IF SO FREE TANK
UOUTPUT  DS    0H                  PUNCH THE CARD
         MVI   PUNCHOUT,C' '                  CLEAR PUNCH         U0019
         MVC   PUNCHOUT+1(79),PUNCHOUT                 AREA       U0019
         LH    R9,TANKCNT                      INSERT COUNT FOR MVU0019
         SH    R9,=H'1'                                           U0019
         STC   R9,PUNMOV+1                                        U0019
PUNMOV   MVC   PUNCHOUT(80),TANKDATA     MOVE TANK TO PUNCH       U0019
         ST    R8,UCTHOLD                                         U0019
         STM   R13,R2,IOSAV                                       U0019
         LA    R13,SAVEAREA                                       U0019
         MVI   UCTECB,X'10'              SHOW PUNCH BUSY          U0019
         WRITE PCHECB,SF,PUNCH,PUNCHOUT,'S',,,,,MF=E              U0019
         LM    R13,R2,IOSAV                                       U0019
         AIF   (&R(4) OR &R(2) AND &R(3) AND &R(5) AND &R(8)).URTN2
         TM    UCTSTAT,TCT2540     TEST FOR 2540 PUNCH
         BZ    UCHECK              IF NOT GO CHECK I/O OK
.URTN2   AIF   (&R(4)).URTN3                                          4
         $CHECK U         WAIT FOR POST                           U0019
         STM   R13,R2,IOSAV                                       U0019
         LA    R13,SAVEAREA                                       U0019
         CHECK PCHECB     DO OS CHECK                             U0019
         LM    R13,R2,IOSAV                                       U0019
         L     R8,UCTHOLD    GET TANK POINTER                     U0019
         TM    PCHECB,X'7F'                                       U0019
         MVC   PCHECB,=F'0'   CLEAR ECB                           U0019
         BNO   UOUTPUT IF NOT 7F PUNCH IT AGAIN                   U0019
         $FREE $TANKPOL,R8,ENBL    RELEASE THE TANK
         B     USTART              LOOK TO PUNCH NEXT CARD
.URTN3   AIF   (&R(2) AND &R(3) AND &R(5) AND &R(8)).URTN4
UCHECK   $CHECK U,UERR             CHECK FOR IN OK
         $LOAD R8,UCTCCW+4-&L      PICK UP DATA ADDRESS
         SH    R8,=Y(TANKDATA-TANKDSEC) GET TO START OF TANK
.URTN4   ANOP
UFREE    $FREE $TANKPOL,R8,ENBL    RELEASE THE TANK
         AIF   (&R(2) AND &R(3) OR &R(5) AND &R(8) AND &R(4)).URTN5
         TM    UCTSTAT,TCT25200+TCT14420 TEST FOR A DUAL DEVICE
         BNZ   $RRTN1              READ NEXT CARD, CHECK FOR BLANK
         AGO   .URTN6
.URTN5   AIF   (&R(2) AND &R(3)).URTN6                              2+3
         B     $RRTN1              READ NEXT CARD, CHECK FOR BLANK
.URTN6   AIF   (&R(4) OR &R(2) AND &R(3) AND &R(5) AND &R(8)).URTN7
         TM    UCTSTAT,TCT2540     TEST FOR 2540 PUNCH
         BZ    USTART              IF NOT GET NEXT TANK
.URTN7   AIF   (&R(4)).URTN8                                          4
.URTN8   AIF   (NOT(&R(2) AND &R(3)) AND &R(4) AND &R(5) AND &R(8)).UR9
         B     USTART              GO BACK TO START OF PROCESSOR
.UR9     AIF   (NOT(&R(8) AND &R(2) AND &R(3)) OR &R(5)).URTN10
         AIF   (&UDEV(1) NE 2560).URTN10A
UERR     CIO   UBADPOC,UNSTACK     SELECT BAD POCKET
         B     UPUNCH              RETRY PUNCH
         AGO   .URTN10
.URTN10A ANOP
UERR     EQU   UPUNCH              ON ERROR REPUNCH THE CARD
.URTN10  AIF   (&R(2) AND &R(3) AND &R(8)).URTN11                 2+3+8
UERR     DS    0H                  PUNCH I/O ERROR ENTRY
.URTN11  AIF   (&R(2) AND &R(3) OR &R(5) OR &R(8)).URTN12     (2+3)*5*8
         TM    UCTSTAT,TCT25200+TCT14420+TCT1442 TEST FOR SPECIAL
         BZ    UPUNCH              IF NOT REPUNCH THE CARD
.URTN12  AIF   (&R(2) AND &R(3) AND &R(5) OR &R(8)).URTN13    (2+3+5)*8
         TM    UCTSTAT,TCT1442     TEST FOR SINGLE POCKET 1442
         BZ    UEDUAL              IF NOT SKIP 1442 ERROR ROUTINE
         AIF   (NOT(&R(2) AND &R(3))).URTN13
UEDUAL   EQU   UPUNCH              REPUNCH THE CARD
.URTN13  AIF   (&R(8)).URTN17
         $INTREQ U,PUN,PREVLOC=UPUNCH
.URTN17  AIF   (&R(2) AND &R(3) OR &R(5) OR NOT &R(8)).URTN14
         TM    UCTSTAT,TCT25200+TCT14420 TEST FOR DUAL READ/PUNCH
         BZ    UPUNCH              REPUNCH THE CARD IF NO
.URTN14  AIF   (&R(2) AND &R(3)).URTN15                             2+3
UEDUAL   DS    0H                  ERROR ON DUAL READ/PUNCH UNIT
         AIF   (&MACHINE EQ 20).URTN14A
         MVC   UCTHOLD,UCTCCW+4-&L SAVE BAD CARD POINTER
         MVI   UCTCCWCT+1,80       SET DATA LENGTH TO 80
UEDUALA  DS    0H
         $READ U,UCTTDTA1          READ A CARD FROM DUAL UNIT
         $CHECK U,URERR,URERR      CHECK TO MAKE SURE IN OK
         $LOAD R8,UCTHOLD          PICK UP DATA ADDRESS
         SH    R8,=Y(TANKDATA-TANKDSEC) POINT TO TANK
         CLC   UCTTDTA1(80),UCTTDTA2 CHECK FOR ALL BLANK CARD
         BE    UOUTPUT             IF SO GO PUNCH AGAIN
         AGO   .URTN14B
.URTN14A ANOP
UEDUALA  DS    0H
         $READ U,UCTTDTA1,OP=ROPCODE READ A CARD FROM DUAL UNIT
         $CHECK U,URERR,URERR,T=R  CHECK FOR IN OK
         CLC   UCTTDTA1(80),UCTTDTA2 CHECK FOR ALL BLANK CARD
         BE    UPUNCH              IF SO PUNCH AGAIN
.URTN14B ANOP
URERR    $INTREQ U,PUN,PREVLOC=UEDUALA WAIT FOR OPERATOR
.URTN15  AIF   (&NUMPUN EQ 1).URTN16
         DROP  TCTR                DROP BASE FOR NEXT PROCESSOR
.URTN16  ANOP
         $ENDPROC U                END OF PUNCH PROCESSOR
         AIF   (&MACHINE NE 20).URTNSKP
*
*        PUNCH PROCESSOR EQUATES
*
UCT      EQU   80                  LENGTH OF CARD
UCTRTN   EQU   $UCOMM1+4           LOCATION OF NEXT COMMUTATOR ENTRY
.URTNSKP ANOP
         AIF   (&CONSOLE EQ 0 AND &PRTCONS EQ 0).WRTNSKP
PUNCHOUT DC    CL80' '                                            U0019
IOSAV    DC    6F'0'                                              U0019
SAVEAREA DC    18F'0'                                             U0019
 TITLE '$ W R T N 1  -- CONSOLE PROCESSOR'
&A       SETA  0
*
*        BASE REGISTER ASSIGNMENT
*
         USING TANKDSEC,R8
         AIF   (&CONSOLE LT 2).WSK1
         USING WCTDSECT,TCTR
.WSK1    ANOP
         AIF   (&PRTCONS EQ 0).WSK12
         AIF   (&CONSOLE NE 0).WSK15
$WRTN1   NULL
.WSK15   ANOP
*
*        ROUTINE TO PREPARE MESSAGES FOR PRINTING ON 1403-1443-2203
*
WPLOOP   DS    0H                  ENTRY POINT TO PASS MSG TO PRINTER
         AIF   (&NUMPRT LT 2).WSK14
         $LA   R10,$PCOM1+2        PICK UP PRINTER 1 TCT
         USING PCTDSECT,R10
.WSK14   ANOP
         CLI   WCTTNKCT,0          TEST FOR MESSAGES
         BE    WPTLOG              IF NONE TEST FOR ERROR LOG
WPLOG    TM    PCTSTAT,TCTPRTSW    TEST FOR PRINTER AVAILIABLE
         BZ    WPCONS              LOOK FOR PRINTING MESSAGES
WPSCANA  $LA   R9,PCTTANK          PICK UP PRINTER TANK Q ADDR
WPSCAN   $LOAD R8,0(0,R9)          PICK UP NEXT OR ZERO
         CH    R8,=H'0'            TEST FOR END OF Q
         BE    WPINSERT            INSERT CONSOLE TANKS BEHIND
         CLI   TANKRCB,&WRCB(1)    IS THIS A MESSAGE RCB
         BNE   WPINSERT            IF NOT INSERT CONSOLE TANKS HERE
         $LTR  R9,R8               PULL SCAN POINTER UP ONE
         B     WPSCAN              SCAN SOME MORE
WPINSERT MVC   0(&L,R9),WCTTANK    INSERT CONSOLE TANK
         $LOAD R9,0(0,R9)          MOVE TO INSERTED TANK
         MVI   TANKSRCB-TANKDSEC(R9),X'81' INSERT SPACE 1 AFTER
WPFORCE  MVC   WCTTANK,0(R9)       MAKE NEXT HEAD OF CONSOLE CHAIN
         $STO  R8,0(0,R9)          PUT PRINTER CHAIN ON BEHIND
         LH    R14,PCTTNKLM        PICK UP PRINTER TANK COUNT
         AH    R14,=H'1'           ADD 1
         STH   R14,PCTTNKLM        SAVE IT
         LH    R14,WCTTNKLM        PICK UP CONSOLE COUNT
         AH    R14,=H'-1'          SUB 1
         STH   R14,WCTTNKLM        SAVE IT
         CLI   WCTTNKCT,0          TEST FOR MORE
         BNE   WPINSERT            INSERT SOME MORE
         OI    $PCOMM1+1,X'F0'     LET PRINTER PRINT
         OI    WCTSTAT,TCTACT      TURN ON ACTIVITY INDICATOR
         NI    PCTSTAT,255-TCTREL  RESET SUPPRESS EJECT FLAG
         B     $WCOMM1+4           WAIT ONE TIME AROUND
         AIF   (&PRTCONS NE 2).WSK12A
WPCONS   $GETTNK W,R8,R9,EMPTY=WPCLOS GET THE TANK
         $FREE $TANKPOL,R8,ENBL    FREE THE TANK
         B     WPCONS              LOOP BACK FOR MORE
         AGO   .WSK12B
.WSK12A  ANOP
WPCONS   CLI   WCTTNKCT,&WTLM(1)   DO WE HAVE OUR LIMIT
         BL    WPCLOS              IF NOT WE ARE OK
         $LOAD R9,WCTTANK          PICK UP FIRST TANK
         MVI   TANKSRCB-TANKDSEC(R9),X'B1' EJECT AND PRINT CODE
         $LOAD R8,PCTTANK          PICK UP PRINTER TANK Q
         $STO  R9,PCTTANK          CHAIN FIRST TANK ONTO PRINTER
         OI    PCTSTAT,TCTPRTSW    SET PRINTER AVAILABLE
         B     WPFORCE             FORCE MESSAGES OUT
.WSK12B  ANOP
WPCLOS   $CLOSE W                  WAIT AWHILE
WPTLOG   CLC   $LOGOUT,$LOGLAST    ANY ERROR MESSAGES
         BE    WPCLOS              IF NOT CLOSE GATE AND LOOP
         $DCHAIN $TANKPOL,R8,ENBL,EMPTY=$WCOMM1+4 GET A TANK
         $FREE WCTTANK,R8,ENBL     PUT TANK INTO CONSOLE Q
         MVI   WCTTNKCT,1          SET A VALUE OF 1 IN COUNT
         AIF   (&CONSOLE EQ 0).WSK2
         B     WLOGB               PREPARE LOG INFO
.WSK12   ANOP
$WRTN1   NULL
WINIT    DS    0H                  CONSOLE LOOP ENTRY POINT
         MVI   $WCOMM1+1,X'00'    CLOSE THE GATE                  U0019
WTANKTST CLI   WCTTNKCT,0          TEST FOR TANK
         BNE   WGETTANK            IF WE HAVE ONE GET IT
         $DELAY W,TYPE=SETUP,PREVLOC=WINIT SET UP FOR WAIT
         CLC   $LOGOUT,$LOGLAST    TEST FOR ERRORS TO LOG
         BE    WCTRTN              WAIT ONE TIME AROUND COMMUTATOR
         AIF   (&MACHINE NE 20).WSK2
         $OPEN W,R9                OPEN THE GATE WE HAVE WORK
.WSK2    ANOP
WLOGB    $SSM  0                   DISABLE INTERRUPTS
         $LOAD R9,$LOGOUT          PICK UP LOG INFO POINTER
WLOGGA   $AA   R9,4                INCREMENT TO NEXT ENTRY
         $CA   R9,$LOGEND          TEST FOR END OF TABLE
         BL    WLOG                IF NOT PREPARE TO TYPE
         BH    WLOGG               BR IF $LOG CHASED US OUT OF TABLE
         $LA   R9,$LOGTAB          PICK UP START OF TABLE
WLOG     $STO  R9,$LOGOUT          SAVE POINTER FOR NEXT TIME
         MVC   WBUFFP,0(R9)        MOVE LOG INFO TO WORK AREA
         $SSM  FF                  ENABLE INTERRUPTS
         AIF   (&ERRTXTL EQ 0).WSK3
         $LMHA R9,R8,WPREFIX,=Y(LOGEND-LOGDSECT) FIND ENTRY
         $AA   R9,$ERRTAB          ADD TO ENTRY THE TABLE ORIGIN
.WSK3    ANOP
         UNPK  WBUFF,WBUFFP(5)     SPREAD THE HEX DIGITS
         TR    WBUFF(8),WEBCDIC    CONVERT TO EBCDIC
         AIF   (&ERRTXTL EQ 0).WSK4
         USING LOGDSECT,R9
         MVC   WTEXT,LOGTEXT       MOVE IN TEXT PORTION OF ERROR MSG
         DROP  R9
         MVI   WBUFF+8,C' '        BLANK OUT IN FRONT OF TEXT
.WSK4    ANOP
         AIF   (&PRTCONS EQ 0 OR &CONSOLE EQ 0).WSK13
* CHANGE FOLLOWING TO NOP TO LOG ON PRINTER, CHANGE COMMUTATOR/WTCT
*              TO ENTER AT WPLOOP
         B     WLOGC
.WSK13   AIF   (&PRTCONS EQ 0).WSK11
         $LOAD R8,WCTTANK
         MVC   TANKDATA(8+&ERRTXTL),WBUFF MOVE MESSAGE TO TANK
         MVC   TANKRCB(4),WLOGHD   INSERT RCB,SRCB,AND COUNT
         B     WPLOG
WLOGHD   DC    AL1(&WRCB(1)),X'80',AL2(8+&ERRTXTL) RCB,SRCB,COUNT
.WSK11   AIF   (&CONSOLE EQ 0).WSKLOCA
WLOGC    DS    0H
*OLD*    AIF   (&MACHINE EQ 20).WSK5
         WTO   MF=(E,WBUFFCNT)                                    U0019
         B     WINIT                                              U0019
WGETTANK $GETTNK W,R8,R9,EMPTY=WAIT                               U0019
         LH    R9,TANKCNT                                         U0019
         AH    R9,=H'4'                                           U0019
         STH   R9,WTOBUF                                          U0019
         SH    R9,=H'5'                                           U0019
         STC   R9,WTOMOV+1                                        U0019
WTOMOV   MVC   WTOBUF+4(120),TANKDATA                             U0019
         MVC   WTOBUF+2(2),=X'4000'   ASSUME REG0 FORM          UF099
         L     R0,COMCONID         GET LAST INPUT CONSOLE ID   UF099
         LTR   R0,R0               WAS THERE ONE?              UF099
         BNZ   WTOWTO              YES, ISSUE AS IS            UF099
         SPACE 1                                               UF099
         MVC   WTOBUF+2(2),=X'8000'  SET ROUTE CODES FOLLOW    UF099
         LA    R9,WTOBUF+5(R9)     POINT PAST MESSAGE          UF099
         MVC   0(4,R9),=X'00000020'  SET ROUTCDE=11            UF099
         SPACE 1                                               UF099
WTOWTO   WTO   MF=(E,WTOBUF)                                      U0019
         $FREE $TANKPOL,R8,ENBL                                   U0019
         B     WINIT                                              U0019
WTORPROC LA    R7,WTCT                                            U0019
         MVI   $WTORCOM+1,X'00'                                   U0019
INTRELSW B     WTOR1              SWITCH USED IF INTERLOCK REL IS U0019
         MVI   INTRELSW+1,X'F0'    RESET BRANCH                   U0019
         B     PUTITT             GO RE-PUT THE TANK              U0019
WTOR1    B     WONCE           FIRST TIME JUST ISSUE WTOR         U0019
         L     R14,COMPTR          POINT TO COM AREA           UF099
         USING COMLIST,R14         SET TEMP ADDRESSING         UF099
         L     R15,COMCIBPT        GET CIB ADDRESS             UF099
         USING CIB,R15             SET TEMP ADDRESSING         UF099
         LA    R15,0(R15)          CLEAR TOP BYTE              UF099
         LTR   R15,R15             IS THERE ONE?               UF099
         BZ    WTOR2               NO - KEEP WAITING           UF099
         CLI   CIBVERB,CIBSTOP     STOP COMMAND ISSUED?        UF099
         BE    EOJ                 YES - TERMINATE             UF099
         CLI   CIBVERB,CIBMODFY    MODIFY COMMAND?             UF099
         BNE   WTOR2               NO, SKIP IT                 UF099
         SPACE 1                                               UF099
MOD      LH    R1,CIBDATLN         GET LENGTH OF DATA FIELD    UF099
         CH    R1,=H'120'          TOO MUCH TEXT?              UF099
         BNH   WTOEX               NO - MOVE IT IN             UF099
         LH    R1,=H'120'          GET MAX TEXT LENGTH         UF099
WTOEX    BCTR  R1,0                DROP FOR EXECUTE            UF099
         EX    R1,CIBMOVE          MOVE INTO BUFFER            UF099
         XR    R0,R0               CLEAR FOR IC                UF099
         IC    R0,CIBCONID         GET CONSOLE ID              UF099
         ST    R0,COMCONID         AND SAVE FOR LATER          UF099
         B     FREECIB             AND FREE THE CIB            UF099
         SPACE 1                                               UF099
CIBMOVE  MVC   WCTTDTA1(*-*),CIBDATA  COPY DATA TO AREA        UF099
         SPACE 1                                               UF099
FREECIB  QEDIT ORIGIN=COMCIBPT,BLOCK=(R15) FREE CURRENT CIB    UF099
         SPACE 1                                               UF099
         DROP  R14,R15             DROP TEMP ADDRESSING        UF099
         SPACE 1                                               UF099
         MVC   WCTTCT1(2),=X'0050'    SET TANK COUNT              U0019
         CLC   WCTTDTA1(3),=C'EOJ'    IS THIS EOJ???              U0019
         BE    EOJ                                                U0019
         CLC   WCTTDTA1(3),=C'NOT'  SHALL WE UNHOT THE READER     U0019
         BE    UNHOT                 YEP                          U0019
         CLC   WCTTDTA1(3),=C'HOT'    IS THIS REQUEST FOR HOT READU0019
         BE    GOHOT                YEP                           U0019
         B     PUTITT             ITS OK TO SEND TO HASP          U0019
GOHOT    MVI   HOTONE+1,X'00'      SET UP FOR HOT READER          U0019
         B     WTOR2               THEN ISSUE WTOR AGAIN          U0019
UNHOT    MVI   HOTONE+1,X'F0'      UNHOT THE READER               U0019
         B     WTOR2                                              U0019
PUTITT   $PUT  W,WCTTANK1                                         U0019
WTOR2    MVI   WCTTDTA1,C' '                                      U0019
         MVC   WCTTDTA1+1(119),WCTTDTA1                           U0019
         B     $WTORCOM+4                                         U0019
WONCE    MVI   WTOR1+1,X'00'                                      U0019
         B     WTOR2                                              U0019
         AIF   (&LOCCOM EQ 0).WSKLOCA
WLOCALW  MVC   $COMMAND,WCTTDTA1+1 MOVE COMMAND TO WORK AREA
         BAS   R14,$WLOCAL         PROCESS LOCAL COMMAND
         B     WTANKTST            CHECK FOR OUTPUT
.WSKLOCA ANOP
WLOGG    $LOAD R9,$LOGLAST         PICK UP LAST LOGGED
         B     WLOGGA              JUMP BACK IN AHEAD OF $LOG
*
*        ERROR MESSAGE WORK AREAS
*
WPREFIX  DS    0H
         DC    X'00'               PADDING FOR ID OFFSET
WBUFFP   DC    CL4' '              WORK AREA FOR ERROR MSG
         DC    X'0F'               POSITIVE DECIMAL ZERO
WBUFFCNT DC    AL2(4+9+&ERRTXTL-1),X'8000'                     UF099
WBUFF    DC    CL9' '              EBCDIC VERSION OF ERROR
WTEXT    DS    CL(&ERRTXTL-1)      LENGTH OF TEXT OF MESSAGE
         DC    X'0000'             DESCRIPTOR CODES            UF099
         DC    X'0100'             ROUTCDE=8                   UF099
WEBCDIC  EQU   *-X'F0'             SHORT TRANSLATE TABLE
         DC    C'0123456789ABCDEF' FOR HEX DIGITS TO EBCDIC
WTOBUF   DC    F'0'                                               U0019
         DC    CL120' '                                           U0019
COMPTR   DC    F'0'                POINTER FOR COMM AREA       UF099
COMCONID DC    F'0'                CONSOLE ID OF LAST MODIFY   UF099
         $ENDPROC W                END OF CONSOLE PROCESSOR
         AIF   (&MACHINE NE 20 OR &CONSOLE EQ 0).WRTNSKP
WCT      EQU   &WTOSIZE            LENGTH OF CONSOLE LINE
WCTCCW   EQU   WTYPE+6             LOCATION OF XIO INSTRUCTION
WCTRTN   EQU   $WCOMM1+4           LOCATION OF NEXT COMMUTATOR ENTRY
.WRTNSKP ANOP
         AIF   (&LOCCOM EQ 0).WXX1
 TITLE 'L O C A L   C O M M A N D   P R O C E S S I N G'
***********************************************************************
*
*        COMMANDS ARE OF THE FORM:
*              .VP1...PN    WHERE: . IS ID IN FIRST POSITION
*                                  V= VERB, SINGLE CHARACTER IN POS 2
*                                  P1...PN ARE PARAMETERS FOR COMMAND
*                                       PROCESSORS. (NO BLANKS)
*
*        DATA AREAS:
*   $VERBTAB   VERB TABLE LIST OF SINGLE CHARACTER COMMAND VERBS
*              APPEARING IN COLLATING SEQUENCE, ENDING WITH X'FF'
*   $LOCCOM    LOCAL COMMAND PROCESSOR LIST, ENTRY POINT OF COMMAND
*              PROCESSOR TO INITIALLY HANDLE THE COMMAND.
*   $COMMAND   WORK AREA CONTAINING VERB AND PARAMETERS.
*
***********************************************************************
$VERBTAB DS    0C                  VERB TABLE
         DC    C'S'                START COMMAND
         DC    X'FF'               END OF TABLE
$LOCCOM  DS    0F                  LOCAL COMMAND PROCESSOR POINTERS
         $ACON WXS                 START COMMAND
$COMMAND DC    CL4' '              WORK AREA FOR COMMAND PROCESSORS
WXXSAV   $ACON 0                   I/O PROCESSOR RETURN POINT
         USING TCTDSECT,R15
$WLOCAL  DS    0H                  ENTRY TO FIND COMMAND'S PROCESSOR
         $STO  R14,WXXSAV          SAVE RETURN ADDRESS
         OI    $COMMAND,C' '       SET EXPECTED CHAR UPPER CASE
         OI    $COMMAND+1,C' '     SET EXPECTED CHAR UPPER CASE
         $LA   R14,$VERBTAB        PICK UP COMMAND VERB TABLE
WXXLOOP  CLC   0(1,R14),$COMMAND   LOOK FOR MATCHING VERB
         BE    WXXLOC              FOUND MATCH IF EQUAL
         BH    WXXRET              NOT IN TABLE IF HI (IGNORE)
         $AA   R14,1               BUMP TO NEXT ENTRY
         B     WXXLOOP             LOOK AGAIN
WXXRET   $LOAD R14,WXXSAV          RETURN TO USER
         BR    R14                 AT NSI
WXXLOC   $SA   R14,$VERBTAB        CREATE OFFSET
         AIF   (&HICORE GT 32).WXX2
         AR    R14,R14             DOUBLE IT
         AGO   .WXX2A
.WXX2    ANOP
         SLL   R14,2               CREATE ADCON OFFSET
.WXX2A   ANOP
         $AA   R14,$LOCCOM         ADD ORIGIN OF COMMAND TABLE
         $LOAD R14,0(0,R14)        PICK UP COMMAND PROCESSOR ENTRY
         BR    R14                 GO TO COMMAND PROCESSOR
         EJECT
*
*        AIDS FOR COMMAND PROCESSORS
*
*        FIND CORRESPONDING TCT -- ID IN POS 2 OF $COMMAND AREA
WXXFIND  DS    0H
         $LA   R15,$TCT1           PICK UP TCT CHAIN
WXXFL    CLC   TCTID,$COMMAND+1    CHECK FOR MATCH
         BE    4(0,R14)            RETURN IF FOUND
         $LOAD R15,TCTNEXT         PICK UP NEXT TCT
         $LTR  R15,R15             TEST FOR END OF CHAIN
         BNE   WXXFL               LOOP BACK IF NOT END
         BR    R14                 ERROR RETURN
*
*        COMMAND PROCESSORS        COMMANDS THAT DO NOT ISSUE WAITS
*
*                                  FIRST LEVEL COMMAND PROCESSORS
WXS      DS    0H                  START COMMAND
         BAS   R14,WXXFIND         FIND TCT
         B     WXXRET              RETURN TCT NOT FOUND
         NI    TCTSTAT,255-TCTSTOP START THE TCT
         $LOAD R15,TCTCOM          PICK UP COMMUTATOR ENTRY
         OI    1(R15),X'F0'        OPEN THE GATE
         B     WXXRET              RETURN
*
*        SECOND LEVEL COMMAND PROCESSORS REQUIRING COMMUTATOR GATES
*                                  MUST HAVE A CORRESPONDING FIRST
*                                  LEVEL COMMAND PROCESSOR
         DROP  R15
.WXX1    ANOP
         PRINT GEN
 TITLE '$ P U T   --  TPPUT INTERFACE ROUTINE'
*
*        $PUT  ROUTINE             INTERFACE WITH $TPPUT
*
&A       SETA  0
OXDUM    DSECT                     SYMBOLIC AID FOR PUT ROUTINE
         AIF   (&MACHINE EQ 20).OXB
OXGDRET  DS    H                   RETURN ADDR TO USER
         AGO   .OXAB
.OXB     ANOP
OXTNK    DS    H                   TANK ADDRESS
OXTCT    DS    H                   TCT ADDRESS
OXBADRET DS    2H                  WAIT RETURN
OXGDRET  DS    2H                  RETURN ADDR TO USER
.OXAB    ANOP
HASPRTP  CSECT
         USING OXDUM,R14
         USING TANKDSEC,R8
         AIF   (&MACHINE EQ 20).OX1
*        R8 POINTS TO TANK, R14 POINTS TO RETURN, TCTR POINTS TO TCT
         USING TCTDSECT,TCTR
$PUT     NULL
         $STO  R14,TCTSAV1         SAVE RETURN ADDRESS
OXSAV    EQU   TCTSAV1             LOCAL SYMBOL FOR SAVE AREA
         $STO  R8,TCTCCW+4-&L      SAVE TANK ADDRESS
         AGO   .OXA1
.OX1     ANOP
*        R14 POINTS TO USER CALLING SEQ WITH TANK AND TCT ADDRESS
         USING TCTDSECT,R9
$PUT     NULL
         AH    R14,=H'4'           SKIP OVER INITIAL BAS INST
         STH   R14,OXSAV           SAVE RETURN ADDRESS (OFFSET)
         LH    R8,OXTNK            PICK UP ADDRESS OF TANK
         LH    R9,OXTCT            PICK UP ADDRESS OF TCT
.OXA1    AIF   (&CONSOLE EQ 0).OX2
OXLOOP   TM    WCTSTAT,TCTREL      IS INTERLOCK RELEASE ON
         BZ    OXPUT               IF NOT DO NORMAL $TPPUT
         $LA   R8,WCTTANK1         PICK UP CONSOLE TANK ADDRESS
         BAS   R14,$TPREPUT        ATTEMPT TO SEND TO HASP
         $LOAD R14,OXSAV           PICK UP RETURN ADDR
         AIF   (&MACHINE NE 20).OX3
         LH    R9,OXTCT            PICK UP TCT ADDR
.OX3     ANOP
         BNE   OXFINTST            IF TANK OK TEST FOR MORE WORK
         TM    TCTSTAT,TCT1052     IF NOT OK TEST FOR USER ID
         BO    $WTORCOM+4  DIDNT GO AGAIN--LEAVE INTERLOCK REL ON U0019
         AIF   (&MACHINE EQ 20).OX4
         $DELAY O,T,PREVLOC=OXLOOP IF NOT WAIT AND TRY AGAIN
         AGO   .OXA4
.OX4     ANOP
         B     OXNORMA             IF NOT THEN FORGET IT PUT USERS
.OXA4    ANOP
OXFINTST NI    WCTSTAT,255-TCTREL  RESET INTERLOCK RELEASE
         TM    TCTSTAT,TCT1052     CHECK USER ID
         BO    WTOR2       CONSOLE GOT US HERE--GO PUT OUT WTOR   U0019
         MVI   WTOR1+1,X'F0'    SET UP FOR WTOR ONLY              U0019
         MVI   $WTORCOM+1,X'F0'    OPEN WTOR GATE                 U0019
         AIF   (&MACHINE EQ 20).OX5
         $LOAD R8,TCTCCW+4-&L      PICK UP TANK
         AGO   .OXA5
.OX5     ANOP
OXNORMA  LH    R8,OXTNK            PICK UP TANK
.OXA5    ANOP
.OX2     ANOP
OXPUT    BAS   R14,$TPPUT          SUBMIT TANK FOR TRANSMISSION
         $LOAD R14,OXSAV           RESTORE RETURN POINTER
         AIF   (&MACHINE NE 20).OX7
         LH    R9,OXTCT            PICK UP TCT ADDR
.OX7     ANOP
         BNE   OXGDRET             IF TANK WENT OK THEN RETURN
         AIF   (&CONSOLE EQ 0).OX8
         TM    TCTSTAT,TCT1052     IF NOT TEST FOR CONSOLE
         BZ    OXWAIT              IF NOT CONSOLE WAIT
         OI    WCTSTAT,TCTREL      SET INTERLOCK RELEASE INDICATOR
         B     $WTORCOM+4      DONT WTOR UNTIL THIS TANK GETS OUT U0019
OXWAIT   DS    0H                  WAIT TO RESUBMIT TANK
.OX8     AIF   (&MACHINE EQ 20).OX9
         MVC   RCTENTY(2),OBUFNOW     SET UP FOR REENTRY          U0019
         MVI   $RCOMM1+1,X'00'         CLOSE READER GATE          U0019
         MVI   RDRWFB,X'FF'       SET READER-WAITING-FOR-BUFFER   U0019
         B     $RCOMM1+4                                          U0019
BUFNOW   EQU   *                                                  U0019
         MVI   RDRWFB,X'00'  RESET WAIT SWITCH                    U0019
         MVI   $RCOMM1+1,X'00'      CLOSE READER GATE             U0019
         $LOAD R8,TCTCCW+4-&L      PICK UP TANK ADDRESS
         BAL   R14,$TPREPUT        RESUBMIT TANK FOR TRANSMISSION
         $LOAD R14,OXSAV           PICK UP USER RETURN POINT
         BE    OXWAIT                                             U0019
         AGO   .OXA9
.OX9     ANOP
         B     OXBADRET            WAIT ONE TIME AROUND COMMUTATOR
OXSAV    DC    H'0'                SAVE AREA
$PUTA    STH   R14,OXSAV           REENTRY AFTER A WAIT
         LH    R8,OXTNK            PICK UP TANK ADDR
         BAS   R14,$TPREPUT        RESUBMIT TANK FOR TRANSMISSION
         LH    R14,OXSAV           PICK UP RETURN POINTER
         BE    OXBADRET            IF IT DIDN'T GO WAIT AGAIN
.OXA9    ANOP
         B     OXGDRET             RETURN
         DROP  R14,R8
         AIF   (&MACHINE NE 20).OXC
         DROP  R9
.OXC     ANOP
         AIF   (&MACHINE EQ 20).OX50
 TITLE '$ G E T T N K  --  $ C L O S T C T  -- PROCESSOR ASSISTS'
*
*        $GETTNK                   ROUTINE TO GET A TANK FOR PROCESSOR
*
$GETTNK  NULL
         $STO  R14,TCTSAV1         SAVE USER REG FOR POSSIBLE WAIT
         $DELAY O,T,TYPE=SETUP     SET REENTRY FOR POSSIBLE WAIT
         $DCHAIN TCTTANK,R8,ENBL,EMPTY=$CLOSTCT GET TANK OUT OF Q
         $TCTPOST T,R9             POST COMPLETION
         $LOAD R14,TCTSAV1         PICK UP USER
         BR    R14                 RETURN TO HIM
*
*        $CLOSTCT                  ROUTINE TO CLOSE GATE AND RETURN
*
$CLOSTCT NULL
         $LOAD R9,TCTCOM           PICK UP COMMUTATOR
         NI    1(R9),X'0F'         CLOSE GATE
         B     4(R9)               RETURN TO COMMUTATOR
.OX50    ANOP
         $ENDPROC O                END OF PUT ROUTINE
OBUFNOW  DC    S(BUFNOW)                                          U0019
RDRWFB   DC    X'00'                                              U0019
 TITLE 'HRTP  $ L O G  --  LOG SUBROUTINE'
         USING LOGDSECT,R15
$LOG     NULL
         $STO  R14,LOG14SAV        SAVE R14
         $STO  R15,LOGRTN          STORE RTN REG
         LH    R15,0(0,R15)        PICK UP ERROR ENTRY OFFSET
         $AA   R15,$ERRTAB         ADD ERROR TABLE ORIGIN
         LH    R14,LOGCOUNT        LOAD ERROR COUNT
         AH    R14,=H'1'           UP COUNT BY ONE
         STH   R14,LOGCOUNT        STORE NEW COUNT
         AIF   (&TRACE EQ 0).LNOTRC
         $LOAD R14,$TRACUR         PICK UP CURRENT TRACE ADDR
         AH    R14,=H'4'           INCREMENT TO NEXT POSITION
         CH    R14,$TRAEND         IS THIS THE END OF THE TABLE
         BNH   LOGADD              BR LOW OR EQUAL TO ADD ENTRY
         $LOAD R14,$TRASTRT        LOAD ADDR OF FIRST ENTRY
LOGADD   NULL
         MVC   0(1,R14),LOGID      MOVE LOG ID TO TRACE TABLE
         MVC   1(3,R14),$LOGINFO   MOVE IN 3 BYTES OF INFORMATION
         $STO  R14,$TRACUR         UP DATE CURRENT POINTER
.LNOTRC  AIF   (&CONSOLE EQ 0 AND &PRTCONS EQ 0).LOGNOT
         CLI   LOGCLASS,&LOGCLAS   TEST FOR LOGABLE ERROR
         BL    LRTN                SKIP ADDING TO LOG TAB IF NOT
         $LOAD R14,$LOGLAST        GET ADDRESS OF LAST ENTRY
         $AA   R14,4               INCREMENT TO NEXT ENTRY
         $CA   R14,$LOGEND         ARE WE AT END OF TABLE
         BL    LOGOUT              IF NOT LOG INTO THE TABLE
         $LA   R14,$LOGTAB         IF SO RESET TO BEGINNING OF TABLE
LOGOUT   $STO  R14,$LOGLAST        SAVE ENTRY
         MVC   0(1,R14),LOGID      BUILD MESSAGE TO BE LOGGED,ID
         MVC   1(3,R14),$LOGINFO   HEX BYTES, FORGET TEXT
         OI    $WCOMM1+1,X'F0'     OPEN THE CONSOLE GATE
         $CA   R14,$LOGOUT         HAVE WE LAPPED CONSOLE LOGGING
         BNE   LRTN                IF NOT RETURN
         $AA   R14,4               IF SO CHASE IT AHEAD 1 ENTRY
         $STO  R14,$LOGOUT         SAVE IT FOR CONSOLE
.LOGNOT  ANOP
LRTN     $LOAD R14,LOG14SAV        RESTORE R14
         $LOAD R15,LOGRTN          PICK UP CALLER
         MVC   $LOGINFO,=F'0'      ZERO OUT LOG INFO FOR NEXT LOG
         B     2(0,R15)            RETURN
LOG14SAV $ACON
LOGRTN   $ACON
$LOGCLAS EQU   &LOGCLAS
         DROP  R15
 TITLE '$ T P P U T  -- BUILDS BUFFERS FOR TRANSMISSION TO HASP '
*
*  ENTRY - $TPPUT
*                 REGISTERS - R8=RECORD TANK 2(R8)=RCB,3(R8)=SRCB
*                            R14=RETURN ADDR ,CC=0 - RECORD NOT TAKEN
*                                             CC.NE.0-RECORD ACCEPTED
*                            R15 IS CONSIDERED VOLITILE
*
*
$TPPUT   NULL
        $TRACE SSM=YES
         $STO  R14,OSAVR14         SAVE RETURN
         ST    R10,OSAVR10                                        U0019
         ST    R9,OSAVR9                                          U0019
        $STO   R8,OINADD           SAVE INPUT TANK ADDR
         L     R15,=F'1'                                          U0019
        $LOAD  R10,OINADD          COMPRESSION WORK AREA
         A     R10,=A(TANKRCB-TANKDSEC)                           U0019
         USING TANKDSEC,R8         *
         LH    R9,TANKCNT          TANK DATA COUNT
         CH    R9,=H'0'            IS THIS A NULL RECORD
         BE    OEOINPUT            BR IF YES TO ADD TO BUFFER
         AIF   (&CMPTYPE LE 1).ONOCOMP TEST NONE OR TRAILING COMP
         AR    R9,R8               INCLUDE TANK ADDR
        $STO   R9,OINEND           TO SAFE STORAGE
         CLI   OTS(R8),2           IS THIS A TEXT CARD
         BNE   OGOA                BR IF NO
*                   SKIP ATTEMPTING TO COMPRESS A TEXT CARD
         LH    R9,TANKCNT          INPUT COUNT
        $LTR   R11,R8              INPUT ADDR
         AR    R8,R9               END OF RECORD
         AH    R9,OD200            COUNT FORMAT
         B     OSQUEEZE            GO PROCESS RECORD
OGOA     NULL
         MVI   OTS(R9),0           SETUP ENDING CHARACTER
         AIF   (&CMPTYPE EQ 2).ONB8
         CLI   OTS-1(R9),0         DOES ENDING MATCH LAST DATA CHAR
         BNE   *+8                 BR IF NOT
         MVI   OTS(R9),255         YES...USE ANOTHER
.ONB8    ANOP
         MVC   OTS+1(&CCT-1,R9),OTS(R9) PROPAGATE FOR DUPLICATION
OGO      NULL
        $LA    R14,OGO1            LOAD FOR SPEED
        $LA    R13,OSQUEEZE        LOAD FOR SPEED
         LH    R9,OD200            INITIAL COUNTER FOR MVC
        $LTR   R11,R8              INPUT AREA TO R11
OGO1     NULL
         AIF   (&CMPTYPE NE 2).ONB1
         CLI   OTS+&CCT-1(R8),64   IS LOOK-AHEAD A BLANK
         BNE   OSKIPUP             BR IF NO
.ONB1    ANOP
         CLC   OTS(&CCT-1,R8),OTS+1(R8) CHECK FOR COMPRESSABILITY
         BCR   8,R13               BR IF COMPRESSABLE (TO OSQUEEZE)
         AR    R8,R15              UP DATA PTR
         AR    R9,R15              AND CHAR COUNT
         BR    R14                 CONTINUE (TO OGO1)
         AIF   (&CMPTYPE NE 2).ONB2
OSKIPUP  NULL  *                   SKIP &CCT CHARACTERS
         A     R8,=A(&CCT)                                        U0019
         AH    R9,=Y(&CCT)         BUT COUNT IT
         C     R8,OINEND                                          U0019
         BCR   4,R14               BR IF NO
         S     R8,OINEND                                          U0019
         SR    R9,R8               ADJUST STRING COUNT
        $LOAD  R8,OINEND           RESET FOR TERMINATION
*              FALL THROUGH TO OSQUEEZE
.ONB2    ANOP
*
* OSQUEEZE - &CCT IDENTICAL CHARACTERS FOUND
*
*
OSQUEEZE NULL                      *
         CH    R9,OD200            IS A CHARACTER STRING ACTIVE
         BE    OCOMPTST            BR IF NO TO COMPRESS
         CH    R9,OD263            DOES STRING EXCEED SCB
         BH    OBIGMOVE            BR IF YES
         STH   R9,*+4              SET MOVE AND COUNT
         MVC   3(*-*,R10),OTS(R11) MOVE CHAR STRING (+1)
         MVC   2(1,R10),*-5        SET SCB COUNT
         OI    2(R10),X'C0'        SET SCB ID BITS
         SH    R9,OD200            REDUCE TO ACTUAL COUNT
         AR    R10,R9              FIX OUTPUT POINTER
         AR    R10,R15             COUNT SCB
OCOMPTST NULL  *                   TEST FOR EOI
         C     R8,OINEND                                          U0019
         BNL   OEOINPUT            BR IF YES
OCOMP    NULL
        $LA    R14,OCOMP1          FOR LOOP SPEED
        $LA    R13,OCMPSTOP        FOR LOOP SPEED
         LH    R9,=Y(&CCT)         START COMPRESSION COUNTER
OCOMP1   NULL  *                   CONTINUE COMPRESSION TESTING
         AIF   (&CMPTYPE NE 2).ONB3
         CLI   &CCT+OTS(R8),64     IS NEXT A BLANK
         AGO   .ONB4               BLANKS ONLY
.ONB3    ANOP
         CLC   (&CCT+OTS-1)(1,R8),(&CCT+OTS)(R8) DOES MATCH CONTINUE
.ONB4    ANOP
         BCR   7,R13               BR IF NO (TO CMPSTOP)
         AR    R9,R15              ANOTHER MATCH... COUNT IT
         AR    R8,R15              UP TO NEXT CHAR
         BR    R14                 CONTINUE (TO OCOMP1)
OCMPSTOP NULL  *                   IDENTICAL STRING ENDED
         CH    R9,=H'31'           DOES IT EXCEED SCB...
         BH    OBIGPROP            BR IF YES
         STH   R9,$TEMP            TO TEMPORARY STORAGE
         OI    $TEMP+1,X'80'       SET SCB ALWAYS BIT
         MVC   2(1,R10),$TEMP+1    SET SCB
         AIF   (&CMPTYPE EQ 2).ONB5
         CLI   (&CCT+OTS-1)(R8),C' ' ARE WE SQUEEZING BLANKS
         BE    OBLANK              BR IF YES
         MVC   3(1,R10),(&CCT+OTS-1)(R8) SET DUPLICATION CHAR
         OI    2(R10),X'20'        SHOW NON-BLANK DUPLICATION
         AR    R10,R15             SKIP SAMPLE CHAR
.ONB5    ANOP
OBLANK   NULL
         AR    R10,R15             COUNT SCB
         A     R8,=A(&CCT)                                        U0019
         B     OGO                 AND CONTINUE RECORD
OBIGPROP NULL  *                   DUPLICATION COUNT EXCEEDS SCB
         MVI   2(R10),X'9F'        SHOW MAX SCB
         AIF   (&CMPTYPE EQ 2).ONB6
         CLI   (&CCT+OTS-1)(R8),C' ' IS THIS BLANKS
         BE    OBIGBLNK            BR IF YES
         MVC   3(1,R10),(&CCT+OTS-1)(R8) SET SAMPLE CHAR
         OI    2(R10),X'20'        SHOW NON-BLANK
         AR    R10,R15             COUNT SAMPLE
.ONB6    ANOP
OBIGBLNK NULL  *                   EXCESSIVE COUNT BLANKS
         AR    R10,R15             COUNT SCB
         SH    R9,=H'31'           ADJUST COUNT
         B     OCMPSTOP            AND TRY AGAIN
OBIGMOVE NULL                      STRING COUNT EXCEEDS SCB MAXIMUM
         MVC   3(63,R10),OTS(R11)  MOVE MAX
         MVI   2(R10),X'FF'        SET MAX SCB
         A     R10,=F'64'                                         U0019
         A     R11,=F'63'                                         U0019
         SH    R9,=H'63'           REDUCE COUNT
         B     OSQUEEZE            AND TRY AGAIN
         AGO   .OSKNCMP
.ONOCOMP ANOP
OBIGMOVE NULL  *                   MOVE MAXIMUM SCB COUNT
         AIF   (&CMPTYPE NE 1).ONB7
        $LA    R14,ONXTBLK         LOAD FOR SPEED
        $LA    R13,ONONBLK         LOAD FOR SPEED
         AR    R9,R8               R9 = EOR+1
ONXTBLK  NULL  *                   PROCESS NEXT CHARACTER
         CLI   OTS-1(R9),64        IS CHARACTER BLANK
         BCR   7,R13               BR IF NO (TO XNONBLK)
         SR    R9,R15              YES...REDUCE COUNT
         BR    R14                 AND CONTINUE (AT ONXTBLK)
ONONBLK  NULL  *                   LAST TRAILING BLANK OUT
         SR    R9,R8               REDUCE TO TRUE COUNT
         BP    *+8                 BR IF ANY NON-BLANKS
         LH    R9,=H'1'            RECORD IS ALL BLANK...FORCE 1
.ONB7    ANOP
         CH    R9,=H'63'           IS COUNT MAX OR GT
         BL    OENDER              BR IF NO
         MVC   3(63,R10),OTS(R8)   YES...MOVE MAX
         MVI   2(R10),255          SET MAX SCB
         AH    R10,=H'64'          COUNT ADDITION
         AH    R8,=H'63'           COUNT FROM
         SH    R9,=H'63'           REDUCE COUNT
         BZ    OEOINPUT            BR IF NO MORE
         B     OBIGMOVE            OTHERWISE CONTINUE
OENDER   NULL  *                   MOVE RESIDUAL COUNT
         STH   R9,$TEMP            SET COUNT
         MVC   *+7(1),$TEMP+1      AND PUT IN MVC
         MVC   3(*-*,R10),OTS(R8)  MOVE REST
         MVC   2(1,R10),*-5        SET SCB COUNT
         OI    2(R10),X'C0'        SET TYPE BITS
         AR    R10,R9              ADJUST OUTPUT POINTER
         AR    R10,R15             COUNT SCB
.OSKNCMP ANOP
*
*              END OF INPUT RECORD - TERMINATE AND ADD TO BUFFER
*
OEOINPUT MVI   2(R10),0            END-OF-RECORD SCB
         AR    R10,R15             COUNT IT
        $LOAD  R8,OINADD           STARTING ADDR OF COMPRESSED REC
         SR    R10,R8              REDUCE TO ACTUAL COUNT
         SH    R10,=Y(L'TANKCHN-2) COMPENSATE FOR FULL CHAIN WORD
         STH   R10,TANKCHN         SAVE COUNT IN TANK FOR $TPREPUT
OREENT   NULL                      RE-ENTRY POINT FROM $TPREPUT
        $LOAD  R9,OBUFPTR          GET ADDR OF ACTIVE BUFFER
         C     R9,=F'0'                                           U0019
         BE    OGETBUF             BR IF NO
OBUFOK   NULL  *                   VALID BUFFER
         CH    R10,OBUFCNT         WILL THIS RECORD FIT...
         BH    OBUFFULL            BR IF NO
         STH   R10,$TEMP           FOR STC
         MVC   *+7(1),$TEMP+1      SET IN MOVE
         MVC   0(*-*,R9),L'TANKCHN(R8) MOVE RECORD
         AR    R9,R10              UPDATE CURRENT PTR
        $STO   R9,OBUFPTR          AND RESET
         LH    R9,OBUFCNT          REMAINING COUNT
         SR    R9,R10              REDUCE BY THIS RECORD
         STH   R9,OBUFCNT          AND RESET
         CH    R10,=H'3'           WAS THIS A NULL RECORD
         BE    OFLUSH              BR IF YES TO WRITE BUFFER
         CLI   TANKRCB,&ORCB(1)    IS THIS OPER CMD TO HASP
         BE    OFLUSH              BR IF YES TO SEND BUFFER
ORETOK   NULL  *                   POSITIVE RETURN ENTRY
         OI    OFLSW+1,X'F0'       OPEN NORMAL GATE AND SET COND CODE
ORETURN  NULL                      RETURN--COND. CODE ALREADY SET
         L     R8,OINADD       RESTORE TANK ADDR                  U0019
         L     R9,OSAVR9                                          U0019
         L     R10,OSAVR10                                        U0019
         $LOAD R14,OSAVR14         GET RETURN
         BR    R14                 AND DO IT
OGETBUF  NULL  *
         SR    R9,R9               SET COND CODE
$TPPNONE NOP   ORETURN             SW SET BY COMSUP TO STOP BUFFERING
        $DCHAIN $BUFPOOL,R9        GET A BUFFER
         BZ    ORETURN             BR IF NONE (NOTE COND. CODE SET)
        $STO   R9,OACTBUF          SET BUFFER ADDR
         A     R9,=A(BUFDATA-BUFDSECT)                            U0019
        $STO   R9,OBUFPTR          SET CURRENT POINTER
         MVC   OBUFCNT,=Y(&TPBFSIZ-BUFDATA+BUFSTART-2) AND COUNT
         B     OBUFOK              AND GO FIT RECORD
*
*              BUFFER IS FULL--SEND IT TO HASP
*
OFLUSH   NULL  *                   ENTRY TO WRITE A PARTIAL BUFFER
         MVI   OFLSW+1,0           SET FLUSH SWITCH
OBUFFULL NULL
         $LOAD R9,OBUFPTR          GET CURRENT BUFFER POINTER
        $LOAD  R13,OACTBUF         FOR $EXTP
         USING BUFDSECT,R13
         MVI   0(R9),0             SET EOB
         SR    R9,R13              SUBTRACT SOB
         SH    R9,=Y(BUFSTART-BUFDSECT-1) MAKE COUNT ACTUAL
         STH   R9,BUFCOUNT         SET COUNT
         SR    R9,R9               ZERO
        $STO   R9,OBUFPTR          AND SHOW NO BUFFER
         BAS   R14,$EXTP           GO DO I/O
OFLSW    NOP   OGETBUF             FLUSH SWITCH
         B     ORETOK              JUST RETURN IF FLUSH
         DROP  R13
*
*              RE-ENTRY POINT IF ORIGINAL $TPPUT NOT ACCEPTED
*                R8=ORIGINAL TANK , R14= RETURN
$TPREPUT NULL
        $STO   R8,OINADD           SET FOR RESTORE
         $STO  R14,OSAVR14         RESET RETURN
         ST    R10,OSAVR10                                        U0019
         ST    R9,OSAVR9                                          U0019
         LH    R15,=H'1'           CONSTANT
         LH    R10,TANKCHN         COMPRESSED COUNT
         B     OREENT              ENTER FLOW
         EJECT
*
*
*
*
OSAVR9   $ACON 0                   REG SAVE
OSAVR10  $ACON 0                   REG SAVE
OSAVR14  $ACON 0                   RETURN ADDR SAVE
OINADD   $ACON 0                   INPUT TANK ADDR
OINEND   $ACON 0                   LAST VALID DATA BYTE IN TANK
OACTBUF  $ACON 0                   ACTIVE BUFFER ADDR
OBUFPTR  $ACON 0                   CURRENT POINTER IN BUFFER
OBUFCNT  DC    H'0'                REMAING SPACE COUNT IN BUFFER
OD200    DS    0H
         DC    X'D200'             CONSTANT FOR MVC COUNT
OD263    DS    0H
         DC    X'D23F'             MAX SCB CNT + MVC
OTS      EQU   TANKDATA-TANKDSEC
         DROP  R8                  DISCONTINUE TANK REG
 TITLE ' $ T P G E T  --DEBLOCKS BUFFERS RECEIVED FROM HASP  '
*
*
$TPGET   NULL  *                   ENTERED FROM COMUTATOR
         MVI   $TPGETCM+1,0        CLOSE COMMUTATOR
        $LA    R13,$TCT1           BEGINNING OF TCT'S
         USING TCTDSECT,R13        **
GTEST    NULL  *                   *
         TM    TCTSTAT,TCTACT      IS ACTION REQUESTED
         BO    GSERVICE            BR IF YES
GNEXTTCT NULL
        $LOAD  R13,TCTNEXT         TO NEXT TCT
        $LTR   R13,R13             IS THIS END
         BNZ   GTEST               BR IF NO
*
*              ALL TCT'S HAVE BEEN SERVICED...
*
GWAIT    B     $TPGETCM+4          EXIT                           V03.1
         EJECT
*
*              SERVICE TCT WITH ACTION BIT ON
*
GSERVICE NULL  *
         CLI   TCTBUFCT,0          ARE ANY BUFFERS AVAILABLE
         BNE   GTTANK              BR IF YES
GNOACT   NI    TCTSTAT,255-TCTACT  NO... TURN OFF ACTION
         B     GNEXTTCT            AND CONTINUE
GTTANK   NULL  *                   A BUFFER IS PRESENT
         CLC   TCTTNKCT,TCTTNKLM   ARE SUFFICIENT TANKS QUEUED
         BNL   GNOACT              BR IF YES
*                   A DECOMPRESSION IS REQUIRED
        $DCHAIN $TANKPOL,R10,NOENB GET A TANK
         BZ    GWAIT               BR IF NONE
         USING TANKDSEC,R10        *
        $LOAD  R8,TCTBUFER         CURRENT BUFFER
         LH    R15,(BUFCOUNT-BUFDSECT)(0,R8)                      U0019
         AR    R8,R15                                             U0019
        $STO   R10,GTANK           SAVE TANK ADDR.
         MVC   TANKRCB(2),0(R8)    MOVE RCB AND SRCB
         LH    R15,=H'1'           CONSTANT FOR SPEED
GDECOMP  NULL  *                   PROCESS AN SCB
         MVC   GSCB(1),2(R8)       SET SCB
         NI    GSCB,X'7F'          TURN OFF HIGH-BIT
         BZ    GENDREC             END-OF-RECORD
         TM    GSCB,X'40'          IS THIS A CHAR STRING...
         BZ    GPROP               BR IF NOT
         NI    GSCB,X'3F'          TURN OFF STRING BIT
         MVC   TANKDATA(*-*),3(R8) MOVE STRING (+1)
GSCB     EQU   *-5                 SCB AND COUNT
         LH    R9,GSCB-1           GET MOVE COUNT
         SH    R9,GD200            REMOVE MOVE
         AR    R8,R9               COUNT INPUT STRING
GCONT    AR    R10,R9              COUNT OUTPUT STRING
         AR    R8,R15              COUNT SCB
         B     GDECOMP             CONTINUE WITH RECORD
GPROP    NULL  *                   PROPGATION REQUIRED
         TM    GSCB,X'20'          IS THIS BLANKS...
         BZ    GBLANKS             BR IF YES
         NI    GSCB,X'1F'          NO .. REMOVE INDICATOR
         MVC   TANKDATA(1),3(R8)   SET SAMPLE CHARACTER
         MVC   GMOV+1(1),GSCB      SET COUNT
GMOV     MVC   TANKDATA+1(*-*),TANKDATA  PROPAGATE COUNT (+2)
         LH    R9,GSCB-1           PROPAGATION COUNT
         SH    R9,GD200            LESS MOVE
         AR    R8,R15              COUNT SAMPLE CHAR
         B     GCONT               AND ENTER FLOW
GBLANKS  NULL                      BLANK PROPAGATION REQUIRED
         MVI   TANKDATA,C' '       SET BLANK SAMPLE
         MVC   *+7(1),GSCB         SET COUNT
         MVC   TANKDATA+1(*-*),TANKDATA PROPAGATE BLANKS
         LH    R9,GSCB-1           GET MOVE COUNT
         SH    R9,GD200            LESS MVC
         B     GCONT               ENTER FLOW
GENDREC  NULL                      END OF LOGICAL RECORD
        $LOAD  R9,GTANK            TANK ADDR
         SR    R10,R9              FROM END PTR                       X
         DROP  R10
         USING TANKDSEC,R9
         STH   R10,TANKCNT         SET COUNT IN TANK
        $LA    R10,TCTTANK-TCTDSECT TANK CHAIN DISPLACEMENT
         AR    R10,R13             R10 = ABSOLUTE TANK CHAIN PTR
        $CHAIN (R10),R9,NOENB      ADD TO TANK QUEUE
         A     R8,=F'3'                                           U0019
         LH    R10,TCTTNKLM        LIMIT AND COUNT
         AR    R10,R15             INCREMENT COUNT
         STH   R10,TCTTNKLM        AND RESET
        $LOAD  R10,TCTCOM          GET COMMUTATOR ENTRY
         MVI   1(R10),X'F0'        OPEN PROCESSOR GATE
        $LOAD  R9,TCTBUFER         CURRENT BUFFER ADDR
         CLC   TCTRCB,0(R8)        IS NEXT RECORD SAME
         BNE   GSWITCH             BR IF NO
         SR    R8,R9               REDUCE TO DATA DISPLACEMENT
         STH   R8,BUFCOUNT-BUFDSECT(0,R9)                         U0019
         B     GTTANK              AND CONTINUE
GSWITCH  NULL  *                   DIFFERENT RCB ENCOUNTERED
         $SSM  0                   DISABLE INTERRUPTS             V03.1
         MVC   TCTBUFER,0(R9)      UPDATE CHAIN
         $FREE $BUFPOOL,R9,NOENB   FREE THE BUFFER                V03.1
         CLI   RDRWFB,X'FF'    IS THE READER WAITING FOR BUFFERS  U0019
         BE    FIRERDR       IF SO FIRE HIM UP                    U0019
         TM    WCTSTAT,TCTREL    IS THE WTOR INTERLOCK ON???      U0019
         BZ    GASRET           IF NOT GO TO NORMAL EXIT          U0019
         MVI   $WTORCOM+1,X'F0'    OPEN WTOR GATE                 U0019
         MVI   INTRELSW+1,X'00'   SET UP WTOR PROC FOR RE-PUT     U0019
         B     GASRET          NORMAL EXIT                        U0019
FIRERDR  MVI   $RCOMM1+1,X'F0'   OPEN READER GATE                 U0019
GASRET   DS    0H                                                 U0019
         LH    R8,TCTBUFLM         BUFFER LIMIT AND COUNT
        $BCTR  R8,0                REDUCE COUNT
         STH   R8,TCTBUFLM         AND RESET
         CLC   TCTBUFCT,TCTBUFLM   IS ANOTHER BUFFER REQUIRED
         BNL   GENABLE             ENABLE INTERRUPTS              V03.1
        $OC    $FCSOUT,TCTFCS      SHOW NEXT BUFFER PERMITTED
         MVI   $FCSHOT+1,X'F0'     SHOW FCS CHANGE
GENABLE  $SSM  FF                  ALLOW INTERRUPTS               V03.1
         B     GSERVICE            AND CONTINUE
GTANK    $ACON 0                   TANK ADDR
GD200    EQU   OD200               SHARE CONSTANT
         DROP  R9                  DISCONTINUE TANK REG
 TITLE 'C O M S U P  --  $TPOPEN (OBTAINS PERMISSION TO BEGIN SENDING)'
$TPOPEN  NULL  *
        $TRACE SSM=YES
        $STO   R14,TSAVA           SAVE CALLER'S
        $STO   R8,TSAVB             REGS
         MVC   TTANK+TANKSRCB-TANKDSEC(1),TANKRCB-TANKDSEC(R8) SET FCN
        $LOAD  R8,TANKCON          FOR $TPPUT
         BAS   R14,$TPPUT          GO PUT RECORD
        $LOAD  R8,TSAVB            CALLER'S
        $LOAD  R14,TSAVA           REGS
         BR    R14                 RETURN TO CALLER
*                                  DUMMY TANK
TTANK   $ACON  0                   CHAIN
         DC    X'90'               RCB FOR FUNCTION CTL RECORD
         DC    X'00'               USER'S SRCB (FUNCTION TYPE)
         DC    H'0'                TANK COUNT
TSAVA   $ACON  0
TSAVB   $ACON  0
TANKCON $ACON  TTANK
 TITLE 'C O M S U P  --  $EXTP (ENTRY TO TRANSMIT A BUFFER TO HASP)'
*
*$EXTP - R14 = RETURN , R13 = BUFFER ADDR
*
         SPACE 3
$EXTP    NULL  *                   WRITE ENTRY POINT
         USING BUFDSECT,R13        BUFFER ADDR IS IN R13
         AIF   ('&XPARENT' EQ 'YES').NONXP1
&TEMP    SETA  (&TPBFSIZ-4)/256
&TEMP2   SETA  0
.AGAIN   AIF   (&TEMP EQ &TEMP2).ONEMORE
         TR    BUFDATA+256*&TEMP2.(256),$NONXPAR  TRANSLATE OUT
*                                  ANY CONTROL CHARACTERS
&TEMP2   SETA  &TEMP2+1
         AGO   .AGAIN
.ONEMORE ANOP
         AIF   (&TPBFSIZ-4-256*&TEMP2 EQ 0).DONE
         TR    BUFDATA+256*&TEMP2.(&TPBFSIZ-4-256*&TEMP),$NONXPAR
*                                  SHORT TRANSLATE
.DONE    ANOP
.NONXP1  ANOP
         AIF   (&HOME EQ 0).EXTPOK
*              LOCAL PROCESSING MODE SELECTED..............
         $SAVE R14,R15,CREGS       SAVE SOME REGS                 V03.1
         B     CHOMASGN            ASSIGN BUFFER TO TCT           V03.1
         AGO   .EXTPFK
.EXTPOK  ANOP
        $LA    R9,$OUTBUF          QUEUE CONTROL WORD
.EXTPFK  ANOP
        $CHAIN (R9),R13            QUEUE FOR TRANSMISSION
         BR    R14                 RETURN TO CALLER
         AIF   ('&XPARENT' EQ 'YES').NONXP2
$NONXPAR DC    64X'00'             TAKE OUT CTL CHARS
         DC    192AL1(*-$NONXPAR)  NON-CTL CHARS
.NONXP2  ANOP
         DROP  R13                 KILL BUFFER ADDRESSABILITY
 TITLE 'C O M S U P  -- INTERRUPT PROCESSOR (DEFINITIONS)  '
         SPACE 3
*                        CONTROL CHARACTERS
         SPACE 2
XSOH     EQU   X'01'               START OF HEADING
XSTX     EQU   X'02'               START OF TEXT
XETX     EQU   X'03'               END OF TEXT
XDLE     EQU   X'10'               DATA LINK ESCAPE
XETB     EQU   X'26'               END OF TEXT BLOCK
XENQ     EQU   X'2D'               ENQUIRY
XSYN     EQU   X'32'               SYNCHRONIZATION
XEOT     EQU   X'37'               LOST BLOCK ALARM
XNAK     EQU   X'3D'               NEGATIVE ACKNOWLEDGEMENT
XACK1    EQU   X'61'               POSITIVE ACKNOWLEDGEMENT-CONDITIONAL
XACK0    EQU   X'70'               POSITIVE ACKNOWLEDGEMENT
         AIF   ('&XPARENT' EQ 'YES').XPARA
XLDR     EQU   XSOH                NON-TRANSPARENCY HEADER
XTRL     EQU   XSYN                NON-TRANSPARENCY TRAILER
XCHN     EQU   X'A0'               NON-TRANSPARENT CCW CHAINING BITS
         AGO   .XPARB
.XPARA   ANOP
XLDR     EQU   XDLE                TRANSPARENT HEADER
XTRL     EQU   XDLE                TRANSPARENT TRAILER
XCHN     EQU   X'60'               TRANSPARENT CCW CHAINING BITS
.XPARB   ANOP
         SPACE 5
         AIF   (&MACHINE NE 20).D1
         SPACE 5
*                        COMMUNICATIONS ADAPTER ADDRESSES
         SPACE 2
CAINTID  EQU   X'56'               BSCA INTERRUPT IDENTIFIER
CAREAD   EQU   X'54'+1             BSCA RECEIVE CODE
CAWRITE  EQU   X'58'+1             BSCA TRANSMIT CODE
CASENSE  EQU   X'57'               BSCA SENSE CODE
CAERROR  EQU   X'50'               BSCA ERROR TEST CODE
CASCA    EQU   X'56'               BSCA STORE CURRENT ADDRESS
CAENABLE EQU   X'52'               BSCA ENABLE CODE
CARECI   EQU   X'51'+1             BSCA RECEIVE INITIAL CODE
CAWRTRD  EQU   X'50'+1             BSCA TRANSMIT-RECEIVE CODE
         AGO   .D2
.D1      ANOP
         SPACE 5
*                        /360 MACHINE CHARACTERISTICS
         SPACE 2
$ADAPTER EQU   X'&ADAPT'           ADDRESS OF COMMUNICATIONS ADAPTER
$IOOLD   DC    F'0'                                               U0019
         DC    A($START)                                          U0019
$CAW     EQU   X'48'
.D2      ANOP
         SPACE 2
*                        BLOCK CONTROL BYTE INDICATORS
         SPACE 2
BCBIGNRE EQU   X'10'               IGNORE BLOCK COUNT INDICATOR
BCBRESET EQU   X'20'               RESET BLOCK COUNT INDICATOR
 TITLE 'C O M S U P  -- INTERRUPT PROCESSOR (ENTRY POINT)             '
$IOINT   NULL  *                   ALL INTERRUPTS ENTER HERE
         AIF   (&MACHINE NE 20).X2
         CLI   145,CAINTID         IS THIS BSCA
         BNE   $NOTTP              BR IF NO
$COMBUSY B     CEXIT               RETURN IF NO ACTIVITY
         TIOB  CERROR,CAERROR      BR IF ANY ERROR
CREADREQ B     CENDREAD            BR IF READ ENDING
CRDRESP  XIO   *-*(CAREAD),&TPBFSIZ OTHERWISE START READ
CREADCT  EQU   *-2                 READ COUNT FIELD               V03.1
         BC    7,*-6               WAIT FOR READ TO TAKE
         MVI   CREADREQ+1,X'F0'    SHOW READ ACTIVE
         SPSW  144                 AND EXIT
CREXIT   NULL
         AIF   (&TRACE EQ 0 OR &MACHINE NE 20).ITRA
        $RESTORE R12,R15,CREGS     RESTORE INTERRUPTED REGISTERS
         AGO   .ITRB
.ITRA    ANOP
        $RESTORE R13,R15,CREGS     RESTORE INTERRUPTED REGS
.ITRB    ANOP
CEXIT    NULL
         SPSW  144                 RETURN TO INTERRUPTED LOCATION
         AGO   .X3
.X2      ANOP
$INTRUPT MVI   $COMCOM+5,X'00'                                    U0019
$COMBUSY NOP   CEXIT               BR IF NO COMMUNICATIONS I/O ACTIVE
        $SAVE  R13,R15,CREGS       SAVE INTERRUPTED REGS
         $LOAD R13,CBUFFER         GET CURRENT BUFFER ADDR
CUWFAKE  NOP   CWRTSIO             *** DUMMY READ SWITCH ***      V03.1
         TM    $CSW+5,X'BF'        TEST FOR UNEXPECTED ERRORS
         BNZ   CBADERR             BR IF ANY
         TM    $CSW+4,X'F3'        TEST OTHER UNUSUAL ENDINGS
         BNZ   CERROR              BR IF ANY
*              CHANNEL-END , DEVICE-END ASSUMED
.X3      ANOP
 TITLE 'C O M S U P  -- CENDREAD (PROCESS NORMAL READ COMPLETION) '
         SPACE 3
$ENDREAD NULL  *                   EXTERNAL ENTRY POINT
CENDREAD NULL  *                   EXAMINE CONTROL INFORMATION
         AIF   (&MACHINE NE 20).X21
         AIF   (&TRACE EQ 0 OR &MACHINE NE 20).ITRC
        $SAVE  R12,R15,CREGS       SAVE INTERRUPTED REGS
         $LOAD R12,=Y($SVC)        SET TRACE ENTRY
         AGO   .ITRD
.ITRC    ANOP
        $SAVE  R13,R15,CREGS       SAVE INTERRUPTED REGS
.ITRD    ANOP
        $LOAD  R13,CBUFFER         GET ACTIVE BUFFER
.X21     ANOP
         USING BUFDSECT,R13        *
         SPACE 3
         B     CNOLOGAL            AVOID LOG OVERHEAD
         SPACE 2
*              NOP THE ABOVE BRANCH TO LOG EVERY BLOCK RECEIVED
         SPACE 2
         MVC   $LOGINFO(3),BUFSTART+1 RESPONSE LEADERS
        $LOG   XTPREAD             LOG RECEIVED DATA
CNOLOGAL NULL  *                   ENTRY TO SKIP LOGGING EVERYTHING
         MVC   CRESP,BUFSTART      GET FIRST RESPONSE BYTE
         CLI   CRESP,XDLE          IS IT DLE LEADER...
         BNE   *+10                BR IF NO
         MVC   CRESP,BUFSTART+1    YES... GET REAL RESPONSE
         CLI   CRESP,XSOH          IS THIS NON-XPARENT LEADER...
         BE    CINBUF              BR IF YES TO PROCESS TEXT
         CLI   CRESP,XSTX          IS THIS DATA
         BE    CINBUF              BR IF YES TO PROCESS
         CLI   CRESP,XACK0         IS THIS WRITE ACKNOWLEDGEMENT
         BE    CACKED              BR IF YES
         CLI   CRESP,XNAK          WERE WE NAK'ED
         BE    CNAKED              BR IF YES
         B     CRESPBAD            UNKNOWN RESPONSE RECEIVED
 TITLE 'C O M S U P  -- CWRTOK   (INITIATE NEXT WRITE)   '
*
*              POSITIVE ACKNOWLEDGEMENT OF LAST WRITE RECEIVED
*
         SPACE 3
CACKED   NULL  *                   ACKNOWLEDGEMENT WAS ACK
         NI    $FCSIN,255-X'40'    TURN OFF WAIT-A-BIT
CWRTOK   NULL
         TM    BUFSTAT,BUFFAKE     IS THIS A DUMMY BUFFER
         BO    CWRTNEXT            BR IF YES
         MVI   BUFSTAT,0           RESET STATUS BYTE
        $FREE  $BUFPOOL,R13,NOENB  RELEASE WRITTEN BUFFER
         CLI   RDRWFB,X'FF'    IS READER WAITING FOR BUFFERS??    U0019
         BE    FIRERDR1     IF SO START HIM UP                    U0019
         TM    WCTSTAT,TCTREL  IS WTOR INTERLOCK ON??             U0019
         BZ    CWRTNEXT    NORMAL EXIT                            U0019
         MVI   $WTORCOM+1,X'F0'    OPEN WTOR GATE                 U0019
         MVI   INTRELSW+1,X'00'    SET UP WTOR PROC FOR RE-PUT    U0019
         B     CWRTNEXT          NORMAL EXIT                      U0019
FIRERDR1 MVI   $RCOMM1+1,X'F0'    OPEN READER GATE                U0019
CWRTNEXT NULL  *                   ENTRY TO START NEXT WRITE
         LH    R14,$WAITCON        LOAD DELAYING CONSTANT
         MVC   CREADCT(2),=Y(&TPBFSIZ) SET READ COUNT TO FULL     V03.1
CYCLE    NULL  *                   COMMUTATOR CYCLE POINT
         TM    $FCSIN,X'40'        IS WAIT-A-BIT SET
         BO    CWAITBIT            BR IF YES
         MVI   $TPPNONE+1,0        RESET BUFFERING STOP
        $DCHAIN $OUTBUF,R13,NOENB  OTHERWISE CHECK WRITE QUEUE
         BNZ   CSTNDWRT            BR IF WRITE BUFFER GOTTEN
$FCSHOT  NOP   CRESPOND            SW TO FORCE FCS RESPONSE
         CLI   TIMOUTST,X'FF'                                     U0019
         BE    $START                                             U0019
         MVI   TIMOUTST,X'FF'                                     U0019
         STM   R13,R15,STIMREGS                                   U0019
         XC    TIMECB,TIMECB                                      U0019
         MVI   TIMESW,X'00'                                       U0019
         STIMER REAL,TIMEXIT,DINTVL=TIMEINTV                      U0019
         B     $START                                             U0019
$TIMBACK LM    R13,R15,STIMREGS                                   U0019
         MVI   TIMOUTST,X'00'                                     U0019
         B     CRESPOND                                           U0019
STIMREGS DC    3F'0'                                              U0019
TIMECB   DC    F'0'                                               U0019
TIMESW   DC    X'00'                                              U0019
TIMOUTST DC    X'00'                                              U0019
         DS    0D                                                 U0019
TIMEINTV DC    C'00000250'                                        U0019
         DS    0H                                                 U0019
CSTNDWRT NULL  *                   ENTRY FOR BUFFER WRITE WITH BCB
         MVC   BUFSTART,XSTXSEQ    SET START OF TEXT HEADER
         OI    BUFSTAT,BUFTEXT     SHOW TEXT BUFFER
         MVC   CSETBCB+1(1),CBCBCNTO BCB FOR CURRENT BUFFER
         LH    R15,CBCBCNTO-1      GET CURRENT COUNT
         AH    R15,=H'1'           INCREMENT TO NEXT
         STH   R15,CBCBCNTO-1      AND SAVE
         NI    CBCBCNTO,X'80'+15   MODULO 16
         B     CNWRITE             GO WRITE BUFFER
         SPACE 3
*
*              WAIT-A-BIT SEQUENCE RECEIVED FROM HASP
*
CWAITBIT NULL  *                   *
         MVI   $TPPNONE+1,X'F0'    STOP ALL BUFFERING
        $TRACE SSM=NO
         B     $FCSHOT             GO IDLE
 TITLE 'C O M S U P  -- CINBUF   (PROCESS INPUT BUFFER FROM HASP)  '
         SPACE 3
CINBUF   NULL  *                   *
         AIF   (&MACHINE EQ 20).CCOM20
         LA    R15,BUFSTART+&TPBFSIZ-1 POSITION TO END OF BUFFER
         SH    R15,$CSW+6          REDUCE BY RESIDUAL COUNT
         AGO   .CCOMN20            ENTER COMMON CODE
.CCOM20  ANOP
         CIO   CALASTPO,CASCA      LAST ADDR USED +1
         LH    R15,CALASTPO        TO REG
         AH    R15,=H'-1'          REDUCE TO LAST ADDR
.CCOMN20 ANOP
         CLI   0(R15),XETB         WAS ENDING SEQUENCE CORRECT
         BNE   CRESPBAD            BR IF YES TO LOG AND NAK
         MVC   $FCSIN,BUFFCS       SET NEW FUNCTION CONTROL
*              VERIFY BLOCK CONTROL BYTE COUNT
         MVC   CBCB(1),BUFBCB      GET BCB COUNT
CBCB     EQU   *+1                 COUNT BYTE
         CLI   CBCBCNTI,*-*        DOES RECEIVED MATCH EXPECTED
         BNE   CBCBCHEK            BR IF NO
         LH    R15,CBCBCNTI-1      GET CURRENT COUNT
         AH    R15,=H'1'           TO NEXT EXPECTED
         STH   R15,CBCBCNTI-1      AND RESET
         NI    CBCBCNTI,X'80'+15   MOLULO 16
CBCBOK   NULL  *                   ENTRY FROM IGNORE
         TM    BUFSTAT,BUFFAKE     IS THIS DUMMY BUFFER
         BO    CWRTOK              BR IF YES TO IGNORE
CHOMASGN $LA   R14,$TCT1           POINT TO FIRST TCT             V03.1
         USING TCTDSECT,R14                                       V03.1
COMPTCT  CLC   TCTRCB,BUFDATA      DOES BUFFER AND TCT RCBS MATCH V03.1
         BE    CASSIGN             IF SO ASSIGN BUFFER            V03.1
         $LOAD R14,TCTNEXT         GO TO NEXT TCT                 V03.1
         $LTR  R14,R14             TEST FOR END                   V03.1
         BNZ   COMPTCT             COMPARE AGAINST TCT            V03.1
         AIF   (&HOME NE 0).HOMCTL                                V03.1
         CLI   BUFDATA,0           ZERO RCB                       V03.1
         BE    CWRTOK              FREE BUFFER                    V03.1
         TM    BUFDATA,15          IS IT A CONTROL RECORD         V03.1
         BNZ   CWRTOK              FREE BUFFER IF NOT             V03.1
.HOMCTL  ANOP                                                     V03.1
         $LA   R14,$CTLTCT         POINT TO CONTROL TCT           V03.1
CASSIGN  $LA   R15,TCTBUFER-TCTDSECT GET BUFFER POINTER OFFSET    V03.1
         AR    R15,R14             POINT TO TCT BUFFER CHAIN      V03.1
         MVI   $TPGETCM+1,X'F0'    OPEN TPGETS GATE
         MVI   BUFSTAT,0           RESET BUFFER STATUS BITS
        $CHAIN (R15),R13,NOENB     QUEUE FOR PROCESSING
         $LA   R15,BUFDATA-BUFDSECT GET RCB OFFSET                V03.1
         STH   R15,BUFCOUNT        SAVE OFFSET TO FIRST RCB       V03.1
         LH    R15,TCTBUFLM        PICK LIMIT AND COUNT           V03.1
         $AA   R15,1               ADD 1 TO COUNT                 V03.1
         STH   R15,TCTBUFLM        SAVE                           V03.1
         OI    TCTSTAT,TCTACT      SHOW ACTION REQUIRED ON TCT    V03.1
         AIF   (&HOME EQ 0).HOMASGN                               V03.1
         $RESTORE R14,R15,CREGS    RESTORE REGS                   V03.1
         BR    R14                 RETURN TO CALLER               V03.1
.HOMASGN ANOP                                                     V03.1
         CLC   TCTBUFCT,TCTBUFLM   IS BUFFER MAXIMUM EXCEEDED     V03.1
         BL    CASMORE             IF NOT ALLOW MORE              V03.1
         $BITOFF $FCSOUT,TCTFCS,R15 TURN FCS BIT OFF              V03.1
         DROP  R14                                                V03.1
         B     CWRTNEXT            CONTINUE TRANSMISSION          V03.1
CASMORE  MVI   $FCSHOT+1,X'F0'     SHOW FCS ACTIVE                V03.1
         B     CWRTNEXT            AND CONTINUE XMISSION
*
*              RECEIVED BCB CHECK COUNT NOT CORRECT
*
CBCBCHEK NULL  *                   DETERMINE DAMAGE
         TM    CBCB,BCBIGNRE       IS THE IGNORE BIT ON
         BO    CBCBOK              BR IF YES
         TM    CBCB,BCBRESET       IS THIS A RESET REQUEST
         BZ    CBCBBAD             BR IF NO
         MVN   CBCBCNTI(1),CBCB    YES... DO IT
         B     CBCBOK              AND PROCESS RECORD
CBCBBAD  NULL  *                   BLOCK COUNTS DO NOT AGREE
         MVN   $LOGINFO(1),CBCB    SET FOR ERROR LOG
         MVN   $LOGINFO+1(1),CBCBCNTI SET FOR LOG
        $LOG   XBCBCHEK
         MVC   CTEMP+1(1),CBCB     ISOLATE RECEIVED CNT
         LH    R15,CBCBCNTI-1      GET EXPECTED CNT
         SH    R15,CTEMP           LESS RECEIVED
         BP    *+8                 BR IF TOO LOW
         AH    R15,=H'16'          MAKE DIFFERENCE POSITIVE
         CH    R15,CMAXDUP         IS DIFFERENCE REASONABLE
         BH    CBLKLOST            BR IF NO
         B     CWRTOK              IGNORE BLOCK
         SPACE 2
CBLKLOST NULL  *                   ONE OR MORE BLOCKS ARE LOST
         MVN   CLOSTBCB,CBCB       SET RECEIVED BLOCK COUNT
         MVN   CLSTSRCB,CBCBCNTI   SET EXPECTED BLOCK COUNT
         MVC   BUFCOUNT(CLOSTEND-CLOSTBLK),CLOSTBLK  SET BAD BLOCK
         MVC   CSETBCB+1(1),CLOSTBCB  SET RESTORE BCB INSTRUCTION V03.1
         B     CNWRITE             GO TELL HASP ABOUT BAD BCB
         SPACE 2
*              PROTOTYPE CTL RECORD TO TELL HASP THAT BLOCKS ARE LOST
         SPACE 2
CLOSTBLK NULL  *                   START
         DC    AL2(CLOSTEND-CLOSTBS) BUFCOUNT
         DC    AL1(BUFTEXT)        BUFSTAT
CLOSTBS  DC    AL1(XLDR,XSTX)      BUFSTART
CLOSTBCB DC    AL1(X'80'+BCBIGNRE) BUFBCB(RECEIVED BLOCK CT ADDED
CLOSTFCS DC    AL2(0)              FCS
         DC    AL1(X'E0')          RCB (CTL REC,TYPE=LOST DATA)
CLSTSRCB DC    AL1(X'80')          SRCB(EXPECTED BLK CT ADDED)
         DC    AL1(0)              SCB (NULL RECORD)
         DC    AL1(0)              RCB (END OF BLOCK)
CLOSTEND EQU   *                   END OF PROTOTYPE
 TITLE 'C O M S U P  -- COMIDLE   (NO DATA TO SEND TO HASP)  '
         SPACE 3
CRESPOND NULL  *                   ENTRY TO RESPOND TO HASP
         MVI   $FCSHOT+1,0         RESET HOT SWITCH
        $DCHAIN $BUFPOOL,R13,NOENB GET A BUFFER TO USE
         BNZ   CBUFGOTN            BR IF GOTTEN
CSTOPIN  NULL  *                   ENTRY TO STOP ALL INPUT
        $LA    R13,CDUMMY          USE DUMMY BUFFER
         MVI   BUFDATA,0           SET NULL BUFFER RCB
         MVI   BUFSTAT,BUFFAKE     FORCE STATUS TO DUMMY
         MVC   CREADCT(2),=Y(CDUMCT) SET READ COUNT TO SHORT      V03.1
         B     CSTNDWRT            GO DO NORMAL WRITE
CBUFGOTN NULL  *
         MVI   BUFDATA,0           SET NULL BUFFER RCB
         MVC   BUFCOUNT,=AL2(CDUMEND-CDUMSTRT) SET WRITE COUNT
         CLC   CFCSOUT,$FCSOUT     HAS FCS BEEN CHANGED
         BNE   CSTNDWRT            BR IF YES TO DO NORMAL WRITE
         MVC   BUFSTART,XACKSEQ    SETUP STANDARD SEQUENCE
CSENDRES NULL                      *
         OI    BUFSTAT,BUFRESP     SHOW RESPONSE BUFFER
         B     CNWRITE             AND GO WRITE
CDUMMY   $ACON 0                   NO CHAIN
         DC    AL2(CDUMEND-CDUMSTRT) COUNT
         DC    AL1(BUFFAKE)        BUFSTAT
CDUMSTRT DC    AL1(XLDR,XSTX)      BUFSTART
         DC    AL1(X'80'+BCBIGNRE) BUFBCB
         DC    AL2(0)              FCS
         DC    AL1(0)              RCB (EOB)
CDUMEND  EQU   *                   END OF DUMMY BUFFER
         AIF   (&MACHINE NE 20).CNOPAD
         DC    AL2(0)              SPACE FOR ENDING SEQUENCE
.CNOPAD  ANOP
CDUMCT   EQU   *-CDUMSTRT          MAXIMUM ACCEPTABLE COUNT       V03.1
 TITLE 'C O M S U P  -- CNAKED   (PROCESS ERROR REPLY FROM HASP)  '
*
*              A NEGATIVE RESPONSE RECEIVED FROM HASP
*
         SPACE 3
CNAKED   NULL  *                   PREPARE TO RETRANSMIT
        $LOG   XNAKREC             LOG NEGATIVE REPLY
         TM    BUFSTAT,BUFNAK      WERE WE SENDING A NAK
         BO    CNAKNAK             BR IF YES
         MVI   BUFSTART,XLDR       RESET LEADER CHARACTER
         TM    BUFSTAT,BUFTEXT     WAS THIS A TEXT BUFFER
         BO    CREWRITE            BR IF YES TO RETRY
         MVI   BUFSTART,XDLE       SET RESPONSE LEADER
         B     CWRTXIO             AND GO WRITE IT
CNAKNAK  NULL                      OUR NAK WAS NAK'ED
         TM    BUFSTAT,BUFTEXT     WAS ORIGINAL BUFFER TEXT...
         BZ    CWRTOK              NO...FORGET IT
*                                  YES...PREPARE TO RESEND
         MVC   BUFSTART,XSTXSEQ    RESET TEXT LEADERS
         NI    BUFSTAT,255-BUFNAK-BUFRESP RESET STATUS
         B     CNWRITE             WRITE BUFFER AGAIN
         SPACE 5
*
*              UNKNOWN RESPONSE FROM HASP... RESEND LAST DATA
*
CRESPBAD NULL
         MVC   $LOGINFO(2),BUFSTART SHOW BAD RESPONSE
         $LOG  XUNKRES             LOG ERROR
         B     CSENDNAK            GO REPLY NAK
         SPACE 3
*
*              SEND A NEGATIVE RESPONSE TO HASP
*
CSENDNAK NULL  *                   ENTRY
         MVC   BUFSTART,XNAKSEQ    SET NAK SEQUENCE
         OI    BUFSTAT,BUFRESP+BUFNAK SHOW NAK RESPONSE
         B     CNWRITE             AND GO WRITE IT
 TITLE 'C O M S U P  -- CSETCOM  (COMMUTATOR LINKAGE CONTROL)  '
*
*              COMSUP IS EXITING WITHOUT I/O ACTIVE
*              PREPARE FOR RE-ENTRY THROUGH COMUTATOR
*
         SPACE 3
CSETCOM  NULL  *                   *
         MVI   $COMCOM+1,X'F0'     OPEN GATE
         MVI   $COMBUSY+1,X'F0'    SHOW NO ACTIVITY
        $SAVE  R13,R15,CRETREGS    SAVE SOME REGISTERS
         B     CREXIT              AND RETURN TO INTERRUPTED LOC
$COMSUP  NULL
        $SSM   0                   DISABLE
         MVI   $COMCOM+1,0         CLOSE COMUTATOR ENTRY
        $RESTORE R13,R15,CRETREGS  RESTORE
         AIF   (&MACHINE NE 20).CA
         MVC   146(2),=Y($COMCOM+4) SET EXIT TO COMUTATOR
         AGO   .CB
.CA      ANOP
         MVC   $IOOLD+5(3),=AL3($COMCOM+4) SET EXIT TO COMUTATOR
.CB      ANOP
         MVI   $COMBUSY+1,0        ALLOW COMMUNICATIONS INTERRUPTS
         BR    R15                 RE-ENTER COMSUP
CRETREGS $WCON (0,0,0)             REGISTER SAVE
 TITLE 'C O M S U P  -- CNWRITE  (COMMUNICATIONS WRITE SUBROUTINE)  '
         SPACE 3
CNWRITE  NULL
         AIF   (&MACHINE NE 20).X4
         LH    R15,=Y(BUFSTART-BUFDSECT) DATA DISPLACEMENT
         AR    R15,R13             R15 = BEGINNING OF DATA
         STH   R15,CRDRESP+2       SET RETURN READ
         STH   R15,COMWRITE+2      SET WRITE ADDR
         TM    BUFSTAT,BUFRESP     IS THIS A RESPONSE SEQUENCE...
         BZ    CSETEND             BR IF NO
         MVC   COMWRITE+4(2),=H'2' YES...SET RESPONSE COUNT
         B     CWRTXIO             AND WRITE IT
CSETEND  NULL  *                   ADD BSC ENDING SEQUENCE
         LH    R15,BUFCOUNT        DATA COUNT
         AH    R15,=H'11'          FIX FOR XPARENCY
         STH   R15,COMWRITE+4      SET COUNT
         AR    R15,R13             INCLUDE BUFFER
         AH    R15,=Y(BUFSTART-BUFDSECT) ADJUST FOR HEADING
         SH    R15,=H'11'          AVOIDS ASSEMBLER ERROR
         MVC   0(2,R15),XETBSEQ    SET ENDING
CREWRITE NULL  *                   RE-WRITE TEXT ENTRY
         TM    BUFSTAT,BUFRESP     IS THIS A RESPONSE
         BO    CWRTXIO             BR IF YES TO SKIP FCS SET
         MVC   BUFFCS,$FCSOUT      SET CURRENT FCS
         MVC   CFCSOUT,$FCSOUT     SAVE LAST FCS SENT
CSETBCB  MVI   BUFBCB,*-*          SET BCB INTO BUFFER
         MVC   COLDRCB+1(1),BUFDATA SAVE RCB                      V03.1
         TM    BUFSTAT,BUFFAKE     IS THIS A DUMMY BUFFER
         BZ    *+8                 BR IF NO
         OI    BUFFCS,X'40'        YES...SET WAIT-A-BIT
CWRTXIO  NULL  *                   WRITE BUFFER
         MVI   CREADREQ+1,0        SHOW READ REQUIRED
         STH   R13,CBUFFER         SET BUFFER ADDR
         B     CNWLOG              NOP THIS TO LOG EVERY WRITE
         MVC   $LOGINFO(3),BUFSTART+1 SET LOG INFO
         $LOG  XTPWRITE            AND DO IT
CNWLOG   NULL  *                   WRITE LOG BYPASS
         AIF   (&TRACE EQ 0 OR &MACHINE NE 20).TRX
        $RESTORE R12,R15,CREGS     RESTORE BEFORE I/O IN CASE 40KB
         AGO   .TRZ
.TRX     ANOP
        $RESTORE R13,R15,CREGS     RESTORE BEFORE I/O IN CASE 40KB
.TRZ     ANOP
         MVI   $COMBUSY+1,0        SHOW ACTIVITY
         AIF   (&MACHINE NE 20 OR &LINESPD LT 19200).CL           V03.1
         AIF   (&SUBMOD GE 5).CL                                  V03.1
         TIOB  *,PBUSY             WAIT ON PRINTER CARRIAGE CYCLE
.CL      ANOP
COMWRITE XIO   *-*(CAWRITE),0      ISSUE WRITE
         BC    7,*-6               WAIT UNTIL ACCEPTED
         SPSW  144                 EXIT (QUICKLY)
         AGO   .X5
.X4      ANOP
         LA    R15,BUFSTART        TO XMISSION POINT
         ST    R15,CCWA            INTO CCW
         MVI   CCWA,1              RESET OP
         ST    R15,CCWC            SET RETURN DATA ADDR
         MVI   CCWC,2              RESET OP
         MVC   CCWA+6(2),BUFCOUNT  SET WRITE COUNT
         MVI   CCWA+4,XCHN         SET PROPER CCW CHAINING
         $STO  R13,CBUFFER         SAVE BUFFER ADDR
         MVI   CCWB,1              RESET OP FOR ENDING SEQ
         TM    BUFSTAT,BUFRESP     IS THIS JUST A RESPONSE
         BZ    CREWRITE            BR IF NO
         MVI   CCWA+4,X'60'        SET COMMAND CHAINING
         MVC   CCWA+6(3),=X'000203' SET COUNT AND 2ND CCW OP
         B     CWRTSIO             GO START WRITE
CREWRITE NULL  *                   ENTRY TO RETRY WRITE
         MVC   CFCSOUT,$FCSOUT     SAVE LAST FCS SENT
         MVC   BUFFCS,$FCSOUT      SET CURRENT FCS
CSETBCB  MVI   BUFBCB,*-*          SET BCB INTO BUFFER
         MVC   COLDRCB+1(1),BUFDATA SAVE RCB                      V03.1
         TM    BUFSTAT,BUFFAKE     IS THIS A DUMMY BUFFER
         BZ    *+8                 BR IF NO
         OI    BUFFCS,X'40'        YES...SET WAIT-A-BIT
CWRTXIO  NULL  *                   START THE WRITE
CWRTSIO  MVI   CUWFAKE+1,X'00'     MAKE SURE DUMMY READ NOT ON    V03.1
         SPACE 3
         B     CNWLOG              NOP THIS TO LOG ALL WRITES
         MVC   $LOGINFO(3),BUFSTART+1  SET LOG DATA
        $LOG   XTPWRITE            AND DO IT
CNWLOG   NULL  *                   WRITE LOG BYPASS
        $SIO   CCWA                START I/O
         SPACE 3
*
*              INTERRUPT EXIT ROUTINE
*
         SPACE 3
CREXIT   NULL
        $RESTORE R13,R15,CREGS     RESTORE INTERRUPTED REGS
CEXIT    NULL
         L     R11,$IOOLD+4                                       U0019
         BR    R11                                                U0019
.X5      ANOP
 TITLE 'C O M S U P  -- CERROR   (COMMUNICATIONS ERROR PROCESSOR)  '
*
*
*
         SPACE 3
CERROR   NULL  *
         AIF   (&MACHINE NE 20).X10
         AIF   (&TRACE EQ 0 OR &MACHINE NE 20).ITRE
        $SAVE  R12,R15,CREGS       SAVE INTERRUPTED REGS
         $LOAD R12,=Y($SVC)        SET TRACE ENTRY
         AGO   .ITRF
.ITRE    ANOP
        $SAVE  R13,R15,CREGS       SAVE INTERRUPTED REGS
.ITRF    ANOP
        $LOAD  R13,CBUFFER         GET CURRENT BUFFER
         CIO   CENSE,CASENSE       STORE SENSE BYTES
CENSE    EQU   *+1
         MVI   $LOGINFO,*-*        SET FOR LOG PROCESSING
         $LOG  XUNITCHK            LOG ERROR
         CLI   CENSE,X'7F'         TEST I/O TYPE (CLI FASTER)
         BNH   CREWRITE            BR IF WRITE TO RE-TRY
*              PROCESS READ ERROR
COLDRCB  CLI   BUFDATA,*-*         CHECK VALIDITY OF DATA (RCB)   V03.1
         BE    CSENDNAK            BR IF MATCH                    V03.1
         NI    BUFSTAT,255-BUFTEXT OTHERWISE FORGET TEXT          V03.1
         TM    CENSE,B'00010000'   Q. IF TIMEOUT PROBLEM        PP28101
         BO    CRDRESP             BR. IF YES TO REINSTATE READ PP28101
         B     CSENDNAK            GO NAK HASP
         AGO   .X12
.X10     ANOP
         MVC   CCSW,$CSW           PRESERVE CSW AROUND SENSE AND LOG
         TM    $CSW+4,2            TEST UNIT CHECK
         BO    CUNITCHK            BR IF YES
         TM    $CSW+4,1            TEST UNIT EXCEPTION
         BO    CUNITEXC            BR IF YES
CBADERR  NULL  *                   ENTRY FOR UNUSUAL ERROR
         MVC   $LOGINFO(2),$CSW+4  SET INFO BYTES
        $LOG   XUNSLERR            LOG ERROR
         B     CHECKCCW            GO DETERMINE I/O TYPE
CUNITCHK NULL  *                   ENTRY FOR UNIT CHECK
CENSE    EQU   *+1
         MVC   $LOGINFO(1),ADAIOB+2     PUT IN SENSE FROM IOB     U0019
        $LOG   XUNITCHK            LOG ERROR
KNOLOG   EQU   *                                                  U0019
CHECKCCW LA    R14,CREWRITE
         L     R15,CCSW            GET COMMAND ADDR
         LTR   R15,R15             IS IT ZERO...
         BCR   8,R14               BR IF YES TO TRY REWRITE
         TM    CCSW+5,4            TEST CHANNEL CONTROL CHECK
         BCR   1,R14               YES... GUESS AT REWRITE
         S     R15,=F'8'           OTHERWISE BACK UP TO FAILED CC
         CLI   0(R15),1            WAS IT A WRITE
         BCR   8,R14               BR IF YES TO RETRY IT
COLDRCB  CLI   BUFDATA,*-*         CHECK VALIDITY OF DATA (RCB)   V03.1
         BE    CSENDNAK            BR IF MATCH                    V03.1
         NI    BUFSTAT,255-BUFTEXT OTHERWISE FORGET TEXT          V03.1
         B     CSENDNAK            OTHER-WISE SEND A NAK TO HASP
         DS    0F                  FORCE FULL-WORD ALIGNMENT      V03.1
CCSW     DC    XL8'00'             TEMPORARY STORAGE FOR CSW      V03.1
         SPACE 5
*
*              UNIT EXCEPTION SET
*
         SPACE 3
CUNITEXC NULL
         L     R15,$CSW            GET CSW ADDR
         S     R15,=F'8'           BACK UP TO CMD IN ERROR
         MVC   CUNITCMD(1),0(R15)  SAVE COMMAND CODE
CUNITCMD EQU   *+1                 COMMAND CODE STORAGE
         MVI   $LOGINFO,*-*        SHOW COMMAND TYPE
         MVC   $LOGINFO+1(2),BUFSTART LOG BUFFER LEADERS
        $LOG   XUNITEXP            LOG ERROR
         CLI   CUNITCMD,1          WAS THIS A WRITE...
         BNE   CSENDNAK            BR IF NO TO FORCE RESEND (EOT REC)
         MVI   CUWFAKE+1,X'F0'     SET SWITCH TO IGNORE ERROR     V03.1
        $SIO   CCWD                START READ
         B     CREXIT              AND EXIT TO AWAIT INT
 TITLE 'C O M S U P  -- $SIO     (START I/O SUBROUTINE FOR SDA-II) '
$SIO     NULL
         MVC   ADCCWA+1(3),1(R15)       MOVE CCW ADDRESS TO IOB   U0019
         MVC   CLASTCAW,0(R15)     SAVE
        $TRACE SSM=NO
         STM   11,2,ADSAV                                         U0019
         MVI   TIMESW,X'FF'                                       U0019
         L     R14,CLASTCAW                                       U0019
         L     R14,0(R14)                                         U0019
         BAL   R15,KLOGIT                                         U0019
         EXCP  ADAIOB                   ADAPTER  I/O              U0019
         LM    11,2,ADSAV                                         U0019
         B     4(R15)                   BACK TO USER              U0019
CLASTCAW DC    F'0'                CCW ADDR SAVE
.X12     ANOP
 TITLE 'C O M S U P  -- INTERRUPT PROCESSOR (STORAGE)      '
         SPACE  5
CBUFFER $ACON  0                   ACTIVE COMUNICATIONS BUFFER
$BUFFER  EQU   CBUFFER             EXTERNAL REFERENCE NAME
CFCSOUT  DC    H'0'                LAST FCS TRANSMITTED TO HASP
CTEMP    DC    H'0'                TEMPORARY STORAGE
CMAXDUP  DC    H'3'                MAX REPEATED BLOCKS
         DC    AL1(0)              FIRST BYTE OF HALF-WORD
CBCBCNTO DC    AL1(X'80')          BLOCK CHECK COUNT OUT
         DC    AL1(0)              SPACER
CBCBCNTI DC    AL1(X'80')          BLOCK COUNT CHARACTER EXPECTED
         DC    H'0'                *
$INQCNT  EQU   *-1                 COUNT OF QUEUED INPUT BUFFERS
CRESP    DC    AL1(0)              RESPONSE CHARACTER RECEIVED
         AIF   (&TRACE EQ 0 OR &MACHINE NE 20).TRG
CREGS    $WCON (0,0,0,0)           REGISTER SAVE AREA
         AGO   .TRH
.TRG     ANOP
CREGS    $WCON (0,0,0)             REGISTER SAVE AREA
.TRH     ANOP
CALASTPO DC    H'0'                LAST ADDR STORAGE
         SPACE 5
*                        CONTROL SEQUENCES
XSTXSEQ  DC    AL1(XLDR,XSTX)      START-OF-TEXT SEQUENCE
XETBSEQ  DC    AL1(XTRL,XETB)      END-OF-TEXT-BLOCK SEQUENCE
XACKSEQ  DC    AL1(XDLE,XACK0)     POSITIVE ACKNOWLEDGEMENT SEQUENCE
XNAKSEQ  DC    AL1(XSYN,XNAK)      NEGATIVE ACKNOWLEDGEMENT SEQUENCE
         AIF   (&MACHINE EQ 20).S1
         SPACE 5
*                        CHANNEL CONTROL WORDS
         SPACE 2
*                   NORMAL DATA WRITE WITH RETURN DATA READ
         SPACE 1
CCWA    $CCW   1,*-*,60,*-*        WRITE BUFFER
COMWRITE EQU   CCWA                FOR DEBUGGING AID PAGE
CCWB    $CCW   1,XETBSEQ,60,2      WRITE ENDING SEQUENCE
CCWC    $CCW   2,*-*,20,&TPBFSIZ   READ RETURN DATA
CREADCT  EQU   *-2                 READ COUNT FIELD               V03.1
         SPACE 3
*                   DUMMY READ TO TURN OFF LOST DATA SENSE
         SPACE 1
CCWD    $CCW   2,*,30,65000        NON-READ A BUNCH
         SPACE 3
*                   SDA-II SENSE COMMAND
         SPACE 1
CCWSENS $CCW   4,CENSE,20,1        SENSE
.S1      ANOP
         DROP  R13                 KILL BUFFER ADDRESSABILITY
         AIF   (&MACHINE EQ 20).YOSKP1
 TITLE '$ X I O  -- UNIT RECORD I/O SUPERVISOR'
*
*        BASE REGISTER ASIGNMENT
*
         USING TANKDSEC,R8
         USING TCTDSECT,TCTR
         SPACE 3
&A       SETA  0
YOCLOSE  $LOAD R14,TCTCOM          CLOSE COMMUTATOR
         NI    1(R14),X'0F'        CHANGE BR TO NOP
*              IF DEVICE BUSY DEVICE END INTERRUPT WILL CLEAR
*              IF DEVICE NOT  READY DEVICE END WILL CLEAR
         BR    R14                 RETURN TO CALLER
*        $IOCK                     ENTRY POINT TO PASS TO USER CODES
*
$IOCK    $STO  R14,TCTSAV1         SAVE USER RETURN ADDRESS
         $DELAY Y,T,TYPE=SETUP     GET READY FOR DELAY
         B     YOCLOSE                                            U0019
YOCKRET  TM    TCTECB,X'10'          IS THE DEVICE FREE???        U0019
         BO    YOCLOSE                                            U0019
         L     R14,TCTSAV1                                        U0019
         BR    R14                                                U0019
YACN1    DC    S(YOCKRET)                                         U0019
         DROP  TCTR
*                                                                 U0019
*    THE FOLLOWING BR 14 IS THE SYNAD ROUTINE FOR THE BSAM        U0019
*    READER, PRINTER, AND PUNCH. IT IS SUPPOSED TO PROVIDE        U0019
*    THE SAME FACILITY AS THE QSAM ACC EROPT OPTION.              U0019
*                                                                 U0019
BR14     BR    R14                                                U0019
 TITLE '$ N O T T P  -- UNIT RECORD INTERRUPT HANDLER'
*
*        UNIT RECORD I/O SUPERVISOR EQUATES
*
DEVEOF   EQU   X'01'               UNIT EXCEPTION
DEVUCK   EQU   X'02'               UNIT CHECK
DEVATN   EQU   X'80'               ATTENTION
DEVMOD   EQU   X'40'               STATUS MODIFIER
DEVEND   EQU   X'04'               DEVICE END
YOREGSAV DC    3F'0'               INTERRUPT REG SAVE AREA
YOSENCCW DS    0D
CAW      EQU   X'48'               LOCATION OF CHANNEL ADDRESS WORD
CSW      EQU   X'40'               LOCATION OF CHANNEL STATUS WORD
IOOLDPSW EQU   X'38'               LOCATION OF I/O OLD PSW
         DC    X'04',AL3($LOGINFO),X'20',AL3(1) SENSE CCW
YOPSW    DC    X'FF',X'04',AL2(0),AL1(0),AL3(YOCKRET)
         AGO   .YOSKP3
.YOSKP1  ANOP
 TITLE '$ N O T T P  --  UNIT RECORD INTERRUPT HANDLER'
         AIF   (&CONSOLE EQ 0).YOSKP2
$NOTTP   NULL  ,                   INTERRUPT ENTRY POINT
         CLI   145,WREQ            TEST FOR INQUIRY REQUEST
         BNE   YORET               IF NOT IGNORE INTERRUPT
         OI    WCTSTAT,TCTREQ      TURN ON REQUEST FLAG
         OI    $WCOMM1+1,X'F0'     OPEN GATE TO CONSOLE
YORET    SPSW  144                 RETURN TO INTERRUPTED LOCATION
         AGO   .YOSKP3
.YOSKP2  ANOP
$NOTTP   NULL
YORET    SPSW  144                 RETURN TO INTERRUPTED LOCATION
         AIF   (&R(2)).YOSKP3
*
*        $DIAL                     READS DIALS AND CHECKS FOR CHANGE
*
*                                  DESTROYS ALL REGISTERS
*
$DIAL    NULL
         LH    R8,0(0,R14)         PICK LOCATION TO STORE REQUEST
         STH   R14,0(0,R8)         STORE REQUESTORS RETURN LOCATION
         $SSM  0                   DISABLE INTERRUPTS
         MVC   YODSAV,252          SAVE THE READ IN AREA
         DIALS ,                   READ THE DIALS
         MVC   YODIALS,252         MOVE REQUIRED DIAL INFO TO WORK
         MVC   252(3),YODSAV       RESTORE READ IN LOCATIONS
         MVC   YODIAL2+1(1),YODIALS SEPARATE DATA DIALS
         $SSM  X'FF'               ENABLE INTERRUPTS
         NI    YODIALS,X'10'       MASK OUT DIAL 2 PLUS HIGH 3 BITS
         CLC   YODOLD,YODIALS      COMPARE FOR CHANGE IN DATA 1
         BE    2(0,R14)            IF NO CHANGE RETURN TO USER
         MVC   YODOLD,YODIALS      SET DATA 1 FOR FUTURE READS
         NI    YODIAL2+1,X'0F'     MASK OUT DIAL 1
         LH    R8,YODIAL2          PICK UP DATA DIAL 2
         AR    R8,R8               DOUBLE IT
         AH    R8,=Y(YODTAB)       LOCATE REQUEST ENTRY
         LH    R15,0(0,R8)         PICK RESPONSE RETURN POINT
         LH    R9,=Y(YODNULL)      PICK UP ADDR OF NULL RTN
         STH   R9,0(0,R8)          PUT IT IN RESPONSE TABLE
         B     6(0,R15)            RETURN WITH POSITIVE ANSWER
$DIALTAB DS    0H                  DIAL RESPONSE TABLE POINTERS
YODTAB   DC    Y(YODNULL)          0    DIAL OFFSET TABLE
         DC    Y(YODNULL)          1
         DC    Y(YODNULL)          2
         DC    Y(YODNULL)          3
         DC    Y(YODNULL)          4
         DC    Y(YODNULL)          5
         DC    Y(YODNULL)          6
         DC    Y(YODNULL)          7
         DC    Y(YODNULL)          8
         DC    Y(YODNULL)          9
         DC    Y(YODNULL)          A
         DC    Y(YODNULL)          B
         DC    Y(YODNULL)          C
YODNULL  DS    0H                  NULL ROUTINE OFFSET BY -6
         DC    Y(YODNULL)          D
         DC    Y(YODNULL)          E
         DC    Y(YODNULL)          F
         B     2(0,R14)            NULL RTN, RETURN TO USER
YODSAV   DC    CL3' '              SAVE AREA FOR READ IN AREA
YODOLD   DC    CL1' '              OLD DATA DIAL 1
YODIAL2  DC    H'0'                DATA DIAL 2 ISOLATED
YODIALS  DC    CL1' '              WORK AREA FOR DIALS
.YOSKP3  ANOP
 TITLE 'ITS A BIRD... ITS A PLANE... ITS S U P E R T R A C E !!!!'
$SVC     NULL  *                   SVC NEW ENTRY POINT
         AIF   (&TRACE EQ 0).TRASKIP
         $SSM  0                   TRACE MUST RUN DISABLED
        $STO   R12,SVCSAV          PRESERVE
         $LOAD R12,$TRACUR         CURRENT TRACE LOC
         AH    R12,=H'4'           TO NEXT ENTRY
         CH    R12,$TRAEND         IS THIS END
         BNH   *+8                 BR NO
         $LOAD R12,$TRASTRT        YES...GET START
         $STO  R12,$TRACUR         RESET PTR
         MVI   0(R12),0            CLEAR HIGH BYTE
         AIF   (&MACHINE EQ 20).TR20
         MVC   1(3,R12),37         SET TRACE LOCATION
         L     R12,36              SVC OLD ADDR
         CLI   35,X'CC'            IS THIS REGULAR TRACE
         BNE   TRACNTNO            BR IF NO
         LH    R12,0(R12)          GET COUNT FIELD
         CH    R12,=H'32767'       IS TRACE ALREADY MAXIMUM
         BE    *+8                 BR IF YES
         LA    R12,1(R12)          INCREMENT
         STH   R12,TRACNT          SAVE
         L     R12,36              GET SVC OLD
         MVC   0(2,R12),TRACNT     SET COUNT
         B SVCRET                  BACK TO CALLER
TRACNTNO NULL  *                   TRACE COUNT NOT REQUIRED
         MVZ   SVCBRN+1(1),35      SET BRA CONDITION
         SPM   R12                 GET PROGRAM MASK
         MVC   38(2),0(R12)        SET POSSIBLE BRA
SVCBRN   BC    *-*,SVCRETA         DO WHAT USER INTENDED
SVCRET   NULL  *                   NORMAL-SEQUENTIAL RETURN
         LA    R12,2(R12)          NEXT INST
         STH   R12,38              NO BRA...SET RETURN
SVCRETA  NULL  *                   BR RETURN
         L     R12,SVCSAV          RESTORE 12
         LPSW  32                  RETURN TO CALLER
SVCSAV   DC    F'0'                TEMP SAVE
TRACNT   DC    H'0'                TEMPORARY TRACE COUNT
         AGO   .TRNOT20
.TR20    ANOP
         MVC   2(2,R12),SVCSAV     SET TRACED LOCATION
         MVI   1(R12),0            CLEAR 2ND BYTE OF TRACE
         LH    R12,SVCSAV          RESTORE LINKAGE
         AH    R12,=H'2'           ADJUST RETURN
         STH   R12,SVCRET          SET EXIT
         LH    R12,SVCSAV          RESTORE
         LH    R12,0(0,R12)        GET COUNT FIELD
         CH    R12,=H'32767'       WATCH FOR OVERFLOW
         BE    SVCSAV+2            EXIT IF MAX
         AH    R12,=H'1'           COUNT ENTRY
         STH   R12,*-*             RESET COUNT
SVCSAV   EQU   *-2                 STORAGE
         LH    R12,=Y($SVC)        SET FOR NEXT TIME
         B     *-*                 RETURN
SVCRET   EQU   *-2                 RETURN STORAGE
.TRNOT20 ANOP
         EJECT
         SPACE 10
*
*              T R A C E  T A B L E  (AND POINTERS)
*
         SPACE 5
$TRACUR  $ACON (TRACETAB-4)        CURRENT TRACE ENTRY
*
*
$TRASTRT $ACON (TRACETAB)          BEGINNING OF TRACE TABLE
*
*
$TRAEND  $ACON (TRACETAB+&TRACE*4-4) END OF TRACE TABLE
*
*
TRACETAB DC    (&TRACE)F'0'        T R A C E  T A B L E
*
*
.TRASKIP ANOP
 TITLE '$ T A N K P O L  --  DECOMPRESSION TANK POOL '
$1STTANK $GENTANK
         AIF   (&CONSOLE EQ 0 AND &PRTCONS EQ 0).TANKSKP
.TANKSKP ANOP
PRINTR   DCB   DDNAME=PRINTR,MACRF=(W),DSORG=PS,SYNAD=BR14,       U0019X
               DEVD=DA,RECFM=FM,LRECL=133,BLKSIZE=133             U0019
PUNCH    DCB   DDNAME=PUNCH,MACRF=(W),DSORG=PS,SYNAD=BR14,        U0019X
               DEVD=DA,RECFM=F,LRECL=80,BLKSIZE=80                U0019
READR    DCB   DDNAME=READR,MACRF=(R),DSORG=PS,EODAD=RDEOF,       U0019X
               DEVD=DA,RECFM=F,SYNAD=BR14                         U0019
P        DCB   DDNAME=SYSPRINT,MACRF=PM,DSORG=PS,RECFM=F,         U0019X
               BLKSIZE=120,LRECL=120                              U0019
KTAB     DC    C'0123456789ABCDEF'                                U0019
KSAV     DC    6F'0'                                              U0019
KLOGIT   STM   13,2,KSAV                                          U0019
         UNPK  IOLINE(15),0(8,R14)                                U0019
         TR    IOLINE(14),KTAB-240                                U0019
         UNPK  IOLINE+14(15),7(8,R14)                             U0019
         TR    IOLINE+14(14),KTAB-240                             U0019
         UNPK  IOLINE+28(15),14(8,R14)                            U0019
         TR    IOLINE+28(14),KTAB-240                             U0019
         UNPK  IOLINE+42(15),$CSW+1(8)                            U0019
         TR    IOLINE+42(14),KTAB-240                             U0019
         UNPK  IOLINE+57(7),ADAECB(4)                             U0019
         TR    IOLINE+57(6),KTAB-240                              U0019
         LA    R13,SA13                                           U0019
         PUT   P,IOLINE                                           U0019
         LM    13,2,KSAV                                          U0019
         BR    R15                                                U0019
SA13     DC    9D'0'                                              U0019
IOLINE   DC    CL120' '                                           U0019
ADAPTR   DCB   DDNAME=ADAPTR,MACRF=(E)                            U0019
ADSAV    DC    8F'0'                                              U0019
ADAIOB   DC    X'C2000000'                                        U0019
         DC    A(ADAECB)                                          U0019
$CSW     DC    2F'0'                                              U0019
ADCCWA   DC    A(CCTCCW)                                          U0019
         DC    A(ADAPTR)                                          U0019
         DC    2F'0'                                              U0019
UCBINDEX DC    2F'0'                                              U0019
         DC    C'A'                                               U0019
         DC    AL3($TCT1)               ADAPTER                   U0019
ADAECB   DC    F'0'                                               U0019
EOJ      CLOSE (PRINTR)                                           U0019
         CLOSE (PUNCH)                                            U0019
         CLOSE (ADAPTR)                                           U0019
         L     R13,KSAV13                                         U0019
         LM    14,12,12(13)                                       U0019
         SR    R15,R15             CLEAR FOR RETURN TO OS      UF099
         BR    14                                                 U0019
         EJECT
         LTORG
$END     DS    0H                  END OF PERMANENT CODE
 TITLE '$ I N I T I 8  --  DYNAMIC BUFFER POOL CONSTRUCTION '
$1STBUF  DS    0F
*
*              THE FOLLOWING SECTION WILL DYNAMICALLY BUILD THE
*              COMMUNICATIONS BUFFER POOL OVER THE INITIALIZATION
*              INSTRUCTIONS.   BUFFERS WILL BE CONSTRUCTED TO THE
*              EXTENT OF MEMORY OR UNTIL '&NUMBUFS' HAS BEEN BUILT.
*              THE LOCATION OF THE BUFFERS SO GENERATED WILL BE AS
               GIVEN BELOW.
         ORG   *+(BUFSTART-BUFBEGIN)  ORG AFTER BUF CNTRL INFO
P$1STBUF $ACON $1STBUF
BUFLN1   DC    A(BUFEND-BUFBEGIN)                                 U0019
BUFLN2   DC    A(2*(BUFEND-BUFBEGIN))                             U0019
BUFZEROS DC    F'0'
BCOREND  DC    A(1024*&HICORE-1)                                  U0019
BONE     DC    F'1'                                               U0019
BNUMBUFS DC    F'&NUMBUFS'                                        U0019
IBLDBUFS NULL
         $LOAD R11,P$1STBUF        LOAD ADDR OF 1ST BUFFER
         L     R10,P$1STBUF                                       U0019
         L     R9,BNUMBUFS                                        U0019
BULDMORE NULL
         A     R10,BUFLN2                                         U0019
         S     R9,BONE                                            U0019
         BZ    BUFSDONE            BR IF LAST BUBBER
         S     R10,BUFLN1                                         U0019
         $STO  R10,0(0,R11)        STORE POINTER IN PREV BUF
         MVC   L'BUFCHAIN((BUFSTART-BUFCOUNT),R11),BUFZEROS  MOVE IN
*                                  INITIAL VALUES
         L     R11,0(0,R11)                                       U0019
         B     BULDMORE            BR TO BUILD ANOTHER BUFF
BUFSDONE NULL
         $LOAD R10,BUFZEROS        LOAD CHAIN TERMINATOR
         $STO  R10,0(0,R11)        STORE IT IN THE LAST BUFFER
         MVC   L'BUFCHAIN((BUFSTART-BUFCOUNT),R11),BUFZEROS  MOVE IN
*                                  INITIAL VALUES
         AIF   (&HOME EQ 0).IHOMB
         $SSM  FF                  ENABLE INTERRUPTS
         B     $START              GO TO COMMUTATOR DIRECT
.IHOMB   ANOP
 TITLE '$ I N I T I 8  --  ESTABLISH HASP SYNCHRONIZATION '
         $DCHAIN $BUFPOOL,R13,NOENB GET A BUFFER
         USING BUFDSECT,R13        *
         MVC   BUFCOUNT(ICTLE-ICTLS),ICTLS SETUP CONTROL REPLY
         $CHAIN $OUTBUF,R13,NOENB STAGE FOR WRITE
         $DCHAIN $BUFPOOL,R13,NOENB GET ANOTHER
         $STO  R13,$BUFFER         SET FOR I/O ROUTINES
         MVC   BUFSTART,XACKSEQ    FAKE AN ACK
         B     $ENDREAD            FAKE AN INTERRUPT
ICTLS    DS    0H                  CONTROL INFO FOR BUFFER
         DC    AL2(ICTLE-*-3)      BUFCOUNT
         DC    X'00'               BUFSTAT
         DC    AL1(XLDR,XSTX)      BUFSTART
         DC    AL1(X'80'+BCBRESET) BUFBCB (RESETS EXPECTED BLOCK CT)
         DC    AL2(0)              FCS
         DC    X'F0'               GENERAL CONTROL TYPE RCB
         DC    C'A'                SIGN-ON ID
ICTXT    DS    0CL80
         DC    CL21'/*SIGNON       REMOTE'
SIGNON   DC    CL59' '       PARM IS MOVED HERE FOR SIGNON NUMBER U0019
         DC    AL1(0)              EOR
ICTLE    EQU   *
         LTORG
         TITLE 'H A S P / R J E  * ABSOLUTE PATCH LOADER * '
         SPACE 3
INEWTABL NULL
         MVC   LOGTABLE(X'92'),ILOGTABL RECREATE THE LOG TABLE
         EXTRACT COMPTR,FIELDS=COMM  GET COMM POINTERS         UF099
         SPACE 1                                               UF099
         L     R14,COMPTR          SET BASE FOR COM LIST       UF099
         USING COMLIST,R14         ADDRESSING FOR COMM         UF099
         MVC   ECBPCIB,COMECBPT    SET POINTER TO MODIFY ECB   UF099
         L     R15,COMCIBPT        GET POINTER TO CIB          UF099
         USING CIB,R15             ADDRESSING FOR CIB          UF099
         LA    R15,0(R15)          CLEAR TOP BYTE              UF099
         LTR   R15,R15             IS THERE A START CIB?       UF099
         BZ    OPNOSTAR            NO - START QUEUING          UF099
         SPACE 1                                               UF099
         QEDIT ORIGIN=COMCIBPT,BLOCK=(R15) FREE THE START CIB  UF099
         SPACE 1                                               UF099
OPNOSTAR QEDIT ORIGIN=COMCIBPT,CIBCTR=2  SET COMMAND QUEUING   UF099
         SPACE 1                                               UF099
         DROP  R14,R15             DROP TEMP ADDRESSING        UF099
         SPACE 1                                               UF099
         WTO   'HASP REMOTE WORKSTATION/OS READY FOR DIAL-UP'     U0019
         B     ISIO                                               U0019
ILOGTABL DS    0H
         $LOGENT ID=XBCBCHEK,CLASS=10,TEXT='BLOCK SEQ CK'
         $LOGENT ID=XNAKREC,CLASS=7,TEXT='ERROR REPLY'
         $LOGENT ID=XUNKRES,CLASS=10,TEXT='INVALID RESP'
         $LOGENT ID=XUNITEXP,CLASS=10,TEXT='UNIT EXCPTN'
         $LOGENT ID=XUNITCHK,CLASS=7,TEXT='UNIT CHECK'
         $LOGENT ID=XUNSLERR,CLASS=15,TEXT='UNUSUAL END'
         $LOGENT ID=XSIOBAD,CLASS=12,TEXT='SIO FAILURE'
         $LOGENT ID=XTPWRITE,CLASS=1,TEXT='W' LOG OF WRITES
         $LOGENT ID=XTPREAD,CLASS=1,TEXT='R' LOG FOR ALL READS
         DC    X'00'               END OF LOG TABLE
ILTABEND DS    0C                  END OF THE TABLE
*OLD*    AIF   (&MACHINE EQ 20).INI7
         SPACE 3
         AIF   (&HOME NE 0).IHOMA
ISIO     NULL  ,                   ESTABLISH COMMUNICATIONS WITH HASP
         LA    R9,INITCCW          INITIALIZATION CCW STRING
         BAL   R8,I27XXIO          GO START I/O
         MVI   INITCCW,4           CHANGE DISABLE TO SENSE
         MVI   INITCCWS,3          NOP SET MODE
         BNZ   ISIO                RETRY IF PREVIOUS I/O BAD
         CLC   IREADRES,=AL1(XDLE,XACK0) WAS ACK RECEIVED
         BNE   ISIO                START AGAIN IF NO
.IHOMA   ANOP
         MVC   $IOOLD(8),INTFAKE   SET FAKE INTERRUPT
         LA    R8,CCTCCW                                          U0019
         ST    R8,ADCCWA                                          U0019
         B     IBLDBUFS            GO CONSTRUCT BUFFER POOL
INTFAKE  DC    X'FF04',AL2($ADAPTER),AL4($START) FAKE OLD PSW
         DS    0D                  *
INITCCW  $CCW  X'2F',INITCCW+5,60,1 DISABLE  (CHANGED TO SENSE)
INITCCWS $CCW  X'23',ISETMODE,60,1  SET MODE (CHANGED TO A NOP)
         $CCW  X'27',0,60,1        ENABLE
INITCCWR $CCW  1,INITSEQ,60,2      WRITE RESPONSE SEQUENCE
         $CCW  2,IREADRES,20,2     READ ANSWER FROM HASP
INITSEQ  DC    AL1(XSOH,XENQ)      PRE SIGN ON RESPONSE
IREADRES DC    AL2(0)              RESPONSE CHARACTERS FROM HASP
*
*              SUBROUTINE TO PERFORM I/O OPERATIONS ON THE 27XX
*               R8=RETURN,R9=CCW ADDR,CC=Z=NORMAL CE,DE--NZ=BAD
*
I27XXIO  NULL  *                   ENTRY
         ST    R9,ADCCWA                                          U0019
         EXCP  ADAIOB                                             U0019
         WAIT  1,ECB=ADAECB                                       U0019
         CLC   ADAIOB+12(2),=X'0C00'                              U0019
         BR    R8                                                 U0019
ISETMODE DC    X'00'               SET MODE BYTE
IPSWS    NULL  *                   NEW PSW'S
         DC    X'0002000000777777' EXTERNAL
         DC    X'00040000',AL4($SVC) SVC
         DC    X'0002000000111111' PROGRAM INTERRUPT
         DC    X'00020000',X'00FFFFFF' MACHINE CHECK
         DC    X'00040000',AL4($IOINT)  I/O NEW
         DC    CL256' '                                           U0019
         DC    CL256' '                                           U0019
         DC    CL256' '                                           U0019
         DC    CL256' '                                           U0019
         DC    CL256' '                                           U0019
         DC    CL256' '                                           U0019
         DC    CL256' '                                           U0019
         DC    CL256' '                                           U0019
         DC    CL256' '                                           U0019
         DC    CL256' '                                           U0019
         DC    CL256' '                                           U0019
PATCH1   DC    CL30' '                                            U0019
PATCH2   DC    CL30' '                                            U0019
PATCH3   DC    CL30' '                                            U0019
         MVI   PATCH1,C' '                                        U0019
         MVI   PATCH2,C' '                                        U0019
         MVI   PATCH3,C' '                                        U0019
$EXTNEW  EQU   88                  EXTERNAL NEW PSW
         AGO   .IMODXX
.IMOD20  ANOP
         CIO   1,X'45'             SKIP TO CHAN 1
         BC    7,*-4               WAIT UNTIL ACCEPTED
         $LOAD R12,=Y($SVC)        ESTABLISH TRACE ENTRY
         AIF   (&CONSOLE EQ 0).IMOD20A
         CIO   1,WENABLE           ENABLE CONSOLE REQUESTS
         AGO   .IMOD20B
.IMOD20A AIF   (&R(2)).IMOD20B
         MVC   YODSAV,252          SAVE DIAL AREA
         DIALS ,                   READ DIALS
         MVC   YODOLD,252          SET DATA DIALS TO INITIAL VALUE
         NI    YODOLD,X'10'        REMOVE DIAL 2 PLUS HIGH 3 BITS
         MVC   252(3),YODSAV       RESTORE AREA
.IMOD20B ANOP
         AIF   (&HOME EQ 0).IHOMIA
         B     IHOMSKP
.IHOMIA  ANOP
         CIO   1,CAENABLE          TURN ON BSCA
IREDOIT  MVC   148(4),=AL4(INITINT) SET NEW PSW
IAGAIN   NULL  *                   TRY AGAIN
         XIO   IWRDRES(CAWRTRD),4  SEND PRE-SIGNON, REC DLE ACK0
         BC    7,IAGAIN            TRY AGAIN IF NOT STARTED
         $SSM  FF                  PREPARE FOR INTERRUPT
         B     *                   LOOP UNITL INTERRUPT
INTFAKE  DC    X'01',AL1(CAINTID),Y($START),AL4($IOINT) FAKE AND REAL
INITINT  NULL  *                   INITIALIZATION INTERRUPT PROCESSOR
         CLI   145,CAINTID         IS THIS BSCA
         BNE   IBACK               BR IF NO TO IGNORE
         TIOB  IAGAIN,CAERROR      RETRY IF ANY ERROR
         CLC   IREADRES,=AL1(XDLE,XACK0) WAS ACK RECEIVED
         BNE   IAGAIN              START OVER IF NOT
IHOMSKP  DS    0H
         MVC   144(8),INTFAKE      SETUP FAKE OLD AND GOOD NEW PSW
         B     IBLDBUFS            GO BUILD BUFFERS AND SIGN-ON
IWRDRES  DC    AL1(XSOH,XENQ)      IDENTIFY AS CPU TERMINAL
IREADRES DC    AL2(0)              RESPONSE CHARACTERS FROM HASP
IBACK    NULL  *                   NOT BSCA INTERRUPT
         SPSW  144                 RETURN
.IMODXX  ANOP
         EJECT
         LTORG
         EJECT
         SPACE 20
$L       EQU   *-HASPRJE+&HRTPORG                                 V03.1
$L1      EQU   $L/100000*100000
$L2      EQU   ($L-$L1)/10000*10000
$L3      EQU   ($L-$L1-$L2)/1000*1000
$L4      EQU   ($L-$L1-$L2-$L3)/100*100
$L5      EQU   ($L-$L1-$L2-$L3-$L4)/10*10
$L6      EQU   $L-$L1-$L2-$L3-$L4-$L5
         SPACE 3
*
*                  THE FOLLOWING VALUE OF $DLENGTH INDICATES THE
*                  MINIMUM MEMORY SIZE TO CONTAIN THIS PROGRAM.
*                  THE VALUE REPRESENTS THE DECIMAL VALUE
*
$DLENGTH EQU   $L1/100000*1048576+$L2/10000*65536+$L3/1000*4096+$L4/100C
               *256+$L5/10*16+$L6
         EJECT                                                 UF099
IEZCOM   DSECT                                                 UF099
         IEZCOM                                                UF099
         EJECT                                                 UF099
CIB      DSECT                                                 UF099
         IEZCIB                                                UF099
 TITLE 'H A S P REMOTE TERMINAL PROCESSOR DEBUGGING AID PAGE '
**********************************************************************$
         SPACE 1
*                       SIGNIFICANT LOCATION ADDRESSES
         SPACE 1
$01   EQU   CBUFFER           CURRENTLY ACTIVE COMMUNICATIONS BUFFER  $
         AIF   (&TRACE EQ 0).INFO1
$02   EQU   $TRACUR           CURRENT LOCATION IN TRACE TABLE         $
.INFO1   ANOP
$03   EQU   $TANK1            START OF DECOMPRESSION TANKS            $
$04   EQU   $1STBUF           BEGINNING OF COMMUNICATIONS BUFFER POOL $
$05   EQU   $BUFPOOL          FREE BUFFER CHAIN START                 $
$06   EQU   $TANKPOL          FREE DECOMPRESSION TANK CHAIN START     $
$08   EQU   $OUTBUF           BUFFERS AWAITING TRANSMISSION           $
$09      EQU   $FCSOUT             FUNCTION-CONTROL-SEQUENCE          $
$10   EQU   COMWRITE          LAST TP WRITE COMMAND                   $
$11   EQU   $LOGCLAS          ERROR LOG CLASS LEVEL                   $
         SPACE 1
**********************************************************************$
         SPACE 2
*                       M O D E L  2 0  -  BSCA SENSE BYTES           $
         SPACE 1
*              00 = UNDEFINED
*              01 = DATA OVER-RUN ON A WRITE
*              02 = CPU-BSCA PARITY CHECK ON WRITE
*              04 = MAIN STORAGE EXCEEDED ON WRITE
*              08 = NO ENDING SEQUENCE FOUND ON WRITE
*              10 = NOT DEFINED
*              20 = NOT DEFINED
*              40 = EOT RECEIVED WHILE WRITING
*              80 = NOT DEFINED
*              81 = DATA OVER-RUN ON READ
*              82 = NOT DEFINED
*              84 = MAIN STORAGE EXCEEDED ON READ
*              88 = LOST DATA ON READ
*              90 = READ TIMEOUT
*              A0 = DATA CHECK ON READ
*              C0 = EOT RECEIVED ON READ
         SPACE 2
*                       H A S P  E R R O R  L O G  C O D E S
         SPACE 1
*              00 = TRACE ENTRY (NOT LOGGED)
*              01 = BLOCK COUNT CHECK
*              02 = NEGATIVE ACKNOWLEDGEMENT RECEIVED
*              03 = UNKNOWN RESPONSE RECEIVED
*              04 = EOT RECEIVED
*              05 = UNIT CHECK
*              06 = UNUSUAL CHANNEL END
*              07 = SIO FAILURE (360 ONLY)
*              08 = ADAPTER WRITE LOGGING ( 360 ONLY )
*              09 = ALL COMMUNICATIONS INTERRUPTS
         EJECT
         SPACE 5
***********************************************************************
*
*        EIGHT CHARACTER ERROR MESSAGE CODES
*
*              01 = BLOCK COUNT CHECK (DUPLICATE OR LOST RECORDS)
*                   01IIEE00         II= INPUT BLOCK CHECK FROM HASP
*                                    EE= EXPECTED BLOCK CHECK
*
*              02 = NEGATIVE ACKNOWLEDGEMENT RECEIVED
*                   02000000
*
*              03 = UNKNOWN RESPONSE RECEIVED
*                   03IIII00       IIII= DATA BYTES 1,2 OF INPUT.
*                                  ( IF CORRECT CONTROL SEQUENCE
*                                  ENDING SEQUENCE IS INVALID )
*
*              04 = UNIT EXCEPTION - EOT RECEIVED
*                   0400AAAA       AAAA= DEVICE ADDRESS. 0 FOR BSCA
*
*              05 = UNIT CHECK
*                   05SSAAAA         SS= SENSE BYTE
*                                  AAAA= DEVICE ADDRESS. 0 FOR BSCA
*
*              06 = UNUSUAL END
*                   06CCAAAA         CC= CSW BYTE 5
*                                  AAAA= DEVICE ADDRESS. 0 FOR BSCA
*
*              07 = SIO FAILURE
*                   07000000
*
*              08 = ADAPTER WRITE LOGGING
*                   08OOOOOO       OOOOOO= BYTES 2,3,4 OF OUTPUT DATA
*
*              09 = ALL COMMUNICATION ADAPTER INTERRUPTS
*                   09IIIIII       IIIIII= BYTES 2,3,4 OF INPUT DATA
*
***********************************************************************
         EJECT
         END   HASPRJE                                            U0019
