MICR     TITLE 'MICROFICHE WRITER SUBROUTINE'
         MACRO
         TTRMAC
         GBLA  &ACROSS,&DOWN,&LINES,&LINESIZ
         GBLA  &EYECNT,&EYEBLK,&EYEWIT,&EYEHIT
         LCLA  &I,&J,&K,&L
         LCLC  &A,&B
         LCLA  &MAX1,&MAX2
&MAX1    SETA  &ACROSS*&DOWN-1
&MAX2    SETA  &MAX1+2
&J       SETA  1
&K       SETA  1
&L       SETA  1
.*
.SETI    ANOP
&I       SETA  1
         AGO   .NOJ
.LOOP    AIF   (&I NE &ACROSS).NOJ
&B       SETC  '+XPAG'
.NOJ     AIF   (&J NE 1).NOI
&A       SETC  '+XUST'
.NOI     ANOP
.*
TTR&K    DC    XL4'0',AL1(XEND&A&B),AL3(TTR&L)
&A       SETC  ''
&B       SETC  ''
         AIF   (&K NE &ACROSS).NOK
TTRDAT   EQU   *             START OF DATA FRAMES FOLL. EYEBALL
.NOK     ANOP
&K       SETA  &K+1
&L       SETA  &L+&ACROSS
         AIF   (&L LT &MAX2).INCI
&L       SETA  &L-&MAX1
.INCI    ANOP
&I       SETA  &I+1
         AIF   (&I LE &ACROSS).LOOP
&J       SETA  &J+1
         AIF   (&J LE &DOWN).SETI
         MEND
         SPACE 2
         GBLA  &ACROSS,&DOWN,&LINES,&LINESIZ
         COPY  OPTIONGB      DEFINE GLOBALS                      86111
         GBLA  &EYECNT,&EYEBLK,&EYEWIT,&EYEHIT
         GBLA  &WKBLKSI,&WKBPP,&WKLPB,&TEMP
&ACROSS  SETA  10            WAS 16
&DOWN    SETA  8             WAS 10
&LINES   SETA  64            LINES PER PAGE
&LINESIZ SETA  133           133 CHARACTERS PER LINE
&EYECNT  SETA  3             WAS 2 - BIG LETTERS PER TITLE PAGE
&EYEWIT  SETA  39            WIDTH OF EYEBALL3 CHARACTER
&EYEHIT  SETA  44            HEIGHT OF EYEBALL3 CHARACTER
&EYEBLK  SETA  &EYEWIT*&EYEHIT  BLKSIZE OF EYEBALL3 FILE
*      UPDATED 6/30/75 BY C. DAVIS FOR THREE/FRAME EYEBALLS
&WKBLKSI SETA  (&LINES*&LINESIZ)/4  WORK FILE BLOCK SIZE
&WKLPB   SETA  &WKBLKSI/&LINESIZ  DATA LINES PER DISK BLOCK
&WKBPP   SETA  ((&LINES+&WKLPB-1)/&WKLPB)   DISK BLOCKS PER PAGE
         AIF   (&ACROSS GT 16).TOA
         AIF   (&ACROSS GE 10).TOC
&ACROSS  SETA  10            MINIMUM
         AGO   .TOC
.TOA     ANOP
&ACROSS  SETA  16            MAXIMUM
.TOC     SPACE 1
         SYSPARM LIST=YES    SET GLOBALS                         86111
         EJECT
         PRINT &PRTSOR
*
*        SPECIALIZED MICRO FICHE WRITER SUBROUTINE
*        CALL MICROS,(RECORD),VL  EACH CALL PASSES ONE RECORD ADDRESS
*              RECORD MUST BE 133 BYTES IN LENGTH.  POSITION ONE
*              IS EITHER A MACHINE CODE OR ASA CARRIAGE CONTROL
*              CHARACTER.
*        FIRST ENTRY (AND FIRST ENTRY PER FORCED FICHE) HAS A PSEUDO
*        CONTROL CHARACTER OF $ FOLLOWED BY THE FICHE TITLE.
*        LAST ENTRY HAS EIGHT HEX ZEROES IN THE LEADING EIGHT BYTES;
*        THIS TERMINATES PROCESSING.
*        SUBCONTROL OPTIONS :
*         COL 2 //*MICRO     SPECIAL CONTROL CARD
*              COL 11 PARM    TEXT CONTAINS EMBEDDED ASMANY2 PAGES.
*                 COL 17-      BLANK - SUPPRESS ASMANY2 PAGE SEPARATOR
*                 COL 17-      % - NEW FICHE PER ASMANY2 PAGE
*                 COL 17-      PREFIX TO MATCH FOR NEW FICHE PAGE
*
*        JCL REQUIRED - MINIMUM OF 60K INCREASE IN REGION
*        //SYSUT2 DD UNIT=2400-3,LABEL=(,NL,,OUT),DCB=DEN=3
*              MICROFICHE PROCESSOR OUTPUT TAPE
*        //SYSUT3 DD DSN=SYS1.EYEBALL3,DISP=SHR  EYEBALL DATASET
*        //SYSUT4 DD UNIT=SYSDA,DCB=DSORG=DA,SPACE=(2128,321)
*              TEMPORARY WORK DATA SET  OR ALTERNATIVELY :
*        //SYSUT4P DD DSN=...,DISP=OLD  OLD, PREFORMATTED WORK DATASET
*        //SYSPRINT DD SYSOUT=A        OUTPUT LOG & MESSAGES
*
MICROSUB START 0
         ENTRY MICROS        ENTRY FOR FORTRAN CALLERS
         REGEQU
         USING *,R10,R11,R12
MICROS   STM   R14,R12,12(R13)
         LR    R10,R15       COPY
         LM    R11,R12,PROGADD
         LA    R9,SAVE
         ST    R9,8(,R13)
         ST    R13,4(,R9)
         LR    R13,R9
         SPACE 1
         LA    R1,0(,R1)     PARM LIST ADDRESS ?
         LTR   R1,R1         PARM LIST ADDRESS ?
         BZ    EXIT16        NONE, MAJOR ERROR
         L     R1,0(,R1)     GET ADDRESS OF INPUT RECORD
         LA    R1,0(,R1)     JUST IN CASE
         LTR   R1,R1         ANY ?
         BZ    EXIT16        NO, TOO BAD
         MVC   INREC,0(R1)   SAVE INPUT FOR LATER
         TM    IPFG,FEOF+FINIT  FIRST OR LAST TIME ?             86118
         BM    BRMORE        NEITHER; CHECK FOR END              86118
         BO    EXIT16        TOO LATE; TOO BAD                   86118
         SERVINIT ,                                             GP12043
         OI    IPFG,FINIT+FEOF    SET INITIALIZATION ATTEMPTED   86118
         SERVLOAD @PRINTER   LOAD THE PRINTER ROUTINE           GP12043
         OI    PARMFG,PRTOP  SHOW PRINT FILE OPENED EXTERNALLY   86111
         PRTV  HEADER,TITLE=1  PRINT THE TITLE                   86111
         BXLE  R15,R15,PREPRINT  PRINT ALREADY OPEN              86111
         NI    PARMFG,255-PRTOP   SET INTERNAL OPEN              86111
         PRTOPEN SYSPRINT,OPT=(WTO)                              86111
         PRTV  HEADER,TITLE=1  PRINT TITLE                       86111
         PRTV  SUBHEAD,TITLE=3  AND SUB-TITLE                    86111
PREPRINT OPEN  (EYEBALL,(INPUT))
         TM    EYEBALL+DCBOFLGS-IHADCB,DCBOFOPN  OPENED ?        86111
         BZ    EXIT16
         DEVTYPE WORKL+DCBDDNAM-IHADCB,DB  IS SYSUT4 DD PRESENT ?
         BXLE  R15,R15,WORKOPL  YES - OPEN FOR LOAD MODE
         OI    PARMFG,PREFMT  SET PREFORMATTED DSN PRESENT       86111
         DEVTYPE WORK+DCBDDNAM-IHADCB,DB  IS SYSUT4P PRESENT ?   86118
         BXH   R15,R15,EXIT16  NO - TOO BAD
         B     WORKOPNL      SKIP OPEN
WORKOPL  MVC   WORK+DCBDDNAM-IHADCB(8),WORKL+DCBDDNAM-IHADCB     86118
         OPEN  (WORKL,(OUTPUT))
         TM    WORKL+DCBOFLGS-IHADCB,DCBOFOPN  OPENED ?          86111
         BZ    EXIT16
WORKOPNL L     R4,WKBUF
         LR    R3,R4         SAVE FOR (MUCH) LATER
         LA    R1,&LINES+1
WORKIBZ  MVI   0(R4),0       UNUSED
         LA    R4,L'INREC(,R4)   NEXT RECORD
         BCT   R1,WORKIBZ    CLEAR ENTIRE BLOCK
         LM    R5,R7,INDEXAD   GET TTR TABLE POINTERS
         MVC   INDEXAD,INDEXDAT   SET FOR DATA MOVES
         LA    R8,&WKBPP*(&ACROSS*&DOWN)+1
         LA    R2,1          GET NOTE ON FIRST ONE
         SLR   R9,R9         CLEAR BLOCK COUNTER
         USING INDEX,R5
         SPACE
WORKIPUT TM    PARMFG,PREFMT  PREFORMATTED ?                     86111
         BNZ   WORKINPU      YES - SKIP WRITE
         MVI   WORKIECB,0    CLEAR
         WRITE WORKIECB,SF,WORKL,(R3),'S'   WRITE DUMMY BLOCK
         CHECK WORKIECB
WORKINPU BCT   R2,WORKINC    IS NOTE NEEDED ?
         ST    R9,INDTTR     SAVE BLOCK NUMBER
         LA    R2,&WKBPP     SET TO SKIP NOTE ON INTERMEDIATE BLOCKS
         AR    R5,R6         NEXT TTR ADDRESS POINTER
WORKINC  LA    R9,1(,R9)     UP RELATIVE BLOCK
         BCT   R8,WORKIPUT   DO NEXT BLOCK
         TM    PARMFG,PREFMT  PREFORMATTED ?                     86111
         BNZ   WORKIOPN      YES; SKIP CLOSE
         CLOSE (WORKL)
WORKIOPN OPEN  (WORK,UPDAT)
         TM    WORK+DCBOFLGS-IHADCB,DCBOFOPN  OPENED ?           86118
         BZ    EXIT16
         DROP  R5
         OPEN  (OUTAPE,(OUTPUT))
         TM    OUTAPE+DCBOFLGS-IHADCB,DCBOFOPN   OPENED ?        86118
         BZ    EXIT16
         MVI   PUTDECB,X'7E'  INITIALIZE OUTPUT FOR OVERLAPPED I/O
         NI    IPFG,255-FEOF  ALLOW PROCESSING                   86118
         MVI   TITCC,C' '    SET TO CLEAR
         MVC   TITLE(TITBLEN),TITCC   CLEAR IT OUT
LENTIT   EQU   &EYECNT*&ACROSS
         SPACE
       GETMAIN VC,LA=GMREQ,A=GMADR   GET CORE
         LTR   R15,R15       ANY ?
         BNZ   BRMORE        NO, SKIP
         LM    R14,R15,GMADR  ADD/LEN  *****DEBUG*****
         SLR   R0,R0                   *****DEBUG*****
         SLR   R1,R1                   *****DEBUG*****
         MVCL  R14,R0        CLEAR     *****DEBUG*****
         L     R5,GMADR+4    GET LENGTH OBTAINED
         SLR   R4,R4         FOR DIVIDE
         D     R4,GMREQ      GET NUMBER OF FULL BLOCKS GOTTEN
         LR    R6,R4         SAVE REMAINDER
         SH    R5,H1         LESS ONE FOR 'OS' PROCESSING
         BP    GMENUF        ENOUGH FOR AT LEAST ONE BLOCK
         LM    R1,R2,GMADR   GET ADDRESS/SIZE GOTTEN
         FREEMAIN R,A=(1),LV=(R2)  FREE IT
         B     BRMORE        SKIP IF FEWER
GMENUF   A     R6,GMREQ      ADD ONE BLOCK
         LR    R8,R5         SAVE NO. OF BLOCKS TO BE USED
         CVD   R8,DB         AND SAVE FOR MESSAGE
         ZAP   CNCORE,DB
         M     R4,GMREQ      GET AMOUNT OF CORE TO BE USED
         A     R5,GMADR      PLUS START ADDRESS
     FREEMAIN  R,LV=(R6),A=(R5)    FREE EXTRA CORE
         LM    R6,R7,INDEXAD+4   GET INDEX PAGE POINTERS
         L     R5,INDEXBUF   GET TITLE START ENTRIES
         L     R3,GMADR      GET START ADDRESS OF IN-CORE BLOCKS
         USING INDEX,R5
GMNEXT   ST    R3,INDTTR     SAVE IN-CORE ADDRESS OF THE BLOCK
         OI    INDTTR,INCORE    FLAG AS IN-CORE BLOCK
         A     R3,GMREQ      BUMP TO NEXT BLOCK ADDRESS
         BXH   R5,R6,BRMORE  EXIT IF ALL DONE
         BCT   R8,GMNEXT     GET NEXT BLOCK, IF ANY
         DROP  R5
         SPACE 1
BRMORE   OC    INREC(8),INREC   END FILE ?
         BZ    GETINEOF      YES - TAKE EOF EXIT
         TM    IPFG,FONE     FIRST TIME ?                        86118
         BZ    FORCETIT      YES; FORCE A TITLE                  86118
         CLI   INREC,C'$'    TITLE ?
         BNE   GETIN         NO TITLE; USE DEFAULT               86118
FORCETIT MVI   INREC,C'$'    FORCED TITLE                        86118
         MVC   NEXTIT,INREC+1  COPY TITLE
         MVI   PARMLEN,X'FF'  RESET PAGE CONTROL
         MVI   CODESAV,X'E1'  RESET 'PREVIOUS' MCC CHARACTER
         NI    IPFG,255-FASA-FMCC  TURN OFF CARR. CONTROL TYPE
         B     PUTWKEOJ      AND FORCE END OF PREVIOUS FICHE JOB
         SPACE 2
PROGADD  DC    A(MICROSUB+4096,MICROSUB+8192)   BASE ADDRESSES
SAVE     DC    18F'0'
         EJECT
*        PROCESS INPUT RECORDS HERE
*              CHANNEL 12 SKIPS ARE IGNORED, OTHER CHANNEL SKIPS
*              ARE TREATED AS SINGLE SPACES. PAGE EJECT IS HONORED
*              OVERPRINTING IS NOT SUPPORTED AT THIS TIME
         SPACE 1
GETIN    TM    IPFG,FASA+FMCC  CARRIAGE CONTROL TYPE KNOWN ?     86118
         BNZ   GOTINIT       YES                                 86118
         IC    R3,INREC      SAVE CONTROL BYTE                   86118
         CLI   INREC,C'C'    ASA - SKIP 12 ?
         BE    GETIASA       OK
         LA    R4,2          TRY TWICE - FOR IMMEDIATE MCC
GETITR   LA    R1,CODEM      GET MACHINE CODE TABLE
         LA    R2,L'CODEM    AND LENGTH
GETINC   CLC   0(1,R1),INREC   MACHINE CODE ?
         BE    GETIMCC       GET ASA EQUIVALENT
         LA    R1,1(,R1)     TRY NEXT ONE
         BCT   R2,GETINC     TRY AGAIN
         TM    INREC,2       IMMEDIATE MCC BIT ?
         BZ    GETIASA       NO, ASSUME ASA
         NI    INREC,255-2   CLOBBER IMMEDIATE BIT
         BCT   R4,GETITR     TRY AGAIN
GETIASA  OI    IPFG,FASA     SET ASA MODE
         B     GETIAST       RESTORE CODE                        86118
GETIMCC  OI    IPFG,FMCC     SET MACHINE CODE FLAG
GETIAST  STC   R3,INREC      RESTORE CORRECT OPCODE
         SPACE 1
GOTINIT  LA    R1,INREC+1    POINT TO DATA AREA
         CLC   =C'     *',5(R1)  POSSIBLE MVS JCL ?              86111
         BE    GETMVSIN      YES ?                               86111
         CLC   =C'     /',5(R1)  OTHER NEW POSSIBILITY ?         86111
         BNE   GETMVSOL      NO                                  86111
GETMVSIN LA    R1,10(,R1)    SKIP LINE NUMBER FIELD              86111
         B     GETMVSCM      GO TO COMMON                        86111
GETMVSOL CLC   =C'  ',0(R1)  LOCAL MOD - TWO LEADING BLANKS ?    86111
         BNE   GETMVSCM      NO                                  86111
         LA    R1,2(,R1)     YES; SKIP OVER
GETMVSCM CLC   =C'***MICRO',0(R1)    CONTROL RECORD ?            86111
         BE    GETINPDO      YES; CHECK FURTHER
         CLC   =C'//*MICRO',0(R1)    CONTROL RECORD ?
         BNE   GETINOP       NO
GETINPDO CLC   =C'PARM',9(R1)     PAGE CONTROL PARM ?
         BNE   GETINTTL      NO; CHECK FOR TITLE
         MVI   PARMLEN,X'FF'   RESET PARM OPTION TO NONE
         CLI   15(R1),C'%'   ACCEPT ANY ?
         BNE   GETINPRM      NO; CHECK INDIVIDUALLY
         MVI   PARM,C'%'     SET FOR ANY
         MVI   PARMLEN,0
         B     GETINOP       AND PROCESS THIS CARD AS COMMENTS
GETINPRM LA    R14,15(,R1)   SET FIRST INPUT POSITION
         LA    R0,8          SET COLUMNS TO SCAN
         LA    R15,PARM      SET OUTPUT FIELD
GETINPRL CLI   0(R14),C' '   END OF PARM ?
         BE    GETINPRX      YES; CHECK LENGTH
         MVC   0(1,R15),0(R14)  COPY ONE
         LA    R15,1(,R15)   UP ONE
         LA    R14,1(,R14)
         BCT   R0,GETINPRL
GETINPRX LA    R14,7         SET FOR LEN-1 TEST
         SR    R14,R0        GET LEN-1 OF PARM
         BM    GETINOP       NONE - IGNORE
         STH   R14,PARMLEN   ELSE SAVE LENGTH
         B     GETINOP
GETINTTL CLC   =C'TITLE',9(R1)  TITLE OPTION ?
         BNE   GETINOP       NO; IGNORE
         MVC   NEXTIT,15(R1)
         MVC   TITLE(L'NEXTIT),15(R1)
GETINOP  TM    IPFG,FMCC     MACHINE CODE ?
         BZ    GETIN2        NO, ASA
         TM    INREC,2       IMMEDIATE OP ?
         BZ    GETINFP       NO, LEAVE AS IS
         MVI   INREC+1,C' '
         MVC   INREC+2(L'INREC-2),INREC+1   CLEAR RECORD CONTENTS
         NI    INREC,255-2   CLEAR IMMEDIATE COMMAND BIT
GETINFP  XC    CODESAV,INREC GET PRECEEDING CODE AND FLIP WITH CURRENT
         XC    INREC(1),CODESAV
         XC    CODESAV,INREC   COMPLETE FLIP
         SPACE
GETIN1   LA    R1,CODEM      GET MACHINE CODE TABLE
         LA    R2,L'CODEM    AND LENGTH
GETIN1A  CLC   0(1,R1),INREC   IS THIS ONE ?
         BE    GETIN1B       YES, PROCESS
         LA    R1,1(,R1)     TRY NEXT ONE
         BCT   R2,GETIN1A
GETIN1B  MVC   INREC(1),CODEA-CODEM(R1)   REPLACE WITH CORR. ASA CHAR
         SPACE 1
GETIN2   TM    IPFG,FEJE     SKIPPING TILL EJECT ?
         BZ    GETIN2A       NO
         CLI   INREC,C'1'    IS IT AN EJECT
         BNE   GETMORE       NO, IGNORE THIS RECORD
         NI    IPFG,255-FEJE   TURN EJECT SKIP FLAG OFF
         MVI   INREC,C' '    PREVENT EXTRANEOUS PAGE EJECT
         SPACE
GETIN2A  CLI   INREC,C'C'    CHANNEL 12 SKIP ?
         BE    GETMORE       YES, SKIP IT
         CLI   INREC,C'+'    OVERPRINT ?
         BE    GETMORE       YES, SKIP AT THIS TIME
         B     PUTWK         GO TO PUT RECORD OUT TO DISK
         SPACE 1
GETINEOF OI    IPFG,FEOF     SET END-FILE FLAG
         NI    IPFG,255-FEJE  RESET SKIPPING                     86118
         MVI   INREC+1,C' '  MAKE A BLANK RECORD
         MVC   INREC+2(L'INREC-2),INREC+1
         MVI   INREC,C'1'    SET PAGE EJECT
*        B     PUTWK                                             86118
         EJECT
*        AT THIS TIME AN INPUT RECORD IS IN THE BUFFER. THE FOLLOWING
*              CODE WILL BLCK IT AND WRITE IT TO THE PROPER DISK LOCATI
*
PUTWK    TM    IPFG,FEJE     SKIP OPTION ?
         BO    GETMORE       YES, SKIP IT
         TR    INREC+1(L'INREC-1),TRTAB  PREVENT CONTROL CHARACTERS
         CLI   INREC,C'$'    TITLE RECORD ?                      86142
         BE    PUTWKEOJ      YES; FORCE NEW FICHE                86142
         LM    R4,R5,WKADD   GET WORK BLOCK ADDRESS
         LA    R1,CODEA      GET ASA CODE TABLE
         LA    R2,L'CODEA-1  GET LENGTH TO BE SEARCHED
         SPACE
PUTWK1   CLC   0(1,R1),INREC IS IT THIS CODE ?
         BE    PUTWK2        YES, PROCESS
         LA    R1,1(,R1)
         BCT   R2,PUTWK1     ELSE TRY NEXT ONE
         SPACE
PUTWK2   IC    R2,CODESZ-CODEA(,R1)  GET LINE COUNT FOR THIS CODE
         AH    R2,PUTWCNT    ADD TO CURRENT LINE COUT
         STH   R2,PUTWCNT    STASH BACK FOR NEXT LINE
         CR    R4,R5         END OF BUFFER ?
         BNL   PUTWKPG       YES, NEED DISK WRITE
         LR    R1,R4         SAVE ADDRESS IN BUFFER
         LA    R4,L'INREC(,R4)   NEXT BUFFER POSITION
         ST    R4,WKADD      STASH IT BACK
         MVI   0(R4),0       SET NEXT RECORD UNUSED
         CH    R2,PUTWMAX    HIT END OF PAGE ?
         BH    PUTWKPG       YES, NEEDS DISK WRITE               86142
         MVC   0(L'INREC,R1),INREC   COPY RECORD TO BLOCK
         B     GETMORE       GET NEXT INPUT RECORD
         SPACE 2
PUTWKPG  MVI   INREC,C' '    NEXT TIME - IS AT TOP OF PAGE
PUTWKEOJ LM    R5,R7,INDEXAD   GET PAGE INDEX TABLE
         XC    PUTWCNT,PUTWCNT   CLEAR LINE COUNT
         L     R4,WKBUF      GET WORK BUFFER ADDRESS
         ST    R4,WKADD      STASH IT BACK
         C     R5,INDEXDAT   TOP OF FICHE ?
         BNE   PUTWKSEP      NO, NOW CHECK FOR SEPARATOR
         AP    PPAGE,P1      UP PAGE COUNT
         MVC   DB(4),=X'40202120'
         ED    DB(4),PPAGE   FORMAT PAGE NUMBER
         MVC   TITPAG,DB+2   COPY TO EYEBALL
         WAIT  ECB=PUTDECB   WAIT ON I/O FOR BUFFER INTEGRITY
         BAL   R14,IBALL     MAKE EYEBALL FRAMES
PUTWKSEP BAL   R14,SEPAR     DO SEPARATOR CHECK
         B     PUTFORCE      SEPARATOR - FORCE NEW FICHE PAGE
         CLI   INREC,C'$'    TITLE CALL ?
         BNE   PUTWKSEW      NO; DO WRITE
         CLI   0(R4),0       IS PREVIOUS FICHE PAGE EMPTY ?
         BE    PUTWFICH      YES; SKIP WRITE AND STATUS FLAGS
PUTWKSEW LA    R8,&WKBPP     BLOCKS PER PAGE
         USING INDEX,R5
         MVC   BLKNO,INDTTR   GET FIRST BLOCK NUMBER FOR THIS PAGE
         TM    INDTTR,INCORE   IS THIS AN IN-CORE BLOCK ?
         BZ    PUTWKIO       NO, DO THE I/O
         L     R1,INDTTR     GET IN-CORE ADDRESS
         LR    R15,R4        GET INPUT ADDRESS
         BAL   R9,BLKMOVE    MOVE THE BLOCK AND UP IN-CORE COUNT
         B     PUTWKINC      AND SKIP THE I/O
         SPACE 2
PUTWKIO  MVI   PUTWKECB,0    CLEAR ECB
         WRITE PUTWKECB,DI,WORK,(R4),'S',0,RELBLK  WRITE A BLOCK TO DIS
         WAIT  ECB=PUTWKECB  WAIT FOR COMPLETION
         BAL   R9,BLKUP      UP THE BLOCK NUMBER
         LA    R15,&WKLPB    GET NUMBER OF LINES IN THIS BLOCK
PUTWKIOL CLI   0(R4),0       EMPTY RECORD ?
         BE    PUTWKIOC      YES; TERMINATE WRITE
         LA    R4,L'INREC(,R4)  ELSE GO TO NEXT RECORD
         BCT   R15,PUTWKIOL
         BCT   R8,PUTWKIO    GO TO WRITE NEXT BLOCK IN THIS PAGE
PUTWKIOC AP    CNIO,P1       UP THE DISK I/O COUNTER
         SPACE
PUTWKINC OI    NXFG,XUSE     INDICATE THIS BLOCK IS USED
         OI    IPFG,FDAT
         SH    R5,=Y(&ACROSS*L'TTRTAB)   BUMP BACK ONE ROW
         NI    NXFG,255-XEND   TURN OFF LAST PAGE IN COLUMN BIT
         AH    R5,=Y((&ACROSS+1)*L'TTRTAB)   POINT TO NEXT PAGE
         ST    R5,INDEXAD    STASH IT BACK
         SPACE
PUTFORCE TM    IPFG,FEOF+FEJE   EOF ON INPUT OR FORCED FICHE PAGE ?
         BNZ   PUTWFICH      YES, GO TO PUT OUT FICHE PAGE
         CR    R5,R7         END OF TTR TABLE ?
         BH    PUTWFICH      YES, NEED TO PUT OUT FICHE PAGE
PUTWKZ   L     R4,WKBUF      GET BUFFER ADDRESS BACK
         MVI   0(R4),0       SET FIRST RECORD UNUSED
         CLI   INREC,C'$'    TITLE RECORD ?                      86142
         BE    GETMORE       GET ANOTHER INPUT RECORD            86142
         B     PUTWK         NOW GO PROCESS INPUT RECORD FOR NEXT BLOCK
         SPACE 3
BLKMOVE  LA    R14,&LINES    MOVE PAGE MAXIMUM LINES
         AP    CNINC,P1      UP IN-CORE I/O COUNTER
         LA    R0,L'INREC    GET RECORD LENGTH FOR FASTER ADD
BLKMLP   MVC   0(L'INREC,R1),0(R15)   MOVE ONE LINE
         CLI   0(R1),0       WAS THIS RECORD EMPTY ?
         BER   R9            YES; TERMINATE MOVE
         AR    R1,R0         POINT TO NEXT OUTPUT RECORD
         AR    R15,R0        AND NEXT INPUT
         BCT   R14,BLKMLP    DO ENTIRE PAGE
         BR    R9            RETURN
         EJECT
*        AT THIS POINT ONE COMPLETE FICHE PAGE HAS BEEN FINISHED
*              THE REMAINING CODE WILL READ THE ENTIRE FICHE IN
*              SEQUENTIALLY, AND REBLOCK AND CONDENSE THE OUTPUT
*
PUTWFICH L     R5,INDEXBUF   GET TTR ADDRESS
*        LM    R6,R7,INDEXAD+4   DONE BY CALLER
         MVC   INDEXAD,INDEXDAT   RESET ADDRESS FOR FIRST DATA PAGE
         SPACE
READFICH L     R4,INDPTR
         DROP  R5
         USING INDEX,R4
         TM    NXFG,XUSE     PAGE EMPTY ?
         BZ    READPNT       YES, SKIP AND TRY NEXT ONE
         TM    IPFG,FDAT     ANY DATA ?
         BZ    READPNT       NO, SKIP PUTS
         TM    NXFG,XTIT     IS THIS A TITLE FRAME ?
         BO    READLOO1      YES, SKIP COUNT
         AP    PFRAME,P1     INCREASE FRAME COUNT
         SPACE
READLOO1 TM    INDTTR,INCORE   IS DISK I/O REQUIRED ?
         BZ    READLOO2      YES, DO IT
         L     R3,INDTTR     GET STORAGE ADDRESS OF BUFFER
         B     READPBUG      SKIP THE DISK I/O
         SPACE
READLOO2 AP    CNIO,P1       UP DISK I/O COUNTER
         MVC   BLKNO,INDTTR  GET TTR FOR THIS PAGE
         LA    R8,&WKBPP     BLOCKS PER PAGE
         L     R3,WKBUF      INPUT BUFFER
READLOOP MVI   READDECB,0    CLEAR
         READ  READDECB,DI,WORK,(R3),'S',0,RELBLK   READ A BLOCK
         WAIT  ECB=READDECB  WAIT FOR I/O COMPLETION
         BAL   R9,BLKUP      UP THE BLOCK NUMBER
         LA    R15,&WKLPB    CHECK FOR ALL RECORDS
READLIZ  CLI   0(R3),0       EMPTY RECORD HIT ?
         BE    READPBUF      YES, SKIP FURTHER READS
         LA    R3,L'INREC(,R3)
         BCT   R15,READLIZ   ELSE TRY NEXT ONE
         BCT   R8,READLOOP
READPBUF L     R3,WKBUF      GET START OF BUFFER
READPBUG CLI   PUTDECB,X'7E'  DUMMY POST FOR FIRST TIME ?
         BE    READPBUM      YES, SKIP CHECK
         CHECK PUTDECB
READPBUM LA    R2,&LINES     NO. OF INPUT LINES
         LA    R1,L'ENDREC   MINIMUM OUTPUT BLOCK LENGTH
         L     R8,OUTBUF     GET OUTPUT BUFFER ADDRESS
READPLOP CLI   0(R3),0       EMPTY RECORD ?
         BE    READPEND      YES, MOVE END LINE
         MVC   0(1,R8),0(R3)   COPY CONTROL CHARACTER
         MVC   2(L'INREC-1,R8),1(R3)   COPY DATA PORTION OF RECORD
         MVI   1(R8),C' '    ADD SUBSIDIARY CONTROL CHARACTER
         LA    R15,L'INREC-2  MAX LENGTH FOR CHECKING
READPLED CLI   L'INREC(R8),C' '  TRAILING BLANK ?
         BNE   READPINC      NO, ADD LINE EJECT CONTROL CHARACTER
         BCTR  R8,0          BUMP BACK ONE
         SH    R1,H1         DECREASE LENGTH
         BCT   R15,READPLED  AND TRY AGAIN
READPINC MVI   L'INREC+1(R8),X'E0'   ADD RECORD MARK
         LA    R8,L'INREC+2(R8,0)  NEXT OUTPUT POSITION
         AH    R1,*-2        UP LENGTH COUNT
         LA    R3,L'INREC(,R3)   NEXT INPUT ADDRESS
         BCT   R2,READPLOP   NEXT RECORD
         SPACE
READPEND MVC   0(L'ENDREC,R8),ENDREC   MOVE TRAILER RECORD IN
         TM    NXFG,XEND     IS THIS END OF COLUMN ?
         BZ    READPUT       NO, PUT OUT RECORD
         MVI   0(R8),C'M'    ADVANCE COLUMN CONTROL BYTE
         TM    NXFG,XPAG     IS THIS COLUMN THE LAST ON PAGE ?
         BZ    READPUT       NO, LEAVE COLUMN ADVANCE
         MVI   0(R8),C'G'    MOVE 'FRAME ADVANCE' CONTROL BYTE
         LR    R5,R7         FORCE PAGE EXIT
         SPACE
READPUT  MVI   PUTDECB,0     CLEAR
         L     R2,OUTBUF     GET OUTPUT BUFFER
         LR    R3,R1         COPY LENGTH
         WRITE PUTDECB,SF,OUTAPE,(R2),(R3)
         SPACE
READPNT  NI    NXFG,255-XUSE   RESET CONTROL FLAGS FOR NEXT TIME ROUND
         OI    NXFG,XEND     SET END FLAG
         TM    NXFG,XTIT     IS THIS AN EYEBALL FRAME ?
         BZ    *+8           NO, SKIP
         OI    NXFG,XUSE     YES, SET USE COUNT
         BXLE  R5,R6,READFICH  KEEP GOING UNTIL ALL DONE
         TM    IPFG,FEOF+FEJE  END OF INPUT OR FORCED CHANGE ?
         BNZ   READSHOW      YES, SHOW CHANGE
         CLC   NEXTIT(L'NEXTIT),TITLE   TITLE CHANGE ?
         BE    READEXIT      NO
READSHOW MVC   TITFRAM-1(6),=X'402020202120'
         ED    TITFRAM-1(6),PFRAME     SHOW FRAME COUNT
         TM    IPFG,FDAT     ANY DATA ?
         BO    READPRNT      YES, PRINT IT
         SP    PPAGE,P1      ELSE TAKE ONE OFF TO GET TRUE FICHE COUNT
         MVC   DB(4),=X'40202120'
         ED    DB(4),PPAGE
         MVC   TITPAG,DB+2   COPY TO EYEBALL
         TM    IPFG,FONE     FIRST TIME AND EMPTY ?
         BZ    READRST       YES, SKIP PRINTOUT
READPRNT PRTV  VTITLE        SHOW PAGE INFO                      86111
READRST  AP    PTOTAL,PPAGE  TOTAL FICHE PAGES
         SP    PPAGE,PPAGE   RESET COUNT
         SP    PFRAME,PFRAME   CLEAR COUNTS
         MVC   TITLE(L'NEXTIT),NEXTIT
READEXIT TM    IPFG,FEOF     END FILE ON INPUT ?
         BO    RETURN        YES, EXIT
         OI    IPFG,FONE     SET NOT FIRST TIME BIT
         NI    IPFG,255-FDAT   TURN OFF DATA BIT
         B     PUTWKZ        RE-INIT. BUFFER AND GET NEXT INPUT REC.
         EJECT
*        TERMINATION PROCESSING
*
RETURN   CLOSE (WORK)
         CLOSE (EYEBALL)
         WAIT  ECB=PUTDECB   WAIT FOR WRITE TO FINISH
         CLOSE (OUTAPE)
         MVC   TITLE(TITBLEN),TITCC   CLEAR
         MVI   TITCC,C'0'    DOUBLE SPACE
         MVC   TITPAG-3(6),=X'402020202120'
         ED    TITPAG-3(6),PTOTAL
         MVC   TITPAG-5-L'TOTMSG(L'TOTMSG),TOTMSG
         PRTV  VTITLE                                            86111
         PRTV  VOPTHEAD                                          86111
         PRTV  VOPTS                                             86111
         LA    R1,&ACROSS*&DOWN    NUMBER OF BLOCKS
         CVD   R1,DB
         ED    NCBMAX,DB+6   SHOW NUMBER
         ED    NCCORE,CNCORE   SHOW NUMBER OF IN-CORE BLOCKS
         ED    NCIO,CNIO     EDIT NO. OF DISK I/OS
         ED    NCINC,CNINC   SHOW NUMBER OF IN-CORE I/OS
         PRTV  VSTAT         PRINT I/O STATISTICS                86111
         TM    PARMFG,PRTOP   PRINTER ALREADY OPENED ?           86111
         BNZ   RETDELTE      YES; DON'T CLOSE HERE               86111
         PRTCLOSE DEV=1      CLOSE IT                            86111
RETDELTE SERVTERM ,          CLEAN UP                           GP12043
         SPACE 1                                                 86111
GETMORE  DS    0H            NORMAL EXIT TO GET NEXT RECORD
EXIT     SLR   R15,R15       ZERO RETURN CODE
EXITC    L     R13,4(,R13)   BUMP BACK
         LM    R0,R12,20(R13)   RESTORE REGS
         L     R14,12(,R13)  GET RETURN ADDR.
         BR    R14           RETURN
         SPACE
EXIT16   LA    R15,16        SET BIG RETURN CODE
         B     EXITC         AND GET OUT
         SPACE 2
BLKUP    L     R15,BLKNO     GET PREVIOUS BLOCK NUMBER
         LA    R15,1(R15,0)  UP BY ONE
H1       EQU   *-2
         ST    R15,BLKNO     STASH BACK FOR NEXT I/O
         BR    R9            RETURN
         EJECT
*        THIS SUBROUTINE FORMATS THE EYEBALL LINE
*
IBALL    STM   R14,R12,SAVE2    SAVE REGISTERS
         TM    EYESTOR,X'80'  FIRST TIME ENTRY ?
         BZ    IBALL2        NO; SKIP
         NI    EYESTOR,255-X'80'  ELSE SET GETMAIN CHECK DONE
         LA    R4,L'EYEINDEX  GET NUMBER OF EYEBALL PAGES
         LA    R3,&EYEBLK    EYEBALL BLOCKSIZE
         MR    R2,R4         R3=REGION FOR RESIDENT EYEBALL
         GETMAIN EC,LV=(R3),A=DB   TRY TO OBTAIN ENOUGH
         BXH   R15,R15,IBALL2  INSUFFICIENT SPACE
         L     R1,DB         ELSE GET ADDRESS
         LA    R1,0(,R1)     JUST IN CASE
         ST    R1,EYESTOR    SAVE ADDRESS AND ZERO FLAGS
IBALL1L  MVI   0(R1),0       FLAG THIS PAGE AS UNREAD
         LA    R1,&EYEBLK.(,R1)  POINT TO NEXT PAGE
         BCT   R4,IBALL1L    REPEAT FOR ALL PAGES
IBALL2   L     R1,EYEBUF
         LA    R2,&EYEHIT+2  SET EYEBALL LINES + SPACERS
         MVI   0(R1),C' '    SET FOR BLANK
IBALINIT MVC   1(L'INREC,R1),0(R1)   CLEAR A LINE
         LA    R1,L'INREC(,R1)   NEXT ONE
         BCT   R2,IBALINIT   DO MORE
         MVI   0(R1),0       SET UNUSED
         L     R6,INDEXBUF
         DROP  R4
         USING INDEX,R6
         LA    R8,&ACROSS      2 OR 3 CHARACTERS PER FRAME
         LA    R4,TITLE      GET TITLE LINE
IBALLOOP CLC   0(&EYECNT,R4),TITLE-PREVTIT(R4)   SAME AS BEFORE ?
         BE    IBALINC       YES, SKIP ALL I/O AND FORMATTING
         MVC   BLKNO,INDTTR  GET TTR FOR THIS PAGE
         L     R14,OUTBUF    GET EYEBALL INPUT BUFFER
         MVI   0(R14),C' '
         LA    R15,(&EYECNT*&EYEBLK/255)+1   GET NO. OF TIMES TO CLEAR
IBALBLK  MVC   1(256,R14),0(R14)   BLANK IT
         LA    R14,255(,R14) NEXT LINE
         BCT   R15,IBALBLK
         LA    R2,&EYECNT      2 OR 3 CHARACTERS
         LA    R3,DBLTTR     GET BUFFER FOR TTRS
         LR    R14,R4        POINTER TO FIRST/NEXT TITLE GROUP
         LA    R5,EYEINDEX   POINT TO EYEBALL DSN INDEX
IBALLOOK LR    R15,R5        GET INDEX TO EYEBALL DATA SET
         LA    R1,L'EYEINDEX  AND LENGTH
IBALCH   CLC   0(1,R15),0(R14)  IS IT THIS CHARACTER ?
         BE    IBALSET
         LA    R15,1(,R15)   TRY AGAIN
         BCT   R1,IBALCH
         MVI   0(R3),X'FF'     SET EMPTY
         B     IBALTWO       LEAVE BLANK
IBALSET  SR    R15,R5        RELATIVE BLOCK NUMBER
         ST    R15,0(,R3)    SAVE IT
IBALTWO  LA    R3,4(,R3)
         LA    R14,1(,R14)
         BCT   R2,IBALLOOK
         L     R2,OUTBUF     GET INPUT ADDRESS
         LA    R7,&EYECNT      READ 2 OR 3 TIMES
         LA    R3,DBLTTR     POINTER TO REL. BLOCK ADDRESS
IBALGET  LR    R5,R2         COPY BLOCK ADDRESS FOR STORE
         CLI   0(R3),X'FF'     IS THERE A BLOCK NUMBER ?
         BE    IBALSGET      NO, SKIP GET
         TM    EYESTOR,X'40'  RESIDENT EYEBALL CHARACTERS ?
         BNZ   IBALGETI      NO; READ THIS BLOCK IN
         L     R5,0(,R3)     GET THE RELATIVE BLOCK NUMBER
         MH    R5,=Y(&EYEBLK)  CONVERT TO OFFSET
         A     R5,EYESTOR    GET STORAGE ADDRESS OF THE BLOCK
         CLI   0(R5),0       WAS IT READ FROM DISK ?
         BNE   IBALSGET      YES, USE IT; ELSE READ IT ONCE
IBALGETI MVI   IBALDECB,0    CLEAR
         LA    R3,1(,R3)     POINT TO LOW THREE BYTES
         READ  IBALDECB,DI,EYEBALL,(R5),'S',0,(R3)   READ CHAR. BLOCK
         BCTR  R3,0          POINT TO LIST ENTRY AGAIN
         WAIT  ECB=IBALDECB  WAIT FOR I/O
IBALSGET ST    R5,0(,R3)     SAVE ACTUAL BLOCK ADDRESS
         LA    R3,4(,R3)     NEXT BLOCK ADDR.
         LA    R2,&EYEBLK.(,R2) NEXT INPUT ADDRESS
         BCT   R7,IBALGET    GET NEXT CHARACTER BLOCK
         SPACE 1
         L     R1,EYEBUF     POINT TO EYEBALL OUTPUT BUFFER
         LA    R1,L'INREC+IHALF/2(,R1) OFFSET FROM START OF RECORD
         LA    R0,&EYECNT    LOOP FOR ALL EYEBALL CHARACTERS
         LA    R2,DBLTTR     POINT TO STORAGE ADDRESS OF FIRST ONE
IBALCHLP L     R15,0(,R2)    LOAD INPUT CHARACTER ADDRESS
         LR    R14,R1        START OF CHARACTER OUTPUT POSITION
         LA    R3,&EYEHIT    NUMBER OF LINES
IBALLNLP MVC   0(&EYEWIT,R14),0(R15)  MOVE ONE CHARACTER'S LINE
         LA    R14,L'INREC(,R14)      SET NEXT OUTPUT LINE
         LA    R15,&EYEWIT.(,R15)     AND NEXT INPUT LINE
         BCT   R3,IBALLNLP   REPEAT FOR ALL LINES IN CHARACTER
         LA    R2,4(,R2)     POINT TO NEXT CHARACTER'S ADDRESS
         LA    R1,IHALF+&EYEWIT.(,R1)  POINT TO NEXT CHARACTER'S O/P
         BCT   R0,IBALCHLP   REPEAT FOR ALL CHARACTERS
         L     R2,EYEBUF
         LA    R3,&WKBPP     BLOCKS PER PAGE
         TM    INDTTR,INCORE   IS THIS AN IN-CORE BLOCK ?
         BZ    IBALPUP       NO, PUT TO DISK
         L     R1,INDTTR     GET TO ADDR.
         LR    R15,R2        GET FROM
         BAL   R9,BLKMOVE    MOVE IN CORE
         B     IBALINC       SKIP DISK I/O
IBALPUP  AP    CNIO,P1       UP DISK I/O COUNT
IBALPUT  MVI   IBALWECB,0    CLEAR
         WRITE IBALWECB,DI,WORK,(R2),'S',0,RELBLK  WRITE A BLOCK
         WAIT  ECB=IBALWECB  WAIT FOR I/O
         BAL   R9,BLKUP      GET NEXT BLOCK ADDR.
         LA    R15,&WKLPB    GET NUMBER OF LINES IN THIS BLOCK
IBALPUTZ CLI   0(R2),0       EMPTY RECORD ?
         BE    IBALINC       YES; TERMINATE WRITE
         LA    R2,L'INREC(,R2)  ELSE GO TO NEXT RECORD
         BCT   R15,IBALPUTZ
         BCT   R3,IBALPUT    PUT IT OUT
         SPACE
IBALINC  LA    R4,&EYECNT.(,R4)  NEXT TITLE CHARACTERS
         OI    NXFG,XUSE     JUST IN CASE - SET PAGE USED
         A     R6,INDEXAD+4  NEXT TTR POINTER
         BCT   R8,IBALLOOP   DO NEXT TWO CHARACTERS
         SPACE
         MVC   PREVTIT,TITLE
         LM    R14,R12,SAVE2   RESTORE REGS
         BR    R14           RETURN
         DROP  R6
         EJECT
*        THIS SUBROUTINE CHECKS FOR THE PRESENCE OF A SEPARATOR
*              PAGE IN THE INPUT BUFFER. IF SO, THE PAGE(S) ARE SKIPPED
*              AND THE SEP. INFO USED FOR FICHE TITLES
*
SEPAR    STM   R14,R12,SAVE2  SAVE REGS
         NI    PARMFG,255-PRTOP-PREFMT  RESET FLAG               86111
         L     R1,WKBUF
         LA    R2,20         SCAN FIRST 20 LINES
SEPANULL CLI   0(R1),0       IS THIS A NON-EMPTY LINE ?
         BE    SEPANOT       NO, CAN'T BE SEPARATOR
         LA    R1,L'INREC(,R1)   TRY NEXT ONE
         BCT   R2,SEPANULL   TRY AGAIN
         LA    R2,10         SCAN TEN LINES
SEPAFIND CLI   0(R1),0       IS THIS AN EMPTY OR UNUSED SLOT ?
         BE    SEPANOT       YES, CAN'T BE SEPARATOR
         CLC   SEPAREC,7(R1)   IS THIS AN N.I.S. STANDARD SEPARATOR ?
         BE    SEPAGET       YES, GET OTHER STUFF
         CLC   =C' //',44(R1)  IS IT ASMANY DATE FIELD SEPARATOR ?
         BE    SEPASM        MAYBE, GO TO CHECK FURTHER
         LA    R1,L'INREC(,R1)
         BCT   R2,SEPAFIND
SEPANOT  L     R14,SAVE2     RESTORE RETURN REG
         LA    R14,4(,R14)   RETURN SEPARATOR NOT FOUND
         CLI   NEXTIT,0
         BNE   SEPAEXIT
         MVC   NEXTIT,TITLE
SEPAEXIT LM    R15,R12,SAVE2+4
         BR    R14           RETURN
         SPACE 2
SEPASM   CLI   PARMLEN,X'FF'    USER REQUESTED ANY ASMANY PAGES ?
         BE    SEPANOT       NO, DON'T CHECK FURTHER
         CLC   =C' //',86(R1)   IS SECOND SLASH THERE ?
         BNE   SEPANOT       NO, IGNORE IT
         LR    R3,R1         SAVE LINE ADDRESS
         LA    R2,8          CHECK FOR 8 MORE SLIDING LEFT
SEPASM1  LA    R3,L'INREC-1(,R3)   BUMP ONE LINE LESS ONE BYTE
         CLC   =C' //',44(R3)   STILL SEP ?
         BNE   SEPANOT       NO, IGNORE
         CLC   =C' //',86(R3)   SECOND ONE ?
         BNE   SEPANOT       BOO
         BCT   R2,SEPASM1    TRY NEXT LINE
         SH    R1,=Y(3*L'INREC+7)   POSITION FOR COMMON CODE
         CLI   PARM,C'%'     ACCEPT ANY ASMANY SEP ?
         BE    SEPAGET       YES, GO TO COMMON
         OI    PARMFG,PRNAME  SET FOR NAME TEST REQUIRED         86111
         SPACE 2
SEPAGET  ST    R1,SAVEA      SAVE ADDRESS OF SPECIAL LINE
         LA    R3,2
         LA    R4,SEPARM     GET TWO OUTPUT FIELDS
         SH    R1,=Y(21*L'INREC)
SEPAGAIN LA    R2,17
         MVI   SEPREC,C' '
         MVC   SEPREC+1(L'INREC-1),SEPREC    CLEAR
SEPAGL   OC    SEPREC,0(R1)  OR IN
         LA    R1,L'INREC(,R1)
         BCT   R2,SEPAGL
         XC    DB,DB
         LA    R1,DB
         LA    R2,SEPREC+20
         LA    R15,8
SEPACHA  LA    R14,6
SEPACHB  OC    0(1,R1),0(R2)
         LA    R2,1(,R2)
         BCT   R14,SEPACHB
         LA    R1,1(,R1)
         LA    R2,8(,R2)
         BCT   R15,SEPACHA
         MVC   0(8,R4),DB
         MVI   8(R4),C' '
         LA    R15,7
SEPALEFT CLI   0(R4),C' '
         BNE   SEPAJUST
         MVC   0(8,R4),1(R4)
         BCT   R15,SEPALEFT
SEPAJUST LA    R4,SEPARM2-SEPARM(,R4)  GET NEXT FIELD
         L     R1,SAVEA      GET ADDRESS OF SPECIAL LINE AGAIN
         LA    R1,L'INREC(,R1)   START WITH NEXT LINE AFTER
         BCT   R3,SEPAGAIN
         TM    PARMFG,PRNAME  IS COMPARE NECESSARY ?             86111
         BZ    SEPSET        NO, USE IT AS IS
         LH    R2,PARMLEN    GET LENGTH - 1 FOR EX
         CLI   PARMLEN,X'FF' NEGATIVE ?
         BE    SEPSET        YES, SKIP TEST
         EX    R2,SEPCLC     COMPARE ?
         BNE   SEPANOT       NOT EQUAL - DON'T SEPARATE
SEPSET   MVC   NEXTIT+(TITNAM-TITLE)(8),SEPARM   MOVE NAME
         MVC   NEXTIT+(TITDAT-TITLE)(8),SEPARM2   MOVE ASSEMBLY DATE
         L     R14,SAVE2     RESTORE RETURN ADDRESS
         MVI   NEXTIT+(TITB1-TITLE),C' '
         MVI   NEXTIT+(TITB2-TITLE),C' '
         OI    IPFG,FEJE     SKIP INPUT TILL PAGE EJECT
         MVC   1(L'INREC-1,R1),0(R1)   JUST IN CASE, WIPE IT OUT
         CLI   NEXTIT,0      INITIALIZED ?
         BNE   SEPAEXIT
         MVC   NEXTIT(L'TITLE),TITLE
         MVC   TITLE(L'NEXTIT),NEXTIT
         B     SEPAEXIT
         EJECT
*        DATA AND STUFF
&TEMP    SETA  (&LINESIZ+2)*(&LINES+1)
OUTAPE   DCB   DDNAME=SYSUT2,MACRF=W,DSORG=PS,RECFM=U,                 *
               DEVD=TA,BLKSIZE=&TEMP
EYEBALL  DCB   DDNAME=SYSUT3,DSORG=DA,MACRF=RI,OPTCD=R,                *
               RECFM=F,BLKSIZE=&EYEBLK
WORKL    DCB   DDNAME=SYSUT4,MACRF=(WL),DSORG=PS,                      *
               RECFM=F,LRECL=&WKBLKSI,BLKSIZE=&WKBLKSI
WORK     DCB   DDNAME=SYSUT4P,DSORG=DA,MACRF=(RI,WI),OPTCD=R,          *
               RECFM=F,BLKSIZE=&WKBLKSI
         SPACE
         SERVDEFS ,          SERVICE ROUTINES                   GP12043
SYSPRINT PRTWORK SYSPRINT,SYSTERM,TITLE=5                        86111
DB       DC    D'0'          DOUBLE WORD WORK AREA
DBLTTR   DC    (&EYECNT)F'0'
EYESTOR  DC    X'C0',AL3(0)  RESIDENT EYEBALL FLAGS/ADDRESS
SAVE2    DC    18F'0'        SECONDARY SAVE AREA
SAVEA    DC    A(0)          SAVE POINTER
WKBUF    DC    A(WORKREC)    ADDRESS OF WORK BLOCK
WKADD    DC    A(WORKREC,WORKREN)   WORK BLOCK POINTERS
PUTWCNT  DC    H'0'          CURRENT PAGE LINE COUNT
PUTWMAX  DC    Y(&LINES)     MAX LINES / PAGE
OUTBUF   DC    A(OUTREC)     POINTER TO OUTPUT BUFFER
OUTADD   DC    A(OUTREC,OUTRECN)   WORK PINTERS FOR OUTPUT BUFFER
INDEXAD  DC    A(TTRTAB,L'TTRTAB,TTRTAN-L'TTRTAB) INDEX TABLE POINTERS
INDEXBUF DC    A(TTRTAB)     START OF INDEX BUFFER
INDEXDAT DC    A(TTRDAT)     START OF DATA PORTION OF FICHE
EYEBUF   DC    A(EYEWORK)
BLKNO    DC    0A(0),X'0'    REL. BLOCK NUMBER - F
RELBLK   DC    XL3'0'        REL. BLOCK - 3X
IHALF    EQU   (136-(&EYECNT*&EYEWIT))/&EYECNT
         SPACE 2
CODEM    DC    X'0911011989E1C9'  MACHINE CONTROL CHARACTERS ACCEPTED
CODESAV  DC    X'E1'         MCC FOR NEXT I/P RECORD - SKIP 12 INIT.
CODEA    DC    C' 0+-1CC '    EQUIVALENT ASA CODES, + ONE MORE FOR DEFA
CODESZ   DC    AL1(1,2,0,3,65,56,56,1)  EQUIVALENT LINES USED
         SPACE
SEPCLC   CLC   PARM(0),SEPARM  COMPARE ASSEMBLY NAME FIELD
PARMLEN  DC    H'0'          PARM LENGTH FIELD - 1 SAVE AREA
PARM     DC    CL8' '        PARM VALUE
PARMFG   DC    X'0'          PROCESSING FLAG
PRTOP    EQU   X'80'         SYSPRINT FILE ALREADY OPEN          86111
PREFMT   EQU   X'40'         PREFORMATTED BDAM FILE IN USE       86111
PRNAME   EQU   X'01'         NAME COMAPRE REQUIRED               86111
SEPARM   DC    CL8' ',C' '   WORK FIELD FOR PARM ANALYSIS
SEPARM2  DC    CL8' ',C' '   WORK FIELD FOR PARM ANALYSIS
         SPACE
IPFG     DC    AL1(0)  (FEJE)  INPUT CONTROL BYTE                86142
FEOF     EQU   X'80'         EOF READ
FONE     EQU   X'40'         FIRST TIME BIT
FDAT     EQU   X'20'         DATA ON FICHE SWITCH
FEJE     EQU   8             SKIP INPUT TILL PAGE EJECT CONTROL
FASA     EQU   4             INPUT WITH ASA CONTROL CHARS
FMCC     EQU   2             INPUT WITH MACHINE CONTROL CHARACTERS
FINIT    EQU   1               PROCESSING INITIALIZED            86118
PTOTAL   DC    PL3'0'        TOTAL FICHE PAGES
PPAGE    DC    PL2'0'        PAGE OF FICHE
PFRAME   DC    PL3'0'        PAGES ON FICHE
P1       DC    P'1'          INCREMENTER
         SPACE 2
EYEINDEX DC    C'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ/-.#$@'
ENDREC   DC    0CL20' ',CL19'A',X'E0'  END BLOCK / FRAME ADVANCE
INREC    DC    CL&LINESIZ' '      PRIMARY INPUT RECORD
SEPREC   DC    CL&LINESIZ' '
SEPAREC  DC    C'OUTPUT CLASS '
TOTMSG   DC    C'FICHE PAGES :'
PREVTIT  DC    XL(LENTIT)'0'
NEXTIT   DC    0XL(LENTIT-2)'0',X'00',CL(LENTIT-3)' '
HEADER   VCON  '#      MICROFICHE CONVERSION LOG'                86118
VTITLE   DS    0H
SUBHEAD  DC    Y(SUBHEND-*,0)  DOUBLES AS TITLE AND PRINT RECORD
TITCC    DC    C' '          SUB-TITLE CONTROL, LATER BLANK      86118
TITCL    EQU   &EYECNT*&ACROSS-19
TITLE    DC    CL(TITCL)'TITLE'
         ORG   *-1
TITB1    DC    C' '
TITDAT   DC    CL8' DATED:'    DATE OF ORIGINAL RUN
TITB2    DC    C' '
TITNAM   DC    CL8'PROGRAM'  JOB NAME OF RUN
TITPAG   DC    C'PA'         PAGE NUMBER OF FICHE
TITB3    DC    CL3'GE'       TITLE - PAGE DC
TITFRAM  DC    CL5'FRAME'    DATA FRAME WITHIN FICHE
         DC    C'S'          PLURAL
TITBLEN  EQU   *-TITLE
         DC    CL3' '
SUBHEND  EQU   *
         SPACE
VOPTHEAD VCON  '-  RUN OPTIONS IN EFFECT :'
VOPTS VCON '0  &LINES LINES PER PAGE; &ACROSS COLUMNS, AND &DOWN ROWS P*
               ER FICHE'                                         86118
VSPACE   VCON  '0 '
&TEMP    SETA  &WKBLKSI*&WKBPP
GMREQ    DC    A(&TEMP,(&ACROSS*&DOWN+1)*&TEMP)  MAIN STORAGE
GMADR    DC    2A(0)         MAIN STORAGE OBTAINED
CNCORE   DC    PL2'0'        NO. OF IN-CORE BLOCKS
CNIO     DC    PL5'0'        NUMBER OF DISK BLOCK I/OS
CNINC    DC    PL5'0'        NUMBER OF IN-CORE I/OS
VSTAT    VCON  '0      ',END=VSTATE                              86118
NCCORE   DC    X'40202120',C'  OF'
NCBMAX   DC    X'40202120',C' WORK BLOCKS KEPT IN CORE;'
NCIO     DC    X'40202020202020202120',C' DISK I/O''S;'
NCINC    DC    X'40202020202020202120',C' CORE I/O''S'
         VCON  ,                                                 86118
         SPACE 2
         DS    0F            BOUNDARY ALIGNMENT
TTRTAB   DS    0XL8          LENGTH OF TTR TAB ENTRY
         TTRMAC
TTRTAN   DC    A(0,*-4)      END OF TTR TABLE
         SPACE 2
TRTAB    TRTAB CODE=TN,OPT=SVC
         SPACE 2
         LTORG
         SPACE 2
OUTREC   DC    (&LINES+1)CL(&LINESIZ+2)' '    FINAL OUTPUT BLOCK
OUTRECN  EQU   *
         ORG   OUTREC+&EYEBLK*&EYECNT-1
         DC    X'0'            FORCE EYE WORK
         ORG
EYEWORK  DC    (&EYEHIT+2)CL(&LINESIZ)' '
         DC    X'0'          WRITE STOPPER
WORKREC  DC    (&LINES)CL(&LINESIZ)' '  WORK RECORD
WORKREN  DC    X'0'          FOR OVERRUN
         SPACE 2
INDEX    DSECT
INDTTR   DS    F             TTR0 OF FIRST RECORD OF EACH PAGE
INCORE   EQU   X'80'         IF ON - BLOCK KEPT IN-CORE
NXFG     DS    0X            INDEX CONTROL FLAG
XPAG     EQU   X'80'         FICHE ADVANCE IF ON WITH XEND
XEND     EQU   8             LAST PAGE IN COLUMN
XUSE     EQU   1             PAGE NON-EMPTY IF ON
XTIT     EQU   2
XUST     EQU   XTIT+XUSE
INDPTR   DS    A             A OF INDEX FOR SEQUENTIAL I/O
         SPACE 2
         DCBD  DEVD=DA,DSORG=PS                                  86111
         END
