DUSER    TITLE 'DUSER COMMAND'
*          DATA SET DUSER      AT LEVEL 005 AS OF 12/30/75
*   FROM CBT 249, FILE300                                       GP12338
         MACRO
&NAME    CONVERT &EVENREG,&DIGITS,&DBLWD,&TYPE=DEC
.*
.*  THIS MACRO WILL PERFORM HEX TO HEX CHARACTER OR DECIMAL
.*  CHARACTER CONVERSIONS.  IT USES AN EVEN-ODD PAIR OF REGS
.*  AND A DOUBLE WORD OF STORAGE TO DO ITS CALCULATIONS.
.*
         GBLC  &CONV
         GBLC  &P
         LCLA  &N
         LCLA  &ODDREG
         LCLA  &LCLDIGS
&N       SETA  0
&ODDREG  SETA  &EVENREG+1
&LCLDIGS SETA  &DIGITS
         AIF   (T'&EVENREG NE 'N').ERR1
         AIF   (T'&DIGITS NE 'N').ERR2
         AIF   ('&NAME' EQ '').NONAME
&NAME    EQU   *
.NONAME  ANOP  ,
         AIF   ('&TYPE' NE 'DEC').NODEC
         AIF   (&DIGITS GT 5).ERR4
         CVD   &EVENREG,&DBLWD
         UNPK  &DBLWD.(&DIGITS.),&DBLWD+5(3)
         OI    &DBLWD+&DIGITS-1,X'F0'
         MEXIT
.NODEC   ANOP  ,
         AIF   (&DIGITS GT 4).ERR3
&CONV    SETC  'YES'   SO CPDATA KNOWS A HEX CONVERT WAS ISSUED
         AIF   (&LCLDIGS EQ 0).DONE
         SRDL  &EVENREG,4
         SRL   &ODDREG,4
&LCLDIGS SETA  &LCLDIGS-1
         AGOB  .NODEC
.DONE    ANOP  ,
         ST    &ODDREG,&DBLWD
         TR    &DBLWD.(&DIGITS.),&P.CHARS
         MEXIT
.ERR1    ANOP  ,
         MNOTE 8,'FIRST OPERAND NOT NUMERIC'
         MEXIT
.ERR2    ANOP  ,
         MNOTE 8,'SECOND OPERAND NOT NUMERIC'
         MEXIT
.ERR3    ANOP  ,
         MNOTE 8,'SECOND OPERAND > 4 ON HEX CONVERT'
         MEXIT
.ERR4    ANOP  ,
         MNOTE 8,'SECOND OPERAND > 5 ON DEC CONVERT'
         MEND
         MACRO
         CPDATA &LIST=YES
         GBLC  &GIOPL
         GBLC  &DAIRFL
         GBLC  &GPCL
         GBLC  &GDYN
         GBLC  &P
         GBLC  &GNRLF
         GBLC  &CONV
         PUSH  PRINT
         PRINT GEN
         AIF   ('&CONV' EQ '').NOCONV
&P.CHARS DC    C'0123456789ABCDEF'
.NOCONV  ANOP  ,
         AIF   ('&GPCL' EQ 'NONE').NOPCLDC
&P.PCLAD DC    A(&GPCL)
.NOPCLDC ANOP  ,
&P.DATA  DSECT ,              DYNAMIC STORAGE AREA
&P.SAVE  DS    18F            SAVE AREA
&P.ECB   DS    F              COMMAND PROCESSOR ECB
         AIF   ('&LIST' EQ 'YES').LST1
         PRINT NOGEN
.LST1    ANOP  ,
         IKJCPPL
&P.DATA  DSECT ,              RESUME ORIGINAL DSECT
         AIF   ('&GIOPL' EQ 'NO').NOIOPL
         IKJIOPL
&P.DATA  DSECT ,              RESUME ORIGINAL DSECT
         PRINT GEN
&P.IOPL  DS    4A             INPUT/OUTPUT PARAM LIST
.NOIOPL  ANOP  ,
         AIF   ('&GPCL' EQ 'NONE').NOPCL
         AIF   ('&LIST' EQ 'NO').NLST2
         PRINT GEN
         AGO   .LST2
.NLST2   ANOP  ,
         PRINT NOGEN
.LST2    ANOP  ,
         IKJPPL
&P.DATA  DSECT ,              RESUME ORIGINAL DSECT
         PRINT GEN
&P.PPL   DS    7A             PARSE PARAM LIST
&P.ANS   DS    F              POINTER TO PDL (ANSWER PLACE)
.NOPCL   ANOP  ,
         AIF   ('&GDYN' EQ 'NO').NODYN
         AIF   ('&LIST' EQ 'NO').NLST3
         PRINT GEN
         AGO   .LST3
.NLST3   ANOP  ,
         PRINT NOGEN
.LST3    ANOP  ,
         IEFZB4D0
         IEFZB4D2
&P.DATA  DSECT ,              RESUME ORIGINAL DSECT
         PRINT GEN
&P.RBPTR DS    F              DYN ALLOC RB POINTER
&P.RB    DS    5F             DYN ALLOC REQUEST BLOCK
.NODYN   ANOP  ,
         AIF   ('&GNRLF' EQ '').NOGNRLF
         AIF   ('&LIST' EQ 'NO').NLST4
         PRINT GEN
         AGO   .LST4
.NLST4   ANOP  ,
         PRINT NOGEN
.LST4    ANOP  ,
         IKJEFFGF GFDSECT=YES
&P.DATA  DSECT ,              RESUME ORIGINAL DSECT
         PRINT GEN
&P.GNRLF DS    F              PTR TO GNRLFAIL CONTROL BLOCK
         DS    3F             GNRLFAIL CONTROL BLOCK
         DS    H
         DS    2X
         DS    2F
         DS    2H
         DS    4F
.NOGNRLF ANOP  ,
         AIF   ('&DAIRFL' EQ '').NODF
         AIF   ('&LIST' EQ 'NO').NLST5
         PRINT GEN
         AGO   .LST5
.NLST5   ANOP  ,
         PRINT NOGEN
.LST5    ANOP  ,
         IKJEFFDF DFDSECT=YES
&P.DATA  DSECT ,              RESUME ORIGINAL DSECT
         PRINT GEN
&P.DFPL  DS    5A             DAIRFAIL PARAMETER LIST
&P.DFRC  DS    F              SERVICE ROUTINE RETURN CODE
&P.DFID  DS    H              DAIRFAIL ID
&P.FO2PT DS    F              DAIRFAIL IKJEFF02 POINTER
.NODF    ANOP  ,
         MNOTE *,'       CVT    DSECT=YES,LIST=NO'
         PRINT NOGEN
         CVT   DSECT=YES,LIST=NO
         POP   PRINT
&P.DATA  DSECT ,              RESUME ORIGINAL DSECT
         MEND
         MACRO
         CPEND
         GBLC  &P
&P.LEN   EQU   *-&P.DATA
         MEND
         MACRO
&NAME    CPINIT &IOPL=NO,&PCL=NONE,&DYN=NO,&PREFIX=IPG
         GBLC  &GIOPL
         GBLC  &GPCL
         GBLC  &GDYN
         GBLC  &P
         LCLA  &A
.*   CHECK THE VALIDITY OF THE PREFIX (MUST BE <= 3 CHARS)
         AIF   (K'&PREFIX LE 3).PFXOK
         MNOTE 8,'PREFIX > 3 CHARS, SHORTENED'
&P       SETC  '&PREFIX'(1,3)
         AGO   .PFXEND
.PFXOK   ANOP  ,
&P       SETC  '&PREFIX'
.PFXEND  ANOP  ,
&GIOPL   SETC  '&IOPL'
&GPCL    SETC  '&PCL'
&GDYN    SETC  '&DYN'
&NAME    CSECT
.*   GENERATE REG EQUATES
&A       SETA  0
.LOOP    ANOP  ,
R&A      EQU   &A
&A       SETA  &A+1
         AIF   (&A LT 16).LOOP
.*   GENERATE THE INITIALIZATION CODE
         MNOTE *,'       SAVE  (14,12),,*'
         SAVE  (14,12),,*
         LR    R10,R15        INITIALIZE BASE REG
         USING &NAME,R10      ESTABLISH ADDRESSIBILITY
         MNOTE *,'       GETMAIN R,LV=&P.LEN,SP=0'
         GETMAIN R,LV=&P.LEN,SP=0
         ST    R13,4(R1)     SAVE THE BACK CHAIN
         ST    R1,8(R13)
         LR    R13,R1         R13 => DYNAMIC STORAGE
         USING &P.DATA,R13
******************************************
*  INITIALIZE THE CONTROL BLOCKS         *
******************************************
         L     R1,4(R13)
         L     R1,24(R1)      R1 => CPPL
         USING CPPL,R1
         AIF   ('&IOPL' EQ 'NO').NOIOPL
*  FILL IN THE UPT, ECT, AND ECB FIELDS OF THE IOPL
.*   AND LEAVE THE POINTER TO THE PARM BLOCK EMPTY
         MVC   &P.IOPL+(IOPLUPT-IOPL)(4),CPPLUPT
         MVC   &P.IOPL+(IOPLECT-IOPL)(4),CPPLECT
         XC    &P.ECB(4),&P.ECB   ZERO THE ECB
         LA    R2,&P.ECB
         ST    R2,&P.IOPL+(IOPLECB-IOPL)
.NOIOPL  ANOP  ,
         AIF   ('&PCL' EQ 'NONE').NOPCL
*  FILL IN ALL THE FIELDS OF THE PARSE PARAMETER LIST (PPL)
         MVC   &P.PPL+(PPLUPT-PPL)(4),CPPLUPT
         MVC   &P.PPL+(PPLECT-PPL)(4),CPPLECT
         LA    R2,&P.ECB
         ST    R2,&P.PPL+(PPLECB-PPL)
         L     R2,&P.PCLAD
         ST    R2,&P.PPL+(PPLPCL-PPL)
         LA    R2,&P.ANS
         ST    R2,&P.PPL+(PPLANS-PPL)
         MVC   &P.PPL+(PPLCBUF-PPL),CPPLCBUF
         XC    &P.PPL+(PPLUWA-PPL),&P.PPL+(PPLUWA-PPL)
.NOPCL   ANOP  ,
         AIF   ('&DYN' EQ 'NO').NODYN
*  FILL IN THE DYNAMIC ALLOCATION REQUEST BLOCK POINTER
         LA    R2,&P.RB
         ST    R2,&P.RBPTR
         OI    &P.RBPTR,S99RBPND
.NODYN   ANOP  ,
         DROP  R1
         EJECT
         MEND
         MACRO
&NAME    GNRLFAIL &RET=,&TYPE=,&GFCB=,&CPPL=,&KEYN08=NO
.*
.*  THIS MACRO IS USED TO ISSUE ERROR MESSAGES FOR CERTAIN
.*  FAILURES.  IT IS ASSUMED THAT ON ENTRY R15 CONTAINS
.*  EITHER THE ERROR RETURN CODE OR ABEND CODE. THIS ROUTINE
.*  WILL DESTROY R1.
.*
         GBLC  &P
         GBLC  &GNRLF
         LCLC  &CALLID
         LCLC  &GNRLFCB
         LCLC  &LCLLBL
         LCLC  &GFBITS
         AIF   ('&TYPE' EQ '').ERR1   MUST SUPPLY TYPE
         AIF   ('&RET' EQ '').SYSLBL
&LCLLBL  SETC  '&RET'
         AGO   .CONT1
.SYSLBL  ANOP  ,
&LCLLBL  SETC  '&P'.'&SYSNDX'
.CONT1   ANOP  ,
         AIF   ('&GFCB' EQ '').NOGFCB
&GNRLFCB SETC  '&GFCB'
         AGO   .CONT2
.NOGFCB  ANOP  ,
&GNRLFCB SETC  '&P'.'GNRLF'
&GNRLF   SETC  'YES'  SO CPDATA ALLOCATES CONTROL BLOCKS
.CONT2   ANOP  ,
.*  DETERMINE THE CORRECT GFBITS SETTING BASED UPON THE
.*  GNRLFAIL TYPE REQUEST AND THE PROTECT KEY
&GFBITS  SETC  '0'
         AIF   ('&TYPE' NE 'SSREQ' OR '&KEYN08' NE 'YES').CONT4
&GFBITS  SETC  'GFKEYN08+GFSUBSYS'
         AGO   .CONT6
.CONT4   ANOP  ,
         AIF   ('&TYPE' NE 'SSREQ').CONT5
&GFBITS  SETC  'GFSUBSYS'
         AGO   .CONT6
.CONT5   ANOP  ,
         AIF   ('&KEYN08' NE 'YES').CONT6
&GFBITS  SETC  'GFKEYN08'
.CONT6   ANOP  ,
         AIF   ('&NAME' EQ '').NONAME
&NAME    EQU   *
.NONAME  ANOP  ,
         AIF   ('&TYPE' NE 'PARSE').NOPARS
         LA    R1,4           IF PARSE ERROR CODE IS 4 OR 20,
         CR    R15,R1         ERROR MESSAGE HAS BEEN ISSUED
         BE    &LCLLBL
         LA    R1,20
         CR    R15,R1
         BE    &LCLLBL
.NOPARS  ANOP  ,
         LA    R1,&GNRLFCB+4   R1 => GNRLFAIL CONTROL BLOCK
         ST    R1,&GNRLFCB
         USING GFCBPTR,R1
         AIF   ('&TYPE' EQ 'SSREQ').SSREQT    DON'T ZERO PTR IF SSREQ
         XC    GFCBPTR,GFCBPTR  ZERO THE OPTIONAL POINTERS
         AGO   .CONT3
.SSREQT  ANOP  ,
         ST    R0,GFCBPTR     R0 => SSOB
.CONT3   ANOP  ,
         XC    GF02PTR,GF02PTR   ZERO PTR TO TSO MESSAGE ISSUER
         ST    R15,GFRCODE   STORE THE RETURN OR ABEND CODE
         AIF   ('&TYPE' NE 'PUTLINE').NOPUTL
&CALLID  SETC  'GFPUTL'
         AGO   .LINK
.NOPUTL  ANOP  ,
         AIF   ('&TYPE' NE 'PARSE').NOPRS
&CALLID  SETC  'GFPARSE'
         AGO   .LINK
.NOPRS   ANOP  ,
         AIF   ('&TYPE' NE 'ABEND').NOABND
&CALLID  SETC  'GFABEND'
         AGO   .LINK
.NOABND  ANOP  ,
         AIF    ('&TYPE' NE 'SSREQ').ERR3
&CALLID  SETC  'GFSSREQ'
.LINK    ANOP  ,
         LA    R15,&CALLID   SET THE FALURE CODE INTO
         STH   R15,GFCALLID   THE CONTROL BLOCK
         MVI   GFBITS,&GFBITS
         XC    GFRESV1,GFRESV1
         AIF   ('&CPPL' NE '').CPPL
         L     R15,4(R13)
         L     R15,24(R15)    R15 => CPPL
         AGO   .NOCPPL
.CPPL    ANOP  ,
         L     R15,&CPPL      R15 => CPPL
.NOCPPL  ANOP  ,
         ST    R15,GFCPPLP
         XC    GFDSNLEN,GFDSNLEN
         XC    GFPGMNL,GFPGMNL     ZERO THE PROGRAM NAME LENGTH
         XC    GFDSNP,GFDSNP
         XC    GFPGMNP,GFPGMNP
         XC    GFRESV2,GFRESV2
         XC    GFRESV3,GFRESV3
         DROP  R1
         LA    R1,&GNRLFCB
         LINK  EP=IKJEFF19
         AIF   ('&RET' EQ '').GENLBL
         B     &LCLLBL           GO TO ERROR LABEL
         AGO   .EXIT
.GENLBL  ANOP  ,
         AIF   ('&TYPE' NE 'PARSE').EXIT
&LCLLBL  DS    0H
.EXIT    ANOP  ,
         MEXIT
.ERR1    ANOP  ,
         MNOTE 8,'TYPE PARAMETER MISSING ON GNRLFAIL'
         DC    F'0'
         MEXIT
.ERR3    ANOP  ,
         MNOTE 8,'INVALID TYPE ON GNRLFAIL'
         DC    F'0'
         MEXIT
         MEND
DUSER    CPINIT IOPL=YES,DYN=NO,PCL=DUSRSYN
*
*  PARSE THE COMMAND
*
         CALLTSSR EP=IKJPARS,MF=(E,IPGPPL)
         LTR   R15,R15        WAS PARSE SUCCESSFUL?
         BZ    PARSOK         YES,...
         GNRLFAIL TYPE=PARSE
         L     R13,4(R13)
         RETURN (14,12),RC=12   RETURN INDICATING AN ERROR
PARSOK   EQU   *
         EJECT
*
*   INITIALIZE THE STARTING VARIABLES
*
         XR    R7,R7
         ST    R7,NUMUSRS     INIT CURRENT NUMBER USERS
         ST    R7,ENTRYNO     INIT # ENTRIES IN CURR. OUT LINE
         LA    R7,1
         ST    R7,LINENO      INIT CURRENT OUTPUT LINE NO.
         LA    R7,10          INIT # ENTRIES IN NOT-ON LINE TO 10
         ST    R7,NONOTON     TO FORCE SKIP TO NEXT LINE FIRST
         LA    R7,IPGPPL
         L     R7,(PPLANS-PPL)(R7)   R7 => ANSWER PLACE
         L     R2,0(R7)       R2 => PDL
         ST    R2,PDLPTR
         USING IPGPDL,R2
         LA    R7,DUSRUSER
         ST    R7,USERPTR
         LA    R7,FRSTLINE
         ST    R7,LINEPTR
         LA    R7,8(R7)
         ST    R7,COLPTR
         LH    R7,LINE
         LH    R9,LINE
         STC   R9,LINESW  0=NOLINE; 1=LINE;
         AH    R7,ASID
         STH   R7,OPTIONS     SEE COMMENTS WITH OPTIONS DS
         LH    R9,ASID
         STC   R9,ASIDSW    0=NOASID; 1=ASID;
         MVI   NUMBERSW,X'00'
         CLI   NUMBER+1,X'01'   WAS NUMBER SPECIFIED?
         BNE   NONUM          NO,...
         DROP  R2
         MVI   NUMBERSW,X'FF'  TURN ON SW, ONLY GIVE # USERS ON
NONUM    EQU   *
         L     R7,USERPTR     R7 => PDE FOR USERID LIST
         L     R9,0(R7)       R9 => FIRST STRING (USERID)
         LH    R8,4(R7)       R8 = LENGTH OF STRING
         MVI   STARSW,X'00'
         C     R8,F1          LENGTH OF STRING = 1 ?
         BNE   NOSTAR         NO,...
         CLI   0(R9),C'*'     WAS '*' SPECIFIED?
         BNE   NOSTAR            NO,...
         MVI   STARSW,X'FF'   TURN THE STAR SWITCH ON
NOSTAR   EQU   *
         LA    R2,FRSTLINE    LINK FIRST TWO PUTLINE LINES TOGETHER
         ST    R2,OUTLINES
         MVC   OUTLINES+4(2),=H'25'  INIT LENGTH OF FIRST OUT LINE
         XC    OUTLINES+6(2),OUTLINES+6  INIT OFFSET
         MVI   OUTLINES+8,C' '  BLANK THE OUT LINE
         MVC   OUTLINES+9(24),OUTLINES+8
         XC    OUTLINES+LINELNTH(4),OUTLINES+LINELNTH ZERO PUTLINE LINK
         EJECT
*
*   BEGIN THE MAINSTREAM OF THE PROGRAM
*
         L     R2,16(0)       R2 => CVT
         L     R2,(CVTASVT-CVT)(R2)   R2 => ASVT
         USING ASVT,R2
         L     R3,ASVTMAXU    R3 = MAX # ASID'S
         BCTR  R3,0
         SLL   R3,2
         LA    R3,ASVTENTY(R3)   R3 => LAST ASVT ENTRY
         LA    R4,ASVTENTY    R4 => FIRST ASVT ENTRY
         DROP  R2
         LA    R2,4           INCREMENT FOR A BXLE
*
*  LOOP THRU THE ASVT SCANNING FOR APPROPRIATE USERS
*
LOOPASID ICM   R5,15,0(R4)    DOING ANYTHING ?                  GP12338
         BNP   NEXTASID        NO, ...                          GP12338
         L     R6,(ASCBCSCB-ASCB)(R5)  R6 => CSCB
         LTR   R6,R6          IF ZERO, THESE ARE SPECIAL MEMORIES
         BZ    NEXTASID     (IE. MASTER SCHEDULER AND MAIN STOR. SUP.)
         TM    (CHTRKID-CHAIN)(R6),CHINITID   IS THIS AN INITIATOR?
         BO    NEXTASID       YES,...
         TM    (CHTRKID-CHAIN)(R6),CHTSID   IS THIS A TSO USER?
         BZ    NEXTASID       NO, ...
         L     R6,NUMUSRS     ADD 1 TO THE NUMBER OF TSO USERS ON
         LA    R6,1(R6)
         ST    R6,NUMUSRS
         BAL   R14,USERLIST   IS THE USERID IN THE LIST?
         LTR   R15,R15        RC = 0 => NO;  RC = 4 => YES
         BZ    NEXTASID       NO, ... (JUST COUNT HIM AS ON)
         BAL   R14,OUTUSER    YES, PUT USER IN OUT LINE
NEXTASID EQU   *
         BXLE  R4,R2,LOOPASID  TRY THE NEXT ASID
*
*  ALL ACTIVE USERS HAVE BEEN SCANNED
*
*  NOW, IF A LIST OF USERIDS WAS SPECIFIED ON THE DUSER
*  COMMAND, LIST THE ONES WHICH WERE NOT IN THE SYSTEM.
*  (OUTUSER MARKED THE ONES WHICH WERE ON BY CHANGING THE
*  FIRST CHARACTER OF THE USERID IN THE LIST TO X'FF')
*
         TM    NUMBERSW,X'FF' WAS 'NUMBER' REQUESTED?
         BO    NTONDONE        YES, ... (NONE, SO SKIP IT)
         TM    STARSW,X'FF'   WAS '*' ENTERED OR DEFAULTED?
         BO    NTONDONE        YES,... (ALL, SO SKIP IT)
         L     R2,USERPTR     NO, R2 => PDE FOR USERID'S
LOOPNTON EQU   *
         L     R3,0(R2)       R3 => STRING (USERID)
         CLI   0(R3),X'FF'    WAS THIS USER ON?
         BE    NEXTUSER       YES, ...
         BAL   R14,NOTON      NO, PUT THE USERID IN THE OUT LINE
NEXTUSER EQU   *
         L     R2,8(R2)       R2 => NEXT PDE
         C     R2,FF000000    IS THERE A NEXT PDE?
         BNE   LOOPNTON       YES,,...
NTONDONE EQU   *
         L     R8,LINEPTR     COMPUTE LENGTH OF LAST LINE
         L     R2,COLPTR
         SR    R2,R8
         S     R2,F4          R2 = LENGTH OF THIS LINE
         BZ    EMPTYLN        IF ZERO, DELINK LAST LINE
         STH   R2,4(R8)       NO, PUT LENGTH IN LINE
         B     DOOUTPUT
EMPTYLN  EQU   *
         LA    R9,LINELNTH    R9 = LENGTH OF A LINE
         SR    R8,R9          R8 => NEXT TO LAST LINE
         XR    R9,R9
         ST    R9,0(R8)       DELINK LAST LINE
*
*  ALL INFO HAS BEEN GATHERED. PUT # USERS IN OUT LINE
*  AND ISSUE THE PUTLINE.
*
DOOUTPUT EQU   *
*
*   FIRST FORMAT TOTAL NUMBER OF USERS ON THE SYSTEM
*
         L     R8,NUMUSRS     CONVERT THE NUMBER
         CONVERT 8,4,TEMP1,TYPE=DEC  CONVERT # USERS ON TO CHAR
         LA    R4,OUTLINES+8
         MVI   SIGSW,X'00'   TURN SIGNIFICANCE SWITCH OFF
         XR    R8,R8          MOVE CHARS TO OUTLINE AND
         LA    R7,3             REMOVE LEADING ZEROES AS WE GO
SHIFT3   EQU   *
         LA    R9,TEMP1(R8)
         TM    SIGSW,X'FF'    HAVE WE SEEN A SIGNIFICANT DIGIT?
         BO    MOVEDIG        YES,...
         CLI   0(R9),C'0'
         BE    DIGIT0
         MVI   SIGSW,X'FF'
MOVEDIG  EQU   *
         MVC   0(1,R4),0(R9)
         LA    R4,1(R4)
DIGIT0   EQU   *
         LA    R8,1(R8)
         BCT   R7,SHIFT3
         MVC   0(1,R4),1(R9)  ALWAYS MOVE THE LAST DIGIT
         LA    R4,2(R4)
         MVC   0(5,R4),USERS  MOVE IN 'USERS'
         CLC   TEMP1(4),=C'0001'   IF ONLY ONE USER, MAKE MSG
         BNE   MULTIUSR       SINGULAR
         MVI   4(R4),C' '     BLANK THE 'S'
         LA    R8,1(R8)
         BCTR  R4,0
MULTIUSR EQU    *
         LA    R4,6(R4)
         MVC   0(9,R4),LOG    MOVE IN 'LOGGED ON'
*
* ISSUE THE PUTLINE
*
         PUTLINE PARM=PUTBLOK,OUTPUT=(OUTLINES,MULTLIN,DATA),          X
               MF=(E,IPGIOPL)
         LTR   R15,R15        WAS PUTLINE SUCCESSFUL?
         BZ    DUSRRET0       YES, DONE
FAILPUTL GNRLFAIL TYPE=PUTLINE
DUSRRET8 L     R13,4(R13)
         RETURN (14,12),RC=8  EXIT WITH A FAILURE
DUSRRET0 EQU   *
         L     R13,4(R13)
         RETURN               (14,12),RC=0  RETURN WITH A SUCCESS
         EJECT
USERLIST EQU   *
*
*  THIS ROUTINE IS RESPONSIBLE FOR DETERMINING IF THE USERID
*  POINTED TO IN THE ASCB PASSED IN IS IN THE LIST OF USERIDS
*  SPECIFIED IN THE DUSER COMMAND.  IF 'NUMBER' WAS SPECIFIED
*  OR A LIST WAS SPECIFIED AND THIS USERID IS NOT IN IT, R15
*  IS SET TO 0 (FALSE).  OTHERWISE, R15 IS SET TO 4.
*
*  ON ENTRY:
*    R5 => AN ASCB FOR A TSO USER
*
*  ON EXIT:
*    R15 = 0  OR  R15 = 4
*
         STM   R6,R9,USRLSTRG
         L     R6,(ASCBJBNS-ASCB)(R5)    R6 => USERID FOR THIS MEMORY
         L     R7,USERPTR     R7 => PDE FOR USERID'S
         TM    NUMBERSW,X'FF'  WAS 'NUMBER' SPECIFIED?
         BO    USER0          YES, (USER NOT IN LIST) EXIT
         TM    STARSW,X'FF'   WAS '*' SPECIFIED?
         BO    USER4          YES, (USER WAS IN LIST) EXIT
         MVI   USRFNDSW,X'00'    INDICATE USER HAS NOT BEEN FOUND
NEXTPDE  EQU   *
         L     R9,0(R7)       R9 => STRING (USERID)
         LH    R8,4(R7)       R8 = LENGTH OF STRING
         BCTR  R8,0
         EX    R8,CLCNAME     DO USERIDS MATCH?
         BNE   NEXTONE        NO, USER NOT YET IN LIST
         MVI   0(R9),X'FF'  MARK USERID AS ON SYSTEM
         MVI   USRFNDSW,X'FF'   SO WE KNOW THE USER WAS FOUND
NEXTONE  EQU   *
         L     R7,8(R7)       R7 => NEXT PDE IN LIST?
         C     R7,FF000000   IS THERE A NEXT PDE?
         BNE   NEXTPDE        THERE IS A NEXT PDE(USER GAVE A LIST)
         TM    USRFNDSW,X'FF'    WAS A USER FOUND?
         BO    USER4          YES,...
USER0    EQU   *
         LM    R6,R9,USRLSTRG
         XR    R15,R15        SET RC=0
         BR    R14            RETURN
USER4    EQU   *
         LM    R6,R9,USRLSTRG
         LA    R15,4          SET RC=4
         BR    R14
CLCNAME  CLC   0(0,R9),0(R6)
         EJECT
OUTUSER  EQU   *
*
*  THIS ROUTINE IS RESPONSIBLE FOR PUTTING THE USERID OF
*  A USER WHO IS LOGGED ON INTO THE OUTPUT LINE.  IF 'LINE'
*  WAS REQUESTED, THE LINE NUMBER IS OBTAINED AND INCLUDED.
*  IF THE ASID WAS REQUESTED, IT TOO IS INCLUDED.  ALL
*  OUTPUT LINES ARE CHAINED TOGETHER SO THAT A MULTI-LINE
*  PUTLINE CAN BE ISSUED TO PRINT OUT ALL THE DATA AT ONCE.
*
*  ON ENTRY:
*    R5 => THE USER'S ASCB
*
*  ON EXIT:
*    LINEPTR => LINE WITH ROOM FOR NEXT ENTRY
*    COLPTR  => NEXT FREE COLUMN
*    ENTRYNO =  # USERS IN CURRENT OUTPUT LINE
*    LINENO  =  CURRENT OUTPUT LINE NUMBER IN THIS ALLOCATION
*
USERIDLN EQU   7              LENGTH OF A TSO USERID
         STM   R6,R14,OUTREGS
         L     R11,(ASCBJBNS-ASCB)(R5)  R11 => USERID
         L     R8,COLPTR      R8 => NEXT FREE SPOT IN CURRENT OUT LINE
         LTR   R11,R11   POINTER TO USER ID = 0?
         BNZ   USERON         NO, THEY ARE ALREADY ON
         MVC   0(USERIDLN,R8),=C'STARTNG'    YES, USER IS STARTING
         B     USERIDIN
USERON   EQU   *
         MVC   0(USERIDLN,R8),0(R11)  MOVE USERID IN
USERIDIN EQU   *
         LA    R8,USERIDLN(R8)   POINT TO NEXT FREE COL
         CLI   ASIDSW,X'01'   WAS THE ASID REQUESTED?
         BNE   NOASID         NO,...
         LH    R6,(ASCBASID-ASCB)(R5)  R6 = ASID
         CONVERT 6,4,TEMP1,TYPE=HEX  CONVERT ASID TO CHAR
         MVI   0(R8),C','     MOVE IN COMMA
         MVC   1(4,R8),TEMP1  MOVE IN ASID
         LA    R8,5(R8)       POINT TO NEXT FREE COL
NOASID   EQU   *
         B     NOLINE            ********* HEW  RVH    *****  PATCH ***
         CLI   LINESW,X'01'   WAS LINE NO. REQUESTED?
         BNE   NOLINE         NO,...
*
*  CALL THE P&G WRITTEN SVC 241 TO GET THE SUBCHANNEL ADDRESS
*  FROM THE READ PROTECTED TSB.
*
         LA    R0,1           PUT SVC 241 FUNCTION CODE IN R0
         MVC   SVCPARM(2),(ASCBASID-ASCB)(R5)  MOVE ASID IN PARM
         LA    R1,SVCPARM
         ST    R1,SVCPRMPT    SETUP PARM PTR FOR SVC
         OI    SVCPRMPT,X'80'  PUT ON VL BIT
         LA    R1,SVCPRMPT
         SVC   241
         LTR   R15,R15    WAS THE SVC SUCCESSFUL?
         BNZ   SVCERR
         LH    R6,SVCPARM+2   R6 = LINE NO.
         CONVERT 6,3,TEMP1,TYPE=HEX  CONVERT LINE NO. TO CHAR
         MVI   0(R8),C','     MOVE IN COMMA
         MVC   1(3,R8),TEMP1  MOVE IN LINE NO.
         LA    R8,4(R8)       POINT TO NEXT FREE COL
NOLINE   EQU   *
         MVI   0(R8),C' '
         MVI   1(R8),C' '
         LA    R8,2(R8)       SPACE EACH USER ENTRY 2 SPACES APART
         ST    R8,COLPTR      UPDATE
*
*  ALL INFO HAS BEEN MOVED IN FOR THIS USER.  NOW UPDATE ALL
*  POINTERS AND COUNTERS TO PREPARE FOR THE NEXT ONE.
*
*  SEE IF WE MUST GO TO NEXT LINE
*
         L     R8,ENTRYNO
         LA    R8,1(R8)
         ST    R8,ENTRYNO     UPDATE
         LH    R7,OPTIONS   SEE IF MORE USERS WILL FIT
         SLL   R7,1           IN THE CURRENT OUTPUT LINE
         CH    R8,NOENTRY(R7) CURR# >= #POSSIBLE GIVEN THE OPTIONS?
         BL    OUTRET0        STILL MORE ROOM, WE'RE DONE
         BAL   R14,NEXTLINE   NEW LINE NEEDED, MOVE POINTERS
OUTRET0  EQU   *
         LM    R6,R14,OUTREGS
         BR    R14            EXIT
         EJECT
NEXTLINE EQU   *
*
*  THIS ROUTINE UPDATES ALL POINTERS TO GET TO THE NEXT
*  OUTPUT LINE.  IF NECESSARY, A GETMAIN IS DONE TO OBTAIN
*  MORE OUTPUT LINES.  IN THIS EVENT THE OLD LINES ARE LINKED
*  TO THE NEW ONES AND ALL POINTERS ARE SET AS THEY WERE
*  AT THE BEGINNING EXCEPT THAT A NEW DATA AREA IS USED.
*  FINALLY,  THIS ROUTINE LINKS THE LAST & NEXT OUTPUT LINES TOGETHER
*  SO THAT A MULTI-LINE PUTLINE CAN BE ISSUED.
*
*  ON EXIT:
*    LINEPTR => NEXT OUTPUT LINE
*    COLPTR  => FIRST COLUMN IN NEXT OUTPUT LINE
*    LINENO  =  LINE # OF NEXT OUT LINE IN THIS ALLOCATION
*    ENTRYNO =  0
*
         STM   R8,R14,NEXTREG        SAVE REGS
         L     R8,LINEPTR     COMPUTE LENGTH OF CURRENT OUT LINE
         L     R12,COLPTR
         SR    R12,R8
         S     R12,F4         DECREASE FOR HEADER INFO
         STH   R12,4(R8)      PUT LENGTH IN PUTLINE PARAMETER
         LR    R11,R8         SAVE PTR TO LINE
         LA    R8,LINELNTH(R8)  R8 => NEXT FREE LINE
         ST    R8,LINEPTR     UPDATE
         ST    R8,0(R11)      LINK THE PUTLINE LINES
         L     R12,LINENO
         LA    R12,1(R12)
         ST    R12,LINENO     UPDATE
         C     R12,MAXNOLN   IS NEXT LINE PAST LAST ALLOCATED?
         BNH   NOGTMAIN
         BAL   R14,GETMAIN
NOGTMAIN EQU   *
         XR    R12,R12
         ST    R12,0(R8)      MARK END OF PUTLINE LIST
         ST    R12,4(R8)      INIT LENGTH & OFFSET TO 0
         LA    R12,8(R8)
         ST    R12,COLPTR     INITIALIZE
         XR    R12,R12
         ST    R12,ENTRYNO    INITIALIZE
         LM    R8,R14,NEXTREG
         BR    R14
         EJECT
GETMAIN  EQU   *
*
*  THIS ROUTINE IS RESPONSIBLE FOR OBTAINING MORE PUTLINE
*  OUTPUT LINES IN THE EVENT THAT THE STATIC ONES BECOME
*  EXHAUSTED.
*
*  ON ENTRY:
*    R11 => LAST OUTPUT LINE
*
*  ON EXIT:
*    R8  => NEW OUTPUT LINE
*
         GETMAIN R,LV=25*LINELNTH,,SP=0
         ST    R1,0(R11)      COMPLETE PUTLINE LINK
         ST    R1,LINEPTR     INITIALIZE
         LA    R8,1
         ST    R8,LINENO      INITIALIZE
         LR    R8,R1          R8 = LINEPTR
         BR    R14            EXIT
         EJECT
NOTON    EQU   *
*
*  THIS ROUTINE IS RESPONSIBLE FOR PLACING A SPECIFICALLY
*  REQUESTED USERID WHICH IS NOT ON THE SYSTEM INTO THE
*  OUTPUT LINE AS NOT ON.
*
         STM   R6,R14,NOTONREG
         L     R8,COLPTR      R8 => NEXT FREE COLUMN
         L     R6,NONOTON  R6 = # USERID'S IN CURRENT NOT-ON LINE
         LA    R6,1(R6)
         ST    R6,NONOTON     UPDATE
         CH    R6,NTONENTY   MORE SPACE LEFT IN OUT LINE?
         BNH   NTONMOVE       STILL MORE ROOM, EXIT
         BAL   R14,NEXTLINE       GO TO NEXT LINE
         L     R8,COLPTR
         MVC   0(NOTMSGLN,R8),NTONLINE  PUT 'NOT ON -' IN LINE
         LA    R8,NOTMSGLN(R8)    R8 => NEXT FREE COL
         XR    R6,R6
         ST    R6,NONOTON     INITIALIZE
NTONMOVE EQU   *
         MVC   0(USERIDLN,R8),0(R3)  PUT USERID IN OUTPUT
         MVI   USERIDLN(R8),C' '  PUT A BLANK BETWEEN THE ID'S
         LA    R8,USERIDLN+1(R8)
         ST    R8,COLPTR      UPDATE
         LM    R6,R14,NOTONREG
         BR    R14
         EJECT
*
*  THIS BLOCK OF CODE HANDLES ISSUEING A DIAGNOSTIC IN THE
*  EVENT THAT AN UNRECOVERABLE ERROR IS DETECTED WHILE DUSER
*  IS RUNNING.  GENERALLY, THESE ERRORS ARE SEEN TO OCCUR WHEN
*  THE ENVIRONMENT CHANGES WHILE DUSER IS SCANNING A CONTROL BLOCK
*  QUEUE.
*
*  TO ISSUE THE ERROR MESSAGE THIS ROUTINE USES A MULTILINE
*  PUTLINE WITH TEXT INSERTION.
*
SPIEERR  DS    0H             A PROGRAM CHECK HAS OCCURRED
         LA    R1,SPIESEG2    ADD "SPIE" TO ERROR MSG
         B     PUTERR
SVCERR   DS    0H             AN ERROR HAS OCCURRED IN SVC 241
         LA    R1,SVCSEG2     ADD "SVC" TO ERROR MSG
PUTERR   DS    0H
         MVC   MSGOLD1(20),MDLOLD1  INIT OUTPUT LINE DESCRIPTOR 1
         ST    R1,MSGOLD1+3*4  ADD SEGMENT 2 PTR TO OLD 1
         LR    R6,R15          R6 = RETURN CODE FROM WHEREVER
         CONVERT 6,4,TEMP1,TYPE=HEX   CONVERT RC TO HEX CHARACTER
         MVC   MSG1SEG3(8),MDL1SEG3   INIT SEGMENT 3 MESSAGE FIELD
         MVC   MSG1SEG3+4(4),TEMP1   MOVE RC INTO SEGMENT 3
         LA    R1,MSG1SEG3
         ST    R1,MSGOLD1+4*4   ADD SEGMENT 3 PTR TO OLD 1
         PUTLINE PARM=PUTBLOK,OUTPUT=(MSGOLD1,MULTLVL,INFOR),          X
               MF=(E,IPGIOPL)
         LTR   R15,R15        WAS PUTLINE SUCCESSFUL?
         BZ    DUSRRET8       YES,...
         B     FAILPUTL
         EJECT
         PRINT GEN
DUSRSYN  IKJPARM DSECT=IPGPDL
USER     IKJKEYWD DEFAULT='USER'
         IKJNAME 'USER',SUBFLD=DUSRLIST
LINE     IKJKEYWD
         IKJNAME 'LINE'
ASID     IKJKEYWD
         IKJNAME 'ASID'
NUMBER   IKJKEYWD
         IKJNAME 'NUMBER'
DUSRLIST IKJSUBF
DUSRUSER IKJIDENT 'USERID',LIST,ASTERISK,MAXLNTH=7,FIRST=ALPHA,        X
               OTHER=NUMERIC,DEFAULT='*'                        GP12338
         IKJENDP
         EJECT
         EJECT
         LTORG
*
*   DEFINE THE CONSTANTS
*
         PRINT GEN
MAXNOLN  DC    F'24'  DEFAULT NO. OUTPUT LINES FOR MSG
         DS    0F
FF000000 DC    X'FF000000'
F1       DC    F'1'
F5       DC    F'5'
F4       DC    F'4'
CHARS    DC    C'0123456789ABCDEF'  TRANSLATE TABLE
NTONLINE DC    C'NOT ON - '
NOTMSGLN EQU   L'NTONLINE
USERS    DC    C'USERS'
LOG      DC    C'LOGGED ON'
*
* THE FOLLOWING DATA ITEMS ARE USED TO IMPLEMENT
* OUTPUTTING FREE FORMAT MESSAGES.
*   NOENTRY - THE NUMBER OF USERID ENTRIES WHICH
*             FIT ON ONE LINE GIVEN THE OPTIONS WHICH
*             WERE CHOSEN ON THE COMMAND.
*   NTONENTY - NUMBER OF USERID ENTRIES WHICH FIT ON
*              A "NOT-ON" LINE.
*
NOENTRY  DC    H'8'           WITH JUST USERID'S
         DC    H'5'           WITH USERID'S AND LINE OR ASID
         DC    H'3'           WITH USERID'S AND LINE AND ASID
NTONENTY DC    H'8'           NUMBER USERID'S / NOT-ON LINE
*
*  THE FOLLOWING DC'S DEFINE THE OUTPUT LINE DESCRIPTORS AND
*  MESSAGE SEGMENTS USED TO ISSUE THE UNRECOVERABLE ERROR
*  MESSAGE .  THE FIRST LEVEL OF THE MESSAGE USES TEXT
*  INSERTION TO INCLUDE THE NAME OF THE FAILING COMPONENT AND
*  THE RETURN CODE TO DESCRIBE THE ERROR.  THE SECOND LEVEL OF
*  THE MESSAGE IS MERELY SUPPOSED TO HOLD THE USERS HAND.
*
MDLOLD1  DC    A(MSGOLD2)     MODEL FOR FIRST OUTPUT LINE DESCR.
         DC    F'3'           # SEGMENTS
         DC    A(MSG1SEG1)    PTR TO FIRST SEGMENT
         DC    A(0)           PTR TO SECOND SEGMENT (TELLS WHO BLEW UP)
         DC    A(0)           PTR TO 3RD SEGMENT (RETURN CODE)
MSG1SEG1 DC    H'41'          MSG LEVEL 1 SEGMENT 1
         DC    H'0'
         DC    CL38' UNRECOVERABLE DUSER ERROR () - RETRY'
SVCSEG2  DC    H'9'            MSG LEVEL 1 SEGMENT 2 (SVC FAILURE)
         DC    H'28'
         DC    CL5'SVC  '
SPIESEG2 DC    H'9'           MSG LEVEL 1 SEGMENT 2 (SPIE ERROR)
         DC    H'27'
         DC    CL5'SPIE '
MDL1SEG3 DC    H'8'           MODEL FOR MSG LEVEL 1 SEGMENT 3
         DC    H'28'
         DC    CL4' '         RETURN CODE WILL BE PLACED HERE
MSGOLD2  DC    A(0)           OUTPUT LINE DESCRIPTOR 2
         DC    F'1'           # SEGMENTS
         DC    A(MSG2SEG1)     POINTER TO SECOND LEVEL MSG
MSG2SEG1 DC    H'52'          MSG LEVEL 2 SEGMENT 1 OF 1
         DC    H'0'
         DC    CL48' SYSTEM ENVIRONMENT CAUSED ERROR - REISSUE DUSER'
         EJECT
         CPDATA LIST=YES
         EJECT
TEMP1    DS    D
LINEPTR  DS    A              POINTER TO OUTPUT LINE
COLPTR   DS    A              POINTER TO OUTPUT COLUMN
LINENO   DS    F              CURRENT LINE NUMBER
ENTRYNO  DS    F              CURRENT # USERS IN OUTPUT LINE
OUTLINES DS    25CL80         MULTI-LINE PUTLINE DATA AREAS
LINELNTH EQU   80             LENGTH OF LINE INCL PUTLINE CTL INFO
FRSTLINE EQU   OUTLINES+LINELNTH   => FIRST USERID LINE
OUTREGS  DS    9F             SAVE AREA FOR OUTUSER REGS
USRLSTRG DS    4F             SAVE AREA FOR USERLIST REGS
NOTONREG DS    9F             SAVE AREA FOR NOTON REGS
NEXTREG  DS    7F             NEXTLINE REG SAVE AREA
NUMUSRS  DS    F              CURRENT # USERS ON
SVCPARM  DS    2H             SVC 241 PARM AREA
SVCPRMPT DS    A              PTR TO SVC 241 PARM
PDLPTR   DS    A              POINTER TO PDL
USERPTR  DS    A              POINTER TO DUSRUSER PDE
NONOTON  DS    F              CURRENT # USERS IN "NOT-ON" OUTPUT LINE
OPTIONS  DS    H  0 => JUST USERID, 1 => ASID OR LINE, 2 => BOTH
LINESW   DS    X
NUMBERSW DS    X
ASIDSW   DS    X
STARSW   DS    X
SIGSW    DS    X
USRFNDSW DS    X
PUTBLOK  PUTLINE MF=L    PUTLINE PARAMETER BLOCK
MSGOLD1  DS    A              OUTPUT LINE DESCRIPTOR 1
         DS    F
         DS    3A
MSG1SEG3 DS    2H             MESSAGE SEGMENT 3 FOR UNRECOV. ERRORS
         DS    CL4
         CPEND
         EJECT
         IHAASVT
         IHAASCB
         IEECHAIN
         END
