SETCLOCK TITLE '-- AUTOMATIC CLOCK SYNCHRONIZATION BETWEEN CPU''S --'
***********************************************************************
**                                                                   **
**       ---------------- S E T C L O C K -------------------        **
**                                     C.B.&T. MODS TAPE FILE 350    **
**                                                                   **
**       "AUTOMATIC CLOCK SYNCHRONISATION BETWEEN CPU'S"             **
**                                                                   **
**           THIS MODULE HAS BEEN  WRITTEN TO PROVIDE A              **
**       MEAN BY WHICH DIFFERENT CPU'S WILL BE SET TO THE SAME       **
**       TIME-OF-DAY CLOCK VALUES.                                   **
**                                                                   **
**                                                                   **
**                               AUTHOR:  LOUIS LABRECHE, IST        **
**                                        JUNE 1980                  **
**                                                                   **
**                                                                   **
**-------------------------------------------------------------------**
**        LOG HERE ALL SIGNIFICANT MODIFICATION                      **
**-------------------------------------------------------------------**
**  DATE    ×   DESCRIPTION                         × IDENTIFICATION **
** YY-MM-DD ×                                       ×                **
**-------------------------------------------------------------------**
** 81-04-06 ×   IMPLEMENT DISCRIPANCY VALIDATION.   ×                **
**          ×   HIGHER THAN 15 MINUTES, SEND A      ×      V1.01     **
**          ×   WARNING MESSAGE TO OPERATOR.        ×                **
**          ×                        L. LABRECHE    ×                **
**-------------------------------------------------------------------**
** 81-04-06 ×   ISSUE A WAIT MACRO WHEN LOOPING     ×                **
**          ×   TO GET CHECKPOINT RECORD. WAIT TIME ×      V1.02     **
**          ×   SHOULD BE 'SEEK*NCPU'.              ×                **
**          ×                        L. LABRECHE    ×                **
**-------------------------------------------------------------------**
** 81-04-06 ×   MOVE "CPU SET" INDICATOR ONLY AFTER ×                **
**          ×   CPU CLOCK HAD ACTUALLY BEEN SET.    ×      V1.03     **
**          ×                        L. LABRECHE    ×                **
**-------------------------------------------------------------------**
** 81-04-07 ×   IF RESET IS NOT SPECIFIED, MAXIMUM  ×                **
**          ×   NUMBER OF CPU'S WILL BE READ FROM   ×      V1.04     **
**          ×   CHECKPOINT, AND WILL BE EQUAL TO    ×                **
**          ×   LAST NUMBER OF ACTIVE CPU'S.        ×                **
**          ×                        L. LABRECHE    ×                **
**-------------------------------------------------------------------**
** 81-11-04 ×   PARMLIB DATASET IMPLEMENTATION      ×                **
**          ×                        L. LABRECHE    ×                **
**-------------------------------------------------------------------**
** 82-02-19 ×   CLARIFICATION OF SOME COMMENTS AND  ×                **
**          ×   ADDITION OF SOME MACROS TO AID IN   ×                **
**          ×   INSTALLATION TAILORING.             ×                **
**          ×                        P. FOSTER      ×                **
***********************************************************************
         EJECT
***********************************************************************
**                                                                   **
**                                                                   **
**                                                                   **
**       DESCRIPTION                                                 **
**          THIS PROGRAM IS INITIATED AS A STARTED TASK ON EACH      **
**       CPU IN A COMPLEX FOR WHICH TOD CLOCK SYNCHRONIZATION IS     **
**       DESIRED.  THIS SHOULD NORMALLY BE AT IPL TIME, SO THAT      **
**       THE MODIFICATION OF TOD CLOCK VALUES DO NOT IMPACT SMF      **
**       DATA RECORDING.  ONCE STARTED, THE PROGRAM WILL REMAIN      **
**       ACTIVE UNTIL THE TOD CLOCK OF ITS HOST SYSTEM HAS BEEN      **
**       SYNCHRONIZED WITH THOSE OF ALL ITS PARTNERS.                **
**                                                                   **
**           THE INFORMATION IS TRANSMITTED BETWEEN CPU'S VIA        **
**       A "DASD" DEVICE, AND A CHECKPOINT RECORD IS USED TO         **
**       TRANSFER DATA. A LOGICAL LOCK IS USED TO DETERMINE IF       **
**       THE CHECKPOINT IS HELD BY ANY CPU.                          **
**                                                                   **
**           THE ALGORITHM USED TO SYNCHRONIZE THE CLOCKS IS THE     **
**       FOLLOWING:                                                  **
**                                                                   **
**       --  WHEN A SYSTEM REQUESTS THE TIME TO BE SYNCHRONIZED,     **
**           IT ASKS FOR A "SYSTEM TRACKING" REQUEST ON THE DASD     **
**           RECORD.                                                 **
**                                                                   **
**       --  FROM THAT MOMENT, EACH "SET CLOCK" JOB WILL ACCESS      **
**           THE CHECKPOINT AND EXPECT TO COMMUNICATE WITH EACH      **
**           CPU SPECIFIED BY "PARMLIB", UNTIL ALL OF THE            **
**           ACTIVE CPU'S KNOW THAT A TIME SYNCHRONIZATION           **
**           WILL BE PERFORMED (ACCESS SHOULD BE DONE, SAY ONCE      **
**           EACH 5 SECONDS)                                         **
**                                                                   **
**           THIS IS CALLED THE "TRACK" STATE.                       **
**                                                                   **
**       --  ONCE ALL THE ACTIVE CPU'S ARE IN THE "TRACK" STATE,     **
**           THE LAST ONE INITIATES A REQUEST FOR ALL CPU'S TO       **
**           ENTER THE LOCK STATE.  ONCE IN THIS STATE , EACH CPU    **
**           WILL STOP "TRACK WAITING" AND WAIT FOR A VERY SHORT     **
**           PERIOD OF TIME (2 TIMES THE "SEEK TIME" , MULTIPLIED    **
**           BY THE NUMBER OF ACTIVE CPUS) UNTIL THE LAST ONE HAS    **
**           OBTAINED THE "LOCK" STATE.                              **
**                                                                   **
**       --  WHEN THE LAST ONE IS LOCKED,  EACH CPU WILL THEN        **
**           WRITE IT'S CLOCK TO THE CHECKPOINT RECORD . THIS IS     **
**           DONE TO DETERMINE WHICH CPU HAS THE HIGHEST CLOCK VALUE **
**           AND WHAT DISCREPANCIES EXIST BETWEEN THE VARIOUS        **
**           CLOCK VALUES.                                           **
**                                                                   **
**       --  WHEN EACH CPU HAS WRITTEN ITS OWN CLOCK VALUE TO THE    **
**           RECORD, A REQUEST IS THEN MADE TO SET THE TIME.         **
**                                                                   **
**       --  FROM THAT MOMENT, EACH CPU THAT READS THE RECORD        **
**           WILL ISSUE A "SET CLOCK" INSTRUCTION ACCORDING TO       **
**           THE "NORMALIZED" TIME OF THE "SET" REQUEST. NORMALIZ-   **
**           ATION IS DONE BY ADDING TO THE CLOCK THE CALCULATED     **
**           TIME DISCREPANCY PLUS THE SEEK TIME MULTIPLIED BY       **
**           THE SEQUENCE OF THE "SET" CPU.  THE BASE VALUE FOR      **
**           THE "NORMALIZATION" IS THE VALUE OF THE TOD CLOCK       **
**           OF THE CPU IN THE COMPLEX WHICH WAS SET TO THE          **
**           HIGHEST VALUE.                                          **
**                                                                   **
***********************************************************************
         EJECT
***********************************************************************
**                                                                   **
**                                                                   **
**       PARAMETERS:                                                 **
**                                                                   **
**           THE PARAMETERS ARE PASSED TO THIS PROGRAM BY            **
**       ALLOCATING A DATASET POINTED BY DDNAME "SYSPARM"            **
**       IT CONTAINS THE FOLLOWING SPECIFICATIONS :                  **
**                                                                   **
**           LONG_WAIT       = SSSS                                  **
**           TRACK_WAIT      = SSSS                                  **
**           SEEK_TIME       = SSSS                                  **
**           DISCONNECT_TIME = SSSS                                  **
**           MAXCPU          = NN                                    **
**                                                                   **
**           SSSS      IS THE TIME IN 100TH OF A SECOND              **
**           NN        IS A NUMERICAL VALUE                          **
**                                                                   **
**                                                                   **
**       "LONG_WAIT"   IS THE INTERVAL OF TIME THE PROGRAM SHOULD    **
**                     WAIT BEFORE CHECKING IF ANY "SYSTEM TRACKING" **
**                     REQUEST IS MADE (SAY 300 SECONDS)             **
**                                                                   **
**       "TRACK_WAIT"  IS THE INTERVAL OF TIME THE PROGRAM SHOULD    **
**                     WAIT ONCE IT HAS DETECTED A "SYSTEM TRACKING" **
**                     REQUEST. AT THIS TIME, IT CHECKS IF ALL CPU'S **
**                     OBTAINED THAT STATE. (SAY 5 SECONDS)          **
**                                                                   **
**       "SEEK_TIME"  IS THE AVERAGE INTERVAL OF TIME REQUIRED TO    **
**                     COMPLETE AN I/O ON THE CHECKPOINT DATASET.    **
**                                                                   **
**       "DISCONNECT_TIME" IS THE PERIOD OF TIME WE SHOULD WAIT      **
**                     BEFORE CONCLUDING THAT ALL THE OTHER CPUS     **
**                     THAT DID NOT REACH THE "TRACK STATE" ARE      **
**                     NOT ACTIVE (SAY 500 SECONDS). MUST BE         **
**                     HIGHER THAN "LONG WAIT".                      **
**                                                                   **
**       "MAXCPU"      IS THE MAXIMUM NUMBER OF CPU'S TO BE          **
**                     SYNCHRONIZED TOGETHER.                        **
**                                                                   **
**                                                                   **
***********************************************************************
         EJECT
***********************************************************************
**                                                                   **
**       NOTES:                                                      **
**       -----                                                       **
**                                                                   **
**           THE "DASD" DEVICE IS POINTED TO BY THE DDNAME           **
**       "SYSCKPT".  ONE TRACK IS A SUFFICENT ALLOCATION.            **
**                                                                   **
**           CPU IDENTIFIER IS TAKEN FROM "SMCA" AND THE LAST        **
**       CHARACTER IS USED TO DETERMINE ENTRY OFFSET IN CHECKPOINT.  **
**       SEE THE DESCRIPTION OF OPERANDS FOR THE SETCGEN MACRO FOR   **
**       AN EXPLANATION OF INSTALLATION TAILORING OPTIONS.  THE      **
**       SETCLOCK PROGRAM ASSUMES THAT THE SMF SYSTEM ID FOR EACH    **
**       SYSTEM CONTAINS A UNIQUE 1 CHARACTER IDENTIFIER LOCATED     **
**       AT A CONSISTENT OFFSET.  IF THIS IS NOT TRUE FOR YOUR       **
**       INSTALLATION, THE CPU IDENTIFICATION CODE WILL HAVE TO      **
**       BE ALTERED.  (SEE LABEL SCGSID) --.                         **
**                                                                   **
**           THE 'PARM' FIELD OF THE PROGRAM CAN BE USED TO          **
**       RESET THE CHECKPOINT RECORD BY CODING                       **
**                                                                   **
**           EXEC PGM=SETCLOCK,PARM='RESET'                          **
**                                                                   **
**       IN THAT CASE, CHECKPOINT RECORD WILL BE INITIALIZED         **
**       AND WRITTEN TO THE CHECKPOINT DATASET.                      **
**                                                                   **
**                                                                   **
***********************************************************************
         MACRO
&LABEL   SETCGEN &SID,&SIDCHAR=4,&CKPTDD=SYSCKPT,&PARMDD=SYSPARM,      X
               &DISCTIM=15
.**********************************************************************
.*
.*        SETCLOCK GENERATION MACRO:  THIS MACRO IS PROVIDED FOR
.*                 THE EASY TAILORING OF THE SETCLOCK PROGRAM TO
.*                 A USER'S ENVIRONMENT.
.*        OPERANDS:
.*        &SID    :  A LIST, ENCLOSED IN PARENTHESES, OF ALL SMF
.*                   SYSTEM IDS IN THE COMPLEX.  THIS LIST IS
.*                   MANDATORY, AND MUST CONTAIN FROM 2 TO 8
.*                   ENTRIES.
.*        &SIDCHAR:  THE CHARACTER POSITION (FROM 1 TO 4) OF A
.*                   CHARACTER IN EACH SMF SYSTEM ID WHICH
.*                   UNIQUELY IDENTIFIES EACH CPU.
.*        &CKPTDD :  THE DDNAME TO BE ASSIGNED TO THE
.*                   DASD-RESIDENT CHECKPOINT DATASET.
.*        &PARMDD :  THE DDNAME TO BE ASSIGNED TO THE SETCLOCK
.*                   PARAMETER DATASET.
.*        &DISCTIM:  THE TIME IN MINUTES OF THE LARGEST
.*                   DISCREPANCY BETWEEN TOD CLOCK VALUES ALLOWED
.*                   WITHOUT GENERATING A WARNING MESSAGE.
.*
.**********************************************************************
         GBLB  &TEST               TEST INDICATOR
         GBLC  &SYSCKPT            DDNAME FOR CHECKPOINT DATASET
         GBLC  &SETPARM            DDNAME FOR PARAMTERS DATASET
         GBLC  &MAXDISC            MAXIMUM DISCREPANCY ALLOWED    V1.01
.*                                 IN MINUTES BEFORE ISSUING MSG  V1.01
         GBLC  &SYSID(8)           SINGLE CHARACTER
.*                                 CPU IDENTIFIER TAKEN FROM SMCA
.*                                 USED TO IDENTIFY SYSTEM.
         GBLA  &MAXCPU            MAX NUMBER OF CPU'S TO BE SYNCHRON.
         GBLC  &OFFSET            OFFSET OF UNIQUE CHAR IN SMF SYSID
         LCLA  &N,&I
         AIF   (N'&SID GE 2 AND N'&SID LE 8).SIDOK
         MNOTE 8,'SYSTEM ID LIST ''&SID'' INVALID.  AT LEAST 2 SYSTEM IX
               D''S REQUIRED, WITH A MAXIMUM OF 8.)'
               MEXIT
.SIDOK   ANOP
         AIF   ('&SIDCHAR' GE '1' AND '&SIDCHAR' LE '4').GOODCHR
         MNOTE 4,'SIDCHAR VALUE &SIDCHAR INVALID. 4 ASSUMED.'
&OFFSET  SETC  '4'
         AGO   .SETCPU                                           87251
.GOODCHR ANOP
&OFFSET  SETC  '&SIDCHAR'
&I       SETA  &OFFSET
.SETCPU  ANOP
&MAXCPU  SETA  N'&SID
MAXCPUD  EQU   &MAXCPU             MAXIMUM NUMBER OF CPU'S SUPPORTED
&TEST    SETB  0                   DO NOT SET TEST MODE
.TESTTST AIF   (K'&SYSPARM NE 4).SETPRMS
         AIF   ('&SYSPARM' NE 'TEST').SETPRMS
&TEST    SETB  1                   INDICATE TEST MODE
         MNOTE *,'SETCLOCK GENERATED IN TEST MODE, NO CLOCK UPDATING WIX
               LL OCCUR.  MESSAGES WILL BE SENT VIA TPUT.'
.SETPRMS ANOP
&N       SETA  1
.SYSLOOP ANOP
&SYSID(&N) SETC '&SID(&N)'(&I,1)
&N       SETA  &N+1
         AIF   (&N LE &MAXCPU).SYSLOOP
&I       SETA  &I-1
&OFFSET  SETC  '&I'
         MNOTE *,'SETCLOCK CURRENTLY GENERATED TO SUPPORT A MAXIMUM OF X
               &MAXCPU CPU''S'
         MNOTE *,'UNIQUE SYSTEM IDENTIFIER LOCATED AT SMCASID+&OFFSET..X
               '
&MAXDISC SETC  '&DISCTIM'
         MNOTE *,'MAXIMUM TOD CLOCK DIFFERENCE WITHOUT GENERATION OF A X
               WARNING MESSAGE IS &MAXDISC MIN.'
&SYSCKPT SETC  '&CKPTDD'
         MNOTE *,'DASD CHECKPOINT DDNAME SET TO &SYSCKPT..'
&SETPARM SETC  '&PARMDD'
         MNOTE *,'PARAMETER LIBRARY DDNAME SET TO &SETPARM..'
         MEND
***********************************************************************
         MACRO
&LABEL   SETCTRT
         GBLA  &MAXCPU
         GBLC  &SYSID(8)
         LCLA  &I
&LABEL   DC    256X'00'            TRANSLATE TABLE TO DEFINE SYSID'S
         SPACE  1
&I       SETA  1
.SYSLOOP ORG   &LABEL+C'&SYSID(&I)' SYS ID CHAR OFFSET IN TABLE
         DC    AL1(&I)             SYSTEM NUMBER
&I       SETA  &I+1
         AIF   (&I LE &MAXCPU).SYSLOOP
         SPACE 1
         ORG   ,                   RESET ORDINAL COUNTER
         MEND
***********************************************************************
         MACRO
&LABEL   $SUBRET ,                 PROTOTYPE DEFINITION
.*
.*********************************************************************
.**                                                                 **
.**      $SUBRET -- RETURN FROM SUBROUTINE                          **
.**                                                                 **
.*********************************************************************
.*
         GBLC  &ALLOCLN            ALLOCATION LENGTH
.*
.**********************************************************************
         AIF   (T'&LABEL EQ 'O').NOLABEL
&LABEL   DS    0H                  RETURN TO CALLER
.NOLABEL ANOP
         AIF   ('&ALLOCLN' NE '0').FREE
.*
         ST    RCODE,12+4(RSAVE)   SAVE RETURN CODE
         AGO   .TERM               PROCESS A TERMINAL SUBROUTINE RETURN
.*
.FREE    ANOP
         LA    R0,&ALLOCLN         GET TOTAL DSECT LENGTH
         LR    R1,RSAVE            LOAD STORAGE ADDRESS
         SPACE 1
         L     RSAVE,4(RSAVE)      GET PREVIOUS SAVE AREA POINTER
         ST    RCODE,12+4(RSAVE)   SAVE RETURN CODE
         FREEMAIN R,               FREE STORAGE                        *
               LV=(0),             + OF LENGTH SPECIFIED BY R0         *
               A=(1)               + AND ADDRESS IN REGISTER 1
         SPACE 1
.TERM    ANOP
         LM    R14,R12,12(RSAVE)   RELOAD REGISTERS
         B     0(RCODE,RLINK)      + AND RETURN TO CALLER
         POP   USING               FORGET SUBROUTINE ADDRESSABILITY
         MEND
         MACRO
&LABEL   $SUB  &LOCAL,&LOCLN,&TERMIN=NO
.*                                 PROTOTYPE DEFINITION
.*********************************************************************
.*                                                                  **
.*       $SUB: SUBROUTINE ENTRY POINT MACRO DEFINITION              **
.*                                                                  **
.*********************************************************************
.*
.*       &LOCAL  -- LOCAL VARIABLES DSECT NAME
.*       &LOCLN  -- LOCAL VARIABLES DSECT LENGTH
.*       &TERMIN -- IF YES (OR NOTHING) SPECIFIED, THIS SUBROUTINE
.*                  DOES NOT CALL OTHER SUBROUTINES
.*
.**********************************************************************
.*
         GBLC  &ALLOCLN            GETMAINED AREA LENGTH
.*
&ALLOCLN SETC  '0'                 RESET LENGTH TO ZERO
         SPACE 1
.**********************************************************************
         AIF   (T'&LABEL EQ 'O').ERROR1
&LABEL   CSECT ,                   SUBROUTINE ENTRY POINT
.*
         STM   R14,R12,12(RSAVE)   SAVE REGISTERS
         PUSH  USING               SAVE USING STATUS
         LR    RSUB,RENTRY         LOAD BASE REGISTER
         USING &LABEL,RSUB         SETUP SUBROUTINE ADDRESSABILITY
         SPACE 1
         AIF   ('&TERMIN' NE 'NO').TERMIN
&ALLOCLN SETC  '18*4'              ALLOCATE AT LEAST A SAVE AREA
         AIF   (T'&LOCAL EQ 'O').GETMAIN
.*
         AIF   (T'&LOCLN EQ 'O').ERROR2
.ALLOCDS ANOP                      ALLOCATE LOCAL VARIABLES STORAGE
&ALLOCLN SETC  '&ALLOCLN+&LOCLN'   SET TOTAL LENGTH TO ALLOCATE
.*
.**********************************************************************
.**                                                                  **
.**      ISSUE GETMAIN FOR LOCAL VARIABLES AND SAVE AREA             **
.**                                                                  **
.**********************************************************************
.*
.GETMAIN ANOP
         LA    R0,&ALLOCLN         GET TOTAL DSECT LENGTH
         GETMAIN R,                ALLOCATE STORAGE                    *
               LV=(0)              + OF LENGTH SPECIFIED BY R0
         SPACE 1
         ST    RSAVE,4(R1)         CHAIN SAVE AREAS
         ST    R1,8(RSAVE)         + FORWARD AND BACKWARD
         LM    R0,R1,20(RSAVE)     RELOAD PARAMETER REGISTERS
         L     RSAVE,8(RSAVE)      + AND POINT TO NEW SAVE AREA
         SPACE 1
         AIF   (T'&LOCAL NE 'O').USING
         MEXIT
.USING   ANOP
         USING &LOCAL-(18*4),RSAVE ESTABLISH DSECT ADDRESSABILITY
         MEXIT
.TERMIN  ANOP
         AIF   (T'&LOCAL NE 'O').ALLOCDS
         MEXIT
.**********************************************************************
.**                                                                  **
.**      ERROR MESSAGES                                              **
.**                                                                  **
.**********************************************************************
.*
.ERROR1  MNOTE 8,'SUBROUTINE NAME  MUST BE SPECIFIED'
         MEXIT
.ERROR2  MNOTE 8,'DSECT LENGTH MUST BE SPECIFIED FOR LOCAL VARIABLES'
         MEND
         MACRO
&LABEL   SCANTCB &DSECT=YES,&LIST=NO
.*
         PUSH  PRINT
         PRINT OFF
         AIF   ('&LIST' NE 'YES').NOPRINT
         PRINT ON,GEN,NODATA
***********************************************************************
**                                                                   **
**       -----------------  S C A N T C B  ---------------------     **
**                                                                   **
**           SCAN TEXT CONTROL BLOCK IS USED FOR PASSING             **
**       INFORMATION RELATED TO ANALYSE TEXT BUFFER.                 **
**                                                                   **
**           ON FIRST CALL, FOLLOWING HAS TO BE DONE:                **
**                                                                   **
**           -- ZERO OUT ALL CONTROL BLOCK                           **
**           -- FILL SBTXT AND SBTXTLN FIELDS                        **
**                                                                   **
***********************************************************************
.NOPRINT ANOP
         AIF   ('&DSECT' EQ 'YES').DSECT
SCANTCB  DS    0D
         AGO   .NODSECT
.DSECT   ANOP
.*
SCANTCB  DSECT
.NODSECT ANOP
         AIF   ('&LABEL' EQ '').NEQ
&LABEL   DS    0D
.NEQ     ANOP
         SPACE 1
SBTXTBUF DS    CL88                TEXT BUFFER (FOR CARD IMAGE)
         ORG   SBTXTBUF            POINT TO BEGINNING OF BUFFER
SBTXTLN  DC    H'0'                TEXT LENGTH STARTING FROM
*                                  + SBTXTA (FIRST CHARACTER ADDRESS)
SBTXTOFS DC    H'0'                OFFSET TO OBTAIN NEXT CHARACTER
*                                  + FOLLOWING LAST PROCESSED TOKEN.
SBATOMA  DC    A(0)                POINTER TO FIRST CHARACTER FOLLOWING
*                                  + PROCESSED TOKEN
SBTXT    DC    CL80' '             TEXT CARD
         SPACE 1
SBGBUF   DC    XL80'00',X'00'      GROUP BUFFER THAT CONTAINS AN
*                                  + IMAGE OF SBTXT, BUT REPLACING EACH
*                                  + CHARACTER BY ASSOCIATED GROUP
*                                  + LAST BYTE IS X'00'
         SPACE 1
SBSFLG1  DS    FL1                 FLAGS BYTE
*
SBFNEW   EQU   B'00000001'         -- USED BY SCAN ROUTINE
         SPACE 1
SBSCNR15 DS    F                   REGISTER 15 UPON SCAN RETURN
*
         SPACE 1
SBSCNR0  DS    F                   REGISTER R0 UPON SCAN RETURN
SBSCNR1  DS    F                   REGISTER R1 UPON SCAN RETURN
         SPACE 1
SCANDLN  EQU   *-SCANTCB           DSECT LENGTH
         POP   PRINT
         MEND
**********************************************************************
**                                                                  **
**       SEND A MESSAGE MACRO --                                    **
**       GENERATE WTO OR TPUT DEPENDING UPON "TEST" VALUE           **
**                                                                  **
**********************************************************************
         MACRO
&LABEL   SEND  &MESS,&ROUTCDE=     PROTOTYPE DEFINITION
.***************************
         GBLB  &TEST               TEST INDICATOR
         ANOP
         LCLA  &K                  LOCAL COUNTER
         LCLC  &LAB                BRANCH LABEL DEFINITION
.***************************
         ANOP
         AIF   (&TEST).GENTPUT     IF TEST -- GENERATE TPUT
         ANOP
&LABEL   WTO   &MESS,ROUTCDE=&ROUTCDE
         MEXIT
.GENTPUT ANOP
&K       SETA  K'&MESS-2           MESSAGE LENGTH
&LAB     SETC  'SEND&SYSNDX'       BRANCH LABEL
         ANOP
         CNOP  0,4
&LABEL   BAL   R1,&LAB             BRANCH AROUND DEFINITION
         DC    AL2(&K)             MESSAGE LENGTH
         DC    B'0000000000000000' DUMMY MCS FLAGS
         DC    C&MESS
&LAB     DS    0H                  TPUT ENTRY POINT
         LA    R0,&K               GET MESSAGE LENGTH
         LA    R1,4(R1)            GET MESSAGE ADDRESS
         TPUT  (1),(0),EDIT        SEND MESSAGE TO TERMINAL
         MEND
         TITLE '-- L O C A L   D S E C T S --'
***********************************************************************
**                                                                   **
**       CHECKPOINT RECORD DESCRIPTION                               **
**                                                                   **
***********************************************************************
         SPACE 2
CHECKPT  DSECT                     DEFINE BEGINNING OF THE DESECT
         SPACE 2
CKHKEY   DS    XL8                 HARDWARE KEY DESCRIPTION
*
*              X'0000000000000000' -- FREE LOCK HARD KEY
*
         ORG   CKHKEY
         DC    X'FFFFFFFF'         LOCKED STATE KEY
CKLKSID  DS    CL4                 LOCKED CHECKPOINT SYSTEM ID (OWNER)
         SPACE 2
CKID     DC    C'CKPT'             CHECKPOINT RECORD ID
         SPACE 1
CKREQ    DS    X                   REQUEST CODE
*
CKRLWAIT EQU   X'00'               -- LONG WAIT
CKRTRACK EQU   X'04'               -- TRACK SYSTEM
CKRLOCK  EQU   X'08'               -- LOCK  SYSTEM
CKRSET   EQU   X'0C'               -- SET TIME AND DATE
CKREND   EQU   X'10'               -- TERMINATE PROGRAM (END)
         SPACE 1
CKCREQ   DS    C                   "CHARACTER REQUEST"
         SPACE 1
CKCRLW   EQU   C'W'                -- LONG WAIT
CKCRTR   EQU   C'T'                -- TRACK
CKCRTL   EQU   C'L'                -- LOCK
CKCRST   EQU   C'S'                -- SET TIME
CKCRND   EQU   C'E'                -- END OF PROGRAM
         SPACE 2
CKFLAGS  DS    FL1                 GLOBAL CHECKPOINT FLAGS
*
CKFLOCK  EQU   B'00000001'         ALL SYSTEMS GOT THE LOCK STATE
CKRSV01  DS    X                   RESERVED
         SPACE 1
CKRTIME  DS    F                   REQUEST TIME OF DAY IN 100TH OF SEC.
CKRDATE  DS    PL4                 REQUEST DATE IN FORMAT X'00YYDDDF'
         SPACE 1
CKSCLOCK DS    D                   CLOCK TO BE SET (BEFORE NORMALIZATN)
         SPACE 1
CKNACPU  DS    H                   NUMBER OF ACTIVE CPU (TRACKED BEFORE
*                                  DISCONNECT TIME IS REACHED )
         SPACE 1
CKNRCPU  DS    H                   RESIDUAL NUMBER OF CPU'S TO REACH
*                                  THE "LOCK" STATE OR THE "SET" STATE
         DS    0D                  ALIGN ENTRIES TO DOUBLEWORD
         EJECT
***********************************************************************
**                                                                   **
**       SYSTEM ENTRY -- THERE IS  ONE ENTRY FOR EACH SYSTEM         **
**                                                                   **
***********************************************************************
         SPACE 2
CKSENTRY DS    5XL16               SYSTEM ENTRY (DEFINE A MAX OF 5)
*                                  THERE IS AS MANY SYSTEM ENTRIES AS
*                                  THERE ARE CPU'S TO BE SYNCHRONIZED
*                                  TOGETHER.
         SPACE 1
         ORG   CKSENTRY            RESET ORDINAL COUNTER
CKSID    DS    CL4                 SYSTEM ID
         SPACE 1
         SPACE 1
CKSSTAT  DS    C                   SYSTEM STATUS
*
CKTWAIT  EQU   C'W'                -- WAIT
CKTTRACK EQU   C'T'                -- TRACKED
CKTLOCK  EQU   C'L'                -- LOCKED
CKTTIME  EQU   C'R'                -- TIME REFRESHED
CKTSET   EQU   C'S'                -- TIME IS SET
CKTDISC  EQU   C'D'                -- DISCONNECTED
         SPACE 1
CKRSV02  DS    3X                  RESERVED
         SPACE 1
CKSYSCLK DS    D                   SYSTEM CLOCK -- CPU CLK WHEN REQUEST
*                                  WAS TO 'LOCK'
         SPACE 1
         ORG   ,                   RESET ORDINAL COUNTER
CKEND    EQU   *                   CHECKPOINT RECORD END
CKLEN    EQU   CKEND-CHECKPT       CHECKPOINT RECORD LENGTH
         EJECT
***********************************************************************
**                                                                   **
**       SCAN CONTROL BLOCK DSECT DEFINITION                         **
**                                                                   **
***********************************************************************
         SCANTCB LIST=YES
         SPACE 2
         EJECT
***********************************************************************
**                                                                   **
**       WORK DSECT -- STORAGE WORK AREA                             **
**                                                                   **
***********************************************************************
         SPACE 1
WORK     DSECT                     WORK AREA DSECT DESCRIPTION
         SPACE 1
AREA     DS    18F                 MAINLINE SAVE AREA
AREA2    DS    18F                 SECOND LEVEL ROUTINES SAVE AREA
         SPACE 1
SCWDBLE  DS    D                   WORK DOUBLE WORD
SCWPKBUF DS    PL8                 PACK BUFFER
         SPACE 1
SCENTRYP DS    A                   POINTER TO THE SYSTEM ENTRY IN THE
*                                  CHECKPOINT BUFFER
         SPACE 1
SCCKCNT  DS    XL8                 COUNT FIELD (SHOULD IMMEDIATELY
*                                  PRECEEDE 'SCCKPNT' -- USED TO
*                                  WRITE THE RECORD)
         ORG   SCCKCNT             RESET POINTER TO COUNT FIELD
SCCKID   DC    XL5'0000000000'     COUNT ID (CCHHR)
SCCKLEN  DS    AL3                 RECORD LENGTH
         ORG   SCCKLEN             RESET ORDINAL COUNTER
         DC    AL1(L'CKHKEY)       -- KEY  LENGTH
         DC    AL2(CKLEN-L'CKHKEY) -- DATA LENGTH
         SPACE 1
SCCKPNT  DS    XL(CKLEN)           CHECKPOINT RECORD BUFFER
         SPACE 1
SCSYSID  DS    CL4                 SYSTEM ID
         SPACE 1
SCWTIME  DS    F                   CURRENT WAITING TIME
*                                  -- DEPEND UPON STATE
SCHTIME  DS    F                   HIGH TIME
*                                  -- USED TO DETERMINE WHICH CPU HAS
*                                     THE HIGHEST TIME WHEN WE ARE
*                                     PERFORMING SYNCHRONIZATION
SCDCLOCK DS    D                   CLOCK WORK DOUBLE WORD
         SPACE 1
SCFLAGS  DS    FL1                 FLAGS
*
SCFRESET EQU   B'00000001'         CHECKPOINT RECORD WILL BE RESET
SCFSTART EQU   B'00000010'         INDICATE BEGINNING OF 'SET'
SCFRES01 EQU   B'11111100'         RESERVED
         SPACE 2
***********************************************************************
**                                                                   **
**       SET DATE MESSAGE MAPPING                                    **
**                                                                   **
***********************************************************************
         SPACE 2
SCDWMSG  DC    C'SCK0017I -- TIME IS NOW  '
*                                  TIME KEYWORD DEFINITION
SCDWTIM  DC    C'HH.MM.SS'         TIME
         DC    C', DATE IS '       DATE KEYWORD DEFINITION
SCDWDAT  DC    C'YY.DDD'           DATE
         EJECT
***********************************************************************
**                                                                   **
**        INPUT PARAMETERS VARIABLES DEFINITIONS                     **
**                                                                   **
***********************************************************************
         SPACE 1
SCPFLAGS DS    FL1                 FLAGS BYTE
*
SCPFCNT  EQU   B'00000001'         -- CONTINUING SAME KEYWORD PARSE
SCPFPERR EQU   B'00000010'         -- PARSE ERROR ENCOUNTERED
SCPFRSV1 EQU   B'11111100'         -- RESERVED
*
         SPACE 1
SCPRDSA  DS    (5+1)F              RDSCAN COMMUNICATION SAVE AREA
SCPSTCB  DS    XL(SCANDLN)         SCAN TEXT CONTROL BLOCK
         SPACE 2
SCPWAIT  DS    F                   LONG  WAIT TIME (HUNDREDS OF SEC)
SCPTRACK DS    F                   TRACK WAIT TIME (HUNDREDS OF SEC)
SCPSEEK  DS    F                   SEEK TIME -- I/O ESTIMATED TIME
         SPACE 1                                                  V1.04
SCPMAXC  DS    F                   MAXIMUM NUMBER OF CPU'S. IF    V1.04
*                                  RESET IS NOT SPECIFIED, IT     V1.04
*                                  WILL BE READ FROM CHECKPOINT   V1.04
         SPACE 1                                                  V1.04
SCPDISC  DS    F                   ELAPSED TRACKING TIME  BEFORE
*                                  CONSIDERING A SYSTEM AS "INACTIVE"
         SPACE 2
SCPLOCK  DS    F                   LOCK WAIT TIME -- SEEK*NACPU
WORKLEN  EQU   *-WORK              WORK AREA LENGTH
         TITLE '--  S Y S T E M   D S E C T S --'
***********************************************************************
**                                                                   **
**       SYSTEM DSECTS                                               **
**                                                                   **
***********************************************************************
         SPACE 1
         PUSH  PRINT               SAVE PRINT STATUS
         PRINT ON,NOGEN            SUPPRESS SYSTEM GENERATION
         SPACE 1
         IHAPSA                    PREFIXED STORAGE AREA
         DCBD DSORG=PS             DATA CONTROL BLOCK
         IECSDSL1 1                DSCB
         CVT   DSECT=YES           COMMUNICATION VECTOR TABLE
         IEESMCA                   SMF CONTROL TABLE (FOR SID)
         IEZDEB                    DEB MAP AND KEYWORDS
         IEZIOB                    IOB MAP AND KEYWORDS
         SPACE 1
         POP   PRINT               RESET PRINT STATUS
         TITLE '-- R E G I S T E R   D E F I N I T I O N S   --'
         SPACE 3
***********************************************************************
**                                                                   **
**       ABSOLUTE REGISTER DEFINITIONS :                             **
**                                                                   **
***********************************************************************
         SPACE 1
         YREGS ,                  + GENERAL REGISTERS
         SPACE 2
***********************************************************************
**                                                                   **
**       SYMBOLIC REGISTERS DEFINITIONS :                            **
**                                                                   **
***********************************************************************
         SPACE 1
RPARM    EQU   R1                  O/S AND PROGRAM PARAMETER REGISTER
RWORK    EQU   R11                 COMMON WORKAREA POINTER
RBASE    EQU   R12                 BASE OF MAINLINE
RSUB     EQU   R12                 BASE OF SUBROUTINES
RSAVE    EQU   R13                 O/S SAVE AREA POINTER
RLINK    EQU   R14                 O/S AND PROGRAM LINK REGISTER
RENTRY   EQU   R15                 O/S AND PROGRAM ENTRY POINT REGISTER
RCODE    EQU   R15                 O/S AND PROGRAM RETURN CODE REGISTER
         SPACE 2
RLINK2   EQU   R8                  PROGRAM SECOND LEVEL LINK REGISTER
RBCKP    EQU   R9                  CHECKPOINT RECORD BASE REGISTER
RSENTRY  EQU   R10                 BASE REGISTER FOR SYSTEM (IN CKPT)
         TITLE 'SYMBOLIC VARIABLES '
***********************************************************************
**                                                                   **
**       GLOBAL AND LOCAL SYMBOLIC VARIABLES DEFINITIONS             **
**                                                                   **
***********************************************************************
         SPACE 1
         GBLB  &TEST               TEST INDICATOR -- IF SET TO ONE,
*                                  WILL SUPPRESS SUPERVISOR MODE AND
*                                  EXECUTION OF "SCK" INSTRUCTION.
*                                  GENERATE TPUT INSTEAD OF WTO
         SPACE 1
         GBLC  &SYSCKPT            DDNAME FOR CHECKPOINT DATASET
         GBLC  &SETPARM            DDNAME FOR PARAMTERS DATASET
         GBLC  &MAXDISC            MAXIMUM DISCREPANCY ALLOWED    V1.01
*                                  IN MINUTES BEFORE ISSUING MSG  V1.01
         SPACE 1
         GBLC  &OFFSET             SMCASID OFFSET OF UNIQUE ID CHAR
***********************************************************************
**                                                                   **
**       SYMBOLIC VARIABLES INITIALISATION                           **
**                                                                   **
***********************************************************************
         SPACE 1
         SETCGEN (434A,434B),DISCTIM=30  IT'S A SMALL WORLD      87251
***********************************************************************
**                                                                   **
**       PARMLIB DATASET DEFAULT PARAMETERS                          **
**                                                                   **
***********************************************************************
*        MAXCPU DETERMINED FROM SETCGEN MACRO
DISTIME  EQU   12000      DEFAULT DISC TIME  100TH OF A SECOND (2 MIN.)
LONGWT   EQU   6000       DEFAULT LONG WAIT  100TH OF A SECOND (1 MIN.)
TRAKWT   EQU   300        DEFAULT TRACK WAIT 100TH OF A SECOND (3 SEC.)
SEKTIM   EQU   3          DEFAULT SEEK TIME  100TH OF A SECOND (30 MS.)
         SPACE 2
***********************************************************************
**                                                                   **
**       GLOBAL EQUATES                                              **
**                                                                   **
***********************************************************************
         SPACE 1
ZERO     EQU   0                   ZERO
         SPACE 1
D1       EQU   1                   1 BYTE DISPLACEMENT
D2       EQU   2                   2 BYTE DISPLACEMENT
D3       EQU   3                   3 BYTE DISPLACEMENT
         SPACE 2
FF       EQU   X'FF'               X'FF' DEFINITION
         TITLE ' --  I N I T I A L I S A T I O N '
***********************************************************************
**                                                                   **
**       SAVE REGISTERS AND CHAIN SAVE AREAS                         **
**                                                                   **
***********************************************************************
         SPACE 1
         PRINT NOGEN         SAVE A TREE                        GP03029
SETCLOCK CSECT
         SAVE  (14,12),,SETCLOCK--&SYSDATE.--&SYSTIME
         SPACE 1
         LR    RBASE,RENTRY        LOAD BASE REGISTER
         USING SETCLOCK,RBASE      TELL THE ASSEMBLER
         SPACE 1
         LR    R2,RPARM            LOAD R2 WITH PARM REGISTER
         SPACE 1
         LA    R0,WORKLEN          WORK AREA LENGTH
         GETMAIN R,LV=(0)
*                                  ALLOCATE LOCAL WORK STORAGE
         SPACE 1
         ST    RSAVE,4(R1)         *  CHAIN
         ST    R1,8(RSAVE)         *  SAVE
         LR    RWORK,R1            *  AREAS
         SPACE 2
         USING WORK,RWORK          SET DSECT ADDRESSABILITY
         LA    RSAVE,AREA          SET SAVEAREA POINTER
         SPACE 2
         USING PSA,R0              SET PSA ADDRESSABILITY
         SPACE 1
         LA    RBCKP,SCCKPNT       LOAD THE CHECKPOINT RECORD ADDRESS
         USING CHECKPT,RBCKP       SET CHECKPOINT ADDRESSABILITY
         EJECT
***********************************************************************
**                                                                   **
**       INITIALIZE PROGRAM FLAGS AND CCW'S ADDRESSES                **
**                                                                   **
***********************************************************************
         SPACE 1
         MVI   SCFLAGS,ZERO        CLEAR INITIAL FLAGS
         SPACE 1
         STCM  RBCKP,B'0111',CPRBUF3
         STCM  RBCKP,B'0111',CPRBUF2
         SPACE 1
         LA    R1,SCCKCNT          POINT TO COUNT FIELD
         STCM  R1,B'0111',CPWBUFA  SAVE IT IN CHANNEL PROGRAM
         SPACE 1
         LA    R1,CKID             CHECKPOINT 'DATA' PORTION ADDRESS
         STCM  R1,B'0111',CPRBUF1  STORE IT IN CCW
         SPACE 1
         MVC   SCCKLEN,SCKLDL      MOVE KEY AND RECORD LENGTH
         SPACE 1
***********************************************************************
**                                                                   **
**       READ THE INPUT PARAMETERS FROM DDNAME "SETPARM"             **
**                                                                   **
***********************************************************************
         SPACE 2
SCREADP  DS    0H                  READ PARAMETERS
         BAL   RLINK,READPARM      READ THE INPUT PARAMETERS
         B     *+L'*+4             ERROR IN THE INPUT PARAMETERS
         B     SCINIT              PROCESS MAINLINE CODE
         SPACE 2
***********************************************************************
**                                                                   **
**       ERROR HAS BEEN DETECTED INPUT PARAMETERS, WRITE MSG & QUIT  **
**                                                                   **
***********************************************************************
         SPACE 1
         SEND  'SCK0001E -- ERROR  DETECTED IN INPUT PARAMETERS',      *
               ROUTCDE=(1,2)      ROUTE TO MASTER CONSOLES
         SPACE 1
         B     SCERR               GO PROCESS AFTER ERROR
         EJECT
***********************************************************************
**                                                                   **
**       CHECK IF PARM 'RESET' IS SPECIFIED AND SET ACCORDING FLAG   **
**                                                                   **
***********************************************************************
         SPACE 1
SCINIT   DS    0H                  PROCESS INITIALISATION
         L     R1,0(R2)            LOAD PARM ADDRESS IN REGISTER ONE
         XR    R0,R0               CLEAR WORK REGISTER
         SPACE 1
         ICM   R0,B'0011',0(R1)    LOAD PARM LENGTH
         BZ    SCOPEN              ZERO -- NO PARM WAS SPECIFIED
         SPACE 1
         CL    R0,=A(L'RESET)      COMPARE PARM LENGTH
         BNE   SCERPARM            NOT EQUAL -- PARM ERROR
         SPACE 1
         OC    D2(L'RESET,R1),SCBL CONVERT PARM FIELD TO UPPERCASE
         CLC   RESET,D2(R1)        IS PARM EQUAL ?
         BE    SCRESET             YES, RESET THING
         SPACE 1
***********************************************************************
**                                                                   **
**       INVALID 'PARM' WAS ENCOUNTERED -- PRINT MSG & QUIT          **
**                                                                   **
***********************************************************************
         SPACE 2
SCERPARM DS    0H                  INVALID PARM ENCOUNTERED
         SPACE 1
         SEND  'SCK0008E -- INVALID  PARM WAS SPECIFIED (RESET???)',   *
               ROUTCDE=(1,2)      ROUTE TO MASTER CONSOLES
         B     SCERR               QUIT WITH ERROR
         EJECT
***********************************************************************
**                                                                   **
**       RESET HAS BEEN SPECIFIED -- INIT RECORD AND SET FLAG        **
**       ALSO TELL OPERATOR OF "CHECKPOINT" RESET                    **
**                                                                   **
***********************************************************************
         SPACE 1
SCRESET  DS    0H                  RESET CHECKPOINT RECORD
         SPACE 1
         SEND  'SCK0016I -- CHECKPOINT RECORD WILL BE RESET',          *
               ROUTCDE=(1,2)      ROUTE TO MASTER CONSOLES
         SPACE 1
         XC    CHECKPT(CKLEN),CHECKPT
*                                  ZERO OUT CHECKPOINT RECORD
*                                  LOCK IS NOW FREE (IN BUFFER)
         SPACE 1
         MVC   CKID,=CL4'CKPT'     MOVE RECORD ID
         OI    SCFLAGS,SCFRESET    RESET HAS BEEN SPECIFIED
         SPACE 1
         L     R1,SCPMAXC          GET MAX NUMBER OF CPU'S
         STH   R1,CKNRCPU          THIS IS NUMBER OF RESIDUAL CPU'S
         STH   R1,CKNACPU          POTENTIAL NUMBER OF ACTIVE CPU'S
         SPACE 1
         LA    R2,CKSENTRY         GET SYSTEM ENTRIES ADDRESSES
         USING CKSENTRY,R2         SET R2 AS BASE REGISTER
         SPACE 1
         LA    R1,(CKEND-CKSENTRY)/L'CKSENTRY
*                                  MAXIMUM NUMBER OF ENTRIES
         SPACE 1
SCRLOOP  DS    0H                  RESET LOOP
         SPACE 1
         MVI   CKSSTAT,CKTDISC     SET SYSTEM AS 'DISCONNECTED'
         LA    R2,L'CKSENTRY(R2)   POINT TO NEXT ENTRY
         BCT   R1,SCRLOOP          RESET ALL SYSTEM ENTRIES
         SPACE 1
         DROP  R2                  NO MORE USED
         EJECT
***********************************************************************
**                                                                   **
**       OPEN THE CHECKPOINT DATASET -- EXCP                         **
**                                                                   **
***********************************************************************
         SPACE 1
SCOPEN   DS    0H                  OPEN CHECKPOINT DATASET
         SPACE 1
         OPEN  (SYSCKPT,OUTPUT)    OPEN CKPT OUTPUT MODE
         SPACE 1
         TM    SYSCKPT+DCBOFLGS-IHADCB,DCBOFOPN
*                                  DID THE DATASET OPENED PROPERLY?
         BO    SCGOODOP            YES, CONTINUE PROCESSING
         SPACE 2
         SEND  'SCK0006E -- DASD DEVICE DID NOT OPEN PROPERLY',        *
               ROUTCDE=(1,2)      ROUTE TO MASTER CONSOLES
         B     SCERR               GO PROCESS THE ERROR
         EJECT
***********************************************************************
**                                                                   **
**       OPEN WAS SUCCESSFUL -- ACKNOWLEGE SETCLOCK OPERATION        **
*                            -- SAVE "CC" AND "HH" FOR I/O ROUTINE   **
**                                                                   **
***********************************************************************
         SPACE 1
SCGOODOP DS    0H                  OPEN WAS SUCCESSFUL
         SPACE 1
         SEND  'SCK0015I -- CLOCKS SYNCHRONIZATION IN PROGRESS',       *
               ROUTCDE=(1,2)      ROUTE TO MASTER CONSOLES
         SPACE 1
         LA    R2,SYSCKPT          GET DCB ADDRESS IN R2
         USING IHADCB,R2           SET DCB ADDRESSABILITY
         SPACE 1
         L     R2,DCBDEBAD         LOAD DEB ADDRESS
         USING DEBBASIC,R2         SET BASIC ADDRESSABILITY
         SPACE 1
         LA    R2,DEBBASND         LOAD SEGMENT ADDRESS
         USING DEBDASD,R2          SET DASD SECTION ADDRESSABILITY
         SPACE 1
         MVC   CPSEEKCC,DEBSTRCC   SET STARTING CYLINDER ADDRESS
         MVC   CPSEEKHH,DEBSTRHH   SET STARTING HEAD NUMBER
         MVI   CPSEEKR,1           SET STARTING RECORD TO '1'
         SPACE 2
         MVC   SCCKID,CPSEEKCC     MOVE ID FOR WRITE
         SPACE 1
         DROP  R2                  NO MORE USED
         TITLE '-- M A I N L I N E    P R O C E S S I N G --'
***********************************************************************
**                                                                   **
**       GET THE SYSTEM "ID" AND COMPUTE OUR ENTRY OFFSET IN THE     **
**       CHECKPOINT RECORD. SAVE IT IN WORK AREA.                    **
**                                                                   **
***********************************************************************
         SPACE 1
SCGSID   DS    0H                  GET SYSTEM IDENTIFIER FROM SMCA
         L     R1,FLCCVT           LOAD CVT ADDRESS
         L     R1,CVTSMCA-CVT(,R1) LOAD SMCA ADDRESS
         SPACE 1
         MVC   SCSYSID,SMCASID-SMCABASE(R1)
*                                  AND SAVE CURRENT SYSID IN WORK AREA
         SPACE 1
         XR    R2,R2               CLEAR WORK REGISTER
         TRT   SCSYSID+&OFFSET.(1),SCXTBL SET R2 TO SYSTEM
*                                  OFFSET IN RECORD
         SPACE 1
         BCTR  R2,R0               OBTAIN RELATIVE POSITION
         MH    R2,=Y(L'CKSENTRY)   THIS IS THE OFFSET OF OUR SYSID
         SPACE 1
         LA    RSENTRY,CKSENTRY(R2) POINT TO OUR SYSTEM ENTRY
         ST    RSENTRY,SCENTRYP    SAVE CPU ENTRY IN WORK AREA
         SPACE 1
         USING CKSENTRY,RSENTRY    SET OUR ENTRY ADDRESSABILITY
         SPACE 1
***********************************************************************
**                                                                   **
**       OBTAIN THE LOCK AND READ THE CHECKPOINT RECORD              **
**       -- IF RESET HAS BEEN SPECIFIED, SKIP THIS SECTION           **
**                                                                   **
***********************************************************************
         SPACE 1
         TM    SCFLAGS,SCFRESET    WAS RESET SPECIFIED?
         BO    SCSETRQ             YES, SO DO NOT READ THE RECORD
         SPACE 1
         BAL   RLINK,SCGETREC      GET THE LOCK AND READ THE RECORD
         B     SCERR               IF AN ERROR OCCURS
         SPACE 1
         MVC   SCPMAXC+2(2),CKNACPU                               V1.04
*                                  IF RESET IS NOT SPECIFIED,TAKE V1.04
*                                  MAX NUMBER OF CPU'S FROM CKPT  V1.04
         EJECT
***********************************************************************
**                                                                   **
**       SET THE REQUEST CODE TO "TRACK" --                          **
**       NOTE THAT OUR STATUS WILL REMAIN AS "DISCONNECTED" OR WAIT  **
**                                                                   **
***********************************************************************
         SPACE 1
SCSETRQ  DS    0H                  SET THE SYSTEM REQUEST
         SPACE 1
***********************************************************************
**                                                                   **
**       TEST IF THIS REQUEST IS TOO LATE (SYNCHRONIZATION STARTED)  **
**       IF SO, WRITE MESSAGE AND TERMINATE EXECUTION                **
**                                                                   **
***********************************************************************
         SPACE 1
         CLI   CKREQ,CKRLWAIT      IS ACTUAL REQUEST TO "WAIT"?
         BE    SCOKREQ             OK, CONTINUE
         CLI   CKREQ,CKREND        IS ACTUAL REQUEST "END" ?
         BE    SCOKREQ             OK, CONTINUE
         CLI   CKREQ,CKRTRACK      IS ACTUAL REQUEST "TRACK" ?
         BE    SCOKREQ             OK, CONTINUE
         SPACE 1
         SEND  'SCK0017E -- TOO LATE FOR THIS CPU..RETRY LATER OR RESET*
                CHECKPOINT',                                           *
               ROUTCDE=(1,2)       ROUTE TO MASTER CONSOLES
         B     SCERR               GO PROCESS THE ERROR
         SPACE 1
SCOKREQ  DS    0H                  REQUEST IS OK -- CONTINUE
         MVI   CKREQ,CKRTRACK      SET REQUEST CODE TO TRACK
         MVI   CKCREQ,CKCRTR       SET REQUEST CODE TO TRACK (CHAR)
         SPACE 1
         MVC   CKSID,SCSYSID       MOVE OUR SYSTEM ID TO BUFFER
         MVC   SCWTIME,SCPTRACK    SET WAITING TIME TO 'TRACK'
         SPACE 2
***********************************************************************
**                                                                   **
**       GET TIME AND DATE AND INITIALIZE REQUEST TIME AND DATE      **
**                                                                   **
***********************************************************************
         SPACE 1
SCTRACK  DS    0H                  PROCESS A TRACK REQUEST
         SPACE 1
         TIME  BIN                 SET TIME IN R0 AND DATE IN R1
*                                  DATE IS IN FORMAT X'00YYDDDF'
*                                  TIME IS IN BINARY 100TH OF SECONDS
         SPACE 1
         STCM  R0,B'1111',CKRTIME  STORE REQUEST TIME IN BUFFER
         STCM  R1,B'1111',CKRDATE  STORE REQUEST DATE IN BUFFER
         SPACE 1
***********************************************************************
**                                                                   **
**       WRITE  THE RECORD AND FREE THE LOCK                         **
**                                                                   **
***********************************************************************
         SPACE 1
         BAL   RLINK,SCWRITE       WRITE THE RECORD
*                                  THIS SECTION WRITES THE RECORD
*                                  AND FREES THE LOCK BY WRITING A
*                                  HARDWARE KEY OF X'0000000000000000'
         B     SCERR               WHEN AN ERROR OCCURS
         TITLE '-- STATE PROCESSING'
***********************************************************************
**                                                                   **
**       LOOP UNTIL ALL CPU'S REACH THE "WANTED STATE" OR IF THE     **
**       DISCONNECT TIME IS EXPIRED. (WHEN REQUEST IS TRACK)         **
**                                                                   **
***********************************************************************
         SPACE 1
SCTLOOP  DS    0H                  STATE LOOP
         SPACE 1
         LA    R1,SCWTIME          LOAD THE WAIT TIME ADDRESS
         STIMER WAIT,              WAIT FOR TIME TO ELAPSE             *
               BINTVL=(R1)         ADDRESS SPECIFIED BY R1
         SPACE 2
         BAL   RLINK,SCGETREC      GET THE RECORD AND THE LOCK
         B     SCERR               IF AN ERROR OCCURS
         SPACE 1
         XR    R1,R1               CLEAR WORK REGISTER
         IC    R1,CKREQ            INSERT REQUEST CODE
         SPACE 1
         LA    RLINK,SCTWTR        SET RETURN ADDRESS TO 'WRITE'
         B     *+L'*(R1)           GO PROCESSING ACCORDING TO REQUEST
         SPACE 1
         B     SCTWTR              WAIT  -- WAIT FOR REQUEST
         B     SCTREQ              TRACK -- TRACK REQUEST
         B     SCLREQ              LOCK  -- LOCK REQUEST
         B     SCSTIME             SET   -- SET TIME REQUEST
         B     SCRETURN            END   -- RETURN TO CALLER
         SPACE 2
***********************************************************************
**                                                                   **
**       WRITE OUT THE RECORD AND RESET THE LOCK                     **
**                                                                   **
***********************************************************************
         SPACE 1
SCTWTR   DS    0H                  WRITE THE  RECORD AND RESET THE LOCK
         BAL   RLINK,SCWRITE       WRITE THE RECORD
         B     SCERR               IF AN ERROR OCCURS
         SPACE 1
         B     SCTLOOP             LOOP AGAIN
         TITLE '-- PROCESS A TRACK REQUEST'
***********************************************************************
**                                                                   **
**       "TRACK REQUEST"                                             **
**                                                                   **
**       ON ENTRY, STATE MIGHT BE "DISCONNECTED" (IF FIRST CALL )    **
**                                "SET"          (IF WAS IN WAIT)    **
**                                "TRACKED"      (IF PROCESSING )    **
**                                                                   **
***********************************************************************
         SPACE 1
SCTREQ   DS    0H                  TRACK REQUEST
         SPACE 1
         CLI   CKSSTAT,CKTTRACK    ALREADY TRACKED?
         BE    SCTCKDIS            YES, CHECK IF DISCONNECTED
         SPACE 2
SCTFREQ  DS    0H
         SPACE 1
         MVC   SCWTIME,SCPTRACK    SET WAIT TIME TO "TRACK" IN CASE
*                                  WE WERE IN "WAIT STATE" BEFORE
         SPACE 1
         LH    R1,CKNRCPU          NUMBER OF RESIDUAL CPU'S
         BCT   R1,SCTNOTL          IF NOT LAST ONE
         SPACE 1
***********************************************************************
**                                                                   **
**       WE ARE THE LAST CPU TO GET 'TRACK REQUEST'                  **
**                                                                   **
***********************************************************************
         SPACE 2
         SEND  'SCK0012I -- ALL CPU''S WILL BE SYNCHRONIZED',          *
               ROUTCDE=(1,2)      ROUTE TO MASTER CONSOLES
         SPACE 1
         MVI   CKREQ,CKRLOCK       ASK TO OBTAIN LOCK
         MVI   CKCREQ,CKCRTL       ALSO CHAR REQUEST
         SPACE 1
         L     R1,SCPMAXC          GET MAX NUMBER OF CPU'S
         STH   R1,CKNACPU          THIS IS NUMBER OF ACTIVE CPU"S
         B     SCTLOCK             AND PROCESS TO GET LOCK STATE
         EJECT
***********************************************************************
**                                                                   **
**       WE ARE NOT THE LAST TO GET TRACK STATE                      **
**                                                                   **
***********************************************************************
         SPACE 1
SCTNOTL  DS    0H                  WE ARE NOT THE LAST
         SPACE 1
         STH   R1,CKNRCPU          SAVE NUMBER OF RESIDUAL CPU'S
         MVI   CKSSTAT,CKTTRACK    OUR STATUS IS TRACK
         BR    RLINK               RETURN WRITE RECORD
         SPACE 2
***********************************************************************
**                                                                   **
**       "TRACK REQUEST" CHECK IF TIME IS EXPIRED                    **
**                                                                   **
***********************************************************************
         SPACE 1
SCTCKDIS DS    0H                  TRACK -- CHECK IF TIME IS EXPIRED
         SPACE 1
         TIME  BIN                 SET TIME IN R0 AND DATE IN R1
*                                  DATE IS IN FORMAT X'00YYDDDF'
*                                  TIME IS IN BINARY 100TH OF SECONDS
         S     R0,CKRTIME          GET TIME DISCREPANCY
         C     R0,SCPDISC          CPU'S DISCONNECTED?
         SPACE 1
         BNHR  RLINK               NO, LOOP AGAIN
         SPACE 2
***********************************************************************
**                                                                   **
**       DISCONNECT TIME HAS EXPIRED -- SET NUMBER OF ACTIVE CPU'S   **
**       AND ASK FOR A "LOCK" REQUEST                                **
**                                                                   **
***********************************************************************
         SPACE 1
         SEND  'SCK0013I -- DISCONNECT TIME HAS EXPIRED, PARTIAL SYNCHR*
               ONIZATION WILL BE DONE',                                *
               ROUTCDE=(1,2)      ROUTE TO MASTER CONSOLES
         SPACE 1
         MVI   CKREQ,CKRLOCK       NEW REQUEST IS TO LOCK
         MVI   CKCREQ,CKCRTL       SET CHAR REQUEST
         SPACE 1
         L     R1,SCPMAXC          LOAD MAX NUMBER OF CPU'S
         SH    R1,CKNRCPU          SUBSTRACT RESIDUAL
         SPACE 1
         STH   R1,CKNACPU          SAVE NUMBER OF ACTIVE CPU'S
         SPACE 2
SCTLOCK  DS    0H                  PROCESS TO GET LOCK STATE
         SPACE 1
         BCTR  R1,R0               NUMBER OF RESIDUAL CPU'S TO LOCK
         SPACE 2
         STH   R1,CKNRCPU          SAVE IT IN CHECKPOINT RECORD
         MVI   CKSSTAT,CKTLOCK     SET OUR STATUS TO 'LOCK'
         SPACE 1
***********************************************************************
**                                                                   **
**       COMPUTE WAIT TIME FOR LOCK STATE (SEEK*NACPU)               **
**                                                                   **
***********************************************************************
         SPACE 2
         L     R0,SCPSEEK          GET SEEK TIME
         MH    R0,CKNACPU          AND MULTIPLY BY NUMBER OF ACTIVE
*                                  CPU'S
         ST    R0,SCPLOCK          THIS IS THE LOCK TIME
         SPACE 1
         MVC   SCWTIME,SCPLOCK     SET WAIT TIME TO 'LOCK'
         SPACE 1
***********************************************************************
**                                                                   **
**       DETERMINE IF WE ARE THE ONLY ACTIVE CPU --                  **
**       WRITE A MESSAGE AND GO INTO A LONG WAIT IF SO.              **
**                                                                   **
***********************************************************************
         SPACE 2
         LTR   R1,R1               IS NUMBER OF RESIDUAL CPU'S ZERO?
         BNZR  RLINK               NO, SO QUIT + WRITE BACK CKPT RECORD
         SPACE 1
         SEND  'SCK0010W -- NO OTHER ACTIVE CPU FOUND, WAITING FOR SYNC*
               HRONIZATION',                                           *
               ROUTCDE=(1,2)      ROUTE TO MASTER CONSOLES
         SPACE 2
         MVC   SCWTIME,SCPWAIT     SET TIME TO WAIT
         SPACE 1
         MVI   CKREQ,CKRLWAIT      REQUEST IS TO WAIT
         MVI   CKCREQ,CKCRLW       SO IS CHAR REQUEST
         MVI   CKSSTAT,CKTWAIT     SET OUR STATUS TO "LONG WAIT"
         SPACE 1
         L     R1,SCPMAXC          LOAD MAX NUMBER OF CPU'S
         STH   R1,CKNACPU          SAVE IT IN CHECKPOINT
         STH   R1,CKNRCPU          ALSO SAVE RESIDUAL NUMBER
         SPACE 1
         BR    RLINK               AND RETURN WRITE THE CKPT RECORD
         TITLE '  -- PROCESS A LOCK REQUEST'
***********************************************************************
**                                                                   **
**       LOCK REQUEST                                                **
**                                                                   **
***********************************************************************
         SPACE 1
SCLREQ   DS    0H                  LOCK REQUEST
         SPACE 1
         TM    CKFLAGS,CKFLOCK     ARE ALL CPU'S LOCKED ?
         BO    SCLTIME             YES, PROCESS AFTER ALL ARE LOCKED
         SPACE 1
         CLI   CKSSTAT,CKTLOCK     ARE WE ALREADY LOCKED?
         BER   RLINK               YES, SO RETURN TO CALLER
         SPACE 1
***********************************************************************
**                                                                   **
**       COMPUTE WAIT TIME FOR LOCK STATE (SEEK*NACPU)               **
**                                                                   **
***********************************************************************
         SPACE 2
         L     R0,SCPSEEK          GET SEEK TIME
         MH    R0,CKNACPU          AND MULTIPLY BY NUMBER OF ACTIVE
*                                  CPU'S
         ST    R0,SCPLOCK          THIS IS THE LOCK TIME
         SPACE 1
         MVC   SCWTIME,SCPLOCK     SET WAIT TIME TO 'LOCK'
         MVI   CKSSTAT,CKTLOCK     STATUS IS 'LOCKED'
         SPACE 1
         LH    R1,CKNRCPU          NUMBER OF RESIDUAL CPU'S TO LOCK
         BCT   R1,SCLCNT           NOT THE LAST, CONTINUE
         SPACE 2
***********************************************************************
**                                                                   **
**       WE WERE THE LAST CPU TO GET 'LOCKED'                        **
**                                                                   **
***********************************************************************
         SPACE 1
SCLLAST  DS    0H                  THE LAST CPU GOT LOCKED
         SPACE 2
         MVC   CKNRCPU,CKNACPU     THIS NUMBER OF RESIDUAL I/O BEFORE
*                                  SET IS REACH
         SPACE 1
         STCK  CKSYSCLK            MOVE CLOCK TO CHECKPOINT
         BAL   RLINK2,SCCNORM      GO NORMALIZE THE CLOCK
         SPACE 1
         LH    R1,CKNACPU          GET NUMBER OF ACTIVE CPU'S
         BCTR  R1,R0               SUBSTRACT ONE FROM IT (US)
         STH   R1,CKNRCPU          THIS NUMBER TO GET "TIME" MODE
         SPACE 1
         MVI   CKSSTAT,CKTTIME     SET OUR MODE TO "TIME"
         OI    CKFLAGS,CKFLOCK     AND INDICATE ALL CPU'S LOCKED
         SPACE 1
         BR    RLINK               GO BACK WRITE THE RECORD
         SPACE 2
SCLCNT   DS    0H                  LOCK MUST GO ON
         STH   R1,CKNRCPU          NUMBER OF RESIDUAL CPU'S TO GO
         BR    RLINK               RETURN WRITE THE RECORD
         SPACE 2
***********************************************************************
**                                                                   **
**       ALL CPU'S ARE LOCKED --  TIME SHOULD BE WRITTEN TO CKPT     **
**       TO DETERMINE THE ONE WHO GETS THE "HIGHEST" CLOCK.          **
**                                                                   **
***********************************************************************
         SPACE 2
SCLTIME  DS    0H                  WRITE TIME TO CKPT RECORD
         SPACE 1
         CLI   CKSSTAT,CKTTIME     WE ALREADY GOT TIME MODE?
         BNE   SCLREF              NO SO GO REFRESH CHECKPOINT
         SPACE 1
***********************************************************************
**                                                                   **
**       TIME MODE HAS ALREADY BEEN REACHED PRIOR TO NOW --          **
**                                                                   **
**       THIS  MEANS THAT CPU'S DID NOT READ THE CHECKPOINT          **
**       IN SEQUENTIAL ORDER, SO TIME ACCURACY HAS BEEN LOST         **
**       IN TIME ESTIMATION                                          **
**                                                                   **
**       WRITE A WARNING MESSAGE AND CONTINUE PROCESSING             **
**                                                                   **
***********************************************************************
         SPACE 1
         SEND  'SCK0011W -- TIME ESTIMATION MIGHT NOT BE ACCURATE',    *
               ROUTCDE=(1,2)      ROUTE TO MASTER CONSOLES
         SPACE 1
         BR    RLINK               CONTINUE PROCESSING
         EJECT
***********************************************************************
**                                                                   **
**       REFRESH THE TIME IN CHECKPOINT RECORD                       **
**                                                                   **
***********************************************************************
         SPACE 2
SCLREF   DS    0H                  REFRESH TIME IN CHECKPOINT RECORD
         SPACE 1
         STCK  CKSYSCLK            MOVE CLOCK TO CHECKPOINT RECORD
         BAL   RLINK2,SCCNORM      GO NORMALIZE THE CLOCK
         SPACE 1
         MVI   CKSSTAT,CKTTIME     SET OUR MODE TO "TIME REFRESHED"
         SPACE 1
         LH    R1,CKNRCPU          NUMBER OF RESIDUAL CPU'S TO REFRESH
         BCT   R1,SCLCNT           NOT THE LAST, CONTINUE
         SPACE 1
***********************************************************************
**                                                                   **
**       WE ARE THE LAST CPU TO GET 'REFRESHED'                      **
**       DETERMINE HIGH TIME , SAVE IT IN CHECKPOINT AND             **
**       ASK FOR A "SET TIME" REQUEST.                               **
**                                                                   **
***********************************************************************
         SPACE 1
         XI    CKFLAGS,CKFLOCK     RESET 'LOCK' FLAG
         XC    CKSCLOCK,CKSCLOCK   RESET 'SET CLOCK' FIELD
         SPACE 1
         LH    R1,CKNACPU          LOAD NUMBER OF ACTIVE CPU'S
         SPACE 1
         PUSH  USING               SAVE USING STATUS
         DROP  RSENTRY             FORGET SYSTEM ENTRY ADDRESSABILITY
         LA    R2,CKSENTRY-CHECKPT-L'CKSENTRY(RBCKP)
*                                  POINT TO FIRST CPU ENTRY (- LENGTH)
         USING CKSENTRY,R2         SET ENTRIES ADDRESSABILITY
         SPACE 2
SCLTLP   DS    0H                  GET MAX TIME LOOP
         LA    R2,L'CKSENTRY(R2)   POINT TO NEXT ENTRY
         SPACE 1
         CLI   CKSSTAT,CKTTIME     IS SYSTEM 'REFRESHED'?
         BNE   SCLTLP              NO -- SO LOOP AGAIN
         SPACE 1
         CLC   CKSYSCLK,CKSCLOCK   IS OUR TIME HIGHER THAN THE HIGHEST?
         BNH   *+L'*+6             NO -- SO DO NOT SWAP
         SPACE 1
         MVC   CKSCLOCK,CKSYSCLK   MOVE TIME TO CHECKPOINT
         SPACE 1
         BCT   R1,SCLTLP           LOOP UNTIL ALL ARE SEARCHED
         SPACE 1
         DROP  R2                  NO MORE USED
         POP   USING               RESTORE OLD ADDRESSABILITY
         EJECT
***********************************************************************
**                                                                   **
**       HIGH TIME HAS BEEN PLACED IN CHECKPOINT -- REQUEST SET TIME **
**                                                                   **
***********************************************************************
         SPACE 1
         MVC   CKNRCPU,CKNACPU     NUMBER OF RESIDUAL IS SAME AS TO SET
         SPACE 1
         MVI   CKREQ,CKRSET        REQUEST CODE IS TO 'SET' TIME
         MVI   CKCREQ,CKCRST       SO IS CHAR REQUEST
         BR    RLINK               RETURN WRITE THE RECORD
         SPACE 1
         TITLE '-- PROCESS A SET TIME REQUEST'
***********************************************************************
**                                                                   **
**       REQUEST TO SET TIME                                         **
**       ISSUE 'SET CLOCK' INSTRUCTION.                              **
**                                                                   **
***********************************************************************
         SPACE 2
SCSTIME  DS    0H                  SET TIME REQUEST
         SPACE 1
***********************************************************************
**                                                                   **
**       CHECK FIRST IF WE ARE THE HIGHEST OR IF TIME IS SET         **
**       IF SO , DO NOT SET TIME. ..IT IS ALREADY CORRECT.           **
**                                                                   **
***********************************************************************
         SPACE 1
         CLI   CKSSTAT,CKTSET      ARE WE ALREADY SET?
         BER   RLINK               IF SO, RETURN AT END OF PROCESS
         SPACE 1
         CLC   CKSCLOCK,CKSYSCLK   ARE WE THE HIGHEST?
         BNE   SCSNOTH             NO, SO ISSUE A SET CLOCK INSTRUCTION
         SPACE 1
         SEND  'SCK0014I -- THIS CPU WILL BE USED AS REFERENCE',       *
               ROUTCDE=(1,2)      ROUTE TO MASTER CONSOLES
         SPACE 1
         B     SCSUPD              GO RETURN UPDATE CHECKPOINT
         SPACE 2
***********************************************************************
**                                                                   **
**       GET CLOCK DISCREPANCY AND SAVE IT IN SCDCLOCK               **
**                                                                   **
***********************************************************************
         SPACE 1
SCSNOTH  DS    0H                  WE WERE NOT HIGH CLOCK --
         SPACE 1
         LM    R0,R1,CKSCLOCK      LOAD SYSTEM CLOCK INTO R0,R1 PAIR
         SL    R1,CKSYSCLK+4       SUBSTRACT LOW ORDER CLOCK WORD
         BNM   *+L'*+2             IF NO CARRY, DO NOT INCREMENT HIGH
         SPACE 1
         BCTR  R0,R0               DECREASE HIGH ORDER WORD
         SPACE 1
         SL    R0,CKSYSCLK         SUBSTRACT HIGH ORDER WORD
         STM   R0,R1,SCDCLOCK      SAVE CLOCK DISCREPANCY
         SPACE 1
***********************************************************************
**                                                                   **
**       VALIDATE DISCREPANCY --  IF NOT ACCEPTABLE, SEND WARN MSG   **
**                                                                   **
***********************************************************************
         SPACE 1
         CL    R0,=A(60*&MAXDISC)  IS DISCREPANCY HIGHER THAN     V1.01
*                                  MAXIMUM EXPECTED ?             V1.01
         BL    SCSDEPK             NO, ALL OK TO SET CLOCK        V1.01
         SPACE 1                                                  V1.01
         SEND  'SCK0018W -- DISCREPANCY IS MORE THAN &MAXDISC MINUTES, *
               CLOCK NOT SET',     ADVISE SYSTEM OPERATORS        V1.01*
               ROUTCDE=(1,2)       ROUTE TO MASTER CONSOLES       V1.01
         B     SCSUPD              PROCESS AS IF UPDATED          V1.01
         SPACE 1
***********************************************************************
**                                                                   **
**       WRITE  THE OPERATOR A MSG  TO DEPRESS "CLOCK KEY"           **
**                                                                   **
***********************************************************************
         SPACE 2
SCSDEPK  DS    0H                  REQUEST OPERATOR TO HIT KEY    V1.01
         SPACE 1                                                  V1.01
         SEND  'SCK0015I -- PLEASE, DEPRESS CLOCK KEY',                *
               ROUTCDE=(1,2)      ROUTE TO MASTER CONSOLES
         SPACE 1
***********************************************************************
**                                                                   **
**       ISSUE "SET CLOCK" INSTRUCTION                               **
**       THIS REQUIRES TO BE IN SUPERVISOR MODE.                     **
**                                                                   **
***********************************************************************
         SPACE 2
         AIF   (&TEST).SCNOSUP
         SPACE 1
***********************************************************************
**                                                                   **
**       OBTAIN SUPERVISOR MODE                                      **
**                                                                   **
***********************************************************************
         SPACE  1
         MODESET MODE=SUP          GET SUPERVISOR STATE
         LTR   R15,R15             IS IT RIGHT?
         BZ    SCOKSUP             YES, CONTINUE PROCESSING
         SPACE 1
         SEND  'SCK0002E -- SUPERVISOR MODE COULD NOT BE OBTAINED',    *
               ROUTCDE=(1,2)      ROUTE TO MASTER CONSOLES
         B     SCERR               GO PROCESS THE ERROR
         SPACE 1
SCOKSUP  DS    0H                  ZERO KEY CAN NOW BE OBTAINED
.SCNOSUP ANOP
         SPACE 2
***********************************************************************
**                                                                   **
**       CALCULATE UPDATED CLOCK AND ISSUE SET CLOCK INSTRUCTION     **
**       UNTIL  OPERATOR DEPRESS CLOCK KEY --                        **
**                                                                   **
***********************************************************************
         SPACE 2
SCSSET   DS    0H                  SET CLOCK LOOP
         SPACE 1
         STCK  SCWDBLE             STORE CLOCK IN DOUBLE WORD
         LM    R0,R1,SCWDBLE       LOAD CLOCK IN R0,R1 PAIR
         SPACE 1
         AL    R1,SCDCLOCK+4       ADD CLOCK DISCREPANCY
         BC    12,*+L'*+4          IF CARRY, SHOULD ADD 1 TO HIGH
*                                  WORD OF RESULTANT CLOCK
         SPACE 1
         AL    R0,=A(1)            ADD 1 TO R0
         SPACE 1
         AL    R0,SCDCLOCK         ADD TO HIGH ORDER CLOCK WORD
         STM   R0,R1,SCWDBLE       SAVE CLOCK IN WORK DOUBLEWORD
         SPACE 2
         AIF   (&TEST).NOSCK
         SCK   SCWDBLE             SET CLOCK
         BC    7,SCSSET            IF NOT SET, GO BACK LOOP
         SPACE 2
         MVI   CKSSTAT,CKTSET      SET STATUS TO "TIME SET"       V1.03
         SPACE 1
***********************************************************************
**                                                                   **
**       OBTAIN PROGRAM MODE                                         **
**                                                                   **
***********************************************************************
         SPACE  1
         MODESET MODE=PROB         RESET MODE TO PROBLEM STATE
.NOSCK   ANOP
         EJECT
***********************************************************************
**                                                                   **
**       CLOCK IS UPDATED -- WRITE TIME TO CONSOLE                   **
**                                                                   **
***********************************************************************
         SPACE 1
SCSUPD   DS    0H                  CLOCK IS UPDATED -- WRITE IT BACK
         SPACE 2
         TIME  DEC                 SET TIME IN R0 AND DATE IN R1
*                                  DATE IS IN FORMAT X'00YYDDDF'
*                                  TIME IS IN FORMAT X'HHMMSSTH'
         SPACE 1
         STM   R0,R1,SCWPKBUF      SAVE TIME AND DATE IN PACK FORMAT
         SPACE 1
         LA    R2,SCDMWTO+8        POINT TO MESSAGE
         USING SCDWMSG,R2          SET DUMMY MESSAGE ADDRESSABILITY
         SPACE 2
***********************************************************************
**                                                                   **
**       MOVE DATE TO MESSAGE                                        **
**                                                                   **
***********************************************************************
         SPACE 1
         UNPK  SCWDBLE(5),SCWPKBUF+5(3)
*                                  UNPACK DATE TO WORK FIELD
         SPACE 1
         MVC   SCDWDAT(2),SCWDBLE  MOVE YEAR AND DAY INTO MESSAGE
         MVC   SCDWDAT+3(3),SCWDBLE+2
         SPACE 1
***********************************************************************
**                                                                   **
**       MOVE HOURS, MINUTES AND SECONDS TO MESSAGE                  **
**                                                                   **
***********************************************************************
         SPACE 1
         UNPK  SCWDBLE,SCWPKBUF(4) UNPACK TIME TO WORK FIELD
         SPACE 1
         MVC   SCDWTIM(2),SCWDBLE+1
         MVC   SCDWTIM+3(2),SCWDBLE+3
         MVC   SCDWTIM+6(2),SCWDBLE+5
         SPACE 2
SCDMWTO  SEND  'SCK0017I -- TIME IS NOW  HH.MM.SS, DATE IS YY.DDD',    *
               ROUTCDE=(1,2)      ROUTE TO MASTER CONSOLES
         SPACE 1
         DROP  R2                  DROP MESSAGE ADDRESSABILITY
         SPACE 1
***********************************************************************
**                                                                   **
**       UPDATE THE CHECKPOINT RECORD                                **
**                                                                   **
***********************************************************************
         SPACE 1
         MVC   SCWTIME,SCPTRACK    SET TRACK TIME
         SPACE 1
         LH    R1,CKNRCPU          NUMBER OF CPU'S TO REACH THE "SET"
         SH    R1,=H'1'            MINUS ONE (BECAUSE WE NOW ARE)
         BH    SCWRWT              HIGH, THERE ARE STILL SOME TO RUN
         SPACE 1
         MVI   CKREQ,CKREND        REQUEST IS TO END
         MVI   CKCREQ,CKCRND       REQUEST IS TO END  (CHAR)
         SPACE 2
         MVC   CKNRCPU,CKNACPU     NUMBER OF RESIDUAL IS AS ACTIVE
         BR    RLINK               RETURN WRITE THE UPDATED RECORD
         SPACE 1
SCWRWT   DS    0H
         STH   R1,CKNRCPU          NUMBER OF RESIDUAL CPU'S TO PROCESS
         BR    RLINK               RETURN TO CALLER
         SPACE 2
         TITLE '-- NORMALIZE CLOCK TIME --'
***********************************************************************
**                                                                   **
**       NORMALIZE CLOCK TIME                                        **
**                                                                   **
**       WE MUST NORMALIZE THE TIME BY ADDING TO IT THE 'SEEK' TIME, **
**       MULTIPLIED BY RESIDUAL NUMBER OF I/O BEFORE 'TIME SETTING'. **
**       BIT 51 OF THE CLOCK HAS THE VALUE 1 MICRO SECOND, SO,       **
**       TO BE ACCURATE, SEEK TIME SHOULD BE MULTIPLIED BY 10000     **
**       (TO GIVE IN MICROSECONDS) AND SHIFT LEFT 12 BITS. THIS      **
**       RESULT SHOULD BE ADDED TO SECOND WORD OF THE CLOCK.         **
**                                                                   **
**       -- LINK REGISTER IS RLINK2                                  **
**                                                                   **
**                                                                   **
***********************************************************************
         SPACE 1
SCCNORM  DS    0H                  NORMALIZE CLOCK TIME BEFORE 'SET'
         SPACE 2
         LH    R1,CKNRCPU          GET NUMBER OF RESIDUAL CPU'S.
*                                  THIS IS THE NUMBER OF I/O TO DO
*                                  ON THE CHECKPOINT DATASET BEFORE
*                                  TIME WILL BE SET
         SPACE 1
         XR    R0,R0               CLEAR REGISTER
         M     R0,SCPSEEK          MULTIPLY BY SEEK TIME
         MH    R1,=H'10000'        GET NUMBER OF MICROSECONDS
         SLL   R1,12               AND ALIGN IT TO BIT 51
         SPACE 1
***********************************************************************
**                                                                   **
**       NORMALISATION TIME IS IN R1 -- UPDATE CKSYSCLK FIELD        **
**                                                                   **
***********************************************************************
         SPACE 1
         AL    R1,CKSYSCLK+4       ADD TO TIME TO BE SET
         L     R0,CKSYSCLK         LOAD HIGH CLOCK WORD
         BC    12,*+L'*+4          IF OVERFLOW, SHOULD ADD 1 TO HIGH
*                                  WORD
         SPACE 1
         AL    R0,=A(1)            ADD 1 TO HIGH ORDER CLOCK WORD
         SPACE 1
         STM   R0,R1,CKSYSCLK      AND SAVE IT IN CHECKPOINT
         BR    RLINK2              RETURN TO CALLER
         TITLE '-- RETURN TO CALLER, TERMINATE PROGRAM'
***********************************************************************
**                                                                   **
**       WRITE BACK THE RECORD TO FREE THE LOCK AND RETURN           **
**                                                                   **
***********************************************************************
         SPACE 2
SCRETURN DS    0H                  RETURN TO CALLER
         SPACE 1
         BAL   RLINK,SCWRITE       WRITE THE RECORD
         B     SCERR               IF AN ERROR OCCURS
         SPACE 1
         B     SCRETN              RETURN TO CALLER
         TITLE '-- OBTAIN THE LOCK AND GET THE CHECKPOINT RECORD'
***********************************************************************
**                                                                   **
**       OBTAIN THE LOCK AND GET THE CHECKPOINT RECORD               **
**                                                                   **
***********************************************************************
         SPACE 2
SCGETREC DS    0H                  OBTAIN THE LOCK AND GET THE RECORD
         STM   R14,R12,AREA2+12    SAVE REGISTERS
         SPACE 1
SCGLOOP  DS    0H                  GET RECORD LOOP
         SPACE 1
         LA    R1,SCPLOCK          LOAD THE WAIT TIME ADDRESS
         STIMER WAIT,              WAIT FOR TIME TO ELAPSE             *
               BINTVL=(R1)         ADDRESS SPECIFIED BY R1
         SPACE 2
         MVC   CKHKEY(4),=X'FFFFFFFF'
*                                  MOVE 'LOCK' KEY INTO BUFFER
         MVC   CKLKSID,SCSYSID     AND ALSO SYSTEM ID (HOLDING)
         SPACE 1
         LA    RPARM,CPRDCK        'READ THE CHECKPOINT RECORD' CCW
         SPACE 1
         BAL   RLINK,EXCP          READ THE CHECKPOINT RECORD
         SPACE 1
         B     SCGTERR             GET ERROR
         SPACE 1
***********************************************************************
**                                                                   **
**       READ WAS SUCCESSFUL -- SEE IF THE CHECKPOINT IS FREE        **
**                                                                   **
***********************************************************************
         SPACE 2
         CLC   CKLKSID,SCSYSID     IS THE KEY OBTAINED?
         BNE   SCGLOOP             NO, SO TRY AGAIN
         SPACE 1
         LM    R14,R12,AREA2+12    LOAD BACK CALLERS' REGISTERS
         B     4(RLINK)            RETURN TO CALLER
         SPACE 1
SCGTERR  DS    0H                  GET ERROR
         SPACE 1
         LM    R14,R12,AREA2+12    LOAD BACK CALLERS' REGISTERS
         BR    RLINK               RETURN TO CALLER -- ERROR OFFSET
         EJECT
***********************************************************************
**                                                                   **
**       'READ CHECKPOINT RECORD'  CCW -- OBTAIN THE LOCK IF FREE    **
**                                                                   **
***********************************************************************
         SPACE 1
CPRDCK   DS    0D
         CCW   CWSKHD,CPSEEKBB,CWCC,6      - SEEK HEAD
         CCW   CWSIDEQ,CPSEEKCC,CWCC,5     - SEARCH ID EQUAL
         CCW   CWTIC,*-8,CWCC,1            - TIC *-8
         CCW   CWSKEYEQ,CPKFREE,CWCC,8     - SEARCH KEY EQUAL
         CCW   CWTIC,CPLOCKED,CWCC,1       - TIC CPLOCKED  (NOT FOUND)
         SPACE 1
         CCW   CWRDDATA,*-*,CWCC,CKLEN-8   - READ DATA
CPRBUF1  EQU   *-8+1,3,C'A'                DATA ADDRESS (TO BE READ)
         SPACE 1
         CCW   CWSKHD,CPSEEKBB,CWCC,6      - SEEK HEAD
         CCW   CWSIDEQ,CPSEEKCC,CWCC,5     - SEARCH ID EQUAL
         CCW   CWTIC,*-8,CWCC,1            - TIC *-8
         CCW   CWWRKD,*-*,0,CKLEN          - WRITE KEY AND DATA (STOP)
CPRBUF2  EQU   *-8+1,3,C'A'                DATA/KEY ADDRESS TO WRITE
         SPACE 1
CPLOCKED CCW   CWSKHD,CPSEEKBB,CWCC,6      - SEEK HEAD
         CCW   CWSIDEQ,CPSEEKCC,CWCC,5     - SEARCH ID EQUAL
         CCW   CWTIC,*-8,CWCC,1            - TIC *-8
         CCW   CWRDKDT,*-*,0,CKLEN         - READ KEY AND DATA
CPRBUF3  EQU   *-8+1,3,C'A'                KEY/DATA ADDRESS
         TITLE '-- WRITE THE CHECK POINT RECORD AND RELEASE THE LOCK'
***********************************************************************
**                                                                   **
**       WRITE THE CKECKPOINT RECORD AND RELEASE THE LOCK            **
**                                                                   **
***********************************************************************
         SPACE 2
SCWRITE  DS    0H                  WRITE THE RECORD AND RELEASE THE
*                                  LOCK
         STM   R14,R12,AREA2+12    SAVE REGISTERS
         SPACE 1
         XC    CKHKEY,CKHKEY       CLEAR FREE LOCK
         SPACE 1
         MVC   CPSEEKCW,CPSEEKCC   INIT SEEK ADDRESS
         MVI   CPSEEKCW+4,X'00'    BUT SEARCH FOR RECORD ZERO
         SPACE 1
         LA    RPARM,CPWRCK        WRITE RECORD CCW
         BAL   RLINK,EXCP          WRITE THE RECORD
         SPACE 1
         B     SCWERR              WRITE ERROR
         SPACE 1
         LM    R14,R12,AREA2+12    LOAD BACK CALLERS' REGISTERS
         B     4(RLINK)            RETURN TO CALLER
         SPACE 1
SCWERR   DS    0H                  WRITE ERROR
         SPACE 1
         LM    R14,R12,AREA2+12    LOAD BACK CALLERS' REGISTERS
         BR    RLINK               RETURN TO CALLER -- ERROR OFFSET
         SPACE 2
***********************************************************************
**                                                                   **
**       'WRITE CHECKPOINT RECORD' CCW                               **
**                                                                   **
***********************************************************************
         SPACE 1
CPWRCK   DS    0D
         CCW   CWSKHD,CPSEEKBB,CWCC,6        - SEEK HEAD
         CCW   CWSIDEQ,CPSEEKCW,CWCC,5       - SEARCH ID EQUAL
         CCW   CWTIC,*-8,CWCC,1              - TIC *-8
         CCW   CWWRCKD,*-*,0,CKLEN+L'SCCKCNT - WRITE COUNT KEY AND DATA
         SPACE 1
CPWBUFA  EQU   *-8+1,3,C'A'                  DATA ADDRESS
         TITLE '-- READ AND INITIALIZE THE INPUT PARAMETERS '
***********************************************************************
**                                                                   **
**       READ AND INITIALIZE THE INPUT PARAMETERS                    **
**                                                                   **
**       THIS  SUBROUTINE WILL SET DEFAULT PARAMETERS. IT WILL       **
**       THEN OPEN PARMLIB DATASET AND READ THE SPECIFIED            **
**       PARAMETERS. IF NO &SETPARM DDNAME IS ALLOCATED, DEFAULTS    **
**       PARAMETERS ONLY WILL BE USED (AND MESSAGE WILL BE ISSUED)   **
**                                                                   **
**       IF ANY ERROR IS ENCOUNTERED WITHIN THE PARAMETERS,          **
**       MESSAGE IS PRINTED AND EXECUTION IS TERMINATED.             **
**                                                                   **
***********************************************************************
         SPACE 2
READPARM DS    0H                  READ AND INITIALISE THE INPUT PARMS
         SPACE 1
         STM   R14,R12,12(R13)    SAVE REGISTERS
         SPACE 1
         LA    R15,AREA2          POINT TO OUR SAVE AREA
         ST    R13,4(R15)         SAVE CALLER'S SAVEAREA ADDRESS
         ST    R15,8(R13)         AND CHAIN BACK SAVEAREAS
         LR    R13,R15            AND FINALLY GET OUR SAVEAREA POINTER
         SPACE 1
***********************************************************************
**                                                                   **
**       INITIALIZE PARAMETERS BY SETTING DEFAULTS.                  **
**                                                                   **
***********************************************************************
         SPACE 1
         MVC   SCPMAXC,=A(MAXCPUD)  -- MAX NUMBER OF CPU'S
         MVC   SCPWAIT,=A(LONGWT)   -- LONG WAIT DEFAULT
         MVC   SCPTRACK,=A(TRAKWT)  -- TRACK WAIT DEFAULT
         MVC   SCPSEEK,=A(SEKTIM)   -- SEEK TIME
         MVC   SCPDISC,=A(DISTIME)  -- DISCONNECT TIME
         SPACE 1
         CALL  LPARMS             LOAD INPUT PARAMETERS
         SPACE 1
***********************************************************************
**                                                                   **
**       LOAD INPUT PARAMETERS                                       **
**                                                                   **
***********************************************************************
         SPACE 1
         B     READPXIT           EXIT, SUCCESSFULL
         SPACE 1
         L     RSAVE,4(RSAVE)      LOAD BACK PREVIOUS SAVE AREA
         LM    R14,R12,12(RSAVE)   RELOAD REGISTERS
         B     0(RLINK)            RETURN AFTER ERROR IN PARMS DATASET
         SPACE 1
***********************************************************************
**                                                                   **
**       COMPUTE INITIAL LOCK WAIT TIME AND RETURN                   **
**                                                                   **
***********************************************************************
         SPACE 1
READPXIT DS    0H                 NORMAL EXIT (0 RETURN CODE)
         L     R1,SCPSEEK         GET SEEK TIME
         MH    R1,SCPMAXC+2       MULTIPLY BY MAX NUMBER OF CPU'S
         ST    R1,SCPLOCK         THIS IS COMPUTED LOCK TIME
         SPACE 1
         L     RSAVE,4(RSAVE)      LOAD BACK PREVIOUS SAVE AREA
         LM    R14,R12,12(RSAVE)   RELOAD REGISTERS
         B     4(RLINK)            RETURN OK
         TITLE '-- ERROR ENCOUNTERED -- RETURN TO CALLER'
***********************************************************************
**                                                                   **
**       PROCESS ERROR                                               **
**                                                                   **
***********************************************************************
         SPACE 2
SCERR    DS    0H                  PROCESS ERROR
         SPACE 1
         SEND  'SCK0008I -- ERROR  ENCOUNTERED, PROCESS ENDED',        *
               ROUTCDE=(1,2)      ROUTE TO MASTER CONSOLES
         SPACE 2
***********************************************************************
**                                                                   **
**       PROGRAM TERMINATION                                         **
**                                                                   **
***********************************************************************
         SPACE 2
SCRETN   DS    0H                  RETURN TO CALLER
         SPACE 1
         L     RSAVE,AREA+4        LOAD BACK SAVE REGISTER
         LM    R14,R12,12(RSAVE)   AND THE CALLER'S REGISTERS
         XR    RCODE,RCODE         SET RETURN CODE TO ZERO
         SPACE 1
         BR    RLINK               RETURN TO CALLER
         TITLE '-- E X C P  -- EXECUTE THE SPECIFIED CHANNEL PROGRAM'
***********************************************************************
**                                                                   **
**       EXECUTE THE CHANNEL PROGRAM                                 **
**                                                                   **
**           THE PURPOSE OF THIS ROUTINE IS TO INTERFACE WITH        **
**       THE OPERATING SYSTEM TO DO I/O ON THE CKECKPOINT DATASET.   **
**                                                                   **
**           WHEN CONTROL WILL BE RETURNED TO THE CALLER,            **
**       THE I/O WILL BE COMPLETED SINCE CPEXCP ISSUES A             **
**       'WAIT' SVC UNTIL COMPLETION OF THE I/O OPERATION.           **
**                                                                   **
**       PARAMETERS :                                                **
**                                                                   **
**           INPUT: RPARM -  POINTS TO THE CHANNEL PROGRAM TO        **
**                           BE EXECUTED.                            **
**                                                                   **
**           OUTPUT: RETURN LOCATION DEPENDS UPON I/O COMPLETION     **
**                                                                   **
**                           0(RLINK)  UNCORRECTABLE I/O ERROR       **
**                           4(RLINK)  SUCCESSFULL                   **
**                                                                   **
***********************************************************************
         SPACE 2
EXCP     DS    0H                 ENTRY POINT
         SPACE 1
         ST    RLINK,CPXSAVE      SAVE LINK REGISTER
         STM   R2,R5,CPXSAVE+4    AND SOME OTHER REGISTERS
         SPACE 1
         LA    R3,SCIOB           IOB ADDRESS
         USING IOBSTDRD,R3        SET ADDRESSABLILTY OF DSECT
         SPACE 1
         XC    SCECB,SCECB        CLEAR EVENT CONTROL BLOCK
         XC    IOBSENS0(2),IOBSENS0
*                                 CLEAR SENS BYTES
         MVI   IOBECBCC,X'00'     CLEAR CONDIITON CODE IN IOB
         XC    IOBCSW,IOBCSW      CLEAR CSW
         SPACE 1
         ST    RPARM,IOBSTART     SET CHANNEL PROGRAM ADDRESS
         MVC   IOBSEEK,CPSEEK     MOVE SEEK ADDRESS IN IOB
         SPACE 1
***********************************************************************
**                                                                   **
**       EXECUTE THE I/O AND WAIT FOR COMPLETION                     **
**                                                                   **
***********************************************************************
         SPACE 1
         LA    RPARM,SCIOB        LOAD IOB ADDRESS IN PARM REGISTER
         EXCP  (1)                EXECUTE CHANNEL PROGRAM
         SPACE 1
         WAIT  ECB=SCECB          WAIT FOR THE I/O COMPLETION
         SPACE 1
***********************************************************************
**                                                                   **
**       ANALYZE  I/O COMPLETION CODES AND RETURN TO CALLER          **
**                                                                   **
***********************************************************************
         SPACE 1
         CLI   SCECB,ECBNORM      NORMAL COMPLETION?
         BE    SCRT               RETURN TO CALLER IF SO
         SPACE 1
         CLI   SCECB,ECBPERR      INDICATING PERMANENT I/O ERROR?
         BE    SCNOTFND           YES, MAY BE NOT FOUND
         SPACE 1
         CLI   SCECB,ECBDAEA      DID WE HAVE AN END OF EXTEND?
         BNE   SCIOERR            NO, MEANS I/O ERROR
         SPACE 1
         TM    IOBSENS1,IOBS1B2   TEST FOR AN END OF CYLINDER
         BZ    SCIOERR            NO, I/O ERROR
         SPACE 1
SCNOTFND DS    0H                 RECORD MAY BE NOT FOUND
         SPACE 1
         XR    R1,R1              CLEAR REGISTER
         ICM   R1,B'0111',IOBCMDA POINT TO COMMAND WORD
         CLI   0(R1),CWTIC        IS IT A TIC?
         BNE   SCIOERR            NO, I/O ERROR
         SPACE 1
         SH    R1,=H'8'           POINT TO COMMAND
         TM    0(R1),X'21'        ONE OF THE SEARCH CMDS?
         BO    SCRT               YES, RETURN, NOT FOUND
         SPACE 1
***********************************************************************
**                                                                   **
**       PERMANENT I/O ERROR ON THE CHECKPOINT DATASET               **
**       RETURN TO CALLER WITH ERROR OFFSET.                         **
**                                                                   **
***********************************************************************
         SPACE 1
SCIOERR  DS    0H                 I/O ERROR ENTRY
         SPACE 1
         SEND  'SCK0007E -- I/O ERROR ON THE CHECKPOINT DATASET',      *
               ROUTCDE=(1,2)      ROUTE TO MASTER CONSOLES
         SPACE 1
         L     RLINK,CPXSAVE      RESTORE LINK REGISTER
         LM    R2,R5,CPXSAVE+4    AND SOME OTHER
         BR    RLINK              RETURN TO CALLER WITH ERROR
         EJECT
***********************************************************************
**                                                                   **
**       I/O TERMINATED NORMALLY : RETURN TO CALLER                  **
**                                                                   **
***********************************************************************
         SPACE 2
SCRT     L     RLINK,CPXSAVE      RESTORE LINK REGISTER
         LM    R2,R5,CPXSAVE+4    AND SOME OTHER
         B     4(RLINK)           RETURN TO CALLER (GOOD)
         SPACE 1
         TITLE '-- E X C P -- DATA AREAS AND EXECUTED INSTRUCTIONS'
         SPACE 1
***********************************************************************
**                                                                   **
**       I/O ROUTINE EQUATES                                         **
**                                                                   **
***********************************************************************
         SPACE 1
ECBNORM  EQU   X'7F'              NORMAL COMPLETION
ECBPERR  EQU   X'41'              PERMANENT ERROR COMPLETION
ECBDAEA  EQU   X'42'              END OF EXTENT COMPLETION
         SPACE 2
***********************************************************************
**                                                                   **
**       DATA  AREAS AND CONSTANTS                                   **
**                                                                   **
***********************************************************************
         SPACE 1
SCECB    DC    F'0'               EVENT CONTROL BLOCK FOR I/O
         SPACE 1
CPXSAVE  DS    (1+4)F             CPEXCP SAVE AREA
         SPACE 2
***********************************************************************
**                                                                   **
**       EXCP PARAMETER BLOCK (IOB)                                  **
**                                                                   **
***********************************************************************
         SPACE 2
SCIOB    DC    0F'0'              BEGINNING OF IOB
         DC    AL1(IOBDATCH+IOBCMDCH+IOBUNREL,0,0,0)
         DC    A(SCECB)           ECB PTR
         DC    A(00,00)
         DC    A(*-*)             START OF CH. PROG.
         DC    A(SYSCKPT)         DCB ADDRESS
         DC    A(00,00)
         DC    XL8'00'            IOBSEEK
         SPACE 2
         TITLE '-- E X C P --  DATA AREAS AND EXECUTED INSTRUCTIONS --'
***********************************************************************
**                                                                   **
**              DATA AREAS AND EXECUTED INSTRUCTIONS                 **
**                                                                   **
***********************************************************************
         SPACE 2
CPSEEK   DC    0D'0'              SEEK ADDRESS FOR IOB
         SPACE 1
CPSEEKM  DC    FL1'0'             -- EXTEND NUMBER: ZERO
CPSEEKBB DC    FL2'0'             -- BINARY NUMBER: ZERO
CPSEEKCC DC    XL2'0000'          -- CYLINDER NUMBER
CPSEEKHH DC    XL2'0000'          -- HEAD NUMBER
CPSEEKR  DC    XL1'00'            -- RECORD NUMBER
         SPACE 1
CPSEEKCW DS    XL5                 SEEK ADDRESS FOR WRITE (RECORD 0)
         EJECT
***********************************************************************
**                                                                   **
**       CCW EQUATES  -- CHANNEL COMMAND CODES                       **
**                                                                   **
***********************************************************************
         SPACE 1
CWSKHD   EQU   X'1B'              --  SEEK HEAD
CWSSCTR  EQU   X'23'              --  SET SECTOR
CWSHOME  EQU   X'39'              --  SEARCH HOME ADDRESS
CWSIDEQ  EQU   X'31'              --  SEARCH ID EQUAL
CWSKEYEQ EQU   X'29'              --  SEARCH KEY EQUAL
CWSKHIGH EQU   X'49'              --  SEARCH KEY HIGH
CWSKHEQ  EQU   X'69'              --  SEARCH KEY HIGH OR EQUAL
CWRDCNT  EQU   X'12'              --  READ COUNT
CWRDDATA EQU   X'06'              --  READ DATA
CWRDKDT  EQU   X'0E'              --  READ KEY AND DATA
CWRDCKD  EQU   X'1E'              --  READ COUNT, KEY AND DATA
CWWRCKD  EQU   X'1D'              --  WRITE COUNT, KEY AND DATA
CWWRDAT  EQU   X'05'              --  WRITE DATA
CWWRKD   EQU   X'0D'              --  WRITE KEY AND DATA
CWTIC    EQU   X'08'              --  TRANSFER IN CHANNEL
CWNOP    EQU   X'03'              --  NO OPERATION
         SPACE 1
CWMTRK   EQU   X'80'              MULTI TRACK FEATURE BIT
         SPACE 2
***********************************************************************
**                                                                   **
**       CCW EQUATES  -- FLAGS                                       **
**                                                                   **
***********************************************************************
         SPACE 1
CWCD     EQU   X'80'              --  CHAIN ON DATA
CWCC     EQU   X'40'              --  CHAIN ON COMMAND
CWSILI   EQU   X'20'              --  SUPPRESS INCORRECT LENGTH
CWSKIP   EQU   X'10'              --  SUPPRESS TRANSFER OF
*                                     INFORMAITON TO MAIN STORAGE
CWPCI    EQU   X'08'              --  PROGRAM CONTROLLED
*                                     INTERRUPTION
         EJECT
***********************************************************************
**                                                                   **
**       LITTERAL POOL FOR "EXCP"                                    **
**                                                                   **
***********************************************************************
         SPACE 1
         LTORG ,                   EXCP LITTERAL POOL
         TITLE '-- D C B S -- PROGRAM DATA CONTROL BLOCKS'
***********************************************************************
**                                                                   **
**       DCB USED TO PROCESS CHECKPOINT DATASET                      **
**                                                                   **
***********************************************************************
         SPACE 1
         PUSH  PRINT               SAVE PRINT STATUS
         PRINT  ON,NOGEN           DO NOT EXPAND THE MACRO
         SPACE 2
SYSCKPT  DCB   DDNAME=&SYSCKPT,    CHECKPOINT DDNAME                   +
               MACRF=(E),          USING 'EXCP'                        +
               RECFM=F,            FIXED LENGTH RECORD                 +
               DSORG=DA,           DIRECT ACCESS DATASET               +
               KEYLEN=8            USE A 8 BYTES KEY (LOCK INDICATOR)
         POP   PRINT               RESTORE PRINT STATUS
         SPACE 2
         TITLE '-- CONSTANTS, TABLES AND EXECUTED INSTRUCTIONS'
***********************************************************************
**                                                                   **
**       CONSTANTS, TABLES AND EXECUTED INSTRUCTIONS                 **
**                                                                   **
***********************************************************************
         SPACE 1
SCXTBL   SETCTRT ,                 GENERATE SID SEARCH TABLE
         SPACE 2
CPKFREE  DC    X'0000000000000000' FREE CHECKPOINT RECORD KEY
         SPACE 2
RESET    DC    C'RESET'            RESET KEY WORD
SCBL     DC    CL8' '              8 BLANKS
         SPACE 2
SCKLDL   DC    AL1(L'CKHKEY)       LENGTH COUNT FIELD -- KEY
         DC    AL2(CKLEN-L'CKHKEY)                    -- DATA
         TITLE '-- L P A R M S  --  LOAD INPUT PARAMETERS --'
         SPACE 3
***********************************************************************
**                                                                   **
**                     ----  L P A R M S  ----                       **
**                                                                   **
**           THIS SUBROUTINE, CALLED BY UTILITIES PROCESSOR, WILL    **
**       LOAD INPUT PARAMETERS SPECIFIED BY PARMLIB DATASET.         **
**                                                                   **
**             -- INPUT : RPARM    N/A                               **
**                        RLINK    RETURN ADDRESS                    **
**                                                                   **
**             -- OUTPUT: RCODE = 0  PARMS SUCCUSSFULLY READ         **
**                        RCODE = 4  PARMS ERROR ENCOUNTERED         **
**                                                                   **
**                                                                   **
***********************************************************************
         SPACE 2
***********************************************************************
**                                                                   **
**       LOAD PARM TEXT INITIALISATION                               **
**                                                                   **
***********************************************************************
         SPACE 1
LPARMS   $SUB  ,                   LOAD INPUT PARAMETERS SUBROUTINE
         EJECT
         SPACE 1
***********************************************************************
**                                                                   **
**       TRY TO OPEN PARMLIB DATASET. IF OPEN FAILS, SEND MSG        **
**       AND USE DEFAULTS                                            **
**                                                                   **
***********************************************************************
         SPACE 1
         OPEN  (SETPARM,INPUT)    OPEN PARMLIB , INPUT MODE
         SPACE 1
         TM    SETPARM+DCBOFLGS-IHADCB,DCBOFOPN
*                                  DID THE DATASET OPENED PROPERLY?
         BO    LPAPGET             YES, CONTINUE PROCESSING
         SPACE 2
         SEND  'SCK0009E -- SETPARM NOT ALLOCATED, USING DEFAULTS',    *
               ROUTCDE=(1,2)      ROUTE TO MASTER CONSOLES
         B     LPAPEOD            RETURN USING DEFAULTS
         SPACE 1
***********************************************************************
**                                                                   **
**       SYSPARM DATASET SUCCESSFULLY OPENED                         **
**                                                                   **
***********************************************************************
         SPACE 1
LPAPGET  DS    0H                  GET INPUT CARD
         SPACE 1
         GET   SETPARM             GET INPUT CARD WITH QSAM
         MVC   SCPSTCB+SBTXT-SCANTCB(L'SBTXT),0(R1)
*                                  MOVE BUFFER TO SCAN TEXT CTL BLOCK
         LH    R1,SETPARM+DCBLRECL-IHADCB
*                                  GET TOTAL RECORD LENGTH
         SH    R1,=H'8'            SUBSTRACT SEQUENCE FIELD LENGTH
         STH   R1,SCPSTCB+SBTXTLN-SCANTCB
*                                  SAVE LENGTH TO BE SCANNED IN STCB
         SPACE 1
LPAPSCN  DS    0H                  PARSE A KEYWORD FROM TEXT BUFFER
         LA    RPARM,SCPSTCB       POINT TO SCANTCB
         CALL  RDPARM              READ PARAMETER LINE
*
         B     LPAPSCN             GO SCAN NEW KEYWORD WITHIN BUFFER
         B     LPAPGET             GO GET NEW BUFFER
*
         OI    SCPFLAGS,SCPFPERR   INDICATE PARSE ERROR
         B     LPAPSCN             CONTINUE SCAN WITHIN SAME BUFFER
         SPACE 1
***********************************************************************
**                                                                   **
**       END OF FILE ENCOUNTERED ON PARMLIB DATASET                  **
**       -- FREE/CLOSE IT AND RETURN TO CALLER WITH RCODE ZERO       **
**                                                                   **
***********************************************************************
         SPACE 1
LPAPEOD  DS    0H                  END OF DATA ON PARMLIB DATASET
         SPACE 1
         CLOSE SETPARM             CLOSE/FREE DCB
         SPACE 1
         XR    RCODE,RCODE         CLEAR RETURN CODE
         SPACE 1
         TM    SCPFLAGS,SCPFPERR   TEST IF ANY PARSE ERROR
         BZ    LPAEXIT             NONE, EXIT RETURN CODE ZERO
         SPACE 1
         LA    RCODE,4             SET RETURN CODE = 4
         SPACE 1
LPAEXIT  $SUBRET                   RETURN TO CALLER
         TITLE '--  L P A R M S  -- DATA CONTROL BLOCKS DEFNITIONS --'
***********************************************************************
**                                                                   **
**       DATA CONTROL BLOCKS DEFINITIONS AND CONSTANTS               **
**                                                                   **
***********************************************************************
         SPACE 1
         PUSH  PRINT               SAVE PRINT STATUS
         PRINT  ON,NOGEN           DO NOT EXPAND THE MACROS
         SPACE 1
SETPARM  DCB   DDNAME=&SETPARM,    PARAMETER LIBRARY DDNAME            *
               MACRF=(GL),         USING GET LOCATE                    *
               RECFM=FB,           FIXED BLOCKED RECORDS               *
               EODAD=LPAPEOD,      WHEN END REACHED                    *
               DSORG=PS            SEQUENTIAL
         SPACE 1
         POP   PRINT               RESTORE PRINT STATUS
         SPACE 1
***********************************************************************
**                                                                   **
**       LITERAL POOL FOR LPARMS                                     **
**                                                                   **
***********************************************************************
         SPACE 1
         LTORG ,                   LITERAL POOL
         TITLE '-- R D P A R M --  READ A PARAMETERS LINE --'
         SPACE 3
***********************************************************************
**                                                                   **
**                     ----  R D P A R M  ----                       **
**                                                                   **
**           THIS SUBROUTINE WILL READ AND PRINT THE PARAMETER       **
**       SPECIFIED BY INPUT REGISTER.                                **
**                                                                   **
**                                                                   **
**             -- INPUT : RPARM    POINTER TO "READY" SCAN TCB       **
**                        RLINK    RETURN ADDRESS                    **
**                        SCPFLAGS IN REQWA IS SET TO 1 IF WE        **
**                                 + ARE ENTERING FOR SAME KEYWORD   **
**                                                                   **
**             -- OUTPUT: MESSAGE IS SENT TO OPERAROR FOR PARAMETER  **
**                                                                   **
**                        RCODE = 0  KEYWORD COMPLETELY PARSED       **
**                        RCODE = 4  NEW TEXT LINE IS EXPECTED       **
**                                   TO CONTINUE PARSING             **
**                        RCODE = 8  PARSE ERROR                     **
**                                                                   **
***********************************************************************
         SPACE 1
***********************************************************************
**                                                                   **
**       LOCAL VARIABLES DEFINITIONS                                 **
**                                                                   **
***********************************************************************
         SPACE 2
PARMDS   DSECT
         SPACE 1
PRMFLAGS DS    FL1                 FLAGS BYTE
*
PRMFCOM  EQU   B'00000001'         WHEN SCANNING MULTI-DECIMAL VALUE
*                                  + A COMMA WAS LAST ENCOUNTERED
         SPACE 1
PRMCBUF  DS    X                   CONVERSION BUFFER
PARMDLN  EQU   *-PARMDS
         EJECT
***********************************************************************
**                                                                   **
**       READ PARM TEXT INITIALISATION                               **
**                                                                   **
***********************************************************************
         SPACE 1
RDPARM   $SUB  PARMDS,PARMDLN      READ A PARAMETERS LINE
         SPACE 1                   POINT TO LAST CHARACTER OF VARIABLE
         LR    R6,RPARM            POINT TO SCAN TXT CTL BLOCK
         USING SCANTCB,R6          SET ADDRESSABILITY
         SPACE 1
         TM    SCPFLAGS,SCPFCNT    NEW KEYWORD PARSE EXPECTED ?
         BZ    RDPSCAN             YES, GO FOR IT
         SPACE 1
         LM    R0,R5,SCPRDSA       RELOAD REGISTERS TO CONTINUE PARSE
         BR    R3                  GO PROCESS IT WITH NEW TEXT BUFFER
         EJECT
***********************************************************************
**                                                                   **
**       SCAN LINE FOR ANY OF THE KEYWORDS IN TABLE                  **
**                                                                   **
***********************************************************************
         SPACE 1
RDPSCAN  DS    0H                  CALL SCAN INTERFACE
         BALR  R3,R0               SET RESTART ADDRESS IN CASE OF EOD
         SPACE 1
         LR    RPARM,R6            LOAD SCANTCB ADDRESS
         CALL  SCAN                CALL SCANNER
         SPACE 1
         B     RDPGKW              GO SEARCH FOR KEYWORD
         B     RDGKERR             HEX -- SHOULD NOT OCCUR
         B     RDGKERR             DEC -- SHOULD NOT OCCUR
         B     RDGKERR             DLM -- SHOULD NOT OCCUR
         B     RDGKERR             STRING -- SHOULD NOT OCCUR
         B     *-*                 RESERVED
         B     RDPCNT              END OF TEXT -- PREPARE TO CONTINUE
         B     RDGKERR             ERROR OCCURED
         SPACE 1
***********************************************************************
**                                                                   **
**       FIND KEYWORD FROM TABLE                                     **
**                                                                   **
***********************************************************************
         SPACE 1
RDPGKW   DS    0H                  GET KEYWORD FROM TABLE
         PUSH  USING               SAVE CURRENT USING STATUS
         LA    R5,RDPKVTBL         POINT TO KEYWORDS TABLE
         USING RDPKVTBL,R5         SET TABLE ENTRY ADDRESSABILITY
         SPACE 1
RDPGETKW DS    0H                  GET KEYWORD
         CH    R0,RDPKLN           POSSIBLE LENGTH (NOT HIGHER?)
         BH    RDKNEXT             NO, SKIP TO NEXT
         SPACE 1
         L     R2,RDPKSA           GET SYMBOL ADDRESS
         LR    R3,R0               AND IT'S LENGTH
         SPACE 1
         BCTR  R3,R0               DECREASE COUNT BY ONE FOR EXECUTE
         EX    R3,RDPKCLC          COMPARE KEYWORDS
         BE    RDPKFND             EQUAL, FOUND
         SPACE 1
RDKNEXT  DS    0H                  TRY WITH NEXT KEYWORD
         TM    RDPKVTBL,X'80'      END OF TABLE ?
         BO    RDGKNF              YES, KEYWORD NOT FOUND
         SPACE 1
         LA    R5,RDPKELN(R5)      POINT TO NEXT ENTRY
         B     RDPGETKW            AND TRY AGAIN
         EJECT
***********************************************************************
**                                                                   **
**       EXPECTED KEYWORD WAS FOUND, SCAN FOR '=' AND VALUE          **
**                                                                   **
***********************************************************************
         SPACE 2
RDPKFND  DS    0H                  EXPECTED KEYWORD FOUND
         BALR  R3,R0               SET RESTART ADDRESS IN CASE OF EOD
         SPACE 1
         LR    RPARM,R6            LOAD SCANTCB ADDRESS
         CALL  SCAN                CALL SCANNER
         SPACE 1
         B     RDGDERR             GO SEARCH FOR KEYWORD
         B     RDGDERR             HEX -- SHOULD NOT OCCUR
         B     RDGDERR             DEC -- SHOULD NOT OCCUR
         B     RDPEQU              EQUAL SIGN IS EXPECTED
         B     RDGDERR             STRING -- SHOULD NOT OCCUR
         B     *-*                 RESERVED
         B     RDPCNT              END OF TEXT -- PREPARE TO CONTINUE
         B     RDGDERR             ERROR OCCURED
         SPACE 1
RDPEQU   DS    0H                  '=' SIGN EXPECTED
         SPACE 1
         CLI   0(R1),C'='          IS IT FOUND ?
         BNE   RDGDERR
         SPACE 1
***********************************************************************
**                                                                   **
**       SCAN FOR VALUE ASSOCIATED WITH KEYWORD                      **
**                                                                   **
***********************************************************************
         SPACE 1
         BALR  R3,R0               SET RESTART ADDRESS IN CASE OF EOD
         SPACE 1
         LR    RPARM,R6            LOAD SCANTCB ADDRESS
         CALL  SCAN                SCAN FOR ASSOCIATED VALUE
RDPKVAL  DS    0H                  VALUE BRANCH OPTION
*
         B     RDPVERR             GOT A SYMBOL -- ERROR
         B     RDPVERR             HEX -- ERROR
         B     RDPVDEC             DEC -- DECIMAL VALUE
         B     RDPVDLM             DLM -- MULTI-NUMERIC VALUES
         B     RDPVSTR             STR -- STRING  VALUE
         B     *-*                 RESERVED
         B     RDPCNT              END OF TEXT, VALUE NOT SUPPLIED
         B     RDPVERR             ERROR ENCOUNTERED
         EJECT
***********************************************************************
**                                                                   **
**       SYMBOL (STRING) VALUE VALIDATION ROUTINE                    **
**                                                                   **
***********************************************************************
         SPACE 1
RDPVSTR  DS    0H                  STRING VALUE VALIDATION ROUTINE
         SPACE 1
         CH    RCODE,RDPKVT        IS EXPECTED TYPE FOUND ?
         BNE   RDPVERR             NO, MEANS ERROR
         CH    R0,=Y(L'DS1DSNAM+2) IS IT MORE THAN 44 CHARACTERS ?
         BH    RDPVERR             YES, VALUE LENGTH ERROR
         SPACE 1
*        MVI   WRKPNAM,C' '        MOVE IN A BLANK
*                                  + AND PROPAGATE IT ACROSS NAME
*        MVC   WRKPNAM+1(L'WRKPNAM-1),WRKPNAM
*                                  CLEAR OUT DATABASE NAME (BLANKS)
         SPACE 1
         LR    R2,R0               SET NAME LENGTH FOR EXECUTE
         SH    R2,=H'3'            + AND SUBSTRACT 1+2 (EX AND QUOTES)
         SPACE 1
*        EX    R2,RDPNMVC          MOVE DATASET NAME
         B     RDPEXIT             AND RETURN TO CALLER
         EJECT
***********************************************************************
**                                                                   **
**       NUMERIC VALUE VALIDATION ROUTINE                            **
**                                                                   **
***********************************************************************
         SPACE 1
RDPVDEC  DS    0H                  DECIMAL SYMBOL VALIDATION ROUTINE
         SPACE 1
         CH    RCODE,RDPKVT        IS EXPECTED TYPE FOUND ?
         BNE   RDPVERR             NO, MEANS ERROR
         SPACE 1
         LR    R2,R0               SET LENGTH FOR EXECUTE
         BCTR  R2,R0               + AND DECREASE BY ONE
         EX    R2,RDPVPAK          PACK VALUE TO WORK BUFFER
         CVB   R0,SCWDBLE          CONVERT VALUE TO BINARY INTO R0
         SPACE 1
         LH    R2,RDPKSEQ          GET SEQUENCE NUMBER
         SLL   R2,2                MULTIPLY BY FOUR
         SPACE 1
         EX    R0,RDPVSTO-4(R2)    SAVE VALUE IN TABLE
         B     RDPEXIT             RETURN TO CALLER
         EJECT
***********************************************************************
**                                                                   **
**       MULTI-NUMERIC VALIDATION ROUTINE (N1,N2,...)                **
**                                                                   **
***********************************************************************
         SPACE 1
RDPVDLM  DS    0H                  MULTI NUMERIC VALIDATION ROUTINE
         SPACE 1
         CH    RCODE,RDPKVT        IS EXPECTED TYPE FOUND ?
         BNE   RDPVERR             NO, MEANS ERROR
         SPACE 1
         CLI   0(R1),C'('          IS EXPECTED '(' FOUND
         BNE   RDPVERR             NO, VALUE ERROR
         SPACE 1
         NI    PRMFLAGS,FF-PRMFCOM RESET COMMA INDICATOR BIT
         LH    R2,RDPKSEQ          GET SEQUENCE NUMBER
         SLL   R2,2                MULTIPLY BY FOUR
         SPACE 1
*        EX    R0,RDPVLDA-4(R2)    SET R4 TO POINT TO RECEIVING FIELD
         SPACE 1
***********************************************************************
**                                                                   **
**       SCAN FOR ##,##,.. UNTIL ')'  IS FOUND                       **
**                                                                   **
***********************************************************************
         SPACE 1
RDPVMNUM DS    0H                  MULTI-NUMERIC VALUES SCANNING
         BALR  R3,R0               SET RESTART ADDRESS IN CASE OF EOD
         SPACE 1
         LR    RPARM,R6            LOAD SCANTCB ADDRESS
         CALL  SCAN
         B     RDPVERR             GOT A SYMBOL (CHARACTERS STRING)
         B     RDPVERR             HEX -- ERROR
         B     RDPVMDEC            DEC -- DECIMAL VALUE
         B     RDPVMDLM            DLM -- ',' OR ')' EXPECTED
         B     RDPVERR             STR -- ERROR
         B     *-*                 RESERVED
         B     RDPCNT              END OF TEXT, VALUE NOT SUPPLIED
         B     RDPVERR             ERROR ENCOUNTERED
         SPACE 1
***********************************************************************
**                                                                   **
**       DELIMITER ENCOUNTERED, CHECK FOR ',' OR ')'                 **
**                                                                   **
***********************************************************************
         SPACE 1
RDPVMDLM DS    0H                  DELIMITER ENCOUNTERED
         SPACE 1
         CLI   0(R1),C','          IS-IT A COMMA ?
         BNE   RDPVMEOD            NO, TRY FOR ')'
         SPACE 1
         XI    PRMFLAGS,PRMFCOM    REVERSE COMMA BIT
         TM    PRMFLAGS,PRMFCOM    IS-IT NOW RESET TO ZERO ?
         BO    RDPVERR             NO, WAS ENTERED TWICE... ERROR
         SPACE 1
         B     RDPVMNUM            CONTINUE EXPECTING NUMERIC
         SPACE 1
RDPVMEOD DS    0H                  TEST FOR END OF NUMERICS
         CLI   0(R1),C')'          IS-IT FINISHED ?
         BE    RDPEXIT             YES, ALL OF IT IS DONE
         B     RDPVERR             NO, DON'T KNOW WHAT IS GOING ON...
         SPACE 1
***********************************************************************
**                                                                   **
**       DECIMAL VALUE ENCOUNTERED, PROCESS IT                       **
**                                                                   **
***********************************************************************
         SPACE 1
RDPVMDEC DS    0H                  DECIMAL VALUE ENCOUNTERED
         SPACE 1
         XI    PRMFLAGS,PRMFCOM    REVERSE COMMA BIT
         TM    PRMFLAGS,PRMFCOM    IS-IT NOW SET TO ONE?
         BZ    RDPVERR             NO, NO COMMA WAS SUPPLIED..ERROR
         SPACE 1
         LR    R2,R0               SET LENGTH FOR EXECUTE
         BCTR  R2,R0               + AND DECREASE BY ONE
         EX    R2,RDPVPAK          PACK VALUE TO WORK BUFFER
         CVB   R0,SCWDBLE          CONVERT VALUE TO BINARY INTO R0
         SPACE 1
         LH    R2,RDPKSEQ          GET SEQUENCE NUMBER
         SLL   R2,2                MULTIPLY BY FOUR
         SPACE 1
         B     *(R2)               PROCESS ACCORDING TO SEQUENCE #
*
         B     RDPKSEQ1            -- PROCESS FIRST KEYWORD
         B     RDPKSEQ2            -- PROCESS SECOND KEYWORD
         SPACE 1
***********************************************************************
**                                                                   **
**       PROCESS BITMAPS ALLOCATION PATTERN                          **
**                                                                   **
***********************************************************************
         SPACE 1
RDPKSEQ1 DS    0H                  PROCESS
         SPACE 1
         LR    R1,R4               LOAD RECEIVING FIELD POINTER
*        LA    R15,WRKPALP         POINT TO INITIAL ADDRESS
         SR    R1,R15              GET CURRENT OFFSET
*        CH    R1,=Y(&MAXLVL)      COMPARE AGAINST MAXIMUM VALUE
         BNL   RDPVMERR            IF HIGH OR EQUAL TO MAX, IMPOSSIBLE
         SPACE 1
         LTR   R0,R0               TEST FOR POSITIVE VALUE
         BNP   RDPVMERR            IF NOT POSITIVE, ERROR
         SPACE 1
         STC   R0,0(R4)            SAVE VALUE
         LA    R4,1(R4)            POINT TO NEXT RECEIVING FIELD
         B     RDPVMNUM            CONTINUE SCANNING
         SPACE 1
***********************************************************************
**                                                                   **
**       PROCESS SECOND KEYWORD VALUE                                **
**                                                                   **
***********************************************************************
         SPACE 1
RDPKSEQ2 DS    0H                  PROCESS MERGE BITMAP
         SPACE 1
*        CH    R0,=Y(&MAXFLD#-1)   TEST FOR MAXIMUM VALUE
         BH    RDPVMERR            HIGHER, ERROR
         SPACE 1
         LR    R2,R0               LOAD IT'S CONTENT
         SRL   R2,3                DIVIDE BY 8
         LA    R3,0(R2,R4)         POINT TO FIELD RECEIVING BIT
         SLL   R2,3                RESET
         SPACE 1
         SR    R0,R2               SET TO BIT# TO BE SET
         STC   R0,PRMCBUF          SAVE IT IN CONVERT BUFFER
         TR    PRMCBUF,RDPCTBL     TRANSLATE IT
         OC    0(1,R3),PRMCBUF     SET RIGHT BIT
         B     RDPVMNUM            + AND GO PROCESS NEXT VALUE
         EJECT
***********************************************************************
**                                                                   **
**       VALUE  ERROR OCCURED -- PRINT MESSAGE AND QUIT              **
**                                                                   **
***********************************************************************
         SPACE 1
RDPVERR  DS    0H                  VALUE ERROR OCCURED
         SPACE 1
         SEND  'SCK0010E -- VALUE TYPE DOES NOT MATCH KEYWORD',        *
               ROUTCDE=(1,2)      ROUTE TO MASTER CONSOLES
         B     RDPPERR             RETURN TO CALLER
         EJECT
***********************************************************************
**                                                                   **
**       VALUE SUPPLIED OUT OF BOUNDS, PRT MESSAGE AND QUIT          **
**                                                                   **
***********************************************************************
         SPACE 1
RDPVMERR DS    0H                  VALUE ERROR OCCURED
         SPACE 1
         SEND  'SCK0011E -- TO MANY VALUES SUPPLIED',                  *
               ROUTCDE=(1,2)      ROUTE TO MASTER CONSOLES
         B     RDPPERR             RETURN TO CALLER
         EJECT
***********************************************************************
**                                                                   **
**       ERROR OCCURED, PRINT MESSAGE AND QUIT                       **
**                                                                   **
***********************************************************************
         SPACE 1
RDGKERR  DS    0H                  KEYWORD ERROR
         SEND  'SCK0012E -- ERROR OCCURED WHILE SCANNING',             *
               ROUTCDE=(1,2)      ROUTE TO MASTER CONSOLES
         SPACE 1
         B     RDPPERR             RETURN TO CALLER
         SPACE 2
***********************************************************************
**                                                                   **
**       EXPECTED KEYWORD WAS NOT FOUND                              **
**                                                                   **
***********************************************************************
         SPACE 1
RDGKNF   DS    0H                  KEYWORD EXPECTED, BUT NOT FOUND
         SPACE 1
         SEND  'SCK0013E -- KEYWORD EXPECTED BUT BAD SYMBOL FOUND',    *
               ROUTCDE=(1,2)      ROUTE TO MASTER CONSOLES
         SPACE 1
         B     RDPPERR             RETURN TO CALLER
         SPACE 1
***********************************************************************
**                                                                   **
**       EQUAL SIGN NOT FOUND                                        **
**                                                                   **
***********************************************************************
         SPACE 1
RDGDERR  DS    0H                  KEYWORD ERROR
         SPACE 1
         SEND  'SCK0014E -- EXPECTED "=" NOT FOUND, "=" ASSUMED',      *
               ROUTCDE=(1,2)      ROUTE TO MASTER CONSOLES
         SPACE 1
         LM    R15,R1,SBSCNR15     RELOAD SCAN REGISTERS
         B     RDPKVAL(RCODE)      RETURN VALIDATING VALUE
         EJECT
***********************************************************************
**                                                                   **
**        KEYWORD PARSE NOT FINISHED, PREPARE TO CONTINUE            **
**                                                                   **
***********************************************************************
         SPACE 1
RDPCNT   DS    0H                  EXIT READ PARM, CONTINUE FURTHER
         SPACE 1
         OI    SCPFLAGS,SCPFCNT    CONTINUE PARSE OF SAME KEYWORD
         STM   R0,R5,SCPRDSA       SAVE REGISTERS (WHEN RE-ENTRY,
*                                  + WILL CONTINUE AT 0(RENTRY))
         LA    RCODE,4             SET RCODE TO 4
         B     RDPRET              RETURN TO CALLER -- WAIT BUFFER
         SPACE 2
***********************************************************************
**                                                                   **
**        PARSE ERROR OCCURED, SET BAD RETURN CODE AND EXIT          **
**                                                                   **
***********************************************************************
         SPACE 1
RDPPERR  DS    0H                  PARSE ERROR, EXIT
         SPACE 1
         NI    SCPFLAGS,FF-SCPFCNT REQUEST A NEW KEYWORD (IN CASE)
         LA    RCODE,8             SET RCODE TO 8
         B     RDPRET              RETURN TO CALLER
         EJECT
***********************************************************************
**                                                                   **
**        RETURN TO CALLER AT PROPER LOCATION                        **
**                                                                   **
***********************************************************************
         SPACE 1
RDPEXIT  DS    0H                  EXIT READ PARM
         SPACE 1
         NI    SCPFLAGS,FF-SCPFCNT REQUEST A NEW KEYWORD
         XR    RCODE,RCODE         SET RCODE TO ZERO
RDPRET   $SUBRET                   + AND RETURN TO CALLER
         EJECT
***********************************************************************
**                                                                   **
**       RDPARM DATA AND CONSTANTS                                   **
**                                                                   **
***********************************************************************
         SPACE 1
RDPKCLC  CLC   0(*-*,R1),0(R2)     COMPARE SUPPLIED ENTRY WITH KEYWORD
*DPNMVC  MVC   WRKPNAM(*-*),1(R1) MOVE DATABASE NAME (EXCL QUOTE)
RDPVPAK  PACK  SCWDBLE,R0(*-*,R1) PACK NUMERIC VALUE
         SPACE 1
RDPVSTO  STCM  R0,B'1111',SCPMAXC  SAVE MAX CPU TIME
         STCM  R0,B'1111',SCPDISC  SAVE DISCONNECT TIME
         STCM  R0,B'1111',SCPWAIT  SAVE LONG WAIT TIME
         STCM  R0,B'1111',SCPTRACK SAVE TRACK TIME
         STCM  R0,B'1111',SCPSEEK  SAVE SEEK TIME
         SPACE 1
*DPVLDA  LA    R4,WRKPALP          SET TO ALLOC PATTERN ADDRESS
*        LA    R4,WRKPMRG          SET TO ALLOC PATTERN ADDRESS
         SPACE 2
RDPCTBL  DC    B'10000000'         BITMAP TRANSLATE TABLE
         DC    B'01000000'
         DC    B'00100000'
         DC    B'00010000'
         DC    B'00001000'
         DC    B'00000100'
         DC    B'00000010'
         DC    B'00000001'
         SPACE 2
***********************************************************************
**                                                                   **
**       LITERAL POOL DEFINITION                                     **
**                                                                   **
***********************************************************************
         LTORG ,                   LITERAL POOL DEFINITION
         EJECT
***********************************************************************
**                                                                   **
**       PARAMETERS KEYWORDS DEFINITIONS                             **
**                                                                   **
***********************************************************************
         SPACE 1
RDPKVTBL DS    0F                  KEYWORDS TABLE DEFINITION
*
RDPKSA   DS    AL4                 -- SYMBOL ADDRESS (UNALIGNED)
RDPKLN   DS    Y                   -- SYMBOL LENGTH
RDPKVT   DS    Y                   -- EXPECTED VALUE TYPE
RDPKSEQ  DS    Y                   -- SEQUENCE OF SYMBOL WITH SAME
*                                     VALUE TYPE (SEE UTILDS)
*
RDPKELN  EQU   *-RDPKVTBL          TABLE ENTRY LENGTH
*
         ORG   RDPKVTBL            RE-ORG TO TABLE DEFINITION
*
         DC    AL4(RDP1K),Y(L'RDP1K,SCTDEC,1)
         DC    AL4(RDP2K),Y(L'RDP2K,SCTDEC,2)
         DC    AL4(RDP3K),Y(L'RDP3K,SCTDEC,3)
         DC    AL4(RDP4K),Y(L'RDP4K,SCTDEC,4)
         DC    AL4(RDP5K),Y(L'RDP5K,SCTDEC,5)
         SPACE 1
         ORG   *-RDPKELN           RE-ORG TO LAST ENTRY
         DC    X'80'               END OF KEYWORDS TABLE
         ORG   ,                   RE-ORG
RDP1K    DC    C'MAXCPU'           MAX NUMBER OF CPU'S
RDP2K    DC    C'DISCONNECT_TIME'  MAX TIME BEFORE DISCONNECTION
RDP3K    DC    C'LONG_WAIT'        LONG WAIT TIME
RDP4K    DC    C'TRACK_WAIT'       TRACK WAIT TIME
RDP5K    DC    C'SEEK_TIME'        SEEK TIME
         TITLE '-- S C A N  -- SERVICE ROUTINE'
***********************************************************************
**                                                                   **
**                     ----  S C A N  ----                           **
**                                                                   **
**           THIS MODULE WILL EXTRACT A TOKEN FROM THE TEXT          **
**       BUFFER AND RETURN TO THE CALLER WITH THE NEXT TOKEN.        **
**       IT WILL ALSO FLUSH ANY COMMENT FROM TEXT (/*...*/).         **
**                                                                   **
**           POSSIBLE RETURNED TOKEN TYPES ARE:                      **
**                                                                   **
**             SYMBOL :   <ALP> (  <ALP> × <DIGIT> )                 **
**             HEX:       ( 0×1×2×3×4×5×6×7×8×9×A×B×C×D×E×F)         **
**             DEC:       ( 0×1×2×3×4×5×6×7×8×9 )                    **
**             DLM:       *×-×+×&×/×%×^×'×"×?×<×>×,×.×**×<=....      **
**             STRING:    'ANY CHARACTER  ...'                       **
**             OTHER:     ...                                        **
**                                                                   **
**                                                                   **
**       <ALP> ::=  A×B×C×D×E×F×G×H×I×J×K×L×M×N×O×P×                 **
**                  Q×R×S×T×U×V×W×X×Y×Z×@×#×_                        **
**                                                                   **
**       <DIGIT>    0×1×2×3×4×5×6×7×8×9                              **
**                                                                   **
**                                                                   **
**       PARAMTERS :                                                 **
**       ----------                                                  **
**                                                                   **
**       INPUT:                                                      **
**              RPARM POINTS TO TEXT CONTROL BLOCK                   **
**              FOR INFORMATION, SEE DSECT SCANTCB                   **
**                                                                   **
**       OUTPUT:                                                     **
**              OFFSET IS UPDATED IN TEXT CONTROL BLOCK AND          **
**              NOW POINTS A THE FIRST CHARACTER FOLLOWING EXTRACTED **
**              TOKEN .                                              **
**                                                                   **
**       --  TOKEN ADDRESS IS RETURNED IN REGISTER R1                **
**       --  TOKEN LENGTH  IS RETURNED IN REGISTER R0                **
**                                                                   **
**       --  RETURN CODE IS SET IN REGISTER RCODE AND INDICATES      **
**           TOKEN TYPE:                                             **
**                                                                   **
**           RCODE  = 0  SYMBOL         -- MIGHT BE HEX (C.F. AABBC) **
**                  = 4  HEX            -- HEXADECIMAL NUMBER        **
**                  = 8  DEC            -- DECIMAL NUMBER (NO SIGN)  **
**                  = 12 DLM            -- DELIMITER                 **
**                  = 16 STRING         -- CHARACTER STRING          **
**                  = 20 RESERVED                                    **
**                  = 24 END OF TEXT BUFFER                          **
**                  = 28 SCAN ERROR (UNDEFINED OR INVALID CHARACTER) **
**                                                                   **
**                                                                   **
***********************************************************************
         EJECT
         SPACE 5
***********************************************************************
**                                                                   **
**       FUNCTIONNAL REGISTERS DEFINITIONS                           **
**                                                                   **
***********************************************************************
         SPACE 1
RSTCB    EQU   R10                 BASE REGISTER FOR TEXT CONTROL BLOCK
         SPACE 2
***********************************************************************
**                                                                   **
**       LOCAL EQUATES -- RETURNED TOKEN TYPES                       **
**                                                                   **
***********************************************************************
         SPACE 1
SCTSYM   EQU   0                   TYPE = SYMBOL
SCTHEX   EQU   4                   TYPE = HEXADECIMAL
SCTDEC   EQU   8                   TYPE = DECIMAL
SCTDLM   EQU   12                  TYPE = DELIMITER
SCTSTR   EQU   16                  TYPE = STRING
SCTRES   EQU   20                  RESERVED
SCTEND   EQU   24                  END OF TEXT BUFFER
SCTERR   EQU   28                  ERROR ENCOUNTERED
         SPACE 1
***********************************************************************
**                                                                   **
**       LOCAL VARIABLES DEFINITION                                  **
**                                                                   **
***********************************************************************
         SPACE 1
SCANDS   DSECT
SCATOMA  DC    A(0)                ADDRESS OF TOKEN FIRST CHARACTER
*                                  + IN GROUPS BUFFER
         SPACE 1
SCDSLN   EQU   *-SCANDS            LENGTH OF DSECT
         TITLE 'S C A N  -- INITIALISATION --'
***********************************************************************
**                                                                   **
**       S C A N  --  INITIALISATION                                 **
**                                                                   **
***********************************************************************
         SPACE 2
SCAN     $SUB  SCANDS,SCDSLN       DEFINE SCAN ENTRY POINT
         SPACE 1
         LR    RSTCB,RPARM         SET TEXT CONTROL BLOCK ADDR.
         USING SCANTCB,RSTCB       SET DSECT ADDRESSABILITY
         TITLE '  -- MAIN PROCESSING ENTRY POINT --'
***********************************************************************
**                                                                   **
**       CHECK FOR FIRST CALL FOR THIS TEXT BUFFER.                  **
**                                                                   **
**       -- IF SO, INITIALIZE FIELD "SBGBUF" BY ASSOCIATING FOR      **
**          EACH CHARACTER A GROUP ACCORDING TO "SCGTAB" TABLE       **
**                                                                   **
***********************************************************************
         SPACE 1
         TM    SBSFLG1,SBFNEW      FIRST CALL ?
         BO    SCOKINIT            NO, CONTINUE PROCESSING THIS BUFFER
         SPACE 1
         OI    SBSFLG1,SBFNEW      SET INDICATOR
         MVC   SBGBUF,SBTXT        MOVE TEXT
         TR    SBGBUF,SCGTAB       TRANSLATE IN GROUPS.
         SPACE 1
         LA    R1,SBTXT            POINT TO TEXT
         ST    R1,SBATOMA          INITIALIZE  FIELD
         XC    SBTXTOFS,SBTXTOFS   INITIALIZE OFFSET FROM BEGINNING
         SPACE 1
***********************************************************************
**                                                                   **
**       SKIP BLANKS AND POINT TO FIRST CHARACTER OF TOKEN           **
**                                                                   **
***********************************************************************
         SPACE 1
SCOKINIT DS    0H                  INITIALIZATION COMPLETED
         SPACE 1
         LA    R1,SBTXT            ADDRESS OF TEXT BUFFER
         LR    R3,R1               SET REGISTER TO POINT
         AH    R3,SBTXTLN          +  END OF BUFFER
         BCTR  R3,R0               POINT LAST CHARACTER
         SPACE 1
         AH    R1,SBTXTOFS         POINT TO FIRST CHARACTER
         CR    R1,R3               REACHED  END OF BUFFER?
         BH    SCREINIT            YES, REINITIALIZE
         SPACE 1
         LA    R2,1                INITIALIZE TO 1 (INCREMENT)
         SPACE 1
SCSKIP   CLI   0(R1),C' '          IS-IT A BLANK?
         BNE   SCBEGIN             NO, WE ARE AT THE BEGINNING
         BXLE  R1,R2,SCSKIP        POINT TO NEXT CHARACTER
*                                  + IF IT IS NOT FINISHED
         SPACE 1
SCREINIT XI    SBSFLG1,SBFNEW      RESET INDICATOR TO ZERO
         LA    R15,SCTEND          INDICATE  END OF BUFFER
         B     SCEXIT              END OF EXECUTION
         SPACE 1
SCBEGIN  ST    R1,SBATOMA          SAVE  TOKEN POINTER
         SPACE 1
         LA    R2,SBTXT            ADDRESS OF TEXT BUFFER
         SR    R1,R2               GET OFFSET
         STH   R1,SBTXTOFS         SAVE IN TEXT CONTROL BLOCK
         TITLE ' SELECTION OF TOKEN TYPE --'
***********************************************************************
**                                                                   **
**       DEFINE TOKEN TYPE IN FUNCTION OF FIRST CHARACTER            **
**       AND ANALYSE IT.                                             **
**                                                                   **
**       -- REGISTER ONE CONTAINS TOKEN OFFSET IN BUFFER             **
**                                                                   **
***********************************************************************
         SPACE 1
         LA    R2,SBGBUF           ADDRESS OF GROUPS BUFFER
         AR    R2,R1               GROUPE OF FIRST CHARACTER FOR
*                                  + CURRENT SYMBOL
         ST    R2,SCATOMA          SAVE THIS ADDRESS
         SPACE 1
         XR    R1,R1               CLEAR BEFORE BRANCH
         ICM   R1,B'0001',0(R2)    INSERT 1ST CHARACTER GROUP
         BZ    SCERR1              ILLEGAL, END OF PROCESSING
         B     *(R1)               BRANCH ACCORDING TO GROUP
         SPACE 1
         B     SCLET               LETTER  (A - F)
         B     SCLET               LETTER  (G - Z), @, #, _
         B     SCNUM               DIGIT (0 - 9)
         B     SCDLMS              SIMPLE DELIMITER
         B     SCDLMM              MULTIPLE DELIMITER
         B     SCQUOT              QUOTE
         B     *-*                 RESERVED
         TITLE 'PROCESS A SYMBOL '
***********************************************************************
**                                                                   **
**       PROCESS A SYMBOL.                                           **
**       --   FIRST CHARACTER IS ALPHABETIC, REST IS ALPHANUMERIC    **
**                                                                   **
***********************************************************************
         SPACE 1
SCLET    DS    0H
         LA    R15,SCTSYM          TYPE  = SYMBOL
         SPACE 1
         LA    R2,1(R2)            POINT TO NEXT
         CLI   0(R2),SCGERR        ERROR?
         BE    SCEXIT              NO, STOP
         SPACE 1
         CLI   0(R2),SCGNUM        DIGIT OR LETTER?
         BNH   SCLET               YES, CONTINUE
         SPACE 1
         B     SCEXIT              RETURN TO CALLER
         SPACE 2
***********************************************************************
**                                                                   **
**       PROCESS A NUMBER.                                           **
**       -- IT MIGHT BE HEX OR DECIMAL...                            **
**                                                                   **
***********************************************************************
         SPACE 1
SCNUM    DS    0H
         LA    R15,SCTDEC          INITIALIZE  TYPE TO DECIMAL.
*                                  IF ANY HEX CHARACTER (A-F) IS
*                                  + FOUND, TYPE WILL BE CHANGED TO
*                                  + "SCTHEX"
         SPACE 1
SCCHIB   LA    R2,1(R2)            SKIP TO NEXT CHARACTER
         SPACE 1
         CLI   0(R2),SCGNUM        DIGIT?
         BE    SCCHIB              YES, LOOP ON NUMBER
         CLI   0(R2),SCGHEX        LETTER? (A-F)
         BNE   SCEXIT              NO, THAT IS IT, ALL IS DONE
         SPACE 1
         LA    R15,SCTHEX          INITIALIZE   TYPE HEX
         B     SCCHIB              CONTINUE PROCESSING
         SPACE 2
***********************************************************************
**                                                                   **
**       PROCESS A SIMPLE DELIMITER (1 CHARACTER)                    **
**                                                                   **
***********************************************************************
         SPACE 1
SCDLMS   DS    0H                  SIMPLE DELIMITER PROCESSING
         LA    R15,SCTDLM          TYPE = DELIMITER
         LA    R2,1(R2)            SKIP TO NEXT CHARACTER
         SPACE 1
         B     SCEXIT              RETURN
         EJECT
***********************************************************************
**                                                                   **
**       PROCESS A MULTIPLE DELIMITER (MANY CHARACTERS)              **
**       -- THE POSSIBLE DELIMITERS ARE:                             **
**                                                                   **
**           **,<>,>=,<=,^=,/*,/*,:=                                 **
**                                                                   **
***********************************************************************
         SPACE 1
SCDLMM   DS    0H                  PROCESS A POTENTIAL MULTIPLE DLM
         L     R4,SBATOMA          TOKEN ADDRESS
         SPACE 1
         LR    R0,R2               SAVE  REGISTER
         TRT   0(1,R4),SCDLMTBL    TRANSLATE TO CORRESPONDING OFFSET
         SPACE 1
         N     R2,=X'000000FF'     ZERO OUT 3 FIRST BYTES
         SPACE 1
         LR    R1,R2               LOAD BRANCH OFFSET
         LR    R2,R0               REINITIALIZE REGISTER
         SPACE 1
         B     *(R1)               BRANCH ACCORDING TO FIRST CHARACTER
         SPACE 1
         B     SCDLM00             X'04' *  OR   **  */
         B     SCDLM01             X'08' <       <=  <>
         B     SCDLM02             X'0C' >       >=
         B     SCDLM02             X'10' ^       ^=
         B     SCDLM02             X'14' :       :=
         B     SCDLM03             X'18' /       /*
         SPACE 1
SCDLM00  CLI   1(R4),C'*'          IS-IT ** ?
         BE    SCDLMOK             YES, IT'S CORRECT
         CLI   1(R4),C'/'          IS-IT */ ?
         BE    SCDLMOK             YES, IT'S CORRECT
         B     SCDLMS              NO, IT'S A SIMPLE DELIMITER
         SPACE 1
SCDLM01  CLI   1(R4),C'='          IS-IT <= ?
         BE    SCDLMOK             YES, IT'S CORRECT
         CLI   1(R4),C'>'          IS-IT <> ?
         BE    SCDLMOK             YES, IT'S CORRECT
         B     SCDLMS              NO, IT'S A SIMPLE DELIMITER
         SPACE 1
SCDLM02  CLI   1(R4),C'='          IS-IT >= ^= := ?
         BE    SCDLMOK             YES, IT'S CORRECT
         B     SCDLMS              NO, IT'S A SIMPLE DELIMITER
         SPACE 1
SCDLM03  CLI   1(R4),C'*'          IS-IT /* ?
         BNE   SCDLMS              NO, IT'S A SIMPLE DELIMITER
         B     SCDCOMM             GO PROCESS A COMMENT (SKIP IT)
         SPACE 1
SCDLMOK  LA    R15,SCTDLM          TYPE = DELIMITER
         LA    R2,2(R2)            POINT TO NEXT CHARACTER (L=2)
         B     SCEXIT              IT'S ALL
         TITLE 'PROCESS A COMMENT (SKIP IT)'
***********************************************************************
**                                                                   **
**        WE ARE PROCESSING A COMMENT, SKIP IT UNTIL */ IS FOUND     **
**                                                                   **
***********************************************************************
         SPACE 1
SCDCOMM  DS    0H                  PROCESS A COMMENT
         SPACE 1
         LA    R1,SBTXT            ADDRESS OF TEXT BUFFER
         LR    R3,R1               SET REGISTER TO POINT
         AH    R3,SBTXTLN          + TO END OF BUFFER
         BCTR  R3,R0               POINT TO LAST CHARACTER OF BUFFER
         SPACE 2
         LA    R2,1                INITIALIZE TO 1 (INCREMENT)
         SPACE 1
SCDCNXT  DS    0H                  PROCESS NEXT CHARACTER
         CLC   0(2,R4),=C'*/'      END OF COMMENT ?
         BE    SCDCRET             YES, GO RETRY SCAN
         BXLE  R4,R2,SCDCNXT       POINT TO NEXT CHARACTER
*                                  + IF IT IS NOT FINISHED
         B     SCREINIT            IF END OF BUFFER, RETURN
         SPACE 2
SCDCRET  DS    0H                  RETRY SCAN
         LA    R4,2(R4)            POINT TO NEXT CHARACTER FOLLOWING */
         SR    R4,R1               GET OFFSET FROM BUFFER BEGINNING
         STH   R4,SBTXTOFS         SAVE IT IN TEXT CONTROL BLOCK
         B     SCOKINIT            + AND RESTART SCAN
         TITLE 'PROCESS A CHARACTERS STRING'
***********************************************************************
**                                                                   **
**       PROCESS A CHARACTERS STRING                                 **
**                                                                   **
***********************************************************************
         SPACE 1
SCQUOT   DS    0H
         LA    R15,SCTSTR          TYPE = STRING
         SPACE 1
         LA    R1,1(R2)            POINT TO NEXT GROUP OF CHARACTER
         LA    R2,1                INITIALIZE TO 1 (INCREMENT)
         SPACE 1
         LA    R3,SBGBUF           ADDRESS OF BUFFER
         AH    R3,SBTXTLN          POINTER AFTER  LAST CHARACTER
         BCTR  R3,R0               POINTER TO LAST CHARACTER
         SPACE 1
SCAPO00  CLI   0(R1),SCGAPO        IS-IT A QUOTE
         BE    SCAPO01             YES, CHECK IF WE REACHED END
         SPACE 1
         BXLE  R1,R2,SCAPO00       POINT TO NEXT CHARACTER
*                                  IF NOT THE END
         SPACE 1
         LR    R2,R1               POINTER TO LAST CHARACTER
         B     SCERR1              IT'S AN ERROR
         SPACE 1
SCAPO01  DS    0H
         CLI   1(R1),SCGAPO        IS-IT AGAIN  A QUOTE?
         BNE   SCAPO02             NO, WE TERMINATED
         SPACE 1
         LA    R1,2(R1)            POINT TI NEXT CHARACTER
         B     SCAPO00             LOOK FOR ENDING QUOTE
         SPACE 1
SCAPO02  DS    0H
         LA    R2,1(R1)            POINTER TO NEXT CHARACTER
         B     SCEXIT              END OF PROCESSING
         TITLE 'PROCESS AN ERROR'
***********************************************************************
**                                                                   **
**       PROCESS AN ERROR                                            **
**                                                                   **
***********************************************************************
         SPACE 1
SCERR1   DS    0H
         SPACE 1
         LA    R15,SCTERR          SYNTAX ERROR
         LA    R2,1(R2)            IGNORE CHARACTER IN ERROR
         SPACE 1
         B     SCEXIT              RETURN
         TITLE ' END  OF TOKEN PROCESSING --'
***********************************************************************
**                                                                   **
**       END OF TOKEN PROCESSING                                     **
**       WE MUST REINITIALIZE  FIELD SBTXTOFS                        **
**                                                                   **
**          REGISTER 2 POINTS TO END OF SYMBOL                       **
**          REGISTER 15 CONTAINS TOKEN TYPE                          **
**                                                                   **
**                                                                   **
**       TO RETURN,  REGISTER 0    MUST CONTAIN  LENGTH              **
**                   REGISTER 1    MUST POINT TO SYMBOL              **
**                   REGISTER 15   IS SET TO TOKEN TYPE              **
**                                                                   **
***********************************************************************
         SPACE 1
SCEXIT   DS    0H                  PREPARE TO EXIT SCAN
         SPACE 1
         LR    R0,R2               CALCULATE TOKEN LENGTH
         S     R0,SCATOMA          SET R0 TO IT.
         SPACE 1
         LA    R1,SBGBUF           ADDRESS OF GROUP
         SR    R2,R1               OFFSET
         SPACE 1
         STH   R2,SBTXTOFS         SAVE IT BACK IN CONTROL BLOCK
         SPACE 1
         L     R1,SBATOMA          SET R1 TO TOKEN ADDRESS (RETURN IT)
         SPACE 1
         L     R2,4(RSAVE)         POINT TO PREVIOUS SAVE AREA
         STM   R15,R1,16(R2)       SAVE RETURNED REGISTERS
         SPACE 1
         $SUBRET ,                 RETURN TO CALLER
         TITLE 'CONSTANTS AND EXECUTED INSTRUCTIONS --'
***********************************************************************
**                                                                   **
**       CONSTANTS DEFINITIONS                                       **
**                                                                   **
***********************************************************************
         SPACE 2
         LTORG ,                   LITERAL  POOL DEFINITION
         SPACE 1
***********************************************************************
**                                                                   **
**       MULTIPLE DELIMITERS TABLE                                   **
**                                                                   **
***********************************************************************
         SPACE 1
SCDLMTBL EQU   *
         DC    256X'00'            INITIALIZE TABLE TO ZEROES
         ORG   SCDLMTBL+C'*'       STARTING WITH *:   ** */
         DC    X'04'
         SPACE 1
         ORG   SCDLMTBL+C'<'       STARTING WITH < ×  <= <>
         DC    X'08'                               ×
         SPACE 1
         ORG   SCDLMTBL+C'>'       STARTING WITH > ×  >=
         DC    X'0C'                               ×
         SPACE 1
         ORG   SCDLMTBL+C'^'       STARTING WITH ^ ×  ^=
         DC    X'10'                               ×
         SPACE 1
         ORG   SCDLMTBL+C':'       STARTING WITH : ×  :=
         DC    X'14'                               ×
         SPACE 1
         ORG   SCDLMTBL+C'/'       STARTING WITH / ×  /*
         DC    X'18'                               ×
         SPACE 1
         ORG   ,                   REORG TO END OF TABLE
         EJECT
***********************************************************************
**                                                                   **
**       GROUPS TRANSCRIPTION TABLE                                  **
**                                                                   **
**       FOLLOWING ARE THE GROUPS  ASSOCIATED WITH CHARACTERS:       **
**                                                                   **
**       X'00':  ERROR -- ILLEGAL  CHARACTER                         **
**       X'04':  A-F                                                 **
**       X'08':  G-Z , @, #, _                                       **
**       X'0C':  0-9                                                 **
**       X'10':  SIMPLE DELIMITER                                    **
**       X'14':  MULTIPLE DELIMITER                                  **
**       X'18':  QUOTE                                               **
**                                                                   **
***********************************************************************
         SPACE 1
SCGERR   EQU   X'00'               ERROR
SCGHEX   EQU   X'04'               A - F
SCGLET   EQU   X'08'               G - Z , @, #, _
SCGNUM   EQU   X'0C'               0 - 9
SCGDLS   EQU   X'10'               SIMPLE DELIMITER
SCGDLM   EQU   X'14'               MULTIPLE DELIMITER
SCGAPO   EQU   X'18'               QUOTE
         SPACE 1
SCGTAB   DC    0XL256'00'
*
*                0 1 2 3 4 5 6 7 8 9 A B C D E F
         DC    X'00000000000000000000000000000000'  0
         DC    X'00000000000000000000000000000000'  1
         DC    X'00000000000000000000000000000000'  2
         DC    X'00000000000000000000000000000000'  3
         DC    X'00000000000000000000001014101010'  4
         DC    X'10000000000000000000101014101014'  5
         DC    X'10140000000000000000001010081410'  6
         DC    X'00000000000000000000140808181010'  7
         DC    X'00000000000000000000000000000000'  8
         DC    X'00000000000000000000000000000000'  9
         DC    X'00000000000000000000000000000000'  A
         DC    X'00000000000000000000000000000000'  B
         DC    X'00040404040404080808000000000000'  C
         DC    X'00080808080808080808000000000000'  D
         DC    X'00000808080808080808000000000000'  E
         DC    X'0C0C0C0C0C0C0C0C0C0C000000000000'  F
         SPACE 1
         LTORG ,                  LITERAL POOL DEFINITION
         END   SETCLOCK            PROGRAM END
