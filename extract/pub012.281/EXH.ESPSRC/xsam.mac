XSAM     TITLE 'TRACK I/O SAM INTERFACE ROUTINE'
         MACRO
&NM      ENTER &EOF=,&DECB=,&CLOSE=YES  ENTRY FROM USER GET/READ/ETC.
         DS    0H             JUST IN CASE
&NM      STM   R14,R12,12(R13)  SAVE
         AIF   ('&DECB' EQ '').DECBQ
         LR    R8,R1         COPY DECB ADDRESS
         L     R10,8(,R8)    AND DCB ADDRESS
         AGO   .DECBCOM
.DECBQ   LR    R10,R1        COPY DCB ADDRESS
.DECBCOM AIF   ('&CLOSE' NE 'YES').CLOSES
         TM    DCBOFLGS,DCBOFOPN  OPEN ?
         BZ    QUICKOUT-&NM.(,R15)  ERROR IF CLOSED
.CLOSES  L     R1,DCBCNTRL   GET WORK AREA BACK
         L     R12,XSAMPBAS-XSAMPRFX(,R1)    RESTORE BASE
         LA    R1,XSAMWORK-XSAMPRFX(,R1)    BUMP TO SAVE AREA
         ST    R1,8(,R13)    LINK
         ST    R13,4(,R1)
         LR    R13,R1
         AIF   ('&EOF' EQ '').MEND
         TM    FLAG,FGEOF    READ PAST EOF ?
         BNZ   EOFABEND      YES; BOMB
.MEND    MEND  ,
         SPACE 1
         MACRO
&NM      MRG   &TO,&FROM,&BASE=
         GBLC  &BASEMG
         LCLC  &L
&L       SETC  'L'''
         AIF   ('&BASE' EQ '').NOBASE
&BASEMG  SETC  '&BASE'
.NOBASE  AIF   ('&TO' EQ '*END').QUIT
&NM      DC    AL1(&L.DCB&TO-1,DCB&TO-IHADCB,&FROM-&BASEMG)
         MEXIT
.QUIT    ANOP  ,
&NM      DC    X'FF'         END OF LIST
         MEND  ,
         SPACE 2
         COPY  OPTIONGB                                         GP12045
         SPACE 1
         SYSPARM LIST=YES                                       GP12045
         SPACE 2
**********************************************************************
*
*        THIS MODULE IS INTENDED TO MAKE ROUTINE UTILITY JOBS FASTER.
*        FOR NORMAL QSAM/BSAM/BPAM I/O, THE OPEN (AND CLOSE) ARE
*        REPLACED BY LA R1,DCB/CALL XSAMOPEN OR XSAMCLOS
*          MOST FANCY FUNCTIONS ARE NOT SUPPORTED.
*        USE AT YOUR OWN RISK.
*
*        THE MODULE REPLACES DATA IN THE SPECIFIED DCB, BUT DOES NOT
*        USE THEM. ALL PROCESSING IS DONE FROM A 32K WORK AREA POINTED
*        TO BY DCBCNTRL IN THE USER'S DCB.  ALL I/O IS DONE ON A TRACK
*        BASIS (MAXIMUM OF TWO I/O REQUESTS PER TRACK).
*
**********************************************************************
         EJECT ,
XSAMOPEN START 0               VERY PRELIMINARY VERSION ADDED ON 79365
         USING *,R12
         STM   R14,R12,12(R13)
         LR    R12,R15
         LR    R10,R1        COPY DCB ADDRESS
         NUSE  DCB,R10
         TM    DCBOFLGS,DCBOFOPN  ALREADY OPEN ?
         BNZ   QUICKOUT      THAT WAS FAST
         L     R3,GETMLENG   LOAD LENGTH OF GETMAIN
         GETMAIN R,LV=(R3)   GET IT
         BXH   R15,R15,QUICKABE
         LR    R2,R13        SAVE CURRENT SAVE AREA
         LR    R13,R1        COPY WORK AREA
         USING XSAMPRFX,R13  DECLARE IT
         LR    R15,R3        COPY LENGTH
         LR    R14,R13       ALSO WORK AREA
         XR    R0,R0
         XR    R1,R1
         MVCL  R14,R0        CLEAR THE WHOLE THING FOR DEBUGGING
         MVC   XSAMPRFX(12),=X'0700070041F0000807FEE7E2' QSAM PRFX
         LA    R14,EXPOINT
         LA    R15,EXNOTE
         LR    R0,R12        BASE
         STM   R14,R0,XSAMPPNT  SET POINT/NOTE/BASE ADDRESSES
         LA    R13,XSAMWORK-XSAMPRFX(,R13)  WORK AREA PROPER
         ST    R2,4(,R13)    BACK-LINK
         ST    R13,8(,R2)    AND FORWARD-LINK SAVE AREAS
         LA    R11,2048(,R13)
         LA    R11,2048(,R11)  DURING INIT - USE FULL ADDRESSABILITY
         USING XSAMWORK,R13,R11
         MVC   DCB(PATDCBL),PATDCB  MAKE DCB
         MVC   DCBDDNAM+DCB-IHADCB,DCBDDNAM  COPY DD NAME
         ST    R10,USERDCB   SAVE USER'S DCB
         MVC   EMPIRE,DCBDDNAM  SAVE THE FOUNDATION
         MVC   ANACREON,DCBRECFM
         MVC   SMYRNA,DCBREAD
         MVC   KALGAN,DCBCIND1
         TM    DCBMACR,DCBMRECP  EXCP MODE ?
         BNZ   USEROPEN      YES; WON'T HANDLE
         TM    DCBDSRG1,255-DCBDSGPS-DCBDSGPO-DCBDSGU  NON-PS ?
         BNZ   USEROPEN      YES; QUIT NOW
         CLI   DCBDSRG2,0    ANY NON-PS ?
         BNE   USEROPEN
         MVC   MERGOC(12),PERGOC  MAKE MERGE OC/MVC PATTERN
         MVI   TRACKXLE+7,8  MAKE BXLE INCREMENT
         LA    R14,CKDCCW    MAKE ADDRESS LISTS
         LA    R15,CKDCCW2
         LA    R0,CKD
         LA    R1,DATCCW
         LA    R2,DATCCW2
         LA    R3,2048(,R2)  DO IT THE HARD WAY
         LA    R3,DATA-DATCCW2-2048(,R3)
         STM   R14,R3,@CKDCCW
         LA    R1,IOBLOCK
         NEED  IOB           EXPAND IOB MAPPING
         ST    R1,DCBIOBAD+DCB-IHADCB  SET IOB ADDRESS
         LA    R1,ECB        SET ECB ADDRESS
         ST    R1,IOBECBPT-IOBSTDRD+IOBLOCK  IN IOB
         LA    R14,CKDCCW    SET FIRST CCW CHAIN
         LA    R15,DCB       AND DCB ADDRESS
         STM   R14,R15,IOBSTART-IOBSTDRD+IOBLOCK
         ST    R15,DB
         MVI   DB,X'90'      MAKE OPEN INPUT/REREAD
         MVI   IOBFLAG1-IOBSTDRD+IOBLOCK,IOBCMDCH+IOBUNREL
         LA    R14,NEWCCHH+3
         LA    R15,5
         LA    R0,CKDCCW
         STM   R14,R0,CKDCCW  PREPARE FIRST CCW CHAIN
         MVI   CKDCCW,X'31'  SEARCH ID EQUAL
         MVI   CKDCCW+4,X'40'  CC
         MVI   CKDCCW+8,X'08'  TIC *-8
         LA    R0,256        LOOP 256 TIMES
         LM    R14,R15,=X'1200000040000008'  PATTERN READ COUNT
         LA    R1,CKD        OUTPUT COUNT FIELDS
         OR    R14,R1        OR ADDRESS INTO PATTERN
         LA    R1,CKDCCW2    ADDRESS OF FIRST CCW
         LA    R2,8          CONSTANT
CKDLOOP  STM   R14,R15,0(R1) MAKE CCW
         ALR   R14,R2        MAKE NEXT COUNT ADDRESS
         AR    R1,R2         MAKE NEXT CCW ADDRESS
         BCT   R0,CKDLOOP    REPEAT FOR ALL
         SR    R1,R2         GET LAST CCW
         MVI   4(R1),0       TURN CMD CHAINING OFF
         LA    R14,NEWCCHH+3
         LA    R15,5
         LA    R0,DATCCW
         STM   R14,R0,DATCCW  PREPARE SECOND CCW CHAIN
         MVI   DATCCW,X'31'  SEARCH ID EQUAL
         MVI   DATCCW+4,X'40'  CC
         MVI   DATCCW+8,X'08'  TIC *-8
         LA    R0,256        LOOP 256 TIMES
         LM    R14,R15,=X'1E00000040000008'  PATTERN READ C/K/D
         LA    R1,DATA       OUTPUT COUNT AND DATA FIELDS
         OR    R14,R1        OR ADDRESS INTO PATTERN
         LA    R1,DATCCW2    ADDRESS OF FIRST CCW
         LA    R2,8          CONSTANT
DATLOOP  STM   R14,R15,0(R1) MAKE CCW
         ALR   R14,R2        MAKE NEXT COUNT ADDRESS
         AR    R1,R2         MAKE NEXT CCW ADDRESS
         BCT   R0,DATLOOP    REPEAT FOR ALL
         SR    R1,R2         GET LAST CCW
         MVI   4(R1),0       TURN CMD CHAINING OFF
         L     R1,CVTPTR
         NUSE  CVT,R1
         L     R1,CVTTCBP
         L     R1,4(,R1)     CURRENT TCB
         NUSE  TCB,R1
         L     R1,TCBTIO     GET TIOT
         NUSE  TIOT,R1
         XR    R2,R2         CLEAR LENGTH IC
SCANTIOT CLI   TIOELNGH,0    LAST ENTRY ?
         BE    USEROPEN      YES; LET USER BOMB ON IT
         CLC   DCBDDNAM-IHADCB+DCB(8),TIOEDDNM  SAME DDNAME ?
         BE    SCANTIOF      YES; CHECK IT
         IC    R2,TIOELNGH   LENGTH OF THIS ENTRY
         AR    R1,R2         SPACE TO NEXT ENTRY
         B     SCANTIOT      AND CHECK IT
SCANTIOF CLI   TIOEWTCT,1    ONE UCB ?
         BNE   USEROPEN      NO; IGNORE
         L     R3,TIOEFSRT-1  GET UCB ADDRESS
         LA    R3,0(,R3)     CLEAN IT
         LTR   R3,R3
         BZ    USEROPEN      SKIP DD DUMMY
         IC    R2,TIOELNGH   GET LENGTH OF THIS ENTRY
         AR    R1,R2
         CLI   TIOELNGH,0    LAST ENTRY ?
         BE    NOCONCAT      YES; OK
         CLI   TIOEDDNM,C' '  CONCATENATION ?
         BNH   USEROPEN      YES; DO NOT ACCEPT
         NUSE  UCB,R3
NOCONCAT CLI   18(R3),X'20'  RESIDES ON DISK ?
         BNE   USEROPEN      NO; IGNORE
         DROP  R1
         MVC   VOLSER,UCBVOLI  AND VOLUME SERIAL
         LA    R1,TEMPSAVE   BUILD EXIT LIST
         STCM  R1,7,DCBEXLSA-IHADCB+DCB
         MVC   TEMPSAVE+1(3),@DATA+1  USE DATA AREA FOR WORK
         MVI   TEMPSAVE,X'87'  MAKE JFCB
         MVI   TEMPSAVE+28,X'07'  LOOK FOR JFCB EXIT
         BAL   R9,FINDEX
         LTR   R1,R1         USER EXIT ?
         BZ    DORDJFCB      NO; DO IT
         L     R14,@DATA     GET RDJFCB JFCB ADDRESS
         MVC   0(176,R14),0(R1)  MOVE IT FROM USER
         B     DDRDJFCB      SKIP MY READ
DORDJFCB RDJFCB MF=(E,DB)    READ JFCB
         BXH   R15,R15,USEROPEN  GET OUT IF BAD
DDRDJFCB L     R1,@DATA      A(DSN)
         NUSE  JFCB,R1
         MVC   MEMBER,JFCBELNM  SAVE MEMBER NAME
         OI    JFCBTSDM,X'0A'  SET NO-REWRITE
         XC    DCBFDAD(15),DCBFDAD  CLEAR
         MVN   DCBDEVT,UCBTBYT4  SAVE DISK SUB-TYPE
         XR    R15,R15
         IC    R15,DCBDEVT   GET DISK SUB-TYPE
         L     R14,CVTPTR .   GET CVT
         L     R14,CVTZDTAB-CVTMAP(,R14)  GET CVT DEVICE POINTER
         IC    R15,0(R15,R14) .  GET INDEX TO DEVICE ENTRY
         AR    R14,R15 .       GET ENTRY FOR THIS TYPE
         STCM  R14,7,DCBDVTBA  SAVE DEVICE CONSTANT ADDRESS
         AIF   (&MVS).TRKCAP      USE TRKCALC                   GP12050
         LH    R15,4(,R14) .   GET BLOCK SIZE
         TM    UCBFL5-UCB(R3),UCBEXTSN .   EXTENDED SENSE DEVICE ?
         BZ    DVTCAP        NO; SKIP RECALCULATION
         XR    R0,R0 .
         IC    R0,6(,R14) .   GET OVERHEAD
         TM    9(R14),8 .     TWO BYTE OVERHEAD ?
         BZ    *+8 .         NO
         LH    R0,6(,R14) .   GET FULL OVERHEAD
         SR    R15,R0 .       ADJUST
         XR    R0,R0
         IC    R0,8(,R14) .   GET ADJUSTMENT TO ADJUSTMENT
         AR    R15,R0 .       FINAL ADJUSTED SIZE
DVTCAP   ST    R15,TRKCAP    SET RECALCULATED BLOCKSIZE
         AGO   .COMCAP                                          GP12050
.TRKCAP  LR    R9,R14        COPY DEVICE TABLE ADDRESS          GP12050
         TRKCALC FUNCTN=TRKBAL,UCB=(R3),R=1,REMOVE=YES          GP12050
         ST    R0,TRKCAP                                        GP12050
.COMCAP  OI    DCBDEVT,X'20'  MAKE DISK MAIN TYPE
         LA    R14,MERGJFCB  GET JFCB TO DCB MERGE LIST
         BAL   R9,MERGES     DO MERGES
         TM    DCBMACR,DCBMRGET  QSAM ?
         BZ    *+12          NO; SKIP
         LA    R14,QSAMJFCB
         BAL   R9,MERGES     MERGE EROPT
         LA    R2,VOLSER
         LA    R3,176(,R1)
         LA    R0,X'C1'      SEEK OPTION IN CAMLST
         SLL   R0,24          SHIFT OVER
         STM   R0,R3,TEMPSAVE+8
         XR    R0,R0         JUST IN CASE
         OBTAIN TEMPSAVE+8   READ IT IN
         CLI   0(R3),C'4'    VTOC DSCB4 ?
         BE    SAVEVTOC      YES; SPECIAL HANDLING
         BXH   R15,R15,USEROPEN  GET OUT IF OBTAIN FAILED
         NEED  DSCB1         DECLARE IT
         USING DS1FMTID,R3
         MVC   DSORG,DS1DSORG   SAVE DCB OPTIONS
         MVC   RECFM,DS1RECFM
         MVC   BLKSI,DS1BLKL
         MVC   LRECL,DS1LRECL
         MVC   KEYLEN,DS1KEYL
         LR    R1,R3         COPY DSCB ADDRESS
         LA    R14,MERGDSCB  GET MERGE PARAMETERS
         BAL   R9,MERGES     MERGE TO DCB
         DROP  R3
         CLI   MEMBER,C' '   MEMBER NAME ?
         BNH   NULLMEMB      NO; CLEAR IT OUT
         TM    DSORG,JFCORGPO  PARTITIONED DATASET ?
         BZ    NULLMEMB      NO; CLEAR MEMBER
         B     OPENIT
SAVEVTOC MVI   DSORG,JFCORGDA
         MVI   RECFM,JFCFIX
         MVI   KEYLEN,L'JFCBDSNM
         MVC   LRECL,=H'96'
         MVC   BLKSI,=H'96'
NULLMEMB MVC   MEMBER,=CL8' '  CLEAR MEMBER
OPENIT   EQU   *
         OPEN  MF=(E,DB),TYPE=J     OPEN THE DCB
         TM    DCBOFLGS-IHADCB+DCB,DCBOFOPN  OPEN ?
         BZ    USEROPEN      NO; BOMB
         CLI   MEMBER,C' '   MEMBER NAME TO BE DONE ?
         BNH   NOTMEMB       NO
         L     R4,@DATA      GET DATA AREA BACK
         L     R3,@DATCCW2   GET SECOND CCW CHAIN
         XC    0(24,R3),0(R3)  CLEAR IT
         LA    R2,MEMBER
         ST    R2,0(,R3)     M/T SEARCH KEY .LE.
         ST    R3,8(,R3)     TIC *-8
         ST    R4,16(,R3)    BUFFER ADDRESS
         OC    0(24,R3),SCANCCW1  MAKE SCAN CCWS
         MVC   IOBSTART+1-IOBSTDRD+IOBLOCK(3),@DATCCW+1  CCW ADDR
         MVI   NEWTTR+2,1    SEARCH FROM RECORD 1 ON
         BAL   R9,READONLY   SCAN FOR MEMBER KEY
         BAL   R9,WAITER     WAIT ON I/O
         CLI   ECB,X'7F'
         BNE   SYNCHSYN
         LH    R2,0(,R4)     GET BLOCK LENGTH
         CH    R2,SCANCCW3+6  VALID LENGTH ?
         BNL   SYNCHSYN      NO
         SH    R2,=H'2'      ALLOW FOR LENGTH OF LENGTH
         BNP   SYNCHSYN      NO; IGNORE
         XR    R1,R1         IC REG
LOOPMEMB CLC   MEMBER,2(R4)  CORRECT MEMBER ?
         BE    FOUNDMEM      YES
         BL    SYNCHSYN
         NI    13(R4),X'1F'  KILL FLAG BITS
         IC    R1,13(,R4)    GET HALF-WORD LENGTH
         SLL   R1,1          MAKE BYTES
         LA    R1,12(,R1)    ADD BASIC OVERHEAD
         AR    R4,R1         POINT TO NEXT ENTRY
         SR    R2,R1         SUBTRACT FROM RESIDUAL
         BP    LOOPMEMB      TRY AGAIN
         B     SYNCHSYN      MEMBER NOT FOUND
FOUNDMEM MVC   NEWTTR(3),10(R4)  COPY MEMBER TTR
         L     R1,NEWTTR
         SRL   R1,8          MAKE 0TTR
         BCTR  R1,0          SEARCH FOR PREVIOUS RECORD
         SLL   R1,8          FINAGLE
         ST    R1,NEWTTR     SET IT BACK
         OI    FLAG,FGFIND   SHOW TTR CHANGED
NOTMEMB  MVC   DCBDSRG1,DSORG          COPY DSORG
         MVI   DCBDSRG2,0
         LA    R1,IOBLOCK
         ST    R1,DCBIOBAD             SET IOB
         MVI   DCBQSLM,DCB1DVDS        ONE DEVICE
         MVC   DCBTIOT,DCBTIOT-IHADCB+DCB  TIOT OFFSET
         MVC   DCBIFLGS,DCBIFLG        IFLAGS
         MVC   DCBDEBA,DCBDEBA-IHADCB+DCB  DEB ADDRESS
         LA    R14,EXGET               GET ROUTINE
         LA    R15,EXWAIT    WAIT ROUTINE FOR BSAM, NO NOTE/POINT
         MVC   DCBMACRF,DCBMACR        COPY FUNCTION
         TM    DCBMACRF,DCBMRGET       QSAM ?
         BNZ   *+8                     YES
         LA    R14,EXREAD              ELSE SET FOR READ
         STM   R14,R15,DCBGET          SET GET,READ/CHECK
         MVI   TEMPSAVE+28,X'05'  LOOK FOR DCB EXIT
         BAL   R9,FINDEX     LOOK FOR EXIT LIST
         LTR   R15,R1        ANY ?
         BZ    NODCBEXI      NO
         LR    R1,R13
         SH    R1,=AL2(XSAMWORK-XSAMPRFX)
         STCM  R1,7,DCBCNTRL+1  MAKE REALLY SURE
         LR    R1,R10        COPY DCB ADDRESS
         MVI   DCBOFLGS,DCBOFUEX+DCBOFIOF  MAKE PARTIALLY OPEN
         L     R2,4(,R13)    GET USER'S SAVE AREA BACK
         LM    R2,R12,28(R2)  RESTORE USER REGISTERS
         DROP  R11
         SYNCH (15)          INVOKE USER EXIT
         LR    R10,R1        RESTORE DCB
         L     R12,DCBCNTRL  GET WORK PREFIX
         LA    R13,XSAMWORK-XSAMPRFX(,R12)  GET WORK AREA
         L     R12,XSAMPBAS-XSAMPRFX(,R12)  GET BASE
NODCBEXI CLI   DCBRECFM,0    ANY ?
         BNE   *+10          DON'T CLOBBER
         MVC   DCBRECFM,RECFM          RECORD FORMAT
         OC    DCBBLKSI,DCBBLKSI
         BNZ   *+10
         MVC   DCBBLKSI,BLKSI          BLOCKSIZE
         MVC   DCBIOBA,DCBIOBAD        IOB PREFIX - NONE
         LA    R14,GOODEXIT            EOB READ ROUTINE
         LR    R15,R14                 EOB WRITE
         XR    R0,R0
         ICM   R0,3,DCBLRECL
         BNZ   *+8
         ICM   R0,3,LRECL              RECLEN
         LR    R1,R13                  NOTE/POINT
         SH    R1,=AL2(XSAMWORK-XSAMPRFX)  GET PREFIX
         STM   R14,R1,DCBEOBR
         TM    DCBMACRF,DCBMRGET       QSAM ?
         BNZ   DONEQSAM
         TM    DCBRECFM,X'C0'  RECFM=U ?
         BM    DONOTPT
         XR    R0,R0
         IC    R0,DCBKEYLE   ADD KEYLENGTH
         AH    R0,DCBBLKSI   TO BLOCKSIZE
         STH   R0,BLKSI      SAVE FOR READ
DONOTPT  TM    DCBMACRF,DCBMRPT1  NOTE/POINT/CHECK TO BE USED ?
         BZ    DONEUDCB      NO; USE DUMMY WAIT AND READ CODE
         MVC   0(18,R1),=X'47F0F00C58F0F01407FFE7E258F0F01807FF'
         LA    R1,EXNPREAD   USE DUMMY READ ROUTINE
         STCM  R1,7,DCBREAD+1
         LA    R1,EXCHECK    AND DO EVERYTHING IN CHECK
         STCM  R1,7,DCBCHECK+1
         B     DONEUDCB      FINISHED NOTE/POINT/FIND
DONEQSAM L     R14,@DATCCW2  FAKE HIGHER THAN BUFFER END
         L     R15,@DATCCW     BUFFER END
         XR    R2,R2
         ICM   R2,3,DCBPRECL
         BNZ   *+8
         ICM   R2,3,BLKSI
         LA    R3,EXGET                QSAM EOB
         STM   R14,R3,DCBEOBAD
         MVI   DCBBUFNO,1    ***FAKE IT***
DONEUDCB TM    DCBOPTCD,DCBOPTQ  ASCII ?
         BNZ   USEROPEN      YES; SKIP
         CLI   DCBBUFOF,0    BUFFER OFFSET ?
         BNE   USEROPEN
         OC    DCBBLKSI,DCBBLKSI  ANY ?
         BZ    USEROPEN
         TM    DCBRECFM,X'C0'  ANY RECFM ?
         BNZ   DONEUREC
         TM    DCBRECFM,X'20'  D ?
         BNZ   USEROPEN
         OI    DCBRECFM,X'C0'  FAKE 'U'
DONEUREC TM    DCBRECFM,X'80'  U/F ?
         BNZ   DONERECV
         TM    DCBRECFM,DCBRECSB  SPANNED ?
         BNZ   USEROPEN
DONERECV TM    DCBBFTEK,DCBBFT-DCBBFTS  FUNNY BUFFERING ?
         BNZ   USEROPEN
DONEDONE MVI   DCBOFLGS,DCBOFOPN+DCBOFUEX  OPEN DCB
         XR    R0,R0
         IC    R0,KEYLEN     GET KEYLENGTH
         AH    R0,DCBBLKSI   ADD BLOCKSIZE
         STH   R0,DCBBLKSI   UPDATE FOR 'U' WITH KEYS
         CLI   DCBBUFNO,0    ANY BUFFERS TO GET ?
         BE    MAKEREAD      NO
         TM    DCBBUFCB+3,1  ALREADY HAVE A POOL ?
         BZ    MAKEREAD      YES; DON'T DO IT AGAIN
         ICM   R0,4,DCBBUFNO + NUMBER OF BUFFERS
         LR    R1,R10        DCB
         GETPOOL (1),(0)     GET A BUFFER POOL
MAKEREAD LA    R0,8          MAKE BXLE INCREMENT
         XR    R1,R1
         LA    R15,1         FORCE BXLE BRANCH FOR TRACK READ
         STM   R15,R1,BLOCKXLE
         STM   R15,R1,TRACKXLE
         LA    R9,GOODEXIT   SET NORMAL EXIT
         B     READAHED      READ AHEAD AND TAKE GOOD EXIT
         SPACE 2
USEROPEN TM    DCB+DCBOFLGS-IHADCB,DCBOFOPN  MY DCB OPEN ?
         BZ    USERNTMY
         LA    R1,DCB
         ST    R1,DB
         MVI   DB,X'80'
         CLOSE MF=(E,(1))
USERNTMY MVC   DCBDDNAM(L'EMPIRE),EMPIRE  RESTORE THE FOUNDATION
         MVC   DCBRECFM,ANACREON
         MVC   DCBREAD(L'SMYRNA),SMYRNA
         MVC   DCBCIND1(L'KALGAN),KALGAN
         MVC   DCBCNTRL+1(3),=X'000001'  KILL THE CNTRL MODULE
         ST    R10,DB        CANNOT USE XSAM - OPEN SAM
         MVI   DB,X'80'
         MVI   TEMPSAVE+28,X'07'  JFCB IN EXLST ?
         BAL   R9,FINDEX     CHECK IT
         LTR   R1,R1
         BNZ   USEROPNJ      YES - OPENJ
         LA    R1,DB
         OPEN  MF=(E,(1))
         B     CLOSFREE
USEROPNJ LA    R1,DB
         OPEN  MF=(E,(1)),TYPE=J
CLOSFREE LR    R1,R13        GET WORK AREA
         SH    R1,=AL2(XSAMWORK-XSAMPRFX)  GET PREFIX
         L     R0,GETMLENG    AND LENGTH
         L     R13,4(,R13)   GET USER'S SAVE AREA
         FREEMAIN R,LV=(0),A=(1)  FREE THE WORKAREA
         LM    R14,R12,12(R13)  RESTORE ALL REGS
         LA    R15,4         SET CODE 4
         BR    R14           RETURN TO CALLER WITH OS OPEN
         SPACE 2
EXGET    ENTER EOF=EOFABEND  COMMON ENTRY CODE
         LM    R15,R1,BLOCKXLE  GET NEXT RECORD
         BXLE  R15,R0,EXGETS   HAVE ANOTHER RECORD
EXGETA   LM    R3,R5,TRACKXLE  GET ANOTHER CCW
         BXLE  R3,R4,EXGETB  HAVE ANOTHER ?
         BAL   R9,READTRAK   READ ANOTHER TRACK
         LM    R3,R5,TRACKXLE  GET NEW CCW POINTERS
EXGETB   STM   R3,R5,TRACKXLE     AND SAVE UPDATED POINTERS
         L     R15,0(,R3)    POINT TO DATA
         MVC   OLDCCHH+3(5),0(R15)  SAVE FOR NOTE
         XR    R0,R0         CLEAR FOR LENGTH ICM
         XR    R2,R2         CLEAR FOR KEYLENGTH IC
         ICM   R0,3,6(R15)   GET LENGTH
         BZ    EOFSYNCH      ZERO DATA LENGTH - END-FILE
         IC    R2,5(,R15)    KEY LENGTH
         LA    R15,8(,R15)   SKIP OVER COUNT FIELD
         AR    R15,R2         AND OVER KEY
         LR    R1,R15
         AR    R1,R0         LAST BYTE+1
         TM    DCBRECFM,X'C0'  'U' ?
         BNO   EXGETK        NO
         CLI   DCBKEYLE,0    INCLUDE KEYS ?
         BE    EXGETK
         SR    R15,R2        INCLUDE KEY
         AR    R0,R2          AND SET LENGTH
EXGETK   STH   R0,DCBBLKSI   UPDATE BLOCKSIZE
EXGETS   L     R4,4(,R13)    GET USER'S SAVE AREA BACK
         TM    DCBRECFM,X'C0'  TEST RECFM
         BNM   EXGETZ        UNDEFINED
         LH    R0,DCBLRECL   GET LRECL
         TM    DCBRECFM,X'80'  FIXED ?
         BNZ   EXGETX        YES; STASH BACK
         ICM   R0,3,0(R15)    VARIABLE - INSERT V LENGTH
         TM    DCBMACRF,DCBMRMVG  MOVE MODE ?
         BZ    EXGETX        NO
         LA    R2,4
         AR    R15,R2        SKIP RDW
         SR    R0,R2         ADJUST LENGTH
         BNM   EXGETX
         L     R1,=X'80002000'
         SVC   13            002 ABEND - INVALID RDW
EXGETX   STH   R0,DCBLRECL   SET NEW LENGTH
EXGETZ   CR    R15,R1        DID WE GO PAST LAST RECORD ?
         BNL   EXGETA        YES; READ NEXT TRACK
         LR    R2,R15        COPY CURRENT RECORD ADDRESS
         AR    R2,R0         ADD LENGTH
         CR    R2,R1         LAST RECORD IN BLOCK ?
         BL    *+6           NO
         LR    R1,R15        TERMINATE BXLE NEXT TIME
         STM   R15,R1,BLOCKXLE  SET FOR NEXT TIME
         TM    DCBMACRF,DCBMRMVG  MOVE MODE ?
         BZ    EXGET1        NO; OK AS IS
         LR    R14,R15       FROM
         LR    R15,R0        LENGTH
         LR    R1,R0         LENGTH
         L     R0,20(,R4)    USER'S R0
         MVCL  R0,R14        MOVE TO USER
         L     R15,20(,R4)   USER'S RECORD ADDRESS
EXGET1   ST    R15,24(,R4)    RETURN WITH RECORD ADDRESS
         B     GOODEXIT      RETURN OK
         SPACE 2
*        READ ROUTINE FOR BSAM/BPAM WITH NOTE/POINT
*
EXNPREAD MVI   0(R1),X'7F'   POST DECB
         B     EXWAIT-EXNPREAD(,R15)
         SPACE 2
*        READ ROUTINE FOR BSAM WITHOUT CHECK/NOTE/POINT
*        CHECK ROUTINE FOR BSAM WITH CHECK AND FOR BPAM
*
EXCHECK  DS    0H            USE SAME CODE
EXREAD   ENTER DECB=YES
         MVI   0(R8),X'48'   I/O PURGED IF AFTER EOF
         TM    FLAG,FGEOF    AFTER EOF ?
         BNZ   GOODEXIT      DON'T SUPPORT
         MVI   0(R8),X'7F'   SET GOOD COMPLETION
         LM    R3,R5,TRACKXLE  GET TRACK VALUES
         BXLE  R3,R4,EXREADB   HAVE ANOTHER
         BAL   R9,READTRAK   READ ANOTHER TRACK
         LM    R3,R5,TRACKXLE
EXREADB  STM   R3,R5,TRACKXLE   SAVE UPDATED POINTERS
         L     R4,0(,R3)     COPY FROM ADDRESS
         MVC   OLDCCHH+3(5),0(R4)  SAVE FOR NOTE
         XR    R5,R5         CLEAR FOR LENGTH ICM
         XR    R0,R0         CLEAR FOR KEYLENGTH IC
         ICM   R5,3,6(R4)    GET LENGTH
         BNZ   *+8           OK IF NOT EOF
         MVI   0(R8),X'41'   SET EOF
         IC    R0,5(,R4)    KEY LENGTH
         LA    R4,8(,R4)   SKIP OVER COUNT FIELD
         AR    R4,R0         AND OVER KEY
         CLI   DCBKEYLE,0    USER WANT KEYS ?
         BE    EXREADK       NO
         SR    R4,R0
         AR    R5,R0         ADJUST TO INCLUDE KEYS
EXREADK  CLI   0(R8),X'41'   EOF ?
         BE    EXREADU       YES; DON'T CHANGE
         TM    DCBRECFM,X'C0'   U ?
         BM    EXREADF       NO
         STH   R5,DCBLRECL   SET LENGTH
         B     EXREADU
EXREADF  STH   R5,DCBBLKSI   SET IN DCB
EXREADU  L     R0,12(,R8)    GET DECB ADDRESS
         LH    R1,6(,R8)     AND LENGTH
         TM    4(R8),X'80'   'S' ?
         BZ    *+8
         LH    R1,DCBBLKSI   USE FULL VALUE
         LTR   R1,R1         VALID LENGTH ?
         BP    *+6           YES
         LR    R1,R5         COPY LENGTH READ
         XC    FAKEIOB(USERDCB-FAKEIOB),FAKEIOB  CLEAR PART
         LR    R6,R1         GET USER'S LENGTH
         SR    R6,R5         GET RESIDUAL LENGTH
         BNP   *+8
         ST    R6,FAKEIOB+12  MAKE FAKE CSW RESIDUAL LENGTH
         LA    R6,FAKEIOB
         STCM  R6,7,DCBIOBAA  SET FAKE IOB IN DCB
         ST    R6,16(,R8)    AND INTO DECB
         CR    R1,R5         USER'S LENGTH LONGER ?
         BL    *+6           NO
         LR    R1,R5         USE SHORTER VALUE
         LTR   R5,R5         ANYTHING TO COPY ?
         BZ    EXREADT       NO
         MVCL  R0,R4         MOVE BLOCK
EXREADT  CLI   0(R8),X'41'   EOF ?
         BNE   GOODEXIT
         B     EOFSYNCH      YES; TAKE EODAD
         SPACE 2
EXNOTE   ENTER ,             BSAM/BPAM NOTE
         BAL   R9,EXNOTCH    GO TO COMMON CONVERSION
         L     R4,4(,R13)    GET USER'S SAVE AREA
         MVC   24(4,R4),DB   SET TTR
         MVC   20(4,R4),TRKCAP  SET BLOCKSIZE
         B     GOODEXIT
         SPACE 1
EXPOINT  ENTER ,             BSAM/BPAM POINT/FIND
         LR    R2,R0         SAVE R0
         TM    FLAG,FGCKD    ASYNCHRONOUS READ ISSUED ?
         BZ    EXPOINT2      NO
         BAL   R9,WAITER     WAIT ON IT
EXPOINT2 CR    R2,R10        R0=R1 => FIND
         BNE   *+8
         L     R2,DCBRELAD   GET TTR WHERE FIND STASHED IT
         NI    DCBCIND2,255-DCBCNFEO  TURN EOF BIT OFF
         NI    FLAG,255-FGEOF-FGEOFT-FGCKD  ALSO MINE
         OI    FLAG,FGFIND   SHOW TTR CHANGED
         LR    R0,R2         COPY FOR CONVERSION
         L     R1,DCBDEBAD-IHADCB+DCB  GET DEB ADDRESS
         LA    R2,NEWCCHH    NEW DISK ADDRESS
         LA    R3,TEMPSAVE   TEMP SAVE AREA
         STM   R9,R13,0(R3)  SAVE
         L     R14,CVTPTR
         NEED  CVT
         L     R15,CVTPCNVT-CVTMAP(,R14)  TTR=>ABS CONVERSION
         BALR  R14,R15       CONVERT
         LM    R9,R13,0(R3)  RESTORE REGS
         BXLE  R15,R15,EXPOINT3  OK IF VALID TTR
         MVI   ECB,X'42'     ELSE POST OUT-OF-EXTENT
         OI    FLAG,FGCKD    FAKE I/O ISSUED
         B     GOODEXIT
EXPOINT3 XR    R2,R2
         MVC   OLDCCHH,NEWCCHH  SET FOR NOTE
         ICM   R2,1,OLDCCHH+7  GET RECORD NUMBER
         BZ    *+6           IF ZERO, LEAVE IT ALONE
         BCTR  R2,0          ELSE LOOK FOR PREVIOUS
         STC   R2,OLDCCHH+7  SET BACK FOR POSITIONING
         BAL   R9,EXNOTCH    CONVERT TO REPOSITION TTR
         MVC   NEWTTR,DB     SET FOR READ
         B     MAKEREAD      GO TO READ-AHEAD AND EXIT CODE
         SPACE 1
EXNOTCH  L     R1,DCBDEBAD-IHADCB+DCB  GET DEB ADDRESS
         LA    R2,OLDCCHH    DISK ADDRESS
         LA    R3,TEMPSAVE   TEMP SAVE AREA
         STM   R9,R13,0(R3)  SAVE
         L     R14,CVTPTR
         NEED  CVT
         L     R15,CVTPRLTV-CVTMAP(,R14)  ABS=>TTR CONVERSION
         BALR  R14,R15       CONVERT
         LM    R9,R13,0(R3)  RESTORE REGS
         ST    R0,DB         STASH FOR CALLER
         BR    R9            RETURN
         SPACE 2
GOODEXIT L     R13,4(,R13)   GET USER'S SAVE AREA
         LM    R14,R12,12(R13)  RESTORE
EXWAIT   XR    R15,R15       SET GOOD RETURN CODE
         BR    R14
         SPACE 1                                                 79095
         SPACE 3
READTRAK TM    FLAG,FGEOF    END-FILE ?
         BNZ   EOFABEND      YES; QUIT
         TM    FLAG,FGCKD    WAS READ COUNT CHAIN STARTED ?
         BNZ   READCKDW      YES; DO A WAIT
READTRA2 ST    R9,TEMPSAVE+28  SAVE RETURN REG
         BAL   R9,READCOUN   READ TRACK COUNTS
         L     R9,TEMPSAVE+28   RESTORE RETURN
READCKDW WAIT  ECB=ECB       AWAIT I/O COMPLETION
         NI    FLAG,255-FGEOF-FGEOFT-FGCKD  RESET FLAGS
         CLI   ECB,X'7F'     COMPLETE WITHOUT ERRORS ?
         BE    READGEN2      THIS IS A VERY FULL TRACK
         CLI   ECB,X'42'     OUT-OF-EXTENT ?
         BNE   READCK41      NO
         TM    FLAG,FGFIND   TTR CHANGED ?
         BNZ   SYNCHSYN      FAIL INVALID EXTENT
         L     R3,@CKDCCW2   ELSE FAKE EOF INSTEAD OF EOE
         LA    R1,8(,R3)
         ST    R1,IOBCMDA-1-IOBSTDRD+IOBLOCK
         L     R1,0(,R3)
         MVC   0(5,R1),NEWCCHH+3  FAKE COUNT FIELD
         XC    5(3,R1),5(R1)  WITH ZERO LENGTHS
         B     READGEN2      CONTINUE
READCK41 CLI   ECB,X'41'     SEE IF ERROR DETECTED
         BNE   SYNCHSYN      SCHEDULE SYNAD
         CLI   IOBSENS1-IOBSTDRD+IOBLOCK,IOBS1B4  NO RCD FOUND ?
         BE    READGEN2      YES; WE ARE OK
SYNCHSYN ABEND  666,DUMP     *****TEMPORARY*****
READGEN2 MVC   OLDTTR,NEWTTR
         NI    FLAG,255-FGFIND  CHANGED TTR OK
         L     R3,@CKDCCW2   GET ADDRESS OF FIRST CKD CCW
         L     R1,IOBCMDA-1-IOBSTDRD+IOBLOCK  GET CSW CCW
         LA    R1,0(,R1)     CLEAR
         CR    R1,R3         MUST BE HIGHER
         BNH   READTRA2      RETRY THE I/O
         SR    R1,R3         MAKE SIZE
         LA    R5,8          CONSTANT
         SR    R1,R5         NUMBER OF CCWS*8
         SRL   R1,3          NUMBER OF CCWS
         LR    R0,R1         COPY FOR BCT
         XR    R14,R14       FOR IC OF RECORD NUMBER TEST
         XR    R15,R15
         IC    R15,NEWCCHH+L'NEWCCHH-1  GET PREVIOUS RECORD NO.
         LM    R1,R2,=X'1E00000040000008'  PATTERN CCW
         O     R1,@DATA      MAKE FIRST DATA ADDRESS
         L     R4,@CKD       POINT TO COUNT FIELDS READ
         L     R7,@DATCCW2   POINT TO READ DATA CCWS
         L     R3,=X'FF000000'  CCW LENGTH MASK
         MVI   0(R7),0       SET NO READ FLAG
READGENN LA    R15,1(,R15)   UPDATE RECORD NUMBER
         IC    R14,4(,R4)    GET RECORD READ
         CR    R14,R15       ECC REREAD ?
         BNE   READGENT      NOT EQUAL - KILL CHAIN
         OC    6(2,R4),6(R4)  EOF ?
         BNZ   READGENS      NO; CONTINUE
         SR    R7,R5         BACK UP ONE CCW
         MVI   4(R7),0       TERMINATE THE CHAIN
         AR    R7,R5         RESET
         XR    R2,R2         FORCE END
         STM   R1,R2,0(R7)   MAKE NEW CCW
         MVI   0(R7),0       KILL COMMAND
         MVC   0(8,R1),0(R4)  MAKE DATA LENGTH=0
         AR    R7,R5         FAKE OUT ONE MORE FOR EXGET
         OI    FLAG,FGEOFT   SHOW EOF ON TRACK
         B     READGENT      NOW TRUNCATE
READGENS NR    R2,R3         KILL OLD LENGTH
         XR    R6,R6
         IC    R6,5(,R4)     GET KEY LENGTH
         AH    R6,6(,R4)     ADD DATA LENGTH
         AR    R6,R5         ADD COUNT FIELD LENGTH
         OR    R2,R6         PLACE INTO CCW
         STM   R1,R2,0(R7)   MAKE NEW CCW
         ALR   R1,R6         POINT TO NEXT AVAILABLE FIELD
         AR    R4,R5         NEXT COUNT FIELD TO BE DONE
         AR    R7,R5         NEXT OUTPUT CCW
         BCT   R0,READGENN   REPEAT FOR ALL CCWS
READGENT SR    R7,R5         BACK UP TO LAST ONE
         MVI   4(R7),0       KILL CMD CHAINING
         STCM  R7,7,TRACKXLE+9   SET ADDRESS OF LAST CCW
         L     R7,@DATCCW2   RELOAD
         STCM  R7,7,TRACKXLE+1   INIT FIRST CCW TO BE DONE
         CLI   0(R7),0       CCW NOT CHANGED ?
         BNE   READDATA      NO; CHANGED.  READ DATA
         TM    FLAG,FGEOF+FGEOFT  EOF ON TRACK ?
         BNZR  R9            RETURN EOF ONLY
         L     R1,OLDTTR     GET CURRENT TTR
         SRL   R1,16         SHIFT OUT THE R AND Z BYTES
         LA    R1,1(,R1)     SET FOR NEXT TRACK
         SLL   R1,16         REPOSITION TT00
         ST    R1,NEWTTR
         B     READTRAK      SKIP EMPTY TRACK
READDATA MVI   ECB,0         CLEAR ECB
         MVI   IOBFLAG1-IOBSTDRD+IOBLOCK,IOBCMDCH+IOBUNREL
         MVC   IOBSTART+1-IOBSTDRD+IOBLOCK(3),@DATCCW+1  CCW ADDR
         EXCP  IOBLOCK       READ COUNT/KEY/DATA FOR ONE TRACK
READDATW WAIT  ECB=ECB       AWAIT I/O COMPLETION
         CLI   ECB,X'7F'     COMPLETE WITHOUT ERRORS ?
         BNE   SYNCHSYN      TOO BAD - NO RECOVERY AS YET
READNEXT L     R1,OLDTTR     GET CURRENT TTR
         SRL   R1,16         SHIFT OUT THE R AND Z BYTES
         LA    R1,1(,R1)     SET FOR NEXT TRACK
         SLL   R1,16         REPOSITION TT00
         ST    R1,NEWTTR
READAHED TM    FLAG,FGEOF+FGEOFT    EOF READ ?
         BNZR  R9            YES; RETURN TO CALLER
         OI    FLAG,FGCKD    INDICATE READ ISSUED
READCOUN MVC   IOBSTART+1-IOBSTDRD+IOBLOCK(3),@CKDCCW+1  CCW ADDR
READONLY L     R0,NEWTTR
         L     R1,DCBDEBAD-IHADCB+DCB  GET DEB ADDRESS
         LA    R2,NEWCCHH    NEW DISK ADDRESS
         LA    R3,TEMPSAVE   TEMP SAVE AREA
         STM   R9,R13,0(R3)  SAVE
         L     R14,CVTPTR
         NEED  CVT
         L     R15,CVTPCNVT-CVTMAP(,R14)  TTR=>ABS CONVERSION
         BALR  R14,R15       CONVERT
         LM    R9,R13,0(R3)  RESTORE REGS
         BXLE  R15,R15,READONOK
         MVI   ECB,X'42'     FAKE END-EXTENT ON BAD TTR
         BR    R9            RETURN WITHOUT I/O
READONOK MVI   ECB,0
         MVI   IOBFLAG1-IOBSTDRD+IOBLOCK,IOBCMDCH+IOBUNREL
         EXCP  IOBLOCK       READ COUNT/KEY/DATA FOR ONE TRACK
         BR    R9            RETURN TO CALLER
         SPACE 2
EOFSYNCH L     R10,USERDCB   GET USER'S DCB BACK
         OI    FLAG,FGEOF    SET EOF FLAG ON
         OI    DCBCIND2,DCBCNFEO  IN DCB ALSO
         L     R15,DCBEODAD-IHADCB(,R10)  GET EODAD
         L     R13,4(,R13)   GET SAVE AREA
         LM    R0,R12,20(R13)  RESTORE ALL REGISTERS
         BALR  R14,R15       CALL IT
EOFABEND ABEND 620,DUMP      ABEND IF USER RETURNS
         SPACE 2
         ENTRY XSAMCLOS
XSAMCLOS ENTER ,             THIS IS A CLOSE CALL
         ST    R10,DB
         MVI   DB,X'80'      MAKE CLOSE LIST
         L     R1,DCBCNTRL   GET CONTROL ADDRESS
         CLC   =C'XS',XSAMPPON-2-XSAMPRFX(R1)  XSAM AREA ?
         BE    XSAMCLS
         CLOSE MF=(E,DB)     CLOSE THE USER'S DCB
         B     GOODEXIT      AND RETURN
XSAMCLS  TM    FLAG,FGCKD    READ STARTED ?
         BZ    XSAMCLS2       NO
         BAL   R9,WAITER
XSAMCLS2 LA    R1,DCB        GET MY DCB
         STCM  R1,7,DB+1
         CLOSE MF=(E,DB)     CLOSE IT
         MVC   DCBDDNAM(L'EMPIRE),EMPIRE  RESTORE THE FOUNDATION
         MVC   DCBRECFM,ANACREON
         MVC   DCBREAD(L'SMYRNA),SMYRNA
         MVC   DCBCIND1(L'KALGAN),KALGAN
         MVC   DCBCNTRL+1(3),=X'000001'  KILL THE CNTRL MODULE
         B     CLOSFREE      AND QUIT
         SPACE 1
QUICKOUT LM    R14,R12,12(R13)
         LA    R15,8         SET ERROR
         BR    R14           RETURN
         SPACE 1
QUICKABE L     R1,=X'0080A000'  MAKE QUICKY 80A - NO DUMP
         SVC   13
         SPACE 1
MERGES   XR    R15,R15       CLEAR FOR LENGTH IC
MERGLOOP CLI   0(R14),X'FF'  END OF LIST ?
         BER   R9            RETURN TO CALLER
         IC    R15,0(,R14)   INSERT LENGTH-1
         MVC   MERGOC+3(1),1(R14)  DCB OFFSET
         MVC   MERGOC+5(1),1(R14)
         MVC   MERGMV+3(1),1(R14)
         MVC   MERGMV+5(1),2(R14)  JFCB/DSCB OFFSET
         LA    R14,3(,R14)   NEXT ENTRY
         EX    R15,MERGOC    FIELD EMPTY ?
         BNZ   MERGLOOP      NO; SKIP
         EX    R15,MERGMV    ELSE MOVE
         B     MERGLOOP
         SPACE 2
WAITER   WAIT  ECB=ECB       WAIT ON ECB
         NI    FLAG,255-FGCKD  RESET ASYNCHRONOUS I/O FLAG
         BR    R9            RETURN TO CALLER
         SPACE 2
FINDEX   MVC   TEMPSAVE+29(1),TEMPSAVE+28  COPY EXLST TYPE
         OI    TEMPSAVE+29,X'80'  MAKE INTO END-LIST FORM
         LA    R1,1          GET COMPARE VALUE
         CLM   R1,7,DCBEXLSA  USER HAS AN EXIT LIST ?
         BNL   FINDEX0       NO
         ICM   R1,7,DCBEXLSA  GET USER LIST
FINDEXLP CLC   0(1,R1),TEMPSAVE+28  MATCH ?
         BE    FINDEXLT      YES
         CLC   0(1,R1),TEMPSAVE+29  AT END ?
         BNE   FINDEXIN      NO; BUMP
FINDEXLT ICM   R1,7,1(R1)    LOAD ADDRESS
         BR    R9            RETURN
FINDEXIN TM    0(R1),X'80'   LAST ENTRY ?
         LA    R1,4(,R1)     SPACE TO NEXT
         BZ    FINDEXLP      NO; TRY IT
FINDEX0  XR    R1,R1         NOT FOUND OR NO LIST
         BR    R9
         EJECT ,
GETMLENG DC    A((XSAMWLEN+4095)/4096*4096)  MAKE PAGE SIZE
FILLER   DC    0A(0),5XL8'0'
         ORG   FILLER
PATDCB   DCB   DDNAME=USERS,MACRF=E,EXLST=5   PATTERN DCB
PATDCBL  EQU   *-PATDCB
SCANCCW1 CCW   X'E9',0,X'40',8  M/T SEARCH KEY <=
SCANCCW2 CCW   8,0,0,0          TIC *-8
SCANCCW3 CCW   6,0,0,256     READ DATA
PERGOC   OC    0(0,R10),0(R10)  PATTERN FOR MERGE OC
PERGMV   MVC   0(0,R10),0(R1)   PATTERN FOR MERGE MVC
         SPACE 1
MERGJFCB MRG   BUFOF,JFCBUFOF,BASE=INFMJFCB
         MRG   BUFNO,JFCBUFNO
         MRG   BFALN,JFCBFALN
         MRG   BUFL,JFCBUFL
         MRG   KEYLE,JFCKEYLE
         MRG   DSORG,JFCDSORG
         MRG   RECFM,JFCRECFM
         MRG   OPTCD,JFCOPTCD
         MRG   BLKSI,JFCBLKSI
         MRG   LRECL,JFCLRECL
         MRG   NCP,JFCNCP
         MRG   *END
QSAMJFCB MRG   EROPT,JFCEROPT
         MRG   *END
MERGDSCB MRG   DSORG,DS1DSORG,BASE=DS1FMTID
         MRG   RECFM,DS1RECFM
         MRG   OPTCD,DS1OPTCD
         MRG   BLKSI,DS1BLKL
         MRG   LRECL,DS1LRECL
         MRG   *END
         EJECT
XSAMPRFX DSECT ,
         B     XSAMPPON-XSAMPRFX(,R15)  FIND/POINT ENTRY
         L     R15,XSAMPNOT-XSAMPRFX(,R15)  NOTE ENTRY
         BR    R15           BR TO EXNOTE
         DC    C'XS'         XSAM WORK AREA ID
XSAMPPON L     R15,XSAMPPNT-XSAMPRFX(,R15)  POINT/FIND ENTRY
         BR    R15           BR TO EXPOINT
         DC    H'0'
XSAMPPNT DC    A(0)          EXPOINT
XSAMPNOT DC    A(0)          EXNOTE
XSAMPBAS DC    A(0)          BASE ADDRESS
XSAMWORK DS    0D
SAVEAREA DC    9D'0'
DB       DS    D             WORK WORD
TEMPSAVE DS    16F
FLAG     DC    X'0'
FGEOF    EQU   X'80'         EOF ENCOUNTERED
FGEOFT   EQU   X'40'         EOF ON THIS TRACK
FGCKD    EQU   X'20'         ASYNCHRONOUS READ COUNT STARTED
FGFIND   EQU   X'10'         TTR CHANGED BY POINT OR FIND
VOLSER   DS    CL6
MEMBER   DS    CL8
DSORG    DS    X
KEYLEN   DS    X
RECFM    DS    X
LRECL    DS    H
BLKSI    DS    H
FAKEIOB  DC    4A(0)         FAKE IOB
USERDCB  DS    A             ADDRESS OF USER'S DCB
         DC    2A(0)
OLDCCHH  DC    XL8'0'        END OF FAKE IOB
EMPIRE   DC    XL12'0'       SAVE THE FOUNDATION
ANACREON DC    X'0'
SMYRNA   DC    XL9'0'
KALGAN   DC    XL24'0'
TRKCAP   DS    F             MAX BLOCKSIZE ON TRACK
MERGOC   OC    0(0,R10),0(R10)  CHECK DCB FIELD
MERGMV   MVC   0(0,R10),0(R1)   MOVE TO DCB FROM JFCB/DSCB
OLDTTR   DC    F'0'
NEWTTR   DC    F'0'
BLOCKXLE DC    A(DATCCW2,8,DATCCW2)  BXLE VALUES FOR TRACK
TRACKXLE DC    A(DATCCW2,8,DATCCW2)  BXLE VALUES FOR TRACK
@CKDCCW  DC    A(CKDCCW)
@CKDCCW2 DC    A(CKDCCW2)
@CKD     DC    A(CKD)
@DATCCW  DC    A(DATCCW)
@DATCCW2 DC    A(DATCCW2)
@DATA    DC    A(DATA)
DCB      DCB   DDNAME=USERS,MACRF=RC,DSORG=PS,DEVD=DA  BIG DCB
         XDAP  ECB,RI,DCB,1,2,,NEWTTR,MF=L
IOBLOCK  EQU   ECB+4
         ORG   *-32          OVERLAY
NEWCCHH  DC    D'0'
CKDCCW   CCW   X'31',NEWCCHH,X'40',5  SEARCH FOR RECORD -1
         CCW   X'08',CKDCCW,0,0
CKDCCW2  CCW   X'12',CKD,X'40',8      256 READ COUNTS
         DS    255D
DATCCW   CCW   X'31',NEWCCHH,X'40',5  SEARCH FOR RECORD -1
         CCW   X'08',DATCCW,0,0
DATCCW2  CCW   X'1E',DATA,X'40',1     256 READ COUNT/KEY/DATA
         DS    255D          OR ONE READ COUNT/KEY/DATA MULTIPLE
CKD      DS    256D          COUNT FIELDS
DATA     DS    24CL1024      ALLOW 24K FOR DATA
XSAMWLEN EQU   *-XSAMPRFX    LENGTH OF GETMAIN
         SPACE 2
XSAMOPEN CSECT ,
         PRINT NOGEN
         NEED  NOT,DCB
         MSECT ,
         PRINT GEN
         NEED  DCB
         MSECT ,
         END
