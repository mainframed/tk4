         TITLE 'PASCALL - PASCAL COMPILE, ASMPCODE, AND GO INTERFACE'
         SPACE
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        THIS MODULE PROVIDES THE USER A COMMAND INTERFACE FOR        *
*        PERFORMING ANY COMBINATION OF THE COMPILE, ASMPCODE, AND GO  *
*        STEPS IN THE PASCAL ENVIRONMENT UNDER CMS.  IT USES A LIBRARY*
*        OF MACROS FROM WATERLOO CALL THE INTERFACE MACRO LIBRARY,    *
*        WHICH IS USEFUL FOR WRITING ROUTINES SUCH AS THIS ONE.  MOST *
*        OF THIS PROGRAM IS DEDICATED TO ISSUING INTERNAL FILEDEFS AND*
*        COMMANDS TO SET UP THE CORRECT ENVIRONMENT.  THE REST SCANS  *
*        THE COMMAND LINE, INTERPRETS OPTIONS, AND CALLS THE VARIOUS  *
*        PROCESSORS.                                                  *
*                                                                     *
*        PLEASE NOTE THAT THIS IS A PRELIMINARY VERSION.  IT DOES NOT *
*        CONTAIN MANY OF THE OPTIONS AND FILE HANDLING FACILITIES     *
*        THAT ARE ANTICIPATED FOR THE FUTURE.  HOWEVER, IT DOES PRO-  *
*        VIDE THE FRAMEWORK FOR A FULL FLEDGED INTERFACE.             *
*                                                                     *
*        DAVID J. ROSSETTI                                            *
*        STANFORD LINEAR ACCELERATOR CENTER                           *
*        OCTOBER 31, 1979                                             *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 3
         MACRO
         $SYSTEM &NAME=,&PATHLEN=0,&PARM=$NULL,&DIRTNAM=16,&COMPSWT=ON,*
               &ERROR=*+4
         GBLB  &$CALL
         AIF   ('&NAME' EQ '').MNOTE01
&$CALL   SETB  (1)
         AIF   ('&NAME' NE '$OPND').DOBAL
         MVC   $SYS&SYSNDX.(8),$OPND
.DOBAL   CNOP  0,4
         BAL   R8,$CALLSYS
$SYS&SYSNDX DC    CL8'&NAME'
         DC    A(&PATHLEN)
         DC    A(&PARM)
         DC    A(&DIRTNAM-16)
         AIF   ('&COMPSWT' EQ 'ON').SKIP01
         DC    H'0'
         AGO   .SKIP02
.SKIP01  DC    H'-1'
.SKIP02  ANOP
         B     &ERROR
         MEXIT
.*
.MNOTE01 MNOTE 8,'$SYSTEM      NAME PARAMETER OMITTED'
         MEXIT
         MEND
         MACRO
&LAB     $SETFID  &FILEDEF,&LIST
         AIF   (K'&LAB EQ 0).SKPNULL
&LAB     $NULL
.SKPNULL $SET     &FILEDEF,NAME,&LIST(1)
         $SET     &FILEDEF,TYPE,&LIST(2)
         $SET     &FILEDEF,MODELET,&LIST(3)
         AIF      (N'&LIST LE 3).DONE
         MNOTE    4,'EXTRA OPERANDS (>3) IGNORED'
.DONE    MEND
*
*  DETERMINE THE INITIAL OPTION FLAG SETTINGS BASED ON THE FILETYPES
*  FOUND WITH MATTCHING FILENAME ON TTHE DISK THAT A MATCH FOR
*  <FILENAME> * * OCCURRED.
*
*        IF     PASCAL THEN COMPILE, ASMP, GO
*        ELSEIF PCODE  THEN ASMP, GO
*        ELSEIF TEXT   THEN GO
*
PASCALL  $START   QUERY=TYPEINFO
         $OPND    END=NOINPUT
         $SETFID  INPUT,($OPND,'PASCAL','*')
         $STATE   INPUT,ERROR=TRYPCODE
         $OPTINIT 1,#COMPILE+#ASMP+#GO
         $GOTO    HAVEINPT
         SPACE
TRYPCODE $NULL
         $STATE   INPUT,FTYPE=PCODE,ERROR=TRYTEXT
         $OPTINIT 1,#ASMP+#GO
         $GOTO    HAVEINPT
         SPACE
TRYTEXT  $NULL
         $STATE   INPUT,FTYPE=TEXT,ERROR=NOTFOUND
         $OPTINIT 1,#GO
         SPACE
HAVEINPT $NULL
         USING FSTSECT,R7
         MVC   SAVEMODE(1),FSTM    SAVE FILEMODE OF INPUT
         $OPTIONS TABLE=OPTABLE
*
*  FORMAT THE "OPTIONS USED ..." LINE AND LET THE USER KNOW WHAT'S
*  GOING ON.
*
         SR    R4,R4               R4 = INDEX - SET TO ZERO
         LA    R8,10               INCREMENT - OPTNAMES ENTRY SIZE
         SR    R9,R9
         IC    R9,OPTNSIZE         COMPARAND - STOPS BXLE LOOP
         LA    R0,BLANK            INITIALIZE NEXT FOR TACKON ROUTINE
         ST    R0,NEXT
         ICM   R6,B'0001',$UFLAGS  R6 = OPTION FLAGS BYTES
         SR    R7,R7               R7 WILL TEST BITS, ONE AT A TIME
TACKLOOP EQU   *
         LA    R1,OPTNAMES+1(R4)   R1 -> OPTION NAE FOR THIS BIT4)
         SR    R2,R2
         IC    R2,OPTNAMES(R4)     R2 = LENGTH OF OPTION STRING
         SRDL  R6,1                NOW R7'S SIGN BIT IS THE OPTION BIT
         LTR   R7,R7               IS R7 >= 0?  (I.E. BIT IS OFF)
         BNM   PICKUP              YES - BRANCH TO MOVE "NOXXXX"
         LA    R1,2(,R1)           CHOP OFF THE "NO"
         BCTR  R2,0                AND SHORTEN THE LENGTH
         BCTR  R2,0                BY TWO BYTES
PICKUP   BAL   R14,TACKON          LET TACKON MOVE IT
         BXLE  R4,R8,TACKLOOP      LOOP UNTIL ALL OPTIONS PRINTED
         SPACE
         MVI   BLANK,C' '          CLEAN UP FIRST ERRONEOUS COMMA
         L     R0,NEXT             R0 = NEXT - A(PRINTLINE)
         S     R0,=A(OPTMSG)
         WRTERM  OPTMSG,(R0)       WRITE IT OUT
*
*  INITIALIZE THE OS STORAGE MANAGEMENT FREE LIST FOR CMS SIMULATION
*
         STRINIT  TYPCALL=SVC
*
*  SET UP FOR AND EXECUTE THE PASCAL COMPILER.  THE COMPILE OPTION
*  WAS SET, EITHER EXPLICITLY OR BY ASSUMPTION BECAUSE A FN PASCAL FM
*  FILE WAS FOUND.
*
         $IFOPT   1,OFF,#COMPILE,CHKASMP
         $SETFID  PRD,('PRD','PASCUTIL','A')
         $SETFID  QRR,($OPND,'PTABLES',SAVEMODE)
         $SETFID  PRR,($OPND,'PCODE',SAVEMODE)
         $SETFID  OUTPUT,($OPND,'LISTING',SAVEMODE)
         SPACE
         $FILEDEF INPUT,ERROR=FDERR
         $FILEDEF PRD,ERROR=FDERR
         $FILEDEF QRR,ERROR=FDERR
         $FILEDEF PRR,ERROR=FDERR
         $FILEDEF OUTPUT,ERROR=FDERR
         SPACE
         $IFOPT   1,OFF,#DEBUG,CALLPASC
         $TYPE    'Summary of filedefs for PASCAL step:'
         $EXEC    FILIST
CALLPASC $NULL
         WRTERM 'Compile: ',EDIT=NO
         $SYSTEM   NAME=PASCAL,PATHLEN=48*4096
         LINEDIT   TEXT='Compile Return Code = ....',SUB=(DEC,(R15))
         LTR   R15,R15             IS RET CODE ZERO?
         BZ    CHKASMP             ZERO - GO DO NEXT STEP
         $RC   (R15)               NOPE - STOP RIGHT HERE
         SPACE
*
*  SET UP FOR AND EXECUTE ASMPCODE.  RE-ISSUE ALL FILEDEFS FOR NEEDED
*  FILES, WITH THE "CHANGE" OPTION IN CASE THEY ALREADY EXIST.
*
CHKASMP  $NULL
         $IFOPT   1,OFF,#ASMP,CHKGO
         $SETFID  INPUT,($OPND,'PCODE',SAVEMODE)
         $SETFID  PRD,($OPND,'PTABLES',SAVEMODE)
         $SETFID  PRR,($OPND,'TEXT',SAVEMODE)
         SPACE
         $FILEDEF INPUT,ERROR=FDERR
         $FILEDEF PRD,ERROR=FDERR
         $FILEDEF PRR,ERROR=FDERR
         $FILEDEF TOUTPUT,ERROR=FDERR
         SPACE
         $IFOPT   1,OFF,#DEBUG,CALLASMP
         $TYPE    'Summary of filedefs for ASMP step:'
         $EXEC    FILIST
CALLASMP $NULL
         WRTERM 'Asmp: ',EDIT=NO
         $SYSTEM   NAME=ASMPCODE,PATHLEN=64*4096
         LINEDIT   TEXT='Asmp Return Code = ....',SUB=(DEC,(R15))
         LTR   R15,R15             IS RETURN CODE ZERO?
         BZ    CHKGO               YES - NOW TO THE GO STEP
         $RC   (R15)               NO - STOP AT THIS POINT
         SPACE
*
*  SET UP FOR AND EXECUTE THE OBJECT PROGRAM.  THE ONLY FILEDEFS
*  PROVIDED BY DEFAULT ARE FOR:
*        INPUT    (FN DATA *)
*        OUTPUT   (TERMINAL)
*        QRD      (FN PTABLES FM)
*        FT06F001 (TERMINAL)
*
CHKGO    $NULL
         $IFOPT   1,OFF,#GO,FINISH
         $SETFID  INPUT,($OPND,'DATA','*')
         $SETFID  QRD,($OPND,'PTABLES',SAVEMODE)
         $SET     FT06F001,DEVICE,'TERMINAL'
         $FILEDEF INPUT,ERROR=FDERR
         $FILEDEF TOUTPUT,ERROR=FDERR
         $FILEDEF QRD,ERROR=FDERR
         $FILEDEF FT06F001,ERROR=FDERR
         SPACE
         $IFOPT   1,OFF,#DEBUG,CALLGO
         $TYPE    'Summary of filedefs for GO step:'
         $EXEC     FILIST
CALLGO   $NULL
         $EXEC     CLEARCOR
         STRINIT  TYPCALL=SVC
         $SYSTEM   NAME=$OPND,PATHLEN=64*4096,COMPSWT=OFF
         LINEDIT   TEXT='Go Return Code = ....',SUB=(DEC,(R15))
         $RC   (R15)               SUPPLY THE GO RETURN CODE
         SPACE
FINISH   $NULL
         $RC      0
*
*  TACKON - SUBROUTINE TO TACK ", <STRING>" ONTO THE END OF A LINE.
*  USES A VARIABLE "NEXT" AS THE DESTINATION POINTER, AND UPDATES IT
*  TO BE USED FOR THE NEXT CALL.  REGISTERS ON ENTRY:
*        R1 = ADDRESS OF THE INPUT STRING
*        R2 = LENGTH OF INPUT STRING
*        R14 = RETURN ADDRESS
*
TACKON   EQU   *
         L     R3,NEXT             R3 -> WHERE TO PUT THE INPUT STRING
         MVI   0(R3),C','          PUT A COMMA IN TO SEPARATE
         EX    R2,OPTMOVER         NOTE: R2 HAS LENGTH - 1
         LA    R3,3(R2,R3)         R3 -> NEW DESTINATION BYTE
         ST    R3,NEXT
         BR    R14                 RETURN
OPTMOVER MVC   2(*-*,R3),0(R1)     OFFSET LEAVES ROOM FOR COMMA
         SPACE
*
*  DATA AREAS FOLLOW
*
NEXT     DS    A                   POINTER FOR DESTINATION IN TACKON
OPTNSIZE DC    AL1(OPTEND-*-2)
OPTNAMES DC    AL1(8),CL9'NOCOMPILE'   AL1 IS LENGTH-1 FOR EXECUTED MVC
         DC    AL1(5),CL9'NOASMP'
         DC    AL1(3),CL9'NOGO'
         DC    AL1(6),CL9'NODEBUG'
OPTEND   EQU   *
         SPACE
OPTMSG   DC    CL120' '
         ORG   OPTMSG
         DC    C'Options used:'
BLANK    DC    CL2'  '
OPTSTART DS    C
         ORG
         SPACE
SAVEMODE DS    CL1            HOLDS INPUT FILE MODE FOR LIFE OF PROGRAM
FILIST   $PLIST   FILEDEF
CLEARCOR DS    0D
         DC    CL8'LOAD',CL8'IEFBR14',CL8'(',CL8'ORIGIN',CL8'21FF8'
         DC    8X'FF'
         SPACE
TYPEINFO $NULL
         $TYPE    'Pascall Command Prototype:'
         $TYPE   'PASCALL <filename> (Compile  Asmp    Go   <-Defaults'
         $TYPE   '                    NOComp   NOAsmp  NOGo'
         $TYPE   'Note:  Many options imply others; later options take *
               precedence.'
         BR       R14
         SPACE
NOINPUT  $ERROR   'No file name given.  Type "PASCALL ?" for help.',   X
               RC=1
NOTFOUND $ERROR   'INPUT FILE NOT FOUND',RC=1
FDERR    $ERROR   'ERROR IN FILEDEF',RC=2
         SPACE
         $OPTSW   (#COMPILE,#ASMP,#GO,#DEBUG)
OPTABLE  $OPTDEF  (C,CO,COM,COMP,COMPI,COMPIL,COMPILE),                X
               (,#COMPILE+#ASMP,,#GO),                                 X
               (A,AS,ASM,ASMP),(,#ASMP,,#COMPILE+#GO),                 X
               (G,GO),(,#GO,,#COMPILE+#ASMP),                          X
               (NOC,NOCO,NOCOM,NOCOMP,NOCOMPI,NOCOMPIL),               X
               (,#GO,,#COMPILE+#ASMP),                                 X
               (NOA,NOAS,NOASM,NOASMP),(,,,#ASMP+#GO),                 X
               (NOG,NOGO),(,,,#GO),                                    X
               (D,DE,DEB,DEBU,DEBUG),(,#DEBUG)
         $END
INPUT    $FILE    DDNAME=INPUT,TYPE=DISK,FILEID=(*,*,*),XTENT=50,      X
               CHANGE=YES,RECFM=FB,LRECL=80,BLOCK=800
PRD      $FILE    DDNAME=PRD,TYPE=DISK,FILEID=(*,*,*),XTENT=50,        X
               CHANGE=YES,RECFM=F
QRR      $FILE    DDNAME=QRR,TYPE=DISK,FILEID=(*,*,*),XTENT=50,        X
               CHANGE=YES,RECFM=FB,LRECL=80,BLOCK=800
PRR      $FILE    DDNAME=PRR,TYPE=DISK,FILEID=(*,*,*),XTENT=50,        X
               CHANGE=YES,RECFM=FB,LRECL=80,BLOCK=800
OUTPUT   $FILE    DDNAME=OUTPUT,TYPE=DISK,FILEID=(*,*,*),XTENT=50,     X
               CHANGE=YES,RECFM=FBA,LRECL=112,BLOCK=2240
TOUTPUT  $FILE    DDNAME=OUTPUT,TYPE=TERMINAL,CHANGE=YES,RECFM=F,      X
               LRECL=80,BLOCK=80
QRD      $FILE    DDNAME=QRD,TYPE=DISK,FILEID=(*,*,*),XTENT=50,        X
               CHANGE=YES,RECFM=F
FT06F001 $FILE    DDNAME=FT06F001,TYPE=TERMINAL,RECFM=F,LRECL=80,      X
               BLOCK=80
         SPACE
         FSTB
         END
************************************************************************
***********************************************************************
***** THIS SET UP IS PROVIDED AS A GUIDELINE FOR A 'CMS' INTERFACE ****
***** AND IS NOT INTENDED TO BE USED AS A FINAL VERSION.           ****
***** THE CURRENT VERSION OF THE RUN TIME SYSTEM 'PMONSRC' SHOULD  ****
***** BE SUBSTITUTED FOR THIS MODULE IN THE FINAL INTERFACE.       ****
***********************************************************************
***********************************************************************
         TITLE 'PASCSP, PASCAL RUNTIME SUPPORT AND STANDARD PROCS'
***********************************************************************
*
*
*
*     PASCAL ENVIRONMENT AND ENTRY SETUP
*     ------------------------------------
*
*
*     COPYRIGHT 1976, STANFORD LINEAR ACCELERATOR CENTER.
*
*
*     THE FOLLOWING PROGRAMS CREATE  THE  RUN-TIME  ENVIRONMENT  AND
*     PROVIDE THE I/O INTERFACE FOR THE SLAC 'PASCAL' COMPILER.
*
*     EXCEPT FOR THE FEW POINTS EXPLAINED IN THIS BOX, THE INTERNALS
*     OF THESE ROUTINS SHOULD BE INVISIBLE (AND INCONSEQUENTIAL)  TO
*     THE 'PASCAL' USER.
*
*
*
*     1) THE USER MAY SPECIFY THE SIZE OF THE RUN  TIME  STACK/HEAP,
*     THE  SIZE OF THE AREA RETURNED TO THE OPERATING SYSTEM FOR I/O
*     BUFFERS, THE MAXIMUM COUNT OF RUN  TIME  ERRORS,  THE  RUNNING
*     TIME  OF  THE  PROGRAM,  REQUEST  AN  OPTIONAL MEMORY DUMP AND
*     SPECIFY OTHER SPECIAL CONTROL OPTIONS AS FOLLOWS:
*
*       // EXEC USERPROG,
*       //      PARM='USER PARMS /STACK=XXXK,IOBUF=YYYK,ERRLIM=NNN,
*                            TIME=TTTS,NOSPIE,NOSNAP,NOCC,DUMP'      #
*
*       'USER PARMS': THE PARAMETER LIST TO BE PASSED TO THE USER
*                     PROGRAM (IF ANY).
*       'XXX' : STORAGE AREA (IN K BYTES) FOR STACK+HEAP+IOBUFFERS.
*       'YYY' : STORAGE AREA (IN K BYTES) TO BE RETURNED TO SYSTEM.
*       'NNN' : NUMBER OF NON FATAL RUN-TIME ERRORS TO BE TOLERATED
*               BEFORE THE PROGRAM IS TERMINATED.
*       'TTT' : PROGRAM RUNNING TIME (IN SECONDS).
*       'DUMP': TO GENERATE AN OS STYLE MEMORY DUMP IN CASE OF AN
*               ABNORMAL PROGRAM TERMINATION.
*       'NOSPIE': TO PREVENT INTERCEPTION OF ERROR INTERRUPTS        #
*       'NOSNAP': TO STOP USE OF SNAPSHOT RT. AFTER AN ERROR         #
*       'NOCC': TO STOP FIRST CHARACTER ON EACH LINE FROM BEING      #
*               TAKEN AS A CONTROL CHARACTER                         #
*       DEFAULT VALUE FOR 'XXXK' IS THE JOB 'REGION' SIZE.
*       DEFAULT VALUE FOR 'YYYK' IS 32K.
*       DEFAULT VALUE FOR 'NNN' IS 1.
*
*     2) THE VALUE OF THE RETURN CODE 'RC', IF OTHER  THAN GENERATED
*     BY  THE  USER  PROGRAM,  MAY  BE  INTERPRETED ACCORDING TO THE
*     FOLLOWING TABLE.  FOR MORE DETAILED EXPANATION  OF  THE  ERROR
*     CONDITION,  SEE  THE  CONTENTS OF THE 'OUTPUT' FILE WHICH HAVE
*     THE APPROPRIATE MESSAGES.  NOTE THAT THIS FILE (OUTPUT) SHOULD
*     BE INCLUDED IN THE USER PROGRAM IN ORDER TO GET THE  RUN  TIME
*     DIAGNOSTICS AND RELATED MESSAGES.
*
*       RETURN CODE:  IMPLIES:
*
*       1001          INDEX VALUE OUT OF RANGE
*       1002          SUBRANGE VALUE OUT OF RANGE
*       1003          ACTUAL PARAMETER OUT OF RANGE
*       1004          SET MEMBER OUT OF RANGE
*       1005          POINTER VALUE INVALID
*       1006          STACK/HEAP COLLISION
*       1007          ILLEGAL INPUT/RESET OPERATION
*       1008          ILLEGAL OUTPUT/REWRITE OPERATION
*       1009          SYNCHRONOUS I/O ERROR
*       1010          PROGRAM EXCEEDED SPECIFIED RUNNING TIME
*       1011          ILLEGAL FILE DEFINITION (I.E., TOO MANY FILES)
*       1012          NOT ENOUGH STACK SPACE
*       1013          ATTEMPT TO CALL MATH RT. VIA CSP (OBSOLETE)    #
*       1014          LINELIMIT EXCEEDED FOR A FILE                  #
*       1020          READ PAST END OF FILE                          #
*       1021          BAD BOOLEAN INPUT                              #
*       1022          BAD INTEGER INPUT                              #
*       1023          BAD REAL INPUT                                 #
*
*       200X          PROGRAM INTERRUPTION CODE 'X'
**
*       3001          INVALID ARGUMENT TO MATH ROUTINES LOG, SQRT,..
*
*       X1XX          UNABLE TO RUN SNAPSHOT, OTHER DIGITS AS ABOVE
*
*
*     3) THE CONDITIONAL ASSEMBLY FLAG &SYSTEM DETERMINES WHETHER    #
*     CERTAIN SECTIONS OF CODE ARE INCLUDED IN THE PROGRAM.          #
*     WITH &SYSTEM=1, SOME CHECKING CODE, REAL NUMBER INPUT AND THE  #
*     FORTRAN INTERFACE IS OMITTED.  THIS RESULTS IN A SMALLER       #
*     FASTER PROGRAM BUT WHICH CAN ONLY BE USED WITH "SAFE"          #
*     PROGRAMS THAT DO NOT USE MATHEMATICAL ROUTINES - SUCH AS THE   #
*     COMPILER AND THE P-ASSEMBLER.                                  #
*     WITH &SYSTEM=0, THE FULL PROGRAM IS PRODUCED AND THIS IS THE   #
*     VERSION THAT SHOULD NORMALLY BE COMBINED WITH USER PROGRAMS.   #
*
*
*     4) THIS PROGRAM MAY BE ASSEMBLED WITH MOST STANDARD IBM        #
*     ASSEMBLERS.                                                    #
*
*
*     5) IF THE RUN PROFILE SWITCH IS ENABLED IN THE PASCAL  PROGRAM
*     (I.E.   'K+'),  THE  RUN  TIME SYSTEM WILL 'REWRITE' THE 'RAW'
*     EXECUTION COUNTS ON THE PREDEFINED 'QRR'  FILE  AFTER  RUNNING
*     THE  USER  PROGRAM.  IN SUCH CASES THE USER PROGRAM SHOULD NOT
*     USE THE 'QRR' FILE BUT THE 'DD' STATEMENT FOR THIS FILE SHOULD
*     BE INCLUDED IN THE 'GO' STEP.
*
*
*
*     THESE PROGRAMS INCLUDE SOME CONTRIBUTIONS BY KEITH RICH,  JOHN
*     BANNING AND NIGEL HORSPOOL.
*
*     SIX LINES WERE ADDED FOR THIS (CMS) VERSION.  THEY ATTEMPT
*     TO SOLVE THE LOCATE MODE PROBLEM FOR OUTPUT, BUT CAUSE AN
*     EXTRA LINE TO BE WRITTEN WHEN THE OUTPUT FILE IS CLOSED.
*     DAVE ROSSETTI,  OCTOBER 31, 1979.
*
*
*
*
*                                SASSAN HAZEGHI,
*
*                                COMPUTATION RESEARCH GROUP
*                                STANFOR LINEAR ACCELERATOR CENTER
*                                P. O. BOX 4349
*                                STANFORD, CALIFORNIA  94305.
*
*
*
*                                LAST UPDATE:
*                                             MAR.  15, 76.
*                                             SEPT.  8, 76.
*                                             JAN.  20, 77.
*                                             JULY  28, 77.
*                                             MAY   21, 77.
*                                             JULY   6, 78.
*                                             SEPT. 15, 78.
*                                             NOV.  11, 78.
*
*     FURTHER MODIFICATIONS MADE AT MCGILL UNIVERSITY,               #
*                                                                    #
*                                R. NIGEL HORSPOOL                   #
*                               JULY 1, 1979                         #
*
***********************************************************************
         EJECT
**************************************************************
*
*        I/O (FILE) HANDLING MACROES
*
**************************************************************
*
         MACRO ,
&L       FILADR ,
.*       TO COMPUTE FILE BUFFER ADDRESS ETC.
&L       LR    AE,AD
         SR    AE,GBR                         AE <-- FILE #
         SLA   AE,2                           FILE # TO OFFSET
         L     AE,FILBLK-PASBUFAD*4(AE)       OFFSET TO FILE BLOCK
         L     AF,FILBUF(AE)       SET I/O BUFFER POINTER            #
         MEND  ,
*
         MACRO ,                                                     #
         FILDEF &NAME,&DIRECT,&LENGTH                                #
.*       DEFINE A FILE  DDNAME,DIRECTION,LRECL                       #
         LCLC  &NAM                                                  #
         DS    0D                                                    #
&NAM     SETC  '&NAME'(1,3)                                          #
FIL&NAM  DC    A(0)                BUFFER ADDRESS                    #
         DC    H'0',H'0'            LRECL,CHAR. PTR.                 #
         DC    H'0'                CHAR. START POS.                  #
         DC    X'0',X'0'           EOFFLAG, OPENFLAG                 #
         DC    F'0'                OUTPUT LINES LIMIT                #
         AIF   ('&DIRECT' NE 'INPUT').OUTPUT                         #
         DCB   DSORG=PS,DDNAME=&NAME,MACRF=(GL),EODAD=EOD,           # X
               SYNAD=SYNADRT,EXLST=XL&DIRECT,BFTEK=A                 #
         MEXIT ,                                                     #
.OUTPUT  AIF   ('&DIRECT' NE 'OUTPUT').INPOUT                        #
         DCB   DSORG=PS,DDNAME=&NAME,MACRF=(PL),                     # X
               SYNAD=SYNADRT,EXLST=XL&DIRECT,BFTEK=A                 #
         MEXIT ,                                                     #
.INPOUT  ANOP  ,                                                     #
         DCB   DSORG=PS,DDNAME=&NAME,MACRF=(GL,PL),EODAD=EOD,        # X
               SYNAD=SYNADRT,EXLST=XL&DIRECT,BFTEK=A                 #
         MEND  ,                                                     #
*                                                                    #
         EJECT
         GBLB  &SYSTEM                                               #
&SYSTEM  SETB  0                  TRUE INDICATES A COMPACT 'CSP'
*
         AIF   (&SYSTEM).SYS1
*        GENERAL SETUP FOR USER PROGRAM(S).
         AGO   .USE1
.SYS1    ANOP
*        COMPACT SETUP, OMITS FORTRAN INTERFACE & REAL INPUT         #
.USE1    ANOP
*
*
*
         EJECT
***************************************************************
*
*        STACK (AND SAVE AREA) LAYOUT
*
***************************************************************
*
*
         PRINT NOGEN
         DCBD  DSORG=PS
         PRINT GEN
*
DYNSTORE DSECT ,
         DS    20F                 PASCAL ENVIRONMENT SAVE AREA
STACK    DS    18F                 BOTTOM OF RUNTIME STACK
CLOCK    EQU   STACK               CLOCK LOCATION
NEWPTR   DS    A                   PASCAL 'NEW' POINTER
HEAPLIM  DS    A                   UPPER LIMIT OF HEAP ( +1 )
*                                  ALSO POINTS TO DYN2STOR
DISPREGS DS    10F                 RUN TIME DISPLAY REGISTERS
DISPLAY  EQU   DISPREGS,*-DISPREGS
FL1      DS    D                   R/W  FIX/FLOAT CONVERSION HELPS
FL2      DS    D                   R ONLY
FL3      DS    D                   R/W
FL4      DS    D                   R ONLY
CHKSUBS  DS    0F                  ENTRY TO RUN TIME CHECK ROUTINES
INXCHK   DS    3F                  INDEX CHECK
RNGCHK   DS    3F                  SUBRANGE CHECK
PRMCHK   DS    3F                  PARAMETER VALUE CHECK
PTRCHK   DS    3F                  POINTER CHECK
PTACHK   DS    3F                  SET MEMBER CHECK
SETCHK   DS    3F
STKCHK   DS    3F
ZZZCHK   DS    3F
INPUT    DS    CL1
OUTPUT   DS    CL1
PRD      DS    CL1
PRR      DS    CL1
QRD      DS    CL1
QRR      DS    CL1
F01PAS   DS    CL1
F02PAS   DS    CL1
F03PAS   DS    CL1
F04PAS   DS    CL1
F05PAS   DS    CL1
F06PAS   DS    CL1
F07PAS   DS    CL1
F08PAS   DS    CL1
F09PAS   DS    CL1
F10PAS   DS    CL1
F11PAS   DS    CL1
F12PAS   DS    CL1
F13PAS   DS    CL1
F14PAS   DS    CL1
F15PAS   DS    CL1
F16PAS   DS    CL1
F17PAS   DS    CL1
F18PAS   DS    CL1
**F19PAS   DS    CL1
**F20PAS   DS    CL1
CLEARBUF DS    XL8                  BUFFER TO CLEAR ACTIVATION RECORDS
PASDATE  DS    CL10                 PREDEFINED VARIABLE DATE
PASTIME  DS    CL10                 PREDEFINED VARIABLE TIME
OSPRMPTR DS    A                    POINTER TO O.S. PARM STRING      #
*FPRSAVE  DS    4D                  FLT. PT. REGS SAVE AREA (OPTIONAL)
*
*       DYNAMIC STORAGE AREA POINTED TO BY HEAPLIM
*
DYN2STOR DSECT     ,
DYNRUNC  DS        F         # OF RUN TIME FREQUENCY COUNTERS
DYNERRL  DS        F         LIMIT OF ERROR BEFORE TERMINATING
DYNERRC  DS        F         ERROR COUNTER
DYNABEND DS        X         X'FF' => ABEND ON ERROR TERMINATION
         DS        0D
DYNCOUNT DS        0F
         AIF       (&SYSTEM).SYS3
DYN2LEN  EQU       128       EXTRA MARGIN FOR PATHOLOGICAL CALL PARMS
         AGO       .USE3
.SYS3    ANOP
DYN2LEN  EQU       *-DYN2STOR
.USE3    ANOP
*
         EJECT
**************************************************************
*
*        PASCAL ENTRY POINT AND PROGRAM PROLOGUE
*
**************************************************************
*
*
$PASENT  CSECT ,
         ENTRY $PASENT,$PASCSP,$PASINT                               #
*
*
         USING *,15
         SAVE  (14,12),,*
         LR    R10,R15
         DROP  R15
         USING $PASENT,R10
         ST    R1,OSPARMS          SAVE ADDRESS OF O.S. PARMS        #
         L     R1,0(R1)
         SPACE
*
*        R1 POINTS TO THE PARAMETER LIST THE FIRST HALF WORD OF
*        WHICH GIVES THE LENGTH OF THE LIST
*
         LH    R2,0(R1)
         LTR   R2,R2
         BNH   NOPARM             NO PARAMETER LIST SPECIFIED
         LA    R0,256              SET MAX STRING LENGTH             #
         CR    R2,R0                                                 #
         BNH   *+6                 JUMP IF LENGTH OK                 #
         LR    R2,R0               ENFORCE THE LIMIT                 #
         LA    R8,1                INCREMENT FOR BXLE & BXH          #
         LA    R9,1(R1,R2)         LIMIT FOR BXLE & BXH              #
         LA    R1,2(,R1)           POINT AT FIRST CHAR               #
         ST    R1,OSPARMAD         SAVE ADDRESS FOR LATER            #
*
PARMRTRY CLI   0(R1),C'/'
         BE    PARMSLSH            SEPARATOR FOUND ?                 #
         BXLE  R1,R8,PARMRTRY                                        #
*
PARMSLSH LR    R3,R1                                                 #
         SL    R3,OSPARMAD         COMPUTE STRING LENGTH             #
         STH   R3,OSPARML          SAVE IT FOR LATER                 #
         BXH   R1,R8,NOPARM        JUMP IF STRING END                #
*
GOTPARM  CLC   0(3,R1),=C'STACK'  PROGRAM DATA AREA SPECIFIED ?
         BNE   TESTBUF
*
SETREG   BAL   R7,GETNUM          SET STACK REGION SIZE
         LTR   R4,R4
         BNP   NXTPARM
         SLA   R4,10              CONVERT TO 'K' BYTES
         ST    R4,REQSTORE        RESET REGION SIZE
         ST    R4,REQSTORE+4      ALSO SET MAX STORE TO THE SAME VALUE
         B     NXTPARM
*
TESTBUF  CLC   0(3,R1),=C'IOBUF' I/O BUFFER SIZE SPECIFIED ?
         BNE   TESTABND
*
SETBUF   BAL   R7,GETNUM
         LTR   R4,R4
         BNP   NXTPARM
         SLA   R4,10
         ST    R4,BUFSTORE        RESET I/O BUFFER SIZE
         B     NXTPARM
*
TESTABND CLC       0(4,R1),=C'DUMP'    ABEND ON ERROR ?
         BNE       TESTLIM        IF NOT, SKIP
         MVI       DUMPFLAG,X'FF' SET_FLAG
*        LA        R1,4(R1)       ADVANCE POINTER AND                #
         B         NXTPARM        CONTINUE
*
TESTLIM  CLC       0(6,R1),=C'ERRLIM'  LIMIT ON NUMBER OF ERRORS
         BNE       TESTTIME       IF NOT, SKIP
         BAL       R7,GETNUM      GET ERROR LIMIT
         LTR       R4,R4
         BNP       NXTPARM        IGNORE NUMBER IF BAD
         ST        R4,ERRLIMIT    ELSE SET LIMIT
         B         NXTPARM
*
TESTTIME CLC   0(4,R1),=C'TIME'
         BNE   TESTCC             SEE IF EXEC TIME SPECIFIED         #
         BAL   R7,GETNUM
         LTR   R5,R4
         BNP   NXTPARM            IF TIME PARM NO GOOD, SKIP
         M     R4,=F'38400'       CONVERT SECONDS TO CPU TIMER UNITS
         ST    R5,EXECTIME
         B     NXTPARM
*
TESTCC   CLC   0(4,R1),=C'NOCC'    SEE IF CONTROL CHARS CANCELLED    #
         BNE   TESTSPIE            JUMP IF NOT                       #
         L     R15,=A(CCFLAG)      FLAG IS NOT DIRECTLY ADDRESSABLE  #
         MVI   0(R15),X'FF'        SET THE FLAG                      #
*        LA    R1,4(,R1)                                             #
         B     NXTPARM                                               #
*                                                                    #
TESTSPIE CLC   0(6,R1),=C'NOSPIE'  CANCEL SPIE TRAP?                 #
         BNE   TESTSNAP                                              #
         MVI   SPIEFLAG,X'FF'      SET THE CANCEL SPIE FLAG          #
*        LA    R1,6(,R1)           ADVANCE POINTER                   #
         B     NXTPARM                                               #
*
TESTSNAP CLC   0(6,R1),=C'NOSNAP'  CANCEL SNAPSHOT                   #
         BNE   NXTPARM                                               #
         MVI   SNAPFLAG,X'FF'      SET FLAG                          #
*        LA    R1,6(,R1)                                             #
*        B     NXTPARM                                               #
*
*
*
*
NXTPARM  BXLE  R1,R8,GOTPARM       STEP TO NEXT CHAR                 #
*                                                                    #
*                                                                    #
*        DDNAME-LIST PARAMETER PROCESSING                            #
*                                                                    #
NOPARM   EQU   *                                                     #
         L     R1,OSPARMS                                            #
         TM    0(R1),X'80'         TEST IF DDNAME LIST PROVIDED      #
         BO    NODDPARM                                              #
         L     R1,4(,R1)           ADDRESS OF DDNAME LIST PARM       #
         LH    R2,0(,R1)           LENGTH OF LIST IN BYTES           #
         L     AD,=A(FILBLK)       POINTER TO FIRST ENTRY IN FILE TAB#
         LA    R3,6                MAX NUMBER OF DDNAMES ALLOWED     #
DDLOOP   SH    R2,=H'8'            CHECK FOR END OF DDNAME LIST      #
         BM    NODDPARM                                              #
         NC    2(8,R1),2(R1)       CHECK FOR BINARY ZEROS            #
         BZ    DDDFLT              IF SO, DONT CHANGE DDNAME         #
         L     AE,0(,AD)           ADDRESS OF FILE CONTROL BLOCK     #
         USING IHADCB-FILDCB,AE                                      #
         MVC   DCBDDNAM(8),2(R1)   MOVE NEW DDNAME INTO DCB          #
DDDFLT   LA    R1,8(,R1)           ADVANCE THROUGH LIST              #
         LA    AD,4(,AD)           ADVANCE THROUGH FILE TABLE        #
         BCT   R3,DDLOOP           REPEAT FOR NEXT FILE              #
NODDPARM EQU   *                                                     #
*
*
*        GET SPACE FOR THE RUN TIME STACK
*
         GETMAIN VU,LA=REQSTORE,A=ALOSTORE
         SPACE ,
*
         L     R1,ALOSTORE         GET ADDRESS OF ALLOCATED AREA
         LR    R12,R1
         A     R1,ALOSTORE+4       ADD SIZE OF THE AREA
         S     R1,BUFSTORE         BEGINNIG (ENDING !) OF THE HEAP
         S     R1,=A(8)            NAME FIELD OF THE HEAP
         AIF   (&SYSTEM).SYS32
*
         LR    R2,R1
         SR    R2,R12              R2 <-- SIZE OF THE USABLE AREA
         BNH   NOCLR               SKIP IF NOT LARGE ENOUGH
         LD    FPR0,=XL8'8181818181818181'
         SRA   R2,3                CONVERT BYTE COUNT TO D_WORD COUNT
         LR    R3,R12
         STD   FPR0,0(R3)
         LA    R3,8(R3)
         BCT   R2,*-8
*
.SYS32   ANOP
NOCLR    ST    R13,4(R12)          BACK LINK OF NEW SAVE AREA
         ST    R12,8(R13)          FRWRD LINK OF OLD SAVE AREA
         LR    R13,R12             RESET SAVE AREA POINTER
*
         USING DYNSTORE,GBR
         MVC   STACK-8(8),=CL8'   STACK'
         MVC   0(8,R1),=CL8'HEAP    '
         LA    R12,STACK           GLOBAL (STACK BOTTOM) POINTER
         USING STACK,R12
         ST    R1,NEWPTR           SET PASCAL 'NEW' PONTER
*
*        CLEAR DISPLAY PSEUDO REGISTERS
*
         MVI   DISPLAY,X'FF'       SET DISP REGS TO '-1'
         MVC   DISPLAY+1(L'DISPLAY-1),DISPLAY
         SPACE ,
         L     R0,BUFSTORE         SIZE OF THE AREA TO BE RETURNED
         LA    R1,8(R1)            ADDRESS OF THE AREA TO BE RETURNED
         LR    R2,R1
         SR    R2,R12              RSPACE LEFT FOR THE STACK
         C     R2,USESTORE
         LA    R2,SPCERR           ERROR CODE FOR LACK OF SPACE
         BL    QUIT1
*
*        FREE SOME SPACE FOR O/S FILE BUFFERS (4K/FILE !)
*
         FREEMAIN R,LV=(R0),A=(R1)
         L     R1,ALOSTORE+4       KEEP TRACK OF HOW MUCH CORE       #
         S     R1,BUFSTORE         TO RETURN TO THE O.S.             #
         ST    R1,ALOSTORE+4       AT END OF EXECUTION               #
         SPACE ,
*
*        INITIALIZE FORTRAN ENVIRONMENT (IF THERE ARE FORTRAN        #
*        ROUTINES IN THE LOAD MODULE)                                #
*
         AIF   (&SYSTEM).SYS325                                      #
         L     R15,=V(IBCOM#)
         LTR   R15,R15             TEST IF IBCOM# HAS BEEN           #
         BZ    *+8                 INCLUDED IN LOAD MODULE           #
         BAL   R14,64(R15)
.SYS325  ANOP                                                        #
         SPACE ,
*
*        SET THE 'SPIE' TO TRAP PROGRAM  INTERRUPTS
*
         CLI   SPIEFLAG,X'00'      TEST IF SPIE TO BE ISSUED         #
         BNE   NOSPIE                                                #
         SPIE  $PASINT,((1,7),9,11,12,15)
         ST    R1,OLDPICA
NOSPIE   EQU   *                                                     #
*
*        SETUP DYN2STOR AREA
*
         L         R1,NEWPTR          TOP OF HEAP
         S         R1,=A(DYN2LEN)     LESS SIZE OF DYN2
         ST        R1,HEAPLIM         AND LIMIT
         USING     DYN2STOR,R1
         MVC       DYNERRL,ERRLIMIT   SET ERROR LIMIT
         SR        R0,R0
         ST        R0,DYNRUNC         CLEAR '# OF COUNTERS' FIELD
         ST        R0,DYNERRC         CLEAR '# OF ERRORS' FIELD
         MVC       DYNABEND,DUMPFLAG  SET DUMP FLAG
         LH    R2,OSPARML                                            #
         LTR   R2,R2                                                 #
         BZ    OSPARM1             JUMP IF NO PARM STRING            #
         SLR   R1,R2                                                 #
         SL    R1,=F'4'            ALLOCATE PARM STRING RECORD       #
         SRL   R1,3                FORCE TO DOUBLE-WORD BOUNDARY     #
         SLL   R1,3                                                  #
         ST    R2,0(,R1)           PUT STRING LENGTH IN RECORD       #
         L     R3,OSPARMAD                                           #
         BCTR  R2,0                                                  #
         EX    R2,OSPRMMVC         MOVE STRING INTO RECORD           #
         ST    R1,OSPRMPTR         SET POINTER TO RECORD             #
         B     OSPARM2                                               #
OSPRMMVC MVC   4(0,R1),0(R3)                                         #
OSPARM1  BCTR  R2,0                SET POINTER TO NIL                #
         ST    R2,OSPRMPTR                                           #
OSPARM2  ST    R1,NEWPTR                                             #
         DROP  R1                                                    #
*
*
*
*        DISABLE INTEGER OVERFLOW, EXPONENT UNDERFLOW AND
*        SIGNIFICANCE INTERRUPTS.
*
         BALR  R6,0
         N     R6,=XL4'F0FFFFFF'   DISABLE MASKABLE INTERRUPT
         SPM   R6
         SPACE ,
         MVC   FL1,=X'4E00000000000000'  INITIALIZE FIX-FLOAT-FIX
         MVC   FL2,=X'4E00000080000000'  CONVERSION VALUES
         MVC   FL3,=X'0000000000000000'
         MVC   FL4,=X'4F08000000000000'
         SPACE ,
         MVC   CHKSUBS(L'CALLSUBS),CALLSUBS  INIT. RUN TIME CHECK AREA
         SPACE
         MVC   CLOCK,EXECTIME            SET THE ALARM CLOCK
         STIMER  TASK,$TIMEOUT,TUINTVL=CLOCK
*
*        INITIALIZE DATE/TIME PREDEFINED VARIABLES
*
         TIME  DEC                 GET TOD IN TU
         ST    R1,DATESAV               PUT DATE IN WORK AREA
         CP    DATESAV+2(2),=PL2'59'
         BNH   LY
         TM    DATESAV+1,1              LEAP YEAR?
         BNZ   NLY                      NO
         TM    DATESAV+1,X'12'          LEAP YEAR?
         BNM   LY                       YES
NLY      AP    DATESAV+2(2),=P'1'
LY       LA    R4,JAN
         LA    R3,12
         ZAP   MONTH(3),=P'0'
MDLP     AP    MONTH(3),=P'1000'       BUMP MONTH
         CP    DATESAV+2(2),0(2,R4)    THIS MONTH?
         BNH   MDEND                    BR IF SO
         SP    DATESAV+2(2),0(2,R4)    TRY NEXT
         LA    R4,2(R4)
         BCT   R3,MDLP
MDEND    L     R3,DATESAV
         N     R3,=X'00FF0000'          GET YEAR
         O     R3,MONTH-2               INSERT MONTH
         L     R4,DATESAV               GET DAY
         SRL   R4,4
         N     R4,=X'000000FF'
         OR    R3,R4
         ST    R3,DATESAV               PREPARE TO REFORMAT DATE
         UNPK  DATESAV(9),DATESAV(5)
         MVC   PASDATE(2),DATESAV+4    FIRST MOVE MONTH
         MVC   PASDATE+3(2),DATESAV+6  THEN THE DAY
         MVC   PASDATE+6(4),DATESAV    FOLLOWED BY YEAR
         MVI   PASDATE+2,C'-'
         MVI   PASDATE+5,C'-'
*
*        FIX TIME OF DAY STRING
*
         ST    R0,DATESAV
         UNPK  DATESAV(7),DATESAV(4)     CONVERT TO EBCDIC
         MVC   PASTIME+6(2),DATESAV+4    MOVE SECONDS
         MVC   PASTIME+3(2),DATESAV+2    THEN MINUTES
         MVC   PASTIME(2),DATESAV        AND HOURS
         MVI   PASTIME+2,C':'
         MVI   PASTIME+5,C':'            AND FORMAT THE STRING
         MVC   PASTIME+8(2),=C'  '       PAD WITH BLANKS
*
*        FINALLY CALL THE USER PROGRAM
*
         LA    1,STACK
         L     LINK,=A($MAINBLK)
         BALR  RET,LINK
*
*        CLOSE THE OPEN FILES AND RETURN TO OS
*
         SR    R2,R2               RETURN CODE = ZERO  !
QUIT1    LA    R1,PXIT             CLOSE OPEN FILES / RETURN TO OS
         L     LINK,=A($PASCSP)
         BR    LINK               EXIT PASCAL PROGRAM
*
*
*        GET THE NEXT INTEGER IN THE PARAMETER LIST
*
GETNUM   BXH   R1,R8,NOPARM        QUIT IF NO MORE CHARS             #
         CLI   0(R1),C'='
         BNE   GETNUM             SKIP UNTIL THE FIRST '='
*
         SR    R3,R3
         SR    R4,R4              CLEAR ACCUMULATOR
*
NXTDIG   BXH   R1,R8,0(R7)         RETURN IF NO MORE CHARS           #
         CLI   0(R1),C'9'
         BHR   R7                 OR IF A NON DIGIT
         IC    R3,0(R1)
         SH    R3,=Y(C'0')
         BLR   R7                 IS ENCOUNTERED
         MH    R4,=H'10'
         AR    R4,R3              OTHERWISE KEEP ACCUMULATING
         B     NXTDIG
*
         EJECT
****************************************************************
*
*        TABLE OF CALLS FOR RUN TIME CHECK ROUTINES. TO BE COPIED
*        ,EXACTLY AS IS, ONTO THE RUN TIME STACK.
*
****************************************************************
*
CALSUB   DS    0F
CALLINX  L     R15,INXCHK+8
         BR    R15
         DC    A($INXCHK)
*
CALLRNG  L     R15,RNGCHK+8
         BR    R15
         DC    A($RNGCHK)
*
CALLPRM  L     R15,PRMCHK+8
         BR    R15
         DC    A($PRMCHK)
*
CALLPTR  L     R15,PTRCHK+8
         BR    R15
         DC    A($PTRCHK)
*
CALLPTA  L     R15,PTACHK+8
         BR    R15
         DC    A($PTACHK)
*
CALLSET  L     R15,SETCHK+8
         BR    R15
         DC    A($SETCHK)
*
CALLSTK  L     R15,STKCHK+8
         BR    R15
         DC    A($STKCHK)
*
CALLSUBS EQU   CALSUB,*-CALSUB
*
         DROP  R10
         EJECT
*
BUFSTORE DC    A(IOBUFSZE)
REQSTORE DC    A(MINSTORE,MAXSTORE)
ALOSTORE DS    2A
OSPARMS  DS    A                   ADDRESS OF O.S. PARAMETERS        #
OSPARMAD DC    A(0)                POINTER TO O.S. STRING            #
USESTORE DC    A(8000)
OLDPICA  DC    A(1)                                                  #
ERRLIMIT DC    F'1'                LIMIT ON NUMBER OF ERRORS
EXECTIME DC    XL4'7FFFFFFF'       DEFAULT TIME LIMIT
OSPARML  DC    H'0'                LENGTH OF PARM STRING             #
DUMPFLAG DC    X'00'               X'FF' IF DUMP REQUESTED
SPIEFLAG DC    X'00'               X'FF' IF SPIE NOT TO BE ISSUED    #
SNAPFLAG DC    X'00'               X'FF' IF SNAPSHOT NOT TO BE CALLED#
*
DATESAV  DS    F         # THESE LOCATIONS TO SUCCEED WITH NO GAP
         DS    2F        #      UNPACKING BUFFER
         DC    X'1900'   #
MONTH    DS    3X        #
JAN      DC    P'31,29,31,30,31,30,31,31,30,31,30,31'
*
         LTORG ,
         EJECT
***********************************************************************
*
*
*        INTERRRUPT PROCCESSING FOR PASCAL PROGRAMS
*
*        ONLY FIXED/FLOAT DIVISION BY ZERO AND EXPONENT OVERFLOW
*        INTERRUPTS ARE EXPECTED TO BE CAUGHT HERE, OTHER INTERRUPTS
*        IN GENERAL ARE CAUSED BY STACK/HEAP OVER FLOW OR A BAD I/O
*        FILE SPECIFICATION AND OR MISSING APPROPRIATE DD STATEMENTS.
*
***********************************************************************
         DS    0H
         USING *,R15
$PASINT  B     *+12
         DC    X'7',C'$PASINT'
         MVC   INTDATA(32),0(R1)   SAVE ALL INTERRUPT DATA FOR       #
         STM   R3,R13,INTDATA+32   POSSIBLE INCLUSION IN ABEND DUMP  #
         LA    R0,PASINT1          GO TO PASINT1 VIA THE CONTROL     #
         ST    R0,8(R1)            PROGRAM TO CANCEL SPIE EXIT       #
         BR    R14                                                   #
         DROP  R15                                                   #
*
PASINT1  BALR  R11,0               RE-ESTABLISH ADDRESSABILITY       #
         USING *,R11                                                 #
         L     R1,=A(OLDPICA)      CANCEL THE SPIE TRAP              #
         L     1,0(R1)            THAT IS IN EFFECT                  #
         SPIE  MF=(E,(1))                                            #
*                                                                    #
*        GET INTERRUPT CODE AND POINT TO THE APPROPRIATE ERROR MESSAGE
*
         SR    R4,R4
         IC    R4,INTDATA+7        GET THE INTERRUPT CODE            #
         LA    R8,2000(R4)             SET THE RETURN CODE
         IC    R4,MSGTBL(R4)
         LA    R3,MSGTXT+1(R4)         R3 --> ERROR MESSAGE
         IC    R4,MSGTXT(R4)           R4 --> MESSAGE LENGTH
         L     R14,INTDATA+8       GET LOCATION OF INTERRUPT         #
         CLI   SPUSERSA,X'FF'               SEE IF INTERR. IN SP MODULE
         BE    NOTINSP
*
*        IF INTERRUPTION OCCURED WITHIN THE '$PASCSP' ROUTINE PATCH UP
*        A SAVE AREA TO POINT TO CALLERS SAVE AREA FOR A MEANINGFULL
*        ERROR MESSAGE.
*
         L     R5,=A(SPUSERSA)              GET USER REGS
         LM    R12,R15,(R12-R1)*4(R5)       GET IMPORTANT VALUES
         LR    R10,R15                      SET PROC ENTRY POINT ADR
         ST    R13,FAKESA+4                 SET SAVE AREA CHAIN
         STM   R14,R15,FAKESA+12            SET RETURN ADR FIELD
         LA    R13,FAKESA
         L     R14,INTDATA+8       RESET INTERRUPT LOCATION          #
         B     KNOWNPRC
*
*        SEE IF R10 POINTS TO THE BEGINING OF A PROC.
*
NOTINSP  L     R12,=A(ALOSTORE)        GET THE STACK ADDRESS
         L     R12,0(R12)
         LA    R12,STACK-DYNSTORE(R12) POINT TO BASE OF THE STACK
         LA    R10,0(R10)
*        C     R10,=A($PASCSP)                                       #
*        BL    FIXENTRY                IF R10 IS OUT OF BOUND, SKIP  #
*        C     R10,=A($MAINBLK)                                      #
*        BH    FIXENTRY                                              #
         LH    R5,0(R10)               R10 IS WITHIN BOUND, SEE IF
         CH    R5,=XL2'47F0'           IT POINTS TO A PROC ENTRY POINT
         BNE   FIXENTRY
         CR    R13,R12                 SEE IF SAVE AREA PTR IS
         BL    FIXENTRY                WITHIN BOUNDS
         C     R13,NEWPTR-STACK(R12)
         BH    FIXENTRY
         C     R10,16(R13)             CONSISTANCY CHECK
         BE    KNOWNPRC                THIS IS A USER PROCEDURE ?
*
*        R10 POINTS TO NOWHERE, FAKE A PROCEDURE HEADING
*
FIXENTRY ST    R12,4+FAKESA            CHAIN THE FAKE SAVE AREA
         L     R5,16(R12)              POINT TO $MAINBLK ENTRY POINT
         ST    R5,12+FAKESA            SET RET. ADR. FROM FAKE PROC
         LA    R10,FAKEPROC            POINT TO THE ENTRY OF FAKEPROC
         AR    R14,R10                 ALSO SET THE ERROR LOCATION ADR
         LA    R13,FAKESA
*
*        THIS IS THE ENTRY TO A FAKE PROC TO BE USED IF
*        NO MEANINGFULL PROC IS FOUND AFTER AN INTRRUPT
*
KNOWNPRC L     R15,=A($CHKMSG0)
         BR    R15                GO TO PRINT ERROR MESSAGE
*
         USING *,R15
FAKEPROC B     *+12
         DC    AL1(7),C'UNKNOWN'
*
FAKESA   DC    6F'0'
*                                                                    #
         DC    CL8'INTDATA'                                          #
INTDATA  DS    19F                 INTERRUPT DATA                    #
*
MSGTBL   DC    AL1(0,IMSG1,IMSG1,IMSG1,IMSG1,IMSG1,IMSG1,IMSG1,IMSG1)
         DC    AL1(IMSG2,IMSG1,IMSG2,IMSG3,IMSG1,IMSG1,IMSG2)
*
MSGTXT   DS    0C
IM1      DC    AL1(L'IMSG1),C' PROGRAM INTERRUPT, SEE RETURN CODE.'
IMSG1    EQU   IM1-MSGTXT,*-IM1-1
IM2      DC    AL1(L'IMSG2),C' DIVISION BY ZERO '
IMSG2    EQU   IM2-MSGTXT,*-IM2-1
IM3      DC    AL1(L'IMSG3),C' EXPONENT OVERFLOW '
IMSG3    EQU   IM3-MSGTXT,*-IM3-1
         DC    C'    '
         DROP  R11
*
***************************************************************
*
*        END OF INTERRUPT HANDLING ROUTINE
*
***************************************************************
         SPACE 2
****************************************************************
*
*
*        PASCAL RUN TIME CHECK/ABORT ROUTINES
*
*
*        THE $CHKMSG ROUTINE IS USED BY THE INTERRUPT HANDLER AS
*        WELL AS OTHER $PASCSP ROUTINES TO PRINT OUT DIAGNOSTIC
*        MESSAGES ON THE 'OUTPUT' FILE.
*
*
****************************************************************
*
*
*        RANGE CHECK ROUTINE
*
$RNGCHK  DS    0H
         USING *,R15
         CR    R2,R0    CHECK LOWER BOUND
         BL    BADRNG
         CR    R2,R1    CHECK UPPER BOUND
         BNHR  R14      IF WITHIN BOUNDS, RETURN
BADRNG   STM   R0,R15,CHKSVALL SAVE IN CASE RETURN
         LA    R3,RNGMSG
         LA    R4,L'RNGMSG
         LA    R8,SUBERR    RETURN CODE
         B     $CHKMSG
*
*
*        INDEX CHECK ROUTINE
*
$INXCHK  DS    0H
         USING *,R15
         CR    R2,R0    CHECK LOWER BOUND
         BL    BADINX
         CR    R2,R1    CHECK UPPER BOUND
         BNHR  R14      IF WITHIN BOUNDS, RETURN
BADINX   STM   R0,R15,CHKSVALL  SAVE IN CASE HAVE TO RETURN
         LA    R3,INXMSG
         LA    R4,L'INXMSG
         LA    R8,INXERR     SET RETURN CODE
         B     $CHKMSG
*
*
*        POINTER CHECK ROUTINE
*
*
$PTACHK  DS    0H
         USING *,R15
         SR    R0,R0
         BCTR  R0,0     R0 <-- '-1'
         CR    R0,R2
         BER   R14      NIL VALUE BEING ASSIGNED
*
         BALR  R15,0    GO TO NEXT ROUTINE TO CNTINUE CHECKING
*
$PTRCHK  DS    0H
         USING *,R15
         LM    R0,R1,NEWPTR   LOAD POINTER RANGE
         CR    R2,R0    CHECK LOWER BOUND
         BL    BADPTR
         CR    R2,R1    CHECK UPPER BOUND
         BNHR  R14      IF WITHIN BOUNDS, RETURN
BADPTR   STM   R0,R15,CHKSVALL SAVE IN CASE OF RETURN
         LA    R3,PTRMSG
         LA    R4,L'PTRMSG
         LA    R8,PTRERR
         B     $CHKMSG
*
*
*        PASSED PARAMETER CHECK ROUTINE
*
$PRMCHK  DS    0H
         USING *,R15
         CR    R2,R0    CHECK LOWER BOUND
         BL    BADPRM
         CR    R2,R1    CHECK UPPER BOUND
         BNHR  R14      IF WITHIN BOUNDS, RETURN
BADPRM   STM       R0,R15,CHKSVALL SAVE IN CASE OF RETURN
         LA    R3,PRMMSG
         LA    R4,L'PRMMSG
         LA    R8,PARERR     SET RETURN CODE
         B     $CHKMSG
*
*
*        SET MEMBER CHECK ROUTINE
*
$SETCHK  DS    0H
         USING *,R15
         CL    R2,=F'63'                                             #
         BNHR  R14                IF WITHIN BOUNDS, RETURN
BADSET   STM       R0,R15,CHKSVALL SAVE IN CASE OF RETURN
         LA    R3,SETMSG
         LA    R4,L'SETMSG
         LM    R0,R1,=F'0,63'
         LA    R8,SETERR
         B     $CHKMSG
*
*        STACK/HEAP INTERFERENCE ERROR
*
$STKCHK  DS    0H
         USING *,R15
         LA    R3,STKMSG
         LA    R4,L'STKMSG
         LA    R8,STKERR
         B     $CHKMSG0
*
*        'TIME OUT' ENTRY POINT
*
*        ASSUMES THAT R10 POINTS TO THE CURR PROC ENTRY POINT
*        THIS MAY NOT BE TRUE UNDER MFT OR SOME OTHER VARIANTS
*        OF THE OPERATING SYSTEM. ( 'STIMER' PECULIARITY )
*
$TIMEOUT DS    0H                 ENTRY TO TIME OUT ERROR
         BALR  R15,0
         USING *,R15
         L     R12,=A(ALOSTORE)   RESTORE STACK POINTER IN CASE !
         L     R12,0(R12)
         LA    R12,STACK-DYNSTORE(R12)
         LR    R13,R12
*
         CLI   SPUSERSA,X'FF'     SEE IF TIMER WENT OFF IN '$PASCSP'
         BE    TIMEOUT2
         LM    R1,R14,SPUSERSA     IF SO, RESTORE REGS ACCORDINGLY
         B     TIMEOUT4
*
TIMEOUT2 L     R1,16          LOAD CVT ADDR                          #
         L     R1,0(,R1)      LOAD TCB WORDS ADDR                    #
         L     R1,4(,R1)      ADDR OF CURRENT TCB                    #
         L     R1,120(,R1)    ADDR OF TQE                            #
         L     R1,28(,R1)     ADDR OF RB                             #
         L     R1,20(,R1)     WORD2 OF OLD PSW (AT LAST)             #
         LA    R14,0(,R1)     SET ERROR LOC TO THIS ADDRESS          #
TIMEOUT3 C     R10,16(R13)        GO DOWN THE CALL CHAIN UP TO
         BE    TIMEOUT4           CURRENT PROC.
         L     R13,8(R13)         PROCEED TO NEXT SAVE AREA
         B     TIMEOUT3
*
TIMEOUT4 DS    0H
         LA    R3,TIMMSG
         LA    R4,L'TIMMSG
         LA    R8,TIMERR
         B     $CHKMSG0
*
*
*
*        THIS IS THE ENTRY POINT FOR RUN-TIME ERROR INDICATION
*        AND THE RELATED MESSAGES.
*
*
$CHKMSG0 BALR  R11,0              ENTRY POINT FOR FATAL ERRORS
         USING *,R11
         MVI   NORETURN,X'FF'
         B     $CHKMSG3
$CHKMSG  BALR  R11,0              ENTRY FOR (POSSIBLY) REPETABLE ERROR
         USING *,R11
         MVI   NORETURN,X'00'
$CHKMSG3 BALR  R11,0
         DROP  R15
         USING *,R11
         LA    R14,0(R14)
         LA    R15,0(R15)         GET RID OF FLAG BITS
         STM   R14,R13,CHKSAVE    SAVE RELEVENT REGISTERS
*
         L     R2,SNAPADR
         LTR   R2,R2               IS SNAPSHOT LOADED ?
         BZ    NOSNAP
         L     R2,=A(SNAPFLAG)                                       #
         CLI   0(R2),X'00'         SNAPSHOT TO BE USED?              #
         BNE   NOSNAP              NO                                #
*
         ST    R8,CHKSAVE-4        SAVE ERROR CODE
         GETMAIN EC,LV=SNAPAREA,A=SNAPLOCS                           #
         LTR   R15,R15             SUCCESSFUL ?                      #
         BNZ   NOSNAP              NOT ENOUGH SPACE FOR SNAPSHOT     #
         L     R1,SNAPLOCS                                           #
*        R1 POINTS TO THE BASE OF GOTTEN AREA
         SR    R2,R2
         BCTR  R2,0                R2 <-- '-1'
         ST    R2,LCAFTMST(R1)     FIRST PARM OF 'SNAPSHOT'
         LA    R2,CHKSAVE-4        SECOND PARM OF 'SNAPSHOT'
         ST    R2,LCAFTMST+4(R1)
         L     R15,SNAPADR
         BALR  R14,R15
         FREEMAIN R,LV=SNAPAREA,A=SNAPLOCS  RETURN THE AREA TO O.S.  #
         B     SNAPDONE
*
NOSNAP   DS    0H
         LA    R8,SNPERR(R8)
         L     R15,=A($PASCSP)    PREPARE TO CALL I/O MODULE
         LA    R9,OUTPUT          PICK THE FILE NAME
         LA    R1,PREW            (RE)OPEN THE MESSAGE (OUTPUT) FILE
         BALR  R14,R15
         LA    R1,PSKP                                               #
         LA    R2,2                                                  #
         BALR  R14,R15            SPACE PROPERLY
*
         LA    R1,PWRS            THE FUNCTION (WRITE STRING)
         LA    R2,MSG1
         LA    R4,L'MSG1
         LA    R3,9(R4)           STRING LENGTH AND FIELD WIDTH
         BALR  R14,R15
*
         LA    R1,PWRI            WRITE LOCATION OF ERROR
         L     R2,CHKSAVE
         S     R2,CHKSAVE+(R10+2)*4    RELATIVE ADDRESS OF ERROR
         LA    R3,11                   LOCATION AND ITS FIELD WIDTH
         BALR  R14,R15
*
         L     R2,CHKSAVE+4*(R10+2)    POINT TO PROC. ENTRY POINT
         MVC   MSG2PROC,5(R2)          AND MOVE THE PROC. NAME
         LA    R1,PWRS
         LA    R2,MSG2
         LA    R3,L'MSG2+7
         LR    R4,R3
         BALR  R14,R15
*
*        INDICATE THE TYPE OF RUN TIME ERROR
*
         LA    R1,PSKP                                               #
         LA    R2,2                                                  #
         BALR  R14,R15                 NEW LINE
         LA    R1,PWRS
         LA    R2,MSG1                 ' **** '
         LA    R4,7
         LA    R3,9(R4)
         BALR  R14,R15
         LM    R2,R3,CHKSAVE+4*(R3+2)
         LR    R4,R3
         BALR  R14,R15
*
*        INDICATE THE STATMNT # OF THE ERROR LOCATION, IF ASKED FOR
*
         BAL   R6,PRNTLOC
         AIF   (&SYSTEM).SYS34
*
*        PRINT THE ERRONEOUS VALUE AND THE RANGE
*
PRNTRNG  L     R0,CHKSAVE+4*(R15-R14)
         C     R0,=A($STKCHK)          THESE ERRORS DO NOT HAVE
         BNL   CALCHAIN                A RANGE TO BE PRINTED
*
         LA    R1,PWRS
         LA    R2,MSG4
         LA    R4,L'MSG4
         LA    R3,9(R4)
         BALR  R14,R15
         LA    R1,PWRI
         L     R2,CHKSAVE+4*(R2+2)
         LA    R3,8
         BALR  R14,R15                 PRINT THE OUT OF RANGE VALUE
         LA    R1,PWRS
         LA    R2,MSG5
         LA    R4,L'MSG5
         LR    R3,R4
         BALR  R14,R15
         LA    R1,PWRI
         L     R2,CHKSAVE+4*(R0+2)
         LA    R3,8
         BALR  R14,R15                 PRINT LOWER BOUND (OF THE RANGE)
         LA    R3,10
         L     R2,CHKSAVE+4*(R1+2)
         BALR  R14,R15                 AND THE UPPER BOUND
         LA    R1,PSKP                                               #
         LA    R2,2                                                  #
         BALR  R14,R15
*
.SYS34   ANOP
CALCHAIN LA    R1,PSKP                                               #
         LA    R2,2                                                  #
         BALR  R14,R15
         LA    R7,16                   SET MAX # OF LINKS TO BE TRACED
NXTLNK   CR    R13,R12                 SEE IF END OF STACK
         BE    CHAINDON
         MVC   CALLED(7),5(R10)        MOVE CALLERS NAME
         L     R5,12(R13)              BACK UP TO THE HIGHER SAVE AREA
         L     R13,4(R13)
         L     R10,12+(R15-R14)*4(R13) ENTRY POINT OF THE 'CALLER'
         MVC   CALLER(7),5(R10)        MOVE CALLER'S 'NAME'
         LA    R2,MSG7
         LA    R3,L'MSG7
         LR    R4,R3
         LA    R1,PWRS
         BALR  R14,R15
         BAL   R6,PRNTLOC              PRINT WHEREABOUT OF THE CALL
         BCT   R7,NXTLNK               NEXT LEVEL IF NOT EXHAUSTED
CHAINDON DS    0H
*
*
*        TIME TO EXIT
*
ABORT    LA    R1,PWLN                 TERMINATE LINE BUFFER
         BALR  R14,R15
*
SNAPDONE DS    0H
         CLI   NORETURN,X'FF'          IF NO RETURN
         BE    ABORT2                  THEN ABORT
         L     R1,HEAPLIM
         USING DYN2STOR,R1
         L     R3,DYNERRC
         LA    R3,1(R3)
         ST    R3,DYNERRC
         C     R3,DYNERRL
         BNL   ABORT2
         DROP  R1
         LM    R0,R15,CHKSVALL
         BR    R14
ABORT2   DS    0H
         L     R15,=A($PASCSP)
         LA    R9,OUTPUT
         LA    R1,PREW                 CLOSE THE MESSAGE FILE
         BALR  R14,R15
         LR    R2,R8
         LA    R1,PXIT
         BR    R15
*
*
PRNTLOC  DS    0H
SKIP2    LA    R1,PSKP                                               #
         LA    R2,2                                                  #
         BALR  R14,R15
         BR    R6            RETURN TO CALLER
.SYS36   ANOP
*
NORETURN DS    X                   IF X'FF' THEN CAN RETURN
         DS    0D
CHKSVALL DS    18F
CHKSAVE  DS    16F                 ALSO INCLUDES THE PREV. FOUR BYTES
*
SNAPADR  DC    V(SNAPSHOT)
SNAPAREA EQU   2048                APPROX SIZE OF SNAPSHOT LOCAL DATA#
SNAPLOCS DS    A                   ADDRESS OF TEMP SNAPAREA          #
*
*
RNGMSG   DC    C' SUBRANGE VALUE OUT OF RANGE '
INXMSG   DC    C' INDEX VALUE OUT OF RANGE '
PTRMSG   DC    C' POINTER VALUE OUT OF RANGE '
PRMMSG   DC    C' ACTUAL PARAMETER OUT OF RANGE '
STKMSG   DC    C' STACK/HEAP OVER/UNDER_FLOW '
SETMSG   DC    C' SET MEMBER OUT OF RANGE '
TIMMSG   DC    C' RUNNING OUT OF TIME '
ENDMSG   DC    C' '
*
MSG1     DC    C' ****   RUN ERROR AT LOCATION :'
*
MSG2     DC    C'  OF PROCEDURE :  '
MSG2PROC DS    CL7
*
MSG3     DC    C'  BETWEEN P_STATEMENTS :'
*
MSG4     DC    C' ****   THE OFFENDING VALUE :'
*
MSG5     DC    C'  IS NOT IN THE RANGE :'
*
MS7      DC    C'          ****   '
CALLED   DC    CL7' '
MSG6     DC    C'  WAS CALLED BY :  '
CALLER   DC    CL7' '
MSG7     EQU   MS7,*-MS7
*
         DROP  R11
         LTORG
         EJECT
******************************************************************
*
*
*        PASCAL I/O AND STANDARD PROCEDURE (CSP) INTERFACE
*
*        FOLLOWING CODE INTERCEPTS ERRORS DETECTED BY FORTRAN        #
*        MATH. ROUTINES.  SUCH ROUTINES ARE PRESENT IF REFERRED      #
*        TO BY THE PASCAL PROGRAM.                                   #
*
******************************************************************
         SPACE 2
         AIF   (&SYSTEM).SYS38
*
*        IHCERRM - CALLED BY FORTRAN MATH ROUTINES IN CASE OF ERROR
*
ERRMON   DS    0H                                                    #
IHCERRM  DS    0H
IHOERRM  DS    0H
IHNERRM  DS    0H                                                    #
         ENTRY IHCERRM,IHOERRM,IHOERRE,IHNERRM,IHNERRE,IHCERRE       #
         ENTRY  ERRMON                                               #
         USING IHCERRM,R15
         L     R1,0(R1)            GET 1ST ARG - PTR TO A(LEN),C'MSG'
         SR    R4,R4
         IC    R4,3(R1)            GET THE MESSAGE LENGTH
         LA    R3,4(R1)            POINT TO MESSAGE TEXT
         NOPR  0                   WARNING - THE LOCATION ERRMON+19  #
         BC    0,0                 CAN BE OVERWRITTEN BY FORTRAN     #
         L     R15,=A($CHKMSG0)
         LA    R8,3001             SET RETURN CODE
         BR    R15                 GIVE THE ERROR MSG
         DROP  R15
*
*        THE FOLLOWING IS FOR THE FORTRAN ERROR MESSAGES
*
IHCERRE  DS    0H                                                    #
IHNERRE  DS    0H                                                    #
IHOERRE  BR    R14                 THIS SHOULD NOT BE CALLED
         LTORG                                                       #
*
         SPACE 2
.SYS38   ANOP
         EJECT
*****************************************************************
*
*
*        $PASCSP (PASCAL I/0) ENTRY POINT
*
*
*****************************************************************
*
         DS    0D
         USING *,15
$PASCSP  B     *+12                BRANCH AROUND ID
         DC    AL1(7),CL7'$PASCSP'
*
         STM   R1,R15,SPUSERSA      SAVE ONLY POTENTIALLY USEFULL ONES
         LA    R13,SPSYSTSA         SET UP SYSTEM SAVE AREA
         LR    R10,R15
         LA    R11,2048(,R10)                                        #
         LA    R11,2048(,R11)      SET UP TWO BASE REGS              #
         DROP  R15
         USING $PASCSP,R10,R11                                       #
         USING IHADCB-FILDCB,AE                                      #
*        SLA   R1,2                DECODE THE SUBROUTINE NUMBER
         L     R1,SUBTBL(R1)
         BR    R1
         DS    0F
SUBTBL   DC    A(GET,PUT,RES,RLN,REW,WLN,WRS,ELN)
         DC    A(WRI,WRR,WRC,RDI,RDR,RDC)
         DC    A(SIN,COS,EXP,LOG,SQT,ATN)
         DC    A(EOF,XIT,RDS,TRP,SIO,EIO,CLK,FDF,PAG,CLS)
         DC    A(RDB,WRB,SKP,LIM,MSG)                                #
SPUSERSA DC    18XL4'FFFFFFFF'
*
*
*        (GET FETCH) GET A CHAR TO (AD)
*
FILGFE   LH    R1,FILPTR(AE)                                         #
         LA    R1,1(,R1)                                             #
         CH    R1,FILEND(AE)       TEST FOR END-OF-LINE              #
         BNL   FILGFE2             IF SO, GO AND PROVIDE A BLANK     #
         IC    R0,0(R1,AF)         PICK UP INPUT CHARACTER           #
FILGFE1  STC   R0,0(AD)             AND PUT INTO CALLER'S BUFFER     #
         STH   R1,FILPTR(AE)                                         #
         BR    R5                                                    #
FILGFE2  LA    R0,FILBLA           SET EOL CHARACTER                 #
         BE    FILGFE1             GO BACK TO RETURN EOL CHAR        #
*        B     FILGET              NEED TO GET A NEW INPUT RECORD    #
*
*        GET A RECORD TO (AF)
*
FILGET   DS    0H
         TM    FILEOF(AE),1
         BOR   R5                  RETURN IF END-OF-FILE             #
         AIF   (&SYSTEM).SYS42
         CLI   FILOPN(AE),READOPN
         BNE   BADREAD             IF FILE NOT OPEN FOR READ, COMPLAIN
.SYS42   ANOP
FILGET1  MVI   RRFLAG,0            CLEAR REREAD FLAG                 #
         GET   FILDCB(AE)          READ THE NEXT RECORD              #
         CLI   RRFLAG,0            TEST IF REREAD ASKED FOR          #
         BNE   FILGET1             IF SO, GO BACK AND TRY AGAIN      #
         ST    R1,FILBUF(AE)       STORE ADDRESS OF INPUT RECORD     #
         LR    AF,R1                                                 #
         LH    R1,FILBEG(AE)                                         #
         STH   R1,FILPTR(AE)       RESET CHAR. PTR                   #
         IC    R0,0(R1,AF)                                           #
         STC   R0,0(AD)            UPDATE CURRENT FILE ELEMENT       #
         MVC   FILEND(2,AE),DCBLRECL    RESET BUFFER LENGTH          #
         BR    R5
*
*        (PUT-STORE) PUT A CHAR FROM (AD)
*
FILPST   LH    R1,FILPTR(AE)
         CH    R1,FILEND(AE)       TEST IF BUFFER FULL               #
         BNL   FILPST1             CLEAR IT FIRST                    #
         IC    R0,0(AD)                                              #
         STC   R0,0(R1,AF)                                           #
         LA    R1,1(R1)            INCREMENT CHAR. PTR.              #
         STH   R1,FILPTR(AE)                                         #
         BR    R5                                                    #
FILPST1  ST    R5,FILPSTSV         SAVE RETURN ADDRESS               #
         BAL   R5,FILPUT           EMPTY THE BUFFER                  #
         L     R5,FILPSTSV                                           #
         B     FILPST                                                #
*
*        PUT A RECORD (FROM AF)
*
FILPUT   DS    0H
         AIF   (&SYSTEM).SYS44
         CLI   FILOPN(AE),WRITEOPN
         BNE   BADWRITE            IF NOT OPEN FOR WRITE, THEN COMPLAIN
.SYS44   ANOP
         ST    R5,FILPUTSV         SAVE RETURN REG                   #
         BAL   R5,FILEOLN          COMPLETE THE OUTPUT LINE          #
         L     R5,FILPUTSV         RESTORE RETURN REG                #
         LH    R0,FILPTR(AE)       R0 = NEXT CHARACTER POSN
         PUT   FILDCB(AE)          WRITE THE RECORD                  #
         ST    R1,FILBUF(AE)       SAVE ADDRESS OF NEXT OUTPUT BUFFER#
         MVC   FILEND(2,AE),DCBLRECL  RESET BUFFER LENGTH            #
         LR    AF,R1                                                 #
         AIF   (&SYSTEM).SYS415                                      #
         L     R0,FILLIM(AE)       LOAD LINES LIMIT                  #
         BCT   R0,FILPUT1          DECREMENT                         #
         ST    R0,FILLIM(AE)       OVERFLOW OF COUNTER               #
         B     LIMITERR                                              #
FILPUT1  ST    R0,FILLIM(AE)       PUT DECREMENTED COUNT BACK        #
.SYS415  ANOP                                                        #
*        B     FILCLR              I.E., NEXT LINE                   #
*                                                                    #
*        CLEAR THE OUTPUT BUFFER TO BLANKS                           #
*                                                                    #
FILCLR   LH    R1,FILBEG(AE)                                         #
         STH   R1,FILPTR(AE)       RESET CHAR. POINTER               #
         CLI   DCBRECFM,X'80'      JUMP IF F OR U-FORMAT             #
         BNL   FILCLR1                                               #
         TM    DCBRECFM,X'06'                                        #
         BZR   R5                  RETURN IF NO CONTROL CHAR NEEDED  #
         MVI   4(AF),FILBLA        SET DEFAULT CONTROL CHAR          #
         TM    DCBRECFM,X'04'                                        #
         BOR   R5                  RETURN IF ASCII CONTROL CHARS     #
         MVI   4(AF),X'09'         REPLACE WITH MACHINE CHAR         #
         BR    R5                                                    #
FILCLR1  LH    R15,FILEND(AE)      LOAD BUFFER LENGTH                #
         LA    R14,256                                               #
         LR    R1,AF               LOAD BUFFER ADDRESS               #
         MVI   0(AF),FILBLA                                          #
         SH    R15,=H'2'                                             #
         B     FILCLR3                                               #
FILCLR2  MVC   1(256,R1),0(R1)     PROPAGATE BLANKS                  #
         AR    R1,R14                                                #
         SR    R15,R14                                               #
FILCLR3  BMR   R5                                                    #
         CR    R15,R14                                               #
         BNL   FILCLR2                                               #
         EX    R15,CLRBUF          CLEAR REMAINDER OF BUFFER         #
         TM    DCBRECFM,X'02'                                        #
         BZR   R5                  RETURN IF NOT MACH CONTROL CHAR   #
         MVI   0(AF),X'09'                                           #
         BR    R5                                                    #
*                                                                    #
CLRBUF   MVC   1(0,R1),0(R1)       PROPAGATE BLANKS                  #
*
*        'END OF DATA' EXIT, THIS ROUTINE IS ENTERED WHENEVER
*        A 'GET' IS ISSUED FOR A FILE WHICH HAS REACHED THE
*        'END OF FILE' MARK. (I.E. NO MORE INPUT)
*
EOD      DS    0H
         LA    AG,FILDCB(AE)                                         #
         CLOSE ((AG))
         TM    DCBBUFCB+3,1                                          #
         BO    EOD1                SKIP IF NO BUFFER POOL            #
         FREEPOOL (AG)                                               #
EOD1     EQU   *                                                     #
         OI    FILEOF(AE),1
         MVI   FILOPN(AE),0         CLEAR THE OPEN FLAG
         MVI   0(AD),FILBLA        SET EOL CHARACTER                 #
         SR    AF,AF               INDICATE NO I/O BUFFER            #
         STH   AF,FILBEG(AE)       RESET VARIOUS POINTERS            #
         STH   AF,FILEND(AE)                                         #
         STH   AF,FILPTR(AE)                                         #
         ST    AF,FILBUF(AE)                                         #
         BR    R5                                                    #
*                                                                    #
*        PREPARE THE OUTPUT BUFFER FOR TRANSMITTING TO O.S.          #
*                                                                    #
FILEOLN  DS    0H                                                    #
         CLI   DCBRECFM,X'80'                                        #
         BNLR  R5                  RETURN IF F OR U-FORMAT           #
         LA    R0,6                MIN LENGTH FOR VBA RECORDS        #
         TM    DCBRECFM,X'06'                                        #
         BNZ   *+6                 JUMP IF CONTROL CHARS             #
         BCTR  R0,0                ADJUST MIN LENGTH                 #
         LH    R1,FILPTR(AE)                                         #
         CR    R1,R0                                                 #
         BNL   FILEOLN1            JUMP IF RECORD SIZE OK            #
         LTR   AF,AF               RETURN IF THE I/O BUFFER IS NOT   #
         BZR   R5                  ALLOCATED  (FILE NEWLY OPENED)    #
         LA    R0,FILBLA                                             #
         STC   R0,0(R1,AF)         PROVIDE 1 CHAR AT LEAST           #
         LA    R1,1(R1)                                              #
FILEOLN1 STH   R1,0(AF)            SET RDW FOR V-FORMAT              #
         BR    R5                                                    #
*                                                                    #
*        EXIT ROUTINE CALLED WHEN DCB IS OPENED                      #
*              IN THIS ROUTINE, WE PROVIDE SOME REASONABLE DEFAULTS  #
*              FOR THE RECFM, LRECL, BLKSIZE AND BUFNO ATTRIBUTES    #
*              THIS ROUTINE ALSO SETS THE REREAD FLAG WHEN NEEDED    #
*              AT THE CHANGE-OVER BETWEEN TWO CONCATENATED           #
*              INPUT FILES.                                          #
*                                                                    #
XLSTRTIN LA    R1,DEFAULTS         ENTRY FOR INPUT AND INOUT FILES   #
         TM    DCBOFLGS,X'08'      TEST IF CONCAT. FLAG SET          #
         BZ    XLSTRT1                                               #
         MVI   RRFLAG,X'FF'        REQUEST A REREAD                  #
         B     XLSTRT2                                               #
XLSTRT1  OI    DCBOFLGS,X'08'      REQUEST PROCESSING OF CONCAT FILES#
XLSTRT2  SR    R0,R0                                                 #
         CLI   DCBBUFNO,0                                            #
         BNE   XLSTRT3             JUMP IF BUFNO PROVIDED            #
         MVC   DCBBUFNO(1),4(R1)                                     #
XLSTRT3  TM    DCBRECFM,X'FE'                                        #
         BNE   XLSTRT4             JUMP IF RECFM SPECIFIED           #
         OC    DCBRECFM(1),5(R1)                                     #
XLSTRT4  LH    R15,0(R1)           LOAD TARGET BYTES PER RECORD      #
         CH    R0,DCBLRECL                                           #
         BNE   XLSTRT5             JUMP IF LRECL SPECIFIED           #
         TM    DCBRECFM,X'C0'                                        #
         BO    XLSTRT5             JUMP IF U-FORMAT (LEAVE LRECL=0)  #
         CLI   DCBRECFM,X'80'                                        #
         BNL   *+8                 JUMP IF F-FORMAT                  #
         LA    R15,4(R15)          ALLOW FOR RDW/SDW IN RECORD LENGTH#
         TM    DCBRECFM,X'06'                                        #
         BZ    *+8                 JUMP IF NO CONTROL CHAR.          #
         LA    R15,1(R15)          ADD IN 1 BYTE FOR CONTROL CHAR    #
         STH   R15,DCBLRECL                                          #
XLSTRT5  CH    R0,DCBBLKSI                                           #
         BNER  R14            RETURN IF BLKSIZE SPECIFIED            #
         LH    R1,2(R1)       LOAD TARGET BLKSIZE                    #
         CLI   DCBRECFM,X'80'                                        #
         BNL   XLSTRT6        JUMP IF NOT V-FORMAT                   #
         LA    R15,4(R15)     LRECL+4 IS MINIMUM BLKSIZE             #
         B     XLSTRT7                                               #
XLSTRT6  TM    DCBRECFM,X'C0'                                        #
         BO    XLSTRT8        JUMP IF RECFM=U                        #
         DR    R0,R15         THEREFORE, RECFM=F HERE                #
         MR    R0,R15                                                #
XLSTRT7  CR    R1,R15                                                #
         BL    XLSTRT8                                               #
         LR    R15,R1                                                #
XLSTRT8  STH   R15,DCBBLKSI                                          #
         BR    R14                                                   #
XLSTRTOT LA    R1,DEFAULTS         ENTRY FOR OUTPUT DCB'S            #
         C     AE,=A(FILOUT)       TEST IF FILE IS "OUTPUT"          #
         BNE   XLSTRT2             IT USES DIFFERENT DEFAULTS        #
         LA    R1,OUTDFLTS                                           #
         B     XLSTRT2                                               #
*
*        RESET AN INPUT FILE
*
*
         DC    CL4'RES '
RES      DS    0H
         LA    R0,FILCOUNT+INPUT   LAST+1 FILE ADDRESS
         CR    AD,R0
         BNL   BADREAD             RESETTING A NON EXISTANT FILE ?
         FILADR ,
         BAL   R5,FILCLOS          GO AND CLOSE THE FILE             #
*
*        (GET) OPEN A FILE
*
FILGOP   MVI   FILOPN(AE),0        CLEAR OPEN FLAG
         LA    AG,FILDCB(AE)                                         #
         OPEN  ((AG),(INPUT))
         TM    DCBOFLGS,X'10'
         BNO   BADREAD
         LH    R1,DCBLRECL
         TM    DCBRECFM,X'C0'                                        #
         BNO   *+8                 JUMP IF NOT U-FORMAT              #
         LH    R1,DCBBLKSI                                           #
         STH   R1,FILEND(AE)       SET LRECL FOR THE LOCAL BUF
         NI    FILEOF(AE),255-1    SET FLAGS, PTRS, ETC.
         MVI   FILOPN(AE),READOPN
         XC    FILBEG(2,AE),FILBEG(AE)  RESET CHAR. START POS.       #
         CLI   DCBRECFM,X'80'                                        #
         BNL   FILGOP1             JUMP IF NOT V-FORMAT              #
         MVI   FILBEG+1(AE),4      ALLOW 4-BYTE RDW/SDW              #
FILGOP1  TM    DCBRECFM,X'06'                                        #
         BZ    FILGOP2             JUMP IF NO CONTROL CHARS          #
         CLI   CCFLAG,0            OR IF CONTROL CHARS ARE NOT       #
         BE    FILGOP2             TO BE INSERTED                    #
         OI    FILBEG+1(AE),1      ADD IN 1-BYTE CONTROL CHAR        #
FILGOP2  EQU   *                                                     #
         BAL   R5,FILGET
         B     RTN                 RETURN TO PASCAL PROGRAM
*
*
*
         DC    CL4'GET'
GET      FILADR ,
         TM    FILEOF(AE),1
         BO    RTN
         BAL   R5,FILGFE
         B     RTN
*
*
*
         DC    CL4'EOF '
EOF      FILADR ,
         LA    RSLT,TRUE
         TM    FILEOF(AE),1
         BO    RTN
         AIF   (&SYSTEM).SYS46
         CLI   FILOPN(AE),READOPN
         BNE   BADREAD             COMPLAIN IF 'EOF' ON OUTPUT FILE
.SYS46   ANOP
         SR    RSLT,RSLT
         B     RTN
*
*
*
         DC    CL4'RLN'
RLN      FILADR ,
         BAL   R5,FILGET
         B     RTN
*
*
*
         DC    CL4'ELN '
ELN      FILADR ,
         LA    RSLT,TRUE
         TM    FILEOF(AE),1
         BO    RTN
         AIF   (&SYSTEM).SYS48
         CLI   FILOPN(AE),READOPN
         BNE   BADREAD             COMPLAIN IF 'ELN' ON OUTPUT FILE
.SYS48   ANOP
         CLC   FILPTR(2,AE),FILEND(AE)  CHECK IF AT END OF LINE      #
         BE    RTN
         SR    RSLT,RSLT
         B     RTN
*
*
*        RDB, (READ BOOLEAN)   ADR(FILE),ADR(BOOLEAN)                #
*
RDB      FILADR ,                                                    #
RDB1     CLI   0(AD),FILBLA                                          #
         BNE   RDB3                SCAN FOR NON-BLANK                #
RDB2     BAL   R5,FILGFE                                             #
         TM    FILEOF(AE),1                                          #
         BO    EOFREAD             ERROR IF END-OF-FILE              #
         B     RDB1                                                  #
RDB3     LA    RSLT,TRUE                                             #
         CLI   0(AD),C'T'          T = TRUE ?                        #
         BE    RDB4                                                  #
         CLI   0(AD),C'F'          F = FALSE ?                       #
         BNE   BADBOOL             NEITHER = AN ERROR                #
         SR    RSLT,RSLT                                             #
RDB4     STC   RSLT,0(R2)          STORE THE RESULT                  #
         BAL   R5,FILGFE           STEP TO FOLLOWING CHAR            #
         B     RTN                                                   #
*
*
         DC    CL4'RDC'
*
*        RDC  ADR(FILE),ADR(CHAR)
*         AD : FILE ADDRESS, R2 : ADDRESS FOR THE 'CHAR'
RDC      FILADR ,
         TM    FILEOF(AE),1
         BO    RTN
         IC    R0,0(AD)
         STC   R0,0(R2)
         BAL   R5,FILGFE
         B     RTN
*
*        RDI    AD: ADR(FILE),  R2: ADR(INT)
*
         DC    CL4'RDI'
RDI      FILADR ,
         LR    R4,R2               CLEAR A REGISTER PAIR  (R2,R3)
         SR    R3,R3
         MVI   SIGN,1              ASSUME POSITIVE
RDI1     CLI   0(AD),FILBLA
         BNE   RDI2
RDI11    BAL   R5,FILGFE
         TM    FILEOF(AE),1                                          #
         BO    EOFREAD             ERROR IF END-OF-FILE              #
         B     RDI1
RDI2     CLI   0(AD),FILPLU
         BE    RDI23                                                 #
         CLI   0(AD),FILMIN
         BNE   RDI25
         MVI   SIGN,0              CHANGE TO NEGATIVE
RDI23    BAL   R5,FILGFE                                             #
RDI25    LA    R15,BADINT          PREPARE ERROR RT ADDRESS          #
RDI4     SR    R0,R0                                                 #
         IC    R0,0(AD)            GET DIGIT                         #
         SH    R0,=AL2(FILZER)                                       #
         BMR   R15                 QUIT LOOP IF NON-DIGIT            #
         CH    R0,=AL2(9)                                            #
         BHR   R15                                                   #
         M     R2,=F'10'                                             #
         AR    R3,R0
         BAL   R5,FILGFE
         BAL   R15,RDI4            LOOP BACK & SET EXIT ADDRESS      #
RDI5     TM    SIGN,1
         BO    *+6
         LCR   R3,R3
         ST    R3,0(R4)
         B     RTN
*
*
*  RDS, (READ STRING), R2= STRING ADDRESS, R3=STRING LENGTH !
*
         DC    CL4'RDS'
*
RDS      FILADR ,
         TM    FILEOF(AE),1
         BO    RTN
         LH    R1,FILPTR(AE)
         IC    R0,0(AD)            START WITH CURRENT CHARACTER      #
RDSNXTCH STC   R0,0(R2)            COPY CHARS ONE-BY-ONE             #
         LA    R2,CHR(R2)                                            #
         LA    R1,1(,R1)                                             #
         CH    R1,FILEND(AE)       END OF THIS LINE?                 #
         BL    RDSF1               IF NOT, JUMP                      #
         LA    R0,FILBLA           END OF LINE CHARACTER             #
         BE    RDSF2               JUMP IF FIRST CHAR AFTER EOLN     #
         BAL   R5,FILGET           REFILL THE LINE BUFFER            #
         LH    R1,FILPTR(AE)                                         #
RDSF1    IC    R0,0(R1,AF)         LOAD NEXT INPUT CHAR              #
RDSF2    BCT   R3,RDSNXTCH         REPEAT                            #
         STC   R0,0(AD)
         STH   R1,FILPTR(AE)
         CH    R1,FILEND(AE)
         BNH   RTN
         BAL   R5,FILGET           NEED TO REFIL THE BUFFER
         B     RTN
*
*
*  REW, (REWRITE = REWIND FOR OUTPUT)
*
         DC    CL4'REW'
REW      DS    0H
         LA    R0,FILCOUNT+INPUT   LAST+1 FILE ADDRESS
         CR    AD,R0
         BNL   BADWRITE            REWRITING A NON EXISTANT FILE ?
         FILADR ,
         BAL   R5,FILCLOS          GO AND CLOSE THE FILE             #
*
*        (PUT) OPEN A FILE
*
FILPOP   MVI   FILOPN(AE),0        PUT_OPEN THE FILE
         LA    AG,FILDCB(AE)                                         #
         OPEN  ((AG),(OUTPUT))
         TM    DCBOFLGS,X'10'
         BNO   BADWRITE            REPORT ANY PROBLEM
         MVI   FILOPN(AE),WRITEOPN SET FLAGS, BUF PTRS ETC.
         OI    FILEOF(AE),1
         SR    R0,R0                                                 #
         STH   R0,FILPTR(AE)       CLEAR BOTH LINE POSN PTR          #
         ST    R0,FILLIM(AE)       AND LINES LIMIT FOR FILE          #
         ST    R0,FILBUF(AE)       NULLIFY BUFFER POINTER            #
         LH    R1,DCBLRECL         GET LRECL FROM THE DCB            #
         TM    DCBRECFM,X'C0'                                        #
         BNO   *+12                JUMP IF NOT U-FORMAT              #
         LH    R1,DCBBLKSI                                           #
         STH   R1,DCBLRECL                                           #
         STH   R0,FILEND(AE)       NULL BUFFER LENGTH                #
         STH   R0,FILBEG(AE)       RESET CHAR. START POSITION        #
         CLI   DCBRECFM,X'80'                                        #
         BNL   FILPOP1             JUMP IF NOT V-FORMAT              #
         MVI   FILBEG+1(AE),4      ALLOW 4-BYTE RDW/SDW              #
FILPOP1  TM    DCBRECFM,X'06'      TEST IF CONTROL CHARS             #
         BZ    RTN                                                   #
         CLI   CCFLAG,0            RETURN IF CONTROL CHARS ARE NOT   #
         BE    RTN                 TO BE INSERTED                    #
         OI    FILBEG+1(AE),1      ADD 1-BYTE CONTROL CHAR.          #
         B     RTN
*
*
*
         DC    CL4'PUT '
PUT      FILADR ,
         TM    FILEOF(AE),1
         BZ    RTN
         BAL   R5,FILPST
         B     RTN
*
         DC    CL4'WLN '
WLN      FILADR ,
*DJR     LH    R1,FILPTR(AE)                                         #
*DJR     CH    R1,FILEND(AE)       IF BUFFER IS MARKED "OVER-FULL",  #
*DJR     BNH   *+12                   WE WRITE IT OUT                #
         BAL   R5,FILPUT                                             #
*DJR     LH    R1,FILPTR(AE)                                         #
*DJR     BCTR  R1,0                                                  #
*DJR     STH   R1,FILEND(AE)       FLAG BUFFER AS "OVER-FULL"        #
         B     RTN                                                   #
*
*
*        WRB (WRITE BOOLEAN):  ADR(FILE),BOOLEAN,FIELD_WIDTH         #
*
WRB      LTR   R2,R2                                                 #
         BZ    WRB1                JUMP IF "FALSE"                   #
         LA    R2,=C'TRUE'                                           #
         LA    R4,4                                                  #
         B     WRS                                                   #
WRB1     LA    R2,=C'FALSE'                                          #
         LA    R4,5                                                  #
         B     WRS                                                   #
*
*
*        WRC   R1: ADR(FILE),  R3: FIELD_WIDTH,  R2: CHAR
*
         DC    CL4'WRC '
WRC      FILADR ,
         BCTR  R3,0
         LTR   R3,R3
         BZ    WRC3
         BM    RTN
WRC2     MVI   0(AD),FILBLA
         BAL   R5,FILPST
         BCT   R3,WRC2
WRC3     STC   R2,0(AD)
         BAL   R5,FILPST
         B     RTN
*
*     WRS   ADR(FILE): R1, STRLGTH: R4, FIELD_WIDTH:R3 ,R2: ADR(STING)
*
         DC    CL4'WRS '
WRS      FILADR ,
         AIF   (&SYSTEM).SYS6
         LTR   R3,R3
         BNP   RTN                 ZERO FIELD WIDTH, RETURN
.SYS6    ANOP
         LH    R1,FILPTR(AE)
         LA    R0,FILBLA           FILL CHARACTER
WRSB1    CR    R3,R4               COMPARE FLD_LGTH TO STR_LGTH
         BNH   WRSF2               NO NEED FOR FILL CHARS
         CH    R1,FILEND(AE)                                         #
         BL    WRSF1                                                 #
         BAL   R5,FILPUT           EMPTY THE FULL BUFFER             #
         LH    R1,FILPTR(AE)                                         #
         LA    R0,FILBLA                                             #
WRSF1    STC   R0,0(R1,AF)         PLANT NEXT BLANK IN BUFFER        #
         LA    R1,1(R1)            AND ADVANCE TO NEXT POSITION      #
         BCT   R3,WRSB1                                              #
*    NOW WE HAVE R3 <= R4
WRSF2    DS    0H
WRSB2    CH    R1,FILEND(AE)                                         #
         BL    WRSF3                                                 #
         BAL   R5,FILPUT           EMPTY THE FULL BUFFER             #
         LH    R1,FILPTR(AE)                                         #
WRSF3    IC    R0,0(R2)            PICK UP NEXT CHAR IN STRING       #
         STC   R0,0(R1,AF)         AND PLANT IT IN BUFFER            #
         LA    R2,CHR(R2)          ADVANCE IN THE STRING             #
         LA    R1,1(R1)            ADVANCE IN THE BUFFER             #
         BCT   R3,WRSB2                                              #
         STH   R1,FILPTR(AE)
         B     RTN
*
*
*        WRI ADR(FILE),WIDTH,INT
*
         DC    CL4'WRI '
WRI      DS    0H                                                    #
*        AIF   (&SYSTEM).SYS7                                        #
*        LTR   R3,R3                                                 #
*        BNP   RTN                 ZERO FIELD WIDTH - RETURN         #
*.SYS7   ANOP                                                        #
         CVD   R2,PINT                                               #
         MVC   ZINT,=X'402020202020202020202120'
         LA    R1,ZINT+11
         EDMK  ZINT,PINT+2
         LTR   R2,R2
         BNM   *+10
         BCTR  R1,0
         MVI   0(R1),C'-'
         LR    R2,R1                                                 #
         LA    R4,ZINT+L'ZINT                                        #
         SR    R4,R1                                                 #
         CR    R4,R3                                                 #
         BNH   WRS                 PRINT INTEGER AS A STRING         #
         LR    R3,R4               - BUT INCREASE FIELD WIDTH IF     #
         B     WRS                 NECESSARY TO PRINT ENTIRE NUMBER  #
*
*
*        RDR, READ THE NEXT (REAL) NUMBER INTO (GRG2)
*
         DC    CL4'RDR'
RDR      DS    0H
         AIF   (&SYSTEM).SYS9
         FILADR ,
         SDR   0,0
         LA    R3,1
RDR1     CLI   0(AD),FILBLA
         BNE   RDR2
         BAL   R5,FILGFE
         TM    FILEOF(AE),1                                          #
         BO    EOFREAD             ERROR IF END-OF-FILE              #
         B     RDR1
RDR2     CLI   0(AD),FILPLU
         BE    RDR3
         CLI   0(AD),FILMIN
         BNE   RDR4
         LCR   R3,R3
RDR3     BAL   R5,FILGFE
RDR4     LA    R15,BADREAL         SET ERROR EXIT ADDRESS            #
RDR45    SR    R1,R1                                                 #
         IC    R1,0(AD)            GET CHARACTER                     #
         SH    R1,=AL2(FILZER)                                       #
         BMR   R15                 QUIT LOOP IF NON-DIGIT            #
         CH    R1,=AL2(9)                                            #
         BHR   R15                                                   #
         MD    0,=D'10.0'                                            #
         SLA   R1,3
         AD    0,DECTBL(R1)
         BAL   R5,FILGFE
         BAL   R15,RDR45           LOOP BACK & SET EXIT ADDRESS      #
RDR5     SR    R4,R4
         CLI   0(AD),FILDOT
         BNE   RDR7
         BAL   R5,FILGFE
RDR6     CLI   0(AD),FILZER
         BL    RDR7
         CLI   0(AD),FILNIN
         BH    RDR7
         MD    0,=D'10.0'
         SR    R1,R1
         IC    R1,0(AD)
         SH    R1,=AL2(FILZER)                                       #
         SLA   R1,3
         AD    0,DECTBL(R1)
         BAL   R5,FILGFE
         BCTR  R4,0
         B     RDR6
RDR7     LTR   R3,R3
         BNM   *+6
         LCDR  0,0
         CLI   0(AD),FILEXP
         BNE   RDR13
         LA    R3,1
RDR8     BAL   R5,FILGFE
         CLI   0(AD),FILBLA
         BE    RDR8
         ST    R4,EXPONENT
         SR    R4,R4
RDR9     CLI   0(AD),FILPLU
         BE    RDR10
         CLI   0(AD),FILMIN
         BNE   RDR11
         LCR   R3,R3
RDR10    BAL   R5,FILGFE
RDR11    LA    R15,BADREAL         SET ERROR EXIT ADDRESS            #
RDR115   SR    R1,R1                                                 #
         IC    R1,0(AD)            GET CHARACTER                     #
         SH    R1,=AL2(FILZER)                                       #
         BMR   R15                 QUIT LOOP IF NON-DIGIT            #
         CH    R1,=AL2(9)                                            #
         BHR   R15                                                   #
         MH    R4,=H'10'
         AR    R4,R1
         BAL   R5,FILGFE
         BAL   R15,RDR115          LOOP BACK & SET EXIT ADDRESS      #
RDR12    LTR   R3,R3
         BNM   *+6
         LCR   R4,R4
         A     R4,EXPONENT
RDR13    LTR   R4,R4
         BZ    RDR16
         BP    RDR14
         LPR   R4,R4
         B     RDR15
RDR14    MD    0,=D'10.0'
         BCT   R4,RDR14
         B     RDR16
RDR15    DD    0,=D'10.0'
         BCT   R4,RDR15
RDR16    STD   0,0(R2)             PUT THE RESULT IN PASCAL VARIABLE
         B     RTN
.SYS9    ANOP
*
*        WRR, REAL NUMBER IN FPRG2, FIELDWITH IN GRG3
*
         DC    CL4'WRR'
WRR      FILADR ,
         SR    R2,R2         R2 <-- POWER OF 10
         LTDR  FPR2,FPR2
         BNZ   WRR20
*
*        PRINT 'ZERO' IN THE PROPER FORMAT
*
         LTR   R4,R4         'F' FORMAT ?
         BP    WRR14
*        E-FORMAT ZERO
         MVI   0(AD),FILBLA
         BAL   R5,FILPST
         BAL   R5,FILPST
         SH    R3,=H'4'
         LR    R4,R3
         B     WRR16
*        F-FORMAT
WRR14    SR    R3,R4
         SH    R3,=H'2'
         BNP   WRR16
         MVI   0(AD),FILBLA
         BAL   R5,FILPST
         BCT   R3,*-4        PRINT LEADING BLANKS
*
WRR16    MVI   0(AD),FILZER
         BAL   R5,FILPST
         MVI   0(AD),FILDOT
         BAL   R5,FILPST
         MVI   0(AD),FILZER
         BAL   R5,FILPST
*        PRINT TRAILING BLANKS
         SH    R4,=H'1'
         BNP   RTN
         MVI   0(AD),FILBLA
         BAL   R5,FILPST
         BCT   R4,*-4
         B     RTN
*
*        PRINT A NON_ZERO REAL NUMBER
*
WRR20    MVI   SIGN,X'00'
         MVI   EFORM,X'00'
         BP    WRR22
         MVI   SIGN,X'01'    NEGATIVE VALUE, REMEMBER THE SIGN
         BCTR  R3,0          AND ADJUST FIELD WIDTH
         LPDR  FPR2,FPR2
WRR22    LD    FPR0,=D'1.0E-12'
         MDR   FPR0,FPR2
         ADR   FPR2,FPR0
         LDR   FPR0,FPR2     SAVE THE ORIGINAL VALUE
*
WRR24    CD    FPR2,=D'1.0'
         BNL   WRR26
         MD    FPR2,=D'10.0'
         BCT   R2,WRR24
WRR26    CD    FPR2,=D'10.0'
         BL    WRR30
         DD    FPR2,=D'10.0'
         LA    R2,1(R2)
         B     WRR26
*
*        NOW WE HAVE  "1.0 <= FPR2 < 10"
*        AND "FPR0 = FPR2 * (R2 ** 10)" .
*
WRR30    LTR   R4,R4         SEE IF F_FORMAT REQUESTED
         BP    WRR40
*        PRINT THE VALUE IN E_FORM
         MVI   EFORM,X'01'   SET E_FORMAT FLAG
         ST    R2,EXPONENT   SAVE EXPONENT VALUE
         MVI   0(AD),FILBLA
         BAL   R5,FILPST
         LR    R4,R3         R4 <-- FIELD WIDTH (AT LEAST 9)
         SH    R4,=H'7'
         TM    SIGN,X'01'
         BNZ   WRR32
         MVI   0(AD),FILBLA  PRINT UP TO TWO LEADING BLANKS
         BAL   R5,FILPST
         BCTR  R4,0
WRR32    LTR   R4,R4
         BP    *+8
         LA    R4,1
         SR    R2,R2         ONLY ONE DIGIT BEFORE DECIMAL POINT
         B     WRR50
*
*        F_FORMAT OUTPUT
*
WRR40    LTR   R2,R2
         BNM   WRR44         SEE IF NEGATIVE EXPONENT
         LDR   FPR2,FPR0     IF SO, USE THE ORIGINAL VALUE
         SR    R2,R2         ONLY ONE DIGIT BEFORE DECIMAL POINT
*
WRR44    SR    R3,R4         COMPUTE THE # OF LEADING BLANKS
         SR    R3,R2
         SH    R3,=H'2'      R3 IS THE # OF LEADING BLANKS
         BNP   WRR50
WRR46    MVI   0(AD),FILBLA
         BAL   R5,FILPST
         BCT   R3,*-4
*
*        R2 # OF DIGITS BEFORE DECIMAL POINT
*        R4 # OF DIGITS FOLLOWING DECIMAL POINT
*
WRR50    TM    SIGN,X'01'
         BZ    WRR52
         MVI   0(AD),FILMIN
         BAL   R5,FILPST
*
WRR52    LA    R2,1(R2)
         BAL   R3,WRRDGTS
         BCT   R2,*-4
         MVI   0(AD),FILDOT
         BAL   R5,FILPST
         BAL   R3,WRRDGTS
         BCT   R4,*-4
         TM    EFORM,X'01'
         BZ    RTN
*
*        PRINT THE EXPONENT FOR E_FORMAT OUTPUT
*
         L     R4,EXPONENT
         MVI   0(AD),FILEXP
         BAL   R5,FILPST
         MVI   0(AD),FILPLU
         LTR   R4,R4
         BNM   *+8
         MVI   0(AD),FILMIN
         BAL   R5,FILPST
         LPR   R3,R4
         SR    R2,R2
         D     R2,=F'10'
         LA    R3,FILZER(R3)
         STC   R3,0(AD)
         BAL   R5,FILPST
         LA    R2,FILZER(R2)
         STC   R2,0(AD)
         BAL   R5,FILPST
         B     RTN
*
*        THIS ROUTINE PRINTS THE NEXT DIGIT OF THE VALUE
*        IN FPR2, IT USES R3 FOR ITS RETURN ADDRESS
*        IT IS ASSUMED THAT "0 <= FPR2 < 10" AND FPR2
*        IS UPDATED FOR THE NEXT DIGIT
*
WRRDGTS  SR    R1,R1                                                 #
         LA    R1,1(R1)                                              #
         SD    FPR2,=D'1.0'                                          #
         BNM   WRRDGTS+2                                             #
         AD    FPR2,=D'1.0'                                          #
         LA    R1,FILZER-1(R1)                                       #
         STC   R1,0(AD)                                              #
         BAL   R5,FILPST           WRITE NEXT DIGIT                  #
         MD    FPR2,=D'10.0'                                         #
         BR    R3                 RETURN TO CALLER
*
*
*        PAG   SKIP TO NEW PAGE
*
         DC    CL4'PAG'
PAG      SR    R2,R2                                                 #
         BCT   R2,SKP1             SET R2 = -1, THEN USE SKP ROUTINE #
*                                                                    #
*                                                                    #
*        SKP - SKIP R2 INPUT OR OUTPUT LINES                         #
*                                                                    #
         DC    CL4'SKP'                                              #
SKP      LTR   R2,R2                                                 #
         BM    RTN                 FORCE NUMBER OF LINES TO BE       #
SKP1     FILADR ,                                                    #
         CLI   FILOPN(AE),READOPN                                    #
         BE    SKP7                JUMP IF AN INPUT FILE             #
         LA    R0,MAXSKIP                                            #
         CR    R2,R0                                                 #
         BL    *+6                 LIMIT NUMBER OF LINES TO "MAXSKIP"#
         LR    R2,R0                                                 #
         TM    DCBRECFM,X'06'      JUMP IF FILE DOES NOT HAVE        #
         BZ    SKP6                CARRIAGE CONTROL CHARS            #
         LA    R3,3                MAX NO. OF SKIPS PER RECORD       #
         TM    DCBRECFM,X'04'                                        #
         BNZ   SKP2                JUMP IF ANS CONTROL CHARS         #
         LTR   AF,AF               FORCE AN INITIAL PUT OPERATION IF #
         BNZ   SKP3                  NO I/O BUFFER YET ALLOCATED     #
SKP2     BAL   R5,FILPUT           CLEAR LINE BUFFER                 #
SKP3     CR    R2,R3                                                 #
         LR    R4,R2                                                 #
         BNH   *+6                                                   #
         LR    R4,R3               NOW, R4 = MIN( R2, 3 )            #
         LH    R1,FILBEG(AE)                                         #
         CLI   CCFLAG,0            DONT BACK UP POINTER              #
         BE    *+6                 UNLESS NOCC IN EFFECT             #
         BCTR  R1,0                                                  #
         TM    DCBRECFM,X'04'                                        #
         BZ    SKP5                JUMP IF MACHINE CHARS             #
         IC    R0,SKPASCII(R4)                                       #
         STC   R0,0(R1,AF)         SET ASCII CONTROL CHAR            #
         SR    R2,R4                                                 #
         BP    SKP2                REPEAT IF MORE LINES TO SKIP      #
         LA    R1,1(R1)                                              #
         STH   R1,FILPTR(AE)       POINT AT FIRST DATA BYTE          #
         B     RTN                                                   #
SKP5     IC    R0,SKPMACH(R4)                                        #
         STC   R0,0(R1,AF)         SET MACHINE CONTROL CHAR          #
         BAL   R5,FILPUT           AND SEND TO OUTPUT DEVICE         #
         SR    R2,R4                                                 #
         BP    SKP3                REPEAT IF MORE LINES TO SKIP      #
         B     RTN                                                   #
SKP6     BAL   R5,FILPUT           NO CONTROL CHARS                  #
         BCTR  R2,0                BUT GIVE AN APPROPRIATE NUMBER    #
         LTR   R2,R2               OF EMPTY OUTPUT RECORDS           #
         BP    SKP6                                                  #
         B     RTN                                                   #
SKP7     LTR   R2,R2               REJECT PAGE() ON AN INPUT FILE    #
         BM    BADWRITE                                              #
         BNZ   SKP8                JUMP IF > 0 SKIPS                 #
         LH    R1,FILBEG(AE)                                         #
         STH   R1,FILPTR(AE)       RESET CHAR PTR. TO REREAD LINE    #
         IC    R0,0(R1,AF)                                           #
         STC   R0,0(AD)            RESET CURRENT FILE ELEMENT        #
         B     RTN                                                   #
SKP8     BAL   R5,FILGET                                             #
         BCT   R2,SKP8             STEP THROUGH THE LINES            #
         B     RTN                                                   #
*
*
*        CLOCK FUNCTION
*
         DC    CL4'CLK'
CLK      TTIMER ,
         S     R0,CLOCK            SUBTRACT START-UP TIME
         LCR   R1,R0
         M     R0,=FS32'0.02604166'
         B     RTN                RETURNS THE RESULT IN R0
*
*        OBSOLETE MATH RT. HANDLING CODE.  ALL CALLS TO FORTRAN      #
*        ARE NOW DIRECT.  AN OLD PASCAL PROGRAM THAT ATTEMPTS TO     #
*        CALL THEM VIA THIS PROGRAM CAUSES AN ERROR MESSAGE.         #
*
         DC    CL4'MATH'
SIN      DS    0H                                                    #
COS      DS    0H                                                    #
EXP      DS    0H                                                    #
LOG      DS    0H                                                    #
SQT      DS    0H                                                    #
ATN      DS    0H                                                    #
         B     MATHERR             GO AND PRINT AN ERROR MESSAGE     #
*
*
*        MESSAGE PROCEDURE   R2=STRING ADDR,  R3=LENGTH              #
*                                                                    #
         DC    CL4'MSG'                                              #
MSG      LTR   R3,R3                                                 #
         BNP   RTN                                                   #
         LA    R0,MAXMSGL          SET MAXIMUM MESSAGE LENGTH        #
         CR    R3,R0                                                 #
         BNH   *+6                                                   #
         LR    R3,R0                                                 #
         EX    R3,MSGMVC                                             #
         LA    R3,4(R3)            CONSTRUCT VARIABLE-LENGTH RECORD  #
         STH   R3,SYNADMSG                                           #
         LA    R3,SYNADMSG(R3)                                       #
         MVC   0(4,R3),=X'00000020' SET THE ROUTING CODE             #
         MVC   SYNADMSG+2(2),=X'8000'                                #
         LA    R1,SYNADMSG                                           #
         SVC   35                  ISSUE WTO REQUEST                 #
         B     RTN                                                   #
MSGMVC   MVC   SYNADMSG+4(*-*),0(R2)                                 #
*                                                                    #
*        LINELIMIT PROCEDURE   AD=FILE,  R2=LIMIT                    #
*                                                                    #
         DC    CL4'LIM'                                              #
LIM      FILADR ,                                                    #
         ST    R2,FILLIM(AE)       SET THE NEW LIMIT                 #
         B     RTN                                                   #
*
*
*        DEFINE THE FILE NAME
*
         DC    CL4'FDF'
FDF      DS    0H
         LR    AE,AD
         SR    AE,GBR              CONVERT FILE ADR TO FILE ID
         C     AE,=A(INPUT+FILCOUNT-STACK)
         BNL   BADFDF
         SLA   AE,2
         L     AD,FILBLK-PASBUFAD*4(AE)
         LTR   AD,AD
         BNZ   RTN                 FILE BLOCK ALREADY ALLOCATED
*
         LA    R3,FILBLK-PASBUFAD*4(AE)                              #
         GETMAIN EC,LV=L'#FILREC,A=(R3)                              #
         LTR   R15,R15             TEST IF STORAGE AVAILABLE         #
         BNZ   BADFDF                                                #
         L     AE,0(,R3)                                             #
*        MOVE FILE RECORD TEMPLATE TO THE GETMAINED AREA
         L     R3,=A(#FILREC)
         MVC   0(L'#FILREC,AE),0(R3)                                 #
         MVC   DCBDDNAM,0(R2)      MOVE THE FILE NAME TO ITS DCB FIELD
         B     RTN
*                                                                    #
*        GENERAL ROUTINE TO CLOSE A FILE                             #
*                                                                    #
FILCLOS  TM    FILOPN(AE),1                                          #
         BNOR  R5                  RETURN IF FILE NOT OPEN           #
         CLI   FILOPN(AE),READOPN                                    #
         BE    FILCLOS1            JUMP IF AN INPUT FILE             #
         ST    R5,FILCLSSV                                           #
         BAL   R5,FILEOLN          COMPLETE THE OUTPUT BUFFER        #
         L     R5,FILCLSSV                                           #
FILCLOS1 LA    AG,FILDCB(AE)                                         #
         CLOSE ((AG))                                                #
         TM    DCBBUFCB+3,1        TEST IF BUFFER POOL THERE         #
         BOR   R5                  RETURN IF NOT                     #
         FREEPOOL (AG)             RELEASE THE POOL                  #
         BR    R5                                                    #
*
*
*        EXIT : TO EXIT USER PROGRAM WITH A RETURN CODE
*
         DC    CL4'XIT'
XIT      C     R2,=A(1000)         IF ERROR GO TO CLOSE/EXIT ROUTINE
         BNL   CLS
         L     R4,HEAPLIM
         USING DYN2STOR,R4
         L     R5,DYNRUNC
         LTR   R5,R5               SEE IF RUN TIME COUNTERS ARE PRESENT
         BNP   CLS                 IF NOT, QUIT.
         LR    R6,R2               SAVE RETURN CODE
         LA    AD,QRR              PICK THE COUNTER FILE NAME
         LA    R1,PREW
         LA    R15,$PASCSP
         BALR  R14,R15             CALL THE $PASCSP ROUTINES
*
*        THIS CAN BE DONE ONLY IF WE KNOW THAT WE DO NOT NEED
*        TO GO BACK TO THE PROGRAM WHICH CALLED THE EXIT
*        ROUTINE.
*
         LA    R1,PWRI             SET THE FUNCTION CODE
         LA    R3,10               SET THE FIELD_WIDTH
NXTCNT   L     R2,DYNCOUNT         PICK THE NEXT COUNT VALUE
         BALR  R14,R15             OUTPUT IT
         LA    R4,4(R4)
         BCT   R5,NXTCNT           REPEAT UNTIL DONE
         DROP  R4
*
         LA    R1,PWLN
         BALR  R14,R15             OUTPUT THE LAST LINE
         LR    R2,R6               RESTORE RETURN CODE
*
         B     CLS                 GO TO COMPLETE EXIT EPILOGUE.
*
*       CLOSE ALL THE FILES
*
         DC    CL4'CLS '
CLS      L     AD,=A(FILBLK)                                         #
         LA    R3,FILCOUNT         INPUT,OUTPUT,PRD,...........
CLSB1    L     AE,0(AD)
         LTR   AE,AE                IS THIS FILE DEFINED ?
         BZ    CLSF1                IF NOT, SKIP.
         L     AF,FILBUF(AE)                                         #
         BAL   R5,FILCLOS          GO AND DO A FILE CLOSE            #
         C     AD,=A(FILBLK+6*4)   TEST IF BUILT-IN FILE             #
         BL    CLSF1               IF SO, JUMP                       #
         FREEMAIN R,LV=L'#FILREC,A=(AE)  RELEASE FILE BLOCK STORAGE  #
CLSF1    LA    AD,4(AD)
         BCT   R3,CLSB1
*
*        TIME TO EXIT
*
         L     R1,=A(OLDPICA)
         TM    3(R1),1             TEST IF SPIE WAS ISSUED           #
         BO    SKIPSPIE            JUMP IF NOT                       #
         L     1,0(R1)             RESET OLD PICA ADDRESS
         SPIE  MF=(E,(1))
SKIPSPIE EQU   *                                                     #
*
*        CHECK FOR ABEND
*
         C         R2,=A(1000)     IF RETURN CODE < 1000
         BL        XIT2              THEN DON'T ABEND
         L         R1,HEAPLIM
         USING     DYN2STOR,R1
         CLI       DYNABEND,X'FF'
         DROP      R1
         BNE       XIT2
         LR        R1,R2
         N         R1,=A(X'00000FFF')
         A         R1,=A(X'80000000')
         SVC       13
XIT2     DS        0H
         C     R2,=A(TIMERR)       SEE IF THIS IS A TIME OUT EXIT
         BE    XIT3
         C     R2,=A(TIMERR+SNPERR)
         BNE   XIT4
*
*        THIS ABEND IS BECAUSE THERE IS NO CLEAN AND EASY WAY
*        TO TERMINATE THE PROGRAM IN CASE OF A TIMER INTERRUPT !
*
XIT3     ABEND (R2)
*
XIT4     LR    R13,R12             POINT TO STACK BASE               #
         S     R13,=A(STACK-DYNSTORE)                                #
         L     R13,4(R13)          POINT TO THE SYSTEM SAVE AREA     #
         FREEMAIN V,A=ALOSTORE     RELEASE STACK STORAGE             #
         LR    R15,R2              SET THE RETURN CODE               #
         L     R14,12(R13)         PICK THE RETURN ADDRESS
         LM    R0,R12,20(R13)      RESTORE OTHER REGS
         BR    14
*
*
*        UNDEFINED CSP ENTRIES
*
TRP      DS    0H
SIO      DS    0H
EIO      DS    0H
*
*
*
*         RETURN TO PASCAL PROGRAM
*
RTN      LM    R1,R15,SPUSERSA      'RSLT' REG SHOULD NOT BE RESTORED !
         AIF   (&SYSTEM).SYS92
         DROP
         USING $PASCSP,R15
         MVI   SPUSERSA,X'FF'      CLEAR 'SP' FLAG
.SYS92   ANOP
         BR    14
*
*        I/O ERROR CONDITIONS
*
         DROP
         USING $PASCSP,R10,R11                                       #
BADFDF   LA    R0,FDFMSG                                             #
         B     ERRMSGRT                                              #
MATHERR  LA    R0,MATHMSG                                            #
         B     ERRMSGRT                                              #
LIMITERR LA    R0,LIMMSG                                             #
         B     ERRMSGRT                                              #
BADREAD  LA    R0,READMSG                                            #
         B     ERRMSGRT                                              #
EOFREAD  LA    R0,EOFMSG                                             #
         B     ERRMSGRT                                              #
BADBOOL  LA    R0,BOOLMSG                                            #
         B     ERRMSGRT                                              #
BADINT   LA    R0,INTMSG                                             #
         B     ERRMSGRT                                              #
BADREAL  LA    R0,REALMSG                                            #
         B     ERRMSGRT                                              #
*
         USING STACK,GBR
BADWRITE LA    R3,OUTPUT           IF BAD FILE IS "OUTPUT" WE HAVE   #
         CR    AD,R3          TO BY-PASS GENERATION OF ERROR         #
         BNE   BADWRIT1          MESSAGES  (OTHERWISE INFINITE LOOP) #
         WTO   'UNABLE TO USE "OUTPUT" FILE',ROUTCDE=11              #
         LA    R2,OUTERR                                             #
         B     XIT                                                   #
BADWRIT1 LA    R0,WRITEMSG                                           #
         B     ERRMSGRT                                              #
*                                                                    #
SYNADRT  EQU   *              GENERATES MESSAGE FOR FILE ERRORS      #
         LA    R3,OUTPUT                                             #
         CR    AD,R3          OBVIOUSLY, AN ERROR WITH "OUTPUT" FILE #
         BER   R14            CANT BE PRINTED, SO CONTINUE ABENDING  #
         SYNADAF ACSMETH=QSAM GENERATE THE ERROR DESCRIPTION         #
         MVC   SYNADMSG+1(78),50(R1) AND MOVE IT INTO LOCAL BUFFER   #
         SYNADRLS ,           NOW RELEASE THE SYSTEM'S BUFFER        #
         LA    R0,SYNMSG                                             #
*        B     ERRMSGRT                                              #
*
ERRMSGRT L     R15,=A($CHKMSG0)    RESTORE USER'S REGISTERS          #
         LM    R1,R14,SPUSERSA                                       #
         LR    R3,R0                                                 #
         LH    R8,0(R3)            SET ERROR CODE                    #
         LH    R4,2(R3)            SET MESSAGE LENGTH                #
         LA    R3,4(R3)            SET MESSAGE POINTER               #
         BR    R15                 AND EXIT WITH THE MESSAGE         #
         DROP  ,
*
*          VARIOUS TABLE AND DCB DEFINITIONS
*
         DS    0D
SPSYSTSA DS    18F
DECTBL   DC    D'0,1,2,3,4,5,6,7,8,9'
PINT     DS    D                   PACKED INTEGER BUFFER
         DC    20AL1(FILBLA)
ZINT     DS    CL12                ZONED INTEGER BUFFER
         DS    0F
*                                                                    #
*              DCB EXIT LIST PARAMETERS                              #
*                                                                    #
XLINPUT  DC    X'85',AL3(XLSTRTIN)                                   #
XLINOUT  EQU   XLINPUT                                               #
XLOUTPUT DC    X'85',AL3(XLSTRTOT)                                   #
*                                                                    #
*        DEFAULT AND TARGET VALUES FOR FILES OTHER THAN "OUTPUT"     #
*                                                                    #
DEFAULTS DC    H'80'               TARGET DATA BYTES PER RECORD      #
         DC    H'1600'             TARGET BYTES PER BLOCK            #
         DC    AL1(3)              DEFAULT BUFNO VALUE               #
         DC    X'50'               DEFAULT RECFM = VB                #
*                                                                    #
*        DEFAULT AND TARGET VALUES FOR "OUTPUT" FILE                 #
*                                                                    #
OUTDFLTS DC    H'132'              TARGET DATA BYTES PER RECORD      #
         DC    H'1600'             TARGET BYTES PER RECORD           #
         DC    AL1(5)              DEFAULT BUFNO VALUE               #
         DC    X'54'               DEFAULT RECFM = VBA               #
*                                                                    #
MAXSKIP  DC    F'60'               MAXIMUM NUMBER OF LINES TO SKIP   #
SKPASCII EQU   *+1                 TABLE OF ASCII CONTROL CHARS      #
         DC    C'1+ 0-'                                              #
SKPMACH  EQU   *+1                 TABLE OF MACHINE CONTROL CHARS    #
         DC    X'8901091119'                                         #
RRFLAG   DC    X'0'                RE-READ FLAG                      #
FILPSTSV DS    A                                                     #
FILPUTSV DS    A                                                     #
FILCLSSV DS    A                                                     #
EXPONENT DS    F                                                     #
SIGN     DS    CL1
EFORM    DS    CL1
CCFLAG   DC    X'00'               SET BY NOCC O.S. PARM STRING      #
*
READMSG  DC    AL2(INPERR,25),C' INVALID INPUT OPERATION '
WRITEMSG DC    AL2(OUTERR,26),C' INVALID OUTPUT OPERATION '
FDFMSG   DC    AL2(FDFERR,25),C' INVALID FILE DEFINITION '
MATHMSG  DC    AL2(MTHERR,32),C' OBSOLETE MATH. ROUTINE LINKAGE '    #
LIMMSG   DC    AL2(LIMERR,26),C' LINELIMIT VALUE EXCEEDED '          #
EOFMSG   DC    AL2(EOFERR,24),C' ILLEGAL READ AFTER EOF '            #
BOOLMSG  DC    AL2(BOLERR,21),C' BAD BOOLEAN ON INPUT '              #
INTMSG   DC    AL2(INTERR,21),C' BAD INTEGER ON INPUT '              #
REALMSG  DC    AL2(RELERR,18),C' BAD REAL ON INPUT '                 #
SYNMSG   DC    AL2(SYNERR,79)                                        #
SYNADMSG DC    CL128' '             BUFFER FOR I/O ERROR MESSAGE     #
*        NOTE: THIS BUFFER IS ALSO USED BY "MESSAGE". ITS LENGTH MUST#
*        NOT BE LESS THAN MAXMSGL+8.                                 #
         LTORG ,
         DS    0D
*
*        FILE  NAME TABLE
*
FILBLK   DC    A(FILINP,FILOUT,FILPRD,FILPRR,FILQRD,FILQRR)
         DC    20F'0'              USER DEFINED FILES !
         PRINT NOGEN               TURN OFF DCB EXPANSIONS           #
*
*        FILE CONTROL BLOC AND DCB FOR THE ABOVE FILES
*
         FILDEF INPUT,INPUT,LINELGTH
         FILDEF OUTPUT,OUTPUT,LINELGTH
         FILDEF PRD,INOUT,LINELGTH
*
#FILREC  EQU   FILPRD,*-FILPRD     FILE RECORD TEMPLATE
*
         FILDEF PRR,INOUT,LINELGTH
         FILDEF QRD,INOUT,LINELGTH
         FILDEF QRR,INOUT,LINELGTH
**************************************************************
*
*        END OF $PASCSP MODULE
*
**************************************************************
         SPACE 3
*        GLOBAL DEFINITIONS
*
*
*
*
*        REGISTER ASSIGNMENTS
*
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
GBR      EQU   12
FPR0     EQU   0                   FLOATING REG 0
FPR2     EQU   2
FPR4     EQU   4
FPR6     EQU   6
K        EQU   1024
IOBUFSZE EQU   32*K                SIZE OF AREA RETURNED TO OS FOR I/O
MINSTORE EQU   IOBUFSZE+6*K        MIN ACCEPTABLE DYNAMIC STORAGE SIZE
MAXSTORE EQU   4000*K              MAX REQUESTABLE DYNAMIC STORAGE
PASBUFAD EQU   INPUT-STACK         ADR OF THE FIRST FILE CHAR BUFFER
LCAFTMST EQU   80                  LOCAL VARIABLE AREA (PASCAL PROCS)
MAXMSGL  EQU   120                 MAX LENGTH MESSAGE                #
RET      EQU   14                  RETURN ADDRESS/LOCATION COUNTER
LINK     EQU   15                  BRANCH REGISTER
PBASE2   EQU   11                  PROGRAM BASE REGISTER #2
PBASE1   EQU   10                  "     "      #1
*
INXERR   EQU   1001                INDEX ERROR RETURN CODE
SUBERR   EQU   1002                SUBRANGE ERROR RETURN CODE
PARERR   EQU   1003                PARAMETER ERROR RETURN CODE
SETERR   EQU   1004                SET ELEMENT ERROR RETURN CODE
PTRERR   EQU   1005                POINTER ERROR RETURN CODE
STKERR   EQU   1006                STACK/HEAP ERROR RETURN CODE
INPERR   EQU   1007                INPUT OPERATION ERROR RETURN CODE
OUTERR   EQU   1008                OUTPUT OPERATION ERROR RETURN CODE
SYNERR   EQU   1009                SYNCHRONOUS I/O ERROR RETURN CODE #
TIMERR   EQU   1010                TIME OUT ERROR RETURN CODE
FDFERR   EQU   1011                FILE DEFINITION ERROR RETURN CODE
SPCERR   EQU   1012                'NO SPACE' ERROR RETURN CODE
MTHERR   EQU   1013                'MATH ROUTINES NOT LOADED' ERROR  #
LIMERR   EQU   1014                'LINES LIMIT EXCEEDED' ERROR      #
EOFERR   EQU   1020                ILLEGAL READ PAST EOF             #
BOLERR   EQU   1021                BAD BOOLEAN ON INPUT              #
INTERR   EQU   1022                BAD INTEGER ON INPUT              #
RELERR   EQU   1023                BAD REAL ON INPUT                 #
SNPERR   EQU   100                 SNAPSHOT ERROR RETURN CODE
FILCOUNT EQU   F18PAS-INPUT+1      # OF FILES (AND FILE DCB'S)
*
*
*        MISCELANEOUS CONSTANTS
*
*
*        FILE RELATED SYMBOL DEFINITIONS
*
         EXTRN $MAINBLK
         WXTRN SNAPSHOT,IBCOM#                                       #
*
*
*        CSP ROUTINE NUMBERS
*
PGET     EQU   0*4
PPUT     EQU   1*4
PRES     EQU   2*4
PRLN     EQU   3*4
PREW     EQU   4*4
PWLN     EQU   5*4
PWRS     EQU   6*4
PWRI     EQU   8*4
PXIT     EQU   21*4
PCLS     EQU   29*4
PSKP     EQU   32*4                                                  #
*
*        FILE BLOCK FIELDS
*
FILBUF   EQU   0                                                     #
FILEND   EQU   4                                                     #
FILPTR   EQU   6                                                     #
FILBEG   EQU   8                                                     #
FILEOF   EQU   10                                                    #
FILOPN   EQU   11                                                    #
FILLIM   EQU   12                                                    #
FILDCB   EQU   16                                                    #
*
*        INTERNAL CHARACTER CODE FOR USEFUL CHARACTERS
*
FILEOL   EQU   0  ?
FILEXP   EQU   C'E' 5
FILZER   EQU   C'0' 27
FILNIN   EQU   C'9' 36
FILPLU   EQU   C'+' 37
FILMIN   EQU   C'-' 38
FILTIM   EQU   C'*' 39
FILBLA   EQU   C' ' 45
FILDOT   EQU   C'.' 47
*
*        READ/WRITE FLAG
*
READOPN  EQU   1
WRITEOPN EQU   3
*
*        AD :  @ PASCAL_FILE_BUFFER    (WITHIN GLOBAL DATA AREA)
*        AE :  @ CSP_FILE_CTL.BLK      (INDICATING WHICH FILE )
*        AF :  @ CSP_RECORD_BUFFER     (POINTING TO THE LINE BUF)
*        AG :  @ CSP_DCB               (POINTER TO FILE DCB)
*
FALSE    EQU   0
TRUE     EQU   1
RSLT     EQU   0
AD       EQU   9
AE       EQU   8
AF       EQU   7
AG       EQU   6
*
*        MISCELLANEOUS CONSTANTS
*
CHR      EQU   1                   LENGTH (IN BYTES) OF A CHAR. VALUE
BOL      EQU   1                   "     "   "     OF A LOGICAL VALUE
ADR      EQU   4                   "     "   "     OF AN ADDRESS VALUE
INT      EQU   4                   "     "   "     OF AN INTEGER VALUE
REL      EQU   8                   "     "   "     OF A REAL VALUE
SET      EQU   8                   "     "   "     OF A SET VALUE
CDS      EQU   8                   COMMON DATUM SIZE (LARGEST OF ABOVE)
*
         END   $PASENT
