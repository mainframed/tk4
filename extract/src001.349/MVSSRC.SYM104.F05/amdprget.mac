         TITLE 'AMDPRGET -TRACE RECORD GET ROUTINE                     *
                        '
AMDPRGET CSECT ,                                                   0001
@MAINENT DS    0H                                                  0001
         USING *,@15                                               0001
         B     @PROLOG                                             0001
         DC    AL1(16)                                             0001
         DC    C'AMDPRGET  78.074'                                 0001
         DROP  @15
@PROLOG  STM   @14,@12,12(@13)                                     0001
         BALR  @11,0                                               0001
@PSTART  LA    @05,4095(,@11)                                      0001
         USING @PSTART,@11                                         0001
         USING @PSTART+4095,@05                                    0001
         ST    @13,@SA00001+4                                      0001
         LA    @14,@SA00001                                        0001
         ST    @14,8(,@13)                                         0001
         LR    @13,@14                                             0001
         EQUATES
         COMMON
         USING COMMON,COMBASE      BASE AMDPRCOM
         SYNEPS
         USING SYNTAX,R15          BASE AMDPRSYN EP-S
         DCBD  DSORG=PS,DEVD=(DA,TA)
         USING IHADCB,R8           BASE DCB MAPPING MACRO
AMDPRGET  CSECT
*                                      ADDRESS OF AMDPRTAB REG 12  0147
*                                      (COMBASE) IS POINTER TO     0147
*                                      AMDPRDMP COMMON CSECT       0147
*                                      (AMDPRCOM)              Y02014*/
*   AEDITCBR=AEDITCB;               /* SET UP AMDPRTAB REG           */
         L     AEDITCBR,AEDITCB                                    0148
*   GET='1'B;                       /* INDICATE AMDRPGET IN CONTROL  */
         OI    GET(AEDITCBR),B'00100000'                           0149
*   IF TERM='1'B THEN               /* TEST TERM. REQUEST BIT        */
*                                                                  0150
         TM    TERM(AEDITCBR),B'01000000'                          0150
         BNO   @RF00150                                            0150
*     /***************************************************************/
*     /*                                                             */
*     /* IF ON, CLOSED DOWN GET OPERATIONS                           */
*     /*                                                             */
*     /***************************************************************/
*                                                                  0151
*CLOSDOWN:                                                         0151
*     DO;                                                          0151
CLOSDOWN DS    0H                                                  0152
*       IF FIRSTGET='0'B THEN       /* TEST IF GET WAS SET UP AT ALL */
         TM    FIRSTGET,B'10000000'                                0152
         BZ    @RT00152                                            0152
*         GO TO GETDONE;            /* IF NOT, NO CLOSE DOWN       0153
*                                      REQUIRED, SO BRANCH TO EXIT   */
*                                                                  0153
*       /*************************************************************/
*       /*                                                           */
*       /* IF GET WAS SET UP, TEST WHETHER DATA WAS EXTERNAL OR DUMP */
*       /* TO DETERMINE HOW MUCH SHUT DOWN IS REQUIRED               */
*       /*                                                           */
*       /*************************************************************/
*                                                                  0154
*       IF EXTTRC='0'B THEN         /* IF DUMP DATA SET BEING      0154
*                                      PROCESSED,                    */
         TM    EXTTRC(AEDITCBR),B'00000100'                        0154
         BZ    @RT00154                                            0154
*         GO TO GETFREE;            /* BRANCH TO FREE TRACE BUILD  0155
*                                      AREA                          */
*                                                                  0155
*       /*************************************************************/
*       /*                                                           */
*       /* IF PROCESSING EXTERNAL TRACE DATA SET IN PROCESS,         */
*       /*                                                           */
*       /*************************************************************/
*                                                                  0156
*       RFY                                                        0156
*        (REG8) RSTD;               /* REG 8 FOR BASE OF DCB MAPPING
*                                      MACRO                   Y02014*/
*       REG8=ADDR(GTFDCB);          /* LOAD REG 8 FOR EOF HANDLER,   */
         LA    REG8,GTFDCB                                         0157
*       CLOSE='1'B;                 /* INDICATE CLOSE DOWN REQUIRED, */
         OI    CLOSE,B'00000100'                                   0158
*       GO TO EOFHANDL;             /* BRANCH TO PROCESS EOF         */
         B     EOFHANDL                                            0159
*     END CLOSDOWN;                                                0160
*   IF DDNAME=BLANKS THEN           /* DETERMINE TYPE OF DATA SET  0161
*                                      BEING PROCESSED               */
@RF00150 CLC   DDNAME(8,AEDITCBR),BLANKS                           0161
         BE    @RT00161                                            0161
*     GO TO DUMPTRC;                /* IF DDNAME SLOT IN AMDPRTAB IS
*                                      BLANK, GO PROCESS DUMP DATA IF
*                                      DDNAME HAS BEEN SPECIFIED,  0162
*                                      FALL THROUGH TO PROCESS     0162
*                                      EXTERNAL TRACE DATA SET       */
*   REG8=ADDR(GTFDCB);              /* POINT TO INPUT DCB            */
         LA    REG8,GTFDCB                                         0163
*   IF FIRSTGET='1'B THEN           /* IF NOT FIRST TIME INTO      0164
*                                      AMDRGET,                      */
         TM    FIRSTGET,B'10000000'                                0164
         BO    @RT00164                                            0164
*     GO TO GETREC;                 /* GO GET NEXT RECORD            */
*                                                                  0166
*/********************************************************************
*                                                                    */
*/*                                                                  */
*/*  THE FOLLOWING CODE SETS UP TO PROCESS AN EXTERNAL GTF DATA SET. */
*/*  THIS CODE IS EXECUTED ONCE PER EDIT CONTROL STATEMENT.          */
*/*                                                                  */
*/********************************************************************
*                                                                    */
*                                                                  0166
*   EXTTRC='1'B;                    /* INDICATE EXTERNAL DATA SET IN
*                                      PROCESS                       */
         OI    EXTTRC(AEDITCBR),B'00000100'                        0166
*   AEIOCT=ADDR(EIOCTL);            /* POINT TAB TO I/O CONTROL TABLE*/
         LA    @10,EIOCTL                                          0167
         ST    @10,AEIOCT(,AEDITCBR)                               0167
*   SYNMSGA=ADDR(AMDPRE01);         /* POINT TO GET ERROR MESSAGE  0168
*                                      ARRAY IN MESSAGE CSECT -    0168
*                                      AMDPRFMG                      */
         L     @10,AFMG(,AEDITCBR)                                 0168
         ST    @10,SYNMSGA                                         0168
*   REG2=ADDR(DDNAME);              /* POINT TO DDNAME FIELD IN    0169
*                                      AMDPRTAB                      */
*                                                                  0169
         LA    REG2,DDNAME(,AEDITCBR)                              0169
*   /*****************************************************************/
*   /*                                                               */
*   /* ISSUE DEVTYPE TO VERIFY THAT DD CARD HAS BEEN GIVEN AND TO    */
*   /* DETERMINE DEVICE TYPE OF ALLOCATED DEVICE                     */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0170
*   GEN(DEVTYPE  (REG2),EIODEV);                                   0170
         DEVTYPE  (REG2),EIODEV
*   IF REG15^=0 THEN                                               0171
         LTR   REG15,REG15                                         0171
         BZ    @RF00171                                            0171
*     DO;                           /* IF RETURN CODE FROM DEVTYPE 0172
*                                      INDICATES NO DD CARD, EXIT  0172
*                                      WITH MESSAGE AMD220I          */
*       REG2=SYNMSGA;               /* POINT TO AMD22OI ENTRY IN MSG
*                                      ARRAY - 1-ST MESSAGE          */
         L     REG2,SYNMSGA                                        0173
*       MSGTEXT(27:34)=DDNAME;      /* MOVE SPECIFIED DD NAME TO MSG */
         L     @10,MSGAD(,REG2)                                    0174
         MVC   MSGTEXT+26(8,@10),DDNAME(AEDITCBR)                  0174
*       GEN(OI  SWD,NOSTDMG);       /* REQUEST THAT MEESAGE AMD165I
*                                      NOT BE ISSUED                 */
         OI  SWD,NOSTDMG
*       REG15=ASYNTAX;              /* POINT TO MESSAGE WRITER       */
         L     REG15,ASYNTAX                                       0176
*       CALL SYNTAXA;               /* LINK TO MESSAGE WRITING     0177
*                                      ROUTINE REQUESTING 1-ST MSG.
*                                      IN LIST                       */
         BAL   @14,SYNTAXA                                         0177
*/* BRANCH HERE TO REQUEST TERMINATION OF EDIT PROCESSING            */
*                                                                  0178
*GETTERM:                                                          0178
*       TERM='1'B;                  /* SET TERM BIT IN AMDPRTAB      */
GETTERM  OI    TERM(AEDITCBR),B'01000000'                          0178
*/* BRANCH HERE TO EXIT FROM AMDPRGET                                */
*                                                                  0179
*GETDONE:                                                          0179
*       GET='0'B;                   /* RESET AMDPRGET PATH FLAG      */
GETDONE  NI    GET(AEDITCBR),B'11011111'                           0179
*       RETURN;                     /* RETURN TO AMDPRFRM - THIS IS
*                                      THE ONLY EXIT FROM AMDPRGET   */
@EL00001 L     @13,4(,@13)                                         0180
@EF00001 DS    0H                                                  0180
@ER00001 LM    @14,@12,12(@13)                                     0180
         BR    @14                                                 0180
*     END;                                                         0181
*   IF EIODEV(3)='20'X THEN         /* TEST FOR D/A DATA SET         */
@RF00171 CLI   EIODEV+2,X'20'                                      0182
         BNE   @RF00182                                            0182
*     DAWRAP='1'B;                  /* IF SO, SET WRAP INDICATOR IN
*                                      EIOCT. WRAP POSITIONING IN  0183
*                                      PROCESS INDICATED BY PSITWRAP
*                                      BIT OFF                       */
         OI    DAWRAP,B'00100000'                                  0183
*   EIOERCT=3;                      /* INITIALIZE ERROR COUNTER      */
@RF00182 MVC   EIOERCT(2),@CH00198                                 0184
*   EIODCB=REG8;                    /* STORE DCB ADDRESS IN EIOCT    */
         ST    REG8,EIODCB                                         0185
*   DCBDDNAM=DDNAME;                /* MOVE GIVEN DDNAME TO DCB      */
         MVC   DCBDDNAM(8),DDNAME(AEDITCBR)                        0186
*   EIOX1=DCBRECFM;                 /* SAVE HIGH ORDER BYTE IN     0187
*                                      DCBEXLST FIELD                */
         MVC   EIOX1(1),DCBRECFM                                   0187
*   DCBEXLST=ADDR(EIODCBEX);        /* STORE LIST ADDRESS IN DCB     */
         LA    @10,EIODCBEX                                        0188
         ST    @10,DCBEXLST                                        0188
*   DCBRECFM=EIOX1;                 /* RESTORE HIGH BYTE             */
         MVC   DCBRECFM(1),EIOX1                                   0189
*   EIODCBEX=ADDR(DCBEXIT);         /* SET EXIT ADDRESS IN EXIT LIST */
         LA    @10,DCBEXIT                                         0190
         ST    @10,EIODCBEX                                        0190
*   EIOX1='85'X;                    /* SET EXIT LIST FLAGS           */
         MVI   EIOX1,X'85'                                         0191
*   GEN(OPEN  ((R8),INPUT));        /* OPEN INPUT DCB - EXIT ROUTINE
*                                      TO PROCESS DURING OPEN        */
         OPEN  ((R8),INPUT)
*   IF OPENFAIL='1'B THEN           /* TEST IF EXIT ROUTINE WAS      */
         TM    OPENFAIL,B'01000000'                                0193
         BNO   @RF00193                                            0193
*     DO;                           /* SUCCESSFUL - IF NOT,          */
*       GEN(CLOSE ((R8)));          /* ISSUE CLOSE                   */
         CLOSE ((R8))
*       GO TO UNSPIE;               /* IF NOT, GO TERMINATE EDIT     */
         B     UNSPIE                                              0196
*     END;                                                         0197
*   FIRSTGET='1'B;                  /* INDICATE SET UP COMPLETE      */
@RF00193 OI    FIRSTGET,B'10000000'                                0198
*                                                                  0199
*/********************************************************************
*                                                                    */
*/*                                                                  */
*/*  GET MAINLINE IF EXTERNAL TRACE DATA SET IS BEING PROCESSED      */
*/*                                                                  */
*/********************************************************************
*                                                                    */
*/* BRANCH HERE TO GET LOGICAL TRACE RECORD                          */
*                                                                  0199
*GETREC:                                                           0199
*   SYNADSW='0'B;                   /* RESET SYNAD ENTERED INDICATOR */
GETREC   NI    SYNADSW,B'11111101'                                 0199
*   TRCCOUNT=TRCCOUNT+1;            /* UPDATE READ COUNT IN AMDPRCOM */
         LA    @10,1                                               0200
         AL    @10,TRCCOUNT                                        0200
         ST    @10,TRCCOUNT                                        0200
*   RFY                                                            0201
*    (REG1) RSTD;                   /* REG 1 USED BY DATA MGT. LOCATE
*                                      MODE                    Y02014*/
*   GEN(GET  (R8));                 /* GET LOGICAL TRACE RECORD      */
*                                                                  0202
         GET  (R8)
*   /*****************************************************************/
*   /*                                                               */
*   /* LOCATE MODE RETURNS RECORD ADDRESS IN REG 1 LOCATE MODE IS    */
*   /* USED SO THAT LITTLE-LL CAN BE VERIFIED                        */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0203
*   REG2=REG1->LLVAL;               /* PICK UP LITTLE-LL VALUE       */
         LH    REG2,LLVAL(,REG1)                                   0203
*   IF REG2<4×                      /* LL MUST BE GREATER THAN 4 AND
*                                      LESS THAN MAXIMUM TRACE RECORD
*                                      SIZE                          */
*       REG2>284 THEN                                              0204
*                                                                  0204
         C     REG2,@CF00065                                       0204
         BL    @RT00204                                            0204
         C     REG2,@CF01337                                       0204
         BNH   @RF00204                                            0204
@RT00204 DS    0H                                                  0205
*     /***************************************************************/
*     /*                                                             */
*     /* LL ERROR, PRINT MESSAGE ON PRINTER DATA SET AND TERMINATE   */
*     /* EDIT FUNCTION                                               */
*     /*                                                             */
*     /***************************************************************/
*                                                                  0205
*GBADLL:                                                           0205
*     DO;                                                          0205
GBADLL   DS    0H                                                  0206
*       GEN(BRWRITE  SKIP,IMM);     /* SKIP TO NEW PAGE M0866        */
         BRWRITE  SKIP,IMM
*       LLERR(29:36)=DDNAME;        /* MOVE DDNAME TO MESSAGE        */
         MVC   LLERR+28(8),DDNAME(AEDITCBR)                        0207
*       REG2=DCBBLKCT;              /* GET BAD BLOCK NUMBER FROM DCB */
         L     REG2,DCBBLKCT                                       0208
*       GEN(CVD  REG2,WORK1);       /* CONVERT TO DEC IN COM WORK  0209
*                                      AREA                          */
*                                                                  0209
         CVD  REG2,WORK1
*       /*************************************************************/
*       /*                                                           */
*       /* POINT TO FIELD IN MESSAGE TO RECEIVE BLOCK NUMBER         */
*       /*                                                           */
*       /*************************************************************/
*                                                                  0210
*       REG2=ADDR(LLERR(48));                                      0210
         LA    REG2,LLERR+47                                       0210
*       GEN;                                                       0211
*                                                                  0211
         UNPK  0(6,REG2),WORK1(8)     CONVERT TO CHAR IN MESSAGE
         OI    5(REG2),X'F0'          FIXED SIGN DIGIT
*       /*************************************************************/
*       /*                                                           */
*       /* SUPPRESS LEADING ZEROS IN BLOCK NUMBER                    */
*       /*                                                           */
*       /*************************************************************/
*                                                                  0212
*       DO I=48 TO 53;                                             0212
*                                                                  0212
         LA    I,48                                                0212
@DL00212 DS    0H                                                  0213
*         /***********************************************************/
*         /*                                                         */
*         /* ONCE NOT ZERO, GET OUT                                  */
*         /*                                                         */
*         /***********************************************************/
*                                                                  0213
*         IF LLERR(I)^='0' THEN                                    0213
         LA    @10,LLERR-1(I)                                      0213
         CLI   0(@10),C'0'                                         0213
         BNE   @RT00213                                            0213
*           GO TO BADLLMSG;                                        0214
*                                                                  0214
*         /***********************************************************/
*         /*                                                         */
*         /* CHANGE LEADING ZERO TO BLANK                            */
*         /*                                                         */
*         /***********************************************************/
*                                                                  0215
*         ELSE                                                     0215
*           LLERR(I)=' ';                                          0215
         LA    @10,LLERR-1(I)                                      0215
         MVI   0(@10),C' '                                         0215
*       END;                                                       0216
*                                                                  0216
         AL    I,@CF00076                                          0216
         C     I,@CF01251                                          0216
         BNH   @DL00212                                            0216
*       /*************************************************************/
*       /*                                                           */
*       /* MOVE MESSAGE TO CURRENT OUTPUT BUFFER                     */
*       /*                                                           */
*       /*************************************************************/
*                                                                  0217
*BADLLMSG:                                                         0217
*       OUTBUF(1:53)=LLERR;                                        0217
BADLLMSG L     @10,CURBUF                                          0217
         MVC   OUTBUF(53,@10),LLERR                                0217
*       OUTBUF(55:82)=TERMSG;       /* IND. EDIT TERMINATING         */
         MVC   OUTBUF+54(28,@10),TERMSG                            0218
*       GEN(BRWRITE  1);            /* WRITE BAD LL MESSAGE          */
         BRWRITE  1
*       CLOSE='1'B;                 /* REQUEST TERMINATION BY EOF  0220
*                                      HANDLER                       */
         OI    CLOSE,B'00000100'                                   0220
*       GO TO EOFHANDL;             /* SHUT DOWN                     */
         B     EOFHANDL                                            0221
*     END GBADLL;                                                  0222
*                                                                  0222
*   /*****************************************************************/
*   /*                                                               */
*   /* LL-FIELD IS OK, POINT CURREC AT RECORD                  Y02014*/
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0223
*   RECDLL=REG2;                    /* SAVE RECORD LENGTH      Y02014*/
@RF00204 STCM  REG2,7,RECDLL(AEDITCBR)                             0223
*   CURREC=REG1;                    /* PT CURREC TO DM BUFF REC    0224
*                                                              Y02014*/
         ST    REG1,CURREC(,AEDITCBR)                              0224
*   RFY                                                            0225
*    (REG1) UNRSTD;                 /*                         Y02014*/
*   IF SYNADSW='0'B THEN            /* TEST FOR SYNAD ROUTINE HAVING
*                                      BEEN CALLED                   */
         TM    SYNADSW,B'00000010'                                 0226
         BNZ   @RF00226                                            0226
*     EIOERCT=3;                    /* RESET ERROR COUNT IF NOT      */
         MVC   EIOERCT(2),@CH00198                                 0227
*   IF DAWRAP='0'B THEN             /* TEST FOR PROCESSING WRAP DATA
*                                      SET                           */
@RF00226 TM    DAWRAP,B'00100000'                                  0228
         BZ    @RT00228                                            0228
*     GO TO GETDONE;                /* IF NOT, GET REQUIREMENTS ARE
*                                      COMPLETE, GO RETURN TO      0229
*                                      AMDPRFRM                      */
*   IF PSITWRAP='0'B THEN           /* TEST FOR WRAP POSITIONING   0230
*                                      REQUIRED                      */
         TM    PSITWRAP,B'00010000'                                0230
         BZ    @RT00230                                            0230
*     GO TO POSIT;                  /* IF SO, BRANCH TO POSITIONING
*                                      ROUTINE                       */
*                                                                  0231
*   /*****************************************************************/
*   /*                                                               */
*   /* TEST FOR TIME-STAMP RECORD                                    */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0232
*   IF RECAID='00'X&                /* TIME-STAMP RECORD INDENTIFIED
*                                      BY AID '00'X AND              */
*       RECFID='01'X THEN           /* FID '04'X                     */
         L     @10,CURREC(,AEDITCBR)                               0232
         CLI   RECAID(@10),X'00'                                   0232
         BNE   @RF00232                                            0232
         CLI   RECFID(@10),X'01'                                   0232
         BNE   @RF00232                                            0232
*TESTTIME:                                                         0233
*     DO;                                                          0233
*                                                                  0233
TESTTIME DS    0H                                                  0234
*       /*************************************************************/
*       /*                                                           */
*       /* TEST VALUE OF TIME-STAMP TO DETERMINE IF LOGICAL END OF   */
*       /* DATA SET HAS BEEN ENCOUNTERED. TIME VALUE WILL DECREASING */
*       /* AT POINT AT WHICH WRAP STOPPED FIRST COMPARE DATES        */
*       /*                                                           */
*       /*************************************************************/
*                                                                  0234
*       IF RECTOD<EIOTOD THEN                                      0234
*                                                                  0234
         L     @10,CURREC(,AEDITCBR)                               0234
         CLC   RECTOD(8,@10),EIOTOD                                0234
         BNL   @RF00234                                            0234
*         /***********************************************************/
*         /*                                                         */
*         /* LOGOICAL END-OF FILE HAS BEEN FOUND                     */
*         /*                                                         */
*         /***********************************************************/
*                                                                  0235
*LOGEND:                                                           0235
*         DO;                                                      0235
LOGEND   DS    0H                                                  0236
*           CLOSE='1'B;             /* INDICATE DONE PROCESSING      */
         OI    CLOSE,B'00000100'                                   0236
*           GO TO EOFHANDL;         /* GO TO EOF HANDLER TO CLOSE  0237
*                                      DOWN                          */
         B     EOFHANDL                                            0237
*         END LOGEND;                                              0238
*                                                                  0238
*       /*************************************************************/
*       /*                                                           */
*       /* IF TIME DOES NOT DECREASE, SAVE TIME VALUE AND RETURN TO  */
*       /* CALLER                                                    */
*       /*                                                           */
*       /*************************************************************/
*                                                                  0239
*       ELSE                                                       0239
*SAVETME:                                                          0239
*         DO;                                                      0239
*                                                                  0239
@RF00234 DS    0H                                                  0239
SAVETME  DS    0H                                                  0240
*           /*********************************************************/
*           /*                                                       */
*           /* SAVE TIME FROM CURRENT RECORD                         */
*           /*                                                       */
*           /*********************************************************/
*                                                                  0240
*           EIOTIME=RECTOD;                                        0240
*                                                                  0240
         L     @10,CURREC(,AEDITCBR)                               0240
         MVC   EIOTIME(8),RECTOD(@10)                              0240
*           /*********************************************************/
*           /*                                                       */
*           /* GO EXIT TO CALLER                                     */
*           /*                                                       */
*           /*********************************************************/
*                                                                  0241
*           GO TO GETDONE;                                         0241
         B     GETDONE                                             0241
*         END SAVETME;                                             0242
*     END TESTTIME;                                                0243
*                                                                  0243
*   /*****************************************************************/
*   /*                                                               */
*   /* IF NOT TIME-STAMP RECORD RETURN TO CALLER                     */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0244
*   ELSE                                                           0244
*     GO TO GETDONE;                /* GO EXIT TO CALLER             */
*                                                                  0245
*/********************************************************************
*                                                                    */
*/*                                                                  */
*/*  POSITIONING SUBROUTINE.  THIS ROUTINE POSITIONS A GTF WRAP DATA */
*/*  SET TO THE TIME STAMP RECORD WITH THE LOWEST TIME VALUE.        */
*/*  THIS RECORD MARKS THE LOGICAL BEGINNING OF THE TRACE DATA.      */
*/*                                                                  */
*/********************************************************************
*                                                                    */
*/* BRANCH HERE IF POSITIONING WRAP DATA SET IS IN PROCESS           */
*                                                                  0245
*POSIT:                                                            0245
*   IF RECAID='00'X&                /* TEST FOR TIME-STAMP RECORD BY
*                                      AID OF '00'X AND              */
*       RECFID='01'X THEN           /* FID OF '04'X                  */
POSIT    L     @10,CURREC(,AEDITCBR)                               0245
         CLI   RECAID(@10),X'00'                                   0245
         BNE   @RF00245                                            0245
         CLI   RECFID(@10),X'01'                                   0245
         BNE   @RF00245                                            0245
*TIMEREC:                                                          0246
*     DO;                                                          0246
TIMEREC  DS    0H                                                  0247
*       IF FRSTWRAP='0'B THEN       /* TEST FOR FIRST TIME INTO    0247
*                                      POSITIONING ROUTINE           */
         TM    FRSTWRAP,B'00001000'                                0247
         BNZ   @RF00247                                            0247
*         DO;                                                      0248
*                                                                  0248
*           /*********************************************************/
*           /*                                                       */
*           /* SAVE TIME FROM CURRENT RECORD                         */
*           /*                                                       */
*           /*********************************************************/
*                                                                  0249
*           EIOTIME=RECTOD;                                        0249
         L     @10,CURREC(,AEDITCBR)                               0249
         MVC   EIOTIME(8),RECTOD(@10)                              0249
*           FRSTWRAP='1'B;          /* SET FIRST TIME POSIT. SWITCH  */
         OI    FRSTWRAP,B'00001000'                                0250
*           GO TO GETREC;           /* GO SEARCH FOR NEXT TIME-STAMP
*                                      RECORD                        */
         B     GETREC                                              0251
*         END;                      /* END FIRST-TIME POSITIONING  0252
*                                      PROCESSING                    */
*                                                                  0252
*       /*************************************************************/
*       /*                                                           */
*       /* IF NOT FIRST TIME INTO POSITIONING ROUTINE, COMPARE NEW   */
*       /* TIME VALUE TO SAVED TIME, LOOKING FOR POINT IN DATA SET   */
*       /* WHERE TIME VALUES DECREASE                                */
*       /*                                                           */
*       /*************************************************************/
*                                                                  0253
*       ELSE                                                       0253
*         DO;                                                      0253
@RF00247 DS    0H                                                  0254
*           IF RECTOD<EIOTOD THEN                                  0254
         L     @10,CURREC(,AEDITCBR)                               0254
         CLC   RECTOD(8,@10),EIOTOD                                0254
         BNL   @RF00254                                            0254
*DECFND:                                                           0255
*             DO;                   /* TIME DECREASES - LOGICAL    0255
*                                      BEGINNING HAS BEEN FOUND      */
DECFND   DS    0H                                                  0256
*               PSITWRAP='1'B;      /* INDICATE POSITIONING COMPLETE */
*                                                                  0256
         OI    PSITWRAP,B'00010000'                                0256
*               /*****************************************************/
*               /*                                                   */
*               /* SAVE TIME FROM CURRENT RECORD                     */
*               /*                                                   */
*               /*****************************************************/
*                                                                  0257
*               EIOTIME=RECTOD;                                    0257
         L     @10,CURREC(,AEDITCBR)                               0257
         MVC   EIOTIME(8),RECTOD(@10)                              0257
*               GO TO GETDONE;      /* GO RETURN TO CALLER           */
         B     GETDONE                                             0258
*             END DECFND;                                          0259
*                                                                  0259
*           /*********************************************************/
*           /*                                                       */
*           /* IF TIME DOES NOT DECREASE, SAVE NEW TIME AND CONTINUE */
*           /* SCAN                                                  */
*           /*                                                       */
*           /*********************************************************/
*                                                                  0260
*           ELSE                                                   0260
*             DO;                                                  0260
*                                                                  0260
@RF00254 DS    0H                                                  0261
*               /*****************************************************/
*               /*                                                   */
*               /* SAVE TIME FROM CURRENT RECORD                     */
*               /*                                                   */
*               /*****************************************************/
*                                                                  0261
*               EIOTIME=RECTOD;                                    0261
         L     @10,CURREC(,AEDITCBR)                               0261
         MVC   EIOTIME(8),RECTOD(@10)                              0261
*               GO TO GETREC;       /* GO READ FOR NEXT TIME-STAMP 0262
*                                      RECORD                        */
         B     GETREC                                              0262
*             END;                                                 0263
*         END;                                                     0264
*     END TIMEREC;                                                 0265
*   ELSE                                                           0266
*     GO TO GETREC;                 /* IF NOT TIME-STAMP RECORD LOOP
*                                      BACK TO GET NEXT RECORD       */
*                                                                  0267
*/********************************************************************
*                                                                    */
*/*                                                                  */
*/*  DCB EXIT ROUTINE.  THE PURPOSE OF THIS ROUTINE IS TO            */
*/*  SET THE DCBBLKSI AND THE DCBBUFNO AND TO OBTAIN THE             */
*/*  INPUT BUFFER AREA.                                              */
*/*                                                                  */
*/********************************************************************
*                                                                    */
*                                                                  0267
*DCBEXIT:                                                          0267
*   EIOR14SV=REG14;                 /* SAVE RETURN POINT ADDRESS     */
DCBEXIT  ST    REG14,EIOR14SV                                      0267
*   DCBBLKSI=4096;                  /* 4K BUFFERS WANTED       Y02014*/
         L     @10,@CF01192                                        0268
         STH   @10,DCBBLKSI                                        0268
*   DCBLRECL=4000;                  /*                       @YM04522*/
         MVC   DCBLRECL(2),@CH01482                                0269
*   DCBBUFNO=3;                     /* 3 BUFFERS WANTED        Y02014*/
         LA    @04,3                                               0270
         STC   @04,DCBBUFNO                                        0270
*   REG2=DCBBLKSI*DCBBUFNO;         /* COMPUTE AMOUNT OF STORAGE   0271
*                                      NEEDED FOR BUFFERS            */
         LR    @01,@10                                             0271
         MR    @00,@04                                             0271
         LR    REG2,@01                                            0271
*   REG1=DCBBLKSI//4;               /* BLKSIZE MULTIPLE OF 4?      0272
*                                                            @ZA28699*/
         LR    @00,@10                                             0272
         SRDA  @00,32                                              0272
         D     @00,@CF00065                                        0272
         LR    REG1,@00                                            0272
*   RFY                                                            0273
*    (REG1) RSTD;                   /* KEEP IT FROM COMPILER @ZA28699*/
*   IF REG1^=0 THEN                 /* IF NOT, ROUND UP FOR  @ZA28699*/
         LTR   REG1,REG1                                           0274
         BZ    @RF00274                                            0274
*     REG2=REG2+((4-REG1)*DCBBUFNO);/* EACH BUFFER           @ZA28699*/
         LA    @07,4                                               0275
         SLR   @07,REG1                                            0275
         MR    @06,@04                                             0275
         ALR   REG2,@07                                            0275
*   RFY                                                            0276
*    (REG1) UNRSTD;                 /* GIVE IT BACK TO CMPLR @ZA28699*/
@RF00274 DS    0H                                                  0277
*   REG2=REG2+8;                    /* ACCOUNT FOR BUFFER CONTROL BLK*/
         AL    REG2,@CF00039                                       0277
*   LNGTH1=REG2;                    /* LNGTH PARM FOR GETMAIN        */
         ST    REG2,LNGTH1                                         0278
*   LNGTH2=REG2;                    /* LNGTH PARM FOR GETMAIN        */
         ST    REG2,LNGTH2                                         0279
*   EIOSTOR=REG2×'01000000'X;       /* STORE TOTAL LENGTH IN CONTROL
*                                      TABLE                         */
*                                                                  0280
         LR    @10,REG2                                            0280
         O     @10,@CF01483                                        0280
         ST    @10,EIOSTOR                                         0280
*   /*****************************************************************/
*   /*                                                               */
*   /* ISSUE CONDITONAL GETMAIN FOR BUFFERS                          */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0281
*   RFY                                                            0281
*    (REG1,                                                        0281
*     REG0) RSTD;                   /*                         Y02014*/
*   GEN(GETMAIN VC,LA=LNGTH,A=BUFADDR,SP=1);                       0282
         GETMAIN VC,LA=LNGTH,A=BUFADDR,SP=1
*   IF REG15^=0 THEN                                               0283
         LTR   REG15,REG15                                         0283
         BZ    @RF00283                                            0283
*     DO;                           /* TEST FOR INSUFFICIENT STORAGE */
*       REG2=SYNMSGA+8;             /* POINT TO AMD225I ENTRY IN MSG
*                                      ARRAY                         */
*                                                                  0285
         LA    REG2,8                                              0285
         AL    REG2,SYNMSGA                                        0285
*       /*************************************************************/
*       /*                                                           */
*       /* REQUEST THAT MESSAGE AMD165I NOT BE ISSUED                */
*       /*                                                           */
*       /*************************************************************/
*                                                                  0286
*NOSPACEM:                                                         0286
*       GEN(OI  SWD,NOSTDMG);                                      0286
NOSPACEM OI  SWD,NOSTDMG
*       REG15=ASYNTAX;              /* POINT TO MESSAGE WRITER       */
         L     REG15,ASYNTAX                                       0287
*       CALL SYNTAXC;               /* LINK TO MESSAGE WRITER - C  0288
*                                      INDICATES THIRD MESSAGE IN  0288
*                                      ARRAY                         */
*                                                                  0288
         BAL   @14,SYNTAXC                                         0288
*       /*************************************************************/
*       /*                                                           */
*       /* SET UP BUFNO AND BLKSIZE TO AVOID 80A IN OPEN             */
*       /*                                                           */
*       /*************************************************************/
*                                                                  0289
*       DCBBUFNO=1;                                                0289
         MVI   DCBBUFNO,X'01'                                      0289
*       DCBBLKSI=8;                                                0290
         MVC   DCBBLKSI(2),@CH00039                                0290
*       OPENFAIL='1'B;              /* SIGNAL OPEN FAILED            */
         OI    OPENFAIL,B'01000000'                                0291
*       GO TO EXITDONE;             /* GO RETURN TO OPEN ROUTINES    */
         B     EXITDONE                                            0292
*     END;                                                         0293
*                                                                  0293
*   /*****************************************************************/
*   /*                                                               */
*   /* BUILD PARMS FOR BUFFER BUILD                                  */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0294
*   WORK1(1)='00'X;                 /* CLEAR HIGH ORDER BYTE         */
@RF00283 MVI   WORK1,X'00'                                         0294
*   WORK1(2)=DCBBUFNO;              /* NUMBER OF BUFFERS             */
         IC    @10,DCBBUFNO                                        0295
         STC   @10,WORK1+1                                         0295
*   WORK1(3:4)=DCBBLKSI;            /* SIZE OF EACH BUFFER           */
         MVC   WORK1+2(2),DCBBLKSI                                 0296
*   REG0=WORK1(1:4);                /* LOAD PARAMETER REG            */
         ICM   REG0,15,WORK1                                       0297
*   REG1=BUFFER;                    /* REG1 CONTAINS ADDR BUFF Y02014*/
         L     REG1,BUFFER                                         0298
*   DCBBUFCB=REG1;                  /* SET BUFFER CONTROL BLOCK ADDR
*                                      IN DCB                        */
         ST    REG1,DCBBUFCB                                       0299
*   DCBBUFNO=WORK1(2);              /* RESTORE BUFFER COUNT          */
         IC    @10,WORK1+1                                         0300
         STC   @10,DCBBUFNO                                        0300
*   GEN(BUILD  (1),(0));            /* BUILD BUFFER AREA             */
         BUILD  (1),(0)
*/* BRANCH HERE TO COMPLETE DCB EXIT PROCESSING                      */
*                                                                  0302
*EXITDONE:                                                         0302
*   REG14=EIOR14SV;                 /* RESTORE REG 14 VALUE          */
EXITDONE L     REG14,EIOR14SV                                      0302
*   GEN(BR  R14);                   /* RETURN TO OPEN - EXIT COMPLETE*/
         BR  R14
*   RFY                                                            0304
*    (REG0,                                                        0304
*     REG1) UNRSTD;                                                0304
*                                                                  0305
*/********************************************************************
*                                                                    */
*/*                                                                  */
*/*  SYNAD ROUTINE.  THIS ROUTINE ISSUES SYNADAF AND PRINTS THE ERROR*/
*/*  ANALYSIS BUFFER.  THE CONSECUTIVE ERROR COUNT IS DECREMENTED.   */
*/*  IF THIS BECOMES 0, EDIT EXECUTION IS TERMINATED.                */
*/*                                                                  */
*/********************************************************************
*                                                                    */
*                                                                  0305
*SYNAD:                                                            0305
*   EIOR14SV=REG14;                 /* SAVE RETURN ADDRESS           */
SYNAD    ST    REG14,EIOR14SV                                      0305
*   GEN(SYNADAF  ACSMETH=QSAM);     /* GET ERROR DESCRIPTION         */
         SYNADAF  ACSMETH=QSAM
*   RFY                                                            0307
*    (REG1) RSTD;                   /* REG 1 REST IN EXIT RTN  Y02014*/
*   REG2=REG1;                      /* SAVE ADDRESS OF MESSAGE BUFFER*/
         LR    REG2,REG1                                           0308
*   SYNADSW='1'B;                   /* INDICATE SYNAD ROUTINE ENTERED
*                                      SO MAINLINE WILL NOT RESET  0309
*                                      ERROR COUNT                   */
         OI    SYNADSW,B'00000010'                                 0309
*   EIOERCT=EIOERCT-1;              /* DECREMENT ERROR COUNT         */
*                                                                  0310
         LH    @10,EIOERCT                                         0310
         BCTR  @10,0                                               0310
         STH   @10,EIOERCT                                         0310
*   /*****************************************************************/
*   /*                                                               */
*   /* CONSTRUCT I/O ERROR MESSAGE AND INDICATE ACTION               */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0311
*   IF EIOERCT=2 THEN               /* IF APPARENT FIRST ERROR,      */
         C     @10,@CF00109                                        0311
         BNE   @RF00311                                            0311
*     GEN(BRWRITE  SKIP,IMM);       /* SKIP TO NEW PAGE              */
         BRWRITE  SKIP,IMM
*   OUTBUF(1:12)=ERMSG;             /* MOVE I/O ERROR MESSAGE TO   0313
*                                      OUTPUT BUFFER                 */
@RF00311 L     @10,CURBUF                                          0313
         MVC   OUTBUF(12,@10),ERMSG                                0313
*   OUTBUF(14:21)=DDNAME;           /* MOVE DD NAME TO BUFFER        */
         MVC   OUTBUF+13(8,@10),DDNAME(AEDITCBR)                   0314
*   IF EIOERCT=0 THEN               /* TEST ERROR COUNT FOR ZERO     */
         LH    @04,EIOERCT                                         0315
         LTR   @04,@04                                             0315
         BNZ   @RF00315                                            0315
*     OUTBUF(23:50)=TERMSG;         /* IF ZERO, MOVE TERMINATION   0316
*                                      MESSAGE TO OUTPUT BUFFER      */
         MVC   OUTBUF+22(28,@10),TERMSG                            0316
*   ELSE                                                           0317
*     OUTBUF(23:34)=CONMSG;         /* IF ERROR COUNT NOT YET ZERO,
*                                      MOVE CONTINUING MESSAGE TO  0317
*                                      OUTPUT BUFFER                 */
         B     @RC00315                                            0317
@RF00315 L     @10,CURBUF                                          0317
         MVC   OUTBUF+22(12,@10),CONMSG                            0317
*   RFY                                                            0318
*    (REG1) UNRSTD;                 /*                         Y02014*/
@RC00315 DS    0H                                                  0319
*   GEN(BRWRITE  1);                /* PRINT MESSAGE ON PRINTER DATA
*                                      SET                           */
         BRWRITE  1
*   OUTBUF=SYNADBUF;                /* MOVE SYNADAF MESSAGE TO OUTPUT
*                                      AREA - SYNADBUF BASED ON REG 2*/
         L     @10,CURBUF                                          0320
         MVI   OUTBUF+77(@10),C' '                                 0320
         MVC   OUTBUF+78(54,@10),OUTBUF+77(@10)                    0320
         MVC   OUTBUF(77,@10),SYNADBUF(REG2)                       0320
*   GEN;                                                           0321
    BRWRITE  2                 /*  WRITE SYNADAF MSG ON PRINTER DATA */
*                             /*  SET - SPACE A LINE AFTER PRINTING */
    SYNADRLS                       RELEASE SYNADAF BUFFER
*   IF EIOERCT=0 THEN               /* IF ERROR COUNT IS ZERO,       */
         LH    @10,EIOERCT                                         0322
         LTR   @10,@10                                             0322
         BNZ   @RF00322                                            0322
*TERMER:                                                           0323
*     DO;                           /* SET UP TO TERMINATE EDIT      */
TERMER   DS    0H                                                  0324
*       CLOSE='1'B;                 /* REQUEST CLOSE DOWN            */
         OI    CLOSE,B'00000100'                                   0324
*       GO TO EOFHANDL;             /* GO TO EOF HANDLER TO CLOSE  0325
*                                      TRACE DATA SET                */
         B     EOFHANDL                                            0325
*     END TERMER;                                                  0326
*                                                                  0326
*   /*****************************************************************/
*   /*                                                               */
*   /* IF ERROR COUNT IS NOT ZERO, IGNORE BAD BLOCK BY RETURNING TO  */
*   /* SYSTEM                                                        */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0327
*   REG14=EIOR14SV;                 /* RESTORE REG 14                */
@RF00322 L     REG14,EIOR14SV                                      0327
*   GEN(BR  R14);                   /* RETURN TO SYSTEM              */
         BR  R14
*                                                                  0329
*/********************************************************************
*                                                                    */
*/*                                                                  */
*/*  EOF HANDLER.  THE FUNCTION OF THIS ROUTINE IS TO CLOSE THE      */
*/*  TRACE DATA SET AND, IF THE EDIT FUNCTION IS TERMINATING,        */
*/*  TO FREE INPUT BUFFERS AND WORKING STORAGE.                      */
*/*  IF A D/A WRAP DATA SET IS BEING PROCESSED AND THE LOGICAL END OF*/
*/*  FILE HAS NOT BEEN REACHED, THE DATA SET IS RE-OPENED TO POSITION*/
*/*  TO THE BEGINNING OF THE DATA SET.  THIS ROUTINE IS ALSO USED TO */
*/*  FREE WORKING STORAGE WHEN TRACE DATA IS BEING EDITED FROM A DUMP*/
*/*  DATA SET.                                                       */
*/*                                                                  */
*/********************************************************************
*                                                                    */
*                                                                  0329
*EOFHANDL:                                                         0329
*   GEN(CLOSE  ((R8)));             /* ISSUE CLOSE SVC               */
EOFHANDL CLOSE  ((R8))
*   IF EXTTRC='1'B THEN             /* PROCESSING EXTERNAL     Y02014*/
         TM    EXTTRC(AEDITCBR),B'00000100'                        0330
         BNO   @RF00330                                            0330
*     DO;                                                          0331
*       IF((DAWRAP='1'B&FRSTWRAP='0'B)×/* TIME STAMP FOUND     Y02014*/
*           (DAWRAP='0'B&TSFOUND='0'B))&TRCCOUNT^=0&/* WAS A RECORD
*                                      READ                    Y02014*/
*           CLOSE='0'B&             /* CLOSE DOWN NOT REQUESTED    0332
*                                                              Y02014*/
*           TERM='0'B THEN          /* TERM NOT REQUESTED      Y02014*/
         TM    DAWRAP,B'00100000'                                  0332
         BNO   @GL00007                                            0332
         TM    FRSTWRAP,B'00001000'                                0332
         BZ    @GL00006                                            0332
@GL00007 TM    DAWRAP,B'00100000'                                  0332
         BNZ   @RF00332                                            0332
         TM    TSFOUND(AEDITCBR),B'00100000'                       0332
         BNZ   @RF00332                                            0332
@GL00006 L     @10,TRCCOUNT                                        0332
         LTR   @10,@10                                             0332
         BZ    @RF00332                                            0332
         TM    CLOSE,B'00000100'                                   0332
         BNZ   @RF00332                                            0332
         TM    TERM(AEDITCBR),B'01000000'                          0332
         BNZ   @RF00332                                            0332
*         DO;                                                      0333
*           SYNMSGA=ADDR(AMDPRE11); /* PT TO NON VS2 ERROR MSG Y02014*/
         L     @10,AFMG(,AEDITCBR)                                 0334
         LA    @10,AMDPRE11(,@10)                                  0334
         ST    @10,SYNMSGA                                         0334
*           GEN(OI SWD,NOSTDMG);    /* NO PRDMP MSG WANTED     Y02014*/
         OI SWD,NOSTDMG
*           REG15=ASYNTAX;          /* POINT TO MSG WRITER     Y02014*/
         L     REG15,ASYNTAX                                       0336
*           CALL SYNTAXA;           /* CALL MESSAGE WRITER     Y02014*/
         BAL   @14,SYNTAXA                                         0337
*           GO TO GETFREE;          /* GO CLEAN UP GET         Y02014*/
         B     GETFREE                                             0338
*         END;                                                     0339
*     END;                                                         0340
*                                                                  0340
@RF00332 DS    0H                                                  0341
*   /*****************************************************************/
*   /*                                                               */
*   /* TEST FOR WRAP DATA SET, IN WHICH CASE RE-POSITIONING MAY BE   */
*   /* REQUIRED.                                                     */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0341
*   IF DAWRAP='1'B THEN             /* TEST WRAP INDICATOR IN CONTROL
*                                      TABLE                         */
@RF00330 TM    DAWRAP,B'00100000'                                  0341
         BNO   @RF00341                                            0341
*REPOS:                                                            0342
*     DO;                           /* IF PROCESSING WRAP DATA SET,
*                                      MAY REQUIRE RE-POSITIONING    */
REPOS    DS    0H                                                  0343
*       IF CLOSE='1'B THEN          /* IF CLOSE DOWN IS REQUESTED ON
*                                      ANY EOF, GO BACK TO GET     0343
*                                      TERMINATION CODE. THIS CAN  0343
*                                      HAPPEN IF LOGICAL END HAS BEEN
*                                      FOUND                         */
         TM    CLOSE,B'00000100'                                   0343
         BO    @RT00343                                            0343
*         GO TO GETFINAL;                                          0344
*       IF PSITWRAP='0'B THEN       /* IF EOF HAS BEEN ENCOUNTERED,
*                                      DURING WRAP POSITIONING THEN
*                                      ACTUAL WRAP DID NOT OCCUR     */
         TM    PSITWRAP,B'00010000'                                0345
         BNZ   @RF00345                                            0345
*         DAWRAP='0'B;              /* PROCESS WITHOUT WRAP          */
         NI    DAWRAP,B'11011111'                                  0346
*       GEN(OPEN  ((R8),INPUT));    /* RE-OPEN TO POSITION TO      0347
*                                      BEGINNING OF DATA SET         */
@RF00345 DS    0H                                                  0347
         OPEN  ((R8),INPUT)
*       GO TO GETREC;               /* GO CONTINUE PROCESSING        */
         B     GETREC                                              0348
*     END REPOS;                                                   0349
*                                                                  0349
*/* BRANCH HERE TO SET GET EOF AND FREE GET STORAGE                  */
*                                                                  0350
*GETFINAL:                                                         0350
*   IF TERM='0'B THEN               /* IF TERM BIT SET BY PRGET ONLY,*/
@RF00341 DS    0H                                                  0350
GETFINAL TM    TERM(AEDITCBR),B'01000000'                          0350
         BNZ   @RF00350                                            0350
*     GETEOF='1'B;                  /* THEN SIGNAL EOF               */
         OI    GETEOF(AEDITCBR),B'10000000'                        0351
*/* BRANCH HERE TO JUST FREE - THIS IS USED IF ERROR OCCURS        0352
*   PROCESSING TRACE BUFFERS IN DUMP                                 */
*                                                                  0352
*GETFREE:                           /*                       @AZ30042*/
*   TRCCOUNT=TRCCOUNT-1;            /* EOF MEANS NO TRC REC  @AZ30042*/
@RF00350 DS    0H                                                  0352
GETFREE  L     @10,TRCCOUNT                                        0352
         BCTR  @10,0                                               0352
         ST    @10,TRCCOUNT                                        0352
*   RFY                                                            0353
*    (REG1,                                                        0353
*     REG0) RSTD;                   /*                       @ZA30042*/
*   REG0=EIOSTOR;                   /* REG0 CONTAINS LENGTH, SBP00L  */
         L     REG0,EIOSTOR                                        0354
*   REG1=BUFFER;                    /* RECORD ADDRESS IN REG 1       */
         L     REG1,BUFFER                                         0355
*   GEN(FREEMAIN R,LV=(0),A=(1));   /* RELEASE BUFFER AREA           */
         FREEMAIN R,LV=(0),A=(1)
*UNSPIE:                                                           0357
*   IF EXTTRC='0'B THEN             /* TEST FOR EXT DATA SET,  Y02014*/
UNSPIE   TM    EXTTRC(AEDITCBR),B'00000100'                        0357
         BNZ   @RF00357                                            0357
*     ERRADDR=EIOERR;               /* IF PROCESSING DUMP DATA SET,
*                                      MUST RESTORE CALLER-S ERROR 0358
*                                      ROUTINE ADDRESS.              */
         L     @10,EIOERR                                          0358
         ST    @10,ERRADDR                                         0358
*   RFY                                                            0359
*    (REG1,                                                        0359
*     REG0) UNRSTD;                 /*                         Y02014*/
@RF00357 DS    0H                                                  0360
*   EIOFLGS='00000000'X;            /* RESET ALL SWITCHES            */
         MVC   EIOFLGS(4),@CB01261                                 0360
*   IF EOF='1'B&                    /* USER WANTS EOF EXIT     Y02014*/
*       USEREXIT^='        ' THEN   /* EXIT EXISTS             Y02014*/
         TM    EOF(AEDITCBR),B'00000001'                           0361
         BNO   @RF00361                                            0361
         CLC   USEREXIT(8,AEDITCBR),@CC01502                       0361
         BE    @RF00361                                            0361
*     DO;                           /* YES                     Y02014*/
*       EOFINPRO='1'B;              /* EOF IN PROCESS BIT      Y02014*/
         OI    EOFINPRO(AEDITCBR),B'01000000'                      0363
*       CALL PREXT;                 /* GO INTERFACE WITH USER  Y02014*/
         L     @10,AFRMAD(,AEDITCBR)                               0364
         L     @15,AEXT(,@10)                                      0364
         BALR  @14,@15                                             0364
*     END;                          /*                         Y02014*/
*   GO TO GETTERM;                  /* GO INDICATE TERMINATION OF  0366
*                                      EDIT REQUIRED                 */
         B     GETTERM                                             0366
*   RFY                                                            0367
*    (REG8) UNRSTD;                 /*                         Y02014*/
*   GEN;                                                           0368
GTFDCB    DCB  DSORG=PS,            SEQUENTIAL ORGANIZATION            X
               EODAD=EOFHANDL,                                         X
               EROPT=SKP,           SKIP ERROR RECORDS                 X
               MACRF=(GL),          GET - LOCATE MODE                  X
               RECFM=VB,            VARIABLE BLOCKED RECORDS           X
               DDNAME=XXXXXXXX,     DDNAME TO BE FILLED IN BY GET INIT X
               SYNAD=SYNAD
*                                                                  0369
*/********************************************************************
*                                                                    */
*/*                                                                  */
*/*  DUMP PROCESSING INITIALIZATION.  THE CVT IN THE DUMP SYSTEM IS  */
*/*  TESTED TO INSURE THAT GTF WAS ACTIVE AT THE TIME OF THE DUMP    */
*/*  GTF BUFFERS ARE LOCATED BY THE FOLLOWING SCHEME.                */
*/*                                                                  */
*/*    CVT-->MCHEAD-->MCCE-->GTF'S MCQE-->GTFPCT-->BUFFERS           */
*/*  IF PROCESSING A S/A DUMP                                        */
*/*    CVT-->MCHEAD-->MCCE-->GTF'S MCQE--GTFPCT-->SLE-->BUFFERS      */
*/*                                         ×---->BLOKING AREA       */
*/*                                                                  */
*/*  EDITING BEGINS WITH OLDEST BUFFER.                              */
*/*  IN THE CASE OF A S/A DUMP THE BLOKING AREAS WILL BE             */
*/*  FORMATTED LAST.                                                 */
*/*                                                                  */
*/********************************************************************
*                                                                    */
*/* BRANCH HERE IF TRACE DATA TO BE EDITED FROM DUMP                 */
*                                                                  0369
*DUMPTRC:                           /* DUMP PROCESSING         Y02014*/
*   IF BLOKPROC='1'B THEN           /* S/A DUMP PROCESSING REQ Y02014*/
DUMPTRC  TM    BLOKPROC,B'10000000'                                0369
         BO    @RT00369                                            0369
*     GO TO DEBLKSA;                /* GO DEBLOCK GTFBLOKS     Y02014*/
*   IF FIRSTGET='1'B THEN           /* HAS SET UP BEEN DONE    Y02014*/
         TM    FIRSTGET,B'10000000'                                0371
         BO    @RT00371                                            0371
*     GO TO DEBLOCK;                /* GO DEBLOCK BUFFERS      Y02014*/
*   AEIOCT=ADDR(EIOCTL);            /* PT PRTAB TO I/O TABLE   Y02014*/
         LA    @10,EIOCTL                                          0373
         ST    @10,AEIOCT(,AEDITCBR)                               0373
*   SYNMSGA=ADDR(AMDPRE01);         /* PT TO ERROR MSG ARRAY   Y02014*/
         L     @10,AFMG(,AEDITCBR)                                 0374
         ST    @10,SYNMSGA                                         0374
*   RFY                                                            0375
*    (REG1,                                                        0375
*     REG2) RSTD;                   /*                         Y02014*/
*   REG2=572;                       /* SIZE OF BUILD AREA      Y02014*/
         LA    REG2,572                                            0376
*   GEN(GETMAIN R,LV=(R2));         /* GET TRACE BUILD AREA    Y02014*/
         GETMAIN R,LV=(R2)
*   BLDAREA=REG1;                   /* STORE ADDR              Y02014*/
         ST    REG1,BLDAREA                                        0378
*   EIOSTOR=REG2;                   /* STORE LENGTH IN TABLE   Y02014*/
         ST    REG2,EIOSTOR                                        0379
*   EIOERR=ERRADDR;                 /* SAVE CALLER'S ERROR RTN Y02014*/
         L     @10,ERRADDR                                         0380
         ST    @10,EIOERR                                          0380
*   ERRADDR=ADDR(DUMPER);           /* ESTAB GET'S ERROR RTN   Y02014*/
         LA    @10,DUMPER                                          0381
         ST    @10,ERRADDR                                         0381
*   FIRSTGET='1'B;                  /* INDICATE INIT COMPLETE  Y02014*/
         OI    FIRSTGET,B'10000000'                                0382
*   REG2=CVTADDR+DISP1;             /* GET ADDR OF GTF CVT WD  Y02014*/
         L     REG2,CVTADDR                                        0383
         AL    REG2,DISP1                                          0383
*   GEN(BRREAD (R2),DATA,ASID=AID); /* READ FOR GTF CVT WD     Y02014*/
         BRREAD (R2),DATA,ASID=AID
*   IF CVTGTFAT^='1'B THEN          /* GTF ACTIVE AT TIME      Y02014*/
         TM    CVTGTFAT(REG1),B'10000000'                          0385
         BO    @RF00385                                            0385
*     DO;                           /* OF DUMP                 Y02014*/
*       REG2=ADDR(NOTACMSG);        /* PT TO NOT ACTIVE MSG    Y02014*/
         LA    REG2,NOTACMSG                                       0387
*       I=30;                       /* SET LENGTH OF MESSAGE   Y02014*/
         LA    I,30                                                0388
*       GO TO WRITERR;              /* GO WRITE MESSAGE        Y02014*/
         B     WRITERR                                             0389
*     END;                          /*                         Y02014*/
*                                                                  0390
*   /*****************************************************************/
*   /*                                                               */
*   /* THE MCHEAD IS THE NEXT STEP IN THE BUFFER LOCATING SCHEME     */
*   /*                                                         Y02014*/
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0391
*   ADDRSAVE=P;                     /* SAVE ADDR OF MCHEAD     Y02014*/
@RF00385 L     @10,P(,REG1)                                        0391
         ST    @10,ADDRSAVE                                        0391
*   IDVALID='MCHEAD';               /* COMPARE ELEMENT SAVED   Y02014*/
         MVI   IDVALID+6,C' '                                      0392
         MVI   IDVALID+7,C' '                                      0392
         MVC   IDVALID(6),@CC01507                                 0392
*   CALL IDCHECK;                   /* CHECK FOR VALID ID      Y02014*/
         BAL   @14,IDCHECK                                         0393
*/* NEXT STEP IS THE MCCE                                      Y02014*/
*                                                                  0394
*   REG2=ADDRSAVE+DISP2;            /* ADD OFFSET TO MCCE ADDR Y02014*/
         L     REG2,ADDRSAVE                                       0394
         AL    REG2,DISP2                                          0394
*   GEN(BRREAD (R2),DATA,ASID=AID); /* READ FOR MCCE ADDR      Y02014*/
         BRREAD (R2),DATA,ASID=AID
*   ADDRSAVE=P;                     /* SAVE ADDR OF MCCE       Y02014*/
         L     @10,P(,REG1)                                        0396
         ST    @10,ADDRSAVE                                        0396
*   IDVALID='MCCE';                 /* COMPARE ELEMENT SAVED   Y02014*/
         MVI   IDVALID+4,C' '                                      0397
         MVC   IDVALID+5(3),IDVALID+4                              0397
         MVC   IDVALID(4),@CC01509                                 0397
*   CALL IDCHECK;                   /* CHECK FOR VALID ID      Y02014*/
*                                                                  0398
         BAL   @14,IDCHECK                                         0398
*   /*****************************************************************/
*   /*                                                               */
*   /* NEXT STEP IS LOCATING GTF'S MCQE                        Y02014*/
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0399
*   REG2=ADDRSAVE+DISP3;            /* ADD OFFSET TO MCQE ADDR Y02014*/
         L     REG2,ADDRSAVE                                       0399
         AL    REG2,DISP3                                          0399
*   GEN(BRREAD (R2),DATA,ASID=AID); /* READ FOR MCQE POINTER   Y02014*/
         BRREAD (R2),DATA,ASID=AID
*   ADDRSAVE=P;                     /* SAVE ADDR OF 1ST MCQE   Y02014*/
         L     @10,P(,REG1)                                        0401
         ST    @10,ADDRSAVE                                        0401
*   IDVALID='MCQE';                 /* SAVE COMPARE ELEMENT    Y02014*/
         MVI   IDVALID+4,C' '                                      0402
         MVC   IDVALID+5(3),IDVALID+4                              0402
         MVC   IDVALID(4),@CC01510                                 0402
*MCQESRCH:                          /*                         Y02014*/
*   IF ADDRSAVE=0 THEN              /* IS THERE A CHAIN PTR    Y02014*/
MCQESRCH L     @10,ADDRSAVE                                        0403
         LTR   @10,@10                                             0403
         BZ    @RT00403                                            0403
*     GO TO CHAINERR;               /* GO PUT OUT ERROR MSG    Y02014*/
*   CALL IDCHECK;                   /* CHECK FOR VALID ID      Y02014*/
         BAL   @14,IDCHECK                                         0405
*   REG2=ADDRSAVE+DISP4;            /* ADD OFFSET TO APP NAME  Y02014*/
         L     REG2,ADDRSAVE                                       0406
         AL    REG2,DISP4                                          0406
*   GEN(BRREAD (R2),DATA,ASID=AID); /* READ FOR APP ID         Y02014*/
         BRREAD (R2),DATA,ASID=AID
*   IDHOLD1=TABLEID;                /* SAVE APP ID             Y02014*/
         MVC   IDHOLD1(4),TABLEID(REG1)                            0408
*   IF IDHOLD1^='GTF ' THEN         /* IS THIS GTF'S MCQE      Y02014*/
         CLC   IDHOLD1(4),@CC01514                                 0409
         BE    @RF00409                                            0409
*     DO;                           /* NO                      Y02014*/
*       REG2=ADDRSAVE+DISP5;        /* ADD OFFSET TO MCQE PTR  Y02014*/
         L     REG2,ADDRSAVE                                       0411
         AL    REG2,DISP5                                          0411
*       GEN(BRREAD (R2),DATA,ASID=AID);/* READ FOR MCQE ADDR   Y02014*/
         BRREAD (R2),DATA,ASID=AID
*       ADDRSAVE=P;                 /* SAVE ADDR OF MCQE       Y02014*/
         L     @10,P(,REG1)                                        0413
         ST    @10,ADDRSAVE                                        0413
*       GO TO MCQESRCH;             /* GO SEARCH FOR GTF'S     Y02014*/
         B     MCQESRCH                                            0414
*     END;                          /*                         Y02014*/
*                                                                  0415
*   /*****************************************************************/
*   /*                                                               */
*   /* NEXT STEP IS THE GTFPCT                                 Y02014*/
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0416
*   REG2=ADDRSAVE+DISP6;            /* ADD OFFSET TO PCT PTR   Y02014*/
@RF00409 L     REG2,ADDRSAVE                                       0416
         AL    REG2,DISP6                                          0416
*   GEN(BRREAD (R2),DATA,ASID=AID); /* READ FOR PCT ADDR       Y02014*/
         BRREAD (R2),DATA,ASID=AID
*   ADDRSAVE=P;                     /* SAVE ADDRESS OF GTFPCT  Y02014*/
         L     @10,P(,REG1)                                        0418
         ST    @10,ADDRSAVE                                        0418
*   PCTSAVE=ADDRSAVE;               /* SAVE ADDRESS OF GTFPCT  Y02014*/
         ST    @10,PCTSAVE                                         0419
*   IDVALID='GTFPCT';               /* SAVE COMPARE ELEMENT    Y02014*/
         MVI   IDVALID+6,C' '                                      0420
         MVI   IDVALID+7,C' '                                      0420
         MVC   IDVALID(6),@CC01515                                 0420
*   CALL IDCHECK;                   /* CHECK FOR VALID ID      Y02014*/
         BAL   @14,IDCHECK                                         0421
*   REG2=ADDRSAVE+DISP7;            /* ADD OFFSET TO HQ LENGTH Y02014*/
         L     REG2,ADDRSAVE                                       0422
         AL    REG2,DISP7                                          0422
*   GEN(BRREAD (R2),DATA,ASID=AID); /* READ FOR HQ LENGTH      Y02014*/
         BRREAD (R2),DATA,ASID=AID
*   BUFFCNT=P;                      /* SAVE HQ LENGTH          Y02014*/
         L     @10,P(,REG1)                                        0424
         ST    @10,BUFFCNT                                         0424
*   REG2=ADDRSAVE+DISP21;           /* ADD OFFSET TO ASCB ADDR Y02014*/
         L     REG2,ADDRSAVE                                       0425
         AL    REG2,DISP21                                         0425
*   GEN(BRREAD (R2),DATA,ASID=AID); /* READ FOR ASCB ADDRESS   Y02014*/
         BRREAD (R2),DATA,ASID=AID
*   ASCBGTF=P;                      /* SAVE ASCB ADDRESS       Y02014*/
         L     ASCBGTF,P(,REG1)                                    0427
*   REG2=ASCBGTF+DISP22;            /* ADD OFFSET TO ASID      Y02014*/
         LR    REG2,ASCBGTF                                        0428
         AL    REG2,DISP22                                         0428
*   GEN(BRREAD (R2),DATA,ASID=AID); /* READ FOR ASID           Y02014*/
         BRREAD (R2),DATA,ASID=AID
*   GTFASID=P2;                     /* SAVE ASID               Y02014*/
         LH    GTFASID,P2(,REG1)                                   0430
*/********************************************************************/
*/*                                                            Y02014*/
*/* DETERMINE WHAT TYPE OF DUMP IN ORDER TO DECIDE WHAT SCHEME Y02014*/
*/*     TO USE IN LOCATING THE GTF BUFFERS                     Y02014*/
*/*                                                            Y02014*/
*/********************************************************************/
*                                                                  0431
*   IF SADMP='0'B THEN              /* PROCESSING A S/A        Y02014*/
         TM    SADMP,B'00100000'                                   0431
         BZ    @RT00431                                            0431
*     GO TO SLQREQ;                 /* NO, LOOK AT SLQ         Y02014*/
*   REG2=ADDRSAVE+DISP8;            /* ADD OFFSET TO HQHEAD    Y02014*/
         L     REG2,ADDRSAVE                                       0433
         AL    REG2,DISP8                                          0433
*   GEN(BRREAD (R2),DATA,ASID=AID); /* READ FOR HQHEAD         Y02014*/
         BRREAD (R2),DATA,ASID=AID
*   ADDRSAVE=P;                     /* SAVE ADDR OF GTFBCB     Y02014*/
         L     @10,P(,REG1)                                        0435
         ST    @10,ADDRSAVE                                        0435
*   AID=GTFASID;                    /* DO READS IN GTF'S MEMORY    0436
*                                                              Y02014*/
         STH   GTFASID,AID                                         0436
*BCBVAL:                            /*                         Y02014*/
*   IDVALID='GTFBCB';               /* COMPARE ELEMENT SAVED   Y02014*/
BCBVAL   MVI   IDVALID+6,C' '                                      0437
         MVI   IDVALID+7,C' '                                      0437
         MVC   IDVALID(6),@CC01518                                 0437
*   CALL IDCHECK;                   /* CHECK FOR VALID ID      Y02014*/
         BAL   @14,IDCHECK                                         0438
*   REG2=ADDRSAVE+DISP9;            /* ADD OFFSET TO BUF ADDR  Y02014*/
         L     REG2,ADDRSAVE                                       0439
         AL    REG2,DISP9                                          0439
*   GEN(BRREAD (R2),DATA,ASID=AID); /* READ FOR BUFFER ADDR    Y02014*/
         BRREAD (R2),DATA,ASID=AID
*   REG2=P;                         /* PREPARE TO READ IN BUF  Y02014*/
         L     REG2,P(,REG1)                                       0441
*   GEN(BRREAD (R2),DATA,ASID=AID); /* READ IN BUFFER          Y02014*/
*                                                                  0442
         BRREAD (R2),DATA,ASID=AID
*   /*****************************************************************/
*   /*                                                               */
*   /* ONLY ONE BRREAD IS NECESSARY DUE                        Y02014*/
*   /* TO THE BUFFER BEING ON 4K BOUNDRY                       Y02014*/
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0443
*   BUFPTR=REG1;                    /* SAVE PTR TO BUFFER      Y02014*/
         ST    REG1,BUFPTR                                         0443
*   RECPTR=REG1;                    /* PTR TO RECORDS          Y02014*/
         ST    REG1,RECPTR                                         0444
*NEWBUF:                            /*                         Y02014*/
*   IF(BLL<4)×(BLL>4096)            /* VALID BIG LL FIELD      Y02014*/
*     THEN                                                         0445
NEWBUF   LA    @10,4                                               0445
         L     @08,BUFPTR                                          0445
         LH    @04,BLL(,@08)                                       0445
         CR    @04,@10                                             0445
         BL    @RT00445                                            0445
         C     @04,@CF01192                                        0445
         BH    @RT00445                                            0445
*     GO TO BADLL;                  /* GO ISSUE ERROR MSG      Y02014*/
*   RECDLL=4;                       /* VALUE TO BYPASS PREFIX  Y02014*/
         STCM  @10,7,RECDLL(AEDITCBR)                              0447
*   BLL=BLL-4;                      /* SUBT PREFIX LENGTH      Y02014*/
         SLR   @04,@10                                             0448
         STH   @04,BLL(,@08)                                       0448
*DEBLOCK:                           /*                         Y02014*/
*   IF BLL<4 THEN                   /* RECORDS REMAINING       Y02014*/
DEBLOCK  LA    @10,4                                               0449
         L     @08,BUFPTR                                          0449
         LH    @04,BLL(,@08)                                       0449
         CR    @04,@10                                             0449
         BL    @RT00449                                            0449
*     GO TO NEXTBUF;                /* GO GET NEXT BUFFER      Y02014*/
*   RECPTR=RECPTR+RECDLL;           /* POINT TO NEXT RECORD    Y02014*/
         L     @03,RECDLL-1(,AEDITCBR)                             0451
         LA    @03,0(,@03)                                         0451
         AL    @03,RECPTR                                          0451
         ST    @03,RECPTR                                          0451
*   IF(LLL<4)×(LLL>284) THEN        /* VALID LITTLE LL         Y02014*/
         LH    @15,LLL(,@03)                                       0452
         CR    @15,@10                                             0452
         BL    @RT00452                                            0452
         C     @15,@CF01337                                        0452
         BH    @RT00452                                            0452
*     GO TO BADLL;                  /* GO ISSUE ERR MSG        Y02014*/
*   BLL=BLL-LLL;                    /* SUBT REC LNG FROM TOTAL Y02014*/
         SLR   @04,@15                                             0454
         STH   @04,BLL(,@08)                                       0454
*   IF BLL<0 THEN                   /* INVALID LITTLE LL       Y02014*/
         LTR   @04,@04                                             0455
         BM    @RT00455                                            0455
*     GO TO BADLL;                  /* GO ISSUE ERR MSG        Y02014*/
*   RECDLL=LLL;                     /* SAVE LL VALUE           Y02014*/
         STCM  @15,7,RECDLL(AEDITCBR)                              0457
*   CURREC=RECPTR;                  /* POINT CURREC AT RECORD  Y02014*/
         ST    @03,CURREC(,AEDITCBR)                               0458
*   TRCCOUNT=TRCCOUNT+1;            /* INCR TRACE REC COUNT    Y02014*/
         LA    @10,1                                               0459
         AL    @10,TRCCOUNT                                        0459
         ST    @10,TRCCOUNT                                        0459
*   GO TO GETDONE;                  /* SET UP FOR RETURN       Y02014*/
         B     GETDONE                                             0460
*NEXTBUF:                           /*                         Y02014*/
*   BUFFCNT=BUFFCNT-1;              /* CALC # OF BUFFERS LEFT  Y02014*/
NEXTBUF  L     @10,BUFFCNT                                         0461
         BCTR  @10,0                                               0461
         ST    @10,BUFFCNT                                         0461
*   IF BUFFCNT=0 THEN               /* NO BUFFERS LEFT         Y02014*/
         LTR   @10,@10                                             0462
         BZ    @RT00462                                            0462
*     GO TO TESTSADP;               /* CHECK IF S×A DUMP       Y02014*/
*   REG2=ADDRSAVE+DISP10;           /* ADD OFFSET FOR CHAIN    Y02014*/
         L     REG2,ADDRSAVE                                       0464
         AL    REG2,DISP10                                         0464
*   GEN(BRREAD (R2),DATA,ASID=AID); /* READ FOR BCB ADDR       Y02014*/
         BRREAD (R2),DATA,ASID=AID
*   ADDRSAVE=P;                     /* SAVE BCB ADDR           Y02014*/
         L     @10,P(,REG1)                                        0466
         ST    @10,ADDRSAVE                                        0466
*   GO TO BCBVAL;                   /* CHECK OUT BCB           Y02014*/
         B     BCBVAL                                              0467
*TESTSADP:                          /*                         Y02014*/
*   IF SADMP='0'B THEN              /* S×A DUMP PROCESSING     Y02014*/
TESTSADP TM    SADMP,B'00100000'                                   0468
         BZ    @RT00468                                            0468
*     GO TO GETFINAL;               /* NO GO CLEAN UP          Y02014*/
*SAPROC:                            /*                         Y02014*/
*   AID=0;                          /* BLOKS ARE IN COMMON     Y02014*/
SAPROC   SLR   @10,@10                                             0470
         STH   @10,AID                                             0470
*   BLOKPROC='1'B;                  /* DO BLOKING AREAS        Y02014*/
         OI    BLOKPROC,B'10000000'                                0471
*   ADDRSAVE=PCTSAVE;               /* RESTORE PTR TO GTFPCT   Y02014*/
         L     @10,PCTSAVE                                         0472
         ST    @10,ADDRSAVE                                        0472
*   REG2=ADDRSAVE+DISP11;           /* ADD OFFSET FOR CURRBLOK     0473
*                                      ADDRESS                 Y02014*/
         AL    @10,DISP11                                          0473
         LR    REG2,@10                                            0473
*   GEN(BRREAD (R2),DATA,ASID=AID); /* READ FOR ADDRESS        Y02014*/
         BRREAD (R2),DATA,ASID=AID
*   EIOSTOP=P;                      /* SAVE CURRBLOK ADDRESS   Y02014*/
         L     @10,P(,REG1)                                        0475
         ST    @10,EIOSTOP                                         0475
*   REG2=ADDRSAVE+DISP12;           /* ADD OFFSET FOR NEXTBLOK Y02014*/
         L     REG2,ADDRSAVE                                       0476
         AL    REG2,DISP12                                         0476
*   CURREC=BLDAREA;                 /* RESTORE CURREC          Y02014*/
         L     @10,BLDAREA                                         0477
         ST    @10,CURREC(,AEDITCBR)                               0477
*   GEN(BRREAD (R2),DATA,ASID=AID); /* READ FOR ADDRESS        Y02014*/
         BRREAD (R2),DATA,ASID=AID
*   EIOCUR=P;                       /* SAVE NEXTBLOK ADDR      Y02014*/
         L     @10,P(,REG1)                                        0479
         ST    @10,EIOCUR                                          0479
*   IDVALID='GTFBLOK';              /* SAVE COMPARE ELEMENT    Y02014*/
         MVI   IDVALID+7,C' '                                      0480
         MVC   IDVALID(7),@CC01530                                 0480
*   ADDRSAVE=EIOCUR;                /* SET UP FOR IDCHECK      Y02014*/
         ST    @10,ADDRSAVE                                        0481
*   CALL IDCHECK;                   /* CHECK FOR VALID ID      Y02014*/
         BAL   @14,IDCHECK                                         0482
*NEWSABUF:                          /*                         Y02014*/
*   IF EIOSTOP=(EIOCUR&ADDRMASK)    /* LAST BLOKING AREA     @YM03670*/
*       ×COUNT=3 THEN               /* 4 BLOKS MAXIMUM         Y02014*/
NEWSABUF L     @10,EIOCUR                                          0483
         N     @10,ADDRMASK                                        0483
         CL    @10,EIOSTOP                                         0483
         BE    @RT00483                                            0483
         CLC   COUNT(4),@CF00198                                   0483
         BNE   @RF00483                                            0483
@RT00483 DS    0H                                                  0484
*     THATSALL='1'B;                /* YES INDICATE SO         Y02014*/
         OI    THATSALL,B'01000000'                                0484
*   REG2=ADDRSAVE+DISP13;           /* ADD OFFSET FOR USE CNT  Y02014*/
@RF00483 L     REG2,ADDRSAVE                                       0485
         AL    REG2,DISP13                                         0485
*   GEN(BRREAD (R2),DATA,ASID=AID); /* READ FOR USE COUNT      Y02014*/
         BRREAD (R2),DATA,ASID=AID
*   IF USECNT^=0 THEN               /* USE COUNT ZERO          Y02014*/
         LH    @10,USECNT(,REG1)                                   0487
         LTR   @10,@10                                             0487
         BNZ   @RT00487                                            0487
*     GO TO HEXBUFDP;               /* NO,GO DUMP BUF IN HEX   Y02014*/
*   REG2=ADDRSAVE+DISP14;           /* ADD OFFSET TO BLOK AREA Y02014*/
         L     REG2,ADDRSAVE                                       0489
         AL    REG2,DISP14                                         0489
*   EIOREC=REG2;                    /* ADDR IN DUMP OF BLKAREA Y02014*/
         ST    REG2,EIOREC                                         0490
*   GEN(BRREAD (R2),DATA,ASID=AID); /* READ FOR BIG LL         Y02014*/
         BRREAD (R2),DATA,ASID=AID
*   IF(LL<=4)×(LL>4096) THEN        /* VALID BIG LL            Y02014*/
         LA    @10,4                                               0492
         LH    @08,LL(,REG1)                                       0492
         CR    @08,@10                                             0492
         BNH   @RT00492                                            0492
         C     @08,@CF01192                                        0492
         BH    @RT00492                                            0492
*     GO TO BADLL;                  /* NO GET NEXT BLOK        Y02014*/
*   EIOLL=LL-4;                     /* BYPASS BIG LL FIELD     Y02014*/
         SLR   @08,@10                                             0494
         STH   @08,EIOLL                                           0494
*   EIOREC=EIOREC+4;                /* INCREMENT TO LITTLE LL  Y02014*/
         AL    @10,EIOREC                                          0495
         ST    @10,EIOREC                                          0495
*DEBLKSA:                                                          0496
*   IF EIOLL<=4 THEN                /* ARE LOGICAL RECORDS REMAINING
*                                      IN THIS BLOK                  */
DEBLKSA  LH    @10,EIOLL                                           0496
         C     @10,@CF00065                                        0496
         BNH   @RT00496                                            0496
*     GO TO NEXTSABF;               /* IF NOT, GO TO NEXT BLOK Y02014*/
*                                                                  0497
*   /*****************************************************************/
*   /*                                                               */
*   /* READ LITTLE-LL FIELD. TWO BRREAD-S ARE REQUIRED BECAUSE FIELD */
*   /* MAY HAVE BYTE BOUNDARY ALLIGNMENT AND SPAN 2K STORAGE BLOCK   */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0498
*   REG2=EIOREC;                    /* POINT TO LOGICAL RECORD LL  0498
*                                      FIELD                         */
         L     REG2,EIOREC                                         0498
*   GEN(BRREAD (R2),DATA,ASID=AID); /* READ FOR FIRST HALF     Y02014*/
         BRREAD (R2),DATA,ASID=AID
*   EIORECLL(1)=HALFLL;             /* MOVE FIRST HALF TO EIOCT    0500
*                                      HALFLL BASED ON REG 1         */
         MVC   EIORECLL(1),HALFLL(REG1)                            0500
*   REG2=REG2+1;                    /* POINT TO SECOND BYTE          */
         AL    REG2,@CF00076                                       0501
*   GEN(BRREAD  (R2),DATA,ASID=AID);/* READ FOR SECOND HALF OF RECORD
*                                      LL FIELD                Y02014*/
         BRREAD  (R2),DATA,ASID=AID
*   EIORECLL(2)=HALFLL;             /* MOVE SECOND BYTE TO EIOCT     */
         MVC   EIORECLL+1(1),HALFLL(REG1)                          0503
*   RECDLL=EIORECLL;                /* RECORD LNG IN PRTAB     Y02014*/
*                                                                  0504
         LH    @10,EIORECLL                                        0504
         N     @10,@CF01570                                        0504
         STCM  @10,7,RECDLL(AEDITCBR)                              0504
*   /*****************************************************************/
*   /*                                                               */
*   /* VALIDITY CHECK LITTLE-LL, MUST LIE IN RANGE 4-284       Y02014*/
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0505
*   IF EIORECLL<4×EIORECLL>TWO84 THEN                              0505
*                                                                  0505
         C     @10,@CF00065                                        0505
         BL    @RT00505                                            0505
         CH    @10,TWO84                                           0505
         BNH   @RF00505                                            0505
@RT00505 DS    0H                                                  0506
*     /***************************************************************/
*     /*                                                             */
*     /* IF RECORD LL IS BAD, PRINT COMMENT AND GO ON TO NEXT BUF    */
*     /*                                                             */
*     /***************************************************************/
*                                                                  0506
*BADLL:                                                            0506
*     DO;                                                          0506
BADLL    DS    0H                                                  0507
*       GEN(BRWRITE  SKIP,IMM);     /* SKIP TO NEW PAGE              */
*                                                                  0507
         BRWRITE  SKIP,IMM
*       /*************************************************************/
*       /*                                                           */
*       /* MOVE DUMP ERROR - CONTINUING MESSAGE TO OUTPUT BUFFER     */
*       /*                                                           */
*       /*************************************************************/
*                                                                  0508
*       OUTBUF(1:49)=DUMPERCN;                                     0508
         L     @10,CURBUF                                          0508
         MVC   OUTBUF(49,@10),DUMPERCN                             0508
*       GEN(BRWRITE  2);            /* WRITE MESSAGE TO PRINTER DATA
*                                      SET                           */
         BRWRITE  2
*       IF BLOKPROC='1'B THEN       /* PROCESSING GTF BLOKS    Y02014*/
         TM    BLOKPROC,B'10000000'                                0510
         BO    @RT00510                                            0510
*         GO TO NEXTSABF;           /* YES GO GET NEXT ONE     Y02014*/
*       GO TO NEXTBUF;              /* BRANCH TO FIND NEXT BUFFER    */
         B     NEXTBUF                                             0512
*     END BADLL;                                                   0513
*                                                                  0513
*   /*****************************************************************/
*   /*                                                               */
*   /* LITTLE-LL IN PROPER RANGE                                     */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0514
*   EIOLL=EIOLL-EIORECLL;           /* SUBTRACT CURRENT RECORD LENGTH
*                                      FROM REMAINNING LENGTH IN   0514
*                                      BLOCK                         */
@RF00505 LH    @10,EIORECLL                                        0514
         N     @10,@CF01570                                        0514
         LH    @08,EIOLL                                           0514
         SLR   @08,@10                                             0514
         STH   @08,EIOLL                                           0514
*   IF EIOLL<0 THEN                 /* REMAINDER SHOULD NEVER GO   0515
*                                      NEGATIVE                      */
         SLR   @04,@04                                             0515
         CR    @08,@04                                             0515
         BL    @RT00515                                            0515
*     GO TO BADLL;                  /* IF THIS HAPPENS, SOME LL IS IN
*                                      ERROR SO GO ON TO NEXT BUFFER */
*                                                                  0516
*   /*****************************************************************/
*   /*                                                               */
*   /* EIOBRCT IS TOTAL NUMBER OF WORDS BEGINNING ON A WORD BOUNDARY */
*   /* WHICH ARE REQUIRED TO SPAN THE TRACE ENTRY BEING DEBLOCKED.   */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0517
*   EIOBRCT=(EIORECLL+3)/4+1;                                      0517
         LA    @06,3                                               0517
         ALR   @06,@10                                             0517
         SRDA  @06,32                                              0517
         D     @06,@CF00065                                        0517
         LA    @07,1(,@07)                                         0517
         STH   @07,EIOBRCT                                         0517
*   REG2=EIOREC&'FFFFFFFC'X;        /* ROUND DATA POINTER DOWN TO  0518
*                                      WORD BOUNDARY                 */
         L     @08,EIOREC                                          0518
         LR    REG2,@08                                            0518
         N     REG2,@CF01537                                       0518
*   EIOBR=EIOREC&'00000003'X;       /* SAVE REMAINDER OF ROUND DOWN  */
         LR    @03,@08                                             0519
         N     @03,@CF01538                                        0519
         STH   @03,EIOBR                                           0519
*   EIOREC=EIOREC+EIORECLL;         /* UPDATE DATA POINTER           */
*                                                                  0520
         ALR   @08,@10                                             0520
         ST    @08,EIOREC                                          0520
*   /*****************************************************************/
*   /*                                                               */
*   /* LOOP TO READ EACH WORD OF TRACE RECORD                        */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0521
*   DO I=0 TO EIOBRCT-1;                                           0521
         LR    I,@04                                               0521
         B     @DE00521                                            0521
@DL00521 DS    0H                                                  0522
*     GEN(BRREAD  (R2),DATA,ASID=AID);                             0522
*                                                                  0522
         BRREAD  (R2),DATA,ASID=AID
*     /***************************************************************/
*     /*                                                             */
*     /* READ WORD FROM DUMP - FULL WORD WILL BE READ BECAUSE DATA   */
*     /* ADDR (REG 2) HAS BEEN ROUNDED TO WORD BOUNDARY              */
*     /*                                                             */
*     /***************************************************************/
*                                                                  0523
*     K=(I*4)+1;                    /* COMPUTE OFFSET INTO BUILD AREA*/
         LR    @10,I                                               0523
         SLA   @10,2                                               0523
         AL    @10,@CF00076                                        0523
         STH   @10,K                                               0523
*     BULDAREA(K:K+3)=TWORD;        /* MOVE WORD TO BUILD AREA       */
         L     @08,CURREC(,AEDITCBR)                               0524
         ALR   @08,@10                                             0524
         MVC   BULDAREA-1(4,@08),TWORD(REG1)                       0524
*     REG2=REG2+4;                  /* POINT TO NEXT WORD            */
         AL    REG2,@CF00065                                       0525
*   END;                                                           0526
*                                                                  0526
         AL    I,@CF00076                                          0526
@DE00521 LH    @10,EIOBRCT                                         0526
         BCTR  @10,0                                               0526
         CR    I,@10                                               0526
         BNH   @DL00521                                            0526
*/*   TRACE ENTRY NOW IN CORE                                        */
*                                                                  0527
*   REG2=EIORECLL/256;              /* COMPUTE NUMBER OF MOVES     0527
*                                      REQUIRED TO MOVE ENTIRE RECORD
*                                      TO TRACE RECORD AREA          */
         LH    REG2,EIORECLL                                       0527
         N     REG2,@CF01570                                       0527
         SRL   REG2,8                                              0527
*   DO I=0 TO REG2-1;               /* LOOP PERFORM MOVES            */
         SLR   I,I                                                 0528
         B     @DE00528                                            0528
@DL00528 DS    0H                                                  0529
*     K=(I*256)+1;                  /* COMPUTE OFFSET INTO TRACE   0529
*                                      RECORD AREA AT WHICH THIS MOVE
*                                      IS TO GO                      */
         LR    @10,I                                               0529
         SLA   @10,8                                               0529
         AL    @10,@CF00076                                        0529
         STH   @10,K                                               0529
*     J=K+EIOBR;                    /* COMPUTE OFFSET INTO BUILD AREA
*                                      OF SOURCE OF MOVE             */
*                                                                  0530
         LH    J,EIOBR                                             0530
         ALR   J,@10                                               0530
*     /***************************************************************/
*     /*                                                             */
*     /* MOVE 256 BYTE SEGMENT                                       */
*     /*                                                             */
*     /***************************************************************/
*                                                                  0531
*     TRECFINL(K:K+255)=BULDAREA(J:J+255);                         0531
         L     @08,CURREC(,AEDITCBR)                               0531
         ALR   @10,@08                                             0531
         BCTR  @10,0                                               0531
         ALR   @08,J                                               0531
         MVC   TRECFINL(256,@10),BULDAREA-1(@08)                   0531
*   END;                                                           0532
         AL    I,@CF00076                                          0532
@DE00528 LR    @10,REG2                                            0532
         BCTR  @10,0                                               0532
         CR    I,@10                                               0532
         BNH   @DL00528                                            0532
*   REG2=EIORECLL//256;             /* COMPUTE REMAINDER, IF ANY, YET
*                                      TO BE MOVED                   */
         LH    REG2,EIORECLL                                       0533
         N     REG2,@CF01570                                       0533
         N     REG2,@CF01539                                       0533
*   IF REG2^=0 THEN                                                0534
         LTR   REG2,REG2                                           0534
         BZ    @RF00534                                            0534
*     DO;                           /* TEST FOR NOT ALL OF RECORD  0535
*                                      HAVING BEEN MOVED             */
*                                                                  0535
*       /*************************************************************/
*       /*                                                           */
*       /* IF THERE IS A REMAINING PART TO BE MOVED, COMPUTE OFFSET  */
*       /* OF WHERE REMAINDER SHOULD GO I VALID FROM EXIT FROM       */
*       /* DO-LOOP ABOVE                                             */
*       /*                                                           */
*       /*************************************************************/
*                                                                  0536
*       K=(I*256)+1;                /* GET OFFSET INTO TARGET AREA   */
         LR    @10,I                                               0536
         SLA   @10,8                                               0536
         AL    @10,@CF00076                                        0536
         STH   @10,K                                               0536
*       J=K+EIOBR;                  /* OFFSET OF REMAINDER           */
         LH    J,EIOBR                                             0537
         ALR   J,@10                                               0537
*       REG2=REG2-1;                /* ACCOUNT FOR INCLUSIVE NATURE
*                                      OF SUB-STRING NOTATION        */
*                                                                  0538
         BCTR  REG2,0                                              0538
*       /*************************************************************/
*       /*                                                           */
*       /* MOVE REMAINDER                                            */
*       /*                                                           */
*       /*************************************************************/
*                                                                  0539
*       TRECFINL(K:K+REG2)=BULDAREA(J:J+REG2);                     0539
         L     @08,CURREC(,AEDITCBR)                               0539
         ALR   @10,@08                                             0539
         BCTR  @10,0                                               0539
         ALR   @08,J                                               0539
         EX    REG2,@SM01571                                       0539
*     END;                                                         0540
*                                                                  0540
*   /*****************************************************************/
*   /*                                                               */
*   /* TRACE RECORD IS NOW COMPLETELY ASSEMBLED                      */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0541
*   TRCCOUNT=TRCCOUNT+1;            /* UPDATE TRACE RECORD READ COUNT*/
@RF00534 LA    @10,1                                               0541
         AL    @10,TRCCOUNT                                        0541
         ST    @10,TRCCOUNT                                        0541
*   GO TO GETDONE;                  /* GO EXIT TO AMDPRFRM           */
         B     GETDONE                                             0542
*SLQREQ:                                                           0543
*   REG2=ADDRSAVE+DISP15;           /* ADD OFFSET FOR SLQHEAD  Y02014*/
SLQREQ   L     REG2,ADDRSAVE                                       0543
         AL    REG2,DISP15                                         0543
*   GEN(BRREAD (R2),DATA,ASID=AID); /* READ FOR POINTER        Y02014*/
         BRREAD (R2),DATA,ASID=AID
*   ADDRSAVE=P;                     /* SAVE SLE ADDRESS        Y02014*/
         L     @10,P(,REG1)                                        0545
         ST    @10,ADDRSAVE                                        0545
*   IDVALID='SLE';                  /* SAVE COMPARE ELEMENT    Y02014*/
         MVI   IDVALID+3,C' '                                      0546
         MVC   IDVALID+4(4),IDVALID+3                              0546
         MVC   IDVALID(3),@CC01541                                 0546
*   AID=GTFASID;                    /* READ SLE FROM GTF MEMORY    0547
*                                                              Y02014*/
         STH   GTFASID,AID                                         0547
*INVALSLE:                          /*                         Y02014*/
*   IF ADDRSAVE=0 THEN              /* CHAIN CONTINUES         Y02014*/
INVALSLE L     @10,ADDRSAVE                                        0548
         LTR   @10,@10                                             0548
         BZ    @RT00548                                            0548
*     GO TO CHAINERR;               /* GO ISSUE ERR MESSAGE    Y02014*/
*   CALL IDCHECK;                   /* CHECK FOR VALID ID      Y02014*/
         BAL   @14,IDCHECK                                         0550
*   REG2=ADDRSAVE+DISP16;           /* ADD OFFSET TO ASID      Y02014*/
         L     REG2,ADDRSAVE                                       0551
         AL    REG2,DISP16                                         0551
*   GEN(BRREAD (R2),DATA,ASID=AID); /* READ ASID               Y02014*/
         BRREAD (R2),DATA,ASID=AID
*   ASIDHOLD=ASIDCOMP;              /* SAVE ASID               Y02014*/
         LH    ASIDHOLD,ASIDCOMP(,REG1)                            0553
*   REG2=ADDRSAVE+DISP17;           /* ADD OFFSET FOR TCB      Y02014*/
         L     REG2,ADDRSAVE                                       0554
         AL    REG2,DISP17                                         0554
*   GEN(BRREAD (R2),DATA,ASID=AID); /* READ TCB                Y02014*/
         BRREAD (R2),DATA,ASID=AID
*   IF(ASIDHOLD^=QASID)×            /* SLE WE'RE LOOKING FOR   Y02014*/
*       (TCBHOLD^=ZERO) THEN        /*                         Y02014*/
         CH    ASIDHOLD,QASID                                      0556
         BNE   @RT00556                                            0556
         CLC   TCBHOLD(4,REG1),ZERO                                0556
         BE    @RF00556                                            0556
@RT00556 DS    0H                                                  0557
*     DO;                           /*                         Y02014*/
*       REG2=ADDRSAVE+DISP18;       /* OFFSET FOR CHAIN        Y02014*/
         L     REG2,ADDRSAVE                                       0558
         AL    REG2,DISP18                                         0558
*       GEN(BRREAD (R2),DATA,ASID=AID);/* READ CHAIN PTR       Y02014*/
         BRREAD (R2),DATA,ASID=AID
*       ADDRSAVE=P;                 /* SAVE ADDR OF SLE        Y02014*/
         L     @10,P(,REG1)                                        0560
         ST    @10,ADDRSAVE                                        0560
*       GO TO INVALSLE;             /* CHECK OUT SLE           Y02014*/
         B     INVALSLE                                            0561
*     END;                          /*                         Y02014*/
*   REG2=ADDRSAVE+DISP19;           /* ADD OFFSET TO BCB ADDR  Y02014*/
@RF00556 L     REG2,ADDRSAVE                                       0563
         AL    REG2,DISP19                                         0563
*   GEN(BRREAD (R2),DATA,ASID=AID); /* READ FOR BCB PTR        Y02014*/
         BRREAD (R2),DATA,ASID=AID
*   ADDRSAVE=P;                     /* SAVE BCB ADDRESS        Y02014*/
         L     @10,P(,REG1)                                        0565
         ST    @10,ADDRSAVE                                        0565
*   GO TO BCBVAL;                   /* GO CHECK OUT BCB        Y02014*/
         B     BCBVAL                                              0566
*NEXTSABF:                          /*                         Y02014*/
*   IF THATSALL='1'B THEN           /* ALL AREAS FORMATTED     Y02014*/
NEXTSABF TM    THATSALL,B'01000000'                                0567
         BO    @RT00567                                            0567
*     GO TO GETFINAL;               /* GO CLEAN UP             Y02014*/
*   REG2=ADDRSAVE+DISP20;           /* GET CHAIN PTR           Y02014*/
         L     REG2,ADDRSAVE                                       0569
         AL    REG2,DISP20                                         0569
*   GEN(BRREAD (R2),DATA,ASID=AID); /* READ FOR GTFBLOK ADDR   Y02014*/
         BRREAD (R2),DATA,ASID=AID
*   ADDRSAVE=P;                     /* SAVE GTFBLOK ADDR       Y02014*/
         L     @10,P(,REG1)                                        0571
         ST    @10,ADDRSAVE                                        0571
*   EIOCUR=ADDRSAVE;                /* SAVE ADDR FOR COMPARISON    0572
*                                                              Y02014*/
         ST    @10,EIOCUR                                          0572
*   CALL IDCHECK;                   /* CHECK FOR VALID ID      Y02014*/
         BAL   @14,IDCHECK                                         0573
*   COUNT=COUNT+1;                  /* COUNT OF BLOKS FORMATTED    0574
*                                                              Y02014*/
         LA    @10,1                                               0574
         AL    @10,COUNT                                           0574
         ST    @10,COUNT                                           0574
*   GO TO NEWSABUF;                 /* PROCESS NEW GTFBLOK     Y02014*/
         B     NEWSABUF                                            0575
*                                                                  0576
*/************************************************************ Y02014*/
*/*      BUFFER DUMPING ROUTINE                                Y02014*/
*/************************************************************ Y02014*/
*                                                                  0576
*HEXBUFDP:                          /*                         Y02014*/
*   RFY                                                            0576
*    (REG2) RSTD;                   /*                         Y02014*/
HEXBUFDP DS    0H                                                  0577
*   FIRSTHSW='0'B;                  /* FIRST TIME SWITCH       Y02014*/
         NI    FIRSTHSW(AEDITCBR),B'11101111'                      0577
*   REG2=ADDRSAVE+DISP14;           /* ADD OFFSET TO AREA      Y02014*/
         L     REG2,ADDRSAVE                                       0578
         AL    REG2,DISP14                                         0578
*   GEN(BRREAD (R2),DATA,ASID=AID); /* READ IN BIG LL FIELD    Y02014*/
         BRREAD (R2),DATA,ASID=AID
*   EIOLL=LL;                       /* SAVE BIG LL VALUE       Y02014*/
         LH    @10,LL(,REG1)                                       0580
         STH   @10,EIOLL                                           0580
*READAGAN:                          /*                         Y02014*/
*   LLSTORE=EIOLL;                  /* SAVE LL VALUE           Y02014*/
READAGAN LH    @10,EIOLL                                           0581
         LR    LLSTORE,@10                                         0581
*   EIOLL=EIOLL-32;                 /* PRINT 32 BYTES A TIME   Y02014*/
         SL    @10,@CF00122                                        0582
         STH   @10,EIOLL                                           0582
*   IF EIOLL>=0 THEN                /* A FULL LINE TO PRINT    Y02014*/
         SLR   @08,@08                                             0583
         CR    @10,@08                                             0583
         BL    @RF00583                                            0583
*     DO;                           /*                         Y02014*/
*       DO I=0 TO 7;                /* 8 READS FOR 32 BYTES    Y02014*/
         LR    I,@08                                               0585
@DL00585 DS    0H                                                  0586
*         GEN(BRREAD (R2),DATA,ASID=AID);/* READ IN 4 BYTES    Y02014*/
         BRREAD (R2),DATA,ASID=AID
*         K=(I*4)+1;                /* COMPUTE OFFSET          Y02014*/
         LR    @10,I                                               0587
         SLA   @10,2                                               0587
         AL    @10,@CF00076                                        0587
         STH   @10,K                                               0587
*         HEXLINE(K:K+3)=TWORD;     /* MOVE BYTES INTO BUFFER  Y02014*/
         L     @08,CURREC(,AEDITCBR)                               0588
         ALR   @08,@10                                             0588
         BCTR  @08,0                                               0588
         MVC   HEXLINE(4,@08),TWORD(REG1)                          0588
*         REG2=REG2+4;              /* POINT TO NEXT WORD      Y02014*/
         AL    REG2,@CF00065                                       0589
*       END;                        /*                         Y02014*/
         AL    I,@CF00076                                          0590
         C     I,@CF00087                                          0590
         BNH   @DL00585                                            0590
*     END;                          /*                         Y02014*/
*   ELSE                                                           0592
*     DO;                           /* PARTIAL LINE TO HANDLE  Y02014*/
         B     @RC00583                                            0592
@RF00583 DS    0H                                                  0593
*       EIOLL=LLSTORE;              /* RESTORE LL VALUE        Y02014*/
         STH   LLSTORE,EIOLL                                       0593
*       IF(EIOLL//4)^=0 THEN        /* LENGTH DIVISABLE BY WD  Y02014*/
         LH    @10,EIOLL                                           0594
         LR    @06,@10                                             0594
         SRDA  @06,32                                              0594
         D     @06,@CF00065                                        0594
         LTR   @06,@06                                             0594
         BZ    @RF00594                                            0594
*         EIOBRCT=(EIOLL/4)+1;      /* CALC # READS NECESSARY  Y02014*/
         LR    @06,@10                                             0595
         SRDA  @06,32                                              0595
         D     @06,@CF00065                                        0595
         LA    @07,1(,@07)                                         0595
         STH   @07,EIOBRCT                                         0595
*       ELSE                                                       0596
*         EIOBRCT=EIOLL/4;          /* CALC # READS NECESSARY  Y02014*/
         B     @RC00594                                            0596
@RF00594 LH    @06,EIOLL                                           0596
         SRDA  @06,32                                              0596
         D     @06,@CF00065                                        0596
         STH   @07,EIOBRCT                                         0596
*       DO I=0 TO EIOBRCT-1;        /* SET UP LOOP FOR READS   Y02014*/
@RC00594 SLR   I,I                                                 0597
         B     @DE00597                                            0597
@DL00597 DS    0H                                                  0598
*         GEN(BRREAD (R2),DATA,ASID=AID);/* DO READ FOR A WORD Y02014*/
         BRREAD (R2),DATA,ASID=AID
*         K=(I*4)+1;                /* CALC OFFSET IN BUFFER   Y02014*/
         LR    @10,I                                               0599
         SLA   @10,2                                               0599
         AL    @10,@CF00076                                        0599
         STH   @10,K                                               0599
*         HEXLINE(K:K+3)=TWORD;     /* MOVE WD TO BUFFER       Y02014*/
         L     @08,CURREC(,AEDITCBR)                               0600
         ALR   @08,@10                                             0600
         BCTR  @08,0                                               0600
         MVC   HEXLINE(4,@08),TWORD(REG1)                          0600
*         REG2=REG2+4;              /* POINT TO NEXT WORD      Y02014*/
         AL    REG2,@CF00065                                       0601
*       END;                        /*                         Y02014*/
         AL    I,@CF00076                                          0602
@DE00597 LH    @10,EIOBRCT                                         0602
         BCTR  @10,0                                               0602
         CR    I,@10                                               0602
         BNH   @DL00597                                            0602
*       I=EIOLL//4;                 /* CALC # OF EXTRA BYTES   Y02014*/
         LH    @06,EIOLL                                           0603
         SRDA  @06,32                                              0603
         D     @06,@CF00065                                        0603
         LR    I,@06                                               0603
*       IF I^=0 THEN                /* BLANK OUT # OF EXTRA    Y02014*/
         LTR   I,I                                                 0604
         BZ    @RF00604                                            0604
*         HEXLINE((K+I):(K+3))=BLANKS;/* BYTES READ            Y02014*/
         LH    @10,K                                               0605
         LR    @08,I                                               0605
         ALR   @08,@10                                             0605
         L     @04,CURREC(,AEDITCBR)                               0605
         ALR   @04,@08                                             0605
         BCTR  @04,0                                               0605
         SLR   @10,@08                                             0605
         AL    @10,@CF00198                                        0605
         EX    @10,@SM01574                                        0605
*       EIOLL=0;                    /* NO MORE TO FORMAT       Y02014*/
@RF00604 SLR   @10,@10                                             0606
         STH   @10,EIOLL                                           0606
*     END;                          /*                         Y02014*/
*   CALL PRHEX;                     /* GO DUMP BYTES IN HEX    Y02014*/
@RC00583 L     @10,AFRMAD(,AEDITCBR)                               0608
         L     @15,AHEX(,@10)                                      0608
         BALR  @14,@15                                             0608
*   IF EIOLL>0 THEN                 /* MORE BUFFER TO DUMP     Y02014*/
         LH    @10,EIOLL                                           0609
         LTR   @10,@10                                             0609
         BP    @RT00609                                            0609
*     GO TO READAGAN;               /* GO DUMP NEXT LINE       Y02014*/
*   GO TO NEXTSABF;                 /* GO GET NEXT GTFBLOK     Y02014*/
         B     NEXTSABF                                            0611
*                                                                  0612
*/********************************************************************
*                                                                    */
*/*                                                                  */
*/*  ERROR DURING BUFFER LOCATING PROCEDURE                          */
*/*                                                                  */
*/********************************************************************
*                                                                    */
*                                                                  0612
*DUMPER:                                                           0612
*   GEN;                                                           0612
DUMPER   DS    0H                                                  0612
         USING *,R15            /* TEMPORARYILY BASE ON REG 15 - EP  */
*                               /* ADDRESS                           */
         LA    R13,@SA00001     /* POINT TO SAVE AREA          Y02014*/
*                               /* *** DEPENDENT ON BSL NAMING ***   */
         LM    R14,R12,12(R13)     RELOAD REGISTERS
         DROP  R15                 GO BACK TO BSL-S BASE
*CHAINERR:                          /*                         Y02014*/
*   I=39;                           /* LENGTH OF MESSAGE       Y02014*/
CHAINERR LA    I,39                                                0613
*   REG2=ADDR(DUMPERTM);            /* POINT TO DUMP ERROR MESSAGE   */
         LA    REG2,DUMPERTM                                       0614
*/* BRANCH HERE TO PRINT TERMINAL ERROR MESSAGE AND TERMINATE EDIT   */
*                                                                  0615
*WRITERR:                                                          0615
*   GEN(BRWRITE  SKIP);             /* SKIP TO NEW PAGE              */
*                                                                  0615
WRITERR  BRWRITE  SKIP
*   /*****************************************************************/
*   /*                                                               */
*   /* MOVE MESSAGE TO OUTPUT AREA                                   */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0616
*   OUTBUF(1:I)=COMNTTXT(1:I);                                     0616
         L     @10,CURBUF                                          0616
         LR    @08,I                                               0616
         BCTR  @08,0                                               0616
         EX    @08,@SM01576                                        0616
*   GEN(BRWRITE  1);                /* WRITE MESSAGE ON PRINTER DATA
*                                      SET                           */
         BRWRITE  1
*   GO TO GETFREE;                  /* GO TO EOF HANDLER TO CLOSE  0618
*                                      GOWN GET OPERATION            */
         B     GETFREE                                             0618
*                                                                  0619
*/********************************************************************/
*/*      ROUTINE TO VALIDITY CHECK                                   */
*/*          CONTROL BLOCK IDS                                 Y02014*/
*/********************************************************************/
*                                                                  0619
*IDCHECK:                                                          0619
*   PROC;                                                          0619
IDCHECK  STM   @14,@12,@SA00002                                    0619
*   REG2=ADDRSAVE;                  /* PICK UP PTR TO TABLE    Y02014*/
         L     REG2,ADDRSAVE                                       0620
*   GEN(BRREAD (R2),DATA,ASID=AID); /* READ FOR 1ST 4 BYTES    Y02014*/
         BRREAD (R2),DATA,ASID=AID
*   IDHOLD1=TABLEID;                /* SAVE 1ST 4 BYTES        Y02014*/
         MVC   IDHOLD1(4),TABLEID(REG1)                            0622
*   REG2=ADDRSAVE+4;                /* PT TO 2ND 4 BYTES       Y02014*/
         LA    REG2,4                                              0623
         AL    REG2,ADDRSAVE                                       0623
*   GEN(BRREAD (R2),DATA,ASID=AID); /* READ FOR 2ND 4 BYTES    Y02014*/
         BRREAD (R2),DATA,ASID=AID
*   IDHOLD2=TABLEID;                /* SAVE 2ND 4 BYTES        Y02014*/
         MVC   IDHOLD2(4),TABLEID(REG1)                            0625
*   IF ID^=IDVALID THEN             /* IS THIS VALID ID        Y02014*/
         CLC   ID(8),IDVALID                                       0626
         BNE   @RT00626                                            0626
*     GO TO CHAINERR;               /* NO WRITE ERR MSG        Y02014*/
*   END;                            /* END OF PROC             Y02014*/
@EL00002 DS    0H                                                  0628
@EF00002 DS    0H                                                  0628
@ER00002 LM    @14,@12,@SA00002                                    0628
         BR    @14                                                 0628
*   END AMDPRGET                                                   0629
*                                                                  0629
*/* THE FOLLOWING INCLUDE STATEMENTS WERE FOUND IN THIS PROGRAM.     */
*/*%INCLUDE SYSLIB  (AMDPRTAB)                                       */
*/*%INCLUDE SYSLIB  (IHAASCB )                                       */
*/*%INCLUDE SYSLIB  (CVT     )                                       */
*/*%INCLUDE SYSLIB  (MCHEAD  )                                       */
*/*%INCLUDE SYSLIB  (MCCE    )                                       */
*/*%INCLUDE SYSLIB  (MCQE    )                                       */
*/*%INCLUDE SYSLIB  (GTFPCT  )                                       */
*/*%INCLUDE SYSLIB  (SLE     )                                       */
*/*%INCLUDE SYSLIB  (GTFBLOK )                                       */
*/*%INCLUDE SYSLIB  (GTFBCB  )                                       */
*                                                                  0629
*       ;                                                          0629
@DATA    DS    0H
@CH01482 DC    H'4000'
@SM01571 MVC   TRECFINL(0,@10),BULDAREA-1(@08)
@SM01574 MVC   HEXLINE(0,@04),BLANKS
@SM01576 MVC   OUTBUF(0,@10),COMNTTXT(REG2)
         DS    0F
@SA00001 DS    18F
@SA00002 DS    15F
         DS    0F
@CF00076 DC    F'1'
@CF00109 DC    F'2'
@CF00198 DC    F'3'
@CH00198 EQU   @CF00198+2
@CF00065 DC    F'4'
@CF00087 DC    F'7'
@CF00039 DC    F'8'
@CH00039 EQU   @CF00039+2
@CF00122 DC    F'32'
@CF01251 DC    F'53'
@CF01539 DC    F'255'
@CF01337 DC    F'284'
@CF01192 DC    F'4096'
@CF01483 DC    XL4'01000000'
@CF01537 DC    XL4'FFFFFFFC'
@CF01538 DC    XL4'00000003'
@CF01570 DC    XL4'0000FFFF'
         DS    0D
ASCBPTR  DS    A
CVTPTR   DS    A
PCTPTR   DS    A
DISP1    DC    AL4(CVTGTF-CVT)
DISP2    DC    AL4(MCHCUR-MCHEAD)
DISP3    DC    AL4(MCCEQEA-MCCE)
DISP4    DC    AL4(MCQENAME-MCQE)
DISP5    DC    AL4(MCQEMCQE-MCQE)
DISP6    DC    AL4(MCQEAT-MCQE)
DISP7    DC    AL4(HQLENGTH-GTFPCT)
DISP8    DC    AL4(HQHEAD-GTFPCT)
DISP9    DC    AL4(GBUFRPTR-GTFBCB)
DISP10   DC    AL4(BCBCHAIN-GTFBCB)
DISP11   DC    AL4(CURRBLOK-GTFPCT)
DISP12   DC    AL4(NEXTBLOK-GTFPCT)
DISP13   DC    AL4(BLOKUSE-GTFBLOK)
DISP14   DC    AL4(BLOKAREA-GTFBLOK)
DISP15   DC    AL4(SLQHEAD-GTFPCT)
DISP16   DC    AL4(SLEASID-SLE)
DISP17   DC    AL4(SLETCBA-SLE)
DISP18   DC    AL4(SLQCHAIN-SLE)
DISP19   DC    AL4(SLEBCBQ-SLE)
DISP20   DC    AL4(BLKCHAIN-GTFBLOK)
DISP21   DC    AL4(GTFASCB-GTFPCT)
DISP22   DC    AL4(ASCBASID-ASCB)
ADDRSAVE DS    A
BUFFCNT  DS    F
BUFPTR   DS    A
RECPTR   DS    A
PCTSAVE  DS    A
ZERO     DC    XL4'00'
ADDRMASK DC    XL4'00FFFFFF'
COUNT    DC    F'0'
K        DS    H
TWO84    DC    H'284'
AID      DC    AL2(0)
@CC01502 DC    C'        '
@CC01530 DC    C'GTFBLOK'
@CC01507 DC    C'MCHEAD'
@CC01515 DC    C'GTFPCT'
@CC01518 DC    C'GTFBCB'
@CC01509 DC    C'MCCE'
@CC01510 DC    C'MCQE'
@CC01514 DC    C'GTF '
@CC01541 DC    C'SLE'
@CB01261 DC    X'00000000'
SRB      DS    CL4
         DS    CL2
EIOCTL   DS    CL48
         ORG   EIOCTL
EIOFLGS  DC    X'00000000'
         ORG   EIOFLGS
FIRSTGET DS    BL1
OPENFAIL EQU   EIOFLGS+0
DAWRAP   EQU   EIOFLGS+0
PSITWRAP EQU   EIOFLGS+0
FRSTWRAP EQU   EIOFLGS+0
CLOSE    EQU   EIOFLGS+0
SYNADSW  EQU   EIOFLGS+0
         ORG   EIOCTL+4
EIOSTOR  DS    FL4
EIOVARIB DS    CL40
         ORG   EIOCTL+48
BUFADDR  DS    CL8
         ORG   BUFADDR
BUFFER   DS    AL4
BUFL     DS    AL4
         ORG   BUFADDR+8
LNGTH    DS    CL8
         ORG   LNGTH
LNGTH1   DS    AL4
LNGTH2   DS    AL4
         ORG   LNGTH+8
ERMSG    DC    CL12'I/O ERROR ON'
LLERR    DC    CL53'TRACE RECORD LL INVALID, DD XXXXXXXX  BLOCK NO XXXXC
               XX'
TERMSG   DC    CL38'- EDIT PROCESSING TERMINATED'
CONMSG   DC    CL12'- CONTINUING'
NOTACMSG DC    CL30'GTF NOT ACTIVE AT TIME OF DUMP'
DUMPERCN DC    CL49'ERROR IN GTF BUFFER - CONTINUING WITH NEXT BUFFER'
DUMPERTM DC    CL39'ERROR IN GTF BUFFER CONTROL BLOCK CHAIN'
GETPTCH  DC    CL200'GETPTCH'
IDVALID  DS    CL8
ID       DS    CL8
         ORG   ID
IDHOLD1  DS    CL4
IDHOLD2  DS    CL4
         ORG   ID+8
GETSWITS DC    B'00000000'
         ORG   GETSWITS
BLOKPROC DS    BL1
THATSALL EQU   GETSWITS+0
@NM00024 EQU   GETSWITS+0
         ORG   GETSWITS+1
@00      EQU   00                      EQUATES FOR REGISTERS 0-15
@01      EQU   01
@02      EQU   02
@03      EQU   03
@04      EQU   04
@05      EQU   05
@06      EQU   06
@07      EQU   07
@08      EQU   08
@09      EQU   09
@10      EQU   10
@11      EQU   11
@12      EQU   12
@13      EQU   13
@14      EQU   14
@15      EQU   15
LLSTORE  EQU   @03
GTFASID  EQU   @03
ASCBGTF  EQU   @03
ASIDHOLD EQU   @03
J        EQU   @06
I        EQU   @03
AEDITCBR EQU   @09
REG0     EQU   @00
REG1     EQU   @01
REG2     EQU   @02
REG8     EQU   @08
REG14    EQU   @14
REG15    EQU   @15
COMMONRG EQU   @12
PRTABREG EQU   @09
         ENTRY GETPTCH
AMDPRTAB EQU   0
AFMG     EQU   AMDPRTAB
CURREC   EQU   AMDPRTAB+4
DEBGFLGS EQU   AMDPRTAB+8
PTHFLGS1 EQU   DEBGFLGS
GET      EQU   PTHFLGS1
PTHFLGS2 EQU   DEBGFLGS+1
INRFCFGS EQU   DEBGFLGS+2
TERM     EQU   INRFCFGS
EXTTRC   EQU   INRFCFGS
IOFLGS   EQU   DEBGFLGS+3
GETEOF   EQU   IOFLGS
USEREXIT EQU   AMDPRTAB+24
DDNAME   EQU   AMDPRTAB+32
STARTIME EQU   AMDPRTAB+40
STOPTIME EQU   AMDPRTAB+52
NAMES    EQU   AMDPRTAB+64
ADS      EQU   AMDPRTAB+104
AADS     EQU   ADS
SIF      EQU   AMDPRTAB+124
SIOFLGS  EQU   SIF
DVADS1   EQU   AMDPRTAB+128
IO       EQU   AMDPRTAB+228
IOFLGS2  EQU   IO
DVADS2   EQU   AMDPRTAB+232
VCF      EQU   AMDPRTAB+332
SVCFLGS  EQU   VCF
USR      EQU   AMDPRTAB+368
USRFLGS  EQU   USR
USRTAB   EQU   AMDPRTAB+372
PI       EQU   AMDPRTAB+452
PIFLGS   EQU   PI
PGMNGEN  EQU   AMDPRTAB+456
GENFLAGS EQU   PGMNGEN+3
EOF      EQU   GENFLAGS
GENFLGS1 EQU   AMDPRTAB+460
EOFINPRO EQU   GENFLGS1
TSFOUND  EQU   GENFLGS1
FIRSTHSW EQU   GENFLGS1
RECDLL   EQU   AMDPRTAB+461
AEIOCT   EQU   AMDPRTAB+476
AFRMAD   EQU   AMDPRTAB+488
ESTARTME EQU   AMDPRTAB+500
ESTOPTME EQU   AMDPRTAB+509
ASCB     EQU   0
ASCBASID EQU   ASCB+36
ASCBFW1  EQU   ASCB+100
ASCBRCTF EQU   ASCBFW1+2
ASCBFLG1 EQU   ASCBFW1+3
ASCBDSP1 EQU   ASCB+114
ASCBFLG2 EQU   ASCB+115
CVTMAP   EQU   0
CVT      EQU   CVTMAP
CVTDAR   EQU   CVTMAP+72
CVTFLGS1 EQU   CVTDAR
CVTDCB   EQU   CVTMAP+116
CVTIOQET EQU   CVTMAP+120
CVTIERLC EQU   CVTMAP+144
CVTHEAD  EQU   CVTMAP+160
CVTSV76C EQU   CVTHEAD
CVTOPTA  EQU   CVTMAP+182
CVTOPTB  EQU   CVTMAP+183
CVTGTF   EQU   CVTMAP+236
CVTGTFST EQU   CVTGTF
CVTGTFS  EQU   CVTGTFST
CVTSTATE EQU   CVTGTFST
CVTTMODE EQU   CVTGTFST
CVTFORM  EQU   CVTGTFST
CVTGTFA  EQU   CVTGTF+1
CVTAQAVT EQU   CVTMAP+240
CVTTCMFG EQU   CVTAQAVT
CVTVOLM2 EQU   CVTMAP+244
CVTTATA  EQU   CVTVOLM2
CVTTSKS  EQU   CVTTATA
CVTVOLF2 EQU   CVTTSKS
CVTTAT   EQU   CVTTATA+1
CVTATER  EQU   CVTMAP+248
CVTEXT1  EQU   CVTMAP+252
CVTPURG  EQU   CVTMAP+260
CVTQMSG  EQU   CVTMAP+268
CVTDMSR  EQU   CVTMAP+272
CVTRSV37 EQU   CVTDMSR
CVTDMSRF EQU   CVTRSV37
CVTERPV  EQU   CVTMAP+316
CVTINTLA EQU   CVTMAP+320
CVTAPF   EQU   CVTMAP+324
CVTEXT2  EQU   CVTMAP+328
CVTHJES  EQU   CVTMAP+332
CVTPGSIA EQU   CVTMAP+348
CVTA1F1  EQU   CVTMAP+356
CVTSYSK  EQU   CVTMAP+357
CVTVOLM1 EQU   CVTMAP+380
CVTVOLF1 EQU   CVTVOLM1
CVTATMCT EQU   CVTMAP+388
CVTXTNT1 EQU   0
CVTXTNT2 EQU   0
CVTDSSV  EQU   CVTXTNT2
CVTFLGBT EQU   CVTXTNT2+5
CVTQID   EQU   CVTXTNT2+24
CVTRV400 EQU   CVTXTNT2+52
CVTRV409 EQU   CVTXTNT2+53
CVTATCVT EQU   CVTXTNT2+64
CVTRV429 EQU   CVTXTNT2+84
CVTRV438 EQU   CVTXTNT2+85
CVTRV457 EQU   CVTXTNT2+112
CVTRV466 EQU   CVTXTNT2+113
CVTFIX   EQU   0
CVTRELNO EQU   CVTFIX+252
MCHEAD   EQU   0
MCHCUR   EQU   MCHEAD+8
MCHFLGS  EQU   MCHEAD+24
MCHFLG1  EQU   MCHFLGS
MCCE     EQU   0
MCCEQEA  EQU   MCCE+16
MCQE     EQU   0
MCQENAME EQU   MCQE+8
MCQEMCQE EQU   MCQE+20
MCQEAT   EQU   MCQE+32
MCQEFLGS EQU   MCQE+41
GTFPCT   EQU   0
GTFSTAT  EQU   GTFPCT+8
GTFOPTS  EQU   GTFPCT+12
GTFOPTS1 EQU   GTFOPTS
GTFOPTS2 EQU   GTFOPTS+1
GTFOPTS3 EQU   GTFOPTS+2
GTFOPTS4 EQU   GTFOPTS+3
PCTCATF  EQU   GTFPCT+16
HQHEAD   EQU   GTFPCT+132
HQLENGTH EQU   GTFPCT+140
SLQHEAD  EQU   GTFPCT+144
NEXTBLOK EQU   GTFPCT+180
CURRBLOK EQU   GTFPCT+184
WRTRCOM  EQU   GTFPCT+204
TRMWRIT  EQU   GTFPCT+212
WRTRERR  EQU   GTFPCT+216
GTFSSRB  EQU   GTFPCT+220
QLOCKWRD EQU   GTFPCT+236
QLOCKECB EQU   GTFPCT+240
AUDITFLG EQU   GTFPCT+296
GTFASCB  EQU   GTFPCT+300
SLE      EQU   0
SLQCHAIN EQU   SLE+8
SLEHOOK  EQU   SLE+12
SLEDUMP  EQU   SLEHOOK+2
SLEASID  EQU   SLEDUMP
SLETCBA  EQU   SLEDUMP+2
SLEPGLST EQU   SLE+20
SLEBCBQ  EQU   SLE+24
SLEFLAGS EQU   SLE+32
SVCPLIST EQU   0
PAGELIST EQU   SVCPLIST+4
GTFBLOK  EQU   0
BLKCHAIN EQU   GTFBLOK+8
BLOKAREA EQU   GTFBLOK+12
BLOKUSE  EQU   BLOKAREA+2
GTFBCB   EQU   0
BCBSWAP  EQU   GTFBCB+8
BCBQFLAG EQU   BCBSWAP
BCBCHAIN EQU   GTFBCB+12
HQCHAIN  EQU   BCBCHAIN
WQCHAIN  EQU   HQCHAIN
EQCHAIN  EQU   WQCHAIN
RQCHAIN  EQU   EQCHAIN
GBUFRPTR EQU   GTFBCB+16
GTFBUFR  EQU   0
CMPWKA   EQU   0
SWAPBCB  EQU   CMPWKA+4
@NM00017 EQU   SWAPBCB
FRMATAB  EQU   0
AGET     EQU   FRMATAB
AHEX     EQU   FRMATAB+4
ACON     EQU   FRMATAB+8
AFLT     EQU   FRMATAB+12
AAPP     EQU   FRMATAB+16
AEXT     EQU   FRMATAB+20
ASPI     EQU   FRMATAB+28
ATME     EQU   FRMATAB+32
PRHEX    EQU   0
PREXT    EQU   0
AMDPRE11 EQU   52
RECMAP   EQU   0
RECLL    EQU   RECMAP
RECAID   EQU   RECMAP+4
RECFID   EQU   RECMAP+5
RECTIME  EQU   RECMAP+6
RECTOD   EQU   RECTIME
TRECBULD EQU   0
TRECFINL EQU   TRECBULD
BULDAREA EQU   TRECBULD+284
TWORD    EQU   0
CVTGTFM  EQU   0
CVTGTFFG EQU   CVTGTFM
CVTGTFAT EQU   CVTGTFFG
AMDPRE01 EQU   0
MSGAD    EQU   0
MSGTEXT  EQU   4
COMNTTXT EQU   0
SYNADBUF EQU   50
OUTBUF   EQU   1
P        EQU   0
P2       EQU   P
LL       EQU   0
HALFLL   EQU   0
TABLEID  EQU   0
GTFBUF   EQU   0
BLL      EQU   GTFBUF
RECORD   EQU   0
LLL      EQU   RECORD
USECNT   EQU   0
ASIDCOMP EQU   0
TCBHOLD  EQU   0
HEXLINE  EQU   0
PRAPP    EQU   0
PRCON    EQU   0
PRFLT    EQU   0
PRGET    EQU   0
PRSPI    EQU   0
PRTME    EQU   0
CVTS01   EQU   CVTPGSIA
CVTLPDIA EQU   CVTS01+12
CVTDIRST EQU   CVTLPDIA
CVTSLIDA EQU   CVTS01+24
CVTCTLFG EQU   CVTS01+50
CVTRV210 EQU   CVTS01+424
CVTRV219 EQU   CVTS01+425
CVTRV228 EQU   CVTS01+426
CVTRV237 EQU   CVTS01+427
CVTMFRTR EQU   CVTS01+452
CVTRV262 EQU   CVTS01+468
CVTRV271 EQU   CVTS01+469
CVTRV280 EQU   CVTS01+470
CVTRV289 EQU   CVTS01+471
CVTGSDA  EQU   CVTS01+600
EIOEXT   EQU   EIOVARIB
EIOTIME  EQU   EIOEXT
EIOTOD   EQU   EIOTIME
EIOERCT  EQU   EIOEXT+8
EIODEV   EQU   EIOEXT+12
EIODCB   EQU   EIOEXT+20
EIODCBEX EQU   EIOEXT+24
EIOX1    EQU   EIODCBEX
EIOR14SV EQU   EIOEXT+32
EIODUMP  EQU   EIOVARIB
EIOSTOP  EQU   EIODUMP
EIOCUR   EQU   EIODUMP+4
EIOREC   EQU   EIODUMP+8
EIOLL    EQU   EIODUMP+12
EIOBRCT  EQU   EIODUMP+14
EIOBR    EQU   EIODUMP+16
EIORECLL EQU   EIODUMP+18
EIOERR   EQU   EIODUMP+32
LLVAL    EQU   RECLL
SWS      EQU   SWF
SADMP    EQU   SWS
BLDAREA  EQU   BUFFER
BLOKSWAP EQU   BLKCHAIN
         AGO   .@UNREFD                START UNREFERENCED COMPONENTS
@NM00021 EQU   SWS
@NM00020 EQU   SWS
EIORES4  EQU   EIODUMP+36
EIORES3  EQU   EIODUMP+20
EIOPICA  EQU   EIOEXT+28
EIOX2    EQU   EIODCBEX+1
EIORES2  EQU   EIOEXT+10
CVTRV628 EQU   CVTS01+728
CVTRV627 EQU   CVTS01+724
CVTRV626 EQU   CVTS01+720
CVTRV625 EQU   CVTS01+716
CVTRV624 EQU   CVTS01+712
CVTRV623 EQU   CVTS01+708
CVTRV622 EQU   CVTS01+704
CVTRV621 EQU   CVTS01+700
CVTIHASU EQU   CVTS01+696
CVTRV619 EQU   CVTS01+692
CVTRV618 EQU   CVTS01+688
CVTRV617 EQU   CVTS01+684
CVTRV616 EQU   CVTS01+680
CVTRV615 EQU   CVTS01+676
CVTRV614 EQU   CVTS01+672
CVTRV613 EQU   CVTS01+668
CVTTCASP EQU   CVTS01+664
CVT0PT03 EQU   CVTS01+660
CVT0PT0E EQU   CVTS01+656
CVTRV609 EQU   CVTS01+652
CVTCGK   EQU   CVTS01+648
CVTRAC   EQU   CVTS01+644
CVTHSM   EQU   CVTS01+640
CVTRV605 EQU   CVTS01+636
CVTRV604 EQU   CVTS01+632
CVTEFF02 EQU   CVTS01+628
CVTCBBR  EQU   CVTS01+624
CVTSSCR  EQU   CVTS01+620
CVTEVENT EQU   CVTS01+616
CVTCRCA  EQU   CVTS01+612
CVTTPIO  EQU   CVTS01+608
CVTADV   EQU   CVTS01+604
CVTGSDAB EQU   CVTGSDA
CVTQV3   EQU   CVTS01+596
CVTQV2   EQU   CVTS01+592
CVTQV1   EQU   CVTS01+588
CVTRPT   EQU   CVTS01+584
CVTSSRB  EQU   CVTS01+580
CVTCSDRL EQU   CVTS01+576
CVTEXP1  EQU   CVTS01+572
CVTRMPMT EQU   CVTS01+568
CVTRMPTT EQU   CVTS01+564
CVTVPSA  EQU   CVTS01+560
CVTVSTOP EQU   CVTS01+556
CVTGTFR8 EQU   CVTS01+552
CVTQUIT  EQU   CVTS01+548
CVTVACR  EQU   CVTS01+544
CVTWTCB  EQU   CVTS01+540
CVTSTPRS EQU   CVTS01+536
CVT0PT02 EQU   CVTS01+532
CVTDARCM EQU   CVTS01+528
CVTIRECM EQU   CVTS01+524
CVTJRECM EQU   CVTS01+520
CVTVEMS0 EQU   CVTS01+516
CVTSPFRR EQU   CVTS01+512
CVTRLSTG EQU   CVTS01+508
CVT0TC0A EQU   CVTS01+504
CVTGMBR  EQU   CVTS01+500
CVTLFRM  EQU   CVTS01+496
CVTRMBR  EQU   CVTS01+492
CVTVIOP  EQU   CVTS01+488
CVTRV307 EQU   CVTS01+486
CVTRV306 EQU   CVTS01+484
CVTRV305 EQU   CVTS01+482
CVTRV304 EQU   CVTS01+480
CVTRV303 EQU   CVTS01+478
CVTRV302 EQU   CVTS01+476
CVTTRCA  EQU   CVTS01+472
CVTRV297 EQU   CVTRV289
CVTRV296 EQU   CVTRV289
CVTRV295 EQU   CVTRV289
CVTRV294 EQU   CVTRV289
CVTRV293 EQU   CVTRV289
CVTRV292 EQU   CVTRV289
CVTRV291 EQU   CVTRV289
CVTRV290 EQU   CVTRV289
CVTRV288 EQU   CVTRV280
CVTRV287 EQU   CVTRV280
CVTRV286 EQU   CVTRV280
CVTRV285 EQU   CVTRV280
CVTRV284 EQU   CVTRV280
CVTRV283 EQU   CVTRV280
CVTRV282 EQU   CVTRV280
CVTRV281 EQU   CVTRV280
CVTRV279 EQU   CVTRV271
CVTRV278 EQU   CVTRV271
CVTRV277 EQU   CVTRV271
CVTRV276 EQU   CVTRV271
CVTRV275 EQU   CVTRV271
CVTRV274 EQU   CVTRV271
CVTRV273 EQU   CVTRV271
CVTRV272 EQU   CVTRV271
CVTRV270 EQU   CVTRV262
CVTRV269 EQU   CVTRV262
CVTRV268 EQU   CVTRV262
CVTRV267 EQU   CVTRV262
CVTRV266 EQU   CVTRV262
CVTRV265 EQU   CVTRV262
CVTRV264 EQU   CVTRV262
CVTRV263 EQU   CVTRV262
CVTVFP   EQU   CVTS01+464
CVTVSI   EQU   CVTS01+460
CVTVPSIB EQU   CVTS01+456
CVTMFACT EQU   CVTMFRTR
CVTMFCTL EQU   CVTS01+448
CVTPVBP  EQU   CVTS01+444
CVTPWI   EQU   CVTS01+440
CVTRV254 EQU   CVTS01+438
CVTRV253 EQU   CVTS01+436
CVTRV252 EQU   CVTS01+434
CVTRV251 EQU   CVTS01+433
CVTRV250 EQU   CVTS01+432
CVTRV249 EQU   CVTS01+431
CVTRV248 EQU   CVTS01+430
CVTRV247 EQU   CVTS01+429
CVTRV246 EQU   CVTS01+428
CVTRV245 EQU   CVTRV237
CVTRV244 EQU   CVTRV237
CVTRV243 EQU   CVTRV237
CVTRV242 EQU   CVTRV237
CVTRV241 EQU   CVTRV237
CVTRV240 EQU   CVTRV237
CVTRV239 EQU   CVTRV237
CVTRV238 EQU   CVTRV237
CVTRV236 EQU   CVTRV228
CVTRV235 EQU   CVTRV228
CVTRV234 EQU   CVTRV228
CVTRV233 EQU   CVTRV228
CVTRV232 EQU   CVTRV228
CVTRV231 EQU   CVTRV228
CVTRV230 EQU   CVTRV228
CVTRV229 EQU   CVTRV228
CVTRV227 EQU   CVTRV219
CVTRV226 EQU   CVTRV219
CVTRV225 EQU   CVTRV219
CVTRV224 EQU   CVTRV219
CVTRV223 EQU   CVTRV219
CVTRV222 EQU   CVTRV219
CVTRV221 EQU   CVTRV219
CVTRV220 EQU   CVTRV219
CVTRV218 EQU   CVTRV210
CVTRV217 EQU   CVTRV210
CVTRV216 EQU   CVTRV210
CVTRV215 EQU   CVTRV210
CVTRV214 EQU   CVTRV210
CVTRV213 EQU   CVTRV210
CVTRV212 EQU   CVTRV210
CVTRV211 EQU   CVTRV210
CVTLCCAT EQU   CVTS01+420
CVTPCCAT EQU   CVTS01+416
CVTIPCRP EQU   CVTS01+412
CVTIPCRI EQU   CVTS01+408
CVTIPCDS EQU   CVTS01+404
CVTAIDVT EQU   CVTS01+400
CVTSSAP  EQU   CVTS01+396
CVTEHCIR EQU   CVTS01+392
CVTEHDEF EQU   CVTS01+388
CVTDAIR  EQU   CVTS01+384
CVTPERFM EQU   CVTS01+380
CVT044R2 EQU   CVTS01+376
CVTFETCH EQU   CVTS01+372
CVTRSTWD EQU   CVTS01+368
CVTSPOST EQU   CVTS01+364
CVTIOBP  EQU   CVTS01+360
CVTASMVT EQU   CVTS01+356
CVTRECRQ EQU   CVTS01+352
CVTWSAC  EQU   CVTS01+348
CVTRV149 EQU   CVTS01+344
CVTWSAL  EQU   CVTS01+340
CVTSPSA  EQU   CVTS01+336
CVTGLMN  EQU   CVTS01+332
CVTVEAC0 EQU   CVTS01+328
CVT062R1 EQU   CVTS01+324
CVTRPOST EQU   CVTS01+320
CVTDQIQE EQU   CVTS01+316
CVTCSD   EQU   CVTS01+312
CVTLKRMA EQU   CVTS01+308
CVTRSPIE EQU   CVTS01+304
CVTRENQ  EQU   CVTS01+300
CVTLQCB  EQU   CVTS01+296
CVTFQCB  EQU   CVTS01+292
CVTQCS01 EQU   CVTS01+288
CVTAPFT  EQU   CVTS01+284
CVTPARRL EQU   CVTS01+280
CVTVWAIT EQU   CVTS01+276
CVTGSPL  EQU   CVTS01+272
CVTLSMQ  EQU   CVTS01+268
CVTGSMQ  EQU   CVTS01+264
CVTEXPRO EQU   CVTS01+260
CVTOPCTP EQU   CVTS01+256
CVTSIC   EQU   CVTS01+252
CVTTPIOS EQU   CVTS01+248
CVTRTMS  EQU   CVTS01+244
CVTSDBF  EQU   CVTS01+240
CVTSCBP  EQU   CVTS01+236
CVTSDMP  EQU   CVTS01+232
CVTSV60  EQU   CVTS01+228
CVTRTMCT EQU   CVTS01+224
CVTASCBL EQU   CVTS01+220
CVTASCBH EQU   CVTS01+216
CVTGDA   EQU   CVTS01+212
CVTASVT  EQU   CVTS01+208
CVTVVMDI EQU   CVTS01+204
CVTAQTOP EQU   CVTS01+200
CVTIOSCS EQU   CVTS01+196
CVTSDRM  EQU   CVTS01+192
CVTOPTE  EQU   CVTS01+188
CVTSTXU  EQU   CVTS01+184
CVTQUIS  EQU   CVTS01+180
CVTPARS  EQU   CVTS01+176
CVTS1EE  EQU   CVTS01+172
CVTFRAS  EQU   CVTS01+168
CVTQSAS  EQU   CVTS01+164
CVTCRAS  EQU   CVTS01+160
CVTCRMN  EQU   CVTS01+156
CVTDELCP EQU   CVTS01+152
CVTFRECL EQU   CVTS01+148
CVTGETCL EQU   CVTS01+144
CVTBLDCP EQU   CVTS01+140
CVTAUTHL EQU   CVTS01+136
CVTSCAN  EQU   CVTS01+132
CVTRV144 EQU   CVTS01+130
CVTMAXMP EQU   CVTS01+128
CVTSTCK  EQU   CVTS01+124
CVTRV139 EQU   CVTS01+123
CVTDSSAC EQU   CVTS01+122
CVTRV513 EQU   CVTS01+121
CVTIOSPL EQU   CVTS01+120
CVTPTGT  EQU   CVTS01+116
CVTCSPIE EQU   CVTS01+112
CVTSMFEX EQU   CVTS01+108
CVTOLT0A EQU   CVTS01+104
CVTSRBRT EQU   CVTS01+100
CVTPUTL  EQU   CVTS01+96
CVTASCRL EQU   CVTS01+92
CVTASCRF EQU   CVTS01+88
CVTRV326 EQU   CVTS01+84
CVTRV325 EQU   CVTS01+80
CVTRV324 EQU   CVTS01+76
CVT0VL01 EQU   CVTS01+72
CVTSHRVM EQU   CVTS01+68
CVTRV332 EQU   CVTS01+64
CVTTAS   EQU   CVTS01+60
CVTRSCN  EQU   CVTS01+56
CVTTRAC2 EQU   CVTS01+54
CVTTRACE EQU   CVTS01+52
CVTAPG   EQU   CVTS01+51
CVTSDTRC EQU   CVTCTLFG
CVTGTRCE EQU   CVTCTLFG
CVTNOMP  EQU   CVTCTLFG
CVTRSV79 EQU   CVTCTLFG
CVTDSTAT EQU   CVTCTLFG
CVTRSV78 EQU   CVTCTLFG
CVTRV333 EQU   CVTCTLFG
CVTRV323 EQU   CVTCTLFG
CVTSPVLK EQU   CVTS01+49
CVTRSV77 EQU   CVTS01+48
CVTRV331 EQU   CVTS01+44
CVTRV330 EQU   CVTS01+40
CVTRV329 EQU   CVTS01+36
CVTRV328 EQU   CVTS01+32
CVTRV322 EQU   CVTS01+28
CVTSLID  EQU   CVTSLIDA+1
CVTSYLK  EQU   CVTSLIDA
CVTRV321 EQU   CVTS01+20
CVTRV320 EQU   CVTS01+16
CVTLPDIR EQU   CVTLPDIA+1
CVTRSV69 EQU   CVTDIRST
CVTRSV68 EQU   CVTDIRST
CVTRSV67 EQU   CVTDIRST
CVTRSV66 EQU   CVTDIRST
CVTRSV65 EQU   CVTDIRST
CVTRSV64 EQU   CVTDIRST
CVTRSV63 EQU   CVTDIRST
CVTDICOM EQU   CVTDIRST
CVTPVTP  EQU   CVTS01+8
CVTLPDSR EQU   CVTS01+4
CVTGETL  EQU   CVTS01
RECDATA  EQU   RECORD+4
@NM00023 EQU   RECORD+2
@NM00022 EQU   GTFBUF+2
CVTMCHD  EQU   CVTGTFM+1
@NM00019 EQU   CVTGTFFG
RECRES1  EQU   RECMAP+2
FRMRES1  EQU   FRMATAB+36
APRFMG   EQU   FRMATAB+24
SWAPUSE  EQU   SWAPBCB+2
@NM00018 EQU   @NM00017
DECBFSWA EQU   @NM00017
RQFSWAP  EQU   @NM00017
HQFSWAP  EQU   @NM00017
SQFSWAP  EQU   @NM00017
CQFSWAP  EQU   @NM00017
WQFSWAP  EQU   @NM00017
EQFSWAP  EQU   @NM00017
COMPBCB  EQU   CMPWKA
BIGLL    EQU   GTFBUFR
BCBFREQ  EQU   GTFBCB+20
SQCHAIN  EQU   RQCHAIN
BCBUSE   EQU   BCBSWAP+2
DECBFLAG EQU   BCBQFLAG
RQFLAG   EQU   BCBQFLAG
HQFLAG   EQU   BCBQFLAG
SQFLAG   EQU   BCBQFLAG
CQFLAG   EQU   BCBQFLAG
WQFLAG   EQU   BCBQFLAG
EQFLAG   EQU   BCBQFLAG
GTFBCBID EQU   GTFBCB
BLOKLEN  EQU   BLOKAREA
BLKINUSE EQU   BLKCHAIN
BLOKID   EQU   GTFBLOK
COMMONPG EQU   PAGELIST
PLINDEX  EQU   SVCPLIST
@NM00016 EQU   SLEFLAGS
SLEINUSE EQU   SLEFLAGS
SLEQCNT  EQU   SLE+28
SLEEID   EQU   SLEHOOK
SLEID    EQU   SLE
PCTWTOMD EQU   GTFPCT+312
PCTDMPMD EQU   GTFPCT+308
TRANSMAX EQU   GTFPCT+304
@NM00015 EQU   AUDITFLG+3
AFSLEBLD EQU   AUDITFLG+3
WSERFG06 EQU   AUDITFLG+3
WSERFG05 EQU   AUDITFLG+3
WSERFG04 EQU   AUDITFLG+3
WSERFG03 EQU   AUDITFLG+3
WSERFG02 EQU   AUDITFLG+2
WSERFLAG EQU   AUDITFLG+2
TERMFLAG EQU   AUDITFLG+2
AFXWRIT  EQU   AUDITFLG+2
AFQLWAIT EQU   AUDITFLG+2
AFSLEGET EQU   AUDITFLG+2
AFBUFGET EQU   AUDITFLG+2
AFFEOB   EQU   AUDITFLG+2
AFBLKFIX EQU   AUDITFLG+1
AFEQFIX  EQU   AUDITFLG+1
AFPGRLSE EQU   AUDITFLG+1
AFWRAP   EQU   AUDITFLG+1
AFBUFOFF EQU   AUDITFLG+1
AFLDFX   EQU   AUDITFLG+1
AFCLOSE  EQU   AUDITFLG+1
AFOPEN   EQU   AUDITFLG+1
AFGMBLOK EQU   AUDITFLG
AFGMSRB  EQU   AUDITFLG
AFWAIT   EQU   AUDITFLG
AFTERM   EQU   AUDITFLG
AFINIT   EQU   AUDITFLG
AFWWRIT  EQU   AUDITFLG
AFCWRIT  EQU   AUDITFLG
AFIWRIT  EQU   AUDITFLG
EQSHORT  EQU   GTFPCT+292
SLEMAX   EQU   GTFPCT+288
SLECNT   EQU   GTFPCT+284
RQPURGE  EQU   GTFPCT+280
RQTOTAL  EQU   GTFPCT+276
WRTDLST  EQU   GTFPCT+272
NUMOFBUF EQU   GTFPCT+268
SBUFDISA EQU   GTFPCT+264
SLESUSED EQU   GTFPCT+260
EQMIN    EQU   GTFPCT+256
EQLENGTH EQU   GTFPCT+252
WQMAX    EQU   GTFPCT+248
WQLENGTH EQU   GTFPCT+244
QLECBP   EQU   QLOCKECB
@NM00014 EQU   QLOCKECB
@NM00013 EQU   QLOCKWRD+3
SCHEDBUF EQU   QLOCKWRD+2
POSTWRIT EQU   QLOCKWRD+1
QLOCK    EQU   QLOCKWRD
WRITERDD EQU   GTFPCT+228
GTFLOSTR EQU   GTFPCT+224
SRBAVAIL EQU   GTFSSRB
WRTRERRP EQU   WRTRERR
@NM00012 EQU   WRTRERR
TRMWRITP EQU   TRMWRIT
@NM00011 EQU   TRMWRIT
GTFCMECB EQU   GTFPCT+208
WRTRCOMP EQU   WRTRCOM
@NM00010 EQU   WRTRCOM
TRANSCNT EQU   GTFPCT+200
AHLRDPLQ EQU   GTFPCT+196
SFEOBRTN EQU   GTFPCT+192
SBLOKRTN EQU   GTFPCT+188
GBCDS    EQU   NEXTBLOK
WSMODEND EQU   GTFPCT+176
WSMODBEG EQU   GTFPCT+172
BCBPAGE  EQU   GTFPCT+156
SLEPAGE  EQU   GTFPCT+152
SAVECNT  EQU   GTFPCT+148
QTAIL    EQU   GTFPCT+136
WQHEAD   EQU   GTFPCT+128
RQHEAD   EQU   GTFPCT+124
EQHEAD   EQU   GTFPCT+120
WPOSTSRB EQU   GTFPCT+116
WTSKTCBA EQU   GTFPCT+112
WRTRTCBA EQU   GTFPCT+108
TRMWTASK EQU   GTFPCT+104
WTSKATTH EQU   GTFPCT+100
WTSKINIT EQU   GTFPCT+96
WTASKECB EQU   GTFPCT+92
WMTABPTR EQU   GTFPCT+88
ATTCHECB EQU   GTFPCT+84
AHLECB   EQU   GTFPCT+80
STOPECBA EQU   GTFPCT+76
ECBADRLT EQU   GTFPCT+72
FIXLEN   EQU   GTFPCT+68
FIXPTR   EQU   GTFPCT+64
INITPTR  EQU   GTFPCT+60
MCQEPTR  EQU   GTFPCT+56
GTFEIDL  EQU   GTFPCT+52
GTFPIBL  EQU   GTFPCT+48
GTFPIFT  EQU   GTFPCT+44
GTFSVCBL EQU   GTFPCT+40
GTFSVCFT EQU   GTFPCT+36
GTFIOBL  EQU   GTFPCT+32
GTFIOFT  EQU   GTFPCT+28
GTFSIOBL EQU   GTFPCT+24
GTFSIOFT EQU   GTFPCT+20
@NM00009 EQU   PCTCATF+1
PCTPIF   EQU   PCTCATF+1
PCTSIOF  EQU   PCTCATF+1
PCTIOF   EQU   PCTCATF+1
PCTSVCF  EQU   PCTCATF+1
PCTRR    EQU   PCTCATF+1
PCTSRM   EQU   PCTCATF+1
PCTRNIO  EQU   PCTCATF+1
PCTUSR   EQU   PCTCATF
PCTPI    EQU   PCTCATF
@NM00008 EQU   PCTCATF
PCTDSP   EQU   PCTCATF
PCTSIO   EQU   PCTCATF
PCTIO    EQU   PCTCATF
PCTEXT   EQU   PCTCATF
PCTSVC   EQU   PCTCATF
OPTTIME  EQU   GTFOPTS4
OPTRES3  EQU   GTFOPTS4
OPTIOSIO EQU   GTFOPTS3
OPTRES2  EQU   GTFOPTS3
OPTRR    EQU   GTFOPTS3
OPTSRM   EQU   GTFOPTS3
OPTRNIO  EQU   GTFOPTS3
OPTEXT   EQU   GTFOPTS3
OPTIOP   EQU   GTFOPTS2
OPTIO    EQU   GTFOPTS2
OPTPIP   EQU   GTFOPTS2
OPTPI    EQU   GTFOPTS2
OPTSIOP  EQU   GTFOPTS2
OPTSIO   EQU   GTFOPTS2
OPTSVCP  EQU   GTFOPTS2
OPTSVC   EQU   GTFOPTS2
OPTPCI   EQU   GTFOPTS1
OPTRES1  EQU   GTFOPTS1
OPTDSP   EQU   GTFOPTS1
OPTTRC   EQU   GTFOPTS1
OPTUSR   EQU   GTFOPTS1
OPTSYS   EQU   GTFOPTS1
OPTSYSP  EQU   GTFOPTS1
OPTSYSM  EQU   GTFOPTS1
GTFRESV  EQU   GTFSTAT
GTFDEBUG EQU   GTFSTAT
GTFMODE  EQU   GTFSTAT
GTFPCTID EQU   GTFPCT
MCQESRB  EQU   MCQE+44
@NM00007 EQU   MCQE+42
@NM00006 EQU   MCQEFLGS
MCQEACT  EQU   MCQEFLGS
MCQESCHE EQU   MCQE+40
MCQETECB EQU   MCQE+36
MCQEMCCL EQU   MCQE+28
MCQEMCEE EQU   MCQE+24
MCQEASCB EQU   MCQE+16
MCQEIDEN EQU   MCQE
MCCESRB  EQU   MCCE+44
MCCEECB  EQU   MCCE+40
MCCEMCCE EQU   MCCE+36
MCCECNT  EQU   MCCE+32
MCCEOMCQ EQU   MCCE+28
MCCEOCDA EQU   MCCE+24
MCCEOEDA EQU   MCCE+20
MCCECDA  EQU   MCCE+12
MCCEEDA  EQU   MCCE+8
MCCEIDEN EQU   MCCE
MCHEADTR EQU   MCHEAD+48
MCHEADRD EQU   MCHEAD+44
MCHFRRAD EQU   MCHEAD+40
MCHMCER  EQU   MCHEAD+36
MCHSETD  EQU   MCHEAD+32
MCHSETE  EQU   MCHEAD+28
@NM00005 EQU   MCHFLGS+1
@NM00004 EQU   MCHFLG1
MCHTERM  EQU   MCHFLG1
MCHACT   EQU   MCHFLG1
MCHDIS   EQU   MCHEAD+20
MCHCTL   EQU   MCHEAD+16
MCHCNT   EQU   MCHEAD+12
MCHIDEN  EQU   MCHEAD
CVTLEVL  EQU   CVTRELNO+2
CVTNUMB  EQU   CVTRELNO
CVTMDL   EQU   CVTFIX+250
@NM00003 EQU   CVTFIX+248
@NM00002 EQU   CVTFIX
CVTRV482 EQU   CVTXTNT2+128
CVTRV481 EQU   CVTXTNT2+124
CVTRV480 EQU   CVTXTNT2+120
CVTRV479 EQU   CVTXTNT2+118
CVTRV478 EQU   CVTXTNT2+117
CVTRV477 EQU   CVTXTNT2+116
CVTRV476 EQU   CVTXTNT2+115
CVTRV475 EQU   CVTXTNT2+114
CVTRV474 EQU   CVTRV466
CVTRV473 EQU   CVTRV466
CVTRV472 EQU   CVTRV466
CVTRV471 EQU   CVTRV466
CVTRV470 EQU   CVTRV466
CVTRV469 EQU   CVTRV466
CVTRV468 EQU   CVTRV466
CVTRV467 EQU   CVTRV466
CVTRV465 EQU   CVTRV457
CVTRV464 EQU   CVTRV457
CVTRV463 EQU   CVTRV457
CVTRV462 EQU   CVTRV457
CVTRV461 EQU   CVTRV457
CVTRV460 EQU   CVTRV457
CVTRV459 EQU   CVTRV457
CVTRV458 EQU   CVTRV457
CVTRV456 EQU   CVTXTNT2+108
CVTRV455 EQU   CVTXTNT2+104
CVTRV454 EQU   CVTXTNT2+100
CVTRV453 EQU   CVTXTNT2+96
CVTRV452 EQU   CVTXTNT2+94
CVTRV451 EQU   CVTXTNT2+92
CVTRV450 EQU   CVTXTNT2+90
CVTRV449 EQU   CVTXTNT2+88
CVTRV448 EQU   CVTXTNT2+87
CVTRV447 EQU   CVTXTNT2+86
CVTRV446 EQU   CVTRV438
CVTRV445 EQU   CVTRV438
CVTRV444 EQU   CVTRV438
CVTRV443 EQU   CVTRV438
CVTRV442 EQU   CVTRV438
CVTRV441 EQU   CVTRV438
CVTRV440 EQU   CVTRV438
CVTRV439 EQU   CVTRV438
CVTRV437 EQU   CVTRV429
CVTRV436 EQU   CVTRV429
CVTRV435 EQU   CVTRV429
CVTRV434 EQU   CVTRV429
CVTRV433 EQU   CVTRV429
CVTRV432 EQU   CVTRV429
CVTRV431 EQU   CVTRV429
CVTRV430 EQU   CVTRV429
CVTRV428 EQU   CVTXTNT2+80
CVTRV427 EQU   CVTXTNT2+76
CVTRV426 EQU   CVTXTNT2+72
CVTRV425 EQU   CVTXTNT2+68
CVTATACT EQU   CVTATCVT
CVTRV423 EQU   CVTXTNT2+62
CVTRV422 EQU   CVTXTNT2+60
CVTRV421 EQU   CVTXTNT2+58
CVTRV420 EQU   CVTXTNT2+56
CVTRV419 EQU   CVTXTNT2+55
CVTRV418 EQU   CVTXTNT2+54
CVTRV417 EQU   CVTRV409
CVTRV416 EQU   CVTRV409
CVTRV415 EQU   CVTRV409
CVTRV414 EQU   CVTRV409
CVTRV413 EQU   CVTRV409
CVTRV412 EQU   CVTRV409
CVTRV411 EQU   CVTRV409
CVTRV410 EQU   CVTRV409
CVTRV408 EQU   CVTRV400
CVTRV407 EQU   CVTRV400
CVTRV406 EQU   CVTRV400
CVTRV405 EQU   CVTRV400
CVTRV404 EQU   CVTRV400
CVTRV403 EQU   CVTRV400
CVTRV402 EQU   CVTRV400
CVTRV401 EQU   CVTRV400
CVTICB   EQU   CVTXTNT2+48
CVTSKTA  EQU   CVTXTNT2+44
CVTCCVT  EQU   CVTXTNT2+40
CVTRSV98 EQU   CVTXTNT2+36
CVTRSV97 EQU   CVTXTNT2+34
CVTRSV96 EQU   CVTXTNT2+32
CVTOLTEP EQU   CVTXTNT2+28
CVTQIDA  EQU   CVTQID+1
CVTRSV95 EQU   CVTQID
CVTRSV94 EQU   CVTXTNT2+20
CVTRSV93 EQU   CVTXTNT2+16
CVTRSV92 EQU   CVTXTNT2+12
CVTDEBVR EQU   CVTXTNT2+8
CVTRSV91 EQU   CVTXTNT2+6
CVTRSV9H EQU   CVTFLGBT
CVTRSV9G EQU   CVTFLGBT
CVTRSV9F EQU   CVTFLGBT
CVTRSV9E EQU   CVTFLGBT
CVTRSV9D EQU   CVTFLGBT
CVTRSV9C EQU   CVTFLGBT
CVTVME   EQU   CVTFLGBT
CVTNPE   EQU   CVTFLGBT
CVTNUCLS EQU   CVTXTNT2+4
CVTDSSVA EQU   CVTDSSV+1
CVTRSV89 EQU   CVTDSSV
CVTRSV88 EQU   CVTXTNT1+8
CVTRSV87 EQU   CVTXTNT1+4
CVTFACHN EQU   CVTXTNT1
CVTRV488 EQU   CVTMAP+412
CVTRV487 EQU   CVTMAP+408
CVTRV486 EQU   CVTMAP+404
CVTRV485 EQU   CVTMAP+400
CVTACTAP EQU   CVTMAP+396
CVTAUTH  EQU   CVTMAP+392
CVTATMCA EQU   CVTATMCT+1
CVTATMST EQU   CVTATMCT
CVTRSV61 EQU   CVTMAP+384
CVTVOLT1 EQU   CVTVOLM1+1
CVTVOLI1 EQU   CVTVOLF1
CVTSTOA  EQU   CVTMAP+376
CVTRSV58 EQU   CVTMAP+374
CVTRSV57 EQU   CVTMAP+372
CVTDDCE  EQU   CVTMAP+368
CVTPNWFR EQU   CVTMAP+364
CVTSMF   EQU   CVTMAP+360
CVTSULK  EQU   CVTMAP+358
CVTSLKO  EQU   CVTSYSK
CVTSLKP  EQU   CVTSYSK
CVTSLKQ  EQU   CVTSYSK
CVTSLKR  EQU   CVTSYSK
CVTRSV56 EQU   CVTSYSK
CVTRSV55 EQU   CVTSYSK
CVTRSV54 EQU   CVTSYSK
CVTRSV53 EQU   CVTSYSK
CVTRSV52 EQU   CVTA1F1
CVTRSV51 EQU   CVTA1F1
CVTRSV50 EQU   CVTA1F1
CVTRSV49 EQU   CVTA1F1
CVTRSV48 EQU   CVTA1F1
CVTRSV47 EQU   CVTA1F1
CVTSRSW  EQU   CVTA1F1
CVTPFSW  EQU   CVTA1F1
CVTPCVT  EQU   CVTMAP+352
CVTRSV46 EQU   CVTMAP+344
CVTRSV45 EQU   CVTMAP+340
CVTRSV44 EQU   CVTMAP+338
CVTRSV43 EQU   CVTMAP+336
CVTHJESA EQU   CVTHJES+1
CVTRSV42 EQU   CVTHJES
CVTEXT2A EQU   CVTEXT2+1
CVTRSV41 EQU   CVTEXT2
CVTAPFA  EQU   CVTAPF+1
CVTRSV40 EQU   CVTAPF
CVTRV518 EQU   CVTINTLA
CVTRV517 EQU   CVTERPV
CVTEORM  EQU   CVTMAP+312
CVTMCHPR EQU   CVTMAP+308
CVTTZ    EQU   CVTMAP+304
CVTJEPS  EQU   CVTMAP+300
CVTJESCT EQU   CVTMAP+296
CVTMODE  EQU   CVTMAP+292
CVTPTRV  EQU   CVTMAP+288
CVTREAL  EQU   CVTMAP+284
CVTRSV39 EQU   CVTMAP+280
CVTRSV38 EQU   CVTMAP+276
CVTDMSRA EQU   CVTDMSR+1
CVTRV634 EQU   CVTDMSRF
CVTRV633 EQU   CVTDMSRF
CVTRV632 EQU   CVTDMSRF
CVTRV631 EQU   CVTDMSRF
CVTRV630 EQU   CVTDMSRF
CVTRV629 EQU   CVTDMSRF
CVTUDUMP EQU   CVTDMSRF
CVTSDUMP EQU   CVTDMSRF
CVTQMSGA EQU   CVTQMSG+1
CVTRSV36 EQU   CVTQMSG
CVTAMFF  EQU   CVTMAP+264
CVTPURGA EQU   CVTPURG+1
CVTRSV35 EQU   CVTPURG
CVTCBSP  EQU   CVTMAP+256
CVTATERA EQU   CVTATER+1
CVTSYST  EQU   CVTATER
CVTVOLT2 EQU   CVTTAT
CVTVOLI2 EQU   CVTVOLF2
CVTAQAVB EQU   CVTAQAVT+1
CVTRSV34 EQU   CVTTCMFG
CVTRSV33 EQU   CVTTCMFG
CVTRSV32 EQU   CVTTCMFG
CVTRSV31 EQU   CVTTCMFG
CVTRSV30 EQU   CVTTCMFG
CVTRSV29 EQU   CVTTCMFG
CVTRSV28 EQU   CVTTCMFG
CVTTCRDY EQU   CVTTCMFG
CVTRSV27 EQU   CVTGTFST
CVTRNIO  EQU   CVTGTFST
CVTUSR   EQU   CVTGTFST
CVTRV318 EQU   CVTFORM
CVTRV317 EQU   CVTTMODE
CVTRV316 EQU   CVTSTATE
CVTRV315 EQU   CVTGTFS
CVTGTFAV EQU   CVTGTFS
CVT0SCR1 EQU   CVTMAP+232
CVTRV515 EQU   CVTMAP+228
CVTRMS   EQU   CVTMAP+224
CVTPATCH EQU   CVTMAP+220
CVTTSCE  EQU   CVTMAP+216
CVTLNKSC EQU   CVTMAP+214
CVTQABST EQU   CVTMAP+212
CVTMDLDS EQU   CVTMAP+208
CVTUSER  EQU   CVTMAP+204
CVTABEND EQU   CVTMAP+200
CVTSMCA  EQU   CVTMAP+196
CVTRSV18 EQU   CVTMAP+192
CVTQLPAQ EQU   CVTMAP+188
CVTQCDSR EQU   CVTMAP+184
CVTRSV17 EQU   CVTOPTB
CVTRSV16 EQU   CVTOPTB
CVTFP    EQU   CVTOPTB
CVTAPTHR EQU   CVTOPTB
CVTNLOG  EQU   CVTOPTB
CVTTOD   EQU   CVTOPTB
CVTCTIMS EQU   CVTOPTB
CVTPROT  EQU   CVTOPTB
CVTXPFP  EQU   CVTOPTA
CVTASCII EQU   CVTOPTA
CVTRSV13 EQU   CVTOPTA
CVTRSV12 EQU   CVTOPTA
CVTNIP   EQU   CVTOPTA
CVTDDR   EQU   CVTOPTA
CVTAPR   EQU   CVTOPTA
CVTCCH   EQU   CVTOPTA
CVTSNCTR EQU   CVTMAP+180
CVTQMWR  EQU   CVTMAP+176
CVTQOCR  EQU   CVTMAP+172
CVT1EF00 EQU   CVTMAP+168
CVTMZ00  EQU   CVTMAP+164
CVTSV76Q EQU   CVTSV76C
CVTRSV11 EQU   CVTMAP+156
CVT0PT01 EQU   CVTMAP+152
CVTMSER  EQU   CVTMAP+148
CVTRV516 EQU   CVTIERLC
CVTILCH  EQU   CVTMAP+140
CVT0DS   EQU   CVTMAP+136
CVTFBOSV EQU   CVTMAP+132
CVTNUCB  EQU   CVTMAP+128
CVTIXAVL EQU   CVTMAP+124
CVTSV76M EQU   CVTIOQET
CVTDCBA  EQU   CVTMAP+117
CVTMVS2  EQU   CVTDCB
CVT6DAT  EQU   CVTDCB
CVT4MPS  EQU   CVTDCB
CVTRSV09 EQU   CVTDCB
CVT4MS1  EQU   CVTDCB
CVT2SPS  EQU   CVTDCB
CVT1SSS  EQU   CVTDCB
CVTRSV08 EQU   CVTDCB
CVTSTB   EQU   CVTMAP+112
CVTQTD00 EQU   CVTMAP+108
CVTQTE00 EQU   CVTMAP+104
CVTCUCB  EQU   CVTMAP+100
CVTSJQ   EQU   CVTMAP+96
CVTPBLDL EQU   CVTMAP+92
CVTTPC   EQU   CVTMAP+88
CVTSVDCB EQU   CVTMAP+84
CVTBRET  EQU   CVTMAP+82
CVTEXIT  EQU   CVTMAP+80
CVT0FN00 EQU   CVTMAP+76
CVTDARA  EQU   CVTDAR+1
CVTRSV07 EQU   CVTFLGS1
CVTRSV06 EQU   CVTFLGS1
CVTRSV05 EQU   CVTFLGS1
CVTRSV04 EQU   CVTFLGS1
CVTRSV03 EQU   CVTFLGS1
CVTRSV02 EQU   CVTFLGS1
CVTRSV01 EQU   CVTFLGS1
CVTDMPLK EQU   CVTFLGS1
CVTXITP  EQU   CVTMAP+68
CVTZDTAB EQU   CVTMAP+64
CVTMSLT  EQU   CVTMAP+60
CVTDATE  EQU   CVTMAP+56
CVTBTERM EQU   CVTMAP+52
CVTSYSAD EQU   CVTMAP+48
CVTXTLER EQU   CVTMAP+44
CVTILK2  EQU   CVTMAP+40
CVTILK1  EQU   CVTMAP+36
CVTPRLTV EQU   CVTMAP+32
CVTPCNVT EQU   CVTMAP+28
CVT0VL00 EQU   CVTMAP+24
CVTXAPG  EQU   CVTMAP+20
CVTBUF   EQU   CVTMAP+16
CVTJOB   EQU   CVTMAP+12
CVTLINK  EQU   CVTMAP+8
CVT0EF00 EQU   CVTMAP+4
CVTTCBP  EQU   CVTMAP
ASCBEND  EQU   ASCB+208
ASCBSRBT EQU   ASCB+200
ASCBSWTL EQU   ASCB+196
ASCBRS14 EQU   ASCB+195
ASCBSMCT EQU   ASCB+194
ASCBRS12 EQU   ASCB+192
ASCBPCTT EQU   ASCB+188
ASCBVGTT EQU   ASCB+184
ASCBLGCB EQU   ASCB+180
ASCBJBNS EQU   ASCB+176
ASCBJBNI EQU   ASCB+172
ASCBMCC  EQU   ASCB+168
ASCBRTWA EQU   ASCB+164
ASCBIQEA EQU   ASCB+160
ASCBXMPQ EQU   ASCB+156
ASCBRS01 EQU   ASCB+154
ASCBFMCT EQU   ASCB+152
ASCBOUXB EQU   ASCB+148
ASCBOUCB EQU   ASCB+144
ASCBMECB EQU   ASCB+140
ASCBQECB EQU   ASCB+136
ASCBCMSB EQU   ASCB+132
ASCBCMSF EQU   ASCB+128
ASCBTCBS EQU   ASCB+124
ASCBNVSC EQU   ASCB+122
ASCBVSC  EQU   ASCB+120
ASCBSRBS EQU   ASCB+118
ASCBSSRB EQU   ASCB+116
ASCBRV06 EQU   ASCBFLG2
ASCBRV05 EQU   ASCBFLG2
ASCBRV04 EQU   ASCBFLG2
ASCBSNQS EQU   ASCBFLG2
ASCBS2S  EQU   ASCBFLG2
ASCBCEXT EQU   ASCBFLG2
ASCBPXMT EQU   ASCBFLG2
ASCBXMPT EQU   ASCBFLG2
ASCBRF07 EQU   ASCBDSP1
ASCBRF06 EQU   ASCBDSP1
ASCBRF05 EQU   ASCBDSP1
ASCBRF04 EQU   ASCBDSP1
ASCBRF03 EQU   ASCBDSP1
ASCBRF02 EQU   ASCBDSP1
ASCBFAIL EQU   ASCBDSP1
ASCBNOQ  EQU   ASCBDSP1
ASCBSWCT EQU   ASCB+112
ASCBASXB EQU   ASCB+108
ASCBTMCH EQU   ASCB+104
ASCBNSWP EQU   ASCBFLG1
ASCBTYP1 EQU   ASCBFLG1
ASCBSTND EQU   ASCBFLG1
ASCBABNT EQU   ASCBFLG1
ASCBTERM EQU   ASCBFLG1
ASCBS3S  EQU   ASCBFLG1
ASCBCMSH EQU   ASCBFLG1
ASCBTOFF EQU   ASCBFLG1
ASCBRF01 EQU   ASCBRCTF
ASCBTMLW EQU   ASCBRCTF
ASCBOUT  EQU   ASCBRCTF
ASCBWAIT EQU   ASCBRCTF
ASCBRV08 EQU   ASCBRCTF
ASCBFQU  EQU   ASCBRCTF
ASCBFRS  EQU   ASCBRCTF
ASCBTMNO EQU   ASCBRCTF
ASCBAFFN EQU   ASCBFW1
ASCBDUMP EQU   ASCB+96
ASCBQSVC EQU   ASCB+92
ASCBUBET EQU   ASCB+88
ASCBECB  EQU   ASCB+84
ASCBJSTL EQU   ASCB+80
ASCBEWST EQU   ASCB+72
ASCBEJST EQU   ASCB+64
ASCBTSB  EQU   ASCB+60
ASCBCSCB EQU   ASCB+56
ASCBRSM  EQU   ASCB+52
ASCBLDA  EQU   ASCB+48
ASCBSTOR EQU   ASCB+44
ASCBDP   EQU   ASCB+43
ASCBRV07 EQU   ASCB+42
ASCBIOSM EQU   ASCB+40
ASCBSEQN EQU   ASCB+38
ASCBCPUS EQU   ASCB+32
ASCBSPL  EQU   ASCB+28
ASCBLSLQ EQU   ASCB+24
ASCBFSLQ EQU   ASCB+20
ASCBIOSP EQU   ASCB+16
ASCBLOCK EQU   ASCB+12
ASCBBWDP EQU   ASCB+8
ASCBFWDP EQU   ASCB+4
ASCBASCB EQU   ASCB
ASCBEGIN EQU   ASCB
RESERVED EQU   AMDPRTAB+522
CVTTZONE EQU   AMDPRTAB+518
ESPSEC   EQU   ESTOPTME+7
ESPMIN   EQU   ESTOPTME+5
ESPHR    EQU   ESTOPTME+3
ESPDAY   EQU   ESTOPTME
ESSEC    EQU   ESTARTME+7
ESMIN    EQU   ESTARTME+5
ESHR     EQU   ESTARTME+3
ESDAY    EQU   ESTARTME
ADTSBUF  EQU   AMDPRTAB+496
OFSTDATA EQU   AMDPRTAB+494
OFSTEID  EQU   AMDPRTAB+492
REENTWKA EQU   AMDPRTAB+484
PRFMTADD EQU   AMDPRTAB+480
EXITADDR EQU   AMDPRTAB+472
EXITNM   EQU   AMDPRTAB+464
@NM00001 EQU   GENFLGS1
TS       EQU   GENFLGS1
RR       EQU   GENFLAGS
SRM      EQU   GENFLAGS
RNIO     EQU   GENFLAGS
SYSM     EQU   GENFLAGS
SYS      EQU   GENFLAGS
DSP      EQU   GENFLAGS
EXT      EQU   GENFLAGS
PICODEA  EQU   PGMNGEN+2
PICODES  EQU   PGMNGEN
Q        EQU   PI+1
P01R     EQU   PIFLGS
SELP     EQU   PIFLGS
ALLP     EQU   PIFLGS
USRNGTAB EQU   USRTAB
O        EQU   USR+1
N01R     EQU   USRFLGS
SELU     EQU   USRFLGS
ALLU     EQU   USRFLGS
SVCNUMS  EQU   AMDPRTAB+336
M        EQU   VCF+1
L        EQU   SVCFLGS
SELV     EQU   SVCFLGS
ALLV     EQU   SVCFLGS
IODVADS  EQU   DVADS2
K01RES   EQU   IO+1
JJ       EQU   IOFLGS2
SELI     EQU   IOFLGS2
ALLI     EQU   IOFLGS2
SIODVADS EQU   DVADS1
II       EQU   SIF+1
H        EQU   SIOFLGS
NOEQU    EQU   SIOFLGS
EQUIV    EQU   SIOFLGS
SELS     EQU   SIOFLGS
ALLS     EQU   SIOFLGS
ASCBADDR EQU   AADS
JOBNAMES EQU   NAMES
DAY2     EQU   STOPTIME+10
F        EQU   STOPTIME+8
TIME2    EQU   STOPTIME
DAY      EQU   STARTIME+10
D        EQU   STARTIME+8
TIME     EQU   STARTIME
GTFWDPTR EQU   AMDPRTAB+20
C        EQU   DEBGFLGS+4
B        EQU   IOFLGS
DMDFMT   EQU   INRFCFGS
EDITSTOP EQU   INRFCFGS
RET      EQU   INRFCFGS
FMT      EQU   INRFCFGS
SPIE     EQU   INRFCFGS
FLMODE   EQU   INRFCFGS
REMAIN   EQU   PTHFLGS2
APP      EQU   PTHFLGS2
REXT     EQU   PTHFLGS1
FRM      EQU   PTHFLGS1
FLT      EQU   PTHFLGS1
HEX      EQU   PTHFLGS1
CON      EQU   PTHFLGS1
SCN      EQU   PTHFLGS1
ROOT     EQU   PTHFLGS1
.@UNREFD ANOP                          END UNREFERENCED COMPONENTS
@RT00152 EQU   GETDONE
@RT00154 EQU   GETFREE
@RT00161 EQU   DUMPTRC
@RT00164 EQU   GETREC
@RT00213 EQU   BADLLMSG
@RT00228 EQU   GETDONE
@RT00230 EQU   POSIT
@RF00232 EQU   GETDONE
@RF00245 EQU   GETREC
@RT00343 EQU   GETFINAL
@RF00361 EQU   GETTERM
@RT00369 EQU   DEBLKSA
@RT00371 EQU   DEBLOCK
@RT00403 EQU   CHAINERR
@RT00431 EQU   SLQREQ
@RT00445 EQU   BADLL
@RT00449 EQU   NEXTBUF
@RT00452 EQU   BADLL
@RT00455 EQU   BADLL
@RT00462 EQU   TESTSADP
@RT00468 EQU   GETFINAL
@RT00487 EQU   HEXBUFDP
@RT00492 EQU   BADLL
@RT00496 EQU   NEXTSABF
@RT00510 EQU   NEXTSABF
@RT00515 EQU   BADLL
@RT00548 EQU   CHAINERR
@RT00567 EQU   GETFINAL
@RT00609 EQU   READAGAN
@RT00626 EQU   CHAINERR
@ENDDATA EQU   *
         END   AMDPRGET,(C'PLS1959',0701,78074)
