 TITLE 'IFCESOFT - SOFTWARE (ABEND) RECORD EDIT'
         MACRO
&NAME    DSGEN ,
.*                            THIS MACRO GENERATES ONE DSECT WORD
.*                                 FORMATTED FOR THE SUBJECT LOG RECORD
.*                                 EACH OPERAND HAS TWO SUB LISTS. THE
.*                                 FIRST IS THE NAME OF THE LOG ITEM
.*                                 WHILE THE SECOND IS THE # OF BITS TO
.*                                 ALLOCATE FOR THIS ITEM. ITEMS MUST
.*                                 BE DEFINED CONTIGUOUSLY WITHOUT GAPS
.*                                 UNUSED BIT GROUPS MUST BE GIVEN
.*                                 DUMMY NAMES. THE NAMES PROVIDED FOR
.*                                 THE LOG ITEMS MAY THEN BE USED IN
.*                                 THE CONVERSION MACRO INSTRUCTIONS.
         GBLA  &BITS(2600),&DB,&DT,&INITIAL
         GBLA  &ITEMITR,&ITEMFST(20),&ITEMNBR,&ITEMMDX
         GBLA  &ITEMNDX(2600),&ITEMXPT
         GBLA  &LABELNR,&LASTCC,&LB,&LBLCTR(100),&LPTR,&LT
         GBLA  &NRENTS,&SHIFT(2600)
         GBLB  &DIAGITF,&DIAGLIN,&DIAGSET,&DIAGTST,&FSW,&TEST
         GBLC  &CARRCON,&CSECT,&DSECT,&ITEM(2600)
         GBLC  &LABELS(2600),&LBL(100),&NRENTSX
         LCLB  &ONLY1,&CTIND
         LCLA  &START1,&START2,&END1,&END2
         LCLC  &SYMBOL,&EQUSYM
         LCLA  &OP,&COUNT,&BYTE,&EQUCNT
         ACTR  100000
         AIF   (&ITEMITR EQ 0).START
 MNOTE   20,'DSGEN MACRO OCCURRS AFTER ITEMSORT MACRO HAS BEEN ISSUED.'
         MEXIT
.START   AIF   (N'&SYSLIST(&OP+1) LT 3).LOOP
         AIF   ('&SYSLIST(&OP+1,3)' EQ 'EQU').LOOP     TEST FOR EQU
  AIF   ('&SYSLIST(&OP+1,3)' EQ '' OR '&SYSLIST(&OP+1,4)' EQ '').ERR1
         AIF   ('&SYSLIST(&OP+1,3)' GT '&SYSLIST(&OP+1,4)').ERR3
&START1  SETA  &SYSLIST(&OP+1,3)        GET START COUNT OF 1
&START2  SETA  &SYSLIST(&OP+1,4)        GET FIRST END COUNT
         AGO   .SET2A                   BRANCH AROUND
         AIF   ('&SYSLIST(&OP+1,5)' GT '&SYSLIST(&OP+1,6)').ERR3
.ERR1    MNOTE '**FIRST SYMBOL CONCATENATION INCOMPLETE**'
         MEXIT
.SET2A   AIF   ('&SYSLIST(&OP+1,5)' EQ ''AND '&SYSLIST(&OP+1,6)' EQ '' X
               ).SET2                   TEST FOR NO SECOND
  AIF   ('&SYSLIST(&OP+1,5)' EQ '' OR '&SYSLIST(&OP+1,6)' EQ '').ERR2
&END1    SETA  &SYSLIST(&OP+1,5)        GET START COUNT OF 2
&END2    SETA  &SYSLIST(&OP+1,6)        GET END COUNT OF 2
         AGO   .LOOP
.SET2    ANOP
&ONLY1   SETB  1                        INDICATE ONLY ONE CONCATENATION
         AGO   .LOOP
.ERR2    MNOTE '**SECOND SYMBOL CONCATENATION INCOMPLETE**'
         MEXIT
.ERR3    MNOTE '**START GREATER THAN END CONCATENATION**'
         MEXIT
.LOOP    ANOP
&OP      SETA  &OP+1
         AIF   (&OP GT N'&SYSLIST).DONE      TEST IF ALL DONE
&ITEMNBR SETA  &ITEMNBR+1
         AIF   ('&SYSLIST(&OP,2)' NE '').OK1
         MNOTE '**NULL BIT COUNT FIELD**'
         MEXIT
.OK1     ANOP
&SYMBOL  SETC  '&SYSLIST(&OP,1)'
         AIF   ('&SYMBOL' NE '').OK
*              *****     LOG ITEM SYMBOL NOT PROVIDED     *****
         AIF   ('&SYSLIST(&OP,3)' NE 'EQU').CNT
         AGO   .START                   GET NEXT
.OK      AIF   (N'&SYSLIST(&OP) LT 3).NO3    TEST FOR OLD FORMAT
         AIF   ('&SYSLIST(&OP,3)' EQ 'EQU').EQU   TEST FOR EQU
         AIF   (&ONLY1).OK2             TEST FOR ONLY ONE CONCAT
&SYMBOL  SETC  '&SYMBOL.&START1.&END1'       GET 1 AND 2 CONCAT
         AGO   .NO3                     BRANCH AROUND
.OK2     ANOP
&SYMBOL  SETC  '&SYMBOL.&START1'        GET 1 CONCATENATED
.NO3     ANOP
&SYMBOL  EQU   *+&BYTE
&ITEM(&ITEMNBR) SETC '&SYMBOL'          GET LABEL IN GLOBAL
&BITS(&ITEMNBR) SETA &SYSLIST(&OP,2)
&SHIFT(&ITEMNBR) SETA &COUNT-&BYTE*8
.CNT     ANOP
&CTIND   SETB  1                        SET COUNT INDICATOR
&COUNT   SETA  &COUNT+&SYSLIST(&OP,2)
&BYTE    SETA  &COUNT/8
         AIF   (N'&SYSLIST(&OP) LT 3).START  TEST FOR OLD FORMAT
         AIF   (&ONLY1).TSTST           TEST FOR ONLY ONE CONCAT
         AIF   (&END1 EQ &END2).TSTST   TEST FOR SECOND END
&END1    SETA  &END1+1                  INCREMENT COUNT
&OP      SETA  &OP-1                    DECREMENT INCREMENT
         AGO   .LOOP                    GENERATE NEXT
.TSTST   ANOP
         AIF   (&START1 EQ &START2).LPDONE   TEST FOR END
         AIF   (&ONLY1).NSET1           TEST FOR ONLY ONE CONCAT
&END1    SETA  &SYSLIST(&OP,5)          RE-INIT SECOND START COUNT
.NSET1   ANOP
&OP      SETA  &OP-1                    DECREMENT INDEX
&START1  SETA  &START1+1                INCREMENT FIRST COUNT
         AGO   .LOOP                    GO DO NEXT
.LPDONE  ANOP
&ONLY1   SETB  0                        CLEAR INDICATOR
         AGO   .START                   GO TEST FOR MORE SUB-LISTS
.DONE    AIF   (&COUNT-&COUNT/8*8 NE 0).ERR  TEST FOR MULTIPLE OF EIGHT
         AIF   (&CTIND EQ 0).END        NO DS IF NO COUNT
&COUNT   SETA  &COUNT/8                 GET NUMBER OF BYTES
&NAME    DS    &COUNT.C
.END     MEXIT
.ERR     MNOTE '**BIT COUNT FLDS DO NOT TOTAL MULTIPLE OF 8**'
         MEXIT
.EQU     AIF   ('&SYSLIST(&OP,4)' NE '').EQU1     TEST FOR NULL LABEL
.ERR4    MNOTE '**EQU OPERAND OMITTED OR NOT FOUND**'
         MEXIT
.EQU1    AIF   (&SYSLIST(&OP,2) LT 16).EQU2  COUNT OVER FIFTEEN
*****               THE FOLLOWING STATEMENT                *****
*****     NUMBER OF BITS EXCEED 15 - DO NOT USE AS BIN     *****
.EQU2    ANOP
&EQUCNT  SETA  0                        CLEAR COUNTER
&EQUSYM  SETC  '&SYSLIST(&OP,4)'        GET EQU OPERAND
.EQULOP  ANOP
&EQUCNT  SETA  &EQUCNT+1                INCREMENT INDEX
         AIF   ('&ITEM(&EQUCNT)' EQ '&EQUSYM').EQUOUT  LABEL FOUND?
         AIF   (&EQUCNT EQ &ITEMNBR).ERR4    ALL TESTED?
         AGO   .EQULOP                  NO-GET NEXT
.EQUOUT  ANOP
&ITEM(&ITEMNBR) SETC '&SYMBOL'          GET LABEL NAME
&BITS(&ITEMNBR) SETA &SYSLIST(&OP,2)    GET NUMBER OF BITS
&SHIFT(&ITEMNBR) SETA &SHIFT(&EQUCNT)   GET SHIFT COUNT
&SYMBOL  EQU   &EQUSYM                  THIS SYMBOL EQUATED
         AGO   .START                   RETURN FOR NEXT
         MEND
         MACRO
         HEX   ,
.*                            THIS MACRO FACILITATES GENERATION OF THE
.*                                 TABLE ENTRIES SPECIFYING HEX TYPE
.*                                 CONVERSIONS.
.*                            &SYSLIST(&OP,1) - NAME OF DATA ITEM TO BE
.*                                 CONVERTED
.*                            &SYSLIST(&OP,2) - # OF SPACES TO SKIP ON
.*                                 MULTIPLE PRINT OR NBR OF SPACES TO
.*                                 BACK UP FROM COLUMN FOR START OF
.*                                 PRINTING. THE LETTER B PRECEEDS THE
.*                                 NUMBER (B8) IF THE LATTER OPTION IS
.*                                 DESIRED. OMISSION OF THIS OPERAND
.*                                 FORCES OPTION 2 WITH BACKUP SPACING
.*                                 EQUAL TO THE NUMBER OF BYTES SPECI-
.*                                 FIED BY THE NEXT OPERAND (TWICE THIS
.*                                 NUMBER IF SUFFIX IS EXPLICITLY OR
.*                                 IMPLICITLY B).
.*                            &SYSLIST(&OP,3) - NUMBER OF BYTES TO
.*                                 PROCESS. THIS NUMBER IS SUFFIXED
.*                                 WITH AN L,R, OR B TO STIPULATE
.*                                 PRINTING OF THE LEFT HALF, RIGHT
.*                                 HALF, OR BOTH HALVES OF THE BYTE
.*                                 RESPECTIVELY. OMISSION OF THIS
.*                                 OPERAND DEFAULTS TO B WITH THE NUM-
.*                                 BER OF BYTES EQUAL TO THE ITEM LNGTH
.*                            A NEW ENTRY IS GENERATED ONLY WHEN NECES-
.*                                 SARY. THIS MACRO MUST BE THE FIRST
.*                                 MACRO INSTRUCTION ISSUED FOR THE
.*                                 SUBJECT LINE(S).
         GBLA  &BITS(2600),&DB,&DT,&INITIAL
         GBLA  &ITEMITR,&ITEMFST(20),&ITEMNBR,&ITEMMDX
         GBLA  &ITEMNDX(2600),&ITEMXPT
         GBLA  &LABELNR,&LASTCC,&LB,&LBLCTR(100),&LPTR,&LT
         GBLA  &NRENTS,&SHIFT(2600)
         GBLB  &DIAGITF,&DIAGLIN,&DIAGSET,&DIAGTST,&FSW,&TEST
         GBLC  &CARRCON,&CSECT,&DSECT,&ITEM(2600)
         GBLC  &LABELS(2600),&LBL(100),&NRENTSX
         LCLB  &B,&SUB
         LCLA  &IBITS,&ISHIFT,&K,&T,&CODE,&BYTESP,&OP
         LCLC  &S,&LETTER,&ARG
       ACTR  500000
         AIF   (&DIAGTST EQ 0).NOMSG
         AIF   (&INITIAL EQ 0).NOMSG
         AIF   (&DIAGLIN EQ 1).NOMSG
         MNOTE '**NO LINE ASSOCIATED WITH THIS DATA**'
*****THE FOLLOWING GENERATED FOR TEST PURPOSES*****
*        LINE
         LINE
.NOMSG   ANOP
         AIF   (K'&SYSLIST(1) EQ K'&SYSLIST(1,1)).LOOP
&SUB     SETB  1
.LOOP    ANOP
&OP      SETA  &OP+1
&ARG     SETC  '&SYSLIST(&OP,1)'
         ITEMFIND  &ARG
         AIF   (&ITEMXPT EQ 0).MEXIT
.FOUND   ANOP
&ISHIFT  SETA  &SHIFT(&ITEMXPT)
&IBITS   SETA  &BITS(&ITEMXPT)
         AIF   (&ISHIFT EQ 0 OR &ISHIFT EQ 4).ALIGN
.ERR     MNOTE '**DATA NOT ALLIGNED ON HEX OR BYTE BOUNDARY**'
.MEXIT   MEXIT
.ALIGN   ANOP
&CODE    SETA  1
         AIF   (&SUB EQ 1).SUBA
&K       SETA  K'&SYSLIST(3)
         AGO   .SUBB
.SUBA    ANOP
&K       SETA  K'&SYSLIST(&OP,3)
.SUBB    ANOP
         AIF   (&K EQ 1).ERR3
         AIF   (&IBITS-(&IBITS/4)*4 EQ 0).OK
         MNOTE '**BIT LENGTH SPECIFICATION INCONSISTENT WITH CONTROL**'
         MEXIT
.OK      AIF   (&SUB EQ 1).SUBC
         AIF   ('&SYSLIST(3)' EQ '').USEDEFN
&LETTER  SETC  '&SYSLIST(3)'(&K,1)
&S       SETC  '&SYSLIST(3)'(1,&K-1)
         AGO   .SUBD
.SUBC    ANOP
         AIF   ('&SYSLIST(&OP,3)' EQ '').USEDEFN
&LETTER  SETC  '&SYSLIST(&OP,3)'(&K,1)
&S       SETC  '&SYSLIST(&OP,3)'(1,&K-1)
.SUBD    ANOP
&BYTESP  SETA  &S
         AIF   ('&LETTER' EQ 'B').BOTH
         AIF   ('&LETTER' EQ 'L').LEFT
         AIF   ('&LETTER' EQ 'R').RIGHT
.ERR3    MNOTE '**PARAMETER 3 INCOMPLETE-DSGEN DEFINITION USED**'
         AGO   .USEDEFN
.RIGHT   ANOP
&CODE    SETA  2
         AGO   .L
.LEFT    ANOP
&CODE    SETA  1
         AGO   .L
.USEDEFN ANOP
&BYTESP  SETA  &IBITS/8
.BOTH    AIF   (&ISHIFT NE 0).ERR
&CODE    SETA  3
&T       SETA  &BYTESP*2-1
&S       SETC  '&T'
.OK2     AIF   (&ISHIFT EQ 0).L
&CODE    SETA  2
.L       ANOP
&B       SETB  1
         AIF   (&SUB EQ 1).SUBE
         AIF   ('&SYSLIST(2)' EQ '').BACKUP
&K       SETA  K'&SYSLIST(2)
&B       SETB  ('&SYSLIST(2)'(1,1) EQ 'B')
&S       SETC  '&SYSLIST(2)'(&B+1,&K-&B)
         AGO   .SUBF
.SUBE    ANOP
         AIF   ('&SYSLIST(&OP,2)' EQ '').BACKUP
&K       SETA  K'&SYSLIST(&OP,2)
&B       SETB  ('&SYSLIST(&OP,2)'(1,1) EQ 'B')
&S       SETC  '&SYSLIST(&OP,2)'(&B+1,&K-&B)
.SUBF    ANOP
.BACKUP  ANOP
&NRENTS  SETA  &NRENTS+1
         AIF   (&BYTESP GT 0 AND &BYTESP LT 16).SUB0
         MNOTE '**NO. OF BYTES OUTSIDE RANGE OF 1-15**'
         MEXIT
.SUB0    AIF   (&SUB EQ 1).SUBG
         DC    AL.12(&SYSLIST(1)-&DSECT),XL.4'A'
         AGO   .SUBH
.SUBG    ANOP
         DC    AL.12(&SYSLIST(&OP,1)-&DSECT),XL.4'A'
.SUBH    ANOP
         DC    BL.1'&B',FL.7'&S',AL.4(&BYTESP),FL.4'&CODE'
.OUT     ANOP
&ITEMXPT     SETA  0
         AIF   (&SUB EQ 0).OUTA
         AIF   (&OP LT N'&SYSLIST).LOOP
.OUTA    ANOP
         MEND
         MACRO
         BIN   ,
.*                                 &SYSLIST(&OP,1) - NAME OF LOG ITEM
.*                                      RECORD DSECT
.*                                 $SYSLIST(&OP,2) - NBR OF SPACES
.*                                      TO SKIP ON MULTIPLE
.*                                      PRINT OR NBR OF SPACES
.*                                      TO BACK UP FROM COLUMN FOR
.*                                      START OF PRINTING. THE LETTER
.*                                      B PRECEEDS THE NUMBER (B5) IF
.*                                      THE LATTER IS DESIRED. OMISSION
.*                                      OF THIS OPERAND FORCES OPTION 2
.*                                      WITH BACKUP SPACING EQUAL TO
.*                                 THE NUMBER OF BITS IN THE ITEM
.*                                 DEFINITION (VIA MACRO 'DSGEN').
.*                            A LIMIT OF 15 BITS IS IMPOSED FOR THE
.*                                 TOTAL NUMBER OF BITS TO PRINT.
         GBLA  &BITS(2600),&DB,&DT,&INITIAL
         GBLA  &ITEMITR,&ITEMFST(20),&ITEMNBR,&ITEMMDX
         GBLA  &ITEMNDX(2600),&ITEMXPT
         GBLA  &LABELNR,&LASTCC,&LB,&LBLCTR(100),&LPTR,&LT
         GBLA  &NRENTS,&SHIFT(2600)
         GBLB  &DIAGITF,&DIAGLIN,&DIAGSET,&DIAGTST,&FSW,&TEST
         GBLC  &CARRCON,&CSECT,&DSECT,&ITEM(2600)
         GBLC  &LABELS(2600),&LBL(100),&NRENTSX
         LCLB  &B,&SUB
         LCLA  &IBITS,&ISHIFT,&K
         LCLA  &TEMP,&T,&OP
         LCLC  &S,&ARG
          ACTR  500000
         AIF   (&DIAGTST EQ 0).NOMSG
         AIF   (&INITIAL EQ 0).NOMSG
         AIF   (&DIAGLIN EQ 1).NOMSG
         MNOTE '**NO LINE ASSOCIATED WITH THIS DATA**'
*****THE FOLLOWING GENERATED FOR TEST PURPOSES*****
*        LINE
         LINE
.NOMSG   ANOP
         AIF   (K'&SYSLIST(1) EQ K'&SYSLIST(1,1)).LOOP
&SUB     SETB  1
.LOOP    ANOP
&OP      SETA  &OP+1
&ARG     SETC  '&SYSLIST(&OP,1)'
         ITEMFIND &ARG
         AIF   (&ITEMXPT EQ 0).MEXIT
&ISHIFT  SETA  &SHIFT(&ITEMXPT)
&IBITS   SETA  &BITS(&ITEMXPT)
         AIF   (&SUB EQ 1).SUB00
         AIF   ('&SYSLIST(3)' EQ '').SETT
&IBITS   SETA  &SYSLIST(3)
         AGO   .SETT
.SUB00   AIF   ('&SYSLIST(&OP,3)' EQ '').SETT
&IBITS   SETA  &SYSLIST(&OP,3)
.SETT    ANOP
&T       SETA  &IBITS-1
&B       SETB  0
         AIF   (&IBITS GT 0 AND &IBITS LT 16).SUB0
         MNOTE '**NO. OF BITS OUTSIDE RANGE OF 1-15**'
.MEXIT   MEXIT
.SUB0    AIF   (&SUB EQ 1).SUBA
         AIF   ('&SYSLIST(2)' EQ '').BACKUP
&K       SETA  K'&SYSLIST(2)
&B       SETB  ('&SYSLIST(2)'(1,1) EQ 'B')
&S       SETC  '&SYSLIST(2)'(&B+1,&K-&B)
         AGO   .SUBB
.SUBA    ANOP
         AIF   ('&SYSLIST(&OP,2)' EQ '').BACKUP
&K       SETA  K'&SYSLIST(&OP,2)
&B       SETB  ('&SYSLIST(&OP,2)'(1,1) EQ 'B')
&S       SETC  '&SYSLIST(&OP,2)'(&B+1,&K-&B)
.SUBB    ANOP
&T       SETA  &S
.BACKUP  ANOP
&NRENTS  SETA  &NRENTS+1
&TEMP    SETA  &ISHIFT
         AIF   (&IBITS NE 1 OR &B NE 0).BIN2
         DC    AL.12(&SYSLIST(&OP,1)-&DSECT),XL.4'&TEMP'
         AGO   .OUT
         AIF   (&SUB EQ 1).BIN2
         AIF   ('&SYSLIST(2)' NE '').BIN3
         AGO   .BIN2A
.BIN2    AIF   ('&SYSLIST(&OP,2)' NE '').BIN3
.BIN2A   ANOP
&B       SETB  1
.BIN3    ANOP
         DC    AL.12(&SYSLIST(&OP,1)-&DSECT),XL.4'C'
         DC    BL.1'&B',AL.7(&T),AL.4(&IBITS),FL.4'&ISHIFT'
.OUT     ANOP
&ITEMXPT     SETA  0
         AIF   (&SUB EQ 0).OUTA
         AIF   (&OP LT N'&SYSLIST).LOOP
.OUTA    ANOP
         MEND
         MACRO
&NAME    LINE  &DATA,&LABEL,&SKIP=
.*                            THIS MACRO ESTABLISHES THE MARGINS OR
.*                                 COLUMN SETTINGS FOR EACH LINE. IT
.*                                 GENERATES NECESSARY CARRIAGE CONTROL
.*                                 ENTRIES. LASTLY IT DETERMINES THE
.*                                 NUMBER OF ENTRIES ASSOCIATED WITH
.*                                 THE PREVIOUS LINE AND STORES THAT #
.*                                 INTO THE APPROPRIATE BYTE.
.*                            &DATA(1) - CHARACTER POSITION TO BEGIN
.*                                 DATA.
.*                            &DATA(2) - # OF SPACES BETWEEN SUCCESSIVE
.*                                 DATA COLUMN STARTING CHARACTERS.
.*                            &LABEL(1) - CHAR. POS. TO BEGIN LABELS.
.*                            &LABEL(2) - # SPACES BETWEEN LINE'S LABEL
.*                                 STARTING CHARACTERS.
.*                            &SKIP= - # OF LINES TO ADVANCE CARRIAGE
.*                                 TO BEGIN NEXT PRINTED LINE.
.*                            NEW ENTRIES ARE GENERATED ONLY WHEN
.*                                 NECESSARY. OMISSION OF ITEMS MEANS
.*                                 THEY HAVE NOT CHANGED SINCE PREVIOUS
.*                                 SETTINGS. A LINE MACRO IS REQUIRED
.*                                 FOR EACH PRINTED LINE. IF NO SETTING
.*                                 CHANGES ARE REQUIRED ALL OPERANDS
.*                                 ARE OMITTED IN WHICH CASE ONLY THE
.*                                 # OF ENTRIES FOR THE PREVIOUS LINE
.*                                 IS COMPUTED. THIS MACRO MUST BE THE
.*                                 FIRST MACRO INSTRUCTION ISSUED FOR
.*                                 THE SUBJECT LINE
         GBLA  &BITS(2600),&DB,&DT,&INITIAL
         GBLA  &ITEMITR,&ITEMFST(20),&ITEMNBR,&ITEMMDX
         GBLA  &ITEMNDX(2600),&ITEMXPT
         GBLA  &LABELNR,&LASTCC,&LB,&LBLCTR(100),&LPTR,&LT
         GBLA  &NRENTS,&SHIFT(2600)
         GBLB  &DIAGITF,&DIAGLIN,&DIAGSET,&DIAGTST,&FSW,&TEST
         GBLC  &CARRCON,&CSECT,&DSECT,&ITEM(2600)
         GBLC  &LABELS(2600),&LBL(100),&NRENTSX
         LCLA  &S
         AIF   (&INITIAL EQ 0 OR &DIAGTST EQ 0).DIAGSET
         AIF   (&DIAGSET EQ 0).DIAGSET
         MNOTE '**NO LABEL ASSOCIATED WITH LAST SET**'
***** THE FOLLOWING GENERATED FOR TEST PURPOSES *****
*        LABEL '%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'
               LABEL '%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'
.DIAGSET ANOP
&DIAGSET SETB  1
&DIAGLIN SETB  1
&NAME    DS    0C
         AIF   (&INITIAL EQ 0).FIRSTLN
         LINEND
         AGO   .NTFIRST
.FIRSTLN ANOP
&NRENTSX SETC  'N&SYSNDX'
&INITIAL SETA  1
N&SYSNDX EQU   *
.NTFIRST ANOP
         DC    AL1(0)
         AIF   ('&DATA(1)' EQ '').CKDTABS
         AIF   (&DATA(1) EQ &DB).CKDTABS
&DB      SETA  &DATA(1)
         AGO   .AA
.CKDTABS AIF   ('&DATA(2)' EQ '').NCDATA
         AIF   (&DATA(2) EQ &DT).NCDATA
         AGO   .CC
.AA      AIF   ('&DATA(2)' EQ '').BB
         AIF   (&DATA(2) EQ &DT).BB
.CC      ANOP
&DT      SETA  &DATA(2)
.BB      DC    XL2'FFFE'
         DC    FL1'&DB'
         DC    FL1'&DT'
&NRENTS  SETA  &NRENTS+1
.NCDATA  ANOP
         AIF   ('&LABEL(1)' EQ '').CKLTABS
         AIF   (&LABEL(1) EQ &LB).CKLTABS
&LB      SETA  &LABEL(1)
         AGO   .AAA
.CKLTABS AIF   ('&LABEL(2)' EQ '').NCLABEL
         AIF   (&LABEL(2) EQ &LT).NCLABEL
         AGO   .CCC
.AAA     AIF   ('&LABEL(2)' EQ '').BBB
         AIF   (&LABEL(2) EQ &LT).BBB
.CCC     ANOP
&LT      SETA  &LABEL(2)
.BBB     DC    XL2'FFFF'
         DC    FL1'&LB'
         DC    FL1'&LT'
&NRENTS  SETA  &NRENTS+1
.NCLABEL ANOP
         AIF   ('&SKIP' NE '').CONT
         AIF   (&TEST EQ 0).NOCHANG
         AGO   .DEFALTA
.CONT    ANOP
         AIF   (&TEST EQ 0).AB
         AIF   ('&SKIP' EQ 'E').AB
&S       SETA  &SKIP
.DEFAULT ANOP
         AIF   (&SKIP EQ &LASTCC).DEFALTA
         ORG   &CARRCON+3
         DC    AL.3(0),AL.2(&S),AL.3(1)
         ORG
&LASTCC  SETA  &S
.DEFALTA ANOP
&TEST    SETB  0
         AGO   .DD
.AB      AIF   ('&SKIP' NE 'E').ABB
A&SYSNDX DC    X'FFFB8B00'              EJECT
         AGO   .ABC
.ABB     AIF   (&SKIP EQ &LASTCC).NOCHANG
A&SYSNDX DC    XL2'FFFB'
         DC    AL.3(0),AL.2(&SKIP),AL.3(1)
         DC    AL.3(0),AL.2(&SKIP),AL.3(1)
&LASTCC  SETA  &SKIP
&TEST    SETB  1
.ABC     ANOP
&CARRCON SETC  'A&SYSNDX'
&NRENTS  SETA  &NRENTS+1
.DD      ANOP
.NOCHANG ANOP
         MEND
         MACRO
         LINEND ,
.*                                 THIS MACRO IS USED ONLY BY THE LINE
.*                                 MACRO TO SET THE NUMBER OF ENTRIES
.*                                 ASSOCIATED WITH EACH LINE.
         GBLA  &BITS(2600),&DB,&DT,&INITIAL
         GBLA  &ITEMITR,&ITEMFST(20),&ITEMNBR,&ITEMMDX
         GBLA  &ITEMNDX(2600),&ITEMXPT
         GBLA  &LABELNR,&LASTCC,&LB,&LBLCTR(100),&LPTR,&LT
         GBLA  &NRENTS,&SHIFT(2600)
         GBLB  &DIAGITF,&DIAGLIN,&DIAGSET,&DIAGTST,&FSW,&TEST
         GBLC  &CARRCON,&CSECT,&DSECT,&ITEM(2600)
         GBLC  &LABELS(2600),&LBL(100),&NRENTSX
         ORG   &NRENTSX
         DC    FL1'&NRENTS'
         ORG
&NRENTS  SETA  0
B&SYSNDX EQU   *
&NRENTSX SETC  'B&SYSNDX'
         MEND
           MACRO
&NAME    LABEL &LABEL1,&LABEL2,&LABEL3,&LABEL4,&LABEL5,&LABEL6,        C
               &LABEL7,&LABEL8
.*                                 THIS MACRO ALLOWS LABELS TO
.*                                 BE SPECIFIED FOR A GIVEN LINE. THE
.*                                 LABELS SHOULD BE ENCLOSED IN QUOTA-
.*                                 TION MARKS. THE COLUMN AND LINE END
.*                                 CONTROLS WILL BE INSERTED BY THE
.*                                 MACRO. OMITTED OPERANDS MEAN NO
.*                                 LABEL REQUIRED FOR RESPECTIVE
.*                                 COLUMN.
         GBLA  &BITS(2600),&DB,&DT,&INITIAL
         GBLA  &ITEMITR,&ITEMFST(20),&ITEMNBR,&ITEMMDX
         GBLA  &ITEMNDX(2600),&ITEMXPT
         GBLA  &LABELNR,&LASTCC,&LB,&LBLCTR(100),&LPTR,&LT
         GBLA  &NRENTS,&SHIFT(2600)
         GBLB  &DIAGITF,&DIAGLIN,&DIAGSET,&DIAGTST,&FSW,&TEST
         GBLC  &CARRCON,&CSECT,&DSECT,&ITEM(2600)
         GBLC  &LABELS(2600),&LBL(100),&NRENTSX
         LCLC  &MARGIN,&TACK
         LCLC  &TEXT
         LCLA  &OP,&K,&START,&NRCHAR,&REMAIN
         AIF   (&INITIAL EQ 0).DIAGCLR
         AIF   (&DIAGTST EQ 0).DIAGCLR
         AIF   (&DIAGLIN EQ 1).DIAGCLR
         MNOTE '**NO LINE ASSOCIATED WITH PREVIOUS LABEL**'
***** THE FOLLOWING GENERATED FOR TEST PURPOSES *****
*        LINE
         LINE
.DIAGCLR ANOP
&DIAGSET SETB  0
&DIAGLIN SETB  0
&MARGIN  SETC  '*'
         AIF   ('&NAME' EQ '').LOOPOUT
&LPTR    SETA  &LPTR+1
&LBL(&LPTR) SETC '&NAME'
&LBLCTR(&LPTR) SETA &LABELNR+1
.LOOPOUT ANOP
&OP      SETA  &OP+1
&K       SETA  K'&SYSLIST(&OP)
         AIF (&K GE 2).NORM
&K       SETA  2
.NORM    ANOP
&START   SETA  2
         AIF (&OP LT N'&SYSLIST).NOTLAST
&MARGIN  SETC  '$'
.NOTLAST ANOP
&NRCHAR  SETA  8
&TACK    SETC  ''
.LOOPIN  ANOP
&REMAIN  SETA  &K-&START
         AIF (&REMAIN GE 8).MORE
&TACK    SETC  '&MARGIN'
&NRCHAR  SETA  &REMAIN
.MORE    ANOP
&TEXT    SETC  ''
         AIF (&REMAIN EQ 0).ENDTEXT
&TEXT    SETC  '&SYSLIST(&OP)'(&START,&NRCHAR)
.ENDTEXT ANOP
&LABELNR SETA  &LABELNR+1
&LABELS(&LABELNR) SETC '&TEXT'.'&TACK'
&START   SETA  &START+8
         AIF ('&TACK' EQ '').LOOPIN
         AIF ('&TACK' EQ '*').LOOPOUT
         MEND
         MACRO
&NAME    ROUTINE &LOGITEM,&RNAME
         GBLA  &BITS(2600),&DB,&DT,&INITIAL
         GBLA  &ITEMITR,&ITEMFST(20),&ITEMNBR,&ITEMMDX
         GBLA  &ITEMNDX(2600),&ITEMXPT
         GBLA  &LABELNR,&LASTCC,&LB,&LBLCTR(100),&LPTR,&LT
         GBLA  &NRENTS,&SHIFT(2600)
         GBLB  &DIAGITF,&DIAGLIN,&DIAGSET,&DIAGTST,&FSW,&TEST
         GBLC  &CARRCON,&CSECT,&DSECT,&ITEM(2600)
         GBLC  &LABELS(2600),&LBL(100),&NRENTSX
         AIF   (&DIAGTST EQ 0).NOMSG
         AIF   (&INITIAL EQ 0).NOMSG
         AIF   (&DIAGLIN EQ 1).NOMSG
         MNOTE '**NO LINE ASSOCIATED WITH THIS ROUTINE**'
*****THE FOLLOWING GENERATED FOR TEST PURPOSES*****
*        LINE
         LINE
.NOMSG   ANOP
&NAME    DC    AL.12(&LOGITEM-&DSECT),XL.4'D'
         DC    AL2(&RNAME-&CSECT)
&NRENTS  SETA  &NRENTS+1
         MEND
         MACRO
         ITEMFIND &ARG,&ITFDIAG=
         GBLA  &BITS(2600),&DB,&DT,&INITIAL
         GBLA  &ITEMITR,&ITEMFST(20),&ITEMNBR,&ITEMMDX
         GBLA  &ITEMNDX(2600),&ITEMXPT
         GBLA  &LABELNR,&LASTCC,&LB,&LBLCTR(100),&LPTR,&LT
         GBLA  &NRENTS,&SHIFT(2600)
         GBLB  &DIAGITF,&DIAGLIN,&DIAGSET,&DIAGTST,&FSW,&TEST
         GBLC  &CARRCON,&CSECT,&DSECT,&ITEM(2600)
         GBLC  &LABELS(2600),&LBL(100),&NRENTSX
         LCLA  &A,&B,&X,&I
         LCLC  &C1,&C2,&S
         ACTR  100000
&ITEMXPT SETA  0                  INDICATE ITEM NOT FOUND.
         AIF   ('&ARG' NE '').NORM
         AIF   ('&ITFDIAG' EQ 'OFF'  OR  '&ITFDIAG' EQ 'ON').DIAGSET
  MNOTE 0,'ITEMFIND - OPERAND (&ITFDIAG) INVALID FOR ITFDIAG KEYWORD.'
         MEXIT
.DIAGSET ANOP
&DIAGITF SETB  ('&ITFDIAG' EQ 'ON')
         MEXIT
.NORM    AIF   (&ITEMITR GT 0).SORTED
         ITEMSORT
.SORTED  ANOP
&I       SETA  &ITEMITR           COMPUTED ITTERATION COUNT.
&X       SETA  &ITEMMDX           COMPUTED MAXIMUM INDEX.
&C1      SETC  '&ARG'             ISOLATE SEARCH ARGUMENT.
&C1      SETC  '&C1'.'       '(1,8-K'&C1) PAD TO FULL 8 CHARACTERS.
.SRCHUP  ANOP
&A       SETA  &A+&X              CURRENT TABLE SUBSCRIPT + INDEX.
&S       SETC  '+'
         AIF   (&A  GT &ITEMNBR  AND  NOT &DIAGITF).SRCHDN1
         AIF   (&A  LE &ITEMNBR).SRCH00
&C2      SETC  '*-OVER-*'
&I       SETA  &I-1               DECREMENT ITTERATION COUNTER.
&X       SETA  &X/2               HALVE INDEX VALUE.
 MNOTE *,'&ARG - &C2   ITRCTR = &I   PTR = &A&S &X'
         AIF   (&I GE 0).SRCHDWN  IF ITTERATION COUNT NOT EXPIRED.
.NOFIND  MNOTE  20,' ITEMFIND FAILED FOR NAME  &C1  '
         MEXIT
.SRCH00  ANOP
&I       SETA  &I-1               DECREMENT ITTERATION COUNTER.
         AIF   (&I LT 0).NOFIND   IF COUNT HAS GONE TO ZERO.
&X       SETA  &X/2               HALVE INDEX VALUE.
&B       SETA  &ITEMNDX(&A)       GET SUBSCRIPT FROM INDEX TABLE.
&C2      SETC  '&ITEM(&B)'.'       '(1,8-K'&ITEM(&B))  PAD COMPARAND.
         AIF   (NOT &DIAGITF).COMPARE
 MNOTE *,'&ARG - &C2   ITRCTR = &I   PTR = &A&S &X   POS = &B'
.COMPARE AIF   ('&C1' LT '&C2').SRCHDWN   ARGUMENT LOWER, MOVE DOWN.
         AIF   ('&C1' GT '&C2').SRCHUP    ARGUMENT HIGHER, MOVE UP.
&ITEMXPT SETA  &B                 FOUND. SET INDEX POINTER FOR RETURN.
&ITEMFST(&I+1)  SETA  &ITEMFST(&I+1)+1
         MEXIT
.SRCHDWN ANOP
&A       SETA  &A-&X              CURRENT POINTER MINUS INDEX VALUE.
&S       SETC  '-'
         AIF   (&A LE &ITEMNBR).SRCH00    IF WITHIN BOUNDS OF TABLE.
.SRCHDN1 ANOP
&I       SETA  &I-1               DECREMENT ITTERATION COUNTER.
&X       SETA  &X/2               HALVE INDEX VALUE.
         AIF   (&I GE 0).SRCHDWN  IF ITTERATION COUNT NOT EXPIRED.
         MNOTE  20,' ITEMFIND FAILED FOR NAME  &C1  '
         MEND
         MACRO
         ITEMSORT  &DUMMY
         GBLA  &BITS(2600),&DB,&DT,&INITIAL
         GBLA  &ITEMITR,&ITEMFST(20),&ITEMNBR,&ITEMMDX
         GBLA  &ITEMNDX(2600),&ITEMXPT
         GBLA  &LABELNR,&LASTCC,&LB,&LBLCTR(100),&LPTR,&LT
         GBLA  &NRENTS,&SHIFT(2600)
         GBLB  &DIAGITF,&DIAGLIN,&DIAGSET,&DIAGTST,&FSW,&TEST
         GBLC  &CARRCON,&CSECT,&DSECT,&ITEM(2600)
         GBLC  &LABELS(2600),&LBL(100),&NRENTSX
         LCLA  &R,&ZI,&I,&A1,&A2,&TEMP
         LCLB  &SR,&GOTO,&TB
         LCLB  &SW(3000)
         LCLC  &C1,&C2
         ACTR  100000
&A1      SETA  0
         AIF   (&ITEMITR EQ 0).LOOP0   TEST FOR RE-ENTRY.
 MNOTE   0,'ITEMSORT MACRO OCCURRS MORE THAN ONCE. TABLE NOT RESORTED.'
         MEXIT
.LOOP0   ANOP
&A1      SETA  &A1+1
&ITEMNDX(&A1) SETA &A1
         AIF   (&A1 LT &ITEMNBR).LOOP0
         AIF   (&ITEMNBR LT 2).MEXIT
&A1      SETA  &ITEMNBR/2         HALF OF TOTAL ENTRIES.
&A2      SETA  0
.LOOP1   ANOP
&A2      SETA  &A2+1
&SW(&A2) SETB  1                  SET FIRST HALF OF SWITCHES TO 1.
         AIF   (&A2 LT &A1).LOOP1
.LOOP2   ANOP
&A2      SETA  &A2+1
&SW(&A2) SETB  0                  SET SECOND HALF TO ZERO.
         AIF   (&A2 LT &ITEMNBR).LOOP2
&R       SETA  0                  SET R TO FIRST TRIAL ITEM.
&ZI      SETA  &ITEMNBR-1         SET ZI TO LAST ITEM.
&I       SETA  &ZI-1
.T3      ANOP
&SR      SETB  (&SW(&R+1))        GET FLAG, WHICH WAY TO GO?
&R       SETA  (&R*2)+1+&SR       R=2R+(1 OR 2)
         AIF   (&R LE &I).T3
.T4      ANOP
&R       SETA  (&R-1)/2           R=(R-1)/2
&SR      SETB  (&SW(&R+1))        GET SUBTREE SELECT FLAG.
         AIF   (&SR EQ 0).T7
         AIF   (&GOTO EQ 0).T5
.T7      ANOP
&A1      SETA  &ITEMNDX(&R+1)
&A2      SETA  &ITEMNDX(&ZI+1)
&C1      SETC  '&ITEM(&A1)'.'       '(1,8-K'&ITEM(&A1))
&C2      SETC  '&ITEM(&A2)'.'       '(1,8-K'&ITEM(&A2))
         AIF   ('&C1' LT '&C2').T8
.T9      ANOP
&TEMP    SETA  &ITEMNDX(&R+1)     Z(R) TO TEMP.
&TB      SETB  (&SW(&R+1))
&ITEMNDX(&R+1) SETA &ITEMNDX(&ZI+1)    Z(I) TO Z(R)
&SW(&R+1) SETB (&SW(&ZI+1))
&ITEMNDX(&ZI+1) SETA &TEMP        TEMP TO Z(I)
&SW(&ZI+1) SETB (&TB)
&SR      SETB  (&SR EQ 0)
&SW(&R+1) SETB (&SR)
.T8      AIF   (&R GT 0).T4
&GOTO    SETB  1                  SET 'GO TO' T7
&ZI      SETA  &ZI-1
&I       SETA  &I-1
         AIF   (&I GE 0).T3
.MEXIT   ANOP
&ITEMITR SETA 1
&ITEMMDX SETA 1
.ITRLOOP ANOP
&ITEMITR SETA &ITEMITR+1
&ITEMMDX SETA &ITEMMDX+&ITEMMDX
         AIF  (&ITEMMDX LT &ITEMNBR).ITRLOOP
&ITEMITR SETA &ITEMITR-1
&ITEMMDX SETA &ITEMMDX/2
&A1      SETA &ITEMNBR
&A2      SETA &ITEMMDX
&TEMP    SETA &ITEMITR
 MNOTE *,' ITEMS = &A1, MAX INDEX = &A2, ITTERATION COUNT = &TEMP'
         MEXIT
.T5      ANOP
&TEMP    SETA  &ITEMNDX(&R+1)     Z(R) TO TEMP.
&TB      SETB  (&SW(&R+1))
&ITEMNDX(&R+1) SETA &ITEMNDX(&ZI+1)    Z(I) TO Z(R)
&SW(&R+1) SETB (&SW(&ZI+1))
&ITEMNDX(&ZI+1) SETA &TEMP        TEMP TO Z(I)
&SW(&ZI+1) SETB (&TB)
&SR      SETB  (&SR EQ 0)
&SW(&R+1) SETB (&SR)
         AGO   .T3
         MEND
         MACRO
         LSTART ,
.*                            THIS MACRO IS ISSUED WHEN THE LABEL AREA
.*                                 OF THE TABLE IS TO BEGIN.
         GBLA  &BITS(2600),&DB,&DT,&INITIAL
         GBLA  &ITEMITR,&ITEMFST(20),&ITEMNBR,&ITEMMDX
         GBLA  &ITEMNDX(2600),&ITEMXPT
         GBLA  &LABELNR,&LASTCC,&LB,&LBLCTR(100),&LPTR,&LT
         GBLA  &NRENTS,&SHIFT(2600)
         GBLB  &DIAGITF,&DIAGLIN,&DIAGSET,&DIAGTST,&FSW,&TEST
         GBLC  &CARRCON,&CSECT,&DSECT,&ITEM(2600)
         GBLC  &LABELS(2600),&LBL(100),&NRENTSX
         LCLA  &NDX,&CTR
         ACTR  500000
         AIF   (&DIAGTST EQ 0).NODIAG
         AIF   (&DIAGSET EQ 0).NODIAG
         MNOTE '**NO LABEL ASSOCIATED WITH LAST SET**'
***** THE FOLLOWING GENERATED FOR TEST PURPOSES *****
*        LABEL '%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'
               LABEL '%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'
.NODIAG  ANOP
         LINEND
&CTR     SETA  1
.LOOP    ANOP
&NDX     SETA  &NDX+1
         AIF   (&LBLCTR(&CTR) NE &NDX).NOLBL
&LBL(&CTR) DC  C'&LABELS(&NDX)'
&CTR     SETA  &CTR+1
         AGO   .LOOPCTL
.NOLBL   ANOP
         DC    C'&LABELS(&NDX)'
.LOOPCTL AIF   (&NDX LT &LABELNR).LOOP
         MEND
         MACRO
         CONVT ,
         GBLA  &BITS(2600),&DB,&DT,&INITIAL
         GBLA  &ITEMITR,&ITEMFST(20),&ITEMNBR,&ITEMMDX
         GBLA  &ITEMNDX(2600),&ITEMXPT
         GBLA  &LABELNR,&LASTCC,&LB,&LBLCTR(100),&LPTR,&LT
         GBLA  &NRENTS,&SHIFT(2600)
         GBLB  &DIAGITF,&DIAGLIN,&DIAGSET,&DIAGTST,&FSW,&TEST
         GBLC  &CARRCON,&CSECT,&DSECT,&ITEM(2600)
         GBLC  &LABELS(2600),&LBL(100),&NRENTSX
         LCLB  &SUB
         LCLA  &OP
         LCLA  &OFFSET,&OUT,&IN,&IND,&IBITS,&ISHIFT
.*
.*       CONVERT BINARY TO DECIMAL
.*             &NAME IS THE REFERENCE INTO THE DSECT RECORD
.*             &OUT    IS THE NUMBER OF CHARS TO BE PUT ONTO PRINT LINE
.*                                      DEFAULT IS FOUR MAXIMUM IS 8
.*             &IN       IS THE NUMBER OF BYTES AS INPUT
.*                                      ERROR DEFAULT IS 2 MAXIMUM IS 4
.*
         AIF   (&DIAGTST EQ 0).NOMSG
         AIF   (&INITIAL EQ 0).NOMSG
         AIF   (&DIAGLIN EQ 1).NOMSG
         MNOTE '**NO LINE ASSOCIATED WITH THIS DATA**'
*****THE FOLLOWING GENERATED FOR TEST PURPOSES*****
*        LINE
         LINE
.NOMSG   ANOP
         AIF   (K'&SYSLIST(1) EQ K'&SYSLIST(1,1)).LLOP
&SUB     SETB  1
.LLOP    ANOP
&OP      SETA  &OP+1
&OUT     SETA  4                        .BR NOT NULL ELSE SET TO 4
         AIF   (&SUB EQ 1).SUBA
         AIF   ('&SYSLIST(3)' EQ '').B  TEST FOR NULL INPUT
&OUT     SETA  &SYSLIST(3)             SET &OUT FROM INPUT
         AGO   .A
.SUBA    AIF   ('&SYSLIST(&OP,3)' EQ '').B
&OUT     SETA  &SYSLIST(&OP,3)          SET &OUT FROM INPUT
.A       AIF   (&OUT GT 0 AND &OUT LT 9).B   TEST RANGE
.AERR    MNOTE '*** BYTES OUT INCORRECTLY SPECIFIED DEFAULT USED ***'
&OUT     SETA  4
.B       AIF   (&SUB EQ 1).SUBB
         AIF   ('&SYSLIST(2)' EQ '').LOOP    BRANCH IF NULL
&IN      SETA  &SYSLIST(2)              .SET &IN FROM INPUT
         AGO   .BB
.SUBB    AIF   ('&SYSLIST(&OP,2)' EQ '').LOOP
&IN      SETA  &SYSLIST(&OP,2)          .SET &IN FROM INPUT
.BB      AIF   (&IN GT 0 AND &IN LT 5).D     TEST RANGE
.BERR    MNOTE '*** BYTES IN INCORRECTLY SPECIFIED DEFAULT USED ***'
&IN      SETA  2
         AGO   .D
.LOOP    ANOP                           .LOOP TO FIND &NAME IN DSECT
&IND     SETA  &IND+1                   .SET UP LOOP COUNTER
         AIF   ('&ITEM(&IND)' EQ '&SYSLIST(&OP,1)').FOUND
         AIF   (&IND LT &ITEMNBR).LOOP  .TEST FOR END OF DSECT
         MNOTE '*** LOG ITEM NOT DEFINED ***'
         MEXIT
.FOUND   ANOP
&IBITS   SETA  &BITS(&IND)              .SET UP NUMBER OF BITS SPEC
         AIF   (&IBITS-((&IBITS/8)*8) EQ 0).C  .TEST FOR MULTIPLE OF 8
         MNOTE '*** DATA NOT DEFINED A MULTIPLE OF 8 BITS ***'
         MEXIT
.C       ANOP
&IN      SETA  &IBITS/8                 .COMPUTE NUMBER OF BYTES
         AIF   (&IN LT 1 OR &IN GT 4).BERR  .TEST RANGE B IF IN ERROR
&ISHIFT  SETA  &SHIFT(&IND)             .SET UP FOR TEST OF BYTE BNDR
         AIF   (&ISHIFT EQ 0).D         .TEST FOR BYTE BNDRY
         MNOTE '*** DATA NOT ALIGNED ON A BYTE BOUNDARY ***'
         MEXIT
.*
.D       ANOP
&NRENTS  SETA  &NRENTS+1
         DC    AL.12(&SYSLIST(&OP,1)-&DSECT),AL.4(9)
         DC    X'&IN',X'&OUT'
&IND     SETA  0
         AIF   (&SUB EQ 0).OUTA
         AIF   (&OP LT N'&SYSLIST).LLOP
.OUTA    ANOP
         MEND
IFCESOFT CSECT
         GBLC  &DSECT,&CSECT
&CSECT   SETC  'IFCESOFT'
&DSECT   SETC  'RTMREC'
RTMREC   DSECT
         DSGEN (CLASSRC,8),(SYSREL,8),(,8),(ERRORID,8)
         DSGEN (,32)
         DSGEN (DUM1,8),(YEAR,8),(DAY,16),(TIME,32)
         DSGEN (,8),(CPUSER,24),(CPUID,16),(,16)
         DSGEN (JOBID,64)
         DSGEN (,64)
         DSGEN (SDWACMKA,8),(SDWAMWPA,8),(SDWAINTA,16),(SDWAPMKA,8),   X
               (SDWANXTA,24)
         DSGEN (SDWACMKP,8),(SDWAMWPP,8),(SDWAINTP,16),(SDWAPMKP,8),   X
               (SDWANXTP,24)
         DSGEN (GR,32,0,15)
         DSGEN (SDWANAME,64)
         DSGEN (,32),(,32)
         DSGEN (SDWAEC1A,32),(SDWAEC1B,32)
         DSGEN (,8),(SDWAILC1,8),(SDWAINC1,16),(SDWATRN1,32)
         DSGEN (SDWAEC2A,32),(SDWAEC2B,32)
         DSGEN (,8),(SDWAILC2,8),(SDWAINC2,16),(SDWATRN2,32)
         DSGEN (GPR,32,0,15)
         DSGEN (SDWASPID,8),(SDWALNTH,24)
         DSGEN (SDWASCKB,32),(SDWASCKE,32)
         DSGEN (SDWASRVL,1),(SDWARCDF,1),(SDWATSVL,1),(SDWAINVP,1),    C
               (SDWARSRC,1),(SDWARSRF,1),(,2)
         DSGEN (SDWASKYF,1),(SDWAREGU,1),(SDWAPSWU,1),(SDWASCK,1),     C
               (SDWAACR,1),(SDWAINSF,1),(SDWASOFT,1),(SDWATERR,1)
         DSGEN (SDWACPID,16),(,6),(SDWAMSER,1),(SDWACHNG,1)
         DSGEN (SDWAOFLN,1),(SDWAINTC,1),(SDWASPER,1),(SDWANUCL,1),    C
               (SDWAFSQA,1),(SDWAFLSQ,1),(SDWAPGFX,1),(SDWAVEQR,1),    C
               (,16)
         DSGEN (SDWARFSA,32)
         DSGEN (DUM2,8),(SDWAYEAR,8),(SDWADAY,16),(SDWAHRS,8),         C
               (SDWAMINS,8),(SDWASECS,8),(SDWATNTH,8)
         DSGEN (SDWAMCHK,1),(SDWAPCHK,1),(SDWARKEY,1),(SDWASVCD,1),    C
               (SDWAABTM,1),(SDWASVCE,1),(SDWATEXC,1),(SDWAPGIO,1)
         DSGEN (,4),(SDWATYP1,1),(SDWAENRB,1),(SDWALDIS,1),(SDWASRBM,1)
         DSGEN (SDWASTAF,1),(SDWASTAI,1),(SDWAIRB,1),(SDWAPERC,1),     C
               (SDWAEAS,1),(,3)
         DSGEN (SDWACLUP,1),(SDWANRBE,1),(SDWASTAE,1),(SDWACTS,1),     C
               (SDWAMABD,1),(SDWARPIV,1),(SDWAMCIV,1),(,1)
         DSGEN (SDWAFMID,16)
         DSGEN (SDWAIOQR,1),(SDWAIOHT,1),(SDWANOIO,1),(SDWANIOP,1),(,4)
         DSGEN (,104)
         DSGEN (SDWARCDE,8)
         DSGEN (SDWARCRD,1),(,1),(SDWASPIN,1),(,1),(SDWAUPRG,1),       C
               (SDWAFREE,1),(,2)
         DSGEN (,3),(SDWADISP,1),(SDWAASMP,1),(SDWASALL,1),     YM06007C
               (SDWAIPRG,1),(SDWAICAT,1)                        YM06007
         DSGEN (SDWAIUCB,1),(SDWAILCH,1),(SDWATNCB,1),          YM06007C
               (SDWATDNB,1),(SDWATADB,1),(SDWAOPTM,1),          YM06007C
               (SDWACMS,1),(SDWAFLLK,1)                         YM06007
         DSGEN (SDWAICLW,32),(SDWAIULW,32),(SDWAILLW,32),(SDWAIPLW,32),C
               (SDWAAPLW,32),(SDWATNLW,32),(SDWATDLW,32),(SDWATALW,32),C
               (SDWAASID,16),(DUM3,16)                         @ZA06000
         DSGEN (SDWAMODN,64)
         DSGEN (SDWACSCT,64)
         DSGEN (SDWAREXN,64)
         DSGEN (SDWADPLA,32)
         DSGEN (SDWADPID,8),(SDWADPT,1),(SDWADLST,1),(,4),(SDWASLST,1),C
               (,1),(,16)
         DSGEN (SDWANUC,1),(SDWASQA,1),(SDWALSQA,1),(SDWASWA,1),       C
               (SDWAGTF,1),(SDWACBS,1),(SDWAQQS,1),(,9)
         DSGEN (SDWADSAS,1),(SDWADSAH,1),(SDWADREG,1),(SDWATLPA,1),    C
               (SDWATJPA,1),(SDWADPSW,1),(SDWAUSPL,1),(,9)
         DSGEN (SDWAFRM1,32),(SDWATO1,32),(SDWAFRM2,32),(SDWATO2,32)
         DSGEN (SDWAFRM3,32),(SDWATO3,32),(SDWAFRM4,32),(SDWATO4,32)
         DSGEN (,32)
         DSGEN (SDWARCPL,224)
         DSGEN (SDWACOMP,32),(,32)
         DSGEN (SDWAVRAL,16),(SDWADPVA,8),(SDWAURAL,8),(SDWAVRA,864)
         DSGEN (MRCOUNT,8,EQU,JOBID)                            YM05012
IFCESOFT CSECT
         USING *,R9
         USING RTMREC,R2
         DC    A(ENTRIES)
         DC    CL8'IFCESOFT'
ENTRYPTR DC    F'0'
LABELPTR DC    F'0'
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
L0       EQU   0
L1       EQU   1
L2       EQU   2
L3       EQU   3
L4       EQU   4
L5       EQU   5
L6       EQU   6
L7       EQU   7
L8       EQU   8
L9       EQU   9
L10      EQU   10
L11      EQU   11
L12      EQU   12
L13      EQU   13
L14      EQU   14
L15      EQU   15
*                                                                     *
* THIS CODE WILL DETERMINE THE SOURCE OF THE SOFTWARE RECORD FROM THE *
* INFORMATION IN THE LAST FOUR BITS IN THE RECORD TYPE(1ST BYTE)      *
*                                                                     *
*
TYPEREC  STM   R4,R8,SAVEREG           SAVE REGISTERS
         TM    CLASSRC,X'0F'           IS THIS A LOST RECORD SUMMARY
         LA    R6,TYPETAB+80           GET OFFSET INTO TABLE
         BO    PUTTYPE                 PUT THE TYPE INTO PRINT BUFFER
         TM    CLASSRC,X'08'           IS THIS RTM CALLED BY MCH
         LA    R6,TYPETAB+64           GET OFFSET INTO TABLE
         BO    PUTTYPE                 PUT THE TYPE INTO PRINT BUFFER
         TM    CLASSRC,X'04'           IS THIS A RESTART BY OPERATOR
         LA    R6,TYPETAB+48           GET OFFSET INTO TABLE
         BO    PUTTYPE                 PUT THE TYPE INTO PRINT BUFFER
         SR    R5,R5                   CLEAR REGISTER
         IC    R5,CLASSRC              GET RECORD TYPE
         SLL   R5,28                   ISOLATE LAST FOUR BITS
         SRL   R5,24                   DETERMINE RECORD SOURCE
         LA    R6,TYPETAB(R5)          GET ADDRESS OF IDENTIFIER
PUTTYPE  MVC   0(16,R3),0(R6)          MOVE IT INTO PRINT BUFFER
*                                                                     *
* THIS CODE TAKES THE NS CLOCK TIME FROM THE MACHINE CHECK SECTION OF *
* THE RECORD AND CONVERTS IT TO A USEABLE FORMAT.                     *
*                                                                     *
         LM    R6,R7,DUM2              GET NS TIME FROM RECORD
         LTR   R6,R6                   IF TIME IS ZERO
         BNZ   CONTINUE
         LTR   R7,R7
         BZ    ENDUP                   RETURN WITH NO CONVERSION
CONTINUE SRDL  R6,L12                  GET RID OF ALL BUT MICRO SECONDS
         D     R6,SIXTYMIL             DIVIDE TO GET MINUTES
         SR    R4,R4                   CLEAR REG
         LR    R5,R6                   PICK UP MICRO SECONDS REMAINDER
         D     R4,MILLION              DIVIDE TO GET FULL SECONDS
         CVD   R5,DECBYTE              CONVERT FULL SECONDS
         L     R6,DECBYTE+L4           PICK UP THE VALUE
         SRL   R6,4                    SHIFT OUT ZONE
         STC   R6,SDWASECS             STORE SECONDS IN RECORD
         NI    SDWATNTH,X'00'          ZERO OUT THE TNTHS FIELD
         SR    R6,R6                   CLEAR REG FOR DIVIDE
         D     R6,SIXTY                R7 HAS # MINS-COMPUTE HOURS
         CVD   R6,DECBYTE              CONVERT NUMBER OF MINUTES
         L     R6,DECBYTE+L4           PICK UP THE NUMBER OF MINUTES
         SRL   R6,4                    SHIFT OUT ZONE
         STC   R6,SDWAMINS             STORE NUMBER OF MINUTES
         SR    R6,R6                   CLEAR REG FOR DIVIDE
         D     R6,TWENTY4              R7 HAS # OF HOURS-COMPUTE DAYS
         CVD   R6,DECBYTE              CONVERT NUMBER OF HOURS
         L     R6,DECBYTE+L4           PICK UP NUMBER OF HOURS
         SRL   R6,L4                   SHIFT OUT ZONE
         STC   R6,SDWAHRS              STORE THE HOURS
         LA    R6,365                  LOAD DAY CONSTANTS FOR SUBTRACT
         LA    R8,366                  LOAD DAY CONSTANTS FOR SUBTRACT
         TM    DUM2,X'80'              IS THIS TIME BASED ON 1900
         BZ    SETUP                   NO - USE 1960
         LA    R5,4                    LOAD 4 FOR BCT-1900 NO LEAP YEAR
         SR    R4,R4                   CLEAR YEAR COUNT
         B     REGYEAR
SETUP    LA    R4,60                   SET YEAR COUNT TO 60
LEAP     SR    R7,R8                   SUBTRACT 366 FOR LEAP YEAR
         BM    ADD366                  DAYS COMPLETED-CONV DONE
         LA    R4,1(R4)                INCREMENT YEAR COUNT
         LA    R5,3                    SET BCT COUNT FOR THREE LOOPS
REGYEAR  SR    R7,R6                   SUBTRACT 365 FROM TOTAL DAYS
         BM    ADD365                  IF DAYS LESS THAN ZERO-FINISH
         LA    R4,1(R4)                INCREMENT DAY COUNT
         BCT   R5,REGYEAR              DID WE GO THROUGH ENOUGH TIMES
         B     LEAP
ADD365   LA    R7,365(R7)              ADD BACK 365 DAYS
         B     CONVFIN                 GO TO CONVERT DAY AND YEAR
ADD366   LA    R7,366(R7)              ADD BACK IN 366 DAYS
CONVFIN  LA    R7,1(R7)                INCREMENT DAY COUNT BY 1
         CVD   R4,DECBYTE              CONVERT YEAR
         L     R4,DECBYTE+L4
         SRL   R4,L4                   SHIFT OUT ZONE BITS
         STC   R4,SDWAYEAR             PUT YEAR IN RECORD
         CVD   R7,DECBYTE              CONVERT DAY COUNT
         L     R7,DECBYTE+L4
         STH   R7,SDWADAY              STORE DAY IN RECORD AREA
ENDUP    OI    SDWADAY+1,X'0F'         PUT IN ZONE BITS
         LM    R4,R8,SAVEREG
         BR    R14                     RETURN
TWENTY4  DC    F'24'
SIXTY    DC    F'60'
MILLION  DC    F'1000000'
SIXTYMIL DC    F'60000000'
TYPETAB  DC    CL16'SOFTWARE(SVC 13)'                           YM04255
         DC    CL16'INVALID TYPE'                               YM04255
         DC    CL16'PROGRAM CHECK'
         DC    CL16'OPERATOR RESTART'
         DC    CL16'MCH CALLED RTM'
         DC    CL16'LOST REC SUMMARY'
*                                                                     *
* THIS ROUTINE UNPACKS THE DATE AND MOVES IT TO THE PRINT BUFFER      *
*                                                                     *
*                                                                     *
SETDATE  UNPK  DECBYTE(L5),L0(L3,R4)   UNPACK DATE FROM RECORD
         MVC   L9(L3,R3),DECBYTE+L2    MOVE DAY TO BUFFER
         MVC   L13(L2,R3),DECBYTE      MOVE YEAR TO BUFFER
         LA    R3,L9(R3)               UPDATE PRINT BUFFER POINTER
         BR    R14                     RETURN
SAVEREG  DC    5F'0'
DECBYTE  DC    D'0'
*                                                                     *
* REDUCE THE PRINT BUFFER POINTER BY 4 BYTES                          *
*                                                                     *
SUB4     SH    R3,FOUR                 REDUCE PRINT BUFFER PTR BY FOUR
         BR    R14
FOUR     DC    H'4'
*                                                                     *
* THIS CODE WILL INTERPRET THE RELEASE LEVEL FROM THE RECORD HEADER   *
*                                                                     *
*                                                                     *
RELSE    STM   R6,R7,SAVEREG           SAVE REGS
         SR    R6,R6                   CLEAR REGISTER
         IC    R6,SYSREL               GET RELEASE FROM RECORD
         SRDL  R6,L5                   ISOLATE RELEASE NUMBER
         SRL   R7,27
         CVD   R7,DECBYTE              CONVERT RELEASE NUMBER
         UNPK  L10(L2,R3),DECBYTE+L6(L2) UNPACK IT TO PRT BUFFER
         OI    L11(R3),X'F0'           MAKE IT PRINTABLE
         SLL   R6,L2                   MUTIPLY RELEASE TYPE BY 4
         LA    R7,RELTAB(R6)           GET ADDRESS OF IDENTIFIER
         MVC   L0(L4,R3),L0(R7)        MOVE IDENTIFIER
         LM    R6,R7,SAVEREG           RELOAD REGISTERS
         BR    R14                     RETURN
RELTAB   DS    0C                                              @XL03976
         DC    C'OS  '                                         @XL03976
         DC    C'DOS '                                         @XL03976
         DC    C'VS 1'                                         @XL03976
         DC    C'V370'                                         @XL03976
         DC    C'VS 2'                                         @XL03976
         DC    C'    '                                         @XL03976
         DC    C'    '                                         @XL03976
         DC    C'    '                                         @XL03976
*                                                                     *
* THIS CODE WILL TEST FOR MODULE NAMES BY CHECKING THE FIRST BYTE TO
* SEE IF IT IS HEX ZEROES. IF ZEROES THE NAME IS NOT MOVED TO THE     *
* BUFFER.                                                             *
*                                                                     *
MOVENAME TM    L0(R4),X'FF'            IS THERE A VALID NAME
         BZ    NOTAPP                  NO GO TO PUT IN N/A
         MVC   L0(L8,R3),L0(R4)        MOVE NAME TO PRINT BUFFER
         B     ADD11                   INCREMENT PRINT BUFFER PTR
NOTAPP   MVC   L0(L3,R3),NA            MOVE N/A TO PRINT BUFFER
ADD11    LA    R3,L11(R3)              INCREMENT PRINT BUFFER PTR
DONOTHNG BR    R14                     RETURN
NA       DC    CL3'N/A'
*                                                                     *
* THIS CODE WILL CHECK FOR A X'4F' TYPE RECORD TO DETERMINE IF        *
* PROCESSING WILL CONTINUE. IF X'4F' IS FOUND ONLY A 1 BYTE COUNT IS  *
* PRINTED.                                                            *
*                                                                     *
CHECK4F  ST    R7,SAVEREG              SAVE REG                 YM05012
         CLI   CLASSRC,X'4F'           SHORT RECORD?            YM05012
         BNE   NOPRINT                 NO-CONTINUE PROCESSING   YM05012
         LA    R7,LENGTH-4             GET ADDRESS OF DUMP LIST YM05012
         ST    R7,ENTRYPTR             PUT IT IN TABLE          YM05012
         L     R7,SAVEREG              RELOAD REGISTER          YM05012
         BR    R14                     RETURN                   YM05012
*                                                                     *
* THIS ROUTINE INCREMENTS THE PRINT BUFFER POINTER BY 19 BYTES        *
*                                                                     *
ADD15    LA    R3,15(R3)               INCREMENT POINTER
         BR    R14                     RETURN
*                                                                     *
* THIS ROUTINE WILL INCREMENT THE PRINT BUFFER POINTER BY 43 BYTES    *
*                                                                     *
ADD43    LA    R3,43(R3)               INCREMENT REGISTER
         BR    R14                     RETURN
*                                                                     *
* THESE ROUTINES WILL CHANGE THE POINTER TO THE PRINT BUFFER.         *
*                                                                     *
SUB39    SH    R3,HF39                 CHANGE PRINT BUFFER POINTER
         BR    R14                     RETURN
HF39     DC    H'39'
SUB46    SH    R3,HF46                 CHANGE BUFFER POINTER
         BR    R14                     RETURN
HF46     DC    H'46'
SUB50    SH    R3,HF50                 CHANGER PRINT BUFFER POINTER
         BR    R14                     RETURN
HF50     DC    H'50'
*                                                                     *
* THIS CODE WILL DETERMINE IF THE RECORD HAS INFORMATION TO BE PUT OUT*
* IN EBCDIC FORMAT. IF SO THE INFO CANNOT BE LONGER THAN THE PRINT    *
* BUFFER.                                                             *
*                                                                     *
USERDAT  TM    SDWADPVA,X'40'          IS AN EBCDIC DUMP WANTED YM05092
         BZ    NOPRINT                 NO-DO NOT PRINT HEADING
         ST    R5,SAVEREG              SAVE REGISTER
         SR    R5,R5                   CLEAR REGISTER
         IC    R5,SDWAURAL             GET LENGTH OF USER DATA
         LTR   R5,R5                   IS IT ZERO
         L     R5,SAVEREG              RELOAD REGISTER
         BZ    NOPRINT                 ZERO-DO NOT PRINT HEADING
         BR    R14                     RETURN
NOPRINTA L     R5,SAVEREG              RELOAD REGISTER
NOPRINT  SR    R15,R15                 SET CODE FOR NO PRINT
         BR    R14                     RETURN
MOVEUSER TM    SDWADPVA,X'40'          IS AN EBCDIC DUMP WANTED YM05092
         BZ    NOPRINT                 NO-DO NOT PRINT HEADING
         ST    R5,SAVEREG              SAVE REGISTER
         SR    R5,R5                   CLEAR REGISTER
         IC    R5,SDWAURAL             GET LENGTH OF USER DATA
         LTR   R5,R5                   IS IT ZERO
         BZ    NOPRINTA                ZERO-DO NOT PRINT HEADING
         CLI   SDWAURAL,X'78'          IS SIZE GREATER THAN BUFFER
         BH    NOPRINTA                IF YES DO NOT MOVE IT
         BCTR  R5,0                    REDUCE BY ONE FOR MOVE
         EX    R5,MOVEIT               MOVE INFO TO BUFFER
         L     R5,SAVEREG              RELOAD REGISTER
         BR    R14                     RETURN
MOVEIT   MVC   L0(L1,R3),SDWAVRA       MOVE CONTENTS OF USER AREA
NOID     TM    0(R4),X'20'         ERRORID PRESENT?            @G17EFFR
         BO    NOPRINT             YES,DO NOT PRINT THIS LINE  @G17EFFR
         BR    R14                 NO ERRORID PRINT LINE       @G17EFFR
CHKID    TM    0(R4),X'20'         ERRORID PRESENT?            @G17EFFR
         BNO   NOPRINT             NO,SKIP THIS LINE           @G17EFFR
         STM   R4,R8,SAVEREG       SAVE REGS                   @G17EFFR
         LR    R5,R2               PTR TO RECORD               @G17EFFR
         SH    R5,TWO              BACKUP TO RECORD COUNT      @G17EFFR
         MVC   WRKID(2),0(R5)      RECORD COUNT TO WRKIDAREA   @G17EFFR
         AH    R5,WRKID            ADD COUNT TO REC PTR        @G17EFFR
         SH    R5,EIGHT            PT TO ERRORID               @G17EFFR
         MVC   WRKID+2(10),0(R5)   MOVE ERRORID TO WRKIDAREA   @G17EFFR
         LA    R5,WRKID+2          PT TO WRKIDAREA             @G17EFFR
         LA    R4,ERRID            PT TO OUTPUT LABEL          @G17EFFR
         BAL   R7,CONVERT          CONVERT SEQUENCE NO.        @G17EFFR
         MVC   SEQOUT(5,R4),XWORK MOVE TO LABEL                @G17EFFR
         LH    R6,WRKID+4          GET HEX CPUID               @G17EFFR
         BAL   R5,HEXCNV           CONVERT HEX TO EBCDIC       @G17EFFR
         MVC   CPUOUT(4,R4),XWORK  MOVE EBCDIC TO MSG          @G17EFFR
         LH    R6,WRKID+6          GET HEX ASID                @G17EFFR
         BAL   R5,HEXCNV           CONVERT HEX TO EBCDIC       @G17EFFR
         MVC   ASIDOUT(4,R4),XWORK MOVE EBCDIC TO MSG          @G17EFFR
*                                                              @G17EFFR
         L     R6,WRKID+8           PICK UP TENTHS OF SECS     @G17EFFR
         C     R6,TEN              LESS 10/10 OF A SEC         @G17EFFR
         BL    TENTHS              YES                         @G17EFFR
         SRDA  R6,32(0)            SHIFT TENTHS TO R7          @G17EFFR
         D     R6,TEN              DIVIDE TO GET SECONDS       @G17EFFR
TENTHS   STC   R6,TSECOUT(R4)      REMAINDER IS TENTHS         @G17EFFR
         OI    TSECOUT(R4),X'F0'   MAKE IT XWORK               @G17EFFR
*                                                              @G17EFFR
         LA    R5,WRKID             PT TO WRKIDAREA            @G17EFFR
         XC    0(6,R5),0(R5)       CLEAR WRKIDAREA             @G17EFFR
         LA    R8,2                                            @G17EFFR
COMP     C     R7,SIXTY            LESS THAN SIXTY             @G17EFFR
         BL    DONE                YES,WE ARE DONE             @G17EFFR
         SR    R6,R6               CLEAR REG 6 FOR DIVIDE      @G17EFFR
         D     R6,SIXTY            DIVIDE FOR SEC,MIN OR HRS   @G17EFFR
         STH   R6,0(R5)            STORE REMAINDER IN WRKIDAREA@G17EFFR
         LA    R5,2(R5)            NEXT HALF WORD OF WRKID     @G17EFFR
         BCT   R8,COMP             PROCESS NEXT TIME INCR      @G17EFFR
DONE     STH   R7,0(R5)            LAST INCR INTO WRKID        @G17EFFR
         LA    R5,WRKID             PT TO BEGIN OF WRKID       @G17EFFR
         LA    R4,SECOUT(R4)       PT TO SECONDS IN LABEL      @G17EFFR
         LA    R8,3                LOOP COUNT                  @G17EFFR
HHMMSS   BAL   R7,CONVERT          CONVERT TO XWORK            @G17EFFR
         MVC   0(2,R4),XWORK+3    MOVE TO LABEL                @G17EFFR
         SH    R4,THREE            DECREMENT LABEL PTR         @G17EFFR
         LA    R5,2(R5)                                        Z12033FR
         BCT   R8,HHMMSS           LOOP BACK FOR NEXT          @G17EFFR
*                                                              @G17EFFR
         LM    R4,R8,SAVEREG       RESTORE REGS                @G17EFFR
         BR    R14                 GO PRINT ERRORID            @G17EFFR
HEXCNV   DS    0H                  HEX CONVERSION ROUTINE      @G17EFFR
         SRDL  R6,12               SHIFT OFF ALL BUT 1ST 4 BITS@G17EFFR
         LA    R8,3                LOOP CONTROL                @G17EFFR
SHIFT    SLL   R6,4                SPACE OVER 4 BITS           @G17EFFR
         SLDL  R6,4                GET NEXT 4 BITS             @G17EFFR
         BCT   R8,SHIFT            LOOP BACK FOR NEXT          @G17EFFR
         ST    R6,XWORK            STORE RESULT IN WORK AREA   @G17EFFR
         NI    XWORK,X'0F'         CLEAR SIGN BITS             @G17EFFR
         TR    XWORK(4),XLATE      TRANSLATE TO EBCDIC         @G17EFFR
         BR    R5                  RETURN TO CALLER            @G17EFFR
XLATE    DC    C'0123456789ABCDEF'                             @G17EFFR
CONVERT  DS    0H                  DECIMAL CONVERSION ROUTINE  @G17EFFR
         LH    R6,0(R5)            GET HALF WORD TO BE CONVERTED
         N     R6,PROGSIGN         DELETE PROPOGATED SIGN BITS @XA20475
         CVD   R6,XWORK           CONVERT TO DECIMAL           @G17EFFR
         UNPK  XWORK(5),XWORK+5(3) 5 DIGITS MAX                @G17EFFR
         OI    XWORK+4,X'F0'      LAST CHAR TO XWORK           @G17EFFR
         BR    R7                  RETURN TO CALLER            @G17EFFR
ERRIDOUT EQU   0                                               @G17EFFR
SEQOUT   EQU   ERRIDOUT+11                                     @G17EFFR
CPUOUT   EQU   ERRIDOUT+20                                     @G17EFFR
ASIDOUT  EQU   ERRIDOUT+29                                     @G17EFFR
HRSOUT   EQU   ERRIDOUT+38                                     @G17EFFR
MINOUT   EQU   ERRIDOUT+41                                     @G17EFFR
SECOUT   EQU   ERRIDOUT+44                                     @G17EFFR
TSECOUT  EQU   ERRIDOUT+47                                     @G17EFFR
TEN      DC    F'10'                                           @G17EFFR
EIGHT    DC    H'8'                                            @G17EFFR
THREE    DC    H'3'                                            @G17EFFR
TWO      DC    H'2'                                            @G17EFFR
         DS    0F                                              @XA20475
PROGSIGN DC    X'0000FFFF'         MASK PROPOGATED SIGN BITS   @XA20475
XWORK    DS    1D                                              @G17EFFR
WRKID     DS    3F                                             @G17EFFR
ENTRIES  DS    0F
         DC    XL4'00'
         DC    XL4'00'
         DC    A(LABELS)
         DC    H'0'
         DC    X'01'
         DC    X'000B8B00'
         LABEL ''
         LINE (1,1),(67,22),SKIP=1
         LABEL 'DATE       TIME','CPU      CPU      RELEASE'
         LINE (1,1),(66,23)
         LABEL 'DAY YR   HH MM SS.TH','SERIAL   ID       LEVEL'
         LINE  (48,9),(1,111),SKIP=2
         ROUTINE CLASSRC,TYPEREC
         ROUTINE YEAR,SETDATE
         HEX   TIME,1,4B
         ROUTINE DUM1,SUB4
         HEX   CPUSER,0,3B
         HEX   CPUID,0,2B
         ROUTINE SYSREL,RELSE
         LABEL '--- RECORD ENTRY SOURCE - SOFTWARE ---  TYPE','REL.'
         LINE  (1,1),(16,1),SKIP=2
         ROUTINE ERRORID,CHKID
ERRID    LABEL 'ERRORID=SEQXXXXX CPUXXXX ASIDXXXX TIMEXX.XX.XX.X'
         LINE
         ROUTINE ERRORID,NOID
         LABEL 'NO ERRORID ASSOCIATED WITH THIS RECORD'
         LINE  (31,9),(1,45),SKIP=1                             YM05012
         CONVT MRCOUNT,1,3                                      YM05012
         ROUTINE CLASSRC,CHECK4F                                YM05012
         LABEL 'MISSING RECORD COUNT'                           YM05012
         LINE  (31,9),(1,45),SKIP=1
         ROUTINE JOBID,MOVENAME
         LABEL 'JOBNAME'
         LINE
         ROUTINE SDWANAME,MOVENAME
         LABEL 'ABENDING PROGRAM NAME','BC MODE PSW AT TIME OF ERROR', C
               'BC MODE PSW OF LAST RB'
         LINE
         ROUTINE SDWAMODN,MOVENAME
         LABEL 'NAME OF MODULE INVOLVED'
         LINE
         ROUTINE SDWACSCT,MOVENAME
         HEX   SDWACMKA,0,4B
         HEX   SDWAPMKA,0,4B
         ROUTINE DUM1,ADD15
         HEX   SDWACMKP,0,4B
         HEX   SDWAPMKP,0,4B
         LABEL 'NAME OF CSECT INVOLVED'
         LINE  ,,SKIP=2
         ROUTINE SDWAREXN,MOVENAME
         LABEL 'FUNCTIONAL RECOVERY ROUTINE'
         LINE
         LABEL 'REGS AT TIME OF ERROR'
         LINE  (15,11),,SKIP=1
         HEX   GR0,0,4B
         HEX   GR1,0,4B
         HEX   GR2,0,4B
         HEX   GR3,0,4B
         HEX   GR4,0,4B
         HEX   GR5,0,4B
         HEX   GR6,0,4B
         HEX   GR7,0,4B
         LABEL 'REGS 0-7'
         LINE  ,,SKIP=2
         HEX   GR8,0,4B
         HEX   GR9,0,4B
         HEX   GR10,0,4B
         HEX   GR11,0,4B
         HEX   GR12,0,4B
         HEX   GR13,0,4B
         HEX   GR14,0,4B
         HEX   GR15,0,4B
         LABEL 'REGS 8-15'
         LINE  (28,9),(1,60),SKIP=1
         HEX   SDWAEC1A,0,4B
         HEX   SDWAEC1B,0,4B
         ROUTINE DUM1,ADD43
         HEX   SDWAEC2A,0,4B
         HEX   SDWAEC2B,0,4B
         LABEL 'EC PSW AT TIME OF ABEND','EC PSW FROM ESTAE RB(0 FOR ESC
               TAI)'
         LINE
         LABEL 'ADDITIONAL INFO:','ADDITIONAL INFO:'
         LINE  (,60)
         HEX   SDWAILC1,0,1B
         HEX   SDWAILC2,0,1B
         LABEL 'INST LENGTH CODE','INST LENGTH CODE'
         LINE
         HEX   SDWAINC1,0,2B
         HEX   SDWAINC2,0,2B
         LABEL 'INTERRUPT CODE','INTERRUPT CODE'
         LINE  ,,SKIP=2
         HEX   SDWATRN1,0,4B
         HEX   SDWATRN2,0,4B
         LABEL 'VIRT ADDR OF TRANS EXCEP','VIRT ADDR OF TRANS EXCEP'
         LINE
         LABEL 'REGS OF RB LEVEL OF ESTAE EXIT OR ZERO FOR ESTAI'
         LINE  (15,11),,SKIP=1
         HEX   GPR0,0,4B
         HEX   GPR1,0,4B
         HEX   GPR2,0,4B
         HEX   GPR3,0,4B
         HEX   GPR4,0,4B
         HEX   GPR5,0,4B
         HEX   GPR6,0,4B
         HEX   GPR7,0,4B
         LABEL 'REGS 0-7'
         LINE  ,,SKIP=2
         HEX   GPR8,0,4B
         HEX   GPR9,0,4B
         HEX   GPR10,0,4B
         HEX   GPR11,0,4B
         HEX   GPR12,0,4B
         HEX   GPR13,0,4B
         HEX   GPR14,0,4B
         HEX   GPR15,0,4B
         LABEL 'REGS 8-15'
         LINE  ,(4,30),SKIP=1
         LABEL 'MCH FLAG BYTE','MCK INPUT INFO','FRAME ERROR INDICATORSC
               ','STORAGE ERROR INDICATORS'
         LINE  (27,30),(1,30)
         BIN   SDWASRVL
         BIN   SDWASKYF
         BIN   SDWAMSER
         BIN   SDWAOFLN
         LABEL 'STORAGE ADDRS ARE VALID','STORAGE KEY FAILURE',        C
               'STORAGE ERROR ALREADY SET','FRAME OFFLINE(OR SCHED)'
         LINE
         BIN   SDWARCDF
         BIN   SDWAREGU
         BIN   SDWACHNG
         BIN   SDWAINTC
         LABEL 'MCK RECORD NOT RECORDED','REGISTERS UNPREDICTABLE',    C
               'CHANGE INDICATOR ON','INTERCEPT'
         LINE
         BIN   SDWATSVL
         BIN   SDWAPSWU
         ROUTINE DUM1,DONOTHNG
         BIN   SDWASPER
         LABEL 'TIME STAMP IS VALID','PSW UNPREDICTABLE','',           C
               'STORAGE ERROR PERMANENT'
         LINE
         BIN   SDWAINVP
         BIN   SDWASCK
         ROUTINE DUM1,DONOTHNG
         BIN   SDWANUCL
         LABEL 'STORAGE IS RECONFIGURED','STORAGE DATA CHECK','',      C
               'PERMANENT RES. STORAGE'
         LINE
         BIN   SDWARSRC
         BIN   SDWAACR
         ROUTINE DUM1,DONOTHNG
         BIN   SDWAFSQA
         LABEL 'RECONFIGURE STATUS AVAIL','ACR REQUEST','',            C
               'FRAME IN SQA'
         LINE
         BIN   SDWARSRF
         BIN   SDWAINSF
         ROUTINE DUM1,DONOTHNG
         BIN   SDWAFLSQ
         LABEL 'RECONFIGURE NOT ATTEMPTED','INSTRUCTION FAILURE','',   C
               'FRAME IN LSQA'
         LINE  (57,60),(31,60)
         BIN   SDWASOFT
         BIN   SDWAPGFX
         LABEL 'SOFT ERROR','FRAME IS PAGE FIXED'
         LINE
         BIN   SDWATERR
         BIN   SDWAVEQR
         LABEL 'TIMER ERROR','FRAME IS V=R'
         LINE  ,(61,1)
         LABEL 'TIME STAMP OF ASSOCIATED MACHINE CHECK RECORD'
         LINE  (40,24),(1,73),SKIP=1
         HEX   SDWASCKB,0,4B
         LABEL 'BEGINNING VIRT ADDR OF STORAGE CHECK','DATE       TIME'
         LINE  ,(1,72)
         HEX   SDWASCKE,0,4B
         LABEL 'ENDING VIRT ADDR OF STORAGE CHECK',                    C
               'DAY YR   HH MM SS.TH'
         LINE  ,(,60),SKIP=2
         HEX   SDWARFSA,0,4B
         ROUTINE SDWAYEAR,SETDATE
         ROUTINE DUM1,SUB39
         HEX   SDWAHRS,1,4B
         LABEL 'REAL STORAGE FAILING ADDRESS'
         LINE  (27,30),(1,30),SKIP=1
         BIN   SDWAMCHK
         BIN   SDWATYP1
         BIN   SDWASTAF
         BIN   SDWACLUP
         LABEL 'MACHINE CHECK','TYPE 1 SVC IN CONTROL','PREV ESTA OR FRC
               R FAILED','EXIT TO CLEANUP ONLY'
         LINE
         BIN   SDWAPCHK
         BIN   SDWAENRB
         BIN   SDWASTAI
         BIN   SDWANRBE
         LABEL 'PROGRAM CHECK','ENABLED RB IN CONTROL','(E)STAI PREV INC
                CONTROL','RB OF ESTA NOT IN CONTROL'
         LINE
         BIN   SDWARKEY
         BIN   SDWALDIS
         BIN   SDWAIRB
         BIN   SDWASTAE
         LABEL 'RESTART KEY DEPRESSED','DISABLED RTN IN CONTROL','IRB PC
               RECEDED RB','ESTA EXIT FOR PREV ABEND'
         LINE
         BIN   SDWASVCD
         BIN   SDWASRBM
         BIN   SDWAPERC
         BIN   SDWACTS
         LABEL 'TASK ISSUED SVC 13','SYSTEM IN SRB MODE','THIS RTN PERCC
               OLATED TO','STEP ABEND REQUESTED'
         LINE
         BIN   SDWAABTM
         ROUTINE DUM1,DONOTHNG
         BIN   SDWAEAS
         BIN   SDWAMABD
         LABEL 'SYSTEM FORCED SVC 13','','LOWER LEVEL EXIT INFO',      C
               'TASK ANCESTOR ABENDED'
         LINE  (27,90),(1,90)
         BIN   SDWASVCE
         BIN   SDWARPIV
         LABEL 'SVC BY LOCKED OR SRB RTN','REGS AND PSW UNAVAILABLE'
         LINE
         BIN   SDWATEXC
         BIN   SDWAMCIV
         LABEL 'TRANSLATION FAILURE','MCK INFO UNAVAILABLE'
         LINE  ,,SKIP=2
         BIN   SDWAPGIO
         LABEL 'PAGE I/O ERROR'
         LINE  ,(31,1),SKIP=1
         LABEL 'CURRENT I/O STATUS'
         LINE  (27,30),(1,30)
         HEX   SDWAFMID
         BIN   SDWAIOQR
         LABEL 'MEMORY ASID','I/O IS RESTOREABLE'
         LINE  (26,31)
         CONVT SDWARCDE,1,2
         BIN   SDWAIOHT
         LABEL 'RECOVERY RETURN CODE','I/O IS NOT RESTOREABLE'
         LINE  (57,1),(31,1)
         BIN   SDWANOIO
         LABEL 'NO I/O OUTSTANDING'
         LINE
         BIN   SDWANIOP
         LABEL 'NO I/O PROCESSING'
         DC    X'01'
         DC    X'000B8B00'
         LABEL ''
         LINE  (27,30),(1,30),SKIP=1
         LABEL 'ADDITIONAL PROCESSING','GLOBAL LOCKS TO BE FREED',     C
               'LOCKWORDS'
         LINE
         BIN   SDWARCRD
         BIN   SDWADISP
         LABEL 'RECORDING REQUESTED','DISPATCHER LOCK'
         LINE
         BIN   SDWASPIN
         BIN   SDWAOPTM
         LABEL 'VALID SPIN','SRM LOCK'
         LINE
         BIN   SDWAUPRG
         BIN   SDWAICAT
         HEX   SDWAICLW,0,4B
         LABEL 'UPDATED REGS FOR RETRY','IOSCAT LOCK','IOSCAT LOCKWORD'
         LINE
         BIN   SDWAFREE
         BIN   SDWAIUCB
         HEX   SDWAIULW,0,4B
         LABEL 'FREE RTCA BEFORE RETRY','IOSUCB LOCK','IOSUCB LOCKWORD'
         LINE  (57,30),(31,30)
         BIN   SDWAILCH
         HEX   SDWAILLW,0,4B
         LABEL 'IOSLCH LOCK','IOSLCH LOCKWORD'
         LINE
         BIN   SDWAIPRG
         HEX   SDWAIPLW,0,4B
         LABEL 'IOSYNCH LOCK','IOSYNCH LOCKWORD'
         LINE
         BIN   SDWATNCB
         HEX   SDWATNLW,0,4B
         LABEL 'NCB LOCK','NCB LOCKWORD'
         LINE
         BIN   SDWATDNB
         HEX   SDWATDLW,0,4B
         LABEL 'DNCB LOCK','DNCB LOCKWORD'
         LINE
         BIN   SDWATADB
         HEX   SDWATALW,0,4B
         LABEL 'ACBDEBS LOCK','ACBDEBS LOCKWORD'
         LINE
         BIN   SDWAASMP
         HEX   SDWAAPLW,0,4B
         LABEL 'ASMPAT LOCK','ASMPAT LOCKWORD'
         LINE
         BIN   SDWASALL
         HEX   SDWAASID,0,2B                                   @ZA06000
         LABEL 'SALLOC LOCK','ASID CURRENT'                    @ZA06000
         LINE
         BIN   SDWACMS
         LABEL 'CMS LOCK'
         LINE
         BIN   SDWAFLLK
         LABEL 'LOCAL LOCK'
         LINE  ,(1,1)
         LABEL 'DUMP CHARACTERISTICS'
         LINE  ,(91,1)
         LABEL 'DUMP RANGES AREA'
         LINE  (27,30),(1,30)
         LABEL 'DUMP FLAGS','SDATA OPTIONS','PDATA OPTIONS',           C
               '          FROM      TO'
         LINE
         BIN   SDWADPT
         BIN   SDWANUC
         BIN   SDWADSAS
         ROUTINE DUM1,SUB46
         HEX   SDWAFRM1,0,4B
         ROUTINE DUM1,SUB50
         HEX   SDWATO1,0,4B
         LABEL 'SNAP DUMP REQUEST','DISPLAY NUCLEUS','DISPLAY SAVE AREAC
               S','RANGE 1'
         LINE
         BIN   SDWADLST
         BIN   SDWASQA
         BIN   SDWADSAH
         ROUTINE DUM1,SUB46
         HEX   SDWAFRM2,0,4B
         ROUTINE DUM1,SUB50
         HEX   SDWATO2,0,4B
         LABEL 'PARM LIST SUPPLIED','DISPLAY SQA','DISPLAY SAVE AREA HEC
               ADER','RANGE 2'
         LINE
         BIN   SDWASLST
         BIN   SDWALSQA
         BIN   SDWADREG
         ROUTINE DUM1,SUB46
         HEX   SDWAFRM3,0,4B
         ROUTINE DUM1,SUB50
         HEX   SDWATO3,0,4B
         LABEL 'STORAGE LIST SUPPLIED','DISPLAY LSQA','DISPLAY REGISTERC
               S','RANGE 3'
         LINE  (57,30),(31,30)
         BIN   SDWASWA
         BIN   SDWATLPA
         ROUTINE DUM1,SUB46
         HEX   SDWAFRM4,0,4B
         ROUTINE DUM1,SUB50
         HEX   SDWATO4,0,4B
         LABEL 'DISPLAY SWA','DISPLAY TASK LPA MODULES','RANGE 4'
         LINE
         BIN   SDWAGTF
         BIN   SDWATJPA
         LABEL 'DISPLAY GTF TRACE TABLE','DISPLAY TASK JPA MODULES'
         LINE
         BIN   SDWACBS
         BIN   SDWADPSW
         LABEL 'DISPLAY CONTROL BLOCKS','DISPLAY PSW'
         LINE
         BIN   SDWAQQS
         BIN   SDWAUSPL
         LABEL 'DISPLAY QCB/QELS','DISPLAY USER SUBPOOLS'
         LINE  ,(1,1),SKIP=2
         ROUTINE SDWADPVA,USERDAT
         LABEL 'USER VARIABLE EBCDIC DATA'
         LINE  (1,1),,SKIP=1
         ROUTINE SDWADPVA,MOVEUSER
         LABEL ''
         DC    X'FF'
         DC    XL2'0220'
         DC    XL2'0020'
         DC    XL2'0000'
LENGTH   DC    X'FF'                                            YM05012
         DC    XL2'0019'                                        YM05012
         DC    XL2'0018'                                        YM05012
         DC    XL2'0000'                                        YM05012
LABELS   DS    0F
         LSTART
         END
