      TITLE 'IKJEHAL1 - IBM TIME SHARING LISTALC COMMAND'
IKJEHAL1 CSECT
*A 785000                                                       SA49892
*C 800500                                                       SA49892
*D 800000                                                       SA49892
*C 391500,402000                                                 A49871
*C 638500-639500,642500,643500,688500                            A48499
*C 252500,253500,762500,765500,766200                            A42338
*A 103600,103700,252100-252499,605600,736100,736200              A42338
*D 148000-148500,247500,737500,738000,739500,741500,742000,      A42338
*D 763000                                                        A42338
*C 586600                                                         M0875
*  873104                                                         M0883
*             VS2-3.0 CHANGES
*A 69100,271600,271700,272100-272300,588600,944500-944700       ZA00106
*A 951500,951600                                                ZA00106
*D 711701-711845,711851-711857,712088-712172,712181             ZA02196
*A 711851                                                       ZA02196
*C 711848                                                       ZA02196
*          VS2-3.0 MAINTENCE    SU
*0000272340-272360,273500                                       ZM32756
*0000002000,019600-019700,058100                               @ZA01485
*           VS2-4.1 RACF CHANGES                               @Z40RSSA
*0000109300,195100                                             @ZA01485
*0000252499                                                    @ZA02544
*0000270510,270520                                             @ZA09151
         SPACE 2
***********************************************************************
*                                                                     *
* STATUS     VS2 RELEASE 3 VERSION 0 SU                        @ZA01485
*                                                                     *
* FUNCTION --                                                         *
*    THIS MODULE LISTS THE CURRENTLY ALLOCATED DATA SETS FOR A        *
*    LOGGED-ON USER OF THE SYSTEM.  DATA SET NAMES ARE EXTRACTED      *
*    FROM THE DATA SET EXTENSION (DSE) BLOCKS. ALL INFORMATION        *
*    FOR THE BASIC COMMAND AND FOR THE 'STATUS' KEYWORD IS            *
*    EXTRACTED FROM THE IN-CORE CHAIN OF DSE'S. DATA FOR THE          *
*    'HISTORY' KEYWORD IS TAKEN FROM THE DSCB WHICH IS BROUGHT        *
*    IN BY AN OBTAIN MACRO. A RDJFCB MACRO IS USED TO GET THE         *
*    VOLID NEEDED TO DO THE OBTAIN. IF THE 'MEMBERS' KEYWORD IS       *
*    SPECIFIED IN THE COMMAND AND A DATASET WITH PARTITIONED          *
*    ORGANIZATION IS FOUND TO HAVE THE USER'S USERID AS HIGHEST       *
*    LEVEL QUALIFIER, THEN IKJEHMEM IS LOADED AND CALLED AND          *
*    WILL LIST THE DIRECTORY OF THE PDS. IF THE 'SYSNAMES'            *
*    KEYWORD IS SPECIFIED, ALL SYSTEM GENERATED DSNAMES FOUND         *
*    ALLOCATED TO THIS SESSION ARE INCLUDED IN THE LISTING.           *
*    OTHERWISE SYSTEM NAMES ARE IGNORED.                              *
*                                                                     *
* ENTRY POINTS --                                                     *
*         IKJEHAL1 - MAIN ENTRY POINT OF THE PROGRAM                  *
*         IKJEHWRT - WRITE ROUTINE                                    *
*         IKJEHERR - ERROR ROUTINE                                    *
*                                                                     *
* INPUT -- REGISTER 1 POINTS TO THE COMMAND PROCESSOR PARAMETER LIST  *
*                                                                     *
* OUTPUT --                                                           *
*    DSNAME FOR EACH DSE BLOCK FOUND IN THE CHAIN, WITH THE           *
*    EXCEPTION OF ANY SYSTEM GENERATED DSNAMES FOUND. ADDITIONAL      *
*    OUTPUT OF CREATION AND EXPIRATION DATES, PASSWORD PROTECTION     *
*    STATUS, DATASET ORGANIZATION, DDNAME AND DATASET                 *
*    DISPOSITIONS, AND MEMBER NAMES IS AVAILABLE IF THE PROPER        *
*    KEYWORDS ARE SPECIFIED WITH THE COMMAND.                         *
*        R15 = X'00'  NORMAL RETURN                            @ZA01485
*        R15 = X'0C'  ERROR RETURN                             @ZA01485
*                                                                     *
* EXTERNAL REFERENCES --                                              *
*         IKJEHMEM - TO LIST PDS DIRECTORY                            *
*         IKJPARS - TO PARSE COMMAND STRING                           *
*         IKJPUTL - TO OUTPUT DATA TO TERMINAL                        *
*                                                                     *
* EXITS, NORMAL -- RETURN TO THE TERMINAL MONITOR PROGRAM             *
*                                                                     *
* EXITS, ERROR -- RETURN TO THE TERMINAL MONITOR PROGRAM              *
*                                                                     *
* TABLES/WORK AREAS --                                                *
*    HDTNY -THE TABLE WHICH CONTAINS THE ACCUMULATED DAYS IN THE      *
*    YEAR FOR EACH MONTH.  THIS TABLE IS USED TO FIND THE             *
*    CORRECT MONTH THAT A DAY FALLS IN.  THE NY INDICATES             *
*    THAT THIS IS FOR A NORMAL YEAR.                                  *
*    HDTLY SAME AS HDTNY BUT FOR LEAP YEAR.                           *
*    INITCORE -A WORK AREA HOLDING THE INTERNAL SWITCHES FOR THE      *
*    PROGRAM, THE LIST FORMS OF THE VARIOUS MACROS, AND               *
*    THE OUTPUT BUFFER. THIS DSECT ALSO CONTAINS THE REGISTER         *
*    SAVE AREA.  CORE IS GOTTEN BY A REGISTER GETMAIN.                *
*    OBTWAD -THE WORKING CORE GOTTEN IF THE 'HISTORY' AND/OR          *
*    'MEM' KEYWORDS WERE USED. THIS AREA PROVIDES THE WORK            *
*    AREA FOR THE RDJFCB AND OBTAIN MACROS, THE DCB NEEDED            *
*    BY RDJFCB AND BY MODULE IKJEHMEM, AND THE PARAMETER LIST         *
*    FOR THE RDJFCB AND OBTAIN MACROS.                                *
*                                                                     *
* ATTRIBUTES -- REENTRANT, READ ONLY, REFRESHABLE                     *
*                                                                     *
* CHARACTER CODE DEPENDENCY -- CHARACTER CODE INDEPENDENT             *
*                                                                     *
* NOTES -- N/A                                                        *
*                                                                     *
***********************************************************************
         EJECT
         ENTRY IKJEHWRT
         ENTRY IKJEHERR
         SPACE
*        REGISTER EQUATES
R0       EQU   0                   REGISTER 0
R1       EQU   1                   REGISTER 1
R2       EQU   2                   REGISTER 2
R3       EQU   3                   REGISTER 3
R4       EQU   4                   REGISTER 4
R5       EQU   5                   REGISTER 5
R6       EQU   6                   REGISTER 6
R7       EQU   7                   REGISTER 7
R8       EQU   8                   REGISTER 8
R9       EQU   9                   REGISTER 9
R10      EQU   10                  REGISTER 10
R11      EQU   11                  REGISTER 11
R12      EQU   12                  REGISTER 12
R13      EQU   13                  REGISTER 13
R14      EQU   14                  REGISTER 14
R15      EQU   15                  REGISTER 15
*
*        CHARACTER AND VALUE EQUATES
*
BLANK    EQU   C' '                BLANK
SLASH    EQU   C'/'                SLASH
SSP      EQU   1                   SUBPOOL NUMBER
OSP      EQU   1                   SUBPOOL NUMBER
RT12     EQU   X'0C'               RETURN CODE = 12            @ZA01485
*        MESSAGE NUMBERS
MSG01    EQU   1                   MESSAGE NUMBER 1
MSG02    EQU   2                   MESSAGE NUMBER 2
MSG03    EQU   3                   MESSAGE NUMBER 3
MSG04    EQU   4                   MESSAGE NUMBER 4
MSG05    EQU   5                   MESSAGE NUMBER 5
MSG06    EQU   6                   MESSAGE NUMBER 6
*        SECOND LEVEL MESSAGE NUMBERS
SECMSG01 EQU   1                   SECOND LEVEL MESSAGE 1
SECMSG02 EQU   2                   SECOND LEVEL MESSAGE 2
SECMSG03 EQU   3                   SECOND LEVEL MESSAGE 3
SECMSG04 EQU   4                   SECOND LEVEL MESSAGE 4
SECMSG05 EQU   5                   SECOND LEVEL MESSAGE 5
SECMSG06 EQU   6                   SECOND LEVEL MESSAGE 6
SECMSG07 EQU   7                   SECOND LEVEL MESSAGE 7
SECMSG08 EQU   8                   SECOND LEVEL MESSAGE 8
SECMSG09 EQU   9                   SECOND LEVEL MESSAGE 9
SECMSG10 EQU   10                  SECOND LEVEL MESSAGE 10
SECMSG11 EQU   11                  SECOND LEVEL MESSAGE 11      ZA00106
*        EQUATES
DSECCNCT EQU   X'08'               ENTRY DYNAMICALLY CONCATENATED
ONE      EQU   1                   1
DYNDDOFF EQU   2                   OFFSET DDNAME LIST FOR DYNAM ENTRIES
DDNAMLEN EQU   8                   LENGTH OF DDNAME
TERMDDOF EQU   10                  OFFSET TO DDNAME
NULLDDOF EQU   10                  OFFSET TO DDNAME
SAVELEN  EQU   112                 SIZE OF SAVE AREA
RETREGOF EQU   12                  OFFSET TO RETURN REGISTER
BALREGOF EQU   52                  OFFSET TO BRANCH REGISTER
*  THE BITS OF THE CONTROL BYTE HAVE THE FOLLOWING MEANING
STATMSK  EQU   X'80'               STATUS SPECIFIED
HISTMSK  EQU   X'40'               HISTORY SPECIFIED
MEMMSK   EQU   X'20'               MEMBERS SPECIFIED
SYSNMSK  EQU   X'10'               SYSNAMES SPECIFIED
HISTSTAT EQU   X'C0'               HISTORY AND STATUS SPECIFIED
OBTSW    EQU   X'08'               OBTAIN FAILED INDICATOR
CONCATSW EQU   X'02'               INDICATES DYNAMIC ALLOCATION
WRITEMSK EQU   X'01'               DATA IN THE BUFFER (TO BE WRITTEN)
NOBTSW   EQU   X'F7'               FOR TURNING OFF OBTAIN SWITCH
HISTMEM  EQU   HISTMSK+MEMMSK      HISTORY AND MEMBERS SPECIFIED
HEXFF    EQU   X'FF'               DUMMY FOR TURNING OFF SWITCHES
FIRSTKWD EQU   X'01'               TEST IF FIRST KEYWORD NAME WAS FOUND
LOCNAME  EQU   4                   OFFSET TO LOCATE NAME
LOCCVOL  EQU   8                   OFFSET TO LOCATE CVOL
LOCWA    EQU   12                  OFFSET TO LOCATE WORKAREA
D0       EQU   0                   0
D1       EQU   1                   1
D2       EQU   2                   2
D3       EQU   3                   3
D4       EQU   4                   4
D8       EQU   8                   8
L0       EQU   0                   0
L1       EQU   1                   1
L2       EQU   2                   2
FOUR     EQU   4                   4
L4       EQU   4                   4
L3       EQU   3                   3
L7       EQU   7                   7
L8       EQU   8                   8
D5       EQU   5                   5
D6       EQU   6                   6
D9       EQU   9                   9
D10      EQU   10                  10
D16      EQU   16                  16                          @YL026YB
D43      EQU   43                  43                          @YL026YB
D44      EQU   44                  44                          @YL026YB
D112     EQU   112                 112                         @YL026YB
FIRSTVOL EQU   6                   OFFSET VOLID IN LOCATE VOLUME LIST
LOCSAVOF EQU   72                  OFFSET TO LOCAL SAVEAREA
DSNAMMAX EQU   44                  MAXIMUM SIZE OF DSNAME
AMPHERND EQU   C'&&'               AMPHERSAND
ASTERSK  EQU   C'*'                ASTERISK
MAXBUF   EQU   72                  MAXIMUM OUTPUT LINE
CRDTOFF  EQU   9                   OFFSET CREATION DATE FIELD IN BUFFER
STATOFF1 EQU   2                   STATUS WITHOUT HISTORY OFFSET
NXTBUF   EQU   10                  USED TO BUMP TO NEXT BUFFER SLOT
MNTHS    EQU   12                  LOOP CONTROL FOR MONTHS
STATOFF2 EQU   39                  STATUS WITH HISTORY OFFSET
RETCDOF  EQU   14                  RETURN CODE OFFSET UNPACK AREA
COMMA    EQU   C','                COMMA
PERIOD   EQU   C'.'                PERIOD
LPAREN   EQU   C'('                LEFT PARENTHESIS              A42338
RPAREN   EQU   C')'                RIGHT PARENTHESIS             A42338
BACKWARD EQU   4                   USED FOR BACK CHAIN DISPLACEMENT
FORWARD  EQU   8                   USED FOR FORWARD CHAIN DISPLACEMENT
RETCD12  EQU   12                  RETURN CODE OF 12
ZONE     EQU   C'0'                USED FOR ZERO OF ZONE MASK
EXITCD   EQU   X'87'               USED FOR JFCB DCB EXIT CODE
CHARU    EQU   C'U'                CHARACTER U
SWON     EQU   X'FF'               MASK TURN SWITCH ON
SWOFF    EQU   X'00'               MASK TURN SWITCH OFF
FLDNO    EQU   X'03'                                           @YL026YB
DSAPERM  EQU   X'20'          MASK FOR PERMANENT ALLOCATION    @YL026YB
DUMMY    EQU   X'80'               MASK FOR NULLFILE           @YL026YB
TERMINAL EQU   X'40'               MASK FOR TERMMINAL FILE     @YL026YB
DINUSE   EQU   X'40'               MASK FOR IN-USE             @YL026YB
DYNCON   EQU   X'C0'               MASK FOR DYNAMIC ALLOC.     @YL026YB
HEX01    EQU   X'01'               HEX VALUE FOR ONE           @YL026YB
LOCVSAM  EQU   X'21'               FLAG FOR VSAM LOCATE        @YL026YB
         EJECT
         SAVE  (14,12)             SAVE REGISTERS
         LR    R11,R15             SAVE ENTRY POINT ADDRESS
         USING OBTWAD,R12          USE R12 FOR MEMBER DSECT
         USING IKJEHAL1,R11        USE R11 FOR MAIN BASE
         B     BRID                BRANCH AROUND ID
         DC    C'IKJEHAL1'         MODULE ID
         DC    X'6049'             DATE  02/18/76              @ZA09151
BRID     EQU   *
         LR    R2,R1               SAVE PARAMETER LIST FROM TMP
         GETMAIN R,LV=INITSIZE,SP=SSP GET CORE
         ST    R13,BACKWARD(R1)    SET UP BACKWARD CHAIN
         ST    R1,FORWARD(R13)     SET UP FORWARD CHAIN
         LR    R13,R1              SET UP ADDRESSABILITY FOR WORK SPACE
         USING INITCORE,R13        USE R13 FOR WORK BASE
         MVI   STACKSW,SWOFF       TURN STACK SWITCH OFF
         XC    CTLA(CTLL),CTLA     CLEAR CONTROL AREA
         LA    R3,PUTLLIST         ADDRESS OF LIST FOR PUTLINE
         ST    R3,PUTLCON          -TO WRITE ROUTINE PARAMETER LIST
         LA    R3,DPUTLINE         ADDRESS OF PUTLINE MACRO LIST FORM
         ST    R3,DPUTLCON         -TO WRITE ROUTINE PARAMETER LIST
         LA    R3,CPECB            COMMAND PROCESSOR'S ECB
         ST    R3,ECBPTR           - TO WRITE ROUTINE PARAMETER LIST
         XC    RETCD,RETCD         CLEAR RETURN CODE SAVE AREA
         XC    CPECB,CPECB         CLEAR ECB
*  SAVE PARMLIST FROM CPPL IN WORKAREA
         L     R3,CPPLUPT-CPPL(R2) UPT POINTER
         ST    R3,UPTPTR           SAVE UPT POINTER
         L     R3,CPPLPSCB-CPPL(R2) PSCB PTR
         ST    R3,PSCBPTR          SAVE PSCB POINTER
         L     R3,CPPLECT-CPPL(R2) ECT POINTER
         ST    R3,ECTPTR           SAVE ECT POINTER
         LOAD  EP=IKJPUTL          LOAD PUTLINE
         ST    R0,PUTLADDR         SAVE PUTLINE ADDRESS
         MVC   GETML(LILFS),GETMLMDL MOVE LIST FORMS OF GETMAIN ETC
         MVI   OUTBUF,BLANK        BLANK
         MVC   OUTBUF+D1(L'OUTBUF-D1),OUTBUF -OUTPUT BUFFER
         MVC   DPUTLINE(LTPUTL),TPUTMDL INITIALIZE PUTLINE
*  SETUP PARMLIST FOR PARSE, THEN PARSE COMMAND STRING
         LA    R3,PUTLLIST         POINT TO SPACE FOR PPL
         USING PPL,R3              ADDRESSABILITY FOR PPL
         L     R1,UPTPTR           UPT POINTER
         ST    R1,PPLUPT           -TO LIST
         L     R1,ECTPTR           ECT POINTER
         ST    R1,PPLECT           -TO LIST
         L     R1,ECBPTR           CP'S ECB POINTER
         ST    R1,PPLECB           -TO LIST
         L     R1,PRSEC01          POINTER TO PCL
         ST    R1,PPLPCL           -TO LIST
         LA    R1,PARDSECT         POINTER TO ANSWER PLACE
         ST    R1,PPLANS           -TO LIST
         L     R1,D0(R2)           POINTER TO COMMAND BUFFER
         ST    R1,PPLCBUF          -TO LIST
         DROP  R3                  PPL NO LONGER NEEDED
         LA    R1,PUTLLIST         PARSE PARAMETER LIST
         LINK  EP=IKJPARS,MF=(E,(1)) PARSE LISTALC COMMAND
*
*     TEST FOR PARSE RETURN CODES -- IF ATTENTION RETURN WITH CODE  12
*
         B     PARSCODE(R15)       ANALYZE RETURN CODE FROM PARSE
PARSCODE B     PARSCD00            RC=00 SUCCESSFUL PARSE
         B     PARSCD04            RC=04 UNABLE TO PROMPT
         B     PARSCD08            RC=08 ATTENTION - ECB POSTED
         B     PARSCD12            RC=12 INVALID PARAMETERS
         B     PARSCD16            RC=16 NO SPACE AVAILABLE
PARSCD08 LA    R1,RETCD12          RETURN CODE OF 12 FOR TMP
         ST    R1,RETCD            SAVE IT FOR THE WRAPUP ROUTINE
         B     WRAPUP00            GO TERMINATE
PARSCD12 BAL   R8,CVDREG15         CONVERT REG15 AND SET UP INSERT
         LA    R1,SECMSG10         SECOND LEVEL MESSAGE 10
         B     PARSERR1            GO PROCESS ERROR
PARSCD16 XC    ERRSECND,ERRSECND   CLEAR SECOND LEVEL
         XC    ERRINST1,ERRINST1   CLEAR INSERT
         LA    R1,MSG06            MESSAGE 6
         B     PARSERR2            SET UP PARMLIST
PARSERR1 STH   R1,ERRSECND         SAVE SECOND LEVEL MESSAGE NUMBER
         LA    R1,MSG05            MESSAGE 5
PARSERR2 STH   R1,ERRFIRST         SAVE MESSAGE NUMBER
         BAL   R8,ERROUT           GO TO ERROR ROUTINE
PARSCD04 MVI   STACKSW,SWON        TURN STACK SWITCH ON
         LA    R1,RETCD12          SET RETURN CODE FOR TMP
         ST    R1,RETCD            SAVE FOR WRAPUP ROUTINE
         B     WRAPUP00            GO TO TERMINATE ROUTINE
CVDREG15 CVD   R15,ERRINSRT+D8     CONVERT TO DECIMAL
         UNPK  ERRINSRT+D1(L4),ERRINSRT+RETCDOF(D3) UNPACK
         MVI   ERRINSRT,D2         MOVE IN LENGTH
         LA    R1,ERRINSRT         INSERT ADDRESS
         ST    R1,ERRINST2         -TO INSERT POINTER
         XC    ERRINST1,ERRINST1   NO INSERT FOR 1ST LEVEL MESSAGE
         BR    R8                  RETURN TO CALLER
*     SUCCESSFUL RETURN FROM PARSE  COMES HERE
PARSCD00 L     R9,PARDSECT         ADDRESS OF DSECT RETURNED BY PARSE
         USING IKJPARMD,R9         ADDRESSABILITY PARSE DSECT
         TM    PSTAT+D1,FIRSTKWD   WAS STATUS SPECIFIED
         BNO   PAR04               IF NOT, BRANCH
         OI    CNTRL,STATMSK       IF YES, SET SWITCH
PAR04    TM    PHIST+D1,FIRSTKWD   WAS HISTORY SPECIFIED
         BNO   PAR08               IF NOT, BRANCH
         OI    CNTRL,HISTMSK       IF YES, SET SWITCH
PAR08    TM    PMEM+D1,FIRSTKWD    WAS MEMBERS SPECIFIED
         BNO   PAR12               IF NOT, BRANCH
         OI    CNTRL,MEMMSK        IF YES, SET SWITCH
PAR12    TM    PSYSN+D1,FIRSTKWD   WAS SYSNAMES SPECIFIED
         BNO   PAR16               IF NOT, BRANCH
         OI    CNTRL,SYSNMSK       IF YES, SET SWITCH
PAR16    LR    R1,R9               PARSE DSECT TO BE RELEASED
         IKJRLSA PARDSECT          FREE PARSE DSECT CORE
         DROP  R9                  PARSE DSECT NO LONGER NEEDED
         EJECT
***********************************************************************
*                                                                     *
*    THIS ROUTINE INITIALIZES THE PARAMETER LIST OF MAPPING MACRO     *
*    IEFZB4D0 FOR INPUT TO DYNAMIC INFORMATION RETRIEVAL(DIR). @YL026YB
*    SVC 99 IS INVOKED AND DIR DATA IS GOTTEN FRON THE DSAB.   @YL026YB
*                                                                     *
***********************************************************************
         SPACE
         SR    R2,R2               CLEAR REGISTER 2            @YL026YB
         SR    R3,R3               CLEAR REGISTER 3            @YL026YB
         MVI   DYNAMSW,SWOFF       TURN OFF DYNAM SWITCH       @YL026YB
NXTDSAB  MVI   NOTUSED,SWOFF       TURN OFF NOT-INUSE SWITCH   @YL026YB
         MVI   ASKSWTCH,SWOFF      SWITCH TO WRITE AS NOT-INUSE
         MVI   DSADSNAM,BLANK                                  @YL026YB
         MVC   DSADSNAM+D1(D43),DSADSNAM                       @YL026YB
         MVI   DSADDNAM,BLANK      BLANK                       @YL026YB
         MVC   DSADDNAM+D1(L7),DSADDNAM -CLEAR DDNAME BUFFER   @YL026YB
         XC    DARQBLK,DARQBLK                                 @YL026YB
         MVI   DABLKLN,DARLNTH     SET LNTH OF BLOCK           @YL026YB
         MVI   DAVERB,S99VRBIN     SET VERB CODE FOR D.I.R     @YL026YB
         LA    R5,DAPTR            ADDR OF TEXT POINTERS       @YL026YB
         ST    R5,DATXTPT          SET ADDR OF TEXT POINTERS   @YL026YB
         USING S99TUPL,R5                                      @YL026YB
         USING S99TUNIT,R6                                     @YL026YB
         LA    R6,DAREQ            REL REQ TEXT UNIT           @YL026YB
         ST    R6,S99TUPTR         TEXT POINTER                @YL026YB
         MVC   S99TUNIT(L'TXTREQ),TXTREQ  INIT. TEXT UNIT      @YL026YB
         LA    R2,D1(R2)                                       @YL026YB
         STH   R2,REQNUM           STORE REL.REQ. NUMBER       @YL026YB
         STH   R2,S99TUPAR                                     @YL026YB
         LA    R5,D4(R5)           NEXT TEXT UNIT              @YL026YB
         LA    R6,DADSNM           POINT TO DSNAME TEXT UNIT   @YL026YB
         ST    R6,S99TUPTR         TEXT POINTER                @YL026YB
         MVC   S99TUNIT(L'TXTDSNM),TXTDSNM  DSNAME TXT UNIT    @YL026YB
         LA    R5,D4(R5)           NEXT TEXT UNIT              @YL026YB
         LA    R6,DALIMIT          POINT TO LIMIT TEXT UNIT    @YL026YB
         ST    R6,S99TUPTR         TEXT POINTER                @YL026YB
         MVC   S99TUNIT(L'TXTLIMIT),TXTLIMIT  LIMIT TXT UNIT   @YL026YB
         LA    R5,D4(R5)           NEXT TEXT UNIT              @YL026YB
         LA    R6,DATTR            POINT TO ATTRIBUTE TXT UNIT @YL026YB
         ST    R6,S99TUPTR         TEXT POINTER                @YL026YB
         MVC   S99TUNIT(L'TXTATTR),TXTATTR  ATTRIBUTE TXT UNIT @YL026YB
         LA    R5,D4(R5)           NEXT TEXT UNIT              @YL026YB
         LA    R6,DALENTRY         POINT TO LST ENTRY TXT UNIT @YL026YB
         ST    R6,S99TUPTR         TEXT POINTER                @YL026YB
         MVC   S99TUNIT(L'TXLENTRY),TXLENTRY  LAST ENTRY TXT UNIT
         LA    R5,D4(R5)           NEXT TEXT UNIT              @YL026YB
         LA    R6,DADSTYPE         POINT TO DSTYPE TXT UNIT    @YL026YB
         ST    R6,S99TUPTR         TEXT POINTER                @YL026YB
         MVC   S99TUNIT(L'TXTYPE),TXTYPE  POINTER TO DSTYPE TXT UNIT
         LA    R5,D4(R5)           NEXT TEXT UNIT              @YL026YB
         LA    R6,DAMEM            POINT TO MEMBER TXT UNIT    @YL026YB
         ST    R6,S99TUPTR         TEXT POINTER                @YL026YB
         MVC   S99TUNIT(L'TXTMEM),TXTMEM MEMBER TXT UNIT       @YL026YB
         LA    R5,D4(R5)           NEXT TEXT UNIT              @YL026YB
         LA    R6,DADDNM           POINT TO DDNAME TXT UNIT    @YL026YB
         ST    R6,S99TUPTR         TEXT POINTER                @YL026YB
         MVC   S99TUNIT(L'TXTDD),TXTDD  DDNAME TEXT UNIT       @YL026YB
         TM    CNTRL,STATMSK       WAS STATUS SPECIFIED        @YL026YB
         BNO   LASTPM              NO, PROCESS DSAB            @YL026YB
         LA    R5,D4(R5)           NEXT TEXT UNIT              @YL026YB
         LA    R6,DASTAT           POINT TO STATUS TXT UNIT    @YL026YB
         ST    R6,S99TUPTR         TEXT POINTER                @YL026YB
         MVC   S99TUNIT(L'TXTSTAT),TXTSTAT  STATUS TEXT UNIT   @YL026YB
         LA    R5,D4(R5)           NEXT TEXT UNIT              @YL026YB
         LA    R6,DANDISP          PT. TO NORMAL DISP TXT UNIT @YL026YB
         ST    R6,S99TUPTR         TEXT POINTER                @YL026YB
         MVC   S99TUNIT(L'TXNDISP),TXNDISP  NORMAL DISP. TXT UNIT
         LA    R5,D4(R5)           NEXT TEXT UNIT              @YL026YB
         LA    R6,DACDISP          PT. TO COND. TXT UNIT       @YL026YB
         ST    R6,S99TUPTR         TEXT POINTER                @VS07242
         MVC   S99TUNIT(L'TXCDISP),TXCDISP  POINTER TO COND. DISP
         OI    S99TUPTR,S99TUPLN   TURN ON BIT FOR LAST PTR    @YL026YB
         B     LASTPM1             GO PROCESS DSAB             @YL026YB
LASTPM   OI    S99TUPTR,S99TUPLN   TURN ON BIT FOR LAST PTR    @YL026YB
LASTPM1  LA    R4,DARQBLK          POINTER TO REQUEST BLK      @YL026YB
         ST    R4,DAPARM           STORE REQ. BLK PTR          @YL026YB
         OI    DAPARM,S99RBPND     TURN ON REQ. BLK BIT        @YL026YB
         LA    R1,DAPARM           POINTER TO REQ. BLK PTR     @YL026YB
         USING S99RBP,R1                                       @YL026YB
         L     R5,S99RBPTR                                     @YL026YB
         USING S99RB,R5                                        @YL026YB
         L     R5,S99TXTPP                                     @YL026YB
         USING S99TUPL,R5                                      @YL026YB
         L     R6,S99TUPTR                                     @YL026YB
         USING S99TUNIT,R6                                     @YL026YB
         DYNALLOC                  PROCESS DSAB                @YL026YB
         LTR   R15,R15             TEST RETURN CODE            @YL026YB
         BZ    NEXTSTEP            NORMAL PROCESSING           @YL026YB
         LA    R1,MSG03            MESSAGE 3
         STH   R1,ERRFIRST         TO PARAMETER LIST FOR ERROUT
         XC    ERRSECND,ERRSECND   NO SECOND LEVEL MESSAGE
         XC    ERRINST1,ERRINST1   NO FIRST LEVEL INSERT
         BAL   R8,ERROUT           GO TO ERROR ROUTINE
         MVI   RETCD+3,RT12        SET RC                      @ZA01485
         B     WRAPUP00            GO TO NORMAL TERMINATION
NEXTSTEP BAL   R14,DIR                                         @YL026YB
         LA    R7,DSADSNAM                                     @YL026YB
         LH    R4,S99TULNG                                     @YL026YB
         STH   R4,DSADSLNG                                     @YL026YB
         BCTR  R4,R0                                           @YL026YB
         EX    R4,MOVE22                                       @YL026YB
         BAL   R14,DIR                                         @YL026YB
         MVC   DYNAMCNT(D2),S99TUPAR                           @YL026YB
         BAL   R14,DIR                                         @YL026YB
         MVC   DSACNTRL(D1),S99TUPAR                           @YL026YB
         BAL   R14,DIR                                         @YL026YB
         MVC   LSTENTRY(D1),S99TUPAR                           @YL026YB
         BAL   R14,DIR                                         @YL026YB
         MVC   DSTYPE(D1),S99TUPAR                             @YL026YB
         BAL   R14,DIR                                         @YL026YB
         MVC   DSAMEM(D8),S99TUPAR                             @YL026YB
         MVC   DMEMLNT(D2),S99TULNG                            @YL026YB
         BAL   R14,DIR                                         @YL026YB
         LA    R7,DSADDNAM                                     @YL026YB
         LH    R4,S99TULNG                                     @YL026YB
         LTR   R4,R4                                           @YL026YB
         BZ    SKIPMVC                                         @YL026YB
         BCTR  R4,R0                                           @YL026YB
         EX    R4,MOVE22                                       @YL026YB
SKIPMVC  LA    R3,D1                                           @YL026YB
         TM    CNTRL,STATMSK                                   @YL026YB
         BNO   START01                                         @YL026YB
         BAL   R14,DIR                                         @YL026YB
         MVC   DSASTAT(D1),S99TUPAR                            @YL026YB
         BAL   R14,DIR                                         @YL026YB
         MVC   DSANDISP(D1),S99TUPAR                           @YL026YB
         BAL   R14,DIR                                         @YL026YB
         MVC   DSACDISP(D1),S99TUPAR                           @YL026YB
START01  CR    R2,R3               IS REG2 GREATER THAN ONE    @YL026YB
         BH    BSCROUT             YES,PROCESSING NEXT ENTRY   @YL026YB
         B     DSEOK                                           @YL026YB
DIR      LA    R5,D4(R5)                                       @YL026YB
         L     R6,S99TUPTR                                     @YL026YB
         BR    14                                              @YL026YB
MOVE22   MVC   D0(D0,R7),S99TUPAR                              @YL026YB
*
*     NORMAL PROCESSING BEGINS HERE
*
DSEOK    TM    CNTRL,HISTMEM+SYSNMSK IS CORE NEEDED
         BZ    NOMEMREQ            NO PROCESS NORMAL
         BAL   R8,LGM02            GO ISSUE GETMAIN
         TM    CNTRL,MEMMSK        ARE MEMBER NAMES TO BE LISTED
         BNO   NOMEMREQ            BRANCH AROUND SET UP IF NOT
         LOAD  EP=IKJEHMEM         LOAD MEMBERS ROUTINE
         ST    R0,MEMMOD           SAVE ADDRESS OF MEMBERS ROUTINE
***********************************************************************
*                                                                     *
*        MAIN PROCESSING ROUTINE                                      *
*                                                                     *
***********************************************************************
NOMEMREQ LA    R7,OUTBUF           BUFFER ADDRESS
         LR    R14,R7              INDICATE A SKIP
         BAL   R8,WRITE            GO TO WRITE ROUTINE
         TM    CNTRL,HISTSTAT      CHECK FOR HISTORY OR STATUS
         BZ    SKIPHDNG            NEITHER, SKIP HEADING
         TM    CNTRL,HISTMSK       WAS HISTORY SPECIFIED
         BNO   NXCHECK             NO, CHECK STATUS
         MVC   OUTBUF(L'TITLE1),TITLE1 MOVE HEADING TO BUFFER
         LA    R7,L'TITLE1(R7)     POINT BEYOND HISTORY HEADING
NXCHECK  TM    CNTRL,STATMSK       WAS STATUS SPECIFIED
         BZ    WRITHDNG            NO, GO WRITE HEADING
         MVC   D0(L'TITLE2,R7),TITLE2 MOVE HEADING TO BUFFER
         LA    R7,L'TITLE2(R7)     POINT AT END OF DATA
WRITHDNG LR    R14,R7              SETUP FOR WRITING HEADING
         LA    R7,OUTBUF           POINT AT BUFFER
         BAL   R8,WRITE            GO WRITE BUFFER
         LR    R14,R7              SETUP FOR LINESKIP
         BAL   R8,WRITE            GO SKIP A LINE
***********************************************************************
*                                                                     *
*        THIS ROUTINE IS THE BASIC LISTALC FUNCTION. THE ROUTINE      *
*        CHECKS THE DSAB TO SEE IF DATA SET IS IN-USE. IF NOT         *
*        IT CHECKS TO SEE IF IT IS PERMANENTLY ALLOCATED.             *
*        IF NOT PERMANENTLY ALLOCATED THE DDNAME IS SAVED.            *
*        THE DSNAME IS THEN  CHECKED TO SEE IF IT IS A SYSTEM         *
*        GENERATED NAME AND IF SO IS PROCESSED ONLY IF 'SYSNAMES' IS  *
*        SPECIFIED.                                                   *
*                                                                     *
***********************************************************************
SKIPHDNG EQU   *                   ALIAS FOR BSCROUT
BSCROUT  TM    DSACNTRL,DINUSE     IS DATA SET IN USE          @YL026YB
         BO    BNORM               YES GO TO NORMAL PROCESSING
         TM    DSACNTRL,DSAPERM    IS ENTRY PERMANENTLY ALLOCATED
         BO    DYNAMRT             YES GO SAVEY DDNAME         @YL026YB
         MVI   NOTUSED,SWON        TURN ON NOT IN-USE SWITCH   @YL026YB
BNORM    CLI   DSTYPE,DUMMY        SEE IF DSNAME IS NULLFILE   @YL026YB
         BE    NULLFRT             YES, GO TO NULLFILE HANDLING ROUTINE
         CLI   DSTYPE,TERMINAL     SEE IF DSNAME IS ASTERISK   @YL026YB
         BE    TERMFRT             YES, PROCESS AS A TERMINAL FILE
         TM    CNTRL,SYSNMSK       WAS SYSNAMES SPECIFIED
         BO    BSCRT00A            YES, SKIP TEST FOR SYSTEM NAME
***********************************************************************
*                                                                     *
*   THE FOLLOWING CODE WILL TEST FOR SYSTEM GENERATED NAMES.          *
*   THE TEST MAKES USE OF (AND IS DEPENDENT ON) THE FACT THAT         *
*        1.    THE ZONE FIELD OF ALL NUMERICS IS THE SAME             *
*        2.    THE NUMERIC PORTION OF A BYTE IS BINARY ZERO FOR THE   *
*              CHARACTER ZERO (0).                                    *
*   THE TEST IS PREFORMED BY ANDING A MASK OF THE CONSTANT CHARACTERS *
*   AND CHARACTER ZEROS FOR THE NUMERIC FIELDS OF DATE AND TIME,      *
*   AGAINST THE DSNAME BEING TESTED.  THE RESULT IS THEN EXCLUSIVE    *
*   OR'ED AGAINST THE ORIGINAL MASK.  RESULT SHOULD BE ZERO.          *
*                                                                     *
***********************************************************************
         MVC   SYSNM(L'SYSNMMDL),SYSNMMDL MOVE MASK TO WORK AREA
         NC    SYSNM(L'SYSNMMDL),DSADSNAM AND MASK AGAINST DSNAME
         XC    SYSNM(L'SYSNMMDL),SYSNMMDL EX-OR PRODUCT AGAINST MASK
         BZ    NXDSEBLK            IF SYSNAME, PROCESS NEXT BLOCK
         CLI   DSADSNAM,AMPHERND   IS NAME SYSTEM ASSIGNED     @YL026YB
         BE    NXDSEBLK            YES, PROCESS NEXT DSAB BLK  @YL026YB
         B     BSCRT00             NO, PROCESS NORMALLY
BSCRT00A CLI   DSADSNAM,AMPHERND   DOES DSNAME BEGINS WITH AMPHERSAND
         BNE   BSCRT00             NO, GO PROCESS NORMALLY
         LA    R2,OBTDCB           DCB ADDRESS
         USING IHADCB,R2           ADDRESSABILITY DCB
         MVC   DCBDDNAM(DDNAMLEN),DSADDNAM MOVE DDNAME FROM DSE TO DCB
         LA    R1,RDJL             LIST FORM RDJFCB
         RDJFCB ((R2)),MF=(E,(R1)) ISSUE READ JFCB
         DROP  R2                  DCB NO LONGER NEEDED
         MVC   OUTBUF(DSNAMMAX),OBTDSNAM MOVE DSNAME FROM JFCB
         LA    R7,OUTBUF           BUFFER ADDRESS
         LA    R14,DSNAMMAX(R7)    END OF BUFFER ADDRESS
         B     BSCRT00B            GO CHECK FOR KEYWORDS
BSCRT00  LA    R7,OUTBUF           POINTER TO BUFFER
         CLI   NOTUSED,SWON        CHECK FOR NOT IN-USE        @YL026YB
         BE    DYNAMRY             YES,PROCESS '*' INDICATOR   @YL026YB
BSCRT11  XR    R1,R1               CLEAR FOR INSERT            @YL026YB
         LH    R1,DSADSLNG         GET LENGTH OF DSNAME        @YL026YB
         LA    R3,DSADSNAM         POINTER TO DSNAME           @YL026YB
         BCTR  R1,R0               DECREMENT LENGTH FOR MOVE
         EX    R1,MOVE             MOVE DSNAME TO BUFFER
         LA    R14,D1(R7,R1)       POINT AT END OF DATA
         CLI   NOTUSED,SWON        CHECK FOR NOT IN-USE        @YL026YB
         BNE   CONT9               CONTINUE NORMALLY           @YL026YB
         LR    R7,R6               STARTING ADDRESS OF BUF     @YL026YB
CONT9    CLC   DMEMLNT(D2),ZERO1   IS MEMBER ALLOCATED         @YL026YB
         BE    BSCRT00B            NO, SKIP MEMBER PROCESSING    A42338
*        PROCESS MEMBER NAMES                                         *
         LA    R3,DSAMEM           POINT TO MEMBER NAME          A42338
         MVI   D0(R14),LPAREN      MOVE IN LEFT PARENTHESIS      A42338
         LA    R14,D1(R14)         POINT PAST PARENTHESIS        A42338
         LH    R4,DMEMLNT          LENGTH OF MEMBER NAME       @YL026YB
         BCTR  R4,R0               DECREMENT FOR EXECUTE       @YL026YB
         EX    R4,MOVE1            PUT MEMBER NAME IN BUFFER   @YL026YB
         AR    R14,R4              POINT PAST MEMBER NAME      @YL026YB
         MVI   D2(R14),RPAREN      MOVE IN CLOSING PARENTHESIS   A42338
         LA    R14,D3(R14)         POINT PAST DATA             @ZA02544
BSCRT00B BAL   R8,WRITE            GO WRITE THE NAME             A42338
         TM    CNTRL,HISTMEM       CHECK FOR HISTORY OR MEMBERS  A42338
         BZ    BSCRT01             NEITHER, CHECK STATUS
         BAL   R8,OBTRT            OBTAIN DSCB
         TM    CNTRL,HISTMSK       WAS HISTORY REQUESTED
         BNO   BSCRT01             NO, CHECK STATUS
         L     R15,VCONHIST        ADDRESS OF HISTORY ROUTINE
         BALR  R14,R15             GO TO HISTORY ROUTINE
BSCRT01  TM    CNTRL,STATMSK       WAS STATUS REQUESTED
         BNO   BSCRT02             NO, CHECK WRITE SWITCH
         L     R15,VCONSTAT        ADDRESS OF STATUS ROUTINE
         BALR  R14,R15             GO TO STATUS ROUTINE
BSCRT02  TM    CNTRL,WRITEMSK      IS WRITE SWITCH ON
         BNO   BSCRT02A            NO, GO CHECK NEXT OPTION
         LA    R7,OUTBUF           POINT AT BUFFER
         LA    R14,MAXBUF(R7)      POINT AT END OF BUFFER
         BAL   R8,WRITE            GO WRITE BUFFER TO TERMINAL
         NI    CNTRL,HEXFF-WRITEMSK TURN OFF WRITE SWITCH
BSCRT02A TM    CNTRL,OBTSW         CHECK FOR OBTAIN SWITCH
*                                                                     *
*  IF THE OBTAIN SWITCH IS TURNED ON, IT MEANS THAT THE OBTAIN ISSUED *
*  FOR HISTORY INFORMATION FAILED AND NO DATA WAS SUPPLIED FOR THE    *
*  HISTORY OPTION. THE ERROR WAS NOT PROCESSED UNTIL NOW IN           *
*  ORDER TO ALLOW STATUS INFORMATION TO BE PROCESSED IF REQUESTED.    *
*                                                                     *
         BNO   BSCRT03             NO, GO CHECK FOR MEMBERS
         NI    CNTRL,NOBTSW        TURN OFF OBTAIN SWITCH
         L     R15,OBTAINRC        GET OBTAIN RETURN CODE
         LA    R15,D0(R15)         CLEAR HIGH ORDER BYTE
         TM    OBTAINRC,HEXFF      TEST FOR LOCATE FAILURE
         BNO   OBTCODE(R15)        NO, ANALYZE OBTAIN RETURN CODE
         TM    CNTRL,HISTMSK       WAS HISTORY REQUESTED       @ZA09151
         BNO   TESTMEM             NO, GO CHECK FOR MEMBERS    @ZA09151
         LA    R1,MSG01            MESSAGE 1
         STH   R1,ERRFIRST         INTO LIST FOR ERROR HANDLER
         CLC   JESNAME,OBTDSNAM    TEST FOR SPOOL DS            ZA00106
         BE    SPOOLNM             YES, SEND SPOOL MSG          ZA00106
         LA    R1,SECMSG05         SECOND LEVEL MESSAGE 5
         B     GOON                BRANCH AROUND SPL MSG        ZA00106
SPOOLNM  LA    R1,SECMSG11         SECOND LEVEL MESSAGE 11      ZA00106
         STH  R1,ERRSECND          INTO LIST FOR ERROR HANDLER  ZM32756
         B    MSGOUT      BRANCH AROUND CONVERT OF RETURN CODE  ZM32756
GOON     EQU   *                                                ZA00106
         STH   R1,ERRSECND         INTO LIST FOR ERROR HANDLER
         BAL   R8,CVDREG15         CONVERT RETURN CODE
MSGOUT   EQU   *                                                ZM32756
         BAL   R8,ERROUT           GO WRITE ERROR MESSAGE       ZM32756
         B     BSCRT04             CHECK FOR MORE DSE BLOCKS
OBTCODE  DS    F                   RC=00 HANDLED ELSEWHERE
         B     NOTDA               RC=04 VOLUME NOT MOUNTED OR NOT DA
         B     NODSCB              RC=08 DSCB NOT ON THIS VOLUME
         B     OBTIOERR            RC=12 I/O ERROR DURING OBTAIN
         B     OBTIOERR            RC=16 ERROR IN OBTAIN WORK AREA
         B     OBTIOERR            RC=20 DSCB OUT OF VTOC EXTENT
NOTDA    LA    R1,SECMSG01         SECOND LEVEL MESSAGE 1
         B     OBTERRRT            GO PROCESS ERROR
NODSCB   LA    R1,SECMSG02         SECOND LEVEL MESSAGE 2
         B     OBTERRRT            GO PROCESS ERROR
OBTIOERR BAL   R8,CVDREG15         CONVERT RETURN CODE
         LA    R1,SECMSG04         SECOND LEVEL MESSAGE 4
         B     OBINSERT            SET UP REST OF MESSAGE
OBTERRRT XC    ERRINST1(L'ERRINST1+L'ERRINST2),ERRINST1 CLEAR BYTES
OBINSERT STH   R1,ERRSECND         INTO LIST FOR ERROR ROUTINE
*  EITHER MEMBERS OR HISTORY OR BOTH FAILED
         TM    CNTRL,HISTMSK       HISTORY OPTION ON
         BO    HISTFAIL            IF ONES HISTORY FAILED
         B     TESTMEM             WAS MEMBERS ON
HISTFAIL LA    R1,MSG01            MESSAGE 1
         STH   R1,ERRFIRST         INTO LIST FOR ERROR ROUTINE
         BAL   R8,ERROUT           WRITE MESSAGE
         TM    LOCSW,HEXFF         WAS LOCATE ISSUED
         BNO   TESTMEM             NO, TEST MEMBERS OPTION
         MVI   LOCSW,D0            YES, TURN OFF SWITCH
         B     MSGDONE             CHECK FOR MORE DSE ENTRIES
TESTMEM  TM    CNTRL,MEMMSK        IS MEMBERS OPTION ON
         BNO   MSGDONE             CHECK FOR MORE DSE ENTRIES
         LA    R1,MSG04            MESSAGE 4
         STH   R1,ERRFIRST         INTO LIST FOR ERROR ROUTINE
         BAL   R8,ERROUT           WRITE MESSAGE
MSGDONE  B     BSCRT04             CHECK FOR MORE DSE ENTRIES
BSCRT03  TM    CNTRL,MEMMSK        WAS MEMBERS REQUESTED
         BNO   BSCRT04             NO, PROCESS NEXT ENTRY
         L     R15,VCONMEM         ADDRESS OF MEMBERS ROUTINE
         BALR  R14,R15             GO TO MEMBERS ROUTINE
BSCRT04  CLI   LSTENTRY,SWOFF      ARE THERE MORE DSABS        @YL026YB
         BNE   WRAPUP              NO, GO FINISH               @YL026YB
         LA    R7,OUTBUF           SETUP TO SKIP A LINE
         LR    R14,R7              NULL LINE
         BAL   R8,WRITE            GO TO WRITE ROUTINE
         LH    R2,REQNUM           RELATIVE REQUEST NUMBER     @YL026YB
         B     NXTDSAB             GO PROCESS NEXT DSAB        @YL026YB
NXDSEBLK CLI   LSTENTRY,SWOFF      ARE THERE MORE DSABS        @YL026YB
         BNE   WRAPUP              YES, GO TO NORMAL TERMINATION
         LH    R2,REQNUM           RELATIVE REQUEST NUMBER     @YL026YB
         B     NXTDSAB             GO PROCESS NEXT DSAB        @YL026YB
         EJECT
***********************************************************************
*                                                                     *
*     THE NORMAL TERMINATION ROUTINE FIRST CHECKS TO SEE IF ANY DATA- *
*     NEED TO BE UNALLOCATED IF SO, A MESSAGE IS PUT TO THE TERMINAL  *
*     WITH THE COUNT, FOLLOWED BY THE DDNAMES IF STATUS WAS REQUESTED.*
*                                                                     *
***********************************************************************
WRAPUP   CLC   DYNAMCNT(D2),ZERO1  WERE ANY DSETS TO  BE FREED @YL026YB
         BE    WRAPUP00            NO, GO TERMINATE            @YL026YB
         LH    R2,DYNAMCNT         PICK UP COUNT
         CVD   R2,NULLCNT          CONVERT COUNT TO DECIMAL
         LA    R7,OUTBUF           POINT AT BUFFER
         UNPK  D0(L3,R7),NULLCNT+D6(D2) UNPACK COUNT INTO BUFFER
         OI    D2(R7),ZONE         SET CORRECT ZONE
         CLI   D0(R7),ZONE         ELIMINATE LEADING ZEROES
         BNE   DYNAMRT4            NONE, GO GET MESSAGE
         MVC   D0(D3,R7),D1(R7)    SHIFT ZERO AWAY
         CLI   D0(R7),ZONE         CHECK NEXT PLACE FOR ZERO
         BE    DYNAMRT5            YES, GO GET RID OF IT
         LA    R7,D3(R7)           NO, INDICATE PROPER DISPLACEMENT
DYNAMRT3 MVC   D0(L'DYNAMMSG,R7),DYNAMMSG PUT TEXT IN BUFFER
         LA    R14,L'DYNAMMSG(R7)  BUMP POINTER TO END OF DATA
         LA    R7,OUTBUF           START OF BUFFER
         BAL   R8,WRITE            WRITE BUFFER
         B     DYNAMRT6            GO CHECK STATUS
DYNAMRT4 LA    R7,D4(R7)           PROPER DISPLACEMENT
         B     DYNAMRT3            GO PUT OUT MESSAGE
DYNAMRT5 MVC   D0(L2,R7),D1(R7)    SHIFT EXTRA ZERO OFF
         LA    R7,D2(R7)           PROPER DISPLACEMENT
         B     DYNAMRT3            GO COMPLETE MESSAGE
DYNAMRT6 TM    CNTRL,STATMSK       WAS STATUS REQUESTED
         BNO   WRAPUP00            NO, GO TERMINATE
         LA    R9,DYNAMSAV         ADDRESS OF FIRST DYNAM ENTRY
         LH    R5,DDCNT            COUNT OF RE-USE DDNAME      @YL026YB
DYNAMRT7 MVC   OUTBUF+DYNDDOFF(DDNAMLEN),D0(R9) MOVE DDNAME TO @YL026YB
*                                               BUFFER         @YL026YB
         LA    R7,OUTBUF           POINT AT BUFFER
         LA    R14,DDNAMLEN+DYNDDOFF(R7) END OF DATA POINTER
         BAL   R8,WRITE            GO WRITE BUFFER
         LA    R9,D8(R9)           POINT TO NEXT DDNAME        @YL026YB
         BCT   R5,DYNAMRT7         CHECK FOR MORE ENTRIES      @YL026YB
WRAPUP00 CLI   ASKSWTCH,SWON        CHECK FOR NOT IN-USE       @YL026YB
         BNE   WRAPUP99            GO TERMINATE                @YL026YB
         LA    R7,OUTBUF           POINT AT BUFFER             @YL026YB
         MVC   D0(L'ASKMSG,R7),ASKMSG PUT TEXT IN BUFFER       @YL026YB
         LA    R14,L'ASKMSG(R7) BUMP POINTER TO IN OF DATA     @YL026YB
         BAL   R8,WRITE            GO TO WRITE ROUTINE         @YL026YB
WRAPUP99 LA    R7,OUTBUF           SETUP TO SKIP A LINE        @YL026YB
         LR    R14,R7              NULL LINE
         BAL   R8,WRITE            GO TO WRITE ROUTINE
WRAPUPT  NC    OBTWA,OBTWA         TEST FOR OBTAIN WORK AREA
         BZ    WRAPUP01            NO, SKIP FREEMAIN
*  FREE WORK CORE GOTTEN FOR OBTAIN AND JFCB WORKAREAS
         LA    R2,OBTWA            POINTER TO CORE TO BE FREE
         LA    R1,FREEML           FREEMAIN PARAMETER LIST
         FREEMAIN E,A=(R2),LV=OBTWAL,SP=OSP,MF=(E,(1)) FREE CORE
WRAPUP01 NC    MEMMOD,MEMMOD       WAS MEMBER MODULE LOADED
         BZ    WRAPUP02            NO, SKIP DELETE
         DELETE EP=IKJEHMEM        DELETE MEMBERS MODULE
WRAPUP02 DELETE EP=IKJPUTL         DELETE PUTLINE
*  NOW CHECK IF AN ERROR HAS OCCURRED.  IF SO, THE STACK MUST BE
*  FLUSHED AND THE INPUT QUEUE CLEARED.
         CLI   STACKSW,SWON        IS STACK SWITCH ON
         BNE   STACKOK             NO ERROR, END NORMALLY
         LA    R1,UPTPTR           POINT TO I/O PARAMETER LIST
         LA    R2,STACKPRM         POINT TO STACK PARM BLOCK
         ST    R2,PUTLADDR         POINT TO STACK PARM BLOCK
         STACK DELETE=ALL,MF=(E,(1)) FLUSH STACK
         TCLEARQ INPUT             CLEAR ANYTHING TYPED AHEAD
STACKOK  EQU   *                   NORMAL RETURN FROM HERE
         L     R8,RETCD            GET RETURN CODE
         LR    R1,R13              ADDRESS OF CORE TO BE FREED
         L     R13,D4(R13)         RESTORE ADDRESS OF CALLERS SAVEAREA
         FREEMAIN R,LV=INITSIZE,A=(1),SP=SSP FREE CORE
         LR    R15,R8              PUT RETURN CODE IN REGISTER 15
         RETURN (14,12),T,RC=(15)  RETURN
*
***********************************************************************
*                                                                     *
*  GETMAIN ROUTINE FOR MEMBERS, SYSNAMES AND HISTORY WORK AREA        *
*                                                                     *
***********************************************************************
LGM02    LA    R1,GETML            GETMAIN PARAMETER LIST
         LA    R2,OBTWA            ADDRESS OF CORE GOES TO OBTWA
         GETMAIN A=(R2),SP=OSP,LV=OBTWAL,MF=(E,(1)) GET CORE
         B     GMRC(R15)           ANALYZE GETMAIN RETURN CODE
GMRC     B     GMOK                RC = 0, GETMAIN OK
         B     GMNOTOK             RETURN CODE=4, NO CORE AVAILABLE
GMOK     L     R12,OBTWA           ADDRESS OF CORE JUST GOTTEN
         ST    R12,OBTJFCBX        ADDRESS OF JFCB WORK AREA
         LA    R2,OBTDCB           ADDRESS OF DCB IN DSECT
         USING IHADCB,R2           ADDRESSABILITY DCB
         MVC   OBTMACS(LOLFS),OLFS MOVE MACRO LIST FORMS TO DSECT
         LA    R15,OBTDCBXL        ADDRESS OF DCB EXIT LIST
         ST    R15,DCBEXLST        SET UP EXIT LIST ADDRESS
         MVI   OBTJFCBX,EXITCD     SET JFCB DCB EXIT CODE
         DROP  R2                  DCB NO LONGER NEEDED
         BR    R8                  RETURN TO CALLER
GMNOTOK  LA    R1,MSG02            MESSAGE 2
         STH   R1,ERRFIRST         INTO LIST FOR ERROR HANDLER
         XC    ERRSECND,ERRSECND   CLEAR SECOND LEVEL MESSAGE
         LA    R1,ERRINSRT         PICK UP ADDRESS OF FIRST INSERT
         ST    R1,ERRINST1         PUT IN ERROR LIST
         MVI   ERRINSRT,L'NHISTORY LENGTH OF INSERT
         TM    CNTRL,HISTMSK       WAS HISTORY OPTION ON
         BNO   CKMEM               NO, CHECK MEMBERS OPTION
         NI    CNTRL,HEXFF-HISTMSK YES, TURN OFF SWITCH
         MVC   ERRINSRT+D1(L'NHISTORY),NHISTORY HISTORY INSERT
         BAL   R8,ERROUT           GO WRITE MESSAGE
CKMEM    TM    CNTRL,MEMMSK        IS MEMBERS OPTION ON
         BNO   CKSYSNM             NO, CHECK SYSNAMES
         NI    CNTRL,HEXFF-MEMMSK  TURN OFF MEMBERS OPTION
         MVC   ERRINSRT+D1(L'NMEMBERS),NMEMBERS MEMBERS INSERT
         BAL   R8,ERROUT           GO WRITE MESSAGE
CKSYSNM  TM    CNTRL,SYSNMSK       IS SYSNAMES OPTION ON
         BNO   GMEND               IF NOT, EXIT
         NI    CNTRL,HEXFF-SYSNMSK YES, TURN OFF SYSNAMES OPTION
         MVC   ERRINSRT+D1(L'NSYSNAME),NSYSNAME SYSNAMES INSERT
         MVI   ERRINSRT,L'NSYSNAME LENGTH OF INSERT
         BAL   R8,ERROUT           GO WRITE MESSAGE
GMEND    B     NOMEMREQ            GO PROCESS
***********************************************************************
*                                                                     *
*    THIS ROUTINE GETS CONTROL WHEN A NULLFILE IS FOUND. A MESSAGE IS *
*    WRITTEN OUT INDICATING THE NULLFILE IS PRESENT.  IF STATUS       *
*    WAS REQUESTED, THE DDNAME IS INCLUDED.                           *
*                                                                     *
***********************************************************************
NULLFRT  LA    R7,OUTBUF           POINT AT BUFFER
         MVC   D0(L'NULLFILE,R7),NULLFILE MOVE NULLFILE TO BUFFER
         LA    R14,L'NULLFILE(R7)  POINT AT END OF DATA
         TM    CNTRL,STATMSK       WAS STATUS REQUESTED
         BNO   NULLFRT1            NO, GO WRITE OUT BUFFER
         MVC   NULLDDOF(DDNAMLEN,R7),DSADDNAM MOVE DDNAME TO BUFFER
         LA    R14,D2+DDNAMLEN(R14) POINT PAST DDNAME            A49871
NULLFRT1 BAL   R8,WRITE            GO WRITE BUFFER
         B     BSCRT04             GO CHECK FOR MORE BLOCKS
***********************************************************************
*                                                                     *
*     THIS ROUTINE GETS CONTROL WHEN AN ASTERISK (*) IS FOUND FOR THE *
*     DSNAME IN THE DSE ENTRY. THIS IS AN INDICATION THAT IT IS A     *
*     TERMINAL FILE AND A MESSAGE IS WRITTEN TO INDICATE THIS. IF     *
*     STATUS INFORMATION WAS REQUESTED, THE DDNAME WILL BE INCLUDED.  *
*                                                                     *
***********************************************************************
TERMFRT  LA    R7,OUTBUF           POINT AT BUFFER
         MVC   D0(L'TERMFILE,R7),TERMFILE MOVE TERMFILE TO BUFFER
         LA    R14,L'TERMFILE(R7)  POINT AT END OF DATA
         TM    CNTRL,STATMSK       WAS STATUS REQUESTED
         BNO   TERMFRT1            NO, GO WRITE BUFFER
         MVC   TERMDDOF(DDNAMLEN,R7),DSADDNAM MOVE DDNAME TO BUFFER
         LA    R14,D2+DDNAMLEN(R14) END OF DATA POINTER          A49871
TERMFRT1 BAL   R8,WRITE            GO WRITE BUFFER
         B     BSCRT04             GO CHECK FOR MORE BLOCKS
***********************************************************************
*                                                                     *
*     THIS ROUTINE GETS CONTROL IF AN AVAILABLE ENTRY IS FOUND IN     *
*     THE CHAIN OF DSE ENTRIES. IF IT IS THE FIRST TIME THE ROUTINE   *
*     HAS BEEN ENTERED, A SWITCH IS TURNED ON AND A COUNTER IS SET    *
*     TO ONE. THE ADDRESS OF THE FIRST DYNAM ENTRY IS SAVED. IF THIS  *
*     IS NOT THE FIRST TIME INTO THIS ROUTINE, THE COUNTER IS BUMPED  *
*     BY ONE AND AN EXIT IS TAKEN.                                    *
*                                                                     *
***********************************************************************
DYNAMRT  LA    R3,DSADDNAM         ADDRESS OF DDNAME           @YL026YB
         CLI   DYNAMSW,SWON        IS THIS THE FIRST ENTRY     @YL026YB
         BE    DYNAMRT1            NO,GO TO NEXT ENTRY         @YL026YB
         SR    R5,R5               CLEAR REG 5                 @YL026YB
         LA    R4,DYNAMSAV         POINT TO DDNAMES            @YL026YB
         MVI   DYNAMSW,SWON        TURN SWITCH ON              @YL026YB
         B     DYNAMRX             GO STORE DDNAME             @YL026YB
DYNAMRT1 L     R4,DSAV             POINTER TO NEXT DDNAME ENTRY
         LH    R5,DDCNT            PUT DDNAME COUNT IN REG 5   @YL026YB
         LA    R5,D1(R5)           COUNT OF DDNAME ENTRIES     @YL026YB
DYNAMRX  MVC   D0(D8,R4),D0(R3)    STORE DDNAME                @YL026YB
         LA    R4,D8(R4)           POINT TO SPACE FOR NEXT DDNAME
         ST    R4,DSAV             STORE POINTER               @YL026YB
         STH   R5,DDCNT            STORE DDNAME COUNT          @YL026YB
         B     BNORM               RETURN TO NORMAL PROCESSING @YL026YB
DYNAMRY  MVI   D0(R7),ASTERSK      PUT '*' IN 1ST POSITION     @YL026YB
         LR    R6,R7               SAVE ADRESS IN R6           @YL026YB
         LA    R7,D1(R7)           BUMP POINTER FOR DSNAME     @YL026YB
         B     BSCRT11             GO WRITE NAME               @YL026YB
*                                  -LIST DATA SET INFORMATION
***********************************************************************
*                                                                     *
*   THIS ROUTINE IS ENTERED IF HISTORY OR MEMBERS WAS REQUESTED       *
*   ON THE COMMAND.  IT MAKES THE NECESSARY CONCATENATION TESTS AND   *
*   ISSUES A LOCATE TO GET A VOLSER FOR THE OBTAIN IF THE             *
*   HISTORY OPTION WAS REQUESTED.  IF IT IS NOT                       *
*   CONCATENATED, A RDJFCB IS ISSUED FOR THE VOLSER.  IF THE OBTAIN   *
*   FOR THE DSCB FAILS, A SWITCH IS SET (OBTSW--ALSO SET IF LOCATE    *
*   FAILS), AND CONTROL IS RETURNED TO THE MAINLINE.  THE SWITCH IS   *
*   CHECKED IN THE MAINLINE AND A MESSAGE IS PUT OUT TO THE TERMINAL  *
*   INDICATING THE REQUESTED INFORMATION CANNOT BE SUPPLIED.          *
*                                                                     *
***********************************************************************
OBTRT    STM   R0,R9,LOCSAVOF(R13) SAVE REGISTERS LOCALLY
         CLC   DSADDNAM(L'BLANKS),BLANKS IS DDNAME BLANKS      @YL026YB
         BE    HISTLOC             YES, MUST BE CONCATENATED
         TM    DSACNTRL,DYNCON     SEE IF DYNAMICATENATION BIT IS ON
         BO    HISTDCON            YES, CHECK FURTHUR
         NI    CNTRL,HEXFF-CONCATSW TURN OFF CONCATENATION SWITCH
HISTGO   LA    R2,OBTDCB           ADDRESS OF THE DCB IN THE DSECT
         USING IHADCB,R2           ADDRESSABILITY DCB
         MVC   DCBDDNAM,DSADDNAM   PUT DDNAME IN DCB           @YL026YB
         LA    R1,RDJL             RDJFCB LIST FORM IN DSECT
         RDJFCB  ((R2)),MF=(E,(R1)) ISSUE READ JFCB
         DROP  R2                  DCB NO LONGER NEEDED
         LA    R15,JFCBVOLS        ADDESS OF VOLID
         CLC   JFCBVOLS(D4),ZERO   CHECK FOR ZERO VOLSER
         BE    HISTLOC             GO DO A LOCATE
         ST    R15,OBTVOL          -TO OBTAIN LIST
HISTOBTN LA    R15,OBTDSNAM        ADDRESS OF THE DATA SET NAME
         ST    R15,OBTDSN          -TO OBTAIN LIST
         LA    R15,OBTWORKA        ADDRESS OF 350 BYTE WORK AREA
         ST    R15,OBTWKA          -TO OBTAIN LIST
         OBTAIN  OBTCLST           ISSUE OBTAIN
         LTR   R15,R15             TEST RETURN CODE
         BZ    OBTOKGO             ZERO, GO PROCESS INFORMATION
         L     R15,VCONVHS                                     @YL026YB
         BALR  R14,R15                                         @YL026YB
         B     BSCRT01             GO CHECK NEXT ENTRY
HISTDCON TM    CNTRL,CONCATSW      CHECK CONCATENATION SWITCH
         BO    HISTLOC             IF ON, GO ISSUE LOCATE FOR VOLUMES
         OI    CNTRL,CONCATSW      IF OFF, TURN IT ON
         B     HISTGO              GO PROCESS THIS ENTRY NORMALLY
HISTLOC  TM    CNTRL,HISTMSK       WAS HISTORY BIT ON
         BNO   HISTLOC1            IF NOT DO NOT DO LOCATE
         XR    R15,R15             CLEAR REGISTER FOR INSERT
         LH    R15,DSADSLNG        GET LENGTH OF DSNAME        @YL026YB
         MVI   OBTDSNAM,BLANK      BLANK OUT AREA TO CONTAIN
         MVC   OBTDSNAM+D1(L'OBTDSNAM-D1),OBTDSNAM -DSNAME
         LA    R7,OBTDSNAM         POINT AT AREA TO HOLD DSNAME
         LA    R3,DSADSNAM         POINT AT DSNAME             @YL026YB
         BCTR  R15,R0              DECREMENT LENGTH FOR EXECUTE
         EX    R15,MOVE            MOVE DSNAME
         MVC   LOCLIST(L'LOCLIST),CAM1 INITIALIZE LOCATE LIST
         LA    R1,OBTDSNAM         POINT AT DSNAME
         ST    R1,LOCLIST+LOCNAME  PUT INTO CAMLST
         XR    R1,R1               ZERO REGISTER
         ST    R1,LOCLIST+LOCCVOL  INDICATE NO CVOL
         LA    R1,LOCAREA          POINT AT LOCATE WORK AREA
         ST    R1,LOCLIST+LOCWA    PUT ADDRESS INTO CAMLST
         LOCATE LOCLIST            ISSUE LOCATE
         LTR   R15,R15             TEST RETURN CODE
         BZ    HISLOCOK            IF ZERO, GO DO OBTAIN
         L     R15,VCONVHS         ADDRESS OF VSAM HISTORY ROUT.
         BALR  R14,R15             GO TO VSAM ROUTINE          @YL026YB
         B     BSCRT01             GO CHECK STATUS
HISTLOC1 XC    DS1DSORG-OBTWAD(L2,R12),ZERO CLEAR DSORG FIELD
         B     BSCRT01             GO CHECK STATUS
HISLOCOK LA    R15,LOCAREA+FIRSTVOL POINT AT FIRST VOLSER IN LIST
         ST    R15,OBTCLST+D8      PUT IN OBTAIN LIST
         B     HISTOBTN            GO COMPLETE LIST AND ISSUE OBTAIN
OBTOKGO  LM    R0,R9,LOCSAVOF(R13) RESTORE REGISTERS
         BR    R8                  RETURN
         EJECT
***********************************************************************
*                                                                     *
*   INPUT TO THIS ROUTINE IS THE BUFFER ADDRESS IN REGISTER 7         *
*   AND THE END OF BUFFER ADDRESS IN REGISTER 14.                     *
*   THE RETURN ADDRESS IS IN REGISTER 8.                              *
*   THE OUTPUT BUFFER IS CLEARED AND RETURNED IN REGISTER 7.          *
*   TRAILING BLANKS WILL BE ELIMINATED.                               *
*                                                                     *
*   IMPORTANT---THIS ROUTINE REQUIRES NO BASE REGISTER. KEEP IT THAT  *
*   WAY SO THAT IKJEHMEM CAN USE IT.                                  *
*                                                                     *
***********************************************************************
IKJEHWRT EQU   *                   WRITE ROUTINE EXTERNAL NAME
WRITE    STM   R0,R9,LOCSAVOF(R13) SAVE REGISTERS LOCALLY
         LR    R2,R14              GET END OF DATA POINTER
         SR    R2,R7               CALCULATE DATA LENGTH
         LA    R1,FOUR             DECREMENT BUFFER POINTER BY 4
         SR    R7,R1               -SO R7 WILL POINT AT LL FIELD
         LA    R2,FOUR(R2)         BUMP LL BY FOUR FOR LL AND OFFSET
         STH   R2,D0(R7)           STORE LENGTH
         XC    D2(L2,R7),D2(R7)    CLEAR OFFSET BYTE
         LR    R6,R7               PUT OUTPUT LINE POINTER IN PROPER
         LA    R1,PARMLSTL         POINT IN FRONT OF BUFFER
         SR    R7,R1               CONTANING VARIOUS ADCONS
         LM    R1,R5,D0(R7)        SET UP REGISTERS FOR PUTLINE
         L     R15,PARMLSTL-FOUR(R7) GET ENTRY POINT.
         PUTLINE PARM=(R2),UPT=(R3),ECT=(R4),ECB=(R5),OUTPUT=((R6),    X
               DATA),ENTRY=(15),MF=(E,(1)) PUTLINE
         LA    R7,PARMLSTL+FOUR(R7) POINT BACK TO DATA BUFFER
         MVI   D0(R7),BLANK        BLANK FIRST BYTE OF BUFFER
         MVC   D1(L'OUTBUF-L1,R7),D0(R7) CLEAR BUFFER
         LM    R0,R9,LOCSAVOF(R13) RESTORE CALLERS REGISTER
         BR    R8                  RETURN TO CALLER
         EJECT
***********************************************************************
*                                                                     *
*  THIS ROUTINE IS USED TO OUTPUT ERROR MESSAGES.  INPUT IS A THREE   *
*  WORD LIST CALLED ERRPARM WHICH CONTAINS INFORMATION AS FOLLOWS-    *
*        BYTE 1 AND 2 - THE RELATIVE POSITION OF THE FIRST            *
*                       LEVEL MESSAGE IN THE MESSAGE CSECT            *
*        BYTE 3 AND 4 - THE RELATIVE POSITION OF THE SECOND           *
*                       LEVEL MESSAGE IN THE MESSAGE CSECT            *
*        SECOND WORD  - POINTS TO TEXT TO BE INSERTED AFTER THE       *
*                       FIRST SEGMENT OF FIRST LEVEL MESSAGE          *
*        THIRD WORD   - POINTS TO TEXT TO BE INSERTED AFTER THE       *
*                       FIRST SEGMENT OF SECOND LEVEL MESSAGE         *
*  REGISTER 8 IS THE RETURN REGISTER                                  *
*                                                                     *
***********************************************************************
IKJEHERR EQU   *                   EXTERNAL NAME FOR ERROR ROUTINE
ERROUT   STM   R0,R9,LOCSAVOF(R13) SAVE LOCAL REGISTERS
         MVI   STACKSW,SWON        TURN STACK SWITCH ON
         LA    R7,OUTBUF+D4        POINT AT PROPER BUFFER OFFSET
         LH    R1,ERRPARM          RELATIVE MESSAGE NUMBER
         BCTR  R1,R0               DECREMENT POSITION COUNT
         SLL   R1,D3               MULTIPLY BY 8 GIVES INDEX INTO TABLE
         L     R6,MSGCSECT         ADDRESS OF MESSAGE CSECT
         LA    R5,D0(R6,R1)        TABLE ENTRY FOR PROPER MESSAGE
         LH    R1,D0(R5)           LENGTH OF MESSAGE
         LA    R2,D4(R1)           UP LENGTH FOR LL AND OFFSET FIELDS
         STH   R2,OUTBUF           SAVE LENGTH
         XC    OUTBUF+D2(L2),OUTBUF+D2 CLEAR OFFSET FIELD
         LH    R4,D2(R5)           OFFSET TO MESSAGE IN CSECT
         LA    R3,D0(R6,R4)        POINTER TO MESSAGE IN CSECT
         BCTR  R1,R0               DECREMENT COUNT FOR EXECUTE
         EX    R1,MOVE             MOVE MESSAGE TO BUFFER
         LA    R7,D1(R1,R7)        POINT BEYOND MESSAGE
         L     R4,ERRINST1         INSERTION POINTER
         LTR   R4,R4               TEST FOR ZERO
         BZ    SEGCHECK            IF ZERO, CHECK FOR SEGMENTATION
         XR    R1,R1               ZERO REGISTER
         IC    R1,D0(R4)           GET LENGTH OF INSERT DATA
         LA    R3,D1(R4)           POINT AT INSERT DATA
         LH    R2,OUTBUF           GET LENGTH
         LA    R2,D0(R2,R1)        INCREMENT COUNT
         STH   R2,OUTBUF           SAVE LENGTH AGAIN
         BCTR  R1,R0               DECREMENT COUNT FOR EXECUTE
         EX    R1,MOVE             MOVE INSERT DATA TO BUFFER
         LA    R7,D1(R1,R7)        POINT BEYOND MESSAGE
SEGCHECK LH    R4,D4(R5)           PICKUP OFFSET OF SEGMENT
         LTR   R4,R4               TEST FOR ZERO
         BZ    SECLVTST            CHECK FOR SECOND LEVEL MESSAGE
         LA    R4,D0(R4,R6)        POINT AT SEGMENT TABLE
SEGLOOP  LH    R1,D0(R4)           PICK UP LENGTH OF SEGMENT
         LTR   R1,R1               TEST LENGTH
         BZ    SECLVTST            CHECK FOR SECOND LEVEL MESSAGE
         LH    R2,OUTBUF           GET LENGTH
         LA    R2,D0(R2,R1)        INCREMENT COUNT
         STH   R2,OUTBUF           SAVE LENGTH AGAIN
         LH    R3,D2(R4)           PICKUP OFFSET TO SEGMENT
         LA    R3,D0(R3,R6)        CALCULATE THE ADDRESS
         BCTR  R1,R0               DECREMENT FOR EXECUTE
         EX    R1,MOVE             MOVE SEGMENT TO BUFFER
         LA    R7,D1(R7,R1)        POINT AT END OF DATA IN BUFFER
         LA    R4,D4(R4)           NEXT SEGMENT SLOT IN TABLE
         B     SEGLOOP             PROCESS ANOTHER SEGMENT
*  THIS ROUTINE CHECKS FOR SECOND LEVEL MESSAGES,
*  IF NONE IT PROCESSES FIRST LEVEL
SECLVTST LA    R1,D1               SEGMENT COUNT IS 1
         ST    R1,MSGPARM1+D4      PUT IN PARM LIST
         LA    R1,OUTBUF           POINT TO OUTPUT BUFFER
         ST    R1,MSGPARM1+D8      SAVE POINTER TO FIRST LEVEL MESSAGE
         LH    R1,ERRSECND         CHECK FOR SECOND LEVEL MESSAGE
         LTR   R1,R1               TEST FOR ZERO
         BZ    NOSECLVL            NO SECOND LEVEL PUT OUT FIRST ONLY
         BCTR  R1,R0               DECREMENT POSITION COUNT
         LA    R0,D6               TABLE ENTRY SIZE
         MR    R0,R0               OFFSET INTO TABLE CALCULATED
         LH    R4,D6(R5)           OFFSET TO SECOND LEVEL TABLE
         LA    R4,D0(R4,R6)        ADDRESS OF TABLE
         LA    R5,D0(R4,R1)        OFFSET TO ENTRY IN TABLE
         LA    R7,SECBUFF+D4       POINT TO SECOND BUFFER OFFSET
         LH    R1,D0(R5)           GET LENGTH OF ENTRY
         LA    R2,D4(R1)           UP LENGTH FOR LL AND OFFSET FIELDS
         STH   R2,SECBUFF          SAVE LENGTH OF FIRST SEGMENT
         XC    SECBUFF+D2(L2),SECBUFF+D2 CLEAR OFFSET FIELD
         LH    R4,D2(R5)           OFFSET TO MESSAGE IN CSECT
         LA    R3,D0(R6,R4)        ADDRESS OF MESSAGE IN CORE
         BCTR  R1,R0               DECREMENT LENGTH FOR EXECUTE
         EX    R1,MOVE             MOVE MESSAGE SEGMENT TO BUFFER
         LA    R7,D1(R1,R7)        BUMP BUFFER POINTER
         MVC   SECBUFF+D10(L2),OUTBUF+D10 SET ID FOR SECOND LEVEL
         L     R4,ERRINST2         INSERT POINTER FOR SECOND LEVEL
         LTR   R4,R4               TEST FOR ZERO
         BZ    SECSEGCK            IF ZERO, CHECK SEGMENTATION
         XR    R1,R1               ZERO REGISTER
         IC    R1,D0(R4)           GET LENGTH OF INSERT DATA
         LH    R2,SECBUFF          SEGMENT LENGTH
         LA    R2,D0(R2,R1)        UPDATE LENGTH OF BUFFER MESSAGE
         STH   R2,SECBUFF          SAVE LENGTH AGAIN
         LA    R3,D1(R4)           POINT AT DATA
         BCTR  R1,R0               DECREMENT COUNT FOR EXECUTE
         EX    R1,MOVE             MOVE DATA TO BUFFER
         LA    R7,D1(R1,R7)        UPDATE BUFFER POINTER
SECSEGCK LA    R1,D1               SET SEGMENT COUNT TO ONE
         ST    R1,MSGPARM2+D4      PUT IT INTO PARM LIST
         LA    R1,SECBUFF          BUFFER ADDRESS
         ST    R1,MSGPARM2+D8      -INTO LIST
         LA    R1,MSGPARM2         CHAIN MESSAGE LEVEL
         ST    R1,MSGPARM1         -PARAMETER LISTS
         XC    MSGPARM2,MSGPARM2   END OF CHAIN LINK ADDRESS
         MVI   MSGPARM2,HEXFF      END OF LIST FLAG IN CHAIN FIELD
         LH    R4,D4(R5)           OFFSET TO SEGMENT TABLE
         LTR   R4,R4               TEST FOR ZERO
         BZ    PUTMSG              IF ZERO, PUT OUT MESSAGE
         LA    R4,D0(R4,R6)        ADDRESS OF SEGMENT TABLE
         LH    R1,D0(R4)           LENGTH OF SEGMENT
SECSEGLP LTR   R1,R1               IS THIS THE LAST SEGMENT
         BZ    PUTMSG              YES, GO WRITE MESSAGE
         LH    R2,SECBUFF          SEGMENT LENGTH
         LA    R2,D0(R2,R1)        UPDATE LENGTH OF BUFFER MESSAGE
         STH   R2,SECBUFF          RE-STORE IT
         LH    R3,D2(R4)           OFFSET TO SEGMENT
         LA    R3,D0(R3,R6)        ADDRESS OF MESSAGE
         BCTR  R1,R0               DECREMENT COUNT FOR EXECUTE
         EX    R1,MOVE             MOVE INTO BUFFER
         LA    R7,D1(R7,R1)        UPDATE BUFFER OFFSET
         LA    R4,D4(R4)           GET NEXT SEGMENT
         B     SECSEGLP            GO PROCESS THIS SEGMENT
NOSECLVL XC    MSGPARM1,MSGPARM1   CLEAR SECOND LEVEL POINTER
         MVI   MSGPARM1,HEXFF      PUT IN END OF CHAIN MARK
PUTMSG   LM    R3,R5,UPTPTR        LOAD UPT, ECT, ECB ADDRESSES
         LA    R6,MSGPARM1         POINT TO MESSAGE PARM LISTS
         LA    R2,DPUTLINE         LIST FORM OF MACRO
         LA    R1,PUTLLIST         LIST FOR E FORM OF MACRO
         L     R15,PUTLADDR        ADDRESS OF PUTLINE ROUTINE
         PUTLINE PARM=(R2),UPT=(R3),ECT=(R4),ECB=(R5),                 X
               OUTPUT=((R6),MULTLVL),ENTRY=(15),MF=(E,(1)) PUTLINE
         LM    R0,R9,LOCSAVOF(R13) RESTORE LOCAL REGISTERS
         BR    R8                  RETURN
         EJECT
*
*  CONSTANTS AND LIST FORMS OF MACROS
*
TPUTMDL  PUTLINE MF=L              LIST FORM OF PUTLINE
ENDTPUT  EQU   *                   END OF PUTLINE EXPANSION
LTPUTL   EQU   ENDTPUT-TPUTMDL     LENGTH OF PUTLINE EXPANSION
OLFS     EQU   *                   BEGINNING OF LIST FORMS FOR OBTWAD
RDJMDL   RDJFCB  (,(INPUT)),MF=L   LIST FORM READ JFCB
         SPACE
CLSTMDL  CAMLST  SEARCH,1,2,3      OBTAIN CAMLST
         SPACE
DCBMDL   DCB   DSORG=PS,MACRF=R,RECFM=F,BLKSIZE=256,KEYLEN=8,LRECL=256,C
               DDNAME=DUMMY        DCB
         SPACE
OPENMDL  OPEN  (,),MF=L            LIST FORM OF OPEN
         SPACE
READMDL  READ  RMDECB,SF,,,'S',,,MF=L LIST FORM OF READ
         SPACE
CLOSEMDL CLOSE (,),MF=L            MODEL FOR THE LIST FORM OF CLOSE
LOLFS    EQU   *-OLFS              LENGTH OF AREA TO MOVE
         SPACE
ILFS     EQU   *                   BEGINNING OF LIST FORMS FOR INITCORE
GETMLMDL GETMAIN  EC,MF=L          LIST FORM OF GETMAIN
FREEMMDL FREEMAIN  E,MF=L          LIST FORM OF FREEMAIN
LILFS    EQU   *-ILFS              LENGTH OF LIST FORMS FOR INITCORE
         SPACE
PRSEC01  DC    V(IKJEHPRM)         ADDRESS OF PARSE CONTROL CSECT
MSGCSECT DC    V(IKJEHALM)         ADDRESS OF MESSAGE CSECT
VCONHIST DC    V(IKJEHHST)         ADDRESS OF HISTORY CSECT
VCONSTAT DC    V(IKJEHSTS)         ADDRESS OF STATUS CSECT
VCONMEM  DC    V(IKJEHMMR)         ADDRESS OF MEMBER CSECT
VCONVHS  DC    V(IKJEHVHS)         ADDR. OF VSAM HIST. CSECT   @YL026YB
CAM1     CAMLST NAME,1,,3          LOCATE CAMLST                  M0875
ZERO     DC    F'0'                USED FOR SETTING ZEROS
MOVE1    MVC   D0(D0,R14),D0(R3)   USED FOR EXECUTE INST.      @YL026YB
MOVE     MVC   D0(L1,R7),D0(R3)    USED FOR EXECUTE MOVES
BLANKS   DC    C'        '         BLANKS FOR COMPARISON
JESNAME  DC    C'JES'              COMPARISON FOR SPOOL DS      ZA00106
SYSNMMDL DC    C'SYS00000.T000000.' TEST FOR SYSNAMES MASK
NHISTORY DC    C'HISTORY'          HISTORY INSERT
NMEMBERS DC    C'MEMBERS'          MEMBERS INSERT
NSYSNAME DC    C'SYSNAMES'         SYSNAMES INSERT
NULLFILE DC    C'NULLFILE'         NULLFILE
DYNAMMSG DC    C'DATA SETS MUST BE UNALLOCATED BEFORE NEW ALLOCATIONS  *
               CAN BE DONE'        MESSAGE                     @YL026YB
ASKMSG   DC    C'* THIS DATA SET IS NOT IN-USE' MESSAGE        @YL026YB
TERMFILE DC    C'TERMFILE'         TERMINAL FILE
TITLE1   DC    C'--DSORG--CREATED---EXPIRES---SECURITY'  HEADING
TITLE2   DC    C'--DDNAME---DISP--' HEADING
*        CONSTANTS FOR DYNAMIC INFORMATION RETRIEVAL           @YL026YB
TXTREQ   DS    0CL6                RELATIVE REQUEST TXTUNIT    @YL026YB
         DC    X'000F'             KEY FOR REL. REQ            @YL026YB
         DC    X'0001'             NUMBER OF REL. REQ.         @YL026YB
         DC    X'0002'             LENGTH OF REQUEST           @YL026YB
TXTDSNM  DS    0CL6                DSNAME TEXT UNIT            @YL026YB
         DC    X'0005'             KEY FOR DSNAME              @YL026YB
         DC    X'0001'             NUMBER OF DSNAMES           @YL026YB
         DC    X'002C'             LENGTH OF DSNAME            @YL026YB
TXTLIMIT DS    0CL6                LIMIT OF TEXT UNIT          @YL026YB
         DC    X'000B'             KEY FOR LIMIT               @YL026YB
         DC    X'0001'             NUMBER OF LIMITS            @YL026YB
         DC    X'0002'             LENGTH OF LIMIT             @YL026YB
TXTATTR  DS    0CL6                ATTRIBUTE TXT UNIT          @YL026YB
         DC    X'000C'             KEY FOR ATTRIBUTE           @YL026YB
         DC    X'0001'             NUMBER                      @YL026YB
         DC    X'0001'             LENGTH                      @YL026YB
TXLENTRY DS    0CL6                LAST ENTRY TXT UNIT         @YL026YB
         DC    X'000D'             KEY                         @YL026YB
         DC    X'0001'             NUMBER                      @YL026YB
         DC    X'0001'             LENGTH                      @YL026YB
TXTYPE   DS    0CL6                DATA SET TYPE TXT UNIT      @YL026YB
         DC    X'000E'             KEY                         @YL026YB
         DC    X'0001'             NUMBER                      @YL026YB
         DC    X'0001'             LENGTH                      @YL026YB
TXTMEM   DS    0CL6                                            @YL026YB
         DC    X'0006'             KEY                         @YL026YB
         DC    X'0001'             NUMBER                      @YL026YB
         DC    X'0008'             LENGTH                      @YL026YB
TXTDD    DS    0CL6                DDNAME TXT UNIT             @YL026YB
         DC    X'0004'             KEY                         @YL026YB
         DC    X'0001'             NUMBER                      @YL026YB
         DC    X'0008'             LENGTH                      @YL026YB
TXTSTAT  DS    0CL6                STATUS TXT UNIT             @YL026YB
         DC    X'0007'             KEY                         @YL026YB
         DC    X'0001'             NUMBER                      @YL026YB
         DC    X'0001'             LENGTH                      @YL026YB
TXNDISP  DS    0CL6                NORMAL DISP TXT UNIT        @YL026YB
         DC    X'0008'             KEY                         @YL026YB
         DC    X'0001'             NUMBER                      @YL026YB
         DC    X'0001'             LENGTH                      @YL026YB
TXCDISP  DS    0CL6                CONDITIONAL DISP TXT UNIT   @YL026YB
         DC    X'0009'             KEY                         @YL026YB
         DC    X'0001'             NUMBER                      @YL026YB
         DC    X'0001'             LENGTH                      @YL026YB
         EJECT
IKJEHPRM IKJPARM
PSTAT    IKJKEYWD
         IKJNAME  'STATUS'
PHIST    IKJKEYWD
         IKJNAME  'HISTORY'
PMEM     IKJKEYWD
         IKJNAME  'MEMBERS'
PSYSN    IKJKEYWD
         IKJNAME  'SYSNAMES'
         IKJENDP
         EJECT
IKJEHHST CSECT
***********************************************************************
*                                                                     *
*    THIS ROUTINE GETS CONTROL IF HISTORY WAS REQUESTED AND           *
*    FORMATS THE REQUIRED INFORMATION INTO THE OUTPUT BUFFER.         *
*    THE INFORMATION IS OBTAINED FROM THE DSCB WHICH IS ALREADY       *
*    AVAILABLE IN CORE AT THIS POINT. THE INFORMATION IS              *
*    REFERENCED THROUGH DSECT OBTWAD. THE FOLLOWING INFORMATION       *
*    IS COLLECTED-                                                    *
*                                                                     *
*                   1. CREATION DATE                                  *
*                   2. EXPIRATION DATE                                *
*                   3. SECURITY (PASSWORD) INFORMATION                *
*                   4. DSORG                                          *
*                                                                     *
***********************************************************************
HISTROUT SAVE  (14,12),,*          SAVE REGISTERS
         LR    R11,R15             ENTRY POINT ADDRESS
         LR    R10,R13             WORKAREA ADDRESS
         DROP  R13                 CHANGE BASE FOR INITCORE      A42338
         USING INITCORE,R10        ADDRESSABILITY FOR WORK AREA
         USING OBTWAD,R12          ADDRESSABILITY FOR OBTAIN WORK AREA
         USING HISTROUT,R11        ADDRESSABILITY FOR THIS ROUTINE
         GETMAIN R,LV=SAVELEN,SP=SSP GET NEW SAVE AREA
         ST    R13,D4(R1)          CHAIN SAVE AREAS BACKWARDS
         ST    R1,D8(R13)          -AND FORWARDS
         LR    R13,R1              NEW SAVEAREA
         OI    CNTRL,WRITEMSK      TURN ON WRITE SWITCH
         TM    DS1DSORG,PS         IS DSORG PS
         BO    SETPS               IF YES, BRANCH
         TM    DS1DSORG,PO         IS DSORG PO
         BO    SETPO               IF YES, BRANCH
         TM    DS1DSORG,IS         IS DSORG IS
         BO    SETIS               IF YES, BRANCH
         TM    DS1DSORG,DA         IS DSORG DA
         BO    SETDA               IF YES, BRANCH
         TM    DS1DSORG,NOTID      IS AN UNIDENTIFIED BIT SET
         BZ    SETND               IF NO, BRANCH
         LA    R15,UNKL            LENGTH OF DSORG FIELD
         LA    R14,UNK             DSORG WAS NOT IDENTIFIABLE
EXDSORGM LA    R5,OUTBUF+DSORGOFF  POINT AT DSORG FIELD
         BCTR  R15,R0              DECREMENT FOR EXECUTE
         EX    R15,DSORGMV         MOVE DSORG TO BUFFER
         LA    R5,D1(R5,R15)       POINT BEYOND DSORG IN BUFFER
         TM    DS1DSORG,UNMV       CHECK DSCB FOR UNMOVABLE ATTRIBUTE
         BZ    DSORGEXT            EXIT FROM DSORG PROCESSING
         MVI   D0(R5),CHARU        SET UNMOVABLE ATTRIBUTE
         B     DSORGEXT            GO TO DSORG OPTION PROCESSING
SETPS    LA    R15,SEQL            LENGTH OF DSORG FIELD
         LA    R14,SEQ             DSORG WAS SEQUENTIAL
         B     EXDSORGM            PROCESS THE DSORG FIELD
SETPO    LA    R15,PDSL            LENGTH OF DSORG FIELD
         LA    R14,PDS             DSORG WAS PARTITIONED
         B     EXDSORGM            PROCESS THE DSORG FIELD
SETIS    LA    R15,ISEQL           LENGTH OF DSORG FIELD
         LA    R14,ISEQ            DSORG WAS INDEXED SEQUENTIAL
         B     EXDSORGM            PROCESS THE DSORG FIELD
SETDA    LA    R15,DAL             LENGTH OF DSORG FIELD
         LA    R14,DIRECT          DSORG WAS DIRECT (BDAM)
         B     EXDSORGM            PROCESS THE DSORG FIELD
SETND    LA    R15,UNDEFL          LENGTH OF DSORG FIELD
         LA    R14,UNDEF           DSORG WAS NOT DEFINED
         B     EXDSORGM            PROCESS THE DSORG FIELD
DSORGEXT LA    R2,DS1CREDT         SET UP TO CONVERT CREATION DATE
         LA    R7,OUTBUF           ADDRESS OF OUTPUT BUFFER
         LA    R7,CRDTOFF(R7)      POINT AT BUFFER POSITION
         BAL   R14,HDT02           GO CONVERT DATE AND PUT IN BUFFER
         LA    R2,DS1EXPDT         SET UP TO CONVERT EXPIRATION DATE
         LA    R7,NXTBUF(R7)       POINT AT NEXT BUFFER POSITION
         BAL   R14,HDT02           GO CONVERT DATE AND PUT IN BUFFER
         LA    R7,NXTBUF(R7)       POINT AT NEXT BUFFER POSITION
*   CHECK FOR VARIOUS COMBINATIONS OF RACF AND PASSWORD PROTECTION
         TM    DS1DSIND,RACOPWD    RACF AND PASSWORD           @Z40RSSA
         BNO   NTBOTH                 NO                       @Z40RSSA
         MVC   D0(9,R7),WPWDRAC                                @Z40RSSA
TSTREAD  TM    DS1DSIND,WPIND      WRITE PASSWORD PROTECT?     @Z40RSSA
         BO    HISTEXIT               YES                      @Z40RSSA
         MVI   D0(R7),C'R'            NO, CHANGE TO RPWD/RACF  @Z40RSSA
HISTEXIT LR   R1,R13               SAVE AREA ADDRESS FOR FREEMAIN
         L    R13,D4(R1)           CALLERS SAVEAREA
         FREEMAIN R,LV=SAVELEN,A=(1),SP=SSP FREE SAVE AREA
         RETURN (14,12)            RETURN
        SPACE  1
*       NOT BOTH RACF AND PASSWORD PROTECTED
NTBOTH  MVC   D0(4,R7),NONE        ASSUME NONE                 @Z40RSSA
        BZ    HISTEXIT                IF NONE                  @Z40RSSA
        MVC   D0(4,R7),RACF        ASSUME RACF                 @Z40RSSA
        TM    DS1DSIND,RACIND                                  @Z40RSSA
        BO    HISTEXIT                RACF ONLY                @Z40RSSA
        MVC   D0(4,R7),WPWD       ASSUME WPWD ONLY             @Z40RSSA
        B     TSTREAD             TO TEST FOR READ             @Z40RSSA
***********************************************************************
*                                                                     *
*    THIS ROUTINE CONVERTS BINARY DATES OF THE FORM YYDDDD TO         *
*    CHARACTER FORMAT IN THE FORM MM/DD/YY.  LEAP YEARS ARE HANDLED.  *
*    INPUT REQUIREMENTS ARE-                                          *
*         1.   R2 POINTS TO FIELD TO BE CONVERTED                     *
*         2.   R7 POINTS TO RECEIVING FIELD                           *
*         3.   R14 HAS RETURN ADDRESS                                 *
*                                                                     *
***********************************************************************
HDT02    CLC   D0(L3,R2),HDTZ      CHECK FOR UNSPECIFIED DATE
         BNE   HDT04               BRANCH IF DATE PRESENT
HDT03    MVC   D0(L'HDTDF,R7),HDTDF MOVE IN DEFAULT OF 00/00/00
         BR    R14                 RETURN
HDT04    STM   R14,R6,HDTSV        SAVE REGISTERS
*
*  TEST FOR LEAP YEAR BY ANDING THE YEAR FIELD AGAINST A BYTE WITH
*  THE TWO LOW ORDER BITS ON. LEAP YEARS WILL HAVE ZEROS FOR THE TWO
*  LOW ORDER BYTES.
*
         SR    R3,R3               CLEAR REGISTER
         IC    R3,D0(R2)           GET YEAR BYTE FROM DATE FIELD
         LA    R4,HDTBIN3          SET UP TO TEST LOW ORDER BITS
         NR    R3,R4               ZERO, IF YEAR IS DIVISIBLE BY 4
         LA    R4,HDTNY            SET UP FOR NON-LEAP YEAR
         BNZ   HDT06               NOT ZERO, NOT LEAP YEAR
         LA    R4,HDTLY            REMAINDER IS ZERO, USE LEAP YEAR
HDT06    MVC   HDTWK(L2),D1(R2)    MOVE DAY FIELD TO HALFWORD FOR ALIGN
         LH    R3,HDTWK            DAY OF YEAR (0-365)
         LA    R6,MNTHS            BRANCH CONTROL IS NUMBER OF MONTHS
*
*  SEARCH NOW BEGINS TO FIND THE MONTH IN WHICH THE DAY-OF-THE-YEAR
*  OCCURS. IF DAY-OF-THE-YEAR IS GREATER THAN 365/366, MONTH 12 IS USED
*
HDT08    CH    R3,D0(R4)           COMPARE DAY TO TABLE ENTRY FOR MONTH
         BH    HDT10               DAY GREATER THAN TABLE IS A FIND
         LA    R4,D2(R4)           POINT TO NEXT ELEMENT
         BCT   R6,HDT08            DECREMENT MONTH AND RETRY
         B     HDT03               USE DEFAULT 00/00/00
HDT10    SH    R3,D0(R4)           SUBTRACT TABLE ELEMENT FROM DAY
         EX    R3,HDTCLI           COMPARE DAY TO 31
         BNL   HDT12               OKAY, GO TO MONTHS
         LA    R3,DYS31            DEFAULT TO 31 DAYS
HDT12    CVD   R6,HDTWK            CONVERT MONTH TO DECIMAL
         UNPK  D0(L2,R7),HD6(D2)   -THEN TO CHARACTER
         CVD   R3,HDTWK            CONVERT DAY TO DECIMAL
         UNPK  D3(L2,R7),HD6(D2)   -THEN TO CHARACTER
         IC    R6,D0(R2)           GET YEAR
         CVD   R6,HDTWK            CONVERT IT TO DECIMAL
         UNPK  D6(L2,R7),HD6(D2)   -THEN TO CHARACTER
         MVZ   D1(L7,R7),D0(R7)    PROPAGATE NUMERIC ZONE
         MVI   D2(R7),SLASH        MOVE IN SEPARATORS BETWEEN
         MVI   D5(R7),SLASH        -MONTH, DAY, AND YEAR
         LM    R14,R6,HDTSV        RESTORE REGISTERS
         BR    R14                 RETURN
*
*  THE FOLLOWING EQUATES AND CONSTANTS ARE USED BY THE HISTORY ROUTINE.
*
DSORGOFF EQU   2                   OFFSET TO DSORG FIELD IN OUTPUT
PS       EQU   X'40'               SEQUENTIAL
PO       EQU   X'02'               PARTITIONED
IS       EQU   X'80'               INDEXED SEQUENTIAL
DA       EQU   X'20'               DIRECT
NOTID    EQU   X'1C'               THESE BITS RESERVED IN DSORG
UNMV     EQU   X'01'               UNMOVEABLE BIT
DYS31    EQU   31                  USED FOR THIRTY ONE COMPARE
PWRD1    EQU   X'14'               MASK FOR PASSWORD PROTECTION (DSCB)
PWRD2    EQU   X'10'               MASK FOR WRITE PROTECTION
RACIND   EQU   X'40'               MASK FOR RACF PROTECTION
WPIND    EQU   X'04'               WRITE PASSWORD PROTECT
RACOPWD  EQU   X'50'               RACF OR PASSWORD
HDTBIN3  EQU   X'03'               BYTE WITH TWO LOW ORDER BITS ON
DSORGMV  MVC   D0(L0,R5),D0(R14)   USED WITH EXECUTE TO MOVE DSORG
HDTCLI   CLI   HDTC31,D0           CHECKS IF DATE GREATER THAN 31
SEQ      DC    C'PS'               PHYSICAL SEQUENTIAL
SEQL     EQU   L'SEQ               LENGTH OF CONSTANT SEQ
PDS      DC    C'PO'               PARTITIONED DATA SET
PDSL     EQU   L'PDS               LENGTH OF CONSTANT PDS
ISEQ     DC    C'IS'               INDEXED SEQUENTIAL
ISEQL    EQU   L'ISEQ              LENGTH OF CONSTANT ISEQ
DIRECT   DC    C'DA'               DIRECT ACCESS
DAL      EQU   L'DIRECT            LENGTH OF CONSTANT DIRECT
UNDEF    DC    C'**'               DSORG NOT SPECIFIED
UNDEFL   EQU   L'UNDEF             LENGTH OF CONSTANT UNDEF
UNK      DC    C'??'               DSORG NOT RECOGNIZED
UNKL     EQU   L'UNK               LENGTH OF CONSTANT UNK
NONE     DC    C'NONE'             NO RACF OR PASSWORD PROTECTION
RACF     DC    C'RACF'             RACF PROTECTION             @Z40RSSA
WPWD     DC    C'WPWD'             WRITE PASSWORD PROTECTION   @Z40RSSA
WPWDRAC  DC    C'WPWD/RACF'        WRITE PASSWORD AND RACF     @Z40RSSA
HDTZ     DC    X'000000'           DATE IS NOT SPECIFIED
HDTDF    DC    C'00/00/00'         DISPLAYED DATE OF ZERO
HDTC31   DC    FL1'31'             USED FOR 31 DAY COMPARISON
*  THIS IS THE MONTH TABLE LOOKUP INDEX FOR NON LEAP-YEARS
HDTNY    DC    H'334'              DECEMBER
         DC    H'304'              NOVEMBER
         DC    H'273'              OCTOBER
         DC    H'243'              SEPTEMBER
         DC    H'212'              AUGUST
         DC    H'181'              JULY
         DC    H'151'              JUNE
         DC    H'120'              MAY
         DC    H'90'               APRIL
         DC    H'59'               MARCH
         DC    H'31'               FEBRUARY
         DC    H'0'                JANUARY
*  THIS IS THE MONTH TABLE LOOKUP INDEX FOR LEAP YEARS
HDTLY    DC    H'335'              DECEMBER
         DC    H'305'              NOVEMBER
         DC    H'274'              OCTOBER
         DC    H'244'              SEPTEMBER
         DC    H'213'              AUGUST
         DC    H'182'              JULY
         DC    H'152'              JUNE
         DC    H'121'              MAY
         DC    H'91'               APRIL
         DC    H'60'               MARCH
         DC    H'31'               FEBRUARY
         DC    H'0'                JANUARY
         EJECT
IKJEHVHS CSECT                                                 @YL026YB
***********************************************************************
*                                                                     *
*    THIS ROUTINE GETS CONTROL IF HISTORY WAS REQUESTED AND           *
*    FORMATS THE REQUIRED INFORMATION INTO THE OUTPUT BUFFER.         *
*    THE INFORMATION IS OBTAINED FROM THE DSCB WHICH IS ALREADY       *
*    AVAILABLE IN CORE AT THIS POINT. THE INFORMATION IS              *
*    REFERENCED THROUGH DSECT OBTWAD. THE FOLLOWING INFORMATION       *
*    IS COLLECTED-                                                    *
*                                                                     *
*                   1. CREATION DATE                                  *
*                   2. EXPIRATION DATE                                *
*                   3. ENTRY CODE                                     *
*                                                                     *
***********************************************************************
HISTROU1 SAVE  (14,12),,*          SAVE REGISTERS              @YL026YB
         LR    R11,R15             ENTRY POINT ADDRESS         @YL026YB
         LR    R10,R13             WORKAREA ADDRESS            @YL026YB
         USING INITCORE,R10        ADDRESSABILITY FOR WORK AREA
         USING OBTWAD,R12          ADDRESSABILITY FOR OBTAIN WORK AREA
         USING HISTROU1,R11        ADDRESSABILITY FOR THIS ROUTINE
         GETMAIN R,LV=SAVELEN,SP=SSP GET NEW SAVE AREA         @YL026YB
         ST    R13,D4(R1)          CHAIN SAVE AREAS BACKWARDS  @YL026YB
         ST    R1,D8(R13)          -AND FORWARDS               @YL026YB
         LR    R13,R1              NEW SAVEAREA                @YL026YB
         LA    R8,LOCPTN           POINT TO CPL CONSTANTS      @YL026YB
         ST    R8,CTGPLPTR         STORE IN CTGPL POINTER      @YL026YB
         USING CTGPL,R8            ADDRESSABILITY TO CPL       @YL026YB
         XC    LOCPTN(D112),LOCPTN ZERO CPL AND FPL            @YL026YB
         MVI   CTGOPTN1,CTGNAME    44 BYTE NAME ENTRY          @YL026YB
         MVI   CTGOPTN3,LOCVSAM    VSAM LOCATE REQUEST         @YL026YB
         LA    R5,DSADSNAM         POINT TO DSNAME             @YL026YB
         ST    R5,CTGENT           STORE IN CPL                @YL026YB
         LA    R5,WKAREA           POINT TO WORKAREA           @YL026YB
         MVC   WKAREA(D2),WKLGTH   LENGTH OF WORK AREA         @YL026YB
         ST    R5,CTGWKA           STORE IN CPL                @YL026YB
         MVI   CTGNOFLD,FLDNO      NUMBER OF FPLS REQUIRED     @YL026YB
         LA    R5,FLDREQ1          POINT TO FIRST FPL          @YL026YB
         ST    R5,CTGFIELD         STORE IN CPL                @YL026YB
         LA    R5,FLDREQ2          POINT TO 2ND FPL            @YL026YB
         ST    R5,CTGFIELD+D4      STORE IN CPL                @YL026YB
         LA    R5,FLDREQ3          POINT TO 3RD FPL            @YL026YB
         ST    R5,CTGFIELD+D8      STORE IN CPL                @YL026YB
         USING CTGFL,R4            ADDRESSABILITY TO 1ST FPL   @YL026YB
         L     R4,CTGFIELD         POINT TO 1ST FPL            @YL026YB
         MVI   CTGFLDNO,HEX01      NUMBER OF DATA ADDR.        @YL026YB
         LA    R5,ENNTYPE          POINTER TO 1ST FIELD NAME   @YL026YB
         ST    R5,CTGFLDNM         STORE IN FIELD PARM. POINTER
         L     R4,CTGFIELD+D4      POINT TO 2ND FPL            @YL026YB
         MVI   CTGFLDNO,HEX01      NUMBER OF DATA ADDR.        @YL026YB
         LA    R5,DSCRDT           POINTER TO 2ND FIELD NAME   @YL026YB
         ST    R5,CTGFLDNM         STORE IN FIELD PARM. PTR.   @YL026YB
         L     R4,CTGFIELD+D8      POINT TO 3RD FPL            @YL026YB
         MVI   CTGFLDNO,HEX01      NUMBER OF DATA ADDR.        @YL026YB
         LA    R5,DSETEX           POINTER TO 3RD FIELD NAME   @YL026YB
         ST    R5,CTGFLDNM         STORE IN FIELD PARM.PTR     @YL026YB
         L     R1,CTGPLPTR         PUT CTGPL ADDR. IN REG 1    @YL026YB
         CATLG (1)                 VSAM LOCATE                 @YL026YB
         LTR   R15,R15             TEST RETURN CODE            @YL026YB
         BZ    NRMPROSS            GO TO NORMAL PROCESSING     @YL026YB
         ST    R15,OBTAINRC        SAVE LOCATE RETURN CODE     @YL026YB
         OI    OBTAINRC,HEXFF      INDICATE RETURN CODE IS FROM LOCATE
         OI    CNTRL,OBTSW         TURN ON OBTAIN SWITCH       @YL026YB
         B     HOSTEXIT            RETURN                      @YL026YB
NRMPROSS OI    CNTRL,WRITEMSK      TURN ON WRITE SWITCH        @YL026YB
         USING CTGFL,R4            ADDRRESSABILITY TO FPLS     @YL026YB
ENTCODE  LA    R5,OUTBUF           POINT AT ENTRY FIELD         ZA02196
         MVC   DSORGOF1(L4,R5),VSAMCON  MOVE IN CONSTANT        ZA02196
DSORGET1 L     R4,CTGFIELD+D4      SET TO CONVERT DATE         @VS07788
         L     R2,CTGFLPT          POINT TO CREATION DATE      @YL026YB
         LA    R7,OUTBUF           ADDRESS OF OUTPUT BUFFER    @YL026YB
         LA    R7,CRDTOFF(R7)      POINT AT BUFFER POSITION    @YL026YB
         BAL   R14,HDTO2           GO CONVERT DATE AND PUT IN BUFFER
         L     R4,CTGFIELD+D8      POINT TO 3RD FPL            @VS07788
         L     R2,CTGFLPT          SET UP TO CONVERT EXPIRATION DATE
         LA    R7,NXTBUF(R7)       POINT AT NEXT BUFFER POSITION
         BAL   R14,HDTO2           GO CONVERT DATE AND PUT IN BUFFER
HOSTEXIT LR    R1,R13              SAVE AREA ADDRESS FOR FREEMAIN
         L     R13,D4(R1)          CALLERS SAVEAREA            @YL026YB
         FREEMAIN R,LV=SAVELEN,A=(1),SP=SSP FREE SAVE AREA     @YL026YB
         RETURN (14,12)            RETURN                      @YL026YB
***********************************************************************
*                                                                     *
*    THIS ROUTINE CONVERTS BINARY DATES OF THE FORM YYDDDD TO         *
*    CHARACTER FORMAT IN THE FORM MM/DD/YY.  LEAP YEARS ARE HANDLED.  *
*    INPUT REQUIREMENTS ARE-                                          *
*         1.   R2 POINTS TO FIELD TO BE CONVERTED                     *
*         2.   R7 POINTS TO RECEIVING FIELD                           *
*         3.   R14 HAS RETURN ADDRESS                                 *
*                                                                     *
***********************************************************************
HDTO2    L     R1,D16(R4)                                      @VS07242
         LA    R1,D0(R1)
         LTR   R1,R1
         BZ    HDTO3
         CLC   D0(L3,R2),HITZ      CHECK FOR UNSPECIFIED DATE  @YL026YB
         BNE   HDTO4               BRANCH IF DATE PRESENT      @YL026YB
HDTO3    MVC   D0(L'HDTDF,R7),HITDF MOVE IN DEFAULT OF 00/00/00
         BR    R14                 RETURN                      @YL026YB
HDTO4    STM   R14,R6,HDTSV        SAVE REGISTERS              @YL026YB
*                                                              @YL026YB
*  TEST FOR LEAP YEAR BY ANDING THE YEAR FIELD AGAINST A BYTE WITH
*  THE TWO LOW ORDER BITS ON. LEAP YEARS WILL HAVE ZEROS FOR THE TWO
*  LOW ORDER BYTES.                                            @YL026YB
*                                                              @YL026YB
         SR    R3,R3               CLEAR REGISTER              @YL026YB
         IC    R3,D0(R2)           GET YEAR BYTE FROM DATE FIELD
         LA    R4,HITBIN3          SET UP TO TEST LOW ORDER BITS
         NR    R3,R4               ZERO, IF YEAR IS DIVISIBLE BY 4
         LA    R4,HITNY            SET UP FOR NON-LEAP YEAR    @YL026YB
         BNZ   HDTO6               NOT ZERO, NOT LEAP YEAR     @YL026YB
         LA    R4,HITLY            REMAINDER IS ZERO, USE LEAP YEAR
HDTO6    MVC   HDTWK(L2),D1(R2)    MOVE DAY FIELD TO HALFWORD FOR ALIGN
         LH    R3,HDTWK            DAY OF YEAR (0-365)         @YL026YB
         LA    R6,MNTHS            BRANCH CONTROL IS NUMBER OF MONTHS
*                                                              @YL026YB
*  SEARCH NOW BEGINS TO FIND THE MONTH IN WHICH THE DAY-OF-THE-YEAR
*  OCCURS. IF DAY-OF-THE-YEAR IS GREATER THAN 365/366, MONTH 12 IS USED
*                                                              @YL026YB
HDTO8    CH    R3,D0(R4)           COMPARE DAY TO TABLE ENTRY FOR MONTH
         BH    HIT10               DAY GREATER THAN TABLE IS A FIND
         LA    R4,D2(R4)           POINT TO NEXT ELEMENT       @YL026YB
         BCT   R6,HDTO8            DECREMENT MONTH AND RETRY   @YL026YB
         B     HDTO3               USE DEFAULT 00/00/00        @YL026YB
HIT10    SH    R3,D0(R4)           SUBTRACT TABLE ELEMENT FROM DAY
         EX    R3,HITCLI           COMPARE DAY TO 31           @YL026YB
         BNL   HIT12               OKAY, GO TO MONTHS          @YL026YB
         LA    R3,DYS311           DEFAULT TO 31 DAYS          @YL026YB
HIT12    CVD   R6,HDTWK            CONVERT MONTH TO DECIMAL    @YL026YB
         UNPK  D0(L2,R7),HD6(D2)   -THEN TO CHARACTER          @YL026YB
         CVD   R3,HDTWK            CONVERT DAY TO DECIMAL      @YL026YB
         UNPK  D3(L2,R7),HD6(D2)   -THEN TO CHARACTER          @YL026YB
         IC    R6,D0(R2)           GET YEAR                    @YL026YB
         CVD   R6,HDTWK            CONVERT IT TO DECIMAL       @YL026YB
         UNPK  D6(L2,R7),HD6(D2)   -THEN TO CHARACTER          @YL026YB
         MVZ   D1(L7,R7),D0(R7)    PROPAGATE NUMERIC ZONE      @YL026YB
         MVI   D2(R7),SLASH        MOVE IN SEPARATORS BETWEEN  @YL026YB
         MVI   D5(R7),SLASH        -MONTH, DAY, AND YEAR       @YL026YB
         LM    R14,R6,HDTSV        RESTORE REGISTERS           @YL026YB
         BR    R14                 RETURN                      @YL026YB
*                                                              @YL026YB
*  THE FOLLOWING EQUATES AND CONSTANTS ARE USED BY THE HISTORY ROUTINE.
*                                                              @YL026YB
DSORGOF1 EQU   2                   OFFSET TO DSORG FIELD IN OUTPUT
VSAMCON  DC    C'VSAM'             DSORG CONSTANT FOR VSAM      ZA02196
DYS311   EQU   31                  USED FOR THIRTY ONE COMPARE @YL026YB
HITBIN3  EQU   X'03'               BYTE WITH TWO LOW ORDER BITS ON
HITCLI   CLI   HITC31,D0           CHECKS IF DATE GREATER THAN 31
HITZ     DC    X'000000'           DATE IS NOT SPECIFIED       @YL026YB
HITDF    DC    C'00/00/00'         DISPLAYED DATE OF ZERO      @YL026YB
HITC31   DC    FL1'31'             USED FOR 31 DAY COMPARISON  @YL026YB
ENNTYPE  DC    C'ENTYPE  '         ENTRY TYPE                  @YL026YB
DSCRDT   DC    C'DSETCRDT'         CREATION DATA               @YL026YB
DSETEX   DC    C'DSETEXDT'         EXPIRATION DATE             @YL026YB
         DS    0H                  HALF WORD BNDRY             @YL026YB
WKLGTH   DC    H'100'              LENGTH OF CPPL WORKAREA     @YL026YB
*  THIS IS THE MONTH TABLE LOOKUP INDEX FOR NON LEAP-YEARS     @YL026YB
HITNY    DC    H'334'              DECEMBER                    @YL026YB
         DC    H'304'              NOVEMBER                    @YL026YB
         DC    H'273'              OCTOBER                     @YL026YB
         DC    H'243'              SEPTEMBER                   @YL026YB
         DC    H'212'              AUGUST                      @YL026YB
         DC    H'181'              JULY                        @YL026YB
         DC    H'151'              JUNE                        @YL026YB
         DC    H'120'              MAY                         @YL026YB
         DC    H'90'               APRIL                       @YL026YB
         DC    H'59'               MARCH                       @YL026YB
         DC    H'31'               FEBRUARY                    @YL026YB
         DC    H'0'                JANUARY                     @YL026YB
*  THIS IS THE MONTH TABLE LOOKUP INDEX FOR LEAP YEARS         @YL026YB
HITLY    DC    H'335'              DECEMBER                    @YL026YB
         DC    H'305'              NOVEMBER                    @YL026YB
         DC    H'274'              OCTOBER                     @YL026YB
         DC    H'244'              SEPTEMBER                   @YL026YB
         DC    H'213'              AUGUST                      @YL026YB
         DC    H'182'              JULY                        @YL026YB
         DC    H'152'              JUNE                        @YL026YB
         DC    H'121'              MAY                         @YL026YB
         DC    H'91'               APRIL                       @YL026YB
         DC    H'60'               MARCH                       @YL026YB
         DC    H'31'               FEBRUARY                    @YL026YB
         DC    H'0'                JANUARY                     @YL026YB
         EJECT                                                 @YL026YB
IKJEHMMR CSECT
***********************************************************************
*                                                                     *
*    THIS ROUTINE GETS CONTROL IF THE MEMBERS KEYWORD IS SPECIFIED    *
*    WITH THE COMMAND AND DOES THE FOLLOWING-                         *
*         1. CHECKS WHETHER DATA SET IS PARTITIONED (DSORG IN DSCB)   *
*         2. CHECKS WHETHER DATA SET HAS THIS USERS USERID AS FIRST   *
*            QUALIFIER IN DSNAME                                      *
*         3. CHECKS FOR BLANK DDNAME (EXIT IF YES--CONCATENATED)      *
*         4. CHECKS DYNAMIC CONCATENATION BIT IN DSE--IF ON, THE      *
*            DSADDNAM IS COMPARED TO THE DCBDDNAM. IF THEY ARE THE    *
*            SAME, THEN THIS IS AT LEAST THE SECOND MEMBER OF A       *
*            CONCATENATION CLUSTER AND AN EXIT IS TAKEN.              *
*                                                                     *
*    IF ALL CONDITIONS ARE MET, A RDJFCB IS ISSUED AND IKJEHMEM IS    *
*    CALLED TO LIST THE DIRECTORY. IF HISTORY WAS SPECIFIED AS A      *
*    KEYWORD, THE JFCB HAS ALREADY BEEN READ.                         *
*                                                                     *
***********************************************************************
MEMROUT  SAVE  (14,12),,*          SAVE REGISTERS
         LR    R11,R15             ENTRY POINT ADDRESS
         LR    R10,R13             WORKAREA ADDRESS
         USING INITCORE,R10        ADDRESSABILITY FOR WORKAREA
         USING OBTWAD,R12          ADDRESSABILITY FOR OBTAIN WORK AREA
         USING MEMROUT,R11         ADDRESSABILITY FOR ROUTINE
         GETMAIN R,LV=SAVELEN,SP=SSP GET NEW SAVE AREA
         ST    R13,BACKWARD(R1)    CHAIN SAVE AREAS BACKWARD
         ST    R1,FORWARD(R13)     -AND FORWARD
         LR    R13,R1              NEW SAVE AREA
         TM    DS1DSORG,PO         IS DSORG PO
         BNO   MEMEXIT             NO, EXIT FROM ROUTINE
*  COMPARE USERID AGAINST HIGHEST LEVEL QUALIFIER
         L     R2,UPTPTR           POINT TO UPT                @YL026YB
         USING UPT,R2              ADDRESSABILITY UPT          @YL026YB
         XR    R1,R1               CLEAR REGISTER
         IC    R1,UPTPREFL         LENGTH OF USERID            @YL026YB
         LTR   R1,R1               SEE IF USERID IS ZERO       @YL026YB
         BZ    NOPREFIX            YES,NO USERID OR PREFIX     @YL026YB
         LA    R3,DSADSNAM         ADDRESS OF DSNAME IN DSAB   @YL026YB
         LA    R3,D0(R3,R1)        ADD USERID LENGTH TO DSNAME
         CLI   D0(R3),PERIOD       CHECK FOR A PERIOD
         BNE   MEMEXIT             NOT EQUAL, GO EXIT THIS ROUTINE
         BCTR  R1,R0               DECREMENT LENGTH FOR EXECUTE
         EX    R1,USRIDCOM         COMPARE USERID TO FIRST QUALIFIER
         BNE   MEMEXIT             NOT EQUAL, GO EXIT THIS ROUTINE
NOPREFIX CLI   DSADDNAM,BLANK      IS DDNAME BLANK             @YL026YB
         BE    MEMEXIT             YES, GO EXIT
         LA    R2,OBTDCB           ADDRESS OF DCB                A42338
         USING IHADCB,R2           ADDRESSABILITY DCB            A42338
         TM    DSACNTRL,DYNCON     CHECK DYNAMIC CONCATENATION BIT
         BNO   MEMRT01             OFF, GO PROCESS
         CLC   DCBDDNAM(DDNAMLEN),DSADDNAM COMPARE DDNAMES IN DSE, DCB
         BE    MEMEXIT             EQUAL, GO EXIT--CANNOT LIST MEMBERS
MEMRT01  TM    CNTRL,HISTMSK       WAS HISTORY SPECIFIED
         BO    MEMRT02             YES, SKIP RDJFCB
         MVC   DCBDDNAM(DDNAMLEN),DSADDNAM MOVE DDNAME TO DCB  @YL026YB
         LA    R1,RDJL             ADDRESS OF RDJFCB LIST FORM
         RDJFCB ((R2)),MF=(E,(R1)) ISSUE READ JFCB
         DROP  R2                  DCB NO LONGER NEEDED
MEMRT02  L     R15,MEMMOD          ADDRESS OF IKJEHMEM (MEMBERS MODULE)
         LA    R1,CALLIST          PARAMETER LIST FOR CALL MACRO
         L     R3,VCONWRTE         ADDRESS OF WRITE ROUTINE
*  GO TO MEMBERS ROUTINE (IKJEHMEM)
         CALL  (15),((R12),GETML,OUTBUF,(R3),FREEML),VL,MF=(E,(1))
         B     MEMCODE(R15)        ANALYZE IKJEHMEM RETURN CODE
MEMCODE  B     MEMEXIT             SUCCESS
         B     MEMCDE04            INSUFFICIENT CORE
         B     MEMCDE08            I/O ERROR
         B     MEMCDE12            DIRECTORY ERROR
MEMCDE04 LA    R1,SECMSG06         SECOND LEVEL MESSAGE 6
         B     MEMERROR            GO PROCESS MESSAGE
MEMCDE08 LA    R1,SECMSG08         SECOND LEVEL MESSAGE 8
         LA    R2,SYNMSG           ADDRESS OF INSERT
         ST    R2,ERRINST2         -TO PARM LIST
         B     MEMSYN              GO PROCESS MESSAGE
MEMCDE12 LA    R1,SECMSG07         SECOND LEVEL MESSAGE 7
MEMERROR XC    ERRINST2,ERRINST2   NO SECOND LEVEL INSERTION
MEMSYN   XC    ERRINST1,ERRINST1   NO FIRST LEVEL INSERTION
         STH   R1,ERRSECND         SECOND LEVEL MESSAGE CODE
         LA    R1,MSG04            MESSAGE 4
         STH   R1,ERRFIRST         FIRST LEVEL MESSAGE CODE
         LR    R1,R13              ADDRESS OF AREA TO FREE
         LR    R13,R10             CALLERS SAVEAREA
         L     R2,VCONERRT         ERROUT ADDRESS
         L     R3,RETREGOF(R13)    CALLERS RETURN ADDRESS
         ST    R2,RETREGOF(R13)    MAKE RETURN TO ERROR HANDLER
         ST    R3,BALREGOF(R13)    FROM ERROR HANDLER TO CALLER
         B     MEMEXIT1            GO FREE CORE AND RETURN       A42338
MEMEXIT  LR    R1,R13              SAVE AREA ADDRESS TO BE FREED
         LR    R13,R10             CALLERS SAVEAREA
MEMEXIT1 FREEMAIN R,LV=SAVELEN,A=(1),SP=SSP FREE SAVE AREA       A42338
         RETURN (14,12)            RETURN
*
*  CONSTANTS USED BY THE MEMBERS ROUTINE                         A42338
*
         USING UPT,R2              ADDRESSABILITY PSCB         @YL026YB
USRIDCOM CLC   UPTPREFX(L1),DSADSNAM COMPARE TO BE EXECUTED    @YL026YB
         DROP  R2                  PSCB NO LONGER NEEDED
VCONERRT DC    V(IKJEHERR)         ADDRESS OF ERROR ROUTINE
VCONWRTE DC    V(IKJEHWRT)         ADDRESS OF WRITE ROUTINE
         EJECT
IKJEHSTS CSECT
***********************************************************************
*                                                                     *
*    THIS ROUTINE GETS CONTROL IF THE STATUS KEYWORD IS SPECIFIED ON  *
*    THE COMMAND. IT EXTRACTS THE DDNAME AND NORMAL AND ABNORMAL      *
*    DISPOSITION FROM THE DSE BLOCK CURRENTLY BEING PROCESSD. THE     *
*    DDNAME MAY BE BLANKS IF THE DATA SET WAS CONCATENATED IN THE     *
*    LOGON PROCEDURE.  SOME DDNAMES MAY BE DUPLICATED IN THE LISTING. *
*    THESE DATA SETS WILL ALL BE MEMBERS OF THE SAME CONCATENATION    *
*    CLUSTER (DYNAMIC CONCATENATION).  THE POSSIBLE DISPOSITIONS      *
*    INCLUDE ALL THOSE CURRENTLY SUPPORTED IN OS.                     *
*                                                                     *
***********************************************************************
STATROUT SAVE  (14,12),,*          SAVE REGISTERS
         LR    R11,R15             ENTRY POINT ADDRESS
         LR    R10,R13             WORKAREA ADDRESS
         USING INITCORE,R10        ADDRESSABILITY WORK AREA
         USING OBTWAD,R12          ADDRESSABILITY OBTAIN WORK AREA
         USING STATROUT,R11        ADDRESSABILITY FOR THIS ROUTINE
         GETMAIN R,LV=SAVELEN,SP=SSP GET SAVE AREA
         ST    R13,BACKWARD(R1)    CHAIN SAVE AREAS BACKWARD
         ST    R1,FORWARD(R13)     -AND FORWARD
         LR    R13,R1              NEW SAVE AREA
         LA    R7,OUTBUF+STATOFF1  POINT AT OFFSET FOR STATUS ALONE
         TM    CNTRL,HISTMSK       WAS HISTORY SPECIFIED
         BNO   STATRT01            NO, USE AS IS
         LA    R7,OUTBUF+STATOFF2  YES, POINT TO NEW OFFSET
STATRT01 MVC   D0(DDNAMLEN,R7),DSADDNAM MOVE DDNAME TO BUFFER  @YL026YB
         LA    R7,DDNAMLEN+D1(R7)  UPDATE BUFFER POINTER        SA49892
* TEST STATUS BITS AND MOVE IN APPROPRIATE WORD
         TM    DSANDISP,KEEP       IS DISPOSITION KEEP         @YL026YB
         BO    STATKEEP            YES, BRANCH
         TM    DSANDISP,DELETE     IS DISPOSITION DELETE       @YL026YB
         BO    STATDELE            YES, BRANCH
         TM    DSANDISP,CATLG      IS DISPOSITION CATALOG      @YL026YB
         BO    STATCATL            YES, BRANCH
         TM    DSANDISP,UNCATLG    IS DISPOSITION UNCATALOG    @YL026YB
         BO    STATUNCT            YES, BRANCH
         TM    DSANDISP,PASS       IS DISPOSITION PASS         @YL026YB
         BO    STATPASS            YES,BRANCH                  @YL026YB
         B     STATRT03            IF UNSPECIFIED, SKIP TO NEXT
STATKEEP LA    R14,SKEEP           DISPOSITION OF 'KEEP'
         LA    R15,L'SKEEP         ITS LENGTH
         B     STATRT02            PUT IT IN BUFFER
STATDELE LA    R14,SDELE           DISPOSITION OF 'DELETE'
         LA    R15,L'SDELE         ITS LENGTH
         B     STATRT02            PUT IT IN BUFFER
STATCATL LA    R14,SCATL           DISPOSITION OF 'CATLG'
         LA    R15,L'SCATL         ITS LENGTH
         B     STATRT02            PUT IT IN BUFFER
STATUNCT LA    R14,SUNCT           DISPOSITION OF 'UNCATLG'
         LA    R15,L'SUNCT         ITS LENGTH
         B     STATRT02            PUT IT IN BUFFER            @YL026YB
STATPASS LA    R14,SPASS           DISP. OF 'PASS'             @YL026YB
         LA    R15,L'SPASS         ITS LENGTH                  @YL026YB
* MOVE THE CORRECT FIELD TO THE BUFFER
STATRT02 BCTR  R15,R0              DECREMENT COUNT FOR EXECUTE  SA49892
         EX    R15,DISPMOVE        MOVE DISPOSITION TO BUFFER
         LA    R7,D1(R15,R7)       POINT AT NEXT LOCATION
* TEST FOR ABNORMAL DISPOSITION
STATRT03 TM    DSACDISP,KEEP       IS DISPOSITION KEEP         @YL026YB
         BO    STKEEP              YES, BRANCH
         TM    DSACDISP,DELETE     IS DISPOSITION DELETE       @YL026YB
         BO    STDELE              YES, BRANCH
         TM    DSACDISP,CATLG      IS DISPOSITION CATALOG      @YL026YB
         BO    STCATL              YES, BRANCH
         TM    DSACDISP,UNCATLG    IS DISPOSITION UNCATALOG    @YL026YB
         BO    STUNCT              YES, BRANCH
         TM    DSACDISP,PASS       IS DISP. PASS               @YL026YB
         BO    STPASS              YES,BRANCH                  @YL026YB
         B     STATRT05            IF UNSPECIFIED, SKIP IT
STKEEP   LA    R14,SKEEP           DISPOSITION OF 'KEEP'
         LA    R15,L'SKEEP         ITS LENGTH
         B     STATRT04            PUT IT INTO THE BUFFER
STDELE   LA    R14,SDELE           DISPOSITION OF 'DELETE'
         LA    R15,L'SDELE         ITS LENGTH
         B     STATRT04            PUT IT INTO BUFFER
STCATL   LA    R14,SCATL           DISPOSITION OF 'CATLG'
         LA    R15,L'SCATL         ITS LENGTH
         B     STATRT04            PUT IT INTO BUFFER
STUNCT   LA    R14,SUNCT           DISPOSITION OF 'UNCATLG'
         LA    R15,L'SUNCT         ITS LENGTH
         B     STATRT04            PUT IT INTO BUFFER          @YL026YB
STPASS   LA    R14,SPASS           DISP OF 'PASS'              @YL026YB
         LA    R15,L'SPASS         ITS LENGTH                  @YL026YB
* MOVE THE CORRECT FIELD TO THE BUFFER
STATRT04 MVI   D0(R7),COMMA         PUT A COMMA SEPARATOR IN BUFFER
         LA    R7,D1(R7)            BUMP POINTER
         BCTR  R15,R0               DECREMENT LENGTH FOR EXECUTE
         EX    R15,DISPMOVE         MOVE DISPOSITION TO BUFFER
STATRT05 OI    CNTRL,WRITEMSK       TURN ON WRITE SWITCH
         LR    R1,R13               ADDRESS OF SAVE AREA TO BE FREED
         LR    R13,R10              USERS SAVEAREA
         FREEMAIN R,LV=SAVELEN,A=(1),SP=SSP FREE SAVE AREA
         RETURN (14,12)             RETURN
*
*     EQUATES AND CONSTANTS USED BY THE STATUS ROUTINE
*
DISPMOVE MVC   D0(D0,R7),D0(R14)    EXECUTED TO MOVE DISPOSITION
KEEP     EQU   X'08'                DSAB DISPOSITION KEEP      @YL026YB
DELETE   EQU   X'04'                DSAB  DISPOSITION DELETE   @YL026YB
CATLG    EQU   X'02'                DSAB  DISPOSITION CATALOG  @YL026YB
UNCATLG  EQU   X'01'                DSAB  DISPOSITION UNCATALOG
PASS     EQU   X'10'                DSAB DISP. PASS            @YL026YB
SKEEP    DC    C'KEEP'              KEEP
SDELE    DC    C'DELETE'            DELETE
SCATL    DC    C'CATLG'             CATALOG
SUNCT    DC    C'UNCATLG'           UNCATALOG
SPASS    DC    C'pass'              PASS                       @YL026YB
         EJECT
INITCORE DSECT
SAVEAREA DS    28F                  SAVEAREA AND LOCAL SAVEAREA
NULLCNT  DS    D                    KEEPS COUNT OF DYNAMS
DSAV     DS    F                    ADDR. OF DDNAME BUFFER     @YL026YB
OBTAINRC DS    F                    HOLDS OBTAIN RETURN CODE
CTLA     EQU   *                    BEGIN CONTROL WORD AND SW AREA
MEMMOD   DS    A                    ADDRESS OF MEMBERS MODULE
OBTWA    DS    A                    ADDRESS OF CORE FOR OBTAIN WORKAREA
RETCD    DS    F                    HOLDS RETURN CODE
PARDSECT DS    F                    ADDRESS OF PARSE DSECT
CNTRL    DS    XL1                  SWITCH FOR COMMAND SCAN RESULTS
CTLL     EQU   *-CTLA               LENGTH CONTROL WORD AND SWITCH AREA
DDCNT    DS    H                    COUNT OF DDNAMES IN BUFFER @YL026YB
ZERO1    DC    X'0000'              ZEROS FOR COMPARES         @YL026YB
LOCSW    DC    X'00'                SWITCH USED FOR LOCATE ISSUED
         EJECT
***********************************************************************
*                                                                     *
*    THE  FOLLOWING 3 WORDS ARE USED TO PASS PARAMETERS TO THE        *
*    ERROR HANDLING ROUTINE. THE FIRST TWO BYTES CONTAIN THE RELATIVE *
*    POSITION OF THE MESSAGE IN THE MESSAGE CSECT. THE NEXT TWO BYTES *
*    CONTAIN THE NUMBER THAT INDICATES WHICH SECOND LEVEL MESSAGE     *
*    IS TO BE SELECTED. THE SECOND WORD POINTS TO A FIELD CONTAINING  *
*    A ONE BYTE LENGTH FIELD FOLLOWED BY DATA TO BE INSERTED IN THE   *
*    FIRST MESSAGE. THE LAST WORD CONTAINS A SIMILAR POINTER FOR THE  *
*    SECOND MESSAGE.                                                  *
*                                                                     *
***********************************************************************
ERRPARM  DS    0F                  PARAMETER LIST FOR ERROR HANDLER
ERRFIRST DS    H                   RELATIVE FIRST LEVEL MESSAGE NUMBER
ERRSECND DS    H                   RELATIVE SECOND LEVEL MESSAGE NUMBER
ERRINST1 DS    F                   INSERT DATA FOR FIRST LEVEL MESSAGE
ERRINST2 DS    F                   INSERT DATA FOR SECOND LEVEL MESSAGE
         DS    0D                  DOUBLE WORD ALIGN
ERRINSRT DS    CL70                INSERT DATA BUFFER
***********************************************************************
*                                                                     *
*        THE FOLLOWING CONSTANTS, BUFFER AND PUTLINE MACRO MUST ALL   *
*        APPEAR TOGETHER IN THE SPECIFIED ORDER SO THAT THE WRITE     *
*        ROUTINE WILL REMAIN INDEPENDANT OF A BASE REGISTER.          *
*                                                                     *
***********************************************************************
PARMLSTS DS    0F                  ALIGN PARAMETER LIST
PUTLCON  DS    F                   LIST FOR PUTLINE MACRO
DPUTLCON DS    F                   PUTLINE LIST FORM
UPTPTR   DS    F                   UPT POINTER
ECTPTR   DS    F                   ECT POINTER
ECBPTR   DS    F                   CPS ECB POINTER
PUTLADDR DS    F                   ENTRY POINT OF PUTLINE
PARMLSTL EQU   *-PARMLSTS          LENGTH OF PARAMETER LIST
         DS    F                   LENGTH AND OFFSET FIELDS
OUTBUF   DS    CL120               OUTPUT BUFFER FOR PUTLINE
DPUTLINE PUTLINE MF=L              PUTLINE LIST FORM
*
* SERVICE ROUTINE PARAMETER LIST AREA
*
PUTLLIST DS    7F                  COMMON PARAMETER AREA
* END OF SERVICE ROUTINE PARAMETER LIST AREA
CPECB    DS    F                   CPS ECB
PSCBPTR  DS    F                   PSCB POINTER
GETML    GETMAIN  EC,MF=L          LIST FORM OF GETMAIN
FREEML   FREEMAIN  E,MF=L          LIST FORM OF FREEMAIN
LOCLIST  DS    4F                  LOCATE CAMLST
MSGPARM1 DS    3F                  FIRST LEVEL MESSAGE PARAMETERS
MSGPARM2 DS    3F                  SECOND LEVEL MESSAGE PARAMETERS
SECBUFF  DS    30F                 SECOND BUFFER FOR ERROR HANDLER
STACKPRM DS    2F                  SPACE FOR STACK PARAMETER BLOCK
SYSNM    DS    C'SYS00000.T000000.' MASK TO TEST FOR SYSNAMES
STACKSW  DS    CL1                 INDICATE FLUSH STACK AND CLEAR QUEUE
         DS    0D                  ALIGN LOCATE WORKAREA          M0883
LOCAREA  DS    CL265               WORK AREA FOR LOCATE MACRO
DYNAMSAV DS    CL265               BUFFER FOR DDNAMES          @YL026YB
DYNAMSW  DS    CL1                 INDICATOR FOR RE-USE        @YL026YB
WKAREA   DS    CL100               WORKAREA FOR CPL            @YL026YB
NOTUSED  DS    CL1                 INDICATOR FOR NOT IN-USE    @YL026YB
ASKSWTCH DS    CL1                 SWITCH TO WRITE AS NOT-INUSE
*                                                              @YL026YB
*                                                              @YL026YB
         DS    0F                  ALINE POINTER               @YL026YB
CTGPLPTR DS    F                   POINTER TO CPL AREA         @YL026YB
CTGFLPTR DS    F                   POINTER TO FPL AREA         @YL026YB
LOCPTN   DS    0F                  CPL CONSTANTS               @YL026YB
         DS    CL40                POINTER TO ENTRY NAME       @YL026YB
*                                                              @YL026YB
*                                                              @YL026YB
FLDREQ1  DS    CL24                FPL CONSTANTS               @YL026YB
FLDREQ2  DS    CL24                FPL CONSTANTS               @YL026YB
FLDREQ3  DS    CL24                FPL CONSTANTS               @YL026YB
*                                                              @YL026YB
*                                                              @YL026YB
*                                                              @YL026YB
*                                                              @YL026YB
         DS    0H                                              @YL026YB
REQNUM   DS    CL2                 RELATIVE REQUEST NUMBER     @YL026YB
DSADSLNG DS    CL2                 DSNAME LENGTH               @YL026YB
DSADSNAM DS    CL44                                            @YL026YB
DYNAMCNT DS    CL2                                             @YL026YB
DSACNTRL DS    CL1                                             @YL026YB
LSTENTRY DS    CL1                                             @YL026YB
DSTYPE   DS    CL1                                             @YL026YB
         DS    0H                                              @YL026YB
DMEMLNT  DS    CL2                                             @YL026YB
DSAMEM   DS    CL8                                             @YL026YB
DSADDNAM DS    CL8                                             @YL026YB
DSASTAT  DS    CL1                                             @YL026YB
DSANDISP DS    CL1                                             @YL026YB
DSACDISP DS    CL1                                             @YL026YB
*        WORK AREA FOR ALLOCATION                              @YL026YB
DAPARM   DS    F                   POINTER TO REQUEST BLK      @YL026YB
DARQBLK  DS    0CL20               DYNAMIC ALLOC REQUEST BLK   @YL026YB
DABLKLN  DS    CL1                 LENGTH OF BLK               @YL026YB
DAVERB   DS    CL1                 VERB CODE                   @YL026YB
DAFLGS1  DS    CL2                 FLAGS                       @YL026YB
DAERRCD  DS    CL2                 ERROR RETURN CODE           @YL026YB
DAINFO   DS    CL2                 INFORMATION RETURN CD       @YL026YB
DATXTPT  DS    CL4                 ADDRESS OF TEXT POINTERS    @YL026YB
         DS    CL4                 RESERVED                    @YL026YB
DAFLGS2  DS    CL4                 FLAGS                       @YL026YB
DARLNTH  EQU   *-DARQBLK                                       @YL026YB
*        TEXT POINTER                                          @YL026YB
DAPTR    DS    11F                                             @YL026YB
*        *     TEXT UNIT FOR DYNAMIC INFORMATION RETRIEVAL     @YL026YB
DAREQ    DS    0CL8                                            @YL026YB
         DS    CL2                 KEY                         @YL026YB
         DS    CL2                 NUMBER                      @YL026YB
         DS    CL2                 LENGTH                      @YL026YB
         DS    CL2                 RELATIVE REQUEST NO.        @YL026YB
DADSNM   DS    0CL50               DSNAME TEXT UNIT            @YL026YB
         DS    CL2                 KEY                         @YL026YB
         DS    CL2                 NUMBER                      @YL026YB
         DS    CL2                 LENGTH                      @YL026YB
         DS    CL44                DATA SET NAME               @YL026YB
DALIMIT  DS    0CL8                LIMIT TETX UNIT             @YL026YB
         DS    CL2                 KEY                         @YL026YB
         DS    CL2                 NUMBER                      @YL026YB
         DS    CL2                 LENGHT                      @YL026YB
         DS    CL2                 LIMIT                       @YL026YB
DATTR    DS    0CL7                ATTRIBUTE TEXT UNIT         @YL026YB
         DS    CL2                 KEY                         @YL026YB
         DS    CL2                 NUMBER                      @YL026YB
         DS    CL2                 LENGTH                      @YL026YB
         DS    CL1                 ATTRIBUTE                   @YL026YB
DALENTRY DS    0CL7                LAST ENTRY TEXT UNIT        @YL026YB
         DS    CL2                 KEY                         @YL026YB
         DS    CL2                 NUMBER                      @YL026YB
         DS    CL2                 LENGTH                      @YL026YB
         DS    CL1                 LAST ENTRY CODE             @YL026YB
DADSTYPE DS    0CL7                DATA SET TYPE TXT UNIT      @YL026YB
         DS    CL2                 KEY                         @YL026YB
         DS    CL2                 NUMBER                      @YL026YB
         DS    CL2                 LENGTH                      @YL026YB
         DS    CL1                 DATA SET TYPE               @YL026YB
         DS    0H                                              @YL026YB
DAMEM    DS    0CL14               MEMBER TEXT UNIT            @YL026YB
         DS    CL2                 KEY                         @YL026YB
         DS    CL2                 NUMBER                      @YL026YB
         DS    CL2                 LENGTH                      @YL026YB
         DS    CL8                 MEMBER NAME                 @YL026YB
DADDNM   DS    0CL14               DDNAME TEXT UNIT            @YL026YB
         DS    CL2                 KEY                         @YL026YB
         DS    CL2                 NUMBER                      @YL026YB
         DS    CL2                 LENGTH                      @YL026YB
         DS    CL8                 DDNAME                      @YL026YB
DASTAT   DS    0CL7                STATUS TEXT UNIT            @YL026YB
         DS    CL2                 KEY                         @YL026YB
         DS    CL2                 NUMBER                      @YL026YB
         DS    CL2                 LENGTH                      @YL026YB
         DS    CL1                 STATUS                      @YL026YB
DANDISP  DS    0CL7                NORMAL DISP. TEXT UNIT      @YL026YB
         DS    CL2                 KEY                         @YL026YB
         DS    CL2                 NUMBER                      @YL026YB
         DS    CL2                 LENGTH                      @YL026YB
         DS    CL1                 NORMAL DISPOSITION          @YL026YB
DACDISP  DS    0CL7                CONDITIONAL DISP. TXT UNIT  @YL026YB
         DS    CL2                 KEY                         @YL026YB
         DS    CL2                 NUMBER                      @YL026YB
         DS    CL2                 LENGTH                      @YL026YB
         DS    CL1                 CONDITIONAL DISPOSITION     @YL026YB
INITSIZE EQU   *-SAVEAREA          LENGTH OF DSECT
         EJECT
         IKJEHCOM
         DCBD  DSORG=PS
         EJECT
         CVT
         EJECT
         IKJTCB
         SPACE 3
         IEFZB4D0                                              @YL026YB
         EJECT
         IEZCTGPL                                              @YL026YB
         EJECT                                                 @YL026YB
         IEZCTGFL                                              @YL026YB
         EJECT                                                 @YL026YB
         IKJUPT                                                @YL026YB
         EJECT                                                 @YL026YB
         IKJPSCB
         EJECT
         IKJIOPL                                               @YL026YB
         EJECT                                                 @YL026YB
         IKJCPPL
         SPACE 2
         IKJPPL
         SPACE 2
         IKJDAPL
         EJECT
IKJEHALM CSECT
***********************************************************************
*                                                                     *
*    THE CSECT BEGINS WITH A TABLE OF 8 BYTE ENTRIES, ONE FOR         *
*    EACH FIRST LEVEL MESSAGE.  THE FIRST HALFWORD OF EACH ENTRY      *
*    CONTAINS THE LENGTH OF A MESSAGE.  THE SECOND HALFWORD CONTAINS  *
*    THE OFFSET TO THE MESSAGE IN THE CSECT.  THE THIRD HALFWORD      *
*    CONTAINS THE OFFSET TO THE SEGMENT CHAIN IF MORE THAN ONE        *
*    MESSAGE SEGMENT EXISTS FOR A PARTICULAR MESSAGE.  THE FOURTH     *
*    AND LAST HALFWORD POINTS TO A TABLE DESCRIBING SECOND LEVEL      *
*    MESSAGES.  THE SEGMENT CHAIN ADDRESS IS CURRENTLY ALWAYS ZERO.   *
*                                                                     *
*    THE TABLE DESCRIBING SECOND LEVEL MESSAGES IS MADE UP OF         *
*    6 BYTE ENTRIES. A 2 BYTE LENGTH, A 2 BYTE MESSAGE OFFSET,        *
*    AND A 2 BYTE SEGMENT CHAIN OFFSET.                               *
*                                                                     *
***********************************************************************
SEGCH0   EQU   0                   SEGMENT CHAIN OFFSET
*
*        FIRST LEVEL MESSAGE TABLE
*
STARTALM DS    0F                  ALIGN FIRST LEVEL MESSAGE TABLE
         DC    AL2(L'MSGE1)        LENGTH OF MESSAGE
         DC    AL2(MSGE1-STARTALM) OFFSET TO MESSAGE
         DC    AL2(SEGCH0)         OFFSET TO SEGMENT CHAIN
         DC    AL2(SECLEVEL-STARTALM) OFFSET TO SECOND LEVEL TABLE
         DC    AL2(L'MSGE2)        LENGTH OF MESSAGE
         DC    AL2(MSGE2-STARTALM) OFFSET TO MESSAGE
         DC    AL2(SEGCH0)         OFFSET TO SEGMENT CHAIN
         DC    AL2(SECLEVEL-STARTALM) OFFSET TO SECOND LEVEL TABLE
         DC    AL2(L'MSGE3)        LENGTH OF MESSAGE
         DC    AL2(MSGE3-STARTALM) OFFSET TO MESSAGE
         DC    AL2(SEGCH0)         OFFSET TO SEGMENT CHAIN
         DC    AL2(SECLEVEL-STARTALM) OFFSET TO SECOND LEVEL TABLE
         DC    AL2(L'MSGE4)        LENGTH OF MESSAGE
         DC    AL2(MSGE4-STARTALM) OFFSET TO MESSAGE
         DC    AL2(SEGCH0)         OFFSET TO SEGMENT CHAIN
         DC    AL2(SECLEVEL-STARTALM) OFFSET TO SECOND LEVEL TABLE
         DC    AL2(L'MSGE5)        LENGTH OF MESSAGE
         DC    AL2(MSGE5-STARTALM) OFFSET TO MESSAGE
         DC    AL2(SEGCH0)         OFFSET TO SEGMENT CHAIN
         DC    AL2(SECLEVEL-STARTALM) OFFSET TO SECOND LEVEL TABLE
         DC    AL2(L'MSGE6)        LENGTH OF MESSAGE
         DC    AL2(MSGE6-STARTALM) OFFSET TO MESSAGE
         DC    AL2(SEGCH0)         OFFSET TO SEGMENT CHAIN
         DC    AL2(SECLEVEL-STARTALM) OFFSET TO SECOND LEVEL TABLE
*
*        FIRST LEVEL MESSAGES
*
*
MSGE1    DC    C'IKJ58300I HISTORY NOT AVAILABLE+'
MSGE2    DC    C'IKJ58303I NOT ENOUGH MAIN STORAGE TO LIST '
MSGE3    DC    C'IKJ58302I NO DATA SETS ALLOCATED'
MSGE4    DC    C'IKJ58301I MEMBERS NOT AVAILABLE+'
MSGE5    DC    C'IKJ58304I COMMAND SYSTEM ERROR+'
MSGE6    DC    C'IKJ58305I NOT ENOUGH MAIN STORAGE TO EXECUTE COMMAND'
*
*        SECOND LEVEL MESSAGE TABLE
*
SECLEVEL DS    0F                  ALIGN SECOND LEVEL MESSAGE TABLE
         DC    AL2(L'MSGSEC01)     LENGTH OF MESSAGE
         DC    AL2(MSGSEC01-STARTALM) OFFSET TO MESSAGE
         DC    AL2(SEGCH0)         OFFSET TO SEGMENT CHAIN
         DC    AL2(L'MSGSEC02)     LENGTH OF MESSAGE
         DC    AL2(MSGSEC02-STARTALM) OFFSET TO MESSAGE
         DC    AL2(SEGCH0)         OFFSET TO SEGMENT CHAIN
         DC    AL2(L'MSGSEC03)     LENGTH OF MESSAGE
         DC    AL2(MSGSEC03-STARTALM) OFFSET TO MESSAGE
         DC    AL2(SEGCH0)         OFFSET TO SEGMENT CHAIN
         DC    AL2(L'MSGSEC04)     LENGTH OF MESSAGE
         DC    AL2(MSGSEC04-STARTALM) OFFSET TO MESSAGE
         DC    AL2(SEGCH0)         OFFSET TO SEGMENT CHAIN
         DC    AL2(L'MSGSEC05)     LENGTH OF MESSAGE
         DC    AL2(MSGSEC05-STARTALM) OFFSET TO MESSAGE
         DC    AL2(SEGCH0)         OFFSET TO SEGMENT CHAIN
         DC    AL2(L'MSGSEC06)     LENGTH OF MESSAGE
         DC    AL2(MSGSEC06-STARTALM) OFFSET TO MESSAGE
         DC    AL2(SEGCH0)         OFFSET TO SEGMENT CHAIN
         DC    AL2(L'MSGSEC07)     LENGTH OF MESSAGE
         DC    AL2(MSGSEC07-STARTALM) OFFSET TO MESSAGE
         DC    AL2(SEGCH0)         OFFSET TO SEGMENT CHAIN
         DC    AL2(L'MSGSEC08)     LENGTH OF MESSAGE
         DC    AL2(MSGSEC08-STARTALM) OFFSET TO MESSAGE
         DC    AL2(SEGCH0)         OFFSET TO SEGMENT CHAIN
         DC    AL2(L'MSGSEC09)     LENGTH OF MESSAGE
         DC    AL2(MSGSEC09-STARTALM) OFFSET TO MESSAGE
         DC    AL2(SEGCH0)         OFFSET TO SEGMENT CHAIN
         DC    AL2(L'MSGSEC10)     LENGTH OF MESSAGE
         DC    AL2(MSGSEC10-STARTALM) OFFSET TO MESSAGE
         DC    AL2(SEGCH0)         OFFSET TO SEGMENT CHAIN
         DC    AL2(L'MSGSEC11)     LENGTH OF MESSAGE            ZA00106
         DC    AL2(MSGSEC11-STARTALM) OFFSET TO MESSAGE         ZA00106
         DC    AL2(SEGCH0)         OFFSET TO SEGMENT CHAIN      ZA00106
*
*        SECOND LEVEL MESSAGES
*
MSGSEC01 DC    C'IKJ583XXI REQUIRED VOLUME NOT MOUNTED'
MSGSEC02 DC    C'IKJ583XXI DATA SET NOT ON VOLUME'
MSGSEC03 EQU   *
MSGSEC04 DC    C'IKJ583XXI I/O ERROR DURING OBTAIN, CODE '
MSGSEC05 DC    C'IKJ583XXI LOCATE ERROR CODE '
MSGSEC06 DC    C'IKJ583XXI NOT ENOUGH MAIN STORAGE'
MSGSEC07 DC    C'IKJ583XXI DIRECTORY STRUCTURE ERROR'
MSGSEC08 DC    C'IKJ583XXI I/O SYNAD ERROR DURING DIRECTORY SEARCH '
MSGSEC09 EQU   *
MSGSEC10 DC    C'IKJ583XXI PARSE ERROR CODE '
MSGSEC11 DC    C'IKJ583XXI NO HISTORY AVAILABLE ON SPOOL DATA SETS'
*                                                               ZA00106
PATCH    DC    20X'00'             PATCH AREA
         END
