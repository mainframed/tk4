         TITLE 'IKJEHDS1-IBM TIME SHARING LISTDS COMMAND'
IKJEHDS1 CSECT
*         VS2 -3.0 SERVICE UPDATE                      PTF#     APAR#
*0000116620,312400,738840                             UZ03988  @ZA10244
*0000116200,192201,239801-239802,239900-241100        UZ03988  @ZA09142
*0000116200,579750,579780                             UZ03988  @ZA07714
*0000592820,592840,593020                             UZ03988  @ZA06703
*0000042900,165900,183608,183612,183618,183630                 @VS06783
*0000192100-192300,481300-481500,483100-483300                 @VS06171
*A 029500,579756-579757                               UZ03988  @ZA06146
*C 579092,579760-579764,579776-579778,579785-579787   UZ03988  @ZA06146
*C 579801-579804,579810,302800                        UZ03988  @ZA06146
*0000184201-184280                                    UZ03988  @ZA06144
*0000012200-012700,116500-116640,142100,144800        UZ03988  @ZA01485
*0000183645                                           UZ03988  @ZA01485
*0000183433,183532                                    UZ03988  @ZA05439
*A 343600-343760                                                SA52667
*C 328800,329700,336900,343200                                  SA52667
*D 334200-335700                                                SA52667
*C 746100                                                        YM1019
*A 582400                                                       SA49892
*D 591600                                                       SA49829
*C 828600,829200,829800,830400,831000                            A49872
*A 646600-646700                                                 A48499
*C 474000-474600,476400,477000,497700                            A48499
*C 240000                                                        A46800
*A 630100-630280,671800-671900,718600-718720                     100000
*C 130500-130800,131700-135300,169500-169800,170400-170700,      100000
*C 172200-172800,174900-175200,175800-176100,624600,             100000
*C 648600-648900,649500-652200,652800,669300                     100000
*D 131100-131400,135600,170100,173100-174000,174600,177300,      100000
*D 232500-233100,245700,624900-627300,649200,652500,             100000
*D 669600-669900                                                 100000
*C 191700                                                        A46749
*C 167400,191400,192300,195900,236700                            A42337
*A 069300,167700-168900,188700-191100,191700-192000,             A42337
*A 192600-195600,746400,754200-754800                            A42337
*D 168300,169000,169300,169400                                   A42337
*C 712200                                                         M0875
*                  RELEASE 3.0, VS2 CHANGES
*C 297564                                                      @ZA00105
*D 570420                                                       ZA00105
*
*             VS2-4.1 RACF CHANGES                             @Z40RSSA
*A 66901,303620,303640,570420-570476,570508-570538,570848       ZA00105
*A 734099-734299,734400,734500                                  ZA00105
*A 032200,202960,202980,738280                                  ZA00612
*C 183598                                                       ZA02173
*D 579436-579740,579900-579964                                  ZA02196
*C 579868                                                       ZA02196
*A 579436,579424,579900                                         ZA02196
*C231000                                                        ZA01264
***********************************************************************
*                                                                     *
* STATUS --  VS2  030  SU                                      @ZA06146
*                                                                     *
* FUNCTION --                                                         *
*    THIS IS THE MAIN PROCESSING MODULE OF THE LISTDS COMMAND.        *
*    IT GETS CONTROL FROM THE TERMINAL MONITOR PROGRAM VIA ATTACH     *
*    AND PROCESSES A LIST OF DSNAMES, DISPLAYING THEIR ATTRIBUTES     *
*    ON THE TERMINAL. A LOCATE IS ISSUED TO GET THE VOLUME LIST,
*    ENTRY TYPE, AND OTHER INFORMATION ABOUT THE DATA SET.     @YL026YA
*    IF THE DATA SET IS NON-VSAM,                              @YL026YA
*    OBTAIN IS USED TO GET THE REMAINDER OF THE INFOR-         @YL026YA
*    MATION GIVEN AS PART OF THE BASIC FUNCTION OF THE COMMAND.       *
*    IF THE DATA SET IS VSAM, THE ORIGINAL LOCATE SUPPLIED     @YL026YA
*    THE INFORMATION.                                          @YL026YA
*    IF THE DSNAME IS NOT CATALOGED, AN ENTRY IS MADE TO DAIR TO      *
*    SEE IF IT WAS ALLOCATED VIA THE LOGON PROC. IF IT WAS, THE       *
*    DDNAME IS EXTRACTED AND A RDJFCB IS ISSUED. IN THIS CASE         *
*    ONLY UP TO 5 VOLSERS WILL BE DISPLAYED.                          *
*    HISTORY INFORMATION IS OPTIONALLY PROVIDED FROM THE DSCB  @YL026YA
*    FOR NON-VSAM DATA SETS.  FOR VSAM DATA SETS, HISTORY      @YL026YA
*    INFORMATION IS RETRIEVED FROM THE CATALOG VIA THE ORIGINAL
*    LOCATE.                                                   @YL026YA
*    IF STATUS INFORMATION IS REQUESTED, THE INFORMATION       @YL026YA
*    RETRIEVAL FUNCTION OF DYNAMIC ALLOCATION IS USED;         @YL026YA
*    THE DDNAME AND DISPOSITION                                @YL026YA
*    IS EXTRACTED AND DISPLAYED. IF THE DSNAME IS A MEMBERNAME        *
*    A BLDL ISSUED AND INFORMATION IN THE DIRECTORY FOR THAT          *
*    MEMBER IS DISPLAYED. IF MEMBERS INFORMATION IS REQUESTED,        *
*    AND THE DATASET IS A PDS, THEN IKJEHMEM IS CALLED TO LIST        *
*    OUT THE DIRECTORY. IF LABEL INFORMATION IS REQUESTED, THE        *
*    DSCB CHAIN IS PRINTED IN HEXADECIMAL ON THE TERMINAL.            *
*                                                                     *
* ENTRY POINTS --                                                     *
*         IKJEHDS1 - MAIN ENTRY POINT OF THE PROGRAM                  *
*         IKJEHWRT - WRITE ROUTINE                                    *
*                                                                     *
* INPUT -- REGISTER 1 POINTS TO THE COMMAND PROCESSOR PARAMETER LIST  *
*                                                                     *
* OUTPUT -- A LIST OF ATTRIBUTES FOR THE DATA SETS SPECIFIED          *
*         R15 = X'00'   NORMAL RETURN                          @ZA01485
*         R15 = X'0C'   ERROR RETURN                           @ZA01485
*                                                                     *
* EXTERNAL REFERENCES --                                              *
*         IKJEHMEM TO LIST PDS DIRECTORY                              *
*         IKJPARS TO PARSE COMMAND                                    *
*         IKJPUTL TO OUTPUT DATA TO TERMINAL                          *
*         IKJEHSIR TO ESTABLISH STAE EXIT                             *
*         IKJDAIR TO ALLOCATE DATASET                                 *
*         IKJDFLT TO QUALIFY DATA SET NAMES                           *
*         IKJEHCIR TO OBTAIN A LIST OF NAMES IF LEVEL OR A     @YL026YA
*                  GENERIC (*) DATA SET NAME IS SPECIFIED.     @YL026YA
*                                                                     *
* EXITS, NORMAL -- RETURN TO THE TERMINAL MONITOR PROGRAM             *
*                                                                     *
* EXITS, ERROR -- RETURN TO THE TERMINAL MONITOR PROGRAM              *
*                                                                     *
* TABLES/WORK AREAS --                                                *
*    HDTNY-THIS TABLE THE ACCUMULATED DAYS IN THE YEAR FOR EACH       *
*    MONTH. IT IS USED TO FIND THE CORRECT MONTH THAT A               *
*    DAY FALLS IN. NY STANDS FOR NORMAL YEAR.                         *
*    HDTLY-SAME AS HDTNY BUT FOR LEAP YEAR.                           *
*    TRANSTAB-USED TO TRANSLATE BINARY TO HEXADECIMAL                 *
*    OBTWAD-WORKING CORE GOTTEN THAT PROVIDES THE WORK AREA FOR       *
*    THE RDJFCB AND OBTAIN MACROS ALONG WITH DCBS AND                 *
*    VARIOUS INTERNAL SWITCHS, LIST FORMS OF MACROS,                  *
*    BUFFERS, REG SAVE AREA, AND PARAMETER LISTS. CORE                *
*    IS GOTTEN BY A REG GETMAIN.                                      *
*                                                                     *
* ATTRIBUTES -- REENTRANT, READ-ONLY, REFRESHABLE                     *
*                                                                     *
* CHARACTER CODE DEPENDENCY -- CHARACTER CODE INDEPENDENT             *
*                                                                     *
* NOTES --                                                            *
*    DESCRIBED IN OS/VS2 TSO COMMAND PROCESSOR LOGIC,          @YL026YA
*    VOLUME IV, SY28-0652.                                     @YL026YA
*                                                                     *
***********************************************************************
         ENTRY IKJEHWRT
         ENTRY IKJEHALC                                        @YL026YA
         ENTRY IKJEHERR
R0       EQU   0                   REGISTER 0
R1       EQU   1                   REGISTER 1
R2       EQU   2                   REGISTER 2
R3       EQU   3                   REGISTER 3
R4       EQU   4                   REGISTER 4
R5       EQU   5                   REGISTER 5
R6       EQU   6                   REGISTER 6
R7       EQU   7                   REGISTER 7
R8       EQU   8                   REGISTER 8
R9       EQU   9                   REGISTER 9 - POINTER TO CURRENT     *
                                   DSNAME                      @YL026YA
R10      EQU   10                  REGISTER 10 - BASE FOR      @YL026YA
*                                    SECONDARY PROGRAM CSECTS  @YL026YA
R11      EQU   11                  REGISTER 11 - MAIN PROGRAM  @YL026YA
*                                    BASE REGISTER             @YL026YA
R12      EQU   12                  REGISTER 12 - BASE FOR WORKAREA
R13      EQU   13                  REGISTER 13
R14      EQU   14                  REGISTER 14
R15      EQU   15                  REGISTER 15
WORKSP   EQU   1                   SUBPOOL NUMBER
SAVELEN  EQU   112                 SAVE AREA LENGTH            @ZA06146
SAVELEN1 EQU   120                 SAVE AREA LENGTH            @ZA06146
ONE      EQU   X'01'               MASK TO CHECK KEYWORD PDE
HISTORY  EQU   X'01'               HISTORY OPTION
STATUS   EQU   X'02'               STATUS OPTION
MEMBERS  EQU   X'04'               MEMBERS OPTION
LABEL    EQU   X'08'               LABEL OPTION
CATALOG  EQU   X'01'               CATALOG OPTION              @YL026YA
LEVEL    EQU   X'02'               LEVEL OPTION                @YL026YA
JFCB     EQU   X'20'               INDICATE RDJFCB HAS BEEN ISSUED
LOCATE   EQU   X'40'               INDICATE LOCATE HAS BEEN SUCCESSFUL
MOREVOLS EQU   X'80'               INDICATE FOR MORE VOLUMES.
NMOREVOL EQU   X'7F'               MASK TO TURN OFF MORE VOL SWITCH
B1       EQU   1                   MASK FOR BYTE#1 OF REG       ZA00612
ON       EQU   X'80'               MASK FOR DSLIST PDE FLAGS
MEMFLAG  EQU   14                  OFFSET TO MEMBER FLAG BYTE IN PDE
MEMNAME  EQU   X'10'               INDICATOR FOR MEMBER NAME
PWOFF    EQU   16                  OFFSET TO PASSWORD ADDRESS
STATOFF1 EQU   29                  OFFSET FOR STATUS WITHOUT HISTORY
STATOFF2 EQU   58                  OFFSET FOR STATUS WITH HISTORY
BLANK    EQU   C' '                BLANK
ZONE     EQU   C'0'                ZONE FIELD
SLASH    EQU   C'/'                CHARACTER SLASH
FOXES    EQU   X'FF'               HEX FF BYTE
MNAMTTR  EQU   11                  OFFSET TO TTR FOR MNAM OUTPUT
MNAMALI  EQU   18                  ALIAS OFFSET
MNAMTTRN EQU   24                  OFFSET TO TTRN
MNAMCNT  EQU   29                  OFFSET TO HW COUNT
MNAMDATA EQU   33                  OFFSET TO DATA TO INSERT.
FOX3     EQU  X'F3'                USED FOR MASK OF F3
MAXDSN   EQU   44                  LONGEST NAME ALLOWED TO     @YL026YA
*                                  SYSTEM                      @YL026YA
CIRLIST  EQU   X'FF'               INDICATOR THAT NAME BEING   @YL026YA
*                                  PROCESSED IS FROM CIR LIST  @YL026YA
CIROPTDS EQU   X'02'               CIR OPTION TO RETURN LIST   @YL026YA
*                                  OF NAMES                    @YL026YA
*     RELATIVE MESSAGE NUMBERS TO BE USED FOR ERROR HANDLING
MSG01    EQU   1                   MESSAGE NUMBER 1
MSG02    EQU   2                   MESSAGE NUMBER 2
MSG03    EQU   3                   MESSAGE NUMBER 3
MSG04    EQU   4                   MESSAGE NUMBER 4
MSG05    EQU   5                   MESSAGE NUMBER 5
MSG06    EQU   6                   MESSAGE NUMBER 6
MSG07    EQU   7                   MESSAGE NUMBER 7
MSG08    EQU   8                   MESSAGE NUMBER 8
MSG09    EQU   9                   MESSAGE NUMBER 9
MSG10    EQU   10                  MESSAGE NUMBER 10
MSG11    EQU   11                  MESSAGE NUMBER 11
MSG12    EQU   12                  MESSAGE NUMBER 12
MSG13    EQU   13                  MESSAGE NUMBER 13
MSG14    EQU   14                  MESSAGE NUMBER 14
MSG15    EQU   15                  MESSAGE NUMBER 15
MSG16    EQU   16                  MESSAGE NUMBER 16
MSG17    EQU   17                  MESSAGE NUMBER 17
MSG18    EQU   18                  MESSAGE NUMBER 18           @YL026YA
MSG19    EQU   19                  MESSAGE NUMBER 19           @YL026YA
MSG20    EQU   20                  MESSAGE NUMBER 20           @VS06783
SECMSG01 EQU   1                   SECOND LEVEL MESSAGE 1
SECMSG02 EQU   2                   SECOND LEVEL MESSAGE 2
SECMSG03 EQU   3                   SECOND LEVEL MESSAGE 3
SECMSG04 EQU   4                   SECOND LEVEL MESSAGE 4
SECMSG05 EQU   5                   SECOND LEVEL MESSAGE 5
SECMSG06 EQU   6                   SECOND LEVEL MESSAGE 6
SECMSG07 EQU   7                   SECOND LEVEL MESSAGE 7
SECMSG08 EQU   8                   SECOND LEVEL MESSAGE 8
SECMSG09 EQU   9                   SECOND LEVEL MESSAGE 9
SECMSG10 EQU   10                  SECOND LEVEL MESSAGE 10
SECMSG11 EQU   11                  SECOND LEVEL MESSAGE 11
SECMSG12 EQU   12                  SECOND LEVEL MESSAGE 12
SECMSG13 EQU   13                  SECOND LEVEL MESSAGE 13
SECMSG14 EQU   14                  SECOND LEVEL MESSAGE 14
SECMSG15 EQU   15                  SECOND LEVEL MESSAGE 15
SECMSG16 EQU   16                  SECOND LEVEL MESSAGE 16
SECMSG17 EQU   17                  SECOND LEVEL MESSAGE 17
SECMSG18 EQU   18                  SECOND LEVEL MESSAGE 18
SECMSG19 EQU   19                  SECOND LEVEL MESSAGE 19
SECMSG20 EQU   20                  SECOND LEVEL MESSAGE 20
SECMSG21 EQU   21                  SECOND LEVEL MESSAGE 21     @YL026YA
SECMSG22 EQU   22                  SECOND LEVEL MESSAGE 22     @YL026YA
*
CHARV    EQU   C'V'                RECFM EQUAL V
CHARU    EQU   C'U'                EQUAL U
CHARF    EQU   C'F'                EQUAL F
CHARAST  EQU   C'*'                RECFM NOT SPECIFIED
CHART    EQU   C'T'                TRACK OVERFLOW CHAR
CHARB    EQU   C'B'                BLOCKED ATTRIBUTE
CHARS    EQU   C'S'                STANDARD OR SPANNED
CHARA    EQU   C'A'                ASA CONTROL CHAR
CHARM    EQU   C'M'                MACHINE CONTROL
NOHIBIT  EQU   X'7F'               USED FOR MASK OF X'7F'
DAIR08   EQU   X'08'               DAIR ENTRY CODE 08
DAIR2C   EQU   X'2C'               DAIR ENTRY CODE 2C
EXITCODE EQU   X'87'               EXIT CODE FOR JFCB
RETCD52  EQU   52                  RETURN CODE OFFSET
*                                    (END OF SAVE AREA)        @YL026YA
DAYS31   EQU   31                  USED FOR VALUE 31
ERRCOD   EQU   14                  USED AS OFFSET OF 14 IN ERROR RTN
PASSLOT  EQU   60                  PASSWORD SLOT OF DAIRLIST
CRDTOFF  EQU   28                  OFFSET TO CREATION DATE
*                                  IN OUTPUT (PRINT) BUFFER    @YL026YA
VOLENTLN EQU   6                   LENGTH OF VOLSER ENTRY      @YL026YA
DSNADDR  EQU   0                   OFFSET TO DSNAME ADDR IN PDE LIST
DSNLEN   EQU   4                   OFFSET TO DSNAME LENGTH FIELD IN PDE
DSNFLAGS EQU   6                   OFFSET TO FLAG1 IN PDE      @YL026YA
MEMADDR  EQU   8                   OFFSET TO MEMBERNAME POINTER IN PDE
MEMLEN   EQU   12                  OFFSET TO MEMBERNAME LENGTH
PWRDADDR EQU   16                  OFFSET TO PASSWORD ADDRESS IN PDE
PWLEN    EQU   20                  OFFSET TO PASSWORD LENGTH IN PDE
PWFLAG   EQU   22                  OFFSET TO PASSWORD          @YL026YA
CHAINAD  EQU   24                  OFFSET TO PDE CHAIN FIELD
BLDLLEN  EQU   80                  LENGTH OF BLDL LIST
LOCSAVOF EQU   72                  OFFSET TO LOCAL SAVE AREA
TCBOFF   EQU   4                   OFFSET TO TCB
FOUR     EQU   4                   USED FOR FULL WORD MOVES AND REFS
OPT02    EQU   X'20'               USED AS OPTION FOR DEFAULT INTERFACE
OPT04    EQU   X'04'               USED AS OPTION FOR DEFAULT ROUTINE
QUOTED   EQU   X'40'               FLAG FOR QUOTED DSNAME IN PDE
HIGHBIT  EQU   X'80'               HIGH ORDER BIT MASK
*  DISPLACEMENTS, LENGTHS
D0       EQU   0                   0
D1       EQU   1                   1
D2       EQU   2                   2
D3       EQU   3                   3
D4       EQU   4                   4
D5       EQU   5                   5
D6       EQU   6                   6
D7       EQU   7                   7
D8       EQU   8                   8
D9       EQU   9                   9                          @YL026YB
D10      EQU   10                  10
D11      EQU   11                  11
D12      EQU   12                  12
D56      EQU   56                  56
L0       EQU   0                   0
L1       EQU   1                   1
L2       EQU   2                   2
L3       EQU   3                   3
L4       EQU   4                   4
L5       EQU   5                   5
L6       EQU   6                   6
L7       EQU   7                   7
L8       EQU   8                   8
L9       EQU   9                   9
L10      EQU   10                  10
L12      EQU   12                  12                           ZA00105
L15      EQU   15                 15
L16      EQU   16                  16                          @YL026YA
L23      EQU   23                  23                          @YL026YA
L34      EQU   34
*
FOURB    EQU   4                   4
EQ       EQU   8                   CONDITION CODE EQUAL        @YL026YA
RC28     EQU   28                  RETURN CODE 28
NXTBUF   EQU   10                  NEXT BUFFER POSITION
CONVCNT  EQU   8                   HALF BYTE COUNT FOR BITOHEX
NUMMONTH EQU   12                  NUMBER OF MONTHS IN A YEAR
DDNAMLEN EQU   8                   LENGTH OF A DDNAME
STAR     EQU   C'*'                ASTERISK                    @YL026YA
PERIOD   EQU   C'.'                DSNAME LEVEL DELIMITER      @YL026YA
COMMA    EQU   C','                COMMA
QUOTE    EQU   C''''               CHARACTER QUOTE               A42337
CONDZERO EQU   8                   BRANCH IF ZERO CONDITION CODE
RETCD12  EQU   12                  RETURN CODE FOR ERROR RETURN TO TMP
ONEF     EQU   X'1F'               USED FOR MASK OF X'1F'
RT08     EQU   X'08'               USED FOR RETURN CODE CHECK
RT12     EQU   X'0C'               USED FOR RETURN CODE
RT16     EQU   X'10'               USED FOR RETURN CODE 16
ZERO     EQU   X'00'               USED TO CLEAR BYTES
SWON     EQU   X'FF'               MASK TURN SWITCH ON
SWOFF    EQU   X'00'               MASK TURN SWITCH OFF
***********************************************************************
*                                                                     *
*    THE FOLLOWING EQUATES ARE USED BY THE LABEL KEYWORD PROCESSING   *
*    ROUTINE (IKJEHLBL).   THEY ARE MAINLY USED FOR FORMATTING THE    *
*    FORMAT 1 AND 3 DSCBS INTO THE OUTPUT BUFFER.  EQUATES ENDING IN  *
*    LEN ARE GENERALLY LENGTHS OF SOME DATA FIELD AND THOSE ENDING IN *
*    OFF AND OF ARE GENERALLY OFFSETS INTO ONE OF THE WORK AREAS OR   *
*    THE BUFFER.  THOSE OFFSETS BEGINNING WITH N ARE OFFSETS INTO THE *
*    OUTPUT BUFFER.  THOSE OFFSETS NOT BEGINNING WITH N ARE OFFSETS   *
*    INTO A WORK AREA WHERE THE DATA IS CONVERTED TO HEXIDECIMAL.     *
*                                                                     *
*    ANY OF THE LENGTHS OF THE DATA FIELDS MAY BE CHANGED WITHOUT     *
*    REQUIRING CHANGES TO THE OFFSETS OR OUTPUT FORMATS, EXCEPT IN    *
*    IN THE CASE WHERE THE CHANGE IN LENGTH CAUSES THE CONVERSION     *
*    AREA OR THE BUFFER TO BE OVER RUN.                               *
*                                                                     *
***********************************************************************
MAXNUM   EQU   40                  MAX BYTE COUNT FOR FORMAT 1 CONVERT
MAXNUM2  EQU   36                  MAX COUNT FOR A FORMAT 3 CONVERSION
IDLEN    EQU   2                   LENGTH OF ID BYTE
SNLEN    EQU   12                  SERIAL NUMBER LENGTH
VSLEN    EQU   4                   VOLUME SEQUENCE LENGTH
CDLEN    EQU   6                   CREATION DATE LENGTH
EDLEN    EQU   6                   EXPIRATION DATE LENGTH
NELEN    EQU   2                   NUMBER OF EXTENTS LENGTH
NOBDBLEN EQU   2                   BYTES USED IN LAST DIRECTORY BLK LEN
RESLEN1  EQU   2                   RESERVED AREA 1 LENGTH
SYSCDLEN EQU   26                  SYSTEM CODE LENGTH
RESLEN2  EQU   14                  RESERVED AREA NUMBER 2 LENGTH
DSORGLEN EQU   4                   DSORG FIELD LENGTH
RECFMLEN EQU   2                   RECFM FIELD LENGTH
OPTCDLEN EQU   2                   OPTCD FIELD LENGTH
BLKLLEN  EQU   4                   BLKL FIELD LENGTH
LRECLLEN EQU   4                   LRECL FIELD LENGTH
KEYLLEN  EQU   2                   KEY LENGTH FIELD LENGTH
RKPLEN   EQU   4                   RELATIVE KEY POSITION FIELD LENGTH
DSINDLEN EQU   2                   DSIND FIELD LENGTH
SCALOLEN EQU   8                   SECONDARY ALLOC. FIELD LENGTH
LSTARLEN EQU   6                   LSTAR FIELD LENGTH
TRBALLEN EQU   4                   TRACK BALANCE FIELD LENGTH
RESLEN3  EQU   4                   RESERVED AREA 3 LENGTH
EXT1LEN  EQU   20                  EXTENT ONE LENGTH
EXT2LEN  EQU   20                  EXTENT TWO LENGTH
EXT3LEN  EQU   20                  EXTENT THREE LENGTH
PTRDSLEN EQU   10                  CCHHR OF NEXT DSCB LENGTH
     EJECT
***********************************************************************
*
*      THE FOLLOWING EQUATES APPEAR IN PAIRS, THE FIRST BEING THE
*      OFFSET INTO AN AREA WHERE A PORTION OF THE DSCB HAS BEEN
*      CONVERTED TO HEXIDECIMAL, AND THE SECOND (STARTING ALWAYS
*      WITH N) INTO THE BUFFER WHERE IT WILL BE OUTPUTTED. THE
*      FIRST COUPLE CHARACTERS CORRESPONDS TO THE SAME ITEM THAT
*      IS REPRESENTED ABOVE AS THE LENGTH OF THE FIELD.
*
***********************************************************************
SNOFF    EQU   IDLEN               OFFSET TO ID FIELD IN CONVERSION
*                                  AREA
NSNOFF   EQU   IDLEN+1             OFFSET INTO BUFFER TO ID FIELD FOR
*                                  OUTPUT
VSOFF    EQU   SNOFF+SNLEN         VOLUME SEQ FIELD
NVSOFF   EQU   SNLEN+NSNOFF+1
CDOFF    EQU   VSOFF+VSLEN         CREATION DATE
NCDOFF   EQU   VSLEN+NVSOFF+1
EDOFF    EQU   CDOFF+CDLEN         EXPIRATION DATE
NEDOFF   EQU   CDLEN+NCDOFF+1
NEOFF    EQU   EDOFF+EDLEN         N. OF EXTENTS
NNEOFF   EQU   EDLEN+NEDOFF+1
NOBDBOFF EQU   NEOFF+NELEN         N. OF BYTES IN LAST PDS DIRECT. BLK.
NNOBDBOF EQU   NELEN+NNEOFF+1
RESOFF1  EQU   NOBDBOFF+NOBDBLEN   RESERVED AREA 1
NRESOFF1 EQU   NOBDBLEN+NNOBDBOF+1
SYSCDOFF EQU   RESOFF1+RESLEN1     SYSTEM CODE FIELD
NSYSCDOF EQU   RESLEN1+NRESOFF1+1
*
DSORGOF  EQU   RESLEN2             DSORG FIELD
NDSORGOF EQU   RESLEN2+1
RECFMOF  EQU   DSORGOF+DSORGLEN    RECFM FIELD
NRECFMOF EQU   DSORGLEN+NDSORGOF+1
OPTCDOFF EQU   RECFMOF+RECFMLEN    OPTCD FIELD
NOPTCDOF EQU   RECFMLEN+NRECFMOF+1
BLKLOF   EQU   OPTCDOFF+OPTCDLEN   BLKL FIELD
NBLKLOF  EQU   OPTCDLEN+NOPTCDOF+1
LRECLOF  EQU   BLKLOF+BLKLLEN      LRECL FIELD
NLRECLOF EQU   BLKLLEN+NBLKLOF+1
KEYLOFF  EQU   LRECLOF+LRECLLEN    KEY LENGTH
NKEYLOFF EQU   LRECLLEN+NLRECLOF+1
RKPOFF   EQU   KEYLOFF+KEYLLEN     REL. KEY POSITION FIELD
NRKPOFF  EQU   KEYLLEN+NKEYLOFF+1
DSINDOFF EQU   RKPOFF+RKPLEN       DSIND FIELD
NDSINDOF EQU   RKPLEN+NRKPOFF+1
SCALOOFF EQU   DSINDOFF+DSINDLEN
NSCALOOF EQU   DSINDLEN+NDSINDOF+1  SEC. ALLOC. FIELD
LSTAROFF EQU   SCALOOFF+SCALOLEN   LSTAR FIELD
NLSTAROF EQU   SCALOLEN+NSCALOOF+1
TRBALOFF EQU   LSTAROFF+LSTARLEN   TRK BALANCE FIELD
NTRBALOF EQU   LSTARLEN+NLSTAROF+1
RESOFF3  EQU   TRBALOFF+TRBALLEN   RESERVED AREA THREE
NRESOFF3 EQU   TRBALLEN+NTRBALOF+1
EXT2OFF  EQU   EXT1LEN             EXTENT TWO FIELD
NEXT2OFF EQU   EXT1LEN+1
EXT3OFF  EQU   EXT2OFF+EXT2LEN     EXTENT THREE
NEXT3OFF EQU   EXT2LEN+NEXT2OFF+1
PTRDSOFF EQU   EXT3OFF+EXT3LEN     PTRDS FIELD
NPTRDSOF EQU   EXT3LEN+NEXT3OFF+1
*
*   THE FOLLOWING EQUATES ARE USED FOR PROCESSING THE FORMAT 3 DSCB.
*
KEYIDLEN EQU   8                   LEN OF KEY ID FIELD WHEN IN HEX
F3EXTLEN EQU   20                  LEN OF EXTENT FIELD WHEN CONVERTED
F3IDLEN  EQU   2                   ID FIELD LENGTH
MAXNUM3  EQU   15                  NUMBER USED IN CONVERSION ROUTINE
MAXNUM4  EQU   31                  NUMBER USED IN CONVERSION ROUTINE
EOBUFF1  EQU   2*MAXNUM2           USED IN UNKNOWN DSCB ROUTINE
IDOFF    EQU   9                   OFFSET TO ID
*
F3OFF1   EQU   KEYIDLEN            OFFSET TO EXTENT 4
F3OFF2   EQU   F3EXTLEN+F3OFF1     EXTENT 5
F3OFF3   EQU   F3EXTLEN+F3OFF2     EXTENT 6
*
NF3OFF1  EQU   KEYIDLEN+1          OFFSET INTO BUFFER FOR EXTENTS
NF3OFF2  EQU   NF3OFF1+F3EXTLEN+1
NF3OFF3  EQU   NF3OFF2+F3EXTLEN+1
NF3OFF4  EQU   F3EXTLEN+1
F3OFF4   EQU   F3EXTLEN            EXTENT OFFSETS INTO CONVERSION AREA
F3OFF5   EQU   F3OFF4+F3IDLEN
NF3OFF5  EQU   NF3OFF4+F3IDLEN+1
F3OFF6   EQU   F3OFF5+F3EXTLEN
NF3OFF6  EQU   NF3OFF5+F3EXTLEN+1
F3OFF7   EQU   F3EXTLEN
NF3OFF7  EQU   F3EXTLEN+1
F3OFF8   EQU   F3OFF7+F3EXTLEN
NF3OFF8  EQU   NF3OFF7+F3EXTLEN+1
*
*******EQUATES USED IN MEMBER PROCESSING ****
*
DSORGF   EQU   1                   DSORG FIELD LENGTH
BLDL1    EQU   1                   DO BLDL ON ONE ENTRY
BLDLMAX  EQU   76                  MAX LIST LENGTH ON BLDL
DTACNT   EQU   1                   DATA COUNT TO BE CONVERTED
USERFLD  EQU   4                   OFFSET TO USER DATA
BUFPTLN  EQU   9                   LENGTH OF BUFFPTR
LSTFLD   EQU   69                  OFFSET TO LAST FIELD OUTPUT BUFF
*
         EJECT
LISTDS   SAVE  (14,12)
         LR    R11,R15             ESTABLISH ADDRESSABILITY
         USING LISTDS,R11          USE R11 FOR MAIN BASE
         USING OBTWAD,R12          USE R12 FOR WORKAREA BASE
         B     BRARID              BRANCH AROUND ID            @ZA01485
         DC    C'IKJEHDS1'         MODULE ID                   @ZA01485
         DC    X'6098'             DATE 04/07/76               @ZA10244
BRARID   EQU   *                                               @ZA01485
         LR    R2,R1               COPY PARM LIST POINTER
         GETMAIN  R,LV=WORKSIZE,SP=WORKSP   GET INITIAL CORE
         LR    R12,R1              SETUP BASE FOR WORKAREA
         LA    R3,SAVEAREA         GET ADDR OF THIS PROGRAMS SAVEAREA
         ST    R13,D4(R3)          SET UP BACK CHAIN
         ST    R3,D8(R13)          SET UP FORWARD CHAIN
         LR    R13,R3                   BACKWARD CHAIN AREAS.
*
         MVI   STACKSW,SWOFF       TURN STACK SWITCH OFF
         LA    R3,PUTLLIST         SETUP
         ST    R3,PUTLCON          ADCONS
         LA    R3,DPUTLINE         TO
         ST    R3,DPUTLCON          BE USED
         LA    R3,CPECB               BY THE
         ST    R3,ECBPTR               PUTLINE
         XC    CPECB,CPECB               ROUTINES
         L     R3,CPPLUPT-CPPL(R2) GET UPT PTR
         ST    R3,UPTPTR           SAVE UPT POINTER
         L     R3,CPPLPSCB-CPPL(R2)  GET PSCB PTR
         ST    R3,PSCBPTR          SAVE IT
         L     R3,CPPLECT-CPPL(R2)  GET ECT PTR
         ST    R3,ECTPTR           SAVE IT
         ST    R2,TMPSR1
         LOAD  EP=IKJPUTL
         ST    R0,PUTLADDR
         XC    RETCODE,RETCODE     SET RETURN CODE TO ZERO
         XC    CIRADDR,CIRADDR     INDICATE CIR NOT LOADED     @YL026YA
         XC    PROCNM,PROCNM       INITIALLY PROCESSING DSNAMES        *
                                   FROM PARSE LIST             @YL026YA
         MVI   FIRSTIME,ONE        TURN ON FIRST ALLOC SWITCH
         XC    ALLOCSW(L3),ALLOCSW  CLEAR CONTROL BYTES
         XC    ERRPARM(ERRLIST),ERRPARM  CLEAR ERROR PARM LIST
         MVC   GETML(LILFS),GETMLMDL MOVE LIST FORMS OF GETMAIN ETC
         MVI   OUTBUF,BLANK        CLEAR OUTPUT BUFFER
         MVC   OUTBUF+D1(L'OUTBUF-D1),OUTBUF
         MVC   DPUTLINE(LTPUTL),TPUTMDL INITIALIZE PUTLINE
         ST    R12,OBTJFCBX        SAVE ADDR OF JFCB WORK AREA
         LA    R3,OBTDCB           ADDR OF DCB IN DSECT
         USING IHADCB,R3
         MVC   OBTMACS(LOLFS),OLFS MOVE MACRO LIST FORMS TO DSECT
         LA    R15,OBTDCBXL        ADDR OF DCB EXIT LIST
         ST    R15,DCBEXLST        SET UP EXIT LIST ADDRESS
         MVI   OBTJFCBX,EXITCODE   SET JFCB DCB EXIT CODE
         DROP  R3
*
*        SETUP PARMLIST FOR PARSE, THEN PARSE COMMAND STRING
*
         LA    R1,PUTLLIST         POINT TO PARSE PARM LIST      100000
         USING PPL,R1              USE PARSE PARM LIST DSECT     100000
         L     R3,UPTPTR           UPT POINTER TO-               100000
         ST    R3,PPLUPT           PARSE PARM LIST               100000
         L     R3,ECTPTR           ECT POINTER TO-               100000
         ST    R3,PPLECT           PARSE PARM LIST               100000
         L     R3,ECBPTR           ECB POINTER TO-               100000
         ST    R3,PPLECB           PARSE PARM LIST               100000
         L     R3,PARSECON         PCL POINTER TO-               100000
         ST    R3,PPLPCL           PARSE PARM LIST-              100000
         LA    R3,PARDSECT         ANSWER PLACE POINTER TO-      100000
         ST    R3,PPLANS           PARSE PARM LIST               100000
         L     R3,D0(R2)           COMMAND BUFFER POINTER        100000
         ST    R3,PPLCBUF          TO PARSE PARM LIST            100000
         DROP  R1                  DSECT NO LONGER NEEDED        100000
         LINK  EP=IKJPARS,MF=(E,(1))
*
*    TEST FOR PARSE RETURN CODES--IF ATTENTION, RETURN WITH RC OF 12
*
         B     PARSCODE(R15)       ANALYZE RETURN CODE FROM PARSE
*
PARSCODE B     PARSCD00            RC=00 SUCESSFUL PARSE
         B     PARSCD04            RC=04 UNABLE TO PROMPT (NO-PROMPT
*                                                MODE)
         B     PARSCD08            RC=08 ATTENTION--ECB POSTED
         B     PARSCD12            RC=12 INVALID PARAMETERS
PARSCD16 EQU   *                   RC=16 NO SPACE AVAILABLE
         MVI   ERR1,MSG14          MESSAGE 14
         B     PARSERR2            GO PROCESS ERROR
PARSCD12 EQU   *
         LR    R6,R15              SAVE RETURN CODE
         BAL   R8,CVDREG15         GO CONVERT REG 15 AND SET UP INSERT
         MVI   ERR2,SECMSG16       SECOND LEVEL MESSAGE 16
         MVI   ERR1,MSG13          MESSAGE 13
PARSERR2 BAL   R8,ERROUT           GO WRITE MESSAGE
PARSCD04 EQU   *                                               @ZA01485
PARSCD08 LA    R1,RETCD12          GET RC FOR TMP
         MVI   STACKSW,SWON        TURN STACK SWITCH ON        @ZA01485
         ST    R1,RETCODE          SAVE IT FOR WRAPUP ROUTINE
         B     WRAPUP              GO TERMINATE
*
*    SUCESSFUL RETURN FROM PARSE COMES HERE
*
PARSCD00 EQU   *
         L     R10,PARDSECT        GET POINTER TO PARSE DSECT
         USING IKJPARMD,R10
         TM    PHISTORY+D1,ONE     WAS HISTORY REQUESTED
         BNO   PARS00              NO, CHECK STATUS
         OI    OPTMASK,HISTORY     YES, SET INDICATOR IN MASK
PARS00   TM    PSTATUS+D1,ONE      WAS STATUS REQUESTED
         BNO   PARS01              NO, CHECK MEMBERS
         OI    OPTMASK,STATUS      YES, SET INDICATOR
         L     R15,STIVCON         GET ADDR OF STATUS INIT RTN @YL026YA
         BALR  R8,R15              INITIALIZE INFORMATION      @YL026YA*
                                   RETRIEVAL                   @YL026YA
PARS01   TM    PMEMBERS+D1,ONE     WAS MEMBERS REQUESTED
         BNO   PARS02              NO, CHECK LABEL
         OI    OPTMASK,MEMBERS     YES, SET INDICATOR
         LOAD  EP=IKJEHMEM
         ST    R0,MEMMOD
PARS02   TM    PLABEL+D1,ONE       WAS LABEL SPECIFIED
         BNO   PARS03              NO, CHECK CATALOG           @YL026YA
         OI    OPTMASK,LABEL       YES, SET INDICATOR
PARS03   TM    PCATLG+D1,ONE       WAS CATALOG SPECIFIED?      @YL026YA
         BNO   PARS04              NO - CHECK LEVEL            @YL026YA
         OI    OPTMASK2,CATALOG    YES - SET MASK BIT          @YL026YA
* BUILD A 44-BYTE CATALOG NAME IN THE WORKAREA                 @YL026YA
         MVI   CATBUFF,BLANK       CLEAR BUFFER TO BLANKS      @YL026YA
         MVC   CATBUFF+D1(L'CATBUFF-L1),CATBUFF                @YL026YA
         LA    R7,CATBUFF          POINT TO BUFFER             @YL026YA
         L     R3,PCATNM           POINT TO CATALOG NAME       @YL026YA
         LH    R2,PCATNM+DSNLEN    GET LENGTH OF NAME          @YL026YA
         BCTR  R2,R0               DECREMENT FOR EX INST.      @YL026YB
         EX    R2,MOVE             MOVE NAME TO BUFFER         @YL026YA
PARS04   TM    PLEVEL+D1,ONE       WAS LEVEL SPECIFIED         @YL026YA
         BNO   MAINLINE            NO - START PROCESSING       @YL026YA
         OI    OPTMASK2,LEVEL      YES - SET MASK BIT          @YL026YA
         L     R15,VCONCIR         ADDRESS OF CIR              @YL026YB
         BALR  R8,R15              BRANCH TO CIR               @YL026YB
         B     MAINLINE            RETURN CODE ZERO            @YL026YB
         B     GOWRT               NONZERO RETURN CODE         @YL026YB
*
*    MAINLINE ROUTINE
*
MAINLINE EQU   *
         LA    R9,PDSLIST          POINT AT FIRST ENTRY IN DSNAME LIST
         CLC   CHAINAD(L4,R9),NOTCHAIN WAS A DSLIST ENTERED?   @YL026YA
         BE    MAINL01             NO - OK                     @YL026YA
         TM    OPTMASK2,LEVEL      YES - WAS LEVEL SPECIFIED?  @YL026YA
         BO    LEVELER             YES - LIST NOT ALLOWED      @YL026YA
*                                  WITH LEVEL                  @YL026YA
MAINL01  EQU   *                                               @YL026YA
         XC    STAELIST(STAELNTH),STAELIST   CLEAR STAE BLOCKS
         LOAD  EP=IKJEHSIR         LOAD STAE INTERFACE ROUTINE
         ST    R0,STAEADDR         SAVE ADDRESS OF STAE ROUTINE
BLDSTAE  PSEUDO TMP=TMPSR1,MF=E
         STABUILD CODE=(113,213,313,713,913),ADDR=STAEONE,NUM=2,       X
               FLAG=(MUL,NMSG),LIST=STAELST,RTN=OPENERR,               X
               MF=E
         STABUILD CODE=000,RTN=ANYABND,ADDR=STAETWO,                   X
               FLAG=(ALL,NMSG,END),                                    X
               MF=E
         STAEPARM FLAG=(CP),LIST=STAEONE,ADDR=STAEPARM,PSEUDO=$PSEUDO, X
               MF=E
         L     R2,STAEADDR         POINTER TO STAE INTERFACE ROUTINE
         STAE  (R2),CT,PARAM=STAEPARM,MF=(E,STAELIST)
         B     NXDSNAME            CONTINUE  MAINLINE
ANYABND  EQU   *
         MVI   ERR2,SECMSG14       ABEND ERROR CODE MSG
MCOM5    MVI   ERR1,MSG09          DSNAME NOT USABLE MSG
         LA    R5,ERRINSRT         PUT ADDRESS OF INSERT
         ST    R5,ERRINST2         INTO INSERT SLOT
         STH   R1,CNVRTWD          PLACE RETURN CODE IN AREA
         LA    R4,CNVRTWD          ADDR OF AREA FOR CONVERT RTN
         L     R2,STAEADDR         POINTER TO STAE INTERFACE ROUTINE
         STAE  (R2),CT,PARAM=STAEPARM,MF=(E,STAELIST)
         B     MCOM4               GO TO COMMON RTN
OPENERR  EQU   *
         MVI   ERR2,SECMSG12       OPEN ERROR CODE
         B     MCOM5               SET UP MESSAGE
     EJECT
NXDSNAME DS    0H
***********************************************************************
*                                                                     *
*   THIS ROUTINE INTERFACES WITH THE DEFAULT SERVICE ROUTINE (IKJDFLT)*
*   IF A NAME IS FOUND IN THE DSLIST WHICH IS NOT FULLY QUALIFIED. THE*
*   SERVICE ROUTINE WILL APPEND THE USERID AND ADD THE APPROPRIATE    *
*   DESCRIPTIVE QUALIFIER. WHEN CONTROL IS RETURNED, CURNTNAM WILL    *
*   CONTAIN THE FULLY QUALIFIED DSNAME.  IF NO DSNAME IS SPECIFIED    *
*   (INDICATING A MEMBERNAME WAS ENTERED ALONE), AN ERROR MESSAGE     *
*   IS PUT OUT TO THE TERMINAL AND THE NEXT NAME IN THE LIST IS       *
*   SELECTED.                                                         *
*                                                                     *
***********************************************************************
*
         ST    R9,$RETRY0+R9*L4    STORE CURRENT R9 FOR RETRY
*
         MVI   CURNTNAM,BLANK      BLANK OUT AREA FOR DSNAME
         MVC   CURNTNAM+D1(L'CURNTNAM-L1),CURNTNAM BLANK ENTIRE AREA
         TM    DSNFLAGS(R9),HIGHBIT  IS DSNAME OMITTED
         BZ    NAMERR              YES, PROCESS AS AN ERROR    @YL026YA
         LH    R1,DSNLEN(R9)       LENGTH OF DSNAME
         STH   R1,CURNTNAM         SAVE LENGTH
         BCTR  R1,R0               DECREMENT LENGTH FOR EX OF MOVE
         LA    R7,TEMPNAME         POINT AT AREA TO HOLD NAME
         L     R3,DSNADDR(R9)      NAME TO MOVE                @YL026YA
         EX    R1,MOVE             MOVE NAMES
         TM    DSNFLAGS(R9),QUOTED SEE IF DSNAME IS QUOTED
         BO    QUOTNAME            YES, GO PROCESS AS IS         A42337
*  SAVE UNQUALIFIED DATA SET NAME FOR MESSAGES                   A42337
         LA    R1,D2(R1)           UP LENGTH FOR LENGTH FIELD    A42337
         LA    R7,MSGNAMEL         MESSAGE LENGTH-NAME BUFFER    A42337
         LA    R3,CURNTNAM         DATA SET LENGTH-NAME BUFFER   A42337
         EX    R1,MOVE             MOVE DSNAME TO BUFFER         A42337
         B     ASTERCK             GO CHECK NAME FOR ASTERISK  @YL026YA
**     SET UP DEFAULT PARM LIST USING MAP MACROS         *
QUALNAM  LA    R1,PUTLLIST         POINT TO PARM LIST          @YL026YA
         USING DFPL,R1             IKJDFPL MAP MACRO             100000
         L     R3,UPTPTR           UPT POINTER TO-               100000
         ST    R3,DFPLUPT          DEFAULT PARM LIST             100000
         L     R2,ECTPTR           GET ECTPTR
         ST    R2,DFPLECT          PUT IN LIST
         L     R4,ECBPTR           GET ECB PTR
         ST    R4,DFPLECB          PUT IN LIST                 @VS06783
         LA    R3,DEFLIST          DEFAULT PARM LIST ADDRESS-    100000
         ST    R3,DFPLDFPB         TO DEFAULT PARM LIST          100000
         DROP  R1                  IKJDFPL NO LONGER NEEDED      100000
         USING DFPB,R3             MACRO IKJDFPB
         LA    R2,CURNTNAM         DSNAME PRECEDED BY LENGTH-    100000
         ST    R2,DFPBDSN          PUT INTO DEFAULT LIST         100000
         OI    DFPBCODE,OPT04      INDICATE OPTION REQUESTED OF DEFAULT
         L     R2,PSCBPTR          PSCB ADDRESS TO-              100000
         ST    R2,DFPBPSCB         DEFAULT PARM BLOCK            100000
         DROP  R3
******************************************************
         LINK  EP=IKJDFLT,MF=(E,(1))
*
         LA    R8,DSNTEST1                                     @YL026YB
         ST    R8,RETADDR                                      @YL026YB
         B     DEFCODE(R15)        ANALYZE  RETURN CODE
DEFCODE  B     DEFOK               SUCCESS
         B     DSNTEST             MSG BY DEFAULT, GET NEXT DSNAME
         B     DEF8                INVALID NAME
         B     DSNTEST             MSG BY DEFAULT, GET NEXT DSNAME
         B     DEF16               DSNAME NOT IN CATLG
         B     DEF16               DSNAME NOT IN CATLG
         B     DEF28               NOT POSSIBLE
         B     DEF28               COMMAND SYSTEM ERROR
         B     DEF16               NOT POSSIBLE
*  THIS IS NOT AN UNCONDITIONAL BRANCH TO THE NEXT SEQUENTIAL
*  INSTRUCTION.  IT IS DEFAULT RC=36
DEF16    EQU   *                   DEFAULT RC=16,20,32,36
         MVI   ERR1,MSG01          MESSAGE 1
         B     MCOMMON3            INSERT NAME IN MESSAGE
DEF8     EQU   *
         MVI   ERR1,MSG16          MESSAGE 16
         B     RETCOM2             PUT OUT REST OF MSG
DEF28    EQU   *
         MVI   ERR1,MSG13          COMMAND SYSTEM ERROR
         MVI   ERR2,SECMSG17       DEFAULT ERROR CODE
         B     GOWRT               PUT OUT MESSAGE
QUOTNAME LA    R7,MSGNAME          DSNAME MESSAGE BUFFER         A42337
         MVI   D0(R7),QUOTE        MOVE QUOTE                    A42337
         LA    R7,D1(R7)           POINT PAST QUOTE              A42337
         EX    R1,MOVE             MOVE IN DSNAME                A42337
         LA    R7,D1(R1,R7)        POINT PAST DSNAME             A42337
         MVI   D0(R7),QUOTE        MOVE QUOTE                    A42337
         LA    R1,D3(R1)           UP LENGTH FOR QUOTES AND EXEC A42337
         STH   R1,MSGNAMEL         SAVE DSNAME LENGTH            A42337
*                                                              @YL026YA
*   CHECK THE DSNAME FOR ASTERISKS.  IF NONE, PROCESS THE      @YL026YA
*   DATA SET.  IF AN ASTERISK APPEARS, OR LEVEL WAS SPECIFIED, @YL026YA
*   CALL CIR TO GET A LIST OF NAMES TO PROCESS.                @YL026YA
*                                                              @YL026YA
ASTERCK  EQU   *                                               @YL026YA
         LA    R2,TEMPNAME         ADDRESS OF NAME             @YL026YA
         LH    R3,CURNTNAM         LENGTH OF NAME              @YL026YA
         L     R15,VCONAST         GET ADDRESS OF ASTERISK     @YL026YA
*                                  ROUTINE                     @YL026YA
         BALR  R14,R15                                         @YL026YA
         B     STARER1             * IN FIRST LEVEL - ERROR    @YL026YA
         B     STARER2             MORE THAN ONE * - ERROR     @YL026YA
         CLI   STARLEV,ZERO        OK - IS THERE AN * ?        @YL026YA
         BNE   ASTERNM             YES - CALL CIR              @YL026YA
         TM    OPTMASK2,LEVEL      NO - WAS LEVEL SPECIFIED ?  @YL026YA
         BO    LEVL1               YES - PROCESS LEVEL         @YL026YA
         TM    DSNFLAGS(R9),QUOTED NO * - IS NAME QUOTED ?     @YL026YA
         BO    DEFGO               QUOTED NAMES - CONTINUE     @YL026YA
         B     QUALNAM             UNQUOTED - QUALIFY THE NAME @YL026YA
ASTERNM  EQU   *                   * IN NAME - GET NAME LIST   @YL026YA
*   SET UP TO CALL CIR                                         @YL026YA
         L     R15,VCONCIR
         BALR  R8,R15
         B     LEVL1
         B     GOWRT
LEVL1    TM    OPTMASK2,CATALOG    WAS CATALOG NAME GIVEN?     @YL026YA
         BO    CATOK               YES - ALREADY SET UP        @YL026YA
*                                  NO - USE DATASET PASSWORD   @YL026YA
         LH    R2,PWLEN(R9)        LENGTH OF PASSWORD          @YL026YA
         LA    R3,PWRDADDR(R9)     ADDRESS OF PASSWORD         @YL026YA
         BCTR  R2,R0               DECREMENT LENGTH FOR MOVE   @YL026YA
         LTR   R2,R2               CHECK FOR POSITIVE NO.      @YL026YB
         BNP   CATOK               NO,GOTO CATOK               @YL026YB
         LA    R7,CIRPASS          ADDRESS OF PASSWORD BUFFER  @YL026YA
         EX    R2,MOVE             MOVE THE PASSWORD           @YL026YA
CATOK    EQU   *                                               @YL026YA
         MVI   CIRDSN,BLANK        CLEAR DSNAME BUFFER         @YL026YA
         MVC   CIRDSN+D1(L'CIRDSN-L1),CIRDSN                   @YL026YA
         LA    R7,CIRDSN           ADDRESS OF CIR DSNAME       @YL026YA
*                                  BUFFER                      @YL026YA
         TM    OPTMASK2,LEVEL      WAS LEVEL SPECIFIED ?       @YL026YB
         BNO   NOLEV               NO, PROCESSING '*' NAME     @YL026YB
         LA    R3,TEMPNAME         POINT TO DATASET NAME       @YL026YB
         LH    R2,CURNTNAM         LOAD LENGTH OF NAME         @YL026YB
         EX    R2,MOVE             MOVE NAME TO BUFFER         @YL026YB
         B     CALLCIR             GO TO CIR                   @YL026YB
*                                                              @YL026YB
NOLEV    LA    R3,TEMPNAME         POINT TO DATA SET NAME      @YL026YA
         L     R2,STARADR          POINT TO ASTERISK           @YL026YA
         SR    R2,R3               ASTERISK DISPLACEMENT       @YL026YA
         BCTR  R2,R0               DECREMENT FOR EX INST.      @YL026YB
         EX    R2,MOVE             MOVE THE NAME TO CIR NAME   @YL026YA
*                                    BUFFER                    @YL026YA
*   SAVE THE TRAILING QUALIFIERS FOR LATER COMPARISON.         @YL026YA
*                                                              @YL026YA
         LA    R2,2(R2)           LENGTH OF NAME TO ASTERISK  @YL026YA
         CH    R2,CURNTNAM         COMPARE TO LENGTH OF NAME   @YL026YA
*   IF LENGTHS ARE EQUAL THE ASTERISK IS IN THE LAST POISITION @YL026YA
*   OF THE NAME AND THE TRAILING QUALIFIER IS STORED AS        @YL026YA
*   BLANKS; OTHERWISE, SAVE THE TRAILING QUALIFIER.            @YL026YA
         BNE   SAVEQUAL            ASTERISK NOT IN LAST LEVEL  @YL026YA
         SR    R0,R0               CLEAR REG ZERO              @YL026YB
         STH   R0,LASTQLEN         LENGTH IS ZERO              @YL026YA
         BCTR  R2,R0              DECREMENT FOR EX INST.       @YL026YB
         MVI   LASTQUAL,BLANK      BLANKS FOR TRAILING QUAL.   @YL026YA
         MVC   LASTQUAL+D1(L'LASTQUAL-L1),LASTQUAL             @YL026YA
         B     CALLCIR             GO GET LIST OF NAMES        @YL026YA
SAVEQUAL EQU   *                                               @YL026YA
         LH    R4,CURNTNAM         LENGTH OF NAME              @YL026YA
         SR    R4,R2               LENGTH OF NAME AFTER *      @YL026YA
         LA    R3,D0(R3,R2)        ADDRESS OF TRAILING PART    @YL026YA
*                                  OF NAME                     @YL026YA
         STH   R4,LASTQLEN         SAVE LENGTH                 @YL026YA
         BCTR  R4,R0               DECREMENT FOR MOVE          @YL026YA
         LA    R7,LASTQUAL         ADDRESS OF LAST QUALIFIER   @YL026YA
         EX    R4,MOVE             MOVE THE TRAILING QUALIFIER @YL026YA
         BCTR  R2,R0               DECREMENT TO ELIMINATE *    @ZA05439
CALLCIR  EQU   *                                               @YL026YA
*   NOW GET A LIST OF NAMES FROM CIR                           @YL026YA
         STH   R2,0(R13)                                       @YL026YB
         L     R15,CIRADDR         ADDRESS OF IKJEHCIR         @YL026YA
         LA    R1,CIRPARM          ADDRESS OF PARAMETER LIST   @YL026YA
         CALL  (15)                GO TO CIR                   @YL026YA
         LTR   R15,R15             TEST RETURN CODE            @YL026YA
         BNZ   CIRERROR            NON-ZERO IS ERROR           @YL026YA
         ST    R9,PARSPTR          SAVE PTR TO PARSE DSNAME    @YL026YA
         L     R9,CIRWA            GET ADDR OF CIR RETURN AREA @YL026YA
         LA    R9,D4(R9)           POINT TO FIRST TYPE/DSNAME  @YL026YA
NAMELOOK EQU   *                                               @YL026YA
*   NO ENTRY-TYPE CHECKING HERE YET.                           @YL026YA
         LA    R9,D1(R9)           POINT TO NEXT DSNAME        @YL026YA
         OI    PROCNM,CIRLIST      INDICATE PROCESSING CIR NAME
         TM    OPTMASK2,LEVEL      WAS LEVEL SPECIFIED?        @YL026YA
         BO    NAMEMOVE            YES - PROCESS EVERY NAME    @YL026YA
*                                  NO - TEST QUALIFIERS        @YL026YA
         MVC   NAMEBUFF,CIRDSN     MOVE PARTIAL NAME TO BUFFER @YL026YA
*   MOVE ONE QUALIFIER                                         @YL026YA
         LA    R3,D8               INITIALIZE LOOP INDEX TO    @YL026YA
*                                  COUNT 8 CHARACTERS          @YL026YA
         LA    R4,NAMEBUFF         ADDRESS OF NAME BUFFER      @YL026YA
         LH    R2,0(R13)           GET LENGTH OF NAME          @YL026YB
         LR    R1,R2               SAVE LENGTH
         LA    R2,D0(R4,R2)        END OF PARTIAL NAME         @YL026YA
         LR    R5,R9               POINT TO FIRST CHARACTER OF @YL026YA
*                                  DATA SET NAME               @YL026YA
         LA    R5,D0(R5,R1)        POINT TO QUALIFIER IN       @YL026YA
*                                  ASTERISK POSITION           @YL026YA
LOOPCHAR EQU   *                                               @YL026YA
         CLI   D0(R5),BLANK        IS IT A BLANK ?             @YL026YA
         BE    ENDNAME             YES - END OF NAME - QUIT    @YL026YA
         CLI   D0(R5),PERIOD       OR A PERIOD ?               @YL026YA
         BE    ENDNAME             YES - END OF QUALIFIER      @YL026YA
         MVC   D0(L1,R2),D0(R5)    MOVE THE CHARACTER          @YL026YA
         LA    R5,D1(R5)           LOOK AT NEXT CHARACTER      @YL026YA
         LA    R2,D1(R2)           LOOK AT NEXT CHARACTER      @YL026YA
         BCT   R3,LOOPCHAR         LOOP UNTIL 8 CHARACTERS     @YL026YA
*                                  HAVE BEEN MOVED             @YL026YA
ENDNAME  LH    R4,LASTQLEN         LENGTH OF TRAILING QUALIFIERS
         LA    R4,D0(R4,R1)        PLUS LENGTH SO FAR          @YL026YA
         LA    R3,MAXDSN           MAX LENGTH OF NAME          @YL026YA
         CR    R4,R3               IS NAME TOO LONG?           @YL026YA
         BH    NAMERR              YES - PUT OUT MESSAGE       @YL026YA
         LH    R1,LASTQLEN         NO - GET LENGTH OF QUALS.   @YL026YA
         LTR   R1,R1               IS LENGTH ZERO?             @YL026YA
         BZ    NOQUAL              YES - NO QUALIFIER          @YL026YA
         BCTR  R1,R0               DECREMENT LENGTH FOR MOVE   @YL026YA
         LR    R7,R2               WHERE TO MOVE               @ZA05439
*                                  (AFTER PARTIAL NAME)        @YL026YA
         LA    R3,LASTQUAL         ADDRESS OF TRAILING QUALS   @YL026YA
         EX    R1,MOVE             MOVE IN TRAILING QUALIFIERS @YL026YA
NOQUAL   CLC   NAMEBUFF,D0(R9)     IS THIS THE NAME            @YL026YA
*                                  RETURNED BY CIR ?           @YL026YA
         BE    NAMEMOVE            YES - USE IT                @YL026YA
*   LOOK AT NEXT NAME                                          @YL026YA
NEXTCIR  EQU   *                                               @YL026YA
         LA    R9,MAXDSN(R9)       STEP PAST NAME              @YL026YA
         L     R7,CIRWA            GET ADDRESS OF WORK AREA    @YL026YA
         LH    R3,D2(R7)           GET WORK AREA LENGTH        @YL026YA
         LA    R7,D0(R7,R3)        ADDRESS OF END OF WORK AREA @YL026YA
         CR    R9,R7               IS NEXT NAME OUT OF WORK AREA?
         BL    NAMELOOK            NO - DO NEXT NAME FROM LIST @YL026YA
         XC    PROCNM,PROCNM       NO MORE NAMES - GO BACK TO  @YL026YA
*                                  DSLIST                      @YL026YA
         L     R9,PARSPTR          RESTORE DSLIST ADDRESS      @YL026YA
         B     DSNTEST             PROCESS NEXT NAME           @YL026YB
*   MOVE NAME TO CURNTNAM AND MESSAGE BUFFER                   @YL026YA
NAMEMOVE EQU   *                                               @YL026YA
         MVC   TEMPNAME,D0(R9)     MOVE NAME TO BUFFER         @YL026YA
         MVC   MSGNAME,D0(R9)      MOVE NAME TO MESSAGE BUFFER @YL026YA
         LA    R2,MAXDSN           MAXIMUM LENGTH OF NAME      @YL026YA
BLNKCT   LA    R3,TEMPNAME         ADDRESS OF NAME             @YL026YA
         LA    R3,D0(R3,R2)        ADDRESS OF NEXT CHARACTER   @YL026YA
         CLI   D0(R3),BLANK        IS THIS CHARACTER BLANK?    @YL026YA
         BNE   BLNKEND             NO - STORE LENGTH OF NON-   @YL026YA
*                                  BLANK NAME                  @YL026YA
         BCT   R2,BLNKCT           YES - LOOP UNTIL NON-BLANK  @YL026YA
*                                  CHARACTER FOUND             @YL026YA
BLNKEND  STH   R2,CURNTNAM         LENGTH OF NON-BLANK NAME    @YL026YA
         STH   R2,MSGNAMEL         TO BOTH BUFFERS             @YL026YA
         B     DEFGO               PROCESS THIS NAME            ZA02173
*                                                              @YL026YA
*   ERROR ROUTINES                                             @YL026YA
*                                                              @YL026YA
CIRERROR EQU   *                                               @YL026YA
         LA    R8,DSNTEST1           GOTO WRAPUP ROUTINE       @VS06783
         ST    R8,RETADDR          SAVE WRAPUP ADDRESS         @YL026YB
         MVI   ERR1,MSG20          MESSAGE 20 (NOT IN CATALOG) @VS06783
         B     MCOMMON3            INSERT DATA SET NAME IN MSG @YL026YA
STARER1  EQU   *                                               @YL026YA
         LA    R8,DSNTEST1         GOTO WRAPUP ROUTINE         @VS06783
         ST    R8,RETADDR          SAVE WRAPUP ROUTINE         @YL026YB
         MVI   ERR1,MSG18          INVALID USE OF ASTERISK     @YL026YA
         MVI   ERR2,SECMSG21       NOT ALLOWED IN FIRST LEVEL  @YL026YA
         B     MCOMMON3            GO PUT OUT MESSAGE          @YL026YA
STARER2  EQU   *                                               @YL026YA
         LA    R8,DSNTEST1         GOTO WRAPUP ROUTINE         @VS06783
         ST    R8,RETADDR          SAVE WRAPUP ADDRESS         @YL026YB
         MVI   ERR1,MSG18          INVALID USE OF ASTERISK     @YL026YA
         MVI   ERR2,SECMSG22       MORE THAN ONE NOT ALLOWED   @YL026YA
         B     MCOMMON3            GO PUT OUT MESSAGE          @YL026YA
LEVELER  EQU   *                                               @YL026YA
         LA    R8,WRAPUP           GOTO WRAPUP ROUTINE         @YL026YB
         ST    R8,RETADDR          SAVE WRAPUP ADDRESS         @YL026YB
         MVI   RETCODE+3,RT12      SET RETURN CODE             @ZA01485
         MVI   ERR1,MSG17          NO DSLIST WITH LEVEL        @YL026YA
         B     GOWRT               GO PUT OUT MESSAGE          @YL026YA
NAMERR   EQU   *
*
*   MEMBER NAME SPECIFIED ALONE--ERROR SINCE THIS ROUTINE IS UNABLE
*   TO DETERMINE THE FULLY QUALIFIED NAME DESIRED.
*
         LH    R1,MEMLEN(R9)       GET LENGTH OF MEMBERNAME
         L     R3,MEMADDR(R9)      GET ADDR OF MEMBERNAME
         STH   R1,CURNTNAM         SAVE LENGTH
         BCTR  R1,R0               DECREMENT FOR EX OF MOVE
         LA    R7,TEMPNAME         AREA TO HOLD MEMBERNAME
         EX    R1,MOVE             MOVE NAME TO AREA
         MVI   ERR1,MSG07          MESSAGE 7
         B     RETCOM2             FILL IN REST OF MSG
*  NOW STRIP OFF USERID AND SAVE DATA SET NAME FOR MESSAGES      A42337
DEFOK    L     R3,UPTPTR           POINT TO UPT                @YL026YB
         USING UPT,R3              ADDRESSABILITY PSCB           A42337
         SR    R1,R1               CLEAR REGISTER                A42337
         IC    R1,UPTPREFL         USERID LENGTH                 A42337
         LA    R1,D1(R1)           PLUS ONE FOR PERIOD           A42337
         DROP  R3                  PSCB NO LONGER NEEDED         A42337
         LH    R2,CURNTNAM         LENGTH OF QUALIFIED DSNAME    A42337
         LA    R7,MSGNAME          DATA SET NAME MESSAGE BUFFER  A42337
         LA    R3,TEMPNAME         QUALIFIED DATA SET NAME       A42337
         SR    R2,R1               MINUS USERID LENGTH           A42337
         STH   R2,MSGNAMEL         SAVE DATA SET NAME LENGTH     A42337
         AR    R3,R1               POINT PAST USERID             A42337
         BCTR  R2,R0               DECREMENT FOR EXECUTE         A42337
         EX    R2,MOVE             MOVE DATA SET NAME            A42337
DEFGO    MVC   CONTROL,OPTMASK     INITIALIZE CONTROL BYTE       A42337
         NI    ALLOCSW,ZERO        TURN OFF ALLOCATE SWITCH
         L     R1,$RETRY0+R9*L4    GET PTR TO PDE              @ZA06144
         TM    MEMFLAG(R1),ON      SEE IF MEM NAME WAS GIVEN   @ZA06144
         BNO   MAIN00              SKIP TURNING ON SWITCH
         OI    CONTROL,MEMNAME     TURN ON MEMBER INDICATOR
MAIN00   EQU   *
         LH    R1,CURNTNAM         GET LENGTH OF NAME
         LA    R3,TEMPNAME         POINT AT NAME TO MOVE
         BCTR  R1,R0               DECREMENT LENGTH FOR EX OF MOVE
         LA    R7,OUTBUF
         EX    R1,MOVE             MOVE DSNAME TO BUFFER
         LA    R14,D1(R7,R1)       POINT AT END OF NAME
         BAL   R8,WRITE            GO WRITE THE NAME.
*
*  ISSUE VSAM LOCATE ON THE GIVEN NAME                         @YL026YA
*                                                              @YL026YA
*  FIRST BUILD CPL AND WORKAREA                                @YL026YA
         XC    CPLAREA,CPLAREA     CLEAR AREA FOR CPL          @YL026YA
         LA    R1,CPLAREA          ADDRESSABILITY FOR CPL      @YL026YA
         USING CTGPL,R1                                        @YL026YA
         OI    CTGOPTN1,CTGNAME+CTGCNAME 44-BYTE ENTRY NAME    @YL026YA
*                                  AND CATALOG NAME            @YL026YA
         OI    CTGOPTN3,CTGLOC+CTGAM0 SET FUNCTION TO          @YL026YA
*                                  VSAM LOCATE                 @YL026YA
         LA    R2,TEMPNAME         POINT TO 44-BYTE ENTRY NAME @YL026YA
         ST    R2,CTGENT           STORE NAME ADDRESS IN CPL   @YL026YA
         LA    R2,CATBUFF          POINT TO 44-BYTE CATALOG NAME
         ST    R2,CTGCAT           STORE NAME ADDRESS IN CPL   @YL026YA
         LA    R2,CATWORK1         POINT TO WORKAREA           @YL026YA
         ST    R2,CTGWKA           STORE ADDRESS IN CPL        @YL026YA
         LA    R2,L'CATWORK1       SET WORKAREA LENGTH         @YL026YA
         STH   R2,CATWORK1         IN FIRST HALFWORD OF AREA   @YL026YA
LOCBUILD EQU   *                                               @YL026YA
         TM    OPTMASK2,CATALOG    WAS CATALOG SPECIFIED?      @YL026YA
         BO    CATPSWD             YES - GET CATALOG PASSWORD  @YL026YA
         XC    CTGCAT,CTGCAT       CLEAR CAT.NAME PTR
         L     R2,PDSLIST+PWRDADDR NO - GET DSNAME PASSWORD    @YL026YA
         B     PSWDST                                          @YL026YA
CATPSWD  LA    R2,CIRPASS          CATALOG PASSWORD            @YL026YA
PSWDST   ST    R2,CTGPSWD          STORE ADDRESS IN CPL        @YL026YA
*                                                              @YL026YA
*  NOW BUILD THE FPL'S                                         @YL026YA
*                                                              @YL026YA
         USING CTGFL,R2                                        @YL026YA
         LA    R2,CTGFL1           POINT TO FIRST FPL          @YL026YA
         LA    R3,D1               ONE FIELD                   @YL026YA
         LA    R4,ENTYPE           POINT TO FIRST FIELD        @YL026YA
         LA    R7,CTGFIELD         POINT TO FIRST CPL SLOT     @YL026YA
         TM    OPTMASK,HISTORY     WAS HISTORY SPECIFIED?      @YL026YA
         BNO   NOHIST              NO - SKIP DATES             @YL026YA
         LA    R5,D8               8 FPLS IF HISTORY OPTION    @YL026YA
         STC   R5,CTGNOFLD         NO. OF FPLS                 @YL026YB
         B     FPLLOOP             GO BUILD FPL                @YL026YA
NOHIST   LA    R5,D6               6 FPLS IF NO HISTORY        @YL026YA
         STC   R5,CTGNOFLD         NO. OF FPLS                 @YL026YB
FPLLOOP  EQU   *                                               @YL026YA
         ST    R2,D0(R7)           STORE FPL ADDRESS IN CPL    @YL026YA
         XC    D0(CTGFL2-CTGFL1,R2),D0(R2) CLEAR FPL AREA      @YL026YA
         STC   R3,CTGFLDNO         STORE FIELD COUNT           @YL026YA
         ST    R4,CTGFLDNM         STORE FIELD NAME            @YL026YA
         LA    R2,CTGFL2-CTGFL1(R2)  POINT TO NEXT FPL         @YL026YA
         LA    R4,D8(R4)           POINT TO NEXT FIELD NAME    @YL026YA
         LA    R7,L'CTGFIELD(R7)   POINT TO NEXT SLOT IN CPL   @YL026YA
         BCT   R5,FPLLOOP          GO DO NEXT FPL              @YL026YA
*  ISSUE LOCATE                                                @YL026YA
         DROP  R1                                              @YL026YA
         DROP  R2                                              @YL026YA
         CATLG (1)                                             @YL026YA
******* RETURN FROM LOCATE IS NOT ANALYZED IN DETAIL AND NO
*       MESSAGE IS PUT OUT IF A NON ZERO RETURN CODE IS
*       RECEIVED . THIS IS BECAUSE ALLOCATE WILL BE ISSUED
*       AND A MESSAGE PUT OUT THEN
*
         LTR   R15,R15             RETURN CODE ZERO SKIP ALLOCATE
         BZ    TESTTYPE            GO TEST DATA SET TYPE       @YL026YA
*
*
*  ALL VSAM DATA SETS ARE CATALOGUED,THEREFORE THIS MUST BE    @VS06171
*  A NONVSAM DATA SET.                                         @VS06171
NONVSAM  EQU   *                                               @ZA09142
         MVI   DSTYPE,CTGTALIN     FORCE NONVSAM DSTYPE        @VS06171
***********************************************************************
*
*   A NONZERO RETURN CODE FROM LOCATE INDICATES ONLY THAT THE DSNAME
*   INFORMATION COULD NOT BE GOTTEN FROM THE CATALOG. NONE OF THE
*   RETURN CODES CONCLUSIVELY ELIMINATES THE POSSIBILITY OF THE DATA
*   SET EXISTING AND BEING ACCESSIBLE THROUGH DAIR, SO AN INFORMATIVE
*   MESSAGE IS PUT OUT INDICATING THAT THE DATASET COULD NOT BE
*   ACCESSED THROUGH THE CATALOG AND THEN DAIR IS LINKED TO.
*
*
***********************************************************************
***********************************************************************
*
*
*    INTERFACE WITH DAIR, CODE X'08'. GET DDNAME FROM RETURNED LIST
*    AND PUT INTO DCB SO RDJFCB CAN BE ISSUED.
*
*
*
*
***********************************************************************
         BAL   R8,ALLOCDS          GO ALLOCATE THE DATA SET    @YL026YA
         TM    ALLOCSW,ON          ALLOCATE OKAY
         BO    ACODE00             GO READ JFCB
         B     DSNTEST             GET NEXT DSNAME
*
         EJECT                                                 @YL026YA
IKJEHALC DS    0H                                              @YL026YA
ALLOCDS  DS    0H                                              @YL026YA
***********************************************************************
*                                                              @YL026YA
*        THIS IS A COMMON ROUTINE THAT TAKES THE CURRENT DSNAME AND
*        ALLOCATES IT BY GOING TO DAIR AT ENTRY X'08'.         @YL026YA
*                                                              @YL026YA
***********************************************************************
*                                                              @YL026YA
         ST    R8,RETADDR          SAVE CALLERS ADDRESS        @YL026YA
*                                                              @YL026YA
*                                                              @YL026YA
ALLOCDS1 EQU   *                   ENTRY FROM RETRY            @YL026YA
         LA    R2,DAIRLIST         SET UP USE OF DSECT         @YL026YA
         USING DAPB08,R2           USE DSECT HERE              @YL026YA
*                                                              @YL026YA
         XC    DAPB08(DAIR08LN),DAPB08 ZERO PARM BLOCK         @YL026YA
         MVI   DA08DDN,BLANK       BLANK-                      @YL026YA
         MVC   DA08DDN+D1(L23),DA08DDN DDNAME, UNIT NAME, AND VOLSER
         MVC   DA08MNM(L16),DA08DDN ALSO MEMBER NAME AND PASSWORD
         MVI   DA08DSP1,DA08SHR    SET DISPOSITION OF KEEP     @YL026YA
         MVI   DA08CD+D1,DAIR08    SET ENTRY CODE              @YL026YA
         LA    R1,CURNTNAM                                     @YL026YA
         ST    R1,DA08PDSN         PTR TO CURRENT DSNAME       @YL026YA
*                                                              @YL026YA
         TM    PWFLAG(R9),HIGHBIT  TEST FOR PASSWORD           @YL026YA
         BZ    GODAIR              IF NONE GO TO DAIR          @YL026YA
         LH    R1,PWLEN(R9)        GET LENGTH OF PASSWORD      @YL026YA
         L     R3,PWOFF(R9)        GET ADDRESS OF PASSWORD     @YL026YA
         LA    R7,DA08PSWD         POINT AT PASSWORD SLOT OF DAIRLIST
         BCTR  R1,R0               DECREMENT BY ONE            @YL026YA
         EX    R1,MOVE             MOVE PASSWORD TO LIST       @YL026YA
        DROP  R2                                               @YL026YA
*                                                              @YL026YA
GODAIR   BAL   R8,MEMDAIR          LINK TO DAIR                @YL026YA
ALLOCCHK LTR   R15,R15                                         @YL026YA
         BNZ   ALLOCERR            ALLOCATE ERROR              @YL026YA
*                                                              @YL026YA
**********************************************************************
         OI    ALLOCSW,ON                                      @YL026YA
         NI    FIRSTIME,ZERO       TURN OFF FIRSTIME SWITCH    @YL026YA
ALLOCEND EQU   *                                               @YL026YA
         L     R8,RETADDR          RETURN TO CALLER            @YL026YA
         BR    R8                  RETURN                      @YL026YA
**********************************************************************
         EJECT                                                 @YL026YA
MEMDAIR  EQU   *                                               @YL026YA
*                                                              @YL026YA
         LA    R1,PUTLLIST         POINT TO PARM LIST            100000
         USING DAPL,R1             DAPL DSECT                    100000
         L     R2,UPTPTR           UPT POINTER TO-               100000
         ST    R2,DAPLUPT          DAIR PARM LIST                100000
         L     R2,ECTPTR           ECT POINTER TO-               100000
         ST    R2,DAPLECT          DAIR PARM LIST                100000
         L     R2,ECBPTR           ECB POINTER TO-               100000
         ST    R2,DAPLECB          DAIR PARM LIST                100000
         L     R2,PSCBPTR          PSCB POINTER TO-              100000
         ST    R2,DAPLPSCB         DAIR PARM LIST                100000
         LA    R2,DAIRLIST         DAIR PARM BLOCK POINTER-      100000
         ST    R2,DAPLDAPB         TO DAIR PARM LIST             100000
         DROP  R1                  DAPL NO LONGER NEEDED         100000
         LINK  EP=IKJDAIR,MF=(E,(1))                           @YL026YA
         BR    R8                   RETURN TO CALLER           @YL026YA
*                                                              @YL026YA
         EJECT                                                 @YL026YA
**********************************************************************
*                                                                    *
*    ALLOCERR ROUTINE ANALYZES NON ZERO RETURN CODES FROM ALLOCATION *
*    THIS ROUTINE IS PART OF THE ALLOCDS CLOSED SUBROUTINE           *
*                                                                    *
**********************************************************************
ALLOCERR LA    R2,DAIRLIST         SET UP ADDRESSABILITY
         USING DAPB08,R2           USING MAP MACRO
         CLM   R15,B1,RC16         RC GREATER THAN X'10'?       ZA00612
         BH    ACODE04             YES, ANALYZE THE DAIR ERROR  ZA00612
         B     ALCCODE(R15)        CHECK RETURN CODE
*
ALCCODE  B     ACODE00             SUCCESS
         B     ACODE04             INVALID PARM LIST
         B     ACODE08             NO ENTRIES AVAILABLE
         B     ACODE12             DDNAME REQUESTED IS IN USE
         B     ACODE16             ALLOCATION FAILED
*
ACODE04  EQU   *
         MVI   ERR1,MSG13          COMMAND SYSTEM ERROR
         MVI   ERR2,SECMSG20       DAIR ERROR CODE
         LR    R6,R15              SAVE RETURN CODE
         BAL   R8,CVDREG15         CONVERT CODE RTN
         B     GOWRT               GO WRITE
*
ACODE08  EQU   *
*********RETURN CODES OF 4 8 12 16 AND 28 ARE VALID ONLY ******
         CLI   DA08CTRC+D1,D4      RC =  4 VOL NOT AVAIL
         BE    CTRC4               PUT OUT MSG
         CLI   DA08CTRC+D1,RC28    RC 28 CAT I/O ERROR
         BE    CTRC28              PUT OUT MSG
******IF NOT ABOVE  USE CATCH ALL DS NOT IN CATLG*********
         MVI   ERR1,MSG01          DSNAME NOT IN CATLG
         B     MCOMMON3            INSERT DSNAME IN MSG
CTRC4    MVI   ERR2,SECMSG10       VOL NOT ON SYSTEM
         MVI   ERR1,MSG10          DS NOT ALLOCATED
         B     MCOMMON3            INSERT NAME AND PUT OUT MSG
CTRC28   MVI   ERR2,SECMSG19       CATALOG I O ERROR
         MVI   ERR1,MSG11          DS NOT ALLOC MSG SYSTEM ERROR
         B     MCOMMON3            INSERT NAME AND PUT OUT MSG
ACODE12  EQU   *
*
*    THE FOLLOWING CODE BREAKS OUT SPECIFIC DARC CODES
*    AFTER CERTAIN RETURN CODES ARE COMPARED FOR A
*    COMMON ERROR CODE IS PUT OUT
*
         LH    R1,DAIRLIST+D4      LOAD DARC CODE
         CH    R1,C210
         BE    M210                DYNAMIC ALLOCATION RC = 210
         CH    R1,C218
         BE    M218                DYNAMIC ALLOCATION RC = 218
**********  THIS RTN CONVERTS THE HEX RC FROM DAIR  ************
****** AND PUTS OUT THE FIRST AND SECOND LEVEL MSG PARMS ******
         MVI   ERR2,SECMSG03       DYNAM ALLOC ERROR
         MVI   ERR1,MSG11          SYSTEM ERROR
HEX      LA    R5,ERRINSRT         PUT ADDRESS OF INSERT
         ST    R5,ERRINST2         INTO INSERT SLOT
         LA    R4,DA08DARC         POINT TO DATA
MCOM4    EQU   *
         LA    R5,D2               NUMBER OF BYTES TO CONVERT
         LA    R7,ERRINSRT+D1      POINT TO OUTPUT BUFFER
         L     R10,VCONLABL        ADDRESSABILITY FOR BITOHEX
         L     R15,VCONBTHX        ADDRESS OF BITOHEX
         BALR  R8,R15              GO CONVERT HEX CODE
         CLI   ERRINSRT+D1,ZONE    GET RID OF LEADING ZERO
         BNE   ENDHEX              IF ANY
         MVI   ERRINSRT+D1,BLANK   BLANK LEADING ZERO
ENDHEX   MVI   ERRINSRT,FOURB      LENGTH OF TEXT
         B     MCOMMON3            PUT OUT MSG AND INSERT
*
         DROP  R2
*
M210     MVI   ERR2,SECMSG15       DATA SET ALLOCATED TO OTHER USER
         MVI   ERR1,MSG12          MESSAGE 12
         B     MCOMMON2            FILL IN REST OF MSG
M218     MVI   ERR2,SECMSG13       VOL NOT ON SY8STEM
         MVI   ERR1,MSG10          MESSAGE 10
*
RETCOM2  EQU   *
MCOMMON2 EQU   *                   COMMON MESSAGE SEGMENT
MCOMMON3 LA    R1,MSGNAMEL+D1      GET ADDRESS OF NAME           A42337
         ST    R1,ERRINST1
GOWRT    BAL   R8,ERROUT           GO WRITE
         B     DSNTEST             SEE IF MORE DSNAMES          ZA01264
ACODE16  EQU   *
*
         TM    FIRSTIME,ONE        FIRST ATTEMPT TO ALLOCATE
         BNO   UNALLOC             NO THEN UNALLOCATE BY TCB
NODYNAM  NI    OPTMASK,FOXES-MEMBERS   TURN OFF MEM OPTION
*
         MVI   ERR2,SECMSG11       USE FREE COMMAND
         MVI   ERR1,MSG08          MESSAGE 8                     A46800
         B     MCOMMON2            FILL IN REST OF MSG
*                                                                    *
**********************************************************************
*
UNALLOC  EQU   *
         MVI   FIRSTIME,ONE        SET ON TO PREVENT ALLOC LOOP
         LA    R1,DAIRLIST
         USING DAPB2C,R1
         XC    DAPB2C(DAIR2CLN),DAPB2C ZERO PARM BLOCK
         MVI   DAPB2C+D1,DAIR2C    MOVE IN ENTRY CODE
         L     R2,CVTPTR                ADDR OF CVT
         USING CVTTCBP,R2               USE MAP MACRO
         L     R3,CVTTCBP               POINTER TO TCB
         L     R2,TCBOFF(R3)            ADDR OF CURRENT TCB
         ST    R2,DA2CTCB               STORE IN LIST
         DROP  R1
         DROP  R2
         BAL   R8,MEMDAIR               SET UP DAIR PARAMETERS AND LINK
         B     ALLOCDS1            GO ALLOCATE
*
**********************************************************************
**********************************************************************
         EJECT                                                 @YL026YA
*
ACODE00  EQU   *
         OI     ALLOCSW,ON         TURN ON ALLOC SWITCH
         LA    R2,OBTDCB
         USING IHADCB,R2
         MVC   DCBDDNAM(D8),DAIRLIST+D12  PUT DDNAME IN DCB
         DROP  R2
         LA    R1,RDJL             ADDR OF RDJFCB IN DSECT
         LA    R3,OBTDCB           ADDR OF THE DCB IN THE DSECT
         RDJFCB ((R3)),MF=(E,(R1))
*
*
         LA    R3,JFCBVOLS         ADDR OF VOLID FROM JFCB
         ST    R3,OBTVOL
*
*
         OI    CONTROL,JFCB        INDICATE RDJFCB ISSUED
         B     MAIN01              GO ISSUE OBTAIN WITH VOLID JFCB
TESTTYPE EQU   *                   TEST ENTRY TYPE FOR NON-VSAM
         USING CTGFL,R3                                        @YL026YA
         OI    CONTROL,LOCATE      INDICATE LOCATE OK
         LA    R3,CTGFL1           ADDRESSABILITY FOR ENTRY    @YL026YA
*                                  TYPE FPL                    @YL026YA
         L     R3,CTGFLPT          ADDRESS OF ENTRY TYPE       @YL026YA
         MVC   DSTYPE,D0(R3)       SAVE TYPE CODE              @YL026YA
         CLI   DSTYPE,CTGTALIN     IF TYPE IS NOT NONVSAM,     @YL026YA
         BNE   VSAMBSC             PROCESS AS VSAM CLUSTER     @YL026YA
         NI    CONTROL,FOXES-LOCATE TURN OFF SUCESS. LOCATE    @ZA09142
         B     NONVSAM             GO PROCESS AS NON-VSAM      @ZA09142
MAIN01   EQU   *
         LA    R3,OBTDSNAM         GET DSNAME ADDRESS
         ST    R3,OBTDSN           STORE IN OBTAIN LIST
         LA    R3,OBTWORKA         WORK AREA ADDRESS
         ST    R3,OBTWKA           PUT IN LIST
         MVC   OBTCLST(D4),CLSTMDL   INITIALIZE OBTAIN CAMLST
*
*
         OBTAIN                    OBTCLST
         LA    R1,D4               REG 1 = 4
         CR    R15,R1              IS RETURN CODE = 4
         BL    OBTOK               RC = 0 IS OK
         BH    OBTERR              OBTAIN ERROR
         MVI   ERR2,SECMSG13       SECOND LEVEL MESSAGE 13
         B     STSECND             FILL IN REST OF MSG
OBTERR   EQU   *
         LR    R6,R15              SAVE RETURN CODE
         BAL   R8,CVDREG15         CONVERT RETURN CODE
         MVI   ERR2,SECMSG02       SECOND LEVEL MESSAGE 2
STSECND  MVI   ERR1,MSG02          MESSAGE 2
         BAL   R8,ERROUT             PUT OUT MSG
DSNTEST  DS    0H
         NI    ALLOCSW,ZERO        TURN OFF ALLOC SWITCH
         TM    PROCNM,CIRLIST      WAS NAME FROM CIR?
         BNO   DSNTEST1            NO,PROCESS NORMALLY
         B     NEXTCIR             PROCESS NEXT CIR ENTRY
*
*
***********************************************************
DSNTEST1 CLI   CHAINAD(R9),FOXES    TEST FOR END OF CHAIN
         BE    WRAPUP              NO, NORMAL TERMINATION.
         L     R9,CHAINAD(R9)      PICK UP ADDRESS OF NEXT PDE
         B     NXDSNAME            SCAN NEXT DSNAME
**********************************************************
WRAPUP   EQU   *
WRAPUP01 EQU   *
*
* NOW CHECK IF AN ERROR HAS OCCURRED.  IF SO, THE STACK MUST BE
*  FLUSHED AND THE INPUT QUEUE CLEARED.
         CLI   STACKSW,SWON        IS STACK SWITCH ON
         BNE   STACKOK             NO ERROR, END NORMALLY
         LA    R1,UPTPTR           POINT TO I/O PARAMETER LIST
         LA    R2,STACKPRM         POINT TO STACK PARM BLOCK
         ST    R2,PUTLADDR         POINT TO STACK PARM BLOCK
         STACK DELETE=ALL,MF=(E,(1)) FLUSH STACK
         TCLEARQ INPUT             CLEAR ANYTHING TYPED AHEAD
STACKOK  EQU   *                   NORMAL RETURN FROM HERE
         L     R13,D4(R13)         RESTORE ADDRESS OF CALLERS SAVEAREA
         L     R15,RETCODE         GET RETURN CODE INTO REG 15
         RETURN                    (14,12),RC=(15) RETURN TO TMP
*
*
OBTOK    EQU   *
         MVC   DSORGSV(L'DS1DSORG),DS1DSORG  SAVE DSORG TYPE
         LA    R7,OUTBUF           BUILD HEADING FOR FIRST LINE OF
         MVC   D0(L'BASICHDG,R7),BASICHDG  OUTPUT DATA
         LA    R7,L'BASICHDG(R7)
         TM    CONTROL,HISTORY     WAS HISTORY SPECIFIED
         BNO   OBTOK01             NO, CHECK STATUS
         MVC   D0(L'HISTHDG,R7),HISTHDG  YES MOVE HEADING TO BUFFER
         LA    R7,L'HISTHDG(R7)
OBTOK01  EQU   *
         TM    CONTROL,STATUS      WAS STATUS SPECIFIED
         BNO   OBTOK02             NO, WRITE BUFFER
         LA    R8,DCBMDL           REG8 WILL BE BASE FOR CONSTANTS
         USING DCBMDL,R8           ADDRESSABILITY TO CONSTANTS
         MVC   D0(L'STATHDG,R7),STATHDG  MOVE HEADING TO BUFFER
         DROP  R8                  DROP ADDRESSABILITY TO CONSTANTS
         LA    R7,L'STATHDG(R7)
OBTOK02  EQU   *
         LR    R14,R7              POINT AT END OF BUFFER DATA
         LA    R7,OUTBUF
         BAL   R8,WRITE            WRITES OUT THE BUFFER
         L     R15,BSCVCON         ADDRESS OF BASIC INFORMATION ROUTINE
         BALR  R14,R15             GO TO BASIC ROUTINE
ENDBASIC EQU   *                                               @YL026YA
***********************************************************************
*
*   THE  FOLLOWING ROUTINE CHECKS FOR THE HISTORY AND STATUS KEYWORDS
*   AND IF SPECIFIED PASSES CONTROL TO THE RESPECTIVE KEYWORD HANDLING
*   ROUTINES.  THEN THE VOLSER INFORMATION IS PUT OUT.
*
***********************************************************************
         TM    CONTROL,HISTORY     WAS HISTORY REQUESTED
         BNO   STATCHEK            NO, CHECK STATUS
         L     R15,HISTVCON
         BALR  R14,R15             GO TO HISTORY ROUTINE
*
*
*
STATCHEK EQU   *
         TM    CONTROL,STATUS      WAS STATUS REQUESTED
         BNO   VOLROUT             NO, PUT OUT VOLUME INFORMATION
         L     R15,STATVCON        ADDRESS OF STATUS  ROUTINE
         BALR  R14,R15             GO TO STATUS ROUTINE....
VOLROUT  EQU   *
         LA    R7,OUTBUF           POINT AT BUFFER
         LA    R14,L'OUTBUF(R7)    POINT AT END OF BUFFER
         BAL   R8,WRITE            GO WRITE THE BUFFER
         LA    R8,DCBMDL           REG 8 WILL BE BASE FOR END OF PGM
         USING DCBMDL,R8           ADDRESSABILITY TO CONSTANTS
         CLI   DSTYPE,CTGTALIN     IF ENTRY IS NONVSAM,        @YL026YA
         BE    VOLALIN             WRITE VOLSER HEADING        @YL026YA
         MVC   OUTBUF(L'VSAMVHDG),VSAMVHDG  OTHERWISE,         @YL026YA
*                                  WRITE VOLSER AND BLKSIZE    @YL026YA
         LA    R14,L'VSAMVHDG(R7)  POINT TO BUFFER             @YL026YA
         B     VOLWRT              GO WRITE                    @YL026YA
VOLALIN  EQU   *                                               @YL026YA
         MVC   OUTBUF(L'VOLHDING),VOLHDING  MOVE HEADING TO BUFFER
         DROP  R8                  DROP ADDRESSABLIITY TO CONSTANTS
         LA    R14,L'VOLHDING(R7)   ADJUST POINTERS TO WRITE BUFFER
VOLWRT   EQU   *                                               @YL026YA
         BAL   R8,WRITE            WRITE THE HEADING
         TM    CONTROL,LOCATE      SEE IF LOCATE WAS SUCCESSFUL
         BO    VOLROUT2            IF YES, PROCESS VOLUME LIST
***********************************************************************
*
*   IF LOCATE WAS NOT SUCCESSFUL, THEN A RDJFCB HAD TO HAVE BEEN
*   ISSUED IN ORDER TO GET THIS FAR.
*
***********************************************************************
         LA    R3,D5               SET CTR FOR MAX NO. OF VOLSERS
         XR    R4,R4               CLEAR REGISTER
         IC    D4,JFCBNVOL         GET VOLSER COUNT
         LA    R7,OUTBUF           GET BUFFER POINTER
         LA    R1,JFCBVOLS         POINT AT FIRST VOLSER
VOLROUT1 EQU   *
         MVC   D2(L6,R7),D0(R1)    MOVE VOLSER TO BUFFER
         LA    R14,D8(R7)
         BAL   R8,WRITE            WRITE BUFFER
         BCTR  R4,R0               DECREMENT ACTUAL COUNT.
         LTR   R4,R4               SEE IF COUNT IS ZERO
         BZ    VOLEXIT             IF ZERO, ALL DONE
         LA    R1,D6(R1)           BUMP VOLSER POINTER TO NEXT ONE
         BCT   R3,VOLROUT1         DECR MAX COUNT AND BR IF NONZERO
***********************************************************************
*
*   MORE THAN 5 VOLSERS WAS INDICATED IN JFCB. CAN NOT READ JFCB
*   EXTENSION AND DATA SET IS NOT CATALOGED, SO MESSAGE MUST BE
*   WRITTEN TO TERMINAL INDICATING VOLUME LIST IS INCOMPLETE.
*
***********************************************************************
         MVI   ERR1,MSG03          COMPLETE VOL LIST NOT AVAILABLE
         MVI   ERR2,SECMSG18       JFCB EXT NOT AVAILABLE
         BAL   R8,ERROUT           GO PUT OUT ERROR MESSAGE
         B     VOLEXIT             GO PROCESS NEXT KEYWORD
VOLROUT2 EQU   *
         USING CTGFL,R3            ADDRESSABILITY FOR          @YL026YA
         LA    R3,CTGFL3           BLOCKSIZE FPL               @YL026YA
         L     R4,CTGFLPT          ADDRESS OF BLKSIZE LIST     @YL026YA
         LA    R3,CTGFL2           VOLUMES FPL                 @YL026YA
         L     R5,CTGFLPT          ADDRESS OF VOLUMES LIST     @YL026YA
         L     R3,CTGFLNG          LENGTH OF LIST              @YL026YA
         LTR   R3,R3               IS LENGTH ZERO?             @YL026YB
         BZ    VOLROUT5            YES, GOTO VOLROUT5          @YL026YB
         SR    R2,R2               CLEAR REG 2                 @YL026YB
         D     R2,VOLLEN           DIVIDE BY ENTRY LENGTH TO   @YL026YA
*                                  GET VOLUME COUNT            @YL026YA
*  COUNT NOW IN R3, ADDRESS IN R5                              @YL026YA
         DROP  R3                                              @YL026YA
VOLROUT4 EQU   *
         MVC   D2(L6,R7),D0(R5)    MOVE VOLSER TO BUFF
VOLROUT6 CLI   DSTYPE,CTGTALIN     IS THIS A NONVSAM DATA SET  @YL026YA
         BNE   VSAMDS              IF NOT PRINT BLKSIZE
         LA    R14,D8(R7)          POINT AT END OF DATA
         B     ENDBZX              GO WRITE DATA               @YL026YB
VSAMDS   EQU   *                   POINT AT END OF DATA        @YL026YA
         LA    R14,13(R7)
         LTR   R4,R4               IS REG 4 ZERO ?             @YL026YB
         BZ    ZERBLK              YES, GOTO ZERBLK            @YL026YB
         L     R1,D0(R4)           GET BLOCKSIZE VALUE         @YL026YA
         LTR   R1,R1               IS VALUE ZERO?              @YL026YA
         BZ    ZERBLK              YES, PRINT '**'             @YL026YA
         LA    R7,D10(R7)                                       ZA00105
         CVD   R1,WORKROOM         NO, CONVERT TO NUMBERS      @YL026YA
         UNPK  D0(D5,R7),WORKROOM(D8)                          @YL026YA
         OI    D4(R7),ZONE         CLEAR SIGN                  @YL026YA
BLOKLOOP EQU   *                                               @YL026YA
         CLI   D0(R7),ZONE         IS DIGIT ZERO?              @YL026YA
         BNE   ENDBSZ2             NO - END LOOP               @YL026YA
         MVC   D0(L5,R7),D1(R7)    SHIFT NUMBER TO LEFT        @YL026YA
         B     BLOKLOOP            CONTINUE CHECKING           @YL026YA
VOLROUT5 LA    R3,1                REG 3 EQUALS 1              @YL026YB
         B     VOLROUT6            GOTO VOLROUT6               @YL026YB
ZERBLK   MVC   D8(L'ASTER,R7),ASTER  MOVE '**' TO BUFFER       @YL026YA
ENDBSZ   EQU   *                   POINT TO END OF BUFFER      @YL026YA
ENDBZX   BAL   R8,WRITE            WRITE BUFFER                @YL026YB
         LA    R5,VOLENTLN(R5)     POINT AT NEXT VOLSER        @YL026YB
         BCT   R3,VOLROUT4         DECR CNT AND WRITE OUT NEXT VOLSER
VOLEXIT  EQU   *
         CLI   DSTYPE,CTGTALIN          NONVSAM DATA SET?       ZA00105
         BNE   DSNTEST                  NO, SKIP LABEL/MEM      ZA00105
         L     R15,VCONMEM         GET ADDR OF MEMBER AND      @YL026YA
*                                  LABEL PROCESSING ROUTINE    @YL026YA
         BALR  R14,R15             GO PROCESS MEMBER NAMES,    @YL026YA
*                                  LABELS, AND MEMBERS KEYWORD @YL026YA
         B     DSNTEST             GO TEST FOR ANOTHER DSNAME TO O
ENDBSZ2  LA    R8,D10                                          @ZA06146
         SR    R7,R8
         B     ENDBSZ
         EJECT                                                 @YL026YA
**** * * * * * * * * * * * * * * * * * * * *                   @YL026YA
* * * * * * * * * * * * * * * * * * * * * *                    @YL026YA
* * * *THIS RTN CONVERTS RETURN CODES * * *                    @YL026YA
* * * * * * * * * * * * * * * * * * * * *                      @YL026YA
CVDREG15 DS    0H                                              @YL026YA
         CVD   R6,ERRINSRT+D8      CONVERT TO DECIMAL          @YL026YA
         UNPK  ERRINSRT+D1(L4),ERRINSRT+ERRCOD(L3)  UNPACK TWO @YL026YA
         MVI   ERRINSRT,D2         MOVE IN LENGTH OF TWO       @YL026YA
         LA    R1,ERRINSRT         PLACE INSERT ADDRESS IN     @YL026YA
         ST    R1,ERRINST2         2ND LEVEL MESSAG SLOT       @YL026YA
         BR    R8                  RETURN TO CALLER            @YL026YA
* * * * * * * * * * * * * * * * * * * * *                      @YL026YA
* * * * * * * * * * * * * * * * * * * *                        @YL026YA
         EJECT
CIROUTN  CSECT
**********************************************************************
*                                                              @YL026YA
*   THIS ROUTINE LOADS IKJEHCIR, ACQUIRES CORE FOR THE SAVE    @YL026YA
*   AREA AND WORK AREA, AND INITIALIZES THE PARAMETER LIST.    @YL026YA
*                                                              @YL026YA
***********************************************************************
CIRINIT  SAVE  (14,12),,*
         LR    R10,R15
         USING CIRINIT,R10
         GETMAIN R,LV=SAVELEN,SP=WORKSP
         ST    R13,D4(R1)          SAVE CALLERS SAVE AREA      @YL026YB
         ST    R1,D8(R13)          SAVE THIS ROUTINE SAVE AREA
         LR    R13,R1              SAVE AREA ADDRESS           @YL026YB
         LOAD  EP=IKJEHCIR                                     @YL026YA
         ST    R0,CIRADDR          SAVE THE ROUTINE'S ADDRESS  @YL026YA
         LH    R0,CIRLEN           LENGTH OF GETMAIN AREA      @YL026YB
         LR    R3,R0               SAVE LENGTH                 @YL026YB
         O     R0,SUPPL1           SET SUBPOOL NUMBER          @YL026YB
         GETMAIN R,LV=(0)                                      @YL026YA
         LTR   R15,R15             DID GETMAIN WORK?           @YL026YA
         BNZ   NOCORE              NO - ISSUE MESSAGE          @YL026YA
         LR    R4,R1               SAVE CONTENTS FOR R1        @YL026YB
         XC    D0(CIRPMLN,R1),D0(R1) CLEAR AREA                @YL026YA
         LA    R2,CIRPMLN(R1)      SAVE AREA FOLLOWS           @YL026YA
         ST    R2,CIRSAVE          PARAMETER LIST              @YL026YA
         LA    R2,RETCD52(R2)      AFTER SAVE AREA             @YL026YA
         ST    R2,CIRWA            IS WORK AREA                @YL026YA
         SR    R4,R2               LENGTH OF PARM LIST AND SAVEAREA
         LH    R3,CIRLEN           LENGTH OF GETMAIN AREA
         AR    R3,R4               LENGTH OF CIR WORKAREA      @ZA10244
         STH   R3,D0(R2)           PUT IN LENGTH FIELD OF      @YL026YA
*                                  WORK AREA                   @YL026YA
         LA    R2,CIRDSN           ADDRESS OF DSNAME BUFFER    @YL026YA
         ST    R2,CIRSRCH          TO PARAMETER LIST           @YL026YA
         OI    CIROPT,CIROPTDS     SET OPTION BYTE             @YL026YA
         TM    OPTMASK2,CATALOG    WAS A USER CATALOG NAMED?   @YL026YA
         BNO   SKIPCAT             NO - SKIP SETUP             @YL026YA
         LA    R2,CATBUFF          POINT TO NAME               @YL026YA
         ST    R2,CIRCVOL          PUT ADDRESS IN PARAMETER LIST
         LA    R2,CIRPASS          POINT TO PASSWORD           @YL026YA
         ST    R2,CIRPSWD          PUT ADDRESS IN PARAMETER LIST
         B     BANC08
SKIPCAT  EQU   *                                               @YL026YA
         XC    CIRPSWD,CIRPSWD
         XC    CIRCVOL,CIRCVOL
BANC08   LR    R1,R13
         L     R13,D4(R1)
         FREEMAIN R,LV=SAVELEN,A=(1),SP=WORKSP
         LM    R14,R7,D12(R13)     RESTORE REGS 14 TO 7
         LM    R9,R12,D56(R13)     RESTORE REGS 9 TO 12
         BR    R8                  RETURN TO CALLER            @YL026YA
*                                                              @YL026YA
NOCORE   EQU   *                                               @YL026YA
         MVI   ERR1,MSG19          UNABLE TO DO GENERIC LOCATE @YL026YA
         MVI   ERR2,SECMSG06       NOT ENOUGH CORE             @YL026YA
         LA    R8,D4(R8)
         B     BANC08                                          @YL026YA
         EJECT                                                 @YL026YA
IKJEHBSC CSECT
***********************************************************************
*
*   THIS ROUTINE SUPPLIES THE BASIC INFORMATION THAT IS ALWAYS GIVEN
*   WITH THE LISTDS COMMAND FOR EACH SPECIFIED DATASET.  THE
*   INFORMATION THAT IS PROVIDED BY THIS ROUTINE IS AS FOLLOWS...
*     1. RECORD FORMAT (RECFM)
*     2. LOGICAL RECORD LENGTH (LRECL)
*     3. BLOCK SIZE (BLKSIZE)
*     4. DATA SET ORGANIZATION (DSORG)
*    AND BUILD THE OUTPUT DATA LINE
*
***********************************************************************
BASICRT  SAVE  (14,12),,*
         LR    R10,R15             ESTABLISH ADDRESSABILITY
         USING BASICRT,R10
         USING OBTWAD,R12          WORKAREA BASE
         GETMAIN R,LV=SAVELEN,SP=WORKSP
         ST    R13,D4(R1)          CHAIN WORKAREAS TOGETHER
         ST    R1,D8(R13)
         LR    R13,R1              NEW SAVEAREA
         LA    R7,OUTBUF           POINT AT BUFFER
         LA    R5,RECFMOFF(R7)     POSITION POINTER FOR RECFM
         LR    R3,R5               SAVE VALUE                   SA52667
         TM    DS1RECFM,UTYPE      CHECK FOR UNDEFINED
         BO    RECFMU              YES, MOVE PROPER CHARACTER TO BUFFER
         BZ    TTEST1              U, V, F NOT SPECIFIED        SA52667
*
         TM    DS1RECFM,FTYPE      CHECK FIXED
         BO    RECFMF              YES
*
RECFM    EQU   *
         MVI   D0(R5),CHARV        MOVE IN CHARACTER V
         B     TTEST               GO CHECK TRACK OVERFLOW
*
RECFMU   EQU   *
         MVI   D0(R5),CHARU        MOVE CHAR TO BUFFER FOR UNDEFINED
         B     TTEST               GO CHECK FOR TRK OVFLW
*
RECFMF   EQU   *
         MVI   D0(R5),CHARF        INDICATE FIXED
*
TTEST    EQU   *
         LA    R5,D1(R5)           INCRE BUF PTR PAST FIRST RECFM CHARA
TTEST1   TM    DS1RECFM,TOVFLOW    CHECK FOR TRACKFLOW          SA52667
         BNO   BTEST               NO, CHECK FOR BLOCKED
         MVI   D0(R5),CHART        MOVE CHARACTER TO BUFFER
         LA    R5,D1(R5)
BTEST    EQU   *
         TM    DS1RECFM,BLOCKED    CHECK BLOCKED ATTRIBUTE
         BNO   STEST               NO, CHECK STANDARD ATTRIBUTE
         MVI   D0(R5),CHARB        INDICATE BLOCKED
         LA    R5,D1(R5)
STEST    EQU   *
         TM    DS1RECFM,STANDARD   CHECK FOR STANDARD OR SPANNED
         BNO   ASATEST             NO, CHECK ASA
         MVI   D0(R5),CHARS        MOVE STANDARD TO BUFFER
         LA    R5,D1(R5)           BUMP PTR
ASATEST  EQU   *
         TM    DS1RECFM,ASA        CHECK FOR ASA
         BNO   MACHTEST            NO, CHECK FOR MACHINE CTL CHARS
         MVI   D0(R5),CHARA        MOVE ASA CHAR TO BUFFER
         LA    R5,D1(R5)           BUMP PTR
MACHTEST EQU   *
         TM    DS1RECFM,MACHINE    CHECK MACHINE ATTRIBUTE
         BNO   TREG                NO, GO TEST LRECL            SA52667
         MVI   D0(R5),CHARM        MOVE MACHINE CNTRL CHAR TO BUFF
         LA    R5,D1(R5)           BUMP POINTER                 SA52667
TREG     CR    R3,R5               SEE IF REG. CHANGED          SA52667
         BNE   LRECLTST            GO TEST LRECL                SA52667
         MVI   D0(R5),CHARAST      INDICATE RECFM               SA52667
         MVI   D1(R5),CHARAST      NOT SPECIFIED                SA52667
LRECLTST EQU   *
         LH    R1,DS1LRECL         PICK UP LRECL
         N     R1,SIGNOFF          CLEAR POSSIBLE NEGATIVE SIGN
         LTR   R1,R1               PROPAGATED. CHECK FOR ZERO.
         BZ    NOLRECL             IF ZERO, INDICATE NO LRECL WITH **
         CVD   R1,WORKROOM
         UNPK  LRECLOFF(D5,R7),WORKROOM(D8)
         OI    LRECLOFF+D4(R7),ZONE GET RID OF SIGN
LRECLOOP EQU   *
         CLI   LRECLOFF(R7),ZONE   ARE THERE HIGH ORDER ZEROES
         BNE   BLKSIZET            NO, TEST BLKSIZE
         MVC   LRECLOFF(L5,R7),LRECLOFF+D1(R7) SHIFT NUMBER LEFT
         B     LRECLOOP            REPEAT EDIT OF LRECL
NOLRECL  EQU   *
         MVC   LRECLOFF(L'ASTERISK,R7),ASTERISK   INDICATE NO LRECL
BLKSIZET EQU   *
         LH    R1,DS1BLKL          PICKUP BLOCK LENGTH
         N     R1,SIGNOFF          CLEAR POSSIBLE NEGATIVE SIGN
         LTR   R1,R1               TEST FOR ZERO
         BZ    NOBLKLEN            IF ZERO, PUT ** FOR NO BLKLENGTH
         CVD   R1,WORKROOM         CONVERT NUMBER
         UNPK  BLKLOFF(L5,R7),WORKROOM(D8)    AND PLACE IN BUFFER
         OI    BLKLOFF+L4(R7),ZONE GET RID OF SIGN
BLKLOOP  EQU   *
         CLI   BLKLOFF(R7),ZONE    ARE THERE HIGH ORDER ZEROES
         BNE   DSORGTST            NO, CHECK DSORG
         MVC   BLKLOFF(L5,R7),BLKLOFF+D1(R7) SHIFT NUMBER LEFT
         B     BLKLOOP             REPEAT EDIT OF ZEROES
NOBLKLEN EQU   *
         MVC   BLKLOFF(L'ASTERISK,R7),ASTERISK
DSORGTST EQU   *
*
*
         TM    DS1DSORG,PS         IS DSORG PS
         BO    SETPS               IF YES, BRANCH
*
         TM    DS1DSORG,PO         IS DSORG PO
         BO    SETPO               IF YES, BRANCH
*
         TM    DS1DSORG,IS         IS DSORG IS
         BO    SETIS               IF YES, BRANCH
*
         TM    DS1DSORG,DA         IS DSORG DA
         BO    SETDA               IF YES, BRANCH
*
         TM    DS1DSORG,NOTID      IS AN UNIDENTIFIED BIT SET
         BZ    SETND               IF NO, BRANCH
*
         LA    R15,UNKL            DSORG NOT IDENTIFIABLE
         LA    R14,UNK
EXDSORGM EQU   *
         LA    R5,OUTBUF+DSORGOFF    POINT AT DSORG FIELD
         BCTR  R15,R0              DECREEENT FOR EX OF MOVE
         EX    R15,DSORGMV         MOVE DSORG TO BUFFER
         LA    R5,D1(R5,R15)       POINT BEYOND DSORG IN BUFFER
         TM    DS1DSORG,UNMV       CHECK DSCB FOR UNMOVABLE ATTRIBUTE
         BZ    DSORGEXT            EXIT FROM DSORG PROCESSING
         MVI   D0(R5),UNMVABLE     UNMOVABLE ATTRIBUTE.
         B     DSORGEXT            EXIT FROM ROUTINE
*
SETPS    LA    R15,SEQL            DSORG WAS SEQUENTIAL
         LA    R14,SEQ
         B     EXDSORGM            GO MOVE DSORG TO BUFFER
*
SETPO    LA    R15,PDSL            DSORG WAS PARTITIONED
         LA    R14,PDS
         B     EXDSORGM            GO MOVE DSORG TO BUFFER
*
SETIS    LA    R15,ISEQL           DSORG WAS INDEXED SEQUENTIAL
         LA    R14,ISEQ
         B     EXDSORGM            GO MOVE DSORG TO BUFFER
*
SETDA    LA    R15,DAL             DSORG WAS DIRECT (BDAM)
         LA    R14,DIRECT
         B     EXDSORGM            GO MOVE DSORG TO BUFFER
*
SETND    LA    R15,UNDEFL          DSORG WAS NOT DEFINED
         LA    R14,UNDEF
         B     EXDSORGM            GO MOVE DSORG TO BUFFER
DSORGEXT EQU   *
         MVC   WRKCREDT,DS1CREDT   MOVE CREATE DATE TO COMMON  @YL026YA
         MVC   WRKEXPDT,DS1EXPDT   MOVE EXPIR. DATE TO COMMON  @YL026YA
         LR    R1,R13              SAVE DYNAMIC AREA ADDRESS
         L     R13,D4(R1)          CALLERS SAVEAREA
         FREEMAIN R,LV=SAVELEN,A=(1),SP=WORKSP
         RETURN                    (14,12)
*
DSORGOFF EQU   22                  OFFSET TO DSORG FIELD
RECFMOFF EQU   2                   OFFSET TO RECFM FIELD IN BUFFER
UTYPE    EQU   X'C0'               MASK FOR UNDEFINED
FTYPE    EQU   X'80'               MASK FOR FIXED
TOVFLOW  EQU   X'20'               TRACK OVERFLOW MASK
BLOCKED  EQU   X'10'               BLOCKED ATTRIBUTE MASK
STANDARD EQU   X'08'               STANDARD BLOCKED (F), OR SPANNED (V)
ASA      EQU   X'04'               ASA CONTROL CHARACTER
MACHINE  EQU   X'02'               MACHINE CONTROL CHARACTER
LRECLOFF EQU   8                   OFFSET TO LRECL FIELD IN BUFFER
BLKLOFF  EQU   14                  OFFSET TO BLKSIZE FIELD IN BUFFER
PS       EQU   X'40'               SEQUENTIAL
PO       EQU   X'02'               PARTITIONED
IS       EQU   X'80'               INDEXED SEQ
DA       EQU   X'20'               DIRECT
NOTID    EQU   X'1C'               THESE BITS RESERVED IN DSORG
UNMVABLE EQU   C'U'                UNMOVABLE ATTRIBUTE
ASTERISK DC    C'**'               DOUBLE ASTERIKS NO LRECL
DSORGMV  MVC   D0(D0,R5),D0(R14)   USED WITH EXECUTE CMND
SEQ      DC    C'PS'               SEQUENTIAL DATA SET ORG
SEQL     EQU   L'SEQ               LENGTH OF CONSTANT SEQ
PDS      DC    C'PO'               PARTITIONED DATA SET ORG
PDSL     EQU   L'PDS               LENGTH OF CONSTANT PDS
ISEQ     DC    C'IS'               INDEXED SEQUENTIAL
ISEQL    EQU   L'ISEQ              LENGTH OF IS CONSTANT
DIRECT   DC    C'DA'               DIRECT ACCESS
DAL      EQU   L'DIRECT            LENGTH OF DA CONSTANT
UNDEF    DC    C'**'               DSORG NOT SPECIFIED
UNDEFL   EQU   L'UNDEF
UNK      DC    C'??'               DSORG NOT RECOGNIZED
UNKL     EQU   L'UNK
UNMV     EQU   X'01'               UNMOVEABLE BIT
         DS    0F                  ALIGN WORD BOUNDRY
SIGNOFF  DC    X'0000FFFF'         MASK TO TURN OFF HIGH HALF WORD
         EJECT
IKJEHLBL CSECT
***********************************************************************
*
*   THIS ROUTINE IS ENTERED IF THE LABEL KEYWORD IS SPECIFIED ON THE
*   ENTERED COMMAND.  THE FORMAT 1 DSCB HAS TO BE AVAILABLE NOW BY
*   NECESSITY OF THE BASIC FUNCTION OF THE COMMAND.  A HEADING IS PUT
*   TO THE TERMINAL AND THEN THE DSCB IS FORMATTED AND OUTPUT ONE LINE
*   AT A TIME.  THE FORMATTING CONSISTS OF PUTING A BLANK BETWEEN EVERY
*   FIELD IN THE DSCB.  IF THE LINK ADDRESS IS NONZERO, THEN THE NEXT
*   DSCB IS READ VIA THE OBTAIN MACRO AND IF IT IS THE FORMAT 3, IT IS
*   FORMATTED IN A SIMILAR FASHION AS MENTIONED ABOVE.  IF IT IS OTHER
*   THAN THE FORMAT 3, IT IS JUST DUMPED IN HEXIDECIMAL, 36 (ACTUAL)
*   BYTES AT A TIME.  THE ENTIRE CHAIN IS PUT OUT BEFORE PROCESSING IS
*   IS COMPLETE.
*
***********************************************************************
         ENTRY IKJEHBTX
LABELRT  SAVE  (14,12),,*
         LR    R10,R15             ESTABLISH BASE REGISTER
         USING LABELRT,R10
         USING OBTWAD,R12          WORK AREA BASE
         GETMAIN R,LV=SAVELEN,SP=WORKSP   GET A SAVE AREA
         ST    R13,D4(R1)          FORWARD
         ST    R1,D8(R13)          AND
         LR    R13,R1              BACKWARD CHAIN.
         LA    R7,OUTBUF           POINT AT BUFFER
         LR    R14,R7
         L     R15,VCONWRTE        ADDRESS OF WRITE ROUTINE
         BALR  R8,R15              GO WRITE BUFFER
         MVC   D0(L'FORMAT1,R7),FORMAT1  MV FORMAT 1 HEADING TO BUFFER
         LA    R14,L'FORMAT1(R7)
         L     R15,VCONWRTE        ADDRESS OF WRITE ROUTINE
         BALR  R8,R15              GO WRITE BUFFER
         LA    R4,DS1FMTID         POINT TO DATA TO CONVERT
         LA    R5,MAXNUM           MAXIMUM COUNT FOR THIS CONVERSION
         LA    R7,LABELHEX         CONVERSION AREA ADDRESS
         BAL   R8,BITOHEX          GO CONVERT IT.
         MVC   OUTBUF(IDLEN),LABELHEX        IDENTIFIER
         MVC   OUTBUF+NSNOFF(SNLEN),LABELHEX+SNOFF SERIAL NUMBER
         MVC   OUTBUF+NVSOFF(VSLEN),LABELHEX+VSOFF VOLUME SEQUENCE
         MVC   OUTBUF+NCDOFF(CDLEN),LABELHEX+CDOFF CREATION DATE
         MVC   OUTBUF+NEDOFF(EDLEN),LABELHEX+EDOFF EXPIRATION DATE
         MVC   OUTBUF+NNEOFF(NELEN),LABELHEX+NEOFF NUMBER OF EXTENTS
         MVC   OUTBUF+NNOBDBOF(NOBDBLEN),LABELHEX+NOBDBOFF DS1NOBDB
         MVC   OUTBUF+NRESOFF1(RESLEN1),LABELHEX+RESOFF1 RESERVED
         MVC   OUTBUF+NSYSCDOF(SYSCDLEN),LABELHEX+SYSCDOFF DS1SYSCD
         LA    R7,OUTBUF           PUT BUFFER OUT TO TERMINAL
         LA    R14,NSYSCDOF+SYSCDLEN(R7)  END OF DATA IN BUFFER
         L     R15,VCONWRTE        ADDRESS OF WRITE ROUTINE
         BALR  R8,R15              GO WRITE BUFFER
         LA    R4,DS1SYSCD+L'DS1SYSCD POINT AT NEXT DATA TO CONVERT
         LA    R5,MAXNUM           SET UP MAXIMUM COUNT TO CONVERT
         LA    R7,LABELHEX         POINT TO RECEIVING AREA
         BAL   R8,BITOHEX          CONVERT
         MVC   OUTBUF(RESLEN2),LABELHEX     RESERVED AREA
         MVC   OUTBUF+NDSORGOF(DSORGLEN),LABELHEX+DSORGOF  DSORG FIELD
         MVC   OUTBUF+NRECFMOF(RECFMLEN),LABELHEX+RECFMOF  RECFM FIELD
         MVC   OUTBUF+NOPTCDOF(OPTCDLEN),LABELHEX+OPTCDOFF OPTCD FIELD
         MVC   OUTBUF+NBLKLOF(BLKLLEN),LABELHEX+BLKLOF    BLKL FIELD
         MVC   OUTBUF+NLRECLOF(LRECLLEN),LABELHEX+LRECLOF  LRECL FIELD
         MVC   OUTBUF+NKEYLOFF(KEYLLEN),LABELHEX+KEYLOFF   KEYL FIELD
         MVC   OUTBUF+NRKPOFF(RKPLEN),LABELHEX+RKPOFF      RKP  FIELD
         MVC   OUTBUF+NDSINDOF(DSINDLEN),LABELHEX+DSINDOFF DSIND FIELD
         MVC   OUTBUF+NSCALOOF(SCALOLEN),LABELHEX+SCALOOFF SCALO FIELD
         MVC   OUTBUF+NLSTAROF(LSTARLEN),LABELHEX+LSTAROFF LSTAR FIELD
         MVC   OUTBUF+NTRBALOF(TRBALLEN),LABELHEX+TRBALOFF TRBAL FIELD
         MVC   OUTBUF+NRESOFF3(RESLEN3),LABELHEX+RESOFF3 RESRVD FIELD
         LA    R7,OUTBUF           WRITE
         LA    R14,NRESOFF3+RESLEN3(R7) END OF DATA IN BUFFER
         L     R15,VCONWRTE        ADDRESS OF WRITE ROUTINE
         BALR  R8,R15              GO WRITE BUFFER
         LA    R4,DS1EXT1          SETUP TO CONVERT
         LA    R5,MAXNUM           REMAINING DATA.
         LA    R7,LABELHEX
         BAL   R8,BITOHEX          GO TO CONVERT.
         MVC   OUTBUF(EXT1LEN),LABELHEX   FIRST EXTENT
         MVC   OUTBUF+NEXT2OFF(EXT2LEN),LABELHEX+EXT2OFF SECOND EXTENT
         MVC   OUTBUF+NEXT3OFF(EXT3LEN),LABELHEX+EXT3OFF THIRD EXTENT
         MVC   OUTBUF+NPTRDSOF(PTRDSLEN),LABELHEX+PTRDSOFF PTRDS FIELD
         LA    R7,OUTBUF           POINT AT BUFFER
         LA   R14,NPTRDSOF+PTRDSLEN(R7)   END OF BUFFER POINTER
         L     R15,VCONWRTE        ADDRESS OF WRITE ROUTINE
         BALR  R8,R15              GO WRITE BUFFER
ZEROCHCK CLC   DS1PTRDS,ZEROES     CHECK FOR OTHER DSCB ON CHAIN
*************************************************
*******CONTINUE CHECKING FOR MORE DSCBS**********
*******IF NONE EXIT FROM ROUTINE      ***********
*************************************************
         BE    LABELEXT            GO EXIT FROM THIS ROUTINE
         MVC   OBTCLST(D4),CAMLSTSK  SETUP FOR OBTAINING NEXT DSCB
         MVC   OBTCCHHR,DS1PTRDS   MOVE CHAIN CCHHR TO SAVE AREA
         LA    R1,OBTCCHHR         POINT AT CCHHR OF NEXT BLOCK
ZEROCHK1  EQU  *
         ST    R1,OBTCLST+D4       AND PLACE IN CAMLST
         LR    R14,R7              SKIP
         L     R15,VCONWRTE        ADDRESS OF WRITE ROUTINE
         BALR  R8,R15              GO WRITE BUFFER
*
*
****** DO OBTAIN AT THIS POINT TO READ DSCB***
*
*
         OBTAIN                    OBTCLST
         LTR   R15,R15             TEST RETURN CODE
         BZ    LABELOK             IF GOOD, GO PROCESS
         LA    R1,MSG06            INDICATE FIRST LEVEL MESSAGE
         STH   R1,ERRPARM          STORE CODE IN PARAMETER LIST
         LA    R1,SECMSG02         GET SECOND LEVEL MESSAGE CODE
         STH   R1,ERRSECND         SAVE IT
         CVD   R15,ERRINSRT+D8     CONVERT RC TO DECIMAL
        UNPK  ERRINSRT+D1(D2),ERRINSRT+D8(D8)  UNPACK
         OI    ERRINSRT+D2,ZONE    GET RID OF SIGN
         LA    R1,D2               LENGTH OF DATA
         STC   R1,ERRINSRT         PLACE BEFORE DATA
         LA    R1,ERRINSRT         PLACE ADDRESS OF DATA IN SLOT
         ST    R1,ERRINST2         FOR SECOND LEVEL MESSAGE
         LR    R1,R13              SAVE DYNAMIC AREA ADDRESS
         L     R13,D4(R1)          CALLERS SAVE AREA
         L     R2,VCONERRT         ADDRESS OF ERROUT
         L     R3,D12(R13)         GET NORMAL RETURN
         ST    R2,D12(R13)         SAVE IN SAVE AREA NORMAL RETURN SLOT
         ST    R3,RETCD52(R13)     SET RETURN FROM ERROUT NORMAL
LABELEND EQU *
         FREEMAIN R,LV=SAVELEN,A=(1),SP=WORKSP
         LM    R14,R12,D12(R13)    RESTORE REGISTERS
         BR    R14                 RETURN TO CALLER
LABELOK  EQU   *
         CLI   LABELID,FOX3        CHECK FOR FORMAT 3
         BNE   LABEL02             NO,  GO PROCESS UNKNOWN FORMAT
         MVC   OUTBUF(L'FORMAT3),FORMAT3  MOVE HEADING TO BUFFER
         LA    R7,OUTBUF
         LA    R14,L'FORMAT3(R7)   POINT BEYOND HEADING
         L     R15,VCONWRTE        ADDRESS OF WRITE ROUTINE
         BALR  R8,R15              GO WRITE BUFFER
*
**********CONVERT LABEL ROUTINE  **************
*
         LA    R7,LABELHEX         SETUP
         LA    R4,OBTWORKA         TO
         LA    R5,MAXNUM2          CONVERT LABEL.
         BAL   R8,BITOHEX          CONVERT TO PRINTABLE HEX
         MVC   OUTBUF(KEYIDLEN),LABELHEX    KEY IDENTIFER
         MVC   OUTBUF+NF3OFF1(F3EXTLEN),LABELHEX+F3OFF1 EXTENT 1
         MVC   OUTBUF+NF3OFF2(F3EXTLEN),LABELHEX+F3OFF2 EXTENT 2
         MVC   OUTBUF+NF3OFF3(F3EXTLEN),LABELHEX+F3OFF3 EXTENT 3
         LA    R7,OUTBUF           POINT AT BUFFER
        LA    R14,NF3OFF3+F3EXTLEN(R7) END OF DATA
         L     R15,VCONWRTE        ADDRESS OF WRITE ROUTINE
         BALR  R8,R15              GO WRITE BUFFER
         LA    R7,LABELHEX         CONVERT
         LA    R4,LABLOFF1         ANOTHER                     @YL026YA
         LA    R5,MAXNUM2          BLOCK OF DATA.
         BAL   R8,BITOHEX          GO CONVERT DATA
         MVC   OUTBUF(F3EXTLEN),LABELHEX  EXTENT 4
         MVC   OUTBUF+NF3OFF4(F3IDLEN),LABELHEX+F3OFF4 ID BYTE @YL026YA
         MVC   OUTBUF+NF3OFF5(F3EXTLEN),LABELHEX+F3OFF5 EXTENT 5
         MVC   OUTBUF+NF3OFF6(F3EXTLEN),LABELHEX+F3OFF6 EXTENT 6
         LA    R7,OUTBUF           POINT AT BUFFER
         LA    R14,NF3OFF6+F3EXTLEN(R7) END OF BUFFER
         L     R15,VCONWRTE        ADDRESS OF WRITE ROUTINE
         BALR  R8,R15              GO WRITE BUFFER
         LA    R7,LABELHEX         CONVERT
         LA    R4,LABLOFF2         ANOTHER                     @YL026YA
         LA    R5,MAXNUM2          BLOCK OF DATA
         BAL   R8,BITOHEX           TO PRINTABLE HEXADECIMAL.
         MVC   OUTBUF(F3EXTLEN),LABELHEX  EXTENT 7
         MVC   OUTBUF+NF3OFF7(F3EXTLEN),LABELHEX+F3OFF7 EXTENT 8
         MVC   OUTBUF+NF3OFF8(F3EXTLEN),LABELHEX+F3OFF8 EXTENT 9
         LA    R7,OUTBUF           POINT AT BUFFER
         LA    R14,NF3OFF8+F3EXTLEN(R7) END OF BUFFER          @YL026YA
         L     R15,VCONWRTE        ADDRESS OF WRITE ROUTINE
         BALR  R8,R15              GO WRITE BUFFER
         LA    R7,LABELHEX         CONVERT
         LA    R4,LABLOFF3         MORE
         LA    R5,MAXNUM2          DATA.
         BAL   R8,BITOHEX          GO TO CONVERT ROUTINE
         MVC   OUTBUF(F3EXTLEN),LABELHEX  EXTENT 10
         MVC   OUTBUF+NF3OFF7(F3EXTLEN),LABELHEX+F3OFF7 EXTENT 11
         MVC   OUTBUF+NF3OFF8(F3EXTLEN),LABELHEX+F3OFF8 EXTENT 12
         LA    R7,OUTBUF           OUTPUT
         LA    R14,NF3OFF8+F3EXTLEN(R7) THE                    @YL026YA
         L     R15,VCONWRTE        ADDRESS OF WRITE ROUTINE
         BALR  R8,R15              GO WRITE BUFFER
         LA    R7,LABELHEX         CONVERT
         LA    R4,LABLOFF4         LAST                        @YL026YA
         LA    R5,MAXNUM3          FIELDS OF
         BAL   R8,BITOHEX          FORMAT 3.
         MVC   OUTBUF(F3EXTLEN),LABELHEX  EXTENT 13
         MVC   OUTBUF+NF3OFF7(PTRDSLEN),LABELHEX+F3OFF7 PTRDS FIELD
         LA    R7,OUTBUF           BUFFER
         LA    R14,NF3OFF7+PTRDSLEN(R7) END OF DATA
         L     R15,VCONWRTE        ADDRESS OF WRITE ROUTINE
*
*
*******AT THIS POINT WRITE THE DATA AND EXIT THE ROUTINE**
*
         BALR  R8,R15              GO WRITE BUFFER
LABELEXT EQU  *
         LR    R1,R13              SAVE DYNAMIC AREA
         L     R13,D4(R1)          CALLERS SAVEAREA
         B     LABELEND             FREE UP STORAGE AND RETURN
LABEL02  EQU   *
         MVC   OUTBUF(L'FORMAT2),FORMAT2  MOVE HEADING TO BUFFER
         MVC   OUTBUF+IDOFF(L1),LABELID    PUT FORMAT ID IN HEADING
         LA    R7,OUTBUF           POINT TO BUFFER
         LA    R14,L'FORMAT2(R7)   END OF DATA
         L     R15,VCONWRTE        ADDRESS OF WRITE ROUTINE
         BALR  R8,R15              GO WRITE BUFFER
         LA    R4,OBTWORKA         POINT AT START OF DSCB
LABELOOP EQU   *
         LA    R5,MAXNUM2          SET AMOUNT TO BE CONVERTED
         LA    R7,OUTBUF           POINT TO RECEIVING AREA
         BAL   R8,BITOHEX             CONVERTS BINARY TO HEX
         LA    R7,OUTBUF           POINT AT BUFFER
         LA    R14,EOBUFF1(R7)     END OF BUFFER               @YL026YA
         L     R15,VCONWRTE        ADDRESS OF WRITE ROUTINE
         BALR  R8,R15              GO WRITE BUFFER
*
*    BITOHEX BUMPS REG 4 BY 4 EACH TIME IT GOES THROUGH THE PROCESS
*    LOOP SO THAT WHEN WE GET CONTROL BACK IT SHOULD BE POINTING AT
*    THE NEXT DATA TO CONVERT. THIS WILL BE TRUE ONLY IF THE DATA
*    COUNT IS A MULTIPLE OF 4, IN THIS CASE 36. OTHERWISE THE POINTER
*    WOULD BE OFF A COUPLE OF BYTES.
*
         LA    R4,FOUR(R4)         BUMP PTR NEXT DATA TO CONVERT
         LA    R1,LABLOFF5         POINT AT END OF 36 BYTE MULTIPLES
         CR    R4,R1               SEE IF ALL 36-BYTE CHUNKS ARE DONE
         BL    LABELOOP            NO, GO DO ANOTHER ONE.
         LA    R5,MAXNUM4          SET COUNT TO REMAINDER
         LA    R7,OUTBUF           POINT AT BUFFER
         BAL   R8,BITOHEX          CONVERT REMAINING DATA
         LA    R7,OUTBUF           POINT AT BUFFER
         LA    R14,EOBUFF1(R7)     END OF BUFFER               @YL026YA
         L     R15,VCONWRTE        ADDRESS OF WRITE ROUTINE
         BALR  R8,R15              GO WRITE BUFFER
         CLC   LBLCHAIN(L'DS1PTRDS),ZEROES SEE IF CCHHR OF NEXT IS 0.
         BE    LABELEXT            NO, GO EXIT
         MVC   OBTCLST(D4),CAMLSTSK   SETUP CAMLST CODE
         MVC  OBTCCHHR,LBLCHAIN     SAVE CCHHR
         LA    R1,OBTCCHHR         POINT AT CCHHR
         B     ZEROCHK1            GO ISSUE OBTAIN
IKJEHBTX DS    0H
BITOHEX  EQU   *
***********************************************************************
*
*    THIS ROUTINE CONVERTS BINARY DATA TO HEXIDECIMAL REPRESENTATION
*    FOR OUTPUT TO A TERMINAL.
*         INPUT IS AS FOLLOWS.
*
*                 R4 - POINTS TO DATA TO CONVERT
*                 R5 - CONTAINS LENGTH OF DATA IN BYTES
*                 R7 - POINTS TO OUTPUT AREA FOR CONVERTED DATA
*
*        R2 AND R3 ARE USED FOR LOGICAL OPERATIONS
*
***********************************************************************
         AR    R5,R5               DOUBLE COUNT TO CORRESPOND TO OUTPUT
         XR    R3,R3               CLEAR REG TO HOLD DATA
BILOOP01 LA    R1,CONVCNT          NUMBER OF HALF BYTES TO CONVERT
         MVC   ALIGN(FOUR),D0(R4)   ALIGN FOUR BYTES TO CONVERT
         L     R3,ALIGN            PUT FOUR BYTES INTO ODD REGISTER
BILOOP02 XR    R2,R2
         SLDL  R2,FOUR             GET NEXT 4 BITS TO CONVERT TO HEX
         IC    R0,TRANSTAB(R2)     GET PROPER CHARACTER
         STC   R0,D0(R7)           PLACE IN OUT AREA
         LA    R7,D1(R7)           UPDATE OUT AREA POINTER BY ONE
         BCTR  R5,R0               DECREMENT COUNT BY ONE
         LTR   R5,R5               ARE THERE MORE BYTES TO CONVERT
         BCR   CONDZERO,R8         IF ZERO, RETURN TO CALLER
         BCT   R1,BILOOP02         DECREMENT LOOP COUNT AND GO AGAIN
         LA    R4,FOUR(R4)         IF ZERO, POINT AT NEXT BYTES
         B     BILOOP01            GET NEXT FOUR BYTES TO CONVERT
CAMLSTSK CAMLST SEEK,1,2,3
********************************************
******THE FOLLOWING TABLE IS USED FOR THE **
******TRANSLATE INSTRUCTION FOR CONVERTING**
******BINARY TO HEX REPRESENTATION *********
********************************************
TRANSTAB DC    C'0123456789ABCDEF' TRANSLATE TABLE FOR BITOHEX ROUTINE
ZEROES   DC    5X'00'              FIVE BYTES OF ZEROES
FORMAT1  DC    C'--FORMAT 1 DSCB--'         HEADING FOR LABEL COMMAND
FORMAT2  DC    C'--FORMAT 2 DSCB--'         HEADING FOR LABEL COMMAND
FORMAT3  DC    C'--FORMAT 3 DSCB--'         HEADING FOR LABEL COMMAND
VCONWRTE DC    V(IKJEHWRT)         ADDRESS OF WRITE ROUTINE
VCONERRT DC    V(IKJEHERR)         ADDRESS OF ERROR ROUTINE
         EJECT
IKJEHHIS CSECT
***********************************************************************
*
*    THIS ROUTINE GETS CONTROL IF THE HISTORY KEYWORD IS SPECIFIED.
*    THE REQUIRED INFORMATION IS COLLECTED FROM THE DSCB THAT IS
*    AVAILABLE AT THIS TIME SINCE IT IS REQUIRED FOR THE BASIC FUNCTION
*    OF THE COMMAND. THE INFORMATION WHICH IS REFERENCED THROUGH DSECT
*    OBTWAD IS AS FOLLOWS.
*                  1. CREATION DATE
*                  2. EXPIRATION DATE
*                  3. SECURITY (PASSWORD) INFORMATION
*
***********************************************************************
HISTROUT SAVE (14,12),,*
         LR    R10,R15             ESTABLISH ADDRESSABILITY
         USING HISTROUT,R10
         USING OBTWAD,R12          WORKAREA BASE
         GETMAIN R,LV=SAVELEN,SP=WORKSP  GET SAVEAREA FOR THIS ROUTINE
         ST    R13,D4(R1)          CHAIN AREAS TOGETHER
         ST    R1,D8(R13)
         LR    R13,R1              NEW SAVEAREA ESTABLISHED
         LA    R7,OUTBUF          INITIALIZE POINTER
         CLI   DSTYPE,CTGTALIN    CHECK FOR VSAM               @VS06171
         BNE   VSAMHIST           YES                          @VS06171
         LA    R2,WRKCREDT         GET CREATION DATE ADDR      @YL026YA
         LA    R7,CRDTOFF(R7)      POINT AT BUFFER POSITION
         BAL   R14,HDT02           GO CONVERT DATE AND PUT IN BUFFER
         LA    R2,WRKEXPDT         GET EXPIRATION DATE ADDR    @YL026YA
         LA    R7,NXTBUF(R7)       POINT AT NEXT BUFFER POSITION
         BAL   R14,HDT02           GO CONVERT DATE AND PUT IN BUFFER
CHKPROT  LA    R7,NXTBUF(R7)       POINT AT NEXT BUFFER POSITION
         CLI   DSTYPE,CTGTALIN     IS DATA SET NONVSAM?        @VS06171
         BNE   HISTEXIT            NO, NO PROTECTION INFO      @VS06171
*     CHECK FOR VARIOUS COMBINATIONS OF RACF AND PASSWORD PROTECTION
         TM    DS1DSIND,RACOPWD    RACF AND PASSWORD?          @Z40RSSA
         BNO   NTBOTH                  NO                      @Z40RSSA
         MVC   D0(9,R7),WPWDRAC                                @Z40RSSA
TSTREAD  TM    DS1DSIND,WPIND      WRITE PASSWORD PROTECT?     @Z40RSSA
         BO    HISTEXIT               YES                      @Z40RSSA
         MVI   D0(R7),C'R'            NO, CHANGE TO RPWD/RACF  @Z40RSSA
HISTEXIT EQU    *
         LR    R1,R13              SAVE DYNAM AREA ADDR FOR FREEMAIN
         L     R13,D4(R1)          CALLERS SAVEAREA
         FREEMAIN R,LV=SAVELEN,A=(1),SP=WORKSP
         RETURN (14,12)
         SPACE 1
NTBOTH   MVC   D0(4,R7),NONE       ASSUME NONE                 @Z40RSSA
         BZ    HISTEXIT                IF NONE                 @Z40RSSA
         MVC   D0(4,R7),RACF       ASSUME RACF                 @Z40RSSA
         TM    DS1DSIND,RACIND                                 @Z40RSSA
         BO    HISTEXIT                RACF ONLY               @Z40RSSA
         MVC   D0(4,R7),WPWD       ASSUME WPWD ONLY            @Z40RSSA
         B     TSTREAD             TO TEST FOR READ            @Z40RSSA
VSAMHIST LA    R2,WRKCREDT        CREATION DATE IN BINARY
         LA    R7,L15(R7)         OFFSET FOR OUTPUT
         BAL   R14,HDT02          CONVERT TO DEC.
         LA    R2,WRKEXPDT        EXPIRE DATE IN BINARY
         LA    R7,NXTBUF(R7)      OFFSET IN BUFFER
         BAL   R14,HDT02          CONVERT TO DEC.
         B     CHKPROT            CHECK FOR PROTECTION
*
*
*    THIS ROUTINE CONVERTS BINARY DATES OF THE FORM YYDDDD TO         *
*    CHARACTER FORMAT IN THE FORM MM/DD/YY. LEAP YEARS ARE ACCOUNTED  *
*    FOR. INPUT REQUIREMENTS ARE.                                     *
*         1.   R2 POINTS TO FIELD TO BE CONVERTED                     *
*         2.   R7 POINTS TO RECEIVING FIELD                           *
*         3.   R14 HAS RETURN ADDRESS.                                *
*                                                                     *
HDT02 EQU      *
         CLC   D0(D3,R2),HDTZ      CHECK FOR UNSPECIFIED DATE
         BNE   HDT04               BRANCH IF DATE PRESENT
HDT03    MVC   D0(L'HDTDF,R7),HDTDF  MOVE IN DEFAULT OF 00/00/00
         BR    R14                 RETURN
HDT04    STM   R14,R6,HDTSV        SAVE REGS
*
*  TEST FOR LEAP YEAR BY ANDING THE YEAR FIELD AGAINST A BYTE WITH    *
*  THE TWO LOW ORDER BITS ON.  LEAP YEARS WILL HAVE ZEROS FOR THE TWO *
*  LOW ORDER BYTES.                                                   *
*                                                                     *
         SR    R3,R3               CLEAR REG FOR INSERT CHARACTER.
         IC    R3,D0(R2)           GET YEAR BYTE FROM DATE FIELD.
         LA    R4,HDTBIN3          SET UP TO TEST LOW ORDER BITS.
         NR    R3,R4               IF YEAR IS DIVISIBLE BY 4,PROD EQ 0.
         LA    R4,HDTNY            SET UP FOR NON-LEAP YR -SAVE COND CD
         BNZ   HDT06               IF PROD N. EQ. TO ZERO, NOT LEAP YR.
         LA    R4,HDTLY            IF REMAINDER IS ZERO, USE LEAP YR.
*
HDT06    MVC   HDTWK(L2),D1(R2)    MOVE 2 BYTE DAY FLD TO HWORD
         LH    R3,HDTWK            PUT INTO REGISTER
         LA    R6,NUMMONTH         SET UP BR CTL AS NO. OF MONTHS
*
*  SEARCH NOW BEGINS TO FIND THE MONTH THAT THE DAY-OF-THE-YEAR OCCURS
*  IN.  IF DAY-OF-THE-YEAR IS GREATER THAN 365/366, MONTH 12 IS USED.
*
HDT08    CH     R3,D0(R4)          COMPARE DAY TO TABLE ENTRY FOR MONTH
         BH    HDT10               DAY GREATER THAN TABLE IS A FIND
         LA    R4,D2(R4)           UP TBL PTR TO NEXT ELEMENT.
         BCT   R6,HDT08            DECREMENT MONTH AND RETRY.
         B     HDT03               IF DAY NEG, USE DEFAULT 00/00/00
HDT10    SH    R3,D0(R4)           SUBTRACT TABLE ELEMENT FROM DAY
         EX    R3,HDTCLI           COMPARE DAY TO 31.
         BNL   HDT12               IF VALUE LESS THAN 31 OK
         LA    R3,DAYS31           DEFAULT TO 31 DAYS.
HDT12    CVD   R6,HDTWK            CONVERT MONTH TO DEC
        UNPK   D0(L2,R7),HD6(D2)   THEN TO CHARCTER
         CVD   R3,HDTWK            CONVERT DAY TO DECIMAL
        UNPK   D3(L2,R7),HD6(D2)   THEN TO CHARACTER
         IC    R6,D0(R2)           GET YEAR
         CVD   R6,HDTWK            CONVERT IT TO DECIMAL
         UNPK  D6(L2,R7),HD6(D2)   THEN TO CHAR
        MVZ    D1(L7,R7),D0(R7)    PROPAGATE A NUM CHAR ZONE
         MVI   D2(R7),SLASH        MOVE IN SEPARATORS BETWEEN
         MVI   D5(R7),SLASH        MONTH DAY AND YEAR
         LM    R14,R6,HDTSV        RESTORE REGS
HDT16    BR    R14                 RETURN
*
*
*  THE FOLLOWING CONSTANTS ARE USED BY THE HISTORY ROUTINE.
*
HDTCLI   CLI   HDTC31,D0           EXECUTED TO CHECK IF DATE IS GT 31
RACIND   EQU  X'40'                MASK FOR RACF PROTECTION(DSCB)
WPIND    EQU  X'04'                WRITE PASSWORD PROTECT(DSCB)
RACOPWD  EQU  X'50'                RACF OR PASSWORD PROTECTION
NONE     DC   C'NONE'              NO RACF OR PASSWORD PROTECTION
RACF     DC   C'RACF'              RACF PROTECTION ONLY
WPWD     DC   C'WPWD'              WRITE PASSWORD ONLY
WPWDRAC  DC   C'WPWD/RACF'         WRITE PASSWORD AND RACF
HDTZ     DC    X'000000'           MASK OF NO DATE SPECIFIED
HDTDF    DC    C'00/00/00'         DEFAULT OF NO DATE PRINTED
HDTC31  DC    FL1'31'              USED FOR COMPARE OF 31 DAYS
*****************************************************************
**
**THE TABLE BELOW IS USED FOR THE MONTH LOOKUP IN NORMAL YEARS***
***
HDTNY    DC    H'334'              DECEMBER
         DC    H'304'              NOVEMBER
         DC    H'273'              OCTOBER
         DC    H'243'              SEPTEMBER
         DC    H'212'              AUGUST
         DC    H'181'              JULY
         DC    H'151'              JUNE
         DC    H'120'              MAY
         DC    H'90'               APRIL
         DC    H'59'               MARCH
         DC    H'31'               FEBRUARY
         DC    H'0'                JANUARY
***************************************************************
****
****MONTHLY TABLE LOOKUP IN LEAP YEARS              ***********
****
HDTLY    DC    H'335'              DECEMBER
         DC    H'305'              NOVEMBER
         DC    H'274'              OCTOBER
         DC    H'244'              SEPTEMBER
         DC    H'213'              AUGUST
         DC    H'182'              JULY
         DC    H'152'              JUNE
         DC    H'121'              MAY
         DC    H'91'               APRIL
         DC    H'60'               MARCH
         DC    H'31'               FEBRUARY
         DC    H'0'                JANUARY
*****
***END OF TABLE LOOKUP FOR MONTHS****
*****
HDTBIN3  EQU   X'03'               BYTE WITH TWO LOW ORDER BITS EQ 1'S
HDTL     EQU   10
*
         EJECT
IKJEHDS1 CSECT
IKJEHWRT DS    0H
WRITE    EQU   *
***********************************************************************
*                                                                     *
*   INPUT TO THIS ROUTINE IS THE BUFFER ADDRESS IN REG7 AND END       *
*   OF BUFFER ADDRESS IN REG 14. RETURN ADDRESS IS IN REG8.           *
*
*   THE OUTPUT BUFFER IS CLEARED AND RETURNED IN REG7.
*   TRAILING BLANKS WILL BE ELIMINATED.
*
*  IMPORTANT---THIS ROUTINE REQUIRES NO BASE REGISTER. KEEP IT THAT
*  WAY SO THAT IKJEHMEM CAN USE IT.(SEE CALL PARAMETERS)
*
***********************************************************************
         STM   R0,R9,LOCSAVOF(R13)  SAVE REGISTERS LOCALLY
         LR    R2,R14              COPY THE END OF DATA PTR
         SR    R2,R7               CALCULATE DATA  LENGTH
         LA    R1,FOUR             DECREMENT BUFFER POINTER BY 4,
         SR    R7,R1               SO R7 WILL POINT AT LL FIELD
         LA    R2,FOUR(R2)         BUMP LENGTH FOR LL AND OFF FIELD
         STH   R2,D0(R7)           STORE LENGTH OF DATA IN LL FIELD
         XC    D2(L2,R7),D2(R7)    CLEAR OFFSET BYTE
         LR    R6,R7               PUT OUTPUT LINE POINTER IN PROPER
         LA    R1,PARMLSTL         POINT INFRONT OF BUFFER TO PARM LIST
         SR    R7,R1               CONTAING VARIOUS ADCONS. (SEE DSECT)
         LM    R1,R5,D0(R7)        SET UP REGISTERS FOR PUTLINE
         L     R15,PARMLSTL-FOUR(R7) GET ENTRY POINT.
         PUTLINE PARM=(R2),UPT=(R3),ECT=(R4),ECB=(R5),OUTPUT=((R6),    X
               DATA),ENTRY=(15),MF=(E,(1))
***********************************************************
*
*
************************************************************
         LA    R7,PARMLSTL+FOUR(R7) POINT BACK TO DATA BUFFER
*
         MVI   D0(R7),BLANK
         MVC   D1(L'OUTBUF-L1,R7),D0(R7) CLEAR BUFFER
         LM    R0,R9,LOCSAVOF(R13)  RESTORE CALLERS REGISTER
         BR    R8                  RETURN TO CALLER
         EJECT
*
IKJEHERR DS    0H
ERROUT   EQU   *
***********************************************************************
*
*    THIS ROUTINE IS ENTERED VIA A 'BAL R8,ERROUT' INSTRUCTION SEQUENCE
*    AND IS USED TO OUTPUT ERROR MESSAGES. INPUT IS A THREE WORD LIST
*    CALLED ERRPARM WHICH CONTAINS INFORMATION AS FOLLOWS.
*
*                    BYTE 1 AND 2 - THE RELATIVE POSITION OF THE FIRST
*                             LEVEL MESSAGE IN THE MESSAGE CSECT
*                    BYTE 3 AND 4 - THE RELATIVE POSITION OF THE
*                             SECOND LEVEL MESSAGE IN THE STRING.
*                    SECOND WORD  - POINTS TO TEXT TO BE INSERTED AFTER
*                             FIRST SEGMENT OF FIRST LEVEL MESSAGE.
*                    THIRD WORD   - POINTS TO TEXT TO BE INSERTED AFTER
*                             FIRST SEGMENT OF SECOND LEVEL MESSAGE.
*
*
***********************************************************************
         STM   R0,R9,LOCSAVOF(R13)       SAVE LOCAL REGISTERS
         MVI   STACKSW,SWON        TURN STACK SWITCH ON
         LA    R7,OUTBUF+D4        POINT AT PROPER BUFFER OFFSET
         LH    R1,ERRPARM          RELATIVE MESSAGE NUMBER
         BCTR  R1,R0               DECREMENT POSITION COUNT
         SLL   R1,D3               TIMES 8 TO GET INDEX INTO TABLE
         L     R6,MSGCSECT         PICK UP VCON FOR CSECT
         LA    R5,D0(R6,R1)        TABLE ENTRY FOR PROPER MSG
         LH    R1,D0(R5)           LENGTH OF MESSAGE
         LA    R2,D4(R1)           UPDATE LENGTH FOR LL SND OFF FIELDS
         STH   R2,OUTBUF           SAVE LENGTH
        XC     OUTBUF+D2(L2),OUTBUF+D2  CLEAR OFFSET FIELD
         LH    R4,D2(R5)           OFFSET TO MESSAGE IN CSECT
         LA    R3,D0(R6,R4)        POINTER TO MESSAGE IN CSECT
         BCTR  R1,R0               DECREMENT COUNT FOR EX OF MVC
         EX    R1,MOVE             MOVE MESSAGE TO BUFFER
         LA    R7,D1(R1,R7)        POINT BEYOND MESSAGE
         L     R4,ERRINST1         PICKUP INSERT POINTER
         LTR   R4,R4               TEST FOR ZERO
         BZ    SEGCHECK            IF ZERO, CHECK FOR SEGMENTATION
         XR    R1,R1
         IC    R1,D0(R4)           GET LENGTH OF INSERT DATA
         LA    R3,D1(R4)           POINT AT INSERT DATA
         LH    R2,OUTBUF           GET LENGTH
         LA    R2,D0(R2,R1)        INCREMENT COUNT
         STH   R2,OUTBUF           SAVE IT AGAIN
         BCTR  R1,R0               REDUCE COUNT BY ONE
         EX    R1,MOVE             MOVE INSERT DATA TO BUFFER
         LA    R7,D1(R1,R7)
SEGCHECK EQU   *
         LH    R4,D4(R5)           PICKUP OFFSET OF SEGMENT
         LTR   R4,R4               TEST FOR ZERO
         BZ    SECLVTST            CHECK SECOND LEVEL
         LA    R4,D0(R4,R6)        POINT AT SEGMENT TABLE
SEGLOOP  EQU   *
         LH    R1,D0(R4)           PICK UP LENGTH OF SEGMENT
         LTR   R1,R1               TEST CONTENTS OF REGISTERS
         BZ    SECLVTST            CHECK FOR SECOND LEVEL
         LH    R2,OUTBUF           GET LENGTH
         LA    R2,D0(R2,R1)        INCREMENT COUNT
         STH   R2,OUTBUF           SAVE IT AGAIN
         LH    R3,D2(R4)           PICKUP OFFSET TO SEGMENT
         LA    R3,D0(R3,R6)        CALCULATE THE ADDRESS
         BCTR  R1,R0               DECREMENT FOR MOVE
         EX    R1,MOVE             MOVE SEGMENT TO BUFFER
         LA    R7,D1(R7,R1)        POINT AT END OF DATA IN BUFFER
         LA    R4,D4(R4)           NEXT SEGMENT SLOT IN TABLE
         B     SEGLOOP             PROCESS ANOTHER SEGMENT
*********************************************************
***SECOND LEVEL MESSAGE CHECKING BEGINS HERE*************
*********************************************************
SECLVTST EQU   *
         LA    R1,D1               SEGMENT COUNT IS 1
         ST    R1,MPM11            PUT IN PAARM LIST
         LA    R1,OUTBUF
         ST    R1,MPM12            SAVE PTR TO MESSAGE (FIRST LEVEL)
         LH    R3,ERRSECND         CHECK FOR SECOND LEVEL MESSAGE
         LTR   R3,R3
         BZ    NOSECLVL             NO SECOND LEVEL BRANCH =ZERO
         BCTR  R3,R0               DECREMENT POSITION COUNT
         LA    R2,D6               TABLE ENTRY SIZE
         MR    R2,R2               OFFSET INTO TABLE CALCULATED
         LH    R4,D6(R5)           OFFSET TO SECOND LEVEL TABLE
         LA    R4,D0(R4,R6)        ADDRESS OF SECOND LEVEL TABLE
         LA    R5,D0(R4,R3)        OFFSET TO ENTRY IN TABLE
         LA    R7,SECBUFF+D4       POINT TO SECOND BUFFER OFFSET
         LH    R1,D0(R5)           GET LENGTH OF ENTRY
         LA    R2,D4(R1)           UPDATE LENGTH FOR LL SND OFF FIELDS
         STH   R2,SECBUFF          SAVE LENGTH OF FIRST SEGMENT
         XC    SECBUFF+D2(L2),SECBUFF+D2 CLEAR OFFSET FIELD
         LH    R4,D2(R5)           OFFSET TO MESSAGE IN CSECT
         LA    R3,D0(R6,R4)        ADDRESS OF MESSAGE IN CORE
         BCTR  R1,R0               DECREMENT LENGTH FOR EX OF MOVE
         EX    R1,MOVE             MOVE MESSAGE SEGMENT TO BUFFER
         LA    R7,D1(R1,R7)        BUMP BUFFER POINTER
         MVC   SECBUFF+D10(L2),OUTBUF+D10   SET ID FOR SECND LEVEL
         L     R4,ERRINST2         GET INSERT POINTER FOR SECOND LEVEL
         LTR   R4,R4               TEST FOR ZERO
         BZ    SECSEGCK            IF ZERO, CHECK SEGMENTATION
         XR    R1,R1
         IC    R1,D0(R4)           GET LENGTH OF INSERT DATA
         LH    R2,SECBUFF
         LA    R2,D0(R2,R1)        UPDATE LENGTH OF BUFFER MESSAGE
         STH   R2,SECBUFF          SAVE AGAIN
         LA    R3,D1(R4)           POINT AT DATA
         BCTR  R1,R0               DECREMENT COUNT FOR MOVE
         EX    R1,MOVE             MOVE IT TO BUFFER
         LA    R7,D1(R1,R7)        UPDATE BUFFER POINTER
SECSEGCK EQU   *
         LA    R1,D1               SET SEGMENT COUNT TO ONE
         ST    R1,MPM21            PUT IT INTO KPARM LIST
         LA    R1,SECBUFF          PUT BUFFER ADDRESS INTO LIST
         ST    R1,MPM22
         LA    R1,MSGPARM2         CHAIN MSG LEVEL PARM LISTS
         ST    R1,MSGPARM1
         XC    MSGPARM2,MSGPARM2   SETUP LINK ADDRESS TO END OF CHAIN
         LA    R1,FOXES            PUT X'FF' IN A REGISTER
         STC   R1,MSGPARM2         PUT END OF LIST IND IN CHAIN FIELD
         LH    R4,D4(R5)           OFFSET TO SEGMENT TABLE
         LTR   R4,R4               TEST FOR ZERO
         BZ    PUTMSG              IF ZERO, PUT OUT MESSAGE
         LA    R4,D0(R4,R6)        ADDRESS OF SEGMENT TABLE
         LH    R1,D0(R4)           LENGTH OF SEGMENT
SECSEGLP EQU   *
         LTR   R1,R1               SEE IF THIS IS THE LAST
         BZ    PUTMSG              YES, GO
         LH    R2,SECBUFF          UPDATE THE LENGTH FIELD
         LA    R2,D0(R2,R1)
         STH   R2,SECBUFF          RE-STORE IT
         LH    R3,D2(R4)           OFFSET TO SEGMENT
         LA    R3,D0(R3,R6)        ADDRESS OF MESSAGE
         BCTR  R1,R0               DECREMENT COUNT FOR MOVE
         EX    R1,MOVE             MOVE MESSAGE
         LA    R7,D1(R7,R1)        UPDATE BUFFER OFFSET
         LA    R4,D4(R4)           GET NEXT SEGMENT
        B     SECSEGLP             SEGMENT LOOP
NOSECLVL EQU   *
         XC    MSGPARM1,MSGPARM1   CLEAR SECOND LEVEL POINTER
PUTMSG   EQU   *
         LM    R3,R5,UPTPTR        LOAD UPT, ECT, ECB
         LA    R6,MSGPARM1         POINT TO MSG PARM LISTS
         LA    R2,DPUTLINE         LIST FORM OF MACRO
         LA    R1,PUTLLIST         LIST FOR E FORM OF MACRO
         L     R15,PUTLADDR        ADDRESS OF PUTLINE ROUTINE
*
         PUTLINE PARM=(R2),UPT=(R3),ECT=(R4),ECB=(R5),                 X
               OUTPUT=((R6),MULTLVL),ENTRY=(15),MF=(E,(1))
         XC    ERRPARM(ERRLIST),ERRPARM  CLEAR ERROR PARM LIST
         LM    R0,R9,LOCSAVOF(R13)       RESTORE LOCAL REGISTERS
         BR    R8                  RETURN
*
         EJECT                                                 @YL026YA
*   THE VSAM BASIC ROUTINE PROCESSES BASIC                     @YL026YA
*   INFORMATION FOR VSAM DATA SETS                             @YL026YA
*                                                              @YL026YA
VSAMBSC  EQU   *                                               @YL026YA
*  IF ENTRY FOUND IS AN ALIAS, GET INFORMATION FOR THE         @YL026YA
*  REAL (RELATED) NAME                                         @YL026YA
         CLI   DSTYPE,CTGTANM      IS THIS ENTRY AN ALIAS?     @YL026YA
         BNE   GOVSAM              NO, GO AHEAD                @YL026YA
LOCAGAIN EQU   *                                               @YL026YA
         XC    CPLAREA,CPLAREA     CLEAR CPL SPACE             @YL026YA
         LA    R1,CPLAREA          SET UP ADDRESSABILITY       @YL026YA
         USING CTGPL,R1            TO CPL                      @YL026YA
         OI    CTGOPTN3,CTGLOC+CTGAM0 SET FUNCTION TO LOCATE   @YL026YA
         USING CTGFL,R3            SET UP ADDRESSABILITY       @YL026YA
         LA    R3,CTGFL5           TO CATALOG ACB FPL          @YL026YA
         L     R3,CTGFLPT          ADDRESS OF CATALOG ACB ADDR @YL026YA
         ST    R3,CTGCAT           STORE IN CPL                @YL026YA
         LA    R3,CTGFL6           ADDRESS OF RELATED NAME FPL @YL026YA
         L     R3,CTGFLPT          ADDRESS OF RELATED NAME     @YL026YA
         LA    R3,D1(R3)           ADDR OF ENTRY NUMBER ADDR   @YL026YA
         ST    R3,CTGENT           STORE IN CPL                @YL026YA
         LA    R2,CATWORK2         ADDRESS OF WORKAREA         @YL026YA
         ST    R2,CTGWKA           STORE IN CPL                @YL026YA
         LA    R2,L'CATWORK2       GET LENGTH OF WORKAREA      @YL026YA
         STH   R2,CATWORK2         STORE IN FIRST HALFWORD     @YL026YA
*                                  OF AREA                     @YL026YA
         B     LOCBUILD            GO FINISH SETTING UP LOCATE @YL026YA
GOVSAM   EQU   *                                               @YL026YA
         L     R15,VSAMVCON        ADDRESS OF VSAM ROUTINE     @YL026YA
         BALR  R14,R15             GO PROCESS THE DATA SET     @YL026YA
         B     ENDBASIC            GO CHECK FOR HISTORY, ETC.  @YL026YA
         EJECT                                                 @YL026YA
IKJEHVSM CSECT                                                 @YL026YA
*                                                              @YL026YA
*  THIS ROUTINE IS ENTERED IF THE DATA SET NAME OCCURS IN      @YL026YA
*  THE CATALOG AND IS NOT A NONVSAM DATA SET.  A HEADING IS    @YL026YA
*  PUT TO THE TERMINAL AND THE BUFFER IS FILLED WITH BASIC     @YL026YA
*  INFORMATION.  IF THE HISTORY AND/OR STATUS OPTION IS        @YL026YA
*  SPECIFIED, THE HEADING INCLUDES THE APPROPRIATE TITLES.     @YL026YA
*  HISTORY INFORMATION IS PUT TO THE TERMINAL ALONG WITH       @YL026YA
*  THE BASIC INFORMATION.                                      @YL026YA
*                                                              @YL026YA
VSAMROUT SAVE  (14,12),,*                                      @YL026YA
         LR    R10,R15             SET UP ADDESSABILITY TO THIS ROUTINE
         USING VSAMROUT,R10        MAIN BASE FOR THIS ROUTINE  @YL026YA
         USING OBTWAD,R12          WORK AREA, R12 PASSED WITH ADDR
         GETMAIN R,LV=SAVELEN1,SP=WORKSP  GET A SAVE AREA      @ZA06146
         ST    R13,D4(R1)          SAVE CALLERS SAVE AREA      @YL026YA
         ST    R1,D8(R13)          SAVE THIS ROUTINES SAVE AREA ADDR
         LR    R13,R1              THIS ROUTINES SAVE AREA ADDRESS
*  WRITE THE HEADING LINE                                      @YL026YA
         LA    R7,OUTBUF           POINT TO OUTPUT BUFFER      @YL026YA
         MVC   D0(L'VSAMHDG,R7),VSAMHDG  MOVE BASIC HEADING    @YL026YA
         LA    R7,L'VSAMHDG(R7)    POINT PAST BASIC HEADING    @YL026YA
         TM    CONTROL,HISTORY     WAS HISTORY REQUESTED?      @YL026YA
         BNO   VSAM10              NO--SKIP HISTORY HEADING    @YL026YA
         MVC   D0(L'VSAMHHDG,R7),VSAMHHDG  MOVE HISTORY HEAD   @YL026YA
         LA    R7,L'VSAMHHDG(R7)   POINT PAST HISTORY HEADING  @YL026YA
VSAM10   EQU   *                                               @YL026YA
         TM    CONTROL,STATUS      WAS STATUS REQUESTED?       @YL026YA
         BNO   VSAM15              NO--SKIP STATUS HEADING     @YL026YA
         MVC   D0(L'VSAMSHDG,R7),VSAMSHDG  MOVE STATUS HEAD    @YL026YA
         LA    R7,L'VSAMSHDG(R7)   POINT PAST STATUS HEADING   @YL026YA
VSAM15   EQU   *                                               @YL026YA
         LR    R14,R7              POINT AT END OF BUFFER DATA @YL026YA
         LA    R7,OUTBUF           POINT AT BUFFER             @YL026YA
         L     R15,VCONVWRT        ADDRESS OF WRITE ROUTINE    @YL026YA
         BALR  R8,R15              WRITE HEADING LINE          @YL026YA
*  MOVE LRECL AND ENTRY TYPE TO BUFFER                         @YL026YA
         USING CTGFL,R3                                        @YL026YA
         LA    R3,CTGFL4           GET FPL FOR LRECL           @YL026YA
         L     R3,CTGFLPT          ADDRESS OF LRECL VALUE      @YL026YA
         TM    0(R3),X'FF'         CHECK FOR FOXES IN LRECL VALUE
         BO    VSAM30              YES, INDICATE WITH  **      @YL026YB
         L     R1,D0(R3)           LRECL VALUE                 @YL026YA
         N     R1,OFFSIGN          TURN OFF ANY NEGATIVE SIGN  @YL026YA
         LTR   R1,R1               CHECK FOR ZERO VALUE        @YL026YA
         BZ    VSAM30              IF ZERO, INDICATE WITH **   @YL026YA
         CVD   R1,WORKROOM         CONVERT TO NUMBERS          @YL026YA
         UNPK  LRECLOF1(D5,R7),WORKROOM(D8)                    @YL026YA
         OI    LRECLOF1+D4(R7),ZONE  GET RID OF SIGN           @YL026YA
VSAM20   EQU   *                                               @YL026YA
         CLI   LRECLOF1(R7),ZONE   ARE THERE HIGHORDER ZEROS?  @YL026YA
         BNE   VSAM40              NO - VALUE OK AS IS         @YL026YA
         MVC   LRECLOF1(L5,R7),LRECLOF1+D1(R7) SHIFT NUMBER    @YL026YA
         B     VSAM20              REPEAT ZERO TEST            @YL026YA
VSAM30   EQU   *                   NO LRECL VALUE              @YL026YA
         MVC   LRECLOF1(L'NOVAL,R7),NOVAL  UNDEFINED VALUE     @YL026YA
         B     VSAM50              BRANCH TO GET DATES          ZA02196
VSAM40   EQU   *                                               @YL026YA
         MVC   TYPEOFF(L4,R7),VSAMCON   MOVE IN CONSTANT VSAM   ZA02196
VSAM50   EQU   *                                               @YL026YA
         TM    CONTROL,HISTORY     HISTORY                     @ZA06146
         BNO   VSAM60              NO                          @ZA06146
         LA    R3,CTGFL7           GET CREATION DATE FPL       @YL026YA
         L     R3,CTGFLPT          GET ADDRESS OF CREATE DATE  @YL026YA
         XC    WRKCREDT(L3),WRKCREDT    ZERO CREATE COMM AREA  @ZA07714
         TM    1(R3),FOXES              IS CREATE DATE FOXES?  @ZA07714
         BO    VSAM55                   YES CHECK EXPIRE DATE  @ZA07714
         XC    SAVELEN(L8,R13),SAVELEN(R13) ZERO WORK AREA     @ZA06146
         MVC   SAVELEN+6(L2,R13),D1(R3) MOVE IN JULIAN DATE    @ZA06146
         CVB   R1,SAVELEN(R13)          CONVERT TO BINARY      @ZA06146
         STH   R1,WRKCREDT+D1           STORE IN COMM AREA      ZA00105
         XC    SAVELEN(L8,R13),SAVELEN(R13) ZERO WORK AREA     @ZA06146
         LH    R1,D0(R3)                LOAD YYDD INTO REG      ZA00105
         IC    R1,OFFSIGN+D1            MASK DD WITH 'FF'       ZA00105
         SRL   R1,L4                    SHIFT TO YYF            ZA00105
         ST    R1,SAVELEN+4(R13)        STORE IN WORK AREA     @ZA06146
         CVB   R1,SAVELEN(R13)          CONVERT DEC TO BIN     @ZA06146
         STC   R1,WRKCREDT              STORE YY IN COMM AREA   ZA00105
VSAM55   LA    R3,CTGFL8           GET EXPIRATION DATE FPL     @ZA07714
         L     R3,CTGFLPT          GET ADDRESS OF EXPIRE DATE  @YL026YA
         XC    WRKEXPDT(L3),WRKEXPDT    ZERO EXPIRE DATE       @ZA07714
         TM    1(R3),FOXES              IS EXPIRE DATE FOXES?  @ZA07714
         BO    VSAM60                   YES LEAVE ZEROS IN DATE@ZA07714
         XC    SAVELEN(L8,R13),SAVELEN(R13) ZERO WORK AREA     @ZA06146
         MVC   SAVELEN+6(L2,R13),D1(R3) MOVE IN JULIAN DATE    @ZA06146
         CVB   R1,SAVELEN(R13)          CONVT TO BINARY        @ZA06146
         STH   R1,WRKEXPDT+D1           STORE IN COMM AREA      ZA00105
         XC    SAVELEN(L8,R13),SAVELEN(R13) ZERO WORK AREA     @ZA06146
         LH    R1,D0(R3)                LOAD YYDD INTO REG      ZA00105
         IC    R1,OFFSIGN+D1            MASK DD WITH 'FF'       ZA00105
         SRL   R1,L4                    SHIFT TO YYF            ZA00105
         ST    R1,SAVELEN+4(R13)        STORE IN WORK AREA     @ZA06146
         CVB   R1,SAVELEN(R13)          CONVRT TO BINARY       @ZA06146
         STC   R1,WRKEXPDT              STORE YY IN COMM AREA   ZA00105
VSAM60   LR    R1,R13              SAVE DYNAMIC AREA ADDRESS   @ZA06146
         L     R13,D4(R1)          CALLERS SAVEAREA            @YL026YA
         FREEMAIN R,LV=SAVELEN1,A=(1),SP=WORKSP FREE SAVE AREA @ZA06146
         RETURN (14,12)            RETURN TO CALLER            @YL026YA
         EJECT                                                 @YL026YA
*  CONSTANTS AND EQUATES FOR VSAM BASIC INFO                   @YL026YA
VCONVWRT DC    V(IKJEHWRT)         ADDRESS OF WRITE ROUTINE    @YL026YA
OFFSIGN  DC    X'7FFFFFFF'         TO TURN OFF MINUS BIT       @YL026YA
VSAMHDG  DC    C'--LRECL--DSORG-'  BASIC DATA HEADING           ZA02196
VSAMHHDG DC    C'-CREATED---EXPIRES' HISTORY DATA HEADING      @YL026YA
VSAMSHDG DC    C'--DDNAME---DISP'  STATUS DATA HEADING         @YL026YA
NOVAL    DC    C'**'               REPLACES UNDEFINED VALUES   @YL026YA
VSAMCON  DC    C'VSAM'             CONSTANT FOR VSAM ENTRY      ZA02196
DWORD    DS    D                        DOUBLE WORD WORK AREA   ZA00105
*                                                              @YL026YA
TYPEOFF  EQU   9                   OFFSET TO TYPE CODE         @YL026YA
LRECLOF1 EQU   2                   OFFSET TO LRECL FOR VSAM    @YL026YA
         DROP  R3                                              @YL026YA
         DROP  R10                                             @YL026YA
         EJECT
IKJEHSTA CSECT
         ENTRY IKJEHSTI                                        @YL026YA
***********************************************************************
*                                                                     *
*   THIS ROUTINE IS ENTERED IF STATUS IS SPECIFIED ON THE COMMAND     *
*   WHEN IT IS ENTERED.  THE DYNAMIC ALLOCATION REQUEST BLOCK  @YL026YA
*   HAS ALREADY BEEN INITIALIZED BY THE STATUS INITIALIZATION  @YL026YA
*   ROUTINE (IKJEHSTI).                                        @YL026YA
*   DYNAMIC INFORMATION RETRIEVAL IS CALLED TO OBTAIN          @YL026YA
*   INFORMATION ABOUT THE ALLOCATED DATA SET.                  @YL026YA
*   THE APPROPRIATE INFORMATION (DDNAME, NORMAL AND ABNORMAL DISP)    *
*   ARE EXTRACTED AND FORMATTED IN THE BUFFER.  IF DYNAMIC     @YL026YA
*   INFORMATION RETRIEVAL FAILS, THEN NO STATUS IS AVAILABLE   @YL026YA
*   FOR THIS DSNAME.                                           @YL026YA
*                                                                     *
***********************************************************************
*
STATROUT SAVE  (14,12),,*
         LR    R10,R15             SET UP ADDESSABILITY TO THIS ROUTINE
         USING STATROUT,R10        MAIN BASE FOR THIS ROUTINE
         USING OBTWAD,R12          WORK AREA, R12 PASSED WITH ADDR
         GETMAIN R,LV=SAVELEN,SP=WORKSP  GET A SAVE AREA
         ST    R13,D4(R1)          SAVE CALLERS SAVE AREA
         ST    R1,D8(R13)          SAVE THIS ROUTINES SAVE AREA ADDR
         LR    R13,R1              THIS ROUTINES SAVE AREA ADDRESS
*                                                              @YL026YA
*   PUT DATA SET NAME AND LENGTH IN DYNAMIC ALLOCATION         @YL026YA
*   PARAMETER LIST AND RETRIEVE INFORMATION.                   @YL026YA
*                                                              @YL026YA
         LA    R1,RQBLKAD          ADDRESS OF REQUEST BLOCK    @YL026YA
*                                  POINTER                     @YL026YA
         USING S99RBP,R1                                       @YL026YA
         L     R2,S99RBPTR         ADDRESS OF REQUEST BLOCK    @YL026YA
         USING S99RB,R2                                        @YL026YA
         L     R2,S99TXTPP         ADDRESS OF TEXT POINTER     @YL026YA
*                                  LIST                        @YL026YA
         USING S99TUPL,R2                                      @YL026YA
         L     R5,S99TUPTR         ADDRESS OF FIRST TEXT UNIT  @YL026YA
*                                  POINTER                     @YL026YA
         USING S99TUNIT,R5                                     @YL026YA
         LH    R4,CURNTNAM         LENGTH OF DSNAME            @YL026YA
         STH   R4,S99TULNG         STORE IN PARAMETER LENGTH   @YL026YA
*                                  FIELD                       @YL026YA
         LA    R3,TEMPNAME         ADDRESS OF CURRENT DSNAME   @YL026YA
         LA    R7,S99TUPAR         ADDRESS OF PARAMETER FIELD  @YL026YA
         BCTR  R4,R0               DECREMENT LENGTH FOR MOVE   @YL026YA
         EX    R4,MOVE             MOVE DSNAME                 @YL026YA
         DYNALLOC                                              @YL026YA
         LTR   R15,R15             DID RETRIEVE GO OK?         @YL026YA
         BNZ   STATRT05            NO - EXIT WITH NO INFO      @YL026YA
*
*    WE HAVE A HIT--MOVE DDNAME AND DISP FIELDS TO BUFFER AND OUTPUT
*
         CLI   DSTYPE,CTGTALIN     CHECK FOR VSAM
         BNE   VSAMOFF             YES
         LA    R7,OUTBUF+STATOFF1  POINT AT OFFSET FOR STATUS ALONE
         TM    CONTROL,HISTORY     SEE IF HISTORY WAS SPECIFIED
         BNO   STATRT01            NO USE AS IS
         LA    R7,OUTBUF+STATOFF2  YES, POINT TO NEW OFFSET    @YL026YA
STATRT01 EQU   *
         LA    R2,L'S99TUPTR(R2)   LOOK AT NEXT TEXT UNIT      @YL026YA
         L     R5,S99TUPTR         ADDRESS OF TEXT UNIT        @YL026YB
         LH    R4,S99TULNG         LENGTH OF PARAMETER         @YL026YA
         LTR   R4,R4               IS LENGTH GT ZERO           @ZA06703
         BZ    STANODDN            NO, DON'T PROCESS DDNAME    @ZA06703
         BCTR  R4,R0               DECREMENT FOR MOVE          @YL026YA
         EX    R4,STATMOVE         MOVE DDNAME TO BUFFER       @YL026YA
STANODDN EQU   *                                               @ZA06703
         LA    R2,L'S99TUPTR(R2)   LOOK AT NEXT TEXT UNIT      @YL026YA
         L     R5,S99TUPTR         ADDRESS OF TEXT UNIT        @YL026YB
         LA    R7,D9(R7)           BUMP OUTPUT BUFFER PTR
*
*   TEST STATUS BITS AND MOVE IN APPROPRIATE WORD
*
         TM    S99TUPAR,KEEP       IS IT KEEP                  @YL026YA
         BO    STATKEEP            YES, BRANCH
         TM    S99TUPAR,DELETE     IS IT DELETE                @YL026YA
         BO    STATDELE            YES, BRANCH                 @YL026YA
         TM    S99TUPAR,CATLG      IS IT CATALOG               @YL026YA
         BO    STATCATL            YES BRANCH                  @YL026YA
         TM    S99TUPAR,UNCATLG    IS IT UNCATLG               @YL026YA
         BO    STATUNCT            YES, BRANCH                 @YL026YA
         B     STATRT03            IF UNSPECIFIED, SKIP TO NEXT ROUTINE
VSAMOFF  LA    R7,OUTBUF+L16       OFFSET INTO BUFFER
         TM    CONTROL,HISTORY     HISTORY REQUESTED
         BNO   STATRT01            NO
         LA    R7,OUTBUF+L34       OFFSET FOR HISTORY
         B     STATRT01
STATKEEP LA    R14,SKEEP           ADDRESS OF 'KEEP'
         LA    R15,L'SKEEP         ITS LENGTH
         B     STATRT02            PUT IT INTO BUFFER
*
STATDELE LA    R14,SDELE           ADDRESS OF 'DELETE'
         LA    R15,L'SDELE         ITS LENGTH
         B     STATRT02            PUT IT IN BUFFER
*
STATCATL LA    R14,SCATL           ADDRESS OF 'CATLG'
         LA    R15,L'SCATL         ITS LENGTH
         B     STATRT02            PUT IT INTO THE BUFFER
*
STATUNCT LA    R14,SUNCT           ADDRESS OF 'UNCATLG'
         LA    R15,L'SUNCT         ITS LENGTH
*
*  MOVE CORRECT FIELD TO THE BUFFER
*
STATRT02 EQU   *
         BCTR  R15,R0              DECREMENT COUNT BY ONE
         EX    R15,DISPMOVE        MOVE DISP TO BUFFER
         LA    R7,L1(R15,R7)       POINT AT NEXT LOCATION
*
*   TEST FOR ABNORMAL DISPOSITION
*
STATRT03 EQU   *
         LA    R2,L'S99TUPTR(R2)   LOOK AT NEXT TEXT UNIT      @YL026YA
         L     R5,S99TUPTR         ADDRESS OF TEXT UNIT        @YL026YB
         TM    S99TUPAR,KEEP       IS IT KEEP                  @YL026YA
         BO    STKEEP              YES, BRANCH
         TM    S99TUPAR,DELETE     IS IT DELETE                @YL026YA
         BO    STDELE              YES, BRANCH
         TM    S99TUPAR,CATLG      IS IT CATALOG               @YL026YA
         BO    STCATL              YES, BRANCH
         TM    S99TUPAR,UNCATLG    IS IT UNCATALOG             @YL026YA
         BO    STUNCT              YES, BRANCH
         B     STATRT05            IF UNSPECIFIED, SKIP IT
*
STKEEP   LA    R14,SKEEP           ADDRESS OF 'KEEP'
         LA    R15,L'SKEEP         LENGTH OF KEEP
         B     STATRT04            GO PUT IT INTO BUFFER
*
STDELE   LA    R14,SDELE           ADDRESS OF 'DELETE'
         LA    R15,L'SDELE         LENGTH OF DELETE
         B     STATRT04            GO PUT INTO BUFFER
*
STCATL   LA    R14,SCATL           ADDRESS OF 'CATLG'
         LA    R15,L'SCATL         LENGTH OF CATLG
         B     STATRT04            PUT IT INTO BUFFER
*
STUNCT   LA    R14,SUNCT           ADDRESS OF 'UNCATLG'
         LA    R15,L'SUNCT         ITS LENGTH
*
*   MOVE THE CORRECT FIELD TO THE BUFFER
*
STATRT04 EQU   *
         MVI   D0(R7),COMMA        PUT A COMMA SEPARATOR IN BUFFER
         LA    R7,L1(R7)           BUMP POINTER FOR LENGTH OF COMMA
         BCTR  R15,R0              DECREMENT COUNT FOR MOVE
         EX    R15,DISPMOVE        MOVE DISP TO BUFFER
*
STATRT05 EQU   *
         LR    R1,R13              SAVE ADDRESS OF CORE TO FREE
         L     R13,D4(R1)          USERS SAVEAREA
         FREEMAIN R,LV=SAVELEN,A=(1),SP=WORKSP
         RETURN (14,12)
*
*    EQUATES AND CONSTANTS USED BY STATUS
*
KEEP     EQU   X'08'               KEEP DISP MASK
DELETE   EQU   X'04'               DELETE MASK
CATLG    EQU   X'02'               CATALOG MASK
UNCATLG  EQU   X'01'               UNCATALOG
SKEEP    DC    C'KEEP'             KEEP
SDELE    DC    C'DELETE'           DELETE
SCATL    DC    C'CATLG'            CATALOG
SUNCT    DC    C'UNCATLG'          UNCATALOG
         DS    0H                  ALIGN HALF WORD
DISPMOVE MVC   D0(L0,R7),D0(R14)   EXECUTED TO MOVE DISP
STATMOVE MVC   D0(,R7),S99TUPAR    MOVE DDNAME TO BUFFER       @YL026YA
*
         DROP  R2                                              @YL026YA
         DROP  R10                                             @YL026YA
         DROP  R5
         EJECT                                                 @YL026YA
IKJEHSTI DS    0H                                              @YL026YA
*********************************************************************
*                                                              @YL026YA
*   THIS ROUTINE IS ENTERED VIA BAL R8 IF THE STATUS KEYWORD   @YL026YA
*   IS SPECIFIED ON THE COMMAND.                               @YL026YA
*   IT INITIALIZES THE PARAMETER LIST FOR DYNAMIC INFORMATION  @YL026YA
*   RETRIEVAL, WHICH WILL BE USED LATER TO RETRIEVE STATUS     @YL026YA
*   INFORMATION ABOUT SPECIFIC DATA SETS.                      @YL026YA
*                                                              @YL026YA
**********************************************************************
*  INITIALIZE THE REQUEST BLOCK                                @YL026YA
         XC    DAREQBLK(DABLKLN),DAREQBLK                      @YL026YA
*                                  CLEAR REQUEST BLOCK AREA    @YL026YA
         MVI   DARBLEN,DABLKLN     SET LENGTH OF BLOCK         @YL026YA
         MVI   DAVRBCD,S99VRBIN    SET VERBCODE FOR INFOR-     @YL026YA
*                                  MATION RETRIEVAL            @YL026YA
         LA    R3,TXTPTRS          GET ADDRESS OF TEXT PTRS    @YL026YA
         USING S99TUPL,R3                                      @YL026YA
         ST    R3,DATXTPT          SET ADDRESS OF TEXT POINTERS
         USING S99TUNIT,R2                                     @YL026YA
*   INITIALIZE DSNAME TEXT UNIT                                @YL026YA
         XC    TU1DSN(TU1LNGTH),TU1DSN CLEAR TEXT UNIT         @YL026YA
         LA    R2,TU1DSN           ADDRESS OF TEXT UNIT        @YL026YA
         ST    R2,S99TUPTR         TO TEXT POINTER             @YL026YA
         LA    R3,D4(R3)           MOVE TO NEXT TEXT POINTER   @YL026YA
         MVI   S99TUKEY+D1,DSNKEY  KEY TO RETRIEVE DSNAME      @YL026YA
         MVI   S99TUNUM+D1,L1      ONE PARAMETER               @YL026YA
*   INITIALIZE DDNAME TEXT UNIT                                @YL026YA
         XC    TU2DDN(TU2LNGTH),TU2DDN CLEAR TEXT UNIT         @YL026YA
         LA    R2,TU2DDN           ADDRESS OF TEXT UNIT        @YL026YA
         ST    R2,S99TUPTR         TO TEXT POINTER             @YL026YA
         LA    R3,D4(R3)           MOVE TO NEXT TEXT POINTER   @YL026YA
         MVI   S99TUKEY+D1,DDNKEY  KEY TO RETRIEVE DDNAME      @YL026YA
         MVI   S99TUNUM+D1,L1      ONE PARAMETER               @YL026YA
         MVI   S99TULNG+D1,L'TU2NAM LENGTH OF DDNAME FIELD     @YL026YA
*   INITIALIZE STATUS TEXT UNIT                                @YL026YA
         XC    TU3STAT(TU3LNGTH),TU3STAT CLEAR TEXT UNIT       @YL026YA
         LA    R2,TU3STAT          ADDRESS OF TEXT UNIT        @YL026YA
         ST    R2,S99TUPTR         TO TEXT POINTER             @YL026YA
         LA    R3,D4(R3)           MOVE TO NEXT TEXT POINTER   @YL026YA
         MVI   S99TUKEY+D1,STATKEY KEY TO RETRIEVE STATUS      @YL026YA
         MVI   S99TUNUM+D1,L1      ONE PARAMETER               @YL026YA
         MVI   S99TULNG+D1,L1      FIELD LENGTH IS ONE BYTE    @YL026YA
*   INITIALIZE NORMAL DISPOSITION TEXT UNIT                    @YL026YA
         XC    TU4DSPN(TU4LNGTH),TU4DSPN CLEAR TEXT UNIT       @YL026YA
         LA    R2,TU4DSPN          ADDRESS OF TEXT UNIT        @YL026YA
         ST    R2,S99TUPTR         TO TEXT POINTER             @YL026YA
         LA    R3,D4(R3)           MOVE TO NEXT TEXT POINTER   @YL026YA
         MVI   S99TUKEY+D1,NDSPKEY KEY TO RETRIEVE NORM DISP   @YL026YA
         MVI   S99TUNUM+D1,L1      ONE PARAMETER               @YL026YA
         MVI   S99TULNG+D1,L1      FIELD LENGTH IS ONE BYTE    @YL026YA
*   INITIALIZE CONDITIONAL DISPOSITION TEXT UNIT               @YL026YA
         XC    TU5DSPC(TU5LNGTH),TU5DSPC CLEAR TEXT UNIT       @YL026YA
         LA    R2,TU5DSPC          ADDRESS OF TEXT UNIT        @YL026YA
         ST    R2,S99TUPTR         TO TEXT POINTER             @YL026YA
         OI    S99TUPTR,S99TUPLN   INDICATE LAST TEXT UNIT     @YL026YA
         MVI   S99TUKEY+D1,CDSPKEY KEY TO RETRIEVE COND DISP   @YL026YA
         MVI   S99TUNUM+D1,L1      ONE PARAMETER               @YL026YA
         MVI   S99TULNG+D1,L1      FIELD LENGTH IS ONE BYTE    @YL026YA
*   POINT TO REQUEST BLOCK                                     @YL026YA
         LA    R2,DAREQBLK         ADDRESS OF REQUEST BLOCK    @YL026YA
         ST    R2,RQBLKAD          TO PARAMETER LIST POINTER   @YL026YA
         OI    RQBLKAD,S99RBPND    TURN HIGH-ORDER BIT ON      @YL026YA
         DROP  R2                                              @YL026YA
         DROP  R3                                              @YL026YA
         BR    R8
         EJECT
IKJEHMBR CSECT                                                 @YL026YA
***********************************************************************
*                                                              @YL026YA
*   THIS ROUTINE CHECKS FOR DSNAME BEING A MEMBER NAME, CHECKS @YL026YA
*   TO SEE IF LABEL WAS SPECIFIED, AND CHECKS TO SEE IF THE    @YL026YA
*   MEMBERS OPTION WAS SPECIFIED.  IKJEHMBR IS ENTERED FROM    @YL026YA
*   THE MAINLINE PROCESSING ROUTINE VIA BALR 14,15.            @YL026YA
*                                                              @YL026YA
***********************************************************************
MEMCHK   SAVE  (14,12),,*                                      @YL026YA
         LR    R10,R15             SET UP ADDESSABILITY TO THIS ROUTINE
         USING MEMCHK,R10          MAIN BASE FOR THIS ROUTINE  @YL026YA
         USING OBTWAD,R12          WORK AREA, R12 PASSED WITH ADDR
         GETMAIN R,LV=SAVELEN,SP=WORKSP  GET A SAVE AREA       @YL026YA
         ST    R13,D4(R1)          SAVE CALLERS SAVE AREA      @YL026YA
         ST    R1,D8(R13)          SAVE THIS ROUTINES SAVE AREA ADDR
         LR    R13,R1              THIS ROUTINES SAVE AREA ADDRESS
*                                                              @YL026YA
         TM    CONTROL,MEMNAME     IS DSNAME   A MEMBERNAME    @YL026YA
         BNO   LABELCHK            NO, GO CHECK LABEL KEYWORD  @YL026YA
         BAL   R8,MNAMROUT         LIST MEMBER DIRECTORY INFORMATION
LABELCHK TM    CONTROL,LABEL       SEE IF LABEL KEYWORD WAS SPECIFIED
         BNO   MEMBCHK             CHECK FOR MEMBERS KEYWORD   @YL026YA
         L     R15,VCONLBL         GET ADDR OF LABEL PROCESSING ROUTINE
         BALR  R14,R15             GO                          @YL026YA
MEMBCHK  EQU   *                                               @YL026YA
         TM    CONTROL,MEMBERS     WAS MEMBERS SPECIFIED       @YL026YA
         BNO   MEMEND              NO GO TEST FOR MORE NAMES IN LIST
         BAL   R8,MEMROUT          GO LIST PDS DIRECTORY       @YL026YA
MEMEND   LR    R1,R13
         L     R13,D4(R1)          SAVE AREA ADDRESS           @YL026YB
         RETURN (14,12)            RETURN TO PROCESS MORE NAMES
         EJECT                                                 @YL026YA
MEMROUT  DS    0H
***********************************************************************
*
*     THIS ROUTINE GETS CONTROL IF THE MEMBERS KEYWORD WAS SPECIFIED.
*     IT CHECKS DSORG FOR PARTITIONED DATASET AND IF PARRTITIONED
*     SETS UP LINKAGE TO IKJEHMEM WHICH WILL LIST OUT THE DIRECTORY.
*
***********************************************************************
         TM    DSORGSV,PO          IS DS PO
         BCR   CONDZERO,R8         NO, RETURN TO MAINLINE
         LA    R7,OUTBUF           SETUP TO
         LR    R6,R8               SAVE RETURN ADDRESS
         MVC   D0(L'MEMHDG,R7),MEMHDG  MOVE HEADING TO BUFFER
         LA    R14,L'MEMHDG(R7)
         L     R15,VCONWRIT        GET ADDRESS OF WRITE ROUTINE
         BALR  R8,R15              GO WRITE BUFFER             @YL026YA
         TM    CONTROL,JFCB        SEE IF JFCB WAS READ
         BO    MEMLINK             IF YES, GO LINK TO IKJEHMEM
         TM    ALLOCSW,ON          ALLOC OK
         BO    DCODE00             YES JUST DO RDJFCB
         L     R15,VCONALC         ADDRESS OF ALLOCATE ROUTINE @YL026YA
         BALR  R8,R15              GO ALLOCATE DATA SET        @YL026YA
         TM    ALLOCSW,ON          ALLOCATE OKAY
         BO    DCODE00             YES DO RDJFCB
         B     MEMEND              NO GET NEXT DSNAME          @YL026YA
*
*
DCODE00  EQU   *
         LA    R2,OBTDCB
         LA    R3,DAIRLIST         ADDRESS OF DAIR LIST
         USING DAPB08,R3           DAIR 08  ENTRY DSECT ADDRESSABILITY
         USING IHADCB,R2
         MVC   DCBDDNAM(DDNAMLEN),DA08DDN PUT DDNAME IN DCB
         DROP  R3
         LA    R1,RDJL
         LA    R3,OBTDCB
         RDJFCB ((R3)),MF=(E,(R1))
         DROP  R2
         OI    CONTROL,JFCB        INDICATE RDJFCB WAS ISSUED
MEMLINK  EQU   *
         L     R15,MEMMOD
         LA    R1,CALLIST
         CALL  (15),((R12),GETML,OUTBUF,WRITE,FREEML),VL,MF=(E,(1))
         B     MEMCODE(R15)        ANALYZE IKJEHMEM RETURN CODE
MEMCODE  B     MEMCDE00            SUCCESS
         B     MEMCDE04            INSUFFICIENT CORE
         B     MEMCDE08            I/O ERROR
* THIS IS RC=12, MEMCDE12 MUST FOLLOW                            100000
MEMCDE12 EQU   *
         MVI   ERR2,SECMSG04       SECOND LEVEL MESSAGE 4
MEMERROR EQU   *
MEMSYN   EQU   *
         MVI   ERR1,MSG04          MEMBERS NOT AVAIL
         L     R15,VCONERR         GET ADDRESS OF ERROR MSG    @YL026YA
         BALR  R8,R15              GO PUT OUT MESSAGE          @YL026YA
MEMCDE00 EQU   *
         LR    R8,R6
         BR    R8                  RETURN TO CALLER
MEMCDE04 MVI   ERR2,SECMSG06       SECOND LEVEL MESSAGE 6        100000
         B     MEMERROR            GO PROCESS ERROR              100000
MEMCDE08 MVI   ERR2,SECMSG05       SECOND LEVEL MESSAGE 5        100000
         LA    R2,SYNMSG           POINTER TO SYNAD DATA-        100000
         ST    R2,ERRINST2         TO I/O PARM LIST              100000
         B     MEMSYN              FINISH UP MSG                 100000
         EJECT
MNAMROUT EQU   *
***********************************************************************
*                                                                     *
*   THIS ROUTINE GETS CONTROL IF THE DSNAME SPECIFIED WAS A MEMBER    *
*   NAME.  A CHECK IS MADE TO SEE IF DSORG IS PO, AND IF NOT, A       *
*   DIAGNOSTIC IS PUT TO THE TERMINAL. THE JFCB CONTROL BIT IS CHECKED*
*   AND IF ON THE DDNAME IS ALREADY IN THE DCB. THE DSORG IS MADE PO. *
*   IF IT IS OFF, CONTROL IS PASSED TO DAIR TO ALLOCATE THE DATASET,  *
*   AND THE DDNAME IS TAKEN FROM THE RETURNED LIST.                   *
*
***********************************************************************
         TM    DS1DSORG,PO         IS DATASET PARTITIONED
         BNO   MNAMERR             NO, PROCESS AS AN ERROR
         LA    R7,OUTBUF           SET UP
         TM    CONTROL,JFCB        SEE IF RDJFCB WAS ISSUED
         BNO   MNAMDAIR            IF NOT, GOT ALLOCATE DATASET
         LA    R2,OBTDCB           ADDRESS THE DCB
         USING IHADCB,R2
MNAMOPEN MVI   DCBDSORG,PO         SET DSORG FOR BPAM
***********************************************************************
**  THIS CODE PUT IN TO BYPASS OPEN PROBLEM OF CARRY FIELDS TO        *
**  NEXT USER OF JFCB
*
         SR    R1,R1               CLEAR WORK REG
         ST    R1,DCBEXLST         CLEAR EXIT LIST
         STH   R1,DCBBLKSI         CLEAR BLOCK SIZE
         STH   R1,DCBLRECL         CLEAR LRECL
         STH   R1,DCBKEYLE         CLEAR KEYLENGTH
***********************************************************************
         DROP  R2
         LA    R2,OBTDCB
         LA    R1,OPENL
         OPEN  ((R2)),MF=(E,(1))
         XC    BLDLLIST(BLDLLEN),BLDLLIST    CLEAR BLDL LIST
         LA    R1,BLDL1            INITIALIZE LIST FOR BLDL.
         STH   R1,BLDLLIST         ONE ENTRY
         LA    R1,BLDLMAX
         STH   R1,BLDLL            MAXIMUM LIST LENGTH
        MVI   BLDLNME,BLANK        BLANK OUT MEMBERNAME FIELD
        MVC   BLDLNME+D1(L7),BLDLNME  MOVE IN NAME
         LA    R7,BLDLNME          SET UP FOR MOVING MEMBERNAME
         L     R3,D8(R9)           POINT AT NAME
         LH    R1,D12(R9)          GET LENGTH TO BE MOVED
         BCTR  R1,R0               DECREMENT FOR EX OF MVC
         EX    R1,MOVE             MOVE MEMBER NAME TO LIST
         BLDL  OBTDCB,BLDLLIST
         B     BLDLCODE(R15)       ANALYZE RETURN CODE
BLDLCODE EQU   *
         B     BLDLOK              RC=00  SUCCESS
         B     BLDLERR1            RC=04  ENTRY NOT FOUND
*  THIS IS RC=08, BLDERR MUST FOLLOW                             100000
BLDLERR  EQU   *
         LA    R1,SECMSG07         I/O ERROR IN BLDL
BLDLERR2 STH   R1,ERRSECND         PUT IN LIST
         MVI   ERR1,MSG05          DIR INFO NOT AVAIL
         L     R15,VCONERR         GET ADDRESS OF ERR ROUTINE  @YL026YA
         BALR  R8,R15              GO PUT OUT MESSAGE          @YL026YA
         B     BLDLEXIT            GO TO CLOSE DCB
BLDLERR1 LA    R1,SECMSG09         MEMBER NOT FOUND MSG          100000
         B     BLDLERR2            FINISH REST OF MSG            100000
*
*
****** GO TO ALLOCATE THE DATA SET HERE TO GET THE DDNAME **
*
MNAMDAIR EQU   *
         BAL   R8,ALLOCDS          GO ALLOCATE DATA SET
**********************************************************************
         TM    ALLOCSW,ON          ALLOCATE OKAY
         BO    MNAMRC00            YES PUT DDNAME IN DCB
         B     LABELCHK            GO CHECK LABEL KEYWORD
**********************************************************************
MNAMRC00 EQU  *
         LA    R3,DAIRLIST
         USING DAPB08,R3              OF DAIR MACRO MAP
         LA    R2,OBTDCB
         USING IHADCB,R2
         MVC   DCBDDNAM(L'DA08DDN),DA08DDN  PUT DDNME IN
         DROP  R3
         DROP  R2
         B     MNAMOPEN            GO OPEN DCB
MNAMERR  EQU   *
         MVI   ERR1,MSG05          DIR INFO NOT AVAIL
         MVI   ERR2,SECMSG08       DATA SET NOT PO
         L     R15,VCONERR         GET ADDRESS OF ERR ROUTINE  @YL026YA
         BALR  R8,R15              GO PUT OUT MESSAGE          @YL026YA
         B     LABELCHK            GO CHECK FOR LABEL EKYWORD
BLDLOK   EQU   *
         MVC   OUTBUF(L'MNAMHDG),MNAMHDG  MOVE HEADING TO BUFFER
         LA    R7,OUTBUF           POINT AT BUFFER
         LA    R14,L'MNAMHDG(R7)   POINT AT END OF BUFFER
         L     R15,VCONWRIT        GET ADDR OF WRITE ROUTINE   @YL026YA
         BALR  R8,R15              GO WRITE BUFFER             @YL026YA
         MVC   D2(L8,R7),BLDLNME   MOVE MEMBERNAME TO BUFFER   @YL026YA
         LA    R7,OUTBUF+MNAMTTR   POINT TO BUFFER LOCATION
         LA    R4,BLDLTT           POINT AT TTR                @YL026YA
         LA    R5,D3                INDICATE LENGTH OF DATA TO CONVERT
         LR    R6,R10              SAVE BASE                   @VS06864
         L     R15,VCONBHEX        ADDRESS OF BITOHEX          @VS06864
         L     R10,VCONLBL         ADDRESSABILITY FOR BITOHEX  @VS06864
         BALR  R8,R15              GO
         LR    R10,R6              MAIN ADDRESSABILITY         @VS06864
         TM    BLDLCD,HIGHBIT      TEST FOR ALIAS NAME         @YL026YA
         BO    NOTTRUE             YES, BRANCH
         MVC   OUTBUF+MNAMALI(L'NO),NO   NOT AN ALIAS
BLDLNEX  EQU   *
         NI    BLDLCD,NOHIBIT      TURN OFF ALIAS BIT
         XR    R1,R1               CLEAR REG
        IC    R1,BLDLCD            AND INSERT BYTE
         SRL   R1,D5               SHIFT OUT UNNEEDED BITS
         STC   R1,OUTBUF+MNAMTTRN  PUT TTRN IN BUFFER
         OI    OUTBUF+MNAMTTRN,ZONE  SET SIGN POSITIVE
        NI    BLDLCD,ONEF          TURN OFF UNNEEDED BITS
         LA    R7,OUTBUF+MNAMCNT   POINT TO PROPER BUFFER POSITION
         LA    R4,BLDLCD           POINT AT DATA TO CONVERT
         LA    R5,DTACNT           DATA BYTE COUNT
         LR    R6,R10              SAVE BASE                   @VS06864
         L     R15,VCONBHEX        ADDRESS OF BITOHEX          @VS06864
         L     R10,VCONLBL         ADDRESSABILITY FOR BITOHEX  @VS06864
         BALR  R8,R15              GO
         LR    R10,R6              MAIN ADDRESSABILITY         @VS06864
*  THE FOLLOWING PROCESSES AND PRINTS THE USER DATA
         LA    R7,OUTBUF+MNAMDATA  POINT AT PROPER BUFFER LOCATION.
        LA    R4,BLDLUSR           POINT AT USER DATA
BLDLOK00 ST    R7,WORKROOM         SAVE
         ST    R4,WORKROOM+USERFLD  POINTERS.
         XR    R5,R5
        IC    R5,BLDLCD            PICK UP HW COUNT
         LTR   R5,R5               TEST COUNT FOR ZERO
         BZ    BLDLEND             IF ZERO, OUTPUT IS FINISHED
         MVI   BLDLCD,ZERO         CLEAR CNT IN LIST
         CH    R5,TWO              COMPARE COUNT TO 2
         BNH   BLDLOK01            IF LESS OR EQUAL,USE AS IS
         SH    R5,TWO              IF MORE, DECREMENT BY TWO
        STC   R5,BLDLCD            AND STORE BACK IN LIST
         LH    R5,TWO              SET COUNT TO CONVERT TO TWO
BLDLOK01 AR    R5,R5               CHANGE HALFWORD COUNT TO BYTE COUNT
         LR    R6,R10              SAVE BASE                   @VS06864
         L     R15,VCONBHEX        ADDRESS OF BITOHEX          @VS06864
         L     R10,VCONLBL         ADDRESSABILITY FOR BITOHEX  @VS06864
         BALR  R8,R15              GO
         LR    R10,R6              MAIN ADDRESSABILITY         @VS06864
         L     R7,WORKROOM         GET BUFFER PTR AND
         LA    R7,BUFPTLN(R7)       INCREMENT IT.
         LA    R6,OUTBUF+LSTFLD    COMPARE IT AGAINST
         CR    R7,R6               END OF BUFFER.
         BL    BLDLOK02            IF LESS, PROCESS MORE DATA.
         LA    R7,OUTBUF           IF MORE OR EQUAL, PUT OUT.
         LA    R14,LOCSAVOF(R7)       THE BUFFER AND RESET PTR.
         L     R15,VCONWRIT        GET ADDR OF WRITE ROUTINE   @YL026YA
         BALR  R8,R15              GO WRITE BUFFER             @YL026YA
BLDLOK02 L     R4,WORKROOM+USERFLD  GET DATA PTR AND
         LA    R4,D4(R4)           INCREMENT IT.
         B     BLDLOK00            GO PROCESS MORE DATA.
BLDLEND  LA    R7,OUTBUF           GET BUFFER ADDRESS
         L     R6,WORKROOM         SEE IF THERE IS ANY
         CR    R6,R7               DATA TO OUTPUT
         BE    BLDLEXIT            NO, SKIP WRITE ROUTINE
         LA    R14,LOCSAVOF(R7)    SET END OF BUFFER INDICATION
         L     R15,VCONWRIT        GET ADDR OF WRITE ROUTINE   @YL026YA
         BALR  R8,R15              GO WRITE BUFFER             @YL026YA
BLDLEXIT EQU   *
         LA    R2,OBTDCB
         LA    R1,CLOSEL           POINT AT LIST FORM OF CLOSE
         CLOSE  ((R2)),MF=(E,(1))
         LA    R2,OBTDCB           SET UP ADDRESSABILITY TO DCB
         USING IHADCB,R2
***********************************************************************
**  THIS CODE PUT IN TO BYPASS OPEN PROBLEM                           *
*                                                                     *
         MVC   OBTDCB(EOLFS-DCBMDL),DCBMDL   SET DCB FIELDS BACK
         MVI   OBTJFCBX,EXITCODE   SET JFCB DCB EXIT CODE
***********************************************************************
         LA    R1,OBTDCBXL         ADDRESS OF EXIT LIST FOR DCB
         ST    R1,DCBEXLST         RE-ESTABLISH EXIT LIST FOR JFCB
         DROP  R2
         B     LABELCHK            CHECK LABEL OPTION
NOTTRUE  MVC   OUTBUF+MNAMALI(L'YES),YES
         B     BLDLNEX             DO NEXT BLDL
         EJECT                                                 @YL026YA
***********************************************************************
*                                                              @YL026YA
*   CONSTANTS FOR MEMBER NAME AND MEMBERS OPTION PROCESSING    @YL026YA
*                                                              @YL026YA
***********************************************************************
MNAMHDG  DC    C'--MEMBER---TTR----ALIAS-TTRN-CNT-DATA'        @YL026YA
YES      DC    C'YES'              IS AN ALIAS NAME            @YL026YA
NO       DC    C'NO'               IS NOT AN ALIAS NAME        @YL026YA
TWO      DC    H'2'                TWO                         @YL026YA
MEMHDG   DC    C'--MEMBERS--'      HEADING FOR MEMBERS         @YL026YA
VCONLBL  DC    V(IKJEHLBL)         ADDRESS OF LABEL ROUTINE    @YL026YA
VCONWRIT DC    V(IKJEHWRT)         ADDRESS OF WRITE ROUTINE    @YL026YA
VCONERR  DC    V(IKJEHERR)         ADDRESS OF ERROR ROUTINE    @YL026YA
VCONALC  DC    V(IKJEHALC)         ADDRESS OF ALLOCATE ROUTINE @YL026YA
VCONBHEX DC    V(IKJEHBTX)         ADDRESS OF BIT-TO-HEX RTN   @YL026YA
         EJECT
IKJEHDS1 CSECT                                                 @YL026YA
*
*  MACRO 'LIST' FORMS
*
*
TPUTMDL  PUTLINE MF=L
ENDTPUT  EQU   *
LTPUTL   EQU   ENDTPUT-TPUTMDL
OLFS     EQU   *                   BEGINNING OF LIST FORMS
RDJMDL   RDJFCB                    (,(INPUT)),MF=L
CLSTMDL  CAMLST                    SEARCH,OBTMDLNM,OBTMDLVO,OBTMDLWA
OBTMDLNM EQU   0
OBTMDLVO EQU   0
OBTMDLWA EQU   0
DCBMDL   DCB   DSORG=PS,MACRF=R,RECFM=F,BLKSIZE=256,KEYLEN=8,LRECL=256,C
               DDNAME=DUMMY
OPENMDL  OPEN  (,),MF=L            LIST FORM OF OPEN
READMDL  READ  RMDECB,SF,,,'S',,,MF=L  MODEL FOR LIST FORM OF READ
CLOSEMDL CLOSE (,),MF=L            MODEL FOR LIST FORM OF CLOSE
EOLFS    EQU   *                   END OF LIST FORMS
LOLFS    EQU   EOLFS-OLFS          LENGTH OF AREA TO MOVE.
ILFS EQU *
GETMLMDL GETMAIN EC,MF=L
FREEMMDL FREEMAIN E,MF=L
EILFS    EQU   *
LILFS    EQU   EILFS-ILFS
MOVE     MVC   D0(L0,R7),D0(R3)    GENERAL MOVE EXECUTED       @YL026YA
PARSECON DC    V(IKJEHPRM)         ADDRESS OF PARSE MACROS
*
MSGCSECT DC    V(IKJEHDSM)         ADDRESS OF MESSAGES CSECT
VCONBTHX DC    V(IKJEHBTX)         ADDRESS OF BIT-TO-HEX ROUTINE
BSCVCON  DC    V(IKJEHBSC)         ADDRESS OF BASIC INFO ROUTINE
VCONLABL DC    V(IKJEHLBL)         ADDRESS OF LABEL ROUTINE    @YL026YA
HISTVCON DC    V(IKJEHHIS)         ADDRESS OF HISTORY ROUTINE
STATVCON DC    V(IKJEHSTA)         ADDRESS OF STATUS ROUTINE
VCONMEM  DC    V(IKJEHMBR)         ADDRESS OF MEMBERS ROUTINE  @YL026YA
VCONAST  DC    V(IKJEHDS2)         ADDRESS OF ASTERISK ROUTINE @YL026YA
VSAMVCON DC    V(IKJEHVSM)         ADDRESS OF VSAM BASIC RTN   @YL026YA
STIVCON  DC    V(IKJEHSTI)         ADDRESS OF STATUS INIT RTN  @YL026YA
VCONCIR  DC    V(CIROUTN)
NOTCHAIN DC    X'FF000000'         END OF LIST INDICATOR FOR   @YL026YA
SUPPL1   DC    X'01000000'         SUBPOOL NUMBER              @YL026YB
*                                  PARSE                       @YL026YA
         DS    0H                  ALIGNMENT                     100000
C210     DC    X'0210'             DARC CODE 0210                100000
C218     DC    X'0218'             DARC CODE 0218                100000
RC16     DC    X'10'               RETURN CDE FOR DAIR CHECK    ZA00612
*   LENGTH OF WORKAREA FOR CIR PARAMETERS                      @YL026YB
CIRLEN   DC    H'5072'             LENGTH                      @YL026YB
*  CONSTANTS FOR VSAM LOCATE AND VSAM DATA SETS                @YL026YA
ENTYPE   DC    CL8'ENTYPE  '       FIELD NAME FOR ENTRY TYPE   @YL026YA
VOLSER   DC    CL8'VOLSER  '       FIELD NAME FOR VOLUME SERIAL
PHYBLKSZ DC    CL8'PHYBLKSZ'       FIELD NAME FOR BLOCK SIZE   @YL026YA
LRECL    DC    CL8'LRECL   '       FIELD NAME FOR RECORD LENGTH
CATACB   DC    CL8'CATACB  '       FIELD NAME FOR CATALOG ACB  @YL026YA
NAMEDS   DC    CL8'NAMEDS  '       FIELD NAME FOR RELATED NAMES
DSETCRDT DC    CL8'DSETCRDT'       FIELD NAME FOR CREATE DATE  @YL026YA
DSETEXDT DC    CL8'DSETEXDT'       FIELD NAME FOR EXPIRE DATE  @YL026YA
VOLLEN   DC    F'6'                LENGTH OF VOLUMES ENTRY     @YL026YA
ASTER    DC    C'**'               SYMBOL FOR UNDEFINED NUMBER @YL026YA
BASICHDG DC    C'--RECFM-LRECL-BLKSIZE-DSORG'  BASIC DATA HEADING
HISTHDG  DC    C'-CREATED---EXPIRES---SECURITY'  HISTORY DATA HEADING
STATHDG  DC    C'--DDNAME---DISP'  STATUS DATA HEADING         @YL026YA
VOLHDING DC    C'--VOLUMES--'      HEADING FOR VOLSER          @YL026YA
VSAMVHDG DC    C'--VOLUMES-BLKSIZE'  HEADING FOR VSAM VOLSER   @YL026YA
FIXAREA  DC    30F'0'              SPACE FOR PATCHES           @ZA10244
         EJECT
IKJEHPRM IKJPARM
PDSLIST  IKJPOSIT DSTHING,USID,LIST,PROMPT='DATA SET NAME'     @YL026YA
PHISTORY IKJKEYWD
         IKJNAME  'HISTORY'
PSTATUS  IKJKEYWD
         IKJNAME  'STATUS'
PMEMBERS IKJKEYWD
         IKJNAME  'MEMBERS'
PLABEL   IKJKEYWD
         IKJNAME  'LABEL'
PCATLG   IKJKEYWD
         IKJNAME 'CATALOG',SUBFLD=PCATSF                       @YL026YA
PLEVEL   IKJKEYWD
         IKJNAME 'LEVEL'                                       @YL026YA
PCATSF   IKJSUBF
PCATNM   IKJPOSIT DSNAME,PROMPT='CATALOG NAME'                 @YL026YA
         IKJENDP
         EJECT
IKJEHDS2 CSECT
         USING IKJEHDS2,R15        ADDRESSABILITY FOR CSECT
         USING OBTWAD,R12          ADDRESSABILITY FOR WORKAREA @YL026YA
***********************************************************************
*              ASTERISK SCAN ROUTINE
*  THIS ROUTINE SCANS THE DATA SET NAME AND LOCATES ASTERISK
*  QUALIFIERS, IF PRESENT.  IT ALSO CHECKS THAT THE ASTERISK DOES NOT
*  OCCUR IN THE FIRST INDEX LEVEL AND THAT THERE IS NOT MORE THAN ONE
*  ASTERISK IN THE DATA SET NAME.  NOTE-  THE SCAN BY PARSE HAS CHECKED
*  SYNTAX OF DATA SET NAME WITH ASTERISK ALLOWED IN PLACE OF ANY INDEX
*  LEVEL.
*  INPUT-      R2 POINTS TO DSNAME TO BE SCANNED
*              R3 CONTAINS LENGTH OF THIS DSNAME
*              R14 IS RETURN REGISTER
*  REGISTERS 2, 3, 4, AND 6 ARE USED
*  RETURN IS AS FOLLOWS-
*              0 PAST R14 IF * FOUND IN FIRST INDEX LEVEL
*              4 PAST R14 IF MORE THAN ONE * FOUND
*              8 PAST R14 IF SCAN SUCCESSFULLY COMPLETED
*
SCANDSN  SR    R4,R4               ZERO REGISTER
         ST    R4,STARADR          ZERO POINTER TO ASTERISK
         STC   R4,STARLEV          ZERO ASTERISK LEVEL INDICATOR
         AR    R3,R2               ADD LENGTH AND ADDRESS
*  REGISTER 3 POINTS PAST LAST CHARACTER OF DATA SET NAME
         LA    R4,D1               INITIALIZE LEVEL COUNTER TO ONE
         LR    R6,R4               SET REG 6 TO ONE FOR A LATER TEST
STARTST2 CLI   D0(R2),STAR         IS THIS CHARACTER AN ASTERISK
         BE    LEVLTST2            IF *, CHECK INDEX LEVEL
NXTCHAR2 LA    R2,D1(R2)           POINT TO NEXT CHARACTER
         CR    R2,R3               ARE THERE MORE CHARACTERS
         BE    ADD8                IF NOT SCAN IS FINISHED
         CLI   D0(R2),PERIOD       CHECK FOR PERIOD (NEW INDEX LEVEL)
         BNE   NXTCHAR2            IF NOT, CHECK NEXT CHARACTER
         LA    R4,D1(R4)           INCREMENT LEVEL COUNTER
         LA    R2,D1(R2)           POINT TO NEXT CHARACTER
         B     STARTST2            NEW INDEX LEVEL, GO CHECK FOR *
LEVLTST2 CR    R4,R6               IS THIS FIRST INDEX LEVEL
         BCR   EQ,R14              YES ERROR, * IN FIRST INDEX LEVEL
         CLI   STARLEV,ZERO        IS LEVEL INDICATOR ZERO     @YL026YA
         BNE   ADD4                NO, ERROR, MORE THAN ONE ASTERISK
         ST    R2,STARADR          SAVE ADDRESS OF ASTERISK
         STC   R4,STARLEV          SAVE LEVEL AT WHICH ASTERISK FOUND
         B     NXTCHAR2            GO CHECK NEXT CHARACTER
ADD4     LA    R14,D4(R14)         BUMP RETURN ADDRESS BY 4
         BR    R14                 RETURN
ADD8     LA    R14,D8(R14)         BUMP RETURN ADDRESS BY 8
         BR    R14                 RETURN
         DROP  R15                 IKJEHDS2 NO LONGER NEEDED
*
*  WHEN THE SCAN IS FINISHED
*        STARLEV  WILL CONTAIN LEVEL AT WHICH ASTERISK FOUND
*        STARADR  WILL CONTAIN ADDRESS AT WHICH ASTERISK FOUND
*        BOTH WILL CONTAIN ZERO IF NO ASTERISK FOUND
*
***********************************************************************
         EJECT
         IKJEHCOM                                              @YL026YA
         ORG   OBTWAEND            ADJUST FOR CONTINUATION OF WORKAREA
PARDSECT DS    F                   ADDRESS OF PARSE DSECT
FIRSTIME DS    C                   CONTROLS UNALLOCATE LOGIC
ALLOCSW  DS    C                   CONTROLS ALLOCATE SWITCH
OPTMASK  DS    C                   CONTAINS KEYWORD INDICATORS
OPTMASK2 DS    C                   CONTAINS KEYWORD INDICATORS @YL026YA
CONTROL  DS    C                   CTL OPTIONS FOR INDIVIDUAL ENTRIES.
DEFLIST  DS    3F                  DEFAULT PARM LIST
SAVEDDN  DS    8X                  DDNAME SAVE AREA
RETADDR  DS    F                   HOLDS ADDRESS OF CALLER TO ALLOCDS
**********************************************************************
*                                                              @YL026YA
*   PARAMETER LIST FOR IKJEHCIR                                @YL026YA
*                                                              @YL026YA
***********************************************************************
CIRADDR  DS    F                   ADDRESS OF IKJEHCIR ROUTINE @YL026YA
CIRPARM  DS    0C                  PARAMETER LIST              @YL026YA
CIROPT   DS    CL1                 OPTION BYTE                 @YL026YA
         DS    CL2                 RESERVED                    @YL026YA
CIRLOCRC DS    CL1                 LOCATE RETURN CODE          @YL026YA
CIRSRCH  DS    F                   POINTER TO NAME             @YL026YA
CIRCVOL  DS    F                   POINTER TO USER CATALOG     @YL026YA
CIRWA    DS    F                   POINTER TO OUTPUT WORKAREA  @YL026YA
CIRSAVE  DS    F                   18-WORD SAVE AREA ADDRESS   @YL026YA
CIRPSWD  DS    F                   POINTER TO 8-BYTE PASSWORD  @YL026YA
CIRPMLN  EQU   *-CIRPARM           LENGTH OF PARAMETER LIST    @YL026YA
***********************************************************************
*
*        THE FOLLOWING CONSTANTS, BUFFER AND PUTLINE MACRO MUST ALL
*        APPEAR TOGETHER IN THE SPECIFIED ORDER SO THAT THE WRITE
*        ROUTINE WILL REMAIN INDEPENDANT OF A BASE REGISTER.
*
***********************************************************************
PARMLSTS DS    0F
PUTLCON  DS    F                   PTR TO LIST FOR PUTLINE MACRO
DPUTLCON DS    F                   PTR TO PUTLINE LIST FORM
UPTPTR   DS    F                   UPT PTR
ECTPTR   DS    F                   ECT PTR
ECBPTR   DS    F                   CP ECB PTR
PUTLADDR DS    F                   ENTRY POINT OF PUTLINE
PARMLSTL EQU   *-PARMLSTS
*
         DS    F                   LL AND OFF FIELDS FOR OUTPUT LINES
OUTBUF   DS    CL108               OUTPUT BUFFER
DPUTLINE PUTLINE MF=L
*
*
*    AREA FOR SERVICE ROUTINE PARM LIST **
PUTLLIST DS    7F                  PARMLIST  FOR RTNS
*
*    END OF SERVICE AREA ROUTINE PARMLIST *
CIRDSN   DS    CL44                DATA SET NAME BUFFER FOR CIR
CIRPASS  DS    CL8                 PASSWORD BUFFER             @YL026YA
STARADR  DS    F                   ADDRESS OF * IN NAME        @YL026YA
STARLEV  DS    CL1                 POSITION OF * IN NAME       @YL026YA
*                                                              @YL026YA
         DS    0H                  HALF WORD BNDRY             @YL026YB
LASTQLEN DS    H                   LENGTH OF TRAILING QUALIFIER
LASTQUAL DS    CL44                TRAILING QUALIFIER BUFFER   @YL026YA
PARSPTR  DS    F                   VALUE OF DSLIST POINTER (R9)
*                                    BEFORE CALLING CIR        @YL026YA
NAMEBUFF DS    CL44                FOR BUILDING FULLY QUALIFIED
*                                  NAME TO TEST AGAINST        @YL026YA
CATBUFF  DS    CL44                44-BYTE CATALOG NAME        @YL026YA
PROCNM   DS    CL1                 NAME PROCESSING INDICATOR - @YL026YA
*                                   X'00' - NAME FROM DSLIST   @YL026YA
*                                   X'FF' - NAME FROM CIR LIST @YL026YA
         DS    0H                       HALF WORD BNDRY         ZA00105
         DS    CL1                 ALIGN LAST 2 BYTES OF        ZA00105
*                                  CREDT TO HALF WORD           ZA00105
WRKCREDT DS    CL3                 COMMON CREATION DATE        @YL026YA
         DS    CL1                 ALIGN LAST 2 BYTES OF        ZA00105
*                                  EXPDT TO HALF WORD           ZA00105
WRKEXPDT DS    CL3                 COMMON EXPIRATION DATE      @YL026YA
DSTYPE   DS    CL1                 ENTRY TYPE CODE             @YL026YA
CPECB    DS    F                   CP ECB                      @YL026YA
PSCBPTR  DS    F                   PSCB PTR                    @YL026YA
GETML    GETMAIN EC,MF=L
FREEML   FREEMAIN                  E,MF=L
GETMVCL  GETMAIN VC,MF=L                                       @YL026YA
        EJECT
***********************************************************************
*
*   THE  FOLLOWING 3 WORDS ARE USED TO PASS PARAMETERS TO THE
*   ERROR HANDLING ROUTINE. THE FIRST TWO BYTES CONTAIN THE RELATIVE
*   POSITION OF THE MESSAGE IN THE MESSAGE CSECT. THE NEXT TWO BYTES
*   CONTAIN THE A NUMBER THAT INDICATES WHICH SECOND LEVEL MESSAGE
*   IS TO BE SELECTED. THE SECOND WORD POINTS A FIELD CONTAINING
*   A ONE BYTE LENGTH FIELD FOLLOWED BY DATA TO BE INSERTED IN THE
*   FIRST MESSAGE. THE LAST WORD CONTAINS A SIMILAR POINTER FOR THE
*   SECOND MESSAGE.
*
***********************************************************************
ERRPARM  DS    0F
ERRFIRST DS    H                   FIRST LEVEL MSG RELATIVE NUMBER
ERRSECND DS    H                   SECOND LEVEL MSG RELATIVE NUMBER
ERRINST1 DS    F                   PTR TO INSERT DATA FOR LEVEL 1
ERRINST2 DS    F                   PTR TO INSERT DATA FOR LEVEL 2
ERREND   EQU   *
ERRLIST  EQU   ERREND-ERRPARM
ERR1     EQU   ERRFIRST+D1
ERR2     EQU   ERRSECND+D1
         DS    0D
ERRINSRT DS    CL45                FOR PASSING DATA TO ERROR HANDLER TO
*                                BE INSERTED IN A MESSAGE
WORKROOM EQU   ERRINSRT
MSGPARM1 DS    1F                  FIRST LEVEL MSG PARM LIST
MPM11    DS    1F                  OFFSET OF 4
MPM12    DS    1F                  OFFSET OF 8
MSGPARM2 DS    1F                  SECOND LEVEL MSG PARM LIST
MPM21    DS    1F                  OFFSET OF 4
MPM22    DS    1F                  OFFSET OF 8                 @YL026YA
DAIRLIST DS    21F                 DAIR PARAMETER LIST           YM1019
         DS    0H                  HALFWORD ALIGN NEXT FIELD     A42337
CURNTNAM DS    CL47                DSNAME CURRENTLY BEING PROCESSED
TEMPNAME EQU   CURNTNAM+2          ADDRESS OF CURRENT NAME
MEMMOD   DS    F                   CONTAINS ADDRESS OF IKJEHMEM
DSORGSV  DS    CL2                 SAVE DSORG TYPE
* * * * * * * * * * * * * * * * * * *
BLDLLIST DS    0H                  LIST FOR BLDL MACRO
BLDLFF  DS    H                    FLAG OPTIONS
BLDLL   DS    H                    LENGTH OF ENTRY
BLDLNME  DS    CL8                 MEMBERNAME
BLDLTT   DS    H                   RELATIVE TRACK NUMBER
BLDLR    DS    X                   BLOCK NUMBER
BLDLK    DS    X                   CONCATENATION NUMBER
BLDLZ    DS    X                   WHERE FOUND
BLDLCD   DS    X                   MASK OF TYPE NAME
BLDLUSR  DS    31H                 USER AREA
         DS    8F                  ADDED SPACE FOR I/O SYNAD ERROR
* * * * * * * * * * * * * * * * * * *
SAVEAREA DS    28F                 SAVEAREA AND LOCAL SAVEAREA
OBTCCHHR DS    CL5                 HOLDS CCHHR OF NEXT DSCB IN CHAIN
STACKSW  DS    CL1                 INDICATE FLUSH STACK AND CLEAR QUEUE
STACKPRM DS    2F                  STACK PARM BLOCK
         EJECT
***********************************************************************
*                                                              @YL026YA
*   THE FOLLOWING DECLARES ARE USED FOR DYNAMIC INFORMATION    @YL026YA
*   RETRIEVAL.                                                 @YL026YA
*                                                              @YL026YA
***********************************************************************
DAREQBLK DS    0F                  REQUEST BLOCK FOR DYNAMIC   @YL026YA
*                                  ALLOCATION                  @YL026YA
DARBLEN  DS    CL1                 LENGTH OF BLOCK             @YL026YA
DAVRBCD  DS    CL1                 VERB CODE                   @YL026YA
DAFLGS1  DS    CL2                 FLAGS                       @YL026YA
DAERRCD  DS    CL2                 ERROR REASON CODE           @YL026YA
DAINFCD  DS    CL2                 INFORMATIONAL RETURN CODE   @YL026YA
DATXTPT  DS    CL4                 ADDRESS OF TEXT POINTERS    @YL026YA
         DS    CL4                                             @YL026YA
         DS    CL4                                             @YL026YA
DABLKLN  EQU   *-DAREQBLK          LENGTH OF REQUEST BLOCK     @YL026YA
*                                                              @YL026YA
TXTPTRS  DS    5F                  ADDRESSES OF TEXT UNITS     @YL026YA
TU1DSN   DS    0C                  TEXT UNIT FOR DSNAME        @YL026YA
TU1KEY   DS    CL2                                             @YL026YA
TU1NUM   DS    CL2                                             @YL026YA
TU1LEN   DS    CL2                                             @YL026YA
TU1NAM   DS    CL44                                            @YL026YA
TU1LNGTH EQU   *-TU1DSN                                        @YL026YA
TU2DDN   DS    0C                  TEXT UNIT FOR DDNAME        @YL026YA
TU2KEY   DS    CL2                                             @YL026YA
TU2NUM   DS    CL2                                             @YL026YA
TU2LEN   DS    CL2                                             @YL026YA
TU2NAM   DS    CL8                                             @YL026YA
TU2LNGTH EQU   *-TU2DDN                                        @YL026YA
TU3STAT  DS    0C                  TEXT UNIT FOR STATUS        @YL026YA
TU3KEY   DS    CL2                                             @YL026YA
TU3NUM   DS    CL2                                             @YL026YA
TU3LEN   DS    CL2                                             @YL026YA
TU3VALUE DS    CL1                                             @YL026YA
TU3LNGTH EQU   *-TU3STAT                                       @YL026YA
TU4DSPN  DS    0C                  TEXT UNIT FOR NORMAL DISP   @YL026YA
TU4KEY   DS    CL2                                             @YL026YA
TU4NUM   DS    CL2                                             @YL026YA
TU4LEN   DS    CL2                                             @YL026YA
TU4VALUE DS    CL1                                             @YL026YA
TU4LNGTH EQU   *-TU4DSPN                                       @YL026YA
TU5DSPC  DS    0C                  TEXT UNIT FOR COND. DISP.   @YL026YA
TU5KEY   DS    CL2                                             @YL026YA
TU5NUM   DS    CL2                                             @YL026YA
TU5LEN   DS    CL2                                             @YL026YA
TU5VALUE DS    CL1                                             @YL026YA
TU5LNGTH EQU   *-TU5DSPC                                       @YL026YA
*   INFORMATION RETRIEVAL KEYS FOR FIELDS                      @YL026YA
DSNKEY   EQU   X'02'               DSNAME                      @YL026YA
DDNKEY   EQU   X'04'               DDNAME                      @YL026YA
STATKEY  EQU   X'07'               STATUS                      @YL026YA
NDSPKEY  EQU   X'08'               NORMAL DISPOSITION          @YL026YA
CDSPKEY  EQU   X'09'               CONDITIONAL DISPOSITION     @YL026YA
*                                                              @YL026YA
RQBLKAD  DS    0F                  POINTER TO REQUEST BLOCK    @YL026YA
*   END OF INFORMATION RETRIEVAL AREAS                         @YL026YA
         EJECT                                                 @YL026YA
TMPSR1   DS    F                   SAVE TMP'S REGISTER 1 HERE
STAEADDR DS    F                   ADDRESS OF IKJUSTAE
CNVRTWD  DS    H                   CONTAINS RETURN CODE
*  DATA SET NAME INSERTION BUFFER FOR MESSAGES                   A42337
MSGNAMEL DS    H                   DSNAME LENGTH                 A42337
MSGNAME  DS    CL48                DSNAME FOR MESSAGE INSERTION  A42337
         PSEUDO MF=L
STAELIST STAE  STAEADDR,PARAM=STAEPARM,MF=L
STAEONE  STABUILD CODE=(113,213,313,713,913),ADDR=STAEONE,NUM=2,       X
               FLAG=(MUL,NMSG),LIST=STAELST,RTN=OPENERR,               X
               MF=L
STAETWO  STABUILD CODE=000,RTN=ANYABND,ADDR=STAETWO,                   X
               FLAG=(ALL,NMSG,END),                                    X
               MF=L
         ORG
         STAEPARM FLAG=(CP),LIST=STAEONE,ADDR=STAEPARM,PSEUDO=$PSEUDO, X
               MF=L
STAELNTH EQU   *-STAELIST          SIZE OF STAE LISTS
LABELHEX EQU   BLDLLIST            FOR CONVERTING LABEL TO HEX
SECBUFF  EQU   BLDLLIST
         IEZCTGPL                                              @YL026YA
         EJECT                                                 @YL026YA
         IEZCTGFL                                              @YL026YA
         EJECT                                                 @YL026YA
OBTWAD   DSECT                                                 @YL026YA
CPLAREA  DS    CL(CTGPLLEN)        SPACE FOR CPL               @YL026YA
         DS    7A                  SPACE FOR FIELD POINTERS    @YL026YA
CATWORK1 DS    CL512               CATALOG WORK AREA           @YL026YA
CATWORK2 DS    CL512               CATALOG WORK AREA ALSO      @YL026YA
CTGFL1   DS    6A                  FPL SPACE                   @YL026YA
CTGFL2   DS    6A                  FPL SPACE                   @YL026YA
CTGFL3   DS    6A                  FPL SPACE                   @YL026YA
CTGFL4   DS    6A                  FPL SPACE                   @YL026YA
CTGFL5   DS    6A                  FPL SPACE                   @YL026YA
CTGFL6   DS    6A                  FPL SPACE                   @YL026YA
CTGFL7   DS    6A                  FPL SPACE                   @YL026YA
CTGFL8   DS    6A                  FPL SPACE                   @YL026YA
WORKSIZE EQU   *-OBTDSNAM
         EJECT
         DCBD  DSORG=PS
         EJECT
         CVT
         EJECT
         IKJTCB
         EJECT
         IEFZB4D0                                              @YL026YA
         EJECT
         IKJCPPL
         IKJPSCB
         IKJUPT                                                @YL026YB
         IKJPPL
         IKJDAPL
         EJECT                                                 @YL026YA
         IKJDFPL
         IKJDFPB
         EJECT
         IKJDAP2C
DAIR2CLN EQU   *-DAPB2C            LENGTH OF DAIR PARM BLOCK 2C
         EJECT
         IKJDAP08
DAIR08LN EQU   *-DAPB08            LENGTH OF DAIR08 PARM BLOCK
         EJECT
IKJEHDSM CSECT
***********************************************************************
*                                                                     *
*        THIS MODULE CONTAINS THE MESSAGES USED BY THE LISTDS COMMAND *
*                                                                     *
*        THE BEGINNING OF THE CSECT CONTAINS A TABLE WITH ONE DWORD   *
*        ENTRY FOR EACH MESSAGE. THE FIRST HWORD CONTAINS THE LENGTH  *
*        OF THE FIRST LEVEL MESSAGE. THE SECOND HWORD CONTAINS THE    *
*        OFFSET OF THE MESSAGE INTO THE CSECT. THE THIRD HWORD        *
*        CONTAINS THE OFFSET TO THE SEGMENT STRING.    THE FOURTH     *
*        AND LAST HWORD POINTS TO A CHAIN OF FWORDS POINTING TO THE   *
*        SECOND LEVEL MESSAGES.                                       *
*
***********************************************************************
STARTDSM DS    0F                  ALIGN TO A FULL WORD BOUNDARY
         DC    AL2(L'MSGE1)        LENGTH OF MESSAGE 1
         DC    AL2(MSGE1-STARTDSM) OFFSET OF MESSAGE 1
         DC    AL2(OFFSEG1-STARTDSM)            OFFSET TO NEXT SEGMENT
         DC    AL2(SECLEVEL-STARTDSM) OFFSET TO SECOND LEVEL MESSAGES
         DC    AL2(L'MSGE2)
         DC    AL2(MSGE2-STARTDSM)
         DC    AL2(0)
         DC    AL2(SECLEVEL-STARTDSM)
         DC    AL2(L'MSGE3)
         DC    AL2(MSGE3-STARTDSM)
         DC    AL2(0)
         DC    AL2(SECLEVEL-STARTDSM)
         DC    AL2(L'MSGE4)
         DC    AL2(MSGE4-STARTDSM)
         DC    AL2(0)
         DC    AL2(SECLEVEL-STARTDSM)
         DC    AL2(L'MSGE5)
         DC    AL2(MSGE5-STARTDSM)
         DC    AL2(0)
         DC    AL2(SECLEVEL-STARTDSM)
         DC    AL2(L'MSGE6)
         DC    AL2(MSGE6-STARTDSM)
         DC    AL2(0)
         DC    AL2(SECLEVEL-STARTDSM)
         DC    AL2(L'MSGE7)        LENGTH OF MSG 7
         DC    AL2(MSGE7-STARTDSM) OFFSET TO MSG 7
         DC    AL2(OFFSEG7-STARTDSM)   OFFSET TO SEGMENT
         DC    AL2(SECLEVEL-STARTDSM) SECOND LEVEL TABLE
          DC    AL2(L'MSGE8)
          DC    AL2(MSGE8-STARTDSM)
          DC    AL2(OFFSEG8-STARTDSM)
          DC    AL2(SECLEVEL-STARTDSM)
          DC    AL2(L'MSGE9)
          DC    AL2(MSGE9-STARTDSM)
          DC    AL2(OFFSEG9-STARTDSM)
          DC    AL2(SECLEVEL-STARTDSM)
          DC    AL2(L'MSGE10)
          DC    AL2(MSGE10-STARTDSM)
          DC    AL2(OFFSEG10-STARTDSM)
          DC    AL2(SECLEVEL-STARTDSM)
          DC    AL2(L'MSGE11)
          DC    AL2(MSGE11-STARTDSM)
          DC    AL2(OFFSEG11-STARTDSM)
          DC    AL2(SECLEVEL-STARTDSM)
          DC    AL2(L'MSGE12)
          DC    AL2(MSGE12-STARTDSM)
          DC    AL2(OFFSEG12-STARTDSM)
          DC    AL2(SECLEVEL-STARTDSM)
          DC    AL2(L'MSGE13)
          DC    AL2(MSGE13-STARTDSM)
          DC    AL2(0)
          DC    AL2(SECLEVEL-STARTDSM)
          DC    AL2(L'MSGE14)
          DC    AL2(MSGE14-STARTDSM)
          DC    AL2(0)
          DC    AL2(SECLEVEL-STARTDSM)
          DC    AL2(L'MSGE15)
          DC    AL2(MSGE15-STARTDSM)
          DC    AL2(OFFSEG15-STARTDSM)
          DC    AL2(SECLEVEL-STARTDSM)
*
          DC    AL2(L'MSGE16)
          DC    AL2(MSGE16-STARTDSM)
          DC    AL2(OFFSEG16-STARTDSM)
         DC    AL2(SECLEVEL-STARTDSM)
         DC    AL2(L'MSGE17)
         DC    AL2(MSGE17-STARTDSM)
         DC    AL2(OFFSEG17-STARTDSM)
         DC    AL2(SECLEVEL-STARTDSM)
         DC    AL2(L'MSGE18)                                   @YL026YA
         DC    AL2(MSGE18-STARTDSM)                            @YL026YA
         DC    AL2(OFFSEG18-STARTDSM)                          @YL026YA
         DC    AL2(SECLEVEL-STARTDSM)                          @YL026YA
         DC    AL2(L'MSGE19)                                   @YL026YA
         DC    AL2(MSGE19-STARTDSM)                            @YL026YA
         DC    AL2(0)                                          @YL026YA
         DC    AL2(SECLEVEL-STARTDSM)                          @YL026YA
         DC    AL2(L'MSGE20)                                   @VS06783
         DC    AL2(MSGE20-STARTDSM)                            @VS06783
         DC    AL2(0)                                          @VS06783
         DC    AL2(SECLEVEL-STARTDSM)                          @VS06783
*        SECOND LEVEL MESSAGE TABLE--6 BYTES PER ENTRY INCLUDING A
*        2 BYTE LENGTH, A 2 BYTE MESSAGE OFFSET, A 2 BYTE SEGMENT ADDR.
SECLEVEL DS    0F
         DC    AL2(L'MSGSEC01)
         DC    AL2(MSGSEC01-STARTDSM)
         DC    AL2(0)
         DC    AL2(L'MSGSEC02)
         DC    AL2(MSGSEC02-STARTDSM)
         DC    AL2(0)
         DC    AL2(L'MSGSEC03)
         DC    AL2(MSGSEC03-STARTDSM)
         DC    AL2(0)
         DC    AL2(L'MSGSEC04)
         DC    AL2(MSGSEC04-STARTDSM)
         DC    AL2(0)
         DC    AL2(L'MSGSEC05)
         DC    AL2(MSGSEC05-STARTDSM)
         DC    AL2(0)
         DC    AL2(L'MSGSEC06)
         DC    AL2(MSGSEC06-STARTDSM)
         DC    AL2(0)
         DC    AL2(L'MSGSEC07)
         DC    AL2(MSGSEC07-STARTDSM)
         DC    AL2(0)
         DC    AL2(L'MSGSEC08)
         DC    AL2(MSGSEC08-STARTDSM)
         DC    AL2(0)
         DC    AL2(L'MSGSEC09)     LENGTH OF SEC LEVEL MSG 9
         DC    AL2(MSGSEC09-STARTDSM) OFFSET TO MSG 9
         DC    AL2(0)              OFFSET TO SEGMENT TABLE
         DC    AL2(L'MSGSEC10)     LENGTH OF SEC LEVEL MSG 10
         DC    AL2(MSGSEC10-STARTDSM) OFFSET TO MESSAGE
         DC    AL2(0)              OFFSET TO SEGMENT TABLE
          DC    AL2(L'MSGSEC11)
          DC    AL2(MSGSEC11-STARTDSM)
          DC    AL2(0)
          DC    AL2(L'MSGSEC12)
          DC    AL2(MSGSEC12-STARTDSM)
          DC    AL2(0)
          DC    AL2(L'MSGSEC13)
          DC    AL2(MSGSEC13-STARTDSM)
          DC    AL2(0)
          DC    AL2(L'MSGSEC14)
          DC    AL2(MSGSEC14-STARTDSM)
          DC    AL2(0)
          DC    AL2(L'MSGSEC15)
          DC    AL2(MSGSEC15-STARTDSM)
          DC    AL2(0)
          DC    AL2(L'MSGSEC16)
          DC    AL2(MSGSEC16-STARTDSM)
          DC    AL2(0)
          DC    AL2(L'MSGSEC17)
          DC    AL2(MSGSEC17-STARTDSM)
          DC    AL2(0)
         DC    AL2(L'MSGSEC18)
         DC    AL2(MSGSEC18-STARTDSM)
         DC    AL2(0)
         DC    AL2(L'MSGSEC19)
         DC    AL2(MSGSEC19-STARTDSM)
         DC    AL2(0)
         DC    AL2(L'MSGSEC20)
         DC    AL2(MSGSEC20-STARTDSM)
         DC    AL2(0)
         DC    AL2(L'MSGSEC21)                                 @YL026YA
         DC    AL2(MSGSEC21-STARTDSM)                          @YL026YA
         DC    AL2(0)                                          @YL026YA
         DC    AL2(L'MSGSEC22)                                 @YL026YA
         DC    AL2(MSGSEC22-STARTDSM)                          @YL026YA
         DC    AL2(0)                                          @YL026YA
*
*
*   SEGTABLE USED FOR SEGMENTS OF MESSAGES **
         DS    0F                  ALIGN
OFFSEG1  DC    AL2(L'SEG1)
         DC    AL2(SEG1-STARTDSM)
         DC    AL2(0)
OFFSEG7  DC    AL2(L'SEG7)
         DC    AL2(SEG7-STARTDSM)
         DC    AL2(0)
OFFSEG8  DC    AL2(L'SEG8)
         DC    AL2(SEG8-STARTDSM)
         DC    AL2(0)
OFFSEG9  DC    AL2(L'SEG9)
         DC    AL2(SEG9-STARTDSM)
         DC    AL2(0)
OFFSEG10 DC    AL2(L'SEG10)
         DC    AL2(SEG10-STARTDSM)
         DC    AL2(0)
OFFSEG11 DC    AL2(L'SEG11)
         DC    AL2(SEG11-STARTDSM)
         DC    AL2(0)
OFFSEG12 DC    AL2(L'SEG12)
         DC    AL2(SEG12-STARTDSM)
         DC    AL2(0)
         DC    3F'0'
*     THE ABOVE DC IS FILL IN FOR TWO MSGES *
OFFSEG15 DC    AL2(L'SEG15)
         DC    AL2(SEG15-STARTDSM)
         DC    AL2(0)
OFFSEG16 DC    AL2(L'SEG16)
         DC    AL2(SEG16-STARTDSM)
         DC    AL2(0)
OFFSEG17 DC    AL2(L'SEG17)
         DC    AL2(SEG17-STARTDSM)
         DC    AL2(0)
OFFSEG18 DC    AL2(L'SEG18)                                    @YL026YA
         DC    AL2(SEG18-STARTDSM)                             @YL026YA
         DC    AL2(0)                                          @YL026YA
*        FIRST LEVEL MESSAGES FOLLOW BELOW
*
*
*
MSGE1    DC    C'IKJ58503I DATA SET '
SEG1     DC    C' NOT IN CATALOG'       SECND SEG
MSGE2    DC    C'IKJ58500I DATA SET ATTRIBUTES NOT AVAILABLE+'
MSGE3    DC    C'IKJ58504I COMPLETE VOLUME LIST NOT AVAILABLE+'
MSGE4    DC    C'IKJ58501I MEMBERS NOT AVAILABLE+'
MSGE5    DC    C'IKJ58502I DIRECTORY INFORMATION NOT AVAILABLE+'
MSGE6    DC    C'IKJ58505I LABEL INFORMATION NOT AVAILABLE+'
MSGE7    DC    C'IKJ58509I DATA SET NAME REQUIRED WHEN MEMBER '
SEG7     DC    C' IS SPECIFIED'       SECND SEG
MSGE8    DC    C'IKJ58506I DATA SET '    FIRST SEG
SEG8     DC    C' NOT ALLOCATED, TOO MANY DATA SETS+'  SECND SEG A49872
MSGE9    DC    C'IKJ58514I DATA SET '   STAE FIRST MESSAGE SEGMENT
SEG9     DC    C' NOT USEABLE+'          STAE SECOND MESSAGE     A49872
MSGE10   DC    C'IKJ58507I DATA SET '      FIRST SEG
SEG10    DC    C' NOT ALLOCATED, REQUIRED VOLUME NOT MOUNTED+'   A49872
MSGE11   DC    C'IKJ58508I DATA SET '      FIRST SEG
SEG11    DC    C' NOT ALLOCATED, SYSTEM OR INSTALLATION ERROR+'  A49872
MSGE12   DC    C'IKJ58510I DATA SET '      FIRST SEG
SEG12    DC    C' ALREADY IN USE, TRY LATER+'                    A49872
MSGE13   DC    C'IKJ58512I COMMAND SYSTEM ERROR+'  NO SEG
MSGE14   DC    C'IKJ58511I NOT ENOUGH MAIN STORAGE TO EXECUTE COMMAND'
MSGE15   EQU   *
SEG15    EQU   *
MSGE16   DC    C'IKJ58513I INVALID DATA SET NAME, '
SEG16    DC    C' EXCEEDS 44 CHARACTERS'
MSGE17   DC    C'IKJ58515I DATA SET LIST NOT ALLOWED WITH LEVEL'
SEG17    EQU   *
MSGE18   DC    C'IKJ58516I INVALID USE OF * IN '               @YL026YA
SEG18    DC    C' +'                                           @YL026YA
MSGE19   DC    C'IKJ58517I UNABLE TO LIST * NAME OR LEVEL+'    @YL026YA
SEG19    EQU   *                                               @YL026YA
MSGE20   DC    C'IKJ58518I NO DATA SETS FOUND TO MATCH * IN '  @VS06783
*
*
*        SECOND LEVEL MESSAGES FOLLOW BELOW--XX IS DETERMINED
*        DYNAMICALLY AND APPENDED.
*
MSGSEC01 DC    C'IKJ585XXI LOCATE ERROR CODE '     LOCATE ERROR MSG
MSGSEC02 DC    C'IKJ585XXI OBTAIN ERROR CODE '
MSGSEC03 DC    C'IKJ585XXI DYNAMIC ALLOCATION ERROR CODE '
MSGSEC04 DC    C'IKJ585XXI DIRECTORY STRUCTURE ERROR'
MSGSEC05 DC    C'IKJ585XXI I/O SYNAD ERROR DURING DIRECTORY SEARCH '
MSGSEC06 DC    C'IKJ585XXI NOT ENOUGH MAIN STORAGE'
MSGSEC07 DC    C'IKJ585XXI I/O ERROR DURING BLDL'  RC=8
MSGSEC08 DC    C'IKJ585XXI DATA SET IS NOT A PARTITIONED DATA SET'
MSGSEC09 DC    C'IKJ585XXI MEMBER NAME NOT FOUND'    RC=04
MSGSEC10 DC    C'IKJ585XXI VOLUME OR CVOL NOT ON SYSTEM AND CANNOT BE A-
               CCESSED'           CTRC=4  DAIR 8
MSGSEC11 DC    C'IKJ585XXI USE FREE COMMAND TO FREE UNUSED DATA SETS'
MSGSEC12 DC    C'IKJ585XXI OPEN ERROR CODE ' STAE MSG
MSGSEC13 DC    C'IKJ585XXI VOLUME NOT ON SYSTEM AND CANNOT BE ACCESSED'
MSGSEC14 DC    C'IKJ585XXI ABEND CODE '     STAE MSG
MSGSEC15 DC    C'IKJ585XXI DATA SET ALLOCATED TO ANOTHER USER OR JOB'
MSGSEC16 DC    C'IKJ585XXI PARSE ERROR CODE '
MSGSEC17 DC    C'IKJ585XXI DEFAULT ERROR CODE '
MSGSEC18 DC    C'IKJ58504I JFCB EXTENSION NOT AVAILABLE'
MSGSEC19 DC    C'IKJ585XXI CATALOG I/O ERROR '   CTRC28 DAIR8
MSGSEC20 DC    C'IKJ585XXI DAIR ERROR CODE '   RC 4 DAIR
MSGSEC21 DC    C'IKJ585XXI * NOT ALLOWED AS FIRST LEVEL'       @YL026YA
MSGSEC22 DC    C'IKJ585XXI MORE THAN ONE * NOT ALLOWED'        @YL026YA
PATCH     DC    20X'00'                PATCH AREA
         END
