         TITLE 'IEBLDUL - IEBCOPY LOAD/UNLOAD INITIALIZATION ROUTINE'
*C120400,889000                                                  A44144
*A888800,888920,889500,889600                                    A44144
         LCLA  &T,&SPN                                            0002
.@001    ANOP                                                     0002
IEBLDUL  CSECT ,                                                  0002
         ST    @E,12(0,@D)                                        0002
         STM   @0,@C,20(@D)                                       0002
         BALR  @B,0                                               0002
@PSTART  DS    0H                                                 0002
         USING @PSTART+00000,@B                                   0002
         ST    @D,@SAV001+4                                       0002
         LA    @F,@SAV001                                         0002
         ST    @F,8(0,@D)                                         0002
         LR    @D,@F                                              0002
         BC    15,@9FF                                            0076
* IEBLDUL1: ENTRY;
IEBLDUL1 ST    @E,12(0,@D)                                        0076
         STM   @0,@C,20(@D)                                       0076
         BALR  @B,0                                               0076
         LA    @F,IEBLDUL1-IEBLDUL                                0076
         SR    @B,@F                                              0076
         ST    @D,@SAV001+4                                       0076
         LA    @F,@SAV001                                         0076
         ST    @F,8(0,@D)                                         0076
         LR    @D,@F                                              0076
@9FF     EQU   *                                                  0076
*
*         /************************************************************
*         /* THE FOLLOWING GENERATE ESTABLISHES ADDRESSABILITY TO     *
*         /* IEBMCA AND THE DCB,JFCB AND DSCB CONTROL BLOCKS.         *
*         /************************************************************
*
*         GENERATE;
         USING IEBMCA,@4          IEBMCA ADDRESSABILITY
         USING INFMJFCB,@7        JFCB ADDRESSABILITY
         USING DXDSCB,@6          DSCB ADDRESSABILITY
         USING IHADCB,@5          DCB ADDRESSABILITY
         DS    0H
*         JFCBREG=ADDR(JFCBBUF);        /* INITIALIZE JFCB POINTER
*                                          REGISTER                   *
         L     @C,0(0,@1)          ADDRESS OF JFCBBUF             0078
         LR    @7,@C                                              0078
*         DSCBREG=ADDR(DSCBBUF);        /* INITIALIZE DSCB POINTER
*                                          REGISTER                   *
         L     @8,4(0,@1)          ADDRESS OF DSCBBUF             0079
         LR    @6,@8                                              0079
*         ULLDST(1)='1'B;               /* SET LOAD SWITCH            *
         OI    ULLDST,B'10000000'                                 0080
*
*         /*----------------------------------------------------------*
*         /* A TEST IS MADE TO DETERMINE IF THE DATA SET TO BE LOADED *
*         /* IS ALLOCATED TO OTHER THAN A DA OR TAPE DEVICE.  IF IT   *
*         /* IS, THEN AN ERROR HAS BEEN FOUND.                        *
*         /*----------------------------------------------------------*
*
*         IF INCHAR(3) ^= '80'X &       /* IS THE INPUT DATA SET      *
*            INCHAR(3) ^= '20'X         /* ALLOCATED TO OTHER THAN A
*                                          DISK OR TAPE DEVICE        *
*            THEN                       /* YES, IT IS SO ISSUE        *
         CLI   INCHAR+2,X'80'                                     0081
         BC    08,@9FE                                            0081
         CLI   INCHAR+2,X'20'                                     0081
*              GO TO LDUL0102;          /* ERROR MESSAGE              *
         BC    07,LDUL0102                                        0082
*            ELSE;                      /* NO, OK CONTINUE            *
@9FD     EQU   *                                                  0083
@9FE     EQU   *                                                  0083
*
*         /*----------------------------------------------------------*
*         /* A TEST IS MADE TO INSURE THAT THE DATA SET TO BE LOADED  *
*         /* IS NOT A SYSIN DATA SET WHICH IS AN ERROR CONDITION.     *
*         /*----------------------------------------------------------*
*
*         IF JFCBTSDM(3) = '1'B         /* IS THE INPUT DATA SET
*                                          A SYSIN DATA SET           *
*            THEN                       /* YES, IT IS SO ISSUE        *
         TM    JFCBTSDM,B'00100000'                               0084
*              GO TO LDUL0102;          /* ERROR MESSAGE              *
         BC    01,LDUL0102                                        0085
*            ELSE;                      /* NO, OK CONTINUE            *
*
*         /*----------------------------------------------------------*
*         /* A TEST IS MADE TO DETERMINE IF A FREEMAIN HAS BEEN DONE  *
*         /* FOR THE LOADING OF DATA MANAGEMENT ROUTINES.             *
*         /*----------------------------------------------------------*
*
*         IF ULLDST(3)='1'B             /* HAS FREEMAIN BEEN DONE     *
*            THEN                       /* YES, IT HAS BEEN DONE      *
         TM    ULLDST,B'00100000'                                 0087
*              GO TO LDUL0004;          /* BRANCH AROUND FREEMAIN
*                                          LINKAGE                    *
         BC    01,LDUL0004                                        0088
*            ELSE                       /* NO, FREMAIN HAS NOT BEEN
*                                          DONE                       *
*              DO;                      /* LINK TO IEBDSCPY TO ISSUE
*                                          FREEMAIN                   *
*
*                /*****************************************************
*                /* LINKAGE TO THE ENTRY POINT IEBDSFRC IN MODULE     *
*                /* IEBDSCPY IS NOW GENERATED.                        *
*                /*****************************************************
*
*                GENERATE;
         STM   @E,@F,REGSAVE1     SAVE REGISTERS 14 AND 15
         L     @F,VDSFRC          1 ADDRESS OF ENTRY POINT
*                                  IEBDSFRC
         BALR  @E,@F                   LINK TO DO FREEMAIN
         LM    @E,@F,REGSAVE1     RESTORE REGISTERS 14 AND 15
         DS    0H
*              END;
* LDUL0004:                             /* FREEMAIN HAS BEEN DONE     *
*         DCBREG=ADDR(LOADDCB);         /* SET CURRENT DCB POINTER TO
*                                          ADDRESS OF LOAD DCB        *
LDUL0004 LA    @5,LOADDCB                                         0092
*         DCBDDNAM=DDVALNM;             /* INITIALIZE DDNAME FIELD IN
*                                          LOAD DCB                   *
         MVC   DCBDDNAM(8),DDVALNM                                0093
*         LIST5ADR=ADDR(LOADVAL);       /* PLACE ADDRESS OF DCB EXIT
*                                          ROUTINE FOR THE LOAD DCB
*                                          IN IT'S EXIT LIST          *
         LA    @F,LOADVAL                                         0094
         ST    @F,@TEMP4                                          0094
         MVC   LIST5ADR(3),@TEMP4+1                               0094
*         SYNAD24=VIEBIOE3;             /* PLACE ADDRESS OF SYNAD
*                                          ROUTINE IN LOAD DCB        *
         MVC   SYNAD24(3),VIEBIOE3+1                              0095
*         EODAD24=VDSIOE2;              /* PLACE ADDRESS OF EODAD
*                                          ROUTINE IN LOAD DCB        *
         MVC   EODAD24(3),VDSIOE2+1                               0096
*         DCBBLKSI=0;                   /* INITIALIZE LOAD DCB BLKSIZE
*                                          FIELD TO ZERO              *
         SR    @F,@F                                              0097
         STH   @F,DCBBLKSI                                        0097
*         DCBLRECL=0;                   /* INITIALIZE LOAD DCB LRECL
*                                          FIELD TO ZERO              *
         STH   @F,DCBLRECL                                        0098
* LDUL0008:                             /* OPEN THE LOAD DCB          *
*
*         /************************************************************
*         /* THE FOLLOWING GENERATE IS FOR EXPANSION OF THE OPEN      *
*         /* MACRO WHICH IS USED TO OPEN THE LOAD DCB.                *
*         /************************************************************
*
*         GENERATE;
LDUL0008 EQU   *                                                  0099
         STM   @E,@1,REGSAVE1     STORE REGISTERS 14,15,0 AND 1
         OPEN  ((@5),INPUT)       OPEN 1 DCB
         LM    @E,@1,REGSAVE1     RESTORE REGISTERS 14,15,0 AND 1
         DS    0H
*
*         /*----------------------------------------------------------*
*         /* A TEST IS NOW MADE TO SEE IF THE LOAD DCB HAS BEEN       *
*         /* SUCCESSFULLY OPENED.                                     *
*         /*----------------------------------------------------------*
*
*         IF DCBOFLGS(4)='1'B           /* OPEN OK                    *
*            THEN                       /* YES                        *
         TM    DCBOFLGS,B'00010000'                               0100
*              GO TO LDUL0012;          /* BRANCH AROUND ERROR CODE   *
*            ELSE                       /* NO, OPEN ERROR             *
*              GO TO LDUL0100;          /* PREPARE AND ISSUE ERROR
*                                          MESSAGE                    *
         BC    14,LDUL0100                                        0102
* LDUL0012:                             /* GET READY TO READ COPYR1   *
*         IF DCBBLKSI > ACOPYR1 - LOCOR - 60       /*NO BUFFER   M2744
*                                          CAN BE MADE AVAILABLE M2744*
*            THEN                                              /*M2744*
LDUL0012 LH    @F,@D1                                             0103
         S     @F,LOCOR                                           0103
         A     @F,ACOPYR1                                         0103
         CH    @F,DCBBLKSI                                        0103
*            GO TO LDUL0114 ;                /*STOP TRY TO LOAD  M2744*
         BC    04,LDUL0114                                        0104
*            ELSE ;                          /*GO READ HAEDER    M2744*
*         READPTR=LOCOR;                     /* READ INTO LOW PART M274
*                                               OF IEBCOPY CORE  M2744*
         MVC   READPTR(4),LOCOR                                   0106
*         CALL READHD;                  /* READ THE COPYR1 HEADER
*                                          RECORD                     *
         BAL   @E,READHD                                          0107
*         COPYR1 = TEMP1HDR ;                /* MOVE IT TO ACPYR1M2744*
         L     @C,READPTR                                         0108
         L     @8,ACOPYR1                                         0108
         MVC   0(60,@8),0(@C)                                     0108
*
*         /*----------------------------------------------------------*
*         /* A TEST IS MADE TO SEE IF THIS IS AN IEBCOPY UNLOADED     *
*         /* PDS.                                                     *
*         /*----------------------------------------------------------*
*
*         IF ID='CA6D0F'X               /* IS ID FIELD IN COPYR1
*                                          RECORD VALID               *
*            THEN                       /* YES, FIELD IS VALID        *
         CLC   9(3,@8),@X4                                        0109
*              GO TO LDUL0016;          /* BRANCH AROUND ERROR CODE   *
         BC    08,LDUL0016                                        0110
*            ELSE                       /* NO, FIELD IS NOT VALID     *
*              GO TO LDUL0104;          /* PREPARE AND ISSUE ERROR
*                                          MESSAGE                    *
         BC    15,LDUL0104                                        0111
* LDUL0016:                             /* ID IS OK                   *
*
*         /*----------------------------------------------------------*
*         /* A TEST IS MADE TO SEE IF THE 'NOT LOADABLE' INDICATOR    *
*         /* IS SET IN THE COPYR1 HEADER RECORD.                      *
*         /*----------------------------------------------------------*
*
*         IF LOADSTAT='1'B              /* IS THE NOT LOADABLE SWITCH
*                                          IN THE COPYR1 RECORD ON    *
*            THEN                       /* YES, IT IS ON              *
LDUL0016 L     @C,ACOPYR1                                         0112
         TM    8(@C),B'10000000'                                  0112
*              GO TO LDUL0106;          /* PREPARE AND ISSUE ERROR
*                                          MESSAGE                    *
         BC    01,LDUL0106                                        0113
*            ELSE;                      /* NO, OK CONTINUE            *
*
*         /*----------------------------------------------------------*
*         /* A TEST IS MADE TO SEE IF THE LOAD DCB BLKSIZE IS EQUAL   *
*         /* TO THE BLKSIZE USED WHEN THE PDS WAS ORIGINALLY UNLOADED.*
*         /*----------------------------------------------------------*
*
*         IF DCBBLKSI=TBLKSIZE          /* IS THE LOAD DCB BLKSIZE
*                                          EQUAL TO THE BLKSIZE FIELD
*                                          OF THE COPYR1 DESCRIPTOR
*                                          RECORD                     *
*            THEN                       /* YES, THEY ARE EQUAL        *
         LH    @F,22(0,@C)                                        0115
         CH    @F,DCBBLKSI                                        0115
*              GO TO LDUL0020;          /* BRANCH AROUND CLOSE/
*                                          REOPEN CODE                *
         BC    08,LDUL0020                                        0116
*            ELSE                       /* NO, THEY ARE NOT EQUAL     *
*              DO;
*
*                /*****************************************************
*                /* THE FOLLOWING GENERATED CODE CLOSES THE LOAD      *
*                /* DCB.                                              *
*                /*****************************************************
*
*                GENERATE;
         STM   @E,@1,REGSAVE1     SAVE REGISTERS 14,15,0 AND 1
         CLOSE ((@5),REREAD)      CLOSE 1 DCB WITH REREAD OPTION
         LM    @E,@1,REGSAVE1     RESTORE REGISTERS 14,15,0 AND 1
         DS    0H
*                DCBBLKSI=TBLKSIZE;     /* SET CORRECT BLKSIZE INTO
*                                          LOAD DCB                   *
         MVC   DCBBLKSI(2),22(@C)                                 0119
*                DCBLRECL=DCBBLKSI-4;        /* SET CORRECT LRECL
*                                               INTO THE LOAD DCB     *
         LH    @F,DCBBLKSI                                        0120
         SH    @F,@D2                                             0120
         STH   @F,DCBLRECL                                        0120
*                GO TO LDUL0008;        /* GO REOPEN THE LOAD DCB     *
         BC    15,LDUL0008                                        0121
*              END;
* LDUL0020:                             /* BLKSIZE IS OK              *
*         READPTR=LOCOR + 60;                /* POINT TO SAFE    M2744
*                                               PLACE TO READ IN M2744*
LDUL0020 LA    @F,60                                              0123
         A     @F,LOCOR                                           0123
         ST    @F,READPTR                                         0123
*         CALL READHD;                  /* READ THE COPYR2 HEADER
*                                          RECORD                     *
         BAL   @E,READHD                                          0124
*         COPYR2(1:255) = TEMP2HDR(1:255); /* MOVE 1ST PART      M2744*
         L     @C,READPTR                                         0125
         L     @8,ACOPYR2                                         0125
         MVC   0(255,@8),0(@C)                                    0125
*         COPYR2(256:284) = TEMP2HDR(256:284); /* MOVE 2ND PART  M2744*
         MVC   255(29,@8),255(@C)                                 0126
*
*         /************************************************************
*         /* THE DCB POINTER REGISTER IS NOW CHANGED TO POINT TO THE  *
*         /* INPUT PDS DCB.  VARIOUS FIELDS IN THE INPUT DCB,JFCB,    *
*         /* AND DSCB AS WELL AS THE INPUT DEVTYPE CHARACTERISTICS    *
*         /* ARE CHANGED TO 'LOOK' AS IF THE INPUT DATA SET IS A PDS. *
*         /************************************************************
*
*         DCBREG=ADDR(INDCB);           /* RE-ESTABLISH DCB ADDRESS-
*                                          ABILITY TO INPUT PDS DCB   *
         LA    @5,INDCB                                           0127
*         DSCBLKL=UBLKSIZE;             /* SET DSCB BLKSIZE=COPYR1
*                                          DSORG FIELD                *
         L     @9,ACOPYR1                                         0128
         MVC   DSCBLKL(2),14(@9)                                  0128
*         DSCLRECL=ULRECL;              /* SET DSCB LRECL=COPYR1
*                                          LRECL FIELD                *
         MVC   DSCLRECL(2),16(@9)                                 0129
*         DCBRECFM=URECFM;              /* SET INPUT PDS DCB RECFM=
*                                          COPYR1 RECFM FIELD         *
         MVC   DCBRECFM(1),18(@9)                                 0130
*         DCBKEYLE=UKEYLEN;             /* SET INPUT PDS DCB KEYLEN=
*                                          COPYR1 KEYLEN FIELD        *
         MVC   DCBKEYLE(1),19(@9)                                 0131
*         DCBOPTCD=DCBOPTCD×UOPTCD;     /* SET INPUT PDS DCB OPTCD=
*                                          COPYR1 OPTCD FIELD         *
         OC    DCBOPTCD(1),20(@9)                                 0132
*         JFCBLKSI=UBLKSIZE;            /* SET JFCB BLKSIZE=COPYR1
*                                          BLKSIZE FIELD              *
         MVC   JFCBLKSI(2),14(@9)                                 0133
*         JFCLRECL=ULRECL;              /* SET JFCB LRECL=COPYR1
*                                          LRECL FIELD                *
         MVC   JFCLRECL(2),16(@9)                                 0134
*         INCHAR=UDEVTYPE;              /* SET INPUT DEVICE CHARACTER-
*                                          ISTICS=COPYR1 DEVICE CHAR-
*                                          ACTERISTICS FIELD          *
         MVC   INCHAR(20),24(@9)                                  0135
*
*         /************************************************************
*         /* THE UNLOADED EXTENT DESCRIPTIONS IN THE UDEBX FIELD OF   *
*         /* THE COPYR2 RECORD ARE NOW UPDATED TO FACILITATE TTR TO   *
*         /* MBBCCHHR CONVERSION.                                     *
*         /************************************************************
*
*         DEBAD24=ADDR(UDEBL16)-16;     /* SET INPUT PDS DCBDEBAD
*                                          FIELD TO POINT TO THE
*                                          COPYR2 UDEBL16 FIELD MINUS
*                                          16 BYTES                   *
         LH    @F,@D3                                             0136
         LA    @0,8(0,@8)                                         0136
         AR    @F,@0                                              0136
         ST    @F,@TEMP4                                          0136
         MVC   DEBAD24(3),@TEMP4+1                                0136
*         DEBXPTR=ADDR(UDEBX);          /* INITIALIZE UNLOADED DEB
*                                          EXTENT FIELD POINTER TO
*                                          ADDRESS OF UDEBX FIELD OF
*                                          THE COPYR2 RECORD          *
         LA    @F,24(0,@8)                                        0137
         ST    @F,DEBXPTR                                         0137
*         XTENTCTR=UDEBL16(1);          /* INITIALIZE EXTENT COUNTER
*                                          TO THE NUMBER OF EXTENT
*                                          DESCRIPTIONS IN THE UDEBX
*                                          FIELD OF THE COPYR2 RECORD *
         SR    @F,@F                                              0138
         IC    @F,8(0,@8)                                         0138
         STH   @F,XTENTCTR                                        0138
*
*         /************************************************************
*         /* THE FOLLOWING ITERATIVE DO GROUP IS USED TO INITIALIZE   *
*         /* THE UCB POINTER FIELD OF EACH UNLOADED EXTENT DESCRIP-   *
*         /* TION IN THE UDEBX FIELD OF THE COPYR2 RECORD TO THE      *
*         /* ADDRESS OF THE UDEVTYPE FIELD OF THE COPYR1 RECORD MINUS *
*         /* 16 BYTES.                                                *
*         /************************************************************
*
*         DO XTENTCTR=
*            XTENTCTR
*            BY -1
         BC    15,@DO9FB                                          0139
*            TO 1;
*
*               UCBAD=ADDR(UDEVTYPE) -  /* PLACE ADDRESS OF UDEVTYPE  *
*                     16;               /* FIELD MINUS 16 BYTES IN
*                                          EACH UNLOADED DEB EXTENT   *
@DO9FC   LH    @F,@D3                                             0140
         L     @C,ACOPYR1                                         0140
         LA    @0,24(0,@C)                                        0140
         AR    @F,@0                                              0140
         L     @8,DEBXPTR                                         0140
         ST    @F,@TEMP4                                          0140
         MVC   1(3,@8),@TEMP4+1                                   0140
*               DEBXPTR=DEBXPTR +       /* BUMP THE DEB EXTENT        *
*                       16;             /* POINTER TO THE NEXT ENTRY
*                                          WITHIN THE UDEBX FIELD     *
         LA    @F,16                                              0141
         A     @F,DEBXPTR                                         0141
         ST    @F,DEBXPTR                                         0141
*         END;                          /* END OF UDEBX FIELD
*                                          INITIALIZATION             *
* LDUL0024:                             /* RETURN TO CALLER           *
*         RTCDREG=0;                    /* SET RETURN CODE TO ZERO    *
         LH    @F,XTENTCTR                                        0142
         BCTR  @F,0                                               0142
@DO9FB   STH   @F,XTENTCTR                                        0142
         CH    @F,@D4                                             0142
         BC    10,@DO9FC                                          0142
LDUL0024 SR    @F,@F                                              0143
*         RETURN;
         BC    15,@EL01                                           0144
* /********************************************************************
* /*         THIS IS THE DCB EXIT ROUTINE FOR THE LOAD DCB.           *
* /********************************************************************
*
* LOADVAL:
*
*         /*----------------------------------------------------------*
*         /* A TEST IS MADE TO DETERMINE IF THE LOAD DCB BLKSIZE IS   *
*         /* LARGER OR EQUAL TO THE MINIMUM VALID BLKSIZE.            *
*         /*----------------------------------------------------------*
*
*         IF DCBBLKSI < 284             /* IS THE LOAD DCB BLKSIZE
*                                          LESS THAN THE ABSOLUTE
*                                          MINIMUM                    *
*            THEN                       /* YES, IT IS TOO SMALL       *
LOADVAL  LA    @F,284                                             0145
         CH    @F,DCBBLKSI                                        0145
         BC    12,@9F8                                            0145
*              DCBBLKSI=284;            /* SET LOAD DCB BLKSIZE TO
*                                          MINIMUM VALUE              *
         STH   @F,DCBBLKSI                                        0146
*            ELSE;                      /* NO, IT IS OK - CONTINUE    *
@9F8     EQU   *                                                  0147
*         DCBLRECL=DCBBLKSI-4;          /* ASSURE THAT THE LOAD DCB
*                                          LRECL FIELD IS EQUAL TO
*                                          THE LOAD DCB BLKSIZE FIELD
*                                          MINUS THE LENGTH OF THE
*                                          BIG LL FIELD               *
@9F7     LH    @F,DCBBLKSI                                        0148
         SH    @F,@D2                                             0148
         STH   @F,DCBLRECL                                        0148
* LOADVAL8:                             /* RETURN TO OPEN             *
*
*         /************************************************************
*         /* THE FOLLOWING GENERATED CODE IS FOR RETURN LINKAGE TO    *
*         /* OPEN.                                                    *
*         /************************************************************
*
*         GENERATE;
LOADVAL8 EQU   *                                                  0149
         BR    @E                 RETURN TO OPEN
         DS    0H
         BC    15,@9F6                                            0150
*
* /********************************************************************
* /*         THIS IS THE ENTRY POINT FOR UNLOAD PROCESSING            *
* /********************************************************************
*
* IEBLDUL2: ENTRY;
IEBLDUL2 ST    @E,12(0,@D)                                        0150
         STM   @0,@C,20(@D)                                       0150
         BALR  @B,0                                               0150
         LA    @F,IEBLDUL2-IEBLDUL                                0150
         SR    @B,@F                                              0150
         ST    @D,@SAV001+4                                       0150
         LA    @F,@SAV001                                         0150
         ST    @F,8(0,@D)                                         0150
         LR    @D,@F                                              0150
*
*         JFCBREG=ADDR(JFCBBUF);        /* INITIALIZE JFCB POINTER
*                                          REGISTER                   *
@9F6     L     @C,0(0,@1)          ADDRESS OF JFCBBUF             0151
         LR    @7,@C                                              0151
*         ULLDST(2)='1'B;               /* SET UNLOAD SWITCH          *
         OI    ULLDST,B'01000000'                                 0152
*
*         /*----------------------------------------------------------*
*         /* A TEST IS MADE TO DETERMINE IF THE INPUT AND OUTPUT DATA *
*         /* ARE ONE AND THE SAME.                                    *
*         /*----------------------------------------------------------*
*
*         IF INDSNBUF=JFCBDSNM &        /* ARE THE INPUT AND OUTPUT   *
*            INVOLBUF=JFCBVOLS          /* DATA SETS ONE AND THE SAME *
*            THEN                       /* YES, A COMPRESS REQUEST
*                                          HAS BEEN DETECTED          *
         L     @8,12(0,@1)         ADDRESS OF INDSNBUF            0153
         CLC   0(44,@8),JFCBDSNM                                  0153
         BC    07,@9F5                                            0153
         L     @9,8(0,@1)          ADDRESS OF INVOLBUF            0153
         CLC   0(6,@9),JFCBVOLS                                   0153
*              GO TO LDUL0108;          /* PREPARE AND ISSUE ERROR
*                                          MESSAGE                    *
         BC    08,LDUL0108                                        0154
*            ELSE;                      /* NO, OK CONTINUE            *
@9F4     EQU   *                                                  0155
@9F5     EQU   *                                                  0155
*
*         /*----------------------------------------------------------*
*         /* A TEST IS MADE TO DETERMINE IF THE INPUT AND OUTPUT DATA *
*         /* SETS VOLUME SERIAL NUMBERS ARE EQUAL AND THE OUTPUT DATA *
*         /* SET IS ON A TAPE DEVICE WHICH IS AN ERROR CONDITION      *
*         /* SINCE TWO DATA SETS CANNOT BE OPENED ON THE SAME TAPE    *
*         /* VOLUME AT THE SAME TIME.                                 *
*         /*----------------------------------------------------------*
*
*         IF INVOLBUF=JFCBVOLS &        /* ARE THE INPUT AND OUTPUT   *
*            OUTCHAR(3)='80'X           /* DATA SETS ON THE SAME TAPE
*                                          VOLUME                     *
*            THEN                       /* YES, THEY ARE SO ISSUE     *
         L     @C,8(0,@1)          ADDRESS OF INVOLBUF            0156
         CLC   0(6,@C),JFCBVOLS                                   0156
         BC    07,@9F3                                            0156
         CLI   OUTCHAR+2,X'80'                                    0156
*              GO TO LDUL0101;          /* ERROR MESSAGE              *
         BC    08,LDUL0101                                        0157
*            ELSE;                      /* NO, OK CONTINUE            *
@9F2     EQU   *                                                  0158
@9F3     EQU   *                                                  0158
*
*         /*----------------------------------------------------------*
*         /* A TEST IS MADE TO DETERMINE IF THE DATA SET TO CONTAIN   *
*         /* THE UNLOADED PDS IS ALLOCATED TO OTHER THAN A DA OR TAPE *
*         /* DEVICE. IF IT IS, AN ERROR HAS BEEN FOUND.               *
*         /*----------------------------------------------------------*
*
*         IF OUTCHAR(3) ^= '80'X &       /* IS THE OUTPUT DATA SET    *
*            OUTCHAR(3) ^= '20'X        /* ALLOCATED TO OTHER THAN A
*                                          DISK OR TAPE DEVICE        *
*            THEN                       /* YES, IT IS SO ISSUE        *
         CLI   OUTCHAR+2,X'80'                                    0159
         BC    08,@9F1                                            0159
         CLI   OUTCHAR+2,X'20'                                    0159
*              GO TO LDUL0102;          /* ERROR MESSAGE              *
         BC    07,LDUL0102                                        0160
*            ELSE;                      /* NO, OK CONTINUE            *
@9F0     EQU   *                                                  0161
@9F1     EQU   *                                                  0161
*
*         /*----------------------------------------------------------*
*         /* A TEST IS MADE TO INSURE THAT THE DATA SET TO CONTAIN    *
*         /* THE UNLOADED PDS IS NOT A SYSOUT DATA SET WHICH IS AN    *
*         /* ERROR CONDITION.                                         *
*         /*----------------------------------------------------------*
*
*         IF JFCBTSDM(3) = '1'B         /* IS THE OUTPUT DATA SET A
*                                          A SYSOUT DATA SET          *
*            THEN                       /* YES, IT IS SO ISSUE        *
         TM    JFCBTSDM,B'00100000'                               0162
*              GO TO LDUL0102;          /* ERROR MESSAGE              *
         BC    01,LDUL0102                                        0163
*            ELSE;                      /* NO, CONTINUE               *
*
*         /*----------------------------------------------------------*
*         /* A TEST IS MADE TO DETERMINE IF A FREEMAIN HAS BEEN DONE  *
*         /* FOR THE LOADING OF DATA MANAGEMENT ROUTINES.             *
*         /*----------------------------------------------------------*
*
*         IF ULLDST(3)='1'B             /* HAS FREEMAIN BEEN DONE     *
*            THEN                       /* YES, IT HAS                *
         TM    ULLDST,B'00100000'                                 0165
*              GO TO LDUL0026;          /* BRANCH AROUND FREEMAIN
*                                          LINKAGE                    *
         BC    01,LDUL0026                                        0166
*            ELSE                       /* NO, IT HAS NOT             *
*              DO;                      /* LINK TO IEBDSCPY TO ISSUE
*                                          FREEMAIN                   *
*
*                /*****************************************************
*                /* LINKAGE TO THE ENTRY POINT IEBDSFRC IN MODULE     *
*                /* IEBDSCPY IS NOW GENERATED.                        *
*                /*****************************************************
*
*                GENERATE;
         STM   @E,@F,REGSAVE1     SAVE REGISTERS 14 AND 15
         L     @F,VDSFRC          1 ADDRESS OF ENTRY POINT
*                                  IEBDSFRC
         BALR  @E,@F                   LINK TO DO FREEMAIN
         LM    @E,@F,REGSAVE1     RESTORE REGISTERS 14 AND 15
         DS    0H
*              END;
* LDUL0026:                             /* FREEMAIN IS DONE           *
*         DCBREG=ADDR(ULOADDCB);        /* SET CURRENT DCB POINTER TO
*                                          ADDRESS OF UNLOAD DCB      *
LDUL0026 LA    @5,ULOADDCB                                        0170
*         DCBDDNAM=DDVALNM;             /* INITIALIZE DDNAME FIELD IN
*                                          UNLOAD DCB                 *
         MVC   DCBDDNAM(8),DDVALNM                                0171
*         LIST6ADR=ADDR(ULOADVAL);      /* PLACE ADDRESS OF DCB EXIT
*                                          ROUTINE FOR THE UNLOAD DCB
*                                          IN IT'S EXIT LIST          *
         LA    @F,ULOADVAL                                        0172
         ST    @F,@TEMP4                                          0172
         MVC   LIST6ADR(3),@TEMP4+1                               0172
*         SYNAD24=VIEBIOE4;             /* PLACE ADDRESS OF SYNAD
*                                          ROUTINE IN UNLOAD DCB      *
         MVC   SYNAD24(3),VIEBIOE4+1                              0173
*         DCBBLKSI=0;                   /* INITIALIZE UNLOAD DCB
*                                          BLKSIZE FIELD TO ZERO      *
         SR    @F,@F                                              0174
         STH   @F,DCBBLKSI                                        0174
*         DCBLRECL=0;                   /* INITIALIZE UNLOAD DCB
*                                          LRECL FIELD TO ZERO        *
         STH   @F,DCBLRECL                                        0175
*
*         /************************************************************
*         /* THE FOLLOWING GENERATE IS FOR EXPANSION OF THE OPEN      *
*         /* MACRO WHICH IS USED TO OPEN THE UNLOAD DCB.              *
*         /************************************************************
*
*         GENERATE;
         STM   @E,@1,REGSAVE1     STORE REGISTERS 14,15,0 AND 1
         OPEN  ((@5),OUTPUT)      OPEN 2 DCB
         LM    @E,@1,REGSAVE1     RESTORE REGISTERS 14,15,0 AND 1
         DS    0H
*
*         /*----------------------------------------------------------*
*         /* A TEST IS NOW MADE TO SEE IF THE UNLOAD DCB HAS BEEN     *
*         /* SUCCESSFULLY OPENED.                                     *
*         /*----------------------------------------------------------*
*
*         IF DCBOFLGS(4)='1'B           /* OPEN OK                    *
*            THEN                       /* YES                        *
         TM    DCBOFLGS,B'00010000'                               0177
*              GO TO LDUL0030;          /* BRANCH AROUND ERROR CODE   *
*            ELSE                       /* NO, OPEN ERROR             *
*              GO TO LDUL0100;          /* PREPARE AND ISSUE ERROR
*                                          MESSAGE                    *
         BC    14,LDUL0100                                        0179
* LDUL0030:                             /* UNLOAD DCB IS OPEN         *
*         OBLKSIZE=IBLKSIZE;            /* OUTPUT PDS BLKSIZE=INPUT
*                                          PDS BLKSIZE                *
LDUL0030 MVC   OBLKSIZE(2),IBLKSIZE                               0180
*         OUTLRECL=INLRECL;             /* OUTPUT PDS LRECL=INPUT
*                                          PDS LRECL                  *
         MVC   OUTLRECL(2),INLRECL                                0181
*         OUTCHAR=INCHAR;               /* OUTPUT PDS DEVICE CHARACT-
*                                          ERISTICS=INPUT PDS DEVICE
*                                          CHARACTERISTICS            *
         MVC   OUTCHAR(20),INCHAR                                 0182
*         DCBREG=ADDR(INDCB);           /* SET CURRENT DCB POINTER TO
*                                          ADDRESS OF INPUT PDS DCB   *
         LA    @5,INDCB                                           0183
*         OKEYLEN=DCBKEYLE;             /* OUTPUT PDS KEYLEN=INPUT
*                                          PDS DCB KEYLEN             *
         MVC   OKEYLEN(1),DCBKEYLE                                0184
*         OBLKFAC=IBLKFAC;              /* OUTPUT PDS BLOCKING FACTOR
*                                          = INPUT PDS BLOCKING
*                                          FACTOR                     *
         MVC   OBLKFAC(2),IBLKFAC                                 0185
*
*         /************************************************************
*         /* THE FOLLOWING GENERATED CODE IS USED TO SET VARIOUS      *
*         /* OUTPUT PDS DCB FIELDS EQUAL TO THE CORRESPONDING INPUT   *
*         /* PDS DCB FIELDS.                                          *
*         /************************************************************
*
*         GENERATE;
         STM   @6,@9,REGSAVE1     SAVE REGISTERS 6,7,8 AND 9
         IC    @6,DCBKEYLE        INSERT INPUT PDS DCB KEYLEN FIELD
         IC    @7,DCBOPTCD        INSERT INPUT PDS DCB OPTCD FIELD
         IC    @8,DCBRECFM        INSERT INPUT PDS DCB RECFM FIELD
         LA    @5,OUTDCB          CHANGE IHADCB ADDRESSABILITY
*                                  REGISTER TO POINT TO OUTPUT PDS
*                                  DCB
         STC   @6,DCBKEYLE        SET OUTPUT PDS DCB KEYLEN FIELD
*                                  = INPUT PDS DCB KEYLEN FIELD
         STC   @7,DCBOPTCD        SET OUTPUT PDS DCB OPTCD FIELD
*                                  = INPUT PDS DCB OPTCD FIELD
         STC   @8,DCBRECFM        SET OUTPUT PDS DCB RECFM FIELD
*                                  = INPUT PDS DCB RECFM FIELD
         LM    @6,@9,REGSAVE1     RESTORE REGISTERS 6,7,8 AND 9
         DS    0H
*         DCBREG=ADDR(ULOADDCB);        /* CHANGE CURRENT DCB POINTER
*                                          REGISTER TO ADDRESS OF
*                                          UNLOAD DCB                 *
         LA    @5,ULOADDCB                                        0187
*         TBLKSIZE=DCBBLKSI;            /* INITIALIZE THE TBLKSIZE
*                                          FIELD OF THE COPYR1
*                                          RECORD                     *
         L     @C,ACOPYR1                                         0188
         MVC   22(2,@C),DCBBLKSI                                  0188
*
*         /*----------------------------------------------------------*
*         /* A TEST IS NOW MADE TO SEE IF A LOAD IS BEING DONE, IF IT *
*         /* IS THEN THERE IS NO NEED TO BUILD COPYR1 AND COPYR2      *
*         /* RECORDS SINCE THEY HAVE ALREADY BEEN READ INTO THEIR     *
*         /* BUFFERS AND NEED ONLY BE COPIED.                         *
*         /*----------------------------------------------------------*
*
*         IF ULLDST(1)='1'B             /* IS A LOAD BEING DONE       *
*            THEN                       /* YES, IT IS                 *
         TM    ULLDST,B'10000000'                                 0189
*              GO TO LDUL0024;          /* RETURN TO CALLER           *
         BC    01,LDUL0024                                        0190
*            ELSE;                      /* NO, IT IS NOT, CONTINUE
*                                          AND BUILD COPYR1 AND
*                                          COPYR2 RECORDS             *
*
*         /************************************************************
*         /* THE COPYR1 RECORD IS NOW BUILT.                          *
*         /************************************************************
*
*         COPYR1(1)='00'X;              /* CLEAR COPYR1 RECORD BUFFER *
         MVI   0(@C),X'00'                                        0192
*         COPYR1(2:60)=COPYR1(1:59);                        /* CLEAR  *
         MVC   1(59,@C),0(@C)                                     0193
*         DCBREG=ADDR(OUTDCB);          /* SET CURRENT DCB POINTER
*                                          REGISTER TO ADDRESS OF
*                                          OUTPUT PDS DCB             *
         LA    @5,OUTDCB                                          0194
*         BLL1=60;                      /* INITIALIZE COPYR1 BIG LL
*                                          FIELD                      *
         LA    @F,60                                              0195
         STH   @F,0(0,@C)                                         0195
*         LLL1=56;                      /* INITIALIZE COPYR1 LITTLE
*                                          LL FIELD                   *
         LA    @F,56                                              0196
         STH   @F,4(0,@C)                                         0196
*         INDC='00'X;                   /* CLEAR INDICATOR BYTE       *
         MVI   8(@C),X'00'                                        0197
*         ID='CA6D0F'X;                 /* INITIALIZE ID FIELD        *
         MVC   9(3,@C),@X4                                        0198
*         UDSORG=DCBDSORG;              /* INITIALIZE UDSORG FIELD    *
         MVC   12(2,@C),DCBDSORG                                  0199
*         UBLKSIZE=OBLKSIZE;            /* INITIALIZE UBLKSIZE FIELD  *
         MVC   14(2,@C),OBLKSIZE                                  0200
*         ULRECL=OUTLRECL;              /* INITIALIZE ULRECL FIELD    *
         MVC   16(2,@C),OUTLRECL                                  0201
*         URECFM=DCBRECFM;              /* INITIALIZE URECFM FIELD    *
         MVC   18(1,@C),DCBRECFM                                  0202
*         UKEYLEN=DCBKEYLE;             /* INITIALIZE UKEYLEN FIELD   *
         MVC   19(1,@C),DCBKEYLE                                  0203
*         UOPTCD=DCBOPTCD;              /* INITIALIZE UOPTCD FIELD    *
         MVC   20(1,@C),DCBOPTCD                                  0204
*         DCBREG=ADDR(ULOADDCB);        /* CHANGE CURRENT DCB POINTER
*                                          REGISTER TO ADDRESS OF
*                                          UNLOAD DCB                 *
         LA    @5,ULOADDCB                                        0205
*         TBLKSIZE=DCBBLKSI;            /* INITIALIZE THE TBLKSIZE
*                                          FIELD OF THE COPYR1
*                                          RECORD                     *
         MVC   22(2,@C),DCBBLKSI                                  0206
*         UDEVTYPE=OUTCHAR;             /* INITIALIZE UDEVTYPE FIELD  *
         MVC   24(20,@C),OUTCHAR                                  0207
*
*         /************************************************************
*         /* THE COPYR2 RECORD IS NOW BUILT                           *
*         /************************************************************
*
*         UDEBX(1)='00'X;               /* CLEAR UDEBX FIELD OF COPYR2
*                                          RECORD BUFFER              *
         L     @8,ACOPYR2                                         0208
         MVI   24(@8),X'00'                                       0208
*         UDEBX(2:256)=UDEBX(1:255);                    /* CLEAR      *
         MVC   25(255,@8),24(@8)                                  0209
*         URES2(1)='00'X;               /* CLEAR URES2 FIELD OF COPYR2
*                                          RECORD BUFFER              *
         MVI   280(@8),X'00'                                      0210
*         URES2(2:4)=URES2(1:3);                        /* CLEAR      *
         MVC   281(3,@8),280(@8)                                  0211
*         DCBREG=ADDR(INDCB);           /* SET CURRENT DCB POINTER TO
*                                          ADDRESS OF INPUT PDS DCB   *
         LA    @5,INDCB                                           0212
*         DEBREG=DEBAD24;               /* SET DEB ADDRESSABILITY
*                                          REGISTER TO ADDRESS OF
*                                          INPUT PDS DEB              *
         MVC   @TEMP3+1(3),DEBAD24                                0213
         L     @7,@TEMP3                                          0213
*
*         /************************************************************
*         /* THE FOLLOWING GENERATED CODE IS FOR OBTAINING DEB        *
*         /* ADDRESSABILITY.                                          *
*         /************************************************************
*
*         GENERATE;
         DROP  @7
         USING DXDEB,@7           DEB ADDRESSABILITY
         DS    0H
*         BLL2=284;                     /* INITIALIZE COPYR2 BIG LL
*                                          FIELD - FIRST HALF         *
         LA    @F,284                                             0215
         STH   @F,0(0,@8)                                         0215
*         BLL200=0;                     /* INITIALIZE COPYR2 BIG LL
*                                          FIELD - LAST HALF          *
         SR    @F,@F                                              0216
         STH   @F,2(0,@8)                                         0216
*         LLL2=280;                     /* INITIALIZE COPYR2 LITTLE
*                                          LL FIELD - FIRST HALF      *
         LA    @F,280                                             0217
         STH   @F,4(0,@8)                                         0217
*         LLL200=0;                     /* INITIALIZE COPYR2 LITTLE
*                                          LL FIELD - LAST HALF       *
         SR    @F,@F                                              0218
         STH   @F,6(0,@8)                                         0218
*         UDEBL16=DXDEBUSR;             /* INITIALIZE UDEBL16 FIELD   *
         MVC   8(16,@8),DXDEBUSR                                  0219
*         ENDCHAR=DXDEBUSR(1) *         /* CALCULATE TOTAL SIZE OF    *
*                 16;                   /* DEB EXTENT SECTION         *
         LA    @F,16                                              0220
         SR    @0,@0                                              0220
         IC    @0,DXDEBUSR                                        0220
         MR    @E,@0                                              0220
         STH   @F,ENDCHAR                                         0220
*         UDEBX(1:ENDCHAR) =            /* INITIALIZE UDEBX FIELD OF  *
*           DXDEBMOD(1:ENDCHAR);        /* COPYR2 RECORD              *
         LA    @E,DXDEBMOD                                        0221
         LR    @9,@F                                              0221
         BCTR  @9,0                                               0221
         LA    @A,24(0,@8)                                        0221
         EX    @9,@MVC                                            0221
*         GO TO LDUL0024;               /* RETURN TO CALLER           *
         BC    15,LDUL0024                                        0222
* /********************************************************************
* /*         THIS IS THE DCB EXIT ROUTINE FOR THE UNLOAD DCB          *
* /********************************************************************
*
* ULOADVAL:
*         DCBREG=ADDR(INDCB);           /* SET CURRENT DCB POINTER
*                                          REGISTER TO ADDRESS OF
*                                          INPUT PDS DCB              *
ULOADVAL LA    @5,INDCB                                           0223
*         MINBLK=12 +                   /* SET MINIMUM UNLOAD DATA    *
*                8 +                    /*  SET BLKSIZE TO LENGTH OF  *
*                DCBKEYLE +             /*  FMBBCCHHRKDD FIELD +      *
*                IBLKSIZE;              /*  LENGTH OF BIG AND LITTLE
*                                           LL FIELDS + KEY LENGTH
*                                           AND DATA LENGTH OF DATA
*                                           SET TO BE UNLOADED        *
         LH    @F,IBLKSIZE                                        0224
         SR    @0,@0                                              0224
         IC    @0,DCBKEYLE                                        0224
         AR    @F,@0                                              0224
         AH    @F,@D5                                             0224
         AH    @F,@D6                                             0224
         ST    @F,MINBLK                                          0224
*
*         /*----------------------------------------------------------*
*         /* A TEST IS NOW MADE TO SEE IF THE MINIMUM BLKSIZE CALCU-  *
*         /* LATED ABOVE IS LESS THAN 284 BYTES.  IF IT IS, THE MIN-  *
*         /* IMUM BLKSIZE IS SET TO 284.                              *
*         /*----------------------------------------------------------*
*
*         IF MINBLK < 284               /* IS THE VALUE CALCULATED
*                                          ABOVE FOR MINBLK LESS
*                                          THAN THE ABSOLUTE MINUMUM  *
*            THEN                       /* YES IT IS                  *
         LA    @F,284                                             0225
         C     @F,MINBLK                                          0225
         BC    12,@9EF                                            0225
*              MINBLK=284;              /* SET MINBLK TO ABSOLUTE
*                                          MINIMUM (ASSUMING NO
*                                          SPANNING REQUIRED)         *
         ST    @F,MINBLK                                          0226
*            ELSE;                      /* NO, IT IS GREATER OR EQUAL
*                                          SO DON'T CHANGE IT         *
@9EF     EQU   *                                                  0227
*         DCBREG=ADDR(ULOADDCB);        /* SET CURRENT DCB POINTER
*                                          TO ADDRESS OF UNLOAD DCB   *
@9EE     LA    @5,ULOADDCB                                        0228
*
*         /*----------------------------------------------------------*
*         /* A TEST IS NOW MADE TO DETERMINE IF THE UNLOAD DCB BLK-   *
*         /* SIZE (USER SUPPLIED OR 0) IS LESS THAN THE MINIMUM       *
*         /* REQUIRED FOR UNLOADING.  IF IT IS, IT IS SET TO THE      *
*         /* MINIMUM VALUE.                                           *
*         /*----------------------------------------------------------*
*
*         IF DCBBLKSI < MINBLK          /* IS THE UNLOAD DCB BLKSIZE
*                                          LESS THAN THE ABOVE CALC-
*                                          ULATED MINIMUM             *
*            THEN                       /* YES, IT IS TOO SMALL       *
         L     @F,MINBLK                                          0229
         CH    @F,DCBBLKSI                                        0229
         BC    12,@9ED                                            0229
*              DCBBLKSI=MINBLK;         /* SET IT TO CORRECT MINIMUM
*                                          VALUE                      *
         MVC   DCBBLKSI(2),MINBLK+2                               0230
         BC    15,@9EC                                            0231
*            ELSE;                      /* NO, IT IS LARGER OR EQUAL
*                                          SO DO NOT CHANGE IT        *
@9ED     EQU   *                                                  0231
*
*         /*----------------------------------------------------------*
*         /* A TEST IS NOW MADE TO DETERMINE IF THE UNLOAD DATA SET   *
*         /* CAN PHYSICALLY CONTAIN A RECORD WHOSE LENGTH IS AS LONG  *
*         /* AS THAT SPECIFIED BY THE UNLOAD DCB BLKSIZE FIELD.       *
*         /*----------------------------------------------------------*
*
*         IF DCBBLKSI > OUTMXBLK        /* IS THE UNLOAD DCB BLKSIZE
*                                          LARGER THAN THE MAXIMUM
*                                          RECORD LENGTH ALLOWED ON
*                                          THE UNLOAD DEVICE          *
*            THEN                       /* YES, IT IS LARGER          *
@9EC     L     @F,OUTMXBLK                                        0232
         CH    @F,DCBBLKSI                                        0232
         BC    10,@9EB                                            0232
*              DCBBLKSI=OUTMXBLK;       /* SET THE UNLOAD DCB BLKSIZE
*                                          TO DEVICE MAXIMUM RECORD
*                                          LENGTH - SPANNING MAY HAVE
*                                          TO BE DONE OF THE UNLOADED
*                                          DATA                       *
         MVC   DCBBLKSI(2),OUTMXBLK+2                             0233
*            ELSE;                      /* NO, IT IS NOT LARGER, SO
*                                          DO NOT CHANGE IT           *
@9EB     EQU   *                                                  0234
*         DCBLRECL=DCBBLKSI-4;          /* ASSURE THAT THE UNLOAD DCB
*                                          LRECL FIELD IS EQUAL TO
*                                          THE UNLOAD DCB BLKSIZE
*                                          FIELD MINUS THE LENGTH OF
*                                          THE BIG LL FIELD           *
@9EA     LH    @F,DCBBLKSI                                        0235
         SH    @F,@D2                                             0235
         STH   @F,DCBLRECL                                        0235
*
*         /************************************************************
*         /* THE FOLLOWING GENERATED CODE IS FOR RETURN LINKAGE TO    *
*         /* TO OPEN.                                                 *
*         /************************************************************
*
*         GENERATE;
         BR    @E                 RETURN TO OPEN
         DS    0H
* /********************************************************************
* /*         THIS SECTION HANDLES VALIDATION ERRORS FOUND IN THIS     *
* /*         MODULE.                                                  *
* /********************************************************************
*
* LDUL0100:                             /* OPEN ERROR                 *
*         MSG2='8012'X;                 /* INDICATE OPEN ERROR MESSAGE*
LDUL0100 MVC   MSG2(2),@X6                                        0237
*         GO TO LDUL0112;               /* SET HEADER INDICATOR       *
         BC    15,LDUL0112                                        0238
* LDUL0101:                             /* INPUT AND OUTPUT DATA SETS
*                                          ON SAME TAPE VOLUME ERROR  *
*         MSG2='804A'X;                 /* INDICATE INPUT AND OUTPUT
*                                          DATA SET ON SAME TAPE
*                                          VOLUME MESSAGE             *
LDUL0101 MVC   MSG2(2),@X7                                        0239
*         GO TO LDUL0112;               /* SET HEADER INDICATOR       *
         BC    15,LDUL0112                                        0240
* LDUL0102:                             /* LOAD OR UNLOAD DATA SET
*                                          NOT ON A TAPE OR DISK
*                                          DEVICE ERROR               *
*         MSG2='804B'X;                 /* INDICATE LOAD OR UNLOAD
*                                          DATA SET NOT ON A TAPE
*                                          OR DISK DEVICE             *
LDUL0102 MVC   MSG2(2),@X8                                        0241
*         GO TO LDUL0112;               /* SET HEADER INDICATOR       *
         BC    15,LDUL0112                                        0242
* LDUL0104:                             /* INVALID COPYR1 ID FIELD    *
*         MSG2='8045'X;                 /* INDICATE NOT AN IEBCOPY
*                                          UNLOADED PDS ERROR MESSAGE *
LDUL0104 MVC   MSG2(2),@X9                                        0243
*         GO TO LDUL0112;               /* SET HEADER INDICATOR       *
         BC    15,LDUL0112                                        0244
* LDUL0106:                             /* NOT A LOADBLE DATA SET     *
*         MSG2='8049'X;                 /* INDICATE NOT A LOADABLE DATA
*                                          DATA SET MESSAGE           *
LDUL0106 MVC   MSG2(2),@X10                                       0245
*         GO TO LDUL0112;               /* SET HEADER INDICATOR       *
         BC    15,LDUL0112                                        0246
* LDUL0108:                             /* PARM='COMPRESS' ERROR      *
*         MSG1='8046'X;                 /* INDICATE COMPRESS PARAMETER
*                                          INVALID ERROR MESSAGE      *
LDUL0108 MVC   MSG1(2),@X11                                       0247
*         GO TO LDUL0116;               /* GO ISSUE ERROR MESSAGE     *
         BC    15,LDUL0116                                        0248
* LDUL0112:                             /* PREPARE DDNAME MESSAGE     *
*         MSG1='0811'X;                 /* INDICATE DDNAME HEADER
*                                          ERROR MESSAGE              *
LDUL0112 MVC   MSG1(2),@X12                                       0249
*         PARAMS='80'X;                 /* INDICATE NAME TO BE PLACED
*                                          IN MESSAGE                 *
         MVI   PARAMS,X'80'                                       0250
*         NAMEDISP='00'X;               /* INDICATE DISPLACEMENT FOR
*                                          NAME IN MESSAGE            *
         MVI   NAMEDISP,X'00'                                     0251
*         GO TO LDUL0116 ;                   /*GO ISSUE ERROR MSGM2744*
         BC    15,LDUL0116                                        0252
* LDUL0114 :                                                   /*M2744*
*         MSG1 = '8020'X ;                   /*GIVE NO BUFFER    M2744
*                                               AVAILABLE MSG    M2744*
LDUL0114 MVC   MSG1(2),@X13                                       0253
* LDUL0116:                             /* LINK TO IEBVMS             *
*
*         /************************************************************
*         /* THE FOLLOWING GENERATED CODE IS FOR LINKAGE TO THE       *
*         /* MESSAGE HANDLING ROUTINE IEBVMS.                         *
*         /************************************************************
*
*         GENERATE;
LDUL0116 EQU   *                                                  0254
         STM   @E,@F,REGSAVE1     SAVE REGISTERS 14 AND 15
         L     @F,VIEBVMS         1 ADDRESS OF MESSAGE HANDLING
*                                  ROUTINE
         BALR  @E,@F              LINK TO IEBVMS
         LM    @E,@F,REGSAVE1     RESTORE REGISTERS 14 AND 15
         DS    0H
*    IF RCBUF<'F8'X              /* IF RETURN CODE LESS THAN 8  A44144*
*            THEN                /* YES, IT IS SMALLER          A44144*
         CLI   RCBUF,X'F8'                                        0255
         BC    10,@9E9                                            0255
*         RCBUF='F8'X;           /* SET RETURN CODE TO 8        A44144*
         MVI   RCBUF,X'F8'                                        0256
*            ELSE;               /* NO, IT IS NOT SMALLER SO
*                                   DO NOT CHANGE IT            A44144*
@9E9     EQU   *                                                  0257
*         RTCDREG=4;                    /* SET RETURN CODE TO FOUR    *
@9E8     LA    @F,4                                               0258
*         RETURN;                       /* RETURN TO CALLER           *
* /********************************************************************
* /*        THIS NESTED PROCEDURE IS USED TO READ THE COPYR1 AND      *
* /*        COPYR2 DESCRIPTOR RECORDS.                                *
* /********************************************************************
*
* READHD: PROCEDURE;
@EL01    L     @D,4(0,@D)                                         0260
         L     @E,12(0,@D)                                        0260
         LM    @0,@C,20(@D)                                       0260
         BCR   15,@E                                              0260
READHD   STM   @E,@C,12(@D)                                       0260
         ST    @D,@SAV002+4                                       0260
         LA    @F,@SAV002                                         0260
         ST    @F,8(0,@D)                                         0260
         LR    @D,@F                                              0260
*
*         /************************************************************
*         /* THE FOLLOWING ARE REGISTER RESTRICTIONS.                 *
*         /************************************************************
*
*         RESTRICT(4);                  /* IEBMCA AREA POINTER        *
*         RESTRICT(5);                  /* CURRENT DCB POINTER        *
*         RESTRICT(6);                  /* BUFFER POINTER             *
*         /************************************************************
*         /* THE FOLLOWING DATA DEFINITIONS ARE FOR VARIABLES         *
*         /* USED ONLY IN THIS PROCEDURE.                             *
*         /************************************************************
*
*         DCL
*           BUFPOINT REGISTER(6) POINTER(31); /* CURRENT DESCRIPTOR
*                                                RECORD BUFFER POINTER*
*         BUFPOINT=READPTR;             /* LOAD BUFFER POINTER        *
         L     @6,READPTR                                         0265
*
*         /************************************************************
*         /* THE FOLLOWING GENERATED CODE IS USED TO READ COPYR1      *
*         /* AND COPYR2 DESCRIPTOR RECORDS.                           *
*         /************************************************************
*
*         GENERATE;
         STM   @E,@1,REGSAVE1     SAVE REGISTERS 14,15,0 AND 1
         READ  HDECB,SF,(@5),(@6) READ A HEADER RECORD
         CHECK HDECB              WAIT FOR I/O COMPLETED OK
         LM    @E,@1,REGSAVE1     RESTORE REGISTERS 14,15,0 AND 1
         DS    0H
*         RETURN;                       /* RETURN TO CALLER OF READHD *
*         END READHD;
@EL02    L     @D,4(0,@D)                                         0268
         LM    @E,@C,12(@D)                                       0268
         BCR   15,@E                                              0268
*         END IEBLDUL;
@DATA1   EQU   *
@0       EQU   00                  EQUATES FOR REGISTERS 0-15
@1       EQU   01
@2       EQU   02
@3       EQU   03
@4       EQU   04
@5       EQU   05
@6       EQU   06
@7       EQU   07
@8       EQU   08
@9       EQU   09
@A       EQU   10
@B       EQU   11
@C       EQU   12
@D       EQU   13
@E       EQU   14
@F       EQU   15
@D1      DC    H'-60'
@D2      DC    H'4'
@D3      DC    H'-16'
@D4      DC    H'1'
@D5      DC    H'8'
@D6      DC    H'12'
@MVC     MVC   0(1,@A),0(@E)
         DS    0F
@X6      DC    X'8012'
@X7      DC    X'804A'
@X8      DC    X'804B'
@X9      DC    X'8045'
@X10     DC    X'8049'
@X11     DC    X'8046'
@X12     DC    X'0811'
@X13     DC    X'8020'
@X4      DC    X'CA6D0F'
         DS    0D
@DATA    EQU   *
@SAV001  EQU   @DATA+00000000      72 BYTE(S) ON WORD
JFCBBUF  EQU   00000000            176 BYTE(S)
DSCBBUF  EQU   00000000            96 BYTE(S)
INVOLBUF EQU   00000000            6 BYTE(S)
INDSNBUF EQU   00000000            44 BYTE(S)
REGSAVE1 EQU   @DATA+00000072      16 BYTE(S) ON WORD
READPTR  EQU   @DATA+00000088      FULLWORD POINTER
MINBLK   EQU   @DATA+00000092      FULLWORD INTEGER
ENDCHAR  EQU   @DATA+00000096      HALFWORD INTEGER
DEBXPTR  EQU   @DATA+00000100      FULLWORD POINTER
XTENTCTR EQU   @DATA+00000104      HALFWORD INTEGER
RTCDREG  EQU   00000015            FULLWORD INTEGER REGISTER
JFCBREG  EQU   00000007            FULLWORD POINTER REGISTER
DSCBREG  EQU   00000006            FULLWORD POINTER REGISTER
DEBREG   EQU   00000007            FULLWORD POINTER REGISTER
DCBREG   EQU   00000005            FULLWORD POINTER REGISTER
COPYR1   EQU   00000000            60 BYTE(S) ON WORD
BLL1     EQU   COPYR1+00000000     HALFWORD INTEGER
BLL100   EQU   COPYR1+00000002     HALFWORD INTEGER
LLL1     EQU   COPYR1+00000004     HALFWORD INTEGER
LLL100   EQU   COPYR1+00000006     HALFWORD INTEGER
INDC     EQU   COPYR1+00000008     8 BIT(S)
LOADSTAT EQU   COPYR1+00000008     1 BIT(S)
A00000   EQU   COPYR1+00000008     7 BIT(S)
ID       EQU   COPYR1+00000009     3 BYTE(S)
UDSORG   EQU   COPYR1+00000012     16 BIT(S)
UBLKSIZE EQU   COPYR1+00000014     HALFWORD INTEGER
ULRECL   EQU   COPYR1+00000016     HALFWORD INTEGER
URECFM   EQU   COPYR1+00000018     8 BIT(S)
UKEYLEN  EQU   COPYR1+00000019     8 BIT(S)
UOPTCD   EQU   COPYR1+00000020     8 BIT(S)
A00001   EQU   COPYR1+00000021     8 BIT(S)
TBLKSIZE EQU   COPYR1+00000022     HALFWORD INTEGER
UDEVTYPE EQU   COPYR1+00000024     20 BYTE(S)
A00002   EQU   COPYR1+00000044     16 BYTE(S)
COPYR2   EQU   00000000            284 BYTE(S) ON WORD
BLL2     EQU   COPYR2+00000000     HALFWORD INTEGER
BLL200   EQU   COPYR2+00000002     HALFWORD INTEGER
LLL2     EQU   COPYR2+00000004     HALFWORD INTEGER
LLL200   EQU   COPYR2+00000006     HALFWORD INTEGER
UDEBL16  EQU   COPYR2+00000008     16 BYTE(S)
UDEBX    EQU   COPYR2+00000024     256 BYTE(S)
URES2    EQU   COPYR2+00000280     4 BYTE(S)
TEMP1HDR EQU   00000000            60 BYTE(S)
TEMP2HDR EQU   00000000            284 BYTE(S)
DEBXFLD  EQU   00000000            16 BYTE(S) ON WORD
FILEMASK EQU   DEBXFLD+00000000    8 BIT(S)
UCBAD    EQU   DEBXFLD+00000001    3  BYTE  POINTER ON WORD+1
A00003   EQU   DEBXFLD+00000004    12 BYTE(S)
         ENTRY IEBLDUL1
         ENTRY IEBLDUL2
@SAV002  EQU   @DATA+00000108      72 BYTE(S) ON WORD
BUFPOINT EQU   00000006            FULLWORD POINTER REGISTER
         DS    00000180C
@TEMPS   DS    0F
@TEMP3   DC    F'0'
@TEMP4   DC    F'0'
PATCHLEN EQU   (*-IEBLDUL)/20     5 PERCENT OF MODULE LENGTH
         DS    0H
PATCH    DS    CL(PATCHLEN)       5 PERCENT PATCH AREA
         EJECT
IEBMCA   DSECT
         IEBMCA
LIST5ADR EQU   LIST5+1            ADDRESS PORTION OF LIST5
LIST6ADR EQU   LIST6+1            ADDRESS PORTION OF LIST6
OUTMXBLK EQU   OUTCHAR+4          OUTPUT DEVICE CHARACTERISTICS
*                                  MAXIMUM RECORD LENGTH FIELD
         EJECT
         DCBD  DSORG=PS
EODAD24  EQU   DCBEODAD+1         DCB EODAD ADDRESS FIELD
SYNAD24  EQU   DCBSYNAD+1         DCB SYNAD ADDRESS FIELD
DEBAD24  EQU   DCBDEBAD+1         DCB DEB ADDRESS FIELD
         EJECT
IECDSECT DSECT
         IECDSECT
@DATEND  EQU   *
         END   IEBLDUL
