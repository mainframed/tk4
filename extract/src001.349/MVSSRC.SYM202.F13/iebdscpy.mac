         TITLE 'IEBDSCPY - MAIN PROCESSING MODULE'
IEBDSCPY CSECT
*A042044,520100-520198,521300-521340                           @ZA02997
*A 105240-105296,154700                                        @YM06438
*C 389200,390000,392400                                        @YA06439
*A 391700,392900                                               @YA06439
*A914500                                                        YM06972
*D180800,496200,497200-497900,504120-504340,504440,564400-566400 A34431
*D181100-271200,403500-403800,405600-418800  (IEBBAM)            S20201
*C642510,962100                                                  A41780
*C041960-041980                                                  A44338
*041840,084600,421000,556200,921600,921900                       X010XX
*C041960-041980                                                  A44338
*C834600                                                         A44336
*C403300                                                         A44144
*A402920-403100,618300-619300,631400-631900,831000-831300        A44144
*A402500-402540                                                  A44144
*D403400,403500-403800,619800,830500                             A44144
*C389200,390000,392400                                          YA01718
*A402500-402540                                                  A44144
*D403400,403500-403800,619800,830500                             A44144
*042244,115100-1151140                                          YA01688
*D391800,393000                                                 YA01718
*C389200,390000,392400                                         @YA02603
*A391700-392300                                                @YA02603
***********************************************************************
*A083410-083430,085745-085755                                   YA02536
*D085700,085784                                                 YA02536
*C085760                                                        YA02536
*C392400                                                       @ZA07317
*D392900                                                       @ZA07317
*D520100-520198,521300-521340                                  @ZA10904
*A957800-958000                                                @ZA11929
*C956400                                                       @ZA11929
*A078500,078520                                                @ZA13720
*A788900-788980,835800                                         @ZA13739
*C788400                                                       @ZA13739
*A047450-047984,460050,520850-522456                           @ZA11923
*C459200,460000,517800                                         @ZA11923
*A521010-521050                                                @ZA24081
*C055200                                                       @ZA26345
*D047450-047984,459200-460050,517800-519600,520850-522456      @ZA26345
***********************************************************************
*                                                                     *
*TITLE   IEBDSCPY - IEBCOPY MAIN CONTROL MODULE                       *
*STATUS  CHANGE LEVEL 001
*                                                                     *
*FUNCTION/OPERATION  -  MONITORS THE FLOW OF CONTROL FOR THE IEBCOPY  *
*        UTILITY                                                      *
*        ALLOCATES CORE STORAGE                                       *
*        INITIALIZES FOR THE PROCESSING OF AN INDD-GROUP              *
*        DOES NECESSARY INITIALIZATION FOR PROCESSING MULTIPLE INDD'S *
*        AND/OR OUTDD'S                                               *
*        ALLOCATES I/O BUFFERS                                        *
*        'FINDS' SELECTED OR UN-EXCLUDED INPUT MEMBERS                *
*        PERFORMS OUTPUT PRESCAN FOR DUPLICATE INPUT DIRECTORY        *
*        ENTRIES                                                      *
*        SETS UP FOR COPYING A MEMBER                                 *
*        CONVERTS TTR'S TO MBBCCHHR'S                                 *
*        CONVERTS MBBCCHHR'S TO TTR'S                                 *
*        HANDLES SYSIN AND SYSPRINT I/O ERRORS                        *
*        RETURNS A POINTER TO AN OUTPUT DIRECTORY ENTRY IN THE I/O    *
*        BUFFER                                                       *
*        BUILDS THE CTLTAB AND SAVES INPUT DIRECTORY ENTRIES IN  CORE *
*        WHEN POSSIBLE                                                *
*        RETURNS A POINTER TO AN INPUT DIRECTORY ENTRY IN CORE OR     *
*        READS IN A SPILLED INPUT DIRECTORY ENTRY AND RETURNS A       *
*        POINTER TO IT                                                *
*        SAVES OUTPUT DIRECTORY BLOCKS IN CORE WHEN POSSIBLE          *
*ENTRY POINTS                                                         *
*IEBDSCPY - ALLOCATES CORE STORAGE,DOES INITIALIZATION FOR PROCESSING *
*        AN INDD GROUP                                                *
*IEBGME - FOR RE-ISSUING GETMAIN IF IEBVTM ISSUED FREEMAIN BETWEEN    *
*        COPY OPERATIONS                                              *
*IEBMNI - ALLOCATES I/O BUFFERS, SEARCHES INPUT DIRECTORY FOR SELECTED*
*        OR NON-EXCLUDED MEMBERS, PERFORMS OUTPUT DIRECTORY 'PRE-SCAN'*
*IEBMNM - SETS UP FOR COPYING A MEMBER WITHOUT RE/DE BLOCKING         *
*IEBEOF - SYSIN EODAD INTERFACE                                       *
*IEBIOE - EXCP READ OR WRITE I/O ERROR HANDLING                       *
*IEBCER - SYSIN SYNAD EXIT                                            *
*IEBPER - SYSPRINT SYNAD EXIT                                         *
*IEBSCX - USED BY IEBVTM TO EXIT TO IEBSCN                            *
*IEBDSCP2 -  A CSECT WITHIN THE MAIN CONTROL MODULE,CONTAINING        *
*        SUBROUTINES WHICH MUST ALWAYS BE IN CORE (IN ROOT SEGMENT)   *
*                                                                     *
*THE FOLLOWING SUBROUTINES ARE CONTAINED WITHIN IEBDSCP2 -            *
*TTOCC - CONVERTS TTR'S TO MBBCCHHR'S                                 *
*CCOTT - CONVERTS MBBCCHHR'S TO TTR'S                                 *
*IEBMGD - RETURNS A POINTER TO AN OUTPUT DIRECTORY ENTRY IN THE I/O   *
*        BUFFER.                                                      *
*IEBMBT - BUILDS CTLTAB AND SAVES IDE'S                               *
*IEBMGI - RETURNS A POINTER TO AN IDE IN CORE OR READS AN IDE IN IF IT*
*        IS SPILLED.                                                  *
*IEBMKO - RETAINS OUTPUT DIRECTORY ENTRIES IN CORE                    *
*INPUT - PARAMETER LIST FROM INVOKER                                  *
*        INPUT AND OUTPUT DIRECTORIES                                 *
*        MEMBERS TO BE COPIED                                         *
*                                                                     *
*OUTPUT - COPIED MEMBERS                                              *
*        MERGED OUTPUT DIRECTORY                                      *
*                                                                     *
*EXITS - NORMAL - RETURNS TO CALLER VIA IEBVTM WITH A RETURN CODE IN  *
*        REGISTER 15 OF -                                             *
*        00- NORMAL TERMINATION                                       *
*        04- AN ERROR CONDITION EXISTS PROCESSING CAN CONTINUE        *
*        08- AN ERROR CONDITION EXISTS - PROCESSING CANNOT CONTINUE   *
*       ERROR - SYSIN/SYSPRINT I/O ERRORS EXIT BACK TO I/O-ISSUING    *
*               MODULE                                                *
*                                                                     *
*EXTERNAL ROUTINES -                                                  *
*                  IEBDV1                                             *
*                  IEBSCN                                             *
*                  IEBDRD                                             *
*                  IEBVCT                                             *
*                  IEBVTT                                             *
*                  IEBVWS                                             *
*                  IEBDWR                                             *
*                  IEBVDM                                             *
*                  IEBVTM                                             *
*                  IEBVMS                                             *
*                  IEBMCM                                             *
*                  IEBDRB                                             *
*                  IEBIOE                                             *
*                  IGG019C8 (PCI APPENDAGE)                           *
*                  IEBBAM                                        S20201
*                                                                     *
*TABLES/WORK AREAS -                                                  *
*        ALL SWITCHES, TABLES, AND WORK AREAS NECESSARY FOR           *
*        MONITORING THE IEBCOPY UTILITY                               *
*                                                                     *
*ATTRIBUTES - SERIALLY REUSEABLE                                      *
*                                                                     *
***********************************************************************
*
         EJECT
* GENERAL REGISTER DEFINITION / USAGE
         SPACE 2
R0       EQU   0             WORK REG
R1       EQU   1             WORK REG
R2       EQU   2             WORK REG
R3       EQU   3             WORK REG
R4       EQU   4             ADDR OF COMMUNICATION AREA
R5       EQU   5             WORK REG
R6       EQU   6             WORK REG
R7       EQU   7             WORK REG
R8       EQU   8             WORK REG
R9       EQU   9             WORK REG
R10      EQU   10            WORK REG
R11      EQU   11            BASE REG 1
R12      EQU   12            WORK REG
R13      EQU   13            ADDR OF SAVE AREA
R14      EQU   14            LINK-BACK REG
R15      EQU   15            LINK-OUT REG
TKOFLO   EQU   X'20'              BIT FOR TRACK OVERFLOW TEST OF DCB
TABLEN   EQU   10                 LENGTH OF ONE SETAB/CTLTAB ENTRY
C1CTEL   EQU   TABLEN
CON12    EQU   12                 LENGTH OF FLAG+MBB+COUNT FIELDS
NLLEN    EQU   1300          LENGTH OF RESERVED NOTE-LIST WORK AREA
ZERO     EQU   X'00'              CONSTANT
ONE      EQU   X'01'              CONSTANT
FF       EQU   X'FF'              CONSTANT
XF0      EQU   X'F0'                                             X010XX
RPS      EQU   X'10'              RPS BIT IN DEVICE INFO         S20201
S16      EQU   16                 SHIFT VALUE OF 16              S20201
S24      EQU   24                 SHIFT VALUE OF 24              S20201
NMDISP   EQU   2             DISPLACEMENT OF NAME FRM BEG OF TBL ENTRY
NAMLEN   EQU   8                  LENGTH OF NAME IN TABLE(S)
DBOFF    EQU   4                  OFFSET FROM START OF DEVTYPE TO BLKSZ
SXTN     EQU   NAMLEN+NAMLEN      TWO TIMES LENGTH OF NAME FIELD
OPEN     EQU   X'10'              TO TEST DCBOFLGS FOR OPENED DCB
USERMASK EQU   X'60'              TO TEST FOR ANY USER TTRN IN DIR ENT
ADCVT    EQU   16                 ABSOLUTE ADDR OF POINTER TO CVT
BLNK     EQU   C' '               BLANK CHARACTER
CHAINBK  EQU   4                  FOR SAVE AREA LINKAGE
CHAINTHS EQU   8                  FOR SAVE AREA LINKAGE
DDLORPG  EQU   X'80'              BIT TO TEST FOR DDNAME LIST OR PG NBR
DIV2     EQU   1                  TO DIVIDE BY 2 VIA 'SRL' INSTRUCTION
ENDOFPNO EQU   3                  END OF PAGE NBR AREA
FDEOFF   EQU   22                 OFFSET TO 1ST DE IN BLOCK
LEN8     EQU   8                  LENGTH OF 8
LFT8     EQU   8                  FOR 'SLL' INSTRUCTION
LFT25    EQU   25                 USED IN 'SLL' INSTRUCTIONS
LFT27    EQU   27                 USED IN 'SLL' INSTRUCTIONS
LSYN1    EQU   78                 *  UP
LSYN2    EQU   21                 * SYNADAF
LSYN3    EQU   22                 *  MSG
MAXDE    EQU   80                 LENGTH(+6) OF MAXIMUM DIR ENTRY
MBLEN    EQU   120                LENGTH (-1) OF MSG BUFFER
NNLEN    EQU   4                  LENGTH OF 1 ENTRY IN NNPTRTAB
NOT0     EQU   7                  FOR BC INSTRUCTIONS
OFF140I  EQU   0                  OFFSET IN MSG IEB140I FOR DDNAME
OFF141I  EQU   54                 OFFSET IN MSG IEB141I FOR MBRNAME
OFF159I  EQU   54                 OFFSET IN MSG IEB159I FOR DDNAMX010XX
PRFXLEN  EQU   7                  * AND MSG NBR
REC      EQU   7                  OFFSET TO 'R' OF MBBCCHHR
RT26     EQU   26                 USED IN 'SRL' INSTRUCTIONS
RT30     EQU   30                 USED IN 'SRL' INSTRUCTIONS
SPILLEN  EQU   80                 LENGTH OF SYSUT3 RECORD
SYNMT    EQU   50                 * TEXT                         A44338
SYN1     EQU   42                 * USED                         A44338
SYN2     EQU   19                 *  TO
SYN3     EQU   18                 *  SET
TKOFUDGE EQU   12                 FUDGE FACTOR FOR TRK OVFLO BFR ALLOC
L0       EQU   0                  LENGTH OF 0                  @ZA02997
L1       EQU   1                  LENGTH OF 1
L2       EQU   2                  LENGTH OF 2
L3       EQU   3                  LENGTH OF 3
L4       EQU   4                  LENGTH OF 4
P1       EQU   1                  TO ADD 1 TO SOMETHING
P2       EQU   2                  TO ADD 2 TO SOMETHING
P3       EQU   3                  TO ADD 3 TO SOMETHING
P4       EQU   4                  TO ADD 4 TO SOMETHING
P8       EQU   8                  TO ADD 8 TO SOMETHING
P16      EQU   16                 TO ADD 16 TO SOMETHING
P20      EQU   20                 TO ADD 20 TO SOMETHING        YA01688
P24      EQU   24                 TO ADD 24 TO SOMETHING
P32      EQU   32                 TO ADD 32 TO SOMETHING
P40      EQU   40                 TO ADD 40 TO SOMETHING
X0       EQU   0                  OFFSET OF ZERO
X1       EQU   1                  OFFSET OF 1
X2       EQU   2                  OFFSET OF 2
X3       EQU   3                  OFFSET OF 3
X4       EQU   4                  OFFSET OF 4
X5       EQU   5                  LENGTH OF 5                    X010XX
X6       EQU   6                  OFFSET OF 6
X7       EQU   7                  OFFSET OF 7
X8       EQU   8                  OFFSET OF 8
X10      EQU   10                 SHIFT OF TEN                   X010XX
X11      EQU   11                 OFFSET OF 11                   X010XX
X12      EQU   12                 OFFSET OF 12
* FOLLOWING EQUATES MUST BE CHANGED IF DIRECTORY FORMAT IS CHANGED -
C1KL     EQU   9             OFFSET FROM BEGINNING OF A DIRECTORY BLOCK
*                            TO THE KEYLENGTH FIELD OF THE HDWR COUNT
C1DL     EQU   10            OFFSET FROM BEGINNING OF A DIRECTORY BLOCK
*                            TO THE DTALENGTH FIELD OF THE HDWR COUNT
C1DECT   EQU   11            OFFSET FROM BEGINNING OF DE TO COUNT BYTE
*                            OF NBR OF USER HALFWORDS
C1FXL    EQU   12            LENGTH OF FIXED PORTION OF A DE -
*                            MBRNAME=8, MBRTTR=3, COUNT BYTE=1
KL       EQU   8                  LENGTH OF DIRECTORY KEY
BL       EQU   256                LENGTH OF ONE DIRECTORY BLOCK
KBLEN    EQU   KL+BL              LENGTH OF KEY + BLOCK
HDRLEN1  EQU   60                 LENGTH OF FIRST HEADER RECORD  X010XX
SPIDEOFF EQU   12                 OFFSET FROM BEGINNING OF WORK AREA TO
*                                 ACCESS 1ST BYTE OF A SPILLED INPUT DE
CH4      EQU   C'4'               CHAR. CONSTANT FOR COMPLETION CODE
CH8      EQU   C'8'               CHAR. CONSTANT FOR COMPLETION CODE
CHK      EQU   C'K'                                              X010XX
CHCOMMA  EQU   C','                                              X010XX
         EJECT
MAINFLOW EQU   *
         SPACE 2
         ENTRY IEBDSCME
         ENTRY IEBDSCNI
         SAVE  (14,12),T,IEBDSCPY-OZ26345 SAVE REGS            @ZA26345
         BALR  R11,R0             ADDRESSIBILITY
         USING *,R11
         L     R4,VCOMM                ADDR OF COMMUNICATION AREA
         USING IEBMCA,R4               BASE REG FOR COMMUNICATION AREA
         ST    R13,SV1+CHAINBK    SET UP SAVE AREA LINKAGE
         LA    R10,SV1
         ST    R10,CHAINTHS(R13)
         LR    R13,R10
         LA    R2,NAMLEN          INITIALIZE REGS FOR INVOKATION TESTS
         SR    R7,R7
         SR    R8,R8
         SR    R9,R9
         TM    X0(R1),DDLORPG     IS THERE A DDNAME LIST
         BO    EXTEST             IF NOT, TEST FOR PARAMETER - COMPRESS
         L     R5,X4(R1)          GET ADDR OF LIST
         LH    R6,X0(R5)          GET LENGTH OF LIST
         LA    R5,X2(R5)          ACTUAL ADDR OF LIST ENTRY
DDFIN    LTR   R6,R6              IS LIST EXHAUSTED
         BNH   TSTPG              YES, GO SEE IF PAGE NBR IS SPECIFIED
         LA    R9,P1(R9)          NO, ADD 1 TO SLOT-MODIFIER
         CH    R9,DDSL(R8)        IS THIS SLOT MODIFYABLE BY USER
         BNE   NEXTDD             IF NOT, GO SET TO TRY NEXT SLOT
         CLI   X0(R5),ZERO        IS THERE A NON-ZERO ENTRY HERE
         BE    NXTDD1             IF NOT, USER DIDNT CHANGE THIS DDNAME
         LA    R14,DDLIST(R7)     ELSE GET ADDR WHERE TO MOVE THIS NAME
         MVC   X0(NAMLEN,R14),X0(R5)  OVLY ASSEMB DDNAME WITH USER'S
NXTDD1   AR    R7,R2              INDEX TO NEXT NAME IN DDNAME TABLE
         LA    R8,P2(R8)          POINT TO NEXT SLOT INDICATOR
NEXTDD   SR    R6,R2              DECREASE LENGTH OF LIST BY 8
         AR    R5,R2              POINT TO NEXT ENTRY IN USERS DDLIST
         B     DDFIN              LOOP TO SEE IF ALL DONE
*
*        USE USER'S PAGE NBR IF SPECIFIED
*
TSTPG    TM    X4(R1),DDLORPG     IS THERE A USER-SPECIFIED PAGE NUMBER
         BO    EXTEST             IF NOT, CHECK FOR COMPRESS
         L     R5,X8(R1)          ADDR OF PAGE NBR-2 (LENGTH FIELD)
         LH    R6,X0(R5)          LENGTH OF NBR
         LTR   R6,R6              IS THERE A LNGTH OF PGNOLIST @ZA13720
         BZ    EXTEST             NO,USE DEFAULT PAGE NUMBER   @ZA13720
         BCTR  R6,R0              LENGTH-1 FOR EXECUTING MVC
         LA    R8,PGNO+ENDOFPNO   POINT TO END OF PAGE NBR AREA
         SR    R8,R6              ADJUST TO POINT TO 1ST CHARACTER TO
*                                 BE OVERLAYED BY USER'S PAGE NUMBER
         EX    R6,SETPGNO         MOVE IN USERS PAGE NUMBER
EXTEST   L     R1,X0(R1)          ADDR OF POINTER LIST
         LH    R6,X0(R1)          LENGTH OF LIST
DSC00080 EQU   *                                                 X010XX
         LTR   R6,R6              IS THERE A LIST
         BNH   SETDCBNS           IF NOT, DONT LOOK FOR 'COMPRESS'
         LA    R7,X8                                            YA02536
         CLR   R6,R7              WILL 'COMPRESS' FIT IN LIST   YA02536
         BL    DSC00090           NO, CHECK FOR 'SIZE='         YA02536
         CLC   X2(LEN8,R1),COMP   DOES PARAMETER = 'COMPRESS'
         BNE   DSC00090           GO COMPARE TO 'SIZE='          X010XX
         OI    COMDCDSW,COMPRESS  ELSE SET SWITCH
         SR    R6,R7              SUBTRACT 8 FROM LENGTH         X010XX
         LA    R1,X8(R1)          BUMP PARM POINTER              X010XX
DSC00090 LA    R7,X4                                            YA02536
         CLR   R6,R7              WILL 'SIZE=' FIT IN LIST      YA02536
         BL    DSC00190           NO, DO NOT COMPARE            YA02536
         CLC   X2(X5,R1),COMP1    COMPARE TO 'SIZE='            YA02536
         BNE   DSC00190           COMPARE NEXT PLACE             X010XX
         SR    R6,R7              SUBTRACT 4 FROM LENGTH         X010XX
         LA    R1,X0(R1)          CLEAR HIGH ORDER BYTE          X010XX
         LR    R8,R1                                             X010XX
DSC00100 CLI   X7(R8),CHK         K INDICATES SPECIAL CASE       X010XX
         BE    DSC00120           SET SWITCH AND CONVERT         X010XX
         CLI   X7(R8),CHCOMMA     NEXT BYTE A COMMA              X010XX
         BE    DSC00130           NUMBER OK CONVERT IT           X010XX
         BCT   R6,DSC00110        IF LIST EXHAUSTED              X010XX
         B     DSC00130           GO TO CONVERT                  X010XX
DSC00110 LA    R8,X1(R8)          BUMP DIGIT COUNT               X010XX
         CLI   X6(R8),XF0         WAS LAST BYTE NUMERIC          X010XX
         BNL   DSC00100           YES CONTINUE SCAN              X010XX
         LA    R1,X4(R8)          NO RESTORE POINTER             X010XX
         B     DSC00080           SCAN REMAINDER OF PARM FIELD   X010XX
DSC00120 OI    FLG2,NBRK          SET K SWITCH                   X010XX
DSC00130 SR    R8,R1              NOW R8 HOLDS DIGIT COUNT       X010XX
         BZ    DSC00170           IF 0 RETURN                    X010XX
         LA    R7,X8                                             X010XX
         CLR   R8,R7              COUNT GT 8                     X010XX
         BH    DSC00170           RETURN ,IGNORE SIZE            X010XX
         BCTR  R8,R0              SUBTRACT 1 FOR EXECUTE         X010XX
         XC    CCIMAGE,CCIMAGE                                   X010XX
         EX    R8,PACK            PACK THE NUMBER OF BYTES       X010XX
         CVB   R7,CCIMAGE         CONVERT TO BINARY              X010XX
         TM    FLG2,NBRK          SWITCH ON                      X010XX
         BZ    DSC00150           NO,DONT MULTIPLY BY K          X010XX
         SLL   R7,X10             MULTIPLY BY K                  X010XX
         LTR   R7,R7              NUMBER TO BIG FOR SHIFT        X010XX
         BP    DSC00150           OK,CONVERT NUMBER              X010XX
         LA    R7,X1(R0)          ELSE MAKE                      X010XX
         SLL   R7,RT30                 BIG NUMBER                X010XX
DSC00150 ST    R7,MAXBUF          STORE SIZE                     X010XX
         LA    R1,X1(R1)                                         X010XX
DSC00170 LA    R1,X4(R8,R1)       ADJUST PARM POINTER            X010XX
         B     DSC00080           SCAN REMAINDER OF PARM FIELD   X010XX
DSC00190 LA    R1,X1(R1)          BUMP POINTER                   X010XX
         BCT   R6,DSC00080        SCAN REMAINING FIELD IF ANY    X010XX
SETDCBNS LA    R6,CARDCB                                         X010XX
         USING IHADCB,R6                                         X010XX
         MVC   DCBDDNAM(NAMLEN),DDLIST
         LA    R6,PRTDCB
         MVC   DCBDDNAM(NAMLEN),DDLIST+P8
         LA    R6,INDCB
         MVC   DCBDDNAM(NAMLEN),DDLIST+P16
         LA    R6,OUTDCB
         MVC   DCBDDNAM(NAMLEN),DDLIST+P24
         LA    R6,UT3DCB
         MVC   DCBDDNAM(NAMLEN),DDLIST+P32
         LA    R6,UT4DCB
         MVC   DCBDDNAM(NAMLEN),DDLIST+P40
         DROP  R6
         LA    R14,ENTSCAN        SET UP EXIT REG FOR IEBVMS USE
         STM   R11,R14,RESET1     SAVE CRITICAL REGS - USED BY IEBVTM
*                                 TO RESTORE FROM IF EXITING TO IEBSCN
         MVI   VTMFLG1,NOMAIN     SET INDICATOR IN CASE CANNOT OPEN
*                                 SYSIN OR CANT SUCCESSFULLY GETMAIN
         MVI   IOEF2,NOSYSIN      PRESET BAD-SYSIN SWITCH
         L     R15,VIEBDV0        ADDR OF ROUTINE TO OPEN AND VALIDATE
*                                 SYSIN AND SYSPRINT DCB'S
         BALR  R14,R15            LINK TO ROUTINE
         NI    IOEF2,SPRNOPN      RESET ALL BUT POSSIBLY THIS BIT
         OI    CCSWITCH,FIRSTSCN  SET FIRST ENTRY TO SCN SWITCH
         SPACE
* GET A 48-BYTE AREA OUT OF PLPA FOR THE LIST PASSED TO PAGE   @YM06438
* FIX IN THE START I/O APPENDAGE (IGG019FT).  THIS LIST AREA   @YM06438
* MUST BE OBTAINED OUT OF FIXED STORAGE                        @YM06438
* THE AREA WILL BE FREED AT EOJ IN IEBVTM.                     @YM06438
         SPACE
         L     R7,SIXENTRY        GET LENGTH OF AREA-48 BYTES  @YM06438
         GETMAIN R,LV=(R7),SP=253                              @YM06438
         ST    R1,FIXLIST         STORE ADDR OF GOTTEN AREA    @YM06438
         SPACE
IEBGME   EQU   *                  ENTRY POINT - USED WHEN IEBVTM HAS
*                                 ISSUED A FREEMAIN BETWEEN COPY OPERA-
*                                 TIONS AND ANOTHER GETMAIN MUST BE DUN
IEBDSCME EQU   IEBGME
         GETMAIN VC,LA=ADWANT,A=ADGOT
         LTR   R15,R15
         BC    NOT0,LACKCORE      IF RC NOT 0, TELL USER AND TERMINATE
         MVI   VTMFLG1,ZERO       CLEAR ALL POSS ERROR INDICATORS
         SPACE 2
***
* PERFORM ALL ONE-TIME INITIALIZATION HERE
***
         LM    R7,R8,ADGOT        GET ADDR AND LENGTH OF ACQUIRED CORE
         AR    R8,R7                   ADDR OF LOWCORE + LENGTH =
*                                      ADDR OF HICORE (+1)
         L     R0,FREEAMT         GET LENGTH OF CORE TO FREE UP
         SR    R8,R0              SUBTR FROM CALCULATED MAX HI ADDRESS
         LR    R1,R8              GET ADDRESS FROM WHICH TO FREE UP
         ST    R8,HICOR                PUT MODIFIED ADDR INTO COMMAREA
         ST    R8,SVHI            SAVE ADDR OF HIGHEST AVAIL CORE
         ST    R8,END2ND2         SET ENDING ADDR OF 2ND I/O BUFFER
         LA    R7,P20(R7)         ADD UP ADNL TO FIT            YA01688
*                                  COUNT FIELD INTO             YA01688
*                                  GOTTEN AREA                  YA01688
         ST    R7,ADNL                 ADDR OF NOTE-LIST WKAREA
         LA    R7,NLLEN(R7)            ADD LENGTH OF NOTE-LIST AREA
         ST    R7,ADWK            ADDR OF 128-BYTE WORK AREA
         LA    R7,WKLEN(R7)            ADD LENGTH
         ST    R7,LOCOR           SET ADDR OF LOWEST UNUSED CORE
         ST    R7,INBEGIN              THIS IS ADDR OF 1ST CURRENTLY
*                                      UNUSED BYTE OF AVAILABLE CORE -
*                                      INDD TABLE WILL START HERE
         ST    R7,NXTINDS         SET AS ADDR OF CURRENT INDD NAME
         FREEMAIN   R,LV=(0),A=(1) FREE CORE AT HI END OF ACQUIRED AREA
         OI    FLG4,NEWODS        INITIALIZE 'OUTDD-NOT-WRITTEN-TO' SW
         SPACE 2
         L     R15,VIEBSCN   GET ADDR OF CTL-CD SCAN MODULE
         BALR  R14,R15       EXIT TO CCSCAN
         EJECT
* CCSCAN RETURNS TO THIS POINT...THE SCAN WILL HAVE SET UP THE FOL-
* LOWING TABLES -
*        INDDTAB   -TABLE OF INPUT DD NAMES SPECIFIED IN ''THE CUR-
*                   RENT'' INDD
*        OUTNAME   -NAME OF THE OUTPUT DD
*        SETAB     -IF SELECT, TABLE OF NAMES TO BE SELECTED AND NEW-
*                   NAMES, IF ANY SPECIFIED.
*                  -IF EXCLUDE, TABLE OF NAMES TO BE EXCLUDED
* CARDCB WILL BE OPENED BY IEBSCN WHEN FIRSTENT SW IS SET.
* ALSO, SEVERAL SWITCHES AND ADDRESSES WILL BE SET IN COMMAREA.
*
* CCSCAN CAN ENTER MAINFLOW AT THIS POINT WITH EITHER ONLY A NEW INDD-
* GROUP OR WITH BOTH A NEW INDD-GROUP AND NEW OUTDD.
*
* FIRST, MAINFLOW PERFORMS ALL NECESSARY INITIALIZATION FOR THE NEW
* INDD-GROUP.
ENTSCAN  EQU   *
         XC    ADNNPTRT(L4),ADNNPTRT   ZERO PTR TO NEWNAME TABLE
         MVC   LOCOR(L4),SESTOP   SET CURRENT ADDR OF AVAIL CORE (LOW)
         MVC   INIDDCTS(L2),INDDCT SAVE NBR OF CURRENT INDD'S
*                                 THIS NUMBER MAY BE USED TO AID IN DE-
*                                 TERMINING WHETHER ANY INPUT DATA SETS
*                                 HAVE BEEN PROCESSED, SINCE 'INDDCT'
*                                 WILL HAVE BEEN DECREMENTED WHILE
*                                 'INIDDCTS' REMAINS UNCHANGED UNTIL
*                                 THE NEXT INDD-GROUP IS BEGUN.
         MVC   UFCT(L2),ENCT      PRIME COUNT OF NOT-YET-FOUND'S
         MVI   FLG3,ZERO               TURN OFF SWITCHES
         TM    COMDCDSW,SELECTSC+EXCLUDES  IS THIS A FULL COPY
         BZ    CKICT              IF SO, DONT TEST FOR ONLY 1 SETAB ENT
         LA    R6,ONE
         CH    R6,COUNT           IS ONLY 1 MBR BEING SELECTED/EXCLUDED
         BNE   CKICT              IF NOT, DONT WORRY ABOUT FLAG
         L     R7,SEBEGIN         ELSE GET ADDR OF THE ONE SETAB ENTRY
         OI    X0(R7),SEBIT6      MAKE SURE LAST-ENTRY BIT IS SET
         B     CKICT              SINCE THIS IS 1ST TIME THRU THE CUR-
*                                 RENT INDD GROUP, DONT BUMP 'NXTINDS'
VCOMM    DC    V(IEBDSMCA)        ADDRESS OF COMMUNICATION REGION
COMP     DC    CL8'COMPRESS'      COMPARAND FOR 'PARM=COMPRESS'
COMP1    DC    CL5'SIZE='         COMPARAND FOR PARM SCAN        X010XX
DDSL     DC    H'5'               *INDEX *
         DC    H'6'               *COUNTS*
         DC    H'8'               * FOR  *
         DC    H'9'               *VALID *
         DC    H'10'              *DDLIST*
         DC    H'11'              *SLOTS *
SETPGNO  MVC   X0(L1,R8),X2(R5)   EXECUTED TO SET UP USER'S PAGE NUMBER
PACK     PACK  CCIMAGE,X7(X0,R1)                                 X010XX
TENCON   DC    H'10'              CONSTANT OF 10
SIXENTRY DC    F'48'              LENGTH OF FIX LIST IN SIO    @YM06438
         SPACE 2
* CONTROL IS RETURNED TO THIS POINT BY THE TERMINATION ROUTINE WHENEVER
* IT DETERMINES THAT THERE ARE MORE UN-PROCESSED INPUT DATA SETS (DD-
* NAMES) IN THE INDD TABLE.
         SPACE 2
IEBMNI   EQU   *                  ENTRY POINT FOR NXT IN DS OF SAME GRP
IEBDSCNI EQU   IEBMNI
         L     R6,NXTINDS    SET ADDR OF NEXT INPUT DDNAME IN INDDTAB
         LA    R6,TABLEN(R6) NOTE - THIS IS THE ONLY DIFFERENCE BETW.
         ST    R6,NXTINDS    THE NEXT INPUT DS OF SAME INDD GRP AND
*                            THE 1ST INPUT DS OF A NEW INDD GRP.
         MVC   END2ND2(L4),SVHI   RESET ADDR OF END OF 2ND BUFFER
         SPACE 2
CKICT    EQU   *
         LH    R6,INDDCT     DECREMENT COUNT OF NBR OF INPUT DATA SETS
         LPR   R6,R6         STILL TO BE PROCESSED AFTER CURRENT ONE
         BCTR  R6,R0         SUBTR 1 FROM INDDCT
         STH   R6,INDDCT
         MVC   HICOR(L4),SVHI     RE-INIT PTR TO HIGHEST AVAIL CORE
         XC    ICPT(OBCT+P2-ICPT),ICPT INITIALIZE AREA TO ZEROES
         MVI   FLG7,FRSTMBR       SET FIRST-MEMBER INDICATOR
         L     R6,NXTINDS
         LA    R1,INDCB           SET UP DCB ADDR FOR MOVING
         USING IHADCB,R1
         MVC   DCBDDNAM(NAMLEN),NMDISP(R6) INPUT DDNAME TO DCB
         DROP  R1
         SPACE 1
* NOW CHECK TO SEE IF OUTDD WAS PROCESSED BY SCAN JUST NOW
         TM    FLG4,NEWCOPOP      DID SCAN FIND A NEW COPY OPERATION
         BZ    EXVAL2             NO, GO OPEN AND VALIDATE INPUT ONLY
         SPACE 1
         NI    FLG4,FF-NEWCOPOP   RESET NEW COPY OPERATION SWITCH
         MVI   STATUS,ZERO        CLEAR SWITCHES
         XC    DIRBCNT(L2),DIRBCNT RESET DIRECTORY BLK COUNT TO 0
         MVI   NDBTR,ZERO         RESET BLOCKS PER TRACK COUNT   A36049
         OI    TAG,CTOUT          INDIC NEED TO CT NBR BLKS IN OUT DIR
* NOW GO TO VALIDATE I/O DEVICE ASSIGNMENTS
         L     R15,VIEBDV1        GET ADDR OF E.P. FOR INPUT AND OUTPUT
         B     GOVAL              GO TO LINK TO VALIDATE INPUT & OUTPUT
EXVAL2   L     R15,VIEBDV2        ENTRY-POINT FOR INPUT ONLY
GOVAL    EQU   *
         BALR  R14,R15       EXIT TO I/O VALIDATION ROUTINE
* RETURN FROM VALIDATION ONLY IF THE DCB(S) OPEN AND VALIDATED
         EJECT
* THE MAIN PROGRAM NOW MUST DETERMINE SIZE AND LOCATION OF I/O BUFFERS.
         L     R15,VIEBBAM             ADDR OF BUFFER ALLOCATION S20201
         BALR  R14,R15                 EXIT TO BUFFER ALLOCATION S20201
         B     *+4(R15)           RETURNING FROM IEBBAM INTO     S20201
         B     ASRT1              BRANCH TABLE                   S20201
         B     SBFLGS             BRANCH TABLE                   S20201
         B     SLMSG              BRANCH TABLE                   S20201
ASRT1    EQU   *
         L     R15,VIEBVCT        ADDR OF TABLE-SORTING RTNE
         BALR  R14,R15            LINK TO ROUTINE
         EJECT
* WHEN RETURNED TO AT THIS POINT, MAINFLOW EXPECTS SETAB TO BE SORTED.
* IF SELECT, LOCOR WILL CONTAIN ADDR IN SESTOP (IF NO NEWNAMES), OR
* ADDR OF NNPTRTAB END + 1 IF NEWNAMES WERE SPECIFIED.  NOW READY TO
* SET UP TO SEARCH FOR MEMBERS TO BE COPIED FROM THE CURRENT INPUT DATA
* SET.
SBFLGS   OI    FLG2,FMTSPL        INDICATE TO WRITE CT-KEY-DATA IF NEED
*                                 TO SPILL IDE'S TO SYSUT3 ARISES
         MVI   UT3SCTOR,ZERO      SET UT3 SECTOR VALUE TO 0      S20201
*                                   (USED ONLY IF ON AN RPS      S20201
*                                   DEVICE)                      S20201
         MVI   SENSE,ZERO         RESET SWITCHES
         NI    STATUS,STAT5+STAT7 RESET SWITCHES
         OI    STATUS,STAT1       INDIC READING INPUT DIRECTORY
         MVI   INSCTOR,ZERO       SET INPUT SECTOR VALUE TO 0    S20201
*                                   (USED ONLY IF ON AN RPS      S20201
*                                   DEVICE)                      S20201
         MVC   SVLO(L4),LOCOR     SAVE PTR TO LOWEST AVAILABLE CORE
         TM    ULLDST,LOAD        ON LOAD                        X010XX
         BO    DSC00350           CANT RDLNK TO READ INPUT DIRCT X010XX
         BAL   R2,RDLNK           LINK TO SET TO READ INTO 1ST BFR-AREA
DSC00300 EQU   *                                                 X010XX
         SPACE 2
         MVC   WRTNEXT+X1(L3),BEGFST1  INITIALIZE POINTER FOR IEBDWR
         L     R15,VIEBMGD   ADDR OF RTNE TO FIND NEXT DE IN BFR
         BALR  R14,R15       GO GET THE 1ST DE FROM BFR
         B     NOMBRS             IF NO DE FOUND, GO WRT MSG
*              IEBMGD RETURNS TO R14+4 IF DE IS FOUND
         TM    COMDCDSW,SELECTSC+EXCLUDES  FULL COPY (NEITHER BIT ON)
         BZ    NMEQ          IF SO, GO SAVE DE AND BUILD CTLTAB ENTRY
         L     R9,NMAD            ADDR OF NEXT ENTRY IN SETAB
         TM    COMDCDSW,EXCLUDES  IS IT AN EXCLUSIVE COPY
         BO    CN1           IF SO, GO COMP NAME
         SPACE 2
* FOLLOWING CODE IS EXECUTED FOR SELECTIVE COPY ONLY
TSL1     TM    X0(R9),SEBIT1+SEBIT4+SEBIT5
*                            IS THIS ENTRY FLAGGED AS NEWNAME, DONTCO-
*                            PY, OR FOUND
         BZ    CN2           IF NOT, GO COMP. NAME
TS6      TM    X0(R9),SEBIT6      IS THIS THE LAST ENTRY IN THE SETAB
         BO    TFCT               IF SO, TEST COUNT OF ''FOUNDS''
ABMNM    LA    R9,TABLEN(R9)      SET POINTER TO CTLTAB TO NEXT ENTRY
         ST    R9,BUMP
         ST    R9,NMAD            SINCE THIS IS A SELECT, SET POINTER
*                                 TO NAME BEING SOUGHT TO SAME AS BUMP
         B     TSL1               LOOP TO TEST NEXT ENTRY
CN2      L     R6,DEPTR           ADDR OF NEXT DE IN BFR
         CLC   NMDISP(NAMLEN,R9),X0(R6) TABLE NAME VS. MBRNAME FROM DE
         BL    TS6                IF TABLE LO, SEE IF THIS IS LAST ENT.
         BE    NMEQ               IF SAME, GO SAVE DE
         BAL   R2,NXID1           GO LINK TO GET NEXT IDE
         B     CN2                IF DE FOUND, GO COMP WITH TABLE
TFCT     SR    R8,R8              EOD WAS REACHED (OR EOF)
         CH    R8,FCT             DOES NBR MBRS ''FOUND'' = ZERO
         BE    NOMBRSCP           IF SO, WRT 'NO MBRS COPIED' MSG
         TM    COMDCDSW,SELECTSC  IS THIS A SELECTIVE COPY
         BO    ONU                IF SO, GO SETUP FOR OUTPUT PRE-SCAN
         L     R9,BUMP            GET ADDR OF ''NEXT'' CTLTAB SLOT
         SH    R9,TENCON          SUBTRACT LENGTH OF ONE CTLTAB ENTRY
         OI    X0(R9),SEBIT6      SET LAST-ENTRY INDICATOR IN THIS ENT.
         B     ONU                NOW SET UP FOR OUTPUT PRE-SCAN
         SPACE 2
* THIS CODE EXECUTED FOR AN EXCLUSIVE COPY ONLY
CN1      EQU   *
         L     R6,DEPTR           ADDR OF ''NEXT'' DE IN BFR
         CLC   NMDISP(NAMLEN,R9),X0(R6) TABLE NAME VS. MBRNAME FROM DE
         BH    NMEQ               IF TABLE HI, GO SAVE THIS DE, GET NXT
         BL    LSTEX              IF TABLE LO, GO UPDT PTR TO TBL IF
*                                 THIS ISNT LAST ENTRY
*                                 TABLE NAME EQUALS MBRNAME
         BAL   R2,NXID1           GO GET NEXT DE PRIOR TO BUMPING PTR
LSTEX    TM    X0(R9),SEBIT6      IS THIS LAST ENTRY IN SETAB
         BO    NMEQ               IF SO, DONT TRY MORE COMPARING
         LA    R9,TABLEN(R9)      BUMP PTR TO NXT NAME TO BE EXCLUDED
         ST    R9,NMAD
         B     CN1                GO TO COMPARE TABLE VS DE
         SPACE 2
* THIS CODE IS EXECUTED FOR ALL MODES OF COPY
NXID1    L     R15,VIEBMGD        ADDR OF GETDE SUBRTNE
         BALR  R14,R15            LINK TO GET ADDR OF NXT DE IN BFR
         B     TFCT               IF NO DE GOTTEN SEE IF ANY WERE FOUND
*              IEBMGD RETURNS TO R14+4 IF DE IS FOUND
         BR    R2                 EXIT TO INTERNAL LINK ADDR
         SPACE 1
NMEQ     L     R15,VIEBMBT        GET ADDR OF BLDTAB SUBR
         BALR  R14,R15            LINK TO BLD CTLTAB ENTRY
         TM    COMDCDSW,SELECTSC  IS THIS A SELECTIVE COPY
         BO    DECUF              IF SO, GO TEST COUNT OF ''UN-FOUNDS''
         SPACE 2
* THIS CODE IS EXECUTED FOR EXCLUSIVE AND FULL COPY
         LH    R8,ENCT            ADD 1 TO COUNT OF ENTRIES
         LPR   R8,R8              ASSURE POSITIVE VALUE
         LA    R8,P1(R8)
         STH   R8,ENCT
         BAL   R2,NXID1           GO GET POINTER TO NEXT DE
         TM    COMDCDSW,EXCLUDES  IS THIS AN EXCLUSIVE COPY
         BO    CN1                IF SO, GO CK NEXT DE VS TABLE
         B     NMEQ               ELSE GO BLD NEXT CTLTAB ENTRY
         SPACE 2
* FOLLOWING CODE IS EXECUTED FOR SELECTIVE COPY ONLY
DECUF    LH    R8,UFCT            GET COUNT OF ''NOT-YET-FOUNDS''
         BCTR  R8,R0              SUBTRACT 1 - ONE MORE WAS FOUND
         STH   R8,UFCT            SAVE UPDATED CT
         LTR   R8,R8              IS COUNT = TO ZERO
         BZ    TFCT               IF SO, SEE IF ANY FOUND
         BAL   R2,NXID1           GO GET POINTER TO NEXT DE
         B     ABMNM              ELSE LOCATE NXT SELECT TABLE ENTRY
DSC00350 MVC   READNEXT+P1(L3),BEGFST1   ADDR TO READ TO         X010XX
         L     R15,VRSAM          DO LOADDCB DIRECTORY READ      X010XX
         BALR  R14,R15            LINK TO READ                   X010XX
         B     DSC00300           GO BACK                        X010XX
         EJECT
ONU      EQU   *
         SPACE 2
* AT THIS POINT, PREPARE TO PERFORM PRE-SCAN OF OUTPUT DIRECTORY TO AS-
* SURE THAT NO DUPLICATE NAMED MEMBERS (WITHOUT REPLACE OPTION) GET
* COPIED.
         NI    FLG5,FF-DEFSW      ASSURE INITIALIZATION SWITCH IS
*                                   OFF FOR IEBMGD
         MVI   SENSE,ZERO         RESET SWITCHES
         NI    FLG2,TRKS2+MBUSED  RESET RDEOF SWITCH
         MVI   SWITCH1,ZERO       RESET IEBMGI SWITCHES
         TM    ULLDST,UNLOAD      ON UNLOAD                      X010XX
         BO    DSC00450           GO WRITE HEADER AND DIRECTORY  X010XX
         TM    COMDCDSW,COMPRESS  IS COMPRESS-IN-PLACE SPECIFIED
         BO    PRETTR             IF SO, SKIP PRESCAN AND GO DO TTRSORT
         MVI   STATUS,STAT2       INDIC RDG OUT DIR FROM OUTPUT DATASET
         MVI   OUTSCTOR,ZERO      SET OUTPUT SECTOR VALUE TO 0   S20201
*                                   (USED ONLY IF ON AN RPS      S20201
*                                   DEVICE)                      S20201
         TM    FLG4,ODALT         IS OUT DIR ON SYSUT4
         BZ    SETORD             IF NOT, LEAVE 'STAT2' SET
         MVI   UT4SCTOR,ZERO      SET UT4 SECTOR VALUE TO 0      S20201
*                                   (USED ONLY IF ON AN RPS      S20201
*                                   DEVICE)                      S20201
         MVI   STATUS,STAT3       INDIC RDG OUT DIR FROM SYSUT4 DATASET
SETORD   EQU   *
         BAL   R2,RDLNK           LINK TO SET TO READ INTO 1ST BFR-AREA
         SPACE 2
         TM    FLG6,SPL           WERE ANY INPUT DE'S SPILLED
         BO    OSCIN              IF SO, DONT ATTEMPT TO RETAIN ODE'S
         MVC   SVFSTO(L4),LOCOR   ADDR OF 1ST OUT DIR BLOCK TO BE SAVED
         MVC   ALO(L4),LOCOR      INITIALIZE FOR IEBMKO - ADDR AND
         XC    OBCT(L2),OBCT      NBR OF BLOCKS SAVED IN CORE
         L     R15,VIEBMKO        ADDR OF ROUTINE TO RETAIN OUTPUT DE'S
         BALR  R14,R15            LINK TO ROUTINE
         SPACE 2
OSCIN    TM    FLG5,OSCAN         WAS SCAN OF OUT DIR INITIALIZED
         BO    GNODE              IF SO, BYPASS INITIALIZATION
         OI    FLG5,OSCAN+OSW1    INDIC OUTPUT DIRECTORY PRESCAN AND
*                                 SET INITIALIZATION BIT
         NI    FLG4,FF-LE         RESET IEBMGI'S LAST-ENTRY BIT
         XC    NNTCT(L2),NNTCT    SET NEWNAME-TABLE INDEX TO ZERO
         L     R15,VIEBMGD        ADDR OF RTNE TO GET DE FROM BFR
         BALR  R14,R15            LINK TO GET 1ST DE OF OUT DIR
         B     SETST5             INDIC NULL OUTPUT - NO OUTPUT DE'S
*              IEBMGD RETURNS TO R14+4 IF DE IS FOUND
GNI      L     R15,VIEBMGI        RTNE TO GET NXT IDE (USING CTLTAB)
         BALR  R14,R15            LINK TO RTNE
* IEBMGI WILL RETURN ADDR OF THE INPUT NAME (OR NEWNAME IF INPUT RE-
* NAMED) IN ''IDEAD''
         TM    SWITCH1,MGINODE    WAS NO IDE RETURNED DUE TO UT3 ERROR
         BZ    CMPNS              NO - AN IDE WAS RETURNED
         NI    SWITCH1,FF-MGINODE RESET 'NO-IDE' SWITCH
         L     R8,TABAD
         SH    R8,TENCON          POINT TO CTLTAB ENTRY FOR WHICH THE
*                                 IDE COULD NOT BE RETRIEVED FROM UT3
         B     SETDNTCP           GO TO FLAG IT AS DONT-COPY
CMPNS    L     R6,DEPTR           ADDR OF NEXT OUTPUT DE IN BFR
         L     R7,IDEAD           ADDR OF NAME OF ''NEXT'' INPUT MEMBER
         CLC   X0(NAMLEN,R6),X0(R7) OUTPUT MBRNAME VS. INPUT MBRNAME
         BL    GNODE              IF OUTNAME LO, GET NEXT OUTNAME
         BH    TLE                IF HI, SEE IF THERE ARE MORE INPUT DE
         L     R9,NXTINDS         GET ADDR IF INDDTAB ENTRY FOR THIS DS
         TM    X0(R9),REPLACOP    IS INDD-LEVEL REPLACE SPECIFIED
         BO    GNODE              IF SO, GO GET NEXT OUTPUT DE
         L     R8,TABAD           GET PTR TO NEXT TABLE ELEMENT
         SH    R8,TENCON          ADJUST TO POINT TO CURRENT ELEMENT
         TM    X0(R8),SEBIT3      IS MEMBER-LEVEL REPLACE SPECIFIED
         BO    GNODE              IF SO, ALLOW TABLE ENTRY TO REMAIN
         LR    R7,R8              SAVE PTR TO ENTRY IN CASE ITS NEWNAME
         TM    X0(R8),SEBIT1      IS THIS A NEWNAME ENTRY
         BO    DCOLD              IF SO, FIND OLDNAME AND SET DONTCPY
SETDNTCP EQU   *
         OI    X0(R8),SEBIT4      SET 'DONT-COPY' INDICATOR
         MVI   X2(R8),FF          SET OFFSET BYTE TO INHIBIT USE
         LH    R7,FCT             GET CT OF NBR OF CTLTAB ENTRIES
         LPR   R7,R7
         BCTR  R7,R0              SUBTRACT 1 FROM CT, TO REFLECT DE-
*                                 LETED ENTRY
         LTR   R7,R7              IS COUNT NOW SET TO ZERO
         BZ    NOMBRSCP           IF SO, WRT 'NO MBRS COPIED' MSG
         STH   R7,FCT             ELSE SET DECREMENTED COUNT
TLE      TM    FLG4,LE            WAS LAST IDE GOTTEN YET
         BO    ODEALL             IF SO, SEE IF OUT DIR PROCESSING DONE
         B     GNI                ELSE GO GET NEXT IDE
GNODE    L     R15,VIEBMGD        SET TO GET ADDR OF NXT ODE IN BFR
         BALR  R14,R15            LINK TO SUBROUTINE
         B     ODEALL             IF NO MORE ODE'S, SEE IF ALL SAVED
         B     CMPNS              ELSE GO COMPARE MBRNAMES
SETST5   OI    STATUS,STAT5       INDICATE ABSENCE OF AN OUTPUT DATASET
TSTCTO   TM    TAG,CTOUT          IS MAX LENGTH OF OUT DIR TO BE CALC
         BZ    ALLDUN             IF NOT, CLEANUP AND GO TO SORT CTLTAB
*                                 BY MEMBER TTR
         TM    FLG2,RDEOF         WAS EOF REACHED ON OUTPUT DS
         BZ    RDTILEOF           IF NOT, NEED TO RD AND CT TILL EOF
ALLDUN   NI    TAG,FF-CTOUT       RESET SWITCH USED BY READ ROUTINE
         NI    FLG2,FF-RDEOF      RESET EOF-REACHED SWITCH
         NI    FLG4,FF-LE         RESET LAST-ENTRY-REACHED INDICATOR
         B     PRETTR             GO PREPARE FOR TTR SORT
ODEALL   TM    FLG2,RDEOF         DID EOF OCCUR ON OUTPUT DIRECTORY YET
         BO    ALLDUN             IF SO, DONT TRY TO READ MORE
         TM    FLG4,LE            NEED TO DO MORE SCANNING OF OUTPUT
         BO    TF6SPL             NO.  SEE IF POSSIBLE TO RETAIN MORE
*                                 ODE'S IN CORE
RDMOROUT EQU   *
         MVI   SENSE,ZERO         RESET BITS IN CASE SYSUT3 WAS USED
         BAL   R2,RDLNK           ELSE READ MORE OF OUTPUT DIRECTORY
         TM    FLG6,SPL           WERE ANY IDE'S SPILLED
         BO    TRYLE              SEE IF NAMES ARE TO BE COMP  @YA02603
         TM    FLG5,NSP           DID IEBMKO INDIC NO SPACE REMAINING
         BO    TRYLE              SEE IF NAMES ARE TO BE COMP  @YA02603
         L     R15,VIEBMKO        ADDR OF ROUTINE TO RETAIN OUTPUT DE'S
         BALR  R14,R15            LINK TO ROUTINE
TRYLE    TM    FLG4,LE            WAS LAST IDE GOTTEN YET      @YA02603
         BZ    GNODE              NO, GET NEXT ODE TO COMP     @YA02603
         NI    FLG5,FF-DEFSW      RESET INIT SWITCH, LAST IDE  @YA02603
         B     GNODE              MAY NOT BE COMP TO ALL ODE'S @ZA07317
TF6SPL   TM    FLG6,SPL           WAS ANY ''SPILLING'' DONE
         BO    TSTCTO             YES - SEE IF NEED TO COUNT OUTPUT
*                                 DIRECTORY BLOCKS
         B     RDMOROUT           NO, SO TRY TO READ AND RETAIN MORE
RDTILEOF MVI   SENSE,ZERO         RESET BITS POSSIBLY USED TO READ UT3
LNKRTEOF BAL   R2,RDLNK           GO TO READ AND COUNT OUT DIR BLOCKS
         TM    FLG2,RDEOF         WAS EOF REACHED ON OUTPUT DIRECTORY
         BZ    LNKRTEOF           NO, LOOP UNTIL OUTPUT DIR EOF REACHED
         B     ALLDUN             WHEN GET HERE, MAX NO BLKS IS CALC
DCOLD    L     R8,NNTABAD         PTR TO 'NXT' NEWNAME PTRTAB ENTRY
         LA    R15,NNLEN          LENGTH OF ONE NNPTRTAB ENTRY
         SR    R8,R15             ADJUST POINTER TO CURRENT ENTRY
         L     R8,X0(R8)          POINT TO OLDNAME ENTRY IN CTLTAB
         TM    X0(R8),SEBIT5      IS OLDNAME FLAGGED AS 'FOUND'
         BZ    TLE                IF NOT, GET NEXT ENTRY.  THE INDD
*                                 ON WHICH THIS OLDNAME MIGHT BE FOUND
*                                 MAY HAVE THE INDD-REPLACE OPTION.
         OI    X0(R7),SEBIT4      SET 'DONT-COPY' INDICATOR IN NEWNAME
*                                 CTLTAB ELEMENT
         B     SETDNTCP           GO TO SET IT IN THE OLDNAME ELEMENT
         EJECT
DSC00400 MVI   MSG1+P1,M72        MSG CODE                       A44144
         OI    VTMFLG1,UNUSEND    AN ERROR OCCURRED              A44144
         B     SETRTCD                                           A44144
LACKCORE EQU   *        MIN CORE NOT AVAIL - TERMINATE ENTIRE JOB
         MVI   MSG1+P1,M38        MSG CODE
SETRTCD  EQU   *                                                 A44144
         CLI   RCBUF,CH8          IS COMPLETION CODE 8 OR HIGHER A44144
         BNL   SLMSG              YES- DON'T SET RETURN CODE     A44144
         MVI   RCBUF,CH8          SET COMPLETION CODE            A44144
SLMSG    EQU   *
         MVI   MSG1,LASTMSG       INDICATE THE LAST MSG CODE IN LIST
EXWRM    EQU   *
         L     R15,VIEBVMS        ADDR OF MESSAGE WRITER
         BALR  R14,R15            WRITE MESSAGE
         L     R15,VIEBVTM        ADDR OF STEP/OPERATION TERMINATOR
         BALR  R14,R15            EXIT TO TERMINATE THIS COPY OPERATION
*                                 NO RETURN WILL BE MADE TO THIS POINT
*                                 BY IEBVTM
NOMBRS   EQU   *                  NULL INPUT DATA SET MSG
         TM    COMDCDSW,COMPRESS  WAS A COMPRESS IN PLACE TO HAVE BEEN
*                                 DONE
         BZ    SETM45             IF NOT, GO SET UP MESSAGE
*              IF YES, NEED TO MAKE SURE THAT, WHEN THE OUTPUT DCB IS
*              CLOSED, THE DSCB WILL SHOW ALL UNUSED SPACE FOLLOWING
*              THE DIRECTORY -
         MVC   READNEXT(L4),BCB   SET POINTER FOR READ
         MVI   SENSE,SENSE4       SET TO READ WITH NO DATA XFR
         MVI   STATUS,STAT2       INDIC READING OUTPUT DIRECTORY FROM
*                                 OUTPUT DATA SET
         BAL   R2,RDLNK           GO TO CALL IEBDRD TO READ THE DIR.
         LA    R1,OUTDCB          POINT TO THE OUTPUT DCB JUST USED
         USING IHADCB,R1
         MVC   OUTFDAD(LEN8),DCBFDAD SAVE LAST RECORD'S FULL DISK ADDR
         LA    R2,FDAD(R1)        POINT TO DCBFDAD FIELD WITHIN THE DCB
         DROP  R1
         L     R15,VCCOTT
         BALR  R14,R15            GO TO CONVERT THE MBBCCHHR OF THE EOF
*                                 OF THE OUTPUT DIRECTORY TO A TTR
         MVC   OUTDS1(L4),WKA1    SAVE TTR OF EOF OF OUTPUT DIRECTORY
         MVC   OUTPTTR(LEN8),OUTDS1 ALSO SAVE TTR AND TRKBALANCE AGAIN
         NI    FLG2,FF-RDEOF      RESET 'EOF REACHED' BIT
SETM45   EQU   *
         MVI   MSG1+P1,M45        MSG CODE
         MVI   NAMEDISP,OFF140I   OFFSET IN MSG IEB140I FOR NAME
         MVI   PARAMS,ZERO                                       X010XX
NOMSETUP EQU   *
         OI    FLG7,SUPPRMSG+NOPRNBDB  SET INDICATORS TO SUPPRESS PRIN-
*                                 TING OF MEMBERNAMES AND UNUSED DIREC-
*                                 TORY BLOCKS MSGS BY THE IEBVTM ROUT.
         TM    FLG4,NEWODS        HAS A DIRECTORY MERGE OCCURED
*                                   TO CURRENT OUTPUT DATA SET
         BO    LEAVESET           NO, LEAVE FLG7 AS SET
         NI    FLG7,FF-NOPRNBDB   RESET DON'T PRINT UNUSED
*                                   DIRECTORY BLOCKS MSG SWITCH
LEAVESET EQU   *
         L     R1,NXTINDS
         MVC   NAMEFLD(LEN8),NMDISP(R1) DDNAME TO BE PUT INTO MSG
         OI    PARAMS,NAME        INDICATE NAME IS TO BE PUT IN  X010XX
         MVI   MSG1,LASTMSG+PBIT
         B     EXWRM              WRT MSG AND EXIT TO IEBVTM
NOMBRSCP EQU   *                  NO MBRS COPIED FROM INPUT DATA SET
*                                 REFERENCED BY (DDNAME)
         MVI   MSG1+P1,NOMBCPDM   MSG CODE
         MVI   NAMEDISP,OFF159I   OFFSET FOR NAME IN MSG
         MVI   PARAMS,MSGULLD     'COPIED' MAY HAVE TOBE REPLACEDX010XX
         MVI   COPDISP,X11        DISPLACEMENT OF COPIED         X010XX
         B     NOMSETUP           GO SET UP REST OF MSG INDICATORS
         EJECT
PRETTR   NI    FLG5,OSCAN+NSP     RESET DEFSW, NMUP, OSW1 BITS
         L     R15,VIEBVTT        ADDR OF TTR SORT ROUTINE
         BALR  R14,R15            GO SORT VALID CTLTAB ENTRIES BY TTR
* UPON RETURN, THOSE CTLTAB ENTRIES WHICH WERE FLAGGED AS FOUND (SEBIT5
* ON) AND NOT NEWNAME (SEBIT1) OR DONTCOPY (SEBIT4) WILL BE SORTED SUCH
* THAT EACH ENTRY HAS ONE DE-POINTER IN ALPHAMERIC SEQUENCE AND ANOTHER
* DE-POINTER IN TTR SEQUENCE.
         TM    COMDCDSW,COMPRESS  IS THIS A COMPRESS-IN-PLACE
         BO    CMPRSS             IF SO, GO TO EXIT TO IEBMCM
         TM    FLG6,OIC           WAS ALL OUTPUT DIR RETAINED IN CORE
         BZ    GFCT               IF NOT, GO PREPARE TO GET NEXT IDE
         LA    R6,OUTDCB          POINT TO OUTPUT DCB
         USING IHADCB,R6
         TM    DCBRECFM,TKOFLO    IS TRACK OVERFLOW SPECIFIED ON OUTPUT
         BO    GFCT               IF SO, DONT CHANGE BUFFER ALLOCATION
         DROP  R6
         B     SPLITBUF           TRY TO ALLOCATE SECOND BUFFER  X010XX
DSC00450 L     R15,VWSAM1         WRITE HEADER                   X010XX
         BALR  R14,R15            LINK TO WRITE HEADER ROUTINE   X010XX
         L     R15,VIEBVTT        SORT CTLTAB ON TTR             X010XX
         BALR  R14,R15            LINK TO SORT                   X010XX
         L     R15,VIEBDSU        WRITE OUTPUT DIRECTORY         X010XX
         BALR  R14,R15            LINK TO DIRECTORY SETUP ROUTN  X010XX
         MVC   ALO(L4),LOCOR      INITIALIZE ALO                 X010XX
*                                 (NOT YET DONE FOR AN UNLOAD)   X010XX
         SPACE 2
SPLITBUF EQU   *        SUBRTNE TO ATTEMPT TO ALLOC SECOND BFR AREA
         L     R5,ICPT            ADDR OF CTLTAB ENTRY FOR MOST RECENT
*                                 INPUT DIR ENTRY SAVED IN CORE
         MVC   WKA1(L4),X6(R5)    PUT ADDR OF DE (FROM ALPHABETICALLY
*                                 SEQUENCED SIDE OF CTLTAB) INTO WKAREA
         L     R5,WKA1            GET POINTER TO THE DIRECTORY ENTRY
         L     R6,ALO             ADDR+1 OF END OF LAST OUTPUT DIR
*                                 BLOCK SAVED IN CORE
         SR    R5,R6              DIFFERENCE = AMT OF AVAILABLE CORE
         L     R7,BUFSIZ          LENGTH OF 1/2 BUFFER (ORIGINAL ALLOC)
         AR    R7,R7              MPLY BY 2 TO GET ENTIRE LENGTH
         CR    R5,R7              IS AVAILABLE CORE LESS THAN THIS AMT
         BL    GFCT               IF SO, DON'T ALLOCATE
         L     R8,MAXBUF          GET MAX BUFFER LENGTH          X010XX
         CL    R8,ZROS            WAS IT SPECIFIED               X010XX
         BE    GFCT               NO,DONT SPLIT BUFFERS          X010XX
         SR    R8,R7              SUBTRACT LENGTH ALLOCATED      X010XX
         CR    R8,R7              REMAINDER GT ORIGINAL BUFFER   X010XX
         BL    GFCT               NO,DONT SPLIT BUFFERS          X010XX
         CR    R8,R5              REMAINDER GT AVAILABLE CORE    X010XX
         BH    DSC00470           USE AVAILABLE CORE             X010XX
         LR    R5,R8              ELSE USE MAX BUFFER LENGTH     X010XX
DSC00470 EQU   *                                                 X010XX
         MVC   ENDFST1(L4),END2ND2 SET PTR TO END OF 1ST BUFFER EQ TO
*                                 THE ADDR WHICH HAD BEEN USED (UNTIL
*                                 NOW) AS THE ADDR OF THE END OF THE
*                                 2ND BUFFER.
         MVC   BEGFST2(L4),ALO    SET PTR TO START OF NEW 2ND BUFFER
         AR    R6,R5              ADD LENGTH OF AREA TO BEGINNING ADDR
         BCTR  R6,R0              SUBTR 1 TO PREVENT OVLAYING INPUT DES
         ST    R6,END2ND2         SET ADDR OF END OF AREA
         OI    FLG1,P2FLG1        SET 2-BUFFER-AREAS FLAG IN BCB
* END OF SUBROUTINE ''SPLITBUF''
         SPACE 2
GFCT     EQU   *
         OI    FLG7,COP           SET TO GET INPUT DE'S IN TTR SEQUENCE
*                                 DURING COPY PHASE
         MVI   OUTSCTOR,ZERO      SET OUTPUT SECTOR VALUE TO 0   S20201
*                                   (USED ONLY IF ON AN RPS      S20201
*                                   DEVICE)                      S20201
         XC    SWITCH1(L2),SWITCH1 RESET 'SWITCH1' AND 'UTTRFLAG' BYTES
         MVC   WRTNEXT+P1(L3),BEGFST1  INIT WHERE TO WRITE FROM
         MVC   READNEXT(L4),WRTNEXT    INIT WHERE TO READ INTO
RDNXTOK  EQU   *
         L     R15,VIEBMGI        SUBRTNE TO GET ADDR OF INPUT DE
         BALR  R14,R15            LINK TO RTNE
         TM    SWITCH1,MGINODE    WAS NO IDE RETURNED DUE TO UT3 ERROR
         BZ    GOTIDE1            NO - AN IDE WAS RETURNED
         NI    SWITCH1,FF-MGINODE RESET 'NO-IDE' SWITCH
         TM    FLG4,LE            WAS THIS THE ONLY/LAST IDE TO TRY TO
*                                 GET
         BO    NOMBRSCP           YES - WRT NO MBRS COPIED MSG
         L     R8,TABAD           NO
         SH    R8,TENCON          POINT TO CTLTAB ENTRY FOR THE IDE
*                                 WHICH WAS NOT RETRIEVABLE FROM SYSUT3
         OI    X0(R8),SEBIT4      SET 'DONT-COPY' INDICATOR
         B     RDNXTOK            TRY FOR ANOTHER IDE
GOTIDE1  EQU   *
         L     R6,IDEAD           GET ADDR OF 1ST IDE
MVMTTR   MVC   OLDTTR(L3),NAMLEN(R6)   MOVE MEMBER TTR FOR COMPARING
         LA    R1,INDCB           SET UP PARAM REGS TO CONVERT INPUT
         MVC   WKA1(L3),OLDTTR    GET TTR OF NEXT MEMBER TO BE READ
         MVI   WKA1+P3,ZERO       CLEAR LOW ORDER BYTE
         L     R0,WKA1            PUT INTO PARAMETER REG
         LA    R3,SETRDNXT        SET RETURN REG TO NSI AFTER CONVERT
LKTTOCC  LA    R2,FDAD(R1)        ADDR TO PUT MBBCCHHR (DCBFDAD)
         L     R15,VTTOCC
         BALR  R14,R15            GO LINK TO CONVERT TTR TO MBBCCHHR
         IC    R6,REC(R2)         GET 'R' FROM MBBCCHHR IN DCBFDAD
         BCTR  R6,R0              SUBTRACT 1 FROM 'R'
         STC   R6,REC(R2)         PUT BACK DECREMENTED 'R'
         BR    R3                 EXIT TO NSI OR TO CALLER
SETRDNXT EQU   *
         NI    STATUS,STAT5+STAT7+STAT8
         OI    STATUS,STAT4       INDICATE READING INPUT MEMBER
         NI    FLG2,FF-RDEOF      TURN OFF EOF-REACHED SWITCH
         NI    TAG,TAG5+TAG6+TAG8 RESET TAG1,2,3,4, AND 7
         OI    TAG,TAG2           INDICATE COPYING MBR TO OUTPUT DS
         OI    WSFLAG,FRSTMREC    SET FIRST RECORD OF A MEMBER   A34431
*                                  SWITCH                        A34431
         NI    WSFLAG,FF-USERTTR  RESET POSSIBLE NOTELIST/USERTTR SW
         L     R6,IDEAD           ADDR OF CURRENT IDE
         TM    C1DECT(R6),USERMASK  ANY USER OR NOTE-LIST TTRN'S
         BZ    TSTRB              IF NOT, TEST FOR RE/DE-BLOCKING
         OI    WSFLAG,USERTTR     INDICATE PRESENCE OF NOTELIST AND/OR
*                                 USER TTRN(S)
         SR    R7,R7              SET INDICATOR REG TO 0
         IC    R2,C1DECT(R6)      GET 'C' BYTE FROM DIRECTORY ENTRY
         SLL   R2,LFT25           ISOLATE NBR OF NOTE-LIST/USER TTR'S
         SRL   R2,RT30            USE THIS NBR AS LOOP CONTROL
         LA    R6,C1DECT+P1(R6)   POINT TO 1ST TTRN IN THIS DIR ENTRY
NLPREP   CLI   X3(R6),ZERO        IS 'N' EQUAL TO '0'
         BE    NLSETUP            IF SO, GET NEXT TTRN (IF ANY MORE)
         LA    R7,P1              SET INDICATOR REG TO 1
         MVC   WKA1(L3),X0(R6)    SAVE TTR OF THIS NOTE-LIST
*                                 (ASSUMES ONLY ONE NOTE-LIST PER MBR)
         MVI   WKA1+P3,ZERO       CLEAR LOW ORDER BYTE FOR CONVERSION
NLSETUP  LA    R6,X4(R6)          POINT TO 'N' FIELD OF NEXT TTRN
         BCT   R2,NLPREP          LOOP IF MORE TO CHECK
         LTR   R7,R7              IS ANY NOTE LIST TTRN PRESENT
         BZ    GONOMODS           IF NOT, GO PROCESS THIS MEMBER NOW
         TM    ULLDST,LOAD        ON LOAD                        X010XX
         BO    GONOMODS           GO TO PROCESS MEMBER AND       X010XX
*              NOTELIST AT ONCE (DCBFDAD=ADDR MEMBER-1)          X010XX
         L     R0,WKA1            ELSE GET INPUT TTR OF NOTE-LIST REC
         LA    R1,INDCB           ADDR OF DCB TO BE USED
         MVC   WKA1+P8(LEN8),FDAD(R1)  SAVE CURRENT MEMBER'S MBBCCHHR
         BAL   R3,LKTTOCC         GO TO LINK TO CONVERT TTR TO MBBCCHHR
         MVI   SENSE,SENSE2+SENSE3 INDIC TO READ 1 NOTE-LIST RECORD
         L     R3,READNEXT        SAVE CURRENT BUFFER-POINTER
         MVC   READNEXT(L4),ADNL  SET TO READ INTO NOTE-LIST BUFFER
         L     R15,VIEBDRD        ADDR OF READ ROUTINE
         BALR  R14,R15            GO TO READ NOTE-LIST INTO CORE
         ST    R3,READNEXT        RESTORE SAVED BUFFER-POINTER
         LA    R1,INDCB
         MVC   FDAD(LEN8,R1),WKA1+P8   RESTORE MEMBER'S MBBCCHHR TO DCB
         B     GONOMODS           NOW GO TO PROCESS MEMBER
CMPRSS   EQU   *
         L     R15,VIEBMCM        ADDR OF COMPRESS-IN-PLACE ROUTINE
         BALR  R14,R15            LINK TO PERFORM COMPRESS
         B     *+P4(R15)          UPON RETURN FROM IEBMCM, R15 HAS A
*                                 COMPLETION CODE IN IT -
         B     SETRDNXT           R15 = 0, SO SET UP TO COPY     A34431
*                                   THIS MEMBER                  A34431
         B     MRGDONE            R15 = 4, SO BYPASS DIRECTORY MERGE
TSTRB    TM    FLG3,REBLK         WAS RE/DE-BLOCKING SPECIFIED
         BZ    GONOMODS           IF NOT, GO TO 'NORMAL' COPY ROUTINE
         MVI   INSCTOR,ZERO       SET INPUT SECTOR VALUE TO 0    S20201
*                                   (USED ONLY IF ON AN RPS      S20201
*                                   DEVICE)                      S20201
         L     R15,VIEBDRB        ADDR OF RE/DE-BLOCKING ROUTINE
         BALR  R14,R15            LINK TO ROUTINE
         B     UPDATR             CLEAN-UP AND SEE IF MORE
GONOMODS MVI   SENSE,ZERO         RESET SWITCHES USED BY I/O ROUTINES
         L     R15,VIEBMNM        ADDR OF ROUTINE TO COPY A MEMBER -
*                                 NO RE/DE-BLOCKING OF THIS MEMBER WILL
*                                 BE DONE.  THE MEMBER MAY HAVE USER
*                                 TTRN'S AND/OR A NOTE LIST.
         BALR  R14,R15            LINK TO ROUTINE
         TM    ULLDST,UNLOAD      ON UNLOAD                      X010XX
         BO    TLSTCPYD           DONT UPDATE MEMBER TTR         X010XX
UPDATR   EQU   *
         L     R6,IDEAD           LOCATE CURRENT DIR ENTRY
         MVC   NAMLEN(L3,R6),SVTTR PUT INCREMENTED TTR INTO DIR ENTRY
TSTUT3   EQU   *
         L     R8,TABAD           GET CTLTAB PTR
         SH    R8,TENCON          ADJUST TO POINT TO CURRENT ELEMENT
         NI    TAG,TAG5+TAG6+TAG8 RESET POSSIBLE UNWANTED BITS
         OI    TAG,TAG2           INDICATE WRITING OUTPUT MEMBER DATA
         CLI   X2(R8),ONE         WAS THIS DE ON SYSUT3
         BE    PUTBACK            IF SO, WRITE UPDATED DE BACK IN
*                                 PLACE ONTO SYSUT3
TLSTCPYD TM    FLG4,LE            HAS LAST CTLTAB ENTRY BEEN PROCESSED
         BO    MBRSCPYD           IF SO, ALL MBRS ARE NOW COPIED
         L     R6,IDEAD           LOCATE CURRENT UPDATED DE
         MVI   UTTRFLAG,ZERO      RESET TTRN/NOTELIST FLAG FOR IEBVWS
         L     R7,ADNL            ADDR OF WORK AREA
         MVC   X0(MAXDE,R7),X0(R6) MOVE DE (+ ANYTHING) TO AREA
GOTOGI2  EQU   *
         L     R15,VIEBMGI        ELSE GO LOCATE NXT MEMBER'S DIR ENTRY
         BALR  R14,R15            LINK TO ROUTINE
         TM    SWITCH1,MGINODE    WAS NO IDE RETURNED DUE TO UT3 ERROR
         BZ    GOTIDE2            NO - AN IDE WAS RETURNED
         NI    SWITCH1,FF-MGINODE RESET 'NO-IDE' SWITCH
         TM    FLG4,LE            ANY MORE IDE'S TO TRY TO GET
         BO    MBRSCPYD           NO - ALL MEMBERS WHOSE IDE'S WERE AC-
*                                 CESSIBLE HAVE NOW BEEN COPIED
         B     GOTOGI2            YES - TRY FOR NEXT IDE
GOTIDE2  EQU   *
         MVI   SENSE,ZERO         RESET BITS POSSIBLY USED TO READ UT3
         L     R8,IDEAD           GET POINTER TO DIR ENTRY
         LR    R6,R8              SET UP POINTER IN CASE 'BZ' TAKEN
         TM    NAMLEN+P3(R8),ALIAS DOES THIS DE REFERENCE AN ALIAS
         BZ    MVMTTR             IF NOT, CANT BE SAME AS PREVIOUS MBR,
*                                 SO GO SAVE IT AND COPY
         CLC   NAMLEN(L3,R8),OLDTTR IS THIS INPUT MEMBER TTR SAME AS
*                                 THE INPUT MEMBER TTR OF THE MEMBER
*                                 JUST NOW COPIED
         BE    PROCAL             IF SO, THEN MAIN-MBR DIR ENTRY HAS
*                                 BEEN PROCESSED, SO MERGE FIELDS
*        IF NOT EQUAL, CURRENT MEMBER'S TTR MUST BE GREATER THAN THE
*        TTR OF THE MEMBER JUST COPIED.
         B     MVMTTR             GO PROCESS AS IF IT WERE NOT AN ALIAS
         SPACE 2
* IF MEMBER TTR EQ OLDTTR, AN ALIAS HAS BEEN OR IS BEING PROCESSED.
* THE MEMBER TTR AND UP TO 3 USER TTRN'S WILL BE MERGED FROM THE DIREC-
* TORY ENTRY WHICH WAS ''SAVED'' TO THE CURRENT DIRECTORY ENTRY.
         DS    0H
PROCAL   EQU   *
         MVC   NAMLEN(L3,R8),NAMLEN(R7) OVLAY MBR-TTR IN CURRENT D.E.
         IC    R5,C1DECT(R8)      GET 'C' BYTE FROM ALIAS DE
         SLL   R5,LFT25           SHIFT OUT 'ALIAS' BIT
         SRL   R5,RT30            ISOLATE USER-TTRN COUNT BITS
         LA    R6,C1FXL(R8)       SET PTR TO CURRENT TTRN'S
         LA    R3,C1FXL(R7)       SET PTR TO PREVIOUS DE'S TTRN'S
         LTR   R5,R5              ANY USER/NOTELIST TTRN TO BE REPLACED
         BZ    TSTUT3             IF NOT, GO SEE WHERE CURR DE CAME FRM
MVLOOP   EQU   *
         MVC   X0(L4,R6),X0(R3)   MOVE TTRN FROM PREVIOUS DE TO CURR DE
         LA    R3,P4(R3)          BUMP POINTERS TO PREVIOUS
         LA    R6,P4(R6)               AND CURRENT TTRN'S
         BCT   R5,MVLOOP          DECREM TTRN COUNT BY 1 AND LOOP
         B     TSTUT3             NOW SEE IF NEED TO WRT THIS DE TO UT3
* SINCE THERE CAN BE (AT MOST) ONLY 2 LOW ORDER BITS ON IN R5, 'MERGE'
* WILL BE DONE FOR A MAXIMUM OF THREE FIELDS OF USER TTRN'S.
         SPACE 2
PUTBACK  EQU   *
         NI    TAG,TAG5+TAG6      RESET SWITCHES USED BY WRITE RTNE
         OI    TAG,TAG4           INDICATE 'WRITING TO SYSUT3'
         L     R15,ADWK           ADDR OF IDE TO BE RE-WRITTEN (-12)
         LA    R14,UT3DCB
         MVC   X1(LEN8,R15),FDAD(R14) PUT MBBCCHHR OF SYSUT3 REC TO BE
*                                 WRITTEN INTO AREA PRECEEDING RECORD
         MVI   X0(R15),ENDPROC    INDICATE THAT THIS IS THE 'LAST' REC
*                                 TO BE WRITTEN OUT (ALSO IS ONLY REC,
*                                 SINCE ONLY ONE REC BEING WRITTEN BACK
*                                 AT A TIME).  IT WILL BE WRITTEN BACK
*                                 TO SAME PLACE IT WAS READ FROM, USING
*                                 WRITE KEY-DATA CCW TO AVOID FORMAT-
*                                 TING REST OF TRACK AFTER THIS RECORD.
         L     R15,VIEBDWR        GET ADDR OF WRITE ROUTINE
         BALR  R14,R15            GO TO WRITE PREVIOUSLY READ SPILLED
*                                 DIR ENTRY WHICH HAS NOW BEEN UPDATED
         B     TLSTCPYD           GO SEE IF MORE MEMBERS TO BE COPIED
MBRSCPYD EQU   *
         TM    WSFLAG,NOWRT       WAS LAST BFR-FULL OF MBR DATA WRITTEN
         BZ    SKPURGE            IF SO, DONT TRY TO PURGE BUFFER
         NI    TAG,TAG5+TAG6      RESET ALL BUT TAG5,6
         OI    TAG,TAG2           INDICATE WRITING MEMBER DATA
         OI    WSFLAG,FORCEWRT    ELSE INDIC NEED TO PURGE I/O BUFFER
         L     R15,VIEBVWS
         BALR  R14,R15            GO VIA IEBVWS TO EMPTY OUT BUFFER
SKPURGE  NI    FLG7,FF-COP        RESET INDICATOR BIT USED BY IEBMGI
         MVC   OUTPTTR(LEN8),OUTDS1 SAVE LAST RECORD'S TTRN AND TRKBAL
         TM    ULLDST,UNLOAD      ON UNLOAD                      X010XX
         BO    DSC00530           NO DIRECTORY MERGE             X010XX
         MVI   SWITCH1,ZERO       RESET IEBMGI SWITCHES
         L     R15,VIEBVDM        ADDR OF DIRECTORY MERGE RTNE
         BALR  R14,R15            GO TO MERGE DIRECTORY
MRGDONE  L     R15,VIEBVTM        ADDR OF TERMINATION ROUTINE
         BALR  R14,R15            EXIT TO TERMINATE INDD/STEP/OPER/JOB
DSC00530 L     R15,VIEBDSU1       MODIFY CTLTAB                  X010XX
         BALR  R14,R15            LINK TO CTLTAB MODIFIER        X010XX
         MVI   SWITCH1,ZERO       RESET IEBMGI SWITCHES          X010XX
         B     MRGDONE            TERMINATE OPERATION            X010XX
         EJECT
IEBDSFRC EQU   *                                                 X010XX
         ENTRY IEBDSFRC
         SAVE  (14,12)            SAVE REGS                      X010XX
         BALR  R11,R0             GET BASE FOR THIS RTN IN R 11  X010XX
         LA    R15,IEBDSFRC-IEBDSCPY   ADJUST BASE REG           X010XX
         SR    R11,R15            TO HOLD IEBDSCPY BASE          X010XX
         ST    R13,SV6+CHAINBK    SET UP SAVE AREA               X010XX
         LA    R10,SV6                                           X010XX
         ST    R10,CHAINTHS(R13)                                 X010XX
         LR    R13,R10                                           X010XX
         L     R1,HICOR           GET HIGH END OF AVAILABLE CORE X010XX
         L     R0,FREEAMT2        AMOUNT OF CORE TO BE FREED     X010XX
         SR    R1,R0              GET REMAINDER                  X010XX
         L     R5,LOCOR           GET LOW END OF AVAILABLE CORE  X010XX
         AH    R5,HDRLEN          ADD LENGTH OF HEADER RECORDS   X010XX
         CLR   R1,R5              SPACE ENOUGH                   X010XX
         BNH   DSC00400           NO,WRITE MESSAGE               X010XX
         L     R2,LENGOT          TOTAL LENGTH OF CORE GETMAINED X010XX
         SR    R2,R0              ADJUST IT                      X010XX
         ST    R2,LENGOT          AND STORE IT BACK              X010XX
         FREEMAIN R,LV=(0),A=(1)  FREE CORE FOR BSAM WORK AREA   X010XX
         OI    ULLDST,CFREED      INDICATE CORE FREED            X010XX
         L     R1,HICOR           RESTORE REG1 TO PREVIOUS        M2661
         S     R1,FREEAMT2          VALUE,WAS CHANGED             M2661
         SH    R1,HDRLEN          CALCULATE ADDR OF HEADER       X010XX
         ST    R1,ACOPYR1         STORE IT                       X010XX
         ST    R1,HICOR           HIGH END OF UNUSED CORE        X010XX
         ST    R1,SVHI            WILL STAY SO AFTER EACH INDD   X010XX
         ST    R1,END2ND2         END OF SECOND BUFFER           X010XX
         LA    R1,HDRLEN1(R1)     CALCULATE ADDR OF COPYR2       X010XX
         ST    R1,ACOPYR2         STORE IT                       X010XX
         L     R13,SV6+CHAINBK    RESTORE CALLERS REGS           X010XX
         RETURN (14,12)           RETURN TO CALLER               X010XX
         EJECT
IEBMNM   EQU   *                                                 X010XX
* SUBROUTINE TO COPY THE MEMBER WITH NO MODIFICATIONS (I.E., NO RE/DE-
* BLOCKING).  THERE MAY OR MAY NOT BE A NOTE-LIST RECORD AND/OR USER
* TTRN'S SPECIFIED FOR THIS MEMBER.
IEBDSCNM EQU   IEBMNM
         ENTRY IEBDSCNM
         ST    R14,SV14           SAVE EXIT REG CONTENTS
         NI    TAG,TAG5+TAG6+TAG8 RESET TAG1,2,3,4, AND 7
         OI    TAG,TAG2           INDIC COPYING MBR TO OUTPUT DATA SET
         NI    STATUS,STAT5+STAT7+STAT8
         OI    STATUS,STAT4+STAT8 INDIC READING 1ST REC OF INPUT MEMBER
         MVI   INSCTOR,ZERO       SET INPUT SECTOR VALUE TO 0    S20201
*                                   (USED ONLY IF ON AN RPS      S20201
*                                   DEVICE)                      S20201
RDMORDTA EQU    *                                                X010XX
         TM    ULLDST,LOAD        ON LOAD                        X010XX
         BO    DSC00550           DONT USE IEBDRD                X010XX
         L     R15,VIEBDRD        ADDR OF READ ROUTINE           X010XX
         B     DSC00560           USE EXCP                       X010XX
DSC00550 L     R15,VRSAM1         USE LOADDCB                    X010XX
DSC00560 EQU   *                                                 X010XX
         BALR  R14,R15            LINK TO READ A BUFFER-FULL
         TM    ULLDST,UNLOAD      ON UNLOAD                      X010XX
         BO    DSC00580           DONT USE IEBDWR                X010XX
         L     R15,VIEBVWS        GO TO WRITE WHAT WAS JUST READ
         B     DSC00590           USE EXCP WRITE                 X010XX
DSC00580 L     R15,VWSAM          USE ULOADDCB                   X010XX
DSC00590 EQU   *                                                 X010XX
         BALR  R14,R15            LINK TO ROUTINE
TRDEOF   TM    FLG2,RDEOF         WAS ALL OF MEMBER READ AND WRITTEN
         BZ    RDMORDTA           IF NOT, GO READ MORE MEMBER DATA
         NI    FLG2,FF-RDEOF      RESET EOF-READ INDICATOR
         L     R14,SV14           RESTORE EXIT REG
         BR    R14                GO BACK TO MAINFLOW
SV14     DC    F'0'               SVAREA FOR LINK REG
         SPACE 2
RDLNK    EQU   *             LINKAGE TO IEBDRD - USED WHEN READING INTO
*                            ''1ST'' I/O BUFFER AREA
         MVC   READNEXT+P1(L3),BEGFST1 SET ADDR WHERE TO READ INTO
         L     R15,VIEBDRD        ADDR OF READ SUBROUTINE
         BALR  R14,R15            LINK TO READ
         BR    R2                 RETURN TO CALLER
*              IF AN EOF OCCURRED, IEBDRD WILL HAVE SET RDEOF SWITCH
         SPACE 2
*        SYSIN EODAD INTERFACE
IEBEOF   EQU   *
IEBDSCEF EQU   IEBEOF
         ENTRY IEBDSCEF
         L     R15,VIEBSEF        ADDR OF ENTRY POINT IN IEBSCN
         BR    R15                EXIT TO HANDLE SYSIN EOF
*        MEMBER EODAD INTERFACE                                  X010XX
IEBDSOE2 EQU   *                                                 X010XX
         ENTRY IEBDSOE2                                          X010XX
         L     R15,VIEBIOE2       EODAD ROUTINE IN IOE           X010XX
         BR    R15                EXIT TO HANDLE EOF             X010XX
         EJECT
IEBCER   EQU   *
IEBDSCCE EQU   IEBCER
         ENTRY IEBDSCCE
* THIS IS THE ENTRY POINT FOR SYSIN SYNAD EXIT
*
         USING IEBCER,R15
         SYNADAF   ACSMETH=QSAM
         ST    R6,SAV6X           SAVE REG USED IN THIS ROUTINE
         SR    R6,R6              SET REG TO 0 TO INDIC SYSIN SYNAD
         B     SYNRLS             GO SET UP MSG IN BUFFER
         SPACE 2
IEBPER   EQU   *
IEBDSCPE EQU   IEBPER
         ENTRY IEBDSCPE
* THIS IS THE ENTRY POINT FOR SYSPRINT SYNAD EXIT
*
         USING IEBPER,R15
         SYNADAF   ACSMETH=QSAM
         L     R15,AIOE2          GET ADDR OF PRIMARY ENTRY POINT
         DROP  R15
         USING IEBCER,R15
         ST    R6,SAV6X           SAVE REG USED IN THIS ROUTINE
         LA    R6,ONE             SET REG TO +1 FOR SYSPRINT SYNAD IND
         B     SYNRLS             GO SET UP MSG IN BUFFER
         SPACE 1
AIOE2    DC    A(IEBCER)          ADDR OF PRIMARY SYNAD EXIT E.P.
         SPACE 2
SYNRLS   EQU   *
         MVI   MSGBUF,BLNK        CLEAR MSG BUFFER
         MVC   MSGBUF+P1(MBLEN),MSGBUF
         LTR   R6,R6              WAS ERROR ON SYSPRINT
         BP    PRTMSG             YES - SET UP MSG FOR WTO/WTP
         MVC   MSGBUF+SYN1(LSYN1),SYNMT(R1) NO- SET UP SYSIN SYNAD MSG
         MVC   MSGBUF+SYN2(LSYN2),RFSYS MOVE IN MSG PREFIX
         CLI   RCBUF,CH8          IS COMPLETION CODE 8 OR HIGHER A44144
         BNL   SETCODES           YES- DON'T SET RETURN CODE     A44144
         MVI   RCBUF,CH8          SET COMPLETION CODE            A44144
SETCODES EQU   *
         MVI   MSG1,LASTMSG+IOERF  SET INDICATORS FOR IEBVMS
         MVC   MSGBUF+P1(PRFXLEN),IEBPRFX
         L     R6,SAV6X           RESTORE REG USED BY THIS ROUTINE
         SYNADRLS
         BR    R8                 EXIT TO SYNAD RETURN POINT IN CALLER
PRTMSG   EQU   *
         MVC   MSGBUF+SYN1(LSYN1),SYNMT(R1) SET UP SYSPRINT SYNADAF MSG
         MVC   MSGBUF+SYN3(LSYN3),WTPRT
         OI    IOEF2,SPRNOPN      INDICATE TO NOP PRINTING OF MESSAGES
         CLI   RCBUF,CH4          IS COMPLETION CODE 4 OR HIGHER A44144
         BNL   SETCODES           YES- DON'T SET RETURN CODE     A44144
         MVI   RCBUF,CH4          NO - SET IT TO 4               A44144
         B     SETCODES           GO SET IEBVMS INDICATORS
SAV6X    DS    F                  AREA FOR SAVING CALLERS REG
* THE FOLLOWING 3 DC'S ARE USED IN SETTING UP SYNADAF MSG TEXT
RFSYS    DC    C'READING FROM SYSIN - '
WTPRT    DC    C'WRITING TO SYSPRINT - '
IEBPRFX  DC    C'IEB139I'
         DROP  R15
         DROP  R11
         SPACE 2
         DS    0H
IEBSCX   EQU   *             ENTRY POINT IN MAINFLOW
* THIS ENTRY POINT IS USED BY THE TERMINATION ROUTINE (IEBVTM) WHEN
* IT IS NECESSARY TO EXIT TO THE CONTROL-CARD SCAN ROUTINE (IEBSCN).
* THE ENTRY POINT IS IN MAINFLOW IN ORDER TO AVOID AN EXCLUSIVE CALL
* IF THIS UTILITY PROGRAM IS IN OVERLAY STRUCTURE.
IEBDSCSX EQU   IEBSCX
         ENTRY IEBDSCSX
         L     R15,VIEBSCN        ADDR OF CONTROL-CARD SCAN ROUTINE
         BR    R15                EXIT TO IEBSCN
         SPACE 2
         DS    0H
IEBM04   EQU   *                  ENTRY POINT IN MAIN PROGRAM
* THIS ENTRY POINT IS USED BY THE DIRECTORY MERGE ROUTINE (IEBVDM) WHEN
* IT IS NECESSARY FOR IT TO CALL THE VALIDATION ROUTINE (AT ENTRY POINT
* IEBDV4) TO OPEN AND VALIDATE SYSUT4.  THIS ENTRY POINT IS IN THE MAIN
* PROGRAM IN ORDER TO AVOID AN EXCLUSIVE CALL IF THIS UTILITY PROGRAM
* IS LINK-EDITED IN OVERLAY.
IEBDSCM4 EQU   IEBM04
         ENTRY IEBDSCM4
         L     R15,VIEBDV4        E.P. IN IEBDV1 CSECT
         BALR  R14,R15            EXIT TO OPEN/VALIDATE SYSUT4 DCB
         L     R15,VIEBRTM        RETURN POINT IN IEBVDM CSECT
         BR    R15                RETURN TO DIRECTORY MERGE ROUTINE
         SPACE 1                                                 A33288
IEBDSRE  EQU   *                                                 A33288
         ENTRY IEBDSRE                                           A33288
* THIS ENTRY POINT IS TO AVOID AN EXCLUSIVE CALL BETWEEN IEBDRD  A33288
* AND IEBIOE                                                     A33288
         SPACE 1                                                 A33288
         L     R15,VIEBIOE        ADDR OF IEBIOE                 A33288
         BALR  R14,R15            LINK TO IEBIOE                 A33288
         L     R15,VIEBDRDR       ADDR OF RETURN POINT IN IEBDRD A33288
         BR    R15                RETURN                         A33288
         SPACE 1                                                 A33288
IEBDSWE  EQU   *                                                 A33288
         ENTRY IEBDSWE                                           A33288
* THIS ENTRY POINT IS TO AVOID AN EXCLUSIVE CALL BETWEEN IEBDWR  A33288
* AND IEBIOE                                                     A33288
         SPACE 1                                                 A33288
         L     R15,VIEBIOE        ADDR OF IEBIOE                 A33288
         BALR  R14,R15            LINK TO IEBIOE                 A33288
         L     R15,VIEBDWRR       ADDR OR RETURN POINT IN IEBDWR A33288
         BR    R15                RETURN                         A33288
         SPACE 1                                                 A33288
         SPACE 1
         DS    0F
PATCHLN  EQU   (*-MAINFLOW)/20    5 PER-CENT PATCH AREA LENGTH
PATCH    DC    XL(PATCHLN)'00'    PATCH AREA FOR THIS CSECT      A41780
         EJECT
IEBDSCP2 CSECT
         SPACE 2
*
* THIS CSECT CONSISTS OF SUBROUTINES WHICH WILL REMAIN WITHIN THE
* ROOT SEGMENT IF THIS PROGRAM IS IN OVERLAY STRUCTURE.
*
         SPACE 2
         USING IEBMCA,RG4
* SUBROUTINE TO EFFECT LINKAGE TO SYSTEM ROUTINE WHICH CONVERTS TTR TO
* MBBCCHHR
*
* INPUT TO ROUTINE - R1 = ADDR OF DCB, R0 = TTR TO BE CONVERTED,
* R2 POINTS TO LOCATION FOR ROUTINE TO PUT MBBCCHHR, R13 = SVAREA ADDR,
* R14 = RETURN REG.  NOTE--R15 MIGHT NOT HAVE ADDR OF ROUTINE IN IT...
* THIS WILL NOT MATTER.
TTOCC    EQU   *
IEBDSTOC EQU   TTOCC
         ENTRY IEBDSTOC
         SAVE  (14,12)            STANDARD LINKAGE CONVENTIONS
*                                 (EXCEPT FOR USE OF REG 15)
         USING TTOCC,R10          ESTABLISH ADRESSABILITY        X010XX
         LR    R10,R15                                           X010XX
         ST    R13,SV4+CHAINBK
         LA    R9,SV4
         ST    R9,CHAINTHS(R13)
         LR    R13,R9
         LA    R1,X0(R1)          CLEAR HI ORDER BYTE            X010XX
         TM    ULLDST,LOAD        NO LOAD                        X010XX
         BZ    DSC00650           USE SYSTEM CONVERT ROUTINE     X010XX
         LA    R9,INDCB           AT THIS TIME INDCB IN R1 IF    X010XX
         CR    R9,R1                CONVERTING FOR SEQ INPUT DS  X010XX
         BNE   DSC00650           NOT FOR INPUT,USE SYSTEM CONV. X010XX
         L     R15,VIEBCNVT       ELSE USE IEBCOPY CONVERT ROUT. X010XX
         B     DSC00660           GO USE OWN CONVERT ROUTINE     X010XX
DSC00650 EQU   *                                                 X010XX
         L     R15,ADCVT          ADDR OF CVT
         L     R15,TPCNVT(R15)    ADDR OF TTR-TO-MBBCCHHR CONVERT RTNE
DSC00660 EQU   *                                                 X010XX
         USING IHADCB,R1          SET DCB BASE REG
         L     R1,DCBDEBAD        ADDR OF DEB FROM DCB
         LA    R1,X0(R1)          CLEAR HI ORDER BYTE
         BALR  R14,R15            LINK TO CONVERT ROUTINE
         L     R13,SV4+CHAINBK
         RETURN (14,12),RC=(15)
         DROP  R1
         DROP  R10                                               X010XX
         EJECT
* SUBROUTINE TO EFFECT LINKAGE TO SYSTEM ROUTINE WHICH CONVERTS
* MBBCCHHR TO TTR
*
* INPUT TO ROUTINE - R1 = ADDR OF DCB, R2 = POINTER TO MBBCCHHR
* R14 = RETURN REG.  OUTPUT = TTRN STORED IN ''WKA1''.
CCOTT    EQU   *
IEBDSCOT EQU   CCOTT
         ENTRY IEBDSCOT
         SAVE  (14,12)            STANDARD LINKAGE CONVENTIONS
*                                 (EXCEPT FOR USE OF REG 15)
         USING CCOTT,R10          ESTABLISH ADRESSABILITY        X010XX
         LR    R10,R15                                           X010XX
         ST    R13,SV4+CHAINBK
         LA    R9,SV4
         ST    R9,CHAINTHS(R13)
         LR    R13,R9
         LA    R1,X0(R1)          CLEAR HI ORDER BYTE            X010XX
         TM    ULLDST,LOAD        NO LOAD                        X010XX
         BZ    DSC00670           USE SYSTEM CONVERT ROUTINE     X010XX
         LA    R9,INDCB           AT THIS TIME INDCB IN R1 IF    X010XX
         CR    R9,R1                CONVERTING FOR SEQ INPUT DS  X010XX
         BNE   DSC00670           NOT FOR INPUT,USE SYSTEM CONV. X010XX
         L     R15,VIEBCNV1       ELSE USE IEBCOPY CONVERT ROUT. X010XX
         B     DSC00680           GO USE OWN CONVERT ROUTINE     X010XX
DSC00670 EQU   *                                                 X010XX
         L     R15,ADCVT          ADDR OF CVT
         L     R15,TPRLTV(R15)    ADDR OF ABSOL TO REL TTR CONVERT RTNE
DSC00680 EQU   *                                                 X010XX
         USING IHADCB,R1
         L     R1,DCBDEBAD        ADDR OF DEB FROM DCB
         LA    R1,X0(R1)          CLEAR HI ORDER BYTE
         SR    R0,R0              CLEAR ANSWER REG
         BALR  R14,R15            LINK OUT TO CONVERT MBBCCHHR TO TTR
         ST    R0,WKA1            TTRN TO CORE
         L     R13,SV4+CHAINBK
         RETURN (14,12)
         DROP  R10                                               X010XX
         DROP  R1
         EJECT
IEBMGD   EQU   *                  SUBRTNE TO LOCATE NEXT DE IN I/O BFR
IEBDSCGD EQU   IEBMGD
         ENTRY IEBDSCGD
         SAVE  (14,12)            SAVE CALLER'S REGS
         LR    R3,R15             ESTAB ADDRESSIBILITY
         USING IEBMGD,R3
         ST    R13,SV3+CHAINBK    STD LINKAGE
         LA    R12,SV3
         ST    R12,CHAINTHS(R13)
         LR    R13,R12
         TM    FLG5,DEFSW         IS SUBRTNE INITIALIZATION DONE
         BO    DVSC               IF SO, GO COMPARE ADDR OF THIS DE
         OI    FLG5,DEFSW         TURN ON INITIALIZATION SW.
* THIS SUBROUTINE TAKES ADVANTAGE OF ''KNOWING'' THAT IT IS GETTING
* DIR. ENTRIES FROM THE 'FIRST' BUFFER AREA POINTED TO BY THE BCB.
SDEPTR   MVC   DEPTR+P1(L3),BEGFST1 POINT TO 1ST BLOCK IN BUFFER
CKCT     EQU   *
         L     R5,DEPTR           ADDR OF DE
         TM    FLG2,RDEOF         WAS AN EOF READ YET
         BZ    SVKEY              IF NOT, DONT TEST FOR EOD YET
         CLC   C1DL(L2,R5),ZROS   DOES DATA LENGTH = 0 (EOF RECORD)
         BNE   SVKEY              GO SAVE KEY IF NOT
DE0      XC    DEPTR(L4),DEPTR    CLEAR PTR TO DE, INDICATING ALL DONE
DEX      EQU   *
         NI    FLG5,FF-DEFSW      TURN OFF INITIALIZATION SWITCH
         L     R13,CHAINBK(R13)   RESTORE ADDR OF CALLER'S SAVE AREA
         RETURN (14,12)           RETURN TO CALLER+0, INDIC NO DE FOUND
DVSC     L     R5,DEPTR           GET ADDR OF CURRENT DIR ENTRY
         CLC   X0(NAMLEN,R5),DBKEY IS THIS THE LAST DE IN THE BLOCK
         BE    BMP1               IF SO, FIND THE NEXT BLOCK
         SR    R6,R6
         IC    R6,C1DECT(R5)      GET COUNT BYTE OF CURRENT DE
         SLL   R6,LFT27           CLEAR HI ORDER 3 BITS
         SRL   R6,RT26            MPLY WHATS LEFT BY 2 = NBR USER BYTES
         LA    R6,C1FXL(R6)       ADD FIXED LENGTH (12) TO FIND NEXT DE
         A     R6,DEPTR           ADD THIS LENGTH TO ADDR OF CURR DE
CKFFS    EQU   *
         CLI   X0(R6),FF          IS THIS AN END-OF-DIRECTORY NAME
         BE    DE0                IF SO, GO TO ZERO DEPTR AND EXIT
         ST    R6,DEPTR           SET AS ADDR OF NEXT ENTRY IN BLOCK
         B     RTCAL              GO TO EXIT
SVKEY    MVC   DBKEY(LEN8),CON12(R5) SAVE THIS DIRECTORY BLOCK'S KEY
         ST    R5,BLKAD           BLKAD = DEPTR
         LA    R6,FDEOFF(R5)      POINT TO NAME OF 1ST DE IN BLOCK
         B     CKFFS              SEE IF ITS NAME IS 'FF'S
BMP1     L     R6,BLKAD           BUMP POINTER TO ADDR OF NEXT BLOCK
         TM    X0(R6),LASTREC+ENDPROC  IS THIS LAST BLOCK IN THE BUFFER
         BC    NOT0,RDMOR         IF SO, SEE IF CAN READ MORE INTO BFR
         LA    R6,KBLEN+CON12(R6) ADD TOTAL LENGTH
         ST    R6,BLKAD           SAVE ADDR
         ST    R6,DEPTR           SET AS ADDR OF NEXT DE
         B     CKCT               GO CHECK FOR COUNT OF ZERO (EOF REC)
RDMOR    TM    FLG5,OSW1          IS OUTPUT PRE-SCAN BEING DONE
         BO    DEX                IF SO, LEAVE 'DEPTR' AS IS, AND GO TO
*                                 LET CALLER ISSUE HIS OWN 'READ'.
         TM    FLG7,DM            IS DIRECTORY MERGE BEING DONE
         BO    DEX                YES - LET CALLER READ MORE OUTPUT DES
         MVC   READNEXT+P1(L3),BEGFST1 SET ADDR WHERE TO READ INTO
         TM    ULLDST,LOAD        ON LOAD                        X010XX
         BO    DSC00710           DONT USE IEBDRD                X010XX
         L     R15,VIEBDRD        ADDR OF READ SUBROUTINE
         B     DSC00720           USE EXCP READ                  X010XX
DSC00710 L     R15,VRSAM          USE LOADDCB                    X010XX
DSC00720 EQU   *                                                 X010XX
         BALR  R14,R15            LINK TO READ
         B     SDEPTR             GO SET POINTER TO 1ST REC IN BUFFER
RTCAL    L     R13,CHAINBK(R13)   RESTORE ADDR OF CALLER'S SAVE AREA
         LM    R14,R12,X12(R13)   RESTORE CALLERS REGS
         B     X4(R14)            EXIT TO CALLER'S RETURN POINT + 4,
*                                 INDICATING THAT A POINTER TO A D.E.
*                                 IS IN 'DEPTR'
         EJECT
         DS    0H
IEBMBT   EQU   *
*                  SUBROUTINE TO BUILD CTLTAB ENTRIES AND EITHER RE-
*              TAIN OR SPILL (TO SYSUT3) THE NEEDED INPUT DE'S
IEBDSCBT EQU   IEBMBT
         ENTRY IEBDSCBT
* THIS SUBROUTINE GETS CONTROL FROM MAINFLOW WHENEVER A CONTROL TABLE
* ENTRY IS TO BE ''BUILT''.  THIS SUBROUTINE WILL BUILD THE ENTRY, AND
* IF CORE IS AVAILABLE, SAVE THE DE IN CORE.  IF NOT ENOUGH SPACE RE-
* MAINS FOR THE CTLTAB, PREVIOUSLY RETAINED DE'S ARE SPILLED TO SYSUT3,
* AS WELL AS ANY AND ALL FURTHER NEEDED DE'S FROM THIS DATA SET.
* IF THERE ARE NO DE'S LEFT TO BE SPILLED, AND THERE IS NOT ENOUGH
* SPACE FOR THIS CTLTAB ENTRY, THEN AN ERROR MSG IS WRITTEN BY MAINFLOW
* (NOROOM). IF THE CTLTAB ENTRY IS SUCCESSFULLY BUILT, RETURN IS MADE
* TO CALLER VIA R14.
         SAVE  (14,12)            SET UP SVAREA LINKAGE
         LR    R10,R15
         USING IEBMBT,R10
         ST    R13,SV3+CHAINBK
         LA    R12,SV3
         ST    R12,CHAINTHS(R13)
         LR    R13,R12
*              INITIALIZE REGS
         L     R5,HICOR           ADDR OF HIGHEST UNUSED BYTE IN CORE
         L     R6,DEPTR           ADDR OF CURRENT DE
         L     R1,BUMP            ADDR OF NXT SLOT IN CTLTAB (OR SETAB)
         TM    FLG3,REBLK         WAS RE/DE-BLOCKING SPECIFIED
         BZ    TSPL               IF NOT, SEE IF ANY SPILL HAS OCCURRED
         TM    C1DECT(R6),USERMASK  ANY NOTE-LIST OR USER TTRN'S
         BC    NOT0,SETM46        IF SO, CANT ALSO BE RE/DE-BLOCKING
TSPL     EQU   *
         TM    FLG6,SPL           HAS ANY SPILL OCCURRED YET
         BO    C1TSPC             IF SO, GO TEST FOR CORE SPACE
         IC    R7,C1DECT(R6)      GET COUNT BYTE
         SLL   R7,LFT27           CLEAR HI ORDER 3 BITS
         SRL   R7,RT26            MPLY WHATS LEFT BY 2 = NBR USER BYTES
         LA    R7,C1FXL(R7)       ADD LENGTH OF FIXED PORTION OF DE
* R7 NOW CONTAINS LENGTH IN BYTES OF DIR ENTRY TO BE SAVED
         LR    R8,R7              SAVE LENGTH IN R8
         TM    COMDCDSW,SELECTSC  IS THIS A SELECTIVE COPY
         BO    C1TSTHI            IF SO, DONT ADD CTLTAB ENTRY LENGTH
         LA    R7,C1CTEL(R7)      ELSE ADD LENGTH OF ENTRY
         SR    R5,R7              CALC HICOR MINUS LENGTH
         C     R5,BUMP            IS RESULTING ADDR LESS THAN ADDR
*                                 WHERE CTLTAB ENTRY SHOULD GO
         BL    C1SETSP            IF SO, GO SET SPILL SW
         XC    X0(C1CTEL,R1),X0(R1) CLEAR NEXT 10 BYTES OF CTLTAB
*              R6 CONTAINS ADDR OF DE TO BE MOVED
*              R8 CONTAINS ACTUAL LENGTH OF DE
C1MVDE   L     R5,HICOR           GET ADDR OF HIGHEST UNUSED CORE
         SR    R5,R8              SUBTR LENGTH OF DE TO BE MOVED
         BCTR  R8,R0              DECREMENT LENGTH BY 1 FOR EXECUTE
         EX    R8,C1MOVE
         ST    R5,WKA1            SAVE ADDR WHERE MOVED TO
         ST    R5,HICOR
         LH    R8,CDCT            ADD 1 TO COUNT OF IN-CORE INPUT DE'S
         LPR   R8,R8              ASSURE POSITIVE SIGN
         LA    R8,X1(R8)
         STH   R8,CDCT
*              R1 CONTAINS ADDR OF NXT ENTRY IN CTLTAB
         MVC   X3(L3,R1),WKA1+P1  PUT 3-BYTE ADDR OF IN-CORE D.E. INTO
*                                 TABLE
         MVI   X2(R1),ZERO        INDICATE THAT THIS IS AN IN-CORE PTR
         ST    R1,ICPT            SAVE ADDR OF THIS CTLTAB ENTRY AS THE
*                                 MOST RECENT ONE REFERENCING AN IN-
*                                 CORE DIR ENTRY
C1MVTTR  MVC   X7(L3,R1),NAMLEN(R6) MOVE MBR TTR FROM DE TO CTLTAB
         MVI   X6(R1),ZERO        CLEAR INDICATOR BYTE
         TM    NAMLEN+P3(R6),ALIAS DOES THIS DE REFERENCE AN ALIAS
         BZ    INCFCT             IF NOT, GO UPDATE FCT
         MVI   X1(R1),ALIAS       ELSE INDICATE ALIAS IN CTLTAB ENTRY
INCFCT   EQU   *
         TM    X0(R1),SEBIT4      WAS 'DONT-COPY' SET WHILE THIS CTLTAB
*                                 ENTRY WAS BEING BUILT
         BO    ADDEL              IF SO, DONT INCREMENT FOUND-COUNT
         LH    R8,FCT             ADD 1 TO COUNT OF ''FOUND'' MBRS
         LPR   R8,R8              ASSURE POSITIVE SIGN
         LA    R8,X1(R8)
         STH   R8,FCT
         OI    X0(R1),SEBIT5      INDICATE 'FOUND' IN CTLTAB ENTRY
ADDEL    EQU   *
         LA    R1,C1CTEL(R1)      ADD ELEMENT LENGTH TO POINTER
         ST    R1,BUMP            UPDATE POINTER FOR NEXT TIME THRU
         TM    COMDCDSW,SELECTSC  IS THIS A SELECTIVE COPY
         BO    C1RETRN            IF SO, GO EXIT
         ST    R1,LOCOR           ELSE UPDATE ADDR OF LOWEST UNUSED COR
C1RETRN  L     R13,CHAINBK(R13)   RESTORE PTR TO CALLER'S SAVE AREA
         RETURN (14,12)           RESTORE REGS AND EXIT TO CALLER
C1TSTHI  SR    R5,R7              CALC HICOR MINUS LENGTH OF DE
         C     R5,LOCOR           WILL THIS DE FIT
         BNL   C1MVDE             IF SO, GO MOVE IT INTO CORE AREA
         OI    FLG6,SPL           ELSE INDIC NEED TO SPILL
         B     C1CVCC             GO SPILL THIS DIRECTORY ENTRY
C1TSPC   TM    COMDCDSW,SELECTSC  IS THIS A SELECTIVE COPY
         BO    C1CVCC             IF SO, GO TO SPILL THIS IDE
         B     C1GEL              ELSE SEE IF ENUF SPACE FOR CTLTAB ENT
C1SETSP  OI    FLG6,SPL           SET SPILL SWITCH
C1GEL    LA    R11,C1CTEL         GET LENGTH OF CTLTAB ENTRY
         L     R5,HICOR           GET ADDR OF HIGHEST UNUSED CORE
         SR    R5,R11             HICOR = HICOR - 10
         CR    R5,R1              IS THERE ENOUGH ROOM FOR NEXT
*                                 ENTRY IN CTLTAB
         BNL   C1ZR10             IF SO, GO WRITE THE DE TO SYSUT3
         LH    R11,CDCT           GET CT OF NBR OF IN-CORE INPUT DE'S
         LTR   R11,R11            ARE THERE ANY
         BZ    TSTMBUSE           IF NOT, GO SEE IF BFR CAN BE SQUEEZED
         L     R11,ICPT           GET ADDR OF CTLTAB ENTRY FOR MOST
*                                 RECENTLY SAVED-IN-CORE DE
         MVC   WKA1(L4),X2(R11)   PUT ADDR OF DE INTO WORK AREA
         L     R3,WKA1            ADDR OF DE INTO R3
         LA    R9,C1RET1          SET UP EXIT ADDR FOR USE WHEN PRE-
*                                 VIOUSLY SAVED DE IS SPILLED TO SYSUT3
         IC    R2,C1DECT(R3)      CALC LENGTH OF THIS DE IN R2
         SLL   R2,LFT27
         SRL   R2,RT26
         LA    R2,C1FXL(R2)       ADD LENGTH OF FIXED PORTION OF DE
         ST    R2,WKA1+P24        SAVE LENGTH OF DE BEING SPILLED
C1SETUT3 LA    R2,UT3DCB
         USING IHADCB,R2
         TM    DCBOFLGS,OPEN      WAS SYSUT3 OPENED YET
         BO    C1GOWS             IF SO, DONT TRY TO RE-OPEN IT
         DROP  R2
         L     R15,VIEBDV3        ADDR OF VALIDATION ROUTINE FOR SYSUT3
         BALR  R14,R15            GO TO OPEN AND CHECK OUT SYSUT3 -
*                                 ONLY RETURN IF OPENED OKAY AND VALID
C1GOWS   L     R12,ADWK           ADDR OF WORK AREA CONTAINING DE
         MVI   X0(R12),ENDPROC    INDIC THIS IS LAST REC IN ANY BUFFER
         MVI   C1KL(R12),ZERO     SET KEYLEN TO ZERO
         MVC   C1DL(L2,R12),C180  SET FIXED LENGTH OF 80 IN COUNT FIELD
*                                 OF RECORD TO BE SPILLED TO SYSUT3
         LA    R12,C1FXL(R12)     SAVE 12 BYTES FOR FLG, MBB, AND COUNT
         IC    R2,C1DECT(R3)      CALC LENGTH OF THIS DE IN R2 @ZA13739
         SLL   R2,LFT27           STRIP OUT LENGTH             @ZA13739
         SRL   R2,RT26            AND MULTIPLY BY TWO          @ZA13739
         LA    R2,C1FXL(R2)       ADD LEN FIXED PORTION OF DE  @ZA13739
         BCTR  R2,R0              DECREMENT BY 1 FOR EXECUTE   @ZA13739
         EX    R2,C1MOVE1         MOVE IDE TO BE SPILLED       @ZA13739
         L     R2,ADWK            GET ADDRESS OF BUFFER AREA
         LA    R2,X1(R2)          ADDR OF MBBCCHHR (IN UT3 BFR + 1)
         NI    TAG,TAG5+TAG6+CTOUT RESET ANY EXTRANEOUS BITS
         OI    TAG,TAG4           SET INDIC FOR SYSUT3 WRITING
         L     R15,VIEBVWS
         BALR  R14,R15            LINK TO PLUG IN CCHHR AND WRITE REC
         SPACE 2
* NOW NEED TO SET UP TO CALL SYSTEM ROUTINE TO CONVERT MBBCCHHR TO TTR
         LA    R1,UT3DCB
         L     R15,VCCOTT         GET ADDR OF LINKAGE TO CONVERT TTR
         BALR  R14,R15            GO TO CONVERT MBBCCHHR TO TTR
* ADDR OF CTLTAB ENTRY REFERENCING THE DE JUST SPILLED IS IN R11
         MVC   X3(L3,R11),WKA1    TTR INTO CTLTAB, OVERLAYING CORE ADDR
         MVI   X2(R11),ONE        SET OFFSET BYTE TO INDIC THIS IS TTR
         BR    R9                 GO TO CALLER OF C1SETUT3 OR TO NSI
C1RET1   LA    R9,C1CTEL          LENGTH OF CTLTAB ENTRY
         SR    R11,R9
         ST    R11,ICPT           SET ICPT TO ADDR OF PREVIOUS CTLTAB
*                                 ENTRY WH. REF. AN IN-CORE DE
         LH    R11,CDCT
         LPR   R11,R11            ASSURE POSITIVE SIGN
         BCTR  R11,R0             SUBTR 1 FROM COUNT OF IN-CORE IDE'S
         STH   R11,CDCT
         L     R5,WKA1+P24        GET LENGTH OF SPILLED DE
         A     R5,HICOR           ADD TO PREVIOUS ADDR OF HIGHEST UN-
*                                 UTILIZED CORE
         ST    R5,HICOR           HICOR = HICOR + LENGTH OF SPILLED DE
         L     R1,BUMP            RE-INITIALIZE REGS
         L     R6,DEPTR
         B     C1TSPC             GO TO TEST FOR SPACE FOR NXT CTLTAB
*                                 ENTRY
C1ZR10   XC    X0(C1CTEL,R1),X0(R1) CLEAR NEXT SLOT FOR CTLTAB ENTRY
C1CVCC   L     R3,DEPTR           NOW GET ADDR OF CURR DE TO BE SPILLED
         L     R11,BUMP           PT TO SETAB/CTLTAB SLOT BEING USED
         BAL   R9,C1SETUT3        GO WRITE TO SYSUT3 AND PUT ADDRESS,
*                                 IN TTR FORM, INTO SETAB/CTLTAB
         L     R1,BUMP            RE-INIT POINTER TO CTLTAB SLOT
         L     R6,DEPTR           RE-INIT POINTER TO DIRECTORY ENTRY
         B     C1MVTTR            GO SAVE MEMBER TTR AND EXIT
TSTMBUSE EQU   *
         TM    FLG2,MBUSED        IS MINIMUM BUFFER-SIZE NOW ALLOCATED
         BO    NOROOM1            IF SO, CANT SQUEEZE IT DOWN
         L     R11,END2ND2        GET ADDR OF HI END OF 2ND I/O BFR
         S     R11,BCB            CALC CURRENT LENGTH OF ENTIRE BFR
*                                 AREA
         S     R11,MINSIZ         SUBTR AMOUNT OF CORE WHICH WOULD BE
*                                 DE-ALLOCATED
         C     R11,MINSIZ         IS AT LEAST AN EQUAL AMOUNT OF CORE
*                                 STILL AVAILABLE AFTER DE-ALLOCATION
         BL    NOROOM1             NO - CANNOT DE-ALLOCATE I/O BUFFER
         BH    DEALLOC            IF HI, OKAY TO DEALLOCATE
         OI    FLG2,MBUSED        IF AMT LEFT = AMT TO BE DEALLOCATED,
*                                 INHIBIT FURTHER DEALLOCATION
DEALLOC  EQU   *
         L     R5,BCB             ADDR OF START OF IO BUFFER
         A     R5,MINSIZ          ADD MINIMUM BUFFER-LENGTH
         ST    R5,BCB             SET ADJUSTED ADDR AS START OF IO BFR
*                                 NO BCB FLGS WILL BE SET AT THIS POINT
*                                 SO DONT NEED TO WORRY ABOUT RESET-
*                                 TING THEM INADVERTENTLY.
         ST    R5,HICOR           SET NEW HI ADDR OF UNUSED CORE
         L     R5,ENDFST1         ADDR OF END OF 1ST BUFFER
         A     R5,MAXBLK          ADD LENGTH OF 1/2 OF MINIMUM TOTAL
*                                 BFR-LENGTH TO GET NEW ENDING ADDR
         ST    R5,ENDFST1         SET ADJUSTED POINTER INTO BCB
         LA    R5,X1(R5)          ADD 1 TO GET STARTING ADDR OF 2ND BFR
         ST    R5,BEGFST2         SET ADJUSTED POINTER INTO BCB
* I/O BUFFER HAS NOW BEEN 'SQUEEZED' BY SUBTRACTING THE MINIMUM SIZE
* WHICH COULD POSSIBLY BE ALLOCATED FROM THE ACTUAL SIZE ALLOCATED.
         NI    FLG2,FF-TRKS2      RESET 2-TRACKS-ALLOCATED SWITCH
         B     C1GEL              AND CONTINUE BUILDING CTLTAB
NOROOM1  MVI   MSG1+P1,M47        MSG CODE
         MVI   MSG1,LASTMSG       INDIC LAST MSG IN LIST
         OI    FLG7,SUPPRMSG      SUPPRESS MEMBERNAME PRINTING BY VTM
STOPBLDT EQU   *
         CLI   RCBUF,CH8          IS COMPLETION CODE 8 OR HIGHER A44144
         BNL   DONOTSET           YES- DON'T SET RETURN CODE     A44144
         MVI   RCBUF,CH8          SET COMPLETION CODE            A44144
DONOTSET EQU   *                                                 A44144
         MVI   VTMFLG1,UNUSEND    INDIC UNUSUAL END OF COPY OPERATION
         L     R15,VIEBVMS        ADDR OF MSG-WRITER ROUTINE
         BALR  R14,R15            EXIT TO ROUTINE
         L     R15,VIEBVTM        ADDR OF TERMINATION ROUTINE
         BR    R15                EXIT TO TERMINATE THIS COPY OPERATION
SETM46   MVI   MSG1+P1,M46        MSG CODE
         L     R1,DEPTR           POINT TO MBRNAME FOR ERROR MSG A44336
         MVI   MSG1,LASTMSG+PBIT  INDICATORS FOR IEBVMS
         MVI   PARAMS,NAME
         MVC   NAMEFLD(LEN8),X0(R1) EXTRACT MEMBERNAME FROM DIR ENTRY
         MVI   NAMEDISP,OFF141I   OFFSET FOR NAME IN MSG
         B     STOPBLDT           SET INDICATORS, WRT MSG, EXIT TO VTM
C1MOVE   MVC   X0(L1,R5),X0(R6)   EXECUTED TO MOVE IDE FROM I/O BFR
C1MOVE1  MVC   X0(L1,R12),X0(R3)  MOVE IDE TO BUFFER           @ZA13739
C180     DC    H'80'              LENGTH OF AN IDE TO BE SPILLED TO UT3
         EJECT
         DS    0H
IEBMGI   EQU   *
IEBDSCGI EQU   IEBMGI
         ENTRY IEBDSCGI
*                   SUBROUTINE TO LOCATE THE NEXT APPROPRIATE CTLTAB
*              ENTRY AND ACCESS THE ADDRESS OF THE PROPER INPUT DIR ENT
*              DEPENDING UPON THE PHASE OF PROCESSING.  IF THE IDE IS
*              ON SYSUT3, THIS ROUTINE CALLS IEBDRD TO READ IT INTO
*              CORE.  IF THE ATTEMPT TO READ FAILS (DUE TO AN I/O ERROR
*              ON SYSUT3), THE BIT NAMED 'MGINODE' IS SET IN 'SWITCH1'.
*              WHEN A POINTER TO THE IDE IS ACQUIRED, IT IS PASSED BACK
*              TO THE CALLER IN THE LOCATION NAMED 'IDEAD', IN THE COM-
*              MUNICATION AREA.  IF THE IDE BEING ACCESSED IS THE LAST
*              ONE WHICH CAN BE REQUESTED BY THE CALLER, THE BIT NAMED
*              'LE' IS SET IN 'FLG4'.
* REGISTER DEFINITIONS -
RG0      EQU   0
RG1      EQU   1
RG2      EQU   2
RG3      EQU   3
RG4      EQU   4                  ADDRESS OF COMMUNICATION AREA
RG5      EQU   5
RG6      EQU   6
RG7      EQU   7
RG8      EQU   8
RG9      EQU   9
RG10     EQU   10
RG11     EQU   11                 BASE REGISTER
RG12     EQU   12
RG13     EQU   13
RG14     EQU   14
RG15     EQU   15
         SAVE  (14,12)
         BALR  RG11,RG0            ESTABLISH ADDRESSABILITY
         USING *,RG11
         LA    RG12,SV2           LINKAGE CONVENTIONS
         ST    RG12,CHAINTHS(RG13) STD LINKAGE
         ST    RG13,CHAINBK(RG12)
         LR    RG13,RG12
         NI    SWITCH1,FF-ENTERNN RESET 'PUT IN NEWNAME'SWITCH   X010XX
         TM    SWITCH1,TIME1
         BO    LTABAD             DONT INITIALIZE AGAIN IF 'TIME1' ON
         MVC   GIFCT(L2),FCT      SET UP INTERNAL COUNT OF THE NUMBER
*                                 OF MEMBERS 'FOUND' ON THE CURRENT
*                                 INPUT DATA SET
         MVC   TABAD(L4),CTAD     INIT PTR TO CTLTAB
         MVC   NNTABAD(L4),ADNNPTRT INIT PTR TO NEWNAME POINTER TABLE
         OI    SWITCH1,TIME1
LTABAD   L     RG2,TABAD
TESTDC   TM    X0(RG2),SEBIT4     IS 'DONT-COPY' INDICATOR ON
         BZ    TESTF              IF NOT, CHECK FOR NEWNAME OR 'FOUND'
         TM    X0(RG2),SEBIT1     IS THIS A NEWNAME ENTRY
         BZ    GETNEXT            NO
         L     RG8,NNTABAD        SET POINTER TO NNPTRTAB FOR NEXT SLOT
         LA    RG8,X4(RG8)        BUMP POINTER
         ST    RG8,NNTABAD
GETNEXT  LA    RG2,TABLEN(RG2)    POINT TO NEXT CTLTAB ENTRY
         B     TESTDC             SEE IF 'DONT COPY' BIT IS SET
TESTF    TM    X0(RG2),SEBIT1     IS THIS A NEWNAME ENTRY
         BO    NEWENT             YES
         TM    X0(RG2),SEBIT5     WAS THIS MEMBER 'FOUND'
         BZ    GETNEXT            NO, GO LOOK FOR NEXT CTLTAB ENTRY
         TM    FLG7,COP           IS PGM NOW IN THE COPY PHASE
         BO    LEFTHALF           IF SO, WANT RENAMED ENTRY NOW, NOT
*                                 NEWNAME
RENAME   TM    X0(RG2),SEBIT2     WAS THIS MEMBER RENAMED
         BO    GETNEXT            ENTRY IS RENAMED AND IT IS NOT
*                                 THE COPY PHASE
         TM    FLG5,OSW1          IS OUTPUT DIR PRESCAN BEING DONE
         BO    LEFTHALF           IF PRESCAN ACCESS LEFT HALF OF
*                                 CTLTAB
RTHALF   SR    RG3,RG3            IF DIRECTORY MERGE ACCESS
*                                 RIGHT HALF OF CTLTAB
         IC    RG3,X6(RG2)        GET INDICATOR BYTE
         MVC   FULLWD+P1(L3),X7(RG2) PUT POINTER INFO INTO WK AREA
         L     RG5,FULLWD
         LTR   RG3,RG3            IF NON-ZERO, DE POINTED TO IS ON UT3
         BZ    STIDEAD            RETURN A PTR TO THE IDE IN CORE
         LR    RG0,RG5            IDE IS NOT IN CORE
         SLL   RG0,LFT8           SET UP 'TTR0' FOR CONVERSION
         B     NOTCORE            GO GET IDE INTO CORE FROM UT3
RETNAME  LA    RG5,X2(RG2)        IF DOING OUTPUT DIR PRE-SCAN, SET PTR
*                                 TO THE NEWNAME
         L     RG8,NNTABAD
         L     RG7,X0(RG8)        GET ADDR OF CTLTAB ENTRY WHICH WAS
*                                 RENAMED
         LA    RG8,X4(RG8)        BUMP POINTER
         ST    RG8,NNTABAD        UPDATE NNPTRT TO NEXT ENTRY
         TM    X0(RG7),SEBIT4     IS RENAMED ENTRY FLAGGED AS 'DONTCPY'
         BZ    TSTBFV             NO, GO SEE IF IT WAS FOUND
         OI    X0(RG2),SEBIT4     YES, SO SET 'DONTCOPY' IN NEWNAME ENT
         B     GETNEXT            GO LOOK FOR NEXT CTLTAB ENTRY
TSTBFV   TM    X0(RG7),SEBIT5     WAS THIS OLDNAME FOUND
         BZ    GETNEXT            NO, GO LOOK FOR NEXT CTLTAB ENTRY
         B     STIDEAD            YES, GO SET ADDRESS OF NEWNAME INTO
*                                 IDEAD AND RETURN TO CALLER
LEFTHALF SR    RG3,RG3
         IC    RG3,X2(RG2)        GET INDICATOR BYTE
         LTR   RG3,RG3
         BP    GISPTTR            IF NON-ZERO, IDE MUST BE ON SYSUT3
         MVC   IDEAD+P1(L3),X3(RG2) SET UP ADDR OF IDE
         B     ENDFND             SEE IF THIS IS LAST ENTRY TO BE TRIED
GISPTTR  EQU   *
         MVC   FULLWD1(L3),X3(RG2) PUT TTR OF SPILLED DE INTO WK AREA
         L     RG0,FULLWD1        PLACE TTR IN RG0 FOR CONVERSION
         B     NOTCORE            GO GET IDE INTO CORE FROM UT3
NEWENT   TM    FLG5,OSW1          IS OUTPUT DIRECTORY PRESCAN BEING
*                                 DONE NOW
         BO    RETNAME            IF SO, SET UP POINTER TO THE NEWNAME
         TM    FLG7,COP           IS THIS FOR USE DURING COPY PHASE
         BO    GETNEXT            IF COPY PHASE, DONT USE NEWNAME ENTRY
         L     RG6,NNTABAD        GET ADDR OF PTR TO RENAMED CTLTAB ENT
         L     RG7,X0(RG6)        GET ADDR OF RENAMED ENTRY ITSELF
         LA    RG6,X4(RG6)        POINT TO NXT NNPTRTAB SLOT
         ST    RG6,NNTABAD        SAVE UPDATED POINTER
         TM    X0(RG7),SEBIT4     IS THE CTLTAB ENTRY FOR THE ''OLD-
*                                 NAME'' FLAGGED AS 'DONTCOPY'
         BZ    NNRTHALF           NO
         OI    X0(RG2),SEBIT4     YES, SET 'DONTCOPY' IN NEWNAME ENTRY
         B     GETNEXT            LOOK FOR NEXT DESIRED CTLTAB ENTRY
NNRTHALF TM    X0(RG7),SEBIT5     WAS OLDNAME 'FOUND'
         BZ    GETNEXT            NOT YET- GO GET NEXT CTLTAB ENTRY
         SR    RG3,RG3            SET UP TO GET INDICATOR BYTE
         IC    RG3,X6(RG7)        INDICATOR BYTE FROM RENAMED CTLTAB
         MVC   FULLWD(L4),X6(RG7) POINTER INFO INTO WORK AREA
         L     RG5,FULLWD
         LR    RG0,RG5
         SLL   RG0,LFT8           SET UP 'TTR0' FOR CONVERSION
         OI    SWITCH1,ENTERNN    INDICATES THAT NEW NAME WILLL BE
*                                 PLUGGED INTO THE DIRECTORY ENTRY
         LTR   RG3,RG3            IS RENAMED DE IN CORE (INDIC NON-0)
         BP    NOTCORE            NO, GO READ IT FROM SYSUT3
         TM    SWITCH1,UNLDTM     IF CALLED BY DSU (NOT DSU1)    X010XX
         BO    STIDEAD            DONT PUT IN NEWNAME            X010XX
         MVC   X0(LEN8,RG5),X2(RG2) NEWNAME INTO IN-CORE INPUT DIREC-
*                                 TORY ENTRY, OVERLAYING OLDNAME
         B     STIDEAD            GO SET 'IDEAD' POINTER FOR CALLER
NOTCORE  LA    RG1,UT3DCB
         LR    RG10,RG2           SAVE POINTER TO CTLTAB ENTRY
         LA    RG2,FDAD(RG1)      PTR TO DCBFDAD
         L     RG15,VTTOCC
         BALR  RG14,RG15          GO CONVERT TTR TO MBBCCHHR
         TM    UT3CHAR+P1,RPS     IS UT3 ON AN RPS DEVICE        S20201
         BNO   NOTRPS             NO, GO AROUND SECTOR CODE      S20201
         SPACE 1                                                 S20201
*   IF SYSUT3 IS ON AN RPS DEVICE, MUST GO TO SECTOR CONVERT     S20201
* ROUTINE TO GET SECTOR VALUE                                    S20201
         SPACE 1                                                 S20201
         STM   RG0,RG15,SV4       SAVE ALL REGS                  S20201
         IC    RG3,UT3CHAR+P3     INSERT UCB UNIT TYPE CODE      S20201
         SLL   RG3,S24            SHIFT TO HIGH ORDER BYTE       S20201
         LA    RG2,UT3SCTOR       LOAD PTR TO SECTOR SLOT        S20201
         OR    RG2,RG3            OR IN UCB UNIT CODE            S20201
*   PARAMETER REGISTER 2 IS NOW SET UP FOR CONVERT ROUTINE       S20201
         LH    RG0,UT3LRECL       LOAD UT3 RECORD LENGTH         S20201
         SLL   RG0,S16            SHIFT RECORD SIZE TO HIGH      S20201
*                                   ORDER TWO BYTES              S20201
         IC    RG0,SV4+P2         INSERT RECORD NUMBER (TTR0     S20201
*                                   WAS IN REG0 BEFORE ABOVE     S20201
*                                   STM INSTRUCTION EXECUTED     S20201
         SPACE 1                                                 S20201
*   PARAMETER REGISTER 0 IS NOW SET UP FOR CONVERT ROUTINE       S20201
         SPACE 1                                                 S20201
         L     RG15,ADCVT         ADDR OF CVT                    S20201
         USING CVT,RG15                                          S20201
         L     RG15,CVT0SCR1      ADDR OF SECTOR CONVERT ROUTINE S20201
         DROP  RG15                                              S20201
         BALR  RG14,RG15          LINK TO CONVERT ROUTINE        S20201
         SPACE 1                                                 S20201
         LM    RG0,RG15,SV4       RESTORE REGISTERS              S20201
NOTRPS   EQU   *                                                 S20201
         MVC   XWKA1(LEN8),X0(RG2) SAVE MBBCCHHR FROM SYSUT3 DCB
         MVI   SENSE,SENSE1+SENSE3 TURN ON SENSE1 AND SENSE3
         L     RG15,VIEBDRD
         BALR  RG14,RG15          GO TO READ SPILLED IDE FROM SYSUT3
         TM    IOEF1,ERF8         DID AN I/O ERROR OCCUR WHILE READING
         BZ    NOIOER3            IF NOT, RESTORE UT3 MBBCCHHR
         OI    SWITCH1,MGINODE    ELSE SET 'NO IDE' BIT
         LR    RG2,RG10           RESTORE RG2                   YM06972
         B     RETPTR             GO TO RET TO CALLER WITH NO IDE
NOIOER3  EQU   *
         MVC   X0(LEN8,RG2),XWKA1 RESTORE MBBCCHHR TO SYSUT3 DCB
*                                 TO ALLOW TO BE WRITTEN BACK
*                                 FROM WHERE IT WAS READ DURING
*                                 COPY PHASE
         LR    RG2,RG10           RESTORE RG2
         TM    SWITCH1,ENTERNN
         BZ    RETPTR             IF NO NEED TO PUT NEWNAME INTO THIS
*                                 IDE, PREPARE TO SET UP 'IDEAD' NOW
         TM    SWITCH1,UNLDTM     IF CALLED BY DSU (NOT DSU1)    X010XX
         BO    RETPTR             DONT PUT IN NEWNAME            X010XX
         L     RG10,ADWK
         MVC   SPIDEOFF(NAMLEN,RG10),X2(RG2) PUT NEWNAME INTO UT3 IDE-
*                                 THIS IS DURING DIRECTORY MERGE PHASE.
RETPTR   L     RG5,ADWK
         LA    RG5,SPIDEOFF(RG5)  POINT TO 1ST BYTE OF SPILLED DE
STIDEAD  ST    RG5,IDEAD          SET POINTER TO IDE FOR CALLER USE
ENDFND   CLC   GIFCT(L2),ONE1     ANY MORE CTLTAB ENTRIES TO BE SEARCH-
*                                 ED AFTER THIS
         BE    LAST               IF NOT, INDICATE NO MORE TO BE SOUGHT
         LH    RG3,GIFCT
         BCT   RG3,RETURN         DECREMENT INTERNAL COUNT OF NBR OF
*                                 ENTRIES TO BE SOUGHT
LAST     OI    FLG4,LE            SET 'LAST-ENTRY-PROCESSED' INDICATOR
         NI    SWITCH1,FF-TIME1   RESET 1ST-TIME INTERNAL SWITCH
RETURN   LA    RG2,TABLEN(RG2)    BUMP CTLTAB POINTER
         ST    RG2,TABAD
         STH   RG3,GIFCT               SET DECREMENTED COUNT
         L     RG13,SV2+CHAINBK
         RETURN  (14,12)
         SPACE 2
XWKA1    DS    2F                 AREA TO SAVE SYSUT3 MBBCCHHR
FULLWD   DC    F'0'               WORK AREA
FULLWD1  DC    F'0'               AREA FOR USE IN TTR-MBBCCHHR CONVERT
GIFCT    DC    H'0'               INTERNAL CT OF NBR OF ENTRIES TO TRY
ONE1     DC    H'1'               COMPARAND VALUE
         EJECT
         DS    0H
IEBMKO   EQU   *
IEBDSCKO EQU   IEBMKO
         ENTRY IEBDSCKO
* INPUT TO ROUTINE -
*        ALO = ADDR WHERE TO BEGIN SAVING OUTPUT DIR BLKS (CALLER ONLY
*              INIT. ONCE PER INPUT DD, SUBRTNE UPDATES THEREAFTER)
*        NSP, ODIC AND OIC SWITCHES MUST ALL BE OFF (ZERO=OFF)
*        OBCT MUST BE INIT TO ZERO PRIOR TO 1ST CALL FOR CURR. INPUT DD
         SPACE 2
         SAVE  (14,12)            SAVE CALLER'S REGS
         BALR  R10,R0             ESTAB ADDRESSIBILITY
         USING *,R10
         ST    R13,SV3+CHAINBK    SAVE AREA LINKAGE
         LA    R12,SV3
         ST    R12,CHAINTHS(R13)
         LR    R13,R12
         TM    FLG5,NSP           IS NO-SPACE SWITCH ON
         BO    C3BK1              IF SO, DON'T SAVE ANY MORE
         L     R5,BCB
         LA    R5,X0(R5)          ADDR OF 1ST BLOCK IN BUFFER
C3GALO   L     R6,ALO             ADDR WHERE THIS BLOCK IS TO BE PUT
         LA    R7,KBLEN+CON12(R6) ADD LENGTH OF FMBB+CT+KEY+DIR BLOCK
         C     R7,HICOR           IS THIS ADDR G.T. HIGHEST AVAIL LOC.
         BH    C3CKOB             IF SO, GO SEE IF ANY BLOCKS SAVED
         MVC   X0(KL+CON12,R6),X0(R5) MOVE FMBB+COUNT+KEY TO CORE AREA
         MVC   KL+CON12(BL,R6),KL+CON12(R5) MOVE DIRECTORY BLK TO CORE
         LH    R8,OBCT            GET CT OF NBR BLKS SAVED IN CORE
         LPR   R8,R8
         LA    R8,X1(R8)          ADD 1 TO COUNT
         STH   R8,OBCT            SAVE UPDATED COUNT
         ST    R6,SVLSTO          SAVE ADDR OF LAST IN-CORE BLOCK
         ST    R7,ALO             SET ADDR OF LOWEST AVAIL CORE
         CLI   CON12(R5),FF       IS KEYNAME = TO 'FF' (LAST USEFUL BK)
         BNE   C1TEP              IF NO, SEE IF THIS IS LAST BLK IN BFR
         OI    FLG6,OIC           ELSE SET ALL-ODES-SAVED-IN-CORE SW.
C3BK1    L     R13,CHAINBK(R13)   RESTORE CALLER'S SAVE AREA ADDR
         RETURN (14,12)           RETURN TO CALLER
C1TEP    EQU   *
         TM    X0(R5),ENDPROC     IS THIS LAST REC IN BFR
         BO    C3SWOFF            YES,TURN LASTREC/ENDPROC OFF @ZA11929
         LA    R5,KBLEN+CON12(R5) POINT TO NEXT BLOCK IN BFR
         B     C3GALO             GET NXT LOC WHERE TO PUT NXT BLOCK
C3SWOFF  NI    X0(R6),FF-LASTREC-ENDPROC SW OFF IN SAVE BUFFER @ZA11929
         B     C3BK1              GO AND RETURN TO CALLER      @ZA11929
C3CKOB   OI    FLG5,NSP           INDIC NO MORE SPACE LEFT FOR OUT DIR
         SR    R8,R8              SET COMPARAND REG TO ZEROES
         CH    R8,OBCT            ARE THERE ANY OUT DIR BLKS SAVED
         BE    C3BK1              IF NOT, GO EXIT TO CALLER
         OI    FLG6,ODIC          INDICATE SOME-BUT-NOT-ALL BLKS SAVED
         MVC   OUTDAD1(LEN8),X1(R5) MBBCCHHR OF 1ST UN-RETAINED OD BLK
         B     C3BK1              GO TO EXIT TO CALLER
         DS    0F
PATCHL2  EQU   (*-IEBDSCP2)/20    5 PER-CENT PATCH AREA LENGTH
PATCH2   DC    XL(PATCHL2)'00'    PATCH AREA FOR THIS CSECT      A41780
         EJECT
         DS    0D
IEBDSMCA CSECT
IEBMCA   EQU   IEBDSMCA
         IEBMCA
         EJECT
         DCBD  DSORG=PO
FDAD     EQU   DCBFDAD-IHADCB     OFFSET TO DCBFDAD FIELD
         EJECT
CVT      DSECT
         CVT
TPCNVT   EQU   CVTPCNVT-CVTTCBP   DISPLACEMENT TO TTR-MBBCCHHR CONVERT
TPRLTV   EQU   CVTPRLTV-CVTTCBP   DISPLACEMENT TO MBBCCHHR-TTR CONVERT
         EJECT
IECDSECT DSECT
         IECDSECT
TAOFF    EQU   DXDAADDR-DXIOB     OFFSET FROM START OF IOB TO MBBCCHHR
         END
