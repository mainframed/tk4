*TITLE 'HEWLLIBR' - LIBRARY PROCESSOR                                 *
*STATUS-CHANGE LEVEL 20
*        INCREMENTAL 288 - W-CON - ADDED                        INC288
*        TSO CHANGES FOR IDENTIFY AND INCORE DATA SET                 *
*                                                               YM05556
*                                                               YM05562
*                                                               YM05575
* I063800,I112000                                               ZA01335
* C125200,C127400  PRINT UNPRINTABLE CHAR                      @Z12914*
*FUNCTION/OPERATION:                                                  *
*        1)HEWACALL-TRYS TO RESOLVE EXTERNAL REFERENCES IN THE CESD,  *
*              WHICH ARE STILL UNRESOLVED AT THE END OF THE PRIMARY   *
*              INPUT STREAM.  IT CALLS FROM PARTITIONED DATA SETS,    *
*              (OR OPTIONALLY FROM THE LINK PACK AREA)                *
*              MEMBERS WHOSE NAMES ARE EXTERNAL REFERENCES IN THE     *
*              CESD.  IT DETERMINES WHETHER THE CALLED MEMBERS ARE    *
*              OBJECT MODULES OR LOAD MODULES. THEN PASSES CONTROL    *
*              TO THE APPROPRIATE PROCESSOR.                          *
*                                                                     *
*        2)HEWLODE-DETERMINES RECORD TYPE,THEN PASSES CONTROL TO THE  *
*              APPROPRIATE ROUTINE FOR RECORD PROCESSING.             *
*                                                                     *
*        3)LMTXT-PROCESSES LOAD MODULE TEXT.                          *
*                                                                     *
*        4)COMMON-ASSIGNS ADDRESSES TO COMMON.                        *
*                                                                     *
*        5)PSEUDOR-ASSIGNS DISPLACEMENTS TO PSEUDO REGISTERS          *
*                                                                     *
*        6)FINISHUP-PRINTS FINISHING MESSAGES-UNRESOLVED ER'S,        *
*              TOTAL LENGTH,ENTRY ADDRESS. ASSIGNS ENTRY POINT        *
*                                                                     *
*        7)HEWERROR-FORMATS AND PRINTS ERROR MESSAGES. LOGS           *
*              ERROR IN BIT MAP.                                      *
*                                                                     *
*        8)HEWBTMAP-PRINTS THE DIAGNOSTIC MESSAGE DIRECTORY           *
*              FOR ERRORS LOGGED IN THE BIT MAP                       *
*                                                                     *
*ENTRY POINTS:                                                        *
*        1)HEWACALL-FOR AUTOMATIC LIBRARY CALL PROCESSING             *
*        2)HEWLODE-FOR LOAD MODULE PROCESSING                         *
*        3)HEWERROR-FOR PRINTING AND LOGGING ERROR MESSAGES           *
*        4)HEWBTMAP-FOR PRINTING DIAGNOSTIC MESSAGES FOR ERRORS       *
*              LOGGED IN BIT MAP                                      *
*                                                                     *
*INPUT:  ALL ROUTINES EXPECT                                          *
*              #13-ADDRESS OF SAVE AREA                               *
*              #14-RETURN ADDRESS                                     *
*              #15-ADDRESS OF THEIR ENTRY POINT                       *
*              #11-ADDRESS OF COMMUNICATION AREA                      *
*        IN ADDITION-IEWERROR EXPECTS                                 *
*              #0-ERROR CODE                                          *
*              #1-POINTER TO QUALIFYINY DATA(IF ANY)                  *
*EXTERNAL ROUTINES:                                                   *
*        HEWOPNLB-OPEN SYSLIB                                         *
*        HEWLRLD-PROCESSES RLD'S                                      *
*        HEWLREAD-READ CONTROL AND TEXT RECORDS                       *
*        HEWLESD-PROCESSES CESD                                       *
*        HEWLEND-PROCESSES END OF MODULE                              *
*        TRANSID-TRANSLATES ESDID TO TRANSLATION TABLE ENTRY ADDRESS  *
*        HEWLMAP-CREATES MAP PRINTOUT                                 *
*        HEWLPRNT-PRINTS MESSAGES                                     *
*        HEWLERTN-RELOCATES RLD'S                                     *
*        HEWPRIME-PRIMES BUFFERS                                      *
*        HEWLRELO-PROCESS OBJECT MODULES                              *
*        HEWLCNVT-CONVERTS BINARY QUANTITIES TO PRINTABLE HEX         *
*        HEWTERM -PRINTS DIAGNOSTICS ON SYSTERM                       *
*EXITS-NORMAL:TO CALLER       L    13,4(13)                           *
*                             SR   15,15                              *
*                             RETURN (14,12),T,RC=(15)                *
*                                                                     *
*     -ERROR: TO HEWERROR     LA    0,ERCODE                          *
*                             L    15,V(HEWERROR)                     *
*                             BALR 14,15                              *
*                                                                     *
*TABLES/WORKAREAS:REFER TO LOADER PLM FOR DETAILED DESCRIPTION        *
*        1)CESD                                                       *
*        2)TRANSLATION TABLE                                          *
*        3)BLDL LIST                                                  *
*        4)COMMUNICATIONS AREA (HEWLDCOM)                             *
*ATTRIBUTES:READ ONLY,REUSABLE,REENTRANT                              *
*NOTES: NONE                                                          *
*                                                                     *
***********************************************************************
         EJECT
HEWLLIBR CSECT
*C059500                                                         S21016
*C232200                                                         M4115
*                                                               YA00126
*                                                               YA00323
*                                                               YA00398
*I063900-063920,A112100-112140                                  ZA01335
*A049131    SEE FIX FOR OY07896                                 YA07896
HEWACALL EQU   *
         ENTRY HEWACALL
         ENTRY HEWLODE
CQFF     EQU   X'FF'
EMVT     EQU   X'10'                    MVT SYSTEM
EMFT     EQU   X'20'                    MFT SYSTEM
ECESD    EQU   X'20'                    CESD RECORD
ESYMSCAT EQU   X'D0'                    SYM, IDR, OR SCAT/TRANS  S21016
ETXT     EQU   X'01'                    TEXT RECORD
ERLD     EQU   X'02'                    RLD RECORD
ELAST    EQU   X'08'                    END OF MODULE
ELTXT    EQU   X'08'                    TXT REC LAST IN MODULE
ELENGTH  EQU   2                        DISPLACEMENT OF LENGTH
EIDLNG   EQU   4                        LENGTH OF ENTRY IN ID/LENGTH
ERLDFLG  EQU   X'0C'                    FLAG FOR RLD
ERLDADDR EQU   4                        FLAG-ADDRESS
EBLDLRC  EQU   X'08'                    RETURN CODE-BLDL ERROR
EBLDLTTR EQU   8                        TTR
EBLDLDIS EQU   4                        SIZE OF BLDL LIST DISCRIPTION
EADRLENT EQU   4                        ENTRY SIZE IN ADDRESS LIST
EBLDLR   EQU   10                       R
EBLDLSIZ EQU   20                       BYTES NEEDED FOR EACH BLDL
*                                       ENTRY
EBLDLENT EQU   16                       SIZE OF ENTRY
*                                       FIELD
ESDNAME  EQU   4                        NAME
ERTYPE   EQU   X'02'
ESDRELCH EQU   12                       PTR TO RELOCATION CHAIN
ESDCHADR EQU   0                        CHAIN ADDRESS TO NEXT ENTRY
ESDCMCHN EQU   16                       PTR TO CHAINED CM ENTRY
ESDTYPE  EQU   12                      TYPE
ESDLAA   EQU   12                      LINK EDIT ASSIGNED ADDRESS
ESDLNG   EQU   16                       LENGTH OF CONTROL SECTION
ESDRELOC EQU   16                       RELOCATION CONSTANT
ESDPRALN EQU   16                       ALIGNMENT VALUE
ETTR     EQU   X'10'                    TTR RECEIVED BIT IN DESD
EBLDLATT EQU   X'20'                    BLDL ATTEMPTED BIT IN CESD
EDELETE  EQU   X'80'                    DELETE BIT IN CESD
ZERO     EQU   0
ENCAL    EQU   X'08'                    NEVER CALL BIT IN CESD
WEAKCALL EQU   X'40'               W-CON BIT IN CESD             INC288
ECXDADR  EQU   4
PARM     EQU   1
WORKA    EQU   2
WORKB    EQU   3
CUM      EQU   4
ID       EQU   5
ADR      EQU   6
LNG      EQU   7
PTR      EQU   8
CESD     EQU   9
MAINT    EQU   10
CMPTR    EQU   11
BASE     EQU   12
SAVEREG  EQU   13
RETURN   EQU   14
BRANCH   EQU   15
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
TRMRECSZ EQU   81                  LENGTH OF SYSTERM RECORD
         USING *,15
         SAVE  (14,12),T,*              SAVE CALLERS REGISTERS
         LR    BASE,15                  PUT BASE ADDR IN BASE REG
         DROP  15
         USING HEWACALL,BASE       ESTABLISH BASE
         USING ERCODES,0
         L     SAVEREG,8(SAVEREG)       NEW SAVE AREA ADDRESS
         USING HEWLDCOM,CMPTR      COMMUNICATION AREA
         OI    CMLIBFLG,CQAUTOC         AUTOCALL IN PROCESS
         TM    CMPRMFLG,CQCALL          AUTOCALL
         BZ    COMMON                   NO-ASSIGN ADDR TO COMMON
         L     CESD,CMERCHN             GET PTR TO ER CHAIN
         LTR   CESD,CESD                ER CHAIN EMPTY
         BZ    COMMON                   YES-ASSIGN ADDR TO COMMON
         TM    CMPRMFLG,CQRES           LIBRARY RESIDENT IN LPA
         BZ    OPNLIB                   NO-OPEN SYSLIB
*
***********************************************************************
*
*              CHECK FOR VS1/VS2 SYSTEM
*
***********************************************************************
*
         LA    ADR,16                   GET ADDR OF PTR TO CVT
         L     PTR,0(ADR)               GET ADDR OF CVT
         USING CVTSECT,PTR
         TM    CVTDCB,CVT4MS1           VS2 SYSTEM
         BO    CDESRCH2                 YES - SKIP TEST FOR VS1
CDESRCH1 EQU   *
         MVC   CMSYSTYP(1),CVTDCB       SET CODE FOR VS1 SYSTEM
         OI    CMLIBFLG,CQMFTLPA        SET BIT FOR VS1 LPA
LPABIT1  OI    CMLIBFLG,CQLPASRH        TURN ON LPA SEARCH BIT
*
***********************************************************************
*
*              INITIALIZE FOR CDE SEARCH
*
***********************************************************************
*
LPALIB1  NI    CMRELFLG,CQFF-CQLIB      INDICATE LPA LIBRARY
         LA    WORKA,CMERCHN            GET ADDR OF PTR TO ER CHAIN
         ST    WORKA,CMPREVPT           SAVE AS PREVIOUS PTR
         LA    ADR,16                   GET ADDR OF PTR TO CVT
         L     PTR,0(ADR)               GET ADDR OF CVT
*
***********************************************************************
*
*              CONTENTS DIRECTORY ENTRY SEARCH FOR VS1
*
***********************************************************************
*
         USING CDENTRY,ADR
         L     ADR,CVTQLPAQ             GET ADDR OF TOP OF CONTENTS
*                                       DIRECTORY IN LPA QUEUE
         LTR   ADR,ADR                  QUEUE EMPTY
         BZ    OPNLIB                   YES-OPEN SYSLIB
GETNAME1 TM    ESDTYPE(CESD),ENCAL+WEAKCALL NVCALL OR W-CON      INC288
         BC    5,CDEER1            YES. GET NEXT ER              INC288
         LM    WORKA,WORKB,ESDNAME(CESD) GET NAME INTO TWO REGISTERS
CDECOMP1 C     WORKA,CDNAME             COMPARE FIRST HALF OF NAMES
         BE    CDECOMP2                 EQUAL-COMPARE SECOND HALF
NOCOMP   L     ADR,CDCHAIN              GET NEXT IN CHAIN
         LA    ADR,0(ADR)               CLEAR HIGH BYTE
         LTR   ADR,ADR                  END OF CHAIN
         BNE   CDECOMP1                 NO-COMPARE NAMES
CDEER1   ST    CESD,CMPREVPT            SAVE PREVIOUS POINTER
         L     CESD,ESDCHADR(CESD)      GET NEXT ER
CDEER11  LTR   CESD,CESD                ANY LEFT
         BZ    BLDLER                   NO-SEE IF ALL ARE RESOLVED
         L     ADR,CVTQLPAQ             GET ADDR OF FIRST CDE
         DROP  PTR
         B     GETNAME1
CDECOMP2 C     WORKB,CDNAME+4           COMPARE SECOND HALF OF NAME
         BNE   NOCOMP                   NOT EQUAL-CONTINUE SEARCH
         B     SDCHNG                   GO CHANGE ENTRY TO SD
*
***********************************************************************
*
CDESRCH2 EQU   *
         USING CVTSECT,PTR
         MVC   CMSYSTYP(1),CVTDCB       INDICATE SYSTEM IS VS2
         DROP  PTR
LPABIT2  OI    CMLIBFLG,CQLPASRH        TURN ON LPA SEARCH BIT
*
***********************************************************************
*
*              INITIALIZE FOR CDE SEARCH
*
***********************************************************************
*
LPALIB2  NI    CMRELFLG,CQFF-CQLIB      INDICATE LPA LIBRARY
         LA    WORKA,CMERCHN            GET ADDR OF PTR TO ER CHAIN
         ST    WORKA,CMPREVPT           SAVE AS PREVIOUS PTR
SETCVTPT LA    ADR,16                   GET ADDR OF PTR TO CVT  YM05556
         L     R3,0(ADR)                GET ADDR OF CVT         YM05254
         USING CVTSECT,R3                                       YM05254
*
***********************************************************************
*
*              CONTENTS DIRECTORY ENTRY SEARCH FOR VS2
*
***********************************************************************
*
GETNAME2 TM    ESDTYPE(CESD),ENCAL+WEAKCALL NVCALL OR W-CON      INC288
         BC    5,CDEER2                YES. GET NEXT ER          INC288
         LM    R0,R1,ESDNAME(CESD)     GET NAME INTO R0 AND R1
         STM   R2,R10,CMRSAVE          SAVE REGS (IEAVVMSR WILL
*                                      CHANGE SOME OF THOSE SAVED)
         L     BRANCH,CVTLPDSR         V(IEAVVMSR)
         BALR  RETURN,BRANCH
*   IEAVVMSR WILL RETURN TO R14 IF MATCH IS FOUND, R14 + 4 IF NO MATCH
         B     SDCHNG2                  MATCHING ER
         LM    R2,R10,CMRSAVE           RESTORE REGS
CDEER2   ST    CESD,CMPREVPT            SAVE PREVIOUS POINTER
         L     CESD,ESDCHADR(CESD)      GET NEXT ER
CDEER12  LTR   CESD,CESD                ANY LEFT
         BZ    BLDLER                   NO-SEE IF ALL ARE RESOLVED
         B     SETCVTPT                                         YM05556
*
***********************************************************************
*
*              CHANGE ENTRY TO SD
*
***********************************************************************
*
SDCHNG2  EQU   *                        FROM VS2 ROUTINE
         LM    R2,R10,CMRSAVE           RESTORE REGS
SDCHNG   EQU   *                        FROM VS1 ROUTINE
         L     PARM,ESDRELCH(CESD)      GET ADDR OF RLD CHAIN
         LA    PARM,0(PARM)             CLEAR TYPE FIELD
         TM    CMSYSTYP,CVT4MS1         VS2 SYSTEM?
         BO    ENTR2                    GET ENTRY POINT FOR VS2
         TM    CMLIBFLG,CQMFTLPA        MFT LPA
         BO    MFTENTRY                 YES-GET ENTRY POINT
         L     CUM,CDENTPT              GET ENTRY POINT ADDRESS
         B     CLEARFLG                 AROUND VS2 ENTRY POINT
ENTR2    EQU   *                        VS2 SYSTEM
         LR    CUM,R0                   GET ENTRY POINT ADDR
CLEARFLG EQU   *
         L     CUM,16(CUM)              ENTRY POINT             YA07896
         ST    CUM,ESDRELCH(CESD)       PUT IN CESD ENTRY
         L     WORKA,ESDCHADR(CESD)     GET PTR TO NEXT ER
         ST    WORKA,CMBLDLPT           SAVE IT
         L     WORKB,CMPREVPT           REMOVE MATCHED ER FROM CHAIN
         ST    WORKA,0(WORKB)
         L     WORKB,CMSDCHN            PUT ON SD CHAIN
         ST    WORKB,0(CESD)
         ST    CESD,CMSDCHN
         L     BRANCH,MAPRTN            GET ADDR OF MAP ROUTINE
         BALR  RETURN,BRANCH            MAP ENTRY
         L     BRANCH,RLDRES            RELOCATE RLD'S
         BALR  RETURN,BRANCH
         L     CESD,CMBLDLPT            GET NEXT ER
         TM    CMSYSTYP,CVT4MS1         VS2 SYSTEM?
         BO    CDEER12                  LOOK FOR MATCH IN VS2
         B     CDEER11                  LOOK FOR MATCH IN VS1
MFTENTRY L     CUM,CDENTPT+4            GET ADDR OF ENTRY POINT
         B     CLEARFLG                 MAKE INTO SD ENTRY
BLDLER   L     CESD,CMERCHN             GET ADDR OF FIRST ER
         LTR   CESD,CESD                ANY ER'S
         BZ    COMMON                   NO-ASSIGN ADDR TO COMMON
         DROP  ADR
*
***********************************************************************
*
*              OPEN SYSLIB
*
***********************************************************************
*
OPNLIB   TM    CMSTATUS,CQLIBOPN       IS SYSLIB OPEN?
         BO    MOREER                  YES
         L     BRANCH,OPNSYSLI         NO, GET ADDR OF OPEN RTN
         BALR  RETURN,BRANCH            OPEN SYSLIB
         TM    CMSTATUS,CQLIBOPN        SYSLIB OPEN
         BZ    COMMON                   NO-ASSIGN ADDRESSES TO COMMON
*
***********************************************************************
*
*              INITIAL BLDL LIST-GET START ADDRESS AND MAXIMUM
*              NUMBER OF ENTRIES
*
***********************************************************************
*
MOREER   OI    CMRELFLG,CQLIB           INDICATE SYSLIB
         L     LNG,CMLOWTBL             GET LOW TABLE ADDRESS
         L     PTR,CMNXTTXT             GET HIGH TEXT ADDRESS
         ST    PTR,CMBLDLPT             USE AS ADDR OF BLDL LIST
         LA    WORKA,EBLDLENT           FOR INITIALIZING BLDL LIST
         ST    WORKA,0(PTR)             INITIALIZE FIRST 2 HALF WORDS
*                                       IN BLDL LIST TO 0 AND 26
         LA    PTR,EBLDLDIS(PTR)
         SR    LNG,PTR                  GET LENGTH OF BLDL LIST
         SR    ADR,ADR                  CLEAR EVEN REG FOR DIVIDE
         LA    WORKA,EBLDLSIZ           BLDL ENTRY SIZE PLUS BLDL LIST
         DR    ADR,WORKA                DIVIDE SIZE OF BLDL LIST AREA
*                                       BY 20 TO GET NUMBER OF ENTRIES
         LR    ADR,PTR                  FOR ADDR OF LAST USED POSITION
*                                       IN BLDL LIST
         LR    WORKB,PTR
         LR    ID,PTR
         LA    WORKA,EBLDLENT           SIZE OF EACH ENTRY
         SR    CUM,CUM                  CLEAR-NUM OF ENTRIES
         L     CESD,CMERCHN
*
***********************************************************************
*
*              SET UP BLDL LIST
*
***********************************************************************
*
ENDCH    LTR   CESD,CESD                END OF ER CHAIN
         BE    ANYENT                   YES-SEE IF ANY ENTRIES IN BLDL
         TM    ESDTYPE(CESD),EBLDLATT   HAS BLDL BEEN ATTEMPTED
         BZ    MNCAL                    NO-SEE IF MARKED NCAL
NXTER    L     CESD,ESDCHADR(CESD)      GET PTR TO NEXT ER
         B     ENDCH                    SEE IF END OF CHAIN
MNCAL    TM    ESDTYPE(CESD),ENCAL+WEAKCALL  NVCALL OR W-CON     INC288
         BC    5,NXTER             YES. GET NEXT ER              INC288
         TM    ESDRELOC(CESD),X'80'    SPECIAL DELETE BIT ON?   ZA01335
         BO    NXTER                   YES, DON'T RESOLVE       ZA01335
         OI    ESDTYPE(CESD),EBLDLATT   TURN ON BLDL ATTEMPTED BIT
         LTR   CUM,CUM                  FIRST ENTRY
         BNZ   LASTENTR
         LTR   LNG,LNG                  MAXIMUM NUM ENTRIES ZERO
         BNZ   ENTER1                   NO-MOVE NAME INTO BLDL LIST
*
***********************************************************************
*
*              PRINT ERROR MESSAGE-PROGRAM TOO LARGE
*
***********************************************************************
*
TOOBIG   LA    ZERO,ERSIZE2             GET ERROR CODE FOR BIT MAP
         L     BRANCH,LOGRTN            GET ADDR OF ERROR LOG RTN
         BR    BRANCH                   LOG ERROR MESSAGE
*
***********************************************************************
*
*              PUT NAMES IN ALPHABETICAL ORDER
*
***********************************************************************
*
ANYENT   LTR   CUM,CUM                  ANY ENTRIES IN BLDL LIST
         BZ    COMMON                   NO-ASSIGN ADDR TO COMMON
         B     MOVEADR
LASTENTR LA    ID,EBLDLENT(ID)
COMPNAME CLC   ESDNAME(8,CESD),0(PTR)   COMPARE THIS NAME TO PREVIOUS
*                                       NAME IN LIST
         BNL   ENTER                    LOW OR EQUAL MOVE NAME TO LIST
         LA    ADR,EBLDLENT(PTR)        GET ADDR OF NEXT POSITION
*                                       IN BLDL LIST
         MVC   0(12,ADR),0(PTR)         MOVE PREVIOUS NAME DOWN ONE
*                                       POSITION
         CR    PTR,WORKB                PTR AT FIRST ENTRY
         BE    ENTER1
         SR    PTR,WORKA                SET PTR BACK ONE ENTRY
         B     COMPNAME
ENTER    LA    PTR,EBLDLENT(PTR)        GET ADDR OF NEXT POSITION
ENTER1   MVC   0(8,PTR),ESDNAME(CESD)   MOVE NAME INTO BLDL LIST
         ST    CESD,8(PTR)              PUT ADDR OF CESD ENTRY NEXT
*                                       TO NAME
         LA    CUM,1(CUM)               UPDATE NUMBER OF ENTRIES
         LR    PTR,ID
         CR    CUM,LNG                  NUMBER OF ENTRIES EQUAL MAX
         BNE   NXTER                    NO-GET NEXT ER
*
***********************************************************************
*
*              PUT ADDRESSES OF CESD ENTRIES IN ADDRESS LIST
*
***********************************************************************
*
MOVEADR  LR    ADR,WORKB                ADDR OF FIRST BLDL ENTRY
         LA    PTR,EBLDLENT(ID)         ADDR OF FIRST ADR LIST ENTRY
         LR    WORKA,PTR                SAVE ADDRESS
         L     WORKB,CMBLDLPT           GET ADDR OF BLDL LIST
         STH   CUM,0(WORKB)             PUT IN NUMBER OF ENTRIES
         LR    LNG,CUM                  NUMBER OF ENTRIES IN LIST
         LR    ID,ADR                   SAVE FIRST ENTRY ADDRESS
ADRLIST  MVC   0(4,PTR),8(ADR)          MOVE CESD ADDR FROM BLDL LIST
         LA    ADR,EBLDLENT(ADR)        GET ADDR OF NEXT ENTRY
         LA    PTR,EADRLENT(PTR)
         BCT   LNG,ADRLIST              BRANCH UNTIL NO MORE ENTRIES
*
***********************************************************************
*
*              ISSUE BLDL MACRO
*
***********************************************************************
*
DOBLDL   L     PARM,CMRDCBPT            GET ADDR OF SYSLIB DCB
         L     ZERO,CMBLDLPT            GET ADDR OF BLDL LIST
         BLDL  (1),(0)
         LA    WORKB,EBLDLRC            GET RETURN CODE FOR BLDL ERR
         CR    BRANCH,WORKB             BLDL ERROR?
         BNE   MOVETTR                  NO-CONTINUE
         LA    ZERO,ERIOUT4             GET ERROR CODE FOR BLDL ERROR
         L     BRANCH,LOGRTN            GET ADDR OF ERROR LOG RTN
         BALR  RETURN,BRANCH            LOG ERROR
         B     COMMON                   ASSIGN ADDR TO COMMON
*
***********************************************************************
*
*              PUT TTR'S IN CESD ENTRIES
*
***********************************************************************
*
MOVETTR  LR    PTR,WORKA                GET ADDR OF FIRST ENTRY IN
*                                       ADDRESS LIST
         LR    ADR,ID                   GET ADDR FIRST BLDL ENTRY
HAVETTR  CLI   EBLDLR(ADR),X'00'        THIS ENTRY NOT FOUND-R=0
         BE    NXTENT                   YES-GET NEXT ENTRY
         L     WORKB,0(PTR)             GET ADDR OF CESD ENTRY
         MVC   ESDRELOC(4,WORKB),EBLDLTTR(ADR) MOVE TTR TO CESD
         OI    ESDTYPE(WORKB),ETTR      MARK CESD ENTRY TTR
NXTENT   LA    ADR,EBLDLENT(ADR)        INCREMENT BLDL LIST POINTER
         LA    PTR,EADRLENT(PTR)        INCREMENT ADDRESS LIST POINTER
         BCT   CUM,HAVETTR              PROCESS ALL ENTRIES
         L     CESD,CMERCHN             PICK UP ER CHAIN PTR
NEXT     LTR   CESD,CESD                END OF CHAIN
         BZ    TESTLIB                  YES-ANY MORE ER'S
         TM    ESDTYPE(CESD),ETTR       THIS ENTRY HAVE TTR
         BO    DOFIND                   YES-ISSUE FIND MACRO
NEXT1    L     CESD,ESDCHADR(CESD)      PICK UP PTR TO NEXT ER
         B     NEXT
*
***********************************************************************
*
*              ISSUE FIND MACRO
*
***********************************************************************
*
DOFIND   NI    ESDTYPE(CESD),CQFF-ETTR  TURN OFF TTR RECEIVED BIT
         LA    WORKA,ESDRELOC(CESD)     GET ADDR OF TTR FOR FIND
         L     ADR,CMRDCBPT             GET ADDR OF SYSLIB DCB
         FIND  (ADR),(WORKA),C
         LA    R0,72
         LR    R1,R13
         SR    R1,R0              GET NEXT SAVE AREA IN CHAIN
         ST    R1,8(R13)          RESET FORWARD PTR
         NI    CMIOFLGS,CQFF-CQEOCB-CQEOFB-CQEOFSB-CQIGNCR
*                                       INITIALIZE EOF BITS
         TM    CMIOFLGS,CQRECFM         LOAD MODULE-CHECK RECFM IN DCB
         BZ    OBJECT                   NO-PRIME OBJ MOD BUFFERS
         L     BRANCH,LOADRTN           GET ADDR OF LOAD MOD PROC
         BALR  RETURN,BRANCH            PROCESS LOAD MODULE
TESTCC   L     CESD,CMERCHN
         B     NEXT
OBJECT   L     BRANCH,PRIMRTN           GET ADDR OF PRIME ROUTINE
         BALR  RETURN,BRANCH            GO PRIME OBJ MOD BUFFERS
         L     BRANCH,RELORTN           GET ADDR OF OBJ MOD PROCESSOR
         BALR  RETURN,BRANCH            GO PROCESS OBJ MODULE
         B     TESTCC
*
***********************************************************************
*
*              CHECK FOR MORE ER'S AND WHICH LIBRARY TO SEARCH
*
***********************************************************************
*
TESTLIB  L     CESD,CMERCHN             GET ADDR OF FIRST ER
         LTR   CESD,CESD                CHAIN EMPTY
         BZ    COMMON                   YES-ASSIGN ADDR TO COMMON
         TM    CMLIBFLG,CQLPASRH        RESIDENT LIBRARY
         BO    SRCLPA                   YES-SEARCH LPA AREA
         B     MOREER                   NO-ISSUE BLDL
SRCLPA   EQU   *
         TM    CMSYSTYP,CVT4MS1         VS2 SYSTEM?
         BO    LPALIB2                  SEARCH VS2 LPA
         B     LPALIB1                  SEARCH VS1 LPA
***********************************************************************
*
*              ASSIGN ADDRESSES TO COMMON
*
***********************************************************************
*
COMMON   NI    CMLIBFLG,CQFF-CQAUTOC    TURN OFF AUTOCALL BIT
         L     CESD,CMCMCHN             PICK UP PTR TO COMMON CHAIN
         MVC   CMTOPCOD(4),CMNXTTXT  SAVE TOP OF CODE WHICH CAN'T BE
*                                    OVERLAID.
COMMON1  LTR   CESD,CESD                END OF CHAIN
         BZ    PSEUDOR                  YES-ASSIGN DISPLACEMENTS TO PR
         L     PARM,ESDRELCH(CESD)      GET ADDR OF ER CHAIN FOR  RELOC
         LA    PARM,0(PARM)             CLEAR TYPE FIELD
         IC    WORKB,ESDTYPE(CESD)      SAVE TYPE FIELD
         L     PTR,ESDCMCHN(CESD)       PICK UP PTR TO CHAINED CM ENTRY
         L     ADR,CMNXTTXT             GET NEXT TXT ADDRESS
         OI    CMFLAG4,CQCOMMON        SHOW COMMON RECEIVED
         LA    ADR,7(ADR)               ROUND IT TO DOUBLEWORD BOUNDARY
*                                       ADD SEVEN
         ST    ADR,ESDRELCH(CESD)       PLACE IN ESD ENTRY
         NI    ESDRELCH+3(CESD),X'F8'   AND OFF 3 LOW ORDER BITS
         L     ADR,ESDRELCH(CESD)       GET ROUNDED OFF ADDRESS
         ST    ADR,ESDCMCHN(CESD)
         STC   WORKB,ESDTYPE(CESD)      RESTORE TYPE
         L     WORKA,ESDLNG(PTR)        GET LENGTH OF COMMON
         LA    WORKA,0(WORKA)
         AR    ADR,WORKA                ADD LENGTH OF COMMON TO ADDR
         C     ADR,CMHITBL              LESS THAN HIGH TABLE
         BNL   TOOBIG                   NOT LOW-TERMINATE
         ST    ADR,CMNXTTXT             UPDATE NEXT TXT ADDR
         L     BRANCH,MAPRTN            GET ADDR OF MAP ROUTINE
         BALR  RETURN,BRANCH            MAP ENTRY
         L     BRANCH,RLDRES            GET ADDR OF RLD RESOLUTION RTN
         BALR  RETURN,BRANCH            RESOLVE RLD'S
         L     CESD,ESDCHADR(CESD)      PICK UP NEXT PTR IN CHAIN
         B     COMMON1
*
***********************************************************************
*
*              ASSIGN DISPLACEMENTS TO PSEUDO REGISTERS
*
***********************************************************************
*
PSEUDOR  SR    CUM,CUM                  ZERO LOCATION CTR FOR PR'S
         LH    WORKB,CMWTBFCT          PICK UP COUNT IN BUFFER
         LTR   WORKB,WORKB             IS COUNT ZERO
         BZ    PSEUDOR1                YES-DON'T CLEAR BUFFER
         L     BRANCH,PRTRTN            GET ADDR OF IEWLPRNT
         BALR  RETURN,BRANCH            PURGE RRINT BUFFER
PSEUDOR1 L     CESD,CMPRCHN             PICK UP ADDR OF PR CHAIN
         LTR   CESD,CESD                END OF CHAIN
         BZ    FINISHUP                 SKIP THIS ROUTINE
         MVI   CMPRTCTL,CTSPACE2        SET UP CARRIAGE CONTROL
PRC2     SR    WORKA,WORKA              CLEAR REGISTER
         SR    LNG,LNG
         BCTR  WORKA,0                  SET TO ALL FF'S
         IC    LNG,ESDPRALN(CESD)       PICK UP ALIGNMENT FACTOR
         SR    WORKA,LNG                SUBTRACT ALIGN FACTOR FROM FF'S
         AR    CUM,LNG                  ADD ALIGNMENT FACTOR TO PR
*                                       LOCATION COUNTER
         NR    CUM,WORKA                AND SUM WITH F'S-ALIGNMENT
*                                       VALUE EQUAL ASSIGNED ADDRESS
         IC    WORKB,ESDTYPE(CESD)      SAVE TYPE FIELD
         L     PARM,ESDTYPE(CESD)       GET ADDR OF RLD'S FOR RELOC
         LA    PARM,0(PARM)             CLEAR HIGH BYTE
         ST    CUM,ESDTYPE(CESD)        PUT ASSIGN ADDR IN CESD
         STC   WORKB,ESDTYPE(CESD)      RESTORE TYPE
         L     WORKA,ESDLNG(CESD)       GET LENGTH OF PR
         LA    WORKA,0(WORKA)           CLEAR HIGH BYTE
         AR    CUM,WORKA                ADD LENGTH TO PR LOCATION CTR
         L     BRANCH,MAPRTN            GET ADDR OF MAP ROUTINE
         BALR  RETURN,BRANCH            MAP CESD ENTRY
         L     BRANCH,RLDRES            GET ADDR OF RLD RESOLUTION RTN
         BALR  RETURN,BRANCH
         L     CESD,ESDCHADR(CESD)      GET PTR TO NEXT PR
         LTR   CESD,CESD                END OF CHAIN
         BNZ   PRC2
PRA4     L     BRANCH,PRTRTN            GET ADDR OF IEWLPRNT(PRINT RTN)
         BALR  RETURN,BRANCH            FLUSH LAST MAP LINE
PRA5     MVI   CMPRTCTL,CTSPACE2        SET UP CARRIAGE CONTROL
         L     ADR,CMCXDPT              GET ADDR OF LOCATION REQUESTING
*                                       CUMULATIVE LENGTH
NEXTCXD1 LTR   ADR,ADR                 ZERO IF NCAL SPECIFIED
         BZ    FINISHUP                 SKIP FILLING IN LENGTH FOR CXD
NEXTCXD  L     WORKA,ECXDADR(ADR)       GET ADDR OF LOCATION REQUESTING
         ST    CUM,0(WORKA)             PUT TOTAL LENGTH AT THAT LOC
         L     ADR,0(ADR)               GET ADDR OF NEXT LOC
         B     NEXTCXD1                CHECK FOR NEXT CXD
*
***********************************************************************
*
*              ISSUE UNRESOLVED ER MESSAGES
*
***********************************************************************
*
FINISHUP L     CESD,CMERCHN             GET ADDR OF ER CHAIN
DEB2     LTR   CESD,CESD                END OF CHAIN
         BZ    NOTXT
         TM    ESDRELOC(CESD),X'80'    SPECIAL DELETE BIT ON?   ZA01335
         BO    DEF2                    YES, NO MESSAGE          ZA01335
         TM    CMPRMFLG,CQCALL          AUTOCALL SPECIFIED
         BZ    DED2                     NO-ISSUE WARNING MESSAGES
         TM    ESDTYPE(CESD),ENCAL      MARKED NEVER CALL
         BO    DED2                     YES-WARNING MESSAGE
         TM    ESDTYPE(CESD),WEAKCALL  IS IT MARKED W-CON        INC288
         BO    DEF2                YES. GET NEXT ER              INC288
         LA    ZERO,ERRELO2             GET ERROR CODE FOR ERROR MSG
         B     DEE2
NOTXT    TM    CMLIBFLG,CQNOTXT         SEE IF ANY TXT RECEIVED
         BO    DEA4                     YES-FIND ENTRY PT
         LA    ZERO,ERINPT3             GET ERROR CODE FOR NO TEXT
         L     BRANCH,LOGRTN            GET ADDR OF ERROR LOG RTN
         BALR  RETURN,BRANCH            LOG ERROR MESSAGE
         B     BADCC                    QUIT
DED2     LA    ZERO,ERRELO1             GET ERROR CODE FOR WARNING MSG
DEE2     LA    PARM,ESDNAME(CESD)
         L     BRANCH,LOGRTN            GET ADDR OF LOG ROUTINE
         BALR  RETURN,BRANCH            LOG ERROR MESSAGE
DEF2     L     CESD,ESDCHADR(CESD)      GET ADDR OF NEXT ER IN CHAIN
         B     DEB2
*
***********************************************************************
*
*              FIND ENTRY POINT ADDRESS
*
***********************************************************************
*
DEA4     TM    CMPRMFLG,CQEPNAME+CQEPADDR ENTRY POINT NAME AND ADDRESS
*                                         RECEIVED
         BO    DEB3                     YES-ENTRY ADDR ALREADY SET
         BZ    USETXT                   NEITHER-USE FIRST TXT ADDR
         TM    CMPRMFLG,CQEPNAME        ENTRY POINT NAME RECEIVED
         BO    USETXT1                  YES-USE FIRST TXT
         L     CESD,CMEPCESD            GET ADDR OF EP CESD
         TM    ESDTYPE(CESD),ERTYPE     EP AN ER?
         BO    USETXT2
         B     DEB3
USETXT   LA    ZERO,ERENTR1             ERROR CODE FOR NEITHER EP NAME
*                                       OR EP ADDR RECEIVED
         B     ERRO
USETXT1  LA    ZERO,ERENTR2             ERROR CODE FOR EP NAME NOT
*                                       FOUND
         LA    PARM,CMEPNAME           PRINT NAME RECEIVED
ERRO     L     BRANCH,LOGRTN
         BALR  RETURN,BRANCH
USETXT2  LH    WORKA,CMNUMXS       GET NUMBER OF EXTENTS
         LTR   WORKA,WORKA         ANY PRELOADED TEXT
         BNZ   DEB3                YES. LEAVE EP  ADDR
         MVC   CMEPADDR(4),CMBEGADR  UES FIRST TEXT AS EP.
DEB3     L     PARM,CMNXTTXT            GET ADDR OF NXT FREE TXT
         S     PARM,CMBEGADR            SUBTRACT ADDR OF BEGINNING OF
*                                       TXT FROM ADDR OF END OF TXT
         L     WORKA,CMXLCHN       GET EXTENT CHAIN
LEN1     LTR   WORKA,WORKA         ANY PRE-LOADED TEXT
         BZ    LEN2                NO. BRANCH
         A     PARM,8(WORKA)       YES. ADD LENGTH OF EXTENT
         L     WORKA,0(WORKA)      GET NEXT EXTENT IN CHAIN
         B     LEN1                LOOP BACK
LEN2     EQU   *
         ST    BASE,CMBLDLPT            SAVE BASE REGISTER
         L     BRANCH,CNVTRTN           GET ADDR OF CONVERT ROUTINE
         BALR  RETURN,BRANCH            CONVERT LENGTH TO PRINTABLE HEX
         L     BASE,CMBLDLPT            RESTORE BASE REGISTER
         L     ADR,CMPUTREC             GET ADDR OF PRINT BUFFER
         MVC   3(MSG2LNG,ADR),MSG2      TOTAL LENGTH
         MVC   6+MSG2LNG(6,ADR),CMXDBLWD+1  MOVE IN LENGTH      @Z12914
         MVI   CMPRTCTL,CTSPACE2        SET UP CARRIAGE CONTROL
         L     BRANCH,PRTRTN            GET ADDR OF PRINT ROUTINE
         BALR  RETURN,BRANCH
         L     PARM,CMEPADDR            GET ENTRY POINT ADDR
         ST    BASE,CMBLDLPT            SAVE BASE REGISTER
         L     BRANCH,CNVTRTN
         BALR  RETURN,BRANCH
         L     BASE,CMBLDLPT            RESTORE BASE REGISTER
         L     ADR,CMPUTREC             GET ADDR OF PRINT BUFFER
         MVC   3(MSG3LNG,ADR),MSG3      ENTRY ADDRESS
         MVC   5+MSG3LNG(6,ADR),CMXDBLWD+1  MOVE IN ADDR        @Z12914
         L     BRANCH,PRTRTN
         BALR  RETURN,BRANCH
         B     BADCC1
         DROP  BASE
         EJECT
*
***********************************************************************
*
*              LOAD MODULE PROCESSOR
*
***********************************************************************
*
         USING *,BRANCH
HEWLODE  SAVE  (14,12),T,*        SAVE CALLERS REGISTERS
         L     BASE,AUTOCALL
         DROP  15
         USING HEWACALL,BASE
         L     SAVEREG,8(SAVEREG)       NEW SAVE AREA ADDRESS
         NI    CMLIBFLG,CQFF-CQFIRST    INITIALIZE FLAGE
*
***********************************************************************
*
*              READ CONTROL RECORD
*
***********************************************************************
*
RDCNTRL  SR    ZERO,ZERO                INDICATE READ CONTROL RECORD
         L     BRANCH,READRTN           GET ADDRESS OF READ ROUTINE
         BALR  RETURN,BRANCH            GO TO READ
RDCNTRL1 TM    CMIOFLGS,CQEOCB          END OF CONCATENATION
         BO    PROCEOM                  YES-PROCESS END OF MODULE
IGN      NI    CMLIBFLG,CQFF-CQDELETE-CQKEEPS
         TM    CMIOFLGS,CQIGNCR         IGNORE CONTROL REC BIT ON
         BO    RDCNTRL                  YES-READ ANOTHER RECORD
         L     ADR,CMGETREC             GET ADDR OF INPUT BUFFER
         USING DCNTRLB,ADR              ESTABLISH DSECT ADDRESS
         TM    DTYPE,ESYMSCAT           REC TYPE SYM OR SCAT/TRAN
         BM    RDCNTRL                  YES-IGNORE-READ ANOTHER REC
         TM    DTYPE,ECESD              RECORD TYPE CESD
         BZ    FINCESD1                 NO-FINISH PROCESSING CESD
         OI    CMLIBFLG,CQFIRST         FIRST REC IS CESD
         OI    CMLIBFLG,CQCESDR         TURN ON CESD RECEIVED BIT
         LH    ID,DESID                 GET ID OF FIRST ITEM
         LH    LNG,DCOUNT               GET COUNT OF ESD DATA
         LA    PTR,DESDDATA             GET ADDR OF START OF DATA
         L     BRANCH,CESDRTN           GET ADDR OF ESD PROCESSOR
         BALR  RETURN,BRANCH            PROCESS ESD'S
         B     RDCNTRL                  READ ANOTHER CONTROL RECORD
*
***********************************************************************
*
*              PROCESS CESD
*
***********************************************************************
*
FINCESD1 TM    CMLIBFLG,CQFIRST         WAS FIRST REC CESD
         BO    FINCESD                  YES-CONTINUE
         LA    ZERO,ERINPT6             SET ERROR CODE-INVALID INPUT
         L     BRANCH,LOGRTN            GET ADDR OF LOG ROUTINE
         BALR RETURN,BRANCH             LOG ERROR
         B     BADCC1                   RETURN
FINCESD  TM    CMLIBFLG,CQCESDR         TEST CESD RECEIVED ON
         BZ    PROCRAT                  NO-PROCESS RLD'S AND TXT
         NI    CMLIBFLG,CQFF-CQCESDR    TURN OFF CESD RECEIVED BIT
         L     BRANCH,CESDRTN           GET ADDR OF ESD PROCESSOR
         BALR  RETURN,BRANCH            FINISH PROCESSING CESD
PROCRAT  TM    DTYPE,ERLD               RECORD TYPE RLD
         BZ    PROCTXT                  NO-PROCESS TXT
         LH    LNG,DRLDCNT              COUNT OF RLD DATA
         LA    PTR,DRLDDATA             GET ADDR OF START OF RLD DATA
         L     BRANCH,RLDRTN            GET ADDR OF RLD PROCESSOR RTN
         BALR  RETURN,BRANCH            PROCESS RLD'S
         TM    DTYPE,ETXT               ALSO TXT CONTROL RECORD
         BO    LMTXT                    YES-GO TO LOAD MOD TXT PROCESS
         TM    DTYPE,ELAST              LAST RECORD BIT ON
         BZ    RDCNTRL                  NO-READ ANOTHER CONTROL RECORD
         TM    CMLIBFLG,CQAUTOC         AUTOCALL BIT ON
         BO    PROCEOM                  GO TO EOM PROCESSOR
         OI    CMIOFLGS,CQIGNCR         SET IGNORE CONTROL REC BIT ON
         B     RDCNTRL                  READ ANOTHER RECORD
PROCTXT  TM    DTYPE,ETXT               TXT CONTROL RECORD
         BO    LMTXT                    GO TO LOAD MOD TXT PROCESSOR
         LA    ZERO,ERINPT6             SET ERROR CODE-INVALID INPUT
*                                       FROM LOAD MODULE
         L     BRANCH,LOGRTN            GET ADDR OF LOG ROUTINE
         BALR  RETURN,BRANCH            GO TO LOG ERROR MESSAGE
         B     RDCNTRL                  READ ANOTHER RECORD
*
***********************************************************************
*
*              PROCESS END OF MODULES
*
***********************************************************************
*
PROCEOM  L     BRANCH,EOMRTN            GET ADDR OF END OF MODULE PROC
         BALR  RETURN,BRANCH            GO PROCESS END OF MODULE
*
***********************************************************************
*
*              ISSUE RETURN MACRO
*
***********************************************************************
*
BADCC    NI    CMIOFLGS,CQFF-CQIGNCR    SET IGNORE CONTROL REC OFF
BADCC1   L     SAVEREG,4(SAVEREG)       PICT UP PTR TO CALLER'S SAVE
         RETURN (14,12),T               RESTORE REGISTERS AND RETURN
*
***********************************************************************
*
*              PROCESS ID/LENGTH LIST
*
***********************************************************************
*
LMTXT    SR    CUM,CUM                  CLEAR CUMULATING REGISTER
         LA    PTR,DID                  GET ADDRESS OF ID/LENGTH LIST
         LH    ZERO,DRLDCNT             LENGTH OF RLD ITEMS
         AR    PTR,ZERO                 ADD TO START OF DATA
         ST    PTR,CMBLDLPT             SAVE START ADDR OF ID/LENGTH
         LH    LNG,DCNTIDLN             GET LENGTH OF ID/LENGTH LIST
         LA    WORKB,EIDLNG             GET LENGTH OF EACH ENTRY
         LNR   WORKB,WORKB              MAKE NEG FOR DECREMENT
PICKID   BXLE  LNG,WORKB,FINIDL
         LH    ID,0(PTR)
         L     BRANCH,RENUMID           GET ADDRESS OF TRANSID
         BALR  RETURN,BRANCH            GO GET ADDR OF RNT ENTRY
         LTR   PARM,PARM                ENTRY EXISTS IF NOT ZERO
         BZ    SKIPREC                  IF ZERO-SKIP THIS RECORD
         B     MARKDEL                  SEE IF MARKED DELETE
DELETE   OI    CMLIBFLG,CQDELETE        TURN ON DELETE BIT
         AH    CUM,ELENGTH(PTR)         ADD LENGTH TO CUM REGISTER
         B     NEXTID                   GET NEXT ID
MARKDEL  TM    ESDTYPE(CESD),EDELETE    ENTRY MARKED DELETE
         BO    DELETE                   YES-SET DELETE BIT
         TM    CMLIBFLG,CQKEEPS         FIRST 'KEEP' ID
         BO    NOTFIRST                 NO-CONTINUE
         L     WORKA,ESDRELOC(CESD)     GET RELATIVE RELOC CONSTANT
         AR    WORKA,CUM                ADD AMOUNT DELETED FROM FRONT
         OI    CMLIBFLG,CQNOTXT+CQKEEPS TXT HAS BEEN RECEIVED
NOTFIRST SR    CUM,CUM                  CLEAR CUMULATING REGISTER
         L     ID,ESDLAA(CESD)          GET LAST CSECT ADDR
         LA    ID,0(ID)                 CLEAR FLAG BYTE
         AH    ID,ELENGTH(PTR)          ADD LENGTH OF CSECT
         ST    ID,CMLSTTXT              SAVE AS LAST TEXT ADDR
NEXTID   LA    PTR,EIDLNG(PTR)          GET ADDR OF NEXT ENTRY IN
*                                       ID/LENGTH LIST
         B     PICKID
FINIDL   TM    CMLIBFLG,CQKEEPS         KEEP SOME BIT ON
         BO    RDSETUP                  GET INFORMATION FOR TXT READ
*
***********************************************************************
*
*              SKIP TXT RECORD
*
***********************************************************************
*
SKIPREC  LA    ZERO,1                   INDICATE SKIP RECORD
         LNR   ZERO,ZERO
         L     PARM,CMGETREC            REG1 HAS ADDRESS OF RLD BUF
         B     LASTXT                   SEE IF LAST TXT REC IN MODULE
*
***********************************************************************
*
*              READ TXT
*
***********************************************************************
*
RDSETUP  LR    PARM,WORKA               GET ADDR FOR TEXT READ
         MVI   DADDR,X'00'              GET RID OF CCW OP CODE
         A     PARM,DADDR               ADD ADDR FROM CONTROL REC
         L     ZERO,DCCOUNT             GET COUNT FROM CONTROL REC
         N     ZERO,COUNTAND            CLEAR TOP HALF WORD
         SR    ZERO,CUM                 SUBTRACT CUMULATING REGISTER
*                                       FROM COUNT-AMOUNT DELETED
*                                       FROM END
         LR    WORKA,PARM               GET ADDR IN ANOTHER REG
         AR    WORKA,ZERO               ADD COUNT TO ADDR
         C     WORKA,CMLOWTBL           SUM EXCEED LOW TABLE ADDR
         BNH   LASTXT                   NO-SEE IF LAST TXT REC
         B     TOOBIG                   PRINT ERROR MESSAGE
LASTXT   TM    DTYPE,ELTXT              TXT REC LAST IN MODULE
         BZ    IDDEL
         TM    CMLIBFLG,CQAUTOC         AUTOCALL BIT ON
         BO    LMRDTXT                  YES-READ ONLY TEXT
         OI    CMIOFLGS,CQIGNCR         SET IGNORE CONTROL REC BIT ON
IDDEL    TM    CMLIBFLG,CQDELETE        ANY ID'S TO BE DELETED
         BO    LMRDTXT                  YES-READ ONLY TEXT
RDTAC    LNR   ZERO,ZERO                INDICATE READ TXT AND CONTROL
*                                       MAKE REG0 NEGATIVE
LMRDTXT  L     BRANCH,READRTN           GET ADDRESS OF READ ROUTINE
         BALR  RETURN,BRANCH            GO TO READ
         TM    CMIOFLGS,CQEOCB          END OF CONCATENATION
         BZ    ANYDEL                   NO-ANY TXT TO BE DELETED
         TM    CMIOFLGS,CQEOFSB         END OF FILE ON FIRST READ
         BZ    ANYDEL                   NO-ANY TXT TO BE DELETED
         NI    CMLIBFLG,CQFF-CQDELETE-CQKEEPS CLEAR DELETE AND KEEP
*                                             SOME BITS
         LA    ZERO,ERINPT6             INVALID INPUT FROM LOAD MOD
*                                       TEXT RECORD EXPECTED-NOT REC
         L     BRANCH,LOGRTN            GET ADDR OF LOG ROUTINE
         BALR  RETURN,BRANCH            GO TO LOG ERROR MESSAGE
         B     PROCEOM                  GO TO PROCESS END OF MOD
ANYDEL   TM    CMLIBFLG,CQDELETE        ANY TEXT TO BE DELETED
         BO    ALLDEL                   YES-ALL TO BE DELETED
DELALL   LTR   ZERO,ZERO                CONTROL REC READ
*                                       REG0 LESS THAN ZERO
         BNL   PROCEOM                  NO-GO TO PROCESS EOM
         B     RDCNTRL1
*
***********************************************************************
*
*              DELETE SOME TXT
*
***********************************************************************
*
ALLDEL   NI    CMLIBFLG,CQFF-CQDELETE   TURN OFF DELETE TXT BIT
         TM    CMLIBFLG,CQKEEPS         ALL TXT TO BE DELETED
         BZ    DELALL                   YES-DELETE ALL
         NI    CMLIBFLG,CQFF-CQKEEPS    TURN OFF KEEP SOME BIT
         LR    WORKA,PARM               GET ADDR OF FIRST TXT READ
         L     PTR,CMBLDLPT             RESTORE PTR TO FIRST ID
         LH    LNG,DCNTIDLN             GET LENGTH OF ID/LENGTH LIST
         LA    WORKB,EIDLNG             GET LENGTH OF EACH ENTRY
         LNR   WORKB,WORKB              MAKE NEGATIVE FOR DECREMENT
*
***********************************************************************
*
*              MOVE TXT TO CORRECT LOCATION
*
***********************************************************************
*
GETID    BXLE  LNG,WORKB,RDCNTRL
         LH    ID,0(PTR)
         LH    CUM,ELENGTH(PTR)         GET LENGTH OF CSECT
         L     BRANCH,RENUMID           GET ADDR OF TRANSID
         BALR  RETURN,BRANCH            GET ADDR OF RNT ENTRY
         TM    ESDTYPE(CESD),EDELETE    THIS ENTRY MARKED DELETE
         BO    GETNXT                   YES-GET NEXT ID
         L     PARM,ESDLAA(CESD)        GET ADDR OF THIS ID FROM CESD
         CR    WORKA,PARM               TXT IN RIGHT PLACE
         BE    GETNXT                   YES-GET NEXT ID
         LA    ZERO,256                 GET CONSTANT 256 FOR TEST
MOVELOOP CR    CUM,ZERO                 LENGTH GREATER THAN 256
         BNH   MOVELESS                 NO-MOVE REMAINING BYTES
         MVC   0(256,PARM),0(WORKA)     MOVE 256 CHARACTERS
         AR    WORKA,ZERO               INCREMENT MOVE ADDRESSES
         AR    PARM,ZERO
         SR    CUM,ZERO                 DECREMENT LENGTH
         B     MOVELOOP                 COMPARE-STILL GREATER THAN 256
LASTMOVE MVC   0(1,PARM),0(WORKA)       MOVE FOR LESS THAN 256
MOVELESS BCTR  CUM,0                    DECREMENT MOVE FOR EXECUTE MVC
         EX    CUM,LASTMOVE             MOVE LAST TXT
         LA    CUM,1(CUM)               GET BACK TO CORRECT LENGTH
GETNXT   AR    WORKA,CUM                POINT TO NEXT CESECT
         LA    PTR,EIDLNG(PTR)          GET ADDR OF NEXT ENTRY IN
*                                       ID/LENGTH LIST
         B     GETID
      EJECT
***********************************************************************
*   ERROR LOG ROUTINE --- THIS ROUTINE FORMATS AND PRINTS ERROR
*  MESSAGE ON THE SYSPRINT AND SYSTERM DATA SETS.IF A SEV 4 ERROR IS  *
*  DETECTED RETURN IS TO THE HIGHEST LEVEL CALLING ROUTINE.           *
*
*
*
*    UPON ENTRY -- REGISTER 0 CONTAINS A MESSAGE CODE
*                  REGISTER 1 CONTAINS A POINTER TO QUALIFYING
*                 INFORMATION (IF IT EXISTS)
*
*
         ENTRY HEWERROR
*
***********************************************************************
HEWERROR SAVE  (14,12),,*         SAVE CALLERS REGISTERS
         USING HEWERROR,R15       IDENTIFY ENTRY POINT
         L     R12,AUTOCALL            LOAD CSECT BASE
         DROP  R15                       DROP ENTRY POINT BASE
         USING HEWACALL,R12       AND IDENTIFY CSECT BASE
         SPACE
         L     R13,8(R13)          GET NEXT SAVE AREA POINTER
         SPACE
         LR    R2,R0               MOVE ERROR CODE
         LA    R3,1                  SET BIT
         SLL   R3,0(R2)                SHIFT BY ERROR CODE
         O     R3,CMBITMAP               INSERT INTO BITMAP
         ST    R3,CMBITMAP                 AND STORE BITMAP BACK
*
         AR    R2,R2               FORM INDEX
         AR    R2,R2                 FROM ERROR CODE
*
         TM    CMPRMFLG,CQTERM     WAS TERM OPTION PASSED
         BNO   RRCHKPRT            NO. CHECK SYSPRINT
         L     R8,CMTRMREC         YES. GET PTR TO TERM BUFFER
         LA    R9,TRMRECSZ-MSGPLEN  MAXIMUM LENGTH OF IDENTIFYING INFO
         BAL   R14,RRSETUP         MOVE MESSAGE IN
         L     R15,TRMRTN          AND PRINT IT
         BALR  R14,R15
RRCHKPRT TM    CMSTATUS,CQPRTOPN   IS THE SYSPRINT DATA SET OPEN
         BZ    RRERCODE              NO - DON'T SET UP MESSAGE
*
         LH    R6,CMWTBFCT         IS THERE ANYTHING
         LTR   R6,R6                 IN THE PRINT BUFFER
         BZ    RRMESSG                 NO - DON'T PURGE
*
         L     R15,PRTRTN            YES - GO PURGE
         BALR  R14,R15                 CURRENT PRINT BUFFER
*
RRMESSG  L     R8,CMPUTREC         GET POINTER TO PRINT BUFFER
         LH    R9,CMWLRECL         GET LENGTH OF PRINT BUFFER
         LA    R3,MSGPLEN          GET LENGTH OF PREFIX
         SR    R9,R3               GET LENGTH OF QUALIFYING INFO
         BAL   R14,RRSETUP         MOVE MESSAGE IN
         B     RRPRNT              AND GO PRINT IT
*
*              SET UP MESSAGE IN BUFFER POINTED TO BY R8
*        R9 CONTAINS MAXIMUM LENGTH OF QUALIFYING INFO
         USING MSGDSECT,R8
RRSETUP  EQU   *
*
         L     R7,ERTABLE(R2)      GET POINTER TO MESSAGE NUMBER
         MVC   MSGPREFX(4),RRPREFX   MOVE PREFIX TO PRINT BUFFER
         MVC   MSGNUMBR(3),0(R7)       AND MOVE IN MESSAGE NUMBER
*
         SR    R6,R6               GET QUALIFYING
         SLDL  R6,8                  DATA LENGTH
         LTR   R6,R6               IS THERE ANY
         BZ    RRSETRTN            NO. RETURN
*
         CR    R6,R9               WILL IT OVERFLOW BUFFER
         BNH   RRMOV               NO. OKAY
         LR    R6,R9               YES. TRUNCATE IT
RRMOV    EQU   *
         BCTR  R6,0                DECREMENT LENGTH FOR EXECUTE
         EX    R6,RRXTRAMV           AND MOVE INFO INTO PRINT BUFFER
RRSETRTN BR    R14                 RETURN
*
RRPRNT   L     R15,PRTRTN          AND PRINT
         BALR  R14,R15               THE ERROR MESSAGE
*
RRERCODE L     R7,ERTABLE(R2)      RELOAD POINTER TO MESSAGE NUMBER
         IC    R15,2(R7)             PICK UP LOW ORDER CHARACTER
         LA    R6,7           GET SEVERITY CODE
         NR    R15,R6
         LA    R6,1
         TM    CMPRMFLG,CQLET      IS 'LET' SPECIFIED
         BZ    RRTSTCOD           NO
         SR    R15,R6         YES. REDUCE CONDITION CODE BY 1
RRTSTCOD CR    R15,R6         IS IT ONE OR LESS
         BNH   RRTRYH         YES. OKAY
         OI    CMFLAG4,CQNOEX      SET 'NO EXECUTION' FLAG
RRTRYH   IC    R15,2(R7)      RELOAD CODE
         LA    R6,4                    AND OFF ALL
         NR    R15,R6                    BUT SEVERITY 4
RRABORT  L     R13,4(R13)          IF MESSAGE NOT SEVERITY 4 -- RETURN
         BZ    RRRETURN
         SPACE
*   A SEVERITY 4 ERROR HAS BEEN DETECTED ---- EXECUTION IS NO LONGER
*  POSSIBLE.  THE FOLLOWING CODE WILL PROCEED BACK THROUGH THE SAVE
*  AREA CHAIN TO THE HIGHEST LEVEL ROUTINE SO THAT DATA-SETS CAN BE
*  CLOSED AND MAIN STORAGE FREED.
*
*
         OI    CMSTATUS,CQABORT         SET ABORT BIT FOR CONTROL
         TM    CMSTATUS,CQRETURN        RETURN REQUESTED-SEVERITY 4
         BO    RRRETURN
         C     R13,CMFSTSAV        DOES R13 POINT TO FIRST SAVE AREA
         BNE   RRABORT               NO - GO TRY NEXT
*
RRRETURN RETURN (14,12),T
*
*
RRXTRAMV MVC   MSGTEXT(0),0(R1)    EXECUTED MOVE TEXT INTO MESSAGE
         EJECT
***********************************************************************
*                                                                     *
*   ERROR BIT-MAP PROCESSOR --- DIAGNOSTIC MESSAGE DICTIONARY PRINT   *
*                                                                     *
*   THE BIT MAP IS CHECKED FOR ALL ZERO (NO ERRORS)                   *
*   IF IT IS ALL ZERO--IT SETS THE CONDITION CODE AND RETURNS         *
*                                                                     *
*   MESSAGES TO BE PRINTED ARE SELECTED VIA INDEX INTO THE            *
*   MESSAGE TABLE USING THE POSITION OF THE BIT SET IN THE BIT        *
*   MAP AS THE INDEX VALUE.                                           *
*                                                                     *
*   PRINTS MESSAGES ON SYSPRINT AND/OR SYSTERM.                       *
*   IF NEITHER ARE WANTED, THE MESSAGES ARE                           *
*   NOT PRINTED BUT THE BIT MAP IS STILL SCANNED FOR THE              *
*   HIGHEST SEVERITY CODE.                                            *
*                                                                     *
*   BEFORE RETURNING THE SEVERITY CODE IS CHANGED TO THE CONDITION    *
*   CODE AND SET IN REGISTER 15.                                      *
*                                                                     *
***********************************************************************
         SPACE 3
HEWBTMAP SAVE  (14,12),,*
         ENTRY HEWBTMAP
         USING HEWBTMAP,R15
         L     R12,AUTOCALL
         DROP  R15
         USING HEWACALL,R12
         SPACE
         L     R13,8(R13)
         SPACE
         SPACE
         L     R3,CMBITMAP         LOAD BIT-MAP
         SR    R0,R0                    INITIALIZE SEVERITY CODE
         LTR   R3,R3                 IS IT ALL ZERO
         BZ    BMRETURN                YES - RETURN
         SPACE
         MVI   CMPRTCTL,CTSPACE3       SET UP CARRIAGE CONTROL
         SR    R2,R2               SET INDEX TO ZERO
         LA    R5,127                  SET MASK
BMCHKBIT LA    R4,1                CHECK IF LOW ORDER
         NR    R4,R3                 BIT IS SET IN BIT-MAP
         BZ    BMNXTCHK                NO - DON'T PRINT THIS MESSAGE
         L     R6,ERTABLE(R2)           GET PTR TO ERROR TABLE
         IC    R0,2(R6)                 SAVE SEVERITY CODE
         TM    CMPRMFLG,CQTERM     WAS TERM OPTION PASSED
         BZ    BMCHKPRT            NO. CHECK SYSPRINT
         L     R8,CMTRMREC         YES. GET POINTER TO TERM BUFFER
         BAL   R14,BMSETUP         MOVE MESSAGE IN
         L     R15,TRMRTN          AND
         BALR  R14,R15             PRINT IT
BMCHKPRT TM    CMSTATUS,CQPRTOPN   PRINT OPEN
         BZ    BMNXTCHK                 NO-SKIP BIT MAP
         L     R8,CMPUTREC             YES - GET POINTER TO PRINT BUF
         L     R6,ERTABLE(R2)      GET PTR TO ERROR TABLE
         BAL   R14,BMSETUP         MOVE MESSAGE IN
         B     BMPRNT              AND PRINT IT
BMSETUP  EQU   *
         MVC   1(4,R8),RRPREFX     MOVE 'IEW1' TO PRINT BUFFER
         MVC   5(3,R8),0(R6)         MOVE IN MESSAGE NUMBER
         SR    R7,R7
         LA    R8,12(R8)           UPDATE PRINT BUFFER POINTER
         SPACE
BMMESSG  LA    R6,4(R6)            JUMP TO NEXT LENGTH-ADCON PAIR
         L     R9,0(R6)              LOAD THE ADCON TO PHRASE
         IC    R7,0(R6)              LOAD THE LENGTH OF THE PHRASE
         NR    R7,R5                   KNOCK OFF INDICATOR BIT
         EX    R7,MVPHRASE             AND MOVE THE PHRASE TO PRNT BUF
         LTR   R9,R9               WAS THAT THE LAST PHRASE IN MESSAGE
         LA    R8,1(R7,R8)           UPDATE THE PRINT BUFFER POINTER
         BC    11,BMMESSG            N/ - GO MOVE NEXT PHRASE
         BR    R14                 RETURN
BMPRNT   EQU   *
         SPACE
         L     R15,PRTRTN            YES - GET ADDRESS OF PRINT RTN
         BALR  R14,R15                 AND GO PRINT THE MESSAGE
         SPACE 2
BMNXTCHK SRA   R3,1                SHIFT BIT-MAP RIGHT
         LA    R2,4(R2)              UPDATE INDEX INTO ERROR TABLE
         BNZ   BMCHKBIT                AND GO CHECK THIS BIT (IF ANY)
         SPACE 3
BMRETURN L     R13,4(R13)          ALL DONE - PICK UP PREVIOUS SAVE
         LA    R15,7                    PUT SEVERITY CODE INTO
         NR    R15,R0                   REGISTER 15 AND
         SLL   R15,2                             CHANGE TO CONDITION C
         BZ    BMRET                    RETURN IF CONDITION CODE ZERO
         LA    R14,8                    SEVERITY 2 CONSTANT     YA00126
         CR    R15,R14                  CK FOR ERROR GT SEV 2   YA00126
         BH    BMRET                    YES GT SEV 2            YA00126
         TM    CMPRMFLG,CQLET           LET SPECIFIED
         BZ    BMRET                    NO-RETURN
         LA    R10,4                    SUBTRACT FOUR FROM
         SR    R15,R10                  CONDITION CODE
BMRET    RETURN (14,12),T,RC=(15)       RETURN
         SPACE
MVPHRASE MVC   0(0,R8),0(R9)       EXECUTED MOVE PHRASE TO PRINT BUFFER
         EJECT
ERTABLE  DS    0F
         DC    AL1(8)
         DC    AL3(MSRELO1)
         DC    AL1(0)
         DC    AL3(MSENTR1)
         DC    AL1(80)
         DC    AL3(MSINPT8)
         SPACE
         DC    AL1(0)
         DC    AL3(MSINPT10)
         DC    AL1(0)
         DC    AL3(MSINPT2)
         DC    AL1(8)
         DC    AL3(MSRELO2)
         DC    AL1(8)
         DC    AL3(MSINPT4)
         DC    AL1(0)
         DC    AL3(MSINPT5)
         DC    AL1(0)
         DC    AL3(MSINPT7)
         DC    AL1(80)
         DC    AL3(MSINPT9)
         DC    AL1(8)
         DC    AL3(MSINPT1)
         SPACE
         DC    AL1(0)
         DC    AL3(MSINPT3)
         DC    AL1(8)
         DC    AL3(MSENTR2)
         DC    AL1(0)
         DC    AL3(MSIOUT4)
         DC    AL1(0)
         DC    AL3(MSINPT6)
         SPACE
         DC    AL1(8)
         DC    AL3(MSIOUT3)
         DC    AL1(8)
         DC    AL3(MSIOUT1)
         DC    AL1(67)
         DC    AL3(MSIOUT2)
         DC    AL1(0)
         DC    AL3(MSSIZE2)
         DC    AL1(0)
         DC    AL3(MSSIZE3)
         DC    AL1(8)
         DC    AL3(MSIDEN1)
         DC    AL1(8)
         DC    AL3(MSIDEN2)
         DC    AL1(8)                                            YM5575
         DC    AL3(MSINPT11)                                     YM5575
         SPACE
PHRASE1  DC    C'WARNING - '
PLNGTH1  EQU   *-PHRASE1
         SPACE
PHRASE2  DC    C'ERROR - '
PLNGTH2  EQU   *-PHRASE2
         SPACE
PHRASE3  DC    C'UNRESOLVED EXTERNAL REFERENCE'
PLNGTH3  EQU   *-PHRASE3
         SPACE
PHRASE4  DC    C' (NOCALL SPECIFIED)'                           YM05562
PLNGTH4  EQU   *-PHRASE4
         SPACE
PHRASE5  DC    C'NO '
PLNGTH5  EQU   *-PHRASE5
         SPACE
PHRASE6  DC    C'ENTRY POINT '
PLNGTH6  EQU   *-PHRASE6
         SPACE
PHRASE7  DC    C'RECEIVED'
PLNGTH7  EQU   *-PHRASE7
         SPACE
PHRASE8  DC    C'INVALID'
PLNGTH8  EQU   *-PHRASE8
         SPACE
PHRASE9  DC    C' NOT AN OBJECT RECORD'
PLNGTH9  EQU   *-PHRASE9
         SPACE
PHRASE10 DC    C' SPECIFIED'
PLNGTH10 EQU   *-PHRASE10
         SPACE
PHRASE11 DC    C'UNACCEPTABLE '
PLNGTH11 EQU   *-PHRASE11
         SPACE
PHRASE12 DC    C'RECORD FORMAT'
PLNGTH12 EQU   *-PHRASE12
         SPACE
PHRASE13 DC    C'NO TEXT '
PLNGTH13 EQU   *-PHRASE13
         SPACE
PHRASE14 DC    C' RECORD FROM '
PLNGTH14 EQU   *-PHRASE14
         SPACE
PHRASE15 DC    C'OBJECT MODULE'
PLNGTH15 EQU   *-PHRASE15
         SPACE
PHRASE16 DC    C'LOAD MODULE'
PLNGTH16 EQU   *-PHRASE16
         SPACE
         SPACE
PHRASE18 DC    C'CARD '
PLNGTH18 EQU   *-PHRASE18
         SPACE
PHRASE19 DC    C' LENGTH'
PLNGTH19 EQU   *-PHRASE19
         SPACE
PHRASE20 DC    C'DOUBLY DEFINED ESD'
PLNGTH20 EQU   *-PHRASE20
         SPACE
PHRASE21 DC    C' 2 BYTE ADCON'
PLNGTH21 EQU   *-PHRASE21
         SPACE
PHRASE22 DC    C' ID '
PLNGTH22 EQU   *-PHRASE22
         SPACE
PHRASE23 DC    C'BLKSIZE IS '
PLNGTH23 EQU   *-PHRASE23
         SPACE
PHRASE24 DC    C' (VARIABLE ON INPUT)'
PLNGTH24 EQU   *-PHRASE24
         SPACE
PHRASE25 DC    C' BUT NOT MATCHED'
PLNGTH25 EQU   *-PHRASE25
         SPACE
PHRASE26 DC    C'I/O ERROR WHILE SEARCHING LIBRARY DIRECTORY'
PLNGTH26 EQU   *-PHRASE26
         SPACE
PHRASE27 DC    C'DDNAME '
PLNGTH27 EQU   *-PHRASE27
         SPACE
PHRASE28 DC    C'CANNOT BE OPENED'
PLNGTH28 EQU   *-PHRASE28
         SPACE
PHRASE29 DC    C'HAD SYNCHRONOUS ERROR'
PLNGTH29 EQU   *-PHRASE29
         SPACE
         SPACE
PHRASE31 DC    C'AVAILABLE STORAGE EXCEEDED'
PLNGTH31 EQU   *-PHRASE31
         SPACE
PHRASE32 DC    C' TOO LARGE'
PLNGTH32 EQU   *-PHRASE32
         SPACE
PHRASE33 DC    C'TOO MANY EXTERNAL NAMES IN INPUT MODULE'
PLNGTH33 EQU   *-PHRASE33
         SPACE 2
PHRASE34 DC    C'END '
PLNGTH34 EQU   *-PHRASE34
PHRASE35 DC    C'IDENTIFICATION FAILED'
PLNGTH35 EQU   *-PHRASE35
PHRASE36 DC    C' - DUPLICATE PROGRAM NAME FOUND'
PLNGTH36 EQU   *-PHRASE36
PHRASE37 DC    C'COMMON EXCEEDS SIZE OF CSECT WITH SAME NAME'    YM5575
PLNGTH37 EQU   *-PHRASE37                                        YM5575
         DS    0F
MSRELO1  DC    C'001 '
         DC    AL1(PLNGTH1-1),AL3(PHRASE1)
         DC    AL1(PLNGTH3-1),AL3(PHRASE3)
         DC    AL1(128+PLNGTH4-1),AL3(PHRASE4)
         SPACE
MSRELO2  DC    C'012 '
         DC    AL1(PLNGTH2-1),AL3(PHRASE2)
         DC    AL1(128+PLNGTH3-1),AL3(PHRASE3)
         SPACE
MSIOUT1  DC    C'024 '
         DC    AL1(PLNGTH2-1),AL3(PHRASE2)
         DC    AL1(PLNGTH27-1),AL3(PHRASE27)
         DC    AL1(128+PLNGTH28-1),AL3(PHRASE28)
         SPACE
MSIOUT2  DC    C'034 '
         DC    AL1(PLNGTH2-1),AL3(PHRASE2)
         DC    AL1(PLNGTH27-1),AL3(PHRASE27)
         DC    AL1(128+PLNGTH29-1),AL3(PHRASE29)
         SPACE
MSIOUT3  DC    C'044 '
         DC    AL1(PLNGTH2-1),AL3(PHRASE2)
         DC    AL1(PLNGTH11-1),AL3(PHRASE11)
         DC    AL1(PLNGTH12-1),AL3(PHRASE12)
         DC    AL1(128+PLNGTH24-1),AL3(PHRASE24)
         SPACE
MSIOUT4  DC    C'053 '
         DC    AL1(PLNGTH2-1),AL3(PHRASE2)
         DC    AL1(128+PLNGTH26-1),AL3(PHRASE26)
         SPACE
         SPACE
MSINPT1  DC    C'072 '
         DC    AL1(PLNGTH2-1),AL3(PHRASE2)
         DC    AL1(PLNGTH23-1),AL3(PHRASE23)
         DC    AL1(128+PLNGTH8-1),AL3(PHRASE8)
         SPACE
MSINPT2  DC    C'082 '
         DC    AL1(PLNGTH2-1),AL3(PHRASE2)
         DC    AL1(PLNGTH8-1),AL3(PHRASE8)
         DC    AL1(PLNGTH19-1),AL3(PHRASE19)
         DC    AL1(128+PLNGTH10-1),AL3(PHRASE10)
         SPACE
MSINPT3  DC    C'093 '
         DC    AL1(PLNGTH2-1),AL3(PHRASE2)
         DC    AL1(PLNGTH13-1),AL3(PHRASE13)
         DC    AL1(128+PLNGTH7-1),AL3(PHRASE7)
         SPACE
MSINPT4  DC    C'102 '
         DC    AL1(PLNGTH2-1),AL3(PHRASE2)
         DC    AL1(128+PLNGTH20-1),AL3(PHRASE20)
         SPACE
MSINPT5  DC    C'112 '
         DC    AL1(PLNGTH2-1),AL3(PHRASE2)
         DC    AL1(PLNGTH8-1),AL3(PHRASE8)
         DC    AL1(128+PLNGTH21-1),AL3(PHRASE21)
         SPACE
MSINPT6  DC    C'123 '
         DC    AL1(PLNGTH2-1),AL3(PHRASE2)
         DC    AL1(PLNGTH8-1),AL3(PHRASE8)
         DC    AL1(PLNGTH14-1),AL3(PHRASE14)
         DC    AL1(128+PLNGTH16-1),AL3(PHRASE16)
         SPACE
MSINPT7  DC    C'132 '
         DC    AL1(PLNGTH2-1),AL3(PHRASE2)
         DC    AL1(PLNGTH8-1),AL3(PHRASE8)
         DC    AL1(PLNGTH22-1),AL3(PHRASE22)
         DC    AL1(128+PLNGTH7-1),AL3(PHRASE7)
         SPACE
MSINPT8  DC    C'141 '
         DC    AL1(PLNGTH1-1),AL3(PHRASE1)
         DC    AL1(PLNGTH18-1),AL3(PHRASE18)
         DC    AL1(PLNGTH7-1),AL3(PHRASE7)
         DC    AL1(128+PLNGTH9-1),AL3(PHRASE9)
         SPACE
MSINPT9  DC    C'152 '
         DC    AL1(PLNGTH2-1),AL3(PHRASE2)
         DC    AL1(PLNGTH8-1),AL3(PHRASE8)
         DC    AL1(PLNGTH14-1),AL3(PHRASE14)
         DC    AL1(128+PLNGTH15-1),AL3(PHRASE15)
         SPACE
MSINPT10 DC    C'182 '
         DC    AL1(PLNGTH2-1),AL3(PHRASE2)
         DC    AL1(PLNGTH5-1),AL3(PHRASE5)
         DC    AL1(PLNGTH34-1),AL3(PHRASE34)
         DC    AL1(PLNGTH18-1),AL3(PHRASE18)
         DC    AL1(128+PLNGTH7-1),AL3(PHRASE7)
MSINPT11 DC    C'232 '                                           YM5575
         DC    AL1(PLNGTH2-1),AL3(PHRASE2)                       YM5575
         DC    AL1(128+PLNGTH37-1),AL3(PHRASE37)                 YM5575
MSENTR1  DC    C'161 '
         DC    AL1(PLNGTH1-1),AL3(PHRASE1)
         DC    AL1(PLNGTH5-1),AL3(PHRASE5)
         DC    AL1(PLNGTH6-1),AL3(PHRASE6)
         DC    AL1(128+PLNGTH7-1),AL3(PHRASE7)
         SPACE
MSENTR2  DC    C'173 '
         DC    AL1(PLNGTH2-1),AL3(PHRASE2)
         DC    AL1(PLNGTH6-1),AL3(PHRASE6)
         DC    AL1(PLNGTH7-1),AL3(PHRASE7)
         DC    AL1(128+PLNGTH25-1),AL3(PHRASE25)
         SPACE
MSSIZE2  DC    C'194 '
         DC    AL1(PLNGTH2-1),AL3(PHRASE2)
         DC    AL1(128+PLNGTH31-1),AL3(PHRASE31)
         SPACE
MSSIZE3  DC    C'204 '
         DC    AL1(PLNGTH2-1),AL3(PHRASE2)
         DC    AL1(128+PLNGTH33-1),AL3(PHRASE33)
MSIDEN1  DC    C'214 '
         DC    AL1(PLNGTH35-1),AL3(PHRASE35)
         DC    AL1(128+PLNGTH36-1),AL3(PHRASE36)
MSIDEN2  DC    C'224 '
         DC    AL1(128+PLNGTH35-1),AL3(PHRASE35)
RRPREFX  DC    C'IEW1'
AUTOCALL DC    A(HEWACALL)
LOADRTN  DC    A(HEWLODE)         LOAD MODULE PROCESSOR
RLDRTN   DC    V(HEWLRLD)         RLD PROCESSOR
READRTN  DC    V(HEWLREAD)        READ ROUTINE
CESDRTN  DC    V(HEWLESD)         ESD AND CESD PROCESSOR
LOGRTN   DC    A(HEWERROR)        ERROR LOG ROUTINE
EOMRTN   DC    V(HEWLEND)         END CARD AND END  OF MODULE
*                                       PROCESSOR
RENUMID  DC    V(TRANSID)               RENUMBER TBL-ID ROUTINE
MAPRTN   DC    V(HEWLMAP)         MAP PROCESSOR
OPNSYSLI DC    V(HEWOPNLB)        OPEN SYSLIB ROUTINE
PRTRTN   DC    V(HEWLPRNT)        PRINT ROUTINE
TRMRTN   DC    V(HEWTERM)         SYSTERM OUTPUT ROUTINE
RLDRES   DC    V(HEWLERTN)        RLD RESOLUTION ROUTINE
PRIMRTN  DC    V(HEWPRIME)        BUFFER PRIME ROUTINE
RELORTN  DC    V(HEWLRELO)        OBJECT MODULE PROCESSOR
CNVTRTN  DC    V(HEWLCNVT)        CONVERT TO HEX ROUTINE
COUNTAND DC    X'0000FFFF'              CONSTANT FOR AND INST
MSG2     DC    C'TOTAL LENGTH'
MSG2LNG  EQU   *-MSG2
MSG3     DC    C'ENTRY ADDRESS'
MSG3LNG  EQU   *-MSG3
MAINTDS  DS    37F
         EJECT
*   MESSAGE LINE FORMAT DSECT
         SPACE 2
MSGDSECT DSECT
         DC    C' '
MSGPREFX DC    C'IEW0'        MESSAGE PREFIX
MSGNUMBR DS    CL3            MESSAGE NUMBER (AND SEVERITY)
         DC    C'  '
MSGTEXT  DS    C              QUALIFYING INFORMATION
MSGPLEN  EQU   MSGTEXT-MSGDSECT    LENGTH OF PREFIX,ETC
CVTSECT  DSECT
         CVT
         HEWLDCOM
DCNTRLB  DSECT
DTYPE    DS    CL1                      TYPE IDENTIFICATION
         DS    CL3
DESID    DS    CL2                      ESDID OF FIRST ESD ITEM
DCOUNT   DS    CL2                      BYTES OF ESD DATA
DESDDATA EQU   *                        START OF ESD DATA
         ORG   DESID
DCNTIDLN DS    CL2                      BYTES OF ID/LENGTH LIST
         DS    CL2
DCCW     EQU   *                        CHANNEL COMMAND WORD
DADDR    DS    CL4                      DATA ADDRESS
DCCOUNT  DS    CL4                      BYTES OF TXT DATA
DID      DS    CL2                      CESD ENTRY NUMBER
DLENGTH  DS    CL2                      LENGTH OF TEXT RECORD
         ORG   DCOUNT
DRLDCNT  DS    CL2                      BYTES OF RLD INFORMATION
         DS    CL8
DRLDDATA EQU   *                        START OF RLD DATA
CDENTRY  DSECT
CDCHAIN  DS    4C                       CHAIN ADDR-NEXT ENTRY
CDROLL   DS    1C                       COUNT OF ROLL OUTS
CDRPB    DS    3C                       ADDRESS OF PRB
CDNAME   DS    8C                       NAME
CDENTPT  DS    4C                       RELOCATED ENTRY POINT
         END
