         TITLE 'IFCSSOFT - SOFTWARE (ABEND) RECORD SUMMARY'
         MACRO
         HEX   &LOGITEM,&SKIP$OR,&BYTES
.*       CONVERSIONS.
.*          &LOGITEM - NAME OF DATA ITEM TO BE CONVERTED.
.*          &SKIP$OR - NUMBER OF SPACES TO SKIP ON MULTIPLE PRINT OR
.*                     NUMBER OF SPACES TO BACKUP FROM COLUM FOR START
.*                     OF PRINTING.  THE LETTER B PRECEEDS THE NUMBER
.*                     (B8) IF THE LATTER OPTION IS DESIRED.  OMISSION
.*                     OF THIS OPERAND FORCES OPTION 2 WITH BACKUP
.*                     SPACING EQUAL TO THE NUMBER OF BYTES SPECIFIED
.*                     BY THE NEXT OPERAND (TWICE THIS NUMBER IF SUFFIX
.*                     IS EXPLICITLY OR IMPLICITLY B).
.*          &BYTES   - NUMBER OF TOTAL INPUT BYTES TO PROCESS.  THIS
.*                     NUMBER IS SUFFIXED WITH AN L, R, OR B TO
.*                     STIPULATE PRINTING OF THE LEFT HALF, RIGHT HALF
.*                     OR BOTH BALVES OF THE BYTE RESPECTIVELY.
.*                     OMISSION OF THIS OPERAND DEFAULTS TO B WITH THE
.*                     NUMBER OF BYTES EQUAL TO THE ITEM LENGTH.
.*          A NEW ENTRY IS GENERATED ONLY WHEN NECESSARY.  THIS MACRO
.*          MUST BE ISSUED FOR THE SUBJECT LINE(S).
         GBLC  &ITEM(2600),&DSECT
         GBLA  &ITEMNBR,&BITS(2600),&SHIFT(2600),&NRENTS
         LCLB  &B
         LCLA  &IBITS,&NDX,&ISHIFT,&K,&T,&CODE,&BYTESP
         LCLC  &S,&LETTER
.LOOP    ANOP
&NDX     SETA  &NDX+1
         AIF   ('&ITEM(&NDX)'      EQ '&LOGITEM').FOUND
         AIF   (&NDX               LT &ITEMNBR).LOOP
         MNOTE *,'LOG ITEM NOT DEFINED'
         MEXIT
.FOUND   ANOP
&ISHIFT  SETA  &SHIFT(&NDX)
&IBITS   SETA  &BITS(&NDX)
&CODE    SETA  1
&K       SETA  K'&BYTES
         AIF   (&IBITS-(&IBITS/4)*4 EQ 0).OK
         MNOTE *,'BIT LENGTH SPECIFICATION INCONSISTENT WITH CONTROL'
         MEXIT
.OK      AIF   ('&BYTES'           EQ '').USEDEFN
&LETTER  SETC  '&BYTES'(&K,1)
&S       SETC  '&BYTES'(1,&K-1)
&BYTESP  SETA  &S
         AIF   ('&LETTER'          EQ 'B').BOTH
         AIF   (&ISHIFT            EQ 0 OR &ISHIFT EQ 4).OK2
.ERR     MNOTE *,'DATA NOT ALLIGNED ON HEX OR BYTE BOUNDARY'
         MEXIT
.USEDEFN ANOP
&BYTESP  SETA  &IBITS/8
.BOTH    AIF   (&ISHIFT            NE 0).ERR
&CODE    SETA  3
&T       SETA  &BYTESP*2-1
&S       SETC  '&T'
.OK2     AIF   (&ISHIFT            EQ 0).L
&CODE    SETA  2
.L       ANOP
&B       SETB  1
         AIF   ('&SKIP$OR'         EQ '').BACKUP
&K       SETA  K'&SKIP$OR
&B       SETB  ('&SKIP$OR'(1,1)    EQ 'B')
&S       SETC  '&SKIP$OR'(&B+1,&K-&B)
.BACKUP  ANOP
&NRENTS  SETA  &NRENTS+1
         DC    AL.12(&LOGITEM-&DSECT),XL.4'A'
         DC    BL.1'&B',FL.7'&S',FL.4'&BYTESP',FL.4'&CODE'
.OUT     ANOP
         MEND
         EJECT
         MACRO
         SPECIAL &ROUTINE,&PARAM,&SPACE=
.*       THIS MACRO GENERATES A SPECIAL ROUTINE ENTRY TO BE PROCESSED
.*       BY THE SUMMARY MODULE.
.*          &ROUTINE - SYMBOL ON SPECIAL ROUTINE EWT.
.*          &PARAM   - AN 8 BIT BINARY REPRESENTATION TO OCCUPY THE
.*                     'MASK' FIELD BUT TO BE INTERPRETED AS AN
.*                     ARGUMENT OF THE SPECIAL ROUTINE.
.*          &SPACE   - THE NUMBER OF 2 BYTE COUNTERS TO ALLOCATE FOR
.*                     REQUIRED PROCESSING.
         GBLC  &CSECT
         GBLA  &COUNTR
         LCLA  &ADD
         DC    AL1(128)
         DC    BL.8'&PARAM'
         DC    AL2(&ROUTINE-&CSECT)
         DC    AL2(&COUNTR)
&ADD     SETA  1
         AIF   ('&SPACE'           EQ '').NORM
&ADD     SETA  &SPACE
.NORM    ANOP
&COUNTR  SETA  &COUNTR+&ADD
         MEND
         EJECT
         MACRO
&NAME    DSGEN ,
.*                            THIS MACRO GENERATES ONE DSECT WORD
.*                                 FORMATTED FOR THE SUBJECT LOG RECORD
.*                                 EACH OPERAND HAS TWO SUB LISTS. THE
.*                                 FIRST IS THE NAME OF THE LOG ITEM
.*                                 WHILE THE SECOND IS THE # OF BITS TO
.*                                 ALLOCATE FOR THIS ITEM. ITEMS MUST
.*                                 BE DEFINED CONTIGUOUSLY WITHOUT GAPS
.*                                 UNUSED BIT GROUPS MUST BE GIVEN
.*                                 DUMMY NAMES. THE NAMES PROVIDED FOR
.*                                 THE LOG ITEMS MAY THEN BE USED IN
.*                                 THE CONVERSION MACRO INSTRUCTIONS.
         GBLA  &BITS(2600),&DB,&DT,&INITIAL
         GBLA  &ITEMITR,&ITEMFST(20),&ITEMNBR,&ITEMMDX
         GBLA  &ITEMNDX(2600),&ITEMXPT
         GBLA  &LABELNR,&LASTCC,&LB,&LBLCTR(100),&LPTR,&LT
         GBLA  &NRENTS,&SHIFT(2600)
         GBLB  &DIAGITF,&DIAGLIN,&DIAGSET,&DIAGTST,&FSW,&TEST
         GBLC  &CARRCON,&CSECT,&DSECT,&ITEM(2600)
         GBLC  &LABELS(2600),&LBL(100),&NRENTSX
         LCLB  &ONLY1,&CTIND
         LCLA  &START1,&START2,&END1,&END2
         LCLC  &SYMBOL,&EQUSYM
         LCLA  &OP,&COUNT,&BYTE,&EQUCNT
         ACTR  100000
         AIF   (&ITEMITR EQ 0).START
 MNOTE   20,'DSGEN MACRO OCCURRS AFTER ITEMSORT MACRO HAS BEEN ISSUED.'
         MEXIT
.START   AIF   (N'&SYSLIST(&OP+1) LT 3).LOOP
         AIF   ('&SYSLIST(&OP+1,3)' EQ 'EQU').LOOP     TEST FOR EQU
  AIF   ('&SYSLIST(&OP+1,3)' EQ '' OR '&SYSLIST(&OP+1,4)' EQ '').ERR1
         AIF   ('&SYSLIST(&OP+1,3)' GT '&SYSLIST(&OP+1,4)').ERR3
&START1  SETA  &SYSLIST(&OP+1,3)        GET START COUNT OF 1
&START2  SETA  &SYSLIST(&OP+1,4)        GET FIRST END COUNT
         AGO   .SET2A                   BRANCH AROUND
         AIF   ('&SYSLIST(&OP+1,5)' GT '&SYSLIST(&OP+1,6)').ERR3
.ERR1    MNOTE '**FIRST SYMBOL CONCATENATION INCOMPLETE**'
         MEXIT
.SET2A   AIF   ('&SYSLIST(&OP+1,5)' EQ ''AND '&SYSLIST(&OP+1,6)' EQ '' X
               ).SET2                   TEST FOR NO SECOND
  AIF   ('&SYSLIST(&OP+1,5)' EQ '' OR '&SYSLIST(&OP+1,6)' EQ '').ERR2
&END1    SETA  &SYSLIST(&OP+1,5)        GET START COUNT OF 2
&END2    SETA  &SYSLIST(&OP+1,6)        GET END COUNT OF 2
         AGO   .LOOP
.SET2    ANOP
&ONLY1   SETB  1                        INDICATE ONLY ONE CONCATENATION
         AGO   .LOOP
.ERR2    MNOTE '**SECOND SYMBOL CONCATENATION INCOMPLETE**'
         MEXIT
.ERR3    MNOTE '**START GREATER THAN END CONCATENATION**'
         MEXIT
.LOOP    ANOP
&OP      SETA  &OP+1
         AIF   (&OP GT N'&SYSLIST).DONE      TEST IF ALL DONE
&ITEMNBR SETA  &ITEMNBR+1
         AIF   ('&SYSLIST(&OP,2)' NE '').OK1
         MNOTE '**NULL BIT COUNT FIELD**'
         MEXIT
.OK1     ANOP
&SYMBOL  SETC  '&SYSLIST(&OP,1)'
         AIF   ('&SYMBOL' NE '').OK
*              *****     LOG ITEM SYMBOL NOT PROVIDED     *****
         AIF   ('&SYSLIST(&OP,3)' NE 'EQU').CNT
         AGO   .START                   GET NEXT
.OK      AIF   (N'&SYSLIST(&OP) LT 3).NO3    TEST FOR OLD FORMAT
         AIF   ('&SYSLIST(&OP,3)' EQ 'EQU').EQU   TEST FOR EQU
         AIF   (&ONLY1).OK2             TEST FOR ONLY ONE CONCAT
&SYMBOL  SETC  '&SYMBOL.&START1.&END1'       GET 1 AND 2 CONCAT
         AGO   .NO3                     BRANCH AROUND
.OK2     ANOP
&SYMBOL  SETC  '&SYMBOL.&START1'        GET 1 CONCATENATED
.NO3     ANOP
&SYMBOL  EQU   *+&BYTE
&ITEM(&ITEMNBR) SETC '&SYMBOL'          GET LABEL IN GLOBAL
&BITS(&ITEMNBR) SETA &SYSLIST(&OP,2)
&SHIFT(&ITEMNBR) SETA &COUNT-&BYTE*8
.CNT     ANOP
&CTIND   SETB  1                        SET COUNT INDICATOR
&COUNT   SETA  &COUNT+&SYSLIST(&OP,2)
&BYTE    SETA  &COUNT/8
         AIF   (N'&SYSLIST(&OP) LT 3).START  TEST FOR OLD FORMAT
         AIF   (&ONLY1).TSTST           TEST FOR ONLY ONE CONCAT
         AIF   (&END1 EQ &END2).TSTST   TEST FOR SECOND END
&END1    SETA  &END1+1                  INCREMENT COUNT
&OP      SETA  &OP-1                    DECREMENT INCREMENT
         AGO   .LOOP                    GENERATE NEXT
.TSTST   ANOP
         AIF   (&START1 EQ &START2).LPDONE   TEST FOR END
         AIF   (&ONLY1).NSET1           TEST FOR ONLY ONE CONCAT
&END1    SETA  &SYSLIST(&OP,5)          RE-INIT SECOND START COUNT
.NSET1   ANOP
&OP      SETA  &OP-1                    DECREMENT INDEX
&START1  SETA  &START1+1                INCREMENT FIRST COUNT
         AGO   .LOOP                    GO DO NEXT
.LPDONE  ANOP
&ONLY1   SETB  0                        CLEAR INDICATOR
         AGO   .START                   GO TEST FOR MORE SUB-LISTS
.DONE    AIF   (&COUNT-&COUNT/8*8 NE 0).ERR  TEST FOR MULTIPLE OF EIGHT
         AIF   (&CTIND EQ 0).END        NO DS IF NO COUNT
&COUNT   SETA  &COUNT/8                 GET NUMBER OF BYTES
&NAME    DS    &COUNT.C
.END     MEXIT
.ERR     MNOTE '**BIT COUNT FLDS DO NOT TOTAL MULTIPLE OF 8**'
         MEXIT
.EQU     AIF   ('&SYSLIST(&OP,4)' NE '').EQU1     TEST FOR NULL LABEL
.ERR4    MNOTE '**EQU OPERAND OMITTED OR NOT FOUND**'
         MEXIT
.EQU1    AIF   (&SYSLIST(&OP,2) LT 16).EQU2  COUNT OVER FIFTEEN
*****               THE FOLLOWING STATEMENT                *****
*****     NUMBER OF BITS EXCEED 15 - DO NOT USE AS BIN     *****
.EQU2    ANOP
&EQUCNT  SETA  0                        CLEAR COUNTER
&EQUSYM  SETC  '&SYSLIST(&OP,4)'        GET EQU OPERAND
.EQULOP  ANOP
&EQUCNT  SETA  &EQUCNT+1                INCREMENT INDEX
         AIF   ('&ITEM(&EQUCNT)' EQ '&EQUSYM').EQUOUT  LABEL FOUND?
         AIF   (&EQUCNT EQ &ITEMNBR).ERR4    ALL TESTED?
         AGO   .EQULOP                  NO-GET NEXT
.EQUOUT  ANOP
&ITEM(&ITEMNBR) SETC '&SYMBOL'          GET LABEL NAME
&BITS(&ITEMNBR) SETA &SYSLIST(&OP,2)    GET NUMBER OF BITS
&SHIFT(&ITEMNBR) SETA &SHIFT(&EQUCNT)   GET SHIFT COUNT
&SYMBOL  EQU   &EQUSYM                  THIS SYMBOL EQUATED
         AGO   .START                   RETURN FOR NEXT
         MEND
         EJECT
         MACRO
&NAME    LINE  &DATA,&LABEL,&SKIP=
.*                            THIS MACRO ESTABLISHES THE MARGINS OR
.*                                 COLUMN SETTINGS FOR EACH LINE. IT
.*                                 GENERATES NECESSARY CARRIAGE CONTROL
.*                                 ENTRIES. LASTLY IT DETERMINES THE
.*                                 NUMBER OF ENTRIES ASSOCIATED WITH
.*                                 THE PREVIOUS LINE AND STORES THAT #
.*                                 INTO THE APPROPRIATE BYTE.
.*                            &DATA(1) - CHARACTER POSITION TO BEGIN
.*                                 DATA.
.*                            &DATA(2) - # OF SPACES BETWEEN SUCCESSIVE
.*                                 DATA COLUMN STARTING CHARACTERS.
.*                            &LABEL(1) - CHAR. POS. TO BEGIN LABELS.
.*                            &LABEL(2) - # SPACES BETWEEN LINE'S LABEL
.*                                 STARTING CHARACTERS.
.*                            &SKIP= - # OF LINES TO ADVANCE CARRIAGE
.*                                 TO BEGIN NEXT PRINTED LINE.
.*                            NEW ENTRIES ARE GENERATED ONLY WHEN
.*                                 NECESSARY. OMISSION OF ITEMS MEANS
.*                                 THEY HAVE NOT CHANGED SINCE PREVIOUS
.*                                 SETTINGS. A LINE MACRO IS REQUIRED
.*                                 FOR EACH PRINTED LINE. IF NO SETTING
.*                                 CHANGES ARE REQUIRED ALL OPERANDS
.*                                 ARE OMITTED IN WHICH CASE ONLY THE
.*                                 # OF ENTRIES FOR THE PREVIOUS LINE
.*                                 IS COMPUTED. THIS MACRO MUST BE THE
.*                                 FIRST MACRO INSTRUCTION ISSUED FOR
.*                                 THE SUBJECT LINE
         GBLA  &BITS(2600),&DB,&DT,&INITIAL
         GBLA  &ITEMITR,&ITEMFST(20),&ITEMNBR,&ITEMMDX
         GBLA  &ITEMNDX(2600),&ITEMXPT
         GBLA  &LABELNR,&LASTCC,&LB,&LBLCTR(100),&LPTR,&LT
         GBLA  &NRENTS,&SHIFT(2600)
         GBLB  &DIAGITF,&DIAGLIN,&DIAGSET,&DIAGTST,&FSW,&TEST
         GBLC  &CARRCON,&CSECT,&DSECT,&ITEM(2600)
         GBLC  &LABELS(2600),&LBL(100),&NRENTSX
         LCLA  &S
         AIF   (&INITIAL EQ 0 OR &DIAGTST EQ 0).DIAGSET
         AIF   (&DIAGSET EQ 0).DIAGSET
         MNOTE '**NO LABEL ASSOCIATED WITH LAST SET**'
***** THE FOLLOWING GENERATED FOR TEST PURPOSES *****
*        LABEL '%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'
               LABEL '%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'
.DIAGSET ANOP
&DIAGSET SETB  1
&DIAGLIN SETB  1
&NAME    DS    0C
         AIF   (&INITIAL EQ 0).FIRSTLN
         LINEND
         AGO   .NTFIRST
.FIRSTLN ANOP
&NRENTSX SETC  'N&SYSNDX'
&INITIAL SETA  1
N&SYSNDX EQU   *
.NTFIRST ANOP
         DC    AL1(0)
         AIF   ('&DATA(1)' EQ '').CKDTABS
         AIF   (&DATA(1) EQ &DB).CKDTABS
&DB      SETA  &DATA(1)
         AGO   .AA
.CKDTABS AIF   ('&DATA(2)' EQ '').NCDATA
         AIF   (&DATA(2) EQ &DT).NCDATA
         AGO   .CC
.AA      AIF   ('&DATA(2)' EQ '').BB
         AIF   (&DATA(2) EQ &DT).BB
.CC      ANOP
&DT      SETA  &DATA(2)
.BB      DC    XL2'FFFE'
         DC    FL1'&DB'
         DC    FL1'&DT'
&NRENTS  SETA  &NRENTS+1
.NCDATA  ANOP
         AIF   ('&LABEL(1)' EQ '').CKLTABS
         AIF   (&LABEL(1) EQ &LB).CKLTABS
&LB      SETA  &LABEL(1)
         AGO   .AAA
.CKLTABS AIF   ('&LABEL(2)' EQ '').NCLABEL
         AIF   (&LABEL(2) EQ &LT).NCLABEL
         AGO   .CCC
.AAA     AIF   ('&LABEL(2)' EQ '').BBB
         AIF   (&LABEL(2) EQ &LT).BBB
.CCC     ANOP
&LT      SETA  &LABEL(2)
.BBB     DC    XL2'FFFF'
         DC    FL1'&LB'
         DC    FL1'&LT'
&NRENTS  SETA  &NRENTS+1
.NCLABEL ANOP
         AIF   ('&SKIP' NE '').CONT
         AIF   (&TEST EQ 0).NOCHANG
         AGO   .DEFALTA
.CONT    ANOP
         AIF   (&TEST EQ 0).AB
         AIF   ('&SKIP' EQ 'E').AB
&S       SETA  &SKIP
.DEFAULT ANOP
         AIF   (&SKIP EQ &LASTCC).DEFALTA
         ORG   &CARRCON+3
         DC    AL.3(0),AL.2(&S),AL.3(1)
         ORG
&LASTCC  SETA  &S
.DEFALTA ANOP
&TEST    SETB  0
         AGO   .DD
.AB      AIF   ('&SKIP' NE 'E').ABB
A&SYSNDX DC    X'FFFB8B00'              EJECT
         AGO   .ABC
.ABB     AIF   (&SKIP EQ &LASTCC).NOCHANG
A&SYSNDX DC    XL2'FFFB'
         DC    AL.3(0),AL.2(&SKIP),AL.3(1)
         DC    AL.3(0),AL.2(&SKIP),AL.3(1)
&LASTCC  SETA  &SKIP
&TEST    SETB  1
.ABC     ANOP
&CARRCON SETC  'A&SYSNDX'
&NRENTS  SETA  &NRENTS+1
.DD      ANOP
.NOCHANG ANOP
         MEND
         EJECT
         MACRO
         LINEND ,
.*                                 THIS MACRO IS USED ONLY BY THE LINE
.*                                 MACRO TO SET THE NUMBER OF ENTRIES
.*                                 ASSOCIATED WITH EACH LINE.
         GBLA  &BITS(2600),&DB,&DT,&INITIAL
         GBLA  &ITEMITR,&ITEMFST(20),&ITEMNBR,&ITEMMDX
         GBLA  &ITEMNDX(2600),&ITEMXPT
         GBLA  &LABELNR,&LASTCC,&LB,&LBLCTR(100),&LPTR,&LT
         GBLA  &NRENTS,&SHIFT(2600)
         GBLB  &DIAGITF,&DIAGLIN,&DIAGSET,&DIAGTST,&FSW,&TEST
         GBLC  &CARRCON,&CSECT,&DSECT,&ITEM(2600)
         GBLC  &LABELS(2600),&LBL(100),&NRENTSX
         ORG   &NRENTSX
         DC    FL1'&NRENTS'
         ORG
&NRENTS  SETA  0
B&SYSNDX EQU   *
&NRENTSX SETC  'B&SYSNDX'
         MEND
         EJECT
         MACRO
&NAME    LABEL &LABEL1,&LABEL2,&LABEL3,&LABEL4,&LABEL5,&LABEL6,        C
               &LABEL7,&LABEL8
.*                                 THIS MACRO ALLOWS LABELS TO
.*                                 BE SPECIFIED FOR A GIVEN LINE. THE
.*                                 LABELS SHOULD BE ENCLOSED IN QUOTA-
.*                                 TION MARKS. THE COLUMN AND LINE END
.*                                 CONTROLS WILL BE INSERTED BY THE
.*                                 MACRO. OMITTED OPERANDS MEAN NO
.*                                 LABEL REQUIRED FOR RESPECTIVE
.*                                 COLUMN.
         GBLA  &BITS(2600),&DB,&DT,&INITIAL
         GBLA  &ITEMITR,&ITEMFST(20),&ITEMNBR,&ITEMMDX
         GBLA  &ITEMNDX(2600),&ITEMXPT
         GBLA  &LABELNR,&LASTCC,&LB,&LBLCTR(100),&LPTR,&LT
         GBLA  &NRENTS,&SHIFT(2600)
         GBLB  &DIAGITF,&DIAGLIN,&DIAGSET,&DIAGTST,&FSW,&TEST
         GBLC  &CARRCON,&CSECT,&DSECT,&ITEM(2600)
         GBLC  &LABELS(2600),&LBL(100),&NRENTSX
         LCLC  &MARGIN,&TACK
         LCLC  &TEXT
         LCLA  &OP,&K,&START,&NRCHAR,&REMAIN
         AIF   (&INITIAL EQ 0).DIAGCLR
         AIF   (&DIAGTST EQ 0).DIAGCLR
         AIF   (&DIAGLIN EQ 1).DIAGCLR
         MNOTE '**NO LINE ASSOCIATED WITH PREVIOUS LABEL**'
***** THE FOLLOWING GENERATED FOR TEST PURPOSES *****
*        LINE
         LINE
.DIAGCLR ANOP
&DIAGSET SETB  0
&DIAGLIN SETB  0
&MARGIN  SETC  '*'
         AIF   ('&NAME' EQ '').LOOPOUT
&LPTR    SETA  &LPTR+1
&LBL(&LPTR) SETC '&NAME'
&LBLCTR(&LPTR) SETA &LABELNR+1
.LOOPOUT ANOP
&OP      SETA  &OP+1
&K       SETA  K'&SYSLIST(&OP)
         AIF (&K GE 2).NORM
&K       SETA  2
.NORM    ANOP
&START   SETA  2
         AIF (&OP LT N'&SYSLIST).NOTLAST
&MARGIN  SETC  '$'
.NOTLAST ANOP
&NRCHAR  SETA  8
&TACK    SETC  ''
.LOOPIN  ANOP
&REMAIN  SETA  &K-&START
         AIF (&REMAIN GE 8).MORE
&TACK    SETC  '&MARGIN'
&NRCHAR  SETA  &REMAIN
.MORE    ANOP
&TEXT    SETC  ''
         AIF (&REMAIN EQ 0).ENDTEXT
&TEXT    SETC  '&SYSLIST(&OP)'(&START,&NRCHAR)
.ENDTEXT ANOP
&LABELNR SETA  &LABELNR+1
&LABELS(&LABELNR) SETC '&TEXT'.'&TACK'
&START   SETA  &START+8
         AIF ('&TACK' EQ '').LOOPIN
         AIF ('&TACK' EQ '*').LOOPOUT
         MEND
         EJECT
         MACRO
&NAME    ROUTINE &LOGITEM,&RNAME
         GBLA  &BITS(2600),&DB,&DT,&INITIAL
         GBLA  &ITEMITR,&ITEMFST(20),&ITEMNBR,&ITEMMDX
         GBLA  &ITEMNDX(2600),&ITEMXPT
         GBLA  &LABELNR,&LASTCC,&LB,&LBLCTR(100),&LPTR,&LT
         GBLA  &NRENTS,&SHIFT(2600)
         GBLB  &DIAGITF,&DIAGLIN,&DIAGSET,&DIAGTST,&FSW,&TEST
         GBLC  &CARRCON,&CSECT,&DSECT,&ITEM(2600)
         GBLC  &LABELS(2600),&LBL(100),&NRENTSX
         AIF   (&DIAGTST EQ 0).NOMSG
         AIF   (&INITIAL EQ 0).NOMSG
         AIF   (&DIAGLIN EQ 1).NOMSG
         MNOTE '**NO LINE ASSOCIATED WITH THIS ROUTINE**'
*****THE FOLLOWING GENERATED FOR TEST PURPOSES*****
*        LINE
         LINE
.NOMSG   ANOP
&NAME    DC    AL.12(&LOGITEM-&DSECT),XL.4'D'
         DC    AL2(&RNAME-&CSECT)
&NRENTS  SETA  &NRENTS+1
         MEND
         EJECT
         MACRO
         ITEMFIND &ARG,&ITFDIAG=
         GBLA  &BITS(2600),&DB,&DT,&INITIAL
         GBLA  &ITEMITR,&ITEMFST(20),&ITEMNBR,&ITEMMDX
         GBLA  &ITEMNDX(2600),&ITEMXPT
         GBLA  &LABELNR,&LASTCC,&LB,&LBLCTR(100),&LPTR,&LT
         GBLA  &NRENTS,&SHIFT(2600)
         GBLB  &DIAGITF,&DIAGLIN,&DIAGSET,&DIAGTST,&FSW,&TEST
         GBLC  &CARRCON,&CSECT,&DSECT,&ITEM(2600)
         GBLC  &LABELS(2600),&LBL(100),&NRENTSX
         LCLA  &A,&B,&X,&I
         LCLC  &C1,&C2,&S
         ACTR  100000
&ITEMXPT SETA  0                  INDICATE ITEM NOT FOUND.
         AIF   ('&ARG' NE '').NORM
         AIF   ('&ITFDIAG' EQ 'OFF'  OR  '&ITFDIAG' EQ 'ON').DIAGSET
  MNOTE 0,'ITEMFIND - OPERAND (&ITFDIAG) INVALID FOR ITFDIAG KEYWORD.'
         MEXIT
.DIAGSET ANOP
&DIAGITF SETB  ('&ITFDIAG' EQ 'ON')
         MEXIT
.NORM    AIF   (&ITEMITR GT 0).SORTED
         ITEMSORT
.SORTED  ANOP
&I       SETA  &ITEMITR           COMPUTED ITTERATION COUNT.
&X       SETA  &ITEMMDX           COMPUTED MAXIMUM INDEX.
&C1      SETC  '&ARG'             ISOLATE SEARCH ARGUMENT.
&C1      SETC  '&C1'.'       '(1,8-K'&C1) PAD TO FULL 8 CHARACTERS.
.SRCHUP  ANOP
&A       SETA  &A+&X              CURRENT TABLE SUBSCRIPT + INDEX.
&S       SETC  '+'
         AIF   (&A  GT &ITEMNBR  AND  NOT &DIAGITF).SRCHDN1
         AIF   (&A  LE &ITEMNBR).SRCH00
&C2      SETC  '*-OVER-*'
&I       SETA  &I-1               DECREMENT ITTERATION COUNTER.
&X       SETA  &X/2               HALVE INDEX VALUE.
 MNOTE *,'&ARG - &C2   ITRCTR = &I   PTR = &A&S &X'
         AIF   (&I GE 0).SRCHDWN  IF ITTERATION COUNT NOT EXPIRED.
.NOFIND  MNOTE  20,' ITEMFIND FAILED FOR NAME  &C1  '
         MEXIT
.SRCH00  ANOP
&I       SETA  &I-1               DECREMENT ITTERATION COUNTER.
         AIF   (&I LT 0).NOFIND   IF COUNT HAS GONE TO ZERO.
&X       SETA  &X/2               HALVE INDEX VALUE.
&B       SETA  &ITEMNDX(&A)       GET SUBSCRIPT FROM INDEX TABLE.
&C2      SETC  '&ITEM(&B)'.'       '(1,8-K'&ITEM(&B))  PAD COMPARAND.
         AIF   (NOT &DIAGITF).COMPARE
 MNOTE *,'&ARG - &C2   ITRCTR = &I   PTR = &A&S &X   POS = &B'
.COMPARE AIF   ('&C1' LT '&C2').SRCHDWN   ARGUMENT LOWER, MOVE DOWN.
         AIF   ('&C1' GT '&C2').SRCHUP    ARGUMENT HIGHER, MOVE UP.
&ITEMXPT SETA  &B                 FOUND. SET INDEX POINTER FOR RETURN.
&ITEMFST(&I+1)  SETA  &ITEMFST(&I+1)+1
         MEXIT
.SRCHDWN ANOP
&A       SETA  &A-&X              CURRENT POINTER MINUS INDEX VALUE.
&S       SETC  '-'
         AIF   (&A LE &ITEMNBR).SRCH00    IF WITHIN BOUNDS OF TABLE.
.SRCHDN1 ANOP
&I       SETA  &I-1               DECREMENT ITTERATION COUNTER.
&X       SETA  &X/2               HALVE INDEX VALUE.
         AIF   (&I GE 0).SRCHDWN  IF ITTERATION COUNT NOT EXPIRED.
         MNOTE  20,' ITEMFIND FAILED FOR NAME  &C1  '
         MEND
         EJECT
         MACRO
         ITEMSORT  &DUMMY
         GBLA  &BITS(2600),&DB,&DT,&INITIAL
         GBLA  &ITEMITR,&ITEMFST(20),&ITEMNBR,&ITEMMDX
         GBLA  &ITEMNDX(2600),&ITEMXPT
         GBLA  &LABELNR,&LASTCC,&LB,&LBLCTR(100),&LPTR,&LT
         GBLA  &NRENTS,&SHIFT(2600)
         GBLB  &DIAGITF,&DIAGLIN,&DIAGSET,&DIAGTST,&FSW,&TEST
         GBLC  &CARRCON,&CSECT,&DSECT,&ITEM(2600)
         GBLC  &LABELS(2600),&LBL(100),&NRENTSX
         LCLA  &R,&ZI,&I,&A1,&A2,&TEMP
         LCLB  &SR,&GOTO,&TB
         LCLB  &SW(3000)
         LCLC  &C1,&C2
         ACTR  100000
&A1      SETA  0
         AIF   (&ITEMITR EQ 0).LOOP0   TEST FOR RE-ENTRY.
 MNOTE   0,'ITEMSORT MACRO OCCURRS MORE THAN ONCE. TABLE NOT RESORTED.'
         MEXIT
.LOOP0   ANOP
&A1      SETA  &A1+1
&ITEMNDX(&A1) SETA &A1
         AIF   (&A1 LT &ITEMNBR).LOOP0
         AIF   (&ITEMNBR LT 2).MEXIT
&A1      SETA  &ITEMNBR/2         HALF OF TOTAL ENTRIES.
&A2      SETA  0
.LOOP1   ANOP
&A2      SETA  &A2+1
&SW(&A2) SETB  1                  SET FIRST HALF OF SWITCHES TO 1.
         AIF   (&A2 LT &A1).LOOP1
.LOOP2   ANOP
&A2      SETA  &A2+1
&SW(&A2) SETB  0                  SET SECOND HALF TO ZERO.
         AIF   (&A2 LT &ITEMNBR).LOOP2
&R       SETA  0                  SET R TO FIRST TRIAL ITEM.
&ZI      SETA  &ITEMNBR-1         SET ZI TO LAST ITEM.
&I       SETA  &ZI-1
.T3      ANOP
&SR      SETB  (&SW(&R+1))        GET FLAG, WHICH WAY TO GO?
&R       SETA  (&R*2)+1+&SR       R=2R+(1 OR 2)
         AIF   (&R LE &I).T3
.T4      ANOP
&R       SETA  (&R-1)/2           R=(R-1)/2
&SR      SETB  (&SW(&R+1))        GET SUBTREE SELECT FLAG.
         AIF   (&SR EQ 0).T7
         AIF   (&GOTO EQ 0).T5
.T7      ANOP
&A1      SETA  &ITEMNDX(&R+1)
&A2      SETA  &ITEMNDX(&ZI+1)
&C1      SETC  '&ITEM(&A1)'.'       '(1,8-K'&ITEM(&A1))
&C2      SETC  '&ITEM(&A2)'.'       '(1,8-K'&ITEM(&A2))
         AIF   ('&C1' LT '&C2').T8
.T9      ANOP
&TEMP    SETA  &ITEMNDX(&R+1)     Z(R) TO TEMP.
&TB      SETB  (&SW(&R+1))
&ITEMNDX(&R+1) SETA &ITEMNDX(&ZI+1)    Z(I) TO Z(R)
&SW(&R+1) SETB (&SW(&ZI+1))
&ITEMNDX(&ZI+1) SETA &TEMP        TEMP TO Z(I)
&SW(&ZI+1) SETB (&TB)
&SR      SETB  (&SR EQ 0)
&SW(&R+1) SETB (&SR)
.T8      AIF   (&R GT 0).T4
&GOTO    SETB  1                  SET 'GO TO' T7
&ZI      SETA  &ZI-1
&I       SETA  &I-1
         AIF   (&I GE 0).T3
.MEXIT   ANOP
&ITEMITR SETA 1
&ITEMMDX SETA 1
.ITRLOOP ANOP
&ITEMITR SETA &ITEMITR+1
&ITEMMDX SETA &ITEMMDX+&ITEMMDX
         AIF  (&ITEMMDX LT &ITEMNBR).ITRLOOP
&ITEMITR SETA &ITEMITR-1
&ITEMMDX SETA &ITEMMDX/2
&A1      SETA &ITEMNBR
&A2      SETA &ITEMMDX
&TEMP    SETA &ITEMITR
 MNOTE *,' ITEMS = &A1, MAX INDEX = &A2, ITTERATION COUNT = &TEMP'
         MEXIT
.T5      ANOP
&TEMP    SETA  &ITEMNDX(&R+1)     Z(R) TO TEMP.
&TB      SETB  (&SW(&R+1))
&ITEMNDX(&R+1) SETA &ITEMNDX(&ZI+1)    Z(I) TO Z(R)
&SW(&R+1) SETB (&SW(&ZI+1))
&ITEMNDX(&ZI+1) SETA &TEMP        TEMP TO Z(I)
&SW(&ZI+1) SETB (&TB)
&SR      SETB  (&SR EQ 0)
&SW(&R+1) SETB (&SR)
         AGO   .T3
         MEND
         EJECT
         MACRO
         LSTART ,
.*                            THIS MACRO IS ISSUED WHEN THE LABEL AREA
.*                                 OF THE TABLE IS TO BEGIN.
         GBLA  &BITS(2600),&DB,&DT,&INITIAL
         GBLA  &ITEMITR,&ITEMFST(20),&ITEMNBR,&ITEMMDX
         GBLA  &ITEMNDX(2600),&ITEMXPT
         GBLA  &LABELNR,&LASTCC,&LB,&LBLCTR(100),&LPTR,&LT
         GBLA  &NRENTS,&SHIFT(2600)
         GBLB  &DIAGITF,&DIAGLIN,&DIAGSET,&DIAGTST,&FSW,&TEST
         GBLC  &CARRCON,&CSECT,&DSECT,&ITEM(2600)
         GBLC  &LABELS(2600),&LBL(100),&NRENTSX
         LCLA  &NDX,&CTR
         ACTR  500000
         AIF   (&DIAGTST EQ 0).NODIAG
         AIF   (&DIAGSET EQ 0).NODIAG
         MNOTE '**NO LABEL ASSOCIATED WITH LAST SET**'
***** THE FOLLOWING GENERATED FOR TEST PURPOSES *****
*        LABEL '%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'
               LABEL '%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'
.NODIAG  ANOP
         LINEND
&CTR     SETA  1
.LOOP    ANOP
&NDX     SETA  &NDX+1
         AIF   (&LBLCTR(&CTR) NE &NDX).NOLBL
&LBL(&CTR) DC  C'&LABELS(&NDX)'
&CTR     SETA  &CTR+1
         AGO   .LOOPCTL
.NOLBL   ANOP
         DC    C'&LABELS(&NDX)'
.LOOPCTL AIF   (&NDX LT &LABELNR).LOOP
         MEND
         EJECT
         MACRO
         CONVT ,
         GBLA  &BITS(2600),&DB,&DT,&INITIAL
         GBLA  &ITEMITR,&ITEMFST(20),&ITEMNBR,&ITEMMDX
         GBLA  &ITEMNDX(2600),&ITEMXPT
         GBLA  &LABELNR,&LASTCC,&LB,&LBLCTR(100),&LPTR,&LT
         GBLA  &NRENTS,&SHIFT(2600)
         GBLB  &DIAGITF,&DIAGLIN,&DIAGSET,&DIAGTST,&FSW,&TEST
         GBLC  &CARRCON,&CSECT,&DSECT,&ITEM(2600)
         GBLC  &LABELS(2600),&LBL(100),&NRENTSX
         LCLB  &SUB
         LCLA  &OP
         LCLA  &OFFSET,&OUT,&IN,&IND,&IBITS,&ISHIFT
.*
.*       CONVERT BINARY TO DECIMAL
.*             &NAME IS THE REFERENCE INTO THE DSECT RECORD
.*             &OUT    IS THE NUMBER OF CHARS TO BE PUT ONTO PRINT LINE
.*                                      DEFAULT IS FOUR MAXIMUM IS 8
.*             &IN       IS THE NUMBER OF BYTES AS INPUT
.*                                      ERROR DEFAULT IS 2 MAXIMUM IS 4
.*
         AIF   (&DIAGTST EQ 0).NOMSG
         AIF   (&INITIAL EQ 0).NOMSG
         AIF   (&DIAGLIN EQ 1).NOMSG
         MNOTE '**NO LINE ASSOCIATED WITH THIS DATA**'
*****THE FOLLOWING GENERATED FOR TEST PURPOSES*****
*        LINE
         LINE
.NOMSG   ANOP
         AIF   (K'&SYSLIST(1) EQ K'&SYSLIST(1,1)).LLOP
&SUB     SETB  1
.LLOP    ANOP
&OP      SETA  &OP+1
&OUT     SETA  4                        .BR NOT NULL ELSE SET TO 4
         AIF   (&SUB EQ 1).SUBA
         AIF   ('&SYSLIST(3)' EQ '').B  TEST FOR NULL INPUT
&OUT     SETA  &SYSLIST(3)             SET &OUT FROM INPUT
         AGO   .A
.SUBA    AIF   ('&SYSLIST(&OP,3)' EQ '').B
&OUT     SETA  &SYSLIST(&OP,3)          SET &OUT FROM INPUT
.A       AIF   (&OUT GT 0 AND &OUT LT 9).B   TEST RANGE
.AERR    MNOTE '*** BYTES OUT INCORRECTLY SPECIFIED DEFAULT USED ***'
&OUT     SETA  4
.B       AIF   (&SUB EQ 1).SUBB
         AIF   ('&SYSLIST(2)' EQ '').LOOP    BRANCH IF NULL
&IN      SETA  &SYSLIST(2)              .SET &IN FROM INPUT
         AGO   .BB
.SUBB    AIF   ('&SYSLIST(&OP,2)' EQ '').LOOP
&IN      SETA  &SYSLIST(&OP,2)          .SET &IN FROM INPUT
.BB      AIF   (&IN GT 0 AND &IN LT 5).D     TEST RANGE
.BERR    MNOTE '*** BYTES IN INCORRECTLY SPECIFIED DEFAULT USED ***'
&IN      SETA  2
         AGO   .D
.LOOP    ANOP                           .LOOP TO FIND &NAME IN DSECT
&IND     SETA  &IND+1                   .SET UP LOOP COUNTER
         AIF   ('&ITEM(&IND)' EQ '&SYSLIST(&OP,1)').FOUND
         AIF   (&IND LT &ITEMNBR).LOOP  .TEST FOR END OF DSECT
         MNOTE '*** LOG ITEM NOT DEFINED ***'
         MEXIT
.FOUND   ANOP
&IBITS   SETA  &BITS(&IND)              .SET UP NUMBER OF BITS SPEC
         AIF   (&IBITS-((&IBITS/8)*8) EQ 0).C  .TEST FOR MULTIPLE OF 8
         MNOTE '*** DATA NOT DEFINED A MULTIPLE OF 8 BITS ***'
         MEXIT
.C       ANOP
&IN      SETA  &IBITS/8                 .COMPUTE NUMBER OF BYTES
         AIF   (&IN LT 1 OR &IN GT 4).BERR  .TEST RANGE B IF IN ERROR
&ISHIFT  SETA  &SHIFT(&IND)             .SET UP FOR TEST OF BYTE BNDR
         AIF   (&ISHIFT EQ 0).D         .TEST FOR BYTE BNDRY
         MNOTE '*** DATA NOT ALIGNED ON A BYTE BOUNDARY ***'
         MEXIT
.*
.D       ANOP
&NRENTS  SETA  &NRENTS+1
         DC    AL.12(&SYSLIST(&OP,1)-&DSECT),AL.4(9)
         DC    X'&IN',X'&OUT'
&IND     SETA  0
         AIF   (&SUB EQ 0).OUTA
         AIF   (&OP LT N'&SYSLIST).LLOP
.OUTA    ANOP
         MEND
         EJECT
         MACRO
         SUM   &LOGITEM,&MASK
.*                            THIS MACRO GENERATES A NORMAL EDIT ENTRY
.*                                 FOR PROCESSING BY THE SUMMARY MODULE
.*                            &LOGITEM - NAME OF DATA ITEM TO BE SUMMED
.*                            &MASK - BYTE MASK FOR BITS TO BE TESTED.
.*                                 THIS OPERAND SHOULD BE OMITTED FOR
.*                                 SINGLE BIT ITEMS IN WHICH CASE THE
.*                                 MASK WILL BE SET ACCORDING TO THE
.*                                 OFF BYTE BIT DISPLACEMENT OF THE
.*                                ITEM AS DEFINED BY THE MACRO 'DSGEN'
         GBLA  &COUNTR,&ITEMNBR,&BITS(2600),&SHIFT(2600)
         GBLC  &ITEM(2600),&DSECT
         LCLA  &IBITS,&NDX,&ISHIFT,&M,&BITNBR
.LOOP    ANOP
&NDX     SETA  &NDX+1
         AIF   ('&ITEM(&NDX)' EQ '&LOGITEM').FOUND
         AIF   (&NDX LT &ITEMNBR).LOOP
         MNOTE *,'LOGITEM NOT FOUND'
         MEXIT
.FOUND   ANOP
         DC    AL1(0)
&ISHIFT  SETA  &SHIFT(&NDX)
&IBITS   SETA  &BITS(&NDX)
         AIF   ('&MASK' EQ '').FORM
         DC    B'&MASK'
         AGO   .ITEM
.FORM    ANOP
&BITNBR  SETA  &ISHIFT-7
&BITNBR  SETA  0-&BITNBR
&M       SETA  1
.LOOP2   ANOP
         AIF   (&BITNBR EQ 0).GOTIT
&M       SETA  &M*2
&BITNBR  SETA  &BITNBR-1
         AGO   .LOOP2
.GOTIT   ANOP
         DC    AL1(&M)
.ITEM    DC    AL2(&LOGITEM-&DSECT)
         DC    AL2(&COUNTR)
&COUNTR  SETA  &COUNTR+1
         MEND
         EJECT
IFCSSOFT CSECT
         GBLC  &DSECT,&CSECT
&CSECT   SETC  'IFCSSOFT'
&DSECT   SETC  'RTMREC'
RTMREC   DSECT
         DSGEN (CLASSRC,8),(SYSREL,8),(,48)
         DSGEN (XDATE,32),(TIME,32)
         DSGEN (,8),(CPUSER,24),(CPUID,16),(,16)
         DSGEN (JOBID,64)
         DSGEN (,64)
         DSGEN (SDWACMKA,8),(SDWAMWPA,8),(SDWAINTA,16),(SDWAPMKA,8),   X
               (SDWANXTA,24)
         DSGEN (SDWACMKP,8),(SDWAMWPP,8),(SDWAINTP,16),(SDWAPMKP,8),   X
               (SDWANXTP,24)
         DSGEN (GR,32,0,15)
         DSGEN (SDWANAME,64)
         DSGEN (,32),(,32)
         DSGEN (SDWAEC1A,32),(SDWAEC1B,32)
         DSGEN (,8),(SDWAILC1,8),(SDWAINC1,16),(SDWATRN1,32)
         DSGEN (SDWAEC2A,32),(SDWAEC2B,32)
         DSGEN (,8),(SDWAILC2,8),(SDWAINC2,16),(SDWATRN2,32)
         DSGEN (GPR,32,0,15)
         DSGEN (SDWASPID,8),(SDWALNTH,24)
         DSGEN (SDWASCKB,32),(SDWASCKE,32)
         DSGEN (SDWASRVL,1),(SDWARCDF,1),(SDWATSVL,1),(SDWAINVP,1),    C
               (SDWARSRC,1),(SDWARSRF,1),(,2)
         DSGEN (SDWASKYF,1),(SDWAREGU,1),(SDWAPSWU,1),(SDWASCK,1),     C
               (SDWAACR,1),(SDWAINSF,1),(SDWASOFT,1),(SDWATERR,1)
         DSGEN (SDWACPID,16),(,6),(SDWAMSER,1),(SDWACHNG,1)
         DSGEN (SDWAOFLN,1),(SDWAINTC,1),(SDWASPER,1),(SDWANUCL,1),    C
               (SDWAFSQA,1),(SDWAFLSQ,1),(SDWAPGFX,1),(SDWAVEQR,1),    C
               (,16)
         DSGEN (SDWARFSA,32)
         DSGEN (DUM2,8),(SDWAYEAR,8),(SDWADAY,16),(SDWAHRS,8),         C
               (SDWAMINS,8),(SDWASECS,8),(SDWATNTH,8)
         DSGEN (SDWAMCHK,1),(SDWAPCHK,1),(SDWARKEY,1),(SDWASVCD,1),    C
               (SDWAABTM,1),(SDWASVCE,1),(SDWATEXC,1),(SDWAPGIO,1)
         DSGEN (,4),(SDWATYP1,1),(SDWAENRB,1),(SDWALDIS,1),(SDWASRBM,1)
         DSGEN (SDWASTAF,1),(SDWASTAI,1),(SDWAIRB,1),(SDWAPERC,1),     C
               (SDWAEAS,1),(,3)
         DSGEN (SDWACLUP,1),(SDWANRBE,1),(SDWASTAE,1),(SDWACTS,1),     C
               (SDWAMABD,1),(SDWARPIV,1),(SDWAMCIV,1),(,1)
         DSGEN (SDWAFMID,16)
         DSGEN (SDWAIOQR,1),(SDWAIOHT,1),(SDWANOIO,1),(SDWANIOP,1),(,4)
         DSGEN (,104)
         DSGEN (SDWARCDE,8)
         DSGEN (SDWARCRD,1),(,1),(SDWASPIN,1),(,1),(SDWAUPRG,1),       C
               (SDWAFREE,1),(,2)
         DSGEN (,3),(SDWADISP,1),(SDWAASMP,1),(SDWASALL,1),            C
               (SDWAIPRG,1),(SDWAICAT,1)
         DSGEN (SDWAIUCB,1),(SDWAILCH,1),(SDWATNCB,1),                 C
               (SDWATDNB,1),(SDWATADB,1),(SDWAOPTM,1),                 C
               (SDWACMS,1),(SDWAFLLK,1)
         DSGEN (SDWAICLW,32),(SDWAIULW,32),(SDWAILLW,32),(SDWAIPLW,32),C
               (SDWAAPLW,32),(SDWATNLW,32),(SDWATDLW,32),(SDWATALW,32),C
               (SDWAASID,16),(DUM3,16)
         DSGEN (SDWAMODN,64)
         DSGEN (SDWACSCT,64)
         ORG   SDWAMODN
         DSGEN (MODNCSCT,128)
         DSGEN (SDWAREXN,64)
         DSGEN (SDWADPLA,32)
         DSGEN (SDWADPID,8),(SDWADPT,1),(SDWADLST,1),(,4),(SDWASLST,1),C
               (,1),(,16)
         DSGEN (SDWANUC,1),(SDWASQA,1),(SDWALSQA,1),(SDWASWA,1),       C
               (SDWAGTF,1),(SDWACBS,1),(SDWAQQS,1),(,9)
         DSGEN (SDWADSAS,1),(SDWADSAH,1),(SDWADREG,1),(SDWATLPA,1),    C
               (SDWATJPA,1),(SDWADPSW,1),(SDWAUSPL,1),(,9)
         DSGEN (SDWAFRM1,32),(SDWATO1,32),(SDWAFRM2,32),(SDWATO2,32)
         DSGEN (SDWAFRM3,32),(SDWATO3,32),(SDWAFRM4,32),(SDWATO4,32)
         DSGEN (,32)
         DSGEN (SDWARCPL,224)
         DSGEN (SDWACOMP,32),(,32)
         DSGEN (SDWAVRAL,16),(SDWADPVA,8),(SDWAURAL,8),(SDWAVRA,864)
         DSGEN (MRCOUNT,8,EQU,JOBID)
IFCSSOFT CSECT
         USING *,R9
         USING RTMREC,R2
         DC    A(ENTRIES)
         DC    A(PEDIT)
REG8     DC    F'0'
SCSIZE   DC    H'1250'
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
ONE      EQU   1
L2       EQU   2
L4       EQU   4
L0       EQU   0
L8       EQU   8
L16      EQU   16
L1       EQU   1
L12      EQU   12
L9       EQU   9
L18      EQU   18
L21      EQU   21
L6       EQU   6
L32      EQU   32
L28      EQU   28
L7       EQU   7
L3       EQU   3
L5       EQU   5
L20      EQU   20
**
**       FIND THE LOW AND HIGH DATE RANGE
**
XDATE1   CLC   XDATE(L4),HEX00     DATE SPECIFIED?
         BER   R14                 NO, EXIT
         CLC   L0(L4,R3),HEX00     RECORD DATE ZERO
         BNE   XDATE2              NO, CHECK FOR LOW DATE
         MVC   L0(L4,R3),XDATE
XDATE2   CLC   XDATE(L4),L0(R3)    CHECK FOR LOW DATE
         BL    SAVELOW             GO SAVE LOW DATE
         CLC   XDATE(L4),L4(R3)    CHECK FOR HIGH DATE
         BNHR  R14                 NO, EXIT
         MVC   L4(L4,R3),XDATE     MOVE IN HIGH DATE
         BR    R14                 EXIT
SAVELOW  MVC   L0(L4,R3),XDATE     SAVE LOW DATE
         BR    R14
**
**       SEARCH FOR ROUTINE NAME AND CSECT NAME.  IF FOUND, ADD ONE
**       TO COUNTER.  IF NOT, MAKE A NEW ENTRY AND EXIT.
**
XCSECT   STM   R5,R8,REGSAVE       SAVE REGISTERS
         LA    R6,L2(R3)           STEP R6 TO FIRST NAME SECTION
         SR    R5,R5
         ICM   R5,X'3',L0(R3)      GET THE NUMBER OF ENTRIES
         BZ    FOUNDREC            NO ENTRIES, MAKE A NEW ONE.
         LR    R8,R5               COPY OF R5 FOR LOOP
         LR    R7,R3               GET START OF SECTION
         AH    R7,LASTRTN          INCRMENT TO END OF NAME SECTION
         MVC   L0(L16,R7),OTHERS   MOVE IN 'OTHERS'
         MVC   ROUTCSCT(L16),MODNCSCT SAVE ROUTINE/CSECT NAMES
FINDRTN  CLC   L0(L16,R6),ROUTCSCT IS THIS THE RIGHT ONE?
         BE    FOUNDRTN            YES, GO TOTAL
         LA    R6,L18(R6)          NO, GO TO NEXT ONE
         BCT   R8,FINDRTN          DECREMENT NUMBER OF ENTRIES.  IF NO
*                                  MORE, EXIT
         C     R5,MAXREC           AT THE END OF THE TABLE?
         BNL   FOUNDRTN            YES, TOTAL IN 'OTHERS' BUCKET
FOUNDREC LA    R5,L1(R5)           INCREMENT NUMBER OF ENTRIES
         STH   R5,L0(R3)           SAVE NUMBER OF ENTRIES
         MVC   L0(L16,R6),MODNCSCT SAVE ROUTINE NAME
FOUNDRTN LH    R7,L16(R6)          GET COUNT OF USAGE
         LA    R7,L1(R7)           INCREMENT BY ONE
         STH   R7,L16(R6)          SAVE COUNT USAGE
         LM    R5,R8,REGSAVE
         BR    R14
REGSAVE  DS    4F
MAXREC   DC    F'112'
LASTRTN  DC    H'2240'
OTHERS   DC    CL16'OTHERS'
ROUTCSCT DS    16C
HEX00    DC    XL4'00'
         SPACE 3
ENTRIES  DS    0F
         SPECIAL XDATE1,00000000,SPACE=4
         SPECIAL XCSECT,00000000,SPACE=1
         DC    X'FF'
         EJECT
PEDIT    DS    0F
&DSECT   SETC  'RTMYYY'
&CSECT   SETC  'PEDIT'
         USING *,R9
         USING RTMYYY,R2
**
**       EDIT AND PRINT SECTION
**
         DC    A(PENTRY)
         DC    CL8'IFCSSOFT'
ENTRYPTR DC    F'0'
LABELPTR DC    F'0'
*
RTMYYY   DSECT
         DS    3H                  OVERFLOW
         DSGEN (YDUMA,16),(YNOREC,16)
         DSGEN (,40),(YSER,24)
         DSGEN (YCPU,16),(,16)
         DSGEN (YLOWD,32)
         DSGEN (YHID,32)
         DSGEN (YNORTN,16)
YROUT1   EQU   *
         DSGEN (YRNAME,64)
         DSGEN (YRSCECT,64)
         DSGEN (YNUMRTN,16)
         DSGEN (YROUT,144,2,113)
*
IFCSSOFT CSECT
**
**       ESTABLISH THE CPU/SERIAL NUMBER
**
SETCPUNO STM   R5,R8,YSAVE         SAVE REGISTERS
         XC    RTNOUT,RTNOUT        RESET # ENTRIES TO PROCESS @XA17546
         SR    R5,R5               CLEAR REG 5
         ICM   R5,X'03',L0(R4)     LOAD THE CPU MODEL
         BNZ   RETURNA             EXIT IF NOT ZERO
         LA    R6,64               LOAD DISPLACEMENT
         SR    R3,R6               FIND PLACE IN PRINT LINE
         MVC   L0(L9,R3),UNIVERS   MODEL IS UNIVERSAL
         MVC   L32(L6,R3),NONE     SERIAL NUMBER IS NONE
RETURNA  LM    R5,R8,YSAVE         RESTORE REGISTERS
         BR    R14                 EXIT
**
**       SORT THE RECORDS BY ROUTINE NAME/CSECT NAME
**
SORT     STM   R5,R8,YSAVE         SAVE REGISTERS
         LH    R5,YNORTN           GET NUMBER OF ENTRIES
R5SWAP   LR    R6,R5               SAVE NUMBER OF ROUTINES
         BCTR  R6,R0               DECREMENT BY 1 FOR SORT
         LTR   R6,R6               IS THERE ANY RECORDS
         BNP   RETURNA             ZERO OR ONE RECORDS
         LA    R7,YROUT1           GET START OF RECORDS FOR SORT
         LA    R8,YROUT2           GET START OF SECOND RECORD
R6SWAP   CLC   L0(L16,R7),L0(R8)   RECORD IN SORT ORDER?
         BNH   NEXTRTN             YES, DON'T SWAP
         OI    SORTFLG,X'80'       INTERCHANGE DONE
         XC    L0(L18,R7),L0(R8)   SWAP                        @XA20333
         XC    L0(L18,R8),L0(R7)   THE                         @XA20333
         XC    L0(L18,R7),L0(R8)   RECORDS                     @XA20333
NEXTRTN  LA    R7,L18(R7)          INCREMENT TO NEXT RECORD
         LA    R8,L18(R8)          INCREMENT TO NEXT RECORD
         BCT   R6,R6SWAP           CYCLE THROUGH ALL OF THE RECORDS
         TM    SORTFLG,X'80'       ANY INTERCHANGES DONE?
         BZ    RETURNA             NO, RECORDS ARE IN SORT
         NI    SORTFLG,X'00'       YES, CYCLE BACK
         BCT   R5,R5SWAP           CYCLE THROUGH ALL OF THE RECORDS
         B     RETURNA             EXIT
**
**       ESTABLISH THE DATE AND YEAR TO PRINT LINE
**
SETDATE  UNPK  WORK(L8),L0(L4,R4)  PACK DATE
         MVC   L0(L3,R3),WORK+L5   MOVE IN DATE
         MVC   L5(L2,R3),WORK+L3   MOVE IN YEAR
         BR    R14                 EXIT
**
**       ROUTINE TO FREE THE USED SUMMARY COUNTERS
**
THEEND   STM   R14,R12,L12(R13)    SAVE REGISTERS
         LR    R12,R13             SAVE AREA POINTER
         LA    R13,FSAVE           NEXT SAVE AREA
         ST    R12,L4(R13)         POINTER
         ST    R13,L8(R12)         POINTER
         L     R3,L4(R2)             NEXT AREA
         ST    R3,L28(R12)           SAVE POINTER TO AREA
         LH    R0,SIZE               SIZE OF THE AREA TO BE FREED
         LR    R1,R2               ADDRESS OF AREA
         FREEMAIN R,LV=(0),A=(1)
         LTR   R3,R3               ANY MORE SUMMARY COUNTERS
         BZ    RETURNB             NO, EXIT
         LA    R5,PENTRY+10        YES, CYCLE FOR NEXT SET
         LA    R6,LABELS-L1        LABELS FOR NEXT SET
         STM   R5,R6,ENTRYPTR      STORE FOR LOOP BACK
RETURNB  L     R13,L4(R13)         RETORE SAVE AREA ADDRESS
         LM    R14,R12,L12(R13)    RESTORE REGISTERS
         BR    R14                 EXIT
**
**       ROUTINE TO MOVE NAMES TO PRINT LINE
**
PRTRTN   STM   R5,R8,YSAVE         SAVE REGISTERS
         SR    R5,R5               CLEAR REGISTER
         ICM   R5,X'3',YNORTN      GET NUMBER OF ROUTINES
         BZ    RETURNA             NO MORE, EXIT
         SR    R6,R6               CLEAR REGISTER
         LH    R6,RTNOUT           LOAD NUMBER OF THE ENTRY TO PROCESS
         MH    R6,DEC18            DETERMINE DISPLACEMENT
         LA    R7,YROUT1           START ADDRESS
         AR    R6,R7               SET OF ROUTINE NAME/CSECT DESIRED
         MVC   L0(L8,R3),L0(R6)    MOVE ROUTINE NAME TO PRT LINE
         MVC   L9(L8,R3),L8(R6)    MOVE CSECT NAME TO PRT LINE
         SR    R7,R7               CLEAR REGISTER
         LH    R7,L16(R6)          USAGE VALUE
         CVD   R7,WORK             CONVERT TO DECIMAL
         UNPK  L18(L3,R3),WORK+L6(L2) UNPACK VALUE
         MVZ   L20(L1,R3),L18(R3)  ESTABLISH ZONE
         SR    R6,R6               CLEAR REGISTER
         LH    R6,RTNOUT           LOAD NUMBER OF THE ENTRY TO PROCESS
         LA    R6,L1(R6)           INCREMENT ENTRY NUMBER
         STH   R6,RTNOUT           STORE FOR NEXT ENTRY
         BCTR  R5,R0               DECREMENT NUMBER TO PROCESS
         STH   R5,YNORTN           STORE VALUE
         B     RETURNA             EXIT
**
**       CYCLE BACK ROUTINE FOR NEXT ROUTINE NAME
**
GOBACK   STM   R5,R8,YSAVE         SAVE REGISTERS
         SR    R5,R5               CLEAR REGISTER
         ICM   R5,X'3',YNORTN      GET NUMBER OF ROUTINES TO PROCESS
         BZ    RETURNA             NO MORE,EXIT
         LA    R5,PRTLINE-L4       MORE,CHANGE NEXT LINE TO PROCESS
         LA    R6,PRTLABEL-L1      CHANGE NEXT LABEL TO PROCESS
         STM   R5,R6,ENTRYPTR      STORE FOR CYCLE BACK
         B     RETURNA             EXIT
**
WORK     DS    0D
FSAVE    DS    18F
YSAVE    EQU   FSAVE
SIZE     DC    H'2302'
RTNOUT   DC    H'0'
DEC18    DC    H'18'
SORTFLG  DC    X'00'
UNIVERS  DC    C'UNIVERSAL'
NONE     DC    C'NONE'
         EJECT
PENTRY   DS    0F
         DC    X'00010001'
         DC    X'00010001'
         DC    A(LABELS)
         DC    H'0'
         DC    X'01'
         DC    X'000B8B00'         SKIP TO CHANNEL 1
         LABEL
         LINE  (1,1),(1,1),SKIP=2
         LABEL ' '
         LINE  (57,32),(23,26)
         HEX   YCPU,0,2B
         HEX   YSER,0,3B
         ROUTINE YCPU,SETCPUNO
         LABEL 'DAY YEAR   DAY YEAR','MODEL-','SERIAL NO.'
         LINE  (23,11),(1,30)
         ROUTINE YLOWD,SETDATE
         ROUTINE YHID,SETDATE
         LABEL 'SOFTWARE DATE RANGE -','TO'
         LINE  ,(1,1),SKIP=1
         LABEL ' '
         LINE  ,(40,1),SKIP=1
         LABEL 'SUMMARY OF SOFTWARE ENVIRONMENT RECORDS'
         LINE  (29,),(1,1),SKIP=2
         CONVT YNOREC,2,4
         LABEL 'TOTAL NUMBER OF RECORDS'
         LINE
         LABEL ' '
         LINE  ,(3,25),SKIP=1
         ROUTINE YNORTN,SORT
         LABEL 'ROUTINE  CSECT  NUMBER','ROUTINE  CSECT  NUMBER','ROUTI*
               NE  CSECT  NUMBER','ROUTINE  CSECT  NUMBER'
         LINE  ,,SKIP=1
         LABEL ' NAME    NAME  ENTRIES',' NAME    NAME  ENTRIES',' NAME*
                   NAME  ENTRIES',' NAME    NAME  ENTRIES'
         LINE  ,,SKIP=1
         LABEL ' '
PRTLINE  LINE  (3,25),(1,1)
         ROUTINE YNORTN,PRTRTN
         ROUTINE YNORTN,PRTRTN
         ROUTINE YNORTN,PRTRTN
         ROUTINE YNORTN,PRTRTN
         ROUTINE YNORTN,GOBACK
PRTLABEL LABEL ' '
         LINE  ,,SKIP=1
         ROUTINE YDUMA,THEEND
         LABEL ' '
         DC    X'FF'
         DC    X'0000'
         DC    X'0000'
         DC    X'0000'
         DC    C'$'
LABELS   EQU   *
         LSTART
         END
