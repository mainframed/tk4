         TITLE 'GVARC-CIRCULAR ARC GENERATION ROUTINE(WITH VECTORS)'  *
*STATUS. CHANGE LEVEL 0                                               *
*                                                                     *
*FUNCTION/OPERATION. GVARC GENERATES THE GRAPHIC ORDER AND DATA TO    *
*   DISPLAY A CIRCLE OR ARC, OR A POLYGON OR SEGMENT OF POLYGON ON    *
*   THE DISPLAY UNIT SCREEN AND STORES THEM IN THE GRAPHIC DATA OUTPUT*
*   AREA-(GDOA)                                                       *
*                                                                     *
*ENTRY POINTS.GVARC VIA CALL OR LINK MACRO  ALIAS NAME IFFPFAVA       *
*                                                                     *
*INPUT.OUTPUT CONTROL BLOCK POINTER(OCBP) AND A PARAMETER TABLE       *
*   WHICH CONTAINS PARAMETERS REQUIRED BY GVARC                       *
*                                                                     *
*OUTPUT.A GRAPHIC ORDER GEVM TO CAUSE DISPLAY UNIT ENTERING INTO      *
*   VECTOR MODE AND A SERIES OF DATA BYTES WHICH CONTAIN THE X,Y      *
*   COORDINATES OF THE END POINTS OF THE IMAGE. THE OUTPUT OF THIS    *
*   ROUTINE IS STORED IN GDOA                                         *
*                                                                     *
*EXTERNAL ROUTINES. GOFFSG ROUTINE WILL BE USED WHENEVER NEEDED       *
*                                                                     *
*EXITS-NORMAL.COMPLETION OF TASK EXIT VIA RETURN MACRO                *
*     -ERROR.HEXADECIMAL 4,12,16,20,24,28,AND 32(WHEN OFF-SCREEN ONLY)*
*   IN REG 15 RETURN IMMEDIATELY. EXIT VIA RETURN MACRO               *
*     -ERROR.HEXADECIMAL 32(WHEN NOT OFF-SCREEN),40,44,48 IN REG 15   *
*   DO NOT RETURN IMMEDIATELY. UPON COMPLETION OF TASK,RETURN VIA     *
*   RETURN MACRO                                                      *
*                                                                     *
*TABLES/WORK AREAS. USER SPECIFIED PARAMETER TABLE,XYLIM TABLE AND    *
*   WORK AREA                                                         *
*                                                                     *
*ATTRIBUTES.READ ONLY,REENTRANT                                       *
*                                                                     *
IFFPFAVA CSECT                          GVARC
*0669                                                              7468
         ENTRY GVARC
GVARC    SAVE  (14,12),T,*              SAVE REGISTERS
         BALR  9,0
         USING *,9
         SR    NPAREG,NPAREG            INIT  NO.OF POINTS ATTEMPTED
*
*   INITIALIZATION
*
MAINRT   L     WRKREG,0(0,1)            GET OCBP ADDRESS
         L     PATREG,4(0,1)            GET PARTAB ADDRESS
         USING PARTAB,PATREG
         L     WKAREG,4(0,WRKREG)       GET WORKAREA ADDRESS
         USING WKAREA,WKAREG
         L     OABREG,0(WRKREG)         GET OACB ADDRESS
         ST    OABREG,WOACB
         L     XYLREG,XYLIM             LOAD XYLIM ADDR INTO XYLREG
         USING XYLIMTB,XYLREG
*  SAVE MASK BITS AS SET BY USER
         ST    9,MASKSV
         SR    WRKREG,WRKREG
         SPM   WRKREG
         MVC   WUC,UC                   SAVE UC VC FOR WORKING
         MVC   WVC,VC
         MVC   WR,RU                    SAVE RADIUS FOR WORKING
         MVC   WALPHA,ALPHA             SAVE ALPHA FOR WORKING
         MVC   GOFFSGAD,ZERO            ZERO OUT GOFFSG ADDR AREA
         SR    15,15                    CLEAR ERROR CODE REGISTER
         ST    15,ERRCOUNT              CLEAR ERROR COUNT
         BAL   LINREG,XYLCHK
*
*   TEST OFF S/G OPTION SPECIFIED AND DECIDE BOUNDARY TO BE OBSERVED
*
TESTSG   CLI   SG,C'A'                  IS OPTION A SPECIFIED
         BE    MVGRDLIM                 IF YES USE GRID LIMITS
         CLI   SG,C'B'                  IS OPTION B SPECIFIED
         BE    MVSCRLIM                 IF YES USE SCREEN LIMITS
         CLI   SG,C'C'                  IS C OPTION SPECIFIED
         BE    MVGRDLIM                 IF YES USE GRID LIMITS
         CLI   SG,C'D'                  IS D OPTION SPECIFIED
         BE    MVGRDLIM                 IF YES USE GRID LIMITS
         CLI   SG,C'E'                  IS E OPTION SPECIFIED
         BE    MVSCRLIM                 IF YES USE SCREEN LIMITS
         BAL   LINREG,ERR40             OTHERWISE INPUT ERROR ASSUME E
MVSCRLIM LA    WRKREG,SCRCHK            GET SCREEN CHECK RT ADDR
         ST    WRKREG,WRTADDR           STORE THE ROUTINE ADDR USED
         LA    WRKREG,ZERO              GET SCREEN LIMITS START ADDR
         ST    WRKREG,SABL              STORE THE ADDRESS AT SABL
         B     TESTF
MVGRDLIM LA    WRKREG,GRDCK             LOAD GRID CHECK RT ADDR
         ST    WRKREG,WRTADDR           STORE THE ROUTINE ADDR USED
         ST    XYLREG,SABL              STORE GRID LIMITS ADDR
TESTF    CLI   F,C'F'                   TEST FOR FLOAT
         BE    FLTRT
         CLI   F,C'B'                   TEST FOR FIX
         BE    TESTSC
         BAL   LINREG,ERR40
TESTSC   CLI   S,C'S'                   TEST FOR SCALING
         BE    SCALFIX
         CLI   S,C'N'                   TEST FOR NO SCALING
         BE    TESTIN
         BAL   LINREG,ERR40
         B     TESTIN
FLTRT    CLI   S,C'S'                   TEST FOR SCALING
         BE    SCALFLT
         CLI   S,C'N'                   TEST FOR NO SCALING
         BE    FCONVERT
         BAL   LINREG,ERR40
         B     FCONVERT
*
*   TEST OTHER INPUT PARAMETERS
*
TESTIN   SR    NPAREG,NPAREG            INITIATE PT COUNT
         C     NPAREG,WR                COMPARE RADIUS TO ZERO
         BNL   ERR20RET       IF NEGATIVE OR ZERO SET ERROR CODE
         CH    NPAREG,THETA             COMPARE ZERO TO THETA
         BH    ERR20RET
         CH    NPAREG,GAMMA
         BH    ERR20RET
         CLI   INC,C'D'                 TEST IF INC=D
         BE    TESTD                     IF SO TEST DENSITY FIELD
         CLI   INC,C'A'                 TEST IF INC=A
         BE    TESTA                     IF SO TEST ALPHA FIELD
         B     ERR20RET
*
*   MAIN ROUTINE
*
TESTD    CH    NPAREG,DENSITY           COMPARE ZERO TO DENSITY
         BH    ERR20RET                 IF NEGTIVE GO TO SET ERRORCODE
         L     WRKREG,FOUR
         CH    WRKREG,DENSITY           COMPARE FOUR TO DENSITY
         BH    COMALP                   GO TO COMPUTE ALPHA AS D IS 0-3
CONVRD   L     MPCREG,C360              CONVERT DENSITY TO ALPHA
         MH    MPCREG,DENSITY           DENSITY*360
         SRDA  MPCREG,32
         SLDA  MPCREG,28
         D     MPCREG,TWOPI
         SR    MPCREG,MPCREG
         D     MPCREG,WR                DIVIDED BY RADIUS
         SLA   MPCREG,1                 SHIFT TO DOUBLE THE REMAINDER
         C     MPCREG,WR
         BL    CHECK                    NO ROUNDING IF 2*REMAINDER LT R
        A     PRDREG,ONE                ROUND BY ADD ONE TO QUOTIENT
CHECK    C     PRDREG,ZERO              CHECK VALIDITY OF RESULT
         BL    ERR20RET
         BE    SETALP
         STH   PRDREG,WALPHA            SAVE COMPUTED ALPHA
         B     ALPRECK
TESTA    CH    NPAREG,ALPHA             COMPARE ALPHA TO ZERO
         BH    ERR20RET                 IF NEGTIVE GO TO SET ERRORCODE
         BNE   ALPRECK
COMALP   LA    DVDREG,345                IF YES COMPUTE ALPHA
         C     DVDREG,WR
         BL    SETALP                    OTHERWISE
         SRDA  DVDREG,32(0)
         D     DVDREG,WR
         STH   QUOREG,WALPHA            SAVE COMPUTED ALPHA
ALPRECK  LH    WRKREG,WALPHA            GET ALPHA
         C     WRKREG,C360              COMPARE ALPHA TO 360
         BH    ERR20RET                 IF OVER 360 GO TO SET ERRCODE
         B     STOEVM
SETALP   L     WRKREG,ONE               SET ALPHA TO ONE
         STH   WRKREG,WALPHA            STORE ALPHA
STOEVM   STM   2,12,PORSAVE             STORE REGISTERS
         MVC   GOMODE,EVM
         LA    CNTREG,2                 PASSING BYTE NUMBER
         LA    ADDREG,EVM                       GEVM ADDRESS
         L     OABREG,WOACB             GET OACB ADDR SAVED
         BAL   LINREG,STORE
         LM    2,12,PORSAVE             RESTORE REGISTERS
         MVI   BMSWITCH,X'11'           SET BEAM SWITCH OFF
TESTGM   LH    DVDREG,GAMMA             SEE IF GAMMA ZERO
         CH    DVDREG,ZERO               IF YES
         BE    ONEPT                      THIS IS ONE POINT PLOTTING
         SRDA  DVDREG,32(0)
         D     DVDREG,C360                COMPUTE GAMMA(MOD 360)
         C     DVDREG,ZERO              CHECK IF GAMMA(MOD 360) ZERO
         BNE   ARCRT                     IF NOT IT IS AN ARC
         L     GMREG,C360                IF YES SET GAMMI=360 (CIRCLE)
         B     PROCEED
ONEPT    SR    GMREG,GMREG              GAMMI=0 IF ONE POINT
         B     PROCEED
ARCRT    LR    GMREG,DVDREG             GAMMI=GAMMA(MOD 360)
PROCEED  LH    DVDREG,THETA             GET THETA
         SRDA  DVDREG,32(0)
         D     DVDREG,C360              COMPUTE THET=THETA(MOD 360)
         AR    GMREG,DVDREG              GAMM=GAMMI+THET
         STH   GMREG,WGAMMA
         STH   DVDREG,WTHETA            SAVE INITIAL THETA
         STH   DVDREG,WDELTA            SAVE INITIAL THETA AS DELTA
DTENTRY  SRDA  DVDREG,32
         D     DVDREG,C90               COMPUTE THET(MOD 90)
         SLA   QUOREG,1
         C     DVDREG,ZERO               IS THET=K TIMES 90
         BNE   COMPXYI                   IF NOT GO TO COMPUTE XYI
         C     QUOREG,ZERO               IF YES ASSIGN XI YI VALUES
         BNE   TESTG2                     DEPENDING ON QUADRANT
         MVC   WXI,WR                   FOR ZERO DEGREE
         MVC   WYI,ZERO                 XI=R,YI=0
         B     FDENTRY                  GO TO FORM DATA
TESTG2   C     QUOREG,TWO
         BNE   TESTH2
         MVC   WXI,ZERO                 FOR 90 DEGREE
         MVC   WYI,WR                    XI= 0,YI=R
         B     FDENTRY
TESTH2   C     QUOREG,FOUR
         BNE   SETXYI
         L     WRKREG,WR                FOR 180 DEGREE
         LNR   XREG,WRKREG               XI=-R  YI=0
         ST    XREG,WXI                 SAVE COMPUTED XI
         MVC   WYI,ZERO                  SET YI=0
         B     FDENTRY
SETXYI   MVC   WXI,ZERO                 FOR 270 DEGREE
         L     WRKREG,WR                 XI=0 YI=-R
         LNR   YREG,WRKREG
         ST    YREG,WYI
         B     FDENTRY
COMPXYI  C     QUOREG,ZERO              CHECK IF THET IN 1ST OR 3RD Q
         BC    8,NORMAL                  IF YES GO TO NORMAL ROUTINE
         C     QUOREG,FOUR
         BC    8,NORMAL
         L     WRKREG,C90
         SR    WRKREG,DVDREG
         LR    DVDREG,WRKREG
         STH   DVDREG,WTHETA
NORMAL   C     DVDREG,C45               COMPARE THET TO 45
         BH    OVER45
         LR    WRKREG,DVDREG            LOAD THET TO WK REG
         MH    WRKREG,PLUS4
         LH    XREG,TABLE+2(WRKREG)    GET  COS(THET)
         SRDA  XREG,32
         M     XREG,WR                  XI=R*COS(THET)
         A     PRDREG,C8192            ROUND TO THE NEAREST INTEGER
         SRA   PRDREG,14
         MH    PRDREG,CSIGN(QUOREG)
         ST    PRDREG,WXI               SAVE XI
         L     YREG,TABLE(WRKREG)
         SRDA  YREG,48
         M     YREG,WR                  YI=R*SIN(THET)
         A     PRDREG,C8192            ROUND TO THE NEAREST INTEGER
         SRA   PRDREG,14
         MH    PRDREG,SSIGN(QUOREG)
         ST    PRDREG,WYI               SAVE YI
         B     FDENTRY                  GO TO FORM XY DATA
OVER45   LR    WRKREG,DVDREG            ROUTINE FOR THET OVER 45
         MH    WRKREG,MINUS4
         L     XREG,TABLE+360(WRKREG)
         SRDA  XREG,48
         M     XREG,WR                  XI=R*COS(THET)
         A     PRDREG,C8192            ROUND TO THE NEAREST INTEGER
         SRA   PRDREG,14
         MH    PRDREG,CSIGN(QUOREG)
         ST    PRDREG,WXI               SAVE XI
         LH    YREG,TABLE+362(WRKREG)
         SRDA  YREG,32
         M     YREG,WR
         A     PRDREG,C8192            ROUND TO THE NEAREST INTEGER
         SRA   PRDREG,14
         MH    PRDREG,SSIGN(QUOREG)
         ST    PRDREG,WYI               SAVE YI
FDENTRY  A     NPAREG,ONE
         L     WRKREG,WXI               COMPUTE X=XI&XC
         A     WRKREG,WUC
SAVEX    ST    WRKREG,COMPUX            SAVE COMPUTED X
         STH   WRKREG,BUILDXY           SAVE SIGNIFICANT PORTION OF X
         L     WRKREG,WYI               COMPUTE Y=YI&YC
         A     WRKREG,WVC
         ST    WRKREG,COMPUY            SAVE COMPUTED Y
         STH   WRKREG,BUILDXY+2         SAVE SIGNIFICANT PART OF Y
         CLI   BMSWITCH,X'11'           SEE IF THIS IS FIRST PT
         BE    FIRSTPT                  IF YES GO TO FIRST PT SUBRT
         MVC   PT1SW(1),OFFSW           SAVE PREVIOUS SW STATUS
         MVC   PREVPT(8),CURPT
         MVC   CURPT(8),COMPUX          UPDATE PT2
         L     WRKREG,WRTADDR           GET BOUNDARY CHECK RT ADDRESS
         BALR  LINREG,WRKREG             AND BRANCH TO CHECK
         CLC   SWSTATUS,STATUS1         CHECK THE SWS STATUS IF STATUS1
         BE    FILGDOA                  BOTH PTS OK GO TO FILL GDOA
OPTIONA  CLI   SG,C'A'                  OTHERWISE OFFSG CONDITION EXIST
         BNE   OPTIONB                   CHECK USER-SPECIFIED OPTION
         BAL   LINREG,ERR44             IF A OPTION SET ERR CODE AND
         B     ANALOFF                   ANALIZE OFF STATUS TO HANDLE
OPTIONB  CLI   SG,C'B'                  IS B OPTION SPECIFIED
         BNE   OPTIONC                  IF NOT TEST FOR C
         BAL   LINREG,ERR48             IF YES SET ERR CODE AND
         B     ANALOFF                   ANALIZE OFF STATUS TO HANDLE
OPTIONC  CLI   SG,C'C'                  IS C OPTION SPECIFIED
         BNE   OPTIOND                  IF NOT TEST FOR D
         BAL   LINREG,SCRCHK            IF YES FURTHER CHECK IF THE PT
         CLI   OFFSW,X'11'               OFF SCREEN
         BE    ERR32RET                 IFF OFF SCREEN IMMEDIATE RET
         LA    15,32                    OTHERWISE SET ERROR CODE AND
         BAL   LINREG,ERRCNT             CONTINUE THE JOB
         BAL   LINREG,GRDCK             RESTORE THE PT STATUS
         B     ANALOFF                  GO TO ANALIZE OFF STATUS
OPTIOND  CLI   SG,C'D'                  IS OPTION D SPECIFIED
         BNE   ASSUMEE                  IF NOT ASSUME OPTION E
         B     ERR28RET                 IMMEDIATE ERROR RETURN
ASSUMEE  B     ERR32RET                 IMMEDIATE ERROR RETURN
FIRSTPT  MVC   CURPT(8),COMPUX          PLACE FIRST PT AS CURRENT PT
         MVI   BMSWITCH,X'00'           RESTORE THE BEAM SW
         L     WRKREG,WRTADDR           GET BOUNDARY CHECK RT ADDR
         BALR  LINREG,WRKREG            GO TO CHECK PT VALIDITY
         CLI   OFFSW,X'11'              IS THE PT OFF BOUNDARY
         BE    FIRSTOUT                 IF SO GO TO FIRSTOUT HANDLING
         L     WRKREG,COMPUX            IF WITHIN LIMITS BLANK BEAM
         A     WRKREG,C16384
         STH   WRKREG,BUILDXY           PUT BLANKED X TO XY BUILDAREA
         B     FILGDOA                  BRANCH TO FILL GDOA
FIRSTOUT CLI   SG,C'A'                  IS OPTION A SPECIFIED
         BNE   CKFORB                   IF NOT GO TO CHECK FOR B
         BAL   LINREG,ERR44             IF A OPTION GO TO SET ERRORCODE
         B     CKENTRY                   AND CONTINUE THE JOB
CKFORB   CLI   SG,C'B'                  IS OPTION B SPECIFIED
         BNE   CKFORC                   IF NOT GO TO CHECK FOR C
         BAL   LINREG,ERR48             IF B SPECIFIED SET ERROR CODE
         B     CKENTRY                   AND CONTINUE THE JOB
CKFORC   CLI   SG,C'C'                  IS C OPTION SPECIFIED
         BNE   OPTIOND                  IF NOT GO TO OPTION D TEST
         BAL   LINREG,SCRCHK            IF C OPTION TEST IF OFF SCREEN
         BE    ERR32RET                 IF OFF SCREEN IMMEDIATE RETURN
         LA    15,32                    OTHERWISE SET ERROR CODE
         BAL   LINREG,ERRCNT            UPDATE ERROR COUNT
         MVI   OFFSW,X'11'              RESTORE OFF BOUNDARY STATUS
         B     CKENTRY                  CONTINUE THE JOB
ANALOFF  STM   13,0,PORSAVE             SAVE REGISTERS
         ST    13,OVFSAVE+4             SAVE POR SAVEAREA CHAINING ADDR
         ST    15,SVR15                 SAVE ERROR REGISTER
         LA    13,OVFSAVE               LOAD GOFFSG RT SAVEAREA ADDR
         LR    WRKREG,1                 SAVE REG1-WKAREA POINTER
         CLC   GOFFSGAD,ZERO            CHECK IF GOFFSG RT ADDR AREA 0
         BNE   OFFHDLG                  IF NOT RT BROUGHT IN GO TO HDL
         LA    1,SABL                   LOAD 24-WORD PARTAB START ADDR
         LOAD  EP=GOFFSG                RETAIN THE MODULE
         LR    1,WRKREG                 RESTORE REGISTER 1
         ST    0,GOFFSGAD               SAVE GOFFSG RT ADDRESS
OFFHDLG  L     15,GOFFSGAD              LOAD GOFFSG RT ADDRESS
         LA    1,SABL                   LOAD 24-WORD PARTAB ADDR
         BALR  14,15                    BRANCH TO GOFFSG RT
         LR    1,WRKREG                 RESTORE REG 1
LINKOUT  LM    13,0,PORSAVE             RESTORE REG 13 TO 0
         L     15,SVR15                 RESTORE ERROR REGISTER
*   ANALIZE THE RESPONSE OF GOFFSG ROUTINE AND GENERATE PROPER DATA
ANALRES  CLC   NI,ZERO                  IS NI=0
         BE    NOINTS                   IF SO GO TO NO INTERSECT RT
         CLC   NI,ONE                   IS NI=1
         BE    ONEINTS                  IF SO GO TO ONE INTERSECT RT
BOTHOUT  LH    WRKREG,INTS1             OTHERWISE GDV I1X,I1Y,B
         A     WRKREG,C16384             AND GDV I2X,I2Y,U
         STH   WRKREG,INTS1             STORE THE BEAM BLANKED I1X
         STM   2,12,PORSAVE             THEN SAVE REGISTERS
         LA    CNTREG,8                 LOAD BYTE NUMBER
         LA    ADDREG,INTS1             LOAD I1 I2 STARTING ADDR
         B     STOREP                   BRANCH TO STORING POINT
NOINTS   CLC   SWSTATUS,STATUS2         SEE IF PT1 OFF PT2 ON
         BE    NOINTSA                  IF SO IT'S NO INTS CONDITION A
         B     CKENTRY                  CONTINUE THE JOB
NOINTSA  LH    WRKREG,BUILDXY           GET BUILT X
         A     WRKREG,C16384            BLANK THE BEAM BIT
         STH   WRKREG,PRIORXY           STORE TO WKAREA PRIOR TO BLDXY
         MVC   PRIORXY+2(2),BUILDXY+2   PUT Y2 IN
LOADATA  STM   2,12,PORSAVE             SAVE REGISTERS
         LA    CNTREG,8                 LOAD BYTE NUMBER
         LA    ADDREG,PRIORXY           GDV X2,Y2,B AND X2,Y2,U ADDR
         B     STOREP
ONEINTS  CLC   SWSTATUS,STATUS2         SEE IF PT1 OFF PT2 ON
         BE    ONEINTSA                 IF SO GO TO ONE INTS CONDITIONA
         CLC   SWSTATUS,STATUS3         SEE IF PT1 ON PT2 OFF
         BE    ONEINTSB                 IF SO GO TO ONE INTS CONDITIONB
         B     BOTHOUT
ONEINTSA LH    WRKREG,INTS1             GENERATE GDV I1X,I1Y,B
         A     WRKREG,C16384
         STH   WRKREG,PRIORXY
         MVC   PRIORXY+2(2),INTS1+2     IS IMMEDIATELY BEFORE BUILDXY
         B     LOADATA                  BRANCH TO LOAD DATA
ONEINTSB MVC   BUILDXY(4),INTS1         GENERATE GDV I1X,I1Y,U
FILGDOA  STM   2,12,PORSAVE
         LA    CNTREG,4                 LOAD BYTE NUMBER
         LA    ADDREG,BUILDXY
STOREP   L     OABREG,WOACB
         BAL   LINREG,STORE             BRANCH AND LINK TO STORE RT
         LM    2,12,PORSAVE
CKENTRY  LH    DELREG,WDELTA            GET DELTA
         CH    DELREG,WGAMMA            COMPARE DELTA TO GAMMA
         BE    RET                      IF EQUAL JOB IS COMPLLETED
         AH    DELREG,WALPHA            ADD ALPHA
         STH   DELREG,WDELTA            STORE DELTA
         CH    DELREG,WGAMMA            COMPARE DELTA TO GAMM
         BC    12,NEWTHET                IF LE COMPUTE NEW THET
         MVC   WDELTA,WGAMMA            SET DELTA=GAMM
         LH    DELREG,WDELTA
NEWTHET  LR    DVDREG,DELREG            LOAD DELT TO DIVIDEND REG
         SRDA  DVDREG,32
         D     DVDREG,C360              THET NOT OVER 360
         STH   DVDREG,WTHETA
         B     DTENTRY
RET      CLC   GOFFSGAD,ZERO            WAS GOFFSG ROUTINE BROUGHT IN
         BE    RET1
         ST    15,SVR15                 SAVE ERROR REGISTER
         LR    WRKREG,1                 SAVE REGISTER 1
         DELETE EP=GOFFSG
         LR    1,WRKREG                 RESTORE REGISTER 1
         L     15,SVR15                 RESTORE ERROR REGISTER
RET1     LA    WRKREG,1
         C     WRKREG,ERRCOUNT
         BL    SETBIT
* RESTORE PROGRAM MASK TO SETTING UPON ENTRY
RETMACRO L     WRKREG,MASKSV
         SPM   WRKREG
         RETURN (14,12),T,RC=(15)
SETBIT   O     15,MZERO
         B     RETMACRO
*
* STORE GRAPHIC DATA IN GDOA FOR POR
* INPUT TO SUBROUTINE
*   CNTREG = NUMBER OF BYTES OF GRAPHIC DATA TO STORE
*   ADDREG = ADDRESS OF THE GRAPHIC DATA
*   WKAREG = REGISTER 1 MUST CONTAIN THE WORKAREA ADDRESS
*   OABREG = ADDRESS OF OACB
STORE    SR    PASREG,PASREG            CLEAR OVERFLOW PASS INDICATOR
STORE1   L     OLPREG,16(0,OABREG)      ADDRESS OF OLP FROM OACB
         LR    WRKREG,CNTREG            LOAD BYTES TO MOVE
*
* CALCULATE ADDRESSES BASED ON N VALUE AND SIZE OF GDOA
*
STORE2   AR    OLPREG,WRKREG            OLP ADDRESS PLUS N VALUE
         LA    TEMREG,4
         AR    TEMREG,OLPREG            OLP PLUS N PLUS 4
         L     SLOREG,0(OABREG)         SLOA ADDRESS
         A     SLOREG,4(OABREG)         ADD LOA EQUALS TOTAL GDOA
         CR    TEMREG,SLOREG
         L     OLPREG,16(0,OABREG)      RESET INITIAL OLP ADDRESS
         BC    12,OK                    ROOM FOR DATA
*
* NOT ENOUGH ROOM TO STORE ALL OF THE DATA-DETERMINE AMOUNT TO STORE
*
         SR    TEMREG,SLOREG            EQUAL BYTES-CAN'T STORE
         SR    WRKREG,TEMREG            NUMBER OF BYTES CAN STORE
*
* ANY BYTES TO STORE
*
         C     WRKREG,ZERO
         BC    12,STORE4                LESS OF EQUAL TO ZERO
         LH    TEMREG,H2A02
         CH    TEMREG,GOMODE
         BH    STORE3A
         LH    TEMREG,H0003
         NR    TEMREG,WRKREG
         BM    STORE4      GO TO USER OVERFLOW ROUTINE (FAVA)      7468
STORE3A  SR    CNTREG,WRKREG       BYTES REMAINING
         BAL   INTLNK,STORE6            LINK INTERNALLY
STORE3   LA    PASREG,1                 SET PASS INDICATOR
*
* STORE REGISTERS IN WORKAREA
*
         STM   0,15,OVFSAVE             SAVE REGISTERS
         CLC   GOFFSGAD,ZERO            WAS GOFFSG BROUGHT IN
         BE    LAOVFLO                  IF SO GO TO OVERFLOW HDLG
         SR    WRKREG,WRKREG
         ST    WRKREG,GOFFSGAD          CLEAR GOFFSG ROUTINE ADDR
         LR    3,1                      SAVE REG 1.
         DELETE EP=GOFFSG
         LR    1,3                      RESTORE REG 1.
LAOVFLO  L     15,8(0,OABREG)           LOAD OVERFLOW ADDRESS
         LM    2,12,28(13)              RESET USERS REGISTERS
         BALR  14,15                    LINK TO ROUTINE-SET RETURN
         LM    0,15,OVFSAVE             RELOAD AND CONTINUE TO STORE
         B     STORE1                   GET NEW OLP ADDRESS-CONTINUE
*
* NO SPACE AVAILABLE
*
*
STORE4   C     PASREG,ONE               WAS A TRANSFER TO OVERFLOW MADE
         BC    4,STORE3                 NO
*
* SET ERROR CODE AND RETURN TO POR-LEAVE POR WITH RETURN MACRO
*
         LA    15,24                    SET ERROR CODE
         B     RET                      SYMBOLIC IN POR
*
*
OK       BAL   INTLNK,STORE6            LINK INTERNALLY
         BR    LINREG
STORE6   LA    TEMREG,255               SET REG. EQUAL TO 255
STORE6A  CR    WRKREG,TEMREG            IS AMOUNT TO MOVE OVER 255
         BC    2,STORE7                 YES
         LR    TEMREG,WRKREG
         S     TEMREG,ONE               COMPENSATE FOR EXTRA BYTE
         EX    TEMREG,MOVE              MOVE GRAPHIC DATA
         AR    OLPREG,WRKREG            UPDATE OLP ADDRESS
         AR    ADDREG,WRKREG            UPDATE DATA ADDR
         ST    OLPREG,16(0,OABREG)      STORE NEW OLP ADDRESS
         BR    INTLNK                   RETURN INTERNALLY
STORE7   LR    SLOREG,TEMREG
         S     SLOREG,ONE               COMPENSATE FOR EXTRA BYTE
         EX    SLOREG,MOVE              MOVE GRAPHIC DATA
         AR    OLPREG,TEMREG            UPDATE OLP ADDRESS
         AR    ADDREG,TEMREG            UPDATE INPUT ADDRESS
         SR    WRKREG,TEMREG           REDUCE BY 255
         B     STORE6A                  MAKE NEXT COMPARISON
MOVE     MVC   0(0,OLPREG),0(ADDREG)    MOVE DATA TO GDOA
*
*   SUBROUTINE TO CHECK IF INPUT COORDINATES WITHIN GRID
*
GRDCK    LH    WRKREG,X1                GET X1
         C     WRKREG,COMPUX            SEE IF COMPUTED X OUTSIDE GRID
         BH    SIGNAL
         LH    WRKREG,X2                GET X2
         C     WRKREG,COMPUX            SEE IF COMPUTED X OUTSIDE GRID
         BL    SIGNAL
         LH    WRKREG,Y1                GET Y1
         C     WRKREG,COMPUY            SEE IF COMPUTED Y OUTSIDE GRID
         BH    SIGNAL
         LH    WRKREG,Y2                GET Y2
         C     WRKREG,COMPUY            SEE IF COMPUTED Y OUTSIDE GRID
         BL    SIGNAL
         MVI   OFFSW,X'00'              WITHIN LIMIT SET SW OFF
         BR    LINREG
*
*   SUBROUTINE TO CHECK IF INPUT COORDINATES WITHIN SCREEN
*
SCRCHK   L     WRKREG,COMPUX            GET COMPUTED X
         C     WRKREG,ZERO              COMPARE TO ZERO
         BL    SIGNAL                   IF NEGATIVE SIGNAL OFFSG
         C     WRKREG,C4095             COMPARE TO 4095
         BH    SIGNAL                   IF HIGHER SIGNAL OFFSG
         L     WRKREG,COMPUY            GET COMPUTED Y AND
         C     WRKREG,ZERO               TEST IN THE SAME WAY
         BL    SIGNAL
         C     WRKREG,C4095
         BH    SIGNAL
         MVI   OFFSW,X'00'              WITHIN LIMIT SET SW OFF
         BR    LINREG
SIGNAL   MVI   OFFSW,X'11'              SET OFFGRID SWITCH ON
         BR    LINREG
* SCALE UC VC IN FIXED POINT WITH THE FOLLOWING FORMULAS
*
*   UC=(U-U1)(X2-X1)/(U2-U1)+X1
*   VC=(V-V1)(Y2-Y1)/(V2-V1)+Y1
*
SCALFIX  STM   2,12,PORSAVE
FIXSCAL  LA    CNTREG,2
         SR    HALREG,HALREG            INDEX REG FOR X1 THEN Y1
         SR    SCLREG,SCLREG            INDEX REG FOR UC THEN VC
         SR    INXREG,INXREG            INDEX REG FOR UI THEN VI
SCALFXV  L     DVSREG,U2(INXREG)        LOAD U2 THEN V2
         S     DVSREG,U1(INXREG)        U2-U1 THEN V2-V1
         BC    13,ERR16RET              BRANCH ON OVF, MINUS OR ZERO
         L     DVDREG,UC(SCLREG)        LOAD UC THEN VC
         S     DVDREG,U1(INXREG)        UC-U1 OR VC-V1
         LH    WRKREG,X2(HALREG)        LOAD X2 THEN Y2
         SH    WRKREG,X1(HALREG)        X2-X1 OR Y2-Y1
         BC    13,ERR4RET               BRANCH ON OVF, MINUS OR ZERO
         SRDA  DVDREG,32
         MR    DVDREG,WRKREG            (UC-U1)(X2-X1)OR(VC-V1)(Y2-Y1)
         DR    DVDREG,DVSREG            DEVIDED BY U2-U1 ORV2-V1
         AH    QUOREG,X1(HALREG)        ADD X1 OR Y1
         ST    QUOREG,WUC(SCLREG)       STORE SCALED UC VC FOR WORKING
         A     INXREG,EIGHT
         A     SCLREG,FOUR              INDEXING REGISTER
         A     HALREG,TWO               INDEXING REGISTER
         BCT   CNTREG,SCALFXV           LOOP TO SCALE VC
* SCALE RU USING FORMULA
*
*   R=RU*(X2-X1)/(U2-U1)
*
         L     DVSREG,U2                GET U2
         S     DVSREG,U1                U2-U1
         BC    13,ERR16RET              BRANCH ON OVF, MINUS OR ZERO
         LH    DVDREG,X2                LOAD X2
         SH    DVDREG,X1                X2-X1
         BC    13,ERR4RET               BRANCH ON OVF, MINUS OR ZERO
         SRDA  DVDREG,32
         M    DVDREG,RU                 RU*(X2-X1) AND
         DR    DVDREG,DVSREG            DIVIDED BY (U2-U1)
         ST    QUOREG,WR
         LM    2,12,PORSAVE
         B     TESTIN
*    CONVERT XYLIM TABLE TO FLOATING VALUES
SCALFLT  STM   2,12,PORSAVE
*    FLOATING POINT SPECIFIED - TEST FOR CHARACTERISTIC ZERO AND
*    FRACTION NON ZERO. OF ALL U,V VALUES
         L     VALREG,UC
         BAL   LINREG,FIXCONV
         L     VALREG,VC
         BAL   LINREG,FIXCONV
         L     VALREG,RU
         BAL   LINREG,FIXCONV
         L     VALREG,U1
         BAL   LINREG,FIXCONV
         L     VALREG,U2
         BAL   LINREG,FIXCONV
         L     VALREG,V1
         BAL   LINREG,FIXCONV
         L     VALREG,V2
         BAL   LINREG,FIXCONV
         LA    CNTREG,4                 SET LOOP COUNT
         SR    HALREG,HALREG            SET HALF WORK INDEX REG
         SR    SCLREG,SCLREG            CLEAR FULL WORD INDEX REG
NEXTXY   LH    VALREG,X1(HALREG)        GET X1,Y1,X2,Y2
         BAL   LINREG,FLTCONV           BRANCH TO CONVERT
         ST    VALREG,FX1(SCLREG)       STORE CONVERTED VALUES
         A     HALREG,TWO               INDEXING HALF WORD
         A     SCLREG,FOUR              INDEXING FULL WORD
         BCT   CNTREG,NEXTXY
*
*
* SCALE UC VC IN FLOATING POINT WITH THE FOLLOWING FORMULAS
*
*  UC=(UC-U1)(X2-X1)/(U2-U1)+X1
*  VC=(VC-V1)(Y2-Y1)/(V2-V1)+Y1
*
FLTSCAL  LA    CNTREG,2
         SR    INXREG,INXREG
         SR    SCLREG,SCLREG
SCALFLV  LE    REG6,U1(INXREG)          LOAD U1 THEN V1
         LE    REG4,U2(INXREG)          LOAD U2 THEN V2
         SER   REG4,REG6                     U2-U1
         BC    13,ERR16RET              BRANCH ON OVF, MINUS OR ZERO
         LE    REG0,UC(SCLREG)          LOAD UC THEN VC
         SER   REG0,REG6                U-U1  OR V-V1
         LE    REG6,FX1(SCLREG)         LOAD X1 OR Y1 FLT VALUE
         LE    REG2,FX2(SCLREG)         X2 OR Y2 FLOAT VALUE
         SER   REG2,REG6                (X2-X1)
         BC    13,ERR4RET               BRANCH ON OVF, MINUS OR ZERO
         MER   REG0,REG2                (U-U1)(X2-X1)
         DER   REG0,REG4                (U-U1)(X2-X1)
         AER   REG0,REG6
         STE   REG0,WUC(SCLREG)         STORE UC VC SCALED VALUES
         A     INXREG,EIGHT
         A     SCLREG,FOUR
         BCT   CNTREG,SCALFLV
*
* SCALE RU IN FLOATING POINT WITH THE FOLLOWING FORMULAS
*
*   R=RU*(X2-X1)/(U2-U1)
*
         LE    REG6,U1                  LOAD U1
         LE    REG4,U2                  LOAD U2
         SER   REG4,REG6                U2-U1
         BC    13,ERR16RET              BRANCH ON OVF, MINUS OR ZERO
         LE    REG0,RU                  GET RADIUS IN PARTAB
         LE    REG6,FX1                 LOAD X1 FLOAT VALUE
         LE    REG2,FX2                 LOAD X2 FLOAT VALUE
         SER   REG2,REG6                FX2-FX1
         BC    13,ERR4RET               BRANCH ON OVF, MINUS OR ZERO
         MER   REG0,REG2                RU*(X2-X1)
         DER   REG0,REG4                DIVIDED BY U2-U1
         STE   REG0,WR                  STORE SCALED RADIUS
         LM    2,12,PORSAVE
*
*    CONVERT FLOATING UC VC RU TO FIXED POINT VALUES
FCONVERT L     VALREG,WR                LOAD RADIUS
         BAL   LINREG,FIXCONV           FIXCONV=CONVERT FLT TO FIX
         ST    VALREG,WR                STORE THE CONVERTED RADIUS
         L     VALREG,WUC               GET UC
         BAL   LINREG,FIXCONV
         ST    VALREG,WUC               STORE CONVERTED UC
         L     VALREG,WVC               GET VC
         BAL   LINREG,FIXCONV
         ST    VALREG,WVC               STORE CONVERTED VC
         B     TESTIN
FIXCONV  ST    1,OVFSAVE                STORE IN FIRST WORD REG. 1
         TM    OVFSAVE+3,X'07'          TEST LAST THREE BITS
         BZ    SETMODI                  NO BITS ON SET INDEX TO ZERO
         LA    TEMREG,4                 SET MODIFIER
         B     SAVFLT                   START CONVERSION
SETMODI  LA    TEMREG,0                 SET MODIFIER TO ZERO
SAVFLT   ST    VALREG,TEMFLT(TEMREG)    SAVE FLOAT VALUE
         SR    WRKREG,WRKREG
         ST    WRKREG,TEMFLT+4(TEMREG)  CLEAR SECOND WORD
         LD    6,TEMFLT(TEMREG)         VALUE TO FLOAT REGISTERS
         N     VALREG,FCHAR
         BE    FLERR1                   CHARACTERISTIC IS ZERO
         AE    6,FLPT5                  ADD .5 TO ROUND
         AW    6,X4E                    ADD UNNORMALIZED-RIGHT JUSTIFY
         STD   6,TEMFLT(TEMREG)         SAVE VALUES
         L     WRKREG,TEMFLT+4(TEMREG)  CHECK SECOND WORD
         N     WRKREG,MZERO             CHECK BIT 32
         BM    ERR12RET                 INCICATE ERROR
         L     WRKREG,TEMFLT(TEMREG)
         N     WRKREG,BYTE123
         BM    ERR12RET
         L     WRKREG,TEMFLT(TEMREG)
         N     WRKREG,MZERO             DROP CHARACTERISTIC
         L     VALREG,TEMFLT+4(TEMREG)  NEW FIXED VALUE
         LTR   WRKREG,WRKREG
         BNL   NOTNEG
         LNR   VALREG,VALREG            TWO'S COMPLEMENT
NOTNEG   BR    LINREG
FLERR1   CE    6,ZERO                   IS TOTAL VALUE ZERO
         BE    NOTNEG                   RETURN
         B     ERR12RET                 SET ERROR CODE AND RETURN
         DS    0D
X4E      DC    X'4E00000000000000'
FLPT5    DC    E'.5'
BYTE123  DC    X'00FFFFFF'
MZERO    DC    X'80000000'
FCHAR    DC    X'7F000000'
XZERO    DC    X'80FFFFFF'              SIGN AND VALUE -DROP EXPONENT
X6       DC    X'46000000'              EXPONENT OF SIX
NSIGN    DC    X'7FFFFFFF'
*
*   CONVERT FIXED POINT TO FLOATING POINT VALUES
*
FLTCONV  O     VALREG,X6                EXPONENT OF 6
         ST    VALREG,OVFSAVE
         LE    0,OVFSAVE                LOAD TO FLOAT REG.
         AE    0,X6                     NORMALIZE
         STE   0,OVFSAVE
         L     VALREG,OVFSAVE           FLOAT PT VALUE IN REG.
         BR    LINREG
*    CHECK XYLIM TABLE
XYLCHK   LH    XYREG1,X1                LOAD X1
         LH    XYREG2,X2                LOAD X2
         LA    CONREG,2                 SET LOOP CONTROL
XYLOOP   CR    XYREG1,XYREG2            COMPARE X1 TO X2
         BNL   XYLERR
         C     XYREG1,ZERO              COMPARE X1 TO ZERO
         BL    XYLERR
         C     XYREG1,C4095             COMPARE X1 TO 4095
         BH    XYLERR
         C     XYREG2,ZERO              CHECK X2
         BL    XYLERR
         C     XYREG2,C4095
         BH    XYLERR
         LH    XYREG1,Y1                LOAD Y1
         LH    XYREG2,Y2                LOAD Y2
         BCT   CONREG,XYLOOP
         BR    LINREG
XYLERR   B     ERR4RET
*INPUT INVALID- ERROR HANDLING
ERR4RET  LA    15,4                     XYLIM X1,Y1,X2,Y2 ERROR
         B     ERRCNTR
ERR12RET LA    15,12
         B     ERRCNTR
ERR16RET LA    15,16                    U1 V1 GREATER THAN U2 V2
         B     ERRCNTR
ERR20RET LA    15,20                    IMMEDIATE INPUT RETURN
         B     ERRCNTR
ERR24RET LA    15,24                    USERS OVERFLOW
         B     ERRCNTR
ERR28RET LA    15,28                    SET ERROR CODE
         B     ERRCNTR
ERR32RET LA    15,32
         B     ERRCNTR
ERR40    LA    15,40                    INPUT ERROR - NOT SERIOUS
         B     ERRCNT
ERR44    LA    15,44
         B     ERRCNT
ERR48    LA    15,48
         B     ERRCNT
ERRCNTR  LA    LINREG,RET
ERRCNT   L     TEMREG,ERRCOUNT          UPDATE ERROR COUNT
         A     TEMREG,ONE
         ST    TEMREG,ERRCOUNT
         BR    LINREG
ZERO     DC    F'0'
         DC    H'4095,4095'             HIGH LIMITS OF SCREEN
ONE      DC    F'1'
TWO      DC    F'2'
FOUR     DC    F'4'
EIGHT    DC    F'8'
TWOPI    DC    FS28'6.2832'             DEFINE TWOPI VALUE
EVM      DC    X'2A02'                  GEVM ORDER
C16384   DC    F'16384'
C8192    DC    F'8192'
C4095    DC    F'4095'
C360     DC    F'360'
C90      DC    F'90'
C45      DC    F'45'
H2A02    DC    X'2A02'
H0003    DC    H'0003'
PLUS4    DC    X'0004'
MINUS4   DC    X'FFFC'
CSIGN    DC    X'0001FFFFFFFF0001'
SSIGN    DC    X'00010001FFFFFFFF'
TABLE    DC    HS14'0.0000,1.0000,0.0175,0.9999'
         DC    HS14'0.0349,0.9994,0.0523,0.9986'
         DC    HS14'0.0698,0.9976,0.0872,0.9962'
         DC    HS14'0.1045,0.9945,0.1219,0.9925'
         DC    HS14'0.1392,0.9903,0.1564,0.9877'
         DC    HS14'0.1737,0.9848,0.1908,0.9816'
         DC    HS14'0.2079,0.9782,0.2250,0.9744'
         DC    HS14'0.2419,0.9703,0.2588,0.9659'
         DC    HS14'0.2756,0.9613,0.2924,0.9563'
         DC    HS14'0.3090,0.9511,0.3256,0.9455'
         DC    HS14'0.3420,0.9397,0.3584,0.9336'
         DC    HS14'0.3746,0.9272,0.3907,0.9205'
         DC    HS14'0.4067,0.9136,0.4226,0.9063'
         DC    HS14'0.4384,0.8988,0.4540,0.8910'
         DC    HS14'0.4695,0.8830,0.4848,0.8746'
         DC    HS14'0.5000,0.8660,0.5150,0.8572'
         DC    HS14'0.5299,0.8481,0.5446,0.8387'
         DC    HS14'0.5592,0.8290,0.5736,0.8192'
         DC    HS14'0.5878,0.8090,0.6018,0.7986'
         DC    HS14'0.6157,0.7880,0.6293,0.7772'
         DC    HS14'0.6428,0.7660,0.6561,0.7547'
         DC    HS14'0.6691,0.7431,0.6820,0.7314'
         DC    HS14'0.6947,0.7193,0.7071,0.7071'
STATUS1  DC    H'0'                     BOTH PT1 AND PT2 WITHIN LIMITS
STATUS2  DC    X'1100'                  PT1 OFF PT2 ON
STATUS3  DC    X'0011'                  PT1 ON PT2 OFF
REG0     EQU   0
REG2     EQU   2
REG4     EQU   4
REG6     EQU   6
HALREG   EQU   5
SCLREG   EQU   6
INXREG   EQU   7
DVSREG   EQU   8
XYREG1   EQU   7
XYREG2   EQU   8
VALREG   EQU   8
XYLREG   EQU   14
WKAREG   EQU   1
DVDREG   EQU   2
QUOREG   EQU   3
GMREG    EQU   4
DELREG   EQU   4
WRKREG   EQU   4
CONREG   EQU   5
XREG     EQU   6
YREG     EQU   6
MPCREG   EQU   6
PRDREG   EQU   7
NPAREG   EQU   10
PATREG   EQU   12
PASREG   EQU   2
SLOREG   EQU   3
OLPREG   EQU   5
TEMREG   EQU   6
ADDREG   EQU   7
OABREG   EQU   8
CNTREG   EQU   10
LINREG   EQU   11
INTLNK   EQU   12
WKAREA   DSECT
OVFSAVE  DS    CL72                     18-WORD SAVEAREA FOR REGISTERS
         ORG   OVFSAVE
TEMFLT   DS    CL8                      A  TEMPORARY SAVE AREA
         DS    CL64
PORSAVE  DS    CL44                     A  REGISTER SAVE AREA
ERRCOUNT DS    CL4                      COUNT OF ERRORS
FX1      DS    CL4                      FLOATING X1
FY1      DS    CL4                      FLOATING Y1
FX2      DS    CL4                      FLOATING X2
FY2      DS    CL4                      FLOATING Y2
WOACB    DS    CL4                      AN AREA TO SAVE OACB ADDRESS
WUC      DS    CL4
WVC      DS    CL4
WR       DS    CL4
WTHETA   DS    CL2
WALPHA   DS    CL2
WGAMMA   DS    CL2
WDELTA   DS    CL2
WXI      DS    CL4
WYI      DS    CL4
PRIORXY  DS    CL4                      A 4-BYTE AREA BEFORE BUILT XY
BUILDXY  DS    CL4                      XY BUILDUP AREA
COMPUX   DS    CL4                      COMPUTED X VALUE
COMPUY   DS    CL4                      COMPUTED Y VALUE
WRTADDR  DS    CL4                      ADDR OF GRID OR SCREEN CHECK RT
GOFFSGAD DS    CL4                      GOFFSG RT ADDR AREA
SABL     DS    CL4                      ADDR OF BOUNDARY LIMITS
PREVPT   DS    CL8                      PREVIOUS POINT
CURPT    DS    CL8                      CURRENT POINT
NI       DS    CL4                      NUMBER OF INTERSECTIONS
INTS1    DS    CL4                      INTERSECTION 1
INTS2    DS    CL4                      INTERSECTION 2
SCRATCH  DS    CL64
SVR15    DS    CL4                      PLACE TO SAVE ERROR REGISTER
SWSTATUS DS    CL2                      SWITCH STATUS OF PT1 AND PT2
         ORG   SWSTATUS
PT1SW    DS    CL1                      PREVIOUS STATUS
OFFSW    DS    CL1                      CURRENT STATUS
BMSWITCH DS    CL1                      BEAM SWITCH STATUS
MASKSV   DS    F                   SAVE SETTING OF USER PROGRAM MASK
         ORG   OVFSAVE+396
GOMODE   DS    CL2
PARTAB   DSECT
XYLIM    DS    CL4
UC       DS    CL4
VC       DS    CL4
F        DS    CL1
S        DS    CL1
INC      DS    CL1
SG       DS    CL1
RU       DS    CL4
THETA    DS    CL2
DENSITY  DS    CL2
         ORG   DENSITY
ALPHA    DS    CL2
GAMMA    DS    CL2
XYLIMTB  DSECT
X1       DS    CL2
Y1       DS    CL2
X2       DS    CL2
Y2       DS    CL2
U1       DS    CL4
U2       DS    CL4
V1       DS    CL4
V2       DS    CL4
         END
