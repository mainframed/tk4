COMM     TITLE 'HASP COMMAND PROCESSOR - PROLOG'               @OZ18212
***********************************************************************
*                                                                     *
* MODULE NAME = HASJES20 (HASPCOMM CSECT)                             *
*                                                                     *
* DESCRIPTIVE NAME = JES2 COMMAND PROCESSOR                           *
*                                                                     *
* COPYRIGHT = NONE                                                    *
*                                                                     *
* STATUS = OS/VS2 MVS   --  SEE &VERSION (BELOW) FOR JES2 LEVEL       *
*                                                                     *
* FUNCTION = ACCEPTS OPERATOR COMMAND FROM VARYING SOURCES AND        *
*            REPLIES TO THE SUBMITTER THE APPROPRIATE DATA BASED      *
*            UPON THE COMMAND AND ITS OPERANDS. NO I/O IS DONE        *
*            FROM THIS MODULE. THE COMMAND ARE TAKEN FROM THE         *
*            CONSOLE MESSAGE BUFFERS AND A REPLY IS BUILT IN THE      *
*            COMMAND PROCESSOR PCE WORK AREA FROM THE APPROPRIATE     *
*            JES2 CONTROL BLOCKS. THIS RESPONSE IS THEN SENT TO THE   *
*            SUBMITTER BY JES2 $WTO SERVICES.                         *
*                                                                     *
* NOTES = SEE BELOW                                                   *
*                                                                     *
*   DEPENDENCIES = IF MULTIPLE COMMAND ARE USED, THEY MUST BE         *
*                  SEPERATED BY SEMICOLONS AND THE JES2 COMMAND       *
*                  INDENTIFIER IS OMITTED FROM SECOND AND SUBSEQUENT  *
*                  COMMANDS IN THAT INPUT LINE                        *
*                                                                     *
*   RESTRICTIONS = NONE                                               *
*                                                                     *
*   REGISTER CONVENTIONS = R0  =       = PARAMETER REGISTER           *
*                          R1  =       = PARAMETER REGISTER           *
*                          R2  = WA    = WORK REGISTER                *
*                          R3  = WB    = WORK REGISTER                *
*                          R4  = WC    = WORK REGISTER                *
*                          R5  = WD    = CURRENT OPERAND POINTER      *
*                          R6  = WE    = CONSTANT OF FOUR (4)         *
*                          R7  = WF    = LAST OR NULL OPERAND POINTER *
*                          R8  = BASE3 = SUB PROCESSOR ADDRESSABILITY *
*                          R9  =       = RESERVED (IE. NOT USED)      *
*                          R10 =       = WORK REGISTER                *
*                          R11 = BASE1 = HCT ADDRESSABILITY           *
*                          R12 = BASE2 = MAIN PROCESSOR ADDRESSABILITY*
*                          R13 = SAVE  = PCE ADDRESSABILITY           *
*                          R14 = LINK  = LINKAGE REGISTER             *
*                          R15 =       = RETURN REGISTER              *
*                                                                     *
*   PATCH LABEL = NONE                                                *
*                                                                     *
* MODULE TYPE = PROCESSOR, TABLE (CSECT TYPE)                         *
*                                                                     *
*   PROCESSOR = OS/VS ASSEMBLER                                       *
*                                                                     *
*    MODULE SIZE = SEE $DLENGTH MACRO EXPANSION(S) AT END OF ASSEMBLY *
*                                                                     *
*   ATTRIBUTES = READ ONLY, AFTER PROCESSOR INITIALIZATION, AND       *
*                HASP REENTRANT                                       *
*                                                                     *
* ENTRY POINT = HASPCOMM                                              *
*                                                                     *
*   PURPOSE = SEE FUNCTION                                            *
*                                                                     *
*   LINKAGE = VIA $WAIT AND $POST OBEYING JES2 CONVENTIONS            *
*                                                                     *
* ENTY POINT = $JCANR                                                 *
*                                                                     *
*   PURPOSE = TO CANCEL JOBS, STCS, OR TSUS IN JES2                   *
*             1). REJECT ATTEMPTS TO CANCEL OR STOP STC OR            *
*                 TSU TASKS PRIOR TO EXECUTION                        *
*                                                                     *
*             2). PURGE BQES AND JOES FOR STOP JOB AND CANCEL         *
*                 WITH PURGE                                          *
*                                                                     *
*             3). ISSUE OS/VS CANCEL COMMAND IF REQUIRED FOR A JOB    *
*                                                                     *
*             4). DELETE ACTIVITY ON JES2 READERS FOR CANCEL REQUESTS *
*                 AND ON JES2 PRINTERS AND PUNCHES FOR CANCEL         *
*                 WITH PURGE REQUESTS                                 *
*                                                                     *
*   LINKAGE = VIA $JCAN MACRO                                         *
*                                                                     *
* INPUT = CONSOLE MESSAGE BUFFER CONTAINING THE COMMAND               *
*                                                                     *
* OUTPUT = EITHER A DIAGNOSTIC OR A RESPONSE TO THE INPUT COMMAND     *
*                                                                     *
* EXIT-NORMAL = $WTO PROCESSOR                                        *
*                                                                     *
* EXIT-ERROR = NONE                                                   *
*                                                                     *
* EXTERNAL REFERENCES = SEE BELOW                                     *
*                                                                     *
*   ROUTINES = SEE MACROS FOR SERVICES USED                           *
*                                                                     *
*   DATA AREAS = SEE $HASPCB MACRO EXPANSION                          *
*   CONTROL BLOCKS = SEE $HASPCB MACRO EXPANSION                      *
*                                                                     *
* TABLES = 256 BYTE TABLE IS USED TO VALIDATE ALPHANUMERIC            *
*          COMMAND OPERANDS                                           *
*                                                                     *
* MACROS = HASPCOMM = $COMGRUP, $COMTAB, $CRET, $CWTO, $CFCVB, $CFCVE,*
*                     $CFDCTD, $CFDCTL, $CFINVC, $CFINVO, $CFJDCT,    *
*                     $CFJDCTC, $CFJMSG, $CFJSCAN, $CFSEL, $CFVQE     *
*                                                                     *
* MACROS = JES2     = $HASPCB, $ENTRY, $WTO, $WAIT, $STIMER, $GETCMB, *
*                     $MSG, $TTIMER, $FRECMB, $POST, $QCKPT, $JCAN,   *
*                     $QMOD, $QLOC, $FREUNIT, $ALLOC,                 *
*                     $GETLOK, $FRELOK, $#CKPT, $#ADD, $QPUT          *
*                                                                     *
* MACROS = SYSTEM   = TIME, MODESET, PURGE                            *
*                                                                     *
*                                                                     *
*                                                                     *
*                                                                     *
* CHANGE ACTIVITY                                                     *
*                                                                     *
*     RELEASE 4.0 = OZ02440,OZ03321,OZ03339,OZ04315,OZ04343,OZ04344,  *
*                   OZ04983,OZ06751,OZ07444,OZ07458,OZ08189,OZ09044,  *
*                   OZ09045,OZ09105                                   *
*                                                                     *
*     RELEASE 4.1 = OZ09093,OZ10322,OZ10325,OZ10353,OZ10354,OZ10363,  *
*                   OZ11742,OZ11744,OZ11747,OZ11748,OZ11763,OZ11769,  *
*                   OZ11775,OZ11787,OZ12293,OZ12299,OZ12316,OZ13256,  *
*                   OZ14905,OZ15817,OZ15839,OZ16681,OZ16683,OZ18201   *
*                                                                     *
***********************************************************************
         TITLE 'HASP CONTROL BLOCK GENERATION MACRO'
*
*****    $HASPCB   *****           GENERATE HASP CONTROL BLOCKS
*
         SPACE 1
         MACRO
         $HASPCB &DOC=NO,&LIST=NO
         GBLC  &PRINT,&GEN,&DATA
         PUSH  PRINT
         PRINT &PRINT
         $CVT  LIST=&LIST          GENERATE OS CVT DSECT
         $SSOB (SO),LIST=&LIST     GENERATE OS SSOB DSECT
         $TCB  LIST=&LIST          GENERATE OS TCB DSECT
         $DCB  LIST=&LIST          GENERATE OS DCB DSECT
         $DEB  LIST=&LIST          GENERATE OS DEB DSECT
         $UCB  LIST=&LIST          GENERATE OS UCB DSECT
         $CSCB LIST=&LIST          GENERATE OS CSCB DSECT
         $UCM  LIST=&LIST          GENERATE OS UCM DSECT
         $TAB  DOC=&DOC            GENERATE HASP TAB DSECT          R41
         $SVT  DOC=&DOC            GENERATE HASP SSVT DSECT
         $SJB  DOC=&DOC            GENERATE HASP SJB DSECT
         $HCT  DOC=&DOC            GENERATE HASP HCT DSECT
         $QSE  DOC=&DOC            GENERATE QSE DSECT
         $PCE  DOC=&DOC            GENERATE HASP PCE DSECT
         $BUFFER DOC=&DOC          GENERATE HASP BUFFER DSECT
         $CMB  DOC=&DOC            GENERATE HASP CMB DSECT
         $ICE  DOC=&DOC            GENERATE HASP ICE DSECT           R4
         $JQE  DOC=&DOC            GENERATE HASP JQE DSECT
         $JOE  DOC=&DOC            GENERATE HASP JOE DSECT
         $JOT  DOC=&DOC            GENERATE HASP JOT DSECT
         $JCT  DOC=&DOC            GENERATE HASP JCT DSECT
         $PDDB DOC=&DOC            GENERATE HASP PDDB DSECT
         $IOT  DOC=&DOC            GENERATE HASP IOT DSECT          R41
         $CAT  DOC=&DOC            GENERATE HASP CAT DSECT
         $SCAT DOC=&DOC            GENERATE HASP SCAT DSECT
         $RAT  DOC=&DOC            GENERATE HASP RAT DSECT
         $DCT  DOC=&DOC            GENERATE HASP DCT DSECT
         $TQE  DOC=&DOC            GENERATE HASP TQE DSECT
         $CCE  DOC=&DOC            GENERATE HASP CCE DSECT          R41
         $PIT  DOC=&DOC            GENERATE HASP PIT DSECT
         $PSO  DOC=&DOC            GENERATE HASP PSO DSECT
         $CSA  DOC=&DOC            GENERATE HASP CSA DSECT
         $ACT  DOC=&DOC            GENERATE HASP $ACT DSECT
         $MLMWORK DOC=&DOC         GENERATE HASP MLMWORK DSECT       R4
         $RDRWORK DOC=&DOC         GENERATE HASP RDRWORK DSECT
         $PPPWORK DOC=&DOC         GENERATE HASP PPPWORK DSECT
         $COMWORK DOC=&DOC         GENERATE HASP COMWORK DSECT
         $COM  DOC=&DOC,LIST=&LIST GENERATE HASP COM DSECT
         SPACE 1
         POP   PRINT
         PRINT &GEN,&DATA          SET ASSEMBLY PRINT OPTIONS
         MEND
         TITLE 'HASP COMMAND PROCESSOR -- MACRO DEFINITIONS'
         MACRO -- $COMGRUP -- DEFINE GROUP OF COMMAND SUB-PROCESSORS
&NAME    $COMGRUP &A0,&A1,&A2,&A3,&A4,&A5,&A6,&A7,&A8,&A9,&AA,&AB,&AC, C
               &AD,&AE,&AF,&B0,&B1,&B2,&B3,&B4,&B5,&B6,&B7,&B8,&B9,    C
               &DELAY=NO
         LCLC  &I
         GBLC  &COMGRUP                                              R4
&NAME    DS    0H
         USING *,BASE3             ADDRESSABILITY
&COMGRUP SETC  '&NAME'                                               R4
         AIF   ('&DELAY' EQ 'NO').A
         AGO   .C
.A       BR    R1                  GO TO SUB-PROCESSOR SELECTED
         AGO   .XIT
.C       ANOP
&I       SETC  '&SYSNDX'
COF&I    DS    0H                  'BR R1' TO ENTER SUB-PROCESSOR
.XIT     MEND
         EJECT
         MACRO -- $COMTAB -- DEFINE COMMAND TABLE ENTRY
&NAME    $COMTAB &VERB,&GROUP,&REDIR=0,&REJECT=0
         LCLC  &C,&D
&NAME    DS    0F                  DEFINE SUB-PROCESSOR
         DC    AL1(&REDIR*16+&REJECT)  FLAG BYTES
         DC    AL3(&GROUP)         SUB-PROCESSOR ADDRESS
         DC    AL2(C&VERB-&GROUP)  OFFSET TO VERB WITHIN GROUP
         AIF   (K'&VERB LT 2).A
         AIF   (K'&VERB EQ 3).B
         DC    CL2'&VERB'
         MEXIT
.A       DC    CL1'&VERB',X'FF'
         MEXIT
.B       ANOP
&C       SETC  '&VERB'(1,1)
&D       SETC  '&VERB'(2,2)
         DC    CL1'&C',X'&D'
         MEND
         EJECT
         MACRO -- $CRET -- RETURN TO MAIN COMMAND PROCESSOR
&NAME    $CRET &MSG=,&L=,&INFO=
         GBLC  &DOC
         LCLA  &CNT
         AIF   ('&INFO' EQ '' AND '&DOC' EQ 'NO' OR '&INFO' EQ 'NO').Z
         EJECT
***********************************************************************
*                                                                     *
*        $CRET -- RETURN TO MAIN COMMAND PROCESSOR                    *
*                                                                     *
*        ROUTINE MAY ISSUE $WTO AND $WAIT AS DIRECTED BY CALLER       *
*                                                                     *
* REGISTERS USED                                                      *
*        R0    = LENGTH OF MESSAGE IF RESPONSE REQUESTED, NOT MSG=OK  *
*        R1    = MESSAGE ADDRESS -- COMMAND                           *
*        R15   = RETURN CODE -- NO MESSAGE, OK, OR GENERAL MESSAGE    *
*                                                                     *
***********************************************************************
.Z       ANOP
&NAME    NULL
         AIF   ('&MSG' EQ '' AND '&L' EQ '').H
         AIF   ('&L' EQ '').F
         AIF   ('&L'(1,1) EQ '(').A
         LA    R0,&L
         AGO   .C
.A       AIF   ('&L' EQ '(R0)').B
         LR    R0,&L(1)
.B       AIF   ('&MSG' EQ '').E
         MNOTE 4,'REGISTER FORM OF LENGTH INVALID'
         MEXIT
.C       AIF   ('&MSG' EQ '').E
         AIF   ('&MSG'(1,1) EQ '(').D
         MVC   COMMAND(&L),&MSG
         AGO   .E
.LITERAL ANOP
&CNT     SETA  K'&MSG-2
         MVC   COMMAND(&CNT),=C&MSG
         LA    R0,&CNT             SET LENGTH OF MSG IN R0
         AGO   .E
.D       MVC   COMMAND(&L),0&MSG
.E       LA    R15,CORTMSG         RETURN AND ISSUE MESSAGE
         AGO   .I
.F       AIF   ('&MSG' EQ 'OK').G
         AIF   ('&MSG'(1,1) EQ '''').LITERAL
         MNOTE 4,'LENGTH REQUIRED'
         MEXIT
.G       LA    R15,CORTOK          RETURN AND ISSUE OK MESSAGE
         AGO   .I
.H       LA    R15,CORTNORM        NORMAL RETURN
.I       B     CORET               RETURN
         MEND
         EJECT
         MACRO -- $CWTO -- WRITE TO OPERATOR -- RESPONSE
&NAME    $CWTO &MSG=,&L=,&INFO=,&RET=,&TRUNC=NO
         GBLC  &DOC
         LCLA  &CNT
         LCLC  &LOC
&LOC     SETC  'CWTO'
         AIF   ('&TRUNC' EQ 'NO').AA
&LOC     SETC  'CWTOT'
.AA      ANOP
         AIF   ('&INFO' EQ '' AND '&DOC' EQ 'NO' OR '&INFO' EQ 'NO').Z
         EJECT
***********************************************************************
*                                                                     *
*        CWTO/CWTOT -- WRITE TO OPERATOR                              *
*                                                                     *
*        ROUTINE ISSUES A $WAIT                                       *
*                                                                     *
* REGISTERS USED                                                      *
*        R0    = LENGTH OF MESSAGE                                    *
*        R1    = MESSAGE ADDRESS -- COMMAND                           *
*        WA    = LINK REGISTER                                        *
*        LINK  = LINKAGE FOR $WTO                                     *
*        R15   = WAIT REENTRY                                         *
*                                                                     *
***********************************************************************
.Z       ANOP
&NAME    NULL
         AIF   ('&MSG' EQ '' AND '&L' EQ '').H
         AIF   ('&L' EQ '').G
         AIF   ('&L'(1,1) EQ '(').A
         LA    R0,&L
         AIF   ('&MSG' EQ '').D
         AIF   ('&MSG'(1,1) EQ '(').C
         MVC   COMMAND(&L),&MSG
         AGO   .D
.A       AIF   ('&L' EQ '(R0)').B
         LR    R0,&L(1)
.B       AIF   ('&MSG' EQ '').D
         MNOTE 4,'REGISTER FORM OF LENGTH INVALID'
         MEXIT
.C       MVC   COMMAND(&L),0(&MSG)
.D       AIF   ('&RET' EQ '').E
         $DECODE &RET,RA=WA
         B     &LOC                REPLY TO OPERATOR
         MEXIT
.E       BAL   WA,&LOC             REPLY TO OPERATOR
         MEXIT
.F       MNOTE 4,'LENGTH REQUIRED'
         MEXIT
.LITERAL ANOP
&CNT     SETA  K'&MSG-2
         MVC   COMMAND(&CNT),=C&MSG
         LA    R0,&CNT             SET LENGTH OF MSG IN R0
         AGO   .D
.G       AIF   ('&MSG'(1,1) EQ '''').LITERAL
         AGO   .F
.H       AIF   ('&TRUNC' EQ 'NO').F
         SLR   R0,R0               SET NULL LENGTH
         AGO   .D
         MEND
 TITLE 'HASP COMMAND PROCESSOR FUNCTION MACRO DEFINITIONS'
         MACRO -- $CFCVB -- CONVERT TO BINARY
&NAME    $CFCVB &TYPE=CALL,&POINTER=(R1),&NUM=2,&INFO=NO,&NOK=
         GBLC  &DOC
         LCLC  &R
         LCLA  &CNT
&R       SETC  '&SYSNDX'
         AIF   ('&INFO' EQ '' AND '&DOC' EQ 'NO' OR '&INFO' EQ 'NO').Z
         AIF   ('&TYPE' EQ 'RES').NOJECT
         EJECT
.NOJECT  SPACE 2
***********************************************************************
*                                                                     *
*        COFCVB -- CONVERT TO BINARY                                  *
*                                                                     *
*        ROUTINE CONVERTS A PAIR OF NUMBERS OF THE FORM               *
*                                                                     *
*        TEXTN1-N2 WHERE                                              *
*        TEXT  = OPTIONAL TEXT IDENTIFIERS  JOB, PRT, RM ETC.         *
*        N1    = FIRST OF A SERIES OF NUMBERS LT 10000 IN VALUE       *
*        N2    = OPTIONAL LAST OF A SERIES OF NUMBERS LT 10000.       *
*        IN A SERIES OF VALUES, N1-N2-N3-N4, THE LAST TWO VALUES      *
*        ARE CONCIDERED TO BE START-STOP VALUES.                      *
*        THE MEANING OF THE START-STOP VALUES FOR EXAMPLE 1-5 ARE     *
*        THE USER DESIRES AN OPERATION PERFORMED ON JOB OR FACILITY   *
*        TYPE INDICATED, NUMBERS 1, 2, 3, 4, AND 5.                   *
*                                                                     *
*        NO $WAITS ARE ISSUED.                                        *
*                                                                     *
* REGISTERS USED                                                      *
*        R0    = ACCUMULATOR - STOP VALUE                             *
*        R1    = ADDRESS OF OPERAND POINTER -- START VALUE            *
*        LINK  = LINK REGISTER                                        *
*        R15   = WORK REGISTER                                        *
*                                                                     *
* EXITS                                                               *
*        LINK+0 OPERAND DOES NOT CONTAIN NUMERIC OR NUMERIC TOO LARGE *
*        LINK+4 NORMAL EXIT                                           *
*                                                                     *
* NOTES                                                               *
*        R1 VALUE IS EQUAL TO R0 IF USER REQUESTS NUM=2 AND ONLY      *
*        ONE VALUE IS PRESENT. IF NUM=1 IS USED R1 VALUE IS           *
*        UNPREDICTABLE. ( NUM=1 MAY BE IGNORED ).                     *
*                                                                     *
***********************************************************************
.Z       ANOP
&NAME    NULL
         AIF   ('&TYPE' NE 'CALL').INL
         $DECODE &POINTER
.CAL     BAL   LINK,COFCVB         CONVERT NUMBERS TO BINARY
         AIF   ('&NOK' NE '').NOKOK
         MNOTE 4,'NOK KEYWORD MUST BE SUPPLIED'
         AGO   .XIT
.NOKOK   ANOP
         AIF   ('&NOK'(1,1) EQ '(').REG
         B     &NOK                BRANCH IF OPERAND INVALID
         AGO   .XIT
.REG     ANOP
&CNT     SETA  K'&NOK-2
&R       SETC  '&NOK'(2,&CNT)
         B     0(,&R)              BRANCH IF INVALID OPERAND
         MEXIT
.INL     L     R15,0(0,R1)         PICK UP FIRST PARAMETER
COF&R.K  CLI   0(R15),C'0'         CHARACTER NUMERIC...             R41
         BNL   COF&R.L             IF NUMERIC, CONVERT               R4
         LA    R15,1(0,R15)        NEXT CHARACTER
         CLM   R15,7,5(R1)         DID WE GO TOO FAR                 R4
         BL    COF&R.K             LOOP IF NO                       R41
         BR    LINK                RETURN INVALID OPERAND
         EJECT                                                      R41
***********************************************************************
* CONVERT PAIR OF START STOP VALUES                                   *
***********************************************************************
COF&R.L  SLR   R0,R0               ZERO ACCUMULATOR, STOP VALUE
         ST    R0,COMFWORK         CLEAR WORK AREA FOR CONVERT
         AIF   ('&NUM' NE '2').BA
         LNR   R1,R15              SET NEGATIVE FLAGS
.BA      ANOP
COF&R.C  MVN   COMFWORK+1(1),0(R15) MOVE NUMERIC TO WORK AREA
         MH    R0,=H'10'           MULTIPLY BY TEN FOR TEN'S DIGIT
         AH    R0,COMFWORK         ADD LOW DIGIT
         CH    R0,=H'9999'         LOOK FOR MAXIMUM JOB NUMBR
         BCR   H,LINK              RETURN INVALID OPERAND
COF&R.N  LA    R15,1(0,R15)        NEXT CHARACTER
         CLI   0(R15),C'0'         TEST FOR NUMERIC ( FA-FF INCLUDED )
         BNL   COF&R.C             IF NUMERIC, CONVERT THE CHARACTER R4
         AIF   ('&NUM' NE '2').G
         CLI   0(R15),C'-'         LOOK FOR SEPARATOR
         BE    COF&R.O             BR IF YES TO CONVERT NEXT VALUE  R41
         CLR   R1,R0               TEST FOR BOTH VALUES
         BNH   4(0,LINK)           RETURN WITH CONVERTED VALUES
         LR    R1,R0               SET TO SAME
         B     4(0,LINK)           RETURN WITH CONVERTED VALUES
COF&R.O  CLI   1(R15),C'0'         NEXT CHARACTER NUMERIC...        R41
         BLR   LINK                RETURN INVALID OPERAND IF NO     R41
         LR    R1,R0               SET START OF STRING              R41
         SLR   R0,R0               PREPARE FOR NEXT
         B     COF&R.N             CONVERT NEXT VALUE OF SET         R4
         AGO   .I
.G       ANOP
         B     4(0,LINK)           RETURN
.I       ANOP
.XIT     MEND
         EJECT
         MACRO -- $CFCVE -- CONVERT TO EBCDIC
&NAME    $CFCVE &VALUE=(R0),&TYPE=CALL,&INFO=NO
         GBLC  &DOC
         LCLC  &R
&R       SETC  '&SYSNDX'
         AIF   ('&INFO' EQ '' AND '&DOC' EQ 'NO' OR '&INFO' EQ 'NO').Z
         AIF   ('&TYPE' EQ 'RES').NOJECT
         EJECT
.NOJECT  SPACE 2
***********************************************************************
*                                                                     *
*        COFCVE -- CONVERT TO EBCDIC                                  *
*                                                                     *
*        ROUTINE CONVERTS A HALF WORD BINARY NUMBER LOCATED           *
*        AT ADDRESS 'VALUE'.  ANSWER WILL BE IN FIRST FIVE            *
*        CHARACTERS OF COMDWORK.                                      *
*        NO $WAITS ARE ISSUED.                                        *
*                                                                     *
* REGISTERS USED                                                      *
*        R0    = VALUE TO BE CONVERTED                                *
*        LINK  = RETURN LINKAGE                                       *
*                                                                     *
* NOTES                                                               *
*        COMEWORK - COMDWORK AREAS ARE USED FOR SCRATCH               *
*                                                                     *
***********************************************************************
.Z       ANOP
&NAME    $DECODE &VALUE,OPA=LH,RA=R0
         AIF   ('&TYPE' NE 'CALL').INL
.CAL     BAL   LINK,COFCVE         CONVERT TO EBCDIC
         MEXIT
.INL     ANOP
***********************************************************************
* CONVERT TO EBCDIC AND LEAVE ANSWER IN COMDWORK ( 5 DIGITS )         *
***********************************************************************
         CVD   R0,COMDWORK         CONVERT TO DECIMAL
         MVC   COMDWORK-1(6),=X'402020202120' MOVE MASK FOR RESULT
         ED    COMDWORK-1(6),COMDWORK+5 CONVERT TO EBCDIC
         BR    LINK                RETURN
.XIT     MEND
         EJECT
         MACRO -- $CFDCTD -- DISPLAY DEVICE CONTROL TABLE
&NAME   $CFDCTD &DCT=(R1),&TYPE=CALL,&EXT=NO,&ENTRY=COFDCTD,&INFO=NO
         GBLC  &DOC
         GBLC  &COMGRUP                                              R4
         LCLC  &R
&R       SETC  '&SYSNDX'
         AIF   ('&INFO' EQ '' AND '&DOC' EQ 'NO' OR '&INFO' EQ 'NO').Z
         AIF   ('&TYPE' EQ 'RES').NOJECT
         EJECT
.NOJECT  SPACE 2
***********************************************************************
*                                                                     *
*        COFDCTD -- DEVICE CONTROL TABLE DISPLAY                      *
*                                                                     *
*        ROUTINE CREATES A STATUS MESSAGE IN AREA 'COMMAND' AND       *
*        INITIATES OPERATOR RESPONSE.                                 *
*        $WAIT MAY BE ISSUED.                                         *
*                                                                     *
* REGISTERS USED                                                      *
*        R0    = LENGTH OF MESSAGE                                    *
*        R1    = ADDRESS OF DCT, WORK REGISTER, PARAMETER TO $WTO     *
*                HIGH-ORDER BYTE OF R1 INDICATES TYPE OF DISPLAY      *
*                X'FF' -RAT ADDR   DISPLAY RAT INFO                   *
*                X'0F'  DCT ADDR   DISPLAY EXTENDED DCT INFO          *
*                X'00'  DCT ADDR   DISPLAY SHORT DCT INFO             *
*        WA    = LINK REGISTER                                        *
*        LINK  = LINKAGE TO $WTO                                      *
*        R15   = WAIT RETURN                                          *
*                                                                     *
* WORK AREAS USED                                                     *
*        COMEWORK USED TO SAVE PTR TO DCT (R1)                        *
*        COMFWORK USED TO SAVE RETURN ADDRESS (WA)                    *
*        COMDWORK USED TO SAVE REGS (R1 AND WA) OVER $CWTO            *
*        COMJNAME USED AS OVERFLOW MESSAGE AREA                       *
*                                                                     *
***********************************************************************
.Z       ANOP
&NAME    $DECODE &DCT
         AIF   ('&TYPE' NE 'CALL').INL
         AIF   ('&EXT' EQ 'SET').CAL                                 R4
         AIF   ('&EXT' NE 'NO').EXT
         LA    R1,0(,R1)           INDICATE NO EXTENDED DISPLAY
         AGO   .CAL
.EXT     ICM   R1,8,=X'0F'         INDICATE EXTENDED DCT DISPLAY    R41
.CAL     ANOP                                                        R4
         L     BASE3,=A(COFDCTD)   GET ADDRESS OF DCT DISPLAY RTN    R4
         BALR  WA,BASE3            CALL DISPLAY  ROUTINE             R4
         DC    Y(*-&COMGRUP)       ADDRESSABILITY ADJUSTMENT         R4
         MEXIT
.INL     ANOP                                                        R4
         USING *,BASE3             ESTABLISH ROUTINE ADDRESSABILITY  R4
         ST    R1,COMEWORK         SAVE ADDR OF DCT                  R4
         ST    WA,COMFWORK         SAVE CONTENTS OF WA -- USE ASE WK R4
         MVI   COMMAND,C' '        CLEAR RESPONSE AREA
         MVC   COMMAND+1(L'COMMAND+L'COMJNAME-1),COMMAND             R4
         LTR   R1,R1               TEST PASSED ADDRESS              R41
         BP    COFP&R              POSITIVE MEANS A DCT ADDRESS     R41
         LPR   R1,R1               ELSE = -RAT, SO MAKE POSITIVE    R41
         LA    WA,COMMAND+23       BUMP PAST BASIC MESSAGE          R41
         MVC   COMMAND+10(12),=C'*** INACTIVE' INDICATE INACTIVE    R41
         L     R1,RATLDCT-RATDSECT(,R1) GET LINE DCT ADDRESS        R41
         LTR   R1,R1               IS REMOTE CONNECTED              R41
         BZ    COF&R.D             NO, LEAVE INACTIVE               R41
         TM    DCTSTAT-DCTDSECT(R1),DCTINUSE IS RMT ACTIVE          R41
         BZ    COF&R.D             NO, LEAVE INACTIVE               R41
         MVC   COMMAND+14(8),=C'ACTIVE  ' ELSE SHOW ACTIVE          R41
         B     COF&R.W             GO CONTINUE PROCESSING           R41
         SPACE 1                                                    R41
COFP&R   MVC   COMMAND(8),DCTDEVN-DCTDSECT(R1) SET DEVICE NAME      R41
         MVC   COMMAND+10(12),=C'*** DRAINING' SET DEVICE DRAINING
         TM    DCTSTAT-DCTDSECT(R1),DCTDRAIN TEST FOR DRAIN BIT
         BZ    COF&R.A             BRANCH IF NOT DRAINED OR DRAINING
         TM    DCTSTAT-DCTDSECT(R1),DCTINUSE TEST FOR DRAINING
         BO    COF&R.B             LOCATE UCB 'DRAINING'
         MVC   COMMAND+19(3),=CL3'ED'  SET 'DRAINED'
         B     COF&R.B             LOCATE UCB 'DRAINED '
COF&R.A  MVC   COMMAND+14(8),=CL8'ACTIVE'  SET UNIT ACTIVE
         TM    DCTSTAT-DCTDSECT(R1),DCTINUSE TEST FOR ACTIVE
         BZ    COF&R.5             IF NOT ACTIVE CHK FURTHER
         TM    DCTFLAGS-DCTDSECT(R1),DCTSTOP TEST FOR HALTED
         BZ    COF&R.B             NOOGO FIND UCB POSSIBLY
         MVC   COMMAND+14(8),=CL8'HALTED'  DEVICE IS HALTED
         B     COF&R.B             GO LOOK FOR UCB
COF&R.5  TM    DCTDEVTP-DCTDSECT(R1),DCTPRPU TEST FOR PRT/PUN
         BZ    COF&R.6             NO--CAN'T BE PAUSING
         TM    DCTSTAT-DCTDSECT(R1),DCTPAUSE  TEST FOR PAUSED
         BZ    COF&R.6             NO--JUST INACTIVE
         MVC   COMMAND+14(8),=CL8'PAUSED'  SET PRT/PUN PAUSING
         B     COF&R.B             GO LOOK FOR UCB
COF&R.6  MVC   COMMAND+14(8),=CL8'INACTIVE' SET DEVICE AS INACTIVE
         EJECT                                                      R41
***********************************************************************
* DCT STATUS SET IN MESSAGE - LOCATE AND SET DEVICE ADDRESS           *
***********************************************************************
COF&R.B  LA    WA,COMMAND+23       BUMP PAST BASIC MESSAGE           R4
         CLI   DCTDEVTP-DCTDSECT(R1),DCTINR TEST FOR INTERNAL RDR    R4
         BE    COF&R.D             YES  SKIP UCB LOCATE
         CLI   DCTDEVTP-DCTDSECT(R1),DCTLOG TEST OF LOGON            R4
         BE    COFI&R              YES, BR - USE SNA IN UNIT FIELD   R4
         TM    DCTDEVTP-DCTDSECT(R1),DCTRJE  TEST FOR RJE
         BZ    COF&R.C             NO--SKIP NEXT TEST
         CLI   DCTDEVTP-DCTDSECT(R1),DCTLNE SEPERATE LINES
         BE    COF&R.S             FROM REMOTE DEVICES               R4
         TM    MDCTSTAT-DCTDSECT(R1),DCTSINON IS REMOTE SIGNED ON    R4
         BZ    COF&R.D             IF NOT, MESSAGE IS COMPLETE
         L     R1,DCTDCB-DCTDSECT(0,R1) PICK UP LINE DCT
         B     COF&R.W             GO FIND THE LINE UNIT ADDRESS     R4
COF&R.S  L     R15,MDCTRAT-DCTDSECT(,R1) GET RAT ENTRY ADDRESS       R4
         LTR   R15,R15             TEST FOR ACTIVE USER              R4
         BZ    COF&R.W             NO, BR- GO INSERT THE DEVICE ADDR R4
         MVI   0(WA),C'('          INSERT OPEN PAREN                 R4
COF&R.3  MVC   1(L'RATNAME,WA),RATNAME-RATDSECT(R15) MOVE IN RMT ID  R4
         LA    WA,L'RATNAME(,WA)   POINT TO LAST BYTE OF REMOTE ID   R4
COF&R.0  CLI   0(WA),C' '          IS THIS A BLANK CHARACTER         R4
         BNE   *+8                 SKIP NEXT INSTR. IF NON-BLANK     R4
         BCT   WA,COF&R.0          BACK UP ONE BYTE AND LOOP TO TEST R4
         MVI   1(WA),C')'          MOVE CLOSING PAREN AFTER CHAR     R4
         LA    WA,3(,WA)           STEP PAST CHAR, PAREN, AND BLANK  R4
COF&R.W  DS    0H                                                    R4
         TM    MDCTTYPE-DCTDSECT(R1),DCTPSNA TEST FOR SNA LINES      R4
         BNO   COF&R.C             NO, GO FIND UCB ADDRESS           R4
COFI&R   MVC   COMMAND+10(3),=CL3'SNA' INSERT SNA IN UNIT ADDR FIELD R4
         B     COF&R.D             SKIP UCB LOCATE                   R4
COF&R.C  L     R1,DCTDCB-DCTDSECT(0,R1) PICK UP DCB
         L     R1,DCBDEBAD-DCBDSECT(0,R1) PICK UP DEB
         OC    DEBTCBAD+1-DEBDSECT(3,R1),DEBTCBAD+1-DEBDSECT(R1)
         BZ    COF&R.D             IF DEB NOT INITIALIZED, MESSAGE SET
         ICM   R1,7,DEBSUCBB-DEBDSECT(R1)  GET UCB, IS IT SET...     R4
         BZ    COF&R.D             IF NOT, MESSAGE COMPLETE
         MVC   COMMAND+10(3),UCBNAME-UCBDSECT(R1) INSERT UNIT ADDRESS
         EJECT                                                      R41
***********************************************************************
*        TEST FOR EXTENDED DISPLAY OF DCT                             *
***********************************************************************
         SPACE 1
COF&R.D  DS    0H                  CHECK FOR EXTENDED DISPLAY
         TM    COMEWORK,X'FF'      WAS INPUT ADDR A -RAT            R41
         BO    COFT&R              YES GO DISPLAY RAT INFO          R41
         L     R1,COMEWORK         RESTORE DCT POINTER
         CLI   DCTDEVTP-DCTDSECT(R1),DCTRCON TEST FOR REMOTE CONS.  R41
         BE    COF&R.X             WRITE MESSAGE AND EXIT           R41
         TM    COMEWORK,X'FF'      TEST FOR EXTENDED DISPLAY
         BZ    COF&R.X             NO-- WRITE MESSAGE AND EXIT       R4
***********************************************************************
*        EXTENDED DISPLAY OF DCT IS DESIRED                           *
***********************************************************************
         CLI   DCTDEVTP-DCTDSECT(R1),DCTLNE  CHECK FOR RJE LNE
         BE    COF&R.F             YES--GO DISPLAY A LINE
         CLI   DCTDEVTP-DCTDSECT(R1),DCTLOG TEST FOR LOGON DCT       R4
         BE    COF&R.Z             YES, BR - DISPLAY LOGON DCT       R4
***********************************************************************
*        FORMAT JOB NUMBER AND NAME IF DEVICE IS ACTIVE               *
***********************************************************************
         TM    DCTSTAT-DCTDSECT(R1),DCTINUSE  TEST FOR ACTIVITY
         BZ    COF&R.G             NO--FORGET JOB PORTION
         SPACE 1
         L     R15,DCTPCE-DCTDSECT(,R1)  GET POINTER TO PCE
         L     R15,PCEJQE-PCEDSECT(,R15) GET THE JQE ADDRESS   @OZ32566
*              THIS LINE DELETED BY APAR NUMBER                @OZ32566
*              THIS LINE DELETED BY APAR NUMBER                @OZ32566
*              THIS LINE DELETED BY APAR NUMBER                @OZ32566
*              THIS LINE DELETED BY APAR NUMBER                @OZ32566
         LA    R15,0(,R15)         PURIFY                            R4
         LTR   R15,R15             TEST FOR A JOB
         BZ    COF&R.G             NONE -- FORGET IT
         MVC   0(4,WA),=C'(JOB'    SET JOB PREFIX
         LH    R0,QUEJOBNO(,R15)   LOAD BINARY JOB NUMBER
         CH    R0,=H'10000'        CHECK FOR JOB
         BL    COF&R.7             YES -- CONVERT NBR TO EBCDIC
         MVC   1(3,WA),=C'TSU'     ASSUME TIME SHARING USER
         SH    R0,=H'20000'        CHECK ASSUMPTION
         BNM   COF&R.7             YES -- GO CONVERT NBR TO EBCDIC
         AH    R0,=H'10000'        NO -- MUST BE SYSTEM TASK
         MVC   1(3,WA),=C'STC'     ADJUST NBR AND MSG FOR SAME
COF&R.7  DS    0H                  CONVERT NUMBER TO EBCDIC
         CVD   R0,COMDWORK         CONVERT TO DECIMAL
         MVC   4(6,WA),=X'402020202120'  SET EDIT PATTERN
         ED    4(6,WA),COMDWORK+5  EDIT CONVERTED JOB NUMBER
         MVI   10(WA),C' '         SET BLANK AFTER NUMBER
         MVC   11(L'JQEJNAME,WA),QUEJNAME(R15) SET J NAME IN MSG
         LA    R15,L'JQEJNAME      SET MAX LENGTH OF JOB NAME
COF&R.H  CLI   11(WA),C' '         CHECK FOR END OF JOB NAME
         BE    *+12                YES -- TRUNCATE STRING
         LA    WA,1(,WA)           NO--POINT TO NEXT CHARACTER
         BCT   R15,COF&R.H         AND LOOP THROUGH NAME
         MVI   11(WA),C')'         END JOB PORTION
         LA    WA,13(,WA)          POINT TO NEXT BYTE OF MSG
         EJECT                                                      R41
***********************************************************************
*        TEST FOR PRT/PUN--YES--DISPLAY FORMS AND PAUSE               *
***********************************************************************
COF&R.G  NULL
         TM    DCTDEVTP-DCTDSECT(R1),DCTPRPU TEST FOR PRT/PUN
         BZ    COF&R.I             NO--GO TO READERS
         MVC   0(2,WA),=C'F='      SET FORMS PREFIX
         MVC   2(L'DCTFORMS,WA),DCTFORMS-DCTDSECT(R1) SET FORMS SP
         MVI   2+L'DCTFORMS(WA),C','   SET IN SEPERATOR
         TM    DCTPPSW-DCTDSECT(R1),DCTPPSWF CHECK FOR STD FORMS
         BZ    COF&R.J             NO -- HASP CONTROLLED
         MVC   2+L'DCTFORMS+1(4,WA),=C'OPER' SET OPERATOR CNTRL
         B     *+14                BR ARND NEXT
COF&R.J  DS    0H
         MVC   2+L'DCTFORMS+1(5,WA),=C'AUTOM' SET HASP CNTRLED
         LA    WA,1(,WA)           UP ONE FOR THE 'M'
         MVC   2+L'DCTFORMS+1+5(3,WA),=C'P=N' SET PAUSE AS NO
         TM    DCTPPFL-DCTDSECT(R1),DCTPAUSE  CHECK FOR NO PAUSE
         BZ    *+8                 NO PAUSE LEAVE AS IS
         MVI   2+L'DCTFORMS+1+5+2(WA),C'Y' PAUSING -- SET 'Y'
         LA    WA,2+L'DCTFORMS+1+5+4(,WA)  POINT TO NEXT BYTE
***********************************************************************
*        ROUTING OF PRINT/PUNCH DEVICE                                *
***********************************************************************
         LA    R15,DCTNO-DCTDSECT(,R1) POINT TO ROUTE CODE           R4
         LA    R0,1(,WA)           POINT TO TEXT AREA                R4
         BAL   R14,COFRTC          CONVERT TO EBCDIC                 R4
         MVC   0(2,WA),=C'R='      SET KEYWORD                       R4
         LA    WA,11(,WA)          POINT TO NEXT SLOT                R4
         TM    DCTDEVTP-DCTDSECT(R1),DCTPUN  TEST FOR PUNCHES
         BO    COF&R.K             IF SO SKIP FCB UCS SPC MSG
         EJECT                                                      R41
***********************************************************************
*        PRINTERS ONLY -- FCB, UCS, AND SPACING ATTRIBUTES            *
***********************************************************************
         MVC   0(2,WA),=C'C='      SET FCB PREFIX
         MVC   2(L'DCTFCB,WA),DCTFCB-DCTDSECT(R1) SET FCB
         LA    R15,2+L'DCTFCB      LENGTH OF FCB ID                  R4
         CLI   2(WA),C'*'          TEST FOR NULL SETTING             R4
         BNE   *+12                BR IF NO                          R4
         LA    R15,2+1             ELSE, PRINT A                     R4
         MVI   2+1(WA),C' '         SINGLE '*'                       R4
         LA    WA,0(WA,R15)        POINT TO NEXT FREE BYTE           R4
         TM    DCTPPSW-DCTDSECT(R1),DCTPPSWB TEST FOR STD FCB
         BO    *+14                NO--DON'T FLAG AS STD FCB
         MVC   0(4,WA),=C',STD'    SET AS STANDARD                   R4
         LA    WA,4(,WA)           POINT TO NEXT BYTE
         LA    WA,1(,WA)           POINT TO NEXT MESSAGE AREA        R4
         MVC   0(2,WA),=C'T='      SET TRAIN PREFIX
         MVC   2(L'DCTUCS,WA),DCTUCS-DCTDSECT(R1) SET TRAIN
         TM    DCTPPSW-DCTDSECT(R1),DCTPPSWU TEST FOR STD UCS
         BO    *+14                NO--DON'T ADD TO MSG
         MVC   2+L'DCTUCS(4,WA),=C',STD'  SET STD UCS ON PRT
         LA    WA,4(,WA)           POINT TO NEXT BYTE
         LA    WA,2+L'DCTUCS+1(,WA)      POINT TO NEXT BYTE
         SPACE 1
***********************************************************************
*        SET SPACING ATTRIBUTES IF PRESENT                            *
***********************************************************************
         TM    DCTFLAGS-DCTDSECT(R1),DCTSPACE  CHECK FOR SPCING
         BZ    COF&R.K             NONE -- SKIP MESSAGE
         MVC   0(2,WA),=C'K='      SET SPACING PREFIX
         LA    R15,X'F0'           SET ZERO SPACING (F0)
         TM    DCTFLAGS-DCTDSECT(R1),2  CHECK FOR DOUBLE SPACING
         BZ    *+8                 NO--DON'T INDICATE AS SUCH
         LA    R15,2(,R15)         YES--MAKE 'F2' TWO
         TM    DCTFLAGS-DCTDSECT(R1),1  TEST FOR SINGLE SPACING
         BZ    *+8                 NO--DON'T INDICATE AS SUCH
         LA    R15,1(,R15)         YES--ADD ONE(EITHER F1 OR F3)
         STC   R15,2(,WA)          STORE SPACING CHARACTER
         LA    WA,4(,WA)           POINT TO NEXT MSG BYTE
         SPACE 2
***********************************************************************
*        REJOIN PUNCH AND PRINTERS--SERPERATORS AND CLASSES           *
***********************************************************************
COF&R.K  NULL
         MVC   0(3,WA),=C'S=Y'     ASSUME SEPERATOES USED
         TM    DCTPPSW-DCTDSECT(R1),DCTPPSWS  TEST FOR SAME
         BZ    *+8                 SEPERATORS BRANCH
         MVI   2(WA),C'N'          NO SEPERATORS--INDICATE SO
         LA    WA,4(,WA)           FIND NEXT MSG AREA
         EJECT                                                      R41
***********************************************************************
*        SET OUTPUT CLASSES FOR PRINTER AND PUNCH                     *
***********************************************************************
         MVC   0(2,WA),=C'Q='      SET CLASS STRING INDENTIFIER
         SLR   R15,R15             SET MAX SYSOUT                    R4
         IC    R15,$NUMCLAS         CLASSES IN STRING                R4
         BCTR  R15,0               LESS ONE FOR MACHINE
         EX    R15,COF&R.1         MOVE STRING TO MSG AREA
         LA    R14,1               SET INCREMENT
COF&R.L  CLI   2(WA),C' '          CHECK FOR END OF CLASSES
         BE    COF&R.M             YES  EXIT SCAN RTN
         ALR   WA,R14              UP BY ONE TILL END OF STRING
         B     COF&R.L             AND LOOP TILL END OF STRING
COF&R.M  DS    0H                  END OF STRING
         LA    WA,3(,WA)           POINT TO NEXT MSG BYTE
***********************************************************************
*        DISPLAY COMPACTION NUMBER                                    *
***********************************************************************
COFH&R   TM    MDCTFEAT-DCTDSECT(R1),DCTPCPCT TEST FOR COMPACTION   R41
         BZ    COFJ&R              NO,SKIP PROCESSING               R41
         MVC   0(2,WA),=C'Z='      MOVE COMPACTION INDICATOR        R41
         SLR   R0,R0               CLEAR REGISTER                   R41
         IC    R0,DCTDCPTN-DCTDSECT(,R1) INSERT COMPACTION NUMBER   R41
         CVD   R0,COMDWORK         CONVERT TO DECIMAL               R41
         MVC   2(4,WA),=X'40202120' SET EDIT PATTERN                R41
         ED    2(4,WA),COMDWORK+6  EDIT FOR PRINT                   R41
         CLI   4(WA),C' '          TEST IF NUMBER BETWEEN 0-9       R41
         BNE   COFK&R              SKIP IF COMPACTION 0-9           R41
         MVC   2(1,WA),5(WA)       MOVE 1 BYTE COMPACTION NUMBER    R41
         LA    WA,3(,WA)           UPDATE POINTER TO MESSAGE AREA   R41
         B     COFJ&R              BYPASS 2 BYTE COMPACTION NUMBER  R41
COFK&R   MVC   2(2,WA),4(WA)       MOVE TWO BYTES TO MESSAGE        R41
         LA    WA,4(,WA)           UPDATE POINTER TO MESSAGE AREA   R41
         MVI   0(WA),X'40'         CLEAN FOR 1 LINE DISPLAY         R41
COFJ&R   TM    DCTPPSW2-DCTDSECT(R1),DCTNIPRT TEST FOR 3800 PRINTER R41
         BZ    COF&R.X             BR IF NOT                         R4
         SPACE 1                                                     R4
***********************************************************************
*        3800 PRINTERS ONLY--BURST,MARK,CHARS,FLASH AND MODIFY        *
***********************************************************************
         MVC   0(7,WA),=C'B=N M=N' ASSUME NO BURST AND NO EDGE-MARK  R4
         TM    DCTPPSW2-DCTDSECT(R1),DCTNIBRS TEST FOR BURST MODE    R4
         BZ    *+8                 BR IF NO                          R4
         MVI   2(WA),C'Y'          ELSE INDICATE BURST MODE          R4
         TM    DCTPPSW2-DCTDSECT(R1),DCTNIMRK  TEST EDGE-MARK MODE   R4
         BZ    *+8                 BR IF NO                          R4
         MVI   6(WA),C'Y'          ELSE INDICATE EDGE-MARK MODE      R4
         LA    WA,7+1(,WA)         POINT TO NEXT MSG AREA            R4
         SPACE 1                                                     R4
         CLC   DCTCHAR1-DCTDSECT(4,R1),=C'****'  TEST FOR CHAR SET   R4
         BE    COFU&R              BR IF END OF CHARS LIST           R4
         MVC   0(3,WA),=C'X1='     MOVE IN CHAR SET PREFIX           R4
         MVC   3(L'DCTCHAR1,WA),DCTCHAR1-DCTDSECT(R1) SET CHAR1 ID   R4
         LA    WA,3+L'DCTCHAR1+1(,WA)  POINT TO NEXT MSG AREA        R4
         CLC   DCTCHAR2-DCTDSECT(4,R1),=C'****'  TEST FOR CHAR SET   R4
         BE    COFU&R              BR IF END OF CHARS LIST           R4
         MVC   0(3,WA),=C'X2='     MOVE IN CHAR SET PREFIX           R4
         MVC   3(L'DCTCHAR2,WA),DCTCHAR2-DCTDSECT(R1) SET CHAR2 ID   R4
         LA    WA,3+L'DCTCHAR2+1(,WA)  POINT TO NEXT MSG AREA        R4
         CLC   DCTCHAR3-DCTDSECT(4,R1),=C'****'  TEST FOR CHAR SET   R4
         BE    COFU&R              BR IF END OF CHARS LIST           R4
         MVC   0(3,WA),=C'X3='     MOVE IN CHAR SET PREFIX           R4
         MVC   3(L'DCTCHAR3,WA),DCTCHAR3-DCTDSECT(R1) SET CHAR3 ID   R4
         LA    WA,3+L'DCTCHAR3+1(,WA)  POINT TO NEXT MSG AREA        R4
         CLC   DCTCHAR4-DCTDSECT(4,R1),=C'****'  TEST FOR CHAR SET   R4
         BE    COFU&R              BR IF END OF CHARS LIST           R4
         MVC   0(3,WA),=C'X4='     MOVE IN CHAR SET PREFIX           R4
         MVC   3(L'DCTCHAR4,WA),DCTCHAR4-DCTDSECT(R1) SET CHAR4 ID   R4
         LA    WA,3+L'DCTCHAR4+1(,WA)  POINT TO NEXT MSG AREA        R4
         EJECT                                                      R41
COFU&R   NULL                                                        R4
         CLC   DCTFLASH-DCTDSECT(4,R1),=C'****'  TEST FOR FLASH ID   R4
         BE    *+20                BR IF NOT SET                     R4
         MVC   0(2,WA),=C'O='      SET FLASH PREFIX                  R4
         MVC   2(L'DCTFLASH,WA),DCTFLASH-DCTDSECT(R1)  SET FLASH ID  R4
         LA    WA,2+L'DCTFLASH+1(,WA)  POINT TO NEXT MSG AREA        R4
         SPACE 1                                                     R4
         CLC   DCTMODF-DCTDSECT(4,R1),=C'****'  TEST FOR MODIFY ID   R4
         BE    *+20                BR IF NOT SET                     R4
         MVC   0(2,WA),=C'Y='      SET MODIFY PREFIX                 R4
         MVC   2(L'DCTMODF,WA),DCTMODF-DCTDSECT(R1)  SET MODIFY ID   R4
         LA    WA,2+L'DCTMODF+1(,WA) POINT TO NEXT MSG AREA          R4
         B     COF&R.X             AND EXIT DISPLAY
COF&R.1  MVC   2(*-*,WA),DCTCLASS-DCTDSECT(R1) ** EXECUTE ONLY **
         SPACE 2
***********************************************************************
*        DISPLAY READERS--DEFAULT JOB AND MSG CLASSES                 *
***********************************************************************
COF&R.I  NULL
         MVC   0(6,WA),=C'C=  Q='  SET JOB MSG PREFIXES
         CLC   DCTDEVN-DCTDSECT(,R1),=CL8'STCINRDR' TEST STC   @OZ25941
         BE    COFV&R              BRANCH IF STCINRDR          @OZ25941
         CLC   DCTDEVN-DCTDSECT(,R1),=CL8'TSOINRDR' TEST TSO   @OZ25941
         BNE   COFW&R              BRANCH IF NOT TSOINRDR      @OZ25941
COFV&R   DS    0H                                              @OZ25941
         MVI   2(WA),C'*'        SET DEFAULT JOB CLASS         @OZ25941
         B     COFX&R              BRANCH FOR MSG CLASS        @OZ25941
COFW&R   DS    0H                                              @OZ25941
         MVC   2(1,WA),DCTJCLAS-DCTDSECT(R1) SET DEFAULT JOB CLASS
COFX&R   DS    0H                                              @OZ25941
         MVC   6(1,WA),DCTMCLAS-DCTDSECT(R1) SET DEFAULT MSG CLASS
         LA    WA,8(,WA)           POINT TO NEXT MSG BYTE
         SPACE 1
         TM    DCTDEVTP-DCTDSECT(R1),DCTRJE SEPERATE REMOTE READER
         BO    COF&R.N             BR IF REMOTE READER
***********************************************************************
*        DISPLAY AUTHORITY FOR LOCAL AND INTERNAL READERS             *
***********************************************************************
         MVC   0(2,WA),=C'A='      SET AUTHORITY PREFIX
         SLR   R15,R15             CLEAR WORK FOR INSERT CHAR
         IC    R15,DCTRAUTH-DCTDSECT(,R1)  GET AUTHORITY
         LA    R0,DCTREJJB+DCTREJDV+DCTREJSY  SET NO AUTHORITY
         NR    R15,R0              TO TURN OFF MISC BITS
***********************************************************************
*        TABLE HAS TWO BYTE ENTRIES                                   *
***********************************************************************
         ALR   R15,R15             DOUBLE R15 VALUE
         LA    R14,COF&R.O         GET ADDRESS OF DISPLACEMENT
*                                  AND LENGTH TABLE
         SLR   R1,R1               CLEAR R1
         IC    R1,0(R15,R14)       GET DISPLACEMENT IN TBL
         LA    R1,COF&R.P(R1)      POINT TO MSG
         IC    R15,1(R15,R14)      GET MACHINE LENGTH
         EX    R15,COF&R.Q         MOVE MSG TO AREA
         LA    WA,4(R15,WA)        PT TO NXT AVAILABLE MSG BYTE
         L     R1,COMEWORK         RESTORE R1 CONTENTS
COF&R.N  DS    0H                                                    R4
         EJECT                                                      R41
***********************************************************************
*        DEFAULT ROUTINGS FOR A READER                                *
***********************************************************************
         LA    R15,DCTPRINT-DCTDSECT(,R1) POINT TO PRINTER DEFAULT   R4
         LA    R0,1(,WA)           POINT TO TEXT AREA                R4
         BAL   R14,COFRTC          CONVERT TO EBCDIC                 R4
         MVC   0(2,WA),=C'P='      SET KEYWORD                       R4
         LA    WA,11(,WA)          POINT TO NEXT SLOT                R4
         LA    R15,DCTPUNCH-DCTDSECT(,R1) POINT TO PUNCH DEFAULT     R4
         LA    R0,1(,WA)           TEXT AREA                         R4
         BAL   R14,COFRTC          CONVERT TO EBCDIC                 R4
         MVC   0(2,WA),=C'U='      SET KEYWORD                       R4
         LA    WA,11(,WA)          POINT TO NEXT SLOT                R4
***********************************************************************
*        DISPLAY SYSTEM AFFINITIES OF A READER                        *
***********************************************************************
         MVC   0(2,WA),=C'S='      SET AFFINITY PREFIX
         TM    DCTSIAFF-DCTDSECT(R1),QUEINDAF TEST FOR 'IND' MODE
         BZ    *+14                NO--SKIP INSERTION IN MSG
         MVC   2(4,WA),=C'IND,'    SET 'IND' MODE IN MSG
         LA    WA,4(,WA)           PT TO NEXT MSG BYTE
         TM    DCTSIAFF-DCTDSECT(R1),QUESYSAF TEST FOR AFF OF 'ANY'
         BNO   COF&R.8             NO--SEARCH QSE TABLE
         MVC   2(3,WA),=C'ANY'     YES--SET 'ANY' IN MESSAGE
         LA    WA,6(,WA)           POINT TO NEXT AVAILABLE BYTE
         B     COF&R.9             AND EXIT TO NEXT PORTION
COF&R.8  DS    0H                  SEARCH QSE TABLE FOR AFFINITIES
         L     R15,$QSE1           POINT TO 1ST QSE                  R4
         SH    R15,$QSEL           BACK UP ONE QSE                   R4
         USING QSEDSECT,R15        QSE ADDRESSABILITY
COFB&R   AH    R15,$QSEL           POINT TO NEXT QSE                 R4
         IC    R14,QSESIAFF        PICK UP AFFINITY BITS             R4
         EX    R14,COFA&R          TEST FOR AFFINITY TO THIS SYSTEM
         BO    COFC&R              YES--FILL-IN MESSAGE
COFD&R   TM    QSEFLAGS,QSELAST    NO--TEST FOR LAST ELEMENT
         BZ    COFB&R              IF NOT LAST LOOP THRU QSE TABLES
         MVI   1(WA),C' '          SET BLANK WHERE ',' WAS
         LA    WA,2(,WA)           POINT TO NEXT AVAILABLE MSG BYTE
         B     COF&R.9             AND EXIT TO NEXT PORTION
COFC&R   DS    0H                  AFFINITY MATCH-MOVE IN SID NAME
         MVC   2(L'QSESID,WA),QSESID SET SID NAME IN MESSAGE
         MVI   L'QSESID+2(WA),C',' SET SEPERATING COMMA
         LA    WA,L'QSESID+1(,WA)  POINT TO NEXT AVAILABLE BYTE
         B     COFD&R              AND SCAN NEXT TABLE ELEMENT
         DROP  R15                 DROP QSE ADDRESSABILITY
COFA&R   TM    DCTSIAFF-DCTDSECT(R1),*-* **** EXECUTE ONLY ****
         EJECT                                                      R41
***********************************************************************
*        DISPLAY A READER HOLDING INCOMING JOBS                       *
***********************************************************************
COF&R.9  DS    0H                  DISPLAY READER'S HOLDING STATUS
         MVC   0(3,WA),=C'H=N'     SET DEFAULT STATUS
         TM    DCTFLAGS-DCTDSECT(R1),DCTHOLDJ  TEST FOR SAME
         BZ    *+8                 EXIT IF NOT 'HOLDING'
         MVI   2(WA),C'Y'          SET STATUS TO 'HOLDING'
         LA    WA,4(,WA)           POINT TO END OF MESSAGE
         B     COF&R.X             EXIT DISPLAY ROUTINE
         SPACE 2                                                     R4
***********************************************************************
*        DISPLAY RJE LINE DISCONNECTION STATE                         *
***********************************************************************
COF&R.F  DS    0H                                                    R4
         TM    MDCTSTAT-DCTDSECT(R1),DCTSOFF TEST SIGNOFF PENDING    R4
         BNO   COF&R.R             NO, BR--GO FORMAT PASSWORD        R4
         MVC   0(3,WA),=C'D=Q'     SHOW SIGNOFF PENDING              R4
COFF&R   TM    DCTFLAGS-DCTDSECT(R1),DCTRSTRT TEST FOR DCT RESTARTED R4
         BNO   COFG&R              NO, BR--GO SHOW DISCONNECT STATUS R4
         MVC   0(3,WA),=C'D=I'     INDICATE RESTART ACCEPTED         R4
COFG&R   DS    0H                                                    R4
         LA    WA,4(,WA)           MOVE PAST DISCONNECT INDICATOR    R4
         B     COF&R.R             GO FORMAT PASSWORD                R4
         SPACE 2                                                     R4
***********************************************************************
*        DISPLAY LOGON DCT APPLICATION ID                             *
***********************************************************************
COF&R.Z  DS    0H                                                    R4
         MVC   0(2,WA),=C'A='      MOVE IN APPLICATION ID PREFIX     R4
         MVC   2(8,WA),MDCTAPPL-DCTDSECT(R1) AND APPLICATION ID      R4
         LA    WA,11(,WA)          MOVE PAST APPLICATION ID FIELD    R4
         SPACE 2                                                     R4
***********************************************************************
*        DISPLAY DCT LOGGING AND PASSWORD STATUS                      *
***********************************************************************
COF&R.R  DS    0H                                                    R4
         MVC   0(3,WA),=C'E=N'     ASSUME NO LOGGING                 R4
         TM    DCTFLAGS-DCTDSECT(R1),DCTLOGAL TEST ASSUMPTION        R4
         BZ    COFE&R              CORRECT, BR - SKIP RESET          R4
         MVI   2(WA),C'Y'          MAKE MESSAGE SHOW LOGGING         R4
COFE&R   DS    0H                                                    R4
         LA    WA,4(,WA)           MOVE PAST LOGGING INDICATOR       R4
         CLI   MDCTPSWD-DCTDSECT(R1),C' ' TEST FOR PASSWORD SET      R4
         BE    COF&R.X             NO, BR - MESSAGE IS COMPLETE      R4
         MVC   0(5,WA),=C'P=SET'   INDICATE PASSWORD PRESENT         R4
         LA    WA,6(,WA)           LOCATE END OF MESSAGE             R4
         EJECT                                                      R41
***********************************************************************
*        EXIT EXTENDED DISPLAY ROUTINE                                *
***********************************************************************
COF&R.X  DS    0H                  COMPUTE RESPONSE SIZE
         LR    R1,WA               COPY END OF RESPONSE ADDRESS
         LA    R15,COMMAND+69      SET MAX RESPONSE SIZE
COF&R.4  CLR   R1,R15              CHECK SIZE OF THIS RESPONSE
         BNH   COF&R.U             IF NOT TOO LARGE - SEND IT
COF&R.T  BCTR  R1,0                TOO LARGE-SCAN TO BREAK-UP
         CLI   0(R1),C'='          LOOK FOR AN OPERAND
         BNE   COF&R.T             NOT FOUND, BR - KEEP LOOKING      R4
         BCTR  R1,0                LOOK AT CHARACTER BEFORE = SIGN   R4
         CLI   0(R1),C'0'          IS IT A NUMBER                    R4
         BL    *+6                 NO - BACK UP ONE MORE             R4
         BCTR  R1,0                YES - BACK UP TWO MORE            R4
         BCTR  R1,0                POINT AT BLANK BEFORE OPERAND     R4
         B     COF&R.4             AND CHECK RESULTANT SIZE
COF&R.U  DS    0H                  RESPONSE OF PROPER SIZE - SEND
         LA    R0,1(,R1)           TRUE END OF RESPONSE
         LA    R14,COMMAND         BEGINNING OF RESPONSE
         SLR   R0,R14              LENGTH OF RESPONSE
         CLR   R1,WA               IS THIS A ONE-LINE RESPONSE
         BE    COF&R.V             YES--SKIP MULTIPLE LINES
         STM   R1,WA,COMDWORK      SAVE REGS OVER $WTO
         $CWTO L=(R0)              SEND RESPONSE
         LM    R1,WA,COMDWORK      RELOAD REGS
         SLR   WA,R1               COMPUTE SIZE OF RESPONSE LEFT
         BCTR  WA,0                LESS ONE FOR TRUE SIZE
         LA    R0,COMMAND+23-COMMAND(,WA) SAVE TOTAL SIZE
         BCTR  WA,0                MACHINE SIZE
         EX    WA,COF&R.Y          MOVE NEW RESPONSE DOWN
         MVI   COMMAND,C' '        BLANK AREA BEFORE SECOND LINE
         MVC   COMMAND+1(22),COMMAND DITTO
         LA    WA,COMMAND+23+1(WA) POINT TO END OF NEW RESPONSE
         LR    R1,WA               COPY TO R1 FOR LOOP
         LA    R15,COMMAND+69      SET MAX RESPONSE SIZE
         CLR   R1,R15              CHECK REMAINING RESPONSE
         BH    COF&R.T             IF GREATER LOOP
COF&R.V  DS    0H                                                    R4
COF&R.2  $CWTO L=(R0)              WRITE FINAL MESSAGE               R4
         L     R1,COMEWORK         RELOAD DCT                        R4
         L     WA,COMFWORK          RETURN REGISTER                  R4
         LR    BASE3,WA            RELOAD CALLERS BASE               R4
         SH    BASE3,0(,WA)        ADJUST CALLERS ADDRESSABILITY     R4
         B     2(,WA)              RETURN TO CALLER                  R4
COF&R.Y  MVC   COMMAND+23(*-*),1(R1) **** EXECUTE ONLY ****
         EJECT                                                      R41
***********************************************************************
*        DISPLAY RAT DATA                                             *
***********************************************************************
COFT&R   DS    0H                                                   R41
         L     R1,COMEWORK         PICK UP PASSED RAT ADDRESS       R41
         LPR   R1,R1               MAKE POSITIVE                    R41
         MVC   COMMAND(8),RATNAME-RATDSECT(R1) PUT IN PROPER NAME   R41
         MVC   0(3,WA),=C'D=0'     SET UP FOR D=0                   R41
         SLR   R0,R0               CLEAR REG                        R41
         IC    R0,RATDINTV-RATDSECT(R1) GET RAT INTERVAL            R41
         SLA   R0,5                EXPAND IT                        R41
         LTR   R0,R0               IS IT ZERO                       R41
         BZ    COFM&R              YES, LEAVE IT AS IS              R41
         CVD   R0,COMDWORK         NO,  CONVERT TO DISPLAY          R41
         UNPK  2(5,WA),COMDWORK+5(3) PUT INTERVAL IN DISPLAY        R41
         OI    6(WA),X'F0'         MAKE UNITS DIGIT READABLE        R41
         MVC   2(4,WA),3(WA)       LEFT JUSTIFY D=NNNN              R41
         MVI   6(WA),X'40'         CLEAR RIGHT MOST POSITION        R41
         CLI   2(WA),X'F0'         IS LEFTMOST SIGNIFICANT          R41
         BH    COFM&R              YES, LEAVE AS IS                 R41
         MVC   2(3,WA),3(WA)       LEFT JUSTIFY TO D=NNN            R41
         MVI   5(WA),X'40'         CLEAR RIGHT MOST POSITION        R41
         CLI   2(WA),X'F0'         IS LEFTMOST SIGNIFICANT          R41
         BH    COFM&R              YES, LEAVE AS IS                 R41
         MVC   2(2,WA),3(WA)       LEFT JUSTIFY TO D=NN             R41
         MVI   4(WA),X'40'         CLEAR RIGHT MOST POSITION        R41
COFM&R   LA    WA,7(,WA)           ADJUST POSITION COUNT            R41
         TM    RATTYPE-RATDSECT(R1),DCTPLU1 IS THIS SNA             R41
         BNO   COF&R.X             NO, SKIP A=                      R41
         MVC   0(7,WA),=C'A=N S=N' ASSUME A=N AND S=N               R41
         TM    RATFLAGS-RATDSECT(R1),RATALM IS IT A=N               R41
         BZ    *+8                 YES, LEAVE IT AS IS              R41
         MVI   2(WA),C'Y'          NO, MAKE IT A=Y                  R41
         TM    RATFLAGS-RATDSECT(R1),RATSRMT  IS IT S=N             R41
         BZ    *+8                 YES, LEAVE AS IS                 R41
         MVI   6(WA),C'Y'          MAKE IT S=Y                      R41
         LA    WA,7(WA)            ADJUST POSITION COUNTER          R41
         B     COF&R.X             WRITE MESSAGE & EXIT             R41
         SPACE 2                                                    R41
         DROP  BASE3               RELEASE ROUTINE ADDRESSABILITY   R41
         EJECT                                                      R41
***********************************************************************
*        AUTHORITY MSG TABLE                                          *
***********************************************************************
COF&R.P  DC    C'SYS+DEV+JOB+SYSDISPLAY' ALL POSSIBLE MSGS
         SPACE 2
***********************************************************************
*        DISPLACEMENT AND LENGTH TABLE                                *
*        EACH ENTRY HAS DISPLACEMENT INTO ABOVE TABLE AND LENGTH      *
*        FOR EACH AUTHORITY LEVEL                                     *
***********************************************************************
COF&R.O  DC    AL1(00,10)          AUTH=SYS+JOB+DEV LENGTH=11
         DC    AL1(04,06)          AUTH=DEV+JOB     LENGTH=7
         DC    AL1(08,06)          AUTH=JOB+SYS     LENGTH=7
         DC    AL1(08,02)          AUTH=JOB         LENGTH=3
         DC    AL1(00,06)          AUTH=SYS+DEV     LENGTH=7
         DC    AL1(04,02)          AUTH=DEV         LENGTH=3
         DC    AL1(00,02)          AUTH=SYS         LENGTH=3
         DC    AL1(15,06)          AUTH=DISPLAY     LENGTH=7
         SPACE 2
         DS    0H                  ASSURE HALFWORD ALIGNMENT
COF&R.Q  MVC   2(*-*,WA),0(R1)     **** EXECUTE ONLY ****
*        INSTRUCTION IS USED TO MOVE AUTHORITY MSGS TO MSG AREA
.XIT     MEND
         EJECT
         MACRO -- $CFDCTL -- DEVICE CONTROL TABLE LOCATE
&NAME    $CFDCTL &POINTER=(R1),&TYPE=CALL,&INFO=NO
         GBLC  &DOC
         LCLC  &R
&R       SETC  '&SYSNDX'
         AIF   ('&INFO' EQ '' AND '&DOC' EQ 'NO' OR '&INFO' EQ 'NO').Z
         AIF   ('&TYPE' EQ 'RES').NOJECT
         EJECT
.NOJECT  SPACE 2
***********************************************************************
*                                                                     *
*        COFDCTL -- DEVICE CONTROL TABLE LOCATE                       *
*                                                                     *
*        ROUTINE EXAMINES DEVICE NAMED BY THE CURRENT OPERAND         *
*        'POINTER', CONVERTS OPERAND TO EIGHT CHARACTER FORMAT,       *
*        AND LOCATES THE DCT.                                         *
*        NO $WAITS ARE ISSUED.                                        *
*                                                                     *
* REGISTERS USED                                                      *
*        R0    = WORK REGISTER                                        *
*        R1    = OPERAND POINTER - ADDRESS OF DCT,-RAT, OR ZERO       *
*        R15   = WORK REGISTER                                        *
*        LINK  = RETURN LINKAGE                                       *
*                                                                     *
* NOTES                                                               *
*        COMEWORK AND COMDWORK ARE USED FOR SCRATCH.  NOTE THAT       *
*              THIS ROUTINE IS DEPENDENT ON COMDWORK ALWAYS           *
*              FOLLOWING COMEWORK IN THE WORK AREA.                   *
*                                                                     *
***********************************************************************
.Z       ANOP
         AIF   ('&TYPE' NE 'CALL').INL
&NAME    $DECODE &POINTER
.CAL     BAL   LINK,COFDCTL        LOCATE DCT
         MEXIT
.INL     ANOP
&NAME    NULL
***********************************************************************
* SEPARATE DEVICE NAME                                                *
***********************************************************************
         MVC   COMEWORK(8),=CL8' ' CLEAR WORK AREA TO BLANKS
         L     R15,4(,R1)          LOCATE NEXT OPERAND
         LA    R15,0(,R15)         CLEAR HI-ORDER BYTE               R4
         L     R1,0(0,R1)          LOCATE THIS ONE
         SR    R15,R1              LENGTH OF OPERAND + 1
         BCT   R15,*+8             ACTUAL LENGTH
         B     COF&R.Z             COMPARE AGAINST BLANK IF NULL     R4
         BCTR  R15,0               MACHINE LENGTH
         LA    R0,7                SET MAXIMUM LENGTH
         CLR   R15,R0              TEST FOR WITHIN MAXIMUM
         BNH   *+6                 ACCEPT CURRENT LENGTH IF YES
         LR    R15,R0              SET TO MOVE EIGHT CHARACTERS
         EX    R15,COF&R.N         MOVE COMPLETE OPERAND
         TM    COMFLAG,CMBFLAGW    TEST FOR RMT ENTERED COMMAND     R41
         BNO   COF&R.D             BR IF NOT - SKIP RMT DEV ABREV.  R41
         CLC   COMJSYS,$OWNSYS     CMD ENTERED THIS SYSTEM...       R41
         BNE   COF&R.D             BR IF NOT -- CANNOT BE RMT DEV   R41
         LA    R0,2                TEST FOR                         R41
         CLR   R0,R15                 3-BYTE OPERAND                R41
         BH    COF&R.D             MORE THAN 3, CANNOT BE RMT DEV   R41
         CLI   COMEWORK+2,C'0'     TEST 3RD CHARACTER FOR NUMERIC   R41
         BL    COF&R.D             NON-NUMERIC, CANNOT BE RMT DEV   R41
         CLC   =CL2'RD',COMEWORK   TEST FOR REMOTE READER           R41
         BE    COF&R.G             BR IF YES - GO CONVERT ABREV.    R41
         CLC   =CL2'PR',COMEWORK   TEST FOR REMOTE PRINTER          R41
         BE    COF&R.G             BR IF YES - GO CONVERT ABREV.    R41
         CLC   =CL2'PU',COMEWORK   TEST FOR REMOTE PUNCHES          R41
         BNE   COF&R.D             BR IF NO - CANNOT BE A RMT DEV   R41
COF&R.G  ICM   R0,7,COMEWORK       SAVE 3-CHARACTER OPERAND         R41
         LA    R15,COMEWORK+1      PICK UP WORK AREA ADDRESS + 1    R41
         SR    R1,R1               GET RMT NUMBER                   R41
         IC    R1,COMJRMT            FROM WHICH COMMAND ENTERED     R41
         BCTR  R1,0                    MINUS 1                      R41
         MH    R1,=AL2(RATTLE)     COMPUTE RAT                      R41
         AL    R1,$RATABLE           OFFSET                         R41
         MVI   COMEWORK,C'R'               SET UP REMOTE            R41
         MVC   COMEWORK+1(4),RATNAME-RATDSECT+3(R1)   NAME PREFIX   R41
         MVI   COMEWORK+4,C' '     FORCE REMAINDER                  R41
         MVC   COMEWORK+5(3),COMEWORK+4  TO BLANKS                  R41
         LA    R15,1(,R15)         BUMP TO NEXT CHARACTER           R41
         CLI   0(R15),C' '         TEST FOR BLANK                   R41
         BNE   *-8                 NON-BLANK, LOOP                  R41
         MVI   0(R15),C'.'         INSERT SEPARATOR                 R41
         LA    R15,1(,R15)         BUMP TO NEXT CHARACTER           R41
         STCM  R0,7,0(R15)         USE 3-CHAR OPERAND AS SUFFIX     R41
COF&R.D  DS    0H                                                   R41
         CLC   COMEWORK(3),=C'RMT' IS THIS RMTN FORMAT              R41
         BNE   COF&R.C             NO, SKIP MOVE                    R41
         MVC   COMEWORK+1(5),COMEWORK+3 COMPRESS TO RN FORMAT       R41
         LA    R15,COMEWORK+1      SET BXLE INDEX                   R41
         LA    R1,COMEWORK+4       SET MAX  3 DIGITS                R41
         LA    R0,1                SET TO SCAN 1 AT A TIME          R41
         SPACE 1                                                    R41
COF&R.H  CLI   0(R15),C','         CHECK FOR TERMINATING CHAR       R41
         BE    COF&R.P             YES, CONVERT RMT NUMBER          R41
         CLI   0(R15),C' '         CHECK FOR RMTN ONLY              R41
         BE    COF&R.P             YES , CONVERT RMT NUMBER         R41
         CLI   0(R15),C'0'         CHECK FOR VALID RANGE            R41
         BL    COF&R.U             NO, ERROR                        R41
         BXLE  R15,R0,COF&R.H      LOOP                             R41
         B     COF&R.U             ERROR IF 4 CHARS                 R41
         SPACE 1                                                    R41
COF&R.C  CLI   COMEWORK,C'R'       IS REMOTE SPECIFIED              R41
         BNE   COF&R.V             NO, SKIP RAT LOOKUP              R41
         CLI   COMEWORK+1,C'0'     IS THIS RN FORMAT                R41
         BL    COF&R.V             NO--SKIP RAT LOOK-UP
         LA    R15,COMEWORK+1      SET INDEX FOR BXLE
         LA    R1,COMEWORK+4       SET COMPORAND FOR 3 DIGITS
         LA    R0,1                SET INCREMENT FOR SCAN
         SPACE 1
COF&R.O  CLI   0(R15),C'.'         CHECK FOR TERMINATING CHAR
         BE    COF&R.P             YES--CONVERT RMT NBR TO BINARY
         CLI   0(R15),C'0'         CHECK FOR VALID RANGE
         BL    COF&R.U             IF LESS--ERROR IN OPERAND
         BXLE  R15,R0,COF&R.O      LOOP THROUGH OPERAND TILL '.'
         B     COF&R.U             OR FOUR CHAR--ERROR IF NOT FND
         EJECT                                                      R41
COF&R.P  NULL                      VALID FORMAT(IE. RNNN.)
         LR    R1,R15              SAVE POSITION OF '.'
         MVC   COMDWORK+4(3),1(R1) SAVE DEVICE NAME PORTION
         LA    R15,COMEWORK+1      FIND START OF NUMERIC AGAIN
         SR    R1,R15              COMPUTE SIZE OF FIELD
         BNP   COF&R.U             BRANCH IF NOT POSITIVE--ERROR
         BCTR  R1,0                REDUCE BY ONE FOR MACHINE
         LR    R0,WA               SAVE REG 2 OVER 'TRT'
         L     R15,=A(CVALIDTB)    POINT TO TEST TABLE               R4
         EX    R1,COF&R.R          TEST FOR VALID NUMERICS
         LR    WA,R0               RESTORE R2
         BNZ   COF&R.U             BRANCH IN ERROR IF NOT NUMERIC
         LM    R15,R0,COMDWORK     SAVE COMDWORK
         EX    R1,COF&R.S          PACK NUMERIC PORTION OF NAME
         CVB   R1,COMDWORK         CONVERT REMOTE NBR TO BINARY
         STM   R15,R0,COMDWORK     RESTORE COMDWORK
         LTR   R1,R1               TEST FOR A GOOD VALUE
         BNP   COF&R.U             ERROR IF NOT POSITIVE
COF&R.A  LH    R0,$NUMRJE          GET MAX NUMBER OF REMOTES         R4
         CLR   R1,R0               IS CONVERTED HIGHER
         BH    COF&R.U             YES -- ERROR
         BCTR  R1,0                LESS ONE FOR RAT DISPLACEMENT
         MH    R1,=Y(RATTLE)       GET OFFSET IN RAT TABLE
         L     R0,$RATABLE         POINT TO 1ST RAT ELEMENT          R4
         LTR   R0,R0               TEST FOR ANY RJE LINES
         BZ    COF&R.U             NONE -- ERROR
         ALR   R1,R0               COMPUTE LOCATION OF REMOTE
         CLC   COMDWORK+4(3),=C'CON' IS THIS CONSOLE
         BNE   COFL&R              SKIP TEST FOR $T COMMAND         R41
         CLI   COMVERB,C'T'        TEST IF $T CON COMMAND           R41
         BE    COF&R.X             EXIT WITH R1 POINTING TO -RAT
         B     COF&R.U             ERROR, ONLY $TRN.CON VALID       R41
COFL&R   CLI   COMDWORK+4,C' '     TEST IF ONLY RN SPECIFIED        R41
         BE    COF&R.X             YES, EXIT - R1 POINTING TO RAT   R41
         L     R1,RATRDCT-RATDSECT(,R1) FIND FIRST REMOTE DCT
         SPACE 1
COF&R.W  CLC   DCTDEVN-DCTDSECT(L'DCTDEVN,R1),COMEWORK LOOK FOR
         BER   LINK                DCT--IF FOUND RETURN WITH DCT
COF&R.B  L     R1,MDCTDCT-DCTDSECT(,R1) POINT TO NEXT DCT            R4
         LTR   R1,R1               TEST FOR END OF REMOTES DEV
         BNZ   COF&R.W             LOOP THROUGH RMT DEVICES
COF&R.U  SLR   R1,R1               IF RMT NOT FOUND INDICATE IT
         BR    LINK                AND RETURN
COF&R.X  LCR   R1,R1               COMPLEMENT RAT ADDRESS
         BR    LINK                RETURN
         SPACE 2
COF&R.R  TRT   COMEWORK+1(*-*),0(R15) *** EXECUTE ONLY ***           R4
COF&R.S  PACK  COMDWORK(L'COMDWORK),COMEWORK+1(*-*) * EXECUTE *
         SPACE 2
COF&R.V  NULL                      COME HERE WHEN NOT A RMT
         CLC   COMEWORK(3),=C'RDI' CHECK FOR INTERNAL RDR
         BNE   COF&R.Z             NO--SKIP 1ST INTRDR LOCATE
         L     R1,$SSVT            YES--POINT TO THE SSVT
         L     R1,$SVIRDRS-$SVDSECT(,R1) POINT TO 1ST INTRDR
COF&R.Y  CLC   DCTDEVN-DCTDSECT(6,R1),=C'INTRDR' CHECK FOR 1ST ONE
         BER   LINK                YES--RETORN WITH 1ST INTRDR
         ICM   R1,7,DCTCHAIN+1-DCTDSECT(R1) ELSE GET NEXT
         BNZ   COF&R.Y             AND LOOP FOR 1ST INTRDR
         SLR   R1,R1               ELSE FLAG AS NOT FOUND
         BR    LINK                AND RETURN TO CALLER
COF&R.Z  DS    0H                  COME HERE WHEN NOT INTRDR
         LA    R1,COFDCTPL         POINT R1 TO LAST TABLE ENTRY     R41
         CLI   COMEWORK+3,C'0'     IS 4TH CHARACTER NUMERIC...      R41
         BL    COF&R.E             BYPASS TABLE LOOKUP IF NOT       R41
         ICM   R0,15,COMEWORK+3    SAVE NUMERICS (BLANK-PADDED)     R41
         SPACE 1
***********************************************************************
*        CONVERT SHORT NAME OF DEVICE TO LONG NAME AS IN DCT          *
***********************************************************************
         LA    R1,COF&R.T          POINT TO CONVERT TABLE            R4
COF&R.L  IC    R15,3(0,R1)         PICK UP MACHINE LENGTH OF ANSWER
         CLC   COMEWORK(3),0(R1)   LOOK FOR MATCH
         BE    COF&R.F             IF MATCH, REPLACE WITH LONG FORM  R4
         LA    R1,14(,R1)          POINT TO NEXT TABLE ELEMENT       R4
         CLI   0(R1),X'FF'         CHECK FOR END OF TABLE
         BNE   COF&R.L             IF NOT, LOOP
         B     COF&R.E             IF END, EXIT
         SPACE 2
***********************************************************************
*                                                                     *
*        DEVICE ABBREVIATION TABLE                                    *
*                                                                     *
* NOTE--IF $NUMPRTS IS GREATER THAN 9, THE 2ND ENTRY IN THIS TABLE    *
*       IS MODIFIED AT INITIALIZATION TIME TO THE FOLLOWING FORMAT..  *
*                                                                     *
*        DC    C'PRT',X'05',C'PRINTR  ',Y($LNEDCT-HCTDSECT)           *
*                                                                     *
***********************************************************************
COF&R.T  DS    0H
         DC    C'LNE',X'03',C'LINE    ',Y($LNEDCT-HCTDSECT)          R4
COFPRINT DC    C'PRT',X'06',C'PRINTER ',Y($PRTDCT-HCTDSECT)          R4
         DC    C'PUN',X'04',C'PUNCH   ',Y($PUNDCT-HCTDSECT)          R4
         DC    C'RDR',X'05',C'READER  ',Y($RDRDCT-HCTDSECT)          R4
         DC    C'LGN',X'04',C'LOGON   ',Y($LOGNDCT-HCTDSECT)         R4
COFDCTPL DC    X'FF',C'   ',C'FILLER  ',Y($DCTPOOL-HCTDSECT)        R41
         EJECT
***********************************************************************
* ARGUMENT FOUND, MOVE NUMERIC PORTION INTO PLACE                     *
***********************************************************************
COF&R.F  EX    R15,COF&R.M         MOVE LONG FORM OF TEXT
         LA    R15,COMEWORK+1(R15) POINT TO END OF TEXT + 1         R41
         MVI   COMEWORK+8,C' '     MOVE IN FIELD DELIMITER          R41
         STCM  R0,15,0(R15)        MOVE NUMERICS IN AFTER TEXT      R41
         CLI   COMEWORK+8,C' '     DID WE TRUNCATE ANY DATA...      R41
         BE    COF&R.E             NO--GO TO LOCATE DCT              R4
         SLR   R1,R1               YES--ERROR--ZERO OUT DCT REG      R4
         BR    LINK                AND RETURN TO CALLER              R4
         SPACE 1                                                     R4
***********************************************************************
* LOCATE DEVICE CONTROL TABLE                                         *
***********************************************************************
COF&R.E  LH    R1,12(,R1)          POINT TO STARTING POINT           R4
         L     R1,HCTDSECT(R1)      IN DCT CHAIN                     R4
         LTR   R1,R1               TEST CHAIN ADDRESS                R4
         BNZ   COF&R.K             BR IF VALID                       R4
         ICM   R1,15,$DCTPOOL      POINT TO 1ST DCT                  R4
         BZR   LINK                RETURN IF NONE                    R4
COF&R.K  CLC   DCTDEVN-DCTDSECT(L'DCTDEVN,R1),COMEWORK LOOK FOR MATCH
         BE    COF&R.Q             CHECK FOR SYSTEM INTRDRS
         ICM   R1,7,DCTCHAIN+1-DCTDSECT(R1) POINT TO NEXT DCT
         BNZ   COF&R.K             LOOP TO NEXT IF NOT AT END
         BR    LINK                RETURN WITHOUT DCT
COF&R.Q  DS    0H                  LOOK FOR SYSTEM INTRDRS
         CLI   DCTDEVTP-DCTDSECT(R1),DCTINR  IS THIS AN INTRDR
         BNER  LINK                NO--RETURN WITH DCT FOUND
         SLR   R1,R1               YES--MUST BE SYSTEM INTRDR
         BR    LINK                RETURN WITH NO DCT
         SPACE 5                                                    R41
COF&R.N  MVC   COMEWORK(*-*),0(R1) **** EXECUTE ONLY ****
COF&R.M  MVC   COMEWORK(*-*),4(R1) **** EXECUTE ONLY ****
.XIT     MEND
         EJECT
         MACRO -- $CFINVC -- INVALID COMMAND
&NAME    $CFINVC &D,&DD,&TYPE=CALL,&INFO=NO
         GBLC  &DOC
         LCLC  &R
&R       SETC  '&SYSNDX'
         AIF   ('&INFO' EQ '' AND '&DOC' EQ 'NO' OR '&INFO' EQ 'NO').Z
         AIF   ('&TYPE' EQ 'RES').NOJECT
         EJECT
.NOJECT  SPACE 2
***********************************************************************
*                                                                     *
*        COFINVC -- REPLY INVALID COMMAND                             *
*                                                                     *
*        ROUTINE RETURNS TO MAIN COMMAND PROCESSOR BEFORE $WAIT       *
*                                                                     *
***********************************************************************
.Z       ANOP
         AIF   ('&TYPE' NE 'CALL').INL
.CAL     ANOP
&NAME    B     COFINVC             REPLY INVALID COMMAND
         MEXIT
.INL     ANOP
         SPACE 10                                                   R41
***********************************************************************
* RETURN WITH INVALID COMMAND AS RESPONSE                             *
***********************************************************************
&NAME    MVC   COMMAND+9(16),=C' INVALID COMMAND' MOVE DIAG.
         $CRET L=25,INFO=NO
.XIT     MEND
         EJECT
         MACRO -- $CFINVO -- INVALID OPERAND
&NAME    $CFINVO &TYPE=CALL,&OPERAND=(R1),&INFO=NO
         GBLC  &DOC
         LCLC  &C,&R
&C       SETC  '0&OPERAND'         MVC X,0(OPERAND)
         AIF   ('&OPERAND'(1,1) EQ '(').A
&C       SETC  '&OPERAND'          MVC X,OPERAND
.A       ANOP
&R       SETC  '&SYSNDX'
         AIF   ('&INFO' EQ '' AND '&DOC' EQ 'NO' OR '&INFO' EQ 'NO').Z
         AIF   ('&TYPE' EQ 'RES').NOJECT
         EJECT
.NOJECT  SPACE 2
***********************************************************************
*                                                                     *
*        COFINVO -- REPLY INVALID OPERAND                             *
*                                                                     *
*        ROUTINE RETURNS TO MAIN COMMAND PROCESSOR BEFORE $WAIT       *
*                                                                     *
***********************************************************************
.Z       ANOP
         AIF   ('&TYPE' NE 'CALL').INL
&NAME    $DECODE &OPERAND
         B     COFINVO             REPLY INVALID OPERAND
         MEXIT
.INL     ANOP
         SPACE 10                                                   R41
***********************************************************************
* RETURN WITH INVALID OPERAND AS RESPONSE                             *
***********************************************************************
&NAME    MVC   COMJNAME,=CL8' '    INSURE FIELD AFTER BLANK          R4
         MVC   COMMAND(9),&C                                         R4
         MVC   COMMAND+9(16),=C' INVALID OPERAND' SET DIAGNOSTIC
         $CRET L=25,INFO=NO
.XIT     MEND
         EJECT
         MACRO -- $CFJDCT -- FIND JOB'S DCT
&NAME    $CFJDCT &JOBQE=(R1),&TYPE=CALL,&INFO=NO,&CONT=
         GBLC  &DOC
         LCLC  &R
&R       SETC  '&SYSNDX'
         AIF   ('&INFO' EQ '' AND '&DOC' EQ 'NO' OR '&INFO' EQ 'NO').Z
         AIF   ('&TYPE' EQ 'RES').NOJECT
         EJECT
.NOJECT  SPACE 2
***********************************************************************
*                                                                     *
*        COFJDCT -- FIND DEVICE(S) ACTIVE WITH A SPECIFIED JOB        *
*                                                                     *
*        ROUTINE COLLECTS DEVICE IDENTIFIERS FROM THE JQE (IF THE     *
*        JOB IS ON A READER) OR FROM THE JOES (IF THE JOB IS ACTIVE   *
*        IN HARD COPY).                                               *
*                                                                     *
*        FORMAT OF THE DEVICE IDENTIFIER (2 BYTES) IS                 *
*        BYTE 1 -- HIGH ORDER BIT SIGNIFIES A REMOTE DEVICE           *
*              BITS 1-3 INDICATE THE DEVICE TYPE                      *
*              000 = INTERNAL READER                                  *
*              001 = READER                                           *
*              010 = PRINTER                                          *
*              011 = PUNCH                                            *
*              BITS 4-7 INDICATE THE REMOTE DEVICE NUMBER (1-7) IF    *
*              THE DEVICE IS A REMOTE OTHERWISE THEY ARE ZERO         *
*                                                                     *
*        BYTE 2 -- IF A REMOTE -- THE REMOTE NUMBER (1-255)           *
*              IF A LOCAL DEVICE THE LOCAL NUMBER (1-99)              *
*                                                                     *
*        THE DEVICE IDENTIFIERS ARE MOVED INTO A TABLE ON THE FIRST   *
*        ENTRY, SUBSEQUENT ENTRIES RETRIEVE OTHER DEVICE IDENTIFIERS  *
*                                    THIS LINE DELETED BY APAR @OZ20010
*                                                                     *
* REGISTERS USED -                                                    *
*        R1    = JOB QUEUE ELEMENT ADDRESS, ON EXIT DEVICE ID         *
*              ADDRESS                                                *
*        LINK  = LINKAGE                                              *
*        R15   = WORK                                                 *
*        WA    = WORK (SAVED BEFORE IT IS USED IN COMWREGS)           *
*        WB    = WORK (SAVED BEFORE IT IS USED IN COMWREGS)           *
*        WC    = WORK (SAVED BEFORE IT IS USED IN COMWREGS)           *
*        WD    = WORK (SAVED BEFORE IT IS USED IN COMWREGS)           *
*                                                                     *
* WORK AREAS USED                                                     *
*        COMWREGS TO SAVE REGISTERS                                   *
*        COMEWORK TO SAVE R1 -- JQE ADDRESS                           *
*                                                                     *
* EXITS                                                               *
*        LINK+0 DCT NOT FOUND                                         *
*        LINK+4 DCT FOUND                                             *
*                                                                     *
***********************************************************************
.Z       ANOP
&NAME    $DECODE &JOBQE
         AIF   ('&TYPE' NE 'CALL').INL
.CAL     BAL   LINK,COFJDCT        FIND DCT PERFORMING JOB I/O
         MEXIT
.INL     ST    R1,COMEWORK         SAVE JQE ADDRESS
         MVI   COFDEVID,0          CLEAR DEVICE ID
         MVC   COFDEVID+1(L'COFDEVID-1),COFDEVID SAVE AREA
         LA    R15,COFDVEND        POINT TO LAST TABLE ENTRY
         ST    R15,COFDEVSV        SAVE IT FOR LATER
         CLI   JQETYPE,$INPUT      IS JOB ON RDR                     R4
         BNE   COF&R.A             NO--SCAN JOES                     R4
         MVC   COFDEVID(L'JQEFLAGS),JQEFLAGS  SET BUSY FLAG
         NI    COFDEVID,QUEBUSY    TURN 'OFF' NON-BUSY BITS
         MVC   COFDEVID+L'JQEFLAGS(L'JQEDEVID),JQEDEVID  SET DEVICE
         B     COF&R.F             EXIT
         SPACE 1
COF&R.A  DS    0H                  SCAN JOES
*                                    THIS LINE DELETED BY APAR @OZ20010
*                                    THIS LINE DELETED BY APAR @OZ20010
*                                    THIS LINE DELETED BY APAR @OZ20010
*                                    THIS LINE DELETED BY APAR @OZ20010
         STM   WA,WD,COMWREGS      SAVE REGISTERS
         LA    WD,COFDEVID         POINTO FIRST ADDRESS OF DEVID TBL
         L     WA,CDFJOT           POINT TO THE JOT
         USING JOTDSECT,WA         ADDRESSABILITY FOR THE JOT
         USING JOEDSECT,R1         JOE ADDRESSABILITY
         SLR   WB,WB               ZERO CLASS OFFSET REGISTER
         LH    WC,QUEJOECT(,R1)    GET JOB JOE COUNT           @OZ29819
         B     COF&R.C             START JOE SCAN
COF&R.B  DS    0H                  CYCLE THROUGH CLASSES
         LA    WB,2(,WB)           POINT TO NEXT CLASS OFFSET
         CH    WB,=Y(L'JOTRDYWQ-2) CHECK FOR END OF CLASSES          R4
         BH    COF&R.E             YES--EXIT
COF&R.C  DS    0H                  SCAN A CLASS OF JOES
         LA    R1,JOTRDYWQ-(JOENEXT-JOEDSECT)(WB) POINT TO QUEUE ORG R4
COF&R.D  DS    0H                  JOE GET LOOP
         LTR   WC,WC               TEST JOB JOE COUNT          @OZ29819
         BZ    COF&R.E             BR IF ALL JOES PROCESSED    @OZ29819
         LH    R1,JOENEXT          GET OFFSET TO NEXT JOE
         N     R1,=A(X'0000FFFF')  INSURE OFFSET IS POSITIVE
         BZ    COF&R.B             IF LAST  N CLASS -- EXIT
         SLL   R1,2                EXPAND TO BYTE OFFSET             R4
         ALR   R1,WA               COMPUTE JOE ADDRESS
         LH    R15,JOEJQE          PICK-UP JQE OFFSET
         SLL   R15,2               COMPUTE JQE OFFSET ( * 4)
         AL    R15,$JOBQPTR        COMPUTE JQE ADDRESS
         CL    R15,COMEWORK        CHECK FOR IDENTICAL JOB
         BNE   COF&R.D             NO--GO TO NEXT JOE
         BCTR  WC,0                DECREMENT JOB JOE COUNT     @OZ29819
         TM    JOEFLAG,$JOEBUSY    TEST FOR JOE TO BE BUSY
         BZ    COF&R.D             NO--GET NEXT JOE
         MVC   0(L'JOEFLAG,WD),JOEFLAG SAVE BUSY FLAGS
         NI    0(WD),$JOEBUSY      TURN 'OFF' NON-BUSY BITS
         MVC   L'JOEFLAG(L'JOEDEVID,WD),JOEDEVID SET DEVICE ID
         LA    WD,L'JOEFLAG+L'JOEDEVID(,WD) POINT TO NEXT FREE AREA
         C     WD,COFDEVSV         CHECK FOR END OF TABLE
         BNL   COF&R.E             IF END EXIT JOE SCAN LOOP
         B     COF&R.D             ELSE SCAN ALL JOES
COF&R.E  DS    0H                  END OF JOE SCAN
         LM    WA,WD,COMWREGS      RESTORE REGISTERS
COF&R.F  LA    R15,COFDEVID-(L'JQEFLAGS+L'JQEDEVID)
         ST    R15,COFDEVSV        SAVE IT FOR LATER
&CONT    DS    0H                  CONTINUE DEVICE SCAN
         L     R1,COFDEVSV         PICK-UP LAST DEVICE ADDRESS
         LA    R1,L'JQEFLAGS+L'JQEDEVID(,R1)  POINT TO NEXT DEVICE
         ST    R1,COFDEVSV         SAVE IT FOR NEXT TIME
         CLC   0(L'JQEFLAGS+L'JQEDEVID,R1),=XL3'00' CHK FOR END
         BER   R14                 YES RETURN--EMPTY
         B     4(,R14)             NO--RETURN WITH DEV ADDR IN R1
         DROP  R1,WA               DROP ADDRESSABILITIES
         USING JQEDSECT,R1         REESTABLISH JQE ADDRESSABILITY
COFDEVLL EQU   (L'COMREGSV)*40     LENGTH OF SAVE AEA
COFDEVL  EQU   COFDEVLL-L'JOEFLAG-L'JOEDEVID-4 LENGTH OF TABLE
COFDEVID EQU   COMREGSV,COFDEVL    TABLE FOR ACTIVE DEVICES FOR AJOB
COFDVEND EQU   COFDEVID+COFDEVL    LAST TABLE ENTRY
COFDEVSV EQU   COFDEVID+COFDEVL+L'JOEFLAG+L'JOEDEVID,4
.XIT     MEND
         EJECT
         MACRO -- $CFJDCTC -- CONTINUE FIND JOB'S DCT
&NAME    $CFJDCTC &INFO=NO
         GBLC  &DOC
         LCLC  &R
&R       SETC  '&SYSNDX'
         AIF   ('&INFO' EQ '' AND '&DOC' EQ 'NO' OR '&INFO' EQ 'NO').Z
         EJECT
***********************************************************************
*                                                                     *
*        COFJDCTC -- CONTINUE FIND JOB'S DEVICE CONTROL TABLE         *
*                                                                     *
*        ROUTINE CONTINUES THE SEARCH OF DCTS STARTED BY COFJDCT      *
*        BY USING THE BODY OF THAT ROUTINE. THE ENTRY POINT IN        *
*        COFJDCT IS SET BY THE CONT= PARAMETER ON THE CALL OR         *
*        SUBROUTINE VERSION OF THE ROUTINE.                           *
*        NO $WAITS ARE ISSUED.                                        *
*                                                                     *
* REGISTERS USED                                                      *
*        R1    = DCT ADDRESS                                          *
*        LINK  = LINKAGE                                              *
*        R15   = WORK REGISTER                                        *
*                                                                     *
* EXITS                                                               *
*        LINK+0 DCT NOT FOUND                                         *
*        LINK+4 DCT FOUND                                             *
*                                                                     *
* NOTES                                                               *
*        JOB QUEUE POINTER IN COMEWORK AS SET BY COFJDCT              *
*                                                                     *
***********************************************************************
.Z       ANOP
&NAME    BAL   LINK,COFJDCTC       CONTINUE DCT SCAN
.XIT     MEND
         EJECT
         MACRO -- $CFJMSG -- COLLECT JOB INFORMATION FOR MESSAGE
&NAME    $CFJMSG &JOBQE=(R1),&TYPE=CALL,&INFO=,&OPT=COFU,&AFF=
         GBLC  &DOC
         AIF   ('&INFO' EQ '' AND '&DOC' EQ 'NO' OR '&INFO' EQ 'NO').Z
         AIF   ('&TYPE' EQ 'RES').NOJECT
         EJECT
.NOJECT  SPACE 2
***********************************************************************
*                                                                     *
*        COFJMSG -- JOB INFORMATION MESSAGE OUTPUT                    *
*                                                                     *
*        ROUTINE COLLECTS JOB INFORMATION INTO AREA 'COMMAND' AND     *
*        INITIATES OUTPUT RESPONSE.                                   *
*        $WAIT MAY BE ISSUED.                                         *
*                                                                     *
* REGISTERS USED                                                      *
*        R0    = WORK - MESSAGE LENGTH                                *
*        R1    = JOB QUEUE ELEMENT ADDRESS - WORK - AREA 'COMMAND'    *
*        WA    = LINKAGE                                              *
*        R10   = ENTRY BASE                                           *
*        LINK  = LINKAGE                                              *
*        R15   = WORK                                                 *
*                                                                     *
* EXITS                                                               *
*        WA+0  JOB DISPLAYED                                          *
*        WA+4  JOB NOT DISPLAYED ( CONDITIONAL REQUEST ONLY )         *
*                                                                     *
* NOTES                                                               *
*        COMDWORK USED FOR SCRATCH                                    *
*        COMEWORK USED BY COFJDCT TO HOLD JQE POINTER                 *
*        COMFWORK USED FOR SCRATCH                                    *
*        COMWREGS IS USED TO SAVE WORK REGISTERS                      *
*        OPT   = COFU - DISPLAY UNCONDITIONAL                         *
*              = COFQ - DISPLAY QUEUED JOBS                           *
*              = COFA - DISPLAY ACTIVE JOBS                           *
*              = (OTHER MEANINGFUL CONSISTANT COMBINATIONS)           *
*                                                                     *
***********************************************************************
.Z       ANOP
&NAME    $DECODE &JOBQE
         AIF   ('&TYPE' NE 'CALL').INL
         AIF   ('&OPT' EQ 'SET').A
         MVI   COFOPT,&OPT         SET OPTION
.A       ANOP
         AIF   ('&AFF' EQ 'SET').B
         MVI   COFAFF,X'7F'        SET FOR ALL SYSTEMS ACTIVE
.B       ANOP
         L     R10,=A(COFJMSG)     POINT TO SERVICE ROUTINE          R4
         BALR  WA,R10              CALL JOB INFORMATION MSG ROUTINE  R4
         MEXIT
.INL     ANOP
         EJECT
***********************************************************************
* DEFINITIONS FOR JOB INFORMATION MESSAGE                             *
***********************************************************************
         SPACE 2
COFN     EQU   X'01'               DISPLAY NORMAL JOBS
COFS     EQU   X'02'               DISPLAY SYSTEM JOBS
COFT     EQU   X'04'               DISPLAY LOGON JOBS
COFJ     EQU   COFN+COFS+COFT      DISPLAY ALL JOBS
COFX     EQU   X'08'               DISPLAY JOBS IN EXECUTION
COFD     EQU   X'10'               DISPLAY JOBS ON DEVICES
COFA     EQU   COFJ+COFX+COFD      DISPLAY ACTIVE JOBS
COFI     EQU   X'20'               DISPLAY PRE-XEQ QUEUED JOBS
COFO     EQU   X'40'               DISPLAY POST-XEQ QUEUED JOBS
COFP     EQU   X'80'               DISPLAY QUEUED FOR PRT/PUN
COFQ     EQU   COFJ+COFI+COFO+COFP DISPLAY QUEUED JOBS
COFU     EQU   COFJ+COFI+COFO+COFX+COFP+COFD DISPLAY UNCONDITIONAL
         SPACE 2
COFJOB   EQU   COMMAND,3           TEXT 'JOB', 'STC', OR 'TSU'
COFJNO   EQU   COFJOB+3,5          JOB NUMBER WITH LEADING BLANK
COFJNAME EQU   COFJNO+6,8          JOB NAME
COFQUE   EQU   COFJNAME+9,8        TEXT 'AWAITING'
COFQX    EQU   COFQUE+9,9          TEXT 'EXECUTION'
COFQXC   EQU   COFQX+10,1          CLASS
COFQXU   EQU   COFQX,11            TEXT 'EXECUTION *'
COFPRT   EQU   COFQUE,3            TEST 'PRT'                        R4
COFPRTR  EQU   COFPRT+3,10         PRINT ROUTING                     R4
COFPUN   EQU   COFPRT+13,3         TEXT 'PUN'                        R4
COFPUNR  EQU   COFPUN+3,10         PUNCH ROUTING                     R4
COFQOUT  EQU   COFQX,6             TEST 'OUTPUT'
COFPURGE EQU   COFQX,5             TEXT 'PURGE'
COFPRIO  EQU   COFPUNR+10,4        TEXT 'PRIO'                       R4
COFPRI   EQU   COFPRIO+5,2         PRIORITY
COFFLAGS EQU   COFPRI+3,9          'HOLD', 'PURGE', 'DUPLICATE'
COFSID   EQU   COFFLAGS+10,4       FIRST SID NAME                    R4
COFSIDX  EQU   COFSID+5,24         REST OF SID'S
COFINDP  EQU   COFSIDX+25,3        DESIGNATOR FOR INDEPENDENT MODE
COFSEC   EQU   COFINDP+3,2         SECURITY FIELD FOR $WTO'S
COFOPT   EQU   COFSEC+2,1          OPTIOM SPECIFIED
COFAFF   EQU   COFOPT+1,1          ACTIVE SID WHEN SPECIFIED
COFLNGTH EQU   COFAFF+1,1          LENGTH OF MESSAGES
COFAX    EQU   COFQUE,9            TEXT 'EXECUTING'
COFAXC   EQU   COFAX+10,1          CLASS WHEN EXECUTING
COFON    EQU   COFAX,2             TEXT 'ON'
COFDEV   EQU   COFAX+3,8           TEXT DEVICE NAME
COFAXT   EQU   COFDEV+9,COFSEC-COFPRIO ACTIVE JOB MSG TRAILER
COFQOT   EQU   COFQOUT+7,COFSEC-COFPRIO QUEUED FOR OUTPUT TRAILER
COFQPT   EQU   COFPURGE+6,COFSEC-COFPRIO QUEUED FOR PURGE TRAILER
COFAXL   EQU   COFPRIO-(COFDEV+9) LENGTH TO SUBTRACT FOR ACTIVE MSG
COFQOL   EQU   COFPRIO-(COFQOUT+7) LNG TO SUBTRACT FOR Q'S FOR OUT
COFQPL   EQU   COFPRIO-(COFPURGE+6) LNG TO SUBTRACT FOR Q'S FOR PG
         EJECT
         USING *,R10               ESTABLISH ROUTINE ADDRESSABILITY  R4
         LH    R0,JQEJOBNO         GET JOB NUMBER              @OZ29819
         LA    R15,COFT            ASSUME TSU                  @OZ29819
         CH    R0,=H'20000'        TSU JOB...                  @OZ29819
         BH    *+8                 BR IF YES                   @OZ29819
         LA    R15,COFS            ASSUME STC                  @OZ29819
         CH    R0,=H'10000'        STC JOB...                  @OZ29819
         BH    *+8                 BR IF YES OR TSU JOB        @OZ29819
         LA    R15,COFN            MUST BE BATCH JOB           @OZ29819
         EX    R15,COFJBTST        DO WE WANT THIS JOB...      @OZ29819
         BZ    4(,WA)              EXIT NO DISPLAY IF NO       @OZ29819
***********************************************************************
* DETERMINE STATUS OF JOB                                             *
***********************************************************************
         TM    JQETYPE,$XEQ        EXECUTION OR CONVERT QUEUE
         BZ    COFJMT              BRANCH IF NOT                     R4
         CLI   JQETYPE,$XEQ        TEST FOR CONVERTER
         BNE   COFJMX              NO--TRY FOR EXECUTION
***********************************************************************
* JOB IN CONVERSION QUEUE                                             *
***********************************************************************
         TM    COFOPT,COFI         CALLER WANT PRE-EXECUTION
         BZ    4(0,WA)             EXIT NO DISPLAY
         BAL   R15,COFJMB          CREATE BASIC MESSAGE
         BAL   R0,COFJMAFQ         ADD SYS NAMES--RETURN ON R15
         MVC   COFQUE,=C'AWAITING' SET
         MVC   COFQXU,=C'EXECUTION *' TEXT
         B     COFQMADS            DISPLAY AND EXIT
COFJBTST TM    COFOPT,*-*          ***  EXECUTE ONLY  ***      @OZ29819
***********************************************************************
* JOB IN EXECUTION QUEUE - COULD HAVE SOME SPINS IN OUTPUT            *
***********************************************************************
COFJMX   TM    JQEFLAGS,QUEBUSY    TEST FOR ACTIVE
         BZ    COFJMQX             BR IF NOT
         TM    COFOPT,COFX         CALLER WANT EXECUTION
         BZ    COFJMD              TRY DEVICE
         IC    R0,JQEFLAGS         PICK-UP BUSY FLAG
         N     R0,=A(QUEBUSY)      TURN 'OFF' ALL BUT BUSY FLGS
         LA    R15,1               ASSUME 1ST SYSTEM DESIRED
         B     *+8                 ENTER BUSY FLAG CONVERT LOOP
         SLL   R15,1               ASSUME NXT SYS IF ONE DESIRD
         BCT   R0,*-4              LOOP TILL SYSTEM FOUND
         EX    R15,COFAFFTS        TEST JOB BUSY ON DESIRED SYS
         BZ    COFJMD              NO--TRY BUSY ON A DEVICE
         BAL   R15,COFJMB          CREATE BASIC MESSAGE
         IC    R15,JQEFLAGS        PICK-UP ACTIVE BIT
         BAL   R0,COFJMAFA         GET SYS NAME-RETURN ON R15
         MVC   COFAXT,COFPRIO      MOVE MSG FOR ACTIVE IN XEQ
         MVC   COFAX,=C'EXECUTING' SET
         MVC   COFAXC,JQETYPE      NORMAL TEXT
         OI    COFAXC,X'80'        MAKE XEQ CLASS PRINTABLE
         CLI   COFJOB,C'J'         TEST FOR NORMAL
         BE    COFJMDAX            DISPLAY IF YES
         MVI   COFAXC,CATTSUID     SET TSU DISPLAY CLASS
         CLI   COFJOB,C'T'         IS THIS TSU
         BE    COFJMDAX            DISPLAY IF YES
         MVI   COFAXC,CATSTCID     SET STC DISPLAY CLASS
COFJMDAX DS    0H
         MVC   COFSEC,JQEJOBNO     COPY JOB NUMBER
         SLR   R15,R15             ZERO INSERT REGISTER
         IC    R15,COFLNGTH        PICK-UP CURRENT LENGTH
         LA    R0,COFAXL           PICK-UP LENGTH TO SHORTEN MSG BY
         SLR   R15,R0              COMPUTE RESIDUAL LENGTH
         STC   R15,COFLNGTH        SAVE NEW LENGTH FOR $WTO
         BAL   R14,COFJWTO         ISSUE WTO
         EJECT                                                      R41
COFJMDXC DS    0H
         TM    COFOPT,COFD         DOES USER WANT 'ON DEVICE'
         BZR   WA                  EXIT
         CLC   JQEJOECT,=H'0'      ARE THERE ANY SPINS
         BZR   WA                  EXIT
         CLC   JQEJOBNO,COFSEC     SAME JOB NUMBER
         BNER  WA                  EXIT
         $CFJDCT ,                 SCAN FOR DEVICE ACTIVITY
         B     0(,WA)              RETURN IF NONE
         B     COFDEVCR            ENTER DEVICE CREATE RTN
***********************************************************************
* JOB AWAITING EXECUTION                                              *
***********************************************************************
COFJMQX  TM    COFOPT,COFI         CALLER WANT PRE-EXECUTION
         BZ    COFJMD              TRY DEVICE
         BAL   R15,COFJMB          CREATE BASIC MESSAGE
         BAL   R0,COFJMAFQ         ADD SYS NAME(S)-RET ON R15
         MVC   COFQUE,=C'AWAITING' SET
         MVC   COFQX,=C'EXECUTION *' TEXT
         MVC   COFQXC,JQETYPE      SET NORMAL CLASS
         OI    COFQXC,X'80'        MAKE DISPLAYABLE
         CLI   COFJOB,C'J'         TEST FOR NORMAL
         BE    COFJMDQX            DISPLAY IF YES
         MVI   COFQXC,CATTSUID     SET TSU DISPLAY CLASS
         CLI   COFJOB,C'T'         IS THIS TSU
         BE    COFJMDQX            DISPLAY IF YES
         MVI   COFQXC,CATSTCID     SET STC DISPLAY CLASS
COFJMDQX DS    0H                  ISSUE QUEUED FOR XEQ MESSAGE
         MVC   COFSEC,JQEJOBNO     COPY JOB NUMBER
         BAL   R14,COFJWTO         ISSUE MESSAGE
         B     COFJMDXC            CONTINUE DEVICE SCAN
COFJMT   DS    0H                                                    R4
         EJECT                                                      R41
***********************************************************************
* SEARCH FOR DEVICE ACTIVITY                                          *
***********************************************************************
COFJMD   ST    R1,COMEWORK         SAVE JQE ADDRESS            @OZ29819
         TM    COFOPT,COFD         CALLER WANT 'ON DEVICE'...  @OZ29819
         BZ    COFJMQO             BR IF NO                    @OZ29819
        $CFJDCT ,                  LOCATE ACTIVE DCT FOR JOB   @OZ29819
         B     COFJMQO             BR IF NO ACTIVE DEVICE  +0  @OZ29819
COFDEVCT LA    R14,COFJMDCC        POINT TO EXIT ROUTINE   +4  @OZ29819
         B     COFJOIN             AND ENTER EXAMINATION RTN
COFDEVCR DS    0H                  DETERMINE JOB ON ACTIVE SYS
         LA    R14,COFJMDC         POINT TO EXIT ROUTINE
COFJOIN  DS    0H                  JOB ACTIVE EXAM RTN
         IC    R0,0(,R1)           PICK UP ACTIVE FLAG
         N     R0,=A(QUEBUSY)      TURN 'OFF' ALL BUT BUSY FLAG
         LA    R15,1               ASSUME 1ST SYSTEM IS DESIRED
         B     *+8                 ENTER CONVERT LOOP
         SLL   R15,1               ASSUME NEXT SYSTEM DESIRED
         BCT   R0,*-4              LOOP TILL SYSTEM FOUND
         EX    R15,COFAFFTS        ACTIVE JOB ON DESIRED SYSTEM...   R4
         BZR   R14                 NO--ENTEER DESIRED ROUTINE
         ST    R1,COMFWORK         SAVE ADDDRESS FOR LATER
         L     R1,COMEWORK         RESTORE JQE POINTER
         BAL   R15,COFJMB          CREATE BASIC MESSAGE
         ST    R1,COMEWORK         SAVE JQE POINTER AGAIN
         L     R1,COMFWORK         RESTORE R1 CONTENTS
         IC    R15,0(,R1)          PICK-UP ACTIVE SYS BIT
         BAL   R0,COFJMAFA         ADD SYS NAME--RET ON R15
         MVC   COFON,=C'ON'        SET JOBNAME 'ON' DEVICE NAME
         TM    1(R1),DCTRMTID      RJE                               R4
         BNZ   COFRMDEV            DO REMOTE CONVERSION IF YES       R4
         CLI   1(R1),X'0F'         TEST FOR PSO JOE            @OZ30706
         BE    COFPSO              YES-INSERT PSO ID           @OZ30706
         SLR   R15,R15             ZERO INSERT REGISTER
         IC    R15,1(,R1)          PICKUP DEVICE FLAGS
         SRL   R15,4               SHIFT TO LOW 4 BITS OF REG
         MH    R15,=Y(COFDEVTL)    MULTIPLY BY ELEMENT LENGTH
         AL    R15,=A(COFDEVTB)    POINT TO CORRECT ENTRY
         MVC   COFDEV,1(R15)       FILL IN DEVICE NAME
         CLI   0(R15),0            TEST FOR INTERNAL READER
         BE    COFDEVND            YES-SKIP NEXT PORTION OF NAME BLD
         SLR   R0,R0               ZERO INSERT REGISTER
         IC    R0,2(,R1)           PICK-UP DEVICE NUMBER
         CVD   R0,COMDWORK         CONVERT TO PACKED NUMBER
         IC    R0,0(,R15)          PICK-UP LENGTH OF DEVICE NAME
         LA    R14,COFDEV          PT TO BEGINNING OF NAME
         ALR   R14,R0              COMPUTE POSITION FOR DEVICE NBR
         MVC   1(3,R14),=X'202020' PUT MASK INTO AREA
         EDMK  0(4,R14),COMDWORK+6 SET EBCDIC NBR INTO DEVICE NAME
         MVC   0(4,R14),0(R1)      PUT 1ST TWO DIGITS IN NO. FIELD
         B     COFDEVND            AND EXIT DEVICE NAME RTN
COFPSO   DS    0H                                              @OZ30706
         MVC   COFDEV,=C'PRSYSOUT' FILL IN DEVICE NAME         @OZ30706
         B     COFDEVND            AND EXIT DEVICE NAME RTN    @OZ30706
         EJECT                                                      R41
COFRMDEV DS    0H                  DEVICE IS A REMOTE
         SLR   R0,R0               ZERO INSERT REGISTER
         IC    R0,2(,R1)           PICK-UP REMOTE NUMBER
         CVD   R0,COMDWORK         CONVERT TO PACKED DECIMAL
         MVI   COFDEV,C'R'         SET REMOTE IDENTIFIER
         MVC   COFDEV+2(4),=X'2020204B' SET MASK AND '.'             R4
         LR    R14,R1              SAVE POINTER TO DEVICE NAME
         EDMK  COFDEV+1(4),COMDWORK+6 SET EBCDIC REMOTE NO. IN MSG
         MVC   COFDEV+1(4),0(R1)   MOVE REMOTE NBR AND CONCATENATOR
         LA    R1,COFDEV+1         1ST BYTE BEFORE CONCATENATORS
         LA    R1,1(,R1)           PT TO NEXT BYTE
         CLI   0(R1),C'.'          CHECK FOR CONCATENATOR
         BNE   *-8                 NO--LOOP TILL FOUND
         SLR   R15,R15             ZERO INSERT REGISTER
         IC    R15,1(,R14)         PICK-UP DEVICE TYPE AND NUMBER
         SRL   R15,4               ISOLATE DEVICE TYPE
         ALR   R15,R15             TIMES ELEMENT LENGTH
         LA    R15,COFRMDVT-DCTRMTID/8(R15)                          R4
         MVC   1(2,R1),0(R15)      SET DEVICE TYPE IN NAME
         MVC   3(1,R1),1(R14)      SET DEVICE NUMBER
         OI    3(R1),C'0'          MAKE EBCDIC PRINTABLE
COFDEVND DS    0H                  EXIT DEVICE NAME CREATE NAME RTN
         MVC   COFAXT,COFPRIO      MOVE MESSAGE DOWN
         LA    R1,COFAXL           PICK-UP LENGTH TO SUBTRACT
         SLR   R15,R15             ZERO INSERT REGISTER
         IC    R15,COFLNGTH        PICK-UP CURRENT LENGTH
         SLR   R15,R1              COMPUTE NEW LENGTH
         STC   R15,COFLNGTH        SAVE NEW LENGTH
         L     R1,COMEWORK         RESTORE JQE POINTER
         MVC   COFSEC,JQEJOBNO     SET SECURITY NUMBER
         BAL   R14,COFJWTO         ISSUE MESSAGE
         CLC   COFSEC,JQEJOBNO     CHECK FOR INTEGRITY
         BNER  WA                  RETUEN IF NOT SECURE
COFJMDC  $CFJDCTC ,                CONTINUE DCT SCAN
         B     0(,WA)              RETURN IF NO MORE
         B     COFDEVCR            AND ENTER DEVICE NAME RTN
COFJMDCC $CFJDCTC ,                CONTINUE DCT SCAN
         B     COFJMQO             IF NONE, LOOK FOR QUE FOR OUTPUT
         B     COFDEVCT            AND CONTINUE
         SPACE 2                                                    R41
COFAFFTS TM    COFAFF,*-*          **** EXECUTE ONLY ****
         EJECT
***********************************************************************
*        JOB QUEUED FOR OUTPUT                                        *
***********************************************************************
         SPACE 1
COFJMQO  L     R1,COMEWORK         RESTORE JQE POINTER
         TM    COFOPT,COFO         TEST FOR OUTPUT QUEUED
         BZ    COFJMQPP            NO--TEST FOR PRINT PUNCH
         TM    JQETYPE,$OUTPUT     TEST FOR IN OUTPUT PHASE
         BZ    COFJMQPP            NO--PRT/PUN
         TM    JQEFLAGS,QUEBUSY    TEST FOR BUSY
         BNZ   COFJMQPA            DISPLAY AWAITING PRT/PUN IF YES   R4
         BAL   R15,COFJMB          BULID BASIC MESSAGE
         BAL   R0,COFJMAFQ         GET SYS NAMES--RET ON R15
         MVC   COFQUE,=C'AWAITING' SET AWAITING IN TEXT
         MVC   COFQOUT,=C'OUTPUT'  SET QUEUED FOR 'OUTPUT'
         MVC   COFQOT,COFPRIO      MOVE MESSAGE FOR Q'D FOR OUTPUT
         SLR   R15,R15             ZERO INSERT REGISTER
         IC    R15,COFLNGTH        PICK-UP CURRENT LENGTH
         LA    R0,COFQOL           PICK-UP LENGTH TO SHORTEN MSG BY
         SLR   R15,R0              COMPUTE RESIDUAL LENGTH
         STC   R15,COFLNGTH        SAVE NEW MSG LENGTH
         B     COFQMADS            AND SEND MESSAGE
         SPACE 2
***********************************************************************
*        TEST FOR JOB ON PRINT/PUNCH QUEUE                            *
***********************************************************************
COFJMQPP TM    JQETYPE,$HARDCPY    TEST FOR QUEUED FOR HARD COPY    R41
         BZ    COFJMQPG            NO--TRY QUEUED FOR PURGE
COFJMQPA TM    COFOPT,COFP         TEST FOR PRINT / PUNCH QUEUING    R4
         BZ    COFJMQPG            TRY PURGE IF NOT                  R4
         BAL   R15,COFJMB          CREATE BASIC MESSAGE
         MVC   COFPRT,=C'PRT'      SET QUEUE                         R4
         MVC   COFPUN,=C'PUN'      IDENTIFIERS                       R4
         LA    R0,COFPRTR          POINT TO RECEIVE AREA             R4
         LA    R15,JQEPRTRT        POINT TO PRINT ROUTE FIELD        R4
         BAL   R14,COFRTC          CONVERT TO PRINTABLE              R4
         LA    R0,COFPUNR          POINT TO RECEIVE AREA             R4
         LA    R15,JQEPUNRT        POINT TO PUNCH ROUTE FIELD        R4
         BAL   R14,COFRTC          CONVERT TO PRINTABLE              R4
         SLR   R15,R15             ZERO INSERT REGISTER
         IC    R15,COFLNGTH        PICK-UP LENGTH OF MSG
         LA    R14,COFJOB(R15)     POINT TO THE NEXT AVAILABLE BYTE
         MVC   0(3,R14),=C'ANY'    SET AFFINITY TO 'ANY'
         LA    R15,3(,R15)         COMPUTE NEW MESSAGE LENGTH
         STC   R15,COFLNGTH        AND SVAE NEW LENGTH
         B     COFQMADS            AND SEND COMPLETED MESSAGE
         EJECT                                                      R41
***********************************************************************
*        TEST FOR JOB ON PURGE QUEUE                                  *
***********************************************************************
COFJMQPG CLI   JQETYPE,$PURGE      ON PURGE QUEUE                   R41
         BNE   4(,WA)              RETURN NO DISPLAY                 R4
         TM    COFOPT,COFQ         TEST FOR JOB QUEUED TO 'ANYTHING'
         BNO   4(,WA)              NO -- EXIT NO DISPLAY   +4
         BAL   R15,COFJMB          CREATE MESSAGE PROTOTYPE
         BAL   R0,COFJMAFQ         GET SYS NAMES -- RET ON R15
         MVC   COFQUE,=C'AWAITING' SET 'AWAITING' FOR PURGE
         MVC   COFPURGE,=C'PURGE'  SET FOR 'PURGE' PROCESSOR
         MVC   COFQPT,COFPRIO      ADJUST MESSAGE FOR PURGE
         SLR   R15,R15             ZERO INSERT REGISTER
         IC    R15,COFLNGTH        PICK-UP CURRENT  ENGTH
         LA    R0,COFQPL           PICK-UP LENGTH TO SHORTEN MSG BY
         SLR   R15,R0              COMPUTE RESIDUAL LENGTH
         STC   R15,COFLNGTH        AND SAVE IT FOR $WTO
COFQMADS DS    0H                  EXIT WITH FINAL MESSAGE
         BAL   R14,COFJWTO         SEND MESSAGE
         BR    WA                  AND RETURN  +0
***********************************************************************
* SUBROUTINE TO BUILD BASIC JOB INFORMATION MESSAGE                   *
***********************************************************************
COFJMB   LH    R0,JQEJOBNO         PICK UP JOB NUMBER
         CH    R0,=H'10000'        TEST FOR 'JOB'
         BNL   COFJMNJ             IF NOT TRY 'STC' OR 'TSU'
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
         MVC   COFJOB,=C'JOB'      SET 'JOB'
         B     COFJMBA             CONTINUE
COFJMNJ  SH    R0,=H'20000'        SEPARATE
         BL    COFJMNT             'STC' FROM 'TSU'
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
         MVC   COFJOB,=C'TSU'      SET 'TSU'
         B     COFJMBA             CONTINUE
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
COFJMNT  DS    0H                                              @OZ29819
         MVC   COFJOB,=C'STC'      SET 'STC'
         AH    R0,=H'10000'        GET BASE
         EJECT                                                      R41
COFJMBA  $CFCVE ,                  CONVERT TO EBCDIC
         MVC   COFJNO,COMDWORK     SET INTO MESSAGE
         MVI   COFJNAME-1,C' '     BLANK OUT REST OF MESSAGE AREA
         MVC   COFJNAME(COFSEC-COFJNAME),COFJNAME-1
         MVC   COFJNAME,JQEJNAME   MOVE JOB NAME
         MVC   COFPRIO,=C'PRIO'    SET 'PRIO'
         SLR   R0,R0               ZERO PRIORITY
         IC    R0,JQEPRIO          PICK UP PRIORITY * 16
         SRA   R0,4                DIVIDE BY 16
         $CFCVE ,                  CONVERT TO EBCDIC
         MVC   COFPRI,COMDWORK+5-L'COFPRI MOVE PRIORITY
         LR    R0,R15              SAVE LINK REGISTER
         LA    R15,COFFLAGS        SET ADDRESS OF NEXT MESSAGE AREA
         TM    JQEFLAGS,QUEHOLDA+QUEHOLD1+QUEHOLD2+QUEPURGE+QUEOPCAN
*                                  TEST FOR ANY JOB FLAGS
         BZ    COFJMBB             NONE--FILL IN THE AFFINITIES
         MVC   COFFLAGS(4),=C'HOLD'  ASSUME JOB IS HELD
         LA    R15,5(,R15)         PT TO NEXT AVAILABLE MSG AREA
         TM    JQEFLAGS,QUEHOLDA+QUEHOLD1  TEST FOR 'HELD'
         BNZ   COFJMBB             IF HELD--GO TO AFFINITIES FILL-IN
         MVC   COFFLAGS(5),=C'PURGE'  ASSUME PURGE
         LA    R15,1(,R15)         PT TO NEXT AVAILABLE MSG AREA
         TM    JQEFLAGS,QUEPURGE   TEST FOR SAME
         BO    COFJMBB             YES--FILL-IN AFFINITIES
         MVC   COFFLAGS(6),=C'CANCEL'  ASSUME 'CANCELLED'
         LA    R15,1(,R15)         PT TO NEXT AVAILABLE MSG AREA
         TM    JQEFLAGS,QUEOPCAN   TEST FOR CANCELLED
         BO    COFJMBB             YES--FILL-IN AFFINITIES
         MVC   COFFLAGS,=C'DUPLICATE'  MUST BE DUPLICATE JOB NAME
         LA    R15,3(,R15)         PT TO NEXT AVAILABLE MSG BYTE
COFJMBB  DS    0H                  COMPLETE MESSAGE BODY AND SVAE LN
         LA    R14,COFJOB          GET ADDRESS OF MSG BEGINNING
         SLR   R15,R14             COMPUTE MESSAGE LENGTH
         STC   R15,COFLNGTH        SAVE LENGTH
         LR    R15,R0              RESTORE LINK REGISTER
         BR    R15                 AND RETURN
         EJECT                                                      R41
***********************************************************************
*        ADD ACTIVE SYSTEM NAME                                       *
***********************************************************************
         SPACE 1
COFJMAFA DS    0H                  PICK-UP AFFINITY IN R15 FOR NAME
         N     R15,=A(QUEBUSY)     TURN OFF NON-BUSY BITS
         BCTR  R15,0               LESS ONE FOR DISPLACEMENT
         MH    R15,$QSEL           TIMES ELEMENT SIZE                R4
         AL    R15,$QSE1           PLUS TABLE START ADDR             R4
         USING QSEDSECT,R15        QSE ADDRESSABILITY
         SLR   R14,R14             ZERO INSERT REGISTER
         IC    R14,COFLNGTH        PICK-UP CURRENT MSG LENGTH
         LA    R14,COFJOB(R14)     PT TO CURRENT MSG END
         MVC   0(L'QSESID,R14),QSESID PUT SYSTEM NAME IN MESSAGE
         LA    R15,COFJOB          PT TO MSG BEGINNING
         LA    R14,L'QSESID(,R14)  PT TO MSG ENDING
         SLR   R14,R15             COMPUTE NEW LENGTH
         STC   R14,COFLNGTH        SAVE NEW LENFTH FOR $WTO
         LR    R15,R0              GET GOOD RETURN REGISTER
         BR    R15                 AND RETURN TO CALLER
         DROP  R15                 DROP QSE ADDRESSABILITY
         EJECT                                                      R41
***********************************************************************
*        ADD QUEUED SYSTEM NAMES TO MESSAGE                           *
***********************************************************************
         SPACE 1
COFJMAFQ DS    0H                  ADD QUEUED NAMES
         SLR   R15,R15             ZERO INSERT REGISTER
         IC    R15,COFLNGTH        PICK-UP CURRENT LENGTH
         LA    R15,COFJOB(R15)     PT TO CURRENT MSG END
         TM    JQEFLAG2,QUESYSAF   TEST FOR QUEUED TO 'ANY'
         BNO   COFJMAF1            NO--PLACE ALL NAMES IN MSG
         MVC   0(3,R15),=C'ANY'    SET AFFINITY SYS NAMES TO 'ANY'
         LA    R15,3(,R15)         PT TO NEW END OF MSG
         B     COFJMAF2            AND EXIT
COFJMAF1 DS    0H                  ADD SPECIFIC SYS NAMES
         L     R14,$QSE1           POINT TO 1ST QSE                  R4
         SH    R14,$QSEL           BACK UP ONE QSE                   R4
         USING QSEDSECT,R14        QSE ADDRESSABILITY
         ST    WA,COMWREGS         SAVE WA FOR WORK
COFJMAF3 AH    R14,$QSEL           POINT TO NEXT QSE                 R4
         IC    WA,QSESIAFF         PICK UP SYSTEM AFFINITY BIT       R4
         EX    WA,COFJMAFF         TEST FOR JOB QUEUED TO THIS SYS
         BZ    COFJMAF4            NO--SEARCH ALL ELEMENTS
         MVC   0(L'QSESID,R15),QSESID YES--PUT NAME IN MSG
         LA    R15,L'QSESID+1(,R15) COMPUTE NEXT NAME LOCATION
COFJMAF4 DS    0H                  CYCLE THROUGH ALL ELEMENTS
         TM    QSEFLAGS,QSELAST    TEST FOR LAST ELEMENT
         BZ    COFJMAF3            NOT LAST LOOP
         L     WA,COMWREGS         ELSE RESTORE WA CONTENTS
         BCTR  R15,0               REDUCE MSG FOR XTR BLANK
COFJMAF2 DS    0H                  TEST FOR 'IND' MODE OF OPERATION
         TM    JQEFLAG2,QUEINDAF   TEST FOR 'IND' MODE
         BZ    COFJMAF5            NO--SEND MESSAGE AS IS
         MVC   1(3,R15),=C'IND'    SET 'IND ' MODE IN MESSAGE
         LA    R15,4(,R15)         PT TO END OF MESSAGE
COFJMAF5 DS    0H                  COMPUTE MESSAGE LENGTH
         LA    R14,COFJOB          PT TO MSG BEGINNING
         SLR   R15,R14             COMPUTE NEW LENGTH
         STC   R15,COFLNGTH        SAVE IT
         LR    R15,R0              GET GOOD RETURN REGISTER
         BR    R15                 AND RETURN
         SPACE 1
COFJMAFF TM    JQEFLAG2,*-*        **** EXECUTE ONLY ****
         DROP  R14                 DROP QSE ADDRESSABILITY
         EJECT                                                      R41
***********************************************************************
*        SEND MESSAGE FOR JOB ACTIVITY                                *
***********************************************************************
         SPACE 1
COFJWTO  DS    0H                  CREATE MESSAGE OUTPUT
         ST    R14,COMFWORK        SAVE R14
         STM   R1,WA,COMWREGS      SAVE REGISTERS
         SLR   WA,WA               CLEAR INSERT REGISTER
         IC    WA,COFLNGTH         GET MESSAGE LENGTH
COFAGAIN CH    WA,=H'70'           CHECK FOR EXCESSION OF MAX LENGTH
         BNH   COFJFINI            NO--OUTPUT ONE MESSAGE
         LA    R0,COFJOB+69        PT TO LAST POSSIBLE CHAR IN LINE
         LA    R1,COFJOB-1(WA)     SET ADDRESS OF TOTAL MSG
COFCKLN  CLR   R1,R0               TEST REULTANT LENGTH
         BNH   COFLNOK             OK TO SEND IF LESS
COFLESS  BCTR  WA,0                TOO BIG--REDUCE LENGTH
         LA    R1,COFJOB-1(WA)     SET NEW END ADDRESS
         CLI   0(R1),C' '          CHECK FOR BLANK IN MESSAGE
         BE    COFCKLN             IF YES--TEST LENGTH AGAIN
         B     COFLESS             ELSE KEEP REDUCING LENGTH
COFLNOK  DS    0H                  LENGTH NOW OK FOR 1 LINE MESSAGES
         LR    R0,WA               SAVE NEW LENGTH
         IC    WA,COFLNGTH         PICK-UP ORIGINAL LENGTH
         SLR   WA,R0               COMPUTE NEW LENGTH
         STM   R1,WA,COMDWORK      SAVE REGISTERS
         NI    COMMID+1,X'FE'      SET JOB IS SET
         $CWTO L=(R0)              SEND MESSGAE
         LM    R1,WA,COMDWORK      RESTORE REGISTERS
         MVI   COFJOB,C' '         SET BLANK INTO FIRST OF MESSAGE
         MVC   COFJOB+1(COFQUE-COFJOB),COFJOB  BLANK REST
         BCTR  WA,0                REDUCE NEW LENGTH FOR MOVE
         EX    WA,COFMVMSG         MOVE MESSAGE DOWN
         LA    WA,1+COFQUE-COFJOB(,WA)  SET NEW MESSAGE LENGTH
         STC   WA,COFLNGTH         SAVE NEW LENGTH
         B     COFAGAIN            GO OUTPUT REST OF MESSAGE
         SPACE 5                                                    R41
COFMVMSG MVC   COFJOB+(COFQUE-COFJOB)(*-*),1(R1) ** EXECUTE ONLY **
         EJECT                                                      R41
***********************************************************************
*        OUTPUT LAST LINE OF MESSAGE                                  *
***********************************************************************
COFJFINI DS    0H                  OUTPUT LAST LINE OF MESSAGE
         LR    R0,WA               PUT LENGTH INTO R0
         LM    R1,WA,COMWREGS      RESTORE REGISTERS
         STM   R1,WA,COMDWORK      SAVE REGISTERS
         NI    COMMID+1,X'FE'      SET JOB ID IS SET
         $CWTO L=(R0)              OUTPUT MESSAGE
         LM    R1,WA,COMDWORK      RESTORE REGISTERS
         L     R14,COMFWORK        RESTORE R14
         BR    R14                 AND RETURN
         SPACE 4
COFDEVTB EQU   *                   LOCAL DEVICE LOOK-UP TABLE
         DC    AL1(0),CL8'INTRDR'
         DC    AL1(6),CL8'READER'
COFPRDEV DC    AL1(7),CL8'PRINTER'                                   R4
         DC    AL1(5),CL8'PUNCH'                                     R4
COFDEVTL EQU   (*-COFDEVTB)/4      LENGTH OF EACH ELEMENT
         SPACE 4
COFRMDVT EQU   *                   REMOTE DEVICE LOOK-UP TABLE
         DC    CL2'**'             SPACER                            R4
         DC    CL2'RD'
         DC    CL2'PR'
         DC    CL2'PU'
         SPACE 2
         DROP  R10                 RELEASE ROUTINE ADDRESSABILITY    R4
.XIT     MEND
         EJECT
         MACRO -- $CFJSCAN -- SCAN JOB QUEUE
&NAME    $CFJSCAN &PROCESS=,&EMPTY=,&IGNORE=,&NEXT=,&QUEUE=,   @OZ29819C
               &STORE=YES                                      @OZ29819
         LCLC  &R                                                    R4
&R       SETC  '&SYSNDX'                                             R4
        $CHEK  &PROCESS,&NEXT                                        R4
***********************************************************************
*        SCAN JOB QUEUE FOR SELECTED JOBS                             *
***********************************************************************
         AIF   ('&NAME' EQ '').NONAME                                R4
&NAME    DS    0H                                                    R4
.NONAME  AIF   ('&EMPTY' EQ '' OR '&IGNORE' EQ '').NOCHEKA           R4
         MVI   PCEBASE2,0          SET NO JOB(S) FOUND INDICATOR     R4
.NOCHEKA AIF   ('&QUEUE' EQ '').NOQUEUE                        @OZ29819
         $DECOD1 &QUEUE,,LA,R15    GET QUEUE TYPE IN R15       @OZ29819
         L     R1,=V($QINDEX)      GET ADDR OF JOB QUEUE INDEX @OZ29819
         IC    R15,0(R1,R15)       GET OFFSET OF QUEUE HEAD    @OZ29819
         AGO   .NOSTOR1                                        @OZ29819
.NOQUEUE LA    R15,$JQTYPES*2      NO. OF JOB QUEUES (TIMES 2) @OZ29819
         AIF   ('&STORE' NE 'YES').NOSTOR1                           R4
CJS&R.A  STH   R15,COMJQHDS        SAVE JOB QUEUE HEADER INDEX       R4
         LA    R1,$JQHEADS-2-QUECHAIN(R15)  POINT TO NEXT JOB QUEUE  R4
         AGO   .NEXT1                                                R4
.NOSTOR1 ANOP                                                        R4
CJS&R.A  LA    R1,$JQHEADS-2-QUECHAIN(R15)  POINT TO NEXT JOB QUEUE  R4
.NEXT1   AIF   ('&EMPTY' EQ '' OR '&IGNORE' EQ '').NOCHEKB           R4
         B     CJS&R.B             BR TO BEGIN QUEUE SCAN            R4
&NEXT    MVI   PCEBASE2,128        SET JOB FOUND INDICATOR           R4
CJS&R.B  L     BASE2,PCEBASE2      SET JOB FOUND FLAG IN REGISTER    R4
&IGNORE  LH    R1,JQECHAIN         GET OFFSET OF NEXT JQE            R4
         AGO   .NEXT2                                                R4
.NOCHEKB ANOP                                                        R4
&NEXT    LH    R1,JQECHAIN         GET OFFSET OF NEXT JQE            R4
.NEXT2   N     R1,=A(X'0000FFFF')  INSURE OFFSET POSITIVE            R4
         BZ    CJS&R.C             BR IF END OF QUEUE                R4
         SLL   R1,2                GET TRUE                          R4
         AL    R1,$JOBQPTR          JQE ADDRESS                      R4
         B     &PROCESS              AND ENTER PROCESS ROUTINE       R4
         AIF   ('&QUEUE' EQ '').NEXT3                          @OZ29819
CJS&R.C  DS    0H                                              @OZ29819
         AGO   .END                                            @OZ29819
.NEXT3   AIF   ('&STORE' NE 'YES').NOSTOR2                     @OZ29819
CJS&R.C  LH    R15,COMJQHDS        GET CURRENT JOB QUEUE HDR INDEX   R4
         BCTR  R15,0               REDUCE OFFSET BY 1                R4
         AGO   .LOOP                                                 R4
.NOSTOR2 ANOP                                                        R4
CJS&R.C  BCTR  R15,0               REDUCE OFFSET BY 1                R4
.LOOP    BCT   R15,CJS&R.A         BR IF ANOTHER JOB QUEUE           R4
.END     AIF   ('&EMPTY' EQ '' OR '&IGNORE' EQ '').XIT         @OZ29819
         LTR   BASE2,BASE2         TEST FOR ANY JOB(S) FOUND         R4
         BP    &EMPTY              BR IF NO                          R4
.XIT     MEND                                                        R4
         EJECT                                                       R4
         MACRO -- $CFSEL -- SELECT A ROUTINE BASED ON CHARACTER
&NAME    $CFSEL &A0,&A1,&A2,&A3,&A4,&A5,&A6,&A7,&A8,&A9,&AA,&AB,&AC,   C
               &AD,&AE,&AF,                                            C
               &OPERAND=(R1),&TYPE=CALL,&INFO=NO
         GBLC  &DOC
         LCLA  &A
         LCLC  &C,&R
&A       SETA  3                   SET MAX ARG TO PREVENT BAL
&C       SETC  '&OPERAND'          MVC X,OPERAND
         AIF   ('&OPERAND'(1,1) NE '(').A
&C       SETC  '0&OPERAND'         MVC X,0(OPERAND)
.A       ANOP
&R       SETC  '&SYSNDX'
         AIF   ('&INFO' EQ '' AND '&DOC' EQ 'NO' OR '&INFO' EQ 'NO').Z
         AIF   ('&TYPE' EQ 'RES').NOJECT
         EJECT
.NOJECT  SPACE 2
***********************************************************************
*                                                                     *
*        COFSEL -- SELECT A ROUTINE BASED ON KEY INPUT CHARACTER      *
*                                                                     *
*        ROUTINE MATCHES THE DESIGNATED INPUT CHARACTER AGAINST       *
*        THE LIST OF ARGUMENTS PROVIDED AND TRANSFERS CONTROL TO      *
*        THE ROUTINE DESIGNATED BY THE CORRESPONDING ADDRESS.         *
*        NO $WAITS ARE ISSUED.                                        *
*                                                                     *
* REGISTERS USED                                                      *
*        R1    = ADDRESS OF INPUT CHARACTER                           *
*        LINK  = RETURN ( USED IF NO MATCH FOUND )                    *
*        R15   = WORK REGISTER                                        *
*                                                                     *
* NOTES                                                               *
*        SEVERAL METHODS OF SELECTION ARE USED BASED UPON THE         *
*        LENGTH OF THE ARGUMENT LIST.                                 *
*        THE SELECTED ROUTINE MUST BE LOCATEABLE VIA AN S TYPE        *
*        CONSTANT.                                                    *
*                                                                     *
***********************************************************************
.Z       ANOP
&NAME    NULL
         AIF   ('&TYPE' NE 'CALL').INL
.B       AIF   (N'&SYSLIST LE &A).SHORT
         CNOP  0,4                 INSURE ALINGMENT
         BAL   R15,COF&R.T         PICK UP TABLE FOR SELECTION
&A       SETA  0
.C       AIF   (&A GE N'&SYSLIST).D
&A       SETA  &A+1
         DC    CL1'&SYSLIST(&A,1)',AL3(&SYSLIST(&A,2))
         AGO   .C
.D       DC    X'FF'               END OF SELECT TABLE
COF&R.T  BAL   LINK,COFSEL         SELECT ROUTINE
         MEXIT
.INL     ANOP
COF&R.T  CLC   0(1,R15),&C         SEARCH TABLE LOOKING FOR
         BNE   *+10                EQUAL OPERANDS
         L     LINK,0(,R15)        WHEN FOUND INSERT ADDRESS
         BR    LINK                INTO LINK AND EXIT TO SUB-RTN
         LA    R15,4(,R15)         ELSE STEP THROUGH TABLE
         BL    COF&R.T             LOOP WHILE STILL IN TABLE
         BR    LINK                ELSE RETURN IN ERROR
         MEXIT
.SHORT   ANOP
&A       SETA  0
.H       AIF   (&A GE N'&SYSLIST).XIT
&A       SETA  &A+1
         CLI   &C,C'&SYSLIST(&A,1)'  TEST CHARACTER                  R4
         BE    &SYSLIST(&A,2)      BR IF MATCH                       R4
         AGO   .H
.XIT     MEND
         EJECT
         MACRO -- $CFVQE -- VERIFY CONSOLE CONTROL OVER JOB
&NAME    $CFVQE &JOBQE=(R1),&OK=(,B),&NOK=(,B),&TYPE=CALL,&INFO=NO
         GBLC  &DOC
         LCLC  &OP1,&OP2
         AIF   ('&INFO' EQ '' AND '&DOC' EQ 'NO' OR '&INFO' EQ 'NO').Z
         AIF   ('&TYPE' EQ 'RES').NOJECT
         EJECT
.NOJECT  SPACE 2
***********************************************************************
*                                                                     *
*        COFVQE -- VERIFY CONSOLE CONTROL OVER JOB                    *
*                                                                     *
*        ROUTINE TESTS FOR RESTRICTED CONSOLE AND, IF RESTRICTED      *
*        AND NEITHER PRINT OR PUNCH ROUTING IS TO THE RESTRICTED      *
*        UNIT RECORD GROUP, THE JOB IS 'NOT OK'.                      *
*        OTHERWISE THE JOB IS 'OK'.                                   *
*        NO $WAITS ARE ISSUED.                                        *
*                                                                     *
* REGISTERS USED                                                      *
*        R0    = WORK                                                 *
*        R1    = JOB QUEUE ELEMENT ADDRESS                            *
*        LINK  = RETURN                                               *
*        R15   = WORK                                                 *
*                                                                     *
* EXITS                                                               *
*        CC    = (E)  - JOB QUEUE ELEMENT OK                          *
*        CC    = (NE) - JOB QUEUE ELEMENT NOK                         *
*                                                                     *
***********************************************************************
.Z       ANOP
         AIF   ('&TYPE' NE 'CALL').INLINE
         AIF   ('&OK(1)' NE '' OR 'NOK(1)' NE '').A
         MNOTE 12,'''NOT OK'' KEYWORD REQUIRED'
         MEXIT
.A       ANOP
&NAME    DS    0H
         $DECODE &JOBQE
         BAL   LINK,COFVQE         VERIFY JOB'S OWNERSHIP
         AGO   .B
.INLINE  ANOP
&NAME    DS    0H
         TM    COMAUTH,CMBFLAGR    ENTRY CONSOLE ONLY RMT AUTHORIZED R4
         BZR   LINK                NO--RETURN 'OK'--EQUAL
         LH    R0,COMJROUT         PICK UP JOB ROUTE                 R4
         ICM   R0,2,=H'0'          PURIFY REMOTE ID                  R4
         BCTR  R0,0                LESS ONE FOR TRUE INDEX
         MH    R0,=Y(RATTLE)       TIMES RAT SIZE FOR DISPLACEMENT
         LR    R15,R0              FIND DESIRED                      R4
         AL    R15,$RATABLE         RAT ELEMENT                      R4
         LH    R0,RATROUTE-RATDSECT(,R15) GET RAT ROUTE CODE
COFVQEK  CLI   JQETYPE,$INPUT      IS JOB ON READER...              R41
         BE    *+10                BR IF YES (IGNORE PRT ROUTE)     R41
         CH    R0,JQEPRTRT         CHECK IT WITH JOB'S PRT RT       R41
         BER   LINK                EQUAL  'OK'
         CH    R0,JQEPUNRT         CHECK IT WITH JOB'S PUN RTE
         BR    LINK                RETURN-- EQ='OK'  NE='NOK'
         MEXIT
.B       ANOP
         AIF   ('&OK(1)' EQ '').C
         AIF   ('&OK(2)' NE '').D
         BE    &OK(1)              OWNERSHIP VERIFIED -- 'OK'
         AGO   .C
.D       ANOP
&OP1     SETC  '&OK(2)'
&OP1     SETC  '&OP1'(1,1).'E'.'&OP1'(2,1)
         &OP1  &OK(1)              OWNERSHIP VERIFIED--'OK'
.C       AIF   ('&NOK(1)' EQ '').XIT
         AIF   ('&NOK(2)' EQ '').E
&OP2     SETC  '&NOK(2)'
&OP2     SETC  '&OP2'(1,1).'NE'.'&OP2'(2,1)
         &OP2  &NOK(1)             OWNERSHIP NOT VERIFIED--'NOK'
         AGO   .XIT
.E       BNE   &NOK(1)             OWNERSHIP NOT VERIFIED--'NOK'
         AIF   ('&OK(1)' EQ '').XIT                                  R4
         B     &OK(1)              NO REMOTES--ALL CONSOLES VALID
.XIT     MEND
         TITLE 'HASP COMMAND PROCESSOR'
         SPACE 5
HASPCOMM START 0                   HASP COMMAND PROCESSOR
         SPACE 5
*
*                             EXTERNAL REFERENCES
*
         SPACE 5
         ENTRY $JCANR              ADDRESS OF JOB CANCEL ROUTINE
         ENTRY $COMMEND            ADDRESS OF END OF MAIN CSECT
         SPACE 5
         COPY  $HASPGEN            COPY HASPGEN PARAMETERS
         TITLE 'HASP CONTROL BLOCKS'
         SPACE 5
HASPCOMM $ENTRY CSECT=YES,BASE=BASE2  PROVIDE PROCESSOR ENTRY POINT
         SPACE 5
*
*                             DOCUMENTATION OPTIONS FOR THIS ASSEMBLY
*
         SPACE 3
        $SYSPARM (OFF,GEN,NODATA,NO,NO)
         SPACE 5
*
*                             GENERATE HASP CONTROL BLOCKS
*
         SPACE 3
        $HASPCB DOC=&DOC,LIST=&LIST  GENERATE HASP CONTROL BLOCKS
 TITLE 'HASP COMMAND PROCESSOR MAIN ENTRY POINT'
***********************************************************************
*                                                                     *
*        H A S P C O M M   M A I N   E N T R Y   P O I N T            *
*                                                                     *
***********************************************************************
         SPACE 2
         USING PCEDSECT,SAVE
         USING HCTDSECT,BASE1
         USING JQEDSECT,R1
         L     WA,$ACTABLE         POINT TO $ACT
         STCM  SAVE,7,ACTTQE+IPOST+1-ACTDSECT(WA) SET $POST PCE ADDRESS
         L     BASE3,=A(HASPCSY1)  PICK UP BASE FOR S INIT LOGIC
         OI    COMMID+1,X'0F'      INDICATE JOB ID NOT SET           R4
         CLI   $NUMPRTS,10         TEST PRINTER COUNT                R4
         BL    CSIRETI-HASPCSY1(,BASE3)  BR IF LT 10                 R4
         L     WB,=A(COFPRINT)     GET TABLE ENTRY ADDRESS           R4
         MVI   3(WB),5             ADJUST TABLE ENTRY LENGTH VALUE   R4
         MVC   9(2,WB),10(WB)      CHANGE 'PRINTER' TO 'PRINTR'     R41
         L     WB,=A(COFPRDEV)     GET TABLE ENTRY ADDRESS           R4
         MVI   0(WB),6             ADJUST TABLE LENGTH VALUE         R4
         MVC   6(2,WB),7(WB)       CHANGE 'PRINTER' TO 'PRINTR'      R4
         B     CSIRETI-HASPCSY1(,BASE3) ENTER S INIT SCAN
         SPACE 2                                                    R41
COBTABLE B     CONUL               NEXT COMMAND
CORETOK  B     COROK               REPLY OK ENTRY
CORETMSG LA    WA,CONEXT           SET RETURN TO GET NEXT CMB
         SPACE 5                                                    R41
***********************************************************************
*                                                                     *
*        WRITE-TO-OPERATOR SUBROUTINE                                 *
*                                                                     *
***********************************************************************
CWTO     LA    R1,2                SET COUNT ADJUSTMENT              R4
         AR    R0,R1               UP COUNT
         $WTO  COMMID,(R0),MF=(EX,COMFLAG) SEND MESSAGE              R4
         OI    COMMID+1,X'0F'      INDICATE JOB ID NOT SET           R4
         BR    WA                  RETURN
         EJECT                                                      R41
***********************************************************************
*                                                                     *
*        WRITE-TO-OPERATOR (TRUNCATE MLWTO) SUBROUTINE                *
*                                                                     *
***********************************************************************
CWTOT    TM    COMFLAG,CMBFLAGU    TEST FOR UCMID (OWN OR OTHER)     R4
         BZ    CWTOTW              DO NORMAL $WTO
         CLI   COMUCMA,0           MLWTO                             R4
         BZ    CWTOTW              DO NORMAL $WTO
         OI    COMLINET,X'10'      SET END LINE INDICATOR            R4
         LTR   R0,R0               NULL LINE
         BNE   CWTOTM              SKIP NSI
         BCTR  R0,0                SET - 1
CWTOTM   LA    R1,2                SET COUNT ADJUSTMENT              R4
         AR    R0,R1               UP COUNT
         $WTO  COMMID,(R0),MF=(EX,COMFLAG) SEND MESSAGE              R4
CWTOTNM  OI    COMFLAG,CMBFLAGC    SET TYPE=SVC34 ON                 R4
         OI    COMMID+1,X'0F'      INDICATE JOB ID NOT SET           R4
         TM    COMFLAG,CMBFLAGU    IS THIS UCMID                     R4
         BZR   WA                  RETURN IF NOT                     R4
         MVI   COMLINET,0          FORCE NO LINE TYPE                R4
         BR    WA                  RETURN
CWTOTW   LTR   R0,R0               TEST FOR MESSAGE
         BNZ   CWTOTM              SEND MESSAGE IF PRESENT
         B     CWTOTNM             SKIP MESSAGE
         SPACE 5                                                    R41
***********************************************************************
*                                                                     *
*        SEND '$HASP000 OK' MESSAGE                                   *
*                                                                     *
***********************************************************************
COROK    MVC   COMMAND(2),=C'OK'   SET OK MESSAGE
         LA    R0,2                SET LENGTH
         B     CORETMSG            SEND MESSAGE
         EJECT                                                      R41
***********************************************************************
*                                                                     *
*        NULL RETURN - BYPASS $WTO UNLESS UCMID AND END LINE          *
*                      INDICATOR SET                                  *
*                                                                     *
***********************************************************************
CONUL    SLR   R0,R0               SET DUMMY                         R4
         BCTR  R0,0                LENGTH - 1                        R4
         TM    COMFLAG,CMBFLAGU    UCMID                             R4
         BZ    CONEXT              NO MLWTO IF NOT                   R4
         TM    COMLINET,X'10'      END LINE INDICATOR SET            R4
         BNZ   CORETMSG            SEND NULL MESSAGE
***********************************************************************
*                                                                     *
*        GET NEXT CMB                                                 *
*                                                                     *
***********************************************************************
CONEXT   L     R1,$COMMQUE         PICK UP FIRST COMMAND IN QUEUE
         LTR   R1,R1               TEST FOR EMPTY
         BNZ   COWORK              DO WORK IF NOT
         MVC   COMACEID,=CL8' '    BLANK OUT CURRENT ACE ID
         L     WF,$SSVT            POINT TO SSVT
         USING SSVT,WF
         C     R1,$SVCOMMQ         CHECK FOR EMPTY
         BNZ   COSSQUE             IF NOT REMOVE CMBS
         L     WA,$ACTABLE         POINT TO AUTOMATIC COMMAND TABLE
         L     WB,ACTACE-ACTDSECT(,WA) POINT TO POSSIBLE ACE
         LTR   WB,WB               IS THERE ONE THERE
         BNZ   COMACE              ENTER AUTOMATIC SCHEDULER IF YES
COMNOACE SLR   R1,R1               ZERO REG 1
         MVI   $SVCOMM,X'0'        SIGNAL WE NEED POSTING
         C     R1,$SVCOMMQ         CHECK AGAIN
         BNZ   COSSQUE             IF NOT EMPTY BR
         $WAIT WORK                WAIT FOR WORK
COSSQUE  L     R1,$SVCOMMQ         POINT TO WORK
         USING CMBDSECT,R1
COSSQUEA LTR   R1,R1               TEST FOR ZERO
         BZ    CONEXT              IF ZERO LOOP
         SLR   R0,R0               ZERO END POINTER
         CS    R1,R0,$SVCOMMQ      PULL ALL CMBS FROM QUEUE
         BNZ   COSSQUEA            LOOP
         L     WA,$COMMQUE         PICK UP OLD WORK POINTER
COSSQUEL L     WB,CMBCMB           POINT TO NEXT                     R4
         ST    WA,CMBCMB           SET NEW NEXT                      R4
         LR    WA,R1               SWITCH POINTERS
         LTR   R1,WB               AND TEST FOR MORE
         BNZ   COSSQUEL            LOOP IF MORE
         ST    WA,$COMMQUE         SET WORK QUEUE
         B     CONEXT              BACK TO TOP
COWORK   MVC   $COMMQUE,CMBCMB     REMOVE FORM QUEUE                 R4
         L     BASE3,=A(HASPCOME)  ADDRESS OF EDIT ROUTINE
         BR    BASE3               GO TO EDIT PROCESSSOR
         EJECT                                                      R41
         DROP  R1
         DROP  WF
         USING JQEDSECT,R1         RESTORE JQE ADDRESSABILITY
         SPACE 5                                                    R41
***********************************************************************
*                                                                     *
*        CORET - RETURN HERE FROM COMMAND PROCESSORS WITH R15 =       *
*                X'00' - NULL RETURN DESIRED (CONUL)                  *
*                X'04' - '$HASP000 OK' MESSAGE DESIRED (COROK)        *
*                X'08' - $WTO DESIRED - MSG IN 'COMMAND' (CORETMSG)   *
*                                                                     *
***********************************************************************
CORET    TM    COMFLAG,CMBFLAGU    TEST FOR UCMID                    R4
         BZ    COBTABLE(R15)       RETURN TO FUNCTION IF NO
         CLI   COMUCMA,0           TEST FOR MLWTO                    R4
         BZ    COBTABLE(R15)       RETURN TO FUNCTION IF NO
         TM    COMFLAG,CMBFLAGC    THIS COMMAND PHASE                R4
         BO    COBTABLE(R15)       RETURN TO FUNCTION IF YES         R4
         OI    COMLINET,X'10'      SET END LINE INDICATOR            R4
         B     COBTABLE(R15)       RETURN TO FUNCTION
         EJECT
         SPACE 3
***********************************************************************
*                                                                     *
*        REDIRECTION VALUES FOR DISPLAY COMMANDS                      *
*                                                                     *
***********************************************************************
$D7D     EQU   4
$DA      EQU   1
$DF      EQU   2
$DI      EQU   3
$DJ      EQU   4
$DN      EQU   5
$DO      EQU   6
$DQ      EQU   7
$DS      EQU   4
$DT      EQU   4
$DU      EQU   8
         EJECT
CDFJOT   EQU   $JOTABLE            JOB OUTPUT TABLE POINTER
CPSEXIT  DC    V($HEXIT)           ENTRY TO EXIT ROUTINE
COWTO    EQU   CWTO-COBTABLE       COMPUTE OFFSET TO $WTO ENTRY
CORTNORM EQU   COBTABLE-COBTABLE   COMPUTE OFFSET TO NULL RETURN
CORTOK   EQU   CORETOK-COBTABLE    COMPUTE OFFSET TO 'OK' REPLY
CORTMSG  EQU   CORETMSG-COBTABLE   COMPUTE OFFSET TO MSG REPLY
         TITLE 'HASP COMMAND PROCESSOR - ACE SERVICE ROUTINES'
***********************************************************************
*                                                                     *
*        ACE SCHEDULER                                                *
*                                                                     *
* INPUT REGISTERS -                                                   *
*                                                                     *
*        WA    = ACT ADDRESS                                          *
*        WB    = FIRST ACTIVE ACE ADDRESS                             *
*                                                                     *
***********************************************************************
         USING ACTDSECT,WA
         USING ACEDSECT,WB
COMACE   DS    0H
***********************************************************************
* TEST FOR OLD BASE TIME WANT ACTION                                  *
***********************************************************************
         L     R0,ACTTIME          GET LAST RECORDED TIME (SEC)
         C     R0,ACETIME          CHECK EXPIRED
         BNL   COMACEWK            DO WORK IF YES              @OZ27972
***********************************************************************
* TEST TIMER ACTIVE - GET NEW BASE TIME IF NOT                        *
***********************************************************************
         TM    ACTTQE+IPOST,X'80'  TEST FOR TIMER EXPIRED
         BZ    COMNOACE            WAIT FOR EXPIRE
         BAL   LINK,COMACETR       GET NEW TIME REFERENCE
         B     COMACECN            IF CLOCK OUT DO $Z       +0
***********************************************************************
* TRY NEW BASE TIME                                                   *
***********************************************************************
         L     WB,ACTACE           PICK UP ACE              +4
         L     R0,ACTTIME          GET BASE TIME
         C     R0,ACETIME          CHECK FOR EXPIRED NOW
         BNL   COMACEWK            DO WORK IF YES              @OZ27972
         XC    ACTMDELT,ACTMDELT   ZERO MAXIMUM DELAY TIME
         L     R1,ACETIME          PICK UP TIME OF ACE
         LNR   R0,R0               - CURRENT TIME
         AR    R0,R1               EXPIRE TIME - CURRENT TIME
         C     R0,ACTMINTV         COMPARE WITH MAXIMUM
         BNH   COMACET             IF OK SET TIMER
         L     R0,ACTMINTV         SET MAXIMUM
COMACET  ST    R0,ACTTQE+ITIME     SET TIMER
         $STIMER ACTTQE            QUEUE IT
         B     COMNOACE            EXIT
         EJECT
***********************************************************************
*                                                                     *
*        SCHEDULE AUTOMATIC COMMAND                                   *
*                                                                     *
***********************************************************************
COMACEWK $GETCMB NUMCMB=1,COUNT=1  GET A CMB AND COUNT ONE
         BZ    COMACENC            DELAY IF NO CMB
         USING CMBDSECT,R1
***********************************************************************
* FILL IN CMB AND QUEUE IT                                            *
***********************************************************************
         MVC   CMBFLAG(14),COMAMASK SET BASIC MASK                   R4
         MVN   CMBFLAG,ACEFLAG     SET RESTRICTIONS                  R4
         MVC   CMBFM,$SYSID        SET FROM SYSTEM IDENTIFICATION    R4
         MVC   CMBUCM,ACECON       SET DEFAULT CONSOLE               R4
         MVC   CMBMSG(L'ACETEXT),ACETEXT SET TEXT                    R4
         ST    R1,$COMMQUE         SET INTO WORK QUEUE (CHAIN 0)
         MVC   COMACEID,=CL8'ID=****' SET ACE ID IN PCE
         MVC   COMACEID+3(4),ACEID SET IDENTIFICATION
         MVC   ACTACE,ACEACE       REMOVE ACE FROM ACTIVE
***********************************************************************
* DISPOSE OF ACE                                                      *
***********************************************************************
         SLR   R0,R0               ZERO R0 FOR INSERT
         ICM   R0,3,ACEINTV        PICK UP INTERVAL
         BZ    COMACEFR            IF NOT INTERVAL FREE IT
         A     R0,ACTTIME          ADD BASE TIME
         LR    R1,WB               POINT TO ACE
         BAL   LINK,COMAADD        ADD TO ACTIVE QUEUE
         B     CONEXT              EXIT ( TIMER WILL BE SET )
COMACEFR MVC   ACEACE,ACTACEF      PUT FREE QUEUE BEHIND
         ST    WB,ACTACEF          SET FREE QUEUE
         B     CONEXT              EXIT
         EJECT                                                      R41
***********************************************************************
*                                                                     *
*        OUT OF CMBS - ACT UPON DELAY                                 *
*                                                                     *
***********************************************************************
COMACENC ICM   R0,15,ACTMDELT      CHECK DELAY ACTIVE
         BNZ   COMACEDC            IF ACTIVE CHECK EXCEEDED
         L     R0,ACTMDELI         PICK UP DELAY INTERVAL
         A     R0,ACTTIME          ADD CURRENT TIME
         ST    R0,ACTMDELT         SET TIME
COMACEWT LA    R0,10               SET 10 SECONDS
         TM    ACTTQE+IPOST,X'80'  TIMER EXPIRED
         BO    COMACET             SET TIMER
         B     COMNOACE            EXIT
COMACEDC C     R0,ACTTIME          CHECK TOO LONG OF DELAY
         BL    COMACEWT            CHECK TIMER IF NOT
COMACECN MVC   ACTACEZ,ACTACE      FORCE
         XC    ACTACE,ACTACE        $ZA
         OI    ACTFLAG,ACTFLAGZ    SET FLAG
         XC    ACTMDELT,ACTMDELT   ZERO DELAY
         $WTO  COMACEM,COMACEML,JOB=NO, SEND DIAGNOSTIC                C
               ROUTE=$ALL,CLASS=$ALWAYS,PRI=$ST
         BAL   LINK,COMACEKT       KILL TIMER
         B     COMNOACE            EXIT
         SPACE 5                                                    R41
COMACEM  $MSG  002,'AUTOMATIC COMMANDS HALTED',SYMB=COMACEMT
COMACEML EQU   *-COMACEM
COMAMASK $WTO  ,L'ACETEXT,MF=LX,JOB=NO,TYPE=SVC34,UCM=YES,           R4C
               CLASS=$ALWAYS,PRI=$HI                                 R4
         EJECT
***********************************************************************
*                                                                     *
*        SUBROUTINE TO GET TIME OF DAY AND ADJUST BASES               *
*                                                                     *
* REGISTERS -                                                         *
*                                                                     *
*        R0    = WORK                                                 *
*        R1    = WORK                                                 *
*        WA    = ACT ADDRESS                                          *
*        WB    = WORK                                                 *
*        LINK  = RETURN (LINK+0= ERROR, LINK+4= OK)                   *
*        R15   = WORK                                                 *
*                                                                     *
***********************************************************************
COMACETR ST    LINK,PCELINK        SAVE REGISTER 14
         TIME  MIC,ACTDTIME        GET OS TIME OF DAY
         L     LINK,PCELINK        PUT LINK BACK
         LTR   R15,R15             DID CLOCK GO OK
         BNZ   COMACENT            ERROR RETURN
         LM    R14,R15,ACTDTIME    GET TOTAL TIME
         SRDL  R14,32-20           ALIGN MICRO SECS IN RIGHT SIDE
         D     R14,=F'1000000'     GET NUMBER OF SECONDS
         LR    R0,R15              INTO R0
         L     LINK,PCELINK        PUT LINK BACK
         C     R0,ACTTIME          CHECK AGAINST PREVIOUS TIME
         BL    COMACEND            IF LOW PROBABLY NEW DAY
         C     R1,ACTDATE          CHECK BASE DATE
         BNE   COMACEND            CHECK NEXT DAY IF NOT SAME
         ST    R0,ACTTIME          SET TIME
         B     4(0,LINK)           RETURN OK
COMACENT STM   R0,R1,ACTTIME+ACTDATE-ACTDATE SET TIME AND DATE
         BR    LINK                RETURN ERROR
***********************************************************************
* CALCULATE BINARY CENTURY DATE                                       *
***********************************************************************
COMACEND L     R15,ACTDATEB        PICK UP DATE
         STM   R0,R1,ACTTIME+ACTDATE-ACTDATE SET NEW VALUES
         XC    ACTDWORK,ACTDWORK   ZERO WORK
         LR    R0,R1               COPY R1
         SRL   R0,12               ALIGN YYX TO RIGHT
         ST    R0,ACTDWORK+4       RELYING ON OS
         OI    ACTDWORK+7,X'0F'     TO PROVIDE VALID DATA
         CVB   LINK,ACTDWORK       CONVERT TO BINARY
         LA    R0,3(0,LINK)        COPY AND ADJUST FOR LEAP YEARS
         MH    LINK,=H'365'        DAYS IN CENTURY OF NEW YEAR
         SRL   R0,2                ACCOUNT FOR
         AR    LINK,R0             LEAP YEAR
         ST    R1,ACTDWORK+4       GET READY FOR DAY
         MVI   ACTDWORK+4+1,0      ZERO YY
         CVB   R1,ACTDWORK         PUT DAY IN
         AR    R1,LINK             GET CENTURY + 1
         BCTR  R1,0                CENTURY DAY
         L     LINK,PCELINK        RESTORE LINKAGE REGISTER
***********************************************************************
* SEE IF NEXT DAY                                                     *
***********************************************************************
         XC    ACTMDELT,ACTMDELT   ZERO DELAY MAXIMUM
         ST    R1,ACTDATEB         SET NEW DAY
         BCTR  R1,0                BACK UP 1
         CR    R1,R15              ARE THEY THE SAME
         BNER  LINK                ERROR EXIT IF NOT
***********************************************************************
* ADJUST ALL ELEMENTS BY 24 HOURS                                     *
***********************************************************************
         L     R0,=A(60*60*24)     SET 24 HOURS
         ICM   WB,15,ACTACE        POINT TO FIRST ACE
         BNZ   COMACEAL            ADJUST IF NOT EMPTY
         ICM   WB,15,ACTACEZ       POINT TO FIRST HALTED ACE
         BZ    4(0,LINK)           EXIT IF END
COMACEAL L     R1,ACETIME          PICK UP TIME
         SR    R1,R0               SUBTRACT 24 HOURS
         BNM   *+6                 SKIP IF NOT MINUS
         SLR   R1,R1               IF NEGATIVE SET TO ZERO
         ST    R1,ACETIME          SET NEW TIME
         ICM   WB,15,ACEACE        POINT TO NEXT ACE
         BNZ   COMACEAL            LOOP
         B     4(0,LINK)           EXIT
         EJECT
***********************************************************************
*                                                                     *
*        SUBROUTINE TO ADD AN ACE TO CHAIN                            *
*                                                                     *
* REGISTERS -                                                         *
*                                                                     *
*        R0    = TIME OF ACE                                          *
*        R1    = ACE ADDRESS                                          *
*        WA    = ACT ADDRESS                                          *
*        WB    = WORK                                                 *
*        LINK  = RETURN                                               *
*        R15   = WORK                                                 *
*                                                                     *
***********************************************************************
COMAADD  LA    WB,ACTACE-(ACEACE-ACEDSECT) POINT TO HEAD OF CHAIN
         TM    ACTFLAG,ACTFLAGZ    TEST FOR HALTED
         BZ    COMAADDL            BR IF NOT HALTED
         LA    WB,ACTACEZ-(ACEACE-ACEDSECT) POINT TO HEAD OF HALTED
COMAADDL LR    R15,WB              COPY POINTER
         L     WB,ACEACE           POINT TO NEXT ACE
         LTR   WB,WB               CHECK FOR END
         BZ    COMAADDQ            QUEUE IT NOW IF YES
         C     R0,ACETIME          CHECK FOR TIME SEQUENCE
         BNL   COMAADDL            LOOP
COMAADDQ ST    R1,ACEACE-ACEDSECT(,R15) CHAIN TO PREVIOUS
         ST    WB,ACEACE-ACEDSECT(,R1) PUT HIGHER TIMES BEHIND
         ST    R0,ACETIME-ACEDSECT(,R1) SET TIME
         C     R1,ACTACE           IS THIS ONE FIRST
         BNER  LINK                RETURN
COMACEKT TM    ACTTQE+IPOST,X'80'  TEST TIMER ACTIVE
         BOR   LINK                RETURN
         LR    WB,LINK             SAVE LINK REGISTER
         $TTIMER ACTTQE,CANCEL     CANCEL TIMER
         OI    ACTTQE+IPOST,X'80'  SET EXPIRED
         LR    LINK,WB             RESTORE LINK
         BR    LINK                RETURN
         DROP  WA,WB
         USING JQEDSECT,R1
         TITLE 'HASP COMMAND PROCESSOR - SERVICE ROUTINES'
COFCVB  $CFCVB TYPE=RES,INFO=YES .
         EJECT
COFCVE  $CFCVE TYPE=RES,INFO=YES .
         EJECT
COFDCTL $CFDCTL TYPE=RES,INFO=YES .
         EJECT
COFINVC $CFINVC TYPE=RES,INFO=YES .
         EJECT
COFINVO $CFINVO TYPE=RES,INFO=YES .
         EJECT
COFJDCT $CFJDCT TYPE=RES,INFO=YES,CONT=COFJDCTC
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        COFRTC -- CONVERT ROUTE CODE TO EBCDIC FOR DISPLAY           *
*                                                                     *
*        NO $WAITS ARE ISSUED.                                        *
*                                                                     *
* REGISTERS USED                                                      *
*                                                                     *
*        R0    = ADDRESS OF AREA TO PUT EBCDIC ANSWER, WORK           *
*        R1    = WORK (SAVED AND RESTORED)                            *
*        R14   = LINKAGE                                              *
*        R15   = ADDRESS OF ROUTE CODE FIELD                          *
*                                                                     *
* NOTES                                                               *
*                                                                     *
*        COMEWORK AND COMDWORK ARE USED BY THIS ROUTINE.              *
*                                                                     *
***********************************************************************
COFRTC   DS    0H                                                    R4
         ST    R1,COMEWORK         SAVE REGISTER                     R4
         LR    R1,R0               POINT TO OUTPUT AREA              R4
         MVC   0(10,R1),=CL10' R'  ASSUME ' RXXX     '               R4
         SLR   R0,R0               ZERO REGISTER                     R4
         ICM   R0,1,0(R15)         PICK UP BYTE 1                    R4
         BNZ   COFRTCNR            SKIP NEXT IF NOT ZERO             R4
         MVI   1(R1),C'U'          SET SPECIAL UNIT                  R4
COFRTCNR ICM   R0,1,1(R15)         PICK UP REMOTE NUMBER             R4
         BNZ   COFRTCNC            CONVERT WHAT WE HAVE              R4
         MVC   1(5,R1),=C'LOCAL'   SET LOCAL                         R4
COFRTCNX L     R1,COMEWORK         RESTORE REGISTER                  R4
         BR    R14                 RETURN                            R4
COFRTCNC CVD   R0,COMDWORK         CONVERT TO DECIMAL                R4
         UNPK  2(3,R1),COMDWORK    CONVERT TO EBCDIC                 R4
         OI    4(R1),C'0'          SET SIGN                          R4
COFRTCNS CLI   2(R1),C'0'          IS HIGH BYTE ZERO                 R4
         BNE   COFRTCNX            EXIT IF END                       R4
         MVC   2(3,R1),3(R1)       SHIFT ONE                         R4
         B     COFRTCNS            LOOP                              R4
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        COFRTD -- CONVERT TO DEFAULT ROUTE RANGE                     *
*                                                                     *
* REGISTERS USED                                                      *
*                                                                     *
*        R0    = HIGH BOUND ANSWER                                    *
*        R1    = LOW BOUND ANSWER                                     *
*        R14   = LINKAGE                                              *
*        R15   = WORK                                                 *
*                                                                     *
***********************************************************************
COFRTD   DS    0H                                                    R4
         SLR   R1,R1               PICK UP DEFAULT                   R4
         ICM   R1,3,COMJROUT       ROUTE CODE                        R4
         LR    R0,R1               COPY                              R4
         TM    COMFLAG,CMBFLAGW    THIS REMOTE WORKSTATION           R4
         BO    COFRTDRW            LOOK AT REMOTE WORKSTATION IF YES R4
         LA    R0,X'FF'(,R1)       SET HIGH RANGE                    R4
         BR    R14                 RETURN                            R4
COFRTDRW DS    0H                                                    R4
         SLR   R1,R1               PICK UP                           R4
         IC    R1,COMJRMT          REMOTE NUMBER                     R4
         BCTR  R1,0                REDUCE BY ONE                     R4
         MH    R1,=Y(RATTLE)       GET OFFSET                        R4
         AL    R1,$RATABLE         POINT TO RAT ELEMENT              R4
         IC    R0,RATROUTE+1-RATDSECT(,R1) PICK UP REMOTE ROUTING    R4
         LR    R1,R0               COPY                              R4
         BR    R14                 RETURN                            R4
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        COFRTR -- CONVERT DESTINATION RANGES TO ROUTE RANGES         *
*                                                                     *
*        COFRTRA -- CONVERT ADJUSTED RANGES TO ROUTE RANGES           *
*                                                                     *
* REGISTERS USED                                                      *
*                                                                     *
*        R0    = HIGH BOUND ANSWER                                    *
*        WD    = POINTER TO OPERAND POINTER                           *
*        R1    = LOW BOUND ANSWER                                     *
*        R14   = LINKAGE                                              *
*        R15   = WORK                                                 *
*                                                                     *
***********************************************************************
COFRTR   DS    0H                                                    R4
         SLR   R0,R0               ZERO HIGH BOUND ANSWER            R4
         STM   R0,R15,$CSAVREG     SAVE ALL REGISTERS                R4
         LM    WE,WF,0(WD)         POINT TO FIRST                    R4
         LA    WE,0(,WE)           PURIFY                            R4
         B     COFRTRP             ENTER COMMON CODE                 R4
COFRTRA  DS    0H                                                    R4
         SLR   R0,R0               ZERO HIGH BOUND ANSWER            R4
         STM   R0,R15,$CSAVREG     SAVE ALL REGISTERS                R4
         LM    WE,WF,0(WD)         PICK UP POINTERS                  R4
         LA    WE,2(,WE)           ADJUST FOR 'X='                   R4
COFRTRP  CLI   0(WE),C'0'          THIS NUMERIC                      R4
         BNL   COFRTRN             DO NUMERIC CONVERT IF YES         R4
         LA    WF,0(,WF)           PURIFY                            R4
         BCTR  WF,0                AND LAST                          R4
COFRTRL  LR    R10,WF              COPY END + 1                      R4
         BCTR  WF,0                POINT TO END CHARACTER            R4
         LR    WD,WF               COPY END                          R4
         SR    R10,WE              GET LENGTH                        R4
         BNP   COFRTRE             ERROR EXIT IF NOT SOLID           R4
COFRTRDL CLI   0(WF),C'-'          THIS DASH                         R4
         BE    COFRTRD             CONVERT WHAT WE HAVE IF DASH      R4
         BCTR  WF,0                REDUCE                            R4
         BCT   R10,COFRTRDL        LOOP                              R4
COFRTRD  LA    R1,1(,WF)           BACK TO FIRST CHARACTER           R4
         MVC   COMDWORK,=CL8' '    SET BLANKS                        R4
         SR    WD,R1               GET MACHINE LENGTH                R4
         BM    COFRTRE             ERROR IF NOT SOLID                R4
         CH    WD,=Y(8)            TOO LONG                          R4
         BNL   COFRTRE             EXIT WITH ERROR IF TOO LONG       R4
         EX    WD,COFRTRM          MOVE TEXT TO WORK                 R4
         LA    R1,COMDWORK         POINT TO WORK AREA                R4
         SLR   R2,R2               PICK UP                           R4
         IC    R2,COMJSYS          DEFAULT BYTE 1                    R4
         L     R11,$SSVT           POINT TO SSVT                     R4
         L     R15,$SVDEST-SSVT(,R11) POINT TO CONVERT ROUTINE       R4
         BALR  R14,R15             ENTER IT                          R4
         B     COFRTREX            EXIT WITH ERROR          + 0      R4
         L     R11,$SVHCT-SSVT(,R11) RESTORE BASE REGISTER  + 4      R4
         ST    R2,$CSAVREG+(R1*4)  SET LOW BOUND                     R4
         OC    $CSAVREG(4),$CSAVREG HAS HIGH BOUND BEEN SET          R4
         BNZ   COFRTRX             EXIT IF END                       R4
         ST    R2,$CSAVREG         SET HIGH BOUND                    R4
         LTR   R10,R10             ANY MORE                          R4
         BNZ   COFRTRL             LOOP IF MORE                      R4
COFRTRX  LM    R0,R15,$CSAVREG     RESTORE REGISTERS                 R4
         CR    R1,R0               IS LOW REALLY LOW                 R4
         BNH   SKIP10              SKIP NEXT IF OK                   R4
         LR    R1,R0               MAKE SAME AS HIGH                 R4
         ST    R1,$CSAVREG+(R1*4)  SET FOR TESTING                   R4
SKIP10   B     4(,R14)             RETURN                            R4
COFRTREX L     R11,$SVHCT-SSVT(,R11) POINT TO HCT                    R4
COFRTRE  LM    R0,R15,$CSAVREG     RESTORE REGISTERS                 R4
         BR    R14                 RETURN                            R4
COFRTRN  $CFCVB POINTER=(WD),NOK=COFRTRE CONVERT TO BINARY           R4
         CH    R0,=Y(255)          TOO HIGH                          R4
         BH    COFRTRE             ERROR EXIT                        R4
         ICM   R0,2,$OWNSYS        SET HIGH ANSWER                   R4
         ICM   R1,2,$OWNSYS        SET LOW ANSWER                    R4
         LM    R2,R15,$CSAVREG+(R2*4) RESTORE REGISTERS              R4
         B     4(,R14)             RETURN                            R4
COFRTRM  MVC   COMDWORK(*-*),0(R1) MOVE TEXT TO WORK                 R4
         EJECT
COFSEL  $CFSEL TYPE=RES,INFO=YES .
         EJECT
COFVQE  $CFVQE TYPE=RES,INFO=YES .
         EJECT                                                       R4
         LTORG ,
         TITLE 'HASP COMMAND PROCESSOR -- DCT DISPLAY ROUTINE'       R4
COFDCTD $CFDCTD  TYPE=RES,INFO=YES DCT DISPLAY ROUTINE               R4
         EJECT                                                       R4
         LTORG                                                       R4
         TITLE 'HASP COMMAND PROCESSOR -- JOB INFORMATION MESSAGE ROUTIC
               NE'                                                   R4
COFJMSG  $CFJMSG TYPE=RES,INFO=YES                                   R4
         EJECT                                                       R4
         LTORG ,                                                     R4
 TITLE 'HASP COMMAND PROCESSOR COMMAND EDIT ROUTINE'
***********************************************************************
*                                                                     *
*        S E C O N D A R Y  C S E C T  F O R  C O M M  E D I T        *
*        A N D  A L L  V E R B  P R O C E S S O R S                   *
*                                                                     *
***********************************************************************
         SPACE 1
HASPCOMA $ENTRY BASE=,CSECT=YES    PROVIDE PROCESSOR IDENTIFICATION
         SPACE 2
HASPCOME NULL .                    START OF EDIT ROUTINE
         USING *,BASE3             ADDRESSABILITY FOR EDIT ROUTINE
         USING CMBDSECT,R1
         MVC   COMAUTH,CMBFLAG     SET AUTHORITY FLAGS               R4
***********************************************************************
*                                                                     *
*        COPY CMB INTO COMM WORKAREA AND INITIALIZE WORK FIELDS       *
*                                                                     *
***********************************************************************
         MVC   COMINCON,CMBUCM     COPY POSSIBLE INPUT UCMID         R4
         MVC   COMFLAG(14),CMBFLAG COPY CMB INFORMATION              R4
         MVI   COMML,0             ZERO THE LENGTH                   R4
         NI    COMFLAG,255-CMBFLAGC-CMBFLAGR-CMBFLAGJ-CMBFLAGD-CMBFLAGS
         MVI   COMLEVEL,$ALWAYS+$HI FORCE LEVEL AND PRIORITY         R4
         MVC   COMTO,CMBFM         RESPONSE GOES TO SENDING SYSTEM   R4
         MVC   COMJSYS,CMBFMSYS    SET BYTE 1                        R4
         TM    COMFLAG,CMBFLAGU    IS THIS UCM                       R4
         BZ    SKIP20              SKIP LINE TYPE RESET              R4
         MVI   COMLINET,0          RESET LINE TYPE FIELD             R4
SKIP20   MVC   COMMID,COMMIDC      INSERT MESSAGE ID
         LA    WB,COMMAND          POINT TO RECEIVE AREA
         MVI   0(WB),C' '          SET BLANK
         MVC   1(L'COMMAND-1,WB),0(WB) BLANK OUT AREA
         EJECT                                                      R41
***********************************************************************
*                                                                     *
*        INITIALIZE FOR EDIT SCAN                                     *
*                                                                     *
***********************************************************************
         LA    WA,CMBMSG           POINT TO MESSAGE
         SLR   WC,WC               ZERO COUNTER
         IC    WC,CMBML            PICK UP LENGTH OF MESSAGE         R4
         LA    WE,COMOPRND         SET POINTER TO
         ST    WE,COMPNTER         FIRST OPERAND
         LA    WD,COMPNTER+4       POINT TO SECOND OPERAND POINTER
         LA    WE,(COMNULOP-COMPNTER)/4 SET MAXIMUM OPERANDS
         LA    R0,1                CONSTANT FOR SPACE
         SLR   R15,R15             SET APOSTROPHE SWITCH OFF        R41
         SLR   R10,R10             SET MULTIPLE COMMAND POINTER
         STH   R10,COMLCCA         SET L=CCA INDICATORS
         ST    R10,COMNULOP        SET MAXIMUM NULL OPERAND          R4
***********************************************************************
*                                                                     *
*        CHECK FOR APOSTROPHE AND FLIP APOSTROPHE SWITCH (R15) IF     *
*        ONE FOUND (DON'T FLIP IF PAIR OF APOSTROPHES).  NOTE THAT    *
*        THE INSTRUCTION LABELED 'COSW' WILL RESULT IN A BRANCH TO:   *
*              COMVCOFF -- IF THE APOSTROPHE SWITCH (R15) IS OFF      *
*              COMVC    -- IF THE APOSTROPHE SWITCH IS ON             *
*                                                                     *
***********************************************************************
COCOMLOP CLI   0(WA),C''''         DO WE HAVE AN APOSTROPHE
         BNE   COSW                IF NOT SKIP SWITCH SETTING
         CLI   1(WA),C''''         DO WE HAVE A PAIR
         BNE   COSWFLP             IF NOT FLIP SWITCH
         AR    WA,R0               ADD ONE SOURCE POINTER
         BCT   WC,COMVC            MOVE SINGLE APOSTROPHE
         AR    WC,R0               FORGET SECOND APOSTROPHI
COSWFLP  X     R15,=A(COMVC-COMVCOFF) SET OR RESET APOSTROPHE SW
COSW     B     COMVCOFF(R15)       BRANCH ACCORDING TO SWITCH       R41
         EJECT                                                      R41
***********************************************************************
*                                                                     *
*        REMOVE BLANKS AND CHECK FOR MULTIPLE COMMANDS (SEMICOLON)    *
*                                                                     *
***********************************************************************
COMVCOFF CLI   0(WA),C' '          DO WE HAVE BLANK
         BE    COCOMNXT            IF SO DO NOT MOVE
         CLI   0(WA),X'5E'         CHECK FOR MULTIPLE COMMANDS
         BNE   COMNMUL             BR IF NOT MULTIPLE COMMAND
         LTR   R10,R10             TEST FOR FIRST MULTIPLE
         BNZ   COMULT              IF NOT TEST FOR PREVIOUS L=CCA
         STC   WC,CMBML            SAVE FOR NEXT COMMAND SCAN        R4
         BCT   WC,*+8              DECREMENT AND SKIP
         B     COFINMVC            IF NO MORE AFTER SEPARATOR FAKE END
         BCTR  WC,0                GET MOVE COUNT
         EX    WC,COMULMV          MOVE COMMAND WITHIN CMB
         LA    WA,CMBMSG+1         POINT TO FIRST OF NEXT COMMAND
         ALR   WC,R0               UP TO ACTUAL COUNT
         LR    WE,R0               FORCE OPERAND COUNTING OFF
         LR    R10,WB              COPY BREAK ADDRESS
         ALR   WB,R0               UP TO NEXT AVAILABLE SPACE
         B     COCOMLOP            LOOP
COMULT   CLC   1(2,R10),=C'L='     IS THIS L= OPERAND
         BE    COFINMVC            FAKE END
         SLR   WB,R10              GET LENGTH
         EX    WB,COMULBK          BLANK OUT COMMAND
         LNR   R1,R1               NEGATIVE CMB POINTER (REQUEUE SW)
         LR    WF,WC               SAVE COUNT OF REMAINING INFORMATION
         LA    WB,1(0,R10)         POINT TO NEXT AVAILABLE
         B     COCOMNXT            LOOP
***********************************************************************
*        EXECUTED INSTRUCTIONS -- EXECUTE ONLY                        *
***********************************************************************
COMULBK  MVC   1(*-*,R10),0(R10)   BLANK OUT COMMAND
COMULMV  MVC   CMBMSG+1(*-*),1(WA) MOVE ALL BUT COMMAND ID CHARACTER
         SPACE 2                                                    R41
***********************************************************************
*                                                                     *
*        MOVE AND UPPER CASE CHARACTER                                *
*        UPDATE OPERAND POINTER TABLE IF COMMA                        *
*                                                                     *
***********************************************************************
COMNMUL  DS    0H
         OC    0(1,WB),0(WA)       MOVE AND UPPER CASE THE CHARACTER
         AR    WB,R0               ADD TO RECEIVER FIELD POINTER
         CLI   0(WA),C','          WAS IT COMMA
         BNE   COCOMNXT            IF NOT GO TO NEXT CHARACTER
         BCT   WE,COCOMMA          SET OPERAND POINTER
         AR    WE,R0               FORCE CONTINUOUS FALL THROUGH
         B     COCOMNXT            GET NEXT CHARACTER
COCOMMA  ST    WB,0(0,WD)          SAVE OPERAND
         LA    WD,4(0,WD)          POINT TO NEXT AREA
         B     COCOMNXT            NEXT CHARACTER
         EJECT                                                      R41
***********************************************************************
*                                                                     *
*        COME HERE WHEN APOSTROPHE SWITCH (R15) IS ON TO MOVE AND     *
*        UPPER CASE ONLY                                              *
*                                                                     *
*        NOTE: TO MOVE WITHOUT UPPER CASING, CHANGE OC TO MVC         *
*                                                                     *
***********************************************************************
COMVC    OC    0(1,WB),0(WA)       MOVE AND UPPER CASE
         AR    WB,R0               ADD TO RECEIVE FIELD POINTER
         SPACE 2                                                    R41
***********************************************************************
*                                                                     *
*        CONTINUE EDIT SCAN WITH NEXT CHARACTER (IF ANY)              *
*                                                                     *
***********************************************************************
COCOMNXT AR    WA,R0               ADD TO SOURCE FIELD POINTER
         BCT   WC,COCOMLOP         LOOP
         SPACE 2                                                    R41
***********************************************************************
*                                                                     *
*        COME HERE WHEN ENTIRE COMMAND SCANNED, OR WHEN GLOBAL        *
*        L=CCA OPERAND HAS BEEN FOUND                                 *
*                                                                     *
***********************************************************************
COFINMVC ALR   WB,R0               POINT TO NULL LOCATION
         LTR   R10,R10             DO WE HAVE MULTIPLE COMMANDS
         BZ    COMCMBF             FREE CMB
         CLC   1(2,R10),=C'L='     IS THIS L=
         BNE   COMBKIT             BLANK IT IF NOT
         MVI   0(R10),C','         SATISFY L=CCA CONVERTER
         LTR   R1,R1               TEST FOR REQUEUING
         BNM   COMCMBF             FREE IF ONLY ONE COMMAND
         B     COMCMBRQ            REQUEUE CMB
COMBKIT  SLR   WB,R10              GET LAST COMMAND LENGTH + 2
         BCTR  WB,0                GET + 1
         BCTR  WB,0                GET LENGTH
         EX    WB,COMULBK          BLANK OUT LAST COMMAND
         LA    WB,1(0,R10)         POINT TO NEW NULL OPERAND
         SLR   R10,R10             SET GLOBAL L=CCA NOT POSSIBLE
         SLR   WF,WF               L=CCA NOT PRESENT                 R4
         EJECT                                                      R41
***********************************************************************
*                                                                     *
*        COME HERE IF MULTIPLE COMMANDS IN CMB TO REQUEUE             *
*        ADJUSTED CMB TO WORK QUEUE                                   *
*                                                                     *
***********************************************************************
COMCMBRQ LPR   R1,R1               MAKE POINTER POSITIVE
COMCMBR  ST    R1,$COMMQUE         PUT CMB BACK ON LOCAL WORK QUEUE  R4
*                                  OTHER CMBS STILL BEHIND CMB
         B     COMSETNL            SET NULL POINTER
         SPACE 2                                                    R41
***********************************************************************
*        FREE CMB                                                     *
***********************************************************************
COMCMBF  $FRECMB CMB=(R1),COUNT=YES FREE CMB AND UP COUNT
         EJECT                                                      R41
***********************************************************************
*                                                                     *
*        SETUP FOR BXLE WD,WE,... OPERAND SCANS                       *
*                                                                     *
***********************************************************************
COMSETNL ST    WB,0(0,WD)          SET NULL OPERAND POINTER          R4
         LA    WE,4                COUNT
         SLR   WD,WE               POINT TO LAST VALID OPERAND       R4
         LR    WF,WD               SET END FOR BXLE                  R4
         LA    WD,COMPNTER         POINT TO FIRST OPERAND POINTER    R4
***********************************************************************
*                                                                     *
*        SCAN FOR L=CCA OPERAND IF COMMAND ENTERED LOCALLY            *
*        AT OS CONSOLE                                                *
*                                                                     *
***********************************************************************
         TM    COMFLAG,CMBFLAGU    IS THIS UCM                       R4
         BZ    COMNGLEQ            SKIP ADJUSTMENT IF NOT UCMID
         LR    R14,WB              SAVE STARTING POINT FOR BLANK OUT
COMLCCAL LA    R15,3               MAXIMUM CHARACTERS IN CCA
         BCTR  WB,0                POINT TO
         BCTR  WB,0                 LAST SOLID CHARACTER
         MVC   COMEWORK,COMLPTRN   SET X'F0F00000'
         CLI   0(WB),C'A'          IS THIS 'A' +                     R4
         BL    COMLRSET            RESET IF NOT                      R4
         CLI   0(WB),C'I'          IS THIS 'A' TO 'I'                R4
         BNH   COMLSA              SET AREA IF YES                   R4
         CLI   0(WB),C'J'          IS THIS 'J' +                     R4
         BL    COMLRSET            RESET IF NOT                      R4
         CLI   0(WB),C'R'          IS THIS 'J' TO 'R'                R4
         BNH   COMLSA              SET AREA IF YES                   R4
         CLI   0(WB),C'S'          IS THIS 'S' +                     R4
         BL    COMLRSET            RESET IF NOT                      R4
         CLI   0(WB),C'Z'          IS THIS 'S' TO 'Z'                R4
         BH    COMLCC              TRY CONSOLE ID                    R4
COMLSA   MVC   COMLAREA(1),0(WB)   COPY AREA                         R4
         OI    COMLFLG,COMLFLGA    SET AREA IS SET                   R4
COMLCCC  BCTR  WB,0                NEXT CHARACTER
COMLCC   BCT   R15,COMLC           REDUCE MAX CHARACTERS
         B     COMLCK              CHECK FOR KEY WORD
         EJECT                                                      R41
COMLC    MVC   COMLLO(1),COMLHI    SHIFT LOW DIGIT
         MVI   COMLHI,C'0'         SET HIGH DIGIT
         CLI   0(WB),C'0'          IS THIS '0' +
         BL    COMLCK              EXIT IF NOT
         CLI   0(WB),C'9'          IS THIS '0' TO '9'
         BH    COMLCK              EXIT IF NOT
         MVC   COMLHI(1),0(WB)     SET HIGH DIGIT
         OI    COMLFLG,COMLFLGC    SET CONSOLE FLAG
         B     COMLCCC             CHECK CONSOLE DIGIT
COMLCK   BCTR  WB,0                POINT TO WHAT SHOULD BE
         BCTR  WB,0                 ',L='
         CLC   COMLCLEQ,0(WB)      CHECK FOR ',L='
         BNE   COMLRSET            IF NOT RESET ANY FLAGS
         PACK  COMDWORK,COMLHI(2)  CONVERT CONSOLE
         CVB   R0,COMDWORK          TO BINARY
         LTR   R0,R0               CHECK RESULT
         BNZ   COMLCKH             CHECK HIGH BOUND                  R4
         NI    COMLFLG,255-COMLFLGC TURN OFF CONSOLE FLAG            R4
         OI    COMLFLG,COMLFLGA    SET AREA IS SET                   R4
         B     COMLSARA            OVERIDE GLOBAL IF THIS LOCAL      R4
COMLCKH  CH    R0,COMCONNO         CHECK FOR TOO HIGH                R4
         BH    COMLRSET            IF HIGH RESET FLAGS
         STC   R0,COMUCM           SET UCM                           R4
COMLSARA MVI   COMLCCA+1,0         FORCE GLOBAL OFF
COMLBLNK MVI   0(R14),C' '         SET BLANK
         BCTR  R14,0                UNTIL
         CR    R14,WB               PARAMETER
         BNL   COMLBLNK             GONE
         LA    WB,1(0,WB)          POINT TO NEW NULL
         ST    WB,4(0,WF)          SET NEW NULL OPERAND              R4
         C     WB,0(0,WF)          SAME AS LAST                      R4
         BNE   *+6                 SKIP NSI IF NOT
         SLR   WF,WE               REDUCE NUMBER OF OPERANDS         R4
         B     COMNLEQ             SKIP NSI
COMLRSET MVC   COMEWORK,COMLPTRN   RESET WITH PATTERN
COMNLEQ  LTR   R10,R10             MULTIPLE L=CCA POSSIBLE
         BZ    COMERGE             MERGE FLAGS IF NOT
         MVC   COMLCCA,COMLFLG     SAVE FLAGS AND AREA
         SLR   R10,R10             ZERO INDICATOR
         B     COMLCCAL            LOOK FOR LOCAL L=CCA
COMERGE  OC    COMLFLG(L'COMLCCA),COMLCCA MERGE FLAGS FOR L=CCA
         MVC   COMUCMA,COMLAREA    SET AREA                          R4
***********************************************************************
*        END OF L=CCA SCAN                                            *
***********************************************************************
COMNGLEQ DS    0H                                                    R4
         EJECT                                                      R41
***********************************************************************
*                                                                     *
*        LOCATE COMMAND IN HASP COMMAND TABLE                         *
*                                                                     *
***********************************************************************
COMLOC   DS    0H                  LOCATE SUBCOMMAND PROCESSOR       R4
         MVI   COMJRMT,0           ASSUME LOCAL                      R4
         TM    COMFLAG,CMBFLAGW    THIS WORKSTATION                  R4
         BZ    COMLOOK             SKIP REMOTE SETTING               R4
         MVC   COMJRMT,COMRMT      COMPLETE JOB ROUTING FIELD        R4
COMLOOK  LA    WC,COMFASTR         POINT TO FAST LOOKUP TABLE        R4
         LA    WA,4                SET INCREMENT FOR TABLE SCAN      R4
         LA    WB,COMFSTND         SET COMPORAND FOR TABLE SCAN
         CLC   0(1,WC),COMVERB     CHECK FOR HIT IN TABLE
         BH    COMBAD              IF TABLE HIGHER -- ERROR
         BE    *+12                IF EQUAL -- GO GET PROCESSOR
         BXLE  WC,WA,*-14          ELSE LOOP THROUGH TABLE
         B     COMBAD              IF NOT FOUND -- ERROR
         L     WC,0(,WC)           GET MAIN TABLE ADDRESS
         LA    WC,0(,WC)           CLEAR HIGH-ORDER BYTE
         LA    WA,COMTEL           SET INCREMENT TABLE LENGTH
         LA    WB,COMTABE          SET COMPORAND FOR TABLE SCAN
COMSRL   CLC   COMTVB(1,WC),COMVERB  CHECK FOR VERB IN RANGE
         BH    COMBAD              HIGHER IS ERROR
         CLC   COMTVB+1(1,WC),COMVERB+1 LOOK AT SECOND CHARACTER
         BE    COMFND              EXIT IF FOUND
         CLI   COMTVB+1(WC),X'FF'  IS IT THE LAST ENTRY FOR COMMAND
         BE    COMFND              EXIT IF FOUND
COMSRC   BXLE  WC,WA,COMSRL        LOOP
         EJECT                                                      R41
***********************************************************************
*                                                                     *
*        COME HERE IF COMMAND NOT IN TABLE                            *
*                                                                     *
***********************************************************************
COMBAD   TM    COMFLAG,CMBFLAGU    IS THIS UCM                       R4
         BZ    COMBADA             DISPLAY ERROR IF NOT
         BAL   WB,COMVCCA          VERIFY CCA (NO RETURN IF BAD)
         CLI   COMUCMA,0           MLWTO                             R4
         BZ    COMBADA             DISPLAY ERROR IF YES
         MVI   COMLINET,X'80'      SET CONTROL LINE                  R4
         $CWTO L=L'COMMAND         DISPLAY COMMAND
         MVI   COMLINET,X'20'      SET DATA LINE                     R4
COMBADA  $CFINVC ,                 RESPOND
         SPACE 5                                                    R41
***********************************************************************
*                                                                     *
*        COMMAND FOUND IN TABLE -- CHECK CONSOLE AUTHORITY            *
*                                                                     *
***********************************************************************
COMFND   IC    R1,COMTFL(,WC)      PICK UP RESTRICTION BITS
         N     R1,=A(X'F')         PURIFY
         EX    R1,COMTMI           TEST FOR AUTHORIZED CONSOLE
         BNZ   COMBAD              ANY REJECTION BIT, ERROR EXIT
         EJECT                                                      R41
***********************************************************************
*                                                                     *
*        CHECK FOR AUTOMATIC REDIRECTION OF RESPONSES                 *
*                                                                     *
***********************************************************************
         TM    COMFLAG,CMBFLAGU    IS THIS UCM                       R4
         BZ    COMGOOD             IF NOT SKIP REDIRECTION
         TM    COMLFLG,COMLFLGC    CONSOLE SET                       R4
         BNZ   COMRPT              SKIP AUTOMATIC L=CCA              R4
         SR    R1,R1               ZERO WORK
         IC    R1,COMTFL(0,WC)     PICK UP REDIRECT OFFSET
         SRA   R1,4                ALIGN TO LOW HEX DIGIT
         BZ    COMRPT              IF ZERO NO REDIRECTION
         BCTR  R1,0                REDUCE BY 1
         AR    R1,R1               DOUBLE
         SR    WA,WA               ZERO WORK
         IC    WA,COMUCM           PICK UP CURRENT UCM               R4
         CH    WA,COMCONNO         CHECK FOR TOO HIGH
         BH    COMRPT              FORGET AUTOMATIC IF TOO HIGH      R4
         L     R14,COMEXTEN        POINT TO EXTENDED AREA
         USING COMDSECT,R14
         MH    WA,COMLCON          MULTIPLY BY LENGTH DIMENSION
         AR    R1,WA               COMBINE OFFSETS
         LA    R1,COMRESP-COMCONL(R1) POINT TO ELEMENT
         MVC   COMUCM,COMCON(R1)   INSERT NEW CONSOLE ID             R4
         TM    COMLFLG,COMLFLGA    HAS AREA BEEN SET                 R4
         BO    COMRPT              SKIP AUTOMATIC IF YES             R4
         MVC   COMUCMA,COMCONA(R1) SET NEW AREA                      R4
         DROP  R14
COMRPT   BAL   WB,COMVCCA          VERIFY CCA (NO RETURN IF BAD)
         CLI   COMUCMA,0           MLWTO                             R4
         BZ    COMGOOD             SKIP IF NOT MLWTO                 R4
         MVI   COMLINET,X'80'      SET CONTROL LINE                  R4
         $CWTO L=L'COMMAND         DISPLAY COMMAND
         MVI   COMLINET,X'20'      SET DATA LINE                     R4
         SPACE 3                                                    R41
***********************************************************************
*                                                                     *
*        SET UP COMMAND PROCESSOR BASE REGISTER, GET ADDRESS OF       *
*        COMMAND SUBPROCESSOR ------ GO TO PROCESS COMMAND            *
*                                                                     *
***********************************************************************
COMGOOD  DS    0H                                                    R4
         L     BASE3,0(,WC)        POINT TO GROUP PROCESSOR          R4
         LH    R1,COMTOFF(,WC)     OFFSET WITHIN GROUP TO SUB-PROCESSOR
         ALR   R1,BASE3            COMPUTE ADDRESS OF SUB-PROCESSOR
         BR    BASE3               GO TO IT
         EJECT                                                      R41
***********************************************************************
*                                                                     *
*        SUBROUTINE TO VERIFY CONSOLE/AREA                            *
*                                                                     *
***********************************************************************
COMVCCA  DS    0H                                                    R4
         L     WA,COMEXTEN         POINT TO EXTENDED WORK AREA       R4
         USING COMDSECT,WA
         MVC   XASCID(1),COMUCM    SET UCM                           R4
         MVC   XASDID(1),COMUCMA   SET AREA                          R4
         CLI   XASDID,0            ZERO AREA                         R4
         BNZ   SKIP40              SKIP NSI                          R4
         MVI   XASDID,C'Z'         FORCE AREA Z                      R4
SKIP40   MVC   XAU(1),COMUCM       TELL OS SOURCE IS SAME AS OUTPUT  R4
         MVI   XAN,X'22'           SET ID FOR VERIFIER
         MODESET EXTKEY=ZERO       GET KEY 0
         L     R15,COMVERIF        POINT TO OS VERIFICATION ROUTINE
         BALR  R14,R15             ENTER IT
         MODESET EXTKEY=HASP       GET KEY 1
         CH    R15,=H'4'           CHECK FOR SERIOUS ERROR
         BNHR  WB                  SKIP NEXT IF CONSOLE/AREA OK
         SLR   R10,R10             ZERO WORK                         R4
         ICM   R10,3,COMUCM+(COMUCMA-COMUCMA) PICK UP UCMID AND AREA R4
         MVI   COMUCMA,0           FORCE NO MLWTO (NO PREVIOUS LINE) R4
         CH    R15,=H'12'          IS CONSOLE DOWN
         BNE   *+16                DO NOT SET LOGICAL CONSOLE  @OZ29470
         MVC   COMFLAG(4),COWTOL   DESTROY APPARENT SOURCE INFO      R4
         MVC   COMOUT,COWTOL+(COMOUT-COMFLAG) OMITTING CONTROL FIELD R4
         $CWTO L=L'COMMAND         DISPLAY COMMAND
         MVC   COMMAND(COMVINVL),COMVINV MOVE DIAGNOSTIC TEXT
         STC   R10,COMVINVA        SET AREA
         SRL   R10,8               ALIGN CONSOLE ID
         $CFCVE VALUE=(R10)        CONVERT TO EBCDIC
         MVC   COMVINVC,COMDWORK+3 SET INTO TEXT
         MVC   COMMAND+COMVINVL(8),COMACEID MOVE IDENTIFIER
         $CRET L=COMVINVL+8        EXIT
         DROP  WA
         EJECT                                                      R41
***********************************************************************
*                                                                     *
*   C O M M A N D   E D I T   R O U T I N E   C O N S T A N T S       *
*                                                                     *
***********************************************************************
COMTMI   TM    COMAUTH,*-*         *** EXECUTE ONLY ***              R4
COWTOL   $WTO  PRI=$HI,CLASS=$ALWAYS,JOB=NO,ROUTE=X'C000',MF=LX      R4
COMVINV  DC    C'RESPONSE LOCATION L=CCA UNAVAILABLE '
COMVINVL EQU   *-COMVINV
COMVINVC EQU   COMMAND+COMVINVL-16,2
COMVINVA EQU   COMVINVC+2,1
COMLPTRN DC    C'00',X'0000'       WORK AREA PATTERN
COMLHI   EQU   COMEWORK            HIGH DIGIT OF CONSOLE 'CC'
COMLLO   EQU   COMEWORK+1          LOW DIGIT OF CONSOLE 'CC'
COMLFLG  EQU   COMEWORK+2          FLAG BYTE
COMLFLGC EQU   2                   CONSOLE HAS BEEN SPECIFIED
COMLFLGA EQU   4                   AREA HAS BEEN SPECIFIED           R4
COMLAREA EQU   COMEWORK+3          AREA SPECIFICATION                R4
COMLCLEQ DC    C',L='              SPECIAL PARAMETER ID
COMMIDC  $MSG  000                 RESPONSE MESSAGE ID
         SPACE 2
         USING JQEDSECT,R1         USE R1 TO ADDRESS THE JQE
         TITLE 'HASP COMMAND PROCESSOR - HASP COMMAND TABLE'
COMTAB   DS    0F
COMTBLA  $COMTAB A7D,HASPCJB3,REJECT=COMJ  RELEASE JOB BY NAME
         $COMTAB AA,HASPCJB1,REJECT=COMR+COMJ RELEASE ALL JOBS       R4
         $COMTAB AJ,HASPCJB2,REJECT=COMJ RELEASE JOB(S)
         $COMTAB AQ,HASPCJB1,REJECT=COMR+COMJ RELEASE XEQ QUEUE      R4
         $COMTAB AS,HASPCJB2,REJECT=COMJ RELEASE STC(S)
         $COMTAB AT,HASPCJB2,REJECT=COMJ RELEASE TSU(S)
COMTBLB  $COMTAB B,HASPCDV1,REJECT=COMD    BACKSPACE DEVICE
COMTBLC  $COMTAB C7D,HASPCJB3,REJECT=COMJ  CANCEL JOB BY NAME
         $COMTAB CA,HASPCAOC,REJECT=COMR+COMS CANCEL ACES            R4
         $COMTAB CJ,HASPCJB2,REJECT=COMJ          CANCEL JOB
         $COMTAB CS,HASPCJB2,REJECT=COMJ CANCEL STC(S)
         $COMTAB CT,HASPCJB2,REJECT=COMJ CANCEL TSU(S)
         $COMTAB C,HASPCDV1,REJECT=COMD           CANCEL DEVICE ACTVY.
COMTBLD  $COMTAB D7D,HASPCJB3,REDIR=$D7D DISPLAY JOB BY NAME
         $COMTAB DA,HASPCJB1,REDIR=$DA  DISPLAY ACTIVE JOBS
         $COMTAB DF,HASPCJ1A,REDIR=$DF  DISPLAY FORMS QUEUE    @OZ29819
         $COMTAB DI,HASPCSY1,REDIR=$DI  DISPLAY INITIATOR(S)
         $COMTAB DJ,HASPCJB2,REDIR=$DJ  DISPLAY JOB
         $COMTAB DM,HASPCRM1       DISPLAY MESSAGE
         $COMTAB DN,HASPCJB1,REDIR=$DN  DISPLAY INFO. ON Q'D JOBS
         $COMTAB DO,HASPCMS1,REDIR=$DO  DISPLAY OPERATOR REQUESTS
         $COMTAB DQ,HASPCJB1,REDIR=$DQ  DISPLAY NUMBER OF Q'D JOBS
         $COMTAB DS,HASPCJB2,REDIR=$DS DISPLAY STC(S)
         $COMTAB DT,HASPCJB2,REDIR=$DT DISPLAY TSU(S)
         $COMTAB DU,HASPCMS1,REDIR=$DU  DISPLAY UNITS
COMTBLE  $COMTAB E7D,HASPCJB3,REJECT=COMR+COMJ+COMS  RESTART JOB     R4
         $COMTAB EJ,HASPCJB2,REJECT=COMR+COMJ+COMS RESTART JOB       R4
         $COMTAB ES,HASPCSY1,REJECT=COMR+COMS RESTART SYSTEM         R4
         $COMTAB E,HASPCDV1,REJECT=COMD           RESTART DEVICE
COMTBLF  $COMTAB F,HASPCDV1,REJECT=COMD    FORWARD-SPACE DEVICE
COMTBLH  $COMTAB H7D,HASPCJB3,REJECT=COMJ  HOLD JOB BY NAME
         $COMTAB HA,HASPCJB1,REJECT=COMR+COMJ HOLD ALL JOBS          R4
         $COMTAB HJ,HASPCJB2,REJECT=COMJ          HOLD JOB
         $COMTAB HQ,HASPCJB1,REJECT=COMR+COMJ HOLD EXECUTION QUEUE   R4
         $COMTAB HS,HASPCJB2,REJECT=COMJ HOLD STC(S)
         $COMTAB HT,HASPCJB2,REJECT=COMJ HOLD TSU(S)
COMTBLI  $COMTAB I,HASPCDV1,REJECT=COMD    INTERRUPT DEVICE
COMTBLL  $COMTAB L7D,HASPCJB3              LIST JOB OUTPUT BY NM
         $COMTAB LJ,HASPCJB2       LIST A JOB'S OUTPUT
         $COMTAB LS,HASPCJB2       LIST A STC'S OUTPUT
         $COMTAB LT,HASPCJB2       LIST A STC'S OUTPUT
COMTBLN  $COMTAB N,HASPCDV1,REJECT=COMD    REPEAT DEVICE ACTIVITY
COMTBLO  $COMTAB O7D,HASPCJB3,REJECT=COMJ  OUTPUT BQES BY NAME
         $COMTAB OJ,HASPCJB4,REJECT=COMJ  OUTPUT JOB'S HELD DS
         $COMTAB OQ,HASPCJ1A,REJECT=COMR+COMJ OUTPUT BY CLASS        R4
         $COMTAB OS,HASPCJB4,REJECT=COMJ  OUTPUT STC'S HELD DS
         $COMTAB OT,HASPCJB4,REJECT=COMJ  OUTPUT TSU'S HELD DS
COMTBLP  $COMTAB P40,HASPCSY1,REJECT=COMR+COMS STOP SYSTEM           R4
         $COMTAB P7D,HASPCJB3,REJECT=COMJ  STOP JOB BY NAME          R4
         $COMTAB PI,HASPCSY1,REJECT=COMR+COMS STOP INITIATOR         R4
         $COMTAB PJ,HASPCJB2,REJECT=COMJ          STOP JOB
         $COMTAB PQ,HASPCJ1A,REJECT=COMR+COMJ CANCEL BY OUTPUT CLASS R4
         $COMTAB PS,HASPCJB2,REJECT=COMJ STOP STC(S)
         $COMTAB PT,HASPCJB2,REJECT=COMJ STOP TSU(S)
         $COMTAB P,HASPCDV1,REJECT=COMD           STOP (DRAIN) DEVICE
COMTBLR  $COMTAB R,HASPCRM1,REJECT=COMJ    ROUTE JOB OUTPUT
COMTBLS  $COMTAB S40,HASPCSY1,REJECT=COMR+COMS START SYSTEM          R4
         $COMTAB SA,HASPCAOC,REJECT=COMR+COMS START ACES             R4
         $COMTAB SI,HASPCSY1,REJECT=COMR+COMS START INITIATOR        R4
         $COMTAB S,HASPCDV1,REJECT=COMD      START DEVICE
COMTBLT  $COMTAB T7D,HASPCJB3,REJECT=COMR+COMJ SET JOB BY NAME       R4
         $COMTAB TA,HASPCAOC,REJECT=COMR SET ACE                     R4
         $COMTAB TC,HASPCSY3,REJECT=COMR SET CONSOLE LIST LEVEL      R4
         $COMTAB TI,HASPCSY1,REJECT=COMR+COMS SET INITIATOR          R4
         $COMTAB TJ,HASPCJ3A,REJECT=COMR+COMJ SET JOB NO. CLASS PRIO R4
         $COMTAB TM,HASPCSY3,REJECT=COMR+COMS SET MESSAGE ROUTING    R4
         $COMTAB TO,HASPCSY3,REJECT=COMR SET OS CONSOLE              R4
         $COMTAB TS,HASPCJ3A,REJECT=COMR+COMJ SET STC NO.            R4
         $COMTAB TT,HASPCJ3A,REJECT=COMR+COMJ SET TSU NO.            R4
         $COMTAB T,HASPCDV1,REJECT=COMD  SET DEVICE
COMTBLV  $COMTAB VS,HASPCSY1,REJECT=COMR+COMS SEND COMMAND TO VS     R4
COMTBLZ  $COMTAB ZA,HASPCAOC,REJECT=COMR+COMS HALT ACES              R4
         $COMTAB ZI,HASPCSY1,REJECT=COMR+COMS HALT INITIATOR         R4
COMTBLZZ $COMTAB Z,HASPCDV1,REJECT=COMD  HALT DEVICE
COMTABE  EQU   COMTBLZZ
         EJECT
COMFASTR DS    0F                  FAST LOOK-UP TABLE FOR HASPCOMM
         DC    C'A',AL3(COMTBLA)   ENTRY FOR 'A' VERBS
         DC    C'B',AL3(COMTBLB)   ENTRY FOR 'B' VERBS
         DC    C'C',AL3(COMTBLC)   ENTRY FOR 'C' VERBS
         DC    C'D',AL3(COMTBLD)   ENTRY FOR 'D' VERBS
         DC    C'E',AL3(COMTBLE)   ENTRY FOR 'E' VERBS
         DC    C'F',AL3(COMTBLF)   ENTRY FOR 'F' VERBS
         DC    C'H',AL3(COMTBLH)   ENTRY FOR 'H' VERBS
         DC    C'I',AL3(COMTBLI)   ENTRY FOR 'I' VERBS
         DC    C'L',AL3(COMTBLL)   ENTRY FOR 'L' VERBS
         DC    C'N',AL3(COMTBLN)   ENTRY FOR 'N' VERBS
         DC    C'O',AL3(COMTBLO)   ENTRY FOR 'O' VERBS
         DC    C'P',AL3(COMTBLP)   ENTRY FOR 'P' VERBS
         DC    C'R',AL3(COMTBLR)   ENTRY FOR 'R' VERBS
         DC    C'S',AL3(COMTBLS)   ENTRY FOR 'S' VERBS
         DC    C'T',AL3(COMTBLT)   ENTRY FOR 'T' VERBS
         DC    C'V',AL3(COMTBLV)   ENTRY FOR 'V' VERBS
COMFSTND DC    C'Z',AL3(COMTBLZ)   ENTRY FOR 'Z' VERBS
         EJECT
*
*        SYMBOLS TO DEFINE COMMAND TABLE ELEMENT FIELDS
*
COMTEL   EQU   8                   LENGTH OF EACH COMTAB ELEMENT
COMTOFF  EQU   COMTEL-4            LOCATION OF ENTRY OFFSET
COMTFL   EQU   COMTEL-8            LOCATION OF FLAGS WITHIN ELEMENT
COMTVB   EQU   COMTEL-2            LOCATION OF VERB WITHIN GROUP
COMR     EQU   CMBFLAGR            LEVEL OF RESTRICTION FOR REMOTES  R4
COMS     EQU   DCTREJSY            REJECT UNLESS SYSTEM AUTHORIZATION
COMD     EQU   DCTREJDV            REJECT UNLESS DEVICE AUTHORIZATION
COMJ     EQU   DCTREJJB            REJECT UNLESS JOB AUTHORIZATION
COMJDS   EQU   COMJ+COMD+COMS      COMBINATION
         SPACE 2
         LTORG ,
 TITLE 'HASP COMMAND PROCESSOR KNOWN COMMANDS'
***********************************************************************
*                                                                     *
*        COMMAND SUB-PROCESSOR CONVENTIONS                            *
*                                                                     *
* CONTENTS OF REGISTERS UPON ENTRY TO EACH COMMAND SUB-PROCESSOR      *
*                                                                     *
*        R0    = UNPREDICTABLE                                        *
*        R1    = SUB-PROCESSOR ENTRY POINT                            *
*        WA    = UNPREDICTABLE                                        *
*        WB    = UNPREDICTABLE                                        *
*        WC    = UNPREDICTABLE                                        *
*        WD    = FIRST OPERAND POINTER                                *
*        WE    = COUNT OF 4                                           *
*        WF    = LAST OPERAND POINTER ( SET FOR BXLE WD,WE,... )      *
*        WG    = BASE FOR COMMAND SUB-PROCESSOR                       *
*        BASE1 = HCTDSECT                                             *
*        BASE2 = BEGINNING OF MAIN COMMAND PROCESSOR                  *
*        SAVE  = PCE OF COMMAND PROCESSOR                             *
*        LINK  = UNPREDICTABLE                                        *
*        R15   = UNPREDICTABLE                                        *
*                                                                     *
* EXAMPLE EDIT OF COMMAND TEXT BEFORE ENTRY TO SUB-COMMAND PROCESSOR  *
*                                                                     *
* ORIGIONAL IN $WTO BUFFER  ( S OVER CHARACTER = LOWER CASE )         *
*                                                                     *
*         S  S S S    S S S    S    S    S                            *
*        $V  A B C, ' A B,C '' D ', D '' E                            *
*                                                                     *
* FORM PASSED TO COMMAND SUB-PROCESSOR                                *
*                                                                     *
*                                                                     *
*        $VABC,' A B,C ' D ',D'E                                      *
*          1   2             3   4                                    *
*                                                                     *
*        $ IS LOCATED AT COMMAND                                      *
*                                                                     *
*        V IS SINGLE CHARACTER FORM OF VERB                           *
*                                                                     *
*        WD POINTS TO FIRST OF OPERAND POINTER TABLE WHICH, IN THIS   *
*        EXAMPLE, CONTAINS FOUR WORDS OF ADDRESSES WHICH IN TURN      *
*        LOCATES THE BEGINNING OF EACH OPERAND ( INCLUDING A NULL     *
*        END OPERAND ). THESE LOCATIONS ARE DENOTED BY REFERANCE      *
*        POINTS 1, 2, 3, AND 4 RESPECTIVELY. USING BXLE WD,WE,...     *
*        INSTRUCTION WILL FALL THROUGH WITH WD POINTING TO COMNULOP   *
*                                                                     *
***********************************************************************
 TITLE 'HASP COMMAND PROCESSOR HASPCJB1 - JOB QUEUE COMMANDS'
HASPCJB1 $COMGRUP AA,AQ,DA,DN,DQ,HA,HQ  JOB QUEUE COMMANDS     @OZ29819
***********************************************************************
*                                                                     *
*        $A A -- RELEASE ALL JOBS IN JOB QUEUE HELD BY $H A           *
*        $H A -- HOLD ALL JOB(S) IN THE JOB QUEUE                     *
*                                                                     *
*        OPERANDS                                                     *
*        SID...SID = JOB(S) BELONGING TO INDICATED SYSTEMS ARE TO     *
*              BE HELD/RELEASED                                       *
*        ALL   = ALL JOB(S) ARE TO HELD/RELEASED                      *
*        NO OPERAND ONLY JOBS WITH AFFINITY TO ENETRING SYSTEM ARE    *
*              TO BE HELD/RELEASED                                    *
*                                                                     *
*                                                                     *
***********************************************************************
CAA      DS    0H                  RELEASE ALL JOBS IN QUEUE
CHA      DS    0H                  HOLD ALL JOBS IN THE QUEUE
         MVI   COMNULOP,0          SET NO SID AFFINITY
CAASCAN  BXH   WD,WE,CAAEND        SCAN FOR SID OPERNADS
         L     R1,0(,WD)           POINT TO 1ST OPERAND
         CLC   0(3,R1),=C'ALL'     CHECK FOR WHOLE QUEUE OPERATION
         BNE   *+14                NO--LOOK FOR SPECIFIC SID
         MVC   COMNULOP(L'QUESYSAF),=AL1(QUESYSAF) YES FLAG 'ALL'
         B     CAAEND              EXIT OPERAND SCAN LOOP
         L     R14,$QSE1           NO -- POINT TO ALL QSES           R4
         SH    R14,$QSEL           BACK UP ONE QSE                   R4
         USING QSEDSECT,R14        ADDRESSABILITY
CAASILOP AH    R14,$QSEL           POINT TO NEXT QSE                 R4
         CLC   QSESID,0(R1)        DOES SID MATCH OPERAND            R4
         BE    CAASIFND            YES--FLAG SID FOUND
         TM    QSEFLAGS,QSELAST    NO--SCAN ALL SID'S
         BZ    CAASILOP            BR IF NOT LAST QSE                R4
        $CFINVO OPERAND=(R1)       IF NOT FOUND, INVALID OPRAND     R41
CAASIFND DS    0H                  SID MATCHES OPERAND
         MVC   COMNULOP(L'QSESIAFF),QSESIAFF SET AFFINITY FLAG
         DROP  R14                 DROP QSE ADDRESSABILITY
CAAEND   DS    0H                  END OF OPERAND SCAN
         CLI   COMNULOP,0          TEST FOR ANY SID'S FOUND
         BNE   CAAOPXIT            YES--DON'T SET DEFAULT AFF FLAG
         MVC   COMNULOP(L'$SIDAFF),$SIDAFF NO--SET DEFAULT AFF FLAG
CAAOPXIT DS    0H                  EXIT OPERAND FUNCTION
         SPACE 2
         $QSUSE  ,                 ENQUEUE ON SHARED RESOURCE
         SPACE 1
         $CFJSCAN PROCESS=CAAPRO,EMPTY=CAANONE,NEXT=CAANXT,            C
               IGNORE=CAAIGN       SCAN JOB QUEUE
         $POST $HASPECF,(JOB,JOT)  POST FOR JOB AND JOT
         OI    $AQSE,QSEPJOB+QSEPJOT   CAUSE X SYSTEM POST(S)
         $CRET MSG=OK              AND RETURN
CAANONE  DS    0H                  NO JOBS FOUND
         CLI   COMVERB,C'H'        TEST FOR HOLD OPERATION           R4
         MVC   COMMAND(12),=C'NO JOBS HELD' ASSUME TXT FOR NONE HELD R4
         BNE   CAAREL              NO--RELEASE OPERATION
         LA    R0,12               SET DEFAULT MESSAGE LENGTH
         B     CHAAMSG             SEND DIAGNOSTIC
CAAREL   DS    0H                  RELEASE OPERATION
         MVC   COMMAND+8(8),=C'RELEASED'  SET 'RELEASED'
         LA    R0,16               SET MESSAGE LENGTH
CHAAMSG  DS    0H                  SEND DIAGNOSTIC
         $CRET L=(R0)              DITTO
CAAPRO   DS    0H                  JOB--FOUND EXAMINE SUCH
         IC    R15,COMNULOP        GET SYS AFFINITY BITS
         EX    R15,CHATEST         TEST FOR DESIRED AFFINITY
         BZ    CAAIGN              NO--IGNORE THIS ENTRY
         CLI   COMVERB,C'A'        IS THIS A RELEASE OPERATION
         BE    CARREL              YES--TEST FOR SAME
         OI    JQEFLAGS,QUEHOLDA   NO--HOLD JOB WITH 'ALL' OPERAND
         B     CAACKPT             AND CHECKPOINT CHANGED JOB
CARREL   DS    0H                  RELEASE JOB
         TM    JQEFLAGS,QUEHOLDA   IS JOB HELD BY 'ALL'
         BZ    CAAIGN              NO--IGNORE IT
         TM    JQEFLAGS,QUEHOLD1   IS JOB HELD BY $HJ COMMAND
         BO    CAAIGN              YES--IGNORE THIS ONE
         NI    JQEFLAGS,255-QUEHOLDA  ELSE RESET HOLD 'ALL' BIT
CAACKPT  DS    0H                  CHECKPOINT CHANGED ELEMENT
         $QCKPT (R1)               DO IT
         B     CAANXT              GET NEXT JOB
CHATEST  TM    JQEFLAG2,*-*        **** EXECUTE ONLY ****
         EJECT
***********************************************************************
*                                                                     *
*        $A Q,CLASSES -- RELEASE EXECUTION QUEUE                      *
*                                                                     *
***********************************************************************
CAQ      DS    0H
***********************************************************************
*                                                                     *
*        $H Q,CLASSES -- HOLD EXECUTION QUEUE                         *
*                                                                     *
***********************************************************************
CHQ      NULL                      RTN TO 'HOLD', 'RELEASE' A CLAS
         L     WA,$CATABLE         POINT TO THE HEAD OF THE CAT
         LR    WB,WA               SAVE THE POINTER FOR LATER USE
         BXLE  WD,WE,CHQLIST       CHECK FOR CLASS LIST SPECIFIED
         LA    WA,CATEND-CATDSECT(,WA) POINT TO 1ST CLASS
         LA    R0,C'9'-C'A'+1      SET NUMBER OF CLASSES TO SCAN
CHQL     BAL   LINK,CHQSET         SET 'HOLD' OR 'RELEASE'
         LA    WA,CATEND-CATDSECT(,WA) POINT TO NEXT CAT ELEM
         B     CHQL                LOOP THROUGH CAT(HEAD TO TAIL)
         SPACE 1
CHQLIST  NULL                      COME HERE TO HANDLE LIST
         L     R1,0(,WD)           POINT TO BEGINNING OF OPERAND
         L     R15,4(,WD)          POINT TO END OF OPERAND
         BCTR  R15,0               REDUCE BY
         BCTR  R15,0               TWO FOR MACHINE LENGTH
         SR    R15,R1              COMPUTE OPERAND MACHINE LENGTH
         BM    CHQINVO             IF NEGATIVE,  ERROR
         LR    R0,R1               SAVE R1 OVER 'TRT'
         L     WA,=A(CVALIDTB)     POINT TO TEST TABLE               R4
         EX    R15,CHQTEST         TEST CLASS STRING
         LR    R1,R0               RESTORE R1
         BNZ   CHQINVO             INVALID CHARACTERS  ERROR
         LA    R0,1(,R15)          GET LENGTH OF STRING AGAIN
CHQLL    SLR   WA,WA               CLEAR WORK REGISTER
         IC    WA,0(,R1)           INSERT CLASS INTO WORK
CHQC     SL    WA,=A(X'C0')        GET ORDINAL PLACE IN CAT
         SLL   WA,5                FIND CARDINAL PLACE IN CAT
         ALR   WA,WB               ADD $CATABLE BASE
         TM    CATJOBFL-CATDSECT(WA),CATVALID TEST FOR VALID CLASS
         BZ    CHQINVO             INVALID CLASS--ERROR
         BAL   LINK,CHQSET         GO SET 'HOLD' OR 'RELEASE'
         LA    R1,1(,R1)           POINT TO NEXT CLASS IN STRING
         B     CHQLL               LOOP THROUGH ENTIRE OPERAND
CHQTEST  TRT   0(*-*,R1),0(WA)     *** EXECUTE ONLY ***              R4
CHQSET   NULL                      COME HERE TO SET THE 'CAT'
         CLI   COMVERB,C'H'        IS THIS A HOLD OPERATION
         BE    CHQH                YES-HOLD CAT(NOT BY TAIL)
         NI    CATJBOPT-CATDSECT(WA),255-CATQHELD FREE THE CAT
         $POST $HASPECF,JOB        POST INITS' IF WAITING
CHQA     BCTR  R0,LINK             RETURN IF CLASSES NOT EXHAUSTED
*                                  CLASSES EXHAUSTED--GO BACK
*                                  AND RESET TSU AND STC CLASSES
*                                  THAT WERE SET BY ALL TYPE
         SPACE 1
         NI    CATJBOPT-CATDSECT+(CATSTCCL-X'C0')*(CATEND-CATDSECT)(WB)C
               ,255-CATQHELD       RESET 'STC'
         NI    CATJBOPT-CATDSECT+(CATTSUCL-X'C0')*(CATEND-CATDSECT)(WB)C
               ,255-CATQHELD       RESET 'TSU'
         $CRET MSG=OK              RETURN WITH 'OK' MSG
         SPACE 2
CHQH     OI    CATJBOPT-CATDSECT(WA),CATQHELD SET 'HOLD' BIT 'ON'
         B     CHQA                RETURN TO MAJOR LOOP
         SPACE 1
CHQINVO  $CFINVO OPERAND=(R1)      INVALID OPERAND--ERROR EXIT
         EJECT
***********************************************************************
*                                                                     *
*        $D A,SID...SID, OR ALL/XEQ/DEV/JOB/STC/TSU                   *
*        DISPLAY ACTIVE JOB(S)                                        *
*                                                                     *
*        SID...SID = ACTIVE JOBS ON THE SPECIFIED SYSTEM(S)           *
*        ALL   = ACTIVE JOB(S) ON ALL SYSTEM(S)                       *
*        XEQ   = DISPLAY JOBS IN EXECUTION                            *
*        DEV   = DISPLAY JOBS ON DEVICES                              *
*        JOB   = DISPLAY NORMAL JOBS                                  *
*        STC   = DISPLAY SYSTEM TASK CONTROL JOBS                     *
*        TSU   = DISPLAY TIME SHARING USER JOBS                       *
*                                                                     *
***********************************************************************
CDA      DS    0H
         MVI   COMPNTER+COFOPT-COFOPT,0 ZERO OPTION FLAGS            R4
         MVI   COMPNTER+COFAFF-COFOPT,0 ZERO AFFINITY FLAGS          R4
CDAC     BXLE  WD,WE,CDAFIL        FILL OUT OPTIONS IF MORE OPERANDS
         MVC   COFOPT(L'COFOPT+L'COFAFF),COMPNTER SET OPTIONS        R4
         CLI   COFOPT,0            ANYTHING SPECIFIED                R4
         BNZ   SKIP50              SKIP IF YES                       R4
         MVI   COFOPT,COFD+COFX+COFN SET NORMAL JOB AS DEFAULT       R4
SKIP50   TM    COFOPT,COFD+COFX    XEQ OR DEV                        R4
         BNZ   SKIP60              TEST TO FORCE JOB TYPE            R4
         OI    COFOPT,COFD+COFX    FORCE BOTH                        R4
SKIP60   TM    COFOPT,COFJ         JOB STC TSU                       R4
         BNZ   CDAFFSET            SET AFFINITIES IF NOT             R4
         OI    COFOPT,COFJ         FORCE JOB STC TSU                 R4
CDAFFSET DS    0H                  TEST FOR AFFINITY SETTING
         CLI   COFAFF,0            TEST FOR ANY AFFINITY OPERANDS
         BNE   *+10                YES--SKIP SETTING OF DEFAULT
         MVC   COFAFF,$SIDAFF      SET DEFAULT ACTIVE SYSTEM
         LA    R1,CDAQLIST-1       QUEUE LIST - 1              @OZ29819
         ST    R1,CDAQTYPE         SAVE FOR QUEUE SCAN         @OZ29819
         TM    COFOPT,COFS         DISPLAY STARTED TASKS...    @OZ29819
         BZ    *+12                BR IF NO                    @OZ29819
         MVI   1(R1),CATSTCCL-X'80' ELSE SET STC QUEUE         @OZ29819
         LA    R1,1(,R1)             AND UPDATE QUEUE POINTER  @OZ29819
         TM    COFOPT,COFT         DISPLAY TSO LOGONS...       @OZ29819
         BZ    *+12                BR IF NO                    @OZ29819
         MVI   1(R1),CATTSUCL-X'80' ELSE SET TSU QUEUE         @OZ29819
         LA    R1,1(,R1)             AND UPDATE QUEUE POINTER  @OZ29819
         TM    COFOPT,COFN         DISPLAY BATCH JOBS...       @OZ29819
         BZ    *+14                BR IF NO                    @OZ29819
         MVC   1(36,R1),CDQTYPEA    ELSE SET NORMAL JOB CLASSES@OZ29819
         LA    R1,36(,R1)            AND UPDATE QUEUE POINTER  @OZ29819
         TM    COFOPT,COFD         DISPLAY JOBS ON DEVICES...  @OZ29819
         BZ    *+14                BR IF NO                    @OZ29819
         MVC   1(3,R1),=AL1($INPUT,$OUTPUT,$HARDCPY) DEV QUEUES@OZ29819
         LA    R1,3(,R1)           UPDATE QUEUE POINTER        @OZ29819
         MVI   1(R1),255           SET END OF QUEUES INDICATOR @OZ29819
         SLR   WE,WE               CLEAR 'JOB FOUND' INDICATOR @OZ29819
         SPACE 1                                               @OZ29819
CDALOOPA L     R1,CDAQTYPE         INCREMENT                   @OZ29819
         LA    R1,1(,R1)            POINTER TO                 @OZ29819
         ST    R1,CDAQTYPE           JOB QUEUE TYPE            @OZ29819
         CLI   0(R1),255           ALL QUEUES PROCESSED...     @OZ29819
         BE    CDAEND              BR IF YES                   @OZ29819
         SLR   R15,R15             CLEAR FOR INSERT            @OZ29819
         IC    R15,0(,R1)          GET NEXT QUEUE TYPE         @OZ29819
        $CFJSCAN PROCESS=CDAPRO,NEXT=CDANXT,QUEUE=(R15)        @OZ29819
         B     CDALOOPA            BR TO PROCESS NEXT QUEUE    @OZ29819
         SPACE 1                                               @OZ29819
CDAEND   LTR   WE,WE               ANY JOBS DISPLAYED...       @OZ29819
         BZ    CDANONE             BR IF NO                    @OZ29819
        $CRET  ,                    ELSE EXIT                  @OZ29819
CDANONE  $CRET MSG='NO ACTIVE JOBS' EXIT WITH DIAGNOSTIC
CDAPRO   DS    0H                  CHECK JOB FOR SID ACTIVITY
         LR    WD,R1               SAVE R1 OVER DISPLAY
         $CFJMSG OPT=SET,AFF=SET   DISPLAY JOB
         B     CDAJOK              +0 -- JOB DISPLAYED
         LR    R1,WD               +4 -- JOB NOT ACTIVE
         B     CDANXT              BR TO GET NEXT JOB          @OZ29819
CDAJOK   L     R1,CDAQTYPE         GET ADDRESS OF QUEUE TYPE   @OZ29819
         SLR   R15,R15             CLEAR FOR INSERT            @OZ29819
         IC    R15,0(,R1)          GET QUEUE TYPE              @OZ29819
        $CFJSCAN PROCESS=CDACK,NEXT=CDACKNXT,QUEUE=(R15)       @OZ29819
         $CRET MSG='LIST INCOMPLETE' EXIT WITH ERROR
CDACK    CR    R1,WD               SAME JQE
         BNE   CDACKNXT            LOOP IF NOT SAME JOB
         LR    WE,R1               INDICATE JOB DISPLAYED      @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
         B     CDANXT              CONTINUE DISPLAYING JOBS
         SPACE 3
***********************************************************************
*                                                                     *
*        LOOK AT LIMITING OPERANDS                                    *
*                                                                     *
***********************************************************************
CDAFIL   DS    0H                  SCAN OPERANDS
         LM    R1,WA,0(WD)         PICK-UP OPERANDS
         SLR   WA,R1               COMPUTE
         BCTR  WA,0                ACTUAL OPERAND LENGTH
         CH    WA,=H'4'            CHECK WITH SID LENGTH
         BNE   CDACKALL            NO--MAYBE FOR ALL SID'S
         L     R14,$QSE1           POINT TO 1ST QSE                  R4
         SH    R14,$QSEL           BACK UP ONE QSE                   R4
         USING QSEDSECT,R14        ADDRESSABILITY
CDAQLOOP AH    R14,$QSEL           POINT TO NEXT QSE                 R4
         CLC   QSESID,0(R1)        DOES OPERAND MATCH SID            R4
         BE    CDAQFND             YES--FLAG AS SUCH
         TM    QSEFLAGS,QSELAST    NO--LOOP THROUGH ALL SIDS         R4
         BZ    CDAQLOOP            LOOKING FOR SID MATCH
         B     CDAINVO             NOT FOUND -- ERROR
CDAQFND  DS    0H                  SID MATCHED OPERAND
         OC    COFAFF-COFOPT+COMPNTER,QSESIAFF SET AFFINITY          R4
         B     CDAC                LOOK FOR MORE OPERANDS
CDACKALL DS    0H                  NOT A SPECIFIC SID -- 'ALL'
         CLC   0(3,R1),=C'ALL'     WAS IT ALL SIDS
         BNE   *+12                NO--SCAN OTHER OPERANDS
         MVI   COFAFF-COFOPT+COMPNTER,X'7F' SET FOR ALL SYSTEMS      R4
         B     CDAC                AND CONTINUE EXAMING OPERANDS
         DROP  R14                 DISESTABLISH-ADDRESSABILITY
         LA    WA,COFN             SET FOR BATCH JOBS
         CLI   0(R1),C'J'          TEST FOR SAME
         BE    CDASET              YES--FLAG REQUEST
         LA    WA,COFS             SET FOR SYSTEM TASKS
         CLI   0(R1),C'S'          TEST FOR SAME
         BE    CDASET              YES--FLAG REQUEST
         LA    WA,COFT             SET FOR TIME SHARING USERS
         CLI   0(R1),C'T'          TEST FOR SAME
         BE    CDASET              YES--FLAG REQUEST
         LA    WA,COFD             SET REQUEST FOR DEVICE(S)
         CLI   0(R1),C'D'          TEST FOR SAME
         BE    CDASET              YES--FLAG REQUEST
         LA    WA,COFX             SET REQUEST FOR JOB IN EXECUTION
         CLI   0(R1),C'X'          TEST FOR SAME
         BE    CDASET
CDAINVO  $CFINVO OPERAND=(R1)      TELL OPERATOR ABOUT INVO OPERAND
CDASET   EX    WA,CDAOI            TURN BIT ON
         B     CDAC                LOOP
CDAOI    OI    COFOPT-COFOPT+COMPNTER,*-*  *** EXECUTE ONLY ***      R4
         SPACE 1                                               @OZ29819
CDAQTYPE EQU   COMPNTER,4          POINTER TO JOB QUEUE TYPE   @OZ29819
CDAQLIST EQU   CDAQTYPE+4,40       QUEUES TO BE PROCESSED      @OZ29819
         EJECT
***********************************************************************
*                                                                     *
*        $D N -- DISPLAY INFORMATION ON QUEUED JOBS                   *
*                                                                     *
***********************************************************************
CDN      LA    WC,CDNCTR           SET TO LIST EACH JOB
         MVI   CDNFLAG,CDNFLGN     INDICATE $DN                @OZ29819
         B     CDQBREAK            ENTER COMMON CODE WITH $D Q
         EJECT
***********************************************************************
*                                                                     *
*        $D Q -- DISPLAY JOB QUEUE                                    *
*                                                                     *
***********************************************************************
CDQ      LA    WC,CDQCTR           SET TO COUNT EACH JOB
         MVI   CDNFLAG,0           RESET ALL FLAGS             @OZ29819
***********************************************************************
*                                                                     *
*        FORMAT OF OPERANDS                                           *
*                                                                     *
*        SID/ALL/ANY/IND - OPERAND TWO                                *
*              JOBS WITH AFFINITY TO SYSTEM (SID) (DEFAULT=OWN)       *
*              JOBS WITH AFFINITY TO SYS 1,2,... (ALL)                *
*              JOBS WITH AFFINITY TO ANY SYSTEM (ANY)                 *
*        ALL   = ALL JOB(S) REGARDLESS OF THE SYSTEM AFFINITY         *
*        ANY   = JOB(S) WITH AFFINITY TO 'ANY' SYSTEM                 *
*              IND JOBS FOR OWN SYSTEM IN INDEPENDENT MODE            *
*        IND   - THIRD OPERAND QUALIFIES SID/ALL/ANY OF OPERAND TWO   *
*        R=DEST1-DEST2 - JOBS WITH ROUTE CODES WITHIN RANGES          *
*        Q=XEQ/XEQ CLASS/OUT/PPU/HOLD - QUEUE TYPE                    *
*                                                                     *
***********************************************************************
*        BREAK OUT OPERANDS                                           *
         SPACE 1
CDQBREAK DS    0H                  BREAK-OUT OPERANDS
                                   PRINT OFF - SECTION DELETED @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
                                   PRINT ON -- SECTION DELETED @OZ29819
         TM    COMAUTH,CMBFLAGR    IS CONSOLE REMOTE RESTRICTED     R41
         BO    CDQRTD              YES--GET DEFAULT ROUTE RANGE     R41
         MVC   CDQDEFR,CDQRALLD    INCLUDE ALL ROUTE CODES     @OZ29819
         B     CDQLOCAL            SKIP REMOTE                       R4
CDQRTD   BAL   LINK,COFRTD         GET DEFAULT ROUTE RANGES IN R1,R0 R4
         STH   R0,CDQRBNDH         SET HIGH BOUND                    R4
         STH   R1,CDQRBNDL         SET LOW BOUND                     R4
CDQLOCAL MVC   CDQSIDLO,$SIDAFF    ASSUME OUR SYSTEM                 R4
         MVC   CDQSIDHI,$SIDAFF    AS DEFAULT                        R4
         MVC   CDQSE,CDQS          MOVE IN SCAN PARAMETER DEFAULTS   R4
         BXH   WD,WE,CDQXITT       SET DEFAULT SCAN ELEMENTS IF NULL R4
         L     R1,0(,WD)           POINT TO OPERAND                  R4
         CLI   1(R1),C'='          THIS EQUAL                        R4
         BE    CDQROUT             TRY ROUTE RANGE IF YES            R4
         CLC   0(3,R1),=C'ANY'     TEST FOR AFFINITY REQ OF 'ANY'
         BNE   CDQSIDMO            NO-LOOK FOR 'ALL' OR SPECIFIC AFF
         MVI   CDQSIDLO,QUESYSAF   SET AFFINITY TO ANY               R4
         MVI   CDQSIDHI,QUESYSAF   HIGH SAME AS LOW                  R4
         B     CDQSIDND            AND EXIT AFFINITY SCAN
CDQSIDMO CLC   0(3,R1),=C'ALL'     THIS ALL                          R4
         BNE   CDQSIDLK            LOOK FOR SID                      R4
         MVI   CDQSIDLO,1          SET MASK FOR FIRST QSE            R4
         LH    R14,$QSENO          GET NUMBER OF QSES                R4
         IC    R14,CDQQSEAF(R14)   PICK UP AFFINITY OF HIGH QSE      R4
         STC   R14,CDQSIDHI        SET HIGH QSE MASK                 R4
         OI    CDNFLAG,CDNALL      SET ALL SPECIFIED                 R4
         B     CDQSIDND            EXIT AFFINITY SCAN                R4
CDQSIDLK CLC   0(3,R1),=C'IND'     THIS IND                          R4
         BE    CDQIND              SET IND IF YES                    R4
         L     R14,$QSE1           POINT TO 1ST QSE                  R4
         SH    R14,$QSEL           BACK UP ONE QSE                   R4
         USING QSEDSECT,R14        QSE ADDRESSABILITY
CDQSIDLL AH    R14,$QSEL           POINT TO NEXT QSE                 R4
         CLC   QSESID,0(R1)        FOUND QSE                         R4
         BE    CDQSIDFD            YES--FILL IN END AFFINITY
CDQSIDLP TM    QSEFLAGS,QSELAST    TEST FOR LAST ELEMENT
         BZ    CDQSIDLL            AND LOOP THROUGH ALL ELEMENTS
CDQINVOA L     R1,0(,WD)           POINT TO ERROR OPERAND            R4
CDQINVO  $CFINVO OPERAND=(R1)      ERROR EXIT                        R4
CDQSIDFD MVC   CDQSIDLO,QSESIAFF   SET AFFINITY                      R4
         MVC   CDQSIDHI,QSESIAFF   SET ENDING AFFINITY
         DROP  R14                 DROP QSE ADDRESSABILITY
CDQSIDND BXH   WD,WE,CDQXITT       SET DEFAULT SCAN ELEMENT IF NULL  R4
         L     R1,0(,WD)           POINT TO OPERAND                  R4
         CLI   1(R1),C'='          THIS EQUAL                        R4
         BE    CDQROUT             TRY ROUTE RANGE IF YES            R4
         CLC   0(3,R1),=C'IND'     THIS IND                          R4
         BNE   CDQINVO             ERROR IF NOT                      R4
CDQIND   OI    CDNFLAG,CDNIND      SET INDEPENDENT MODE              R4
         OI    CDQSIDLO,QUEINDAF   SET LOW BOUND IND                 R4
         OI    CDQSIDHI,QUEINDAF   SET HIGH BOUND IND                R4
CDQNXTOP BXH   WD,WE,CDQXITT       LOOK FOR MORE                     R4
         L     R1,0(,WD)           POINT TO OPERAND                  R4
         CLI   1(R1),C'='          THIS EQUAL                        R4
         BNE   CDQINVO             ERROR IF NOT                      R4
CDQROUT  CLI   0(R1),C'R'          THIS ROUTE CODE                   R4
         BNE   CDQTYPE             TRY TYPE IF NOT                   R4
         TM    CDNFLAG,CDNROUT     ROUTE ALREADY BEEN SPECIFIED      R4
         BO    CDQINVO             ERROR IF YES                      R4
         OI    CDNFLAG,CDNROUT     SET ROUTE SPECIFIED               R4
         BAL   LINK,COFRTRA        CONVERT DESTINATION               R4
         B     CDQINVOA            ERROR IF BAD             + 0      R4
         STH   R1,CDQRBNDL         SET LOW ROUT CODE        + 4      R4
         STH   R0,CDQRBNDH         SET HIGH ROUTING CODE
         B     CDQNXTOP            DO NEXT OPERAND                   R4
CDQTYPE  CLI   0(R1),C'Q'          THIS QUEUE TYPE                   R4
         BNE   CDQINVO             ERROR IF NOT                      R4
         TM    CDNFLAG,CDNTYPE     ALREADY SPECIFIED                 R4
         BO    CDQINVO             ERROR IF YES                      R4
         OI    CDNFLAG,CDNTYPE     SET SPECIFIED                     R4
         CLC   2(3,R1),=C'XEQ'     EXECUTION QUEUE                   R4
         BNE   CDQOUTT             IF NOT TEST OUT
         CLI   5(R1),C' '          ALL QUEUES...               @OZ29819
         BE    CDQENDS             BR IF YES                   @OZ29819
         CLI   5(R1),C','          ALL QUEUES...               @OZ29819
         BE    CDQENDS             BR IF YES                   @OZ29819
         LA    R15,CDQTYPEC        ASSUME CONVERSION QUEUE     @OZ29819
         CLI   5(R1),C'*'          IF CONVERSION QUEUE,        @OZ29819
         BE    CDQXCLS              BR TO TEST NEXT OPERAND    @OZ29819
         LA    R15,CDQTYPE$        ASSUME STC QUEUE            @OZ29819
         CLI   5(R1),CATSTCID      IF                          @OZ29819
         BE    CDQXCLS              STC                        @OZ29819
         CLC   5(3,R1),=C'STC'       QUEUE,                    @OZ29819
         BE    CDQXCLS                BR TO TEST NEXT OPERAND  @OZ29819
         LA    R15,CDQTYPE@        ASSUME TSU QUEUE            @OZ29819
         CLI   5(R1),CATTSUID      IF                          @OZ29819
         BE    CDQXCLS              TSU                        @OZ29819
         CLC   5(3,R1),=C'TSU'       QUEUE,                    @OZ29819
         BE    CDQXCLS                BR TO TEST NEXT OPERAND  @OZ29819
         MVC   COMDWORK(1),5(R1)   MOVE QUEUE TYPE TO WORK     @OZ29819
         NI    COMDWORK,QUECLASS   CONVERT TO INTERNAL FORMAT  @OZ29819
         LA    R15,CDQTYPEA        SET TO SCAN FOR JOB CLASS   @OZ29819
         LA    R0,36               MAX VALID CLASSES (A-Z, 0-9)@OZ29819
         SPACE 1                                               @OZ29819
CDQNXTCL CLC   0(1,R15),COMDWORK   THIS THE ONE...             @OZ29819
         BE    CDQXCLS             BR IF YES                   @OZ29819
         LA    R15,1(,R15)         POINT TO NEXT CLASS         @OZ29819
         BCT   R0,CDQNXTCL          ELSE LOOP                  @OZ29819
         B     CDQINVOA            NO SUCH CLASS (ERROR)       @OZ29819
         SPACE 1                                               @OZ29819
CDQXCLS  STCM  R15,7,CDQTYPLO      SET QUEUE RANGE             @OZ29819
         STCM  R15,7,CDQTYPHI       TO SPECIFIED QUEUE         @OZ29819
         B     CDQENDS             GO TO SET END
CDQOUTT  CLC   2(3,R1),=C'OUT'     IS IT OUTPUT                      R4
         BNE   CDQPPUTT            IF NOT CHK FOR PR/PU
         MVC   CDQSEE,CDQOUTD      MOVE OUT ELEMENT FIRST      @OZ29819
         B     CDQENDS             EXIT OPERAND SCAN ROUTINE
CDQPPUTT DS    0H                  CHECK FOR PRINT/PUCH QUEUEING
         CLC   2(3,R1),=C'PPU'     IS IT PRINT/PUNCH                 R4
         BNE   CDQHLDT             NO--CHECK FOR 'HOLD'              R4
         MVC   CDQSEE,CDQPPUD      MOVE PPU ELEMENT FIRST      @OZ29819
         B     CDQENDS             EXIT OPERAND SCAN ROUTINE
CDQHLDT  CLC   2(4,R1),=C'HOLD'    IS IT HOLD STATUS                 R4
         BNE   CDQINVO             ERROR IF NOT HOLD                 R4
         MVC   CDQSEE,CDQHLDD      MOVE HOLD ELEMENT FIRST     @OZ29819
CDQENDS  MVC   CDQSECDD,CDQENDD    MOVE END ELEMENT TO SECOND PLACE
         B     CDQNXTOP            DO NEXT OPERAND                   R4
         SPACE 1                                               @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
         SPACE 1                                               @OZ29819
* SET UP FOR JOB QUEUE SCAN
CDQXITT  SLR   R10,R10             ZERO QUEUE SCAN HOLD COUNT  @OZ29819
         MVC   CDQSESAV,CDQSEE     SAVE SEARCH ELEMENTS FOR NXT SID
         MVI   COMMAND+4,C' '      SET BLANK FOR $DQ MESSAGE
         CLC   CDQSIDLO,CDQSIDHI   TST FOR ELMNTION OF PPU ELEM
         BE    *+10                NO--LEAVE PPU ELEMENT
         MVC   CDQSEE+CDQPPUD-CDQS(2),CDQENDD  OMIT PPU        @OZ29819
CDQLOOP  DS    0H                  LOOP THROUGH ALL ELEMENTS
         LH    WF,CDQSEE           POINT TO CURRENT SEARCH ELEMENT
         CH    WF,CDQENDD          TEST FOR LAST ELEMENT
         BE    CDQSIDM             YES--CHK FOR MORE SID'S TO DO
         CH    WF,CDQOUTD          THIS OUTPUT QUEUE                 R4
         BE    SKIP110             SKIP NEXT IF YES                  R4
         CH    WF,CDQPPUD          THIS PRINT/PUNCH QUEUE            R4
         BNE   CDQLOOPB            SKIP NEXT IF NOT                  R4
SKIP110  MVC   CDQSHI(4),CDQDEFR   FORCE ROUTE RANGE                 R4
CDQLOOPB SLR   WE,WE               ZERO $DQ COUNTER                  R4
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
         LH    WB,CDQSHI           SET FIRST ROUTE CODE
         EJECT
***********************************************************************
*                                                                     *
*        SCAN THE JOB QUEUE                                           *
*                                                                     *
***********************************************************************
CDQLOOPA ICM   R1,7,CDQTYPLO       GET ADDRESS OF QUEUE TYPE   @OZ29819
         SLR   R15,R15             CLEAR FOR INSERT            @OZ29819
         IC    R15,0(,R1)          GET QUEUE TYPE              @OZ29819
        $CFJSCAN PROCESS=4(WF,BASE3),NEXT=CDQNXT,QUEUE=(R15)   @OZ29819
         LTR   R0,WE               TEST COUNT FOR ZERO
         BZ    CDQNRES             SKIP DISPLAY IF ZERO
         $CFCVE ,                  CONVERT TO PRINTABLE
         MVC   COMMAND(4),COMDWORK+1 SET NUMBER OF HITS
         B     0(WF,BASE3)         ENTER DISPLAY PREPARATION
CDQRES   $CWTO L=(R0)              RESPOND
         SPACE 1                                               @OZ29819
         SPACE 1                                               @OZ29819
CDQNRES  TM    CDNFLAG,CDNRSCAN    QUEUE RE-SCAN REQUIRED...   @OZ29819
         BZ    CDQNEXT             BR IF NO                    @OZ29819
         NI    CDNFLAG,255-CDNRSCAN  RESET RE-SCAN FLAG        @OZ29819
         STH   WB,CDQSLO           SET NEW RANGE LOW           @OZ29819
         B     CDQLOOPB             AND BR TO RE-SCAN QUEUE    @OZ29819
         SPACE 1                                               @OZ29819
CDQNEXT  ICM   R1,7,CDQTYPLO       GET ADDR OF CURRENT QUEUE   @OZ29819
         CLM   R1,7,CDQTYPHI       LAST QUEUE FOR THIS TYPE... @OZ29819
         BNL   CDQINCR             BR IF YES                   @OZ29819
         LA    R1,1(,R1)           INCREMENT QUEUE ADDRESS     @OZ29819
         STCM  R1,7,CDQTYPLO        AND SAVE                   @OZ29819
         B     CDQLOOPB            THEN BR TO SCAN NEXT QUEUE  @OZ29819
         SPACE 1                                               @OZ29819
CDQINCR  MVC   CDQSEE(L'CDQSE-L'CDQSEE),CDQSECDD SHIFT NEXT IN
         B     CDQLOOP             LOOP
         EJECT                                                 @OZ29819
CDQSIDM  TM    CDNFLAG,CDNFLGN     $DN...                      @OZ29819
         BO    CDQSIDN             BR IF YES                   @OZ29819
         LTR   R0,R10              ANY JOBS HELD THIS SYSTEM...@OZ29819
         BZ    CDQSIDN             BR IF NO                    @OZ29819
        $CFCVE ,                   CONVERT TO PRINTABLE        @OZ29819
         MVC   COMMAND(4),COMDWORK+1  SET NUMBER OF HITS       @OZ29819
         SLR   R10,R10             CLEAR JOB HOLD COUNT        @OZ29819
         B     CDQHLDE             ENTER HOLD DISPLAY ROUTINE  @OZ29819
         SPACE 1                                               @OZ29819
CDQSIDN  CLC   CDQSIDLO,CDQSIDHI   CHECK FOR END OF SCAN       @OZ29819
         BNL   CDQEND              IF NO MORE -- EXIT
         SLR   WE,WE               ZERO INSERT REGISTER
         ICM   WE,8,CDQSIDLO       PICK-UP CURRENT SYSTEM ID
         ALR   WE,WE               SHIFT LEFT ONE SYS ID
         STCM  WE,8,CDQSIDLO       SAVE NEW SYSTEM ID
         BC    12,*+8              BRANCH IF NOT IND SCAN
         OI    CDQSIDLO,QUEINDAF   ELSE FLAG IND SCAN
         MVC   CDQSE,CDQSESAV      RESTORE SEARCH ELEMENTS
         CLC   CDQSIDLO,CDQSIDHI   TST FOR ELMNTION OF PPU ELEM
         BE    CDQLOOP             NO--LEAVE ELEM FOR LAST SID
         MVC   CDQSEE+CDQPPUD-CDQS(2),CDQENDD  OMIT PPU        @OZ29819
         B     CDQLOOP             AND CONTINUE ELEMENT SCANS
         EJECT
***********************************************************************
*                                                                     *
*        EXAMINE JOB QUEUE ELEMENT                                    *
*                                                                     *
***********************************************************************
                                   PRINT OFF - SECTION DELETED @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
                                   PRINT ON -- SECTION DELETED @OZ29819
         SPACE 1
* REQUEST FOR 'XEQ' QUEUE
         SPACE 1
CDQXEQ   B     CDQXEQE             ENTER $DQ MESSAGE PREPARATION
         BAL   R14,CDQCKRTE        CHECK ROUTE CODES
         TM    JQEFLAGS,QUEBUSY    TEST FOR ACTIVE
         BNZ   CDQNXT              YES--GET NEXT JOB
         BAL   R14,CDQCKSID        CHECK FOR PROPER AFFINITY
         BR    WC                  ENTER $DN OR $DQ ROUTINE    @OZ29819
                                   PRINT OFF - SECTION DELETED @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
                                   PRINT ON -- SECTION DELETED @OZ29819
         SPACE 1
CDQXEQE  DS    0H                  DISPLAY QUEUED FOR EXECUTION
         MVC   COMMAND+5(6),=CL6'XEQ *' SET MESSAGE BODY
         LA    R1,COMMAND+11-COMMAND PT TO END OF MESSAGE
         ICM   R15,7,CDQTYPLO      GET ADDR OF QUEUE TYPE      @OZ29819
         CLI   0(R15),$XEQ         CONVERSION QUEUE...         @OZ29819
         BE    CDQSYSNM            BR IF YES                   @OZ29819
         MVC   COMMAND+9(1),0(R15) MOVE QUEUE TYPE TO MSG      @OZ29819
         OI    COMMAND+9,X'80'     MAKE CLASS PRINTABLE
         CLC   CDQSIDLO,$SIDAFF    CHECK FOR POSSIBLE USE OF CAT
         BNE   CDQNOCAT            NO--DIFFERENT MACHINE
         SLR   R14,R14             ZERO INSERT REGISTER
         IC    R14,0(,R15)         PICK UP CLASS               @OZ29819
         SL    R14,=A(X'40')       LESS OFFSET INTO CAT
         SLL   R14,5               TIMES CAT SIZE
         AL    R14,$CATABLE        PLUS BEGINNING ADDRESS IS ELEMENT
         USING CATDSECT,R14        CAT ADDRESSABILITY
         TM    CATJBOPT,CATQHELD   TEST FOR CLASS HELD ($HQ)
         BZ    CDQNOCAT            NO--EXIT CAT SCAN
         MVC   COMMAND+11(5),=CL5'HOLD' YES--FILL IN 'HOLD'
         LA    R1,COMMAND+16-COMMAND PT TO END OF MESSAGE
         B     CDQSYSNM            AND GO FILL IN SYSTEM NAME
         DROP  R14                 DROP QSE ADDRESSABILITY
CDQNOCAT DS    0H                  CAT NOT APPLICABLE
         CLI   COMMAND+9,CATSTCCL  TEST FOR SYSTEM TASK
         BNE   CDQNOSTC            NO--TRY FOR LOGON
         MVC   COMMAND+9(6),CDQTSKID SET STC DESIGNATION
         LA    R1,COMMAND+15-COMMAND PT TO END OF MESSAGE
         B     CDQSYSNM            GO FILL IN SYSTEM NAME
CDQNOSTC DS    0H                  TRY FOR LOGON
         CLI   COMMAND+9,CATTSUCL  TEST FOR TSU
         BNE   CDQSYSNM            NO--FIL-IN SYSTEM NAME
         MVC   COMMAND+9(6),CDQLOGID SET LOGON DESIGNATION
         LA    R1,COMMAND+15-COMMAND PT TO END OF MESSAGE
CDQSYSNM DS    0H                  FILL-IN SYSTEM NAME FOR AFFINITY
         LA    R1,COMMAND(R1)      PT TO END OF MESSAGE
         BAL   WA,CDQSIDNM         PICK-UP NAME
         MVC   0(L'QSESID,R1),0(R15)  FILL-IN NAME
         LA    R0,L'QSESID(,R1)    PT TO END OF MESSAGE
         TM    CDNFLAG,CDNIND      TEST FOR 'IND' REQUEST
         BZ    *+14                NO--SKIP NEXT INSTRUCTIONS
         MVC   L'QSESID(4,R1),=C' IND' SET 'IND' MODE IN MSG
         LA    R0,L'QSESID+4(,R1)  SET END OF MESSAGE
         LA    R1,COMMAND          PT OT BEGINNING OF MESSAGE
         SLR   R0,R1               COMPUTE MESSAGE LENGTH
         B     CDQRES              AND REPLY TO OPERATOR
         EJECT
         SPACE 1
*        REQUEST FOR 'PPU' QUEUE
CDQPPU   DS    0H                  SCAN JOBS IN HARDCPY QUEUE
         B     CDQPPUE             DISPLAY AT END OF JOBS
         CLI   JQETYPE,$HARDCPY    JOB IN HARDCPY...           @OZ29819
         BE    CDQCOMMN            BR IF YES                   @OZ29819
         TM    JQEFLAGS,QUEBUSY    JOB BUSY IN OUTPUT...       @OZ29819
         BZ    CDQNXT              BR IF NO TO GET NEXT JOB    @OZ29819
         B     CDQCOMMN             ELSE TREAT AS IN HARDCPY   @OZ29819
                                   PRINT OFF - SECTION DELETED @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
                                   PRINT ON -- SECTION DELETED @OZ29819
         SPACE 2
*        REQUEST FOR 'OUT' QUEUE
CDQOUT   DS    0H                  CHECK FOR JOBS AWAITING OUTPUT
         B     CDQOUTE             DISPALY AT END OF JOBS
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
         BAL   R14,CDQCKSID        TEST FOR CORRECT SID
         TM    JQEFLAGS,QUEBUSY    TEST FOR ACTIVE
         BNZ   CDQNXT              YES--GET NEXT ELEMENT
         SPACE 1                                               @OZ29819
CDQCOMMN DS    0H
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
         CLC   JQEPRTRT,JQEPUNRT   FIND LOWER ROUTE CODE
         BH    CDQPUNL             CHECK PUNCH TOO LOW IF LOWER
* PRINT ROUTE IS LOW ( OR EQUAL )
         CLC   JQEPRTRT,CDQSLO     IS IT LOWER THAN CURRENT LOW
         BL    CDQPUNC             IT DEPENDS ON PUNCH IF LOW
         BER   WC                  ENTER $DN OR $DQ IF HIT     @OZ29819
CDQPRT   CH    WB,JQEPRTRT         IS IT HIGHER THAN HIGH BOUND
         BL    CDQNXT              LOOP IF YES
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
         LH    WB,JQEPRTRT         SET NEW HIGH BOUND
         B     CDQHIT              FORCE QUEUE RE-SCAN         @OZ29819
CDQPUNC  CLC   JQEPUNRT,CDQSLO     IS PUNCH LOW ALSO
         BL    CDQNXT              LOOP IF YES
         BER   WC                  ENTER $DN OR $DQ IF HIT     @OZ29819
         B     CDQPUN              TEST AGAINST UPPER BOUND
* PUNCH ROUTE IS LOW
CDQPUNL  CLC   JQEPUNRT,CDQSLO     IS IT LOWER THAN CURRENT LOW
         BL    CDQPRTC             IT DEPENDS ON PRINT IF LOW
         BER   WC                  ENTER $DN OR $DQ IF HIT     @OZ29819
CDQPUN   CH    WB,JQEPUNRT         IS IT HIGHER THAN HIGH BOUND
         BL    CDQNXT              LOOP IF YES
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
         LH    WB,JQEPUNRT         SET NEW HIGH BOUND
         B     CDQHIT              FORCE QUEUE RE-SCAN         @OZ29819
CDQPRTC  CLC   JQEPRTRT,CDQSLO     IS PRINT LOW ALSO
         BL    CDQNXT              LOOP IF YES
         BER   WC                  ENTER $DN OR $DQ IF HIT     @OZ29819
         B     CDQPRT              TEST AGAINST UPPER BOUND
         SPACE 1                                               @OZ29819
CDQHIT   DS    0H                  ANOTHER PASS REQUIRED       @OZ29819
         OI    CDNFLAG,CDNRSCAN    FORCE CURRENT QUEUE RE-SCAN @OZ29819
         B     CDQNXT              BR TO GET NEXT JOB          @OZ29819
         SPACE 1
CDQPPUE  DS    0H                  DISPLAY QUEUED FOR PRT/PUN
         MVC   COMMAND+5(3),=C'PPU' SET IDENTIFIER                   R4
         LA    R15,CDQSLO          POINT TO ROUTE FIELD              R4
         LA    R0,COMMAND+8        POINT TO RECEIVE AREA             R4
         BAL   LINK,COFRTC         CONVERT TO PRINTABLE              R4
         MVC   COMMAND+8+10(3),=CL4'ANY' SET ANY                     R4
         LA    R0,COMMAND+18+3-COMMAND SET LENGTH                    R4
         B     CDQRES              AND REPLY TO OPERATOR
         SPACE 2
CDQOUTE  DS    0H                  DISPLAY QUEUED FOR OUTPUT
         MVC   COMMAND+5(4),=CL4'OUT' SET MESSAGE
         BAL   WA,CDQSIDNM         PICK-UP SYSTEM NAME
         MVC   COMMAND+9(L'QSESID),0(R15) SET SYSTEM NAME IN MSG
         LA    R0,COMMAND+9+L'QSESID-COMMAND SET MESSAGE LENGTH
         TM    CDNFLAG,CDNIND      TEST FOR 'IND' REQUEST
         BZ    CDQRES              NO--REPLY TO OPERATOR
         MVC   COMMAND+9+L'QSESID(4),=C' IND' SET 'IND' MODE IN MSG
         LA    R0,COMMAND+13+L'QSESID-COMMAND SET MESSAGE LENGTH
         B     CDQRES              AND REPLY TO OPERATOR
         EJECT
* REQUEST FOR 'HOLD' QUEUE
         SPACE 1
CDQHLD   B     CDQHLDE             ENTER $DQ MESSAGE PREPARATION
         TM    JQEFLAGS,QUEHOLDA+QUEHOLD1+QUEHOLD2 ANY HOLD
         BZ    CDQNXT              LOOP
         TM    JQEFLAGS,QUEBUSY    TEST FOR BUSY
         BNZ   CDQNXT              YES--GET NEXT JOB
         BAL   R14,CDQCKSID        CHECK FOR PROPER AFFINITY
         BAL   R14,CDQCKRTE        CHECK ROUTE CODES
         BR    WC                  GO TO FUNCTION ROUTINE
         SPACE 1
CDQHLDE  DS    0H                  DISPLAY HOLD COUNT
         MVC   COMMAND+5(5),=CL5'HOLD' SET QUEUE TYPE IN MSG
         BAL   WA,CDQSIDNM         PICK-UP SYSTEM NAME
         MVC   COMMAND+10(L'QSESID),0(R15) SET NAME IN MSG
         LA    R0,COMMAND+10+L'QSESID-COMMAND COMPUTE MSG LENGTH
         TM    CDNFLAG,CDNIND      TEST FOR 'IND' REQUEST
         BZ    *+14                BR IF NO                    @OZ29819
         MVC   COMMAND+10+L'QSESID(4),=C' IND' SET MESSAGE
         LA    R0,COMMAND+14+L'QSESID-COMMAND SET MSG LENGTH
        $CWTO  L=(R0)              ISSUE REPLY TO OPERATOR     @OZ29819
         B     CDQSIDN             BR TO TEST FOR END OF SCAN  @OZ29819
         SPACE 1
* END OF QUEUE SCAN
         SPACE 1
CDQEND   B     *+4                 DUMMY MESSAGE PREPARATION
         L     R15,$SSVT           POINT TO SSVT
         L     R1,$SVTGALC-SSVT(,R15) GET TRACK GROUPS ALLOCATED
         M     R0,=F'100'          ALLOW FOR PERCENTAGE
         D     R0,$SVTGTOT-SSVT(,R15) DIVIDE BY TOTAL
         $CFCVE VALUE=(R1)         CONVERT TO PRINTABLE
         MVC   COMMAND(3),COMDWORK+2 PLACE IN MESSAGE AREA
         MVC   COMMAND+3(26),=C' PERCENT SPOOL UTILIZATION'
         $CRET L=29                RETURN WITH LAST MESSAGE
         SPACE 1
* ROUTE CODE RANGE CHECK ROUTINE
         SPACE 1
CDQCKRTE CLC   JQEPRTRT,CDQRBNDL   CHECK PRINT AGAINST LOW BOUND
         BL    CDQCKRTU            TRY PUNCH IF PRINT TOO LOW
         CLC   JQEPRTRT,CDQRBNDH   CHECK PRINT AGAINST HIGH BOUND
         BNHR  R14                 RETURN IF OK
CDQCKRTU CLC   JQEPUNRT,CDQRBNDL   CHECK AGAINST LOW BOUND
         BL    CDQNXT              LOOP
         CLC   JQEPUNRT,CDQRBNDH   CHECK PUNCH AGAINST HIGH BOUND
         BNHR  R14                 RETURN IF 'OK'
         B     CDQNXT              ELSE GET NEXT JQE ELEMENT
         SPACE 1
*        CHECK FOR AFFINITY IN DESIRED RANGE
CDQCKSID DS    0H                  CHECK FOR SID MATCH
         IC    R15,JQEFLAG2        GET SID AFFINITY FLAGS
         TM    CDQSIDLO,QUESYSAF   TEST FOR ANY REQUEST
         BNO   CDQSIDS             NO--LOOK FOR SPECIFIC OR 'ALL'
         CLM   R15,1,CDQSIDLO      TEST FOR 'ANY' AFFINITY
         BNE   CDQNXT              NO--RETURN TO GET NEXT JOB
         BR    R14                 YES--RETURN OK
CDQSIDS  DS    0H                  CHECK FOR SPECIFIC SID OR 'ALL'
         IC    R15,CDQSIDLO        GET CURRENT AFFINITY
         EX    R15,CDNQTEST        TEST FOR JOB WITH SAME
         BNO   CDQNXT              NO GET NEXT JOB
         BR    R14                 YES--RETURN OK
         SPACE 1
*        COMPUTE SID NAME OFFSET FOR MESSAGE
CDQSIDNM DS    0H                  PICK-UP AFFINITY OF JOBS
         TM    CDQSIDLO,QUESYSAF   TEST FOR 'ANY' REQUEST
         BNO   CDQSPECA            NO--GET SPECIFIC AFFINITY
         LA    R15,=CL4'ANY'       SET ADDRESS OF 'ANY' AFF
         BR    WA                  AND RETURN
CDQSPECA DS    0H                  REQUEST IS FOR SPECIFIC AFF
         SLR   R15,R15             ZERO INSERT REGISTER
         LR    R14,R15             ZERO COUNT REGISTER
         IC    R15,CDQSIDLO        PICK-UP AFFINITY BIT
         N     R15,=A(127)         TURN 'OFF'POSSIBLE 'IND' BIT
         LA    R14,1(,R14)         COUNT ONE FOR EACH AFF BIT
         SRA   R15,1               SHIFT OUT ONE BIT
         BNZ   *-8                 AND COUNT FOR EACH BIT MOVED OUT
         L     R15,$QSE1           POINT TO 1ST QSE                  R4
         BCTR  R14,0               LESS ONE FOR DISPLACEMENT
         MH    R14,$QSEL           TIMES ELEMENT SIZE                R4
         ALR   R14,R15             PLUS BEG ADDR EQUALS ELEMENT ADDR
         USING QSEDSECT,R14        QSE ADDRESSABILITY
         LA    R15,QSESID          POINT TO SYSTEM NAME FOR AFFINITY
         BR    WA                  AND RETURN
         DROP  R14                 DROP QSE ADDRESSABILITY
         EJECT
***********************************************************************
*                                                                     *
*        $D N ITEM PROCESSING                                         *
*                                                                     *
***********************************************************************
CDNCTR   DS    0H                  CHECK FOR $DN DISPLAY
         CLC   CDQSEE(L'CDQPPUD),CDQPPUD  THIS PPU SEARCH ELEMENT   R41
         BE    CDNOTALL            YES--SKIP TESTS                  R41
         TM    CDNFLAG,CDNALL      TEST FOR 'ALL' REQUEST
         BZ    CDNOTALL            NO -- SKIP TESTS
         SLR   R15,R15             ZERO INSERT REGISTER
         IC    R15,CDQSIDLO        PICK-UP CURRENT AFFINITY BIT
         N     R15,=A(127)         TURN 'OFF' POSSIBL 'IND' BIT
         EX    R15,CDNQTEST        TST FOR JOB OF DESIRED AFFN
         BZ    CDQNXT              NO--GET NEXT JOB
         BCTR  R15,0               HAS THE JOB BEEN
         EX    R15,CDNQTEST        PREVIOUSLY DISPLAYED
         BNZ   CDQNXT              IF SO --GET NEXT JOB
CDNOTALL DS    0H                  COME HERE FOR NOT 'ALL ' REQ
         LR    WD,R1               SAVE JQE ADDR FOR NEXT JOB SCAN
         $CFJMSG OPT=COFQ          DISPLAY QUEUED JOBS
         NOP   *-*                 SPACER TO PREVENT FUTURE ERROR
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
* EACH $CWTO MAY ISSUE A $WAIT THUS GIVING OTHER PROCESSORS A CHANCE
* TO ALTER THE JOB QUEUE CHAIN FOR THE CURRENT ENTRY
         ICM   R1,7,CDQTYPLO       GET ADDRESS OF QUEUE TYPE   @OZ29819
         SLR   R15,R15             CLEAR FOR INSERT            @OZ29819
         IC    R15,0(,R1)          GET QUEUE TYPE              @OZ29819
        $CFJSCAN PROCESS=CDNPRO,NEXT=CDNNXT,QUEUE=(R15)        @OZ29819
         MVC   COMMAND(15),=C'LIST INCOMPLETE' SET MSG
         LA    R0,15               SET LENGTH
         B     CDQRES              RESPOND
CDNPRO   CR    R1,WD               DO THE POINTERS MATCH
         BNE   CDNNXT              NEXT ELEMENT UNTIL END OR MATCH
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
         B     CDQNXT              NEXT ELEMENT ( CHAIN OK )
CDNQTEST TM    JQEFLAG2,*-*        **** EXECUTE ONLY ****
         EJECT
***********************************************************************
*                                                                     *
*        $D Q ITEM PROCESSING                                         *
*                                                                     *
***********************************************************************
CDQCTR   CH    WF,CDQHLDD          'Q=HOLD' SPECIFIED...       @OZ29819
         BE    CDQCTHLD            BR IF YES                   @OZ29819
         LA    WE,1(,WE)           INCREMENT COUNTER           @OZ29819
         TM    CDNFLAG,CDNTYPE     'Q=' SPECIFIED...           @OZ29819
         BO    CDQNXT              BR IF YES                   @OZ29819
         TM    JQEFLAGS,QUEHOLDA+QUEHOLD1+QUEHOLD2  JOB HELD...@OZ29819
         BZ    CDQNXT              BR IF NO                    @OZ29819
         TM    JQEFLAGS,QUEBUSY    JOB ACTIVE...               @OZ29819
         BNZ   CDQNXT              BR IF YES                   @OZ29819
         BAL   R14,CDQCKRTE        CHECK ROUTE CODES           @OZ29819
         BAL   R14,CDQCKSID        CHECK AFFINITY              @OZ29819
CDQCTHLD LA    R10,1(,R10)         OK -- BUMP HOLD COUNT       @OZ29819
         B     CDQNXT              GO TO NEXT ENTRY
         EJECT
CDQS     EQU   *
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
CDQXEQD  DC    AL2(CDQXEQ-CDQB),AL3(CDQTYPEC,CDQTYPE9)         @OZ29819
CDQOUTD  DC    AL2(CDQOUT-CDQB),AL3(CDQTYPEO,CDQTYPEO)         @OZ29819
CDQPPUD  DC    AL2(CDQPPU-CDQB),AL3(CDQTYPEO,CDQTYPEP)         @OZ29819
CDQENDD  DC    AL2(CDQEND-CDQB)                                @OZ29819
CDQSL    EQU   *-CDQS                                          @OZ29819
CDQHLDD  DC    AL2(CDQHLD-CDQB),AL3(CDQQTYPS,CDQTYPE9)         @OZ29819
CDQRALLD DC    AL2(1*256+$MAXRJE,0)  DEFAULT ROUTE RANGE       @OZ29819
         SPACE 1                                               @OZ29819
CDQQTYPS EQU   *                   VALID JOB QUEUE TYPES       @OZ29819
CDQTYPEO DC      AL1($OUTPUT)                                  @OZ29819
CDQTYPEP DC      AL1($HARDCPY)                                 @OZ29819
CDQTYPER DC      AL1($RECEIVE)                                 @OZ29819
CDQTYPET DC      AL1($SETUP)                                   @OZ29819
CDQTYPEX DC      AL1($XMIT)                                    @OZ29819
CDQTYPEI DC      AL1($INPUT)                                   @OZ29819
CDQTYPEC DC      AL1($XEQ)                                     @OZ29819
CDQTYPE$ DC      AL1(CATSTCCL-X'80')                           @OZ29819
CDQTYPE@ DC      AL1(CATTSUCL-X'80')                           @OZ29819
CDQTYPEA DC     9AL1(C'A'-X'80'+*-CDQTYPEA)                    @OZ29819
CDQTYPEJ DC     9AL1(C'J'-X'80'+*-CDQTYPEJ)                    @OZ29819
CDQTYPES DC     8AL1(C'S'-X'80'+*-CDQTYPES)                    @OZ29819
CDQTYPE0 DC    10AL1(C'0'-X'80'+*-CDQTYPE0)                    @OZ29819
CDQTYPE9 EQU   *-1                                             @OZ29819
         SPACE 1                                               @OZ29819
CDQSHI   EQU   COMREGSV,2          SCAN HIGH VALUE             @OZ29819
CDQSLO   EQU   COMREGSV+2,2        SCAN LOW VALUE              @OZ29819
CDQDEFR  EQU   CDQSLO+L'CDQSLO,4   ROUTE CODE RANGE            @OZ29819
CDQRBNDH EQU   CDQDEFR,2           HIGH BOUND                        R4
CDQRBNDL EQU   CDQDEFR+2,2         LOW BOUND                         R4
CDQSIDLO EQU   CDQDEFR+4,1         SID LOW VALUE                     R4
CDQSIDHI EQU   CDQDEFR+5,1         SID HIGH VALUE                    R4
CDQSE    EQU   CDQDEFR+6,CDQSL     AREA FOR SCAN ELEMENTS            R4
CDQSEE   EQU   CDQSE,8             FIRST SCAN ELEMENT          @OZ29819
CDQTYPLO EQU   CDQSEE+2,3          FIRST QUEUE                 @OZ29819
CDQTYPHI EQU   CDQSEE+5,3          LAST QUEUE                  @OZ29819
CDQSECDD EQU   CDQSEE+L'CDQSEE,L'CDQSEE  SECOND SCAN ELEMENT   @OZ29819
                                   PRINT OFF - SECTION DELETED @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
                                   PRINT ON -- SECTION DELETED @OZ29819
CDQTSKID DC    AL1(CATSTCID),CL5' STC' MESSAGE FOR SYSTEM TASK
CDQLOGID DC    AL1(CATTSUID),CL5' TSU' MESSAGE FOR TIME SHARING USER
CDQSESAV EQU   CDQSE+CDQSL,CDQSL   SAVE AREA FOR $DN,Q ELEMENTS
CDNFLAG  EQU   CDQSESAV+CDQSL,1    $DN FLAG BYTE                     R4
CDNALL   EQU   X'01'               FLAG FOR 'ALL' REQUEST
CDNIND   EQU   X'02'               FLAG FOR 'IND' REQUEST
CDNROUT  EQU   X'04'               FLAG FOR ROUTE RANGE              R4
CDNTYPE  EQU   X'08'               FLAG FOR QUEUE TYPE               R4
CDNFLGN  EQU   X'20'               $DN SPECIFIED               @OZ29819
CDNRSCAN EQU   X'10'               RE-SCAN CURRENT QUEUE       @OZ29819
CDQB     EQU   HASPCJB1            BASE FOR SUB-COMMAND OFFSETS
CDQQSEAF DC    X'0001020408102040' QSE AFFINITIES                    R4
         EJECT                                                 @OZ29819
         LTORG ,                                               @OZ29819
         TITLE 'HASP COMMAND PROCESSOR HASPCJ1A - JOB QUEUE COMMANDS (CC
               ONTINUED)'                                      @OZ29819
HASPCJ1A $COMGRUP DF,OQ,PQ         MORE JOB QUEUE COMMANDS     @OZ29819
         SPACE 1                                               @OZ29819
***********************************************************************
*                                                                     *
*        $D F,D=H/A,JOB=JN-NN,R=DEST1-DEST2                           *
*                ( NO H OR A = RELEASED JOBS ONLY )                   *
*                                                                     *
***********************************************************************
CDF      DS    0H                                                    R4
         BAL   LINK,COFRTD         SET DEFAULT ROUTE RANGES          R4
         LR    WA,R1               SAVE LOW BOUND ONLY               R4
         MVI   COMPNTER,CDFRELJ    DISPLAY ONLY NON-HELD JOBS        R4
         LR    WB,WA               COPY ROUTING
         SR    WC,WC               SET DEFAULT LOW JOB NUMBER
         LH    R10,=H'32767'       SET DEFAULT HIGH
CDFNSPEC BXH   WD,WE,CDFOK         IF NO MORE EXIT
         L     R1,0(,WD)           POINT TO OPERAND                  R4
         CLI   1(R1),C'='          THIS EQUAL                        R4
         BNE   CDFINVO             ERROR IF NOT                      R4
         $CFSEL (D,CDFHA),(J,CDFJ),(R,CDFR) SELECT OPERAND ROUTINE   R4
         B     CDFINVO             ERROR EXIT                        R4
CDFHA    CLI   2(R1),C'A'          THIS DISPLAY ALL                  R4
         BE    CDFSETA             SET ALL IF YES                    R4
         CLI   2(R1),C'H'          THIS DISPLAY HELD ONLY            R4
         BE    CDFSETH             SET HELD ONLY IF YES              R4
         B     CDFINVO             ERROR EXIT                        R4
CDFJ     $CFCVB POINTER=(WD),NOK=CDFINVO,NUM=2                       R4
         LTR   R1,R1               JOB ZERO                          R4
         BZ    CDFINVO             ERROR IF YES                      R4
         L     R15,0(,WD)          POINT TO OPERAND                  R4
         CLI   2(R15),C'J'         IS THIS JOB                       R4
         BE    CDFSETJ             SET JOB IF YES                    R4
         CLI   2(R15),C'S'         IS IT STC                         R4
         BE    CDFSETS             SET STC IF YES                    R4
         CLI   2(R15),C'T'         IS IT TSU                         R4
         BE    CDFSETT             SET TSU IF YES                    R4
         B     CDFINVO             ERROR EXIT                        R4
CDFR     BAL   LINK,COFRTRA        CONVERT DESTINATION RANGE         R4
         B     CDFINVO             ERROR                    + 0      R4
         LR    WA,R0               SAVE ROUTE               + 4      R4
         LR    WB,R1                LIMITS
         B     CDFNSPEC            LOOP TO NEXT SPECIFICATION
CDFSETT  AH    R1,=H'10000'        UP BASE FOR TSU
         AH    R0,=H'10000'        UP BASE
CDFSETS  AH    R1,=H'10000'        UP BASE FOR TSU OR STC
         AH    R0,=H'10000'        UP BASE
CDFSETJ  LR    WC,R1               SAVE JOB
         LR    R10,R0               LIMITS
         B     CDFNSPEC            GET NEXT SPECIFICATION
CDFSETH  MVI   COMPNTER,CDFHOLD    SET HOLD FLAG TEMPORILY
         B     CDFNSPEC            GET NEXT SPECIFICATION
CDFSETA  MVI   COMPNTER,CDFRELJ+CDFHOLD SET TO DISPLAY ALL JOBS
         B     CDFNSPEC            GET NEXT SPECIFICATION
         EJECT
***********************************************************************
*                                                                     *
*        PREPARE TO SCAN JOES FOR EACH ROUTE CODE                     *
*                                                                     *
***********************************************************************
         USING JOTDSECT,WF
         USING JOEDSECT,R1
CDFOK    STH   WC,CDFLJOB          SET LOW JOB
         STH   R10,CDFHJOB         SET HIGH JOB
         STH   WA,CDFEROUT         SAVE END ROUTE
         STH   WB,CDFCROUT         SAVE STARTING ROUTE
         LA    WD,COMMAND+70-5     POINT TO LAST OUTPUT ELEMENT
         ICM   WD,8,COMPNTER       PICK UP JOB TYPE FLAGS
         ST    WD,CDFCOMPR-1+CDFFLAGS-CDFFLAGS SET PTR AND FLAGS
         L     WF,CDFJOT           POINT TO JOT
*                                    THIS LINE DELETED BY APAR @OZ20010
*                                    THIS LINE DELETED BY APAR @OZ20010
*                                    THIS LINE DELETED BY APAR @OZ20010
         EJECT
***********************************************************************
*                                                                     *
*        GET JOE AND PREPARE TO SCAN                                  *
*                                                                     *
***********************************************************************
CDFNROUT LA    R1,JOTCHRQ-(JOENEXT-JOEDSECT) QUEUE HEAD
         LH    R1,JOENEXT          POINT TO NEXT JOE OFFSET
         N     R1,=A(X'0000FFFF')  INSURE OFFSET IS POSITIVE
         BZ    CDFNOJOP            LAST JOE -- EXIT
         SLL   R1,2                EXPAND TO BYTE OFFSET             R4
         ALR   R1,WF               COMPUTE ACTUAL JOE ADDRESS
         MVC   CDFNXTLO,CDFEROUT   SET NEXT LOW ROUTE CODE     @OZ29819
CDFMVCHR MVC   CDFCHAR,JOEFORM     MOVE CHARACTERISTICS
         LA    R0,CDFMR1           POINT TO OUTPUT ROUTING           R4
         LA    R15,CDFCROUT        POINT TO CURRENT ROUTING          R4
         BAL   LINK,COFRTC         CONVERT TO PRINTABLE              R4
         MVC   CDFMID,=C'OUT R='   SET MESSAGE HEADER                R4
         MVC   CDFMB,=C'F=XXXX C=XXXX T=XXXX W= (NONE) '  BASE MSG   R4
         MVC   CDFMBF,CDFORMS      SET FORMS                         R4
         MVC   CDFMBC,CDFFCB       SET CARRIAGE                      R4
         MVC   CDFMBT,CDFUCS       SET TRAIN                         R4
         CLI   CDFWTR,C' '         WRITER BLANK                      R4
         BE    SKIP120             SKIP NEXT                         R4
         MVC   CDFMBW,CDFWTR       SET WRITER NAME                   R4
SKIP120  LA    WD,CDFMB+L'CDFMB    POINT TO NEXT MSG AREA            R4
         CLC   CDFLASH,=C'****'    TEST FOR FLASH SPECIFIED          R4
         BE    CDFTBRST            BR IF NOT                         R4
         MVC   0(3,WD),=C' O='     SET FLASH PREFIX                  R4
         MVC   3(L'CDFLASH,WD),CDFLASH  SET FLASH FRAME ID           R4
         LA    WD,3+L'CDFLASH(,WD) POINT TO NEXT MSG AREA            R4
CDFTBRST TM    CDFCFLAG,$JOEBRST   TEST FOR BURST=YES                R4
         BZ    SKIP130             BR IF NOT                         R4
         MVC   0(4,WD),=C' B=Y'    SET BURST=YES IN MSG              R4
         LA    WD,4(,WD)           POINT TO NEXT MSG AREA            R4
SKIP130  MVC   0(7,WD),=C' CLASS ' SET CLASS PREFIX                  R4
         LA    WD,7(,WD)           POINT TO FIRST CLASS AREA         R4
         EJECT
***********************************************************************
*                                                                     *
*        SCAN CLASS QUEUES                                            *
*                                                                     *
***********************************************************************
         SR    WB,WB               SET FOR CLASS A
         B     CDFACLS             PROCESS CLASS
CDFNCLS  LA    WB,2(0,WB)          UP TO NEXT CLASS
         CH    WB,=H'70'           CHECK FOR MAX NBR CLASSES
         BH    CDFEJOE             EXIT FOR THIS CHARACTERISTIC
CDFACLS  MVC   1(4,WD),=C'=**,'    SET PATTERN FOR CLASS
***********************************************************************
*                                                                     *
*        PASS THROUGH JOES FOR A CLASS                                *
*                                                                     *
***********************************************************************
         SR    R0,R0               SET COUNT
         LA    R1,JOTCLSQ-(JOENEXT-JOEDSECT)(WB) POINT TO QUEUE
CDFNXTJO DS    0H                  GET ANOTHER JOE OF THE SAME CLS
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
         LH    R1,JOENEXT          GET NEXT JOE OFFSET
         N     R1,=A(X'0000FFFF')  INSURE OFFSET IS POSITIVE
         BZ    CDFECLS             END--TRY NEXT CLASS
         SLL   R1,2                EXPAND TO BYTE OFFSET             R4
         ALR   R1,WF               COMPUTE ACTUAL JOE ADDRESS
         TM    JOEFLAG,$JOEBUSY    TEST FOR JOE BUSY
         BNZ   CDFNXTJO            IF BUSY FORGET IT
         LH    R14,JOEJQE          PICK-UP JQE OFFSET
         SLL   R14,2               COMPUTE ACTAUAL JQE OFFSET ( * 4)
         AL    R14,$JOBQPTR        COMPUTE JQE ADDRESS
         TM    QUEFLAGS(R14),QUEHOLDA+QUEHOLD1 JOB HELD
         BZ    CDFJBNH             IF NOT TEST FOR DESIRES
         TM    CDFFLAGS,CDFHOLD    DOES USER WANT HOLD
         BZ    CDFNXTJO            IF NOT FORGET IT
         B     CDFCKR              CHECK RANGE
CDFJBNH  TM    CDFFLAGS,CDFRELJ    DOES USER WANT NON HELD
         BZ    CDFNXTJO            IF NOT FORGET IT
CDFCKR   CLC   QUEJOBNO(2,R14),CDFLJOB TEST FOR WITHIN RANGE
         BL    CDFNXTJO            IF LOW FORGET IT
         CLC   QUEJOBNO(2,R14),CDFHJOB TEST FOR WITHIN RANGE
         BH    CDFNXTJO            IF HIGH FORGET IT
         LH    R15,JOEROUT         GET THE ROUTE CODE          @OZ29819
         LTR   R15,R15             INDIRECT ROUTE...           @OZ29819
         BNZ   CDFNRTE             IF NO, DO NORMAL ROUTE      @OZ29819
         ST    R1,COMWREGS         SAVE JOE POINTER
         BAL   WA,CDFCNVT          CONVERT JOE DISP TO EBCDIC CLS
         L     R15,$SSVT           POINT TO THE SSVT
         LA    R15,$SVSCAT-SSVT(,R15)  GET ADDRESS OF SCAT
         ALR   R15,R1              COMPUTE THIS CLS LOCATION
         L     R1,COMWREGS         RESTORE JOE POINTER
         TM    SCATFLAG-SCADSECT(R15),SCATPRNT TEST FOR NORM PRT
         BO    CDFPRTRT            YES--LOOK AT JQE PRT RTE
         TM    SCATFLAG-SCADSECT(R15),SCATPNCH TEST FOR NORM PNCH
         BZ    CDFNXTJO            NO -- SKIP FURTHER TESTS
         LH    R15,QUEPUNRT(,R14)  GET PUNCH ROUTE CODE        @OZ29819
         B     CDFNRTE             BR TO TEST ROUTE CODE       @OZ29819
         SPACE 1                                               @OZ29819
CDFPRTRT LH    R15,QUEPRTRT(,R14)  GET PRINT ROUTE CODE        @OZ29819
         SPACE 1                                               @OZ29819
CDFNRTE  CH    R15,CDFCROUT        CHECK AGAINST CURRENT RTE CD@OZ29819
         BL    CDFNXTJO            BR IF TOO LOW               @OZ29819
         CH    R15,CDFNXTLO        CHECK AGAINST NEXT LOW      @OZ29819
         BH    CDFNXTJO            BR IF HIGHER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
         LH    R14,JOECHAR         GET CHARACTERISTIC JOE OFFSET
         N     R14,=A(X'0000FFFF') INSURE POSITIVE OFFSET
         SLL   R14,2               EXPAND TO BYTE OFFSET             R4
         ALR   R14,WF              POINT TO CHARACTERISTIC JOE
         CLC   CDFCHAR,JOEFORM-JOEDSECT(R14) CHECK FOR MATCH
         BNE   CDFNXTJO            IF NOT FORGET IT
         CH    R15,CDFCROUT        THIS AN EXACT HIT...        @OZ29819
         BE    CDFINCR             BR IF YES                   @OZ29819
         STH   R15,CDFNXTLO        SET NEW NEXT LOW            @OZ29819
         OI    CDFFLAGS,CDFRSCAN   INDICATE RE-SCAN REQUIRED   @OZ29819
         B     CDFNXTJO            BR TO TEST NEXT JOE         @OZ29819
CDFINCR  LA    R15,1               SET INCREMENT               @OZ29819
         AR    R0,R15              UP 1
         CH    R0,=H'100'          CHECK FOR OVERFLOW
         BL    CDFNXTJO            LOOP
         CLC   CDFCROUT,CDFEROUT   MORE ROUTE CODES TO TEST... @OZ29819
         BL    CDFNXTJO            BR IF YES                   @OZ29819
         EJECT
***********************************************************************
*                                                                     *
*        PUT COUNT IN RESPONSE COUNT FIELD                            *
*                                                                     *
***********************************************************************
CDFECLS  LTR   R0,R0               IS THIS ZERO
         BZ    CDFNCLS             IF ZERO DO NEXT CLASS
         CH    R0,=H'100'          TEST HIT COUNT              @OZ29819
         BNL   CDFOVF              BR IF EXCEEDS 99            @OZ29819
         $CFCVE  VALUE=(R0)        CONVERT TO EBCDIC
         MVC   2(2,WD),COMDWORK+3  INSERT COUNT
CDFOVF   BAL   WA,CDFCNVT          CONVERT JOE DISPL TO CLS CHAR
         STC   R1,0(0,WD)          STORE RESULT
         LA    WD,5(0,WD)          UP TO NEXT
         OI    CDFFLAGS,CDFJOEOK+CDFSOMJO SET FLAGS
         CLM   WD,7,CDFCOMPR       CHECK FOR OUTPUT REQUIRED
         BNH   CDFNCLS             IF NOT GO TO NEXT CLASS
         BAL   WC,CDFPRNT          DISPLAY MESSAGE
         MVC   CDFMCCL,=C'CLASS '  SET CONTINUATION CLASS            R4
         LA    WD,CDFMCC           POINT TO CONTINUATION CLASS ELEMT R4
         B     CDFNCLS             NEXT CLASS
***********************************************************************
*                                                                     *
*        END OF SCAN FOR A GIVEN CHARACTERISTIC                       *
*                                                                     *
***********************************************************************
CDFEJOE  TM    CDFFLAGS,CDFSOMJO   IS THERE SOMETHING TO PRINT
         BZ    CDFEJOA             IF NOT FORGET IT
         BAL   WC,CDFPRNT          DISPLAY MESSAGE
CDFEJOA  LA    R1,JOTCHRQ-(JOENEXT-JOEDSECT) QUEUE HEAD
CDFEJOB  LH    R1,JOENEXT          GET NEXT JOE OFFSET
         N     R1,=A(X'0000FFFF')  INSURE OFFSET IS POSITIVE
         BZ    CDFNOJO             LAST--EXIT
         SLL   R1,2                EXPAND TO BYTE OFFSET             R4
         ALR   R1,WF               COMPUTE JOE ADDRESS
         CLC   CDFCHAR,JOEFORM     CHECK FOR ONE WE WANT
         BNL   CDFEJOB             IF NOT LOOP
         B     CDFMVCHR            IF SO COPY CHARACTERISTICS
         EJECT
***********************************************************************
*                                                                     *
*        END OF PASS THROUGH ALL JOES                                 *
*                                                                     *
***********************************************************************
CDFNOJO  TM    CDFFLAGS,CDFRSCAN   QUEUE RE-SCAN REQUIRED...   @OZ29819
         BZ    CDFNOJOP            BR IF NO                    @OZ29819
         NI    CDFFLAGS,255-CDFRSCAN  RESET RE-SCAN INDICATOR  @OZ29819
         MVC   CDFCROUT,CDFNXTLO   SET NEW CURRENT ROUTE CODE  @OZ29819
         B     CDFNROUT            BR TO RE-SCAN QUEUE         @OZ29819
CDFNOJOP TM    CDFFLAGS,CDFJOEOK   DID WE FIND ANY
         BZ    CDFEMPTY            EXIT WITH DIAGNOSTIC IF NO
         $CRET ,                   RETURN
CDFEMPTY $CRET MSG='NO OUTPUT QUEUED'   RETURN WITH DIAGNOSTIC
***********************************************************************
*                                                                     *
*        DISPLAY A LINE                                               *
*                                                                     *
***********************************************************************
CDFPRNT  DS    0H
         LR    R0,WD               POINT TO END + 2
         LA    R1,COMMAND+1        START + 1
         SR    R0,R1               GET COUNT
         $CWTO L=(R0)              DISPLAY MESSAGE
         NI    CDFFLAGS,255-CDFSOMJO TURN OFF FLUSH BIT
*                                    THIS LINE DELETED BY APAR @OZ20010
*                                    THIS LINE DELETED BY APAR @OZ20010
*                                    THIS LINE DELETED BY APAR @OZ20010
         BR    WC                  RETURN
         EJECT
***********************************************************************
*                                                                     *
*        MISCELLANEOUS                                                *
*                                                                     *
***********************************************************************
CDFINVO  L     R1,0(0,WD)          POINT TO INVALID OPERAND
         $CFINVO OPERAND=(R1)      EXIT ...
CDFCNVT  DS    0H                  CONVERT JOE DISP TO CLS CHAR
         LR    R1,WB               MOVE JOE CLASS TO WORK REGISTER
         SRA   R1,1                DIVIDE BY TWO
         L     R15,=A(CLJHLDTB)    POINT TO CONVERSION TABLE
         IC    R1,0(R1,R15)        PICK-UP CLASS IN R1
         BR    WA                  AND RETURN
CDFCHAR  EQU   COMPNTER,25         ALL CHARACTERISTICS               R4
CDFORMS  EQU   COMPNTER,4          FORMS CHARACTERISTICS
CDFFCB   EQU   COMPNTER+4,4        FCB CHARACTERISTICS
CDFUCS   EQU   COMPNTER+8,4        UCS CHARACTERISTICS
CDFWTR   EQU   COMPNTER+12,8       WTR CHARACTERISTICS
CDFLASH  EQU   COMPNTER+20,4       FLASH CHARACTERISTICS             R4
CDFCFLAG EQU   COMPNTER+24,1       CHARACTERISTICS FLAGS (JOECFLAG)  R4
CDFNXTLO EQU   COMNULOP-10,2       NEXT ROUTE CODE TO SCAN     @OZ29819
CDFLJOB  EQU   COMNULOP-8          LOW JOB NUMBER OF RANGE
CDFHJOB  EQU   COMNULOP-6          HIGH JOB NUMBER OF RANGE
CDFFLAGS EQU   COMNULOP-4          FLAGS
CDFJOEOK EQU   X'80'               AT LEAST ONE JOE HAD INFO
CDFSOMJO EQU   X'40'               THIS JOE HAS SOME TO DISPLAY
CDFRELJ  EQU   X'20'               DISPLAY RELEASED JOBS
CDFHOLD  EQU   X'10'               DISPLAY HELD JOBS
CDFRSCAN EQU   X'08'               JOT RE-SCAN REQUIRED        @OZ29819
CDFCOMPR EQU   COMNULOP-3          LAST CLASS ELEMENT ADDRESS
CDFCROUT EQU   COMNULOP,2          CURRENT ROUTING             @OZ29819
CDFEROUT EQU   COMNULOP+2,2        LAST ROUTING                @OZ29819
         USING JQEDSECT,R1         RESTORE JQE ADDRESSABILITY
         DROP  WF
         SPACE 2
CDFMID   EQU   COMMAND,6           TEXT 'OUT R='                     R4
CDFMR1   EQU   COMMAND+5,10        TEXT ' RXXX     '                 R4
CDFMB    EQU   CDFMR1+10,31        BASE TEXT                         R4
CDFMBF   EQU   CDFMB+2,4           FORMS                             R4
CDFMBC   EQU   CDFMBF+7,4          CARRAGE                           R4
CDFMBT   EQU   CDFMBC+7,4          TRAIN                             R4
CDFMBW   EQU   CDFMBT+7,8          WRITER NAME                       R4
CDFMCCL  EQU   COMMAND,6           CONTINUATION TEXT 'CLASS '        R4
CDFMCC   EQU   CDFMCCL+L'CDFMCCL   CONTINUATION CLASS ELEMENT        R4
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
*              THIS LINE DELETED BY APAR NUMBER                @OZ29819
         EJECT                                                 @OZ29819
***********************************************************************
*                                                                     *
*        $P Q,Q=CLASSES,R=DESTINATION -- CANCEL DATA SETS             *
*                                                                     *
***********************************************************************
         SPACE 2
CPQ      DS    0H                  CANCEL OUTPUT DATA SETS
         LNR   WB,WE               SET DEFAULT TO NO ROUTE ARGUMENT
         XC    CPQCLAS,CPQCLAS     ZERO CLASS SELECTION              R4
CPQLOOP  DS    0H                  LOOP THROUGH OPERANDS
         BXH   WD,WE,CPQEND        PICK-UP NEXT OPERAND POINTER
         LM    R14,R15,0(WD)       PICK-UP POINTERS TO NEXT OPERANDS
         CLI   1(R14),C'='         CHECK FOR =                       R4
         BNE   CPQINVO             EXIT IF NOT                       R4
         CLI   0(R14),C'Q'         CHECK FOR Q                       R4
         BE    CPQCLS              BREAK OUT CLASS LIST              R4
         CLI   0(R14),C'R'         CHECK FOR ROUTING                 R4
         BNE   CPQINVO             ERROR IF NOT                      R4
         BAL   LINK,COFRTRA        CONVERT ROUTINGS                  R4
         B     CPQINVO             ERROR EXIT               + 0      R4
         LR    WB,R0               COPY ANSWER              + 4      R4
         CR    R0,R1               SAME VALUE                        R4
         BNE   CPQINVO             ERROR IF NOT                      R4
         B     CPQLOOP             LOOP                              R4
         SPACE 1
CPQCLS   DS    0H                  EXTRACT CLASS ARGUMENT
         SLR   R15,R14             COMPUTE STRING SIZE
         SH    R15,=H'4'           TEST FOR EXISTENCE OF STRING
         BM    CPQINVO             NONE -- ERROR
         CH    R15,*+10            TEST FOR MAX SIZE OF EIGHT
         BNH   *+8                 IF NOT HIGH USE SIZE
         LA    R15,L'CPQCLAS-2     ELSE USE MAX SIZE -- EIGHT
         L     R1,=A(CVALIDTB)     POINT TO TEST TABLE               R4
         EX    R15,CPQCLTST        TEST FOR VALID CHARACTERS
         BNZ   CPQINVO             IF INVALID -- EXIT IN ERROR
         XC    CPQCLAS,CPQCLAS     ZERO PREVIOUS CLASSES             R4
         EX    R15,CPQMVCLS        MOVE CLASS STRING TO SAVE AREA
         B     CPQLOOP             AND LOOK FOR MORE OPERANDS
         SPACE 1
CPQCLTST TRT   2(*-*,R14),0(R1)    *** EXECUTE ONLY ***              R4
CPQMVCLS MVC   CPQCLAS(*-*),2(R14) **** EXECUTE ONLY ****
         SPACE 1
CPQINVO  DS    0H                  INVLAID OPERAND ROUTINE
         L     R1,0(,WD)           POINT TO INVALID OPERAND
         $CFINVO OPERAND=(R1)      DISPLAY INVALID OPERAND
         SPACE 2
CPQEND   DS    0H                  END OF OPERAND SCAN
        $QSUSE                     REQUEST ACCESS TO CKPT DATA      R41
         SLR   R10,R10             ZERO HIT RECORDER
         SLR   WD,WD               ZERO CLASS OFFSET REGISTER
         SLR   R0,R0               ZERO CLASS INSERT REGISTER
         CLI   CPQCLAS,0           TEST FOR NO CLASS STRING SUPPLIED
         BNE   CPQNALL             NOT ALL CLASSES TO BE CANCELLED
         BCTR  WD,0                LESS ONE
         BCTR  WD,0                LESS ONE
         LA    WA,CPQALLP          POINT TO END OF JOE EXIT
         BR    WA                  GO THERE
CPQNALL  DS    0H                  CANCEL A SELECTED NBR OF CLASSES
         LA    WA,CPQONE           POINT TO END OF JOE EXIT
         BR    WA                  GO THERE
         SPACE 1
CPQALLP  DS    0H                  ALL CLASSES LOOP
         LA    WD,2(,WD)           GET NEXT CLASS OFFSET
         CH    WD,=H'70'           TEST FOR LAST CLASS
         BH    CPQFINI             YES--EXIT ROUTINE
         LR    R15,WD              SAVE WD IN R15
         SRA   R15,1               DIVIDE BY TWO
         L     R14,=A(CLJHLDTB)    POINT TO CLASS CNVT TABLE
         IC    R0,0(R15,R14)       PICK-UP EBCDIC CLASS
         B     CPQJOT              GO SCAN JOT FOR THIS CLASS
         SPACE 1
CPQONE   DS    0H                  REQUEST FOR UP TO EIGHT CLASSES
         IC    R0,CPQCLAS          PICK-UP POSSIBLE CLASS CHARACTER
         NI    CPQCLAS,255-X'C0'   REDUCE TO JOE DISPLACEMENT
         BZ    CPQFINI             EXIT IF LAST CLASS
         IC    WD,CPQCLAS          PICK-UP PSEUDO JOT OFFSET
         IC    WD,CPQTABLE-1(WD)   PICK-UP ACTUAL JOT OFFSET
         MVC   CPQCLAS(L'CPQCLAS-1),CPQCLAS+1 MOVE CLASS(ES) DOWN
CPQJOT   DS    0H                  SCAN JOT LOOKING FOR JOES TO CNCL
         L     WF,CDFJOT           POINT TO THE JOT
         PUSH  USING               SAVE USING STATUS
         USING JOTDSECT,WF         JOT ADDRESSABILITY
         LA    R1,JOTCLSQ-(JOENEXT-JOEDSECT)(WD) PT TO JOE BFORE CLS
         USING JOEDSECT,R1         JOE ADDRESSABILITY
CPQNXTJO DS    0H                  GET ANOTHER JOE
         LH    R1,JOENEXT          GET OFFSET TO NEXT JOE
         N     R1,=A(X'0000FFFF')  INSURE OFFSET IS POSITIVE
         BZR   WA                  LAST JOE -- EXIT
         SLL   R1,2                EXPAND TO BYTE OFFSET             R4
         ALR   R1,WF               COMPUTE JOE ADDRESS
         TM    JOEFLAG,$JOEBUSY    TEST FOR ACTIVE JOE
         BNZ   CPQNXTJO            IF YES -- GET ANOTHER
         LTR   WB,WB               TEST FOR SELECTIVE CANCEL BY ROUT
         BM    CPQDELET            NO--DELETE THIS JOE
         LH    R15,JOEROUT         GET THE ROUTE CODE          @OZ29819
         LTR   R15,R15             INDIRECT ROUTE...           @OZ29819
         BZ    CPQIRTE             IF YES, EXAMINE JQE         @OZ29819
         CH    WB,JOEROUT          NO--TEST FOR ROUTING MATCH
         BNE   CPQNXTJO            NO--GET NEXT JOE
         B     CPQDELET            YES--DELETE THIS JOE
CPQIRTE  DS    0H                  TEST JQE FOR ROUTE MATCH
         LH    R14,JOEJQE          POINT TO JQE OFFSET
         SLL   R14,2               COMPUTE JQE OFFSET ( * 4)
         AL    R14,$JOBQPTR        COMPUTE JQE ADDRESS
         USING JQEDSECT,R14        JQE ADDRESSABILITY
         L     R15,$SSVT           POINT TO THE SSVT
         USING SSVT,R15            SSVT ADDRESSABILITY
         LA    R15,$SVSCAT         POINT TO SYSOUT CLS ATTRIBUTE TBL
         DROP  R15                 FORGET SSVT ADDRESSABILITY
         ALR   R15,R0              COMPUTE LOC OF THIS CLS IN SCAT
         USING SCADSECT,R15        SCAT ADDRESSABILITY
         TM    SCATFLAG,SCATPRNT   IS CLASS NORMALLY PRINTED
         LH    WE,JQEPRTRT         PICK-UP POSSIBLE PRINT ROUTING
         BO    CPQRTEST            YES--TEST FOR ROUTE MATCH
         LH    WE,JQEPUNRT         PICK-UP POSSIBLE PUNCH ROUTING
         TM    SCATFLAG,SCATPNCH   TEST FOR PUNCH CLASS
         BZ    CPQNXTJO            NO--GET NEXT DATA SET
CPQRTEST DS    0H                  TEST FOR ROUTE CODE MATCH
         CLR   WB,WE               TEST FOR MATCH
         BNE   CPQNXTJO            NO--GET NEXT DATA SET
CPQDELET DS    0H                  DELETE THIS DATA SET
         LR    WF,R0               SAVE R0 OVER DELETE
         LR    R10,R1              SET HIT REGISTER
         $#REM WORK=(R1)           DELETE THIS JOE
         LR    R0,WF               RESTORE CLASS
         LR    R1,R10              RELOAD JOE ADDRESS               R41
         TM    JOEFLAG,$JOESPIN    IS THIS A SPIN DATA SET...       R41
         BZ    CPQJOT              BR IF NO                         R41
         L     R15,=A($IOTPUR)     GET ADDR OF IOT PURGE RTN        R41
         BALR  LINK,R15            GO TO PURGE SPIN DS TRACKS       R41
         POP   USING               RESTORE USINGS                   R41
         B     CPQJOT              AND GET NEXT JOE TO DELETE
         SPACE 1
CPQFINI  DS    0H                  FINISHED WITH DATA SET DELETE
         LTR   R10,R10             TEST FOR ANY CANCELLED
         BNZ   CPQCANCL            YES -- RETURN 'OK'
         $CRET MSG='NO DATA SET(S) CANCELLED'
         SPACE 1
CPQCANCL DS    0H                  RETURN 'OK'
         $CRET MSG=OK              RETURN TO OPERATOR
         SPACE 2
CPQCLAS  EQU   COMREGSV,9          CLASS STRING SAVE AREA
         SPACE 1
CPQTABLE DS    0H                  JOT CONVERSION TABLE
         DC    AL1(0,2,4,6,8,10,12,14,16,18)         A-I OR *,A-I    R4
         DC    6AL1(0)                                               R4
         DC    AL1(18,20,22,24,26,28,30,32,34,36)    J-R             R4
         DC    7AL1(0)                                               R4
         DC    AL1(36,38,40,42,44,46,48,50,52)       S-Z             R4
         DC    5AL1(0)                                               R4
         DC    AL1(52,54,56,58,60,62,64,66,68,70,72) 0-9             R4
         EJECT
***********************************************************************
*                                                                     *
*        $O Q,Q=CLASSES,CANCEL,R=DESTINATION -- OUTPUT HELD DATA SET  *
*                                                                     *
***********************************************************************
         SPACE 2
COQINVO  EQU   CPQINVO             EQUATE ERROR ROUTINE
COQ      DS    0H                  FREE OR CANCEL HELD DATA SETS
         MVI   COQFLAGS,0          TURN OFF ALL FLAGS
        $TIME  ,                   GET CURRENT DATE IN R1           R41
         ST    R1,COQSVCRD         SAVE IT                          R41
COQLOOP  BXH   WD,WE,COQEND        SCAN ALL OPERANDS
         LM    R1,WA,0(WD)         PICK-UP OPERAND POINTERS
         CLI   0(R1),C'C'          THIS CANCEL                       R4
         BE    COQCANCL            CANCEL IF YES                     R4
         CLI   1(R1),C'='          THIS EQUAL                        R4
         BNE   COQINVO             ERROR EXIT IF NOT                 R4
         CLI   0(R1),C'Q'          CLASS STRING                      R4
         BE    COQCLAS             BREAK OUT CLASSES IF YES          R4
         CLI   0(R1),C'D'          CUT-OFF DATE SPECIFIED...        R41
         BE    COQDATE             BR IF YES                        R41
         CLI   0(R1),C'R'          ROUTE CODE                        R4
         BNE   COQINVO             ERROR EXIT IF NOT                 R4
         BAL   LINK,COFRTRA        CONVERT TO ROUTE CODE             R4
         B     CPQINVO             ERROR EXIT               + 0      R4
         LR    R10,R0              COPY ANSWER              + 4      R4
         CR    R0,R1               SAME                              R4
         BNE   CPQINVO             ERROR IF NOT                      R4
         OI    COQFLAGS,COQRTE     FLAG ROUTING DESIRED              R4
         B     COQLOOP             LOOP                              R4
COQCLAS  DS    0H                                                    R4
         SLR   WA,R1               COMPUTE OPERAND SIZE
         SH    WA,=H'4'            LESS '4' FOR MACHINE 'EX'
         BM    COQINVO             IF NEGATIVE -- ERROR
         CH    WA,*+10             CHECK WITH MAX OF '8' CHARACTERS
         BNH   *+8                 LRSS THAN OR EQUAL 'OK'
         LA    WA,7                SET MAX CLASS STRING LENGTH
         L     R14,=A(CVALIDTB)    POINT TO TEST TABLE               R4
         EX    WA,COQVALID         TEST FOR VALID CLASS CHARACTERS
         BNZ   COQINVO             IF ANY INVALID--ERROR
         MVI   COQCLASS,C' '       SET CLASS AREA TO BLANKS
         MVC   COQCLASS+1(L'COQCLASS-1),COQCLASS  DITTO
         EX    WA,COQMVCLS         MOVE CLASSES INTO SAVE AREA
         OI    COQFLAGS,COQCLS     FLAG CLASS STRING EXISTS
         B     COQLOOP             AND LOOP FOR MORE OPERANDS
         SPACE 1
COQVALID TRT   2(*-*,R1),0(R14)    *** EXECUTE ONLY ***              R4
COQMVCLS MVC   COQCLASS(*-*),2(R1) **** EXECUTE ONLY ****
         SPACE 2
COQCANCL DS    0H                  REQUEST TO CANCEL DATA SETS
         OI    COQFLAGS,COQCNCL    SET FLAGS AS SUCH
         B     COQLOOP             AND LOOP FOR MORE OPERANDS
         SPACE 2                                                    R41
COQDATE  SLR   WA,R1               ENSURE                           R41
         SH    WA,=H'3'             AT LEAST 1                      R41
         BNP   COQINVO               AND NOT                        R41
         CH    WA,=H'5'               MORE THAN                     R41
         BH    COQINVO                 5 DIGITS                     R41
         LR    R0,WA               RELOAD VALUE LENGTH              R41
         LR    LINK,R1              AND OPERAND POINTER             R41
         SPACE 1                                                    R41
COQDATVL LA    LINK,1(,LINK)       ENSURE                           R41
         CLI   1(LINK),C'0'         OPERAND                         R41
         BL    COQINVO               VALUE                          R41
         CLI   1(LINK),C'9'           IS                            R41
         BH    COQINVO                 STRICTLY                     R41
         BCT   R0,COQDATVL              NUMERIC                     R41
         SPACE 1                                                    R41
         BCTR  WA,0                REDUCE FOR EXECUTE               R41
         EX    WA,COQDATPK         CONVERT VALUE TO PACKED DECIMAL  R41
         CH    WA,=H'1'            TEST FORM OF VALUE               R41
         BH    COQYYDDD            BR IF NOT NN (DAYS)              R41
        $TIME  ,                   GET CURRENT DATE IN R1           R41
         SLR   R0,R0               CLEAR R0                         R41
         STM   R0,R1,COMDWORK      STORE PACKED DECIMAL DATE        R41
         CVB   R1,PCER1            CONVERT DAYS TO BINARY           R41
         CVB   R0,COMDWORK         CONVERT DATE TO BINARY           R41
         CLC   PCER1+6(2),COMDWORK+6  CUT-OFF DATE LAST YEAR...     R41
         BL    COQYYOK             BR IF NO                         R41
         LA    R1,1000-365(,R1)    IGNORE DAYS 366 - 999            R41
         MVO   COMDWORK+5(3),COMDWORK+5(1)  ISOLATE CURRENT YEAR    R41
         CVB   LINK,COMDWORK       CONVERT YEAR TO BINARY           R41
         BCTR  LINK,0              BACK UP 1 YEAR                   R41
         N     LINK,=F'3'          TEST FOR LEAP YEAR               R41
         BNZ   COQYYOK             BR IF NO                         R41
         BCTR  R1,0                ACKNOWLEDGE DAY 366              R41
         SPACE 1                                                    R41
COQYYOK  SR    R0,R1               GET CUT-OFF DATE                 R41
         BNM   *+6                 BR IF THIS CENTURY               R41
         SLR   R0,R0               CUT-OFF AT TURN OF CENTURY       R41
         CVD   R0,PCER1            CONVERT RESULT TO PACKED DECIMAL R41
         MVC   COQSVCRD,PCER1+4    STORE CUT-OFF DATE               R41
         OI    COQSVCRD+3,X'0F'    MAKE 'PRINTABLE'                 R41
         B     COQLOOP             BR TO TEST FOR MORE OPERANDS     R41
         SPACE 1                                                    R41
COQYYDDD CH    WA,=H'4'            TEST FOR YYDDD                   R41
         BNE   COQINVO             INVALID IF NO                    R41
         MVC   COQSVCRD,PCER1+4    STORE CUT-OFF DATE               R41
         B     COQLOOP             BR TO TEST FOR MORE OPERANDS     R41
         SPACE 1                                                    R41
COQDATPK PACK  PCER1(8),2(*-*,R1)  *** EXECUTE ONLY ***             R41
         SPACE 1                                                    R41
COQEND   DS    0H                  END OF OPERANDS
         LR    WA,R10              COPY ROUTE CODE                   R4
         SLR   R10,R10             SET HIT FLAG TO ZERO
         $CFJSCAN PROCESS=COQPRO,NEXT=COQNEXT,EMPTY=COQNONE,           C
               IGNORE=COQIGN       SCAN THE JOB QUEUE
         SPACE 1
         LTR   R10,R10             WERE ANY JOBS FOUND WITH HLD D S
         BZ    COQNOHLD            NO--EXIT WITH DIAGNOSTIC
         L     R15,$PSOPCE         POINT TO PSO PCE                  R4
         $POST (R15),WORK          POST FOR WORK
         MVC   COMMAND(21),=C'DATA SETS RELEASED TO' SET BASIC MSG   R4
         LA    R0,COMMAND+18-COMMAND SET MESSAGE LENGTH
         TM    COQFLAGS,COQCNCL    TEST FOR DATA SETS CANCELLED
         BZ    COQRERTE            NO--TEST FOR RE-ROUTING
         MVC   COMMAND+10(9),=C'CANCELLED' SET DATA SETS CANCELLED
         LA    R0,COMMAND+19-COMMAND SET MESSAGE LENGTH
         B     COQ$WTO             AND EXIT WITH RESPOMSE
COQRERTE DS    0H                  TEST FOR DATA SETS RE-ROUTED
         TM    COQFLAGS,COQRTE     TEST FOR RE-ROUTING
         BZ    COQ$WTO             NO--SEND MESSAGE
         LA    R15,COMPNTER        POINT TO ROUTE CODE               R4
         STH   WA,COMPNTER         SET ROUTE CODE                    R4
         LA    R0,COMMAND+21       POINT TO TEXT AREA                R4
         BAL   LINK,COFRTC         CONVERT TO EBCDIC                 R4
         LA    R0,COMMAND+21+9-COMMAND SET LENGTH OF MESSAGE         R4
COQ$WTO  DS    0H                  RETURN WITH RESPONSE
         $CRET L=(R0)              EXIT WITH RESPONSE
         SPACE 1
*        EXIT WITH MESSAGE THAT NONE WERE FREED/CANCELLED
COQNOHLD DS    0H
         $CRET MSG='NO HELD DATA SETS'
         SPACE 2
COQNONE  DS    0H                  NO JOB(S) WERE IN THE QUEUE
        $CRET  MSG='JOB(S) NOT FOUND'  EXIT WITH DIAGNOSTIC         R41
         SPACE 2
COQPRO   DS    0H                  TEST FOR HELD DATA SETS
         LH    WB,JQEHLDCT         TEST HOLD COUNT
         LTR   WB,WB               TEST FOR NONE
         BZ    COQNEXT             NONE--GET NEXT JOB
         LR    R10,R1              SET HIT FLAG
         LR    WB,R1               SAVE JQE ADDRESS OVER GETMAIN
         SPACE 1
*        GETMAIN AREA TO BUILD PSO ELEMENT
         SPACE 1
         GETMAIN RC,LV=PSOLNGTH,SP=0 GET STORAGE FOR PSO ELEMENT
         SPACE 1
         LR    WD,R1               SAVE GOTTEN AREA ADDRESS
         LTR   R15,R15             TEST FOR STORAGE AVAILABLE
         BNZ   COQNOSTR            NONE--ISSUE DIAGNOSTIC
         USING PSODSECT,WD         PSO ADDRESSABILITY
         LR    R0,R1               CLEAR                            R41
         LA    R1,PSOLNGTH          PSO                             R41
         MVCL  R0,R14                STORAGE                        R41
         LR    R1,WB               POINT TO JQE                     R41
         OI    PSOFLG1,PSOFHLD+PSOFJOBI+PSOFJOBN SET PSO FLAGS
         MVC   PSOCRDT,COQSVCRD    SET CUT-OFF DATE IN ELEMENT      R41
         TM    COQFLAGS,COQCLS     TEST FOR CLASS STRING PROVIDED
         BZ    *+14                NONE--DON'T SET
         OI    PSOFLG1,PSOFCLAS    SET PSO FLAG
         MVC   PSOCLAS,COQCLASS    SET CLASS STRING INTO PSO ELEMENT
         OI    PSOFLG2,PSOFDONE+PSOF$O SET ADDITIONAL PSO FLAGS
         MVC   PSOJOBN,JQEJNAME    SET JOB NAME IN PSO ELEMENT
         MVC   PSOJOBNO,JQEJOBNO   SET JOB NBR IN PSO ELEMENT
         TM    COQFLAGS,COQCNCL    TEST FOR CANCEL REQUEST
         BZ    *+12                NO--TEST FOR RE-ROUTING
         OI    PSOUFLG,PSOFDELC    SET CANCEL REQUIRED
         B     COQQUEUE            GO QUEUE ELEMENT TO CHAIN
         OI    PSOUFLG,PSOFRLSE    SET RELEASE DATA SET
         TM    COQFLAGS,COQRTE     TEST FOR RE-ROUTING DESIRED
         BZ    *+12                NO--GO QUEUE ELEMENT
         STH   WA,PSOROUTE         SAVE ROUTE CODE
         OI    PSOUFLG,PSOFROUT    AND SET APPROPRIATE FLAG
COQQUEUE DS    0H                  QUEUE ELEMENT TO END OF CHAIN
         LR    R15,WD              SAVE ELEMENT ADDRESS
         LA    WD,$OQUEUE-(PSONEXT-PSODSECT) POINT TO HEAD OF QUEUE
         L     R0,PSONEXT          PT TO NEXT ELEMENT
         LTR   R0,R0               TEST FOR LAST ELEMENT
         BZ    *+10                YES--SET NEW LAST ELEMENT
         LR    WD,R0               PT TO NEXT ELEMENT
         B     *-12                AND LOOP TILL LAST ELEMENT
         ST    R15,PSONEXT         CHAIN ELEMENT INTO
         B     COQNEXT             AND GET NEXT JOB
         DROP  WD                  DROP PSO ADDRESSABILITY
         SPACE 2
*        MESSAGE NO STORAGE AVAILABLE
         SPACE 1
COQNOSTR DS    0H
         $CRET MSG='NO STORAGE AVAILABLE'
         SPACE 2
*        $OQ EQUATES
         SPACE 1
COQFLAGS EQU   COMEWORK,1          OPTION FLAGS
COQCLASS EQU   COMJNAME,8          SAVE AREA FOR CLASS STRING
COQSVCRD EQU   COMREGSV,4          AREA FOR SAVING CUT-OFF DATE     R41
COQCLS   EQU   X'80'               FLAG FOR CLASS STRING EXISTS
COQCNCL  EQU   X'40'               FLAG FOR CANCEL HELD DATA SETS
COQRTE   EQU   X'20'               FLAG FOR RE-ROUTING DESIRED
         EJECT                                                 @OZ29819
         LTORG ,
 TITLE 'HASP COMMAND PROCESSOR HASPCJB2 - JOB LIST COMMANDS'
HASPCJB2 $COMGRUP  AJ,AS,AT,CJ,CS,CT,DJ,DS,DT,EJ,HJ,HS,HT,LJ,LS,LT,    C
               PJ,PS,PT,DELAY=YES  DECLARE SUB-PROCESSOR
***********************************************************************
*                                                                     *
*        JOB NUMBER LISTS ARE OF THE FOLLOWING FORM                   *
*                                                                     *
*        $V JXXN1-M1,N2-M2,...,NX-MX                                  *
*        $V    = HASP COMMAND VERB                                    *
*        JXX   = JOB, JB, JOBS, ETC. ( J IS ONLY ID REQUIRED )        *
*        NI-MI ( I=1 TO X ) = PAIR OF START STOP VALUES, IE. 1-10     *
*              INDICATING THAT JOBS 1,2,3,4,5,6,7,8,9,10 ARE          *
*              DESIRED. ( -M VALUES ARE OPTIONAL )                    *
*                                                                     *
* NOTES                                                               *
*                                                                     *
*    (1) A RESPONSE IS REQUIRED FOR EACH JOB                          *
*                                                                     *
*    (2) COMNULOP IS USED FOR FLAGS DURING PROCESSING AS FOLLOWS      *
*                                                                     *
*              X'80' - A JOB WAS FOUND DURING SCAN FOR JOBS           *
*              X'40' - THE VERB IS C WITH DUMP SPECIFIED              *
*              X'02' - THE VERB IS P                                  *
*              X'01' - THE VERB IS C WITH PURGE SPECIFIED             *
*                                                                     *
*        THESE DEFINITIONS MUST NOT BE CHANGED WITHOUT CHANGING       *
*        THE $JCAN MACRO INSTRUCTION.                                 *
*                                                                     *
***********************************************************************
CCJFJOBF EQU   X'80'               JOB FOUND FLAG
CCJFDUMP EQU   X'40'               VERB IS C WITH DUMP FLAG
CPJQOPER EQU   X'10'               CANCEL A JOB(S) DATA SETS
CLJHOLD  EQU   X'04'               LIST HELD DATA SETS FLAG
CCJFSTOP EQU   X'02'               VERB IS P (STOP) FLAG
CCJFPURG EQU   X'01'               VERB IS C WITH PURGE FLAG
CPJQCLS  EQU   COMREGSV,9          SAVE AREA FOR CLASSES TO BE CNCLD
         CLC   COMVERB(5),=C'PJES2'  CHECK FOR STOP JES2
         BNE   CAJNJES2            NO--CONTINUE JOB LIST COMMANDS
         LH    R1,=Y(CPJES2-HASPCSY1)  SET OFFSET TO PROCESSOR
         L     BASE3,=A(HASPCSY1)  PT TO SUB-PROCESSOR FOR $PJES2
         ALR   R1,BASE3            COMPUTE ENTRY ADDRESS
         BR    BASE3               GO STOP JES2
CAJNJES2 DS    0H                  NOT $PJES2 COMMAND
         CLC   COMVERB(4),=C'LSYS' CHECK FOR LIST SYSTEM STATUS
         BNE   CAJNLSYS            NO--SKIP SETTING OFFSETS
         LH    R1,=Y(CLSYS-HASPCSY1) SET OFFSET TO $LSYS PROCESSOR
         L     BASE3,=A(HASPCSY1)  POINT TO SYSTEM COMMANDS
         ALR   R1,BASE3            COMPUTE $LSYS ENRTY ADDRESS
         BR    BASE3               ENTER SYSTEM COMMAND GROUP
CAJNLSYS DS    0H                  NOT $LSYS COMMAND
         LR    WB,R1               SAVE OFFSET TO JOB LIST
* HIGH BYTE OF COMNULOP IS ZERO
CAJLOOP  L     R1,0(0,WD)          POINT TO OPERAND
         CLI   0(R1),C'0'          DOES IT START WITH NUMERIC
         BNL   CAJLOOPC            IF SO CONTINUE CONVERSION
         SLR   WC,WC               ASSUME BASE FOR JX...
         CLI   0(R1),C'J'          IS IT JOB
         BE    CAJLOOPC            CONVERT IF YES
         LH    WC,=H'10000'        ASSUME BASE FOR SX...
         CLI   0(R1),C'S'          IS IT STC
         BE    CAJLOOPC            CONVERT IF YES
         LH    WC,=H'20000'        ASSUME BASE FOR TX...
         CLI   0(R1),C'T'          IS IT TSU
         BE    CAJLOOPC            CONVERT IF YES
         CLI   COMVERB,C'C'        CHECK FOR CANCEL OPTIONS
         BE    CAJCANCL            YES--CHECK FOR CANCEL OPTIONS
         CLI   COMVERB,C'P'        TEST FOR STOP OPTIONS
         BE    CAJSTOP             YES--TEST FOR STOP OPTION
         CLI   COMVERB,C'L'        TEST FOR OPTIONS FOE LIST
         BNE   CAJINVO             NO-OTHER JOB LISTS HAVE NO OPTION
         CLI   0(R1),C'H'          TEST FOR REQUEST TO LIST HELD DS
         BNE   CAJINVO             NO--INVALID LIST OPTION
         OI    COMNULOP,CLJHOLD    YES--FLAG OPTION FOR HOLD LIST
         B     CAJADJWF            GO ADJUST OPERAND PTRS
         SPACE 1
CAJSTOP  DS    0H                  REQUEST IS AN OPTION FOR STOP JOB
         CLC   0(2,R1),=C'Q='      TEST FOR CORRECT OPTION
         BNE   CAJINVO             NO--EXIT IN ERROR
         L     R15,4(,WD)          PT TO NEXT OPERAND
         SLR   R15,R1              COMPUTE OPERAND
         SH    R15,=H'4'           SIZE-LESS 'Q='
         BM    CAJINVO             IF NEGATIVE--NO CLASSES EXIST
         L     R14,=A(CVALIDTB)    POINT TO TEST TABLE               R4
         EX    R15,CPJQTEST        TEST FOR VALID CLASS STRING
         BNZ   CAJINVO             INVALID CLASSES
         CH    R15,*+10            TEST FOR MAX OF EIGHT CLASSES
         BNH   *+8                 YES--USE SUBMITTED LENGTH
         LA    R15,L'CPJQCLS-2     NO--USE MAXIMUM OF EIGHT
         MVI   CPJQCLS,0           SET SAVE AREA TO ZEROES
         MVC   CPJQCLS+1(L'CPJQCLS-1),CPJQCLS DITTO
         EX    R15,CPJQMVIT        MOVE CLASSES INTO SAVE AREA
         OI    COMNULOP,CPJQOPER   FLAG GOOD OPERAND FOUND
         B     CAJADJWF            GO ADJUST OPERAND PTRS
CPJQTEST TRT   2(*-*,R1),0(R14)    *** EXECUTE ONLY ***              R4
CPJQMVIT MVC   CPJQCLS(*-*),2(R1)  **** EXECUTE ONLY ****
         SPACE 1
CAJCANCL DS    0H                  OPTIONS FOR CANCEL COMMAND
         OI    COMNULOP,CCJFDUMP   ASSUME OPTION IS 'DUMP'
         CLI   0(R1),C'D'          TEST FOR SAME
         BE    CAJADJWF            IF SO--ADJUST OPERAND PTRS
         XI    COMNULOP,CCJFDUMP+CCJFPURG SET PURGE OPTION
         CLI   0(R1),C'P'          TEST FOR SAME
         BNE   CAJINVO             NO--INVALID OPTION
CAJADJWF DS    0H                  SET THIS OPERAND AS LAST ONE
         LR    WF,WD               SET THIS AS LAST
         SLR   WF,WE               PT TO FIRST
         B     CAJGO               GO GET JOB(S)
         SPACE 1
CAJLOOPC $CFCVB POINTER=(WD),NOK=CAJINVO CONVERT NUMBERS TO BINARY
         LTR   R1,R1               JOB ZERO                          R4
         BZ    CAJINVO             ERROR IF YES                      R4
         AR    R0,WC               ADD BASE VALUES
         AR    R1,WC               TO HIGH AND LOW
         STH   R0,2(0,WD)          STORE FINAL VALUE
         STH   R1,0(0,WD)          STORE START VALUE
         BXLE  WD,WE,CAJLOOP       COMPLETE FOR ALL STRINGS
CAJGO    LA    WD,COMPNTER         POINT TO FIRST OPERAND POINTER    R4
* START STOP VALUES STORED IN OPERAND POINTER AREA
CAJLOOPA LH    WC,0(0,WD)          PICK UP FIRST JOB OF PAIR
CAJLOOPB SLR   R10,R10             ZERO HIT RECORDER
         LH    WA,2(0,WD)          SET UPPER BOUND AND RESULT
         $QSUSE ,                  ENQUEUE ON SHARED RESOURCE
         SPACE 1
         $CFJSCAN PROCESS=CAJPRO,NEXT=CAJNEXTJ SCAN THE JOB QUEUE
         LTR   R1,R10              DID WE GET A HIT
         BZ    CAJNEXTP            IF NOT TRY NEXT PAIR
         LR    WC,WA               SAVE JOB NUMBER
CAJHITA  $CFVQE NOK=CAJNEXT        VERIFY JOB OWNER
         OI    COMNULOP,CCJFJOBF   SET JOB FOUND FLAG
         BR    WB                  ENTER SELECTED ROUTINE            R4
CAJINVO  L     R1,0(0,WD)          PICK UP OPERAND ADDRESS
         $CFINVO OPERAND=(R1)      RETURN WITH INVALID OPERAND
CAJPRO   LH    R0,JQEJOBNO         PICK UP JOB NUMBER
         CR    R0,WC               CHECK AGAINST LOW BOUND
         BL    CAJNEXTJ            LOOP
         BE    CAJHITA             STOP SCAN ON MATCH
         CR    R0,WA               CHECK AGAINST UPPER BOUND
         BH    CAJNEXTJ            LOOP
         LR    WA,R0               COPY JOB ID
         LR    R10,R1              COPY JQE ADDRESS
         B     CAJNEXTJ            LOOP
         EJECT
***********************************************************************
*                                                                     *
*        $A JOB LIST -- RELEASE JOB(S) HELD BY $H JOB, $H ALL,        *
*              TYPERUN=HOLD, ETC.                                     *
*                                                                     *
***********************************************************************
CAS      DS    0H
CAT      DS    0H
CAJ      MVC   COFQUE-1(10),=C' NOT HELD ' SET MESSAGE
         TM    JQEFLAGS,QUEHOLDA+QUEHOLD1  IS JOB HELD
         BZ    CAJMSG              IF NOT SEND NOT HELD
         NI    JQEFLAGS,255-QUEHOLDA-QUEHOLD1  RELEASE JOB
         MVC   COFQUE(8),=C'RELEASED' SET MESSAGE
         $POST $HASPECF,(JOB,JOT)  POST JOB AND JOT
         OI    $AQSE,QSEPJOB+QSEPJOT   CAUSE X SYSTEM POST(S)
         $QCKPT (R1)               SET CHECKPOINT
CAJMSG   LA    WA,COFQUE-COFJOB+9  SET LENGTH OF MESSAGE
CAJMSGA  MVC   COFJNAME,JQEJNAME   SET JOB NAME
         LR    R0,WC               COPY JOB NUMBER
SKIP140  MVC   COFJOB,=C'JOB'      SET ID
         CH    R0,=H'10000'        CHECK FOR CORRECT
         BL    CAJMSGB             IF OK SET NUMERIC
         MVC   COFJOB,=C'TSU'      SET ID
         SH    R0,=H'20000'        CHECK FOR CORRECT
         BNL   CAJMSGB             IF OK SET NUMERIC
         MVC   COFJOB,=C'STC'      SET ID
         AH    R0,=H'10000'        SET NUMERIC
CAJMSGB  $CFCVE VALUE=(R0)         CONVERT TO EBCDIC
         MVC   COFJNO,COMDWORK     MOVE NUMBER
         MVI   COFJNAME-1,C' '     SET BLANK
         NI    COMMID+1,X'FE'      INDICATE JOB ID SET
         $CWTO L=(WA)              DISPLAY MESSAGE
CAJNEXT  LA    WC,1(0,WC)          NEXT NUMBER OF SEQUENCE
         CH    WC,2(0,WD)          CHECK FOR END OF PAIR
         BNH   CAJLOOPB            IF NOT, WORK ON NEXT JOB
CAJNEXTP BXLE  WD,WE,CAJLOOPA      GO TO NEXT PAIR IF PRESENT
         TM    COMNULOP,CCJFJOBF   TEST JOB FOUND FLAG
         BO    CAJRET              IF ON, EXIT
         $CRET MSG='JOB(S) NOT FOUND'
CAJRET   $CRET ,                   EXIT
         EJECT
***********************************************************************
*                                                                     *
*        $C JOB LIST -- CANCEL JOB, DELETE APPROPRIATE PRINT/PUNCH    *
*              FUNCTION AND DELETE JOB                                *
*                                                                     *
***********************************************************************
CCS      DS    0H
CCT      DS    0H
CCJ      SLR   R0,R0               ZERO OPTION REGISTER
         IC    R0,COMNULOP         PICK UP REQUEST OPTIONS
        $JCAN  JQE=(R1),NOTJOB=CCNOTCAN,OK=CDJ  CANCEL JOB          R41
         SPACE 4                                                    R41
CCNOTCAN MVC   COFQUE-1(15),=C' NON-CANCELABLE'  SET MESSAGE        R41
         LA    WA,COFQUE+14-COFJOB                AND LENGTH        R41
         B     CAJMSGA             ISSUE DIAGNOSTIC AND CONTINUE    R41
         EJECT
***********************************************************************
*                                                                     *
*        $D JOB LIST -- DISPLAY JOB(S)                                *
*                                                                     *
***********************************************************************
CDS      DS    0H
CDT      DS    0H
CDJ      $CFJMSG ,                 DISPLAY JOB INFORMATION
         B     CAJNEXT             GO TO NEXT JOB
         EJECT
***********************************************************************
*                                                                     *
*        $H JOB LIST -- HOLD JOB(S), PREVENT FURTHER PROCESSING       *
*                                                                     *
***********************************************************************
CHS      DS    0H
CHT      DS    0H
CHJ      OI    JQEFLAGS,QUEHOLD1   SET HOLD BIT ON
CHJCKPT  $QCKPT (R1)               SET CHECKPOINT
         B     CDJ                 DISPLAY JOB
         EJECT
***********************************************************************
*                                                                     *
*        $P JOB LIST -- STOP JOB WHEN CURRENT ACTIVITY IS COMPLETE    *
*                                                                     *
***********************************************************************
CPS      DS    0H                  STOP A STC
CPT      DS    0H                  STOP A TSU
CPJ      DS    0H                  STOP A JOB
         TM    COMNULOP,CPJQOPER   TEST FOR REQUEST TO CANCEL OUTPUT
         BO    CPJQCAN             YES--CANCEL SELECTED CLASSES
         OI    COMNULOP,CCJFSTOP   ELSE FLAG STOP JOB,STC,OR TSU
         B     CCJ                 AND ENTER CANCEL ROUTINE
         EJECT
***********************************************************************
*                                                                     *
*        REQUEST IS TO CANCEL CLASS(ES) OF OUTPUT                     *
*        FOR A JOB, STC, OR A TSU                                     *
*                                                                     *
***********************************************************************
         SPACE 1
CPJQCAN  DS    0H                  CANCEL INACTIVE OUTPUT
        $QSUSE                     REQUEST ACCESS TO CKPT DATA      R41
         STM   WB,WE,COMWREGS      SAVE REGISTERS FOR WORK
         ST    WF,COMFWORK         SAVE CLASS POINTER REGISTER
         SLR   WA,WA               ZERO JOE REMOVED REGISTER
         LR    WB,R1               SAVE JQE ADDRESS FOR TESTING
         LA    WF,CPJQCLS          POINT TO CLASS LIST
CPJQLOOP DS    0H                  LOOP THROUGH ALL CLASS(ES)
         ICM   WC,1,0(WF)          PICK-UP NEXT CLASS CHARACTER
         BZ    CPJQEND             IF LAST -- EXIT ROUTINE
         N     WC,=A(255-X'C0')    TURN 'OFF' HIGH ZONE(S)
         L     R14,=A(CPQTABLE-1)  PT TO CLASS CONVERT TABLE
         IC    WC,0(WC,R14)        PICK-UP CORRESPONDING JOT OFFSET
         IC    R0,0(,WF)           PICK-UP ACTUAL CLASS CHARACTER
         LA    WF,1(,WF)           PT TO NEXT CLASS CHARACTER
CPJQJOT  DS    0H                  ENTER JOT SCAN ROUTINE
         L     WD,CDFJOT           POINT TO THE JOT
         PUSH  USING               SAVE CURRENT USING STATUS
         USING JOTDSECT,WD         JOT ADDRESSABILITY
         USING JOEDSECT,R1         JOE ADDRESSABILITY
         SLR   R15,R15             ZERO JOE OFFSET REGISTER
         LA    R1,JOTCLSQ-(JOENEXT-JOEDSECT)(WC) POINT TO HEAD OF Q
CPJQNXJO LH    R1,JOENEXT          GET OFFSET TO NEXT JOE
         N     R1,=A(X'0000FFFF')  INSURE OFFSET IS POSITIVE
         BZ    CPJQLOOP            IF LAST JOE--LOOP FOR MORE CLSES
         SLL   R1,2                EXPAND TO BYTE OFFSET             R4
         ALR   R1,WD               COMPUTE JOE ADDRESS
         TM    JOEFLAG,$JOEBUSY    TEST FOR JOE BUSY
         BNZ   CPJQNXJO            YES--GET NEXT JOE
         LH    R14,JOEJQE          POINT TO JQE OFFSET
         SLL   R14,2               COMPUTE ACTUAL JQE OFFSET ( * 4)
         AL    R14,$JOBQPTR        COMPUTE JQE ADDRESS
         CLR   WB,R14              CHECK FOR DESIRED JOB
         BNE   CPJQNXJO            NO--GET NEXT JOE
*              THIS LINE DELETED BY APAR NUMBER                @OZ24821
*              THIS LINE DELETED BY APAR NUMBER                @OZ24821
*              THIS LINE DELETED BY APAR NUMBER                @OZ24821
         LR    WE,R0               SAVE CLASS IN WE            @OZ24821
         LR    WA,R1               SAVE JOE ADDRESS                 R41
         $#REM WORK=(R1)           REMOVE JOE FROM JOT
         LR    R1,WA               RELOAD JOE ADDRESS               R41
         LR    R0,WE               RESTORE CLASS TO R0
         LR    WA,WF               SET JOE REMOVED REGISTER
         TM    JOEFLAG,$JOESPIN    IS THIS A SPIN DATA SET...       R41
         BZ    CPJQJOT             BR IF NO                         R41
         L     R15,=A($IOTPUR)     GET ADDR OF IOT PURGE RTN        R41
         BALR  R14,R15             GO TO PURGE SPIN DS TRACKS       R41
         B     CPJQJOT             AND GET NEXT JOE
         POP   USING               RESTORE USING'S
         SPACE 1
CPJQEND  DS    0H                  END OF JOE REMOVE ROUTINE
         LR    R1,WB               RESTORE JQE POINTER
         LM    WB,WE,COMWREGS      RESTORE REGISTERS
         L     WF,COMFWORK         RELOAD SAVED REGISTER
         LTR   WA,WA               TEST FOR ANY JOES REMOVED
         BZ    CPJQNONE            NO--SEND DIAGNOSTIC
         MVC   COFQUE-1(20),=C' DATA SETS CANCELLED'  SET MESSAGE
         LA    WA,COFQUE-COFJOB+19 SET MESSAGE LENGTH
         B     CAJMSGA             GO ISSUE MESSAGE
CPJQNONE DS    0H                  NO JOES WERE CANCELLED
         MVC   COFQUE-1(23),=C' NO DATA SETS CANCELLED' SET DIAG
         LA    WA,COFQUE-COFJOB+22 SET MESSAGE LENGTH
         B     CAJMSGA             GO ISSUE MESSAGE
         EJECT
***********************************************************************
*                                                                     *
*        $E JOB LIST -- RESTART JOB CURRENTLY IN EXECUTION            *
*                                                                     *
***********************************************************************
CEJ      CLI   JQETYPE,$XEQ        TEST FOR CONVERTING
         BE    CEJERR              IF SO -- ERROR
         TM    JQETYPE,$XEQ        TEST FOR EXECUTING
         BZ    CEJERR              NO -- ERROR
         TM    JQEFLAGS,QUEBUSY    ACTIVE IN EXECUTION
         BZ    CEJERR              NO--ERROR
         CLC   JQEJOBNO,=H'10000'  JOB IN NORMAL BATCH RANGE
         BNL   CEJERR              ERROR IF NOT
         L     WA,$PITABLE         GET ADDRESS OF FIRST PIT
         USING PITDSECT,WA         PROVIDE PIT ADDRESSABILITY
CEJLOOPE TM    PITSTAT,PITBUSY     TEST FOR PIT IN USE
         BZ    CEJNPIT             BR IF NO
         CLC   JQEJOBNO,=H'10000'  JOB IN NORMAL RANGE
         BNL   CEJERR              ERROR IF NOT
         L     R14,PITSJB          GET ADDRESS OF SJB
         CLM   R1,7,SJBJQE+1-SJBDSECT(R14)  COMPARE JQE ADDRESSES
         BE    CEJE                BR IF FOUND THE JOB
CEJNPIT  ICM   WA,15,PITNEXT       POINT TO NEXT PIT                 R4
         BNZ   CEJLOOPE            BR IF VALID PIT ADDRESS           R4
         B     CEJERROR            IF NOT FOUND BUT ACTIVE SEND DIAG
         DROP  WA                  KILL PIT ADDRESSABILITY
CEJERR   MVC   COFQUE-1(16),=C' NOT RESTARTABLE' SET MESSAGE
         LA    WA,COFQUE-COFJOB+15 SET LENGTH
         B     CAJMSGA             DISPLAY MESSAGE
CEJE     OI    SJBFLG1-SJBDSECT(R14),SJB1EJOB  SET FOR RESTART
         B     CDJ                 ENTER DISPLAY JOB
CEJERROR DS    0H                  SEND DIAGNOSTIC
         MVC   COFQUE-1(18),=C' NOT EXECUTING ON ' SET MSG BODY
         MVC   COFQUE+17(L'$SID),$SID  SET END OF MESSAGE
         LA    WA,COFQUE+17+L'$SID-COFJOB  SET LENGTH
         B     CAJMSGA             EXIT WITH DIAGNOSTIC
         EJECT
***********************************************************************
*                                                                     *
*        $L JOB LIST -- LIST JOB,STC,OR TSU OUTPUT                    *
*                       INCLUDES READY AND HELD DATA SETS             *
*                                                                     *
***********************************************************************
         SPACE 1
CLT      DS    0H                  DEFINE A COMMON ENTRY POINT
CLS      DS    0H                  FOR TIME SHARING USERS SYSTEM
CLJ      DS    0H                  CONTROL TASKS AND BATCH JOBS
         MVI   COMMAND,C' '        SET MSG AREA TO ALL BLANKS
         MVC   COMMAND+1(L'COMMAND-1),COMMAND MORE OF ABOVE
         NI    COMMID+1,X'FE'      INDICATE TO HASPCON JOB ID SET
         LR    R0,WC               GET CURRENT TASK NUMBER
         MVC   COFJOB,=C'JOB'      ASSUME BATCH JOB
         CH    R0,=H'10000'        TEST FOR BATCH JOB
         BL    CLJMSGC             YES--CONTINUE MSG
         MVC   COFJOB,=C'TSU'      ASSUME TIME SHARING USER
         SH    R0,=H'20000'        TEST FOR TSU
         BNM   CLJMSGC             YES--CONTINUE MESSAGE
         MVC   COFJOB,=C'STC'      NO--MUST BE SYSTEM CNTRL TASK
         AH    R0,=H'10000'        READJUST NUMBER FOR IT
CLJMSGC  DS    0H                  CONTINUE MSG PREFIX
         $CFCVE    VALUE=(R0)      CONVERT THE NBR TO EBCDIC
         MVC   COFJNO,COMDWORK     AND MOVE IT TO THE MSG
         MVC   COFJNAME,JQEJNAME   INSERT THE JOB NAME
         TM    COMNULOP,CLJHOLD    TEST FOR HELD REQUEST
         BO    CLJHLDDS            YES--LIST HELD DATA SETS FOR JOB
         MVC   COFQUE(6),=CL6'READY'   SET JOE QUEUE ID
         LA    WA,COFQUE+6         POINT TO NEXT AVAILABLE BYTE
         STM   WB,WE,COMWREGS      SAVE REGISTERS FOR WORK
***********************************************************************
*                                                                     *
*        SCAN JOES AND COUNT ANY BELONGING TO THIS JOB                *
*                                                                     *
***********************************************************************
         USING JOTDSECT,WB         SET
         USING JOEDSECT,WC         ADDRESSABILITIES
         SLR   WD,WD               START JOES WITH CLASS A
         SLR   WE,WE               ZERO JOE FOUND REGISTER
         L     WB,CDFJOT           POINT TO THE JOT
*                                    THIS LINE DELETED BY APAR @OZ20010
*                                    THIS LINE DELETED BY APAR @OZ20010
*                                    THIS LINE DELETED BY APAR @OZ20010
CLJOLOOP DS    0H                  LOOP THROUGH JOES
         SLR   R15,R15             ZERO COUNTER FOR THIS CLASS
         LA    WC,JOTCLSQ-(JOENEXT-JOEDSECT)(WD) POINT TO CLS Q
CLJOES   LH    WC,JOENEXT          GET OFFSET TO NEXT JOE
         N     WC,=A(X'0000FFFF')  INSURE OFFSET IS POSITIVE
         BZ    CLJENDJO            LAST IN THIS CLASS -- EXIT
         SLL   WC,2                EXPAND TO BYTE OFFSET             R4
         ALR   WC,WB               COMPUTE ADDRESS OF JOE
         LH    R0,JOEJQE           PICK-UP JQE OFFSET
         SLL   R0,2                COMPUTE ACTUAL JQE OFFSET ( * 4)
         AL    R0,$JOBQPTR         COMPUTE JQE ADDRESS
         CLR   R1,R0               IS IT MY JOE
         BNE   CLJOES              NO--GET THE NEXT IN THIS CLASS
         LA    R15,1(,R15)         YES--COUNT IT
         B     CLJOES              AND CONTINUE TO LOOK AT JOES
         DROP  WB,WC               DROP ADDRESSABILITIES
CLJENDJO DS    0H                  COME HERE WHEN END OF CLASS
         LTR   R0,R15              TEST FOR ANY HITS
         BZ    CLJNXJOE            NO--GET NEXT CLASS
         LR    WE,WF               SET JOE FOUND
         LR    R14,WD              PUT JOE CLASS OFFSET INTO WORK
         SRA   R14,1               DIVIDE BY TWO FOR OFFSET INTO TBL
         IC    R14,CLJHLDTB(R14)   PICK-UP ACTUAL CLASS CHARACTER
         STC   R14,0(,WA)          SAVE CHARACTER IN MESSAGE
         MVC   1(3,WA),=C'=**'     SET PATTERN IN MSG
         CH    R0,=H'100'          CHK FOR MAX JOE COUNT EXCEEDED
         BNL   CLJOVJOE            YES--SKIP INSERTION OF COUNT
         $CFCVE VALUE=(R0)         CONVERT HITS TO EBCDIC VALUE
         MVC   2(2,WA),COMDWORK+3  AND PLACE RESULT IN MSG
CLJOVJOE LA    WA,5(,WA)           STEP TO NEXT MSG BYTE
         BAL   R15,CLJCKMSG        AND TEST FOR $WTO NEEDED
CLJNXJOE LA    WD,2(,WD)           POINT TO NEXT CLASS
         CH    WD,=Y(L'JOTRDYWQ-2) END OF CLASSES                    R4
         BL    CLJOLOOP              BR IF NO TO RESUME SACN   @OZ20010
         LTR   WE,WE               TEST FOR ANY JOE(S) FOUND
         BNZ   CLJRDYND            YES--SKIP DIAGNOSTIC
         MVC   COFQUE(18),=C'NO READY DATA SETS'  SET DIAGNOSTIC
         LA    WA,COFQUE+18        SET END OF DIAG ADDRESS
         EJECT
***********************************************************************
*                                                                     *
*        MESSAGE LENGTH AND $WTO PORTION                              *
*                                                                     *
***********************************************************************
CLJRDYND DS    0H                  END OF READY DISPLAY
         LM    WB,WE,COMWREGS      RESTORE WORK REGISTERS
         SPACE 1
CLJWTO   DS    0H                  ISSUE WTO FOR $L COMMAND
         LA    R14,COMMAND         POINT TO BEGINNING OF AREA
         LR    R0,WA               POINT TO END OF MESSAGE
         SLR   R0,R14              COMPUTE MESSAGE LENGTH
CLJ$WTO  $CWTO L=(R0)              ISSUE MESSAGE
         B     CAJNEXT             AND GET NEXT JOB
         SPACE 1
CLJCKMSG DS    0H                  CKECK CURRENT MESSAGE LENGTH
         LA    R14,COMMAND+64      SET END ADDR OF LARGEST MESSAGE
         CLR   WA,R14              CHECK CURRENT LENGTH
         BLR   R15                 IF LESS THAN THIS -- RETURN
         ST    R15,COMFWORK        ELSE SAVE REGISTERS
         ST    R1,COMDWORK         SAVE R1 AS WELL                  R41
         LR    R0,WA               GET END ADDRESS
         LA    R14,COMMAND         GET BEGINNING ADDRESS
         SLR   R0,R14              COMPUTE LENGTH
         $CWTO L=(R0)              SEND MESSAGE
         L     R15,COMFWORK        RESTORE R15
         L     R1,COMDWORK         RESTORE R1                       R41
         MVI   COMMAND,C' '        CLEAR MESSAGE AREA
         MVC   COMMAND+1(L'COMMAND-1),COMMAND  DITTO
         NI    COMMID+1,X'FE'      INDICATE JOB ID IS SET
         LA    WA,COFQUE           POINT TO FIRST FREE MESSAGE AREA
         BR    R15                 AND RETURN
         SPACE 2
***********************************************************************
*                                                                     *
*        LIST HELD DATA SETS FOR JOB(S)                               *
*                                                                     *
***********************************************************************
         SPACE 1
CLJHLDDS DS    0H                  LIST HELD DATA SETS
         LH    WA,JQEHLDCT         GET POSSIBLE HOLD COUNT
         LTR   WA,WA               TEST FOR ANY
         BZ    CLJNOHLD            NONE--DISPLAY DIAGNOSTIC
         STM   R14,R12,COMREGSV    ELSE SAVE REGISTRES
         MVI   CLJCLAS,0           ZERO CLASS SAVE AREA
         MVC   CLJCLAS+1(L'CLJCLAS-1),CLJCLAS  DITTO
         ST    R1,CLJJQE           SAVE JQE ADDRESS
         LA    R1,CLJJQE           POINT TO PARAMETER LIST
         SPACE 1
         $LINK HASPLIST            ENTER HOLD DATA SET PROCESSOR
         SPACE 1
         LM    R14,R12,COMREGSV    RESTORE REGISTERS
         MVC   COFQUE(5),=CL5'HELD'  SET MESSAGE HEADER
         LA    WA,COFQUE+5         POINT TO NEXT MESSAGE AREA
         SLR   WC,WC               ZERO INSERT REGISTER
         SLR   R1,R1               ZERO TABLE(S) INDEX REGISTER
         BCTR  R1,0                LESS ONE FOR START
         LA    WE,1                SET INCREMENT
         LA    WF,35               SET COMPORAND
CLJHLDLP DS    0H                  SCAN THE TABLE FOR HOLD COUNTS
         BXH   R1,WE,CLJHLDND      LOOP TROUGH CLASS FIELDS
         LR    R14,R1              PUT CLASS OFFSET INTO WORK REG
         SLL   R14,1               MULTIPLY BY TWO FOR HALFWORD AREA
         LH    WC,CLJCLAS(R14)     PICK-UP POSSIBLE HOLD COUNT
         LTR   WC,WC               TEST FOR ANY HELD DATA SETS
         BZ    CLJHLDLP            NONE OF THIS CLASS -- LOOP
         IC    R0,CLJHLDTB(R1)     PICK-UP CLASS CHARACTER
         STC   R0,0(,WA)           PLACE CHARACTER IN MESSAGE AREA
         MVI   1(WA),C'='          SET EQUAL SIGN FOR MESSAGE
         $CFCVE VALUE=(WC)         CONVERT COUNT TO DISPLAYABLE FORM
         MVC   2(3,WA),COMDWORK+2  COMPLETE MSG -- 'CLASS=NNN'
         LA    WA,6(,WA)           POINT TO NXT AVAIL. MSG AREA
         BAL   R15,CLJCKMSG        GO TEST FOR POSSIBLE $WTO
         B     CLJHLDLP            AND LOOP THROUGH ALL 36 CLASSES
         SPACE 2
*        EXIT LIST HOLD DATA SETS ROUTINE
         SPACE 1
CLJHLDND DS    0H                  END OF HELD DATA SETS
         LR    R14,WA              SAVE WA OVER 'LM'
         LM    R15,R12,COMREGSV+4  RESTORE REGSITERS
         LR    WA,R14              RESTORE WA
         B     CLJWTO              AND EXIT AFTER $WTO
         SPACE 2
*        SEND DIAGNOSTIC 'NO HELD DATA SETS'
         SPACE 1
CLJNOHLD DS    0H                  SEND MESSAGE 'NO HELD DATA SETS'
         MVC   COFQUE(17),=C'NO HELD DATA SETS'  CREATE DIAGNOSTIC
         LA    R0,COFQUE+17-COMMAND  SET MESSAGE LENGTH
         B     CLJ$WTO             AND ISSUE DIAGNOSTIC
         SPACE 2
*        CLASS CONVERT TABLE
         SPACE 1
CLJHLDTB DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
         EJECT
         SPACE 2
***********************************************************************
*                                                                     *
*        EQUATES FOR $L COMMAND                                       *
*                                                                     *
***********************************************************************
CLJJQE   EQU   COMREGSV+15*4,4     SAVE AREA FOR JQE ADDRESS
CLJCLAS  EQU   CLJJQE+4,72         SAVE AREA FOR CLASS COUNTS
         SPACE 2
         LTORG ,
         TITLE 'HASP COMMAND PROCESSOR HASPCJB3 - MISC. JOB COMMANDS'
HASPCJB3 $COMGRUP  A7D,C7D,D7D,E7D,H7D,L7D,O7D,P7D,T7D  JOB CMNDS
CD7D     DS    0H                  ENTRY PT FOR DISPLAY BY NAME
CA7D     EQU   CD7D                ENTRY PT FOR RELEASE BY NAME
CC7D     EQU   CD7D                ENTRY PT FOR CANCEL BY NAME
CE7D     EQU   CD7D                ENTRY PT FOR RESTART BY NAME
CH7D     EQU   CD7D                ENTRY PT FOR HOLD BY NAME
CL7D     EQU   CD7D                ENTRY PT FOR LIST BY NAME
CO7D     EQU   CD7D                ENTRY PT FOR OUTPUT BY NAME
CP7D     EQU   CD7D                ENTRY PT FOR STOP BY NAME
CT7D     EQU   CD7D                ENTRY PT FOR MODIFY BY NAME
***********************************************************************
*                                                                     *
*        $D 'JOBNAME' -- DISPLAY JOB INFORMATION FOR JOB(S)           *
*                                                                     *
***********************************************************************
         L     R1,0(,WD)           PICK-UP START OF OPERAND
         L     WC,4(0,WD)          PICK UP END OF OPERAND + 2
         ST    WD,COMFWORK         SAVE FIRST OPERAND POINTER POINTER
         CLI   COMVERB,C'P'        IS OPTION FOR $PJOB
         BNE   CD7DCN              NO--TRY OPTIONS FOR CANCEL JOB
         CLC   0(2,WC),=C'Q='      CHECK FOR CANCEL OF OUTPUT CLSES
         BNE   CD7DNL              NO--MUST BE $P WITH NO OPERANDS
         L     R15,8(,WD)          YES--POINT TO LAST OPERAND
         SLR   R15,WC              COMPUTE OPERAND LENGTH
         SH    R15,=H'4'           COMPUTE STRING SIZE LESS ONE
         BM    CD7DINVC            IF NEGATIVE--NO STRING
         L     R14,=A(CVALIDTB)    POINT TO TEST TABLE               R4
         EX    R15,CD7DCTST        TEST FOR VALIS CLASS STRING
         BNZ   CD7DINVC            IF NOT VALID CHARACTERS--ERROR
         CH    R15,*+10            TEST FOR MAXIMUM LENGTH
         BNH   *+8                 NOT GREATER--USE PRESENTED LENGTH
         LA    R15,L'CPJQCLS-2     ELSE USE MAXIMUM LENGTH
         MVI   CPJQCLS,0           SET SAVE AREA TO
         MVC   CPJQCLS+1(L'CPJQCLS-1),CPJQCLS ZEROES
         EX    R15,CD7DCMV         MOVE STRING INTO SAVE AREA
         OI    COMNULOP,CPJQOPER   SET OPTION FLAG FOR OUTPUT CANCEL
         B     CD7DNL              AND CONTINUE
CD7DINVC DS    0H                  INVALID OPERAND IN CLASS STRING
         L     R1,4(,WD)           POINT TO INVALID OPERAND          R4
         B     CD7DINV             AND BRANCH TO ERROR RTN
CD7DCTST TRT   2(*-*,WC),0(R14)    *** EXECUTE ONLY ***              R4
CD7DCMV  MVC   CPJQCLS(*-*),2(WC)  **** EXECUTE ONLY ****
CD7DCN   DS    0H                  TRY CANCEL OPTIONS
         CLI   COMVERB,C'C'        TEST FOR CANCEL VERB
         BNE   CD7DA               NO--TRY OTHERS
         OI    COMNULOP,CCJFDUMP   ASSUME DUMP REQUESTED
         CLI   0(WC),C'D'          IS DUMP REQUESTED
         BE    CD7DNL              SKIP NEXT IF SO
         XI    COMNULOP,CCJFPURG+CCJFDUMP ASSUME PURGE
         CLI   0(WC),C'P'          IS PURGE REQUESTED
         BE    CD7DNL              SKIP NEXT IF SO
         XI    COMNULOP,CCJFPURG   SET NO 'PURGE' OPERAND
         B     CD7DNL              NO--MUST BE CANCEL WITH NO OPERND
CD7DA    DS    0H                  CHECK FOR $L'JOBNAME',HOLD
         CLI   COMVERB,C'L'        CHECK FOR $L COMMAND
         BNE   CD7DNL              NO--SKIP REST OF TESTS
         CLI   0(WC),C'H'          TEST FOR LIST HOLD DATA SETS
         BNE   CD7DNL              NO--ASSUME REQ FOR READY D SETS
         OI    COMNULOP,CLJHOLD    SET SWITCH TO LIST HELD DATA SETS
CD7DNL   DS    0H                  NOT $L'JOBNAME',HOLD
         MVC   COMJNAME,=CL8' '    SET JOBNAME TO BLANKS
         BCTR  WC,0                POINT TO END + 1
         BCTR  WC,0                POINT TO END
         MVC   COMFWORK(1),COMVERB SAVE THE VERB
         SR    WD,WD               ZERO QUEUE POINTER
         CLI   0(WC),C''''         DOES OPERAND END WITH APOSTROPHI
         BNE   *+6                 SKIP NSI IF NOT
         BCTR  WC,0                POINT TO END OF NAME
         SR    WC,R1               GET LENGTH OF JOB NAME
         BNP   CD7DINV             IF NOT POSITIVE, ERROR
         BCTR  WC,0                SET MACHINE LENGTH
         LA    R0,7                SET MAXIMUM MACHINE LENGTH
         CR    WC,R0               IS LENGTH TOO LONG
         BNH   *+6                 IF NOT, SKIP
         LR    WC,R0               SET TO MAXIMUM LENGTH
         EX    WC,CA7DMVC          MOVE NAME
CA7DDUP  DS    0H                  RESCAN AFTER DUPLICATE ERROR
         $CFJSCAN PROCESS=CD7DPRO,EMPTY=CD7DNFND,IGNORE=CD7DL,         C
               NEXT=CD7DNXT        SCAN THE JOB QUEUE FOR MATCHING JOBS
         CLI   COMFWORK,C'D'       IS THIS DISPLAY COMMAND
         BNE   CA7DSET             SET FOR XCTL TO ROUTINE
         $CRET ,                   RETURN
CD7DPRO  NULL
         CLC   COMJNAME,JQEJNAME   COMPARE FOR MATCH
         BNE   CD7DL               LOOP IF NO MATCH
         CLI   COMFWORK,C'D'       IS THIS DISPLAY COMMAND
         BNE   CA7DXIT             IF NOT EXIT FOR OTHER COMMANDS
         LR    WC,R1               SAVE CURRENT LOCATION
         L     WB,COMFWORK         SAVE CONTENTS OF COMFWORK         R4
         $CFJMSG JOBQE=(R1),TYPE=CALL  DISPLAY JOB INFO
         ST    WB,COMFWORK         RESTORE COMFWORK                  R4
         $CFJSCAN PROCESS=CD7DCK,NEXT=CD7DCKL,STORE=NO CK CHAIN
CD7DNTFD DS    0H                  CHAIN IS BROKEN
         $CRET MSG='LIST INCOMPLETE'
CD7DCK   CR    WC,R1               HAVE WE MET THE LAST JOB DISPLAYED
         BNE   CD7DCKL             IF NOT, LOOK FURTHER
         CH    R15,COMJQHDS        TEST FOR JOB ON SAME QUEUE
         BNE   CD7DNTFD            NO -- CHAIN IS BROKEN
         B     CD7DNXT             NEXT JOB PLEASE
CD7DNFND MVC   COMMAND(8),COMJNAME MOVE NAME
         MVC   COMMAND+8(14),=C' JOB NOT FOUND' SET EXPLANATION
         $CRET L=22                SEND THE MESSAGE
CD7DINVO L     R1,0(0,WD)          POINT TO OPERAND
CD7DINV  $CFINVO OPERAND=(R1)      ERROR -- EXIT ...
CA7DMVC  MVC   COMJNAME(*-*),1(R1) MOVE NAME
         EJECT
***********************************************************************
*                                                                     *
*        ROUTINE TO CONVERT $A,$C,$E,$H,$P 'JOBNAME' COMMANDS         *
*        TO CORRESPONDING $VJ... COMMANDS                             *
*                                                                     *
***********************************************************************
CA7DXIT  LTR   WD,WD               QUEUE POINTER STILL ZERO
         LR    WD,R1               ASSUME YES
         BZ    CD7DNXT             SIGNAL FOUND AND CONTINUE SCAN
         MVC   COMMAND+12(20),=C' MULTIPLE JOBS FOUND' SET DIAG
         $CWTO L=12+20             SEND MESSAGE
         MVI   COMFWORK,C'D'       CONVERT FLAG TO $D
         B     CA7DDUP             START SCAN ALL OVER
CA7DSET  LR    R1,WD               POINT TO QUEUE ELEMENT
         L     WD,COMFWORK         RESTORE POINTER TO FIRST OPERAND
         LA    WD,0(0,WD)          PURIFY
         $CFVQE  NOK=CD7DINVO      VERIFY OWNERSHIP
         LH    R0,JQEJOBNO         GET JOB NUMBER IN R0
         STH   R0,0(,WD)           SAVE JOB NUMBER AS BOTH
         STH   R0,2(,WD)           HIGH AND LOW BOUNDS
         CLI   COMFWORK,C'T'       TEST FOR SET COMMAND
         BE    CT7DFND             YES--EXIT TO IT
         CLI   COMFWORK,C'O'       CHECK FOR $O COMMAND
         BE    CO7DFND             YES--BR TO $ O PROCESSING
         LR    WF,WD               ELSE TRUNCATE COMMAND
         LA    WC,CA7DTAB          POINT TO ACTION VERB TABLE
         LA    R1,CA7DTABN         SET COUNT AND CLEAR HIGH BYTES
CA7DSCN  CLC   COMFWORK(1),0(WC)   MATCHING VERB
         BE    CA7DFND             IF FOUND EXIT
         LA    WC,3(,WC)           UP TO NEXT ENTRY
         BCT   R1,CA7DSCN          LOOP
         B     CD7DINVO            EXECUTED ON LOGIC ERROR ONLY
CA7DFND  DS    0H                  FOUND JOB
         $QSUSE ,                  ENQUEUE ON SERIAL RESOURCE
         SLR   WB,WB               ZERO OFFSET REGISTER
         L     BASE3,=A(HASPCJB2)  ADDRESS OF GROUP ROUTINE
         ICM   WB,3,1(WC)          PICK UP OFFSET
         ALR   WB,BASE3            POINT TO FUNCTIONAL ENTRY
         B     CAJLOOPA-HASPCJB2(,BASE3) ENTER JOB LIST ROUTINE
CT7DFND  L     BASE3,=A(HASPCJ3A)  ADDRESS OF GROUP CONTROL
         LR    R1,R0               MAKE LOW = HIGH JOB NUMBER        R4
         B     CTJALTER-HASPCJ3A(,BASE3) ENTER $T JOB COMMAND        R4
CO7DFND  DS    0H                  PREPARE TO EXIT TO $O
         L     BASE3,=A(HASPCJB4)  POINT TO SUB-PROCESSOR
         B     COJBEGIN-HASPCJB4(,BASE3)   EXIT
CA7DTAB  DS    0H
         DC    C'A',AL2(CAJ-HASPCJB2)  OFFSET TO RELEASE JOB
         DC    C'C',AL2(CCJ-HASPCJB2)  OFFSET TO CANCEL JOB
         DC    C'E',AL2(CEJ-HASPCJB2)  OFFSET TO RESTART JOB
         DC    C'H',AL2(CHJ-HASPCJB2)  OFFSET TO HOLD JOB
         DC    C'L',AL2(CLJ-HASPCJB2)  OFFSET TO LIST JOB
         DC    C'P',AL2(CPJ-HASPCJB2)  OFFSET TO STOP JOB
CA7DTABN EQU   (*-CA7DTAB)/3       NUMBER OF ENTRIES IN THE TABLE
         SPACE 2
         LTORG ,
         EJECT
HASPCJ3A $COMGRUP TJ,TS,TT         SET BASE NUMBER OR MODIFY
***********************************************************************
*                                                                     *
*        $T    (J,S,T)N -- SET NEW NBR FOR JOBS, STCS, OR TSUS        *
*                                                                     *
*        $T    J1-J2,C=CLASS       -- SET JOB CLASS                   *
*                                                                     *
*        $T    J1-J2,P=(+ OR -)VALUE   -- SET JOB PRIORITY            *
*              +N                      -- INCREMENT CURRENT PRIO      *
*              -N                      -- DECREMENT CURRENT PRIO      *
*              N                       -- SET PRIORITY EXPLICITLY     *
*                                                                     *
*        $T    J1-J2,S=(+ OR -)SID...SID -- SET SYSTEM AFFINITY       *
*              -SID (...SID)             -- DELETE AFFINITIE(S)       *
*              +SID (...SID)             -- ADD AFFINITIE(S)          *
*              SID (...SID)              -- SET AFFINITIE(S) XPLCIT   *
*                                                                     *
***********************************************************************
CTS      NULL                      ENTER HERE FOR STC CHANGE
         CLC   COMVERB(4),=C'TSYS' TEST FOR '$TSYS' COMMAND
         BNE   CTSNOTSY            NO--SKIP NEXT
         LH    R1,=Y(CTSYS-HASPCSY1) PICK-UP OFFSET TO $TSYS COMMAND
         L     BASE3,=A(HASPCSY1)  POINT TO SYSTEM COMMAND PROCESSOR
         ALR   R1,BASE3            COMPUTE ENTRY ADDRESS
         BR    BASE3               ENTER SYSTEM COMMAND PROCESSOR
CTSNOTSY DS    0H                  NOT $TSYS COMMAND
         LH    WA,=H'10000'        SET LOW END FOR STCS
         LA    WB,$STCNO           POINT TO STC BASE
         MVC   COMJNAME(3),=C'STC' SET MESSAGE JOB ID
         B     CTJA                ENTER COMMON ROUTINE
CTT      NULL                      ENTER HERE FOR TSU CHANGE
         LH    WA,=H'20000'        SET LOW END FOR TSUS
         LA    WB,$TSUNO           POINT TO TSU BASE
         MVC   COMJNAME(3),=C'TSU' SET MESSAGE JOB ID
         B     CTJA                ENTER COMMON ROUTINE
CTJ      NULL                      ENTER HERE FOR JOB CHANGE
         SLR   WA,WA               SET LOW END FOR JOBS
         LA    WB,$JOBNO           POINT TO JOB BASE
         MVC   COMJNAME(3),=C'JOB' SET MESSAGE JOB ID
CTJA     $CFCVB POINTER=(WD),NOK=CTJINVO CHANGE NBR TO BINARY
         LTR   R0,R0               TEST FOR GOOD VALUE
         BNP   CTJINVO             NO--ERROR
         ALR   R0,WA               COMPUTE JOB NUMBER
         ALR   R1,WA               COMPUTE JOB NUMBER
         CLR   WD,WF               TEST FOR ALTER A JOB
         BL    CTJALTER            YES--GO TO IT
         $QSUSE ,                  ENQUEUE ON SHARED RESOURCE
         SLR   R0,WA               RESET NUMBER
         ALR   WA,R0               COMPUTE ACTUAL TASK NUMBER
         $CFCVE VALUE=(R0)         CONVERT NUMBER TO EBCDIC
         MVC   COFJNO+(COMJNAME-COFJOB),COMDWORK SET IN MSG
         MVC   COFJOB,COMJNAME     SET REST OF MESSAGE
         BCTR  WA,0                LESS ONE FOR ACTUAL NUMBER
         STH   WA,0(0,WB)          SET NEW BASE
        $POST  $HASPECF,CKPW       $POST CHECKPOINT WRITER          R41
         MVC   COFJNO(14),CTJBM    SET ' NUMBER SET TO'
         MVC   COFJNO+14,COMDWORK  SET JOB NUMBER BASE
         $CRET L=COFJNAME-COFJOB+14 EXIT WITH MESSAGE
CTJBM    DC    C' NUMBER SET TO'   MESSAGE BODY
***********************************************************************
*                                                                     *
*        ALTER A JOB'S CLASS, PRIORITY, OR AFFINITY                   *
*                                                                     *
***********************************************************************
         SPACE 2
CTJALTER DS    0H                  ALTER A JOB' CHARACTERISTICS
         SLL   R1,16               SHIFT INFORMATION                 R4
         LR    WC,R1               COPY LOW BOUND                    R4
         ALR   WC,R0               INCLUDE HIGH BOUND                R4
CTJALTR1 MVI   CTJFLAG,0           SET ALL OPTIONS OFF
CTJLOOP  DS    0H                  LOOP THROUGH OPERANDS
         BXH   WD,WE,CTJEND        LOOP THROUGH ALL OPERANDS
         L     R1,0(,WD)           POINT TO OPERAND
         CLI   1(R1),C'='          CHECK FOR PROPER FORMAT
         BNE   CTJINVO             NO -- ERROR
CTJSELCT DS    0H                  SELECT PROPER BREAK-OUT RTOUTINE
         $CFSEL (C,CTJCLAS),(P,CTJPRIO),(S,CTJSID),OPERAND=(R1)
         SPACE 1
CTJINVO  DS    0H                  INVALID OPERAND ROUTINE
         L     R1,0(,WD)           POINT TO INVALID OPERAND
         $CFINVO OPERAND=(R1)      ISSUE DIAGNOSTIC
         SPACE 3
CTJCLAS  DS    0H                  SET A NEW CLASS
         NI    CTJFLAG,255-CTJCLS  RESET CLASS FOUND FLAG
         L     R15,=A(CVALIDTB)    POINT TO TEST TABLE               R4
         TRT   2(1,R1),0(R15)      VALID CLASS                       R4
         BNZ   CTJINVO             IF INVALID -- ERROR
         SLR   R15,R15             ZERO INSERT REGISTER
         IC    R15,2(,R1)          PICK-UP NEW CLASS
         SL    R15,=A(X'C0')       LESS OFFSET TO CAT                R4
         SLL   R15,5               TIMES CAT ELEMENT SIZE
         AL    R15,$CATABLE        COMPUTE ADDRESS OF CAT ELEMENT
         USING CATDSECT,R15        CAT ADDRESSABILITY
         TM    CATJOBFL,CATVALID   TEST FOR VALID CLASS
         BZ    CTJINVO             NO  --  ERROR
         DROP  R15                 DROP CAT ADDRESSABILITY
         MVC   CTJSVCLS,2(R1)      SAVE GOOD CLASS
         NI    CTJSVCLS,255-X'80'  TURN OFF HIGH BIT                 R4
         OI    CTJFLAG,CTJCLS      SET CLASS OPERAND FOUND
         B     CTJLOOP             AND LOOK FOR MORE OPERANDS
         SPACE 2
CTJPRIO  DS    0H                  SET CHANGE TO JOB(S) PRIORITY
         NI    CTJFLAG,255-(CTJUPRI+CTJDPRI+CTJPRI)  RESET PRI FOUND
         OI    CTJFLAG,CTJUPRI     ASSUME ADDITION TO PRIO
         CLI   2(R1),C'+'          TEST FOR SAME
         BE    CTJCNVT             YES--CONVERT NUMBER
         XI    CTJFLAG,CTJUPRI+CTJDPRI RESET ADD ASSUME SUB
         CLI   2(R1),C'-'          TEST FOR SUBTRACTION
         BE    CTJCNVT             YES--CONVERT NUMBER
         XI    CTJFLAG,CTJDPRI     RESET SUBTRACTION
CTJCNVT  $CFCVB POINTER=(WD),NOK=CTJINVO  CONVERT PRIO
         SLA   R0,4                MULTIPLY BY 16
         CH    R0,*+10             TEST FOR EXCESSION OF MAX PRIO
         BNH   *+8                 NO--LEAVE VALUE AS IS
         LA    R0,255              SET MAX POSSIBLE PRIORITY
         STC   R0,CTJSVPRI         AND SAVE IT FOR LATER
         OI    CTJFLAG,CTJPRI      SET PRIORITY FOUND
         B     CTJLOOP             AND LOOK FOR MORE OPERANDS
         SPACE 2
CTJSID   DS    0H                  EXTRACT NEW AFFINITES FOR JOB(S)
         NI    CTJFLAG,255-(CTJUAFF+CTJDAFF+CTJAFF) RESET AFF FOUND
         MVI   CTJSVSID,0          SET AFFINITY TO 'NONE'
         OI    CTJFLAG,CTJUAFF     ASSUME ADDITION TO AFFINITY
         CLI   2(R1),C'+'          TEST FOR SAME
         BE    CTJSID1             YES--GO EXTRACT REST OF FIELD
         XI    CTJFLAG,CTJUAFF+CTJDAFF ASSUME DELETION OF AFFINITY
         CLI   2(R1),C'-'          TEST FOR SAME
         BE    CTJSID1             YES -- EXTRACT REST OF OPERAND
         XI    CTJFLAG,CTJDAFF     RESET DELETION OF AFFINITIES
         BCTR  R1,0                FAKE EXISTENCE OF '+' OR '-'
CTJSID1  DS    0H                  EXTRACT REST OF AFFINITY OPERAND
         LA    R1,3(,R1)           POINT TO FIRST SID CHARACTER
CTJSID2  DS    0H                  MAJOR LOOP FOR SID SCAN
         CLC   0(3,R1),=C'ANY'     TEST FOR 'ANY' AFFINITY DESIRED
         BNE   CTJSIIND            NO--TEST FOR INDEPENDENT MODE
         OI    CTJSVSID,QUESYSAF   YES -- SET AFFINITY TO 'ANY'
         NI    CTJFLAG,255-(CTJUAFF+CTJDAFF) RESET ADD OR SUB
         B     CTJLPSID            AND EXIT FOR NEXT POSSIBLE SID
CTJSIIND DS    0H                  TEST FOR INDEPENDENT MODE
         CLC   0(3,R1),=C'IND'     IS REQUEST FOR INDEPENDENT MODE
         BNE   CTJSIDM             NO--TRY FOR SPECIFIC SID OPERAND
         OI    CTJSVSID,QUEINDAF   YES -- SET INDEPENDENT MODE
         B     CTJLPSID            AND LOOP FOR MORE SID'S
CTJSIDM  DS    0H                  TRY FOR SPECIFIC SID OPERAND
         L     R14,$QSE1           POINT TO 1ST QSE                  R4
         SH    R14,$QSEL           BACK UP ONE QSE                   R4
         USING QSEDSECT,R14        QSE ADDRESSABILITY
CTJAFFLP DS    0H                  LOOP FOR SID/OPERAND MATCH
         AH    R14,$QSEL           POINT TO NEXT QSE                 R4
         CLC   QSESID,0(R1)        TEST FOR MATCH
         BE    CTJAFFND            FOUND -- FLAG AFFINITY
         TM    QSEFLAGS,QSELAST    TEST FOR LAST ELEMENT
         BZ    CTJAFFLP            AND LOOP TILL FOUND OR ERROR
         B     CTJINVO             ERROR -- OPERAND NOT FOUND
CTJAFFND DS    0H                  SID MATCHED OPERAND
         OC    CTJSVSID,QSESIAFF   FLAG THIS AFFINITY
         SPACE 1
CTJLPSID DS    0H                  LOOP FOR MORE AFFINITIES
         OI    CTJFLAG,CTJAFF      FLAG AFFINITY FOUND
         BXLE  WD,WE,CTJSIDNX      LOOK FOR MORE TO DO
         TM    CTJSVSID,QUEINDAF   IF LAST TEST FOR 'IND 'MODE
         BZ    CTJEND              NO--EXIT OPERAND SCAN
         TM    CTJSVSID,255-QUEINDAF TEST FOR 'IND' WITHOUT OTHER AF
         BNZ   CTJEND              NO--EXIT OPERAND SCAN
         TM    CTJFLAG,CTJUAFF+CTJDAFF TEST FOR '+' OR '-'
         BNZ   CTJEND              'OK' WHEN + OR - IND
         SLR   WD,WE               ELSE ERROR, BACK UP ONE OPERAND
         B     CTJINVO             AND ISSUE DIAGNOSTIC
         SPACE 1
CTJSIDNX DS    0H                  TRY FOR NEXT OPERAND
         L     R1,0(,WD)           PT TO NEXT OPERAND
         CLI   1(R1),C'='          TEST FOR ANOTHER SID
         BE    CTJSELCT            NO -- SELECT NEXT CHANGE
         B     CTJSID2             ELSE ENTER SCAN LOOP
         DROP  R14                 DROP QSE ADDRESSABILITY
         SPACE 2
CTJEND   DS    0H                  END OF OPERANDS
         MVC   CTJFLAG1,CTJFLAG    SAVE OPTIONS
         ST    WC,CTJRANGE         SET JOB RANGES                    R4
         LH    WD,CTJRANGE         PICK UP LOW BOUND                 R4
CTJSCAN  LH    WE,CTJRANGE+2       PICK UP HIGH BOUND                R4
         $QSUSE ,                  ENQUEUE ON SHARED QUEUES
         SLR   R10,R10             ZERO JOB HIT REGISTER
         $CFJSCAN PROCESS=CTJPRO,NEXT=CTJNEXT  SCAN JOB QUEUE
         SPACE 1
         LTR   R1,R10              TEST FOR ANY JOB(S) FOUND
         BZ    CTJNOJOB            NONE--EXIT
         LR    WD,WE               SET NEW HIGHEST NUMBER
         B     CTJCHNG             AND GO MODIFY FOUND JOB
CTJNOJOB DS    0H                  TEST FOR ANY JOB(S) SET
         TM    CTJFLAG,CTJJOB      TEST FOR SAME
         BO    CTJRET              YES--RETURN
         $CRET MSG='NO JOB(S) FOUND'  EXIT EITH DIAGNOSTIC
CTJRET   DS    0H                  RETURN WITH NO DIAGNOSTIC
         $CRET ,                   RETURN
         SPACE 1
CTJUPONE DS    0H                  PICK-UP NEXT NUMBER
         MVC   CTJFLAG,CTJFLAG1    GET OPTIONS FOR NEXT JOB
         LA    WD,1(,WD)           ADD ONE TO FIRST NUMBER
         CH    WD,CTJRANGE+2       ABOVE HIGH BOUND                  R4
         BNH   CTJSCAN             NO--SCAN QUEUE AGAIN
         B     CTJNOJOB            ELSE EXIT $TJ ROUTINE
         SPACE 1
CTJPRO   DS    0H                  JOB FOUND -- TEST IT
         LH    R0,JQEJOBNO         PICK-UP JOB'S NUMBER
         CLR   R0,WD               TEST FOR IN LOW RANGE
         BE    CTJCHNG             EXACT HIT GO CHANGE IT
         BL    CTJNEXT             BELOW RANGE - GET NEXT JOB
         CLR   R0,WE               HIGH--TEST FOR HIGH RANGE
         BH    CTJNEXT             IF HIGHER THAN HIGH-GET NEXT
         LR    R10,R1              IF LOW OR EQUAL SET JOB TO CHANGE
         LR    WE,R0               SET NEW HIGHEST NUMBER
         B     CTJNEXT             AND GET NEXT JOB
         SPACE 1
CTJCHNG  DS    0H                  JOB FOUND TO CHANGE
         OI    CTJFLAG1,CTJJOB     SET JOB FLAG FOUND FLAG
         TM    CTJFLAG,CTJPRI      TEST FOR PRIORITY CHANGE
         BZ    CTJCCLAS            NO--CHECK FOR CLASS CHANGE
         TM    JQEFLAGS,QUEBUSY    TEST FOR JOB BUSY
         BZ    CTJNTPRI            NO--OK TO CHANGE PRIORITY
         NI    CTJFLAG,255-(CTJPRI+CTJUPRI+CTJDPRI) RESET PRI OPTION
         B     CTJCCLAS            AND TRY FOR CLASS CHANGE
CTJNTPRI DS    0H                  CONTINUE WITH PRIORITY CHANGE
         SLR   R0,R0               ZERO CURRENT PRIO REGISTER
         IC    R0,JQEPRIO          GET CURRENT PRIORITY
         SLR   WA,WA               ZERO NEW PRIORITY REGISTER
         IC    WA,CTJSVPRI         PICK-UP NEW PRIORITY
         TM    CTJFLAG,CTJUPRI     TEST FOR ADDITION
         BO    CTJPRIU             YES--ADD NEW TO OLD TO GET NEW
         TM    CTJFLAG,CTJDPRI     TEST FOR SUBTRACTION TO PRIORITY
         BO    CTJPRID             YES-SUB NEW FROM OLD TO GET NEW
         SLR   R0,R0               ELSE SET PRIORITY EXPLICITLY
         B     CTJPRIU             AND ENTER ADDITION RTN
CTJPRID  LNR   WA,WA               SET NEW AS NEGATIVE
CTJPRIU  AR    WA,R0               COMPUTE NEW PRIORITY
         BNM   *+6                 IF NOT NEGATIVE -- OK
         SLR   WA,WA               ELSE SET AS ZERO
         CH    WA,*+10             TEST FOR ABOVE MAX
         BNH   CTJCCLAS            NO--LEAVE AS IS
         LA    WA,255              SET MAX PRIORITY
         SPACE 2
CTJCCLAS DS    0H                  TEST FOR CHANGE TO JOB CLASS
         TM    CTJFLAG,CTJCLS      TEST FOR CLASS CHANGE
         BZ    CTJCAFF             NO TEST FOR CHANGE TO AFFINITY
         TM    JQETYPE,$XEQ        TEST FOR CNVT OR XEQT
         BZ    CTJBDCLS            NO--CAN'T CHANGE CLASS
         TM    JQEFLAGS,QUEBUSY    TEST FOR JOB BUSY IN THESE STAGES
         BNZ   CTJBDCLS            YES -- CAN'T CHANGE CLASS
         CLI   JQETYPE,$XEQ        TEST FOR QUEUED FOR CONVERSION
         BE    CTJBDCLS            YES--CAN'T CHANGE CLASS
         SLR   WB,WB               ZERO NEW CLASS REGISTER
         IC    WB,CTJSVCLS         PICK-UP NEW CLASS
         SLR   R15,R15             ZERO OLD CLASS REGISTER
         IC    R15,JQETYPE         PICK-UP OLD JOB CLASS
         SL    R15,=A(X'40')       SUBTRACT FOR OFFSET TO CAT
         SLL   R15,5               COMPUTE DISPLACEMENT INTO CAT
         AL    R15,$CATABLE        COMPUTE CAT ADDRESS
         SL    WB,=A(X'40')        SUBTRACT FOR CAT
         SLL   WB,5                TIMES CAT SIZE
         AL    WB,$CATABLE         COMPUTE CAT ELEMENT ADDRESS
         TM    CATJOBFL-CATDSECT(R15),CATBATCH  TEST FOR BATCH       R4
         BZ    CTJBDCLS            ERROR IF NOT BATCH                R4
         TM    CATJBOPT-CATDSECT(R15),CATXBACH  TEST FOR XBM         R4
         BO    CTJBDCLS            ERROR IF XBATCH                   R4
         TM    CATJOBFL-CATDSECT(WB),CATBATCH  TEST FOR BATCH        R4
         BZ    CTJBDCLS            ERROR IF NOT BATCH                R4
         TM    CATJBOPT-CATDSECT(WB),CATXBACH  TEST FOR XBM          R4
         BO    CTJBDCLS            ERROR IF XBATCH                   R4
         SLR   WB,WB               CLEAR REGISTER                    R4
         IC    WB,CTJSVCLS         PICK-UP GOOD CLASS
         B     CTJCAFF             AND GO CHANGE AFFINITY POSSIBLY
CTJBDCLS DS    0H                  INVLAID TO CHANGE CLASS
         NI    CTJFLAG,255-CTJCLS  INDICATE NO CLASS CHANGE
         SPACE 2
CTJCAFF  DS    0H                  SET NEW AFFINITY
         TM    CTJFLAG,CTJAFF      TEST FOR AFFINITY CHANGE
         BZ    CTJQMOD             NO--MODIFY ELEMENT POSSIBLY
         CLC   JQEJOBNO,=H'10000'  TEST FOR NORMAL JOB
         BL    CTJNTAFF            YES--OK TO CHANGE AFFINITY
         TM    JQETYPE,$XEQ        TEST FOR STC OR TSU IN XEQ OR CNV
         BO    CTJBDAFF            YES--CAN'T CHANGE AFFINITY
         CLI   JQETYPE,$INPUT      TEST FOR STC OR TSU IN INPUT RDR
         BNE   CTJNTAFF            NO--OK TO CHANGE AFFINITY
CTJBDAFF DS    0H                  CAN'T CHANGE AFFINITY
         NI    CTJFLAG,255-(CTJAFF+CTJUAFF+CTJDAFF) RESET AFF CHANGE
         B     CTJQMOD             AND MODIFY JOB QUEUE ELEMENT
CTJNTAFF DS    0H                  OK TO CHANGE AFFINITY
         MVC   CTJOLDAF,JQEFLAG2   PICK-UP OLD AFFINITIES
         TM    CTJFLAG,CTJUAFF     TEST FOR ADDITION TO AFF
         BO    CTJUPAF             YES--GO DO IT
         TM    CTJFLAG,CTJDAFF     TEST FOR SUBTRACTION TO AFF
         BO    CTJDWAF             YES--GO DO IT
         MVI   CTJOLDAF,0          SET AFFINITY TO 'NONE'
CTJUPAF  OC    CTJOLDAF,CTJSVSID   SET NEW AFFINITIES
         B     CTJQMOD             GO SET NEW JOB CHARACTERISTICS
CTJDWAF  DS    0H                  REQUEST IS TO REMOVE AFFINITIES
         LA    R15,255             SET REGISTER TO ALL BITS 'ON'
         SLR   R0,R0               ZERO INSERT REGISTER
         IC    R0,CTJSVSID         PICK-UP AFFINITIES TO REMOVE
         SLR   R15,R0              COMPUTE BITS TO LEAVE 'ON'
         EX    R15,CTJOFFAF        TURN 'OFF' SELECTED AFFINITIES
         L     R14,$QSE1           POINT TO 1ST QSE                  R4
         SH    R14,$QSEL           BACK UP ONE QSE                   R4
         USING QSEDSECT,R14        QSE ADDRESSABILITY
CTJAFFCK AH    R14,$QSEL           POINT TO NEXT QSE                 R4
         IC    R15,QSESIAFF        PICK UP AFFINITY FOR TEST         R4
         EX    R15,CTJAFFON        TEST FOR IMPOSSIBLE AFFINITY
         BO    CTJQMOD             AFFINITY IS 'OK'
         TM    QSEFLAGS,QSELAST    TEST FOR LAST ELEMENT
         BZ    CTJAFFCK            GO LOOK AGIN
         B     CTJUPAF             NOT FOUND -RESET AFFINITY
CTJOFFAF NI    CTJOLDAF,*-*        **** EXECUTE ONLY ****
CTJAFFON TM    CTJOLDAF,*-*        **** EXECUTE ONLY ****
         DROP  R14                 DROP QSE ADDRESSABILITY
         SPACE 1
CTJQMOD  DS    0H                  SET NEW JOB CHARACTERISTICS
         TM    CTJFLAG,CTJPRI+CTJCLS+CTJAFF TEST FOR ANY CHANGES
         BZ    CTJDISP             NO--DISPLAY JOB ONLY
         TM    CTJFLAG,CTJPRI      TEST FOR PRIORITY CHANGE
         BZ    *+8                 NO--TRY AFFINITY CHANGE
         STC   WA,JQEPRIO          SET NEW PRIORITY
         TM    CTJFLAG,CTJAFF      TEST FOR AFFINITY CHANGE
         BZ    CTJNPOST            NO--TEST FOR $QMOD OR $QCKPT
         MVC   JQEFLAG2,CTJOLDAF   SET NEW AFFINITIES
         $POST $HASPECF,(JOB)      POST FOR JOB CHANGE
         OI    $AQSE,QSEPJOB       CAUSE X SYSTEM POST(S)
CTJNPOST DS    0H                  NO POST REQUIRED
         TM    CTJFLAG,CTJCLS      TEST FOR CLASS CHANGE
         BO    CTJ$QMOD            YES--USE NEW CLASS
         TM    CTJFLAG,CTJPRI      TEST FOR $QMOD OR $QCKTP NEEDED
         BZ    CTJCKPT             NO--CHECKPOINT THE ELEMENT
         SLR   WB,WB               ELSE ZERO CLASS REGISTER
         IC    WB,JQETYPE          PICKUP EXISTING CLASS
CTJ$QMOD DS    0H                  MODIFY JOB QUEUE ELEMENT
         $QMOD (R1),(WB)           ELSE RESET JOB IN QUEUE
         SPACE 1
CTJDISP  $CFJMSG ,                 DISPLAY JOB
         SPACE 1
         B     CTJUPONE            AND GET NEXT JOB
CTJCKPT  DS    0H                  CHECK POINT NEEDED
         $QCKPT (R1)               CHECK POINT MODIFIED JOB
         B     CTJDISP             AND DISPLAY IT
         SPACE 2
*        $TJOB EQUATES
         SPACE 1
CTJOLDAF EQU   COMPNTER,1          OLD AFFINITY SAVE AREA
CTJSVSID EQU   COMPNTER+1,1        NEW AFFINITY SAVE AREA
CTJSVPRI EQU   COMPNTER+2,1        NEW PRIORITY SAVE ATEA
CTJSVCLS EQU   COMPNTER+3,1        NEW CLASS SAVE AREA
CTJFLAG  EQU   COMPNTER+4,1        FLAGS FOR JOB CHANGES
CTJFLAG1 EQU   COMPNTER+5,1        SAVE AREA FOR FLAGS
CTJRANGE EQU   COMPNTER+8,4        JOB RANGES                        R4
*        FLAG DEFINITIONS
CTJCLS   EQU   X'80'               CLASS OPERAND WAS PROVIDED
CTJPRI   EQU   X'40'               PRIORITY OPERAND WAS PROVIDED
CTJUPRI  EQU   X'20'               PRIORITY IS TO BE INCREASED
CTJDPRI  EQU   X'10'               PRIORITY IS TO BE DECREASED
CTJAFF   EQU   X'08'               AFFINITY OPERAND WAS PROVIDED
CTJUAFF  EQU   X'04'               AFFINITY IS TO BE INCREASED
CTJDAFF  EQU   X'02'               AFFINITY IS TO BE DECREASED
CTJJOB   EQU   X'01'               JOB WAS FOUND FLAG
         SPACE 2
         LTORG ,
         EJECT
HASPCJB4 $COMGRUP OJ,OS,OT         DEFINE SUB-PROCESSOR FOR $O CMN
         SPACE 2
***********************************************************************
*                                                                     *
*        $O (J,S,T)N-NN,OPTIONS,Q=SYSOUT CLASS(ES) OF DATA SETS       *
*        CHANGE STATUS OF OUTPUT DATA SETS FOR JOBS, STCS, OR TSUS    *
*        WHERE OPTIONS ARE - CANCEL, RELEASE, OR RELEASE TO A         *
*                            SPECIFIED REMOTE OR LOCAL                *
*        JOB, STC, OR TSU NUMBERS MAY BE SPECIFIED BY RANGE N-NN      *
*        WITH N LESS THAN NN. OPERANDS FOLLOWING THE FIRST MAY        *
*        APPEAR IN ANY ORDER.                                         *
*                                                                     *
* REGISTERS USED -                                                    *
*                                                                     *
*        WB    = ROUTE CODE IF RE-ROUTING IS DESIRED                  *
*        WC    = BEGINNING JOB, STC, OR TSU NUMBER                    *
*        WE    = ENDING JOB, STC, OR TSU NUMBER                       *
*                                                                     *
***********************************************************************
         SPACE 2
COT      DS    0H                  ENTRY FOR $OT COMMAND
         LH    WA,=H'20000'        SET TSU INCREMENT
         B     COJTS               AND ENTER COMMON SECTION
COS      DS    0H                  ENTRY FOR $OS COMMAND
         LH    WA,=H'10000'        SET STC INCREMENT
         B     COJTS               AND ENTER COMMON SECTION
COJ      DS    0H                  ENTRY FOR $OJ COMMAND
         SLR   WA,WA               INDICATE NO INCREMENT FOR JOBS
COJTS    DS    0H                  COMMON SECTION FOR JOB,STC,TSU
         $CFCVB POINTER=(WD),NOK=COJINVOA CONVERT TO BINARY
         LTR   R1,R1               RESULT ZERO                       R4
         BZ    COJINVOA            ERROR IF YES                      R4
         ALR   R1,WA               COMPUTE ACTUAL LOW NUMBER         R4
         ALR   R0,WA               COMPUTE ACTUAL HIGH NUMBER        R4
         STH   R1,0(,WD)           SAVE LOW NUMBER FOR LATER
         STH   R0,2(,WD)           AND HIGH ALSO
         EJECT
***********************************************************************
*                                                                     *
*        SCAN OPERANDS FOR OUTPUT DATA SET ACTION                     *
*                                                                     *
***********************************************************************
COJBEGIN LR    WC,WD               SAVE POINTER TO OPERAND PTRS
        $TIME                      GET CURRENT DATE IN R1           R41
         ST    R1,COJSVCRD         SAVE IT                          R41
COJLOOP  DS    0H                  ENTER OPERAND SCAN LOOP
         BXH   WC,WE,COJOPEND      SCAN TILL END OF OPERANDS
         L     R1,0(,WC)           POINT TO OPERAND
         CLI   1(R1),C'='          TEST FOR POSSIBLE CLASS STRING
         BNE   COJTEST             NO--LOOK FURTHER
         CLI   0(R1),C'Q'          YES -- TEST FOR PROPER FORMAT
         BE    COJCLASS            YES--EXTRACT CLASS STRING
         CLI   0(R1),C'R'          THIS ROUTE CODE                   R4
         BE    COJRMT              BREAK OUT ROUTE CODE IF YES       R4
         CLI   0(R1),C'D'          CUT-OFF DATE SPECIFIED...        R41
         BE    COJDATE             BR IF YES                        R41
         B     COJINVOO            NO--ERROR IN OPERAND
COJTEST  CLI   0(R1),C'C'          IS IT A REQUEST TO CANCEL
         BE    COJCANCL            YES--FLAG CANCEL REQUIRED
COJINVOO DS    0H                  INVALID OPERAND
         LR    WD,WC               COPY OPERAND POINTER
COJINVOA L     R1,0(,WD)           POINT TO INVALID OPERAND
         $CFINVO OPERAND=(R1)      AND DISPLAY IT
         SPACE 2
COJCLASS DS    0H                  EXTRACT SYSOUT CLASSES
         L     R15,4(,WC)          POINT TO NEXT OPERAND
         LA    R15,0(,R15)         CLEAR HI-ORDER FLAG BYTE
         SLR   R15,R1              COMPUTE SIZE OF OPERAND
         SH    R15,=H'4'           COMPUTE MACHINE SIZE
         BM    COJINVOO            NO STRING IF NEGATIVE--ERROR
         CH    R15,*+10            CHECK FOR MAX SIZE
         BNH   *+8                 LESS THAN OR EQ -- OK
         LA    R15,7               ELSE USE MAX OF 8 CHARACTERS
         L     R14,=A(CVALIDTB)    POINT TO TEST TABLE               R4
         EX    R15,COJVALID        TEST FOR ALL VALID CLASSES
         BNZ   COJINVOO            INVALID OPERAND IF INVALID CLASSES
         MVI   COJSVCLS,C' '       BLANK CLASS SAVE AREA
         MVC   COJSVCLS+1(L'COJSVCLS-1),COJSVCLS  DITTO
         EX    R15,COJMVCLS        ELSE MOVE CLASS STRING
         OI    COMNULOP,COJQOP     AND FLAG CLASS STRING EXISTS
         B     COJLOOP             LOOP THROUGH ALL OPERANDS
COJVALID TRT   2(*-*,R1),0(R14)    *** EXECUTE ONLY ***              R4
COJMVCLS MVC   COJSVCLS(*-*),2(R1) **** EXECUTE ONLY ****
         EJECT                                                      R41
COJCANCL DS    0H                  COME HERE FOR CANCEL OPTION
         OI    COMNULOP,COJCNCL    INDICATE HELD DATA SET CANCEL    R41
         B     COJLOOP             LOOP FOR MORE OPERANDS
COJRMT   DS    0H                                                    R4
         LR    WB,WD               SAVE NORMAL SCAN REGISTER         R4
         LR    WD,WC               PUT OPERAND POINTER BACK          R4
         BAL   LINK,COFRTRA        CONVERT RANGES                    R4
         B     COJINVOA            ERROR EXIT               + 0      R4
         CR    R1,R0               SAME ROUTE               + 4      R4
         BNE   COJINVOA            ERROR EXIT                        R4
         LR    WD,WB               RESTORE SCAN REGISTER             R4
         LR    WB,R1               SET ROUTE CODE                    R4
         OI    COMNULOP,COJRTE     SET ROUTE FLAG                    R4
         B     COJLOOP             LOOP FOR MORE                     R4
         SPACE 1                                                    R41
COJDATE  L     WA,4(,WC)           GET POINTER TO NEXT OPERAND      R41
         LA    WA,0(,WA)           CLEAR HIGH-ORDER BYTE            R41
         SLR   WA,R1               ENSURE                           R41
         SH    WA,=H'3'             AT LEAST 1                      R41
         BNP   COJINVOO              AND NOT                        R41
         CH    WA,=H'5'               MORE THAN                     R41
         BH    COJINVOO                5 DIGITS                     R41
         LR    R0,WA               RELOAD VALUE LENGTH              R41
         LR    LINK,R1              AND OPERAND POINTER             R41
         SPACE 1                                                    R41
COJDATVL LA    LINK,1(,LINK)       ENSURE                           R41
         CLI   1(LINK),C'0'         OPERAND                         R41
         BL    COJINVOO              VALUE                          R41
         CLI   1(LINK),C'9'           IS                            R41
         BH    COJINVOO                STRICTLY                     R41
         BCT   R0,COJDATVL              NUMERIC                     R41
         SPACE 1                                                    R41
         BCTR  WA,0                REDUCE FOR EXECUTE               R41
         EX    WA,COJDATPK         CONVERT VALUE TO PACKED DECIMAL  R41
         CH    WA,=H'1'            TEST FORM OF VALUE               R41
         BH    COJYYDDD            BR IF NOT NN (DAYS)              R41
        $TIME  ,                   GET CURRENT DATE IN R1           R41
         SLR   R0,R0               CLEAR R0                         R41
         STM   R0,R1,COMDWORK      STORE PACKED DECIMAL DATE        R41
         CVB   R1,PCER1            CONVERT DAYS TO BINARY           R41
         CVB   R0,COMDWORK         CONVERT DATE TO BINARY           R41
         CLC   PCER1+6(2),COMDWORK+6  CUT-OFF DATE LAST YEAR...     R41
         BL    COJYYOK             BR IF NO                         R41
         LA    R1,1000-365(,R1)    IGNORE DAYS 366 - 999            R41
         MVO   COMDWORK+5(3),COMDWORK+5(1)  ISOLATE CURRENT YEAR    R41
         CVB   LINK,COMDWORK       CONVERT YEAR TO BINARY           R41
         BCTR  LINK,0              BACK UP 1 YEAR                   R41
         N     LINK,=F'3'          TEST FOR LEAP YEAR               R41
         BNZ   COJYYOK             BR IF NO                         R41
         BCTR  R1,0                ACKNOWLEDGE DAY 366              R41
         SPACE 1                                                    R41
COJYYOK  SR    R0,R1               GET CUT-OFF DATE                 R41
         BNM   *+6                 BR IF THIS CENTURY               R41
         SLR   R0,R0               CUT-OFF AT TURN OF CENTURY       R41
         CVD   R0,PCER1            CONVERT RESULT TO PACKED DECIMAL R41
         MVC   COJSVCRD,PCER1+4    STORE CUT-OFF DATE               R41
         OI    COJSVCRD+3,X'0F'    MAKE 'PRINTABLE'                 R41
         B     COJLOOP             BR TO TEST FOR MORE OPERANDS     R41
         EJECT                                                      R41
COJYYDDD CH    WA,=H'4'            TEST FOR YYDDD                   R41
         BNE   COJINVOO            INVALID IF NO                    R41
         MVC   COJSVCRD,PCER1+4    STORE CUT-OFF DATE               R41
         B     COJLOOP             BR TO TEST FOR MORE OPERANDS     R41
         SPACE 1                                                    R41
COJDATPK PACK  PCER1(8),2(*-*,R1)  *** EXECUTE ONLY ***             R41
         SPACE 1                                                    R41
COJOPEND DS    0H                  COME HERE AFTER ALL OPERANDS
         LH    WC,0(,WD)           GET RANGE OF
COJLP    LH    WE,2(,WD)           JOBS TO ACT UPON
         SLR   R10,R10             CLEAR HIT REGISTER
         $CFJSCAN PROCESS=COJJOB,NEXT=COJNXJOB  LOOK FOR JOBS
         LTR   R1,R10              LOOK FOR ANY JOBS IN RANGE
         BZ    COJNOJOB            NO--ISSUE DIAGNOSTIC
         LR    WC,WE               YES--SET NEW FIRST NBR
COJOWNER DS    0H                  CHECK OWNERSHIP OF JOB
         $CFVQE OK=COJOBOK         IS CONSOLE SUBMITTER THE OWNER
COJUPONE LA    WC,1(,WC)           NOT OWNED--GET NEXT
         CH    WC,2(,WD)           CHECK FOR LAST TO HANDLE
         BNH   COJLP               NO--LOOK FOR NEXT JOB
COJNOJOB TM    COMNULOP,COJJOBS    TEST FOR ANY JOBS FOUND
         BO    COJRET              YES--RETURN WITHOUT DIAGNOSTIC
         $CRET MSG='JOB(S) NOT FOUND'
COJJOB   DS    0H                  JOB FOUND
         LH    R0,JQEJOBNO         LOAD JOB NUMBER
         CLR   R0,WC               CHECK VS. DESIRED JOB
         BE    COJOWNER            YES--CHECK OWNERSHIP
         BL    COJNXJOB            OUT OF RANGE--GET NEXT
         CLR   R0,WE               CHECK JOB WITH LAST IN RANGE
         BH    COJNXJOB            HIGH--NEXT JOB
         LR    R10,R1              COPY JQE ADDRESS FOR LATER TEST
         LR    WE,R0               COPY JOB NBR FOR LATER USE
         B     COJNXJOB            AND GET ANOTHER JOB
COJOBOK  DS    0H                  COME HERE WHEN JOB FOUND
         OI    COMNULOP,COJJOBS    FLAG JOB FOUND
         MVI   COMMAND,C' '        CLEAR MSG AREA
         MVC   COMMAND+1(L'COMMAND-1),COMMAND  DITTO
         NI    COMMID+1,X'FE'      TELL HASPCON JOB ID IS SET
         LR    R0,WC               PREPARE TO CONVERT JOB NBR
         MVC   COFJOB,=C'JOB'      ASSUME BATCH JOB
         CH    R0,=H'10000'        TEST FOR SAME
         BL    COJMSGC             COMPLETE MSG IF JOB
         MVC   COFJOB,=C'TSU'      ASSUME TIME SHARING USER
         SH    R0,=H'20000'        TEST FOR TSU
         BNM   COJMSGC             YES--COMPLETE MESSAGE
         AH    R0,=H'10000'        MUST BE SYSTEM CONTROL TASK
         MVC   COFJOB,=C'STC'      ADJUST ID AND NUMBER FOR STC
COJMSGC  DS    0H                  COMPLETE MESSAGE PREFIX
         $CFCVE VALUE=(R0)         CONVERT JOB NUMBER TO EBCDIC
         MVC   COFJNO,COMDWORK     AND PUT SAME IN MSG
         MVC   COFJNAME,JQEJNAME   FINALLY INSERT TASK NAME
***********************************************************************
*                                                                     *
*        GET PSO ELEMENT AND QUEUE IT FOR $O REQUEST                  *
*                                                                     *
***********************************************************************
         SPACE 1
         LH    WF,JQEHLDCT         PICK-UP HOLD DATA SET COUNT
         LTR   WF,WF               TEST FOR ANY
         BZ    COJNOHLD            NO--ISSUE DIAGNOSTIC
         ST    R1,COMEWORK         SAVE JQE ADDRESS
         GETMAIN RC,LV=PSOLNGTH,SP=0  GET STORAGE FOR PSO ELEMENT
         SPACE 1
         LR    WF,R1               PICK-UP STORAGE ADDRESS
         LTR   R15,R15             CHECK FOR STORAGE AVAILABLE
         BNZ   COJNOSTR            NONE--ISSUE DIAGNOSTIC
         USING PSODSECT,WF         PSO ADDRSSSABILITY
         LR    R0,R1               CLEAR                             R4
         LA    R1,PSOLNGTH          PSO                              R4
         MVCL  R0,R14                STORAGE                         R4
         L     R1,COMEWORK         POINT TO JQE                      R4
         OI    PSOFLG1,PSOFHLD+PSOFJOBI+PSOFJOBN  SET PSO FLAGS
         MVC   PSOCRDT,COJSVCRD    SET CUT-OFF DATE IN ELEMENT      R41
         TM    COMNULOP,COJQOP     TEST FOR CLASS STRING
         BZ    *+14                NO--SKIP SETTING SUCH
         OI    PSOFLG1,PSOFCLAS    SET CLASS STRING PROVIDED
         MVC   PSOCLAS,COJSVCLS    SET CLASSES IN ELEMENT
         OI    PSOFLG2,PSOFDONE+PSOF$O  SET PSO FLAGS
         MVC   PSOJOBN,JQEJNAME    SET JOB NAME IN ELEMENT
         MVC   PSOJOBNO,JQEJOBNO   SET JOB NUMBER IN ELEMENT
         TM    COMNULOP,COJCNCL    TEST FOR CANCEL DATA SETS
         BZ    *+12                NO--SET RELEASE
         OI    PSOUFLG,PSOFDELC    SET CANCEL DATA SETS
         B     COJQUEUE            GO QUEUE PSO ELEMENT
         OI    PSOUFLG,PSOFRLSE    SET TO RELEASE DATA SETS
         TM    COMNULOP,COJRTE     TEST FOR RE-ROUTONG DESIRED
         BZ    *+12                NO--SKIP SETTING NEW ROUTE CODE
         STH   WB,PSOROUTE         SET NEW ROUTE CODE
         OI    PSOUFLG,PSOFROUT    AND FLAG AS SUCH
COJQUEUE DS    0H                  ADD ELEMENT TO QUEUE
         LR    R15,WF              SAVE ADDRESS OF ELEMENT
         LA    WF,$OQUEUE-(PSONEXT-PSODSECT) POINT TO ELEMENT
         L     R14,PSONEXT         PT TO NEXT ELEMENT
         LTR   R14,R14             TEST FOR LAST ELEMENT
         BZ    *+10                YES--SET NEW LST ELEMENT
         LR    WF,R14              ELSE PT TO NEXT ELEMENT
         B     *-12                AND LOOP TILL LAST ELEMENT
         ST    R15,PSONEXT         ADD NEW ELEMENT
         DROP  WF                  DROP PSO ADDRESSABILITY
         OI    COMNULOP,COJPSOMD   FLAG REQUEST HONORED
         MVC   COFQUE(21),=C'DATA SETS RELEASED TO'                  R4
         LA    R0,COFQUE+18-COFJOB SET LENGTH FOR NO RE-ROUTING
         TM    COMNULOP,COJCNCL    TEST FOR DATA SETS CANCELLED
         BZ    COJRNCL             NO--TRY FOR RE-ROUTING
         MVC   COFQUE+10(9),=C'CANCELLED' YES--INDICATE SUCH
         LA    R0,COFQUE+19-COFJOB SET MESSAGE LENGTH
         B     COJRES              AND RESPOND TO OPERATOR
COJRNCL  DS    0H                  REQUEST IS NOT TO CANCEL
         TM    COMNULOP,COJRTE     TEST FOR RE-ROUTING
         BZ    COJRES              IF NO RE-ROUTING--RESPOND
         LA    R15,COMFWORK        POINT TO ROUTE CODE FIELD         R4
         STH   WB,COMFWORK         SET ROUTE CODE IN IT              R4
         LA    R0,COFQUE+21        POINT TO TEXT AREA                R4
         BAL   LINK,COFRTC         CONVERT TO PRINTABLE              R4
         LA    R0,COFQUE+21+9-COFJOB SET MESSAGE LENGTH              R4
COJRES   DS    0H                  RESPOND TO THE OPERATOR
         $CWTO L=(R0)
         B     COJUPONE            AND GET NEXT JOB
         B     COJUPONE            GET NEXT JOB
         SPACE 2
*        MESSAGE WHEN JOB HAS NO HELD DATA SETS
         SPACE 1
COJNOHLD DS    0H                  SEND NO HELD DS DIAG
         MVC   COFQUE(17),=C'NO HELD DATA SETS'  FORMAT MESSAGE
         LA    R0,COFQUE+17-COFJOB SET MESSAGE LENGTH
         B     COJRES              RESPOND TO OPERATOR
         SPACE 2
*        MESSAGE NO STORAGE AVAILABLE FOR PSO ELEMEMNT
         SPACE 1
COJNOSTR DS    0H                  NO STORAGE AVAILABLE
        $CRET  MSG='NO STORAGE AVAILABLE'                           R41
         SPACE 2
COJRET   DS    0H                  EXIT $O COMMAND
         TM    COMNULOP,COJPSOMD   TEST FOR ANY PSO ELEMENTS QUEUED
         BZ    COJEXIT             NO--EXIT COMMAND
         L     R15,$PSOPCE         POINT TO PSO PCE                  R4
         $POST (R15),WORK          POST PSO FOR $O WORK
COJEXIT  DS    0H                  EXIT
         $CRET ,                   EXIT $OJ COMMAMD
***********************************************************************
*                                                                     *
*        $O COMMAND EQUATES                                           *
*                                                                     *
***********************************************************************
COJJOBS  EQU   X'80'               FLAG FOR JOBS FOUND
COJPSOMD EQU   X'40'               FLAG FOR PSO ELEMENT ADDED
COJRTE   EQU   X'20'               FLAG FOR RE-ROUTING
COJCNCL  EQU   X'10'               FLAG FOR CANCELLING
COJQOP   EQU   X'08'               FLAG FOR CLASS STRING EXISTS
COJSVCLS EQU   COMJNAME,8          AREA FOR SAVING CLASSES
COJSVCRD EQU   COMREGSV,4          AREA FOR SAVING CUT-OFF DATE     R41
         SPACE 2
         LTORG ,
         TITLE 'HASP COMMAND PROCESSOR HASPCDV1- DEVICE LIST COMMANDS'
HASPCDV1 $COMGRUP  B,C,E,F,I,N,P,S,T,Z,DELAY=YES
***********************************************************************
*                                                                     *
*        DEVICE LISTS ARE OF THE FOLLOWING FORM                       *
*                                                                     *
*        $V DEV1,DEV2,...,DEVN                                        *
*        $V    = HASP COMMAND VERB                                    *
*        DEVX  = DEVICE DESIRED  PRT1,PUN1,RM2.PR1,ETC                *
*                                                                     *
***********************************************************************
         LA    WC,COMPNTER         POINT TO FIRST OPERAND POINTER
         MVI   0(WC),0             INSURE BYTE ZERO
         BXLE  WC,WE,*-4           LOOP
         LR    WC,R1               SAVE SUB-COMMAND OFFSET
CBXDCTL  $CFDCTL POINTER=(WD)      FIND THE DCT
         USING DCTDSECT,R1
         LTR   R1,R1               WAS DCT LOCATED
         BM    CBXRAT              IF NEGATIVE R1 POINTS TO -RAT
         BZ    CBXINVO             IF NOT, INVALID OPERAND
         TM    COMAUTH,CMBFLAGR    CONSOLE REMOTE OWNERSHIP RESTRICTED
         BZR   WC                  IF NOT, ENTER SUB-PROCESSOR
         TM    DCTDEVTP,DCTRJE     MAKE SURE REMOTE CATEGORY
         BZ    CBXINVO             ERROR IF NOT
         CLI   DCTDEVTP,DCTLNE     IS THIS A LINE DCT...            R41
         BE    CBXINVO             BR IF YES (INVALID OPERAND)      R41
         LH    R0,COMJROUT         PICK UP JOB ROUTING OF CONSOLE    R4
         SLR   R15,R15             GET REMOTE                        R4
         IC    R15,COMJRMT          NUMBER LESS 1                    R4
         BCTR  R15,0                 FOR INDEX                       R4
         MH    R15,=Y(RATTLE)      FIND DESIRED                      R4
         AL    R15,$RATABLE         RAT ELEMENT                      R4
         LH    R0,RATROUTE-RATDSECT(,R15) GET RAT ROUTE CODE
CBXCKRT  CH    R0,DCTNO            DEVICE ROUTE MATCH                R4
         BER   WC                  IF OWNER ENTER SUB-PROCESSOR
CBXINVO  L     R1,0(0,WD)          PICK UP OPERAND
         MVC   COMJNAME,=CL8' '    INSURE FIELD AFTER BLANK          R4
         MVC   COMMAND(9),0(R1)    MOVE TEXT                         R4
         MVC   COMMAND+9(16),=C' INVALID OPERAND'                    R4
         LA    R0,25               SET LENGTH
CBXTRUNC $CWTO L=(R0),TRUNC=YES    TRUNCATE MLWTO
         LA    WD,COMPNTER         POINT BACK TO FIRST OP POINTER
CBXTRUNL CLI   0(WD),0             POINTER STILL OPERAND
         BE    CBXTRUNN            TRY NEXT
         ICM   R1,7,1(WD)          PICK UP DCT ADDRESS
         TM    DCTSTAT,DCTINUSE    TEST DRAINED
         BO    CBXTRUNN            SKIP FREE UNIT
         $FREUNIT (R1)             FREE UNIT
CBXTRUNN BXLE  WD,WE,CBXTRUNL      LOOP
CBXTRUND DS    0H                  EXIT DEVICE COMMANDS
         $CRET ,                   EXIT
         SPACE 2                                                    R41
CBXRAT   DS    0H                                                   R41
         LCR   WA,R1               RECOMPLEMENT RAT ADDRESS         R41
         TM    COMAUTH,CMBFLAGR    TEST FOR RMT CONSOLE RESTRICTED  R41
         BZ    CBXRATD             BR IF NO, GO PROCCESS COMMAND    R41
         CLC   COMJROUT,RATCONRT-RATDSECT(WA)  TEST CMD ORIGIN      R41
         BNE   CBXINVO             BR IF NOT THE SAME RMT, INVALID  R41
CBXRATD  CLI   COMVERB,C'S'        TEST COMMAND VERB                R41
         BE    CSXRTER             $S -- ENTER SUBPROCESSOR         R41
         CLI   COMVERB,C'P'        TEST COMMAND VERB                R41
         BE    CPXRMT              $P -- ENTER SUBPROCESSOR         R41
         CLI   COMVERB,C'T'        TEST COMMAND VERB                R41
         BNE   CBXINVO             NOT $T -- INVALID VERB           R41
         CLC   COMDWORK+4(3),=C'CON'  IS THIS $\RN.CON COMMAND      R41
         BNE   CTXRMT              NO, MUST BE $TRMTX COMMAND       R41
         L     R1,=A(CTOR)         POINT TO REMOTE CONSOLE SETTING
         L     BASE3,=A(HASPCSY3)  SET BASE
         BR    BASE3               ENTER PROCESSOR
         EJECT
***********************************************************************
*                                                                     *
*        $B DEV,PAGES -- BACKSPACE DEVICE                             *
*        DEV   = PRINT/PUNCH PROCESSOR OUTPUT DEVICE                  *
*        PAGES = NUMBER OF PAGES TO BACK UP                           *
*              = DS - BACK UP TO START OF DATA SET                    *
*                                                                     *
***********************************************************************
CB       TM    DCTDEVTP,DCTPRPU    IS DEVICE OF CORRECT CLASS
* TEST INCLUDES LOCAL AND REMOTE PRINTER AND PUNCH DEVICES
         BZ    CBXINVO             IF NOT, OPERAND INVALID
         BAL   R14,CTDEVCHK        CHECK FOR ACTIVE DEVICE
         LA    R0,1                SET DEFAULT PAGES TO BK/FWD SP
         BXH   WD,WE,CBXDEF        IF NO PAGE NUMBER ACCEPT DEFAULT
         SLR   R0,R0               ZERO ACCUMULATOR
         ST    R0,COMFWORK         AND WORK AREA
         L     R15,0(0,WD)         PICK UP PARAMETER
         CLI   0(R15),C'D'         IS THIS DATA SET SPACING
         BNE   CBCNVT1             IF NOT, SPACE PAGES
         SLR   R15,R15             SET R15 FOR BK SP DATASET
         CLI   COMVERB,C'F'        SEPARATE $F AND $B
         BNE   CBXDEF              IF $B SET TO BACKSPACE
         BCT   R15,CBXDEF          SET R15 FOR FWDSP DATASET
CBCNVT1  CLI   0(R15),C'0'         LOOK FOR NUMERIC ( FA-FF INCLUDED )
         BL    CBXINVO             ERROR IF NOT NUMERIC
         MH    R0,=H'10'           MULTIPLY BY TEN
         MVN   COMFWORK+1(1),0(R15) MOVE ONE'S DIGIT TO WORK AREA
         AH    R0,COMFWORK         ADD ONE'S DIGIT
         CL    R0,=F'9999'         LOOK FOR MAXIMUM VALUE
         BH    CBXINVO             ERROR IF HIGH
         LA    R15,1(0,R15)        NEXT CHARACTER
         CLI   0(R15),C'0'         TEST FOR END
         BNL   CBCNVT1             LOOP IF NOT END
         LTR   R0,R0               TEST FOR DATASET SPACING
         BZ    CBXNEXT             IGNORE IF ZERO
CBXDEF   L     LINK,DCTPCE         LOCATE PCE                        R4
         LTR   R0,R0               TEST COUNT
         BZ    CBXSET              DATA SET SPACING IF ZERO
         CLI   COMVERB,C'F'        SEPARATE $F FROM $B
         BE    CBXPOSTA            IF FORWARDSPACE SKIP NEXT
         LNR   R0,R0               SET BACKSPACE COUNT
CBXPOSTA L     R15,PDDBPGCT-PCEDSECT(,LINK)  GET CURRENT PAGE NBR
         AR    R15,R0              ADD IN $F/$B COUNT               R41
         BM    CBXBSPD             BR IF SHOULD BE '$BPRT,D'        R41
         C     R15,=F'16777215'    TEST FOR MAX PAGE NUMBER         R41
         BNH   CBXSET              BRANCH IF NO                     R41
         L     R15,=F'16777215'    GET MAX $F PAGE NUMBER           R41
         B     CBXSET              BR TO SET SKIP COUNT             R41
CBXBSPD  SLR   R15,R15             SET FOR '$BPRT,D'                R41
         SLR   R0,R0               SET FOR '$BPRT,D'                R41
CBXSET   ST    R15,PDDBSKIP-PCEDSECT(,LINK) SAVE SKIP COUNT
         ST    R0,PFSBSCT-PCEDSECT(,LINK) SET $F/$B PAGE COUNT      R41
         OI    DCTFLAGS,DCTBKSP    SET INDICATOR
CBXPOST  TM    DCTSTAT,DCTINUSE    TEST FOR DCT ACTIVE
         BZ    CBXNEXT             IF NOT SKIP POST OF DCT'S PCE
         L     R14,DCTPCE          PICK UP PCE ADDRESS               R4
         USING PCEDSECT,R14        TEMPORARY PCE ADDRESSABILITY      R4
         CLI   DCTDEVTP,DCTLOG     TEST FOR LOGON DCT                R4
         BNE   SKIP150             NO--TEST FOR LINE DCT             R4
         OI    MSCANREQ,MSCNSLOG   SET SCAN OF ACTIVE LOGON DCTS     R4
SKIP150  CLI   DCTDEVTP,DCTLNE     TEST FOR LINE DCT                 R4
         BNE   *+24                NO--DO POST                       R4
         TM    MDCTTYPE,DCTPSNA    TEST FOR SNA LINE DCT             R4
         BO    SKIP160             YES--SET SCAN                     R4
         OI    MSCANREQ,MSCNBACT   SET SCAN OF                       R4
         B     *+8                  ACTIVE BSC LINE DCTS             R4
SKIP160  OI    MSCANREQ,MSCNSIDL+MSCNSALL SCAN ACTIVE SNA LINE DCTS  R4
         DROP R14                                                    R4
         $POST (R14),IO            POST PROCESSOR FOR I/O            R4
CBXNEXT  BXLE  WD,WE,CBXDCTL       LOCATE NEXT DCT IF REQUESTED
CBXRET   MVC   COMMAND(2),=C'OK'   SET OK
         LA    R0,2                SET LENGTH
         B     CBXTRUNC            TRUNCATE
         EJECT
***********************************************************************
*                                                                     *
*        $C DEV -- CANCEL ACTIVITY ON DEVICE                          *
*        DEV   = INPUT SERVICE PROCESSOR INPUT DEVICE                 *
*              = PRINT/PUNCH PROCESSOR OUTPUT DEVICE                  *
*                                                                     *
***********************************************************************
CC       TM    DCTDEVTP,DCTRPP     TEST FOR DEVICE CLASS
         BZ    CBXINVO             IF NOT, INVALID OPERAND
         CLI   DCTDEVTP,DCTINR     CHECK FOR INTERNAL RDR
         BE    CBXINVO             INVALID IF INTRDR
         BAL   R14,CTDEVCHK        CHECK FOR ACTIVE DEVICE
* INCLUDES LOCAL AND REMOTE RDRS,ALL PUNCHES AND PRINTERS
         OI    DCTFLAGS,DCTDELET   SET DELETE FLAG
         NI    DCTFLAGS,255-DCTSTOP RESET STOP INDICATOR IF ON
         B     CBXPOST             POST DCT'S PCE FOR I/O
         EJECT
***********************************************************************
*                                                                     *
*        $E DEV -- RESTART CURRENT FUNCTION ON DEVICE                 *
*        DEV   = PRINT/PUNCH PROCESSOR OUTPUT DEVICE                  *
*              = LINE MANAGER TELEPROCESSING DEVICE                   *
*              = LOGON DCT                                            *
*                                                                     *
***********************************************************************
CE       DS    0H                  RESTART DEVICE
         TM    DCTDEVTP,DCTPRPU    TEST FOR PRT/PUN DEVICE
         BO    CEDEVCK             YES--CHECK FOR DEVICE ACTIVE
         CLI   DCTDEVTP,DCTLOG     TEST FOR LOGON DCT                R4
         BE    CEDEVCK             YES--CHECK FOR ACTIVE DCT         R4
         CLI   DCTDEVTP,DCTLNE     TEST FOR RJE LINE
         BNE   CBXINVO             NO--ERROR IN DEVICE
CEDEVCK  BAL   R14,CTDEVCHK        CHECK FOR DEVICE ACTIVE
         TM    DCTDEVTP,DCTPRPU    TEST DCT TYPE                     R4
         BO    CEXGOOD             BRANCH IF NOT LINE                R4
         TM    MDCTTYPE,DCTPSNA    CHECK LINE TYPE                   R4
         BO    CEXPOST             GO POST LNE MGR IF VTAM LINE      R4
         CLI   DCTBUFCT,1          IS LINE I/O ACTIVE
         BNE   CEXGOOD             BRANCH IF NOT
         ST    R1,PCER1            SAVE R1
         L     R15,DCTBUFAD        R15 = TP BUFFER ADDRESS           R4
         USING BUFDSECT,R15        TEMPORARY BUF ADDRESSABILITY      R4
         CLI   IOBECBCC-BUFDSECT(R15),X'48'  HAS I/O PURGED...       R4
         BE    CEXGOOD             BR IF YES                         R4
         L     R1,DCTDCB           R1 = DCB ADDRESS
         MVI   CEPURGE,X'A1'       PREPARE PURGE                     R4
         XC    CEPURGE+4(12),CEPURGE+4  PARM LIST                    R4
         MVC   CEPURGE+1(3),DCBDEBA-IHADCB(R1)  DEB ADDR TO PARMS
         LA    R1,CEPURGE          R1 = ADDRESS OF PURGE PARMS
         PURGE (1)                 ISSUE PURGE
         L     R1,PCER1            RELOAD R1
         L     R15,DCTBUFAD        R15 = TP BUFFER ADDRESS
         CLI   IOBECBCC,X'48'      HAS I/O BEEN PURGED               R4
         BNE   CEXGOOD             BRANCH IF NOT
         L     R0,$RJECHEQ         GET TOP OF RJE BUFFER QUEUE       R4
SKIP170  ST    R0,BUFCHAIN         CHAIN BUFFER TO RJE QUEUE         R4
         CS    R0,R15,$RJECHEQ     ATTEMPT TO UPDATE QUEUE PNTRS     R4
         BNE   SKIP170             RETRY IF UNSUCCESSFUL             R4
CEXPOST  L     R14,$MLLMPCE        GET LINE MANAGER PCE ADDRESS      R4
         $POST (R14),WORK          POST LINE MANAGER FOR WORK        R4
         DROP  R15                 RELEASE TEMPORARY BASE REG        R4
CEXGOOD  OI    DCTFLAGS,DCTRSTRT   TURN ON RESTART FLAG
         NI    DCTFLAGS,255-DCTSTOP CLEAR STOP
         B     CBXPOST             POST I/O
CEPURGE  EQU   $POSTSAV            PURGE PARM LIST                   R4
         EJECT
***********************************************************************
*                                                                     *
*        $F DEV,PAGES -- FORWARDSPACE DEVICE                          *
*        DEV   = PRINT/PUNCH DEVICE                                   *
*        PAGES = NUMBER OF PAGES TO SKIP                              *
*              = DS - SKIP TO END OF DATA SET                         *
*                                                                     *
***********************************************************************
CF       EQU   CB                  COMMON ENTRY WITH BACKSPACE
         EJECT
***********************************************************************
*                                                                     *
*        $I DEV -- INTERRUPT ACTIVITY ON DEVICE                       *
*        DEV   = PRINT/PUNCH DEVICE                                   *
*                                                                     *
***********************************************************************
CI       TM    DCTDEVTP,DCTPRPU    TEST FOR PRT/PUN
         BZ    CBXINVO             IF NOT, ERROR
         BAL   R14,CTDEVCHK        CHECK FOR ACTIVE DEVICE
         OI    DCTFLAGS,DCTBKSP    SET BACKSPACE
         B     CEXGOOD             DO RESTART
         EJECT
***********************************************************************
*                                                                     *
*        $N DEV -- REPEAT CURRENT FUNCTION ON DEVICE                  *
*        DEV   = PRINT/PUNCH PROCESSOR OUTPUT DEVICE                  *
*                                                                     *
***********************************************************************
CN       TM    DCTDEVTP,DCTPRPU    TEST FOR VALID DEVICE GROUP
* TEST INCLUDES PRINTER AND PUNCH DEVICES
         BZ    CBXINVO             IF NOT, INVALID OPERAND
         BAL   R14,CTDEVCHK        CHECK FOR ACTIVE DEVICE
         OI    DCTFLAGS,DCTRPT     SET REPEAT FLAG
         B     CBXPOST             POST I/O
         SPACE 2
***********************************************************************
*                                                                     *
*        ROUTINE TO TEST FOR DEVICE ACTIVE                            *
*                                                                     *
***********************************************************************
         SPACE 2
CTDEVCHK DS    0H                  CHECK FOR DEVICE ACTIVE
         TM    DCTSTAT,DCTINUSE    TEST FOR ACTIVE DEVICE
         BNZR  R14                 YES--RETURN
         MVC   COMREGSV(L'COMMAND),COMMAND SAVE COMMAND OVER $WTO
         MVC   COMMAND(L'DCTDEVN),DCTDEVN SET DEVICE NAME IN MSG
         MVC   COMMAND+L'DCTDEVN(15),=C' NOT ACTIVE ON '  SET MSG
         MVC   COMMAND+L'DCTDEVN+15(L'$SID),$SID  SET SYSTEM ID
         $CWTO L=L'DCTDEVN+15+L'$SID  SEND IT
         MVC   COMMAND,COMREGSV    RESTORE COMMAND TO AREA
         CLI   COMVERB,C'B'        THIS BACKSPACE                    R4
         BE    SKIP180             SKIP NEXT IF YES                  R4
         CLI   COMVERB,C'F'        THIS FORWARD SPACE                R4
         BNE   SKIP190             SKIP NEXT IF NOT                  R4
SKIP180  ALR   WD,WE               FORGET NEXT OPERAND               R4
SKIP190  BXLE  WD,WE,CBXDCTL       AND LOCATE NEXT OPERAND
         B     CBXTRUND            NO--EXIT DEVICE COMMANDS
         EJECT
***********************************************************************
*                                                                     *
*        $P DEV -- STOP DEVICE AFTER THE CURRENT FUNCTION COMPLETES   *
*        DEV   = PRINT/PUNCH PROCESSOR OUTPUT DEVICE                  *
*              = INPUT SERVICE PROCESSOR INPUT DEVICE                 *
*              = LINE MANAGER TELEPROCESSING DEVICE                   *
*              = LOGON DCT                                            *
*                                                                     *
***********************************************************************
CP       NULL
         CLI   DCTDEVTP,DCTINR     TEST FOR INTERNAL READER
         BE    CBXINVO             IF SO REJECT
         OI    DCTSTAT,DCTDRAIN    SET DRAIN FLAG
         TM    DCTSTAT,DCTINUSE    TEST FOR DEVICE NOT ACTIVE
         BNO   CPNIU               PREPARE FOR FREUNIT IF NOT IN USE R4
         L     R14,$MLLMPCE        POINT TO LINE MANAGER PCE         R4
         USING PCEDSECT,R14        TEMPORARY PCE ADDRESSABILITY      R4
         CLI   DCTDEVTP,DCTLOG     TEST FOR LOGON DCT                R4
         BNE   SKIP200             TEST FOR LINE DCT IF NOT          R4
         OI    MSCANREQ,MSCNSLOG   SET SCAN OF ACTIVE SNA LOGON DCTS R4
         B     CPPOST              POST LINE MANAGER                 R4
SKIP200  CLI   DCTDEVTP,DCTLNE     TEST FOR LINE DCT                 R4
         BNE   CBXNEXT             NEXT DCT IF NOT                   R4
         TM    MDCTTYPE,DCTPSNA    TEST FOR SNA LINE DCT             R4
         BNO   CBXNEXT             NEXT DCT IF NOT                   R4
         OI    MSCANREQ,MSCNSALL+MSCNSIDL SCAN ACTIVE SNA LINE DCTS  R4
         DROP  R14                                                   R4
CPPOST   $POST (R14),WORK          POST LINE MANAGER                 R4
         B     CBXNEXT             NEXT DCT                          R4
CPNIU    ST    R1,0(0,WD)          SET DCT ADDRESS IN PLACE OF OP    R4
         MVI   0(WD),X'80'         SET FLAG
         B     CBXNEXT             NEXT DCT
         SPACE 2                                                    R41
CPXRMT   DS    0H                                                   R41
         LCR   WA,R1               RECOMPLEMENT RAT ADDRESS         R41
         NI    RATFLAGS-RATDSECT(WA),255-RATSRMT FORCE $SRMT OFF    R41
         L     R15,RATLDCT-RATDSECT(,WA)  PICK UP LINE DCT ADDRESS  R41
         LTR   R15,R15             TEST LINE DCT ADDRESS            R41
         BZ    CBXNEXT             BRANCH IF NONE, NEXT OPERAND     R41
         OI    MDCTSTAT-DCTDSECT(R15),DCTSOFF  INIDICATE QUIESCE    R41
         B     CBXNEXT             PROCESS NEXT OPERAND             R41
         EJECT                                                      R41
***********************************************************************
*                                                                     *
*        $S DEV -- START DEVICE                                       *
*        DEV   = INPUT SERVICE PROCESSOR DEVICE                       *
*              = PRINT/PUNCH PROCESSOR OUTPUT DEVICE                  *
*              = LINE MANAGER TELEPROCESSING DEVICE                   *
*              = CONSOLE DEVICE                                       *
*                                                                     *
*                                                                     *
***********************************************************************
CS       DS    0H                  START A HASP DEVICE
         CLI   DCTDEVTP,DCTINR     CHECK FOR INTERNAL READER
         BE    CBXINVO             YES--INVALID TO START
         NI    DCTSTAT,255-DCTDRAIN  TURN 'OFF' DRAIN BIT
         TM    DCTDEVTP,DCTRJE     TEST FOR REMOTES
         BZ    SKIP210             SKIP NEXT TESTS IF LOCAL DEVICE   R4
         TM    DCTDEVTP,DCTDEV     CHECK FOR REMOTE DEVICE DCT       R4
         BNZ   CSXRMT              BYPASS ALLOCATION IF YES          R4
         TM    MDCTTYPE,DCTPSNA    TEST LINE OR LOGON TYPE           R4
         BO    CSXRMT              BYPASS ALLOCATION IF VTAM         R4
SKIP210  L     WA,DCTDCB           START TO CHECK FOR REAL DEVICE
         L     R15,DCBDEBAD-IHADCB(,WA)  POSSIBLE
         ICM   R15,3,DEBSUCBA+2-DEBDSECT(R15) NOT POSSIBLE
         BZ    CSXINVU             IF NO UCB POINTER INITIALIZED
         LR    WA,R1               SAVE DCT POINTER OVER ALLOCATE
         $ALLOC (R1),CSXINUSE      ALLOCATE UCB TO HASP DCT
         LR    R1,WA               RELOAD DCT PTR
         NI    DCTSTAT,255-DCTHOLD TURN OFF HOLD BIT
         TM    DCTDEVTP,DCTPRPU    TEST FOR PRT/PUN
         BZ    *+8                 IF NOT DON'T TURN OFF PAUSE BIT
         NI    DCTSTAT,255-DCTPAUSE  PRT/PUN--TURN OFF PAUSE BIT
CSXRMT   DS    0H                  COME HERE FOR REMOTE DEVICES
         NI    DCTFLAGS,255-DCTSTOP  TURN OFF STOP BIT
         CLI   DCTDEVTP,DCTLOG     CHECK FOR LOGON DCT               R4
         BE    SKIP220             YES--POST LINE MANAGER            R4
         CLI   DCTDEVTP,DCTLNE     CHECK FOR RJE LINE
         BNE   CSXNLNE             NO--SKIP POSTING OF MLLM
SKIP220  L     R14,$MLLMPCE        POINT TO RTAMS PCE                R4
         USING PCEDSECT,R14        TEMPORARY PCE ADDRESSABILITY      R4
         OI    MSCANREQ,MSCNUNIT   SCAN INACTIVE LINE AND LOGON DCTS R4
         DROP  R14                 RELEASE TEMPORARY PCE BASE        R4
         $POST (R14),WORK          POST LINE MANAGER FOR WORK        R4
         B     CSXPOST             THEN BR TO $POST JOB AND JOT      R4
         EJECT                                                       R4
CSXNLNE  TM    DCTDEVTP,DCTPRPU+DCTRJE  TEST FOR REMOTE DEVICE      R41
         BO    CSXPOST             BRANCH IF YES, SKIP POST         R41
         TM    DCTSTAT,DCTINUSE    TEST DEVICE STATUS               R41
         BO    CSXPOST             BRANCH IF IN USE, SKIP POST      R41
         L     WA,DCTPCE           GET PCE ADDRESS FROM DCT         R41
        $POST  (WA),WORK            AND INDICATE DEVICE AVAILABLE    R4
CSXPOST $POST  $HASPECF,(JOB,JOT)  $POST ALL FOR JOB AND JOT         R4
         B     CBXPOST             AND EXIT
CSXINVU  DS    0H                  COM HERE WHEN INVALID UNIT
         MVC   COMMAND+L'DCTDEVN(13),=C' INVALID UNIT'  SET MSG
         LA    R0,L'DCTDEVN+13     SET MSG LENGTH
         B     CSXDEVNM            ADD NAME TO MSG AND ISSUE
CSXINUSE DS    0H                  COME HERE IF DEVICE CAN'T BE AL
         LR    R1,WA               RESTORE DCT POINTER
         MVC   COMMAND+L'DCTDEVN(14),=C' NOT AVAILABLE'  SET MSG
         LA    R0,L'DCTDEVN+14     COMPUTE MESSAGE LENGTH
CSXDEVNM MVC   COMMAND(L'DCTDEVN),DCTDEVN  ADD DEVICE NAME
         OI    DCTSTAT,DCTDRAIN    IF NOT ALLOCATED TURN ON DRAIN
         $CRET L=(R0)              AND ISSUE DIAGNOSTIC
CSXRTER  LCR   R1,R1               COMPLEMENT ADDRESS OF RAT        R41
         USING RATDSECT,R1         ESTABLISH ADDRESSABILITY         R41
         TM    RATTYPE,DCTPSNA     TEST FOR REMOTE TYPE             R41
         BZ    CBXINVO             BR IF NOT SNA, INVALID OPERAND   R41
         OI    RATFLAGS,RATSRMT    SET START FLAG IN RAT            R41
         STCK  COMDWORK            STORE CLOCK VALUE                R41
         MVC   RATIMER,COMDWORK     AND PLACE IN RAT                R41
         L     R15,$MLLMPCE        LOAD PROCESSOR ADDRESS           R41
         OI    MSCANREQ-PCEDSECT(R15),MSCNRAT SET SCAN FLAG         R41
         $POST (R15),WORK          POST LINE MANAGER                R41
         B     CBXNEXT             TEST NEXT REMOTE                 R41
         EJECT
CZXNEXT  EQU   CBXNEXT             COMMON ROUTINE ENTRY
CTXINVO  EQU   CBXINVO             COMMON ROUTINE ENTRY
CZXRET   EQU   CBXRET              COMMON ROUTINE ENTRY
***********************************************************************
*                                                                     *
*        $T DEV -- SET DEVICE                                         *
*        DEV   = PRINT/PUNCH PROCESSOR OUTPUT DEVICE                  *
*              = INPUT SERVICE PROCESSOR DEVICE                       *
*              = LINE                                                 *
*                                                                     *
* NOTES                                                               *
*        READER SETTING FORMAT FOLLOWS                                *
*        H= Y/N - SET TO HOLD JOBS READ OR NOT                        *
*        P= DEST - SET DEFAULT PRINT DESTINATION FOR JOBS READ        *
*        U= DEST - SET DEFAULT PUNCH DESTINATION FOR JOBS READ        *
*        A= NUMBER - SET CONSOLE AUTHORITY LEVEL                      *
*        C= CLASS - SET DEFAULT JOB CLASS FOR JOBS READ               *
*        Q= CLASS - SET DEFAULT MSG CLASS FOR JOBS READ               *
*        S= +/- SID,SID,... - SET/ADD/SUBTRACT DEFAULT AFFINITIES     *
*           ANY/IND - SET AFFINITY TO ALL OR INDEPENDANT MODE         *
*                                                                     *
*        PRINTER SETTING FORMAT FOLLOWS                               *
*        B= Y/N FOR BURST/NOBURST ON 3800                             *
*        M= Y/N - EDGE-MARKING BETWEEN UNITS OF 3800 PRINTING OR NOT  *
*        C= CARRAGE TAPE NAME OR FCB IMAGE FROM SYS1.IMAGELIB         *
*        F= FORM OR 'AUTOM'                                           *
*        T= TRAIN NAME 'QN,TN,RN,PN,HN,ETC'                           *
*           OR UCS IMAGE FROM SYS1.IMAGELIB                           *
*           SYSTEM DEFAULT FOR 3800 CHAR SET FROM SYS1.IMAGELIB       *
*        K= 1/2/3/R - FORCE SPACING FOR DATA SET                      *
*        O= FLASH FRAME ID FOR 3800 PRINTERS                          *
*        S= Y/N - PRINT SEPARATORS BETWEEN UNITS OF WORK OR NOT       *
*               - PRINT REMOTE MESSAGES BETWEEN UNITS OF WORK OR NOT  *
*        P= Y/N - LOCAL PRINTER PAUSE BETWEEN UNITS OF WORK OR NOT    *
*        Y= COPY-MODIFICATION RECORD ID FOR 3800 FROM SYS1.IMAGELIB   *
*        Q= LIST OF SYSOUT CLASSES AVAILABLE TO THE PRINTER           *
*        R= NUMBER TO SET ROUTE CODE THIS PRINTER WILL PROCESS        *
*        X1/X2/X3/X4= 3800 CHAR SET ID'S FROM SYS1.IMAGELIB           *
*        Z= NUMBER-SET COMPACTION TABLE NUMBER                        *
*                                                                     *
*                                                                     *
*        PUNCH SETTING FORMAT FOLLOWS                                 *
*        S= Y/N - PUNCH SEPARATORS BETWEEN UNITS OF WORK OR NOT       *
*        P= Y/N - LOCAL PUNCH PAUSE BETWEEN UNITS OF WORK OR NOT      *
*        Q= LIST OF SYSOUT CLASSES AVAILABLE TO THE PUNCH             *
*        R= NUMBER TO SET ROUTE CODE THIS PUNCH WILL PROCESS          *
*        Z= NUMBER-SET COMPACTION TABLE NUMBER                        *
*                                                                     *
*        RJE LINE SETTING FORMAT FOLLOWS                              *
*        E= Y/N - LOG CHANNEL ENDS OR NOT (TESTING MODE ONLY)         *
*        D= QUIESCE/IMMEDIATE TO CAUSE LINE DISCONNECT                *
*        P= PASSWORD OR NULL TO SET OR NULLIFY A PASSWORD             *
*                                                                     *
*        REMOTE DEVICE SETTING FORMAT FOLLOWS                         *
*        A=Y/N SET OR RESET AUTOLOGON FOR SNA DEVICES                 *
*        D=NNN INCREASE OR D INITIALIZATION                           *
***********************************************************************
         SPACE 1                                                     R4
         DROP  R1
         USING DCTDSECT,WA
CT       LR    WA,R1               SAVE DCT POINTER
         MVI   COMNULOP,0          CLEAR FLAG FOR RDI LOOP
         LA    WC,CTXINVO          SET ERROR EXIT ADDRESS
         BXH   WD,WE,CTXINVO       IF NO CORRESPONDING PARAMETER EXIT
CTXLOOP  DS    0H
         L     R1,0(0,WD)          PICK UP OPERAND ADDRESS
         CLI   DCTDEVTP,DCTLNE     IS THIS A LINE SETTING
         BE    CTXLINE             YES--GO CHANGE LINE
         CLI   DCTDEVTP,DCTLOG     IS THIS A LOGON SETTING           R4
         BE    CTXLOG              YES--GO CHANGE LOGON              R4
         TM    DCTDEVTP,DCTRPP     TEST FOR READER/PRINTER/PUNCH
         BZR   WC                  IF NOT, INVALID OPERAND
         CLI   1(R1),C'='          TEST FOR PROPER FORMAT
         BNE   CTXLOOP0            IF NOT, POSSIBLY A 3800 OPERAND   R4
         TM    DCTDEVTP,DCTPRPU    TEST FOR PRINTER/PUNCH
         BZ    CTXRDR              IF NOT, MUST BE READER
         B     CTXLOOP1            IF YES, SKIP 3800 PROCESSNG       R4
CTXLOOP0 TM    DCTPPSW2,DCTNIPRT   TEST FOR 3800 PRINTER             R4
         BNOR  WC                  IF NOT, ERROR                     R4
         CLI   0(R1),C'X'          CHECK FOR 'XN=' FORMAT            R4
         BNER  WC                  IF NOT, ERROR                     R4
         CLI   2(R1),C'='          STILL CHECKING  'XN='             R4
         BNER  WC                  IF NOT, ERROR                     R4
CTXLOOP1 L     WB,4(0,WD)          POINT TO NEXT OPERAND             R4
         SR    WB,R1               GET SIZE OF OPERAND + 1
         SH    WB,=H'4'            GET TEXT MACHINE COUNT
         BMR   WC                  EXIT IN ERROR IF NULL
        $CFSEL (B,CTXB),(C,CTXC),(F,CTXF),(K,CTXK),(M,CTXM),         R4C
               (O,CTXO),(P,CTXP),(Q,CTXQ),(R,CTXR),(S,CTXS),         R4C
               (T,CTXT),(X,CTXX),(Y,CTXY),(Z,CTXZ),OPERAND=(R1),    R41C
               TYPE=CALL                                            R41
         BR    WC                  IF NOT FOUND, INVALID             R4
         EJECT                                                       R4
***********************************************************************
*        SET BURST OPTION FOR 3800 PRINTER                            *
***********************************************************************
CTXB     TM    DCTPPSW2,DCTNIPRT   TEST FOR 3800 PRINTER             R4
         BZR   WC                  ERROR IF NOT                      R4
         CLI   2(R1),C'Y'          TEST FOR 'BURST=YES'              R4
         BNE   CTXBN               IF NOT TRY 'BURST=NO'             R4
         OI    DCTPPSW2,DCTNIBRS   SET BURSTER ON                    R4
         B     CTXLOOPA            GO $POST AND GET NEXT KEYWORD     R4
CTXBN    CLI   2(R1),C'N'          TEST FOR 'BURST=NO'               R4
         BNER  WC                  IF NOT, ERROR                     R4
         NI    DCTPPSW2,255-DCTNIBRS SET BURST FLAG OFF              R4
         B     CTXLOOPA            GO $POST AND GET NEXT KEYWORD     R4
***********************************************************************
*        SET EDGE-MARK OPTION FOR 3800 PRINTER                        *
***********************************************************************
CTXM     TM    DCTPPSW2,DCTNIPRT   TEST FOR 3800 PRINTER             R4
         BZR   WC                  ERROR IF NOT                      R4
         CLI   2(R1),C'Y'          TEST FOR 'MARK=YES'               R4
         BNE   CTXMN               IF NOT TRY 'MARK=NO'              R4
         OI    DCTPPSW2,DCTNIMRK   INDICATE EDGE-MARKING             R4
         B     CTXLOOPC            GET NEXT KEYWORD                  R4
CTXMN    CLI   2(R1),C'N'          TEST FOR 'MARK=NO'                R4
         BNER  WC                  ERROR IF NOT                      R4
         NI    DCTPPSW2,255-DCTNIMRK SET EDGE-MARK FLAG OFF          R4
         B     CTXLOOPC            GET NEXT KEYWORD                  R4
***********************************************************************
*        SET FLASH FRAME ID FOR 3800 PRINTER                          *
***********************************************************************
CTXO     TM    DCTPPSW2,DCTNIPRT   TEST FOR 3800 PRINTER             R4
         BZR   WC                  ERROR IF NOT                      R4
         LA    R15,DCTFLASH        POINT TO FLASH FRAME FIELD        R4
         CLC   2(5,R1),=C'RESET'   TEST FOR FLASH RESET              R4
         BNE   SKIP230             BR IF NOT                         R4
         MVC   0(4,R15),=C'****'   RESET FLASH FRAME ID              R4
         B     CTXLOOPA            GO $POST AND GET NEXT KEYWORD     R4
SKIP230  SLR   R0,R0               CHANGE INDICATOR                  R4
         B     CTXIDVAL            GO CHECK FOR VALID NAME           R4
***********************************************************************
*        SET MODIFY IMAGE FOR 3800 PRINTER                            *
***********************************************************************
CTXY     TM    DCTPPSW2,DCTNIPRT   TEST FOR 3800 PRINTER             R4
         BZR   WC                  ERROR IF NOT                      R4
         LA    R15,DCTMODF         POINT TO MODIFY-IMAGE FIELD       R4
         CLC   2(5,R1),=C'RESET'   TEST FOR MODIFY RESET             R4
         BNE   SKIP240             BR IF NOT                         R4
         MVC   0(4,R15),=C'****'   RESET MODIFY ID                   R4
         B     CTXLOOPC            GET NEXT KEYWORD                  R4
SKIP240  SLR   R0,R0               SET CHANGE INDICATOR              R4
         B     CTXIDVAL            GO CHECK FOR VALID NAME           R4
         EJECT                                                       R4
***********************************************************************
*        SET TRANSLATE TABLE  1,2,3, OR 4 FOR 3800 PRINTER            *
***********************************************************************
CTXX     TM    DCTPPSW2,DCTNIPRT   TEST FOR 3800 PRINTER             R4
         BZR   WC                  ERROR IF NOT                      R4
         LA    R1,1(,R1)           INCR TO NEXT BYTE (CHAR NUMBER)   R4
         SLR   R0,R0               SET CHANGE INDICATOR              R4
         SH    WB,=H'1'            ACCT FOR EXTRA KEYW LGTH          R4
         BMR   WC                  NULL OPERAND SPECIFIED            R4
         LA    R15,DCTCHAR1        POINT TO CHAR SET FIELD           R4
         CLI   0(R1),C'1'          TEST FOR 'X1='                    R4
         BE    CTXIDVAL            BR IF YES                         R4
         LA    R15,DCTCHAR2        POINT TO CHAR SET FIELD           R4
         CLI   0(R1),C'2'          TEST FOR 'X2='                    R4
         BE    CTXIDVAL            BR IF YES                         R4
         LA    R15,DCTCHAR3        POINT TO CHAR SET FIELD           R4
         CLI   0(R1),C'3'          TEST FOR 'X3='                    R4
         BE    CTXIDVAL            BR IF YES                         R4
         LA    R15,DCTCHAR4        POINT TO CHAR SET FIELD           R4
         CLI   0(R1),C'4'          TEST FOR 'X4='                    R4
         BE    CTXIDVAL            BR IF YES                         R4
         BR    WC                  ERROR, INVALID KEYWORD            R4
***********************************************************************
*        SET SEPARATOR OPTION FOR PRINT/PUNCH DEVICE                  *
***********************************************************************
CTXS     CLI   2(R1),C'Y'          TEST FOR 'SEPARATE=YES'           R4
         BNE   CTXSN               IF NOT TRY 'SEPARATE=NO'          R4
         NI    DCTPPSW,255-DCTPPSWS ALLOW SEPARATORS
         B     CTXLOOPA            GO POST AND DO NEXT OPERAND       R4
CTXSN    CLI   2(R1),C'N'          IS THIS SEPARATE = 'NO'
         BNER  WC                  ERROR IF NEITHER
         OI    DCTPPSW,DCTPPSWS    PREVENT SEPARATORS
         B     CTXLOOPA            GO TO NEXT OPERAND                R4
***********************************************************************
*        SET A LOCAL PRINT/PUNCH DEVICE TO PAUSE AFTER EACH JOB       *
***********************************************************************
CTXP     DS    0H                  SET/RESET PAUSE ON DEVICE
         TM    DCTDEVTP,DCTRJE     TEST FOR REMOTE PRT/PUN
         BOR   WC                  IF REMOTE,ERROR TO SET PAUSE
         CLI   2(R1),C'Y'          CHECK FOR SET OF PAUSE
         BE    CTXPAUSE            YES--TURN ON PAUSE BIT
         CLI   2(R1),C'N'          NO--CHECK FOR RESET
         BNER  WC                  NO--ERROR IN COMMAND
         NI    DCTPPFL,255-DCTPAUSE  RESET PAUSE BIT
         B     CTXLOOPC            AND LOOK FOR MORE OPERANDS
CTXPAUSE OI    DCTPPFL,DCTPAUSE    SET PRINT/PUNCH TO PAUSE
         B     CTXLOOPC            AND LOOK FOR MORE OPERANDS
         EJECT                                                       R4
***********************************************************************
*        SET/RESET EXPLICIT SPACING FOR A PRINTER                     *
***********************************************************************
CTXK     NULL                      COME HERE TO SET CARRIAGE SPC
         TM    DCTDEVTP,DCTPUN     TEST FOR PUNCH
         BOR   WC                  YES--INVALID TO SET SPACING
         CLI   2(R1),C'R'          IS THIS A RESET OPERATION
         BE    CTXKRSET            YES--GO HANDLE
         CLI   2(R1),C'3'          NO--CHECK BOUNDS
         BHR   WC                  TRIPLE SPCING IS GREATEST
         CLI   2(R1),C'1'          SINGLE-SPCING IS SMALLEST
         BLR   WC                  ERROR IF LESS THAN
         NI    2(R1),X'03'         TURN 'OFF' ALL ZONE BITS
         IC    R15,2(,R1)          GET READY TO SET SPCING
         NI    DCTFLAGS,255-DCTSPACE FIRST REST PREV SPEC
         EX    R15,CTXKSET         SET SPCING EXPLICITLY
         B     CTXLOOPC            LOOK FOR MORE OPERANDS
CTXKRSET NI    DCTFLAGS,255-DCTSPACE RESET SPACING FLAGS
         B     CTXLOOPC            LOOK FOR MORE OPERANDS
CTXKSET  OI    DCTFLAGS,*-*          **** EXECUTE ONLY ****
***********************************************************************
*        SET TRAIN (UCS) FOR A PRINTER                                *
***********************************************************************
CTXT     LA    R15,DCTUCS          POINT TO UCS TRAIN SETTING
         LA    R0,DCTPPSWT         SET CHANGE INDICATOR
         B     CTXCCTST            TEST FOR INVALID PUNCH
***********************************************************************
*        SET CARRIAGE (FCB) FOR A PRINTER                             *
***********************************************************************
CTXC     LA    R15,DCTFCB          POINT TO FCB CARRIAGE SETTING
         LA    R0,DCTPPSWC         SET CHANGE INDICATOR
         CLC   2(5,R1),=C'RESET'   TEST FOR FCB IMAGE RESET          R4
         BNE   CTXCCTST            BR IF NOT                         R4
         TM    DCTPPSW2,DCTNIPRT   TEST FOR 3800 PRINTER             R4
         BZR   WC                  ERROR IF NOT                      R4
         MVC   0(4,R15),=C'****'   RESET FCB IMAGE ID                R4
         L     R15,DCTPCE          GET ASSOCIATED PCE                R4
         MVC   PRDFCB-PCEDSECT(4,R15),=C'****'  RESET DEFAULT FCB ID R4
         B     CTXLOOPA            GO $POST AND GET NEXT KEYWORD     R4
CTXCCTST TM    DCTDEVTP,DCTPUN     TEST FOR PUNCH DEVICE
         BOR   WC                  BRANCH IN ERROR IF YES
CTXCCT   DS    0H
         TM    DCTPPSW,DCTPPSWO    TEST FOR OPERATOR ACTION ALLOW
         BO    *+8                 BRANCH IF OPERATOR ACTION OK
         BAL   LINK,CTXDEV         CHECK FOR IDLE DEVICE
CTXIDVAL DS    0H                                                    R4
         CH    WB,=H'4'            MOVE NO MORE THAN FOUR
         BNLR  WC                  BRANCH IN ERROR IF TOO LONG
         L     R14,=A(CVALTABL)    POINT TO TEST TABLE               R4
         EX    WB,CTXQVAL          TEST FOR VALID FIELD              R4
         BNZR  WC                  IF INVALID EXIT IN ERROR
         MVC   0(4,R15),=CL4' '    BLANK OUT DCT FIELD               R4
CTXEXMVC EX    WB,CTXMVC           MOVE IN PARAMETER
         LR    WB,R0               GET ACTIVITY FLAG
         EX    WB,CTXOI            TURN ON CHANGE FLAG               R4
         LA    WB,DCTPPSWT         SET UCS INDICATOR           @OZ27012
         CLR   R0,WB               UCS REQUEST                 @OZ27012
         BNE   CTXFCBLD            BR IF NO, TEST FCB          @OZ27012
         NI    DCTPPSW,255-DCTPPSWU RESET NON-STD SWITCH       @OZ27012
         L     R15,DCTPCE          LOAD PRINT PCE ADDR         @OZ27012
         TM    PDEVTYPE+1-PCEDSECT(R15),X'80' TEST UCS         @OZ27012
         BZ    CTXFCBLD            BR IF NOT SUPPORTED         @OZ27012
         TM    DCTPPSW2,DCTNIPRT   3800 PRINTER                @OZ27012
         BO    CTXFCBLD            BRANCH IF YES               @OZ27012
         $GETBUF NOBUF             GET BUFFER FOR IMAGELIB     @OZ27012
         LR    WB,R1               LOAD BUFFER INTO R3         @OZ27012
         USING BUFDSECT,WB         SET BUFFER ADDRESSABILITY   @OZ27012
         ST    R0,COMEWORK         SAVE R0                     @OZ27012
         MVC   BUFSTART(4),=X'0001003A' BLDL PARAMETER LIST    @OZ27012
         MVC   BUFSTART+4(4),=C'UCS1' IMAGE PREFIX-1403 USC    @OZ27012
         MVC   BUFSTART+8(4),DCTUCS USER UCS IMAGE ID          @OZ27012
         L     R15,DCTPCE          LOAD PCE ADDRESS            @OZ27012
         STCM  WA,7,BUFDCT+1       ENSURE CORRECT DCT ADDR     @OZ27012
         CLI   PDEVTYPE+3-PCEDSECT(R15),X'08' IS IT A 1403..   @OZ27012
         BE    CTXUCS01            BRANCH IF YES               @OZ27012
         MVI   BUFSTART+7,C'2'     IMAGE PREFIX FOR 3211 UCS   @OZ27012
CTXUCS01 DS    0H                                              @OZ27012
         TM    $IMAGECB,X'40'      IS IMAGE LOADER TASK BUSY   @OZ27012
         BNO   CTXUCS02            BRANCH IF NO                @OZ27012
         $WAIT IMAG             WAIT FOR IMAGE TASK TO $$POST  @OZ27012
         B     CTXUCS01            TRY AGAIN                   @OZ27012
CTXUCS02 DS    0H                                              @OZ27012
         MVI   BUFECBCC,X'80'      SET BUFFER ECB AS WAITING   @OZ27012
         POST  $IMAGECB,(R3)       POST WITH BUFFER ADDRESS    @OZ27012
CTXUCS03 DS    0H                                              @OZ27012
         $WAIT IMAG             WAIT FOR IMAGE TASK TO $$POST  @OZ27012
         TM    BUFECBCC,X'7F'      TEST STATUS OF LOAD REQ     @OZ27012
         BZ    CTXUCS03            BRANCH IF NOT COMPLETE      @OZ27012
         BM    CTXUCSMS            BR TO NOT FOUND MSG         @OZ27012
         TM    BUFSTART,X'80'      IS IT A STD UCS IMAGE. .    @OZ27012
         BO    CTXUCSEX            BRANCH IF YES               @OZ27012
         OI    DCTPPSW,DCTPPSWU    TURN ON NON-STD SWITCH      @OZ27012
         DROP  WB                  DROP BUFFER ADDRESSIBILITY  @OZ27012
CTXUCSEX $FREEBUF  (WB)            FREE BUFFER                 @OZ27012
         L     R0,COMEWORK         RESTORE R0                  @OZ27012
         B     CTXFCBLD            TRY FCB CHANGE              @OZ27012
CTXUCSNO CLC   $PRTUCS,DCTUCS      REQUESTING STD UCS. . .     @OZ27012
         BE    CTXFCBLD            BRANCH IF YES               @OZ27012
         OI    DCTPPSW,DCTPPSWU    TURN ON NON-STD SWITCH      @OZ27012
CTXFCBLD LA    WB,DCTPPSWC         SET FCB CHANGE INDICATOR    @OZ27012
         CLR   R0,WB               FCB REQUEST. . .            @OZ27012
         BNE   CTXLOOPA            BRANCH IF NOT               @OZ27012
         L     R15,DCTPCE          LOAD PRINT PCE ADDR         @OZ27012
         TM    DCTPPSW2,DCTNIPRT   3800 PRINTER. .             @OZ27012
         BZ    CTXCHUCB            BRANCH IF NOT               @OZ27012
         MVC   PRDFCB-PCEDSECT(,R15),DCTFCB UPDATE 3800 FCB    @OZ27012
         B     CTXLOOPA            POST JOB                    @OZ27012
CTXCHUCB NI    DCTPPSW,255-DCTPPSWB TURN OFF NON=STAND SWITCH  @OZ27012
         CLI   PDEVTYPE+3-PCEDSECT(R15),X'08' IS IT A 1403..   @OZ27012
         BNE   CTXTTE              BRANCH IF NOT 1403          @OZ27012
         CLC   $PRTFCB,DCTFCB      IS IT STD FCB. . .          @OZ27012
         BE    CTXLOOPA            BRANCH IF YES               @OZ27012
         OI    DCTPPSW,DCTPPSWB    TURN ON NON-STD SWITCH      @OZ27012
         B     CTXLOOPA            POST JOB                    @OZ27012
CTXTTE   $GETBUF NOBUF             GET BUFFER FOR FCB READ     @OZ27012
         LR    WB,R1               LOAD R3 WITH BUFF ADDRESS   @OZ27012
         ST    R0,COMEWORK         SAVE R0                     @OZ27012
         USING BUFDSECT,WB         SET BUFFER ADDRESSABILITY   @OZ27012
         MVC   BUFSTART(4),=X'0001003A' BLDL PARAMETER LIST    @OZ27012
         MVC   BUFSTART+4(4),=C'FCB2' IMAGE PREFIX-3211 FCB    @OZ27012
         MVC   BUFSTART+8(4),DCTFCB   USER FCB IMAGE ID        @OZ27012
         L     R15,DCTPCE          LOAD PRINT PCE ADDR         @OZ27012
         STCM  WA,7,BUFDCT+1       ENSURE CORRECT DCT ADDR     @OZ27012
CTXFCB01 DS    0H                                              @OZ27012
         TM    $IMAGECB,X'40'      IS IMAGE LOADER TASK BUSY   @OZ27012
         BNO   CTXFCB02            BRANCH IF NO                @OZ27012
         $WAIT IMAG             WAIT FOR IMAGE TASK TO $$POST  @OZ27012
         B     CTXFCB01            TRY AGIN                    @OZ27012
CTXFCB02 DS    0H                                              @OZ27012
         MVI   BUFECBCC,X'80'      SET BUFFER ECB AS WAITING   @OZ27012
         POST  $IMAGECB,(R3)       POST WITH BUFFER ADDRESS    @OZ27012
CTXFCB03 DS    0H                                              @OZ27012
         $WAIT IMAG             WAIT FOR IMAGE TASK TO $$POST  @OZ27012
         TM    BUFECBCC,X'7F'      TEST STATUS OF LOAD REQ     @OZ27012
         BZ    CTXFCB03            BRANCH IF NOT COMPLETE      @OZ27012
         BM    CTXFCBMS            BRANCH IF IMAGE NOT FOUND   @OZ27012
         TM    BUFSTART,X'80'      TEST FOR STD IMAGE. . .     @OZ27012
         BO    CTXFCBEX            BRANCH IF YES               @OZ27012
         OI    DCTPPSW,DCTPPSWB    TURN ON NON-STD SWITCH      @OZ27012
         DROP  WB                  DROP BUFFER ADDRESSABILITY  @OZ27012
CTXFCBEX $FREEBUF (WB)             FREE BUFFER                 @OZ27012
         L     R0,COMEWORK         RESTORE R0                  @OZ27012
         B     CTXLOOPA            POST JOB                    @OZ27012
CTXQVAL  TRT   2(*-*,R1),0(R14)    *** EXECUTE ONLY ***              R4
CTXMVC   MVC   0(*-*,R15),2(R1)    *** EXECUTE ONLY ***              R4
CTXOI    OI    DCTPPSW,*-*         *** EXECUTE ONLY ***              R4
CTXUCSMS DS    0H                                              @OZ27012
         USING BUFDSECT,WB         GET BUFFER ADDRESSABILITY   @OZ27012
         MVC   BUFSTART(2),=X'000F' MOVE MESSAGE NUMBER        @OZ27012
         MVC   BUFSTART+2(8),DCTDEVN MOVE DEVICE NAME          @OZ27012
         MVC   BUFSTART+10(26),=CL26' UCS  IMAGE XXXX NOT FOUND' Z27012
         MVC   BUFSTART+22(4),DCTUCS MOVE UCS ID               @OZ27012
        $WTO   BUFSTART,36,JOB=NO, ISSUE BUFFER LOAD FAIL MSG  @OZ27012*
               ROUTE=$LOG+$UR,CLASS=$ACTION,PRI=$ST            @OZ27012
         B     CTXUCSEX            EXIT TO GET NEXT PARAMETER  @OZ27012
CTXFCBMS DS    0H                                              @OZ27012
         USING BUFDSECT,WB         GET BUFFER ADDRESSABILITY   @OZ27012
         MVC   BUFSTART(2),=X'000F' MOVE MSG ID                @OZ27012
         MVC   BUFSTART+2(8),DCTDEVN MOVE DEVICE NAME          @OZ27012
         MVC   BUFSTART+10(26),=CL26' FCB  IMAGE XXXX NOT FOUND' Z27012
         MVC   BUFSTART+22(4),DCTFCB MOVE FCB ID               @OZ27012
        $WTO   BUFSTART,36,JOB=NO, ISSUE BUFFER LOAD FAIL MSG  @OZ27012*
               ROUTE=$LOG+$UR,CLASS=$ACTION,PRI=$ST            @OZ27012
         B     CTXFCBEX            BR TO GET NEXT PARAMETER    @OZ27012
NOBUF   $WTO   COMNFCB,COMFCBL,JOB=NO,  BUFFER SHORTAGE MSG    @OZ27012*
               ROUTE=$LOG+$UR,CLASS=$NORMAL,PRI=$ST            @OZ27012
         B     CTXLOOPA            POST JOB                    @OZ27012
COMNFCB  $MSG  000,'NO BUFFERS TO DETERMINE IF STD UCS/FCB'    @OZ27012
COMFCBL  EQU   *-COMNFCB                                       @OZ27012
         EJECT
***********************************************************************
*        SET STRING OF AVAILABLE SYSOUT CLASS(ES) FOR PRT/PUN         *
***********************************************************************
CTXQ     SLR   R15,R15             CHECK                             R4
         IC    R15,$NUMCLAS         FOR                              R4
         CLR   WB,R15                TOO LONG                        R4
         BNLR  WC                  EXIT IF TOO LONG
         L     R14,=A(CVALIDTB)    POINT TO TEST TABLE               R4
         EX    WB,CTXQVALD         CHECK FOR VALID CLASSES
         BNZR  WC                  ERROR IF NOT (A-Z) OR (0-9)
         LA    R14,DCTCLASS        MOVE                              R4
         LA    R0,2(,R1)            CLASS                            R4
         LA    R1,1(,WB)             STRING                          R4
         ICM   R1,8,=C' '             TO                             R4
         MVCL  R14,R0                  DCT                           R4
         B     CTXLOOPA .          GO POST THE JOB
CTXQVALD TRT   2(*-*,R1),0(R14)    *** EXECUTE ONLY ***              R4
***********************************************************************
*        SET ROUTE CODE THIS PRINTER/PUNCH WILL PROCESS               *
***********************************************************************
CTXR     TM    COMFLAG,CMBFLAGW    WAS COMMAND ENTERED FROM REMOTE   R4
         BOR   WC                  ERROR EXIT IF YES                 R4
         BAL   LINK,COFRTRA        CONVERT DESTINATION               R4
         B     0(,WC)              ERROR EXIT               + 0      R4
         CR    R0,R1               SAME                     + 4      R4
         BNER  WC                  ERROR EXIT                        R4
         STH   R0,DCTNO            STORE NEW DEVICE ROUTE CODE
         B     CTXLOOPA            GO $POST JOT, LOOK FOR MORE
***********************************************************************
*        SET FORMS FOR PRINTER OR PUNCH                               *
***********************************************************************
CTXF     LA    R15,DCTFORMS        POINT TO FORMS
         LA    R0,DCTPPSWF         SET OPERATOR CONTROL
         CLC   2(5,R1),=C'AUTOM'   CHECK FOR AUTOMATIC FORMS
         BNE   CTXCCT              FILL IN DATA IF NOT
         NI    DCTPPSW,255-DCTPPSWF ALLOW AUTOMATIC FORMS
* OPERATOR CAN RELINQUISH FORMS CONTROL ANY TIME
CTXLOOPA $POST $HASPECF,(JOB,JOT)  POST JOB AND JOT
CTXLOOPC BXLE  WD,WE,CTXLOOP       GET NEXT OPERAND
         DROP  WA                  DROP DCT ADDRESSABILITY
         LR    WB,WA               PUT DCT IN NON-USED REGISTER
         USING DCTDSECT,WB         DCT ADDRESSABILITY
CTXDISP  $CFDCTD DCT=(WB),EXT=YES,ENTRY=COFDVDSP DISPLAY DEVICE
         SPACE 1
         B     CBXTRUND            AND EXIT $TDEVICE COMMAND
         DROP  WB                  DROP DCT ADDRESSABILITY
         USING DCTDSECT,WA         DCT ADDRESSABILITY
         EJECT                                                       R4
***********************************************************************
*        TEST FOR ACTIVE PRINT/PUNCH DEVICE                           *
***********************************************************************
CTXDEV   TM    DCTSTAT,DCTINUSE    TEST FOR ACTIVE DEVICE
         BZR   LINK                NO -- RETURN 'OK' TO MODIFY
         MVC   COMMAND(8),DCTDEVN  SET NAME
         MVC   COMMAND+8(7),=C' IN USE' MOVE IN DIAGNOSTIC
         $CRET L=15                SEND DIAGNOSTIC AND EXIT
***********************************************************************
*        SET COMPACTION TABLE NUMBER FOR PRT/PUN                      *
***********************************************************************
CTXZ     TM    MDCTFEAT-DCTDSECT(WA),DCTPCPCT TEST IF SUPPORTED     R41
         BZR   WC                  NO, ERROR EXIT                   R41
        $CFCVB POINTER=(WD),NOK=(WC) CONVERT COMPACTION NO TO BIN   R41
         CH    R0,=H'99'           TEST IF COMPACTION NB UNDER 99   R41
         BHR   WC                  NO,ERROR                         R41
         STC   R0,DCTDCPTN         STORE COMPACTION NB IN DCT       R41
         B     CTXLOOPC            LOOK FOR OTHER OPERANDS          R41
         SPACE 1                                                    R41
***********************************************************************
*        PROCESS $TRMTN,A=Y/N,D=NNNN                                  *
***********************************************************************
CTXRMT   DS    0H                                                   R41
         DROP  WA                                                   R41
         USING RATDSECT,WA         RAT ADDRESSABILITY               R41
         LA    WC,CBXINVO          SET ERROR EXIT ADDRESS           R41
         BXH   WD,WE,CBXINVO       IF NO CORRESPONDING PARM, EXIT   R41
CTXRLOOP DS    0H                                                   R41
         L     R1,0(0,WD)          PICK UP OPERAND ADDRESS          R41
         TM    COMFLAG,CMBFLAGR+CMBFLAGS TEST FOR RESTRICTED CNSL   R41
         BNZR  WC                  YES, INVALID TO SET REMOTE       R41
         CLI   1(R1),C'='          CHECK PROPER FORMAT              R41
         BNER  WC                  NO, ERROR                        R41
         $CFSEL (A,CTXRMTA),(D,CTXRMTD)                             R41
         BR    WC                  ERROR, UNKNOWN OPERAND           R41
         SPACE 1                                                    R41
CTXRMTA  DS    0H                                                   R41
         TM    RATTYPE,DCTPLU1     IS THIS AN SNA REMOTE            R41
         BNOR  WC                  NO, ERROR                        R41
         CLI   2(R1),C'Y'          IS THIS A=Y                      R41
         BNE   CTXRMTA1            NO CHECK MORE                    R41
         OI    RATFLAGS,RATALM     YES, INDICATE IN RAT             R41
         STCK  COMDWORK            STORE CLOCK VALUE                R41
         MVC   RATIMER,COMDWORK     AND MOVE INTO RAT               R41
         B     CTXPOSTX            GO POST MLLM                     R41
CTXRMTA1 DS    0H                                                   R41
         CLI   2(R1),C'N'          IS THIS A=N                      R41
         BNER  WC                  NO, ERROR - NEITHER Y OR N       R41
         NI    RATFLAGS,255-RATALM YES, INDICATE IN RAT             R41
         B     CTXPOSTX            GO POST MLLM                     R41
         SPACE 1                                                    R41
CTXRMTD  DS    0H                                                   R41
         $CFCVB POINTER=(WD),NOK=CBXINVO CONVERT D=NNNN             R41
         CH    R0,=H'8160'         CHECK MAX CHANGE                 R41
         BHR   WC                  ERROR IF TOO MUCH                R41
         AH    R0,=H'31'           ROUND TO MULTIPLE OF 32          R41
         SRL   R0,5                DIVIDE BY 32                     R41
         CLI   RATIDINV,X'00'      CHECK FOR NO INTERVAL            R41
         BE    CTXRMTD1            NO INTERVAL, ALLOW MAX CHANGE    R41
         LTR   R0,R0               CHECK FOR ZERO                   R41
         BZR   WC                  YES ERROR                        R41
         CLM   R0,1,RATIDINV       CHECK INTERVAL BEING SET         R41
         BHR   WC                  CANT BE GT INITIAL INTERVAL      R41
CTXRMTD1 STC   R0,RATDINTV         PUT IN RAT                       R41
         B     CTXLOOPX            CHECK IF MORE                    R41
         SPACE 1                                                    R41
CTXPOSTX L     R15,$MLLMPCE        TELL LINE MANAGER ABOUT WORK     R41
         OI    MSCANREQ-PCEDSECT(R15),MSCNRAT  REQUEST RAT SCAN     R41
         $POST (R15),WORK                                           R41
CTXLOOPX DS    0H                                                   R41
         BXLE  WD,WE,CTXRLOOP      LOOP IF MORE OPERANDS            R41
         LNR   R1,WA               LOAD -RAT ADDR FOR DISPLAY       R41
         $CFDCTD DCT=(R1),EXT=SET      DISPLAY RAT INFO             R41
         B     CBXTRUND            RETURN                           R41
         SPACE 2                                                    R41
         DROP  WA                  RELEASE RAT ADDRESSABILITY       R41
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        PROCESS $T READER COMMAND                                    *
*                                                                     *
***********************************************************************
CTXRDR   DS    0H                  CHANGE A READER
         USING DCTDSECT,WA         DCT ADDRESSABILITY               R41
         $CFSEL (A,CTXRDRA),(C,CTXRDRC),(H,CTXRDRH),(P,CTXRDRP),       C
               (Q,CTXRDRQ),(S,CTXRDRS),(U,CTXRDRU)
         BR    WC                  BRANCH IF NOT FOUND
***********************************************************************
*        SET LOCAL CARD READER COMMAND AUTHORITY                      *
***********************************************************************
CTXRDRA  DS    0H                  CHANGE A READERS AUTHORITY
         CLI   DCTDEVTP,DCTRJR     INSURE NOT A REMOTE RDR
         BER   WC                  RMT RDR -- ERROR
         TM    COMFLAG,CMBFLAGU+CMBFLAGT READER CONSOLE              R4
         BZR   WC                  YES-RDR CANNOT SET ANOTHER
         TM    COMAUTH,COMS        CONSOLE LACK SYSTEM AUTHORITY     R4
         BOR   WC                  YES-- ERROR
CTXRDRAA $CFCVB POINTER=(WD),NUM=1,NOK=(WC) CONVERT AUTHORITY
         CH    R0,=H'7'            CHECK FOR MAX AUTH
         BHR   WC                  HIGHER-- ERROR
         OI    DCTRAUTH,COMJDS     RESTRICT RDR COMPLETELY
         LR    R15,R0              GET GOOD REG FOR 'EX'
         EX    R15,CTXSETA         SET NEW AUTHORITY
         BAL   R14,CTXLOOPR        GO TEST FOR INTERNAL RDR CHANGE
         B     CTXLOOPC            AND GET NEXT OPERAND
CTXSETA  XI    DCTRAUTH,*-*        **** EXECUTE ONLY ****
         EJECT                                                       R4
***********************************************************************
*        SET READER'S DEFAULT JOB CLASS                               *
***********************************************************************
CTXRDRC  DS    0H                  CHANGE RDR DEFAULT JOB CLASS
         LA    R15,DCTJCLAS        POINT TO FIELD TO CHANGE
         B     CTXRDRCQ            GO CHECK SOURCE CLASS
***********************************************************************
*        SET READER'S DEFAULT MESSAGE CLASS                           *
***********************************************************************
CTXRDRQ  DS    0H                  CHANGE RDR DEFAULT MSG CLASS
         CLI   DCTDEVTP,DCTINR     INVALID TO SET DEFAULT MSG
         BER   WC                  CLASS FOR INTERNAL READER
         LA    R15,DCTMCLAS        POINT TO FIELD TO CHANGE
CTXRDRCQ DS    0H                  COMMON ROUTINE FOR READER CHANGE
         L     R14,=A(CVALIDTB)    POINT TO TEST TABLE               R4
         TRT   2(L'DCTJCLAS,R1),0(R14) CHECK FOR VALID CLASS         R4
         BNZR  WC                  NO  --  ERROR
         MVC   0(L'DCTMCLAS,R15),2(R1) SET NEW CLASS AS IS IN R15
         BAL   R14,CTXLOOPR        GO TEST FOR INTERNAL READER
         B     CTXLOOPC            AND GET NEXT OPERAND
         SPACE 1
***********************************************************************
*        SET READER TO HOLD/RELEASE INCOMING JOBS                     *
***********************************************************************
CTXRDRH  DS    0H                  SET READER TO HOLD/RELEASE JOBS
         CLI   2(R1),C'N'          TEST FOR RESET HOLD OPTION
         BE    CTXRDRR             YES--GO TO IT
         CLI   2(R1),C'Y'          TEST FOR REQUEST TO HOLD READER
         BNER  WC                  NO--ERROR
         OI    DCTFLAGS,DCTHOLDJ   SET HOLDING BIT 'ON'
         B     CTXRDND             EXIT
CTXRDRR  DS    0H                  RELEASE READER FROM HOLDING JOBS
         NI    DCTFLAGS,255-DCTHOLDJ  RESET HOLDING BIT TO 'OFF'
CTXRDND  DS    0H                  EXIT ROUTINE
         BAL   R14,CTXLOOPR        GO TEST FOR INTERNAL READER
         B     CTXLOOPC            AND GET NEXT OPERAND
***********************************************************************
*        SET DEFAULT SYSTEM AFFINITY FOR READER                       *
***********************************************************************
CTXRDRS  DS    0H                  SET DEFAULT SYSTEM AFFINITY
         LPR   R10,WE              ASSUME ADDITION TO AFFINITY
         CLI   2(R1),C'+'          CHECK FOR SAME
         BE    CTXRSCHG            YES--ADD SELECTED AFFINITIES
         LNR   R10,R10             ASSUME DELETION FROM AFFINITIES
         CLI   2(R1),C'-'          TEST FOR SAME
         BE    CTXRSCHG            YES--FIND AFFINITIES TO DELETE
         SLR   R10,R10             SET NO ADDITION OR DELETION
         BCTR  R1,0                PT BACK ONE FOR NEXT ADDITION
CTXRSCHG DS    0H                  FIND DESIRED AFFINITIES
         MVI   CTXRSIAF,0          SET AFFINITIES TO ZERO
         LA    R1,3(,R1)           POINT TO FIRST SID CHARACTER
CTXRSLP1 DS    0H                  TEST FOR AFFINITY
         CLC   0(3,R1),=C'ANY'     TEST FOR AFFINITY OF 'ANY'
         BNE   CTXRSIND            NO--TRY FOR INDY MODE OPERATION
         OI    CTXRSIAF,QUESYSAF   YES--FLAG ANY AFFINITY
         SLR   R10,R10             SET NO ADDITION OR DELETION
         B     CTXRSLP4            AND TRY FOR MORE OPERANDS
CTXRSIND DS    0H                  TEST FOR INDEPENDENT MODE DESIRED
         CLC   0(3,R1),=C'IND'     TEST FOR 'IND' MODE
         BNE   CTXRSLP2            NO--TRY FOR SPECIFIC SID
         OI    CTXRSIAF,QUEINDAF   YES--SET READER AS SUCH
         B     CTXRSLP4            AND TRY FOR MORE OPERANDS
CTXRSLP2 DS    0H                  TEST FOR SPECIFIC SID GIVEN
         L     R15,$QSE1           POINT TO 1ST QSE                  R4
         SH    R15,$QSEL           BACK UP ONE QSE                   R4
         USING QSEDSECT,R15        QSE ADDRESSABILITY
CTXRSLP3 AH    R15,$QSEL           POINT TO NEXT QSE                 R4
         CLC   QSESID,0(R1)        CHECK FOR MATCH WITH OPERAND      R4
         BE    CTXRSFND            YES--SET AFFINITY AS SUCH
         TM    QSEFLAGS,QSELAST    TEST FOR LAST ELEMENT
         BZ    CTXRSLP3            NOT LAST QSE, LOOP FOR MATCH
         BR    WC                  NOT FOUND -- ERROR
         SPACE 1
CTXRSFND DS    0H                  SID WAS FOUND TO MATCH OPERAND
         OC    CTXRSIAF,QSESIAFF   FLAG THIS AFFINITY
         SPACE 1
CTXRSLP4 BXLE  WD,WE,CTXRSLP5      LOOP THROUGH ALL OPERANDS
         TM    CTXRSIAF,QUEINDAF   IF END TEST FOR 'IND' ON
         BZ    CTXRSFIN            NO--FORGET OTHER TESTS
         TM    CTXRSIAF,255-QUEINDAF TEST FOR 'IND' 'ON' BY ITSELF
         BNZ   CTXRSFIN            OTHERS 'ON' --OK
         LTR   R10,R10             MAKE SURE DESIRE IS 'OFF' OR 'ON'
         BNZ   CTXRSFIN            YES--'OK' AS IS
         SLR   WD,WE               NO--POINT TO BAD OPERAND
         BR    WC                  AND EXIT IN ERROR
CTXRSLP5 DS    0H                  MORE OPERANDS TEST FOR MORE SID'S
         L     R1,0(,WD)           PT TO NEXT OPERAND
         CLI   1(R1),C'='          CHECK FOR NOT SID BUT NEW OPERAND
         BNE   CTXRSLP1            NO--TRY FOR NEXT SID MATCH
CTXRSFIN DS    0H                  SET NEW DEFAULT AFFINITIES
         SLR   WD,WE               POINT BACK TO OPERAND
         LTR   R10,R10             TEST FOR TYPE OF CHANGE
         BM    CTXRSMIN            IF SUBTRACTION  --  BRANCH
         BP    CTXRSPLS            IF ADDITION  --  BRANCH
         MVI   DCTSIAFF,0          SET AFFINITIES TO 'NONE'
CTXRSPLS OC    DCTSIAFF,CTXRSIAF   SET NEW AFFINITIES
         B     CTXRSEND            AND EXIT
CTXRSMIN DS    0H                  REMOVE SELECTED AFFINITIES
         LA    R10,255             SET REGISTER TO ALL BITS 'ON'
         SLR   R0,R0               ZERO INSERT REGISTER
         IC    R0,CTXRSIAF         PICK-UP AFFINITIES TO DELETE
         SLR   R10,R0              COMPUTE BITS TO BE LEFT 'ON'
         EX    R10,CTXRAFOF        DELETE SELECTED AFFINITIES
         L     R15,$QSE1           POINT TO 1ST QSE                  R4
         SH    R15,$QSEL           BACK UP ONE QSE                   R4
CTXRAFLP AH    R15,$QSEL           POINT TO NEXT QSE                 R4
         IC    R10,QSESIAFF        PICK UP AFFINITY BIT              R4
         EX    R10,CTXRAFON        TEST FOR IMPOSSIBLE AFFINITY
         BO    CTXRSEND            NO--EXIT QSE SCAN
         TM    QSEFLAGS,QSELAST    TEST FOR LAST ELEMENT
         BZ    CTXRAFLP            NOT LAST--LOOP THROUGH QSE'S
         OC    DCTSIAFF,CTXRSIAF   RESET AFFINITIES
         BR    WC                  AND EXIT IN ERROR
CTXRSEND DS    0H                  END OF SID CHANGE
         BAL   R14,CTXLOOPR        SET ALL INTERNAL READERS POSSIBLY
         B     CTXLOOPC            AND EXIT FOR NEXT OPERAND
CTXRAFOF NI    DCTSIAFF,*-*        **** EXECUTE ONLY ****
CTXRAFON TM    DCTSIAFF,*-*        **** EXECUTE ONLY ****
         DROP  R15                 DROP QSE ADDRESSABILITY
CTXRSIAF EQU   COMWREGS,1          AFFINITY CREATE AREA
***********************************************************************
*        CHANGE ALL INTERNAL READERS SUBROUTINE                       *
***********************************************************************
CTXLOOPR DS    0H                  SET ALL INTERNAL READERS
         CLI   DCTDEVTP,DCTINR     TEST FOR INTERNAL READER
         BNER  R14                 NO--EXIT
         LR    R15,WA              SAVE BEGINNING ADDRESS
CTXINRLP ICM   WA,7,DCTCHAIN+1     GET NEXT DCT
         BNZ   *+8                 IF NOT LAST TRST FOR INTRDR
         LR    WA,R15              RESET DCT ADDRESS TO FIRST INTRDR
         BR    R14                 AND RETURN
         CLI   DCTDEVTP,DCTINR     TEST FOR STILL INTERNAL READER
         BNE   *-8                 NO--EXIT
         MVC   DCTSIAFF(L'DCTSIAFF+L'DCTRAUTH+L'DCTJCLAS),DCTSIAFF-DCTDC
               SECT(R15)           SET APPRO. FIELDS IN DCT    @OZ29471
         MVC   DCTFLAGS,DCTFLAGS-DCTDSECT(R15)  DITTO
         B     CTXINRLP            AND LOOP FOR MORE INTRDR'S
         SPACE 1
***********************************************************************
*        SET READER'S DEFAULT PRINT/PUNCH DESTINATION(S)              *
***********************************************************************
CTXRDRP  LA    R10,DCTPRINT        SET ADDRESS OF PRINT DESTINATION
         B     *+8                 SKIP
CTXRDRU  LA    R10,DCTPUNCH        SET ADDRESS OF PUNCH DESTINATION
         CLI   DCTDEVTP,DCTINR     IS THIS AN INTERNAL READER        R4
         BER   WC                  ERROR EXIT IF YES                 R4
         BAL   LINK,COFRTRA        CONVERT DESTINATION               R4
         B     0(,WC)              ERROR EXIT               + 0      R4
         CR    R0,R1               SAME                     + 4      R4
         BNER  WC                  ERROR EXIT                        R4
         STH   R0,0(,R10)          STORE NEW PRINT/PUNCH DEST
         B     CTXLOOPC            LOOK FOR ADDITIONAL OPERANDS
***********************************************************************
*        SET LOGON DCT VALUES                                         *
***********************************************************************
CTXLOG   NULL                                                        R4
         TM    COMFLAG,CMBFLAGR+CMBFLAGS TEST FOR RESTRICTED CONSOLE R4
         BNZR  WC                  YES--ILLEGAL TO SET LOGON         R4
         CLI   1(R1),C'='          CHECK FOR VALID OPERAND FORMAT    R4
         BNER  WC                  IF NOT -- ERROR                   R4
         $CFSEL (A,CTXAPPL),(P,CTXLPAS),(E,CTXLLOG)                  R4
         BR    WC                  NO-- ERROR IN COMMAND             R4
***********************************************************************
*        SET LOGON APPLICATION ID                                     *
***********************************************************************
CTXAPPL  LA    WB,MDCTAPPL         PICK UP APPLICATION ID FEILD ADDR R4
         B     CTXLAPAS            GO TO COMMON LINE / LOGON RTN     R4
***********************************************************************
*        SET RJE LINE PASSWORD / LOGGING OPTION                       *
***********************************************************************
CTXLINE  NULL
         TM    COMFLAG,CMBFLAGR+CMBFLAGS TEST FOR RESTRICTED CONSOLE R4
         BNZR  WC                  YES -- INVALID TO SET RJE LNE
         CLI   1(R1),C'='          CHK FOR PROPER FORMAT
         BNER  WC                  IF NOT--ERROR
         $CFSEL (D,CTXLDIS),(E,CTXLLOG),(P,CTXLPAS)                  R4
         BNER  WC                  NO  --  ERROR IN COMMAND
CTXLPAS  LA    WB,MDCTPSWD         PICK UP PASSWORD FIELD ADDR       R4
         EJECT                                                      R41
***********************************************************************
*        SET LINE/LOGN DCT PASSWORD/APPLICATION ID                    *
***********************************************************************
CTXLAPAS MVI   0(WB),C' '          BLANK OUT DCT                     R4
         MVC   1(7,WB),0(WB)         RECEIVING FEILD                 R4
         L     R15,4(,WD)          FIND END OF OPERAND               R4
         SR    R15,R1              COMPUTE OPERAND LENGTH            R4
         SH    R15,=H'4'             LESS 4 FOR KEYWORD AND MACHINE  R4
         BM    CTXLOOPC            RESET VALUE IF NEGATIVE           R4
         CH    R15,*+10            CHECK FOR MAX SIZE
         BNH   *+8                 MOVE IT IF SIZE 'OK'
         LA    R15,8-1             ELSE SUBSTITUTE MAX SIZE          R4
         EX    R15,CTXLMOV         MOVE IN NEW VALUE                 R4
         B     CTXLOOPC            LOOK FOR OTHER OPERANDS
         SPACE 2                                                    R41
CTXLMOV  MVC   0(*-*,WB),2(R1)     **** EXECUTE ONLY ****            R4
         SPACE 3                                                    R41
***********************************************************************
*        SET RJE LINE CHANNEL END LOGGING OPTION                      *
***********************************************************************
CTXLLOG  NULL
         CLI   2(R1),C'Y'          LOG ALL CHNL ENDS
         BE    CTXLOGY             YES--GO DO IT
         CLI   2(R1),C'N'          RESET CHNL END LOGGING
         BNER  WC                  BR IN ERROR IF NEITHER
         NI    DCTFLAGS,255-DCTLOGAL YES--RESET IT                   R4
         B     CTXLOOPC            LOOK FOR ADDITIONAL OPERANDS
CTXLOGY  OI    DCTFLAGS,DCTLOGAL   INDICATE LOG ALL ACTIONS          R4
         B     CTXLOOPC            LOOK FOR ADDITIONAL OPERANDS      R4
         EJECT                                                      R41
***********************************************************************
*        CAUSE RJE LINE DISCONNECT                                    *
***********************************************************************
CTXLDIS  TM    DCTSTAT,DCTINUSE    IS LINE IN USE                    R4
         BZ    CTXLOOPC            BRANCH, IF NOT                    R4
         CLI   2(R1),C'Q'          IS QUIESCE REQUESTED              R4
         BE    CTXLDISQ            BRANCH IF YES                     R4
         CLI   2(R1),C'I'          IS IMMEDIATE REQUESTED            R4
         BNER  WC                  BRANCH IF NEITHER - ERROR         R4
         OI    DCTFLAGS,DCTRSTRT   CAUSE ACTION AT NEXT CHANNEL END  R4
CTXLDISQ OI    MDCTSTAT,DCTSOFF    SET FOR LINE MANAGER DISCONNECT   R4
         TM    MDCTTYPE,DCTPSNA    TEST FOR SNA LINE                 R4
         BZ    CTXLOOPC            NO, SKIP POST                     R4
         L     R14,$MLLMPCE        PICK UP LINE MANAGER PCE ADDRESS  R4
         USING PCEDSECT,R14        SHOW PCE TEMPORARY ADDRESSABILITY R4
         OI    MSCANREQ,MSCNSIDL+MSCNSALL SCAN ACTIVE SNA LINE DCTS  R4
         DROP  R14                                                   R4
         $POST (R14),WORK          POST LINE MANAGER                 R4
         B     CTXLOOPC            LOOK FOR ADDITIONAL OPERANDS      R4
         DROP  WA
         EJECT
         SPACE 4
         USING DCTDSECT,R1
         SPACE 1                                                     R4
***********************************************************************
*                                                                     *
*        $Z DEV -- HALT DEVICE                                        *
*        DEV   = PRINT/PUNCH PROCESSOR OUTPUT DEVICE                  *
*              = INPUT SERVICE PROCESSOR INPUT DEVICE                 *
*                                                                     *
***********************************************************************
CZ       DS    0H                  HALT A DEVICE
         TM    DCTDEVTP,DCTINT     IS THIS AN INTERNAL DEVICE        R4
         BNZ   CTXINVO             INVALID DEVICE OPERAND IF YES     R4
         TM    DCTDEVTP,DCTRPP     IS THIS A RDR,PRTR, OR PUNCH      R4
         BZ    CTXINVO            INVALID DEVICE OPERAND IF NOT      R4
         TM    DCTDEVTP,DCTRJE     IS THIS A REMOTE DEVICE           R4
         BO    CTXINVO            INVALID DEVICE OPERAND IF YES      R4
         BAL   R14,CTDEVCHK        CHECK FOR ACTIVE DEVICE
         OI    DCTFLAGS,DCTSTOP    HALT THE DEVICE IF PRINT/PUNCH
         B     CZXNEXT             GO TO NEXT DEVICE
         DROP  R1
         EJECT                                                      R41
         LTORG ,
 TITLE 'HASP COMMAND PROCESSOR HASPCSY1 - SYSTEM COMMANDS'
HASPCSY1 $COMGRUP DI,PI,SI,TI,ZI,P40,S40,PJES2,VS,ESYS,LSYS,TALL,      C
               TSYS,DELAY=YES      DECLARE SYSTEM COMMANDS PROCESSOR
***********************************************************************
*                                                                     *
*        INITIATOR COMMANDS                                           *
*                                                                     *
*        $D IN -- DISPLAY INITIATOR(S)                                *
*                                                                     *
*        $P IN -- STOP ( DRAIN ) INITIATOR(S)                         *
*                                                                     *
*        $S IN -- START INITIATOR(S)                                  *
*                                                                     *
*        $Z IN -- HALT INITIATOR(S)                                   *
*                                                                     *
*        N     =INITIATOR ID, RANGE OF ID'S, OR ALL IF BLANK          *
*                                                                     *
*        $T IN,LIST -- SET INITIATOR CLASSES                          *
*        N     =INITIATOR ID, RANGE OF ID'S, OR ALL IF BLANK          *
*        LIST  = NEW CLASSES FOR DESIGNATED INITIATOR                 *
*                                                                     *
***********************************************************************
         CLI   COMVERB+1,C'I'      CHECK FOR INITIATOR ACTION
         BNER  R1                  NO--ENTER SUB-PROCESSOR
***********************************************************************
*        SCAN FOR RANGE OF INITIATORS TO ACT UPON                     *
***********************************************************************
         MVI   COMEWORK,X'FF'      FORCE LOW BOUND TO BE SET
         LA    WC,COMOPRND+1       POINT TO FIRST ID CHARACTER
         L     R15,4(0,WD)         POINT TO NEXT OR NULL OPERAND
         BCTR  R15,0               THEN COMMA OR BLANK
         LA    R14,1               SET INCREMENT FOR BXLE
CDIIDS   LR    WB,WC               SAVE STARTING POINT
CDIIDSL  CLI   0(WC),C'-'          CHECK FOR ID SEPARATOR
         BNE   CDIIDSA             SKIP FILL OUT IF NOT SEPARATOR
         SR    WC,WB               GET LENGTH OF ID
         BZ    CDIINVO             ERROR IF NULL
         CH    WC,=Y(L'PITPATID)   CHECK FOR TOO LONG
         BH    CDIINVO             ERROR IF TOO LONG
         LA    R10,COMEWORK        POINT TO TARGET FIELD
         BCT   WC,*+8              REDUCE TO MACHINE LENGTH
         LA    R10,1(,R10)         INSURE ID IS RIGHT-JUSTIFIED
         MVC   COMEWORK(L'PITPATID),=CL(L'PITPATID)' ' INSURE ID BLANK
         EX    WC,CDIIDSMV         MOVE 1ST IDENTIFIER
         LA    WC,2(WC,WB)         POINT TO NEXT CHARACTER TO SCAN
         B     CDIIDS              LOOP FOR OVERIDE OR HIGH ID
CDIIDSA  CLI   0(WC),C''''         INSURE NO APOSTROPHI
         BE    CDIINVO             EXIT IF PRESENT
         BXLE  WC,R14,CDIIDSL      LOOP
         MVC   COMEWORK+L'PITPATID(L'PITPATID),=CL(L'PITPATID)' '
         BCTR  WC,0                BACK-UP TO LAST CHARACTER
         SR    WC,WB               GET LENGTH
         BZ    CDIIDSCK            CHECK FOR ASSENDING
         CH    WC,=Y(L'PITPATID)   CHECK FOR TOO LONG
         BH    CDIINVO             ERROR EXIT
         LA    R10,COMEWORK+L'PITPATID POINT TO TARGET FIELD
         BCT   WC,*+8              REDUCE TO MACHINE LENGTH
         LA    R10,1(,R10)         INSURE ID IS RIGHT-JUSTIFIED
         EX    WC,CDIIDSMV         MOVE 2ND IDENTIFIER
CDIIDSCK CLC   COMEWORK(L'PITPATID),COMEWORK+L'PITPATID ASSENDING
         BL    *+10                SKIP NEXT IF ASSENDING IDS
         MVC   COMEWORK(L'PITPATID),COMEWORK+L'PITPATID  FORCE EQ
         BR    R1                  ENTER FUNCTION SETUP
CDIIDSMV MVC   0(*-*,R10),0(WB)    **** EXECUTE ONLY ****
         SPACE 2
         USING PITDSECT,WB         PROVIDE PIT ADDRESSABILITY
CTI      LA    WC,12               SET OFFSET FOR $TI COMMAND
         B     CDIW                ENTER COMMON ROUTINE
CDI      SR    WC,WC               SET REQUEST OFFSET
         B     CDIW                DO WORK
CPI      LA    WC,4                SET REQUEST OFFSET
         B     CDIW                DO WORK
CSI      LA    WC,8                SET REQUEST OFFSET
         B     CDIW                ENTER COMMON ROUTINE
CZI      LA    WC,16               SET INDEX FOR $ZI COMMAND
CDIW     NULL                      COMMON ROUTINE FOR ALL INIT CMNDS
         L     WB,$PITABLE         POINT TO START OF PITS
         CLI   COMEWORK+1,C' '     CHECK FOR ALL INITS
         BE    CDIALL              YES-BR TO ALL INITS RTN
         SLR   R10,R10             CLEAR HIT REG FOR RANGE SCAN
***********************************************************************
*        ACT UPON ONE OR A RANGE OF INITIATORS                        *
***********************************************************************
CDIONE   BAL   WA,CDIFIXIT         FIX PIT IF REQUIRED
         CLC   COMEWORK(L'PITPATID),PITPATID  CHK PIT VS LOW
         BH    CDIPITLP            IF HIGH CONTINUE SCAN
         CLC   COMEWORK+L'PITPATID(L'PITPATID),PITPATID CHK VS HIG
         BL    CDIPITLP            IF LOW CONTINUE SCAN
         LR    R10,WB              ELSE SAVE PIT IN HIT REG
         EX    0,CDIFUN(WC)        AND PERFORM INDICATED FUNCTION
CDIPITLP ICM   WB,15,PITNEXT       POINT TO NEXT PIT                 R4
         BNZ   CDIONE              BR IF VALID PIT ADDRESS           R4
         LTR   R10,R10             IF LAST--TEST FOR ANY FOUND
         BZ    CDIINVO             IF NOT ERROR IN OPERANDS
         B     CDIXIT(WC)          IF ANY FOUND EXIT PER (WC)
***********************************************************************
*        ACT UPON ALL INITIATORS                                      *
***********************************************************************
CDIALL   BAL   WA,CDIFIXIT         FIX PIT IF REQUIRED
         EX    0,CDIFUNA(WC)       MODIFY ALL INITS
         ICM   WB,15,PITNEXT       POINT TO NEXT PIT                 R4
         BNZ   CDIALL              BR IF VALID PIT ADDRESS           R4
         B     CDIXIT(WC)          FINI--GO TO INDICATED EXIT
CDIINVO  L     R1,0(0,WD)          POINT TO CURRENT OPERAND
         $CFINVO OPERAND=(R1)      EXIT WITH DISPLAY
         SPACE 1
CDIFIXIT TM    PITFLAGS,PITSIVER+PITSIERR WAS A START REJECTED
         BNOR  WA                  RETURN IF NOT
         NI    PITFLAGS,255-(PITSIVER+PITSIERR) RESET FLAGS
         NI    PITSTAT,255-PITINIT RESET INIT STARTED
         OI    PITSTAT,PITHOLD1    SET DRAIN FLAG
         BR    WA                  RETURN
         SPACE 1
*        MULTIPLE INITIATOR FUNCTIONS
         SPACE 1
CDIFUNA  NULL                      MODIFY ALL PITS
         BAL   WA,CDIDIS           DISPLAY ALL PITS        WC = 0
         BAL   WA,CDIPIA           STOP ALL PITS           WC = 4
         NI    PITSTAT,255-(PITHOLDA+PITHALTA) START PITS  WC = 8
         BAL   WA,CDITI            CHANGE ALL PITS         WC = 12
         OI    PITSTAT,PITHALTA    HALT ALL PITS           WC = 16
         SPACE 1
*        SINGLE INITIATOR FUNCTIONS
         SPACE 1
CDIFUN   NULL                      MODIFY A PIT OR RANGE OF PITS
         BAL   WA,CDIDIS           DISPLAY A PIT           WC = 0
         BAL   WA,CDIPI1           SYOP A PIT              WC = 4
         NI    PITSTAT,255-(PITHOLD1+PITHOLDA+PITHALT1+PITHALTA)
         BAL   WA,CDITI            CHANGE A PIT            WC = 12
         OI    PITSTAT,PITHALT1    HALT A PIT              WC = 16
         SPACE 1
***********************************************************************
*        EXIT INITIATOR COMMAND ROUITNES                              *
***********************************************************************
         SPACE 1
CDIXIT   B     CDIRET              EXIT FOR DISPLAY PIT(S) WC = 0
         B     CPIRET              EXIT FOR STOP PIT(S)    WC = 4
         B     CSIRET              EXIT FOR START PIT(S)   WC = 8
         B     CTIRET              EXIT FOR CHANGE PIT(S)  WC = 12
         B     CZIRET              EXIT FOR HALT PIT(S)    WC = 16
CTIRET   $POST $HASPECF,JOB        POST HASP FOR WORK
CZIRET   $CRET MSG=OK              RETURN WITH 'OK' STATUS
CDIRET   $CRET ,                   RETURN WITH NULL MSG--FOR $DI
CPIRET   TM    COMNULOP,CIPOSTX    SEE IF HASP IS TO BE POSTED
         BZ    CZIRET              NO-DON'T POST HASP--RETURN 'OK'
         B     CTIRET              YES-POST HASP--RETURN 'OK'
CSIRET   $POST $HASPECF,JOB        POST JOB
         $CWTO MSG='OK',TRUNC=YES  RESPOND AND PREPARE FOR SVC 34
CSIRETI  L     WB,$PITABLE         LOCATE PITS
         MVC   COMFLAG(14),COMAMASK COPY MASK INTO                   R4
         MVI   COMUCM,X'FF'        INDICATE S INIT SVC 34            R4
         MVC   COMTO,$SYSID        SET OUR SYSTEM                    R4
CSIRETA  TM    PITSTAT,PITINIT     DOES PIT HAVE INIT
         BO    CSIRETN             IF SO GET NEXT PIT
         TM    PITSTAT,PITHOLDA+PITHOLD1 IS PIT DRAINED
         BNZ   CSIRETN             IF SO SKIP START
         OI    PITFLAGS,PITSIVER   SET VERIFICATION REQUIRED
         OI    PITSTAT,PITINIT     INDICATE INIT STARTED
         L     WA,$SSVT            POINT TO THE SSVT
         L     R1,$SVPIDLE-SSVT(,WA)   GET ACTIVE INIT COUNT
         LA    R0,1(,R1)           UP IT BY ONE FOR NEW INIT
         CS    R1,R0,$SVPIDLE-SSVT(WA) SET NEW COUNT -- MAYBE
         BZ    *+8                 GOOD -- ISSUE START COMMAND
         B     *-16                NO--LOOP 'TILL UPDATED
         MVC   COMMAND(14),=C'S INIT.INIT,,,'  SET START INIT
         MVC   COMMAND+14(L'$SVSSNM),$SVSSNM-SSVT(WA) COMMAND
         LA    R0,14+L'$SVSSNM     SET COMMAND LENGTH
         $CWTO L=(R0)              START THE INITIATOR
CSIRETN  ICM   WB,15,PITNEXT       POINT TO NEXT PIT                 R4
         BNZ   CSIRETA             BR IF VALID PIT ADDRESS           R4
         $CRET ,                   RETURN WITH NOTHING
         SPACE 1
***********************************************************************
*        DISPLAY CURRENT STATUS OF AN INITIATOR                       *
***********************************************************************
         SPACE 1
* SET STATUS
CDIDIS   MVC   COMMAND(CDIML),CDIM INSERT MESSAGE PROTOTYPE
         TM    PITSTAT,PITHOLDA+PITHOLD1  TEST FOR DRAIN BITS ON
         BZ    CDINDRN             BR IF NOT DRAINING OR DRAINED
         MVC   CDIMS-CDIM+COMMAND,=CL8'DRAINING' ASSUME DRAINING
         TM    PITSTAT,PITBUSY     TEST FOR PIT IN USE
         BO    CDICLAS             SET CLASSES, PIT (DRAINING)
         MVC   CDIMS-CDIM+COMMAND,=CL8'DRAINED' SET DRAIN
         B     CDICLAS             SET CLASSES, PIT (DRAINED)
CDINDRN  TM    PITSTAT,PITHALTA+PITHALT1 TEST FOR HALT BITS ON
         BZ    CDINHLT             IF NOT, CAN NOT BE HALTED-HALTING
*                                  HALTING TEXT IN PROTOTYPE
         TM    PITSTAT,PITBUSY     TEST FOR PIT IN USE
         BO    CDICLAS             SET CLASSES, PIT (HALTING)
         MVC   CDIMS-CDIM+COMMAND,=CL8'HALTED' SET HALTED
         B     CDICLAS             SET CLASSES, PIT (HALTED)
CDINHLT  MVC   CDIMS-CDIM+COMMAND,=CL8'INACTIVE' ASSUME INACTIVE
         TM    PITSTAT,PITBUSY     TEST FOR PIT IN USE
         BZ    CDICLAS             SET CLASSES, PIT (INACTIVE)
         MVC   CDIMS-CDIM+COMMAND,=CL8'ACTIVE' SET ACTIVE
* SET CLASSES
CDICLAS  SLR   R1,R1               MOVE PIT                          R4
         IC    R1,$MAXCLAS          CLASS                            R4
         BCTR  R1,0                  LIST TO                         R4
         EX    R1,CDIPITCL            MESSAGE                        R4
* SET PIT IDENTIFICATION
         MVC   CDIMI-CDIM+COMMAND,PITPATID SET INIT ID
         TM    PITSTAT,PITBUSY     TEST FOR PIT BUSY
         BO    *+12                YES--SKIP TEST FOR XBM
         TM    PITFLAGS,PITXBM     TEST FOR XEQ BATCHING
         BZ    CDILNGTH            FAILED BOTH TESTS-MSG COMPLETE
         L     R1,PITSJB           POINT TO POSSIBLE SJB
         LA    R1,0(,R1)           CLEAR HIGH-ORDER BYTE
         TM    PITFLAGS,PITXBM     TEST FOR XEQ BATCH MOMITOR
         BZ    CDIJOBNM            NONE--SET POSSIBLE JOB NAME
         MVC   CDIXBM-CDIM+COMMAND,=C'XB'  SET XEQ BATCH MON ID
         TM    PITSTAT,PITHOLD1+PITHOLDA+PITHALT1+PITHALTA
         BNZ   CDIXBMNM            NOT BUSY SET XBM NAME
         TM    PITSTAT,PITBUSY     TEST FOR BUSY
         BO    CDIJOBNM            YES--INSERT XEQ JOB ID
CDIXBMNM MVC   CDINAME-CDIM+COMMAND,SJBXBJNM-SJBDSECT(R1) SET XBM
         B     CDILNGTH            GO SEND MESSAGE
CDIJOBNM MVC   CDINAME-CDIM+COMMAND,SJBJOBID-SJBDSECT(R1) SET JOB
CDILNGTH LA    R0,CDIML            SET MESSAGE LENGTH
         $CWTO L=(R0),RET=(WA)     SEND INIT DISPLAY
         SPACE 2
CDIPITCL MVC   CDIMCLAS-CDIM+COMMAND(*-*),PITCLASS *** EXEC ONLY **  R4
CDIM     DC    CL3' ',CL5'INIT'    MESSAGE PROTOTYPE
CDIXBM   EQU   CDIM,2              AREA FOR XBM IDENTIFIER
CDIMI    DC    CL(L'PITPATID)' ',C' ' INIT ID AND A BLANK
CDIMS    DC    CL8'HALTING',C' '   STATUS OF INIT AND A BLANK
CDINMID  DC    8C'*',CL3' C='      JOB ID AND CLASS PREFIX
CDINAME  EQU   CDINMID,8           AREA FOR JOB OR XBM ID
CDIMCLAS DC    CL36' '             INITIATOR CLASSES                 R4
CDIML    EQU   *-CDIM              LENGTH OF MESSAGE
         SPACE 2
***********************************************************************
*        STOP ALL OR ONE INITIATOR                                    *
***********************************************************************
CDIPIA   NULL                      STOP ALL PITS
         OI    PITSTAT,PITHOLDA    INDICATE PIT STOPPED BY 'ALL' CMND
         B     *+8                 BR ARND STOP SINGLE
CDIPI1   OI    PITSTAT,PITHOLD1    STOP A PIT --$PIN CMND
         L     R15,$SSVT           LOCATE THE SSVT
         OI    $SVJOB-SSVT(R15),X'80'  FLAG INIT DRAINED FOR XEQ
         TM    PITSTAT,PITBUSY     TEST FOR $POST OF HASP NECESSARY
         BNZR  WA                  INIT BUSY--NOT NEEDED
         OI    COMNULOP,CIPOSTX    INIT IDLE--POST OF HASP IS NECESSARY
         BR    WA                  RETURN
         EJECT                                                       R4
***********************************************************************
*        CHANGE THE CLASS STRING OF AN INITIATOR                      *
***********************************************************************
         SPACE 1
CDITI    NULL                      CHANGE A CLASS STRING OF A PIT
         CLR   WD,WF               CHECK FOR PRESENCE OF OPERAND
         BNL   CDIINVO             NO THER -- ERROR
         L     R1,4(,WD)           POINT TO START OF CLS STRING
         L     R15,8(,WD)          POINT TO END OF CLS STRING
         SR    R15,R1              COMPUTE STRING SIZE + 1
         BNP   CDIINVO             ERROR IF NULL
         BCT   R15,*+8             REDUCE TO TRUE LENGTH
         B     CDIINVO             ERROR IF ZERO
         CLM   R15,1,$MAXCLAS      CHECK FOR MAXIMUM SIZE            R4
         BNH   *+8                 OK -- FORGET USING MAXIMUM SIZE
         IC    R15,$MAXCLAS        HIGH -- USE MAXIMUM SIZE          R4
         BCTR  R15,0               REDUCE BY 1 FOR MACHINE LENGTH
         L     R14,=A(CVALIDTB)    POINT TO TEST TABLE               R4
         EX    R15,CTIVALID        CHECK STRING VS VALID ONES
         BNZ   CDIINVO             INVALID CHAR--ERROR EXIT
*                                  VALID CHAR ARE 'A-Z' AND '0-9'
         LR    R0,R15              SAVE STRING LENGTH                R4
         IC    R15,$MAXCLAS        BLANK                             R4
         BCTR  R15,0                OLD                              R4
         EX    R15,CTIBLANK          CLASSES                         R4
         LR    R15,R0              RESTORE STRING LENGTH             R4
         EX    R15,CTIMOVE         PASSED ALL TESTS--MOVE NEW STRING
         BR    WA                  RETURN
         SPACE 1
CTIVALID TRT   0(*-*,R1),0(R14)    *** EXECUTE ONLY ***              R4
CTIBLANK MVC   PITCLASS(*-*),CDIMCLAS  *** EXECUTE ONLY ***          R4
CTIMOVE  MVC   PITCLASS(*-*),0(R1) **** EXECUTE ONLY ****
CIPOSTX  EQU   X'80'               INDICATE POST NEEDED--INIT IDLE
         SPACE 2
         DROP  WB                  DROP PIT ADDRESSABILITY
         EJECT
***********************************************************************
*                                                                     *
*        $P S -- STOP ( DRAIN ) SYSTEM                                *
*                                                                     *
***********************************************************************
CP40     OI    $STATUS,$DRAINED    SET SYSTEM DRAIN FLAG
         $CRET MSG='SYSTEM DRAINING'     TELL OPERATOR
         EJECT
***********************************************************************
*                                                                     *
*        $S   -- START SYSTEM                                         *
*                                                                     *
***********************************************************************
CS40     NI    $STATUS,255-$ALMSGSW-$DRAINED RESET DRAIN FLAGS
         L     R1,$PCEORG          LOCATE FIRST PCE
CSSPOST  $POST (R1),HOLD           POST ALL PCES TO START
         L     R1,PCENEXT-PCEDSECT(0,R1) PICK UP NEXT
         LTR   R1,R1               TEST FOR END
         BNZ   CSSPOST             IF MORE, LOOP
         $POST $HASPECF,(JOB,JOT)  POST JOB AND JOT
         B     CSIRET              POST JOB AND REPLY OK
         EJECT
***********************************************************************
*                                                                     *
*        $P JES2 -- STOP (WITHDRAW) JES2                              *
*                                                                     *
***********************************************************************
         USING JQEDSECT,R1
CPJES2   DS    0H                  STOP JES2 PROCESSOR
         TM    COMAUTH,COMR+COMS   TEST FOR RESTRICTED CONSOLE       R4
         BNZ   CDIINVO             YES--CAN'T WITHDRAW JES2
         OI    $STATUS,$DRAINED    SET SYSTEM DRAINING FLAG
         LH    R1,$EXCPCT          TEST OUTSTANDING I/O
         A     R1,$BUSYQUE         TEST WTO
         BNZ   CPSRET              REJECT IF WORK TO DO
*        WITHDRAW JES2 FROM CONTROL OF THE MACHINE
         CLI   $ACTIVE,0           MAKE SURE READERS ARE NOT STARTING
         BNE   CPSRET              RETURN IF STARTING
         L     R1,$PCEORG          LOCATE FIRST PCE
CPSL     CLI   PCEID-PCEDSECT+1(R1),PCERDRID IS THIS RDR
         BE    CPSNXT              SKIP HOLD TEST FOR RDRS
         TM    PCEEWF-PCEDSECT(R1),$EWFHOLD IS PROCESSOR HELD
         BO    CPSPOST             POST IT IF YES
CPSNXT   L     R1,PCENEXT-PCEDSECT(0,R1) POINT TO NEXT
         LTR   R1,R1               TEST FOR END
         BNZ   CPSL                LOOP
         B     CPSOK               CONTINUE WITHDRAWAL
CPSPOST  $POST (R1),HOLD           RELEASE PROCESSOR
         NI    $STATUS,255-$ALMSGSW RESET MESSAGE SW
CPSNXTA  L     R1,PCENEXT-PCEDSECT(0,R1) POINT TO NEXT
         LTR   R1,R1               TEST FOR END
         BZ    CPSRET              EXIT IF END
         CLI   PCEID-PCEDSECT+1(R1),PCERDRID IS THIS RDR
         BE    CPSNXTA             FORGET POST
         B     CPSPOST             POST PROCESSOR
CPSOK    DS    0H
         OI    $STATUS,$SYSEXIT    SET FOR SYSTEM EXIT
         LA    R1,$PCEORG-(PCENEXT-PCEDSECT) POINT TO PCE HEAD
CPSPCEL  ICM   R1,15,PCENEXT-PCEDSECT(R1) POINT TO NEXT PCE
         BZ    CPSPCEE             EXIT IF END
         CLI   PCEID-PCEDSECT+1(R1),PCERDRID IS THIS A READER
         BNE   CPSPCEL             LOOP
         LM    WA,WB,PCEPCEA-PCEDSECT(R1) PICK UP DISPATCH PTRS
         ST    WA,PCEPCEA-PCEDSECT(,WB) REMOVE
         ST    WB,PCEPCEB-PCEDSECT(,WA) PCE
         ST    R1,PCEPCEA-PCEDSECT(,R1) QUEUE IT
         ST    R1,PCEPCEB-PCEDSECT(,R1) TO ITSELF
         MVI   PCEEWF-PCEDSECT(R1),$EWFOPER DEACTIVATE PROCESSOR
         B     CPSPCEL             LOOP
CPSPCEE  DS    0H
         $POST $HASPECF,JOB        TELL XEQ TO CLEAN UP
         $WAIT HOLD                WAIT FOR POST FROM XEQ
         B     CPJESSHR            TEST FOR SHARED SYSTEM IDLE
CPJESWT  $WAIT ABIT                WAIT FOR A CYCLE
CPJESSHR TM    $STATUS,$CKPTACT    TEST FOR CHECKPOINT IDLE
         BO    CPJESWT             NO--WAIT FOR IT
         L     R1,$QSE1            GET ADDRESS OF 1ST QSE            R4
         TM    QSEFLAGS-QSEDSECT(R1),QSELAST  TEST FOR 1 SYSTEM
         BO    *+12                SKIP NEXT TEST IF ONLY ONE
         TM    $STATUS,$QSONDA     TEST FOR SHARED QUEUES ON DA
         BZ    CPJESWT             BRANCH IF NOT TO WAIT
         L     R10,$SSVT           POINT TO SSVT
         LA    R1,1                SET COMPLETION INDICATOR
         ST    R1,$SVHASP-SSVT(,R10) SIGNAL THAT HASP IS GOING DOWN
         L     R15,CPSEXIT         POINT TO EXIT ROUTINE
         BR    R15                 ENTER IT
CPSRET   $CRET MSG='JES2 NOT DORMANT -- SYSTEM NOW DRAINING'
         DROP  R1
         EJECT
***********************************************************************
*                                                                     *
*        $VS COMMAND-- SEND VS2 COMMANDS TO VS2                       *
*        COMMUNICATIONS TASK VIA SVC34                                *
*                                                                     *
***********************************************************************
CVS      DS    0H                  ENTRY TO $VS COMMAND
         BXH   WD,WE,CDIINVO       CHECK FOR OPERANDS
         $CWTO TRUNC=YES           TRUNCATE MLWTO FOR SVC 34
CVSLOOP  L     R15,0(,WD)          POINT TO 1ST OPERAND
         L     R1,4(,WD)           POINT TO END OF 1ST OPERAND
         CLI   0(R15),C''''        CHECK FOR CORRECT FORMAT
         BNE   CDIINVO             IF NOT ERROR
         SH    R1,=H'2'            LOOK AT END FOR QUOTE ALSO
         CLI   0(R1),C''''         MUST BE SURROUNDED BY QUOTES
         BNE   CDIINVO             IF NOT -- ERROR
         SLR   R1,R15              COMPUTE SIZE OF VS2 CMND
         SH    R1,=H'2'            LESS TWO FOR MACHINE
         BM    CDIINVO             IF NEGATIVE -- ERROR
         EX    R1,CVSCMND          MOVE GOOD CMND TO BEGINNING OF
         LA    R0,1(,R1)           AREA, AND GET TRUE LENGTH
***********************************************************************
*                                                                     *
*        MAKE SURE COMMAND IS NOT ALL BLANKS                          *
*                                                                     *
***********************************************************************
         LR    R1,R0               GET TRUE COMMAND LENGTH          R41
CVSBLKCK CLI   1(R15),C' '         IS CHARACTER A BLANK             R41
         BNE   CVSSVC34            IF NOT, GO TO ISSUE SVC 34       R41
         LA    R15,1(,R15)         POINT TO NEXT CHARACTER          R41
         BCT   R1,CVSBLKCK         LOOP BACK IF MORE CHARACTERS     R41
         B     CDIINVO             ELSE ALL BLANKS -- ERROR         R41
         SPACE 2                                                    R41
CVSSVC34 DS    0H                  SEND COMMAND TO VS2              R41
         $CWTO L=(R0)              SVC 34 THE COMMAND
         BXLE  WD,WE,CVSLOOP       AND LOOP THROUGH ALL CMNDS
         B     CDIRET              RETURN AFTER ALL CMNDS
CVSCMND  MVC   COMMAND(*-*),1(R15) **** EXECUTE ONLY ****
         EJECT
***********************************************************************
*                                                                     *
*        $ESYS,SID -- WARM START A SYSTEM THAT IS NOT ACTIVE          *
*        OPERAND IS A VALID SID WHOSE NAME IS IN THE QSE TABLE        *
*        ONLY ONE SYSTEM IS WARM-STARTABLE AT A TIME                  *
*                                                                     *
***********************************************************************
         SPACE 2
CES      DS    0H                  RESTART SYSTEM
         CLC   COMVERB(4),=C'ESYS'  TEST FOR PROPER COMMAND FORMAT
         BE    CESYSOK             YES--CONTINUE
         $CFINVC ,                 ELSE FLAG AS INVALID COMMAND
CESYSOK  DS    0H                  CONTINUE $ESYS COMMAND
         L     WB,$ESYSQSE         POINT TO QSE WARM START POINTER
         LTR   WB,WB               TEST FOR ACTIVE
         BNZ   CESYSERR            IF ACTIVE--EXIT WITH DIAGNOSTIC
         BXH   WD,WE,CDIINVO       FETCH NEXT OPERAND
         LM    R1,WA,0(WD)         PICK-UP OPERAND POINTERS
         SLR   WA,R1               COMPUTE OPERAND
         BCTR  WA,0                LENGTH
         CH    WA,=H'4'            TEST LENGTH
         BNE   CDIINVO             NOT CORRECT--ERROR
         $QSUSE ,                  ENQUEUE ON SHARED RESOURCE
         L     WA,$QSE1            POINT TO 1ST QSE                  R4
         SH    WA,$QSEL            BACK UP ONE QSE                   R4
         USING QSEDSECT,WA         QSE ADDRESSABILITY
CESLOOP  AH    WA,$QSEL            POINT TO NEXT QSE                 R4
         CLC   QSESID,0(R1)        TEST FOR MATCH WITH OPERAND       R4
         BE    CESYSFND            YES--RESTART IT
         TM    QSEFLAGS,QSELAST    TEST FOR LAST ELEMENT
         BZ    CESLOOP             NOT LAST -- LOOP
         B     CDIINVO             LAST -- ERROR
CESYSFND DS    0H                  SYSTEM ID FOUND
         STCK  COMDWORK            STORE TOD CLOCK VALUE
         L     WC,QSESITIM         PICK-UP LAST CKPT TIME
         L     WD,$SYNCTOL         PICK-UP SYNC TIME VALUE           R4
         ALR   WC,WD               COMPUTE CURRENT TIME VALUE
         CL    WC,COMDWORK         TEST FOR PROCESSOR ACTIVE
         BNL   CESYSACT            YES--PROCESSOR STILL ACTIVE
         ST    WA,$ESYSQSE         SET QSE TO BE WARM STARTED
         NI    QSESTAT,255-QSEACTIV  INDICATE SYSTEM INACTIVE        R4
         L     R15,$WARMPCE        POINT TO WARM START PCE           R4
         $POST (R15),WORK          POST FOR WORK
         SPACE 1
         $CRET MSG=OK              AND EXIT WITH 'OK'
         SPACE 2
*        MESSAGE THAT WARM START TASK IS BUSY
         SPACE 1
CESYSERR DS    0H                  WARM START PCE IS BUSY
         MVC   COMMAND(CESYSLN1),CESYSMS1  SET MESSAGE HEADER
         L     WA,$QSE1            POINT TO 1ST QSE                  R4
         SH    WA,$QSEL            BACK UP ONE QSE                   R4
CESYSERL AH    WA,$QSEL            POINT TO NEXT QSE                 R4
         CLR   WB,WA               SID BEING WARM-STARTED            R4
         BE    CESYSERF            FOUND SID BEING WARM-STARTED
         TM    QSEFLAGS,QSELAST    TEST FOR LAST
         BZ    CESYSERL            IF NOT LAST LOOP
         LA    R0,CESYSLN1-1       SET MSG LENGTH FOR SID NOT FOUND
         B     CESYSWTO            AND EXIT WITH DIAGNOSTIC
CESYSERF DS    0H                  SID BEING WARM/STARTED WAS FOUND
         MVC   COMMAND+CESYSLN1(L'QSESID),QSESID SET SID NAME
         LA    R0,CESYSLN1+L'QSESID  SET MESSAGE LENGTH
CESYSWTO DS    0H                  SEND MESSAGE
         $CRET L=(R0)              EXIT WITH DIAGNOSTIC
         SPACE 2
*        MESSAGE THAT CURRENT SID IS ACTIVE
         SPACE 1
CESYSACT DS    0H                  SID IS ACTIVE
         MVC   COMMAND(L'QSESID),QSESID  SET SID NAME
         MVC   COMMAND+L'QSESID(CESYSLN2),CESYSMS2 SET REST OF DIAG
         LA    R0,L'QSESID+CESYSLN2  SET DIAGNOSTIC LENGTH
         B     CESYSWTO            AND EXIT WITH MESSAGE
         SPACE 1
CESYSMS1 DC    C'TASK BUSY RE-STARTING' WARM START PCE IS ACTIVE MSG
CESYSLN1 EQU   *-CESYSMS1          LENGTH OF DIAGNOSTIC
         SPACE 1
CESYSMS2 DC    C' IS ACTIVE AND CANNOT BE RE-STARTED'
CESYSLN2 EQU   *-CESYSMS2          LENGTH OF DIAGNOSTIC
         SPACE 1
         DROP  WA                  DROP QSE ADDRESSABILITY
         EJECT
***********************************************************************
*                                                                     *
*        $LSYS -- LIST STATUS OF SYSTEMS IN MULTI-SYSTEM NODE         *
*        NO OPERANDS ARE REQUIRED                                     *
*                                                                     *
***********************************************************************
         SPACE 1                                                     R4
CLSYS    DS    0H                  ENTER LIST SYSTEM STATUS
         TM    COMAUTH,COMR+COMS   TEST FOR RESTRICTED CONSOLE       R4
         BNZ   CDIINVO             YES--INVALID AUTH FOR THIS CMND
         L     WB,$QSE1            POINT TO 1ST QSE                  R4
         B     CLSYSMVC            ENTER COMMON DISPLAY ROUTINE      R4
         USING QSEDSECT,WB         QSE ADDRESSABILITY
CLSYSLP  TM    QSEFLAGS,QSELAST    TEST FOR LAST ELEMENT
         BZ    CLSYSQSE            NOT LAST -- ENTER DISPLAY ROUTINE
         $CRET ,                   ELSE EXIT
         SPACE 2
CLSYSQSE AH    WB,$QSEL            POINT TO NEXT QSE                 R4
CLSYSMVC MVC   COMMAND(L'QSESID),QSESID  SET SID NAME IN MESSAGE     R4
         C     WB,$AQSE            OUR SYSTEM                        R4
         BE    CLSYSACT            INDICATE ACTIVE                   R4
         C     WB,$ESYSQSE         IS SYSTEM RESTARTING...     @OZ28240
         BE    CLSYSACT            BR IF YES, DISPLAY STATUS   @OZ28240
         TM    QSESTAT,QSEACTIV    TEST FOR ACTIVE SYSTEM            R4
         BZ    CLSYSDWN            BR IF NO                          R4
         STCK  COMDWORK            SAVE TOD CLOCK VALUE
         L     WC,QSESITIM         PICK-UP LAST CKPT TIME
         L     WA,$SYNCTOL         PICK-UP SYNC TIME VALUE           R4
         ALR   WC,WA               COMPUTE CURRENT TIME
         CL    WC,COMDWORK         COMPARE FOR STATUS
         BH    CLSYSACT            IF NOT LOW OR EQUAL --ACTIVE
         MVC   COMMAND+L'QSESID(8),=C' DORMANT'  SHOW MAYBE DOWN     R4
         LA    R0,L'QSESID+8       SET MESSAGE LENGTH                R4
         B     CLSYSWTO            AND SEND IT                       R4
CLSYSDWN DS    0H                  SYSTEM DEFINTELY NOT UP           R4
         MVC   COMMAND+L'QSESID(9),=C' INACTIVE' SET REST OF MESSAGE
         LA    R0,L'QSESID+9       SET MESSAGE LENGTH
CLSYSWTO DS    0H                  SEND MESSAGE OF STATUS
         $CWTO L=(R0)              SEND IT
         B     CLSYSLP             AND LOOP FOR MORE
         SPACE 1
CLSYSACT DS    0H                  SYSTEM MAY BE ACTIVE
         MVC   COMMAND+L'QSESID(7),=C' ACTIVE' SET ACTIVE MESSAGE
         LA    R0,L'QSESID+7       SET MESSAGE LENGTH
         C     WB,$ESYSQSE         CHECK TO SEE IF RESTARTING
         BNE   CLSYSIND            NO--CHK FOR IND MODE OF OPERATION
         MVC   COMMAND+L'QSESID(12),=C' RE-STARTING'  SET RESART MSG
         LA    R0,L'QSESID+12      SET MESSAGE LENGTH
         B     CLSYSWTO            AND SEND IT
CLSYSIND DS    0H                  CHECK FOR INDEPENDENT MODE
         CLC   QSESID,$SID         TEST FOR SAME SYSTEM
         BNE   CLSYSWTO            NO--CAN'T TELL ABOUT IND MODE
         TM    $STATUS,$INDMODE    TEST FOR IND MODE
         BZ    CLSYSWTO            NO--SEND MESSAGE AS IS
         MVC   COMMAND+L'QSESID+7(17),=C' INDEPENDENT MODE' SET  MSG
         LA    R0,L'QSESID+24      SET MESSAGE LENGTH
         B     CLSYSWTO            AND RESPOND TO OPERATOR
         DROP  WB                  DROP QSE ADDRESSABILITY
         EJECT
***********************************************************************
*                                                                     *
*        $TALL,SID1,+ - OR NULL SID2,SID3,...SIDN                     *
*        SID1  = SID THAT CURRENTLY HAS JOB(S) AFFINITY               *
*        SID2  = SID'S TO WHICH JOB(S) ARE TO BE RE-ROUTED            *
*        + OR - MEANS THAT SID2...SIDN WILL BE ADDED OR SUBTRACTED    *
*        THE WORD 'ANY' MAY BE USE TO SET A SYSTEM AFF TO 'ANY'       *
*        THE WORD 'IND' WHEN USED MEANS INDEPENDENT MODE              *
*        AND INDICATES THAT JOBS ARE TO BE PLACED IN THAT SELECTION   *
*        MODE                                                         *
*                                                                     *
***********************************************************************
         SPACE 2
CTALL    DS    0H
         TM    COMAUTH,COMR+COMS   TEST FOR RESTRICTED CONSOLE       R4
         BZ    CTALLAOK            NO -- AUTHORITY IS 'OK'
         $CFINVC ,                 AUTHORITY IS INVALID FOR COMMAND
CTALLAOK DS    0H
         BXH   WD,WE,CDIINVO       SKIP TO NEXT OPERAND
        $QSUSE                     REQUEST ACCESS TO CHECKPOINT DATA R4
         LM    R1,WA,0(WD)         PICK-UP OPERAND POINTERS
         SLR   WB,WB               ZERO INSERT REGISTER
         CLC   0(3,R1),=C'IND'     TEST FOR 'IND' JOBS
         BNE   CTALLNIN            NO--TRY SPECIFIC SID
         IC    WB,=AL1(QUEINDAF)   PICK-UP IND BIT
         B     CTALLFDA            AND TRY FOR NEXT OPERAND
CTALLNIN DS    0H                  NOT REQUEST FOR 'IND' JOBS
         SLR   WA,R1               COMPUTE
         BCTR  WA,0                OPERAND LENGTH
         CH    WA,=H'4'            CHECK FOR PROPER LENGTH
         BNE   CDIINVO             NO--ERROR
         LA    R15,CTALLFD1        POINT TO FOUND ROUTINE
CTALSCAN DS    0H                  SCAN QSE(S) FOR OPERAND
         L     WA,$QSE1            POINT TO 1ST QSE                  R4
         SH    WA,$QSEL            BACK UP ONE QSE                   R4
         USING QSEDSECT,WA         QSE ADDRESSABILITY
CTALLP1  AH    WA,$QSEL            POINT TO NEXT QSE                 R4
         CLC   QSESID,0(R1)        CHECK FOR MATCH                   R4
         BER   R15                 ENTER APPROPRIATE RTN
         TM    QSEFLAGS,QSELAST    TEST FOR LAST ONE
         BZ    CTALLP1             NO LAST -- LOOP
         B     CDIINVO             NOT FOUND--ERROR
CTALLFD1 DS    0H                  FOUND OPERAND ONE
         IC    WB,QSESIAFF         SET AFFINITY FOR 'EX'
CTALLFDA DS    0H                  TRY FOR NEXT OPERAND
         BXH   WD,WE,CDIINVO       GET NEXT OPERAND OR ERROR
         L     R1,0(,WD)           POINT TO OPERAND
         MVI   CTALLAFF,0          SET NO AFFINITY
         LPR   R10,WE              ASSUME ADDITION
         CLI   0(R1),C'+'          CHECK FOR ADDITION
         BE    CTALCHG             YES -- GO DO IT
         LNR   R10,R10             ASSUME DELETION OF AFFINITIES
         CLI   0(R1),C'-'          TEST FOR SAME
         BE    CTALCHG             YES -- GO DO IT
         SLR   R10,R10             SET NO ADDITION OR SUBTRACTION
         BCTR  R1,0                PT BEFOR NO-EXISTANT '+' OR '-'
CTALCHG  DS    0H                  CONTINUE OPERAND SCAN
         LA    R1,1(,R1)           POINT PAST POSSIBLE '+' OR '-'
         SPACE 1
*        OTHER THAN FIRST OPERAND FOUND
CTALLOOP CLC   0(3,R1),=C'ANY'     TEST FOR ANY AFFINITY
         BNE   CTALNANY            NO--TEST FOR IND MODE OPERATION
         SLR   R10,R10             INDICATE NO ADD OR DELETION
         OI    CTALLAFF,QUESYSAF   FLAG AFFINITY OF 'ANY'
         B     CTALLFD3            AND LOOK FOR MORE OPERANDS
CTALNANY DS    0H                  NOT 'ANY' AFFINITY
         CLC   0(3,R1),=C'IND'     CHECK FOR 'IND' MODE
         BNE   CTALCHG1            NO -- TRY FOR SPECIFIC AFF
         OI    CTALLAFF,QUEINDAF   YES -- SET 'IND' MODE
         B     CTALLFD3            AND LOOK FOR MORE OPERANDS
CTALCHG1 DS    0H                  LOOK FOR SPECIFIC SID NAME
         LA    R15,CTALLFD2        SET TARGET ADDRESS
         B     CTALSCAN            AND GO SCAN QSE(S)
         SPACE 1
CTALLFD2 DS    0H                  FOUND SPECIFIC AFFINITY
         OC    CTALLAFF,QSESIAFF   SET AFFINITY INTO SAVE AREA
CTALLFD3 DS    0H                  SEARCH FOR MORE OPERANDS
         BXLE  WD,WE,CTALLMOR      LOOK FOR NEXT OPERAND
         TM    CTALLAFF,QUEINDAF   TEST FOR 'IND' MODE
         BZ    CTALLEND            NO--EXIT OPERAND SCAN
         TM    CTALLAFF,255-QUEINDAF TEST FOR OTHER AFFINITIES
         BNZ   CTALLEND            YES--EXIT OPERAND SCAN
         LTR   R10,R10             TEST FOR ADDITION OR DELETION
         BNZ   CTALLEND            YES--EXIT OPERAND SCAN
         SLR   WD,WE               NO--ERROR
         B     CDIINVO             POINT TO OPERAND AND EXIT
         SPACE 1
CTALLMOR DS    0H                  MORE OPERANDS
         L     R1,0(,WD)           POINT TO NEXT OPERAND
         B     CTALLOOP            AND ENTER MAJOR SCAN LOOP
         SPACE 2
*        SEARCH JOB QUEUE FOR JOB(S) WITH FIRST SID'S AFFINITY
         SPACE 1
CTALLEND DS    0H                  END OF OPERANDS
         SLR   WA,WA               SET NO JOBS ALTERED
         USING JQEDSECT,R1         JQE ADDRESSABILITY
         $CFJSCAN PROCESS=CTALPRO,NEXT=CTALNXT,EMPTY=CTALNONE,         C
               IGNORE=CTALIGN      SCAN THE JOB QUEUE
         LTR   WA,WA               TEST FOR ANY JOB(S) RE-ROUTED
         BNZ   CTALRET             YES -- SKIP DIAGNOSTIC
         $CRET MSG='NO JOB(S) RE-ROUTED'
         SPACE 1
CTALRET  DS    0H                  RETURN
         $POST $HASPECF,(JOB)      POST FOR WORK
         OI    $AQSE,QSEPJOB       CAUSE X SYSTEM POST(S)
         $CRET MSG=OK              AND RETURN 'OK'
CTALNONE DS    0H                  COME HERE WHEN NO JOB(S) FND
         $CRET MSG='NO JOB(S) FOUND'
         SPACE 2
*        LOOK AT EACH JOB TO SEE IF AFFINITY TO SID
         SPACE 1
CTALPRO  DS    0H                  PROCESS AJOB
         CLC   JQEJOBNO,=H'10000'  TEST FOR NORMAL BATCH JOB
         BL    CTALLTST            IF YES -- BRANCH
         TM    JQETYPE,$XEQ        TEST FOR STC OR TSU IN XEQ OR CVT
         BO    CTALNXT             YES -- GET NEXT JOB
         CLI   JQETYPE,$INPUT      TEST FOR STC OR TSU IN INPUT RDR
         BE    CTALNXT             YES--GET NEXT JOB
CTALLTST DS    0H                  TEST JOB FOR AFFINITY
         EX    WB,CTALTEST         TEST FOR AFFINITY OWNERSHIP
         BZ    CTALNXT             NO--GET NEXT JOB
         LTR   R10,R10             TEST FOR TYPE OF CHANGE
         BM    CTALLESS            IF DELETION GO DO IT
         BP    CTALMORE            IF ADDITION GO DO IT
         NI    JQEFLAG2,QUEINDAF   TURN OFF OLD AFFINITIES          R41
CTALMORE DS    0H                  ADD NEW AFFINITIES
         OC    JQEFLAG2,CTALLAFF   ADD AFFINITIES
         B     CTALCKPT            AND CHECK-POINT ELEMENT
CTALLESS DS    0H                  DELETE SELECTED AFFINITIES
         LA    R15,255             SET REGSITER TO ALL BITS 'ON'
         SLR   R0,R0               ZERO INSERT REGISTER
         IC    R0,CTALLAFF         PICK-UP AFFINITIES TO DELETE
         SLR   R15,R0              COMPUTE BITS TO BE LEFT 'ON'
         EX    R15,CTALAFOF        DELETE SELECTED AFFINITIES
         L     R14,$QSE1           POINT TO 1ST QSE                  R4
         SH    R14,$QSEL           BACK UP ONE QSE                   R4
         USING QSEDSECT,R14        QSE ADDRESSABILITY
CTALAFLP AH    R14,$QSEL           POINT TO NEXT QSE                 R4
         IC    R15,QSESIAFF        PICK UP AFFINITY BITS FOR TEST    R4
         EX    R15,CTALTEST        TEST FOR IMPOSSIBLE AFFINITY
         BO    CTALCKPT            NO -- GO CHECK POINT ELEMENT
         TM    QSEFLAGS,QSELAST    TEST FOR LAST ELEMENT
         BZ    CTALAFLP            LOOP FOR TEST OF AFFINITIES
         OC    JQEFLAG2,CTALLAFF   RESET ORIGINAL AFFINITY
         B     CTALNXT             AND GET NEXT JOB
         DROP  R14                 DROP QSE ADDRESSABILITY
         SPACE 1
CTALCKPT DS    0H                  CHECK-POINT MODIFIED JQE
         LR    WA,WE               FLAG A MODIFICATION HAS BEEN MADE
         $QCKPT (R1)               CKPT MODIFIED JQE
         B     CTALNXT             AND GET ANOTHER JOB
         SPACE 2
CTALTEST TM    JQEFLAG2,*-*        **** EXECUTE ONLY ****
CTALLOFF XI    JQEFLAG2,*-*        **** EXECUTE ONLY ****
CTALAFOF NI    JQEFLAG2,*-*        **** EXECUTE ONLY ****
         SPACE 2
*        $TALL EQUATES
         SPACE 1
CTALLAFF EQU   COMEWORK,1          AFFINITY SAVE AREA
         SPACE 2
         EJECT
***********************************************************************
*                                                                     *
*        $TSYS,IND=Y/N -- SET SYSTEM IN INDEPENDENT MODE              *
*        OPERAND(S) -- IND=YES/NO -- SET/RESET INDEPENDENT MODE       *
*                                                                     *
***********************************************************************
         SPACE 2
CTSYS    DS    0H                  SET/RESET SYS TO INDEPENDENT MODE
         TM    COMAUTH,COMR+COMS   TEST FOR RESTRICTED CONSOLE       R4
         BZ    CTSYSAOK            BRANCH IF AUTHORITY IS 'OK'
         $CFINVC ,                 ELSE COMMAND IS INVALID
         SPACE 1
CTSYSAOK DS    0H                  AUHTORITY IS 'OK'
         BXH   WD,WE,CDIINVO       CHECK FOR PRESENCE OF OPERAND
         L     R1,0(,WD)           POINT TO OPERAND
         CLC   0(4,R1),=C'IND='    CHECK FOR PROPER FORMAT
         BNE   CDIINVO             NO -- ERROR
         CLI   4(R1),C'Y'          IS DESIRE TO ENTER IND MODE
         BE    CTSYINDY            YES -- GO DO IT
         NI    $STATUS,255-$INDMODE RESET INDEPENDENT MODE SELECTION
         MVC   COMMAND+L'$SID(CTSYSLN1),CTSYMSG1 SET MESSAGE
         LA    R0,CTSYSLN1+L'$SID  SET MESSAGE LENGTH
         B     CTSYEXIT            AND EXIT COMMAND
CTSYINDY DS    0H                  ENTER INDEPENDENT MODE
         OI    $STATUS,$INDMODE    SET INDEPENDENT MODE
         MVC   COMMAND+L'$SID(CTSYSLN2),CTSYMSG2 SET MESSAGE
         LA    R0,CTSYSLN2+L'$SID  SET MESSAGE LENGTH
CTSYEXIT DS    0H                  EXIT COMMAND
         $POST $HASPECF,JOB        POST THIS PROCESSOR FOR JOB
         MVC   COMMAND(L'$SID),$SID SET SYSTEM NAME IN MESSAGE
         $CRET L=(R0)              EXIT WITH MESSAGE
         SPACE 2
CTSYMSG1 DC    C' IS NO LONGER IN INDEPENDENT MODE' MESSAGE
CTSYSLN1 EQU   *-CTSYMSG1          LENGTH OF MESSAGE
CTSYMSG2 DC    C' IS NOW IN INDEPENDENT MODE' MESSAGE
CTSYSLN2 EQU   *-CTSYMSG2          LENGTH OF MESSAGE
         LTORG ,
         TITLE 'HASP COMMAND PROCESSOR HASPCSY3 - CONSOLE COMMANDS'
HASPCSY3 $COMGRUP  TC,TM,TO        CONSOLE COMMAND GROUP
***********************************************************************
*                                                                     *
*        $T CON,LEVEL,LIST - SET LIST LEVEL OF LOGICAL CONSOLES       *
*                                                                     *
*        LEVEL = MESSAGE LEVEL (ONLY LEVELS ABOVE THIS DISPLAY)       *
*        LIST  = MAIN/TAPE/TP/UR/ERROR/LOG (LOGICAL ROUTINGS)         *
*                                                                     *
***********************************************************************
CTC      DS    0H
         BXH   WD,WE,CTOINVO       LOCATE SECOND OPERAND POINTER
         L     R1,0(0,WD)          POINT TO OPERAND
         LA    WC,CTOINVO          POINT TO ERROR EXIT ROUTINE
         $CFCVB POINTER=(WD),NOK=CTOINVO CONVERT TO BINARY
         CH    R0,=H'15'           CHECK FOR MAX LEVEL EXCEEDED
         BCR   H,WC                INVALID OPERAND IF SO
         BXH   WD,WE,CTOINVO       LOCATE OPERAND
         SLR   R14,R14             ZERO ACCUMULATOR                  R4
CTXCLOP  L     R1,0(0,WD)          POINT TO OPERAND
         LA    R15,CTXTAB          POINT TO LOGICAL CONSOLE TABLE
         LA    WA,CTXTABCT         SET NUMBER OF ENTRIES
CTXCLOOP CLC   0(2,R15),0(R1)      COMPARE TABLE ENTRY AGAINST TEXT  R4
         BE    CTXCFND             IF MATCH, EXIT
         LA    R15,CTXTESIZ(0,R15) POINT TO NEXT ENTRY
         BCT   WA,CTXCLOOP         LOOP UNTIL END
         BR    WC                  ERROR EXIT
CTXCFND  O     R14,0(,R15)         ACCUMULATE ROUTINGS               R4
         BXLE  WD,WE,CTXCLOP       LOOP IF MORE OPERANDS             R4
         L     R15,$CSAREA         POINT TO CONSOLE SERVICE AREA     R4
         LA    R15,CSALEVEL+7*2-CSADSECT(,R15) POINT TO HIGHEST LEVELR4
         LA    WC,7                SET HIGHEST LEVEL NUMBER          R4
CTXSLOP  LH    R1,0(,R15)          PICK UP OLD ROUTINGS              R4
         OR    R1,R14              TURN ON ROUTE CODE                R4
         CR    WC,R0               IS LEVEL HIGHER THAN SPECIFIED    R4
         BH    CTXSON              TURN ROUTE ON IF YES              R4
         XR    R1,R14              FLIP ROUTES OFF IF NOT            R4
CTXSON   STH   R1,0(,R15)          SET NEW ROUTINGS                  R4
         BCTR  R15,0               DOWN                              R4
         BCTR  R15,0               TWO                               R4
         BCT   WC,CTXSLOP          DO FOR 7 (0 NOT ALTERED)          R4
         $CRET MSG=OK              RETURN                            R4
CTXTAB   DS    0F                  HASP LOGICAL ROUTING TEXT IDS     R4
         DC    C'MA',X'C000'       MAIN                              R4
CTXTESIZ EQU   *-CTXTAB                                              R4
         DC    C'TA',X'3C00'       TAPE                              R4
         DC    C'TP',X'0100'       TELE-PROCESSING                   R4
         DC    C'UR',X'0200'       UNIT RECORD                       R4
         DC    C'ER',X'0040'       ERROR                             R4
         DC    C'LO',X'0000'       LOG                               R4
CTXTABCT EQU   (*-CTXTAB)/CTXTESIZ
         EJECT
***********************************************************************
*                                                                     *
*        $TMCCA,LIST -- SET MESSAGE ROUTING                           *
*                                                                     *
*        CC    = CONSOLE TO RECEIVE THE RESPONSE                      *
*        A     = AREA OF CONSOLE CC                                   *
*        LIST  = DISPLAY COMMAND OPERANDS FOR CONSOLE CC AREA A       *
*                ( NO COMMAS BETWEEN LIST ITEMS )                     *
*                                                                     *
***********************************************************************
CTM      DS    0H
         SLR   WA,WA               ZERO WORK                         R4
         ST    WA,COMEWORK         ALSO WORK AREA                    R4
         IC    WA,COMUCM           ASSUME DESIRED UCM PRESENT        R4
         LA    R1,COMOPRND         SET ERROR LOCATOR
         TM    COMFLAG,CMBFLAGU    IS THIS A UCM                     R4
         BZ    CTMINVO             IF NOT OS CONSOLE, NO
         L     R10,COMEXTEN        POINT TO EXTENDED AREA
         USING COMDSECT,R10
         LR    WC,WA               GET ENTRY CONSOLE
         MH    WC,COMLCON          CALCULATE OFFSET (1 TOO HIGH)
         LA    WC,COMRESP-COMCONL(WC) POINT TO ELEMENTS
         LA    R15,1(0,R1)         POINT TO NUMERIC
         CLI   0(R15),C' '         CHECK FOR DISPLAY ONLY
         BE    CTMDISP             DISPLAY
         CLI   0(R15),C'0'         IS IT NUMERIC
         BL    CTMGETA             IF NOT TRY AREA
         MVN   COMEWORK+3(1),0(R15) EXTRACT NUMERIC
         L     WB,COMEWORK         PICK UP RESPONSE CONSOLE NUMBER   R4
         LA    R15,1(0,R15)        UP 1
         CLI   0(R15),C'0'         CHECK SECOND NUMERIC
         BL    CTMCKC              IF NOT CHECK FOR SUPPORTED
         MH    WB,=H'10'           MULTIPLY BY TEN                   R4
         MVN   COMEWORK+3(1),0(R15) EXTRACT NUMERIC
         A     WB,COMEWORK         ADD UNITS DIGIT                   R4
         LA    R15,1(0,R15)        UP 1
CTMCKC   LTR   WB,WB               CHECK FOR ZERO                    R4
         BZ    CTMCOMBA            LEAVE DEFAULT CONSOLE IN          R4
         CH    WB,COMOCON          CONSOLE TOO HIGH                  R4
         BH    CTMERROR            EXIT IF TOO HIGH
         LR    WA,WB               PUT IN CONSOLE REGISTER           R4
CTMGETA  CLI   0(R15),C','         END OF OPERAND                    R4
         BE    CTMCOMBA            IF SO COMBINE AREA AND UCM
         CLI   0(R15),C' '         IS IT BLANK
         BE    CTMCOMBA            IF SO COMBINE AREA AND UCM
         CLI   0(R15),C'A'         BELOW A
         BL    CTMINVO             IF YES EXIT
         CLI   0(R15),C'I'         IS IT SET NOW
         BNH   CTMCOMB             IF SO COMBINE AREA AND UCM
         CLI   0(R15),C'J'         IS IT WITHIN RANGE
         BL    CTMINVO             IF NOT EXIT
         CLI   0(R15),C'R'         IS IT J - R                       R4
         BNH   CTMCOMB             IF SO COMBINE AREA AND UCM        R4
         CLI   0(R15),C'S'         IS IT BELOW S                     R4
         BL    CTMINVO             IF YES EXIT                       R4
         CLI   0(R15),C'Z'         IS IT S - Z                       R4
         BH    CTMINVO             EXIT IF HIGH
CTMCOMB  ICM   WB,8,0(R15)         PICK UP AREA                      R4
CTMCOMBZ LA    R15,1(0,R15)        UP 1
CTMCOMBA SLDL  WA,8                COMBINE UCM AND AREA
         CLI   0(R15),C','         IS IT ALL OR LIST
         BE    CTMLIST             USE LIST
         CLI   0(R15),C' '         IS IT BLANK
         BNZ   CTMINVO             ERROR IF NOT
* USER WANTS TO SET ALL OPERANDS
         LH    R0,COMLCON          GET COUNT*2
         SRA   R0,1                HALVE IT
         LR    WB,WC               POINT TO FIRST ELEMENT
CTMALL   STCM  WA,3,0(WB)          SET RESPONSE CONSOLE
         LA    WB,2(0,WB)          UP 2 ( NEXT ELEMENT )
         BCT   R0,CTMALL           LOOP
* DISPLAY CURRENT SETTINGS
CTMDISP  LA    WE,6                SET INCREMENT
         LA    WF,COMMAND+70-6     SET END
         LH    WB,COMLCON          PICK UP LENGTH OF ELEMENTS
         SRA   WB,1                HALVE TO GET NUMBER
         SR    WD,WD               SET OFFSET
         SR    R0,R0               ZERO WORK
         IC    R0,COMUCM           PICK UP ENTRY CONSOLE             R4
         MVC   COMMAND(3),=C'CON'  SET BEGINNING OF MESSAGE
         $CFCVE  VALUE=(R0)        CONVERT TO EBCDIC
         MVC   COMMAND+3(3),COMDWORK+2 INSERT
CTMDNLN  LA    WA,COMMAND          SET TO START OF LINE
         SR    R0,R0               ZERO WORK
CTMDNXE  BXH   WA,WE,CTMELN        END OF LINE TEST
         IC    R0,COMCON(WD,WC)    PICK UP CONSOLE ID
         $CFCVE  VALUE=(R0)        CONVERT TO EBCDIC
         MVC   0(5,WA),COMDWORK    SET OUTPUT ITEM '   CC'
         MVI   2(WA),C'='          SET '  =CC'
         MVI   5(WA),C' '          SET BLANK AREA                    R4
         LA    R14,COMCONA(WD,WC)  POINT TO AREA                     R4
         CLI   0(R14),0            IS IT ZERO                        R4
         BZ    SKIP270             SKIP NSI IF YES                   R4
         MVC   5(1,WA),0(R14)      SET '  =CCA'
SKIP270  LA    R14,CTMTAB-2        POINT TO CONVERT TAB -2
CTMDL    LA    R14,2(0,R14)        UP 2
         CLI   0(R14),X'FF'        IS IT END
         BE    CTMERROR            EXIT ON ERROR
         CLM   WD,1,1(R14)         CHECK FOR MATCHING OFFSET
         BNE   CTMDL               LOOP
         MVC   1(1,WA),0(R14)      SET ' O=CCA'
         LA    WD,2(0,WD)          UP TO NEXT ELEMENT
         BCT   WB,CTMDNXE          LOOP TO NEXT ELEMENT
         LA    R0,COMMAND-6        CALCULATE
         SR    WA,R0                LENGTH
         LR    R0,WA                OF MESSAGE
         $CRET L=(R0)              DISPLAY AND EXIT
* END OF DISPLAY LINE
CTMELN   LA    R0,COMMAND-6        CALCULATE
         SR    WA,R0                LENGTH
         LR    R0,WA                OF MESSAGE
         $CWTO L=(R0)              DISPLAY
         B     CTMDNLN             DO NEXT LINE
* LIST ITEMS DESIRED
CTMLIST  LA    R1,1(0,R15)         POINT TO FIRST SPECIFICATION
CTMTBNK  CLI   0(R1),C' '          CHECK FOR END
         BE    CTMDISP             DISPLAY SETTINGS IF END
         LA    R14,CTMTAB-2        POINT TO CONVERT TABLE - 2
CTMLNXT  LA    R14,2(0,R14)        UP TO NEXT
         CLI   0(R14),X'FF'        IS IT END
         BE    CTMINVO             EXIT ON ERROR
         CLC   0(1,R14),0(R1)      MATCH SPECIFICATION
         BNE   CTMLNXT             LOOP
         SR    WB,WB               ZERO WORK
         IC    WB,1(0,R14)         PICK UP OFFSET
         CH    WB,COMLCON          CHECK FOR COMPATIBLE
         BNL   CTMERROR            GEN BAD
         AR    WB,WC               POINT TO ELEMENT
         STCM  WA,3,0(WB)          SET
         LA    R1,1(0,R1)          UP TO NEXT
         B     CTMTBNK             LOOP
CTMERROR $CRET MSG='ENTRY CONSOLE NOT SUPPORTED' SEND DIAGNOSTIC
CTMINVO  $CFINVO OPERAND=(R1)      INVALID OPERAND                   R4
CTMTAB   DS    0H                  ITEMS IN LIST
         DC    C'A',AL1($DA*2-2)
         DC    C'F',AL1($DF*2-2)
         DC    C'I',AL1($DI*2-2)
         DC    C'J',AL1($DJ*2-2)
         DC    C'N',AL1($DN*2-2)
         DC    C'O',AL1($DO*2-2)
         DC    C'Q',AL1($DQ*2-2)
         DC    C'U',AL1($DU*2-2)
* OPTIONAL SPECIFICATIONS NOT DISPLAYED
         DC    X'7D',AL1($D7D*2-2)
         DC    C'S',AL1($DS*2-2)
         DC    C'T',AL1($DT*2-2)
         DC    X'FF'               END OF TABLE
         DROP  R10
         EJECT
***********************************************************************
*                                                                     *
*        $T OSCX,D=M/D=J/D=T - SET OS CONSOLE DISPLAY OPTION          *
*                                                                     *
*        X     = CONSOLE UCMID NUMBER                                 *
*        M     = DISPLAY MESSAGE TEXT ONLY                            *
*        J     = DISPLAY JOB ID AND MESSAGE TEXT                      *
*        T     = DISPLAY TIME STAMP, JOB ID, AND TEXT                 *
*                                                                     *
***********************************************************************
CTO      DS    0H
         $CFCVB POINTER=(WD),NOK=CTOINVO GET UCMID
         LA    R1,255              SET MAXIMUM UCMID
         CR    R0,R1               ABOVE MAX
         BH    CTOINVO             EXIT IF HIGH
* COMNULOP BYTE 0 IS 0 FOR D=M
         L     R15,CVTPTR          POINT TO CVT
         L     R15,CVTCUCB-CVT(,R15) POINT TO UCM
         LM    R1,WB,UCMVEA-UCM(R15) PICK UP ELEMENT SCAN PARMS
CTOCONL  CLM   R0,1,UCMID-UCMLIST(R1) FIND ENTRY
         BE    CTOCON              EXIT IF FOUND
         BXLE  R1,WA,CTOCONL       LOOP
         B     CTOINVO             ERROR EXIT
CTOCON   LR    WB,R1               SAVE UCME ADDRESS
         BXLE  WD,WE,CTOSEL        CHECK FOR MORE PARAMETERS
CTOSET   $GETLOK ,                 LOCK
         MODESET EXTKEY=ZERO       GET KEY 0
         NI    UCMDISP2-UCMLIST(WB),255-UCMDISPI-UCMDISPJ RESET
         OC    UCMDISP2-UCMLIST(1,WB),COMNULOP TURN ON INDICATORS
         MODESET EXTKEY=HASP       GET KEY 1
         $FRELOK ,                 UNLOCK
CTOXIT   $CRET MSG=OK              EXIT WITH OK
CTOSEL   L     R1,0(0,WD)          POINT TO OPERAND
         CLC   0(2,R1),=C'D='      CHECK FOR D=
         BNE   CTOINVO             EXIT IF NOT
         LA    R1,2(0,R1)          POINT TO SELECT CHARACTER
         $CFSEL (M,CTOSET),(J,CTOJ),(T,CTOT),OPERAND=(R1)
CTOINVO  L     R1,0(0,WD)          POINT TO
         $CFINVO OPERAND=(R1)      INVALID OPERAND
CTOJ     OI    COMNULOP,UCMDISPJ   SET TO DISPLAY JOB ID
         B     CTOSET              SET UCME
CTOT     OI    COMNULOP,UCMDISPI   SET TO DISPLAY TIME STAMP
         B     CTOSET              SET UCME
         EJECT
***********************************************************************
*                                                                     *
*        $T RX.CON,D=M/D=J/C=T - SET REMOTE CONSOLE DISPLAY OPTION    *
*                                                                     *
*        M     = DISPLAY MESSAGE TEXT ONLY                            *
*        J     = DISPLAY JOB ID AND MESSAGE TEXT                      *
*        T     = DISPLAY TIME STAMP, JOB ID, AND TEXT                 *
*                                                                     *
***********************************************************************
CTOR     DS    0H
         USING RATDSECT,WA
* WA SET TO RAT ADDRESS BY DEVICE COMMAND GROUP CONTROL
         TM    COMAUTH,COMD        IS CONSOLE RESTRICTED FOR DEVICE  R4
         BO    CTOINVO             EXIT IF YES
         TM    COMAUTH,CMBFLAGR    IS THIS A REMOTE RESTRICTION      R4
         BZ    CTORCOK             DO NEXT OPERAND IF NOT
         CLC   COMJROUT,RATROUTE   CHECK CONSOLE ROUTE FIELD        R41
         BNE   CTOINVO             EXIT IF NOT
CTORCOK  BXLE  WD,WE,CTORSEL       IF MORE OPERANDS EXAMINE
CTORSET  NI    RATCONF,255-RATCONFT-RATCONFJ RESET OPTIONS
         OC    RATCONF,COMNULOP    SET SELECTIONS
         B     CTOXIT              RETURN
CTORSEL  L     R1,0(0,WD)          POINT TO OPERAND
         CLC   0(2,R1),=C'D='      CHECK FOR D=
         BNE   CTOINVO             ERROR IF NOT
         LA    R1,2(0,R1)          POINT TO SELECT CHARACTER
         $CFSEL (M,CTORSET),(J,CTORJ),(T,CTORT),OPERAND=(R1)
         B     CTOINVO             ERROR EXIT
CTORJ    OI    COMNULOP,RATCONFJ   SET TO DISPLAY JOB, TEXT
         B     CTORSET             SET FLAG
CTORT    OI    COMNULOP,RATCONFT   SET TO DISPLAY TIME, JOB, TEXT
         B     CTORSET             SET FLAG
         DROP  WA
         SPACE 2
         LTORG ,
         TITLE 'HASP COMMAND PROCESSOR HASPCAOC - AUTOMATIC OPERATOR COC
               MMANDS'
HASPCAOC $COMGRUP CA,SA,TA,ZA      AUTOMATIC OPERATOR COMMANDS
***********************************************************************
*                                                                     *
*        $C A -- CANCEL AUTOMATIC OPERATOR COMMANDS                   *
*                                                                     *
***********************************************************************
         USING ACTDSECT,WA
         USING ACEDSECT,WB
CCA      L     WA,$ACTABLE         POINT TO ACT
         L     WD,ACTACEF          POINT TO FIRST FREE ELEMENT
         ICM   R1,15,ACTACE        POINT TO FIRST ACTIVE ELEMENT
         BZ    CCANACT             BR IF NO ACTIVE
         BAL   LINK,COMACEKT       KILL TIMER
         L     R1,ACTACE           POINT TO ACE
CCAFIND  LR    R15,R1              POINT TO FIRST
CCAENDAL LR    WB,R1               POINT TO ACE
         ICM   R1,15,ACEACE        POINT TO NEXT
         BNZ   CCAENDAL            LOOP
         ST    R1,ACTACE           ZERO ACTIVE POINTERS
         ST    R1,ACTACEZ          SET ACTIVE POINTERS
         ST    WD,ACEACE           SET OLD FREE BEHIND
         ST    R15,ACTACEF         SET NEW FREE CHAIN
CCARET   $CRET MSG=OK              RETURN WITH OK
CCANACT  ICM   R1,15,ACTACEZ       PICK UP FIRST HALTED ACE
         BNZ   CCAFIND             FIND END
         B     CCARET              RETURN
***********************************************************************
*                                                                     *
*        $S A -- START AUTOMATIC OPERATOR COMMANDS                    *
*                                                                     *
***********************************************************************
CSA      L     WA,$ACTABLE         POINT TO ACT
         NI    ACTFLAG,255-ACTFLAGZ TURN OFF HALT FLAG IF ON
         ICM   WB,15,ACTACEZ       PICK UP HALTED ACE Q
         BZ    CCARET              RETURN
         ST    WB,ACTACE           PUT INTO ACTIVE CHAIN
         SLR   WB,WB               ZERO WORK
         ST    WB,ACTACEZ          SET ZERO IN HALTED
         BAL   LINK,COMACEKT       KILL TIMER
         B     CCARET              RETURN
         EJECT
***********************************************************************
*                                                                     *
*        $T A ID,I=SSSS/T=HH.MM/CANCEL/'TEXT' -- SET ACE              *
*                                                                     *
*        ID    = USER OR SYSTEM ASSIGNED ACE ID                       *
*        HH.MM = TIME OF CURRENT DAY TO EXECUTE 'TEXT' (00.01-99.59)  *
*        SSSS  = TIME INTERVAL BETWEEN EXECUTIONS                     *
*        CANCEL= DELETE ACE                                           *
*        'TEXT'= COMMAND(S) TO EXECUTE AT TIME INDICATED              *
*                                                                     *
***********************************************************************
CTA      DS    0H                  START CHANGE ACE COMMAND
         CLC   COMVERB(4),=C'TALL' TEST FOR $TALL COMMAND
         BNE   CTANOTAL            NO--CONTINUE MODIFY ACE CMND
         LH    R1,=Y(CTALL-HASPCSY1) PICK-UP OFFSET TO $TALL COMMAND
         L     BASE3,=A(HASPCSY1)  POINT TO $TALL PROCESSING GROUP
         ALR   R1,BASE3            COMPUTE $TALL ENTRY ADDRESS
         BR    BASE3               EXIT TO $TALL COMMAND
CTANOTAL DS    0H                                                    R4
         L     WA,$ACTABLE         POINT TO ACE TABLE
         BAL   LINK,COMACETR       GET NEW BASE
         B     CTATERR             ERROR EXIT
CTAA     L     R1,0(0,WD)          POINT TO OPERAND
         L     WC,4(0,WD)          POINT TO NEXT
         BCTR  WC,0                REDUCE TO OPERAND
         BCTR  WC,0                LAST CHARACTER
         SR    WC,R1               GET COUNT OF ID
         BNP   CTANOID             BR IF NO ID
         CH    WC,=H'4'            CHECK FOR WITHIN RANGE
         BH    CTAINVO             EXIT IF OPERAND INVALID
         BCTR  WC,0                GET MACHINE LEBGTH
         MVC   COMEWORK,=CL4' '    BLANK COMEWORK
         EX    WC,CTAMID           MOVE ID TO TEMPORARY
* FIND ACE WITH ID INDICATED
         LA    WB,ACTACE-(ACEACE-ACEDSECT) POINT TO ACTIVE HEAD
         TM    ACTFLAG,ACTFLAGZ    IS QUEUE HALTED
         BZ    CTASACE             SKIP NEXT IF NOT
         LA    WB,ACTACEZ-(ACEACE-ACEDSECT) POINT TO HALTED HEAD
CTASACE  LR    R15,WB              COPY POINTER
         ICM   WB,15,ACEACE        POINT TO NEXT ACE
         BZ    CTACENEW            EXIT IF END
         CLC   ACEID,COMEWORK      CHECK FOR MATCH
         BNE   CTASACE             LOOP
         BAL   LINK,CTAACECK       CHECK AUTHORITY
         B     CTAAOK              OK, CONTINUE             +0
* CONSOLE DOES NOT HAVE AUTHORITY TO REFERENCE THE ACE      +4
CTAINVO  MVC   COMMAND(8),0(R1)    SHIFT TEXT
         MVC   COMMAND+8(22),=C' INVALID SPECIFICATION'
         LA    R0,8+22             SET LENGTH
         B     CTALDISR            EXIT WITH DISPLAY
         SPACE 1
CTAINVC $CFINVC ,                  INVALID COMMAND ERROR EXIT        R4
         EJECT
CTAAOK   BXLE  WD,WE,CTAMODS       CHECK FOR MORE OPERANDS
CTALDIS  BAL   LINK,CTADIS         PREPARE DISPLAY
CTALDISR TM    ACTFLAG,ACTFLAGZ    HALTED
         BZ    CTALDISX            LET IT GO AS IS
         $CWTO L=(R0)              DISPLAY WHAT WE HAVE
         MVC   COMMAND(COMACEML-2),COMACEMT SET DIAGNOSTIC
         LA    R0,COMACEML-2       SET LENGTH
CTALDISX $CRET L=(R0)              EXIT WITH DISPLAY
* REMOVE ACE FROM QUEUE AND BUILD UPON IT
CTAMODS  MVC   ACEACE-ACEDSECT(,R15),ACEACE REMOVE ACE
***********************************************************************
*                                                                     *
*        MODIFY ACE (ACE IS OFF ALL CHAINS)                           *
*                                                                     *
***********************************************************************
CTAMOD   L     R1,0(0,WD)          POINT TO OPERAND
         L     WC,4(0,WD)          POINT TO NEXT
         BCTR  WC,0                POINT TO COMMA
         CLI   1(R1),C'='          IS IT T OR I
         BE    CTAMTIME            IF SO MODIFY TIME
* MUST BE CANCEL OR TEXT
         BCTR  WC,0                POINT TO LAST CHARACTER
         CLI   0(R1),C''''         CHECK FOR APOSTROPHI
         BE    CTATEXT             IF SO SET TEXT
         CLI   0(R1),C'C'          IS IT CANCEL
         BE    CTACAN              CANCEL IT IF YES
CTAABORT MVC   COMMAND(8),0(R1)    SHIFT ERROR
         MVC   COMMAND+8(22),=C' INVALID SPECIFICATION'
         LA    R0,22+8             SET MESSAGE LENGTH
CTAFREE  $CWTO L=(R0)              SEND MESSAGE
         L     WA,$ACTABLE         POINT TO ACT
CTACAN   MVC   ACEACE,ACTACEF      PUT FREE QUEUE BEHIND
         ST    WB,ACTACEF          FREE ACE
         B     CTALDIS             DISPLAY AND EXIT
CTATEXT  CLI   0(WC),C''''         CHECK FOR APOSTROPHI
         BNE   *+6                 SKIP NEXT
         BCTR  WC,0                REDUCE BY 1
         BCTR  WC,0                REDUCE FOR MACHINE COUNT
         SR    WC,R1               CALCULATE MOVE COUNT
         BM    CTAABORT            ABORT IF NULL
         CH    WC,=Y(L'ACETEXT)    MAKE SURE NOT TOO LONG
         BNL   CTAABORT            ABORT IF TOO LONG
         CLC   1(1,R1),COMMAND     CHECK FOR COMMAND CHARACTER FIRST
         BNE   CTAABORT            ABORT IF NOT
         MVI   ACETEXT,C' '        BLANK OUT TEXT
         MVC   ACETEXT+1(L'ACETEXT-1),ACETEXT AREA
         EX    WC,CTAMTXT          MOVE TEXT
         OI    ACEFLAG,ACEFLAGD    SET TEXT OK FLAG
CTAMODN  BXLE  WD,WE,CTAMOD        MODIFY MORE
         MVC   COMMAND(21),=C'INSUFFICIENT OPERANDS'
         LA    R0,21               SET LENGTH
         TM    ACEFLAG,ACEFLAGD+ACEFLAGT DO WE HAVE REQUIRED PARMS
         BNO   CTAFREE             SEND DIAGNOSTIC IF NOT
         L     R0,ACETIME          GET TIME OF COMMAND
         LR    R1,WB               COPY POINTER
         LR    WC,WB               SAVE ACE ADDRESS
         BAL   LINK,COMAADD        ADD ACE TO ACTIVE CHAIN
         LR    WB,WC               BACK TO ACE
         B     CTALDIS             DISPLAY ACE
CTAMTIME LA    R14,2(0,R1)         POINT TO NUMERIC
         SR    WC,R14              GET LENGTH OF SSSS
         BNP   CTAABORT            ABORT IF NULL
         SLR   R0,R0               ZERO AC
         CLI   0(R1),C'T'          IS IT T
         BE    CTATIME             BR IF YES
         CLI   0(R1),C'I'          IS IT I
         BNE   CTAABORT            ABORT IF NOT
* USER WANTS INTERVAL
         CH    WC,=H'4'            CHECK FOR TOO LONG
         BH    CTAABORT            ABORT IF TOO LONG
CTAIL    MH    R0,=H'10'           MULTIPLY BY 10
CTAILA   IC    R15,0(,R14)         PICK UP CHARACTER
         N     R15,=A(X'F')        MASK OUT HIGH VALUES
         CLI   0(R14),C'0'         CHECK FOR NUMERIC
         BL    CTAABORT            ABORT IF LOW
         AR    R0,R15              ADD
         LA    R14,1(0,R14)        UP 1
         BCT   WC,CTAIL            LOOP
         CLI   0(R1),C'T'          IS IT T
         BE    CTATIMEC            BR IF YES
         CH    R0,=H'30'           CHECK FOR BELOW 30
         BL    CTAABORT            EXIT IF LOW
         STH   R0,ACEINTV          SET INTERVAL
         OI    ACEFLAG,ACEFLAGT    SET TIME IS SET
         B     CTAMODN             LOOP
CTATIME  CH    WC,=H'5'            CHECK FOR TOO LONG
         BH    CTAABORT            ABORT IF LONG
         CH    WC,=H'4'            CHECK FOR TOO SHORT
         BL    CTAABORT            ABORT IF LOW
         BE    CTALHR              DO 1 DIGIT HOUR
         CLI   0(R14),C'0'         CHECK FOR NUMERIC
         BL    CTAABORT            ABORT IF NOT
         IC    R0,0(,R14)          PICK UP VALUE
         N     R0,=A(X'F')         PURIFY
         MH    R0,=H'10'           MULTIPLY BY 10
         LA    R14,1(0,R14)        ACCOUNT FOR SPACE
CTALHR   CLI   0(R14),C'0'         NUMERIC
         BL    CTAABORT            ABORT IF NOT
         IC    R15,0(,R14)         PICK UP CHARACTER
         N     R15,=A(X'F')        PURIFY
         AR    R0,R15              ACCUMULATE
         CLI   1(R14),C'.'         CHECK FOR SEPARATOR
         BNE   CTAABORT            EXIT IF NOT OK
         MH    R0,=H'6'            MULTIPLY BY 6
         LA    WC,2                SET 2
         LA    R14,2(0,R14)        UP 2
         B     CTAILA              CONVERT LAST 2
CTATIMEC CH    R0,=H'6000'         CHECK FOR BEYOND MAXIMUM
         BNL   CTAABORT            ABORT IF YES
         MH    R0,=H'60'           GET NUMBER OF SECONDS
         ST    R0,ACETIME          SET TIME OF DAY
         OI    ACEFLAG,ACEFLAGT    SET TIME IS SET
         B     CTAMODN             LOOP
* USER DID NOT GIVE ID - DISPLAY OR CREATE ACE
CTANOID  BXLE  WD,WE,CTAGETID      IF MORE PARMS GET ID
         MVC   COMMAND(26),=C'NO AUTOMATIC COMMAND FOUND'
         LA    R0,26               SET COUNT
         LA    WB,ACTACE-(ACEACE-ACEDSECT) POINT TO HEAD OF ACES
         TM    ACTFLAG,ACTFLAGZ    CHECK FOR HALTED
         BZ    CTADAL              SKIP NEXT IF NOT
         LA    WB,ACTACEZ-(ACEACE-ACEDSECT) POINT TO HALTED HEAD
CTADAL   ICM   WB,15,ACEACE        POINT TO NEXT ACE
         BZ    CTALDISR            EXIT WITH MESSAGE
         BAL   LINK,CTAACECK       CHECK CONSOLE AUTHORITY
         B     CTADALL             DO DISPLAY IF OK         +0
         B     CTADAL              LOOP                     +4
CTADALL  BAL   LINK,CTADIS         CREATE MESSAGE
CTADALLA ICM   WB,15,ACEACE        POINT TO NEXT ACE
         BZ    CTALDISR            EXIT WITH MESSAGE
         BAL   LINK,CTAACECK       CHECK CONSOLE AUTHORITY
         B     *+8                 SKIP NSI IF OK           +0
         B     CTADALLA            GET NEXT ACE IF NOT OK   +4
         $CWTO L=(R0)              DISPLAY
         L     WA,$ACTABLE         RESTORE WA
         B     CTADALL             LOOP
         EJECT
***********************************************************************
*                                                                     *
*        SUPPLY AN ACE ID LEFT ADJUSTED                               *
*                                                                     *
***********************************************************************
CTAGETID L     R1,ACTBID           PICK UP BASE ID
         LA    R1,1(0,R1)          UP 1
         CH    R1,=H'9999'         CHECK FOR ABOVE MAX
         BNH   *+8                 SKIP RESET
         LA    R1,1                SET NEW BASE
         ST    R1,ACTBID           SET FOR NEXT TIME
         LR    R0,R1               COPY VALUE
         $CFCVE ,                  CONVERT TO EBCDIC
         MVC   COMEWORK,COMDWORK+1 PUT INTO COMEWORK
CTASLIDE CLI   COMEWORK,C' '       CHECK FOR BLANK
         BNE   CTAID               IF NOT LOOK FOR ID
         MVC   COMEWORK,COMEWORK+1 SLIDE OVER 1
         B     CTASLIDE            LOOP
CTAID    LA    WB,ACTACE-(ACEACE-ACEDSECT) POINT TO HEAD OF CHAIN
         TM    ACTFLAG,ACTFLAGZ    CHECK FOR HALTED
         BZ    CTAIDS              SCAN IDS
         LA    WB,ACTACEZ-(ACEACE-ACEDSECT) POINT TO HALTED HEAD
CTAIDS   ICM   WB,15,ACEACE        POINT TO NEXT ID
         BZ    CTANEW              BUILD NEW IF NO MATCH
         CLC   ACEID,COMEWORK      CHECK FOR MATCH
         BNE   CTAIDS              LOOP
         B     CTAGETID            GET NEXT ID
***********************************************************************
*                                                                     *
*        CREATE A NEW ACE                                             *
*                                                                     *
***********************************************************************
CTACENEW BXH   WD,WE,CTAANF        GO TO NEXT OPERAND, ERROR IF NONE
CTANEW   ICM   WB,15,ACTACEF       PICK UP NEW ACE
         BZ    CTAOUT              BR IF NO ACE
         MVC   ACTACEF,ACEACE      SET NEW FREE ACE
         MVC   ACEFLAG,COMAUTH     COPY RESTRICTIONS                 R4
         MVC   ACECON,COMUCM       COPY POSSIBLE UCMID               R4
         NI    ACEFLAG,ACEFLAGR    FORCE OTHER FLAGS OFF             R4
         TM    COMFLAG,CMBFLAGU    IS THIS UCMID                     R4
         BO    CTANEWA             SKIP NEXT IF YES
         MVI   ACECON,1            SET UCMID OF 1
CTANEWA  XC    ACEINTV,ACEINTV     ZERO OUT INTERVAL
         XC    ACETIME,ACETIME     ZERO TIME
         MVI   ACETEXT,C' '        BLANK
         MVC   ACETEXT+1(L'ACETEXT-1),ACETEXT OUT TEXT AREA
         MVC   ACEID,COMEWORK      SET ACE ID
         B     CTAMOD              FILL IT IN
         EJECT
***********************************************************************
*                                                                     *
*        FORMAT A DISPLAY OF AN ACE                                   *
*                                                                     *
***********************************************************************
CTADIS   MVC   CTABASIC,=C'ID **** T=**.** I=**** '
         MVC   CTAAID,ACEID        SET ID
         ICM   R1,15,ACETIME       PICK UP TIME
         BNP   CTADNT              BR IF NO TIME
         SR    R0,R0               ZERO R0
         D     R0,=A(60*60)        SEPARATE HOURS
         CVD   R1,COMDWORK         CONVERT
         UNPK  CTAAHH,COMDWORK     TO EBCDIC
         OI    CTAAHH+1,C'0'       SET SIGN
         LR    R1,R0               PUT REMAINDER
         SLR   R0,R0               IN R1
         D     R0,=A(60)           DIVIDE BY SECONDS/MIN
         CVD   R1,COMDWORK         CONVERT
         UNPK  CTAAMM,COMDWORK     TO EBCDIC
         OI    CTAAMM+1,C'0'       SET SIGN
CTADNT   LH    R0,ACEINTV          PICK UP INTERVAL
         CVD   R0,COMDWORK         CONVERT TO DECIMAL
         MVC   COMDWORK-1(6),=X'402020202120'
         ED    COMDWORK-1(6),COMDWORK+5 THEN TO EBCDIC
         MVC   CTAASS,COMDWORK+1   SET SSSS
         MVC   CTAATEXT,ACETEXT    MOVE TEXT
         LA    R0,CTAATEXT-CTABASIC+L'CTAATEXT SET MESSAGE LENGTH
         BR    LINK                RETURN
***********************************************************************
*                                                                     *
*        MISCELLANEOUS                                                *
*                                                                     *
***********************************************************************
CTAACECK IC    WC,COMAUTH          PICK UP RESTRICTION FLAGS         R4
         N     WC,=A(COMJDS)       PURIFY
         BZR   LINK                RETURN OK IF FULL AUTHORITY CONSOLE
         EX    WC,CTAAUTH          CHECK PARTIAL AUTHORITY OK
         BOR   LINK                RETURN OK IF SUFFICIENT
         B     4(0,LINK)           RETURN NOK
         SPACE 1
CTAOUT   MVC   COMMAND(31),=C'AUTOMATIC COMMAND LIMIT REACHED'
         LA    R0,31               SET LENGTH
         B     CTALDISR            EXIT WITH DIAGNOSTIC
         SPACE 1
CTATERR  OC    ACTACE,ACTACE       CHECK FOR EMPTY
         BZ    CTAA                IF ZERO GO ON
         OI    ACTFLAG,ACTFLAGZ    SET HALTED
         MVC   ACTACEZ,ACTACE      PUT QUEUE IN HALTED QUEUE
         XC    ACTACE,ACTACE       ZERO ACTIVE QUEUE
         B     CTAA                GO ON
         SPACE 1
CTAANF   MVC   COMMAND(26),=C'NO AUTOMATIC COMMAND FOUND'
         LA    R0,26               SET COUNT
         B     CTALDISR            EXIT
         EJECT
CTAMID   MVC   COMEWORK(*-*),1(R1) MOVE USER SPECIFIED ID
CTAAUTH  TM    ACEFLAG,*-*         CHECK FOR AUTHORITY
CTAMTXT  MVC   ACETEXT(*-*),1(R1) MOVE USER TEXT
CTABASIC EQU   COMMAND,23          RESPONSE PATTERN
CTAAID   EQU   CTABASIC+3,4        ACE ID
CTAAHH   EQU   CTAAID+7,2          HH
CTAAMM   EQU   CTAAHH+3,2          MM
CTAASS   EQU   CTAAMM+5,4          SSSS
CTAATEXT EQU   CTABASIC+23,L'ACETEXT TEXT AREA
         EJECT
***********************************************************************
*                                                                     *
*        $Z A -- HALT AUTOMATIC OPERATOR COMMANDS                     *
*                                                                     *
***********************************************************************
CZA      L     WA,$ACTABLE         POINT TO ACT
         OI    ACTFLAG,ACTFLAGZ    SHOW HALTED
         ICM   WB,15,ACTACE        PICK UP ACTIVE ACE
         BZ    CCARET              RETURN
         ST    WB,ACTACEZ          SET INTO HALTED QUEUE
         SLR   WB,WB               ZERO WORK
         ST    WB,ACTACE           SET ZERO IN ACTIVE
         BAL   LINK,COMACEKT       KILL TIMER
         B     CCARET              RETURN
         DROP  WA,WB
         SPACE 2
         LTORG ,
 TITLE 'HASP COMMAND PROCESSOR HASPCMS1 - MISC DISPLAY COMMANDS'
HASPCMS1 $COMGRUP DO,DU            DISPLAY COMMANDS
***********************************************************************
*                                                                     *
*        $D O -- DISPLAY OPERATOR REQUESTS                            *
*                                                                     *
***********************************************************************
CDO      DS    0H
* COMNULOP HIGH BYTE = 0 ON ENTRY
         USING CMBDSECT,R1
         SR    WB,WB               CURRENT ID IS ZERO
CDRLOOP  DS    0H
         LA    R1,$DOMQUE-(CMBCMB-CMB) POINT TO QUEUE HEAD           R4
CDRLOOPA ICM   R1,7,CMBCMB+1       POINT TO NEXT CMB                 R4
         BZ    CDREND              IF NONE EXIT
         CLM   WB,15,CMBDOMID      CHECK FOR DOMID                   R4
         BNL   CDRLOOPA            LOOP
         ICM   WB,15,CMBDOMID      PICK UP NEW ID                    R4
         SR    WD,WD               ZERO COUNT REGISTER
         IC    WD,CMBML            PICK UP LENGTH                    R4
         MVC   COMMAND(L'CMBJOBID+1),CMBJOBID MOVE JOBID PORTION
         LA    WA,CMBJOBN-CMBMSG+1 GET LENGTH OF SPECIAL TEXT
         SLR   WD,WA               GET MACHINE MOVE COUNT
         EX    WD,CDRMVC           MOVE
         MVI   COMNULOP,X'80'      TURN ON FOUND FLAG
         NI    COMMID+1,X'FE'      INDICATE JOB ID SET (IF ANY)
         LA    R0,L'CMBJOBID+2(,WD)  GET TRUE LENGTH
         $CWTO L=(R0)              DISPLAY MESSAGE
         B     CDRLOOP             LOOP
CDREND   DS    0H
         CLI   COMNULOP,0          DID WE DISPLAY ANYTHING
         BE    CDRNREQ             IF NOT DISPLAY EMPTY
         $CRET ,                   EXIT
CDRNREQ  $CRET MSG='NO OPERATOR REQUESTS' SEND MSG
CDRMVC   MVC   COMMAND+L'CMBJOBID+1(*-*),CMBJOBN MOVE NORMAL TEXT
         DROP  R1
         EJECT
***********************************************************************
*                                                                     *
*                         ----DISPLAY UNITS-----                      *
*                                                                     *
*                                                                     *
*        $DU   ( ,RDRS )   ( ,RMTN (-N)  )    ( ,ACTIVE  )            *
*              ( ,PRTS )   ( ,DEVICENAME )    ( ,STARTED )            *
*              ( ,PUNS )                      ( ,SHORT   )            *
*              ( ,LGNS )                                              *
*              ( ,LNES )   NOTE: ANY COMBINATION OF OPERANDS          *
*              ( ,RDI  )         MAY BE USED.                         *
*              ( ,RMTS )                                              *
*              ( ,ALL  )                                              *
*              ( ,TP   )                                              *
*                                                                     *
*      **DISPLAY OPERANDS                             CONNECTED RMT   *
*                                                       BREAKDOWN     *
*        RDRS---ALL LOCAL READERS ------------------------ N/A        *
*        PRTS---ALL LOCAL PRINTERS ----------------------- N/A        *
*        PUNS---ALL LOCAL PUNCHES ------------------------ N/A        *
*        LGNS---ALL VTAM INTERFACES ---------------------- NO         *
*        LNES---ALL TP LINES ----------------------------- YES        *
*        RDI----ALL INTERNAL READERS --------------------- N/A        *
*        RMTS---ALL REMOTES ------------------------------ YES        *
*        ALL----ALL LOCAL DEVICES AND INTERNAL READERS --- YES        *
*        TP-----ALL TP LNES AND VTAM INTERFACES ---------- NO         *
*                                                                     *
*      **MODIFIER OPERANDS                                            *
*                                                                     *
*        ACTIVE---DISPLAY ONLY CONNECTED TP LINES OR ACTIVE DEVICES   *
*        STARTED--DISPLAY ONLY DEVICES WHICH ARE STARTED '$S'         *
*        SHORT----ALL DISPLAYS IN NON-EXTENDED FORM                   *
*                                                                     *
*      **NO DISPLAY OPERANDS --- DISPLAY OF ALL LOCAL DEVICES         *
*                                IN SHORT FORM. ACTIVE OR STARTED     *
*                                CAN BE USED WITHOUT OTHER OPERANDS   *
*                                                                     *
***********************************************************************
CDU      DS    0H                  $DU COMMAND ENTRY POINT           R4
         SPACE 1                                                     R4
***********************************************************************
*        PRE-PROCESS ALL OPERANDS                                     *
***********************************************************************
         LA    WE,0                SET OFFSET INDEX ZERO             R4
         LA    WB,CDUTABLE         PICK UP TABLE ADDRESS             R4
         CR    WD,WF               CHECK FOR PLAIN $DU               R4
         BE    CDUFND              YES, TREAT AS MATCH TABLE-ENTRY-0 R4
         ST    WE,0(,WD)           IGNORE FIRST OPERAND              R4
         LA    WD,4(,WD)            AND SKIP IT                      R4
CDUFIND  LA    WE,0                SET OFFSET INDEX ZERO             R4
         LA    WB,CDUTABLE         PICK UP TABLE ADDRESS             R4
         L     R1,0(,WD)           PICK UP OPERAND POINTER           R4
***********************************************************************
*        SEARCH TABLE FOR NON-SPECIFIC OPERAND                        *
***********************************************************************
CDUSRCH  LA    WB,CDUTBSZ(,WB)     FIND NEXT TABLE ENTRY             R4
         LA    WE,1(,WE)           INCREMENT OFFSET INDEX            R4
         L     WA,CDUTBSET(,WB)    PICK UP SETUP INSTRUCTION         R4
         LTR   WA,WA               TEST FOR TABLE END                R4
         BZ    CDUNOFND            YES, BR- TRY SPECIFIC DCT         R4
         IC    WC,CDUTBLEN(,WB)    PICK UP COMPARE LENGTH            R4
         EX    WC,CDUCLC           COMPARE OPERAND                   R4
         BNE   CDUSRCH             NOT EQUAL, BR - TRY NEXT ENTRY    R4
CDUFND   EX    0,CDUTBSET(,WB)     EXECUTE THE SETUP INSTRUCTION     R4
CDUGO    LTR   R1,R1               TEST FOR DCT ADDRESS              R4
         ST    R1,0(,WD)           STORE DCT ADDRESS OR ZERO         R4
         BZ    CDUERR              ZERO, COMPLETE OPERAND LOOP       R4
CDUINDEX STC   WE,0(,WD)           STORE TABLE OFFSET                R4
         B     CDUMDTST            SKIP ERROR FLAGGING              R41
CDUERR   OI    CDUFLAG2,CDUFLERR   INDICATE SOME OPERANDS IN ERROR   R4
CDUMDTST TM    CDUTBFL1(WB),CDUFLMOD  TEST OPERAND TYPE             R41
         BO    CDUNOTOP            BRANCH IF MODIFIER               R41
         OI    CDUFLAG2,CDUFLOPR   SHOW ACTION OPERAND FOUND        R41
CDUNOTOP LA    WD,4(,WD)           BUMP TO NEXT OPERAND             R41
         CLR   WD,WF               TEST FOR LAST OPERAND             R4
         BNH   CDUFIND             NO, PRE-PROCESS NEXT OPERAND      R4
         SPACE 1                                                     R4
***********************************************************************
*        DO DISPLAYS FOR ALL PRE-PROCESSED OPERANDS                   *
***********************************************************************
         SLR   R1,R1               CLEAR OPERAND VALUE              R41
         LA    WD,COMPNTER         RESTORE ADDRESS OF FIRST OPERAND  R4
         TM    CDUFLAG2,CDUFLOPR   TEST FOR MODIFIER ONLY CASES     R41
         BO    CDUNEXT             BR IF ANY NON-MODIFIER OPERANDS  R41
         EX    0,CDUTABLE+CDUTBSET USE TABLE-ENTRY-0 SETUP INSTRCTN R41
         ST    R1,0(,WD)            TO SIMULATE NULL OPERAND CASE   R41
CDUNEXT  L     R1,0(,WD)           PICK UP OPERAND                   R4
         LTR   R1,R1               TEST FOR DUMMY OPERAND            R4C
                                      (PRE-PROCESSED ERRORS)         R4
         BZ    CDULOOP             IGNORE - DO NEXT OPERAND          R4
         LA    R1,0(,R1)           PURIFY IT                         R4
         SLR   WB,WB               CLEAR OFFSET REGISTER             R4
         IC    WB,0(,WD)           PICK UP TABLE INDEX               R4
         MH    WB,=AL2(CDUTBSZ)    COMPUTE TRUE OFFSET               R4
         LA    WB,CDUTABLE(WB)     PICK UP TABLE ENTRY ADDRESS       R4
         MVC   CDUFLAG1(2),CDUTBFL1(WB) COPY FLAGS AND DEVICE TYPE  R41
         MVC   CDUMASK(1),CDUTBMSK(WB)      TO PROCESSOR WORK AREA  R41
         L     WA,CDUTBRTN(,WB)    PICK UP DISPLAY ROUTINE ADDRESS   R4
         BR    WA                  EXECUTE DISPLAY ROUTINE           R4
         SPACE 1                                                     R4
CDUCLC   CLC   CDUTBKEY(*-*,WB),0(R1) **** EXECUTED ****             R4
         SPACE 1                                                     R4
         EJECT                                                       R4
***********************************************************************
*        OPERAND = SPECIFIC DCT NAME                                  *
***********************************************************************
CDUNOFND $CFDCTL POINTER=(WD)      TRY TO LOCATE THE DEVICE BY NAME  R4
         LTR   R1,R1               TEST RETURNED DCT ADDRESS         R4
         BP    CDUGO               VALID, BR - STORE DCT ADDRESS     R4
         SLR   R1,R1               FORCE ZERO                        R4
         B     CDUGO               COMPLETE DUMMY OPERAND            R4
         SPACE 1                                                     R4
***********************************************************************
*        OPERAND IS 'RMTS'                                            *
***********************************************************************
CDURMALL LA    R1,1                SET FIRST RMT TO DISPLAY TO 1     R4
         LH    R0,$NUMRJE          SET LAST RMT TO DISPLAY TO MAX    R4
         LTR   R0,R0               CHECK FOR REMOTES                R41
         BZ    CDURERR             BR IF NONE                       R41
         B     CDURMT              GO COMPLETE PRE-PROCESSING RMT    R4
         SPACE 1                                                     R4
***********************************************************************
*        OPERAND IS RMTNNN(-NNN)                                      *
***********************************************************************
CDURMTS  $CFCVB POINTER=(WD),NOK=CDURERR CONVERT OPERAND             R4
         LA    WA,0                CLEAR THE                         R4
         ST    WA,0(,WD)             THE OPERAND                     R4
         LTR   R1,R1               TEST LOW REMOTE NUMBER VALIDITY   R4
         BNP   CDURERR             BR IF INVALID                    R41
         CH    R0,$NUMRJE          TEST HIGH REMOTE NUMBER VALIDITY  R4
         BH    CDURERR             BR IF INVALID                    R41
CDURMT   BCTR  R0,0                DECREMENT LOW AND                 R4
         BCTR  R1,0                 HIGH REMOTE NUMBERS              R4
         STC   R0,2(WD)            STORE REMOTE                      R4
         STC   R1,1(WD)             RANGE IN OPERAND                 R4
         B     CDUINDEX            GO FINISH OPERAND LOOP            R4
         SPACE 1                                                     R4
CDURERR  SLR   R1,R1               INDICATE NO DEVICE LOCATED        R4
         B     CDUGO               FLAG ERROR - DO NEXT OPERAND      R4
         EJECT                                                       R4
***********************************************************************
*        DISPLAY ONE OR MORE REMOTES (VIA RAT)                        *
***********************************************************************
CDUREMOT SLR   WC,WC               CLEAR FIRST AND                   R4
         SLR   WE,WE                LAST REMOTE INDICES              R4
         IC    WC,1(,WD)           PICK UP FIRST REMOTE DISPLAY      R4
         IC    WE,2(,WD)           PICK UP LAST REMOTE TO DISPLAY    R4
         MH    WC,=AL2(RATTLE)     COMPUTE RAT                       R4
         MH    WE,=AL2(RATTLE)      OFFSETS                          R4
         L     R1,$RATABLE         COMPUTE                           R4
         LA    WC,0(WC,R1)          HIGH AND LOW                     R4
         LA    WE,0(WE,R1)           RAT ADDRESS                     R4
         LR    R1,WC               COPY FIRST RAT ADDRESS            R4
         B     CDURMGRP            GO DISPLAY RMT GROUP              R4
         SPACE 1                                                     R4
***********************************************************************
*        GENERAL DCT DISPLAY ROUTINE                                  *
***********************************************************************
CDUSPLAY LA    R1,0(,R1)           PURIFY DCT ADDRESS               R41
         TM    CDUFLAG2,CDUFLACT   TEST FOR ACTION MODIFIER         R41
         BNO   CDUSTEST            BRANCH IF NOT SPECIFIED          R41
         CLI   DCTDEVTP-DCTDSECT(R1),DCTLNE  TEST DEVICE TYPE       R41
         BNE   CDUZINUS            IF NOT LNE, GO TEST IN USE       R41
         OC    MDCTRAT-DCTDSECT(4,R1),MDCTRAT-DCTDSECT(R1)  TEST    R41C
                                   LINE CONNECTION                  R41
         BZ    CDURSUB             IF NOT CONNECTED, SKIP DISPLAY   R41
         B     CDUSHTST             ELSE GO DO DISPLAY              R41
CDUSTEST TM    CDUFLAG2,CDUFLSTR   TEST FOR STARTED MODIFIER        R41
         BNO   CDUSHTST            BRANCH IF NOT - DO DISPLAY       R41
         TM    DCTSTAT-DCTDSECT(R1),DCTDRAIN  TEST DEVICE STATUS    R41
         BNO   CDUSHTST            NOT DRAINED - GO DO DISPLAY      R41
CDUZINUS TM    DCTSTAT-DCTDSECT(R1),DCTINUSE  TEST DEVICE STATUS    R41
         BNO   CDURSUB             BRANCH IF NOT IN USE, SKIP DSPLY R41
CDUSHTST TM    CDUFLAG2,CDUFLSHT   TEST FOR SHORT MODIFIER          R41
         BO    CDUDSPL             FORCE NON-EXTENDED DSPLY IF ON   R41
         TM    CDUFLAG1,CDUFLNEX   TEST FOR EXTENED REQUEST         R41
         BO    CDUDSPL             IF NO EXTENED REQD, GO DSPLY     R41
         ICM   R1,8,=X'0F'         SET HI ORDER FOR EXTENDED DISP   R41
CDUDSPL  TM    CDUFLAG1,CDUFLCLS   TEST FOR CLASS CHECK REQUESTED   R41
         BNO   CDUDCTD             NO CHECK, BR - GO DSPLY          R41
         IC    WA,CDUDEVTP         PICK UP DEVICE CLASS             R41
         EX    WA,CDUTM            TEST DEVICE CLASS                R41
         IC    WA,CDUMASK          PICK UP BRANCH MASK              R41
         EX    WA,CDUBRNCH         EXECUTE BRANCH INSTRUCTION       R41
CDUDCTD  $CFDCTD EXT=SET           DISPLAY THE DCT                  R41
         OI    CDUFLAG2,CDUFLFND   SHOW SOMETHING DISPLAYED         R41
         EJECT                                                      R41
***********************************************************************
*        SNA LUNAME SUB-DISPLAY ROUTINE                               *
***********************************************************************
         TM    CDUFLAG1,CDUFLLU    TEST FOR LUNAME SUB-DISPLAY REQD  R4
         BNO   CDURSUB             NO, BR - CONTINUE CURRENT DISPLAY R4
         CLI   DCTDEVTP-DCTDSECT,DCTLOG TEST FOR LOGON DCT           R4
         BE    CDULOGLU            YES, SKIP OTHER TESTS - DSPLY LUS R4
         TM    DCTDEVTP-DCTDSECT(R1),DCTRJE TEST FOR RJE DCT         R4
         BNO   CDURSUB             NO, BR - CONTINUE CURRENT DISPLAY R4
         TM    MDCTTYPE-DCTDSECT(R1),DCTPSNA TEST FOR SNA DEVICES    R4
         BNO   CDURSUB             NO, BR- CONTINUE CURRENT DISPLAY  R4
CDULOGLU L     WB,MDCTICE-DCTDSECT(,R1) GET ASSOC. ICE ADDR FROM DCT R4
         LTR   WB,WB               TEST FOR ANY SESSION PRESENT      R4
         BZ    CDURSUB             NO, BR- CONTINUE CURRENT DISPLAY  R4
         MVI   COMMAND,C' '        CLEAR THE                         R4
         MVC   COMMAND+1(L'COMMAND-1),COMMAND MESSAGE AREA           R4
         MVC   COMMAND+23(14),=CL14'SESSION(S) -' MOVE IN HEADING    R4
CDULUOOP LA    WA,COMMAND+23+14    INDENT LUNAME DISPLAY             R4
         MVC   0(L'ICESYMB,WA),ICESYMB-ICEDSECT(WB) MOVE IN LUNAME   R4
         LA    WA,L'ICESYMB+1(,WA) BUMP PAST SNA LUNAME              R4
         TM    DCTDEVTP-DCTDSECT(R1),DCTPRPU TEST FOR REMOTE DEVICES R4
         BNO   CDULUALC            NO, BR--GO TEST FOR ALLOCATION    R4
         TM    MDCTSTAT-DCTDSECT(R1),DCTPSUSP CHK FOR SUSPNDED SESN  R4
         BNO   CDULUALC            NO, BR--TRY OTHER STATES          R4
         MVC   0(9,WA),=CL9'SUSPENDED' SHOW SESSION SUSPENDED        R4
         B     CDULUDSP            GO DISPLAY SUSPENDED SESSION      R4
CDULUALC MVC   0(9,WA),=CL9'INACTIVE' ASSUME SESSION INACTIVE        R4
         TM    ICESTAT-ICEDSECT(WB),ICEALLOC TEST ASSUMPTION         R4
         BZ    CDULUCLO            INACTIVE, BR--GO TEST FOR CLOSING R4
         CLI   DCTDEVTP-DCTDSECT(R1),DCTLNE TEST FOR LINE SUB DSPLY  R4
         BE    CDULUNX             YES, BR--SKIP ACTIVE SESSIONS     R4
         MVC   0(9,WA),=CL9'ACTIVE' SHOW SESSION ACTIVE              R4
         TM    ICESTAT-ICEDSECT(WB),ICEDRAIN TEST FOR DRAINING       R4
         BZ    CDULULOG            NO, SKIP                          R4
         MVC   0(9,WA),=CL9'DRAINING' SHOW SESSION DRAINING          R4
         B     CDULULOG            GO TEST FOR TAGGING AND DISPLAY   R4
CDULUCLO TM    ICESTAT-ICEDSECT(WB),ICECLOSE TEST FOR CLOSING        R4
         BNO   CDULULOG            NO, BR--GO TEST TAGGING AND DSPLY R4
         MVC   0(9,WA),=CL9'CLOSING' SHOW SESSION CLOSING            R4
CDULULOG LA    WA,10(,WA)          MOVE PAST STATUS INDICATION       R4
         CLI   DCTDEVTP-DCTDSECT(R1),DCTLOG TEST FOR LOGON DCT DSPLY R4
         BNE   CDULUDSP            NO, BR--NO TAGGING REQD           R4
         LR    R0,R1               SAVE LOGON DCT ADDRESS            R4
         L     R1,ICELDCT-ICEDSECT(,WB) PICK UP ASSOC LINE DCT ADDR  R4
         LTR   R1,R1               TEST FOR LINE DCT PRESENT         R4
         BZ    CDULUTGD            NO, BR--NO TAGGING REQD           R4
         MVI   0(WA),C'('          INSERT OPEN PAREN INTO MSG        R4
         MVC   1(L'DCTDEVN,WA),DCTDEVN-DCTDSECT(R1) PUT LINE ID INTO R4C
                                                        MESSAGE      R4
         MVI   9(WA),C')'          CLOSE THE PAREN                   R4
CDULUTGD LR    R1,R0               RELOAD THE LOGON DCT ADDRESS      R4
CDULUDSP STM   R1,WA,COMDWORK      SAVE REGISTERS ACROSS WTO         R4
         $CWTO L=66                DISPLAY LUNAME MESSAGE            R4
         LM    R1,WA,COMDWORK      RELOAD REGISTERS                  R4
         MVC   COMMAND+23(L'COMMAND-22),COMMAND+22 BLANK USED AREA   R4
CDULUNXT TM    DCTDEVTP-DCTDSECT(R1),DCTDEV  TEST FOR RJE DEVICES   R41
         BNZ   CDURSUB             YES, BR--NO CHAINING NEEDED      R41
CDULUNX  LA    WB,ICEAPCHN-ICEDSECT(,WB) ASSUME LOGON DCT CHAIN USED R4
         CLI   DCTDEVTP-DCTDSECT(R1),DCTLOG TEST ASSUMPTION          R4
         BE    CDULUCHN            NO, BR--CHAIN TO NEXT ICE         R4
         LA    WB,(ICEALCHN-ICEAPCHN)(,WB) BUMP TO LNE DCT CHN FLD   R4
CDULUCHN L     WB,0(,WB)           PICK UP NEXT ICE ADDRESS          R4
         LA    WB,0(,WB)           PURIFY ADDRESS                    R4
         LTR   WB,WB               TEST FOR END OF CHAIN             R4
         BNZ   CDULUOOP            NO, BR--CONTINUE ICE SUB DSPLY    R4
         SPACE 1                                                     R4
***********************************************************************
*        REMOTE SUB-DISPLAY CODE                                      *
***********************************************************************
CDURSUB  TM    CDUFLAG1,CDUFLRMT   TEST FOR REMOTE-SUB DISPLAY REQD  R4
         BNO   CDUGRPLP            NO, BR CONTINUE MAIN LOOP         R4
         TM    CDUFLAG2,CDUFLSUB   ARE WE IN RMT SUB-DISPLAY LOOP    R4
         BNZ   CDUSUB              YES, CONTINUE SUB-DISPLAY         R4
         CLI   DCTDEVTP-DCTDSECT(R1),DCTLNE TEST FOR LINE DCT        R4
         BNE   CDUGRPLP            NO, CONTINUE MAIN LOOP            R4
         OI    CDUFLAG2,CDUFLSUB   SET SUB-DISPLAY IN PROGRESS       R4
         LR    WC,R1               SAVE LINE DCT POINTER             R4
CDUSUB   L     R1,MDCTDCT-DCTDSECT(,R1) PICK UP NEXT RMT DCT         R4
         LTR   R1,R1               TEST FOR REMOTE DCT PRESENT       R4
         BNZ   CDUSPLAY            YES, BR - GO DISPLAY REMOTE DCT   R4
         NI    CDUFLAG2,255-CDUFLSUB SHOW OUT OF REMOTE LOOP         R4
         LR    R1,WC               RESTORE LINE DCT/RAT POINTER      R4
         SPACE 1                                                     R4
***********************************************************************
*        GROUP DCT DISPLAY TERMINATION CODE                           *
***********************************************************************
CDUGRPLP TM    CDUFLAG1,CDUFLGRP   IS THIS A GROUP DISPLAY           R4
         BZ    CDULOOP             NO, BR - THEN GO DO NEXT OPERAND  R4
         TM    CDUFLAG1,CDUFLRAT   TEST FOR RAT BASED GROUP          R4
         BNO   CDUGROUP            NO, BR- PROCESS NORMAL DCT CHAIN  R4
CDUGRPL1 LA    WC,RATTLE(,R1)      LOCATE AND SAVE NEXT RAT ENTRY   R41
         CLR   WC,WE               TEST FOR END OF RAT (RMT) GROUP   R4
         BH    CDULOOP             YES, BR- GO DO NEXT OPERAND       R4
CDURMGRP OI    CDUFLAG2,CDUFLSUB   SHOW BACK IN REMOTE SUB-DISPLAY   R4
         TM    CDUFLAG2,CDUFLACT   TEST FOR ACTION MODIFIER         R41
         BNO   CDURMGP1            BRANCH IF NOT SPECIFIED          R41
         L     R1,RATLDCT-RATDSECT(,WC) GET LINE DCT ADDRESS        R41
         LA    R1,0(,R1)           PURIFY ADDRESS                   R41
         LTR   R1,R1               TEST FOR LINE DCT PRESENT        R41
         LR    R1,WC               RESET R1 TO RAT ADDR FOR BRANCH  R41
         BZ    CDUGRPL1            BRANCH IF NO LINE DCT            R41
CDURMGP1 LNR   R1,WC               LOAD -RAT FOR RAT DISPLAY        R41
         $CFDCTD EXT=SET           DISPLAY RAT INFO                 R41
         L     R1,RATLDCT-RATDSECT(,WC)  GET LINE DCT ADDRESS        R4
         LA    R1,0(,R1)           PURIFY ADDRESS                    R4
         LTR   R1,R1               TEST FOR LINE DCT PRESENT         R4
         BZ    SKIP290             NO, BR-- GO DISPLAY REMOTE        R4
         CL    WC,MDCTRAT-DCTDSECT(,R1) TEST FOR RMT SIGNED ON LINE  R4
         BE    CDUSPLAY            YES, BR--GO DISPLAY RMT AND LINE  R4
SKIP290  L     R1,RATRDCT-RATDSECT(,WC) GET FIRST REMOTE DCT ADDRESS R4
         B     CDUSPLAY            DISPLAY ONLY REMOTE               R4
CDUGROUP L     R1,DCTCHAIN-DCTDSECT(,R1) GO FIND NEXT DCT            R4
         LA    R1,0(,R1)           PURIFY ADDRESS                    R4
         LTR   R1,R1               TEST FOR END OF THE DCT CHAIN     R4
         BZ    CDULOOP             YES, BR- DO NEXT OPERAND          R4
         EJECT                                                      R41
         SPACE 1                                                     R4
***********************************************************************
*        DCT TYPE-GROUP DISPLAY TERMINATION                           *
***********************************************************************
CDUNOCLS TM    CDUFLAG1,CDUFLTYP   IS THIS A TYPE-GROUP DISPLAY      R4
         BNO   CDUSPLAY            NO, BR- NO CHECK - GO DISPLAY DCT R4
         IC    R0,CDUDEVTP         PICK UP DCT TYPE FOR COMPARE      R4
         CLM   R0,1,DCTDEVTP-DCTDSECT(R1)  COMPARE FOR TERMINATION   R4
         BE    CDUSPLAY            EQUAL - CONTINUE DISPLAY LOOP     R4
         SPACE 1                                                     R4
***********************************************************************
*        MAIN DISPLAY LOOP                                            *
***********************************************************************
CDULOOP  LA    WD,4(,WD)           MOVE TO NEXT OPERAND POINTER      R4
         CR    WD,WF               TEST FOR END OF OPERANDS          R4
         BNH   CDUNEXT             NO, CONTINUE WITH NEW OPERAND     R4
         SPACE 1                                                     R4
***********************************************************************
*        DISPLAY UNIT EXIT                                            *
***********************************************************************
CDUEXIT  DS    0H                                                    R4
         TM    CDUFLAG2,CDUFLERR   WERE ANY ERRORS ENCOUNTERED       R4
         BZ    CDUEXITC            NO, BR - JUST EXIT                R4
         $CRET MSG='INVALID OPERAND(S) DETECTED'                     R4
CDUEXITC TM    CDUFLAG2,CDUFLFND   TEST DISPLAY STATUS              R41
         BO    CDUEXITN            BRANCH IF DISPLAY DONE           R41
         $CRET MSG='NO DEVICE(S) FOUND'  SHOW NO DEVICES DISPLAYED  R41
CDUEXITN $CRET ,                   NORMAL RETURN                    R41
         SPACE 1                                                     R4
CDUTM    TM    DCTDEVTP-DCTDSECT(R1),*-* *** EXECUTED ***            R4
CDUBRNCH NOP   CDURSUB             *** EXECUTED ***                 R41
         EJECT                                                       R4
***********************************************************************
*        DISPLAY UNIT FLAG DEFINITONS                                 *
***********************************************************************
CDUFLAG1 EQU   COMNULOP            CDUFLAG1 DEFINITION               R4
         SPACE 1                                                     R4
CDUFLONE EQU   B'00000000'             SINGLE DCT DISPLAY REQUEST    R4
CDUFLGRP EQU   B'10000000'             GROUP DISPLAY REQUEST         R4
CDUFLTYP EQU   B'11000000'             TYPE-GROUP DISPLAY REQUEST    R4
CDUFLRMT EQU   B'00100000'             REMOTE SUB-DISPLAY REQUEST    R4
CDUFLRAT EQU   B'00010000'             RAT BASED DISPLAY REQUEST     R4
CDUFLNEX EQU   B'00001000'             NO EXTEND DISPLAY REQUIRED    R4
CDUFLCLS EQU   B'00000100'             DCT CLASS SKIP REQUESTED      R4
CDUFLLU  EQU   B'00000010'             SNA LUNAME SUBDISPLAY REQD    R4
CDUFLMOD EQU   B'00000001'             MODIFIER OPERAND ONLY        R41
         SPACE 2                                                     R4
CDUDEVTP EQU   COMNULOP+1          TYPE-GROUP DCT TYPE               R4
         SPACE 1                                                    R41
CDUMASK  EQU   COMNULOP+2          BRANCH MASK VALUE                R41
         SPACE 2                                                     R4
CDUFLAG2 EQU   COMNULOP+3          CDUFLAG2 DEFINITION              R41
         SPACE 1                                                     R4
CDUFLSUB EQU   B'10000000'             RMT SUB-DSPLY IN PROGRESS     R4
CDUFLERR EQU   B'01000000'             INVALID OPERANDS DETECTED     R4
CDUFLFND EQU   B'00100000'             DEVICE FOUND IN DISPLAY      R41
CDUFLOPR EQU   B'00010000'             NON-MODIFIER OPERANDS FND    R41
CDUFLACT EQU   B'00001000'             ACTIVE ONLY MODIFIER         R41
CDUFLSTR EQU   B'00000100'             STARTED ONLY MODIFIER        R41
CDUFLSHT EQU   B'00000010'             SHORT MODIFIER               R41
         SPACE 1                                                    R41
***********************************************************************
*        DISPLAY UNIT OPERAND TABLE DEFINITON                         *
***********************************************************************
CDUTBFL1 EQU   0                   DISPLAY REQUEST FLAGS             R4
CDUTBTYP EQU   1                   DEVICE TYPE VALUE                 R4
CDUTBLEN EQU   2                   COMPARE LENGTH FOR OPERAND CHECK  R4
CDUTBMSK EQU   3                   BRANCH MASK FOR CLASS CHECK      R41
CDUTBKEY EQU   4                   OPERAND KEYWORD VALUE             R4
CDUTBRTN EQU   8                   ADDRESS OF DISPLAY ROUTINE        R4
CDUTBSET EQU   12                  PRE-PROCESSOR SETUP INSTRUCTION   R4
CDUTBSZ  EQU   16                  OPERAND TABLE ELEMENT SIZE        R4
         EJECT                                                       R4
***********************************************************************
*        DISPLAY UNIT OPERAND TABLE                                   *
***********************************************************************
         SPACE 1                                                     R4
CDUTABLE DS    0F                                                    R4
         SPACE 1                                                     R4
         DC    AL1(CDUFLNEX+CDUFLGRP+CDUFLCLS),AL1(DCTINR),AL1(0)    R4
         DC    AL1(O*16)                                            R41
         DC    CL4'NULL'           PLAIN $DU - DISPLAY ALL LOCAL     R4
         DC    A(CDUSPLAY)         DEVICES (NON-EXTENDED FORM)       R4
         L     R1,$DCTPOOL                                           R4
         SPACE 1                                                     R4
         DC    AL1(CDUFLTYP),AL1(DCTRDR),AL1(3),AL1(0)               R4
         DC    CL4'RDRS'           DISPLAY ALL LOCAL READERS         R4
         DC    A(CDUSPLAY)                                           R4
         L     R1,$RDRDCT                                            R4
         SPACE 1                                                     R4
         DC    AL1(CDUFLTYP),AL1(DCTPRT),AL1(3),AL1(0)               R4
         DC    CL4'PRTS'           DISPLAY ALL LOCAL PRINTERS        R4
         DC    A(CDUSPLAY)                                           R4
         L     R1,$PRTDCT                                            R4
         SPACE 1                                                     R4
         DC    AL1(CDUFLTYP),AL1(DCTPUN),AL1(3),AL1(0)               R4
         DC    CL4'PUNS'           DISPLAY ALL LOCAL PUNCHES         R4
         DC    A(CDUSPLAY)                                           R4
         L     R1,$PUNDCT                                            R4
         SPACE 1                                                     R4
         DC    AL1(CDUFLTYP),AL1(DCTLOG),AL1(3),AL1(0)               R4
         DC    CL4'LGNS'           DISPLAY ALL LOGON DCTS            R4
         DC    A(CDUSPLAY)                                           R4
         L     R1,$LOGNDCT                                           R4
         SPACE 1                                                     R4
         DC    AL1(CDUFLTYP+CDUFLRMT),AL1(DCTLNE),AL1(3),AL1(0)      R4
         DC    CL4'LNES'           DISPLAY ALL LINES                 R4
         DC    A(CDUSPLAY)                                           R4
         L     R1,$LNEDCT                                            R4
         SPACE 1                                                     R4
         DC    AL1(CDUFLONE+CDUFLRMT+CDUFLLU),AL1(0),AL1(3),AL1(0)   R4
         DC    CL4'LINE'           DISPLAY A LINE                    R4
         DC    A(CDUSPLAY)                                           R4
         B     CDUNOFND                                              R4
         SPACE 1                                                     R4
         DC    AL1(CDUFLONE+CDUFLRMT+CDUFLLU),AL1(0),AL1(2),AL1(0)   R4
         DC    CL4'LNE*'           DISPLAY A LINE                    R4
         DC    A(CDUSPLAY)                                           R4
         B     CDUNOFND                                              R4
         SPACE 1                                                     R4
         DC    AL1(CDUFLGRP),AL1(0),AL1(2),AL1(0)                    R4
         DC    CL4'RDI*'           DISPLAY ALL INTERNAL READERS      R4
         DC    A(CDUSPLAY)                                           R4
         L     R1,$INRDCT                                            R4
         SPACE 1                                                     R4
         DC    AL1(CDUFLGRP),AL1(0),AL1(2),AL1(0)                    R4
         DC    CL4'ALL*'           DISPLAY ALL LOCAL DEVICES         R4
         DC    A(CDUSPLAY)                                           R4
         L     R1,$DCTPOOL                                           R4
         SPACE 1                                                     R4
         DC    AL1(CDUFLGRP+CDUFLRAT+CDUFLRMT),AL1(0),AL1(3),AL1(0)  R4
         DC    CL4'RMTS'           DISPLAY ALL REMOTES               R4
         DC    A(CDUREMOT)                                           R4
         B     CDURMALL                                              R4
         SPACE 1                                                     R4
         DC    AL1(CDUFLGRP+CDUFLRMT+CDUFLRAT+CDUFLLU),AL1(0),AL1(2) R4
         DC    AL1(0)                                                R4
         DC    CL4'RMT*'           DISPLAY ONE OR MORE REMOTES       R4
         DC    A(CDUREMOT)                                           R4
         B     CDURMTS                                              R41
         SPACE 1                                                    R41
         DC    AL1(CDUFLGRP+CDUFLCLS),AL1(DCTLNE),AL1(1),AL1(Z*16)  R41
         DC    CL4'TP**'           ALL TP                           R41
         DC    A(CDUSPLAY)                                          R41
         L     R1,$DCTPOOL                                          R41
         SPACE 1                                                    R41
         DC    AL1(CDUFLMOD),AL1(0),AL1(2),AL1(0)                   R41
         DC    CL4'ACT*'           ACTIVE ONLY MODIFIER             R41
         DC    A(CDULOOP)                                           R41
         OI    CDUFLAG2,CDUFLACT                                    R41
         SPACE 1                                                    R41
         DC    AL1(CDUFLMOD),AL1(0),AL1(2),AL1(0)                   R41
         DC    CL4'STAR'           STARTED ONLY MODIFIER            R41
         DC    A(CDULOOP)                                           R41
         OI    CDUFLAG2,CDUFLSTR                                    R41
         SPACE 1                                                    R41
         DC    AL1(CDUFLMOD),AL1(0),AL1(1),AL1(0)                   R41
         DC    CL4'SHOR'           SHORT ONLY MODIFIER              R41
         DC    A(CDULOOP)                                           R41
         OI    CDUFLAG2,CDUFLSHT                                    R41
         SPACE 1                                                    R41
         DC    AL1(CDUFLONE+CDUFLLU),AL1(0),AL1(0),AL1(0)           R41
         DC    CL4'****'           DISPLAY A SINGLE SPECIFIC DCT     R4
         DC    A(CDUSPLAY)                                           R4
         DC    A(0)                                                  R4
         EJECT
         SPACE 2
         LTORG ,                                                     R4
         TITLE 'HASP COMMAND PROCESSOR HASPCRM1 - REMOTE JOB ENTRY COMMC
               ANDS'                                                 R4
HASPCRM1 $COMGRUP DM,R             REMOTE JOB ENTRY COMMANDS
***********************************************************************
*                                                                     *
*        $D M LOC,TEXT -- DISPLAY MESSAGE AT LOCATION                 *
*                                                                     *
*        $ D M JOBID,TEXT -- DISPLAY MSG ON EXECUTING JOB'S LOG       *
*                                                                     *
*        $ D M 'JOBNAME',TEXT -- DISPLAY MSG ON EXECUTING JOB'S LOG   *
*                                                                     *
*        LOC   = R N-NN            REMOTE NUMBER OR RANGE (0=LOCAL)   *
*        TEXT  = MESSAGE TEXT                                         *
*                                                                     *
***********************************************************************
         USING JQEDSECT,R1                                           R4
CDM      DS    0H                                                    R4
         SLR   R0,R0               ZERO WORK                         R4
         ST    R0,CDMRRL           SET DEFAULT REMOTE                R4
         ST    R0,CDMRRH           RANGE                             R4
         CLI   COMOPRND+1,C'R'     REMOTE TRANSMISSION               R4
         BE    CDMCR               CONVERT REMOTE RANGE              R4
         B     CDMJ                GO TEST FOR '$DMJ' COMMAND       R41
CDMERR   L     R1,0(0,WD)          POINT TO INVALID OPERAND          R4
         $CFINVO OPERAND=(R1)      INVALID OPERAND                   R4
CDMCR    $CFCVB POINTER=(WD),NOK=CDMERR CONVERT REMOTE RANGE         R4
         L     LINK,$SSVT          POINT TO SSVT                     R4
         CH    R0,$SVROUT-SSVT(,LINK) ABOVE OUR LIMIT                R4
         BH    CDMERR              ERROR IF YES                      R4
CDMCSRR  STM   R0,R1,CDMRRH        SET HIGH/LOW RANGES               R4
CDMPM    TM    COMAUTH,COMR        IS SOURCE REMOTE RESTRICTED       R4
         BO    CDMPMA              NEGATE ANY RANGES IF YES          R4
         TM    COMAUTH,COMJ+COMD+COMS DISPLAY ONLY                   R4
         BNO   CDMPMB              ALLOW RANGES IF NOT               R4
CDMPMA   DS    0H                                                    R4
         MVC   CDMRRL,CDMRRH       FORCE SAME REMOTE                 R4
CDMPMB   BXH   WD,WE,CDMERR        ANY TEXT                          R4
         L     WA,0(,WD)           POINT TO START                    R4
         L     WB,4(,WD)           POINT TO END + 2                  R4
         SLR   WB,WA               CALCULATE LENGTH                  R4
         BCTR  WB,0                BACK UP TO FULL TEXT LENGTH       R4
         BCTR  WA,0                INCLUDE COMMA                     R4
         EX    WB,CDMTEXT          MOVE COMMA AND TEXT               R4
         LA    WF,5(,WB)           SET FULL MESSAGE LENGTH           R4
         MVC   COMPNTER(7),COMFLAG COPY SOURCE INFO                  R4
         $CWTO MSG='OK',TRUNC=YES  TRUNCATE MLWTO                    R4
         SLR   R0,R0               ZERO WORK                         R4
         IC    R0,COMUCM-COMFLAG+COMPNTER PICK UP CON OR RMT NUMBER  R4
         MVC   COMMAND(4),=C'C  0' SET FOR LOGICAL CONSOLE           R4
         $CFCVE VALUE=(R0)         CONVERT TO EBCDIC                 R4
         TM    COMPNTER,CMBFLAGW   IS THIS FROM A REMOTE             R4
         BZ    SKIP460             SKIP IF NOT                       R4
         MVI   COMMAND,C'R'        SET REMOTE IDENTIFIER             R4
SKIP460  TM    COMPNTER,CMBFLAGW+CMBFLAGU REMOTE OR UCM              R4
         BZ    CDMPMC              SKIP IF EITHER                   R41
         MVC   COMMAND+1(3),COMDWORK+2 SET SOURCE ID                 R4
CDMPMC   DS    0H                                                   R41
         LA    WB,CDMRRH           POINT TO RANGES                   R4
         LM    WD,WE,0(WB)         PICK UP RANGES                    R4
CDML     LA    WC,1                SET RANGE INCREMENT               R4
CDMLL    ST    WE,4(,WB)           SET CURRENT VALUE                 R4
         MVC   COMFLAG(14),CDMWTO  PUT MASK IN                       R4
         CLI   CDMRRL+3,0          LOCAL SYSTEM                      R4
         BZ    CDMLOC              DISPLAY TO LOCAL IF YES           R4
         MVI   COMFLAG,CMBFLAGW    SET WORKSTATION AS RECEIVER       R4
         MVC   COMRMT,CDMRRL+3     SET REMOTE NUMBER                 R4
CDMLOC   MVC   COMTO,$SYSID        SET SYSTEM IDENTIFICATION         R4
CDMPUT   $CWTO L=(WF)              SEND MESSAGE                      R4
         BXLE  WE,WC,CDMLL         LOOP                              R4
         $CRET ,                   RETURN                            R4
CDMTEXT  MVC   COMMAND+4(*-*),0(WA) *** EXECUTE ONLY ***             R4
***********************************************************************
*                                                                     *
*        $DM EQUATES                                                  *
*                                                                     *
***********************************************************************
CDMRRH   EQU   COMREGSV,4          REMOTE RANGE HIGH VALUE           R4
CDMRRL   EQU   CDMRRH+4,4          REMOTE RANGE LOW VALUE            R4
CDMWTO   $WTO  PRI=$HI,CLASS=$ALWAYS,JOB=NO,ROUTE=X'0100',MF=LX      R4
CDMMID   $MSG  001                 MESSAGE ID
         EJECT                                                      R41
***********************************************************************
*                                                                     *
*        $ D M JOBID,TEXT    AND    $ D M 'JOBNAME',TEXT              *
*                                                                     *
*        DISPLAY MSG TO EXECUTING JOB, STC, TSU                       *
*                                                                     *
***********************************************************************
         PUSH  USING               SAVE STATUS OF BASE REGS         R41
         SPACE 1                                                    R41
CDMJ     DS    0H                  CHECK FOR $DM TO ACTIVE JOB      R41
         MVC   COMJNAME,=CL8' '    BLANK OUT JOB NAME SLOT          R41
         SLR   WA,WA               SET OFFSET FOR JOB NO            R41
         CLI   COMOPRND+1,C'J'     CHECK FOR JOB                    R41
         BE    CDMJOBID            BRANCH IF YES TO EXTRACT JOBID   R41
         LH    WA,=H'10000'        SET OFFSET FOR STC NO            R41
         CLI   COMOPRND+1,C'S'     CHECK FOR STC                    R41
         BE    CDMJOBID            BRANCH IF YES TO EXTRACT JOBID   R41
         ALR   WA,WA               SET OFFSET FOR TSU NO            R41
         CLI   COMOPRND+1,C'T'     CHECK FOR TSU                    R41
         BE    CDMJOBID            BRANCH IF YES TO EXTRACT JOBID   R41
         CLI   COMOPRND+1,C''''    SEE IF JOBNAME (STARTS W/ QUOTE) R41
         BNE   CDMERR              ERROR IF NOT                     R41
         LA    R1,COMOPRND+2       POINT TO 1ST CHAR OF JOBNAME     R41
         L     WC,4(,WD)           POINT TO END OF NAME + 2         R41
         SLR   WC,R1               COMPUTE MACHINE                  R41
         SH    WC,=H'3'              TEXT LENGTH                    R41
         BM    CDMERR              ERROR IF NOT VALID               R41
         LA    R0,7                ENSURE                           R41
         CLR   WC,R0                 LENGTH                         R41
         BNH   CDMJEX                NOT                            R41
         LR    WC,R0                 OVER 7                         R41
CDMJEX   EX    WC,CDMJNMV          MOVE IN JOB NAME                 R41
         SLR   WC,WC               SHOW JQE NOT FOUND YET           R41
CDMJSCAN DS    0H                  BRANCH HERE TO RE-SCAN           R41
        $CFJSCAN PROCESS=CDMJCK,   SCAN JOB QUEUE,                  R41C
               EMPTY=CDMJNJF,        LOOKING FOR                    R41C
               NEXT=CDMJNEXT,        MATCHING                       R41C
               IGNORE=CDMJNG         JOBNAME                        R41
         LTR   WA,WC               AT END OF SCAN, CHECK FOR ONLY 1 R41
         BNM   CDMJXEQ               JOB FOUND, BRANCH IF SO        R41
        $CRET  ,                   EXIT IF ERROR                    R41
CDMJNJF  CLI   COMJNAME,C' '       SEE IF JOBNAME SUPPLIED          R41
         BNE   CDMJNJF2              BRANCH IF SO                   R41
        $CRET  MSG='JOB(S) NOT FOUND'  EXIT WITH DIAGNOSTIC         R41
CDMJNJF2 MVC   COMMAND(8),COMJNAME CONSTRUCT ERROR MESSAGE          R41
         MVC   COMMAND+8(14),=C' JOB NOT FOUND'                     R41
        $CRET  L=8+14              EXIT WITH ERROR MESSAGE          R41
CDMJCK   CLC   JQEJNAME,COMJNAME   SEE IF DESIRED JOBNAME,          R41
         BNE   CDMJNG                CONTINUE SCAN IF NOT           R41
         LTR   WC,WC               SEE IF FOUND BEFORE,             R41
         BNZ   CDMJCK1               BRANCH IF SO                   R41
         LR    WC,R1               SHOW JQE FOUND                   R41
         B     CDMJNEXT            CONTINUE SCAN                    R41
CDMJCK1  BM    CDMJDISP            BRANCH IF IN 'DISPLAY' MODE      R41
         MVC   COMMAND(8),COMJNAME BUILD ERROR MESSAGE              R41
         MVC   COMMAND+8(20),=C' MULTIPLE JOBS FOUND'               R41
        $CWTO  L=8+20              ISSUE DISGNOSTIC                 R41
         ICM   WC,8,=X'80'         SHIFT TO 'DISPLAY' MODE          R41
         B     CDMJSCAN              AND RESTART SCAN AT THE TOP    R41
CDMJDISP $CFJMSG JOBQE=(R1),       DISPLAY INFO ABOUT               R41C
               TYPE=CALL             DUPLICATE JOB                  R41
         B     CDMJNEXT            RESUME SCAN                      R41
CDMJOBID $CFCVB POINTER=(WD),NOK=CDMERR  EXTRACT JOBID              R41
         CLR   R0,R1               RANGE CANNOT BE SPECIFIED        R41
         BNE   CDMERR              ERROR IF RANGE                   R41
         ALR   R1,WA               ADD IN JOB/STC/TSU OFFSET        R41
        $QLOC  (R1)                SEE IF SPECIFIED JOB EXISTS      R41
         BZ    CDMJNJF             ERROR IF JOB NOT FOUND           R41
         LR    WA,R1               SAVE JQE POINTER IN WA           R41
         MVC   COMJNAME,QUEJNAME(WA) SAVE JOB NAME                  R41
CDMJXEQ  DS    0H                  ENTRY FROM $DM'JOBNAME','TEXT    R41
         TM    QUETYPE(WA),$XEQ    TEST FOR EXECUTION               R41
         BZ    CDMJERR             ERROR IF NOT                     R41
         CLI   QUETYPE(WA),$XEQ    RETEST FOR EXECUTION             R41
         BE    CDMJERR             ERROR IF REALLY CONVERSION       R41
         IC    R0,QUEFLAGS(WA)     PICK UP BUSY FLAGS FOR JOB       R41
         N     R0,=A(QUEBUSY)      ISOLATE BUSY SYSTEM ID           R41
         CLM   R0,1,$SIDBUSY       SEE IF EXECUTING ON OUR SYSTEM   R41
         BNE   CDMJERR             ERROR IF NOT                     R41
         BXH   WD,WE,CDMERR        MAKE SURE TEXT WAS SPECIFIED     R41
         LA    R0,2                SET CELL                         R41
         LR    R1,R0                 CLAIM ID                       R41
         LA    R4,S34DL            LENGTH OF REQUIRED CELL          R41
        $GETCEL NONE=CDMJEND       GET CELL FOR QUEUEING MESSAGE    R41
         LR    R3,R1               SET UP ADDRESSABILITY            R41
         USING S34DSECT,R3           ON CELL                        R41
         MVC   S34DTIME-1(CDMJEDTL),CDMJEDIT MOVE EDIT & FILL CHARS R41
         TIME  DEC                 GET TIME OF DAY                  R41
         ST    R0,PCER0            STORE HHMMSSTH FOR EDIT          R41
         ED    S34DTIME-1(L'S34DTIME+1),PCER0 EDIT TIME OF DAY      R41
         TM    COMFLAG,CMBFLAGU    IF MSG FROM LOCAL CONSOLE,       R41
         BO    CDMVCTXT              LEAVE ID AT 'OPER'             R41
         MVC   S34EDIT,=X'D9202120' MOVE 'R' & EDIT PATTERN         R41
         SLR   R0,R0               PICK UP                          R41
         IC    R0,COMRMT             REMOTE NUMBER                  R41
CDMJCVD  CVD   R0,PCER1            CREATE DECIMAL NUMBER            R41
         LA    R1,S34EDIT+3        PRESET SIGNIF. CHAR. POINTER     R41
         EDMK  S34EDIT,PCER1+6     EDIT NUMBER AND                  R41
         MVC   S34EDIT+1(4),0(R1)    LEFT-JUSTIFY                   R41
CDMVCTXT L     R1,0(,WD)           POINT TO START OF TEXT           R41
         L     R15,4(,WD)          POINT TO END OF TEXT PLUS 2      R41
         SLR   R15,R1              COMPUTE LENGTH                   R41
         BCTR  R15,0                 FOR EXECUTED                   R41
         BCTR  R15,0                 MVC                            R41
         LA    R0,L'S34DTEXT-(S34MSG-S34HEADR)-1 LOAD MAX LENGTH    R41
         CLR   R15,R0              IF TEXT                          R41
         BNH   CDMJEX2               TOO LONG,                      R41
         LR    R15,R0                TRUNCATE                       R41
CDMJEX2  EX    R15,CDMS34MV        MOVE TEXT TO MSG CELL            R41
         LA    R15,S34MSG-S34DTIME+1(,R15) COMPUTE MSG LENGTH       R41
         STH   R15,S34DMSGL          AND STORE IN CELL              R41
         LA    R0,S34DL            SET TOTAL LENGTH                 R41
         STH   R0,S34DLN             OF CELL                        R41
        $GETLOK ,                  GET LOCAL, CMS LOCKS             R41
         L     R14,$SSVT           POINT REG 14 TO SSVT             R41
         USING SSVT,R14            SSVT ADDRESSABILITY              R41
         USING SJBDSECT,R1         SJB ADDRESSABILITY               R41
         L     R1,$SVJXCLS         POINT TO BATCH JOB CHAIN         R41
         CLC   QUEJOBNO(,WA),=H'10000' CHECK FOR BATCH JOB          R41
         BNH   CDMSJBLP            BRANCH IF SO                     R41
         L     R1,$SVJXNUM         POINT TO STC/TSU CHAIN           R41
CDMSJBLP LTR   R1,R1               CHECK FOR END OF CHAIN           R41
         BZ    CDMFRELK            BR TO FREE LOCK IF SO            R41
         CL    WA,SJBJQE           CHECK SJB'S JQE ADDRESS          R41
         BE    CDMSJBOK            BR IF THIS IS THE SJB WE WANT    R41
         L     R1,SJBXQCHN         CHAIN TO NEXT                    R41
         B     CDMSJBLP            LOOP                             R41
CDMSJBOK L     R15,S34DCCEW        SET OWNING SJB ID                R41
         ST    R1,CCESJB-CCEDSECT(,R15)  IN CELL                    R41
         MVC   S34DJOB,SJBJOBID    SET JOBID IN MESSAGE             R41
         MODESET EXTKEY=ZERO       ZERO PROTECT KEY FOR QUEUEING    R41
         L     R15,SJBLOGQ         POINT TO CHAIN OF THINGS TO LOG  R41
CDMCSLP  ST    R15,S34DNEXT        PUT CHAIN POINTER IN OUR CELL    R41
         CS    R15,R3,SJBLOGQ      TRY TO ADD CELL TO CHAIN         R41
         BNE   CDMCSLP             LOOP IF UNSUCCESSFUL             R41
         MODESET EXTKEY=HASP       RETURN TO REGULAR KEY            R41
         DROP  R14                 DROP SSVT ADDRESSABILITY         R41
CDMFRELK $FRELOK ,                 RELEASE CMS, LOCAL LOCKS         R41
         LTR   R1,R1               SEE IF SJB WAS FOUND             R41
         BNZ   CDMJEND             BRANCH IF SO                     R41
         LR    R1,R3               POINT R1 TO CELL                 R41
        $FRECEL ,                  FREE CELL CONTAINING MESSAGE     R41
CDMJERR  MVC   COMMAND(8),COMJNAME CONSTRUCT ERROR MESSAGE          R41
         MVC   COMMAND+8(22),=C' JOB NOT EXECUTING ON '             R41
         MVC   COMMAND+8+22(4),$SID APPEND OUR SYSTEM ID            R41
        $CRET  L=8+22+4            EXIT & ISSUE DIAGNOSTIC          R41
CDMJEND $CRET  MSG='OK'            END OF $DMJ COMMAND              R41
         EJECT                                                      R41
CDMJNMV  MVC   COMJNAME(*-*),0(R1) *** EXECUTE ONLY ***             R41
CDMS34MV MVC   S34MSG(*-*),0(R1)   *** EXECUTE ONLY ***             R41
CDMJEDIT DS    0C                  EDIT PATTERNS AND FILLER         R41
         DC    X'4021204B20204B2020'                                R41
         DC    C' JOB NNNN  '                                       R41
S34CONST DC    C'MSG FROM OPER:    '                                R41
S34HEADR EQU   S34DTEXT,L'S34CONST LOCATION OF ABOVE TEXT           R41
S34EDIT  EQU   S34HEADR+9,4        EDIT PATTERN OVERLAYS 'OPER'     R41
S34MSG   EQU   S34HEADR+16         TEXT OF MESSAGE                  R41
CDMJEDTL EQU   *-CDMJEDIT          LENGTH FOR INITIAL MOVE          R41
         POP   USING                                                R41
         EJECT
***********************************************************************
*                                                                     *
*        $R ALL/PRT/PUN,J=FOR-JOBID/R=FOR-DEST,D=TO-DEST,Q=CLASSES    *
*                                                                     *
*        MEANING                                                      *
*        ROUTE OUTPUT OF TYPE 'OP1' FOR JOB OR DEST TO DEST           *
*        OPTIONALLY QUALIFIED BY CLASSES                              *
*                                                                     *
***********************************************************************
         SPACE 2
***********************************************************************
*                                                                     *
*        CHECK FOR 'ALL' 'PRT' OR 'PUN'                               *
*                                                                     *
***********************************************************************
CR       DS    0H                  START OF $R COMMAND
         CLI   COMOPRND+3,C','     CHECK FOR PROPER FORMAT
         BNE   CDMERR              NO--EXIT IN ERROR
         CLC   COMOPRND(3),=C'ALL' IS ROUTING FOR BOTH PRT AND PUN
         MVI   COMNULOP,CRXALL     ASSUME 'ALL'
         BE    CRXTYPE             YES--EXIT TYPE SCAN
         CLC   COMOPRND(3),=C'PRT' IS ROUTING FOR PRT ONLY
         MVI   COMNULOP,CRXPRINT   ASSUME SUCH
         BE    CRXTYPE             YES--EXIT TYPE SCAN
         CLC   COMOPRND(3),=C'PUN' IS ROUTING FOR PUNCH ONLY
         MVI   COMNULOP,CRXPUNCH   SET 'PUN'
         BNE   CDMERR              NO--ERROR  OR NEXT SECTION
         SPACE 1
***********************************************************************
*                                                                     *
*        EXAMINE 2ND, 3RD AND 4TH OPERANDS FOR VALID SPECS            *
*                                                                     *
***********************************************************************
CRXTYPE  DS    0H                  EXAMINE ADDITIONAL OPERANDS
         XC    CRXWORKA,CRXWORKA   SET CRX WORK AREA TO ZEROES       R4
CRXNXTOP BXH   WD,WE,CRXGO         POINT TO NEXT OPERAND POINTER     R4
         L     WB,0(,WD)           POINT TO FIRST CHARACTER          R4
         CLI   1(WB),C'='          THIS EQUAL                        R4
         BNE   CDMERR              ERROR IF JOB                      R4
         CLI   0(WB),C'J'          IS THIS JOB                       R4
         BE    CRXJANL             BREAK OUT JOB                     R4
         CLI   0(WB),C'Q'          IS THIS QUEUE                     R4
         BE    CRXQANL             BREAK OUT QUEUES                  R4
         CLI   0(WB),C'R'          IS THIS ROUTING                   R4
         BE    CRXFMANL            BREAK OUT DESTINATION             R4
         CLI   0(WB),C'D'          IS THIS NEW DESTINATION           R4
         BNE   CDMERR              ERROR IF NOT                      R4
         BAL   WA,CRXANAL          BREAK OUT DESTINATION             R4
         STCM  R0,3,CRXNEWRT       SET ROUTING                       R4
         OI    COMNULOP,CRXOP3     SET OPERAND 3 PRESENT             R4
         B     CRXNXTOP            DO NEXT OPERAND                   R4
CRXFMANL TM    COMNULOP,CRXOP2     ALREADY SPECIFIED                 R4
         BO    CDMERR              ERROR IF YES                      R4
         BAL   WA,CRXANAL          BREAK OUT DESTINATION             R4
         STCM  R0,3,CRXOLDRT       SET OLD ROUTE CODE                R4
         OI    COMNULOP,CRXOP2     SET OPERAND 2 PRESENT             R4
         B     CRXNXTOP            DO NEXT OPERAND                   R4
CRXGO    TM    COMNULOP,CRXOP2+CRXOP3 REQUIRED OPERANDS PRESENT      R4
         BNO   CDMERR              ERROR IF NOT                      R4
         $QSUSE ,                  ENQUEUE ON SHARED RESOURCE
         TM    COMNULOP,CRXJOB     CHECK FOR FROM ID A JOB
         BO    CRXCHKJB            YES--GO HANDLE JOB
         CLC   CRXNEWRT,CRXOLDRT   ANY EFFECTIVE CHANGE              R4
         BE    CRXRET              SKIP IT IF NOT                    R4
         EJECT
***********************************************************************
*                                                                     *
*        SCAN JOB QUEUE LOOKING FOR JOBS BELONGING TO FROM ID         *
*                                                                     *
***********************************************************************
CRXSCAN  $CFJSCAN  PROCESS=CRXJQE,NEXT=CRXNXJQE  SCAN THE JOB Q
         SPACE 1
         L     R1,COMWREGS         GET ADR OF JOBNAME HIT JQE        R4
         CLI   CRXJOBNO,X'FF'      WAS THERE A JOBNAME HIT           R4
         BE    CRXCHKJO            CHECK JOB OWNERSHIP IF YES        R4
         B     CRXRET              RETURN WHEN QUEUE EXHAUSTED
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        FROM ID IS A JOB -- CHK VALIDITY OF JOB & PERFORM FUNCT      *
*                                                                     *
***********************************************************************
CRXCHKJB DS    0H                  FROM ID IS A JOB
         SLR   R0,R0               ZERO WORK
         ICM   R0,3,CRXJOBNO       GET JOB NUMBER
         BZ    CRXSCAN             IF CRXJOBNO=0 THIS IS J='JOBNAME' R4
         $QLOC (R0),CRXJNFND       LOOK FOR JOB IN QUEUE
CRXCHKJO $CFVQE NOK=CRXRET         VERIFY OWNERSHIP                  R4
         TM    JQEFLAGS,QUEPURGE   TRST FOR JOB TO BE PURGED
         BO    CRXRET              YES -- FORGET CHANGING
         CLI   JQETYPE,$INPUT      IS JOB ON A READER
         BE    CRXRET              YES -- DON'T ROUTE IT
         ICM   WB,15,CRXCLSPT      LOOK FOR Q= OPERAND
         BNZ   CRXJBCLQ            YES -- CHG ALL JOES TO SPECIAL
         TM    COMNULOP,CRXPRINT   ELSE CHANGE JQE FIRST
         BZ    CRXJPUN             TEST FOR PRINT ROUTING CHANGE
         MVC   JQEPRTRT,CRXNEWRT   CHANGE PRINT ROUTING IF YES
CRXJPUN  TM    COMNULOP,CRXPUNCH   TEST FOR PUN RE-ROUTING
         BZ    *+10                NO--SKIP JQE CHANGE
         MVC   JQEPUNRT,CRXNEWRT   YES--RE-ROUTE PUNCH
         $QCKPT  (R1)              CHECKPOINT THE CHANGED JQE
         OI    COMNULOP,CRXMODS    FLAG A MODIFICATION MADE
CRXJBCLQ DS    0H                                              @OZ29780
         LR    WF,R1               POINT TO JOB QUEUE ELEMENT  @OZ29780
         BAL   WE,CRXALLCL         YES-CHANGE SPECIAL JOE ROUTINGS
         B     CRXRET              AND THEN RETURN
         EJECT
*              THIS LINE DELETED BY APAR NUMBER              * @OZ29780
*              THIS LINE DELETED BY APAR NUMBER              * @OZ29780
*              THIS LINE DELETED BY APAR NUMBER              * @OZ29780
*              THIS LINE DELETED BY APAR NUMBER              * @OZ29780
*              THIS LINE DELETED BY APAR NUMBER              * @OZ29780
*              THIS LINE DELETED BY APAR NUMBER              * @OZ29780
*              THIS LINE DELETED BY APAR NUMBER              * @OZ29780
*              THIS LINE DELETED BY APAR NUMBER              * @OZ29780
*              THIS LINE DELETED BY APAR NUMBER              * @OZ29780
*              THIS LINE DELETED BY APAR NUMBER              * @OZ29780
*              THIS LINE DELETED BY APAR NUMBER              * @OZ29780
*              THIS LINE DELETED BY APAR NUMBER              * @OZ29780
***********************************************************************
*                                                                     *
*        LOOK AT EACH JOB IN QUEUE TO SEE IF IT                       *
*        BELONGS TO FROM ID AND THEN CHANGE IT ACCORDINGLY            *
*                                                                     *
***********************************************************************
CRXJQE   DS    0H                  A JOB WAS FOUND
         TM    COMNULOP,CRXJOB     WAS J= OPTION SPECIFIED (JOBNAME) R4
         BZ    CRXJQEF             BRANCH IF NOT                     R4
         CLC   JQEJNAME,COMJNAME   DOES JQE JOBNAME = CMD JOBNAME    R4
         BNE   CRXNXJQE            CONTINUE SCAN IF NOT              R4
         CLI   CRXJOBNO,X'FF'      IS THIS 1ST JOBNAME HIT           R4
         BE    CRXMULTI            OUTPUT ERROR MSG IF NOT           R4
         MVI   CRXJOBNO,X'FF'      INDICATE JOBNAME HIT FOUND        R4
         ST    R1,COMWREGS         SAVE ADR OF JQE                   R4
         B     CRXNXJQE            CONTINUE JQE SCAN                 R4
CRXJQEF  DS    0H                                                    R4
         CLI   JQETYPE,$INPUT      IS JOB ON A READER
         BE    CRXNXJQE            YES -- DON'T ROUTE IT
         TM    JQEFLAGS,QUEPURGE   TEST FOR JOB ON PURGE Q
         BO    CRXNXJQE            YES--GET NEXT JOB
         $CFVQE NOK=CRXNXJQE       VERIFY JOB'S OWNERSHIP
         ICM   WB,15,CRXCLSPT      TEST FOR CLASSES SUPPLIED
         BNZ   CRXTSJOE            DO ONLY JOES IF CLASS LIST  @OZ29780
*              THIS LINE DELETED BY APAR NUMBER              * @OZ29780
*              THIS LINE DELETED BY APAR NUMBER              * @OZ29780
         TM    COMNULOP,CRXPRINT   CHK FOR RE-ROUTING OF PRINT
         BZ    CRXRPUN             NO--TEST FOR PUNCH RE-ROUTING
         CLC   JQEPRTRT,CRXOLDRT   SEE IF FROM ID IS OWNER OF PRT
         BNE   CRXRPUN             NO--MAYBE PUNCH IS TO BE RE-RTD
         MVC   JQEPRTRT,CRXNEWRT   YES--CHANGE PRINT ROUTING
         OI    COMNULOP,CRXCKPT+CRXMODS  CKPT NEEDED AND CHG MADE
CRXRPUN  DS    0H                  TEST FOR PUNCH RE-ROUTING
         TM    COMNULOP,CRXPUNCH   TEST FOR SAID CHANGE
         BZ    CRXTSTCK            NO--TEST FOR POSSIBLE CKPT
         CLC   JQEPUNRT,CRXOLDRT   TEST FOR FROM ID PUNCH OWNER
         BNE   CRXTSTCK            NO--TEST FOR CKPT
         MVC   JQEPUNRT,CRXNEWRT   YES--RE-ROUTE PUNCH ACCORDINGLY
         OI    COMNULOP,CRXMODS    FLAG A MODIFICATION MADE
         B     *+12                FORCE CHECKPOINT
CRXTSTCK TM    COMNULOP,CRXCKPT    TEST FOR JQE CKPT
         BZ    CRXTSJOE            NO--LOOK FOR JOES TO CHANGE
         $QCKPT (R1)               CHECKPOINT THE JQE
         NI    COMNULOP,255-CRXCKPT    RESET CHECKPOINT NECESSARY
CRXTSJOE DS    0H                                                    R4
         LR    WF,R1               POINT TO JOB QUEUE ELEMENT  @OZ29780
         BAL   WE,CRXALLCL         REROUTE ANY READY DATA SETS @OZ29780
         LR    R1,WF               POINT TO JOB QUEUE ELEMENT  @OZ29780
         B     CRXNXJQE            GET NEXT JOB                @OZ29780
         EJECT
***********************************************************************
*                                                                     *
*        ROUTINE TO COMPUTE JOT DISPLACEMENT                          *
*        FOR ANY CLASS AND THEN BRANCH AND LINK TO                    *
*        JOE MODIFY ROUTINE                                           *
*                                                                     *
***********************************************************************
         USING JOTDSECT,R10                                          R4
CRXALLCL DS    0H                  BEGIN CLASS CONVERTS
         OC    JQEJOECT,JQEJOECT   TEST FOR ANY JOES
         BZR   WE                  NONE -- RETURN
         L     R10,CDFJOT          POINT TO JOT                      R4
         SLR   WC,WC               ZERO CLASS OFFSET           @OZ29780
         TM    COMNULOP,CRXALL     REQUEST FOR ALL             @OZ29780
         BO    CRXNJALL            LOOK FOR QUALIFYING CLASSES @OZ29780
         L     WB,$SSVT            POINT TO SSVT               @OZ29780
         LA    WB,$SVSCAT-SSVT(,WB) POINT TO SCAT              @OZ29780
CRXNJL   LA    WC,2(,WC)           UP TO NEXT CLASS OFFSET     @OZ29780
         CH    WC,=Y(L'JOTRDYWQ)   TEST FOR END                @OZ29780
         BNLR  WE                  RETURN IF END               @OZ29780
         LR    R1,WC               COPY OFFSET                 @OZ29780
         SRL   R1,1                HALVE                       @OZ29780
         IC    R1,CRXCLASS-1(R1)   PICK UP OFFSET IN SCAT      @OZ29780
         ALR   R1,WB               POINT TO ENTRY              @OZ29780
         TM    COMNULOP,CRXPRINT   WANT PRINT                  @OZ29780
         BO    CRXNJPRT            LOOK FOR PRINT CLASS        @OZ29780
         TM    0(R1),SCATPNCH      THIS A PUNCH CLASS          @OZ29780
         BZ    CRXNJL              LOOP                        @OZ29780
         B     CRXNJOK             TRY JOE MODIFICATION        @OZ29780
CRXNJPRT TM    0(R1),SCATPRNT      THIS A PRINT CLASS          @OZ29780
         BZ    CRXNJL              LOOP                        @OZ29780
CRXNJOK  BAL   WA,CRXCHJOE         CHANGE JOES                 @OZ29780
         B     CRXNJL              LOOP                        @OZ29780
CRXNJALL OC    CRXCLSPT,CRXCLSPT   CLASSES SPECIFIED           @OZ29780
         BNZ   CRXONEC             DO ONLY SPECIFIED CLASSES   @OZ29780
CRXJOLOP LA    WC,2(,WC)           UP TO NEXT                  @OZ29780
         BAL   WA,CRXCHJOE         CHANGE JOES OF THIS CLASS   @OZ29780
         CH    WC,=Y(L'JOTRDYWQ-2) TEST FOR END                @OZ29780
         BL    CRXJOLOP            LOOP                        @OZ29780
         BR    WE                  YES--RETURN TO CALLER
CRXONEC  DS    0H                  USER CLASS LIST SUPPLIED
         NI    0(WB),255-X'C0'     TURN 'OFF' HIGH ORDER ZONE BITS
         SLR   WC,WC               ZERO INSERT REGISTER
         IC    WC,0(,WB)           PICK-UP OFFSET
         L     WA,=A(CPQTABLE)     PT TO HEAD OF CONVERT TABLE @OZ29780
         IC    WC,0(WC,WA)         PICK-UP OFFSET INTO JOT
         BAL   WA,CRXCHJOE         GO MODIFY JOES OF THIS CLASS
         CLI   1(WB),C' '          CHECK FOR LAST CHARACTER
         BER   WE                  YES--EXIT
         LA    WB,1(,WB)           ELSE POINT TO NEXT CLASS
         B     CRXONEC             AND LOOP FOR ALL CLASSES
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        CHANGE JOES FOR CLASS IN REG (WC)                            *
*                                                            * @OZ29780
************************************************************** @OZ29780
*              THIS LINE DELETED BY APAR NUMBER              * @OZ29780
*              THIS LINE DELETED BY APAR NUMBER              * @OZ29780
*              THIS LINE DELETED BY APAR NUMBER              * @OZ29780
*              THIS LINE DELETED BY APAR NUMBER              * @OZ29780
*              THIS LINE DELETED BY APAR NUMBER              * @OZ29780
*              THIS LINE DELETED BY APAR NUMBER              * @OZ29780
*              THIS LINE DELETED BY APAR NUMBER              * @OZ29780
*              THIS LINE DELETED BY APAR NUMBER              * @OZ29780
*              THIS LINE DELETED BY APAR NUMBER              * @OZ29780
*              THIS LINE DELETED BY APAR NUMBER              * @OZ29780
CRXCHJOE DS    0H                  CHANGE JOE ROUTINGS
         USING JOEDSECT,WD                                           R4
         LA    WD,JOTRDYWQ-(JOENEXT-JOEDSECT)(WC)              @OZ29780
CRXNXJOE DS    0H                                                    R4
         LR    R0,WD               COPY ADDRESS                      R4
         LH    WD,JOENEXT          PICK UP OFFSET TO NEXT JOE        R4
         N     WD,=A(X'0000FFFF')  ENSURE OFFSET POSITIVE            R4
         BZR   WA                  EXIT IF LAST JOE OF CLASS
         SLL   WD,2                EXPAND TO BYTE OFFSET             R4
         ALR   WD,R10              POINT TO JOE                      R4
         LH    R14,JOEJQE          PICK UP JQE INDEX                 R4
         SLL   R14,2               POINT TO                          R4
         AL    R14,$JOBQPTR        JQE                               R4
         CLR   R14,WF              JOE BELONG TO JOB           @OZ29780
         BNE   CRXNXJOE            LOOK AT NEXT                      R4
         TM    COMNULOP,CRXJOB     CHK FOR FROM ID A JOB
         BO    CRXSPCL             YES--BR FOR JOB'S JOES
         CLC   JOEROUT,CRXOLDRT    IS THIS JOE A SPECIAL FOR
*                                  THIS ROUTE
         BNE   CRXNXJOE            NO--DON'T RE-ROUTE
CRXALLJO DS    0H                                                    R4
         TM    JOEFLAG,$JOEBUSY    IS JOE ACTIVE               @OZ29780
         BNZ   CRXJOEB             SKIP SETTING IF YES         @OZ29780
         TM    COMNULOP,CRXALL     IS THIS $RALL...            @OZ16683
         BO    CRXUPDR             BR IF YES                   @OZ16683
         CLC   JOEDEST,=H'0'       IS JOE SPECIAL ROUTE...     @OZ16683
         BNE   CRXNXJOE            SKIP SETTING IF YES         @OZ16683
CRXUPDR  MVC   JOEROUT,CRXNEWRT    SET NEW ROUTE CODE          @OZ16683
CRXCKJO  $#CKPT JOE=0(WD),TYPE=A   SCHEDULE CHECKPOINT FOR JOE       R4
         OI    COMNULOP,CRXMODS    FLAG A MODIFICATION MADE
         B     CRXNXJOE            AND GET ANOTHER
CRXSPCL  EQU   CRXALLJO                                        @OZ29780
CRXJOEB  OI    COMNULOP,CRXJOEA    SET ERROR INDICATOR         @OZ29780
         B     CRXNXJOE            DO NEXT JOE                 @OZ29780
*              THIS LINE DELETED BY APAR NUMBER              * @OZ29780
*              THIS LINE DELETED BY APAR NUMBER              * @OZ29780
*              THIS LINE DELETED BY APAR NUMBER              * @OZ29780
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        SUBROUTINE TO EXAMINE R=DEST(FROM) AND D=DEST(TO)            *
*                                                                     *
***********************************************************************
CRXANAL  DS    0H                  START SCAN OF OPERANDS
         BAL   LINK,COFRTRA        CONVERT ROUTE CODE                R4
         B     CDMERR              ERROR EXIT               + 0      R4
         CR    R0,R1               SAME                     + 4      R4
         BNE   CDMERR              ERROR IF NOT                      R4
         BR    WA                  RETURN                            R4
***********************************************************************
*                                                                     *
*        EXAMINE THE FROM JOB OPERAND (J=JN/J=SN/J=TN)                *
*                                                                     *
***********************************************************************
CRXJANL  DS    0H                                                    R4
         TM    COMNULOP,CRXOP2     OPERAND 2 ALREADY SPECIFIED       R4
         BO    CDMERR              ERROR IF YES                      R4
         CLI   2(WB),C''''         IS THIS A J='JOBNAME' OPERAND     R4
         BNE   CRXJJNOV            GO TO VALIDATE JOB NO. IF NOT     R4
         LA    WB,2(,WB)           STEP WB TO START OF 'JOBNAME'     R4
         L     WC,4(,WD)           POINT 2 BYTES PAST END-OF-OPERAND R4
         BCTR  WC,0                BACK UP TO END                    R4
         BCTR  WC,0                  OF OPERAND                      R4
         CLI   0(WC),C''''         DOES OPERAND END WITH APOSTROPHE  R4
         BNE   SKIP480             SKIP NSI IF NOT                   R4
         BCTR  WC,0                POINT TO LAST CHAR OF JOBNAME     R4
SKIP480  SR    WC,WB               COMPUTE LENGTH OF JOBNAME         R4
         BNP   CDMERR              ERROR EXIT IF NOT POSITIVE        R4
         BCTR  WC,0                GET MACHINE LENGTH                R4
         LA    R0,7                SET R0 = MAXIMUM MACHINE LENGTH   R4
         CR    WC,R0               IS JOBNAME LENGTH TOO LONG        R4
         BNH   SKIP490             SKIP NSI IF NOT                   R4
         LR    WC,R0               SET TO MOVE MAXIMUM LENGTH        R4
SKIP490  MVC   COMJNAME,=CL8' '    BLANK OUT JOBNAME WORKAREA        R4
         EX    WC,CRXJNMVC         MOVE JOBNAME TO WORKAREA          R4
         SLR   R0,R0               SET R0 (JOB NUMBER) TO ZERO       R4
         B     CRXJXIT             GO TO SET COMNULOP FLAGS AND EXIT R4
CRXJJNOV DS    0H                  VALIDATE JOB NO.                  R4
         SLR   WC,WC               SET BATCH JOB VALUE
         CLI   2(WB),C'J'          TEST FOR BATCH JOB                R4
         BE    CRXCVB              YES--GET JOB NUMBER
         AH    WC,=H'10000'        SET STC OFFSET VALUE
         CLI   2(WB),C'S'          TEST FOR SYSTEM STARTED TASK      R4
         BE    CRXCVB              YES--GET STC NUMBER
         ALR   WC,WC               SET TSU OFFSET VALUE
         CLI   2(WB),C'T'          TEST FOR TIME SHARING USER        R4
         BNE   CDMERR              ERROR IF NOT                      R4
CRXCVB   DS    0H                                                    R4
         $CFCVB POINTER=(WD),NUM=1,NOK=CDMERR  DO IT
         LTR   R0,R0               RESULT ZERO                       R4
         BZ    CDMERR              ERROR IF YES                      R4
         ALR   R0,WC               COMPUTE TRUE TASK NUMBER
CRXJXIT  DS    0H                  SET COMNULOP FLAGS AND EXIT       R4
         OI    COMNULOP,CRXJOB+CRXOP2 SET SECOND OPERAND IS JOB      R4
         STH   R0,CRXJOBNO         SET JOB NUMBER                    R4
         B     CRXNXTOP            DO NEXT OPERAND                   R4
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        EXTRACT Q= OPERAND IF SUPPLIED                               *
*                                                                     *
***********************************************************************
CRXQANL  DS    0H
         L     WC,4(,WD)           POINT TO OPERAND END
         LA    WC,0(,WC)           CLEAR HI-ORDER FLAG BYTE
         SLR   WC,WB               COMPUTE SIZE OF OPERAND
         SH    WC,=H'4'            LESS FOUR FOR 'Q=' AND MACH.
         BM    CDMERR              NOT PRESENT -- ERROR
         L     R14,=A(CVALIDTB)    POINT TO TEST TABLE               R4
         EX    WC,CRXVALID         TEST FOR VALID STRING
         BNZ   CDMERR              INVALID CHARACTERS -- ERROR
         TM    COMNULOP,CRXALL     TEST FOR TYPE OF ALL
         BNO   CDMERR              IF NOT -- 'Q=' IS INVALID
         LA    R0,2(,WB)           POINT TO FIRST CHAR IN STRING
         ALR   WC,R0               COMPUTE END OF STRING - 1
         MVI   1(WC),C' '          TRUNCATE STRING
         STCM  R0,15,CRXCLSPT      SET CLASS STRING POINTER          R4
         B     CRXNXTOP            LOOK AT NEXT OPERAND              R4
         SPACE 1
CRXVALID TRT   2(*-*,WB),0(R14)    *** EXECUTE ONLY ***              R4
CRXJNMVC MVC   COMJNAME(*-*),1(WB) *** EXECUTE ONLY ***              R4
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        CRXMULTI - COME HERE IF J=JOBNAME OPERAND WAS USED ON $R     *
*                   COMMAND AND JOB NAME IS NOT UNIQUE.  PUT OUT      *
*                   'MULTIPLE JOBS FOUND' MSG AND DISPLAY THE JOBS.   *
*                                                                     *
***********************************************************************
CRXMULTI DS    0H                                                    R4
         MVC   COMMAND(19),=C'MULTIPLE JOBS FOUND' MOVE MSG          R4
         LA    R0,19               MSG LENGTH                        R4
        $CWTO  L=(R0)              SEND MSG                          R4
*                                  SCAN FOR AND DISPLAY JOBS         R4
        $CFJSCAN PROCESS=CRXMJPRO,NEXT=CRXMJNXT                      R4
         B     CRXRET              RETURN (DISPLAYS COMPLETE)        R4
CRXMJPRO NULL  ,                                                     R4
         CLC   JQEJNAME,COMJNAME   JQE JOBNAME = CMD JOBNAME         R4
         BNE   CRXMJNXT            CONTINUE SCAN IF NOT              R4
         LR    WB,R1               SAVE JQE ADR                      R4
        $CFJMSG JOBQE=(R1),TYPE=CALL  DISPLAY JOB INFORMATION        R4
***********************************************************************
*                                                                     *
*        USING $CFJSCAN MACRO, TRY TO RETRACE CHAIN BACK TO SAME      *
*        JQE.  IF FOUND, AND ON THE SAME QUEUE, WE CAN CONTINUE       *
*        OUR ORIGINAL SCAN LOOKING FOR DUPLICATE JOBS TO DISPLAY.     *
*        IF NOT FOUND OR ON ANOTHER QUEUE, MSG = 'LIST INCOMPLETE.'   *
*                                                                     *
***********************************************************************
        $CFJSCAN PROCESS=CRXMJCHK,NEXT=CRXMJX,STORE=NO               R4
CRXNOFND DS    0H                                                    R4
         MVC   COMMAND(15),=C'LIST INCOMPLETE' MOVE MSG              R4
         LA    R0,15               MSG LENGTH                        R4
        $CWTO  L=(R0)              SEND MSG                          R4
         B     CRXRET              RETURN                            R4
CRXMJCHK NULL  ,                   COME HERE TO CHECK JQE            R4
         CR    R1,WB               IS THIS THE SAME JQE AS DISPLAYED R4
         BNE   CRXMJX              GO TO CHECK NEXT JQE IF NOT       R4
         CH    R15,COMJQHDS        IS JOB STILL ON SAME QUEUE        R4
         BNE   CRXNOFND            IF NOT,CHAIN BROKEN, BRANCH       R4
         B     CRXMJNXT            OTHERWISE, CONTINUE ORIG JOB SCAN R4
         EJECT
***********************************************************************
*        EQUATES FOR $ROUTE COMMAND                                   *
***********************************************************************
CRXOP2   EQU   X'80'               OPERAND 2 IS PRESENT              R4
CRXOP3   EQU   X'40'               OPERAND 3 IS PRESENT              R4
CRXPRINT EQU   X'08'               TYPE IS PRINT
CRXPUNCH EQU   X'04'               TYPE IS PUNCH
CRXALL   EQU   CRXPRINT+CRXPUNCH   TYPE IS ALL
CRXJOB   EQU   X'02'               FROM ID IS A JOB
CRXCKPT  EQU   X'01'               A CHECKPOINT OF THE JQE IS NEED
CRXJOEA  EQU   X'20'               AT LEAST ONE ELIGIBLE JOE IS ACTIVE
CRXMODS  EQU   X'10'               MODIFICATION HAS BEEN MADE
         SPACE 1
CRXWORKA EQU   COMREGSV,8          $ROUTE COMMAND WORK AREA          R4
CRXOLDRT EQU   COMREGSV,2          SAVE AREA FOR OLD ROUTE CODE      R4
CRXJOBNO EQU   COMREGSV,2          SAVE AREA FOR JOB, STC, TSU NO.   R4
CRXNEWRT EQU   COMREGSV+2,2        SAVE AREA FOR NEW ROUTE CODE      R4
CRXCLSPT EQU   COMREGSV+4,4        SAVE AREA FOR CLASS STRING PTR    R4
         SPACE 3
***********************************************************************
*        $ROUTE EXITS                                                 *
***********************************************************************
CRXJNFND DS    0H                  COME HERE IF JOB NOT FOUND
         $CRET MSG='JOB(S) NOT FOUND'
         SPACE 1
CRXRET   DS    0H                  RETURN EXIT
         TM    COMNULOP,CRXJOEA    ANY ACTIVE JOES ELIGIBLE    @OZ29780
         BZ    CRXRETA             SKIP NEXT                   @OZ29780
         $POST $HASPECF,(JOB,JOT)  POST JOB AND JOT            @OZ29780
         $CRET MSG='ACTIVE DATA SETS NOT ROUTED'               @OZ29780
CRXRETA  DS    0H                                              @OZ29780
         TM    COMNULOP,CRXMODS    TEST FOR ANY CHANGES
         BZ    CRXMSG              NONE -- TELL OPERATOR SUCH
         $POST $HASPECF,(JOB,JOT)  POST JOB AND JOT
         OI    $AQSE,QSEPJOB+QSEPJOT   CAUSE X SYSTEM POST(S)
         $CRET MSG=OK              RETURN 'OK'
CRXMSG   DS    0H                  NO RE-ROUTING OF DATA SETS
         $CRET MSG='NO DATA SETS RE-ROUTED'
         SPACE 2
CRXCLASS DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'         @OZ29780
         LTORG ,
         DROP  R1                                                    R4
         DROP  WD                                                    R4
         DROP  R10                                                   R4
         PRINT &DATA               DEFINE PRINTING FOR LITERALS
         TITLE 'HASP COMMAND PROCESSOR - LITERAL POOL'
HASPCOMM CSECT
         LTORG ,
         TITLE 'HASP COMMAND PROCESSOR - GLOBAL DEFINITIONS'
CVALIDTB EQU   *
         DC    193X'01'            X'00'-X'C0' INVALID
         DC    9X'00'              X'C1'-X'C9' VALID (A-I)
         DC    7X'01'              X'CA'-X'D3' INVALID
         DC    9X'00'              X'D1'-X'D9' VALID (J-R)
         DC    8X'01'              X'DA'-X'E1' INVALID
         DC    8X'00'              X'E2'-X'E9' VALID (S-Z)
         DC    6X'01'              X'EA'-X'EF' INVALID
         DC    10X'00'             X'F0'-X'F9' VALID (0-9)
         DC    6X'01'              X'FA'-X'FF' INVALID
         SPACE 5                                                     R4
CVALTABL EQU   *                                                     R4
         DC    75X'01'             X'00'-X'4A'  INVALID              R4
         DC      X'00'             X'4B'        VALID (.)            R4
         DC    15X'01'             X'4C'-X'5A'  INVALID              R4
         DC      X'00'             X'5B'        VALID ($)            R4
         DC    31X'01'             X'5C'-X'7A'  INVALID              R4
         DC    2X'00'              X'7B',X'7C' VALID (#,@)     @OZ18216
         DC    68X'01'             X'7D'-X'C0' INVALID         @OZ18216
         DC     9X'00'             X'C1'-X'C9'  VALID (A-I)          R4
         DC     7X'01'             X'CA'-X'D0'  INVALID              R4
         DC     9X'00'             X'D1'-X'D9'  VALID (J-R)          R4
         DC     8X'01'             X'DA'-X'E1'  INVALID              R4
         DC     8X'00'             X'E2'-X'E9'  VALID (S-Z)          R4
         DC     6X'01'             X'EA'-X'EF'  INVALID              R4
         DC    10X'00'             X'F0'-X'F9'  VALID (0-9)          R4
         DC     6X'01'             X'FA'-X'FF'  INVALID              R4
         TITLE 'HASP COMMAND PROCESSOR - CANCEL JOB SERVICE ROUTINE' R4
***********************************************************************
*                                                                     *
*        $JCAN -- JOB CANCEL SERVICE ROUTINE                          *
*                                                                     *
* FUNCTIONS                                                           *
*                                                                     *
*    (1) REJECT ATTEMPTS TO CANCEL OR STOP STC OR TSU JOBS            *
*        PRIOR TO EXECUTION.                                          *
*                                                                     *
*    (2) PURGE HQRS FOR STOP JOB AND CANCEL WITH PURGE REQUESTS.      *
*                                                                     *
*    (3) PURGE JOES FOR STOP JOB AND CANCEL WITH PURGE REQUESTS.      *
*                                                                     *
*    (4) ISSUE SVC 34 TO CANCEL JOB IF REQUIRED.                      *
*                                                                     *
*    (5) DELET ACTIVITY ON HASP READERS FOR CANCEL REQUESTS           *
*        AND ON HASP PRINTERS AND PUNCHES FOR CANCEL WITH PURGE       *
*        REQUESTS.                                                    *
*                                                                     *
*    (6) FORCE CHECKPOINT IF JQE HAS AN OWNER AND $QPUT TO            *
*        $OUTPUT, $HARDCPY, OR $PURGE IF NO OWNER.                    *
*                                                                     *
*    (7) IGNORE ATTEMPTS TO CANCEL OUTPUT FOR JOB IF CANCEL           *
*        WITHOUT PURGE IS REQUESTED.                                  *
*                                                                     *
*    (8) SIGNAL USER TO WAIT ON CHECKPOINT IF ACTIVE.                 *
*                                                                     *
* INPUT REGISTERS                                                     *
*                                                                     *
*        R0    = REQUEST CODE                                         *
*        R1    = JQE ADDRESS                                          *
*        R11   = BASE1 (HCT)                                          *
*        R13   = PCE ADDRESS (CALLERS)                                *
*        R14   = RETURN (RETURN WILL BE TO R14 + R15)                 *
*        R15   = ENTRY BASE                                           *
*                                                                     *
* OUTPUT REGISTERS                                                    *
*                                                                     *
*        R0-R14= UNCHANGED                                            *
*        R15   = RETURN CODE ( OFFSET TO R14 FOR RETURN )             *
*                                                                     *
*              = 0 - STC OR TSU CANCEL EXECUTION REQUEST REJECTED     *
*              = 4 - CANCEL IGNORED FOR JOB IN OUTPUT                 *
*              = 8 - JQE FLAGGED FOR CANCEL AS REQUESTED              *
*                                                                     *
***********************************************************************
         EJECT
$JCANR   DS    0H
         USING *,R15
         STM   R0,R14,CCJSAVE      SAVE USER REGISTERS
         LR    R8,R15              ESTABLISH WORKING BASE
         USING $JCANR,R8
         USING JQEDSECT,R1
         DROP  R15
         LR    WE,R1               SAVE JQE ADDRESS
         SLR   WB,WB               CLEAR SJB ADDRESS REGISTER       R41
         LA    WF,CCJXNJ           SET NOT JOB ERROR RETURN CODE
         CLC   JQEJOBNO,CCJJMAX    CHECK FOR ABOVE BATCH JOB NUMBERS
         BL    CCJB                DO CANCEL FOR JOBS
         TM    JQETYPE,$XEQ        IS IT IN OR PRIOR TO XEQ
         BO    CCJRET              RETURN 'NOTJOB' IF YES
         CLI   JQETYPE,$INPUT      IS TSU OR STC ON A READER
         BE    CCJRET              RETURN 'NOTJOB' IF YES
         B     CCJB1                ELSE CONTINUE                   R41
         SPACE 1                                                    R41
***********************************************************************
*                                                                     *
*        CHECK FOR 'NON-CANCELABLE' BATCH JOB ATTRIBUTE               *
*                                                                     *
***********************************************************************
         SPACE 1                                                    R41
         USING PITDSECT,WC         PROVIDE PIT ADDRESSABILITY       R41
         SPACE 1                                                    R41
CCJB     TM    JQETYPE,$XEQ        XEQ OR CONVERTER...              R41
         BZ    CCJB1               BR IF NO                         R41
         TM    JQEFLAGS,QUEBUSY    IS JOB ACTIVE...                 R41
         BZ    CCJB1               BR IF NO                         R41
         CLI   JQETYPE,$XEQ        CONVERTING...                    R41
         BE    CCJB1               BR IF YES                        R41
         L     WC,$PITABLE         POINT TO PITS                    R41
         SPACE 1                                                    R41
CCJPIT1  TM    PITSTAT,PITBUSY     IS PIT ACTIVE...                 R41
         BO    CCJSJB              BR IF YES                        R41
         SPACE 1                                                    R41
CCJPIT2  ICM   WC,15,PITNEXT       POINT TO NEXT PIT                R41
         BZ    CCJB1               BR IF END OF PITS                R41
         B     CCJPIT1              ELSE TEST NEW PIT               R41
         SPACE 1                                                    R41
         USING SJBDSECT,WD         PROVIDE SJB ADDRESSABILITY       R41
         SPACE 1                                                    R41
CCJSJB   L     WD,PITSJB           POINT TO SJB                     R41
         CLM   R1,7,SJBJQE+1       IS THIS THE RIGHT SJB...         R41
         BNE   CCJPIT2             TRY NEXT PIT IF NO               R41
         LR    WB,WD               SAVE SJB ADDRESS                 R41
         ICM   WD,15,SJBCSCB       POINT TO CSCB                    R41
         BZ    CCJB1               BR IF NO CSCB                    R41
         SPACE 1                                                    R41
         USING CSCDSECT,WD         PROVIDE CSCB ADDRESSABILITY      R41
         SPACE 1                                                    R41
         TM    CHACT,CHCL          IS JOB CANCELABLE...             R41
         BZ    CCJRET              RETURN 'NOTJOB' IF NO            R41
         SPACE 1                                                    R41
         DROP  WD                  DROP CSCB ADDRESSABILITY         R41
         EJECT                                                      R41
CCJB1    ST    WB,CCJSJBAD         SAVE SJB ADDRESS                 R41
         TM    CCJR,CCJRSTOP+CCJRPURG  $C ONLY...                   R41
         BZ    CCJC                BRANCH IF $C ONLY
         NI    JQEFLAGS,255-QUEHOLDA-QUEHOLD1-QUEHOLD2 RESET HOLD
         OI    JQEFLAGS,QUEPURGE   SET PURGE FOR $CJ,P AND $PJ
         TM    CCJR,CCJRPURG       TEST FOR $CJ,P ONLY
         BZ    *+8                 NO--SKIP SETTING QUEOPCAN
         OI    JQEFLAGS,QUEOPCAN   SET OPERATOR CANCEL
***********************************************************************
*                                                                     *
*        PURGE ANY HELD DATA SETS                                     *
*                                                                     *
***********************************************************************
         SPACE 1
         LH    WB,JQEHLDCT         PICK-UP HOLD COUNT
         LTR   WB,WB               TEST FOR ANY
         BZ    CCJNOHLD            NONE--EXIT DELETION ROUTINE
         LR    WC,R1               SAVE JQE ADDRESS OVER GETMAIN
         LA    WF,CCJXNOP          SET POSSIBLE NOP FOR NO STORAGE
         GETMAIN RC,LV=PSOLNGTH,SP=0  GET STORAGE FOR PSO ELEMENT
         SPACE 1
         LR    R2,R1               RELOAD PSO ADDRESS (IF ANY)      R41
         USING PSODSECT,R2         PROVIDE PSO ADDRESSABILITY       R41
         LTR   R3,R15              TEST FOR STORAGE AVAILABLE       R41
         BNZ   CCJRET              IF NONE--EXIT NOT CANCELLED
         LR    R0,R1               CLEAR                             R4
         LA    R1,PSOLNGTH          PSO                              R4
         MVCL  R0,R2                 STORAGE                        R41
        $TIME  ,                   GET CURRENT DATE IN R1           R41
         ST    R1,PSOCRDT          SET CUT-OFF DATE                 R41
         LR    R1,WC               RESTORE JQE ADDRESS               R4
         OI    PSOFLG1,PSOFHLD+PSOFJOBI+PSOFJOBN SET PSO FLAGS
         OI    PSOFLG2,PSOFDONE+PSOF$O SET ADDITIONAL FLAGS
         OI    PSOUFLG,PSOFDELC    SET TO CANCEL DATA SETS
         MVC   PSOJOBN,JQEJNAME    SET JOBNAME INTO PSO ELEMENT
         MVC   PSOJOBNO,JQEJOBNO   SET JOB NUMBER INTO PSO ELEMENT
         LR    R15,R2              SAVE ADDRESS OF NEW ELEMENT      R41
         LA    R2,$OQUEUE-(PSONEXT-PSODSECT)  PREPARE TO SCAN PSO Q R41
         L     R0,PSONEXT          PT TO NEXT ELEMENT
         LTR   R0,R0               TEST FOR LAST ELEMENT
         BZ    *+10                YES--SET NEW LAST ELEMENT
         LR    R2,R0                ELSE RELOAD ELEMENT ADDRESS     R41
         B     *-12                AND LOOP TILL LAST FOUND
         ST    R15,PSONEXT         ADD ELEMENT TO END OF CHAIN
         L     R15,$PSOPCE         POINT TO PSO PCE                  R4
         $POST (R15),WORK          POST PSO FOR DELETE REQUEST
         DROP  R2                  KILL PSO ADDRESSABILITY          R41
         SPACE 1
CCJNOHLD DS    0H                  COME HERE WHEN NO HELD DATA SETS
         EJECT
***********************************************************************
*                                                                     *
*        PURGE JOES FOR JOB                                           *
*                                                                     *
***********************************************************************
         ICM   R0,3,JQEJOECT       PICK UP JOE COUNT
         BZ    CCJNOJOE            SKIP CANCEL IF NONE
         $#CAN JQE=(R1)            CANCEL IDLE JOES
CCJNOJOE LR    R1,WE               MAKE SURE R1 STILL POINTS TO JQE
***********************************************************************
*                                                                     *
*        CANCEL ACTIVITY OR CHECKPOINT                                *
*                                                                     *
***********************************************************************
CCJCANC  TM    JQETYPE,$XEQ        IS IT XEQ OR CONVERTER
         BZ    CCJNDEV             BR IF NO                          R4
         TM    JQEFLAGS,QUEBUSY    TEST FOR JOB ACTIVE
         BZ    CCJQPUT             BR IF NO TO RE-QUEUE              R4
         CLI   JQETYPE,$XEQ        TEST FOR JOB CONVERTING
         BE    CCJCKPT             POST CHECKPOINT IF YES
         TM    CCJR,CCJFSTOP       IS THIS $P...                    R41
         BO    CCJCKPT             DO NOT DISRUPT EXECUTION IF $P
         OI    CCJR,CCJRCANX       SET FLAG TO RETURN CANCEL REQUIRED
         EJECT
***********************************************************************
*                                                                     *
*        FORCE CHECKPOINT OR PUT JQE ON $OUTPUT, $HARDCPY, OR         *
*        $PURGE QUEUE                                                 *
*                                                                     *
***********************************************************************
CCJNDEV  TM    JQEFLAGS,QUEBUSY    IS JOB ACTIVE
         BNZ   CCJCKPT             CHECK POINT IF YES
CCJQPUT  LA    R0,$OUTPUT          SET OUTPUT
         $QPUT (R1),(R0)           PUT TO OUTPUT, HARDCPY, PURGE
         B     CCJRETOK            RETURN WITH OK RETURN CODE        R4
CCJCKPT  $QCKPT (R1)               FORCE CHECKPOINT OF JQE
CCJRETOK LA    WF,CCJXOK           SET RETURN
         TM    CCJR,CCJRCANX       IS CANCEL SVC 34 REQUIRED
         BZ    CCJRET              SKIP CANCEL EXECUTION IF NOT
***********************************************************************
*                                                                     *
*        TELL OPERATING SYSTEM TO CANCEL EXECUTION OF JOB             *
*                                                                     *
***********************************************************************
         SPACE 1                                                    R41
         USING SJBDSECT,WD         PROVIDE SJB ADDRESSABILITY       R41
         SPACE 1                                                    R41
         LM    WA,WC,CCJSAVEA      SAVE WORK SPACE CONTENTS         R41
         ICM   WD,15,CCJSJBAD      PICK UP SJB ADDRESS              R41
         BZ    CCJPITUH            BR IF NO SJB TO UNHOLD JQE       R41
         OI    SJBFLG2,SJB2CNCL    SET CANCEL FLAG
         MVC   CCJSAVEA+4(8),SJBASCBP+SJBERRET-SJBERRET SET XM POST
         ICM   WE,15,SJBCSCB       POINT TO CSCB
         USING CSCDSECT,WE
         BZ    CCJPITTR            BR IF NO CSCB TO TEST RSTRT      R41
         MODESET EXTKEY=ZERO       GET KEY 0
         OI    CHACT,CHCLD         TELL OS TO DO WHOLE JOB
         MODESET EXTKEY=HASP       GET KEY 1
         LA    R1,CHCECB           POINT TO ECB
         ST    R1,CCJSAVEA         SET INTO XM POST ELEMENT
         LA    R0,X'222'           SET ABEND CODE FOR NO DUMP
         TM    CCJR,CCJRDUMP       IS 'DUMP' DESIRED
         BZ    CCJPOST             SKIP NEXT IF NOT                  R4
         LA    R0,X'122'           SET ABEND CODE FOR DUMP
CCJPOST  POST  ,(0),MF=(E,CCJSAVEA)  POST TO CANCEL JOB              R4
         LA    R0,44               SET REQUEST TO SWAP IN
         ICM   R0,12,SJBASID       SET ASID NUMBER
         SVC   95                  SWAP USER IN (MAYBE)
CCJPITTR DS    0H                  TEST RESTART BIT IN SJB          R41
         TM    SJBFLG1,SJB1EJOB    Q. IF RESTART BIT SET
         BO    CCJPITE             BR. IF YES
CCJPITUH DS    0H                  UNHOLD JQE                       R41
         L     R1,CCJSAVE+4        RELOAD JQE ADDRESS
         NI    JQEFLAGS,255-QUEHOLDA-QUEHOLD1-QUEHOLD2  UNHOLD
CCJPITE  STM   WA,WC,CCJSAVEA      RESTORE SAVE AREA
         DROP  WD,WE
CCJRET   LR    R15,WF              SET RETURN CODE
         LM    R0,R14,CCJSAVE      RESTORE USER REGISTERS
         B     0(R15,R14)          RETURN TO USER
         EJECT
***********************************************************************
*                                                                     *
*        VERB IS $C WITHOUT PURGE OPERAND                             *
*                                                                     *
***********************************************************************
CCJC     TM    JQETYPE,$XEQ        TEST FOR XEQ OR CONVERTER
         BO    CCJWXEQT            IF EITHER TEST FOR EXECUTING     R41
CCJCRDRT LA    WF,CCJXNOP          SET NO-OP RETURN CODE            R41
         CLI   JQETYPE,$INPUT      IS IT ON A READER                R41
         BNE   CCJRET              IGNORE REQUEST
CCJCRDR  NI    JQEFLAGS,255-QUEHOLDA-QUEHOLD1-QUEHOLD2 RELEASE JOB   R4
         OI    JQEFLAGS,QUEOPCAN   SET CANCEL
         B     CCJNDEV             CHECKPOINT OR PUT ON NEXT QUEUE   R4
CCJWXEQT TM    JQEFLAGS,QUEBUSY    IS JOB ACTIVE...                 R41
         BZ    CCJW                BR IF NO TO RELEASE              R41
         CLI   JQETYPE,$XEQ        IS JOB CONVERTING...             R41
         BNE   CCJWCAN             BR IF NO (EXECUTING)             R41
CCJW     NI    JQEFLAGS,255-QUEHOLDA-QUEHOLD1-QUEHOLD2 RELEASE JOB   R4
CCJWCAN  OI    JQEFLAGS,QUEOPCAN   SET CANCEL FLAG                  R41
         B     CCJCANC             CANCEL ACTIVITY
         EJECT
***********************************************************************
*                                                                     *
*        JOB CANCEL ROUTINE WORKAREA DEFINITIONS                      *
*                                                                     *
***********************************************************************
         SPACE 3
CCJJMAX  DC    H'10000'            UPPER LIMIT FOR JOB NUMBERS
CCJCBNK  DC    C'C '               COMMAND VERB
CCJDUMP  DC    C',DUMP'            DUMP OPTION CHARACTERS
CCJSAVE  EQU   $REGSAVE            NON-REENTRANT REGISTER SAVE AREA R41
CCJR     EQU   CCJSAVE+3,1         REQUESTS IN LOW BYTE OF R0
CCJSAVEA EQU   CCJSAVE+4*R2,12     POST PARAMETER LIST
CCJSJBAD EQU   CCJSAVE+(R14-R0+1)*4  SJB ADDRESS SAVE AREA          R41
         SPACE 3
CCJRDUMP EQU   CCJFDUMP            A DUMP IS REQUESTED
CCJRCANX EQU   X'20'               SVC 34 CANCEL REQUIRED
CCJRSTOP EQU   CCJFSTOP            USER REQUESTED STOP JOB
CCJRPURG EQU   CCJFPURG            USER REQUESTED PURGE JOB
*        EQU   X'00'               USER REQUESTED CANCEL EXECUTION
         SPACE 3
CCJXNJ   EQU   X'00'               RETURN OFFSET FOR 'NOT JOB'
CCJXNOP  EQU   X'04'               RETURN OFFSET FOR 'NOP'
CCJXOK   EQU   X'08'               RETURN OFFSET FOR 'OK'
         TITLE 'HASP COMMAND PROCESSOR - PURGE TRACKS FOR SPIN DATA SETC
               S'                                                   R41
***********************************************************************
*                                                                     *
*        $IOTPUR -- IOT PURGE SERVICE ROUTINE                         *
*                                                                     *
* FUNCTIONS --                                                        *
*                                                                     *
*   (1) READ IN THE IOT FOR A SPIN DATA SET.                          *
*                                                                     *
*   (2) PURGE THE TRACKS USED FOR THE DATA SET IF AN ALLOCATION       *
*       IOT.                                                          *
*                                                                     *
*   (3) TURN OFF THE PSO FLAG IN THE PDDB (SO THAT THE DATA SET       *
*       WILL NOT BE RE-SPUN ON JES2 WARM START) AND REWRITE THE       *
*       IOT.                                                          *
*                                                                     *
* INPUT REGISTERS --                                                  *
*                                                                     *
*        R1 = ADDR OF WORK JOE                                        *
*                                                                     *
* OUTPUT REGISTERS --                                                 *
*                                                                     *
*        R0 - R15 UNCHANGED (RETURN IS TO LINK+0)                     *
*                                                                     *
* NOTE - IF UNABLE TO GET AN IOT BUFFER, AN IMMEDIATE RETURN IS       *
*       MADE INSTEAD OF WAITING FOR A BUFFER.  IF AN I/O ERROR        *
*       OCCURS WHEN READING OR WRITING AN IOT THE $IOERROR            *
*       MACRO IS ISSUED TO WRITE A DIAGNOSTIC MESSAGE TO THE          *
*       CONSOLE.  HOWEVER, THE $IOERROR ROUTINE WILL RETURN           *
*       WITHOUT WAITING IF UNABLE TO GET A CMB.                       *
*                                                                     *
***********************************************************************
         EJECT                                                      R41
$IOTPUR  DS    0H                  ENTRY POINT                      R41
         USING $IOTPUR,R15         TEMPORARY ADDRESSABILITY         R41
         USING JOEDSECT,WE         ADDRESSABILITY FOR JOE           R41
         USING IOTDSECT,WF         ADDRESSABILITY FOR IOT           R41
         USING PDBDSECT,WD         ADDRESSABILITY FOR PDDB          R41
         SPACE 2                                                    R41
         STM   R14,R10,COMREGSV+12 STORE REGISTERS             @OZ18622
         LR    BASE3,R15           ESTABLISH WORKING BASE           R41
         DROP  R15                                                  R41
         USING $IOTPUR,BASE3                                        R41
         LR    WE,R1               GET ADR OF WORK JOE              R41
        $GETBUF ,                  GET IOT BUFFER                   R41
         BZ    CIPEXIT             RETURN IF NO BUFFER AVAIL        R41
         LR    WF,R1               POINT TO IOT BUFFER              R41
***********************************************************************
*                                                                     *
*        READ SPIN DATA SET IOT                                       *
*                                                                     *
***********************************************************************
CIPREAD  MVI   PCEDEVTP,PCEDARD    SET UP DCT TO READ               R41
         ST    WF,PCEBUFAD         ADDR OF BUFFER                   R41
         MVC   PCESEEK,JOEIOTTR    MTTR OF SPIN IOT                 R41
         LA    R1,PCEDADCT         ADDR OF DCT                      R41
        $EXCP  (R1),WAIT=YES       READ SPIN IOT                    R41
         BM    CIPFBUF             GO FREE IOT BUFFER IF ERROR      R41
         SPACE 2                                                    R41
***********************************************************************
*                                                                     *
*        PURGE SPIN DATA SET TRACKS IF ALLOCATION IOT                 *
*                                                                     *
***********************************************************************
CIPIOT   TM    IOTFLAG1,IOT1ALOC   IF NOT AN ALLOCATION IOT,        R41
         BNO   CIPPSO              BRANCH (NO TRACKS TO PURGE)      R41
        $PURGE IOTTGMAP            PURGE SPIN DATA SET TRACKS       R41
         NI    IOTFLAG1,255-IOT1ALOC  TURN OFF ALLOCATE FLAG        R41
***********************************************************************
*                                                                     *
*        UPDATE PDDB FLAG AND WRITE IOT                               *
*                                                                     *
***********************************************************************
CIPPSO   L     WD,$IOTPDDB         GET PDDB DISPLACEMENT            R41
         ALR   WD,WF               GET ADDR OF PDDB, MAKE DS        R41
         NI    PDBFLAG1,255-PDB1PSO INELIGIBLE FOR WARMSTART        R41
         MVI   PCEDEVTP,PCEDAWR    SET UP DCT FOR WRITE             R41
         LA    R1,PCEDADCT         POINT TO DCT                     R41
        $EXCP  (R1),WAIT=YES       WRITE UPDATED IOT                R41
***********************************************************************
*                                                                     *
*        NOTE--IF AN IO READ/WRITE ERROR OCCURS, $EXCP WILL           *
*              ISSUE THE $IOERROR MACRO TO OUTPUT A DIAGNOSTIC        *
*              MESSAGE.  IF HOWEVER, THE $IOERROR ROUTINE IS          *
*              UNABLE TO GET A CMB, IT WILL RETURN (WITHOUT           *
*              WAITING FOR A CMB) TO PROTECT AGAINST A POSSIBLE       *
*              CONSOLE LOCKOUT.                                       *
*                                                                     *
***********************************************************************
         SPACE 2                                                    R41
CIPFBUF $FREEBUF (WF)              FREE IOT BUFFER                  R41
         SPACE 2                                                    R41
CIPEXIT $QSUSE                     REQUEST ACCESS TO CKPT DATA      R41
         LM    R14,R10,COMREGSV+12 RESTORE REGISTERS           @OZ18622
         BR    LINK                RETURN TO CALLER                 R41
$COMMEND DS    0D                                                   R41
$MLENGTH $DLENGTH HEADER=M         COMPUTE HASPCOMM CSECT LEN       R41
         SPACE 2                                                    R41
HASPCOMA CSECT                     REVERT TO HASPCOMA CSECT         R41
$COMAEND DS    0D                  FILL OUT CONTROL SECTION         R41
$ALENGTH $DLENGTH HEADER=A         COMNPUTE HASPCOMA CSECT LEN      R41
         SPACE 5                                                    R41
HASPCOMM CSECT                     REVERT TO HASPCOMM CSECT         R41
APARNUM  DC    CL5'32133'          APAR NUMBER
         END   ,                                                    R41
