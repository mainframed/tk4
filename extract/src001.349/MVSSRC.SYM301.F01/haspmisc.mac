MISC     TITLE 'HASP MISCELLANEOUS PROCESSORS'                 @OZ18212
***********************************************************************
*                                                                     *
* MODULE NAME = HASPMISC                                              *
*                                                                     *
* DESCRIPTIVE NAME = HASPMISC                                         *
*                                                                     *
* COPYRIGHT = NONE                                                    *
*                                                                     *
* STATUS = OS/VS2 MVS   --  SEE &VERSION (BELOW) FOR JES2 LEVEL       *
*                                                                     *
* FUNCTION = THE HASP MISCELLANEOUS PROCESSORS CONSIST OF FOUR        *
*            SEPARATE ROUTINES - HASPVPRG, HASPCKPT, HASPGPRC         *
*            AND HASPWARM.                                            *
*                                                                     *
*            HASPVPRG PURGES JOBS FROM THE SYSTEM BY FREEING          *
*            OUTPUT TRACKS, PREPARING A TYPE 26 SMF RECORD, AND       *
*            BY NOTIFYING THE OPERATOR THAT THE JOB HAS BEEN PURGED.  *
*                                                                     *
*            HASPCKPT CHECKPOINTS JOB AND JOT QUEUE RECORDS,          *
*            POSTS PROCESSORS REQUESTING QUEUE ACCESS VIA THE         *
*            $QSUSE MACRO, RELEASES UNUSED TRACK GROUPS FROM THE      *
*            TRACK GROUP BLOCK, HEURISTICALLY ALLOCATES NEW TRACK     *
*            GROUPS FROM THE MASTER TRACK GROUP MAP TO THE TRACK      *
*            GROUP BLOCK, RECALCULATES ALLOCATED TRACK GROUPS, AND    *
*            POSTS PROCESSORS AND OTHER ADDRESS SPACES WHO MAY BE     *
*            WAITING FOR TRACK ALLOCATION.                            *
*            FOR SHARED QUEUE SYSTEMS, HASPCKPT ALSO RESERVES AND     *
*            READS THE SHARED JOB AND JOT QUEUE RECORDS, DETECTS      *
*            POTENTIAL LOCKOUT BY OTHER SYSTEMS, PERFORMS CROSS       *
*            SYSTEM POSTING FOR SHARED QUEUE ELEMENTS, RELEASES THE   *
*            CHECKPOINT DEVICE AFTER A MINIMUM HOLD INTERVAL,         *
*            PREVENTS REREAD OF THE SHARED QUEUES FOR A MINIMUM       *
*            DORMANT INTERVAL TO ALLOW OTHER SYSTEMS ACCESS,          *
*            AND FORCES REREAD OF THE SHARED QUEUES AFTER A           *
*            MAXIMUM DORMANT INTERVAL.                                *
*                                                                     *
*            HASPGPRC PRIORITY AGES JOBS AT A TIME INTERVAL           *
*            DETERMINED FROM THE HASPGEN PARAMETER &PRIRATE.          *
*                                                                     *
*            HASPWARM PERFORMS A SINGLE SYSTEM OR NODAL WARM START    *
*            FOLLOWING JES2 INITIALIZATION OR AS THE RESULT OF A      *
*            $ESYS COMMAND.                                           *
*                                                                     *
* NOTES = SEE BELOW                                                   *
*                                                                     *
*    DEPENDENCIES = NONE                                              *
*                                                                     *
*    RESTRICTIONS = NONE                                              *
*                                                                     *
*    REGISTER CONVENTIONS = SEE BELOW FOR INDIVIDUAL ROUTINES         *
*                                                                     *
*                           R11 = BASE1 = HCT ADDRESSABILITY          *
*                           R12 = BASE2 = ROUTINES BASE REGISTER      *
*                           R13 = SAVE  = PCE ADDRESSABILITY          *
*                                                                     *
*    PATCH LABEL = NONE                                               *
*                                                                     *
* MODULE TYPE = PROCEDURE ( CSECT TYPE )                              *
*                                                                     *
*    PROCESSOR = ASSEMBLER F                                          *
*                                                                     *
*    MODULE SIZE = SEE $DLENGTH MACRO EXPANSION(S) AT END OF ASSEMBLY *
*                                                                     *
*    ATTRIBUTES = READ ONLY, AFTER PROCESSOR INITIALIZATION, AND      *
*                 HASP REENTRANT                                      *
*                                                                     *
* ENTRY POINT 1 = HASPVPRG FOR THE PURGE PROCESSOR                    *
*             2 = HASPCKPT FOR THE CHECKPOINT PROCESSOR               *
*             6 = HASPGPRC FOR THE PRIORITY AGING PROCESSOR           *
*             7 = HASPWARM FOR THE JOB QUEUE WARM START PROCESSOR     *
*                                                                     *
*    PURPOSE = SEE FUNCTION                                           *
*                                                                     *
*    LINKAGE = R12 = BASE2 = ENTRY POINT AND BASE REGISTER            *
*              R13 = SAVE  = PCE SAVE AREA ADDRESSABILITY             *
*                                                                     *
* INPUT = HASPVPRG USES MACRO $QGET TO ACCESS JOB QUEUE ELEMENTS THAT *
*         ARE TO BE PURGED AND $EXCP TO ACCESS JCTS AND IOTS FOR      *
*         THE JQES.                                                   *
*                                                                     *
*        HASPCKPT ACCESSES THE JOB QUEUE BUFFER, THE JOB AND JOT      *
*        CHECKPOINT CONTROL TABLES, THE MASTER TRACK GROUP MAP,       *
*        THE TRACK GROUP BLOCK, THE TRACK EXTENT DATA TABLES,         *
*        THE CHECKPOINT DEVICE SRB-IOSB AND UCB, THE SHARED QUEUE     *
*        CONTROL ELEMENTS, AND FIELDS IN THE HCT AND SSVT.            *
*                                                                     *
*         HASPGPRC ACCESSES JOB QUEUE ENTRIES.                        *
*                                                                     *
*         HASPWARM ACCESSES THE REMOTE SIGN-ON TABLE, THE QSES,       *
*         THE JOT AND THE JOB QUEUE.                                  *
*                                                                     *
* OUTPUT = HASPVPRG PUTS A HASP SMF BUFFER, WITH A TYPE 26 RECORD     *
*         IN IT, ON THE BUSY QUEUE.                                   *
*                                                                     *
*        HASPCKPT WRITES CHECKPOINT RECORDS, CLEARS THE CHECKPOINT    *
*        CONTROL TABLES, UPDATES THE MASTER TRACK GROUP MAP AND       *
*        TRACK GROUP BLOCK, AND CHANGES CONTROL FIELDS IN THE         *
*        CHECKPOINT UCB, QSES, HCT, AND SSVT.                         *
*                                                                     *
*         HASPGPRC UPDATES JOB QUEUE ELEMENTS PRIORITY FIELDS         *
*                                                                     *
*         HASPWARM UPDATES THE RESOURCES ACCESSED AS INPUT.           *
*                                                                     *
* EXIT-NORMAL = HASPVPRG $WAITS FOR JOB                               *
*                                                                     *
*               HASPCKPT $WAITS FOR CKPW AND/OR WORK (TIMER)          *
*                                                                     *
*               HASPGPRC $WAITS FOR WORK                              *
*                                                                     *
*               HASPWARM $WAITS FOR WORK                              *
*                                                                     *
* EXIT-ERROR = HASPVPRG ISSUES $IOERROR AND $DISTERR MSGS IF EITHER   *
*              A JCT OR AN IOT IS INVALID                             *
*                                                                     *
*              HASPCKPT ISSUES $IOERROR AND EXITS WITH CATASTROPHIC   *
*              ERROR CODE K02 OR K04 IF UNRECOVERABLE I/O ERRORS      *
*              OCCUR DURING READ OR WRITE OF CHECKPOINT RECORDS.      *
*              INVALID ALTERATION OF SHARED QUEUES BY THIS OR         *
*              ANOTHER SYSTEM CAUSES EXIT WITH CODE K01 OR K03.       *
*              MESSAGES 260, 093, OR 355 ARE ISSUED WITH $WTO IF      *
*              POTENTIAL SHARED DASD LOCKOUT, SPOOL WARNING           *
*              PERCENTAGE, OR SPOOL FULL CONDITIONS ARE DETECTED.     *
*                                                                     *
*              HASPGPRC HAS NO ERROR EXIT                             *
*                                                                     *
*              HASPWARM HAS NO ERROR EXIT                             *
*                                                                     *
* EXTERNAL REFERENCES = SEE BELOW                                     *
*                                                                     *
*    ROUTINES = NONE                                                  *
*                                                                     *
*    DATA AREAS = SEE BELOW                                           *
*                                                                     *
*    CONTROL BLOCKS = SEE $HASPCB MACRO FOR CONTROL BLOCKS USED       *
*                                                                     *
* TABLES = SEE BELOW                                                  *
*                                                                     *
* MACROS = $ENTRY, $QGET, $ACTIVE, $WAIT, $GETBUF, $EXCP, $IOERROR    *
*          $DISTERR, $PURGE, $GETSMFB, $QUESMFB, $QREM, $WTO,         *
*          $FREEBUF, $DORMANT, $POST, $TTIMER, $STIMER, $DLENGTH      *
*          $BFRBLD, $PGRLSE, $GETLOK, $FRELOK, $ERROR, $MSG,          *
*          MODESET, STARTIO                                           *
*                                                                     *
* CHANGE ACTIVITY                                                     *
*                                                                     *
*     RELEASE 4.0 = OZ02439,OZ03301,OZ03308,OZ03316,OZ04304,OZ04316,  *
*                   OZ04971,OZ04992,OZ04996,OZ08144,OZ08232,OZ10287   *
*                                                                     *
*     RELEASE 4.1 = OZ09107,OZ11763,OZ11776,OZ12270,OZ12289,OZ14441,  *
*                   OZ14890,OZ15818                                   *
*                                                                     *
***********************************************************************
         EJECT
         SPACE 5
*
*****    $HASPCB   *****           GENERATE HASP CONTROL BLOCKS
*
         MACRO
         $HASPCB &DOC=NO,&LIST=NO
         GBLC  &PRINT,&GEN,&DATA
         PUSH  PRINT
         PRINT &PRINT
         $CVT  LIST=&LIST          GENERATE OS CVT DSECT
         $SSCT LIST=&LIST          GENERATE OS SSCT DSECT
         $SSOB (SO,JS),LIST=&LIST  GENERATE OS SSOB DSECT            R4
         $SRB  LIST=&LIST          GENERATE OS SRB DSECT
         $DCB  LIST=&LIST          GENERATE OS DCB DSECT             R4
         $DEB  LIST=&LIST          GENERATE OS DEB DSECT             R4
         $IOSB LIST=&LIST          GENERATE OS IOSB DSECT
         $UCB  LIST=&LIST          GENERATE OS UCB DSECT
         $DYN  LIST=&LIST          GENERATE OS DYN DSECT             R4
         $BASEA LIST=&LIST         GENERATE OS BASEA DSECT
         $IOCM LIST=&LIST          GENERATE OS IOCM DSECT
         $TED  DOC=&DOC            GENERATE HASP TED DSECT
         $TGB  DOC=&DOC            GENERATE HASP TGB DSECT
         $TGM  DOC=&DOC            GENERATE HASP TGM DSECT
         $TAB  DOC=&DOC            GENERATE HASP TAB DSECT           R4
         $SVT  DOC=&DOC            GENERATE HASP SSVT DSECT
         $SJB  DOC=&DOC            GENERATE HASP SJB DSECT
         $HCT  DOC=&DOC            GENERATE HASP HCT DSECT
         $PCE  DOC=&DOC            GENERATE HASP PCE DSECT
         $LRC  DOC=&DOC            GENERATE HASP LRC DSECT          R41
         $BUFFER DOC=&DOC          GENERATE HASP BUFFER DSECT
         $SMF  DOC=&DOC            GENERATE HASP SMF DSECT
         $JQE  DOC=&DOC            GENERATE HASP JQE DSECT
         $JOE  DOC=&DOC            GENERATE HASP JOE DSECT
         $JOT  DOC=&DOC            GENERATE HASP JOT DSECT
         $QSE  DOC=&DOC            GENERATE HASP QSE DSECT
         $JQB  DOC=&DOC            GENERATE HASP JQB DSECT           R4
         $JCT  DOC=&DOC            GENERATE HASP JCT DSECT
         $PDDB DOC=&DOC            GENERATE PDDB DSECTSECT
         $IOT  DOC=&DOC            GENERATE HASP IOT DSECT
         $DCT  DOC=&DOC            GENERATE HASP DCT DSECT
         $TQE  DOC=&DOC            GENERATE HASP TQE DSECT
         $HQR  DOC=&DOC            GENERATE HASP HQR DSECT
         $HQT  DOC=&DOC            GENERATE HASP HQT DSECT
         $PSO  DOC=&DOC            GENERATE HASP PSO DSECT           R4
         $SPL  DOC=&DOC            GENERATE HASP SPL DSECT           R4
         $CKPWORK DOC=&DOC         GENERATE HASP CKPWORK DSECT      R41
         $WARMWRK DOC=&DOC         GENERATE HASP WARMWRK DSECT       R4
         SPACE 1
         POP   PRINT
         PRINT &GEN,&DATA          SET ASSEMBLY PRINT OPTIONS
         MEND
         TITLE 'HASP MISCELLANEOUS PROCESSORS'
         SPACE 5
HASPMISC START 0                   HASP MISCELLANEOUS PROCESSORS
         SPACE 5
*
*                             EXTERNAL REFERENCES
*
         SPACE 5
         COPY  $HASPGEN            COPY HASPGEN PARAMETERS
         TITLE 'HASP CONTROL BLOCKS'
         SPACE 5
HASPMISC $ENTRY BASE=,CSECT=YES    PROVIDE PROCESSOR IDENTIFICATION
         SPACE 5
*
*                             DOCUMENTATION OPTIONS FOR THIS ASSEMBLY
*
         SPACE 3
        $SYSPARM (OFF,GEN,NODATA,NO,NO)
         SPACE 5
*
*                             GENERATE HASP CONTROL BLOCKS
*
         SPACE 3
        $HASPCB DOC=&DOC,LIST=&LIST  GENERATE HASP CONTROL BLOCKS
         TITLE 'HASP PURGE PROCESSOR'
***********************************************************************
*                                                                     *
* PROCESSOR NAME -- HASPVPRG                                          *
*                                                                     *
* DESCRIPTIVE NAME -- JES2 PURGE PROCESSOR                            *
*                                                                     *
* FUNCTION -- FREE ALL TRACKS ACQUIRED FOR A JOB, QUEUE FOR OUTPUT    *
*             AN SMF PURGE RECORD (TYPE 26) AND OPTIONALLY A JMR      *
*             BUFFER, AND NOTIFY THE OPERATOR THAT THE JOB IS PURGED. *
*                                                                     *
* NOTES -- 1) TO IMPROVE THE PERFORMANCE OF THIS PROCESSOR, PERMANENT *
*             STORAGE IS OBTAINED, VIA GETMAIN, TO SERVE AS BUFFER    *
*             STORAGE FOR A JCT AND AN IOT.  WHEN THE PROCESSOR HAS   *
*             NO MORE WORK TO DO, THE BUFFER STORAGE IS PAGE-RELEASED.*
*                                                                     *
* REGISTER CONVENTIONS -- R1  -- WORK REGISTER                        *
*                         WA  -- JQE ADDRESS                          *
*                         WB  -- DCT ADDRESS                          *
*                         WC  -- WORK REGISTER                        *
*                         WD  -- IOT ADDRESS                          *
*                         WE  -- LINK REGISTER                        *
*                         WF  -- WORK REGISTER                        *
*                         JCT -- JCT ADDRESS                          *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
*        H A S P V P R G   I N I T I A L   E N T R Y   P O I N T      *
*                                                                     *
***********************************************************************
         SPACE 2
         USING JQEDSECT,WA         PROVIDE JQE ADDRESSABILITY
         USING IOTDSECT,WD         PROVIDE IOT ADDRESSABILITY
         SPACE 2
HASPVPRG $ENTRY BASE=BASE2         PROVIDE PROCESSOR ENTRY POINT
         SPACE 1
***********************************************************************
*                                                                     *
*        C O M P U T E   S T O R A G E   R E Q U I R E M E N T        *
*                                                                     *
***********************************************************************
         SPACE 1
         LH    R1,$BUFLENG         GET TOTAL SINGLE BUFFER SIZE      R4
         LR    WA,R1               TENTATIVE ADDRESS OF NEXT BUFFER
         LR    R0,WA               R0 = STARTING ADDR OF NEXT BUFFER
         SRL   R0,12                DIVIDED BY 4K
         ALR   R1,WA               R1 = ADDRESS OF LAST BYTE
         BCTR  R1,0                 OF NEXT BUFFER
         SRL   R1,12                 DIVIDED BY 4K
         CLR   R0,R1               DOES BUFFER CROSS 4K BOUNDARY...
         BE    *+10                BR IF NO TO USE TENTATIVE BFR ADDR
         SLL   R1,12                ELSE USE NEXT 4K BOUNDARY AS
         LR    WA,R1                 STARTING ADDR OF NEXT BUFFER
         LR    WD,WA               SAVE RELATIVE ADDR OF NEXT BFR
         AH    WA,$BUFLENG         R0 = TOTAL BUFFER STORAGE         R4
         LA    R0,4095(,WA)         REQUIREMENT ROUNDED
         SRL   R0,12                 UP TO NEXT
         SLL   R0,12                  4K BOUNDARY
         ST    R0,VSTORAGE         SAVE BUFFER STORAGE REQUIREMENT
         EJECT
***********************************************************************
*                                                                     *
*        O B T A I N   P E R M A M E N T   B U F F E R   S T O R A G E*
*                                                                     *
***********************************************************************
         SPACE 1
         GETMAIN RC,LV=(0),BNDRY=PAGE  GET THE BUFFER STORAGE
         LR    JCT,R1              SAVE JCT BUFFER ADDRESS
         ALR   WD,R1               SAVE IOT BUFFER ADDRESS
         ICM   JCT,8,=AL1(X'80')   SHOW BUFFER PAGE(S) RELEASED
         LA    WB,PCEDADCT         GET DIRECT ACCESS DCT ADDRESS
         MVI   PCEDEVTP,PCEDARD    SET READ REQUEST FOR $EXCP
         LTR   R15,R15             TEST GETMAIN
         BZ    VGETJOB             BR IF SUCCESSFUL
V02     $ERROR                      ELSE CRUMP
         SPACE 1
VSTORAGE DC    A(*-*)              SIZE OF PERMANENT BUFFER STORAGE
         EJECT
VNOJOB   LTR   JCT,JCT             HAS BUFFER STORAGE BEEN RELEASED...
         BM    VJBWAIT             BR IF SO
         SPACE 1
***********************************************************************
*                                                                     *
*        R E L E A S E   B U F F E R   P A G E ( S )                  *
*                                                                     *
***********************************************************************
         SPACE 1
        $PGSRVC RLSE,(JCT),VSTORAGE    RELEASE JCT/IOT BUFFER PG(S)  R4
         ICM   JCT,8,=AL1(X'80')   SHOW BUFFER PAGE(S) RELEASED
         SPACE 1
***********************************************************************
*                                                                     *
*        W A I T   F O R   A   J O B   T O   P U R G E                *
*                                                                     *
***********************************************************************
         SPACE 1
VJBWAIT $WAIT  JOB,INHIBIT=NO      $WAIT FOR JOB TO BE QUEUED
         SPACE 1
VGETJOB $QGET  $PURGE,VNOJOB       TRY TO GET A JOB
         LR    WA,R1               SAVE JQE ADDRESS
        $ACTIVE                    INDICATE PROCESSOR ACTIVE
         LTR   JCT,JCT             HAS BUFFER STORAGE BEEN RELEASED...
         BP    VGETJCT             BR IF NO
         LA    JCT,0(,JCT)          ELSE RESET PAGE-RELEASED FLAG
        $BFRBLD (JCT)              BUILD IOB WITHIN JCT BUFFER
        $BFRBLD (WD)               BUILD IOB WITHIN IOT BUFFER
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        R E A D   I N   T H E   J C T                                *
*                                                                     *
***********************************************************************
         SPACE 1
VGETJCT  ST    JCT,PCEBUFAD        SET BUFFER ADDRESS FOR $EXCP
         MVC   PCESEEK,JQETRAK     SET TRACK ADDRESS FOR $EXCP
        $EXCP  (WB)                READ THE JCT
         SPACE 1                                                     R4
VWAIT1  $WAIT  IO                  WAIT FOR I/O TO COMPLETE
         TM    BUFECBCC-BUFDSECT(JCT),X'7F'  TEST I/O STATUS
         BZ    VWAIT1              BR IF I/O NOT COMPLETE
         IC    WF,JQEFLAGS         SAVE JQE FLAG BYTE
         SPACE 1
***********************************************************************
*                                                                     *
*        ISSUE 'JOB PURGED' MESSAGE -- REMOVE JOB FROM SYSTEM         *
*                                                                     *
***********************************************************************
         SPACE 1
VREMJOB  LR    JCT,WA              RELOAD JQE ADDRESS               R41
        $WTO   VPRGMSG,L'VPRGMSG,WAIT=YES,JOB=YES,                  R41C
               ROUTE=$LOG+$UR,CLASS=$TRIVIA,PRI=$ST                 R41
         L     JCT,PCEBUFAD        RESTORE JCT ADDRESS              R41
        $QREM  (WA)                REMOVE JOB FROM SYSTEM           R41
        $WAIT  CKPT                WAIT FOR CHECKPOINT TO COMPLETE
         TM    BUFECBCC-BUFDSECT(JCT),X'7F'  TEST JCT READ
         BO    VNOERROR            BR IF JCT READ WITHOUT ERROR
        $IOERROR (JCT)              ELSE ISSUE I/O ERROR MSG
         SPACE 1
VERROR  $DISTERR                   INDICATE DISASTEROUS ERROR
         B     VDONE               BR TO CONTINUE                   R41
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        R E A D   I O T ( S )   A N D   P U R G E   T R A C K S      *
*                                                                     *
***********************************************************************
         SPACE 1
         CNOP  0,8
VNOERROR L     R1,JCTJQE           VALIDATE
         AL    R1,$JOBQPTR          THE
         CLR   R1,WA                 JCT
         BNE   VERROR              BR IF INVALID JCT
         ST    WD,PCEBUFAD         SET BUFFER ADDRESS FOR $EXCP
         ICM   R1,15,JCTSPIOT      GET TRK ADDR OF 1ST SPIN IOT
         BZ    *+16                BR IF NONE
         BAL   WE,VIOTPRG           ELSE READ IOT AND PURGE TRACKS
         ICM   R1,15,IOTIOTTR      GET TRK ADDR OF NEXT SPIN IOT
         BNZ   *-8                 BR IF VALID TRACK ADDRESS
         ICM   R1,15,JCTIOT        GET TRK ADDR OF 1ST REGULAR IOT
         BZ    VSMFPRG             BR IF NONE
         BAL   WE,VIOTPRG           ELSE READ IOT AND PURGE TRACKS
         B     VSMFPRG             THEN BR TO WRITE SMF RECORDS
         EJECT
***********************************************************************
*                                                                     *
*        VIOTPRG -- ROUTINE TO READ IOT AND PURGE TRACKS              *
*                                                                     *
***********************************************************************
         SPACE 1
         CNOP  0,8
VIOTPRG  ST    R1,PCESEEK          SET TRACK ADDRESS FOR $EXCP
        $EXCP  (WB),WAIT=YES       READ THE IOT                      R4
         BO    VNOIOTER            BR IF NO READ ERROR
         SPACE 1
VDSTER  $DISTERR                   INDICATE DISASTEROUS ERROR
         B     VSMFPRG             THEN WRITE SMF PURGE RECORD
         SPACE 1
         CNOP  0,8
VNOIOTER CLC   IOTJBKEY,JCTJBKEY   TEST FOR VALID IOT
         BNE   VDSTER              BR IF NO
         TM    IOTFLAG1,IOT1ALOC   TEST FOR ALLOCATION IOT
         BZR   WE                  RETURN IF NO
        $PURGE IOTTGMAP             ELSE PURGE ALLOCATED TRACKS
         BR    WE                  THEN RETURN
         EJECT                                                       R4
         CNOP  0,8
VSMFPRG  CLI   $NUMSMFB,2          TEST SMF BUFFER COUNT             R4
         BL    VDONE               BR IF SMF NOT SUPPORTED          R41
         TM    JCTSMFLG,JCTNOUJP+JCTNOT26  PURGE EXIT OR 26...
         BO    VDONE               BR IF NO                         R41
         BZ    *+16                BR IF BOTH
         TM    JCTSMFLG,JCTNOUJP   PURGE EXIT...
         BZ    *+8                 BR IF SO
         NI    JCTINDC,255-JCTJMRUX  ELSE INDICATE NO EXIT           R4
         SPACE 1
***********************************************************************
*                                                                     *
*        GET SMF BUFFER(S) FOR PURGE RECORD(S)                        *
*                                                                     *
***********************************************************************
         SPACE 1                                                     R4
         USING SMFDSECT,R1
         SPACE 1
        $GETSMFB WAIT=YES          OBTAIN JMR BUFFER ADDRESS
         TM    JCTINDC,JCTJMRUX    SHOULD USER EXITS BE TAKEN
         BZ    VCRE826             NO, DO NOT SAVE JMR
         MVC   SMFJMR(JCTJMRND-JCTJMR),JCTJMR  MOVE JMR TO SMF RCD   R4
         MVI   SMFTYPE,SMFJMRTP    JMR BUFFER ID
         LR    WC,R1               SAVE BUFFER ADDR. FOR PURGE REC
        $GETSMFB WAIT=YES          OBTAIN PURGE RECORD BFR ADDR
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        FORMAT AND QUEUE SMF TYPE 26 (PURGE) RECORD                  *
*                                                                     *
***********************************************************************
         SPACE 1
VCRE826  TM    JCTSMFLG,JCTNOT26   WRITE 26 RECORD...
         BZ    *+8                 BR IF SO
         OI    SMF26FLG,SMFNO26    NO
         MVC   SMF26JBN(SMFSIZE1),JCTJMRJN   GATHER PURGE RECORD INTO
         MVC   SMF26UIF,JCTUSEID         SMF BUFFER - HEADER
         MVC   SMF26JBF(JCTJBOPT+L'JCTJBOPT-JCTJOBFL),JCTJOBFL
         MVC   SMF26JNM(JCTPROCN+L'JCTPROCN-JCTJOBID-4),JCTJOBID+4  R41
         MVC   SMF26JID,JCTJOBID   JOB ID
         MVC   SMF26RPT(SMFSIZE3),JCTRDROF        TIME/DATE OFF READER
         MVC   SMF26CST(JCTODTOF+L'JCTODTOF-JCTCNVON),JCTCNVON       R4
         MVC   SMF26ICD(JCTOTSID+L'JCTOTSID-JCTCARDS),JCTCARDS
         STC   WF,PCER1            STORE JQE FLAG BYTE               R4
         TM    PCER1,QUEOPCAN+QUEPURGE  DID OPERATOR ISSUE $C OR $P
         BZ    *+8                 BR IF NO
         OI    SMF26INF,SMFOPCAN   INDICATE OPERATOR CANCELLED JOB
         MVC   SMFRDW(2),=Y(SMF26END-SMFRDW)  SIZE OF PURGE RECORD   R4
         MVI   SMF26LN1+1,SMF26PDD+L'SMF26PDD-SMF26LN1 DESC LENGTH  R41
         MVI   SMF26LN2+1,SMF26OPD+L'SMF26OPD-SMF26LN2 EVENTS LGTH
         MVI   SMF26LN3+1,SMF26END-SMF26LN3    ACTUALS LENGTH
         MVI   SMFHDRTY,SMFPRGTP   IDENTIFY PURGE RECORD TYPE
         MVI   SMF26SBS+1,SMFHSPID HASP SUBSYSTEM ID
         MVI   SMF26IND,X'E0'      SECTION EXISTENCE IDENTIFIER
         TM    JCTINDC,JCTJMRUX    SHOULD USER EXITS BE TAKEN
         BZ    *+10                BR IF NO TO NOT CHAIN BUFFERS
         ST    R1,JMRCHAIN-SMFDSECT(WC) PUT PURGE BUF ADDR IN JMR BUF
         LR    R1,WC               PUT JMR IN SMF BUFFER BUSY
        $QUESMFB                   QUEUE BUFFER(S) FOR WRITING
         SPACE 1
         DROP  R1
         SPACE 1
SMFSIZE1 EQU   L'SMF26JBN+L'SMF26RST+L'SMF26RSD                      R4
SMFSIZE3 EQU   L'SMF26RPT+L'SMF26RPD                                 R4
         EJECT
***********************************************************************
*                                                                     *
*        PROCESSING COMPLETE FOR THIS JOB                             *
*                                                                     *
***********************************************************************
         SPACE 1
VDONE   $DORMANT                   INDICATE PROCESSOR INACTIVE      R41
         B     VGETJOB             BR TO GET NEXT JOB
         SPACE 1
         DROP  WA,WD               KILL JQE, IOT ADDRESSABILITY
         SPACE 1
VPRGMSG $MSG   250,'IS PURGED'
         LTORG                                                 @OZ20010
         TITLE 'HASP CHECKPOINT PROCESSOR'
***********************************************************************
*                                                                     *
*    HASP CHECKPOINT PROCESSOR (SEE PROLOG ABOVE FOR DESCRIPTION)     *
*                                                                     *
***********************************************************************
         SPACE 1
HASPCKPT $ENTRY BASE=BASE2
         SPACE 2
***********************************************************************
*                                                                     *
*    INITIALIZATION  -  EXECUTED ONLY ONCE                            *
*                                                                     *
***********************************************************************
         SPACE 1
         ST    SAVE,CKPSTQE+IPOST  STORE PCE ADDRESS IN STQE        R41
         TM    $RUNOPTS,$RPS       SEE IF RPS FEATURE SHOULD   @OZ20010
         BZ    KINIT1                BE USED, BRANCH IF NOT    @OZ20010
         L     R1,$SSVT                     GET POINTER        @OZ20010
         L     R1,$SVRELSE-SSVT(,R1)        TO CHECKPOINT      @OZ20010
         L     R1,IOSUCB-IOSB+SRBSIZE(,R1)  DEVICE UCB         @OZ20010
         TM    UCBTBYT2-UCBDSECT(R1),UCBRPS TEST UCBTYPE BYTE2 @OZ20010
         BZ    KINIT1              BRANCH IF RPS NOT SUPPORTED @OZ20010
         OI    CKPFLAG1,CKP1RPS    SET 'RPS' BIT IN WORK AREA  @OZ20010
         SPACE 1                                               @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
KINIT1   MVC   PCESEEK,$HASPDCB    SET DA DCT                  @OZ20010
         MVI   PCEDEVTP,DCTINT      TO LOOK LIKE UNIT RECORD
         L     WE,$CKPTIOB         LOAD ADDRESS OF JOBQ BUFFER @OZ20010
         USING JQBDSECT,WE         PROVIDE JQB ADDRESSABILITY        R4
         ST    WE,PCEBUFAD         STORE IOB ADDR IN DA DCT    @OZ20010
                                   PRINT OFF - SECTION DELETED @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
                                   PRINT ON -- SECTION DELETED @OZ20010
         SPACE 1                                                     R4
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*    GO DO INITIAL READ IF SHARED SYSTEM                              *
*                                                                     *
***********************************************************************
         SPACE 1
KINITRD  L     R1,$QSE1            GET ADDRESS OF 1ST QSE            R4
         TM    QSEFLAGS-QSEDSECT(R1),QSELAST  TEST FOR ONE SYSTEM    R4
         BNZ   KSTRTPP             BR IF SO TO SKIP INIT READ  @OZ20010
         OI    CKPFLAG1,CKP1IRD    SET 'INITIAL READ' FLAG     @OZ20010
         B     KRDCCWS               AND GO READ IN QUEUES     @OZ20010
         SPACE 2
***********************************************************************
*                                                                     *
*    START PRINT/PUNCH TIMER AND SKIP ALL READING IF SINGLE SYSTEM    *
*                                                                     *
***********************************************************************
         SPACE 1
KSTRTPP  NI    $STATUS,255-$QSONDA INDICATE QUEUES IN STORAGE  @OZ20010
         TM    $RUNOPTS,$DEBUG     CHECK FOR 'DEBUG' ACTIVE,   @OZ20010
         BZ    KSTRTPP1              BYPASS NEXT IF NOT        @OZ20010
         L     R0,$JBQREAD         POINT TO CKPT READ-IN AREA  @OZ20010
         LH    R1,$JOBRECN         DEVELOP TOTAL               @OZ20010
         AH    R1,$JOTRECN           LENGTH OF JOBQ            @OZ20010
         SLL   R1,12                 AND JOT                   @OZ20010
         L     R14,$JOBQPTR        POINT TO ACTUAL CKPT AREA   @OZ20010
         LR    R15,R1              SET SAME LENGTH             @OZ20010
         MVCL  R0,R14              MOVE COPY OF Q'S FOR DEBUG  @OZ20010
         SPACE 1                                               @OZ20010
KSTRTPP1 L     R0,$CKPTIME         START TIMER FOR             @OZ20010
         BAL   WA,KSTIMER           PRINT/PUNCH CHECKPOINT INTERVAL
         B     KRDTIMER            BR TO BYPASS CKPT READING   @OZ20010
         EJECT
***********************************************************************
*                                                                     *
*    BEGIN READ OPERATION                                             *
*                                                                     *
***********************************************************************
         SPACE 1
KREAD    TM    $RUNOPTS,$DEBUG     TEST DEBUG OPTION                 R4
         BZ    KRDCCWS             BR IF NOT SELECTED                R4
         SPACE 2
***********************************************************************
*                                                                     *
*    CHECK FOR INVALID CHANGE TO SHARED QUEUE AREA WHILE NOT OWNED    *
*                                                                     *
***********************************************************************
         SPACE 1
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
         L     R14,$JOBQPTR        POINT TO JOB QUEUE                R4
         LH    R15,$JOBRECN        GET NO. OF JOBQ RECORDS     @OZ20010
         AH    R15,$JOTRECN          ADD NO. OF JOT RECORDS,   @OZ20010
         SLL   R15,12                MULTIPLY BY PAGE SIZE     @OZ20010
         L     R0,$JBQREAD         POINT TO IN-AREA JOBQ/JOT   @OZ20010
         LR    R1,R15              DUPLICATE FIELD LENGTH
*                                  THIS CARD DELETED BY APAR   @OZ20010
         CLCL  R14,R0              COMPARE JOBQ/JOT WITH COPY  @OZ20010
                                   PRINT OFF - SECTION DELETED @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
                                   PRINT ON -- SECTION DELETED @OZ20010
         BE    KRDCCWS             BRANCH IF EQUAL
         SPACE 1                                                     R4
KRDK01   LR    R1,R0               PRESERVE R0 FOR DEBUGGING         R4
K01     $ERROR                     INVALID CHANGE OF SHARED QUEUES
         EJECT                                                 @OZ20010
***************************************************************@OZ20010
*                                                              @OZ20010
*    PAGE-FIX RECORD ONE READ-IN AREA FOR EXCPVR               @OZ20010
*                                                              @OZ20010
***************************************************************@OZ20010
         SPACE 1                                               @OZ20010
KRDCCWS  LA    WB,JQBCCWS          POINT TO FIRST SET OF CCWS, @OZ20010
         USING JQBCCWE,WB            SET UP ADDRESSABILITY     @OZ20010
         L     R1,$CKPR1RD         POINT TO REC 1 READ-AREA    @OZ20010
         BAL   WC,KR1FIX           PAGE FIX FIRST REC AREA     @OZ20010
         MVI   JQBCRW,X'06'        SET CCW TO 'READ'           @OZ20010
         MVC   JQBCTNXT,KRNOP      SET ENDING TIC TO 'NOP'     @OZ20010
         LA    R0,JQBCCWS          SET ADDRESS OF 1ST CCW      @OZ20010
         ST    R0,IOBSTART-BUFDSECT+JQBDSECT  IN IOB           @OZ20010
                                   PRINT OFF - SECTION DELETED @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
                                   PRINT ON -- SECTION DELETED @OZ20010
         SPACE 1                                               @OZ20010
***********************************************************************
*                                                                     *
*    SET TO RESERVE CHECKPOINT DEVICE                                 *
*                                                                     *
***********************************************************************
         SPACE 1
        $GETLOK                    ACQUIRE LOCAL AND CMS LOCKS
         MODESET EXTKEY=ZERO       CHANGE TO KEY ZERO
         L     R14,$SSVT           OBTAIN                      @OZ20010
         USING SSVT,R14              SSVT ADDRESSABILITY       @OZ20010
         L     R15,$SVRELSE        POINT TO CKPT DEVICE        @OZ20010
         L     R15,IOSUCB-IOSB+SRBSIZE(,R15) UCB               @OZ20010
         USING UCBDSECT,R15        UCB ADDRESSABILITY          @OZ20010
         IC    R1,UCBSQC           INCREMENT
         LA    R1,1(,R1)            CHECKPOINT DEVICE
         STC   R1,UCBSQC             RESERVE COUNT
         OI    $SVSTUS,$SVSTCRV    INDICATE CHECKPOINT RESERVED
         DROP  R14,R15             DROP SSVT, UCB ADDR.        @OZ20010
        $FRELOK                    RELEASE LOCAL AND CMS LOCKS
         EJECT                                                 @OZ20010
***********************************************************************
*                                                                     *
*    DO READ WITH TIMER TO DETECT LOCKOUT BY OTHER SYSTEMS            *
*                                                                     *
***********************************************************************
         SPACE 1
*                                  THIS LINE DELETED BY APAR   @OZ20010
         L     R0,$WARNTIM         START TIMER TO DETECT             R4
         BAL   WA,KSTIMER           SHARED QUEUES CONTROL LOCKOUT
         LA    R1,PCEDADCT         ISSUE V=R EXCP TO READ      @OZ20010
        $EXCP  (R1),TYPE=VR          FIRST RECORD FROM DASD    @OZ20010
         SPACE 1                                                    R41
KRDWAIT $WAIT  IO,INHIBIT=NO       WAIT FOR I/O OR TIMER
         CLI   BUFECBCC-BUFDSECT+JQBDSECT,0 I/O COMPLETE...    @OZ20010
         BNE   KRDIOCC             BR IF YES                         R4
         TM    CKPSTQE+IPOST,X'80' HAS TIMER EXPIRED...             R41
         BZ    KRDWAIT             BR IF NO TO IGNORE $POST          R4
         MVC   CKPMSG(L'KWARNMSG),KWARNMSG MOVE MSG TO WKAREA  @OZ16669
         $$WTO CKPMSG              ISSUE WARNING MESSAGE       @OZ16669
         L     R0,$WARNTIM         RESTART                           R4
         BAL   WA,KSTIMER           WARNING TIMER
         B     KRDWAIT             GO WAIT AGAIN
         EJECT
***********************************************************************
*                                                                     *
*    CHECK FOR UNREADABLE RECORD                               @OZ20010
*                                                                     *
***********************************************************************
         SPACE 1
KRDIOCC  BAL   WA,KTTIMER          STOP TIMER
         CLI   BUFECBCC-BUFDSECT+JQBDSECT,X'7F' CK I/O COMP.   @OZ20010
         BE    KRD1OK              BRANCH IF OK                @OZ20010
        $IOERROR (WE)              ISSUE I/O ERROR MESSAGE     @OZ20010
K02     $ERROR                     CKPT RECORDS UNREADABLE     @OZ20010
         SPACE 1                                               @OZ20010
***************************************************************@OZ20010
*                                                              @OZ20010
*    FORCE READ OF ALL JOBQ/JOT RECORDS IF INITIAL             @OZ20010
*    READ ON SHARED SYSTEM                                     @OZ20010
*                                                              @OZ20010
***************************************************************@OZ20010
         SPACE 1                                               @OZ20010
KRD1OK   L     WC,$RQSE            POINT TO OUR QSE IN IN-AREA @OZ20010
         USING QSEDSECT,WC         QSE ADDRESSABILITY          @OZ20010
         TM    CKPFLAG1,CKP1IRD    SEE IF INITIAL READ         @OZ20010
         BZ    KREAD2                BRANCH IF NOT             @OZ20010
         NI    CKPFLAG1,X'FF'-CKP1IRD   RESET FLAG             @OZ20010
         LH    R14,$JOBRECN        COMPUTE NUMBER OF JOBQ      @OZ20010
         AH    R14,$JOTRECN          AND JOT RECORDS           @OZ20010
         LR    R1,WC               POINT TO FIRST JOBQ/JOT     @OZ20010
         BCTR  R1,0                  CHECKPOINT CONTROL BYTE   @OZ20010
         AH    R1,$QSECTLB           MINUS ONE                 @OZ20010
         LA    R0,X'7F'            NON-ZERO BYTE               @OZ20010
         SPACE 1                                               @OZ20010
KRD1ALL  STC   R0,0(R1,R14)        FORCE CTL BYTE NON-ZERO     @OZ20010
         BCT   R14,KRD1ALL         LOOP THRU ALL BYTES         @OZ20010
         EJECT                                                 @OZ20010
***************************************************************@OZ20010
*                                                              @OZ20010
*    FIX READ-IN AREA PAGES, SET CCW ENTRIES TO READ           @OZ20010
*    JOBQ AND JOT RECORDS AS INDICATED BY QSE                  @OZ20010
*                                                              @OZ20010
***************************************************************@OZ20010
         USING JQBCCWE,WD          CCW ENTRY ADDRESSABILITY    @OZ20010
         SPACE 1                                               @OZ20010
KREAD2   LA    WB,JQBCCWS          'OLD' CCW ENTRY             @OZ20010
         LA    WD,L'JQBCCWEL(,WB)  'CURRENT' CCW ENTRY         @OZ20010
         AH    WC,$QSECTLB         POINT TO CTL BYTES IN QSE   @OZ20010
         DROP  WC                  DROP QSE ADDRESSABILITY     @OZ20010
         L     R1,$JBQREAD         FIRST PAGE IN-AREA ADDR     @OZ20010
         LH    WF,$JOBRECN         TOTAL NUMBER OF RECORDS     @OZ20010
         AH    WF,$JOTRECN           IN JOBQ AND JOT           @OZ20010
         SLR   R0,R0               ZERO OUT STARTING CCW       @OZ20010
         ST    R0,IOBSTART-BUFDSECT+JQBDSECT ADDR IN IOB       @OZ20010
         SPACE 1                                               @OZ20010
KRD2LP   CLI   0(WC),0             SEE IF ZERO BYTE            @OZ20010
         BE    KRD2ADJ             SKIP READ-IN IF SO          @OZ20010
         L     R0,=F'4096'         LENGTH OF PAGE FOR FIX      @OZ20010
         LA    R2,CKPECB           DUMMY ECB FOR FIX           @OZ20010
        $PGSRVC FIX,(R1),(R0),(R2) FIX IN-AREA PAGE            @OZ20010
         LRA   R0,0(,R1)           PUT REAL ADDRESS OF PAGE    @OZ20010
         ST    R0,JQBCRW             INTO 'READ' CCW           @OZ20010
         MVI   JQBCRW,X'06'        SET CCW TO 'READ'           @OZ20010
         BAL   WA,KCCWADJ          LINK CCW ENTRY TO PREVIOUS  @OZ20010
         LR    WB,WD               SET 'PREVIOUS' ENTRY ADDR   @OZ20010
         CLC   IOBSTART-BUFDSECT+JQBDSECT,=F'0'  SET ADDR OF   @OZ20010
         BNE   KRD2ADJ                           FIRST CCW IN  @OZ20010
         ST    WB,IOBSTART-BUFDSECT+JQBDSECT     IOBSTART      @OZ20010
         SPACE 1                                               @OZ20010
KRD2ADJ  LA    WC,1(,WC)           BUMP CTL BYTE POINTER       @OZ20010
         AL    R1,=F'4096'         POINT TO NEXT IN-AREA PAGE  @OZ20010
         LA    WD,JQBCNEXT         POINT TO NEXT CCW ENTRY     @OZ20010
         BCT   WF,KRD2LP           LOOP THRU ALL RECORDS       @OZ20010
         DROP  WD                  DROP CCW ENTRY ADDR.        @OZ20010
         SPACE 1                                               @OZ20010
***************************************************************@OZ20010
*                                                              @OZ20010
*    ISSUE EXCPVR TO READ JOBQ/JOT RECORDS, IF ANY REQUIRED    @OZ20010
*                                                              @OZ20010
***************************************************************@OZ20010
         SPACE 1                                               @OZ20010
         LA    R0,JQBCCWS          SEE IF ANYTHING TO READ     @OZ20010
         CLR   R0,WB                 AT ALL                    @OZ20010
         BE    KRDMVHCT            SKIP READ IF NOTHING        @OZ20010
         MVC   JQBCTNXT,KRNOP      SET LAST TIC TO 'NOP'       @OZ20010
         LA    R1,PCEDADCT         ISSUE V=R EXCP TO READ      @OZ20010
        $EXCP  (R1),TYPE=VR,WAIT=YES  JOBQ AND JOT RECORDS     @OZ20010
         BNO   K02                 BRANCH IF I/O ERROR         @OZ20010
         EJECT                                                 @OZ20010
***************************************************************@OZ20010
*                                                              @OZ20010
*    MOVE NEWLY-READ JOBQ/JOT PAGES TO REAL JOBQ/JOT AREA,     @OZ20010
*    PAGE-RELEASING EACH TARGET PAGE JUST BEFORE MOVE          @OZ20010
*                                                              @OZ20010
***************************************************************@OZ20010
         SPACE 1                                               @OZ20010
KRDMOVE  L     WB,$JBQREAD         READ-IN AREA ADDRESS        @OZ20010
         L     WD,$JOBQPTR         ACTUAL JOBQ/JOT AREA ADDR.  @OZ20010
         L     WC,$RQSE            POINT TO CTL BYTES IN       @OZ20010
         AH    WC,$QSECTLB           OUR QSE                   @OZ20010
         LH    WF,$JOBRECN         LOAD COUNT OF RECORDS       @OZ20010
         AH    WF,$JOTRECN           TO PROCESS                @OZ20010
         SPACE 1                                               @OZ20010
KRDMVLP  CLI   0(WC),0             SEE IF RECORD READ IN       @OZ20010
         BE    KRDMVADJ              BRANCH IF NOT             @OZ20010
         MVI   0(WC),0             ZERO OUT CONTROL BYTE       @OZ20010
         LR    R1,WD               LOAD ADDRESS AND            @OZ20010
         L     R0,=F'4096'           LENGTH FOR PAGE FIX       @OZ20010
         LA    R2,CKPECB           DUMMY ECB FOR PAGE FIX      @OZ20010
        $PGSRVC FIX,(R1),(R0),(R2),RELEASE=Y PAGE-RELEASE,     @OZ20010C
                                     THEN FIX FOR MVCL         @OZ20010
         LR    R0,WB               USE MVCL TO                 @OZ20010
         L     R1,=F'4096'           MOVE PAGE                 @OZ20010
         LR    R14,WD                JUST READ IN FROM         @OZ20010
         LR    R15,R1                INPUT AREA TO             @OZ20010
         MVCL  R14,R0                ACTUAL JOBQ/JOT PAGE      @OZ20010
         LR    R1,WD               LOAD ADDRESS AND            @OZ20010
         L     R0,=F'4096'           LENGTH FOR PAGE FREE      @OZ20010
        $PGSRVC FREE,(R1),(R0)     FREE JOBQ/JOT PAGE          @OZ20010
         LR    R1,WB               LOAD ADDRESS AND LENGTH     @OZ20010
         L     R0,=F'4096'           FOR PAGE FREE/RELEASE     @OZ20010
         TM    $RUNOPTS,$DEBUG     IF 'DEBUG', FREE PAGE       @OZ20010
         BZ    KRDMVRL               OTHERWISE, RELEASE PAGE   @OZ20010
         SPACE 1                                               @OZ20010
KRDMVFR $PGSRVC FREE,(R1),(R0)     PAGE FREE READ-IN AREA PAGE @OZ20010
         B     KRDMVADJ            BRANCH TO BOTTOM OF LOOP    @OZ20010
         SPACE 1                                               @OZ20010
KRDMVRL $PGSRVC FREE,(R1),(R0),RELEASE=Y FREE/RLSE READ-PAGE   @OZ20010
         SPACE 1                                               @OZ20010
KRDMVADJ AL    WB,=F'4096'         BUMP IN-AREA ADDRESS        @OZ20010
         AL    WD,=F'4096'         BUMP JOBQ/JOT ADDRESS       @OZ20010
         LA    WC,1(,WC)           BUMP CTL BYTE POINTER       @OZ20010
         BCT   WF,KRDMVLP          LOOP THRU ALL RECORDS       @OZ20010
         SPACE 1                                               @OZ20010
***************************************************************@OZ20010
*                                                              @OZ20010
*    MOVE CHECKPOINTED HCT VARIABLES TO HCT                    @OZ20010
*                                                              @OZ20010
***************************************************************@OZ20010
         SPACE 1                                               @OZ20010
KRDMVHCT L     R0,$CKPR1RD         START OF REC1 READ-IN AREA  @OZ20010
         L     R1,$CKPTR1L         LOAD TOTAL LENGTH OF REC1   @OZ20010
         LA    R14,$SAVEBEG        START OF HCT VARIABLE AREA  @OZ20010
         LA    R15,$SAVELEN        LENGTH OF THAT AREA ONLY    @OZ20010
         MVCL  R14,R0              MOVE CKPT'D HCT VARIABLES   @OZ20010
         L     R14,$QSE1           START OF ACTUAL QSE AREA    @OZ20010
         LR    R15,R1              REMAINING LENGTH            @OZ20010
         MVCL  R14,R0              MOVE REST OF REC1 DATA      @OZ20010
         SPACE 1                                               @OZ20010
         L     R1,$CKPR1RD         LOAD ADDR AND LENGTH FOR    @OZ20010
         L     R0,$CKPTR1L           PAGE RELEASE              @OZ20010
        $PGSRVC FREE,(R1),(R0),RELEASE=Y FREE/RLSE REC1 AREA   @OZ20010
         EJECT                                                 @OZ20010
***************************************************************@OZ20010
*                                                              @OZ20010
*    CHECK FOR SYSTEM ID(S) INTEGRITY IN QSE(S)                @OZ20010
*                                                              @OZ20010
***************************************************************@OZ20010
         SPACE 1                                               @OZ20010
KRDSID   L     WC,$AQSE            SET ADDRESSABILITY          @OZ20010
         USING QSEDSECT,WC           FOR QSE                   @OZ20010
                                   PRINT OFF - SECTION DELETED @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
                                   PRINT ON -- SECTION DELETED @OZ20010
         CLC   $SIDTIME,QSESITIM   VERIFY SYSTEM ID OWNERSHIP  @OZ20010
         BNE   K03                 BRANCH IF NOT OK
         L     R1,$ESYSQSE         GET ADDRESS OF $ESYS QSE
         LTR   R1,R1               IS $ESYS IN PROCESS
         BZ    KRDOK               BRANCH IF NOT
         CLC   $SIDTIME,QSESITIM-QSEDSECT(R1)  VERIFY $ESYS ID TOD
         BE    KRDOK               BRANCH IF OK
K03     $ERROR                     TWO SYSTEMS USING SAME ID
         SPACE 1                                                     R4
KRDOK    ICM   R1,15,$MCONPCE      POINT TO REMOTE CONSOLE PCE       R4
         BZ    KRDNORCP            BR IF NO REMOTE CONSOLE PROCESSOR R4
        $POST  (R1),WORK            ELSE WAKE IT UP                  R4
         SPACE 1                                                     R4
KRDNORCP DS    0H                                                    R4
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*    MAKE SHARED RESOURCES AVAILABLE TO OTHER PROCESSORS              *
*                                                                     *
***********************************************************************
         SPACE 1
*              THIS LINE DELETED BY APAR NUMBER                @OZ32185
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
         NI    $STATUS,255-$QSONDA INDICATE SHARED QUEUES READ @OZ20010
        $POST  $HASPECF,CKPT       $POST PCES $WAITING IN $QSUSE
*                                  THIS LINE DELETED BY APAR   @OZ20010
*                                  THIS LINE DELETED BY APAR   @OZ20010
*                                  THIS LINE DELETED BY APAR   @OZ20010
*                                  THIS LINE DELETED BY APAR   @OZ20010
         EJECT
***********************************************************************
*                                                                     *
*    PROPAGATE JOB, JOT, AND SPECIFIC $POSTS FROM OTHER SYSTEMS       *
*                                                                     *
***********************************************************************
         SPACE 1
KRCPNP   TM    QSEFLAGS,QSEPOST    TEST FOR CROSS-SYSTEM $POSTS     R41
         BZ    KRDEND              BRANCH IF NONE
         TM    QSEFLAGS,QSEPJOB    TEST FOR CROSS-SYSTEM $POST JOB
         BZ    KRDPOCNV            BRANCH IF NOT
        $POST  $HASPECF,JOB        $POST JOB
         B     KRDPOJOT            SKIP SPECIFIC JOB POSTING
         SPACE 1                                                    R41
KRDPOCNV TM    QSEFLAGS,QSEPCNV    TEST FOR XSYS $POST CONVERTER
         BZ    KRDPOXEQ            BRANCH IF NOT
         L     R1,$JCLPCE          GET ADDRESS OF CONVERTER PCE      R4
        $POST  (R1),JOB             AND $POST FOR JOB
         SPACE 1                                                    R41
KRDPOXEQ TM    QSEFLAGS,QSEPXEQ    TEST FOR XSYS $POST EXECUTION
         BZ    KRDPOOUT            BRANCH IF NOT
         L     R1,$SSVT            POINT TO SSVT               @OZ20010
         MVI   $SVJOB-SSVT(R1),X'80' $$POST XEQ PROCESSOR      @OZ20010
         L     R1,$EXECPCE         GET ADDRESS OF EXECUTION PCE      R4
        $POST  (R1),JOB             AND $POST FOR JOB
         SPACE 1                                                    R41
KRDPOOUT TM    QSEFLAGS,QSEPOUT    TEST FOR XSYS $POST OUTPUT
         BZ    KRDPOPRG            BRANCH IF NOT
         L     R1,$OUTPCE          GET ADDRESS OF OUTPUT PCE         R4
        $POST  (R1),JOB             AND $POST FOR JOB
         EJECT                                                       R4
KRDPOPRG TM    QSEFLAGS,QSEPPRG    TEST FOR XSYS $POST PURGE
         BZ    KRDPOJOT            BRANCH IF NOT
         L     R1,$PRGPCE          GET ADDRESS OF PURGE PCE          R4
        $POST  (R1),JOB             AND $POST FOR JOB
         SPACE 1                                                    R41
KRDPOJOT TM    QSEFLAGS,QSEPJOT    TEST FOR CROSS-SYSTEM $POST JOT
         BZ    KRDPOMLM            BRANCH IF NOT
        $POST  $HASPECF,JOT        $POST JOT
         CLI   $WTRWTCT,0          TEST FOR WAITING XWTRS
         BE    KRDEND              BRANCH IF NOT
         L     R15,=V($#WTR)       GO POST
         BALR  R14,R15              WAITING XWTRS
         B     KRDEND              SKIP SPECIFIC JOT POSTING
         SPACE 1                                                    R41
KRDPOMLM TM    QSEFLAGS,QSEPMLM    TEST FOR XSYS $POST MHASPECF,JOT
         BZ    KRDEND              BRANCH IF NOT
         NI    MHASPECF+$EWBJOT,255-$EWFJOT  TELL LINE MANAGER
         DROP  WC                  DROP QSE ADDRESSABILITY     @OZ20010
         EJECT                                                      R41
***********************************************************************
*                                                                     *
*    START HOLD INTERVAL TIMER (IF ANY)                               *
*                                                                     *
***********************************************************************
         SPACE 1
KRDEND   L     WA,$WARMPCE         GET WARM START PROCESSOR PCE     R41
         CLC   17(3,WA),=AL3(NQWARM)  WARM START IN PROGRESS...     R41
         BE    KRDHOLD             BR IF NO                    @OZ24298
         L     R0,=F'-500'         GET 5 SECOND INTERVAL            R41
         C     R0,$MINHOLD         TEST USER INTERVAL               R41
         BL    KRDTIM              BR IF LESS THAN 5 SECONDS        R41
         SPACE 1                                                    R41
KRDHOLD  L     R0,$MINHOLD         GET MINIMUM HOLD INTERVAL        R41
         SPACE 1                                                    R41
KRDTIM   BAL   WA,KSTIMER          SET MINIMUM HOLD INTERVAL        R41
                                   PRINT OFF - SECTION DELETED @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
                                   PRINT ON -- SECTION DELETED @OZ20010
         SPACE 1                                                     R4
KRDTIMER TM    CKPSTQE+IPOST,X'80' IS TIMER GOING...                R41
         BO    KWRLOOP                BR IF NO TO $POST        @OZ32185
         LM    R0,R1,$EWQTRAK          IF ANY                  @OZ32185
         CL    R1,PCEPCEB-PCEDSECT(,R1) PROCESSORS OR          @OZ32185
         BNE   KWRLOOP                   ADDR SPACES           @OZ32185
         L     R1,$SSVT                   WAITING FOR TRKS     @OZ32185
         TM    $SVTGECB-SSVT(R1),X'80'     POST OURSELVES      @OZ32185
         BZ    KWRREQS                      TO FORCE KBLOB     @OZ32185
         EJECT
***********************************************************************
*                                                                     *
*        $WAIT FOR CHECKPOINT REQUEST, ENSURING THAT ALL OTHER        *
*        PROCESSORS ARE $WAITING WHEN CHECKPOINTING BEGINS            *
*                                                                     *
***********************************************************************
         SPACE 1
KWRLOOP $POST  $HASPECF,CKPW       POST OURSELVES TO INSURE REENTRY
         SPACE 1                                                     R4
KWRREQS $WAIT  CKPW,INHIBIT=NO     WAIT FOR WRITE REQUEST OR TIMER
         LM    R0,R1,PCEPCEA       TEST CONTENTS OF
         CLR   R0,R1                DISPATCHER'S READY QUEUE
         BNE   KWRLOOP             BRANCH IF OTHER PCES ARE READY
         OI    $STATUS,$CKPTACT    INDICATE CHECKPOINT WRITE ACTIVE
         OI    $HASPECF+$EWBCKPT,$EWFCKPT  BACK OUT RESOURCE POST    R4
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*    PAGE-FIX RECORD 1 I/O AREA -- SET CCWS TO WRITE RECORD 1  @OZ20010
*                                                                     *
***********************************************************************
         SPACE 1
KWRCCWS  LA    WB,JQBCCWS          POINT TO CCW ENTRY FOR      @OZ20010
         USING JQBCCWE,WB            RECORD ONE                @OZ20010
         L     R1,$CKPTR1          POINT TO START OF I/O AREA  @OZ20010
         BAL   WC,KR1FIX           PAGE FIX REC1 I/O AREA      @OZ20010
         MVI   JQBCRW,X'05'        SET CCW TO 'WRITE'          @OZ20010
         SPACE 1                                               @OZ20010
***************************************************************@OZ20010
*                                                              @OZ20010
*    SET UP CCWS TO WRITE CHANGED JOBQ/JOT RECORDS             @OZ20010
*                                                              @OZ20010
***************************************************************@OZ20010
         SPACE 1                                               @OZ20010
         LA    WD,JQBCNEXT         POINT TO 1ST JOBQ RECORD'S  @OZ20010
         DROP  WB                    CCW ENTRY.  CHANGE BASE   @OZ20010
         USING JQBCCWE,WD            REG FOR CCW ENTRIES       @OZ20010
         L     WC,$JOBCTLB         POINT TO CKPT CTL BYTES     @OZ20010
         LH    WF,$JOBRECN         LOAD TOTAL NUMBER OF        @OZ20010
         AH    WF,$JOTRECN           PAGES IN CKPT FILE        @OZ20010
         L     WG,$JOBQPTR         POINT TO ACTUAL Q-AREA      @OZ20010
         L     R10,$JBQREAD        POINT TO INPUT AREA         @OZ20010
         SPACE 1                                               @OZ20010
KWRLOOP1 CLI   0(WC),0             IF PAGE IS FLAGGED FOR      @OZ20010
         BNE   KWRFIX1               CKPT, BR TO FIX FOR WRITE @OZ20010
         TM    $RUNOPTS,$DEBUG     IF 'DEBUG' NOT SELECTED,    @OZ20010
         BZ    KWRL1ADJ              TRY NEXT PAGE             @OZ20010
         LR    R0,WG               USE CLCL TO                 @OZ20010
         L     R1,=F'4096'           COMPARE 'UNCHANGED'       @OZ20010
         LR    R14,R10               PAGE WITH LAST            @OZ20010
         LR    R15,R1                INPUT PAGE FROM CKPT      @OZ20010
         CLCL  R14,R0                FILE                      @OZ20010
         BE    KWRL1ADJ            BRANCH IF REALLY UNCHANGED  @OZ20010
         LR    R1,R0               PRESERVE REG0 FOR DEBUGGING @OZ20010
         SPACE 1                                               @OZ20010
K05     $ERROR                     SOMEONE FORGOT TO CKPT      @OZ20010
         SPACE 1                                               @OZ20010
KWRFIX1  LR    R1,WG               LOAD ADDR OF PAGE           @OZ20010
         L     R0,=F'4096'         LOAD LENGTH                 @OZ20010
         LA    R2,CKPECB           POINT TO DUMMY ECB          @OZ20010
        $PGSRVC FIX,(R1),(R0),(R2) FIX PAGE FOR I/O            @OZ20010
         LRA   R1,0(,R1)           SET REAL ADDRESS OF PAGE    @OZ20010
         ST    R1,JQBCRW             IN READ/WRITE CCW         @OZ20010
         MVI   JQBCRW,X'05'        SET CCW TO 'WRITE'          @OZ20010
         BAL   WA,KCCWADJ          SET CCW ENTRY CHAIN         @OZ20010
         LR    WB,WD               SET 'PREV' TO 'CURRENT'     @OZ20010
         SPACE 1                                               @OZ20010
         TM    $RUNOPTS,$DEBUG     IF 'DEBUG' NOT SELECTED,    @OZ20010
         BZ    KWRL1ADJ              BR TO TRY NEXT PAGE       @OZ20010
         LR    R0,WG               MOVE COPY OF CHANGED        @OZ20010
         L     R1,=F'4096'           PAGE TO 'INPUT AREA'      @OZ20010
         LR    R14,R10               FOR LATER                 @OZ20010
         LR    R15,R1                DEBUG                     @OZ20010
         MVCL  R14,R0                COMPARISONS               @OZ20010
         SPACE 1                                               @OZ20010
KWRL1ADJ AL    WG,=F'4096'         NEXT Q-AREA PAGE            @OZ20010
         AL    R10,=F'4096'        NEXT IN-AREA PAGE           @OZ20010
         LA    WD,JQBCNEXT         NEXT CCW ENTRY              @OZ20010
         LA    WC,1(,WC)           NEXT CKPT CONTROL BYTE      @OZ20010
         BCT   WF,KWRLOOP1         LOOP THRU JOBQ AND JOT      @OZ20010
         DROP  WD                  DROP CCW ENTRY ADDR         @OZ20010
         MVC   JQBCTNXT-JQBCCWE(,WB),KRNOP LAST TIC = 'NO OP'  @OZ20010
                                   PRINT OFF - SECTION DELETED @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
                                   PRINT ON -- SECTION DELETED @OZ20010
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*    COLLECT RECORD ONE AND $POSTS FOR OTHER SYSTEMS                  *
*                                                                     *
***********************************************************************
         SPACE 1                                                     R4
*                                  THIS CARD DELETED BY APAR   @OZ20010
         LH    R15,$JOBRECN        COMPUTE LENGTH              @OZ20010
         AH    R15,$JOTRECN          OF BYTE STRING            @OZ20010
         BCTR  R15,0                 LESS ONE FOR EXECUTE      @OZ20010
         L     WD,$JOBCTLB         POINT TO JOB/JOT CTL BYTES  @OZ20010
         L     R1,$QSE1            GET ADDRESS OF 1ST QSE            R4
         SH    R1,$QSEL            BACK UP ONE QSE                  R41
         USING QSEDSECT,R1         QSE ADDRESSABILITY          @OZ20010
         SPACE 1                                                    R41
KWRXSYSP AH    R1,$QSEL            GET ADDRESS OF NEXT QSE           R4
         OC    QSEFLAGS,$AQSE      PROPAGATE XSYS $POSTS       @OZ20010
         LR    R14,R1              POINT TO CKPT CONTROL       @OZ20010
         AH    R14,$QSECTLB          BYTES IN QSE              @OZ20010
         EX    R15,KWRXOC          SET CKPT CTL BYTES IN QSE   @OZ20010
         TM    QSEFLAGS,QSELAST    TEST FOR LAST QSE           @OZ20010
         BZ    KWRXSYSP            LOOP IF NOT
         MVI   $AQSE,0             CLEAR CROSS-SYSTEM $POSTS IN HCT
         SPACE 1                                                    R41
         L     R1,$AQSE            POINT TO OUR QSE            @OZ20010
         NI    QSEFLAGS,255-QSEPOST CLEAR X-S $POST BITS       @OZ20010
         LR    R14,R1              POINT TO CKPT CONTROL       @OZ20010
         AH    R14,$QSECTLB          BYTES IN QSE              @OZ20010
         EX    R15,KWRXXC          CLEAR OUR CKPT CTL BYTES    @OZ20010
         B     KREFILL             GO REFILL TGB               @OZ20010
         SPACE 1                                               @OZ20010
KWRXOC   OC    0(*-*,R14),0(WD)    *** EXECUTE ONLY ***        @OZ20010
KWRXXC   XC    0(*-*,R14),0(R14)   *** EXECUTE ONLY ***        @OZ20010
         DROP  R1                  DROP QSE ADDRESSABILITY     @OZ20010
         SPACE 2
***********************************************************************
*                                                                     *
*    REFILL TRACK GROUP BLOCK                                         *
*                                                                     *
***********************************************************************
         SPACE 1
KREFILL  BAL   R14,KBLOB           GO UNBLOB/BLOB              @OZ20010
         EJECT                                                 @OZ20010
***********************************************************************
*                                                                     *
*    TIME STAMP HCT AND OWNED QSE(S)                                  *
*                                                                     *
***********************************************************************
         SPACE 1
         L     R1,$AQSE            POINT TO OUR QSE,           @OZ20010
         USING QSEDSECT,R1           SET UP ADDRESSABILITY     @OZ20010
         STCK  $SIDTIME            STORE TOD IN HCT
         MVC   QSESITIM,$SIDTIME    AND IN QSE AS CHKPT WRITE TIME
         L     R1,$ESYSQSE         GET ADDRESS OF $ESYS QSE
         LTR   R1,R1               IS $ESYS IN PROCESS
         BZ    *+10                SKIP IF NOT
         MVC   QSESITIM,$SIDTIME   MOVE TOD TO $ESYS QSE       @OZ20010
         DROP  R1                  DROP QSE ADDRESSABILITY     @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
         SPACE 1                                               @OZ20010
***********************************************************************
*                                                                     *
*    MOVE HCT VARIABLES FOR WRITE                              @OZ20010
*                                                                     *
***********************************************************************
         SPACE 1
         L     R0,$CKPTR1          POINT TO R1 I/O AREA        @OZ20010
         LA    R1,$SAVELEN         LENGTH OF HCT VARIABLES     @OZ20010
         LA    R14,$SAVEBEG        POINT TO HCT VARIABLES      @OZ20010
         LR    R15,R1              DUPLICATE LENGTH FOR MOVE   @OZ20010
         MVCL  R0,R14              MOVE HCT VARIABLES          @OZ20010
                                   PRINT OFF - SECTION DELETED @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
                                   PRINT ON -- SECTION DELETED @OZ20010
         EJECT                                                 @OZ20010
                                   PRINT OFF - SECTION DELETED @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
                                   PRINT ON -- SECTION DELETED @OZ20010
***********************************************************************
*                                                                     *
*    DO WRITE, CHECK FOR PERMANENT WRITE ERROR                        *
*                                                                     *
***********************************************************************
         SPACE 1
         LA    R1,JQBCCWS          POINT IOBSTART TO BEGINNING @OZ20010
         ST    R1,IOBSTART-BUFDSECT+JQBDSECT OF CCW CHAIN      @OZ20010
         LA    R1,PCEDADCT         START I/O TO WRITE RECORD   @OZ20010
        $EXCP (R1),TYPE=VR         1 AND CHANGED RECORDS       @OZ32185
        $POST  $HASPECF,TRAK       SHOW TRACKS AVAILABLE       @OZ32185
         L     WF,$SSVT            GET SSVT POINTER            @OZ32185
         USING SSVT,WF             SSVT ADDRESSABILITY         @OZ32185
         L     R0,$SVTGECB         R0 = OTHER MEMORY ECB       @OZ32185
         SPACE 1                                               @OZ32185
KPOSTL   LTR   R0,R0               IF WAITING                  @OZ32185
         BM    KXMTRAK              DO LONG FORM POST          @OZ32185
         L     R1,=A(X'7F000000')  R1 = POST CODE              @OZ32185
         CS    R0,R1,$SVTGECB      SHORT FORM POST ECB         @OZ32185
         BE    KWRWAIT             BRANCH IF POSTED            @OZ32185
         B     KPOSTL               ELSE, TRY AGAIN            @OZ32185
         SPACE 1                                               @OZ32185
KXMTRAK  TM    $SVTGECB,X'20'      XM POST SCHEDULED YET...    @OZ32185
         BO    KWRWAIT             BR IF YES                   @OZ32185
         OI    $SVTGECB,X'20'      INDICATE XM POST SCHEDULED  @OZ32185
         STM   R2,R12,PCEWA        SAVE R2 -  R12 IN PCE       @OZ32185
         ST    R14,PCELINK         SAVE R14 IN PCE             @OZ32185
         LR    R9,R13              SAVE R13 IN R9              @OZ32185
         LA    R11,$SVTGECB        R11 = ADDRESS OF ECB        @OZ32185
         ICM   R11,8,=X'80'        SET HI BIT FOR XM POST      @OZ32185
         L     R15,CVTPTR          R15 = CVT ADDRESS           @OZ32185
         LA    R1,CVTBRET-CVT(,R15) R1 = ERROR RETURN ADDRESS  @OZ32185
         L     R15,CVT0PT01-CVT(,R15) R15 = XM POST BR ENTRY   @OZ32185
         L     R13,$SVTGASC        R13 = ASCB ADDRESS          @OZ32185
         L     R10,=A(X'40000000') R10 = POST CODE             @OZ32185
         LR    R12,R1              R12 = ERROR RETURN ADDRESS  @OZ32185
         MODESET EXTKEY=ZERO       SET PROTECT KEY FOR XMPOST  @OZ32185
         BALR  R14,R15             ENTER XM POST               @OZ32185
         MODESET EXTKEY=HASP       RESTORE HASP KEY            @OZ32185
         LR    R13,R9              RESTORE R13                 @OZ32185
         L     R14,PCELINK         RESTORE R14                 @OZ32185
         LM    R2,R12,PCEWA        RESTORE R2 -  R12           @OZ32185
         DROP  WF                  DROP SSVT ADDRESSABILITY    @OZ32185
         SPACE 1                                               @OZ32185
KWRWAIT $WAIT  IO                  WAIT FOR WRITE TO COMPLETE  @OZ32185
         TM    BUFECBCC-BUFDSECT+JQBDSECT,X'7F' I/O COMPLETE   @OZ32185
         BZ    KWRWAIT             BR IF NO, WAIT              @OZ32185
         BO    KWROK               BR IF WRITE IS OK           @OZ32185
        $IOERROR (WE)              ISSUE I/O ERROR             @OZ32185
K04     $ERROR                     PERMANENT ERROR CKPT WRITE  @OZ20010
         EJECT                                                 @OZ32185
         SPACE 1                                               @OZ20010
KWROK    NI    $STATUS,255-$CKPTACT  INDICATE CKPT WRITE DONE  @OZ20010
         SPACE 1                                               @OZ20010
***************************************************************@OZ20010
*                                                              @OZ20010
*    PAGE-FREE JOBQ/JOT PAGES FIXED FOR I/O OPERATION          @OZ20010
*                                                              @OZ20010
***************************************************************@OZ20010
         SPACE 1                                               @OZ20010
         L     R1,$JOBQPTR         POINT TO START OF JOBQ/JOT  @OZ20010
         L     WC,$JOBCTLB         POINT TO CKPT CTL BYTES     @OZ20010
         LH    WF,$JOBRECN         LOAD TOTAL NUMBER OF        @OZ20010
         AH    WF,$JOTRECN           JOBQ/JOT RECORDS          @OZ20010
         SPACE 1                                               @OZ20010
KWRLOOP2 CLI   0(WC),0             SEE IF PAGE WAS FIXED       @OZ20010
         BE    KWRL2ADJ              BYPASS IF SO              @OZ20010
         MVI   0(WC),0             ZERO OUT CONTROL BYTE       @OZ20010
         L     R0,=F'4096'         LOAD LENGTH FOR FREE        @OZ20010
        $PGSRVC FREE,(R1),(R0)     PAGE-FREE FIXED PAGE        @OZ20010
         SPACE 1                                               @OZ20010
KWRL2ADJ AL    R1,=F'4096'         POINT TO NEXT PAGE          @OZ20010
         LA    WC,1(,WC)           POINT TO NEXT CTL BYTE      @OZ20010
         BCT   WF,KWRLOOP2         LOOP THRU JOBQ AND JOT      @OZ20010
         SPACE 1                                               @OZ20010
         L     R1,$CKPTR1          POINT TO REC1 I/O AREA      @OZ20010
         L     R0,$CKPTR1L         LOAD RECORD 1 LENGTH        @OZ20010
        $PGSRVC FREE,(R1),(R0)     PAGE-FREE REC1 I/O AREA     @OZ20010
         SPACE 1                                               @OZ20010
                                   PRINT OFF - SECTION DELETED @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
                                   PRINT ON -- SECTION DELETED @OZ20010
         L     R1,$QSE1            GET ADDRESS OF 1ST QSE            R4
         TM    QSEFLAGS-QSEDSECT(R1),QSELAST  TEST FOR ONE SYSTEM    R4
         BO    KWR1SYS             BRANCH IF ONLY ONE SYSTEM
         L     R1,$SSVT            IS INITIALIZATION           @OZ20010
         TM    $SVSTUS-SSVT(R1),$SVSTIRV  RESERVE IN EFFECT... @OZ20010
         BO    KWRPOST             BRANCH IF YES
         TM    CKPSTQE+IPOST,X'80' HAS TIMER EXPIRED...             R41
         BZ    KWRPOST             BRANCH IF NOT
         B     KRELEASE            GO RELEASE
         EJECT
***********************************************************************
*                                                                     *
*    RESET PRINT/PUNCH TIMER FOR SINGLE SYSTEM                        *
*                                                                     *
***********************************************************************
         SPACE 1
KWR1SYS  BAL   WA,KTTIMER          STOP TIMER
         L     R0,$CKPTIME         START TIMER FOR                   R4
         BAL   WA,KSTIMER           PRINT/PUNCH CHECKPOINT INTERVAL
         SPACE 2
***********************************************************************
*                                                                     *
*    $POST CHECKPOINT COMPLETE AND LOOP IF SINGLE SYSTEM,             *
*     IF INITIALIZATION RESERVE IS IN EFFECT,                         *
*     OR IF HOLD INTERVAL HAS NOT EXPIRED                             *
*                                                                     *
***********************************************************************
         SPACE 1
KWRPOST $POST  $HASPECF,CKPT       POST PCES FOR CHKPT COMPLETION
         L     R1,$MCONPCE         POINT TO REMOTE CONSOLE PCE       R4
         LTR   R1,R1               TEST FOR REMOTE CONSOLE PROCESSOR R4
         BZ    KWRNORCP            BR IF NO                          R4
        $POST  (R1),WORK           POST IT                          R41
         SPACE 1                                                     R4
KWRNORCP LM    R0,R1,$EWQTRAK          LOOK AT TRAK                  R4
         CL    R1,PCEPCEB-PCEDSECT(,R1) RESOURCE POINTERS            R4
         BNE   KWRLOOP             BRANCH IF ANY PCE'S WAITING
         L     R1,$SSVT            POINT TO SSVT               @OZ20010
         TM    $SVTGECB-SSVT(R1),X'80' TEST SSVT ECB           @OZ20010
         BO    KWRLOOP             BR IF OTHER MEMORY WAITING
         B     KWRREQS             GO WAIT FOR WRITE REQS OR TIMER
         EJECT
***********************************************************************
*                                                                     *
*    RELEASE CHECKPOINT DEVICE IF SHARED SYSTEM                       *
*     AND HOLD INTERVAL HAS EXPIRED                                   *
*                                                                     *
***********************************************************************
         SPACE 1
KRELEASE DS    0H                  REMOVE HASP CHECKPOINT RESERVE
        $GETLOK                    ACQUIRE LOCAL AND CMS LOCKS
         MODESET EXTKEY=ZERO       CHANGE TO KEY ZERO
         L     R14,$SSVT           GET ADDRESSABILITY          @OZ20010
         USING SSVT,R14              ON SSVT                   @OZ20010
         L     R15,$SVRELSE          AND ON CHECKPOINT         @OZ20010
         L     R15,IOSUCB-IOSB+SRBSIZE(,R15)  DEVICE           @OZ20010
         USING UCBDSECT,R15          UCB                       @OZ20010
         SLR   R1,R1               DECREMENT
         IC    R1,UCBSQC            CHECKPOINT DEVICE
         BCTR  R1,0                  RESERVE
         STC   R1,UCBSQC              COUNT
         NI    $SVSTUS,255-$SVSTCRV  INDICATE CHECKPOINT RELEASED
         LTR   R1,R1               NON-HASP RESERVES STILL PRESENT
         BNZ   KDORMANT            BRANCH IF YES
         STM   LINK,BASE2,PCELINK  SAVE REGISTERS
         L     R1,$SVRELSE         GET ADDR OF RELEASE SRB-IOSB
         STARTIO SRB=(1)           RELEASE CHECKPOINT DEVICE
         LM    LINK,BASE2,PCELINK  RELOAD REGISTERS
         DROP  R14,R15             DROP SSVT, UCB ADDR.        @OZ20010
         SPACE 1                                                    R41
KDORMANT DS    0H                  ENTER DORMANT STATE
        $FRELOK                    RELEASE LOCAL AND CMS LOCKS
         OI    $STATUS,$QSONDA     INDICATE SHARED QUEUES ON DASD
         SPACE 2
***********************************************************************
*                                                                     *
*    $WAIT FOR MINIMUM DORMANT INTERVAL (IF ANY)                      *
*                                                                     *
***********************************************************************
         SPACE 1
         L     R0,$MINDORM         START TIMER FOR                   R4
         BAL   WA,KSTIMER           MINIMUM DORMANT INTERVAL
         TM    CKPSTQE+IPOST,X'80' IS TIMER GOING...                R41
         BO    KQSUSE              IF NOT, GO LOOK FOR NEW $QSUSES
        $WAIT  WORK                WAIT FOR MINIMUM DORMANT INTERVAL
         EJECT
***********************************************************************
*                                                                     *
*    LOOK FOR AND $WAIT FOR NEW SHARED QUEUE REQUESTS,                *
*     OR UNTIL MAXIMUM DORMANT INTERVAL EXPIRES,                      *
*     THEN GO READ SHARED QUEUES                                      *
*                                                                     *
***********************************************************************
         SPACE 1
KQSUSE   DS    0H                  LOOK FOR NEW SHARED QUEUE REQS
         LM    R0,R1,$EWQCKPT      LOOK AT CKPT
         CL    R1,PCEPCEB-PCEDSECT(,R1) RESOURCE POINTERS            R4
         BNE   KREAD               BRANCH IF ANY PCES WAITING
         TM    MHASPECF+$EWBCKPT,$EWFCKPT  LINE MGR REQUEST..  @OZ25901
         BO    KREAD               BR IF YES                   @OZ25901
         LM    R0,R1,$EWQTRAK      LOOK AT TRAK
         CL    R1,PCEPCEB-PCEDSECT(,R1) RESOURCE POINTERS            R4
         BNE   KREAD               BRANCH IF ANY PCES WAITING
         L     R1,$SSVT            TEST SSVT TRACK             @OZ20010
         TM    $SVTGECB-SSVT(R1),X'80'  ALLOC ECB              @OZ20010
         BO    KREAD               BRANCH IF OTHER TASKS ARE WAITING
         TM    $MCONPCE,$MCONWAT   IS REMOTE CONSOLE WAITING FOR CKPT
         BO    KREAD               BRANCH IF YES                     R4
         L     R0,$MAXDORM         START TIMER FOR                   R4
         S     R0,$MINDORM          THE CALCULATED             @OZ28663
         BAL   WA,KSTIMER           MAXIMUM DORMANT INTERVAL
         TM    CKPSTQE+IPOST,X'80' IS TIMER GOING...           @OZ28663
         BO    KREAD               IF YES, READ SHARED QUEUES  @OZ28663
        $WAIT  CKPW,INHIBIT=NO     WAIT FOR $QSUSE OR TIMER
         BAL   WA,KTTIMER          STOP TIMER
         B     KREAD               GO READ SHARED QUEUES FROM DASD
         EJECT
***************************************************************@OZ20010
*                                                              @OZ20010
*    CCW CHAIN ADJUSTMENT SUBROUTINE (SELECTIVE READ/WRITE)    @OZ20010
*                                                              @OZ20010
*        ON ENTRY -- WB POINTS TO PREVIOUS CCW ENTRY,          @OZ20010
*                    WD POINTS TO CURRENT  CCW ENTRY           @OZ20010
*                                                              @OZ20010
*        ON EXIT  -- PREVIOUS CCW ENTRY IS CORRECTLY           @OZ20010
*                    CHAINED TO CURRENT CCW ENTRY              @OZ20010
*                                                              @OZ20010
***************************************************************@OZ20010
         SPACE 1                                               @OZ20010
         USING JQBCCWE,WD          SET UP ADDRESSABILITY ON    @OZ20010C
                                     'PREVIOUS' CCW ENTRY      @OZ20010
         SPACE 1                                               @OZ20010
KCCWADJ  LA    R15,JQBCSEEK        POINT TO NEW 'SEEK'         @OZ20010
         CLC   JQBCTRK,JQBCTRK-JQBCCWE(WB) IF RECORDS ARE ON   @OZ20010
         BNE   KCCW1                 DIFFERENT TRACKS, BRANCH  @OZ20010
         LA    R15,JQBCSID         POINT TO NEW 'SEARCH ID'    @OZ20010
         LA    R0,L'JQBCCWEL(,WB)  SEE IF CCW ENTRIES ARE      @OZ20010
         CR    R0,WD                 ADJACENT IN LIST          @OZ20010
         BE    KCCW1               BRANCH IF ADJACENT          @OZ20010
         TM    CKPFLAG1,CKP1RPS    IF RPS FEATURE SHOULD NOT   @OZ20010
         BZ    KCCW1                 BE USED, BRANCH           @OZ20010
         LA    R15,JQBCSET         POINT TO NEW 'SET SEC'      @OZ20010
         DROP  WD                  DROP 'CURRENT' CCW ADDR     @OZ20010
         SPACE 1                                               @OZ20010
         USING JQBCCWE,WB          PICK UP 'PREV' CCW ADDR     @OZ20010
KCCW1    LRA   R0,0(,R15)          SET REAL ADDRESS            @OZ20010
         ST    R0,JQBCTNXT           IN PREVIOUS TIC           @OZ20010
         MVI   JQBCTNXT,X'08'      SET OP-CODE TO 'TIC'        @OZ20010
         ST    R15,JQBCTNXT+4      VIRTUAL ADDR FOR DEBUGGING  @OZ20010
         BR    WA                  RETURN                      @OZ20010
         DROP  WB                                              @OZ20010
         EJECT                                                 @OZ20010
***************************************************************@OZ20010
*                                                              @OZ20010
*    SUBROUTINE TO PAGE-FIX REC1 I/O AREA AND BUILD IDAW'S     @OZ20010
*                                                              @OZ20010
*        ON INPUT, R1 POINTS TO AREA TO FIX                    @OZ20010
*                  WB POINTS TO FIRST CCW ENTRY                @OZ20010
*                  WC CONTAINS RETURN ADDRESS                  @OZ20010
*                                                              @OZ20010
***************************************************************@OZ20010
         USING JQBCCWE,WB          CCW ENTRY ADDRESSABILITY    @OZ20010
         SPACE 1                                               @OZ20010
KR1FIX   L     R0,$CKPTR1L         LOAD LENGTH FOR PAGE-FIX    @OZ20010
         LA    R2,CKPECB           POINT TO DUMMY ECB          @OZ20010
        $PGSRVC FIX,(R1),(R0),(R2) PAGE-FIX RECORD 1 AREA      @OZ20010
         L     WA,$CKPTR1L         LOAD LENGTH AGAIN           @OZ20010
         LA    R15,JQBIDAWS        POINT TO IDAWS FOR REC 1    @OZ20010
         LA    R0,2048             LOAD LENGTH FOR IDAW LOOP   @OZ20010
         SPACE 1                                               @OZ20010
KR1IDAW  OI    0(R1),*-*           FORCE PAGE IN IF NOT IN YET @OZ20010
         LRA   R14,0(,R1)          SET REAL ADDRESS OF         @OZ20010
         ST    R14,0(,R15)           AREA IN IDAW              @OZ20010
         ALR   R1,R0               BUMP VIRTUAL ADDR BY 2K     @OZ20010
         LA    R15,4(,R15)         POINT TO NEXT IDAW          @OZ20010
         SR    WA,R0               SEE IF MORE IDAWS           @OZ20010
         BP    KR1IDAW             LOOP IF SO, ELSE            @OZ20010
         BR    WC                    RETURN                    @OZ20010
         SPACE 1                                               @OZ20010
         DROP  WB                  DROP CCW ENTRY ADDR.        @OZ20010
         EJECT                                                 @OZ20010
***************************************************************@OZ20010
*                                                              @OZ20010
*    TIMER SUBROUTINES                                         @OZ20010
*                                                              @OZ20010
***************************************************************@OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
*                                  THIS CARD DELETED BY APAR   @OZ20010
         SPACE 1
KSTIMER  OI    CKPSTQE+IPOST,X'80' INDICATE TIMER EXPIRED           R41
         LTR   R0,R0               TEST NEW INTERVAL TO BE SET
         BNMR  WA                  RETURN IF NOT MINUS         @OZ28663
         ST    R0,CKPSTQE+ITIME    STORE NEW INTERVAL IN STQE       R41
        $STIMER CKPSTQE            START TIMER                      R41
         BR    WA                  RETURN
         SPACE 1                                                    R41
KTTIMER  TM    CKPSTQE+IPOST,X'80' HAS TIMER EXPIRED...             R41
         BOR   WA                  RETURN IF YES
        $TTIMER CKPSTQE,CANCEL     STOP TIME                        R41
         BR    WA                  RETURN
         TITLE 'HASP TRACK GROUP BLOCK ALLOCATION'
***********************************************************************
*                                                                     *
* KBLOB -- SUBROUTINE TO UNALLOCATE/ALLOCATE THE TRACK GROUP BLOCK    *
*                                                                     *
* PURPOSE - TO RETURN TRACK GROUPS TO THE MASTER TRACK GROUP MAP      *
*  ($TGMAP) FROM THE TRACK GROUP BLOCK AND THEN TO REALLOCATE THE     *
*  TRACK GROUP BLK FROM THE MASTER MAP USING AN EXTREME ALLOCATION    *
*  ALGORITHM. THE ALGORITHM ALLOCATES THE TRACK GROUP BLOCK BY        *
*  SELECTING BITS (TRACK GROUPS) FROM THE 'EXTREME' EXTENTS (RIMS)    *
*  OF DEVICES AS REPRESENTED BY TEDS (SEE TEDDSECT) AND $TGMAP.       *
*                                                                     *
* OPERATION -                                                         *
*                                                                     *
*  (1)  TRACK GROUP BLOCK ENTRIES ARE REMOVED USING CDS LOGIC TO      *
*       ELIMINATE POSSIBLE SIMULTANEOUS REFERENCE BY SSSM $STRAK      *
*       SUBROUTINE. THE ENTRIES REMOVED ARE TALLYED AND THE BIT       *
*       DEFINED BY THE ENTRY IS RETURNED TO $TGMAP. THE NUMBER OF     *
*       RETURNED TRACK GROUPS IS USED TO DETERMINE HOW MANY TO        *
*       REALLOCATE FOR THIS ITERATION OF THE CHECKPOINT PROCESSOR.    *
*       IF NO TRACK GROUPS ARE RETURNED (ALL USED) THE NUMBER LAST    *
*       ALLOCATED IS INCREASED BY 1. IF TRACK GROUPS ARE RETURNED,    *
*       THE NUMBER LAST ALLOCATED IS DECREASED BY 1. THE LOWEST       *
*       EVER ALLOCATED IS 1 AND THE HIGHEST &NUMTGBE.                 *
*  (2)  THE NUMBER OF TRACK GROUPS ALLOCATED IS CALCULATED BY         *
*       'COUNTING' THE NUMBER OF BITS ON IN $TGMAP AND SUBTRACTING    *
*       THIS VALUE FROM THE TOTAL TRACK GROUPS AVAILABLE. IF THE      *
*       RESULT IS 0, THE 100% SPOOL UTILIZATION MESSAGE IS ISSUED.    *
*       IF THE NUMBER OF TRACK GROUPS AVAILABLE IS LESS THAN THE      *
*       NUMBER NEEDED TO FILL THE TRACK GROUP BLOCK, THE NUMBER       *
*       NEEDED IS SET TO THE NUMBER AVAILABLE.                        *
*  (3)  ALL VALID TED BLKS ARE INITIALIZED TO CAUSE THE SEARCH FOR    *
*       UNALLOCATED TRK GROUPS AT THE MODULE EXTENT START. THE TED    *
*       FIELD 'TNCH' IS USED FOR THIS PURPOSE. THE NEXT TED TO BE     *
*       USED FOR ALLOCATION IS SELECTED FROM THE $SVTNEXT FIELD IN    *
*       THE SVT. $SVTNEXT IS SET TO THE NEXT TED TO BE USED UPON      *
*       COMPLETION OF TRACK GROUP BLK ALLOCATION. MODULE SELECTION    *
*       IS 'ROUND-ROBIN'.                                             *
*  (4)  THE NUMBER OF TRACK GROUPS DETERMINED BY THE 'LAST USED'      *
*       PROCESS DESCRIBED ARE ALLOCATED USING EXTREME ALGORITHM.      *
*       THE EXTENT REPRESENTED BY A TED AND THE MASTER MAP IS         *
*       SEARCHED FOR AN AVAILABLE TRACK GRP STARTING AT HE 'TNCH'     *
*       DEFINED POSITION. 'TNCH' IS RESET FOR THE NEXT ITERATION      *
*       OF THE TRACK GROUP BLOCK ALLOCATION LOOP TO THE ADDRESS IN    *
*       THE EXTENT WHERE AN AVAILABLE TRACK GROUP WAS FOUND.          *
*  (5)  THE NUMBER OF TRACK GROUPS ALLOCATED IS ADJUSTED FOR THE      *
*       AMOUNT GIVEN TO THE TRACK GROUP BLK AND A CHECK IS MADE TO    *
*       DETERMINE IF THE TOLERANCE SPECIFIED BY &TGWARN HAS BEEN      *
*       EXCEEDED. IF SO, A PERCENT UTILIZATION MESSAGE IS ISSUED.     *
*  (6)  A $POST FOR TRAK IS ISSUED TO INFORM HASP PROCESSORS OF       *
*       AVAILABILITY OF TRACKS (TRK GROUPS) AND A POST IS INVOKED     *
*       FOR SSSM ECB USED TO WAIT FOR TRKS. CONTROL IS RETURNED TO    *
*       THE CALLER.                                                   *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
*              TGB ALLOCATION ENTRY POINT                             *
*                                                                     *
***********************************************************************
         SPACE 1
         CNOP  4,8
KBLOB    L     JCT,$SSVT           OBTAIN SSVT                 @OZ20010
         USING SSVT,JCT              ADDRESSABILITY            @OZ20010
         TM    $SVSTUS,$SVSTIRV    UNIT RESV STILL IN EFFECT.. @OZ20010
         BOR   R14                 RETURN TO CALLER IF IT IS
         STM   R2,R9,PCEWA         ELSE, SAVE R2 - R9 IN PCE
         LM    R5,R7,$SVTTGBA      R5=1ST, R6=SIZE, R7=LAST TGB
         USING TGBDSECT,R5         TGB ADDRESSABILITY
         SLR   R2,R2               R2 = 0 (FOR CDS)
         SLR   R3,R3               R3 = 0 (FOR CDS)
         SLR   R8,R8               R8 = 0 (FOR ACCUMULATOR)
         L     R9,$TGMAP           POINT TO MASTER TRACK GROUP MAP   R4
         SPACE 1
***********************************************************************
*                                                                     *
*              REMOVE UNUSED TG'S FROM TGB                            *
*                                                                     *
***********************************************************************
         SPACE 1
KBLOBR   LM    R0,R1,TGBENTRY      FETCH TGB ENTRY
         LTR   R1,R1               TEST FOR UNALLOCATED TG
         BZ    KBLOBA              BRANCH IF ALLOCATED
         CDS   R0,R2,TGBENTRY      TRY TO REMOVE ENTRY
         BNE   KBLOBA              BRANCH IF REMOVED BY SSSM
         SPACE 1
         DROP  R5                  FORGET TGB
         SPACE 1
***********************************************************************
*                                                                     *
*              COUNT & RETURN TG TO MASTER MAP                        *
*                                                                     *
***********************************************************************
         SPACE 1
         LA    R8,1(,R8)           COUNT RETURNED TG'S
         LR    R1,R0               R1 = BYTE OFFSET & BIT MASK
         SRL   R1,16               R1 = BYTE OFFSET
         IC    R4,0(R1,R9)         R4 = BYTE CONTAINING BIT          R4
         XR    R4,R0               RETURN TG BIT TO BYTE
         STC   R4,0(R1,R9)         RETURN BYTE TO MAP                R4
         SPACE 1                                                    R41
KBLOBA   BXLE  R5,R6,KBLOBR        TRY NEXT TGB ENTRY
         EJECT
***********************************************************************
*                                                                     *
*              CALCULATE NUMBER OF TG'S FOR TGB                       *
*                                                                     *
***********************************************************************
         SPACE 1
         SLR   R2,R2               R2 = NUMBER OF TG'S               R4
         IC    R2,$NUMTGBE               PER TGB               @OZ17486
*              THIS LINE DELETED BY APAR NUMBER                @OZ17486
*              THIS LINE DELETED BY APAR NUMBER                @OZ17486
*              THIS LINE DELETED BY APAR NUMBER                @OZ17486
*              THIS LINE DELETED BY APAR NUMBER                @OZ17486
*              THIS LINE DELETED BY APAR NUMBER                @OZ17486
*              THIS LINE DELETED BY APAR NUMBER                @OZ17486
*              THIS LINE DELETED BY APAR NUMBER                @OZ17486
*              THIS LINE DELETED BY APAR NUMBER                @OZ17486
*              THIS LINE DELETED BY APAR NUMBER                @OZ17486
*              THIS LINE DELETED BY APAR NUMBER                @OZ17486
         SPACE 1                                                     R4
KBLOBS   STC   R2,$BLBTGBA         STORE NEW TGB COUNT               R4
         SPACE 1
***********************************************************************
*                                                                     *
*              COUNT THE NO. OF TG'S ALLOCATED IN ALL EXTENTS         *
*                                                                     *
***********************************************************************
         SPACE 1
KBLOBM   L     R1,$SVTGTOT         R1 = TOTAL TG'S AVAILABLE
         LA    R4,KBLOBT           R4 = LOOP START ADDRESS
         L     R2,$CYLMAPL         R2 = NUMBER OF BYTES IN MAP       R4
         L     R9,$TGMAP           R9 = ADDRESS OF                   R4
         BCT   R9,KBLOBT                 MASTER TRACK GROUP - 1      R4
         SPACE 1                                                     R4
KBLOBT   IC    R3,0(R9,R2)         R3 = BYTE FROM MAP                R4
         IC    R3,KNBITB(R3)       R3 = NUMBER OF BITS IN BYTE
         SLR   R1,R3               R1 = NUMBER OF ALLOCATED TG'S
         BCTR  R2,R4               PLOW THRU ENTIRE MAP
         SPACE 1                                                     R4
         ST    R1,$SVTGALC         SAVE NUMBER OF ALLOCATED TG'S
         L     R15,$AQSE           POINT TO OUR QSE                 R41
         TM    QSESTAT-QSEDSECT(R15),QSEACTIV  TERMINATING...       R41
         BZ    KBLBXIT             EXIT IF YES                      R41
         EJECT
***********************************************************************
*                                                                     *
*              IF NO TRK GROUPS, ISSUE SPOOL FULL MESSAGE             *
*                                                                     *
***********************************************************************
         SPACE 1
         L     R0,$SVTGTOT         R0 = TOTAL AVAILABLE
         SR    R0,R1               R0 = CURRENT AVAILABLE
         BNZ   KBLBOFFA            BRANCH IF NOT DEPLETED
         STCK  PCER1               STORE TIME-OF-DAY CLOCK          R41
         L     R0,PCER1            PICK UP 'SECONDS' PORTION        R41
         SRL   R0,5                CONVERT TO 32-SECOND UNITS       R41
         TM    KBLBFLAG,KBLBPERB   SEE IF 'SPOOL FULL' MSG ISSUED   R41
         BZ    KBLBFULL            IF NOT, ISSUE MSG IMMEDIATELY    R41
         CL    R0,CKPBTIME         SEE IF ABOUT 30 SEC HAVE PASSED  R41
         BNH   KBLBXIT             EXIT IF NOT                      R41
         SPACE 1                                                    R41
KBLBFULL ST    R0,CKPBTIME         UPDATE TIME STAMP FOR NEXT TIME  R41
         OI    KBLBFLAG,KBLBPERB   SHOW 'SPOOL FULL' MSG ISSUED     R41
         LR    R9,R14              SAVE LINK REGISTER
         $WTO  KM355,L'KM355,                                          C
               JOB=NO,ROUTE=$LOG+$MAIN,                                C
               CLASS=$ALWAYS,PRI=$HI,                                  C
               WAIT=NO
         LR    R14,R9              RESTORE LINK REGISTER
         B     KBLBXIT             RETURN TO CALLER
         SPACE 1                                                    R41
KBLBOFFA NI    KBLBFLAG,255-KBLBPERB RESET SPOOL FULL MSG FLAG
         SPACE 1
***********************************************************************
*                                                                     *
*              BE SURE ENOUGH TG'S FOR TGB                            *
*                                                                     *
***********************************************************************
         SPACE 1
         IC    R3,$BLBTGBA         R3 = TGB COUNT                    R4
         CR    R0,R3               TEST FOR SUFFICIENT TG'S
         BNL   KBLBOK              BRANCH IF ENOUGH
         STC   R0,$BLBTGBA          ELSE RESET TO AVAILABLE          R4
         EJECT
***********************************************************************
*                                                                     *
*              INIT TED'S TO BEGIN SEARCH FROM EXTENT START           *
*                                                                     *
***********************************************************************
         SPACE 1
KBLBOK   L     R3,$SVTFRST         R3 = 1ST TED ADDRESS
         SPACE 1                                                    R41
         USING TEDDSECT,R3         TED ADDRESSABILITY
         SPACE 1                                                    R41
KBLBTED  L     R2,$TGMAP           R2 = MASTER MAP START             R4
         AH    R2,TNMO             R2 = EXTENT START
         ST    R2,TNCH             SET SEARCH START TO 1ST BYTE
         LA    R3,TEDSIZ(,R3)      R3 = ADDRESS OF NEXT TED
         CL    R3,$SVTLAST         TEST FOR LAST TED PROCESSED
         BH    KBLOBP              BRANCH IF ALL PROCESSED
         L     R7,TNTC             TEST FOR NULL TED
         LTR   R7,R7                INDICATED BY TNTC = 0
         BNZ   KBLBTED             BRANCH IF GOOD TED
         SPACE 1
         DROP  R3                  FORGET THE TED
         SPACE 1
***********************************************************************
*                                                                     *
*              PREPARE TO ALLOCATE TGB                                *
*                                                                     *
***********************************************************************
         SPACE 1
KBLOBP   SLR   R2,R2               R2 = NO. TG'S                     R4
         IC    R2,$BLBTGBA               FOR TGB                     R4
         L     R5,$SVTTGBA         R5 = TGB START                    R4
         USING TGBDSECT,R5         TGB ADDRESSABILITY
         L     R3,$SVTNEXT         R3 = NEXT MODULE TED
         USING TEDDSECT,R3         TED ADDRESSABILITY
         LA    R6,1                R6 = 1 (FOR BXLE INCR)
         CLM   R8,1,$NUMTGBE       WHERE ANY TG'S USED...      @OZ17486
         BE    KBLOB1              BR IF NO                    @OZ17486
         BAL   R15,KBLBNXT         GET NEXT TED                @OZ17486
         ST    R3,$SVTNEXT         SAVE FOR NEXT ITERATION     @OZ17486
         EJECT
***********************************************************************
*                                                                     *
*              USE TED TO SETUP SEARCH FOR TG                         *
*                                                                     *
***********************************************************************
         SPACE 1
KBLOB1   L     R7,$TGMAP           R7 = MASTER MAP START             R4
         AH    R7,TNMO             R7 = 1ST BYTE THIS EXTENT
         AH    R7,TNMB             R7 = LAST BYTE + 1
         BCTR  R7,0                R7 = LAST BYTE
         L     R8,TNCH             R8 = SEARCH START ADDRESS
         SPACE 1
***********************************************************************
*                                                                     *
*              ALLOCATE TG USING EXTREME ALGORITHM                    *
*                                                                     *
***********************************************************************
         SPACE 1
KBLOB2   CLI   0(R8),0             TEST FOR AVAILABLE TRACK GROUP
         BNE   KBLOB3              BRANCH IF SOMETHING AVAIL
         BXLE  R8,R6,KBLOB2        SEARCH WHOLE MODULE
         BAL   R15,KBLBNXT         GET NEXT TED
         B     KBLOB1               AND TRY AGAIN
         SPACE 1
***********************************************************************
*                                                                     *
*              SAVE NEW SEARCH START, BIT NO. & MASK                  *
*                                                                     *
***********************************************************************
         SPACE 1
KBLOB3   ST    R8,TNCH             SAVE NEW SEARCH START ADDR
         IC    R1,0(,R8)           R1 = ALLOCATION BYTE
         LA    R0,X'FF'            R0 = X'FF' (FOR MASK)
         NR    R0,R1               CLEAR BYTES 0,1 & 2
         LA    R1,X'80'            ASSUME 1ST BIT IS 1
         SR    R7,R7               R7 = 0 (BIT NUMBER)
         SPACE 1                                                    R41
KBLOB4   CR    R1,R0               LOOK FOR 1ST BIT THAT'S = 1
         BNH   KBLOB5              BRANCH WHEN FOUND
         SRL   R1,1                TRY NEXT BIT
         ALR   R7,R6               DING THE BIT NUMBER
         B     KBLOB4               AND REPEAT LOOP
         EJECT
***********************************************************************
*                                                                     *
*              SHOW MASTER MAP ALLOCATION & SET TGB ENTRY             *
*                                                                     *
***********************************************************************
         SPACE 1
KBLOB5   IC    R0,0(,R8)           R0 = ALLOCATION BYTE
         XR    R0,R1               REMOVE TG BIT
         STC   R0,0(,R8)           SHOW TG ALLOCATION
         SL    R8,$TGMAP           R8 = OFFSET WITHIN TRK GROUP MAP  R4
         STH   R8,TGBYTEN          STORE BYTE OFFSET IN TGB
         SH    R8,TNMO             R8 = OFFSET FROM EXTENT
         STC   R1,TGBBITM+1        STORE BIT MASK IN TGB
         SLL   R8,3                RELATIVE BYTE NO. * 8
         ALR   R7,R8                PLUS BIT NO. = TG NO.
         MH    R7,TNTG             R7 = TT (TRACK NO.)
         SLL   R7,8                R7 = 0TT0
         O     R7,TNMD             R7 = MTT0
         IC    R7,=X'01'           R7 = MTTR
         ST    R7,TGBMTTR          STORE IN TGB
         SPACE 1
***********************************************************************
*                                                                     *
*              GET NEXT TED & INCREMENT TG ALLOC COUNT                *
*                                                                     *
***********************************************************************
         SPACE 1
         BAL   R15,KBLBNXT         GET NEXT TED
         L     R1,$SVTGALC         R1 = NUMBER OF TG'S ALLOC
         ALR   R1,R6               DING BY 1
         ST    R1,$SVTGALC          FOR THIS ALLOCATION
         LA    R5,TGBSIZE(,R5)     R5 = NEXT TGB ENTRY
         BCT   R2,KBLOB1           ALLOCATE NEXT TGB ENTRY
*              THIS LINE DELETED BY APAR NUMBER                @OZ17486
         EJECT
***********************************************************************
*                                                                     *
*              ISSUE WARNING MESSAGE IF % LIMIT REACHED               *
*                                                                     *
***********************************************************************
         SPACE 1
         SLR   R0,R0               R0 = 0 (FOR DIVISION)
         MH    R1,=H'100'          R1 = 100 * NO. ALLOCATED
         D     R0,$SVTGTOT         R1 = % ALLOCATED
         CLM   R1,1,$TGWARN        IS IT WARNING TIME                R4
         BL    KBLBOFFB            BRANCH IF NOT
         STCK  PCER1               STORE TOD CLOCK                  R41
         L     R0,PCER1            PICK UP 'SECONDS' PORTION        R41
         SRL   R0,5                CONVERT TO 32-SECOND UNITS       R41
         CL    R0,CKPBTIME         SEE IF ABOUT 30 SEC HAVE PASSED  R41
         BNH   KBLBXIT             SKIP MESSAGE IF NOT         @OZ32185
         ST    R0,CKPBTIME         UPDATE TIME STAMP FOR NEXT TIME  R41
         CLC   $SVTGALC,$SVTGTOT   IS THE % MEANINGFUL               R4
         BH    KBLBOFFB            IF NOT (INIT NOT COMPLETE)        R4
         LR    R9,R14              SAVE LINK REGISTER
         MVC   CKPMSG(L'KTWMM),KTWMM  MOVE MSG TO WORK AREA         R41
         MVC   CKPMSG+2(4),KTWME   MOVE EDIT PATTERN TO MSG         R41
         CVD   R1,CKPDBL           CONVERT PERCENT TO DECIMAL       R41
         ED    CKPMSG+2(4),CKPDBL+6  EDIT PERCENT INTO MSG          R41
        $WTO   CKPMSG,L'KTWMM,     ISSUE WARNING                    R41C
               ROUTE=$LOG+$MAIN,                                       C
               CLASS=$ALWAYS,PRI=$HI,                                  C
               JOB=NO,WAIT=NO                                       R41
         LR    R14,R9              RESTORE LINK REG
         B     KBLBXIT             BYPASS RESET CODE           @OZ32185
         SPACE 1                                                    R41
KBLBOFFB SLR   R0,R0               SHOW WARNING MESSAGE             R41
         ST    R0,CKPBTIME          NOT ISSUED YET                  R41
                                   PRINT OFF SECTION DELETED   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
*                                  THIS LINE DELETED BY APAR   @OZ32185
                                   PRINT ON SECTION DELETED    @OZ32185
         EJECT
***********************************************************************
*                                                                     *
*              RESTORE REGISTERS &RETURN                              *
*                                                                     *
***********************************************************************
         SPACE 1
KBLBXIT  LM    R2,R9,PCEWA         RESTORE R2 - R9 FROM PCE
         BR    R14                 RETURN TO CALLER
         SPACE 1
***********************************************************************
*                                                                     *
*              SUBROUTINE TO SET R3 = NEXT TED ADDRESS                *
*                                                                     *
***********************************************************************
         SPACE 1
KBLBFRO  L     R3,$SVTFRST         POINT TO FIRST TED
         BR    R15                 RETURN TO CALLER
         SPACE 1                                                    R41
KBLBNXT  LA    R3,TEDSIZ(,R3)      STEP TO NEXT TED
         CL    R3,$SVTLAST         TEST FOR STEPPING TOO FAR
         BH    KBLBFRO             BRANCH IF TOO FAR
         OC    TNTC,TNTC           TEST FOR NULL TED
         BNZR  R15                 RETURN IF GOOD TED
         B     KBLBFRO             ELSE, GET FIRST ONE
         SPACE 1
         DROP  R3,R5,JCT           KILL CTL BLK ADDRESSABILITY @OZ20010
         TITLE 'HASP CHECKPOINT PROCESSOR CONSTANTS AND STORAGE'
KRNOP    CCW   X'03',0,X'20',1     NO-OP TO TERM. R/W CHAIN    @OZ20010
         SPACE 2                                               @OZ20010
         $MID  260                 SET MESSAGE NUMBER          @OZ16669
KRASHMSG WTO   '&MID.JES2 CONTROL LOCKOUT -- RESET CRASHED SYSTEMS',   C
               MF=L                                            @OZ16669
KWARNMSG EQU   KRASHMSG,*-KRASHMSG ALTERNATE LABEL WITH LENGTH @OZ16669
         SPACE 2                                               @OZ20010
KTWMM    $MSG  093,'NNNN% SPOOL UTILIZATION'
KTWME    DC    X'40202120'         EDIT PATTERN                      R4
KM355M   $MSG  355,'SPOOL VOLUMES ARE FULL'
KM355    EQU   KM355M,*-KM355M
KBLBPERB EQU   X'02'               SPOOL FULL MESSAGE FLAG
KBLBFLAG EQU   $BLBFLAG            BLOB/UNBLOB FLAG BYTE             R4
KNBITB   DC    AL1(0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4)    A
         DC    AL1(1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5)    BYTE
         DC    AL1(1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5)    INDEX
         DC    AL1(2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6)    INTO
         DC    AL1(1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5)    THIS
         DC    AL1(2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6)    TABLE
         DC    AL1(2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6)    YIELDS
         DC    AL1(3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7)    THE
         DC    AL1(1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5)    NUMBER
         DC    AL1(2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6)    OF
         DC    AL1(2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6)    BITS
         DC    AL1(3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7)    ON
         DC    AL1(2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6)    IN
         DC    AL1(3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7)    THE
         DC    AL1(3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7)    BYTE
         DC    AL1(4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8)    INDEX
         EJECT                                                       R4
         LTORG
         TITLE 'HASP PRIORITY AGING PROCESSOR'
HASPGPRC $ENTRY BASE=BASE2         HASP PRIORITY AGING PROCESSOR
         ST    SAVE,GPRTQE+IPOST   SET PCE ADDRESS IN STQE
         LH    R1,$PRIRATE         GET PRIORITY AGING RATE           R4
         LR    R2,R1               SAVE IT                           R4
         SRL   R1,1                COMPUTE                           R4
         AL    R1,GPRINT            AND                              R4
         SLR   R0,R0                 SAVE                            R4
         DR    R0,R2                  AGING                          R4
         LCR   R1,R1                   TIME                          R4
         ST    R1,GPRINT                INTERVAL (COMPLEMENT)        R4
         LR    R1,R2               COMPUTE                           R4
         SRL   R1,1                 AND                              R4
         AL    R1,GPRSEC             SAVE                            R4
         SLR   R0,R0                  TIME                           R4
         DR    R0,R2                   ADJUSTMENT                    R4
         AL    R1,$SYNCTOL              IN                           R4
         ST    R1,GPRSEC                 SECONDS                     R4
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        SCAN JOB QUEUE FOR ACTIVE JOB                                *
*                                                                     *
***********************************************************************
         SPACE 1                                                     R4
GPRSTART LA    WB,$JQTYPES*2       PREPARE TO TEST FOR ACTIVE JOB Q
         SPACE 1
         LH    R1,$JQHEADS-2(WB)   GET 1ST ACTIVE JQE OFFSET
         LTR   R1,R1               TEST
         BNZ   GPRTIME             BRANCH IF JOB QUEUE IS NOT EMPTY
         BCTR  WB,0                IF ANOTHER JOB QUEUE,
         BCT   WB,*-12              BR TO TEST IT
         SPACE 1
         $WAIT JOB                 EMPTY, WAIT FOR A JOB
         B     GPRSTART            GO BACK AND TRY AGAIN
         SPACE 1
GPRTIME  L     R1,GPRINT           SET
         ST    R1,GPRTQE+ITIME      AGING TIME                       R4
        $STIMER GPRTQE               INTERVAL                        R4
         $WAIT WORK                WAIT FOR TIME INTERVAL TO EXPIRE
         $QSUSE                    REQUEST ACCESS TO SHARED QUEUES
         STCK  GPRCLOCK            STORE CURRENT CLOCK
         BC    3,GPRSCAN           BRANCH IF INVALID CLOCK
         L     R1,GPRCLOCK         GET CURRENT TIME
         SL    R1,GPRSEC           COMPUTE APPROXIMATE PREVIOUS TIME
         LH    R0,$QSENO           GET COUNT OF MEMBERS IN NODE      R4
         L     R15,$QSE1           GET ADDRESS OF 1ST QSE            R4
         SPACE 1                                                    R41
         USING QSEDSECT,R15        ESTABLISH QSE ADDRESSABILITY
         SPACE 1
GPRQSE   CLC   QSESID,$SID         COMPARE SID'S
         BE    GPRSCAN             BRANCH IF THIS CPU IS 1ST ACTIVE
         CL    R1,QSESITIM         COMPARE TIMES
         BL    GPRTIME             BRANCH IF ANOTHER CPU IS ACTIVE
         AH    R15,$QSEL           GET ADDRESS OF NEXT QSE           R4
         BCT   R0,GPRQSE           BR IF VALID QSE ADDRESS           R4
         SPACE 1                                                     R4
         DROP  R15                 DROP QSE ADDRESSABILITY
         EJECT                                                      R41
GPRSCAN  LA    WB,$JQTYPES*2       PREPARE TO SCAN ALL JOB QUEUES
         SPACE 1                                                     R4
         USING JQEDSECT,R1         JOB QUEUE ADDRESSABILITY
         SPACE 1
GPRQUE1  LH    R1,$JQHEADS-2(WB)   PREPARE TO SCAN NEXT JOB QUEUE
         LA    WC,$PRIHIGH         POINT TO HI/LO PRIO AGING VALUES R41
         CL    WB,GPRHDCPY         TEST FOR $HARDCPY QUEUE,         R41
         BNE   GPRLOOP1              SKIP IF NOT                    R41
         LA    WC,GPRHCPRI         POINT TO $HARDCPY HI/LO VALUES   R41
         SPACE 1
GPRLOOP1 N     R1,=X'0000FFFF'     CLEAR H.O. TWO BYTES AND TEST
         BZ    GPREND1             BRANCH IF END-OF-CHAIN
         SLL   R1,2                EXPAND TO FULL ADDRESS OFFSET
         AL    R1,$JOBQPTR         ADD JOB QUEUE ADDRESS
         CLC   JQEPRIO,0(WC)       COMPARE PRIO WITH UPPER LIMIT    R41
         BL    GPRLOOP2            BRANCH IF LESS
         LH    R1,JQECHAIN         NO, GET OFFSET OF NEXT ELEMENT
         B     GPRLOOP1            TEST NEXT ELEMENT
         SPACE 1
GPREND1  BCTR  WB,0                IF ANOTHER JOB QUEUE,
         BCT   WB,GPRQUE1           BR TO SCAN IT
         B     GPRSTART              ELSE START OVER
         SPACE 1
GPRLOOP2 CLC   JQEPRIO,1(WC)       COMPARE PRIO WITH LOWER LIMIT    R41
         BL    GPREND1             BR IF LESS -- DONE WITH QUEUE     R4
         IC    WA,JQEPRIO          INCREMENT
         LA    WA,1(,WA)            JOB QUEUE
         STC   WA,JQEPRIO            PRIORITY
        $QCKPT (R1)                CHECKPOINT THE JQE                R4
         LH    R1,JQECHAIN         GET OFFSET OF NEXT ELEMENT
         N     R1,=X'0000FFFF'     CLEAR H.O. TWO BYTES AND TEST
         BZ    GPREND1             BRANCH IF END-OF-CHAIN
         SLL   R1,2                EXPAND TO FULL ADDRESS OFFSET
         AL    R1,$JOBQPTR         ADD JOB QUEUE ADDRESS
         B     GPRLOOP2            TEST NEXT ELEMENT
         SPACE 1
GPRCLOCK EQU   PCER1,8             STORAGE FOR CLOCK                 R4
GPRINT   DC    A(540000)           TIME INTERVAL (UNADJUSTED)        R4
GPRSEC   DC    A(5400)             TIME IN SECONDS (UNADJUSTED)      R4
GPRTQE   EQU   PCEWORK             HASP TIMER QUEUE ELEMENT          R4
GPRHDCPY DC    A(4)                OFFSET OF $HARDCPY QUEUE         R41
GPRHCPRI DC    AL1(X'EF',X'10')    $PRIHIGH, $PRILOW FOR $HARDCPY   R41
         SPACE 1
         LTORG
         TITLE 'HASP JOB QUEUE WARM START -- INITIAL ENTRY POINT'
***********************************************************************
*                                                                     *
* PROCESSOR NAME -- HASPWARM                                          *
*                                                                     *
* DESCRIPTIVE NAME -- JES2 JOB QUEUE WARM START PROCESSOR             *
*                                                                     *
* FUNCTION --  PROVIDE WARM START PROCESSING OF THE JES2 JOB QUEUE    *
*              AND JOB OUTPUT TABLE (JOT) FOR ONE OR MORE SYSTEMS     *
*              IN A JES2 NODE.                                        *
*                                                                     *
* NOTES -- 1)  WHILE THIS PROCESSOR IS ACTIVE, THE SYSTEM BEING       *
*              WARM STARTED IS LOCKED TO PREVENT OTHER SYSTEMS        *
*              FROM ATTEMPTING TO WARM START IT.                      *
*                                                                     *
*          2)  MASTER BIT MAP RECONSTRUCTION IS PERFORMED ONLY        *
*              WHEN A WARM START IS BEING PERFORMED ON BEHALF OF      *
*              ALL SYSTEMS IN THE NODE.                               *
*                                                                     *
* REGISTER CONVENTIONS -- R0  -- WORK REGISTER                        *
*                         R1  -- WORK REGISTER                        *
*                         WA  -- WORK/SJB ADDRESS                     *
*                         WB  -- HQT ADDRESS                          *
*                         WC  -- QSE ADDRESS                          *
*                         WD  -- JQE ADDRESS                          *
*                         WE  -- WORK/LINK REGISTER                   *
*                         WF  -- IOT ADDRESS                          *
*                         JCT -- JCT ADDRESS                          *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
*        H A S P W A R M   I N I T I A L   E N T R Y   P O I N T      *
*                                                                     *
***********************************************************************
         SPACE 2
NQHQT    EQU   WB                  HQT ADDRESS
NQSE     EQU   WC                  QSE ADDRESS
NQ       EQU   WD                  JQE ADDRESS
NQIOT    EQU   WF                  IOT ADDRESS
NQJCT    EQU   JCT                 JCT ADDRESS
         SPACE 1
         USING QSEDSECT,NQSE       PROVIDE QSE ADDRESSABILITY
         USING IOTDSECT,NQIOT      PROVIDE IOT ADDRESSABILITY
         USING JCTDSECT,NQJCT      PROVIDE JCT ADDRESSABILITY
         USING JQEDSECT,WD         PROVIDE JQE ADDRESSABILITY
         USING $SVDSECT,R15        PROVIDE SSVT ADDRESSABILITY       R4
         SPACE 2                                                     R4
HASPWARM $ENTRY BASE=(BASE2,BASE3) PROVIDE PROCESSOR ENTRY POINT     R4
         SPACE 1
         LA    BASE3,2048(,BASE2)  SET SECOND                        R4
         LA    BASE3,2048(,BASE3)   BASE REGISTER                    R4
         L     R15,$SSVT           POINT TO SSVT                     R4
         TM    $SVHASP,X'80'       TEST FOR JES2 RESTART             R4
         BZ    SKIP20              BR IF NO                          R4
         OI    NQSTAT,NQRESTRT      ELSE INDICATE RESTART            R4
SKIP20   B     NQWARM              THEN BR TO SHOW PROCESSOR ACTIVE
         SPACE 1
***********************************************************************
*                                                                     *
*        $ W A I T   F O R   $ E S Y S   C O M M A N D                *
*                                                                     *
***********************************************************************
         SPACE 1
NQ000   $WAIT  WORK                $WAIT FOR $ESYS COMMAND
         SPACE 1
NQWARM  $ACTIVE                    INDICATE PROCESSOR ACTIVE
         L     NQSE,$ESYSQSE       GET WARM STARTED SYSTEM QSE ADDR
         LH    R1,$NUMRJE          GET NUMBER OF REMOTES             R4
         LTR   R1,R1               TEST COUNT                        R4
         BZ    NQCKCOLD            BR IF NONE                        R4
     TITLE 'HASP JOB QUEUE WARM START -- REMOTE SIGN-ON TABLE RESET'
***********************************************************************
*                                                                     *
*        R E M O T E   S I G N - O N   T A B L E   R E S E T          *
*                                                                     *
***********************************************************************
         SPACE 1
        $QSUSE                     REQUEST ACCESS TO CHECKPOINT DATA
         L     WA,$RMTSON          POINT TO REMOTE SIGN-ON TABLE     R4
         LTR   NQSE,NQSE           IF SPECIFIC SYSTEM WARM START,
         BNZ   NQRMT20              BR TO CLEAR THIS SYSTEM'S IDS
         MH    R1,=H'3'            R1 = SIZE (IN BYTES)              R4
         LA    R1,7(,R1)                 OF REMOTE                   R4
         SRL   R1,3                       SIGN-ON TABLE              R4
         SPACE 1                                                     R4
SKIP30   MVI   0(WA),0             CLEAR                             R4
         LA    WA,1(,WA)            ENTIRE                           R4
         BCT   R1,SKIP30             SIGN-ON TABLE                   R4
         SPACE 1                                                     R4
        $POST  $HASPECF,CKPW       $POST THE CHECKPOINT WRITER
         B     NQCKCOLD            THEN BR TO TEST FOR COLD START
         SPACE 1
NQRMT20  SLR   R0,R0               GET SYSTEM ID
         IC    R0,QSESIBSY          FROM QSE
         SPACE 1
NQRMT40  LA    WB,8                NUMBER OF IDS PER 3-BYTE TBL SEG
         ICM   R15,14,0(WA)        LOAD 3-BYTE SEGMENT FROM TABLE
         SPACE 1
NQRMT60  SLR   R14,R14             IF REMOTE
         SLDL  R14,3                NOT SIGNED ON
         CLR   R0,R14                TO THIS SYSTEM,
         BNE   *+8                    BR TO TEST NEXT REMOTE
         BAL   WE,NQRESET              ELSE RESET SYSTEM ID
         BCT   R1,NQRMT80          BR IF ANOTHER REMOTE TO TEST
         B     NQCKCOLD             ELSE BR TO TEST FOR COLD START
         SPACE 1
NQRMT80  BCT   WB,NQRMT60          BR IF ANOTHER ID IN TABLE SEGMENT
         LA    WA,3(,WA)            ELSE POINT TO NEXT TABLE SEGMENT
         B     NQRMT40               AND BR TO SCAN IT
         EJECT
***********************************************************************
*                                                                     *
*        R E S E T   S I G N - O N   T A B L E   S Y S T E M   I D    *
*                                                                     *
***********************************************************************
         SPACE 1
NQRESET $POST  $HASPECF,CKPW       $POST THE CHECKPOINT WRITER
         LR    R14,WB              A SEPARATE RTN EXISTS TO RESET
         SLL   R14,2                EACH OF THE 8 GROUPS OF 3 BITS
         B     *(R14)                IN THE CURRENT 3-BYTE TBL SEG
         SPACE 1
         B     NQID8               BR TO RESET ID FOR 8TH REMOTE
         B     NQID7               BR TO RESET ID FOR 7TH REMOTE
         B     NQID6               BR TO RESET ID FOR 6TH REMOTE
         B     NQID5               BR TO RESET ID FOR 5TH REMOTE
         B     NQID4               BR TO RESET ID FOR 4TH REMOTE
         B     NQID3               BR TO RESET ID FOR 3RD REMOTE
         B     NQID2               BR TO RESET ID FOR 2ND REMOTE
         SPACE 1
NQID1    NI    0(WA),X'1F'         RESET SYSTEM ID
         BR    WE                   AND RETURN
         SPACE 1
NQID2    NI    0(WA),X'E3'         RESET SYSTEM ID
         BR    WE                   AND RETURN
         SPACE 1
NQID3    NI    0(WA),X'FC'         RESET
         NI    1(WA),X'7F'          SYSTEM ID
         BR    WE                    AND RETURN
         SPACE 1
NQID4    NI    1(WA),X'8F'         RESET SYSTEM ID
         BR    WE                   AND RETURN
         SPACE 1
NQID5    NI    1(WA),X'F1'         RESET SYSTEM ID
         BR    WE                   AND RETURN
         SPACE 1
NQID6    NI    1(WA),X'FE'         RESET
         NI    2(WA),X'3F'          SYSTEM ID
         BR    WE                    AND RETURN
         SPACE 1
NQID7    NI    2(WA),X'C7'         RESET SYSTEM ID
         BR    WE                   AND RETURN
         SPACE 1
NQID8    NI    2(WA),X'F8'         RESET SYSTEM ID
         BR    WE                   AND RETURN
         SPACE 1
NQCKCOLD LTR   NQSE,NQSE           IF SPECIFIC SYSTEM WARM START,
         BNZ   NQSETST              BR AROUND COLD START TEST        R4
         TM    $OPTSTAT,$OPTCOLD+$OPTFMT  IF COLD START,             R4
         BNZ   NQ700                BR AROUND WARM START             R4
    TITLE 'HASP JOB QUEUE WARM START -- OUTPUT PROCESSOR WARM START'
***********************************************************************
*                                                                     *
*        O U T P U T   P R O C E S S O R   W A R M   S T A R T        *
*                                                                     *
***********************************************************************
         SPACE 1
NQSETST $QSUSE                     REQUEST ACCESS TO CHECKPOINT DATA R4
         LH    WF,$QSEL            GET QSE LENGTH                    R4
         LTR   WA,NQSE             IF SINGLE SYSTEM WARM START,
         BNZ   NQSEONE              BR TO TEST SYSTEM STATUS
         L     WA,$QSE1            POINT TO 1ST QSE                  R4
         SPACE 1
NQSENXT1 ICM   WB,15,QSEOPJNO-QSEDSECT(WA)  IF OUTPUT PROCESSOR BSY,
         BNZ   NQSEACTV                      BR TO XFER JOT INFO
         SPACE 1
NQSENEXT TM    QSEFLAGS-QSEDSECT(WA),QSELAST  IF ANOTHER
         LA    WA,0(WF,WA)                     QSE,                  R4
         BZ    NQSENXT1                         LOOP,
         B     NQ020                ELSE BR TO WARM START THE JOT
         SPACE 1
NQSEONE  ICM   WB,15,QSEOPJNO      IF SYSTEM NOT IN OUTPUT PROC'G,
         BZ    NQ020                BR TO WARM START THE JOT
         SPACE 1
NQSEACTV L     WE,$QSE1            POINT TO 1ST QSE                  R4
         STCK  NQDBL               GET CURRENT TIME OF DAY
         L     R15,NQDBL            ADJUSTED BY
         SL    R15,$SYNCTOL          CLOCK TOLERANCE                 R4
         EJECT                                                       R4
         USING QSEDSECT,WE         ALTER QSE ADDRESSABILITY          R4
         SPACE 1                                                     R4
NQSENXT2 ICM   R0,3,QSEOPJNO       IF OUTPUT PROCESSOR BUSY,         R4
         BNZ   SKIP40               BR TO TEST NEXT QSE              R4
         CL    R15,QSESITIM        IF SYSTEM NOT DORMANT,            R4
         BNH   NQSEXFER             BR TO TRANSFER JOT INFO          R4
SKIP40   TM    QSEFLAGS,QSELAST    IF ANOTHER                        R4
         LA    WE,0(WF,WE)          QSE,                             R4
         BZ    NQSENXT2              LOOP                            R4
         LR    WE,WA                ELSE POINT TO BUSY QSE
         B     NQSEAFF               AND BR TO ASSIGN SYSTEM AFF
         SPACE 1
NQSEXFER STCM  WB,15,QSEOPJNO               TRANSFER OUTPUT          R4
         SLR   R0,R0                         PROCESSOR WARM
         STCM  R0,15,QSEOPJNO-QSEDSECT(WA)    START INFORMATION
         SPACE 1
NQSEAFF  SRL   WB,16               LOCATE JQE
        $QLOC  (WB),NQSENEXT        FOR JOB
         NI    QUEFLAG2(R1),255-QUESYSAF  ASSIGN SYSTEM
         OC    QUEFLAG2(,R1),QSESIAFF        AFFINITY                R4
        $QCKPT (R1)                FORCE CHECKPOINT OF JQE
         LTR   NQSE,NQSE           IF NODAL WARM START,              R4
         BZ    NQSENEXT             BR TO CONTINUE QSE SCAN
         SPACE 1                                                     R4
         DROP  WE                  RESTORE NORMAL QSE ADDRESSABILITY R4
         TITLE 'HASP JOB QUEUE WARM START -- JOT WARM START'         R4
***********************************************************************
*                                                                     *
*        J O T   W A R M   S T A R T                                  *
*                                                                     *
***********************************************************************
         SPACE 1
         USING JOEDSECT,WA         PROVIDE JOE ADDRESSABILITY
         USING JOTDSECT,WB         PROVIDE JOT ADDRESSABILITY
         SPACE 1
NQ020    L     WB,$JOTABLE         GET ADDRESS OF JOT
         LA    WF,72               MAXIMUM INDEX TO CLASS QUEUE
         SPACE 1
NQ040    LA    WA,JOTCLSQ-2-(JOENEXT-JOEDSECT)(WF)  NEXT CLASS QUEUE
         SPACE 1
NQ060    LH    WA,JOENEXT          GET NEXT WORK JOE OFFSET
         N     WA,=X'0000FFFF'     IF END OF CLASS QUEUE,
         BZ    NQ160                BR TO TEST NEXT CLASS QUEUE
         SLL   WA,2                  ELSE CONVERT OFFSET             R4
         ALR   WA,WB                  TO ABSOLUTE ADDRESS
         TM    JOEFLAG,$JOEBUSY    IF JOE NOT IN USE,
         BZ    NQ060                BR TO TEST NEXT JOE
         LTR   NQSE,NQSE           IF NODAL WARM START,              R4
         BZ    NQ080                BR TO RESET JOES
         IC    R0,JOEFLAG          IF NOT
         N     R0,=A(QUEBUSY)       SYSTEM BEING
         CLM   R0,1,QSESIBSY         WARM STARTED,
         BNE   NQ060                  BR TO TEST NEXT JOE
         CLI   JOEDEVID,X'0F'      IS XWTR USING THIS JOE      @OZ30706
         BNE   NQ080               SKIP NEXT IF NOT                  R4
         SPACE 1                                                     R4
***********************************************************************
*                                                                     *
*        CHECK IF THE XWTR USING THIS JOE IS STILL ACTIVE             *
*                                                                     *
***********************************************************************
         SPACE 1                                                     R4
         L     R15,$SSVT          GET SSVT ADDRESS                   R4
         LA    WE,$SVJXNUM-(SJBXQCHN-SJBDSECT) SET TO SCAN SJB'S     R4
         SPACE 1                                                     R4
NQ070    L     WE,SJBXQCHN-SJBDSECT(,WE) GET NEXT SJB ADDRESS        R4
         LTR   WE,WE               IS THERE A POSSIBLE XWTR ACTIVE   R4
         BZ    NQ080               BR IF NONE                        R4
         L     R1,SJBPSOP-SJBDSECT(,WE) IF ACTIVE TASK IS XWTR,      R4
         LA    R1,0(,R1)            IT WILL HAVE A PSO ADDR.         R4
         LTR   R1,R1               TEST FOR A PSO ADDR,              R4
         BZ    NQ070                IF NONE, BR TO GET NEXT SJB.     R4
         CLM   WA,7,PSOWKJOE+1-PSODSECT(R1) THIS XWTR FOR THIS JOE   R4
         BE    NQ060               IF YES BR TO SKIP RESET, OTHERWISER4
         B     NQ070               LOOK FOR ANOTHER XWTR ACTIVE      R4
         SPACE 1                                                     R4
         SPACE 1
NQ080    LH    R1,JOECHAR                POINT TO
         N     R1,=X'0000FFFF'            CHARACTERISTICS
         SLL   R1,2                        JOE                       R4
         LA    WE,JOEACTPR-JOEDSECT(R1,WB)  ACTIVE PRINTER COUNT
         TM    JOEFLAG,$JOEPRT     IF JOB PRINTING LOCALLY,
         BO    NQ100                BR TO DECREMENT COUNT
         TM    JOEFLAG,$JOEPUN     IF JOB NOT PUNCHING LOCALLY,
         BZ    NQ110                BR TO RECOMPUTE PRIORITY        R41
         LA    WE,1(,WE)             ELSE POINT TO ACTIVE PUNCH CT
         SPACE 1
***********************************************************************
*                                                                     *
*        U P D A T E   A C T I V E   D E V I C E   C O U N T          *
*                                                                     *
***********************************************************************
         SPACE 1
NQ100    IC    R0,0(,WE)           DECREMENT
         BCTR  R0,0                 DEVICE
         STC   R0,0(,WE)             COUNT
        $#CKPT JOE=0(,R1)          CHECKPOINT THE CHAR-JOE           R4
         SPACE 1                                                    R41
***********************************************************************
*                                                                     *
*        R E C O M P U T E   J O E   P R I O R I T Y                  *
*                                                                     *
***********************************************************************
         SPACE 1                                                    R41
NQ110    TM    JOEFLAG,$JOECKV     IF NO CKPT INFORMATION,          R41
         BZ    NQ120                 LEAVE PRIORITY ALONE           R41
         LH    R1,JOECKPT          PICK UP CKPT JOE PTR,            R41
         N     R1,=X'0000FFFF'       DELETE SIGN BITS,              R41
         BZ    NQ120                 EXIT IF NO POINTER             R41
         ALR   R1,R1               DEVELOP                          R41
         ALR   R1,R1                 BYTE OFFSET                    R41
         L     R0,JOERECCT         COMPUTE NO OF RECORDS LEFT       R41
         S     R0,JOECRECN-JOEDSECT(R1,WB) TO PRINT OR PUNCH        R41
         BM    NQ120               FORGET IT IF NEGATIVE            R41
         L     R1,$SSVT            POINT TO SSVT,                   R41
         LA    R1,$SVXPRI-4-SSVT(,R1) THEN TO PRIORITY TABLE        R41
         LA    R14,10              SET BCT LOOP COUNTER             R41
         SPACE 1                                                    R41
NQ115    LA    R1,4(,R1)           BUMP TABLE POINTER               R41
         L     R15,0(,R1)          PICK UP TABLE ENTRY,             R41
         LA    R15,0(,R15)           DELETE PRIORITY BYTE           R41
         CLR   R15,R0              SEE IF THIS IS RIGHT SLOT,       R41
         BNL   NQ117                 BRANCH IF SO                   R41
         BCT   R14,NQ115           LOOP THRU TABLE                  R41
         SPACE 1                                                    R41
NQ117    MVC   JOEPRIO,0(R1)       MOVE PRIORITY TO JOE             R41
         EJECT
***********************************************************************
*                                                                     *
*        R E S E T   J O E   F L A G S                                *
*                                                                     *
***********************************************************************
         SPACE 1
NQ120    NI    JOEFLAG,255-$JOEBUSY-$JOEPRT-$JOEPUN  RESET JOE FLAGS
        $#CKPT JOE=0(,R2),TYPE=A   CHECKPOINT THE WORK JOE
        $POST  $HASPECF,CKPW       $POST THE CHECKPOINT WRITER
         LH    NQ,JOEJQE           GET JQE
         N     NQ,=X'0000FFFF'      ADDRESS
         SLL   NQ,2                  FROM
         AL    NQ,$JOBQPTR            JOE
         TM    JQEFLAGS,QUEPURGE   IF JOB NOT BEING CANCELLED,
         BZ    NQ140                BR TO ISSUE MESSAGE
        $#REM  WORK=(WA)             ELSE REMOVE JOE FROM JOT        R4
         SPACE 1
NQ140    LA    R1,NQPRPU           SET 'WAS PRINTING/PUNCHING' MSG   R4
         BAL   WE,NQWTO             AND INFORM THE OPERATOR
         B     NQ040               THEN BR TO RE-SCAN THE CLS QUEUE
         SPACE 1
***********************************************************************
*                                                                     *
*        G E T   N E X T   C L A S S   Q U E U E                      *
*                                                                     *
***********************************************************************
         SPACE 1
NQ160    BCTR  WF,0                DECREMENT QUEUE INDEX BY 1
         BCT   WF,NQ040            BR IF ANOTHER CLASS QUEUE
         B     NQPURGE              ELSE BR TO PURGE REQUEST QUEUES
         SPACE 1
         DROP  WA,WB               KILL JOE, JOT ADDRESSABILITY
         TITLE 'HASP JOB QUEUE WARM START -- REQUEST QUEUE PURGE'
***********************************************************************
*                                                                     *
*        P O S T   C A N C E L / S T A T U S ,   P S O   W A I T S    *
*                                                                     *
***********************************************************************
         SPACE 1
         USING SJBDSECT,WA         PROVIDE SJB ADDRESSABILITY
         SPACE 1
NQPURGE  TM    NQSTAT,NQRESTRT     IF WARM STARTING JES2,            R4
         BZ    NQINIT               BR TO WARM START JOB QUEUE       R4
         L     R15,$SSVT           POINT TO SSVT                     R4
         LA    WF,$SVTSCS          POINT TO CANCEL/STATUS QUEUE
         BAL   WE,NQPOST            AND POST ANY WAITING REQUESTORS
         L     R15,$SSVT           POINT TO SSVT                     R4
         LA    WF,$SVPSOQ          POINT TO PSO QUEUE
         BAL   WE,NQPOST            AND POST ANY WAITING REQUESTORS
         B     NQINIT              THEN BR TO WARM START JOB QUEUE   R4
         SPACE 1
NQPOST  $GETLOK ,                  SERIALIZE WITH OTHER DEQUEUERS
         LM    WA,WB,0(WF)         PICK UP QUEUE HEADER
         SPACE 1
NQTESTQ  LTR   WA,WA               TEST FOR EMPTY QUEUE
         BZ    NQUNLOK             BR IF SO
         L     R0,SJBTCHN           ELSE TRY
         LR    R1,WB                 TO DEQUEUE
         CDS   WA,R0,0(WF)            QUEUE ELEMENT
         BNE   NQTESTQ             BR IF UNSUCCESSFUL TO TRY AGAIN
        $FRELOK ,                   ELSE RELEASE LOCK
         POST  ,1,MF=(E,SJBECBP)   POST ABNORMAL COMPLETION
         B     NQPOST              THEN BR TO POST NEXT QUEUE ENTRY
         SPACE 1
NQUNLOK $FRELOK ,                  RELEASE LOCK
         BR    WE                  THEN RETURN
         TITLE 'HASP JOB QUEUE WARM START -- MAIN PROCESSING'
***********************************************************************
*                                                                     *
*        P R E P A R E   T O   S C A N   J O B   Q U E U E            *
*                                                                     *
***********************************************************************
         SPACE 1
         USING HQTDSECT,NQHQT      PROVIDE HQT ADDRESSABILITY
         SPACE 1
NQ200    LA    NQ,$JQTYPES*2             PREPARE
         ST    NQ,NQQUEUE                 TO SCAN
         LA    NQ,$JQHEADS-2-QUECHAIN(NQ)  ACTIVE JOB QUEUES
         SPACE 1
***********************************************************************
*                                                                     *
*        P R O C E S S   N E X T   J O B   Q U E U E   E N T R Y      *
*                                                                     *
***********************************************************************
         SPACE 1
NQ210    LH    NQ,JQECHAIN         GET OFFSET
         N     NQ,=X'0000FFFF'      OF NEXT JQE
         BZ    NQ660               BR IF END OF CURRENT JOB QUEUE
         SLL   NQ,2                 ELSE CONVERT OFFSET
         AL    NQ,$JOBQPTR           TO ABSOLUTE ADDRESS
         TM    JQEHQLOK,QUEBUSY    IF HOLD QUEUE LOCK NOT HELD,
         BZ    NQ210                BR TO TEST NEXT JQE
         MVC   NQCHAIN,JQECHAIN    SAVE OFFSET OF NEXT JQE
         LTR   NQSE,NQSE           IF NODAL WARM START,              R4
         BZ    NQ220                BR TO TEST QUEUE TYPE
         IC    R0,JQEHQLOK         IF NOT
         N     R0,=A(QUEBUSY)       SYSTEM BEING
         CLM   R0,1,QSESIBSY         WARM STARTED,
         BNE   NQ210                  BR TO TEST NEXT JQE
         SPACE 1
NQ220    CLI   JQETYPE,$INPUT      TEST FOR JOB ON READER
         BNE   NQ230               BR IF NO
SKIP50   LTR   NQSE,NQSE           IF NODAL WARM START,              R4
         BZ    *+20                 BR TO AVOID SYSTEM TEST
         IC    R0,JQEFLAGS         IF NOT
         N     R0,=A(QUEBUSY)       SYSTEM BEING
         CLM   R0,1,QSESIBSY         WARM STARTED,
         BNE   NQ640                  BR TO TEST NEXT JQE
         LA    R1,NQRDRM           SET 'WAS ON READER' MSG           R4
         EJECT                                                      R41
NQ225    BAL   WE,NQWTO            ISSUE MESSAGE TO OPERATOR        R41
         B     NQ255               THEN BR TO QUEUE JOB FOR PURGE
         SPACE 1                                                    R41
***********************************************************************
*                                                                     *
*        J O B   N O T   O N   R E A D E R                            *
*                                                                     *
***********************************************************************
         SPACE 1
NQ230    LTR   NQSE,NQSE           IF NODAL WARM START,              R4
         BZ    NQ245                BR TO TEST FOR XBM
         IC    R0,JQEFLAGS         ISOLATE SYSTEM ID
         N     R0,=A(QUEBUSY)       (IF ANY)
         CLI   JQETYPE,$PURGE      TEST FOR JOB IN/AWAITING PURGE
         BNE   NQ235               BR IF NO
         CLM   R0,1,QSESIBSY       IF NOT PURGING ON THIS SYSTEM,
         BNE   NQ640                BR TO TEST NEXT JQE
         B     NQ620                 ELSE RE-QUEUE JOB FOR PURGE
         SPACE 1
NQ235    TM    JQEFLAGS,QUEBUSY    IF JOB
         BZ    *+12                 ACTIVE ON
         CLM   R0,1,QSESIBSY         ANOTHER SYSTEM,
         BNE   NQ260                  BR TO READ THE JCT
         TM    JQETYPE,$XEQ        WAS JOB CONVERTING/EXECUTING...
         BZ    NQ260               BR IF BEYOND THAT TO READ THE JCT
         TM    NQSTAT,NQRESTRT     TEST FOR JES2 RESTART             R4
         BZ    NQ245               BR IF NO
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        R E - S T A R T I N G   - -   T E S T   F O R   S J B        *
*                                                                     *
***********************************************************************
         SPACE 1
         BAL   WE,NQSJBLOC         TRY TO LOCATE SJB FOR JOB
         LTR   WA,WA               TEST FOR SJB
         BZ    NQ245               BR IF NOT FOUND
         LA    R0,$SVJPNUM         IF STARTING STC
         CL    R0,SJBQUEUE          OR TSU JOB,
         BE    NQ590                 BR TO REQUEUE JOB
         LA    R0,$SVJXNUM         IS SJB FOR AN                     R4
         CL    R0,SJBQUEUE          EXECUTING STC JOB                R4
         BNE   NQ237               BR IF NOT                         R4
         TM    SJBPSOP,X'80'       IS SJB FOR XWTR WAITING ON JOT    R4
         BZ    NQ237               NO, BRANCH                        R4
         IC    R1,$WTRWTCT         YES, GET WTR WAIT COUNT           R4
         LA    R1,1(,R1)            INCREMENT                        R4
         STC   R1,$WTRWTCT          RESTORE COUNT                    R4
NQ237    MVC   JQETRAK,SJBJCTRK    GUARANTEE                         R4
         ST    NQ,SJBJQE            LATEST JOB
         IC    R0,SJBJCLAS           INFORMATION
         N     R0,=A(QUECLASS)        IN SJB
        $QPUT  (NQ),(R0)               AND IN JQE
         OC    JQEFLAGS,$SIDBUSY   THEN SHOW JOB EXECUTING
         CLC   JQEJOBNO,=H'10000'  IF EXECUTING BY CLASS,
         BL    *+12                 BR TO BUMP ACTIVE COUNT
         TM    JQEFLAG2,QUEINIT    IF SYSTEM LOG OR INITIATOR,
         BO    NQ240                DON'T BUMP ACTIVE COUNT
        $ACTIVE                    INDICATE PROCESSOR ACTIVE
         EJECT
NQ240    ST    NQJCT,PCEBUFAD      SET BUFFER ADDRESS FOR $EXCP      R4
         L     R1,JQETRAK          GET JCT TRACK ADDRESS             R4
         BAL   WE,NQREAD            AND READ IN THE JCT              R4
         L     R15,$SSVT           POINT TO SSVT                     R4
         TM    $SVSTUS,$SVSTXST    IF NOT MONITORING TIME EXCESSIONS
         BZ    NQ270                BR TO TEST FOR SPIN IOTS
         LA    R0,$SVJXCLS         IF JOB NOT
         CL    R0,SJBQUEUE          STILL EXECUTING,
         BNE   NQ270                 BR TO TEST FOR SPIN IOTS
         L     R14,JCTETIME        IF TIME ESTIMATE
         C     R14,=A(24*60*60)     WAS 24 HOURS,
         BNL   NQ270                 BR TO TEST FOR SPIN IOTS
         SPACE 1
***********************************************************************
*                                                                     *
*        R E S U M E   T I M E   E X C E S S I O N   T E S T I N G    *
*                                                                     *
***********************************************************************
         SPACE 1
         L     R0,$XTIMPCE         STORE PCE ADDRESS                 R4
         ST    R0,SJBSTQE+IPOST     IN TQE
         OI    SJBSTQE+IPOST,X'80' PRE-POST TQE
         TIME  BIN                 GET CURRENT DATE AND TIME
         CL    R1,JCTXDTON         ADJUST TIME-OF-DAY
         LR    R1,R0                FOR
         BE    *+8                   NEW
         AL    R1,=A(100*60*60*24)    DAY
         SLR   R0,R0               CLEAR FOR DIVIDE
         SL    R1,JCTXEQON         COMPUTE TIME IN
         D     R0,=A(100)           EXECUTION IN SECONDS
         SR    R1,R14              IF ORIGINAL TIME
         ST    R1,SJBXSTIM          INTERVAL NOT ELAPSED,
         BNP   NQ270                 BR TO TEST FOR SPIN IOTS
         SLR   R0,R0               COMPUTE EXCESSION TIME
         D     R0,=A(60)            IN MINUTES
         ST    R1,SJBXSTIM         STORE IN CASE INTEGRAL MINUTES
         LTR   R0,R0               IF INTEGRAL NUMBER OF MINUTES,
         BZ    NQ270                BR TO TEST FOR SPIN IOTS
         LA    R1,1(,R1)             ELSE UPDATE
         ST    R1,SJBXSTIM            EXCESSION TIME
         LA    R1,60               STORE TIME
         SLR   R1,R0                REMAINING
         ST    R1,SJBSTQE+ITIME      IN MINUTE
        $STIMER  SJBSTQE              AND ISSUE $STIMER
         B     NQ270               THEN BR TO TEST FOR SPIN IOTS
         SPACE 1                                                     R4
         DROP  WA                  KILL SJB ADDRESSABILITY
         EJECT
NQ245    TM    JQETYPE,$XEQ        IF JOB BEYOND EXECUTION,
         BZ    NQ260                BR TO READ THE JCT
         TM    JQEFLAGS,QUEBUSY    IF JOB
         BZ    *+12                 ACTIVE
         CLI   JQETYPE,$XEQ          IN EXECUTION,
         BNE   NQ260                  BR TO READ THE JCT
         LTR   NQSE,NQSE           IF NODAL WARM START,              R4
         BZ    *+16                 BR TO TEST FOR XBM
         IC    R1,QSESIAFF         IF JOB DOES NOT HAVE
         EX    R1,NQTSTAFF          AFFINITY TO THIS SYSTEM,
         BZ    NQ260                 BR TO READ THE JCT
         CLC   JQEJOBNO,=H'10000'  IF STC OR TSU JOB,
         BH    NQ250                BR TO RE-QUEUE JOB FOR PURGE
         ST    NQJCT,PCEBUFAD        ELSE
         L     R1,JQETRAK             READ
         BAL   WE,NQREAD               THE JCT
         TM    JCTJBOPT,JCTXBACH   IF NOT XBM JOB,
         BZ    NQ270                BR TO TEST FOR SPIN IOTS
         IC    R0,JCTJCLAS           ELSE REQUEUE
         N     R0,=A(QUECLASS)        JOB FOR
        $QPUT  (NQ),(R0)               EXECUTION
         BAL   WE,NQRELSE          THEN RELEASE ANY DUPLICATE JOBS
         B     NQ270                AND BR TO TEST FOR SPIN IOTS
         SPACE 1
NQ250    NI    JQEFLAG2,255-QUEINIT  RESET INIT BIT
         SPACE 1
NQ255    LTR   NQSE,NQSE           IF SINGLE SYSTEM WARM START,
         BNZ   NQ620                BR TO QUEUE JOB FOR PURGE
        $QPUT  (NQ),$PURGE           ELSE DO IT HERE
         SPACE 1
***********************************************************************
*                                                                     *
*        R E A D   I N   J C T   F O R   J O B                        *
*                                                                     *
***********************************************************************
         SPACE 1
NQ260    ST    NQJCT,PCEBUFAD      SET BUFFER ADDRESS FOR $EXCP
         L     R1,JQETRAK          GET JCT TRACK ADDRESS
         BAL   WE,NQREAD            AND READ IN THE JCT
         SPACE 1
***********************************************************************
*                                                                     *
*        T E S T   F O R   S P I N   I O T ( S )                      *
*                                                                     *
***********************************************************************
         SPACE 1
NQ270    ICM   R1,15,JCTSPIOT      IF NO SPIN IOTS,
         BZ    NQ530                BR TO CONCLUDE JOB PROCESSING
         EJECT
***********************************************************************
*                                                                     *
*        R E M O V E   H Q R   I N - U S E   L O C K S                *
*                                                                     *
***********************************************************************
         SPACE 1
         SLR   NQIOT,NQIOT         INDICATE NO IOT BUFFER
         ST    NQIOT,NQHOLDQ        AND NO HOLD DATA SET REQUESTS
         L     R1,JCTHQT           POINT TO 1ST HQT FOR JOB
         ST    R1,NQHQTRK          SAVE HQT TRACK ADDRESS
         ST    NQHQT,PCEBUFAD      SET BUFFER ADDRESS FOR $EXCP
         LTR   R1,R1               IF VALID HQT ADDRESS,
         BNZ   NQ280                BR TO READ IT IN
         BAL   WE,NQHQTCK            ELSE CREATE DUMMY HQT
         B     NQ300                  AND BR TO RESTORE IOT TRK ADDR
         SPACE 1
         USING HQRDSECT,WA         PROVIDE HQR ADDRESSABILITY
         SPACE 1
NQ280    BAL   WE,NQREAD           READ IN THE HQT
         TM    NQSTAT,NQRESTRT     TEST FOR JES2 RESTART             R4
         BO    NQ300               BR IF YES                         R4
         LA    WA,HQTHQR-HQRLENG   PREPARE TO SCAN HQT
         L     R1,HQTHQRP           FOR HQRS REPRESENTING
         ALR   R1,NQHQT              IN-USE HELD DATA SETS
         SPACE 1
NQ290    LA    WA,HQRLENG(,WA)     POINT TO NEXT HQR
         CLR   WA,R1               IF NO MORE HQRS,
         BE    NQ300                BR TO TEST FOR ANOTHER HQT
         TM    HQRSTAT,HQRINUSE    IF DATA SET NOT IN USE,
         BZ    NQ290                BR TO TEST NEXT HQR
         LTR   NQSE,NQSE           IF NODAL WARM START,              R4
         BZ    *+20                 BR TO RESET IN-USE LOCK
         IC    R0,HQRSTAT          IF NOT
         N     R0,=A(QUEBUSY)       SYSTEM BEING
         CLM   R0,1,QSESIBSY         WARM STARTED,
         BNE   NQ290                  BR TO TEST NEXT HQR
         NI    HQRSTAT,255-HQRINUSE    ELSE RESET LOCK
         OI    HQTFLAG1,HQT1CKPT        AND REQUEST HQT CHECKPOINT
         B     NQ290               THEN BR TO TEST NEXT HQR
         SPACE 1
NQ300    L     R1,JCTSPIOT         RESTORE SPIN IOT TRACK ADDRESS
         ICM   R0,15,HQTHQT        IF END OF HQT CHAIN,
         BZ    NQ310                BR TO READ 1ST SPIN IOT
         TM    HQTFLAG1,HQT1CKPT   IF HQT NOT UPDATED,
         BZ    *+8                  BR TO AVOID CHECKPOINT
         BAL   WE,NQHQTWR            ELSE RE-WRITE CURRENT HQT
         L     R1,HQTHQT           THEN RE-LOAD ADDRESS OF NEXT HQT
         B     NQ280                AND BR TO READ THE HQT
         SPACE 1
         DROP  WA                  KILL HQR ADDRESSABILITY
         EJECT
NQ310    LTR   NQSE,NQSE           IF NODAL WARM START,              R4
         BZ    NQ320                BR TO READ 1ST SPIN IOT
         TM    JQETYPE,$XEQ        IF JOB
         BZ    NQ500                NOT
         CLI   JQETYPE,$XEQ          EXECUTING
         BE    NQ500                  ON
         IC    R0,JQEFLAGS             WARM
         N     R0,=A(QUEBUSY)           STARTING
         CLM   R0,1,QSESIBSY             SYSTEM,
         BNE   NQ500                      BR TO TEST FOR HOLD REQ'S
         SPACE 1
NQ320    LTR   NQIOT,NQIOT         IF HAVE IOT BUFFER,
         BNZ   NQ340                BR TO READ THE SPIN IOT
         ST    R1,NQIOTTR            ELSE SAVE SPIN IOT TRACK ADDR
         LH    R0,$BUFLENG            AND GET CSA STORAGE            R4
         GETMAIN RC,LV=(0),SP=231      FOR SPIN IOT BUFFER
         LR    NQIOT,R1            RE-LOAD BUFFER ADDRESS
         LTR   R15,R15             IF GETMAIN SUCCESSFUL,
         BZ    NQ330                BR TO READ THE SPIN IOT
         LA    R1,NQCORE             ELSE SET 'AWAITING STORAGE' MSG R4
         BAL   WE,NQWTO               AND INFORM THE OPERATOR
         LA    R0,30               THEN $WAIT
         BAL   WA,NQSTIMER          FOR 30 SECONDS,
         L     R1,NQIOTTR            RESTORE SPIN IOT TRACK ADDRESS,
         SLR   NQIOT,NQIOT            SHOW NO IOT BUFFER,
         B     NQ320                   AND BR TO TRY AGAIN
         SPACE 1                                                     R4
NQ330   $BFRBLD (R1)               CONSTRUCT IOB WITHIN IOT BUFFER
         L     R1,NQIOTTR          RESTORE SPIN IOT TRACK ADDRESS
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        R E A D   I N   S P I N   I O T                              *
*                                                                     *
***********************************************************************
         SPACE 1
         USING PDBDSECT,WA         PROVIDE PDDB ADDRESSABILITY
         SPACE 1
NQ340    ST    NQIOT,PCEBUFAD      SET BUFFER ADDRESS FOR $EXCP
         BAL   WE,NQREAD            AND READ IN THE SPIN IOT
         LR    WA,NQIOT            POINT TO                          R4
         AL    WA,$IOTPDDB          DATA SET PDDB                    R4
         TM    PDBFLAG1,PDB1NULL+PDB1NSOT  IF DATASET NOT PRINTABLE,
         BNZ   NQ480                        BR TO GET NEXT SPIN IOT
         CLI   JQETYPE,$PURGE      IF JOB PURGING,
         BE    NQ480                BR TO GET NEXT SPIN IOT
         LR    R0,NQ               GET OFFSET                        R4
         SL    R0,$JOBQPTR          OF JQE                           R4
         CL    R0,IOTJQOFF         IF DATA SET WAS UNALLOCATED,      R4
         BE    NQ345                BR TO SEARCH FOR JOE/HQR         R4
         TM    NQSTAT,NQRESTRT     IF JES2 RESTART,                  R4
         BO    NQ490                BR TO GET NEXT IOT               R4
         TM    JCTJOBFL,JCTNOJNL   IF JOB WAS JOURNALLED,            R4
         BZ    NQ480                BR TO ALLOCATE DATA SET'S TRACKS R4
         B     NQ470                 ELSE BR TO SPIN DATA SET        R4
         SPACE 1
***********************************************************************
*                                                                     *
*        T R Y   T O   F I N D   J O E   F O R   D A T A   S E T      *
*                                                                     *
***********************************************************************
         SPACE 1
         USING JOEDSECT,R1         PROVIDE JOE ADDRESSABILITY
         USING JOTDSECT,R14        PROVIDE JOT ADDRESSABILITY
         SPACE 1
NQ345    L     R14,$JOTABLE        GET ADDRESS OF JOT                R4
         L     R0,IOTTRACK         GET TRACK ADDRESS FOR JOT SCAN
         SLR   R15,R15             INITIALIZE FOR JOT SCAN
         MVI   NQJOE,0             INDICATE NO JOE FOR DATA SET
         SPACE 1
NQ350    LA    R15,2(,R15)         GET OFFSET OF NEXT CLASS QUEUE
         LA    R1,JOTRDYWQ-2-(JOENEXT-JOEDSECT)(R15) AND POINT TO IT R4
         SPACE 1
NQ360    LH    R1,JOENEXT          GET OFFSET OF NEXT WORK JOE
         N     R1,=X'0000FFFF'     TEST FOR END OF CLASS QUEUE
         BNZ   NQ370               BR IF NO
         C     R15,NQMAXQ          IF ANOTHER CLASS QUEUE,
         BL    NQ350                BR TO SCAN IT
         B     NQ400                 ELSE BR TO TEST OUTPUT REQ'TS
         SPACE 1
NQ370    SLL   R1,2                IF JOE                            R4
         ALR   R1,R14               DOESN'T REPRESENT
         CL    R0,JOEIOTTR           CURRENT SPIN DATA SET
         BNE   NQ360                  BR TO TEST NEXT JOE
         EJECT                                                       R4
         TM    JOEFLAG,$JOEBUSY    IF DATA SET PRINTING/PUNCHING,
         BNZ   NQ400               BR TO TEST HOLD REQ'T
         SPACE 1
***********************************************************************
*                                                                     *
*        F O U N D   S P I N   J O E   F O R   D A T A   S E T        *
*                                                                     *
***********************************************************************
         SPACE 1
         TM    JQEFLAGS,QUEPURGE   IF JOB BEING KILLED,
         BO    *+12                 BR TO REMOVE THE JOE
         TM    PDBFLAG1,PDB1PSO    IF JOT CURRENT,
         BO    NQ380                BR TO TEST IOT VALIDITY
        $#REM  WORK=(R1)             ELSE REMOVE JOE FROM JOT        R4
         B     NQ400               THEN BR TO TEST HOLD REQ'T
         SPACE 1
NQ380    MVI   NQJOE,255           INDICATE JOE EXISTS FOR DATA SET
         TM    PDBFLAG1,PDB1HOLD   IF IOT VALID,
         BZ    NQ400                BR TO TEST HOLD REQ'T
         NI    PDBFLAG1,255-PDB1HOLD  ELSE INDICATE
         OI    PDBFLAG1,PDB1PSO        DATA SET IN JOT
         L     R1,IOTTRACK         GET IOT TRACK ADDRESS
         BAL   WE,NQWRITE           AND RE-WRITE THE IOT
         SPACE 1
         DROP  R1,R14              KILL JOE, JOT ADDRESSABILITY      R4
         EJECT
NQ400    TM    NQSTAT,NQRESTRT     IF WARM STARTING JES2,            R4
         BZ    NQ410                BR TO QUEUE SPIN/HOLD REQUEST    R4
         SPACE 1
***********************************************************************
*                                                                     *
*        R E S T A R T   - -   T E S T   S P I N / H O L D   Q U E    *
*                                                                     *
***********************************************************************
         SPACE 1
         L     R15,$SSVT           POINT TO SSVT                     R4
         LR    R0,NQ                        PREPARE
         SL    R0,$JOBQPTR                   TO SCAN
         LA    R14,$SVSPIOT-(IOTIOT-IOTDSECT) SPIN/HOLD              R4
         LH    R15,PDBDSKEY                    REQUEST QUEUE         R4
         ST    R15,PCER15          SAVE DATA SET NUMBER              R4
         L     R1,$IOTPDDB         PROVIDE OFFSET TO SPIN IOT PDDB   R4
         SPACE 1
         DROP  WA                  KILL PDDB ADDRESSABILITY          R4
         USING IOTDSECT,R14        PROVIDE LOCAL IOT ADDRESSABILITY
         SPACE 1
NQ405    ICM   R14,15,IOTIOT       IF END OF QUEUE,
         BZ    NQ410                BR TO QUEUE SPIN/HOLD REQUEST    R4
         CL    R0,IOTJQOFF                  IF DATA SET
         BNE   NQ405                         NOT REPRESENTED
         CH    R15,PDBDSKEY-PDBDSECT(R1,R14)  ON REQUEST QUEUE,      R4
         BNE   NQ405                           LOOP
         B     NQ490                            ELSE GET NXT SPN IOT
         SPACE 1
         DROP  R14                 KILL LOCAL IOT ADDRESSABILITY
         EJECT
***********************************************************************
*                                                                     *
*        T R Y   T O   F I N D   H Q R   F O R   D A T A   S E T      *
*                                                                     *
***********************************************************************
         SPACE 1
NQ410    TM    HQTFLAG1,HQT1HQT1   IF 1ST HQT IN STORAGE,            R4
         BO    NQ420                BR TO SCAN FOR HQR
         TM    HQTFLAG1,HQT1CKPT   IF HQT NOT UPDATED,
         BZ    SKIP80               BR TO AVOID CHECKPOINT           R4
         BAL   WE,NQHQTWR            ELSE RE-WRITE CURRENT HQT
SKIP80   L     R1,JCTHQT           POINT TO 1ST HQT FOR JOB
         ST    R1,NQHQTRK          SAVE HQT TRACK ADDRESS
         ST    NQHQT,PCEBUFAD      SET BUFFER ADDRESS FOR $EXCP
         BAL   WE,NQREAD            AND READ IN THE HQT
         SPACE 1
NQ420    LA    WA,HQTHQR-HQRLENG   PREPARE
         L     R1,HQTHQRP           TO SCAN
         ALR   R1,NQHQT              HQRS
         LR    R15,NQIOT           POINT TO                          R4
         AL    R15,$IOTPDDB         PDDB                             R4
         LH    R0,PDBDSKEY-PDBDSECT(,R15)  GET DATA SET NUMBER       R4
         SPACE 1
         USING HQRDSECT,WA         PROVIDE HQR ADDRESSABILITY
         SPACE 1
NQ430    LA    WA,HQRLENG(,WA)     POINT TO NEXT HQR
         CLR   WA,R1               IF END OF HQRS,
         BE    NQ460                BR TO TEST FOR ANOTHER HQT
         CH    R0,PDBDSKEY-PDBDSECT+HQRPDDB  IF NOT OUR HQR,         R4
         BNE   NQ430                          LOOP
         TM    HQRSTAT,HQRINUSE    IF DATA SET IN USE,
         BNZ   NQ490                BR TO GET NEXT SPIN IOT
         TM    HQRSTAT,HQRUNHLD    IF DATA SET NO LONGER HELD,
         BO    NQ450                BR TO TEST SPIN REQ'T
         TM    PDBFLAG1-PDBDSECT(R15),PDB1HOLD+PDB1PSO  TEST PDDB    R4
         BNO   NQ440               BR IF SHOULD UNHOLD HQR
         TM    JQEFLAGS,QUEPURGE   IF JOB BEING KILLED,
         BO    *+12                 BR TO UNHOLD THE DATA SET
         CLI   NQJOE,0             IF NO JOE FOR DATA SET,
         BE    NQ480                BR TO ALLOCATE ITS TRACKS
         NI    PDBFLAG1-PDBDSECT(R15),255-PDB1HOLD  ELSE UNHOLD      R4
         SPACE 1
NQ440    OI    HQRSTAT,HQRUNHLD    SHOW DATA SET UN-HELD
         OI    HQTFLAG1,HQT1CKPT    AND FLAG HQT FOR CHECKPOINT
         LH    R0,JQEHLDCT            DECREMENT
         N     R0,=A(X'FFFF'-QUEBUSY)  JOB
         BZ    NQ450                    HOLD
         LH    R0,JQEHLDCT               COUNT
         SL    R0,=A(X'10')               (IF
         STH   R0,JQEHLDCT                 NECESSARY)
        $QCKPT (NQ)                THEN FORCE CHECKPOINT OF JQE
         EJECT
         USING PDBDSECT,WA         PROVIDE PDDB ADDRESSABILITY       R4
         SPACE 1                                                     R4
NQ450    CLI   NQJOE,0             IF JOE EXISTS FOR DATA SET,
         BNE   NQ480                BR TO ALLOCATE ITS TRACKS
         LR    WA,NQIOT            POINT TO                          R4
         AL    WA,$IOTPDDB          DATA SET PDDB                    R4
         TM    PDBFLAG1,PDB1PSO    IF DATA SET SPUN/DELETED,         R4
         BZ    NQ480                BR TO ALLOCATE ITS TRACKS        R4
         TM    PDBFLAG1,PDB1HOLD   IF DATA SET SHOULD BE SPUN,       R4
         BZ    NQ470                BR TO SPIN IT                    R4
         MVC   IOTIOT,NQHOLDQ       ELSE ADD HOLD REQUEST
         ST    NQIOT,NQHOLDQ         TO TEMPORARY REQUEST QUEUE
         TM    IOTFLAG1,IOT1ALOC   IF NOT ALLOCATION IOT,
         BZ    *+8                  BR TO GET NEXT SPIN IOT
         BAL   WE,NQALLOC            ELSE ALLOCATE DATA SET'S TRACKS
         L     R1,IOTIOTTR         GET TRACK ADDR OF NEXT SPIN IOT
         SLR   NQIOT,NQIOT         INDICATE NO IOT BUFFER
         LTR   R1,R1               IF ANOTHER SPIN IOT,
         BNZ   NQ320                BR TO READ IT IN
         B     NQ500                 ELSE BR TO TEST FOR HOLD REQ'S
         SPACE 1
NQ460    ICM   R1,15,HQTHQT        IF NO MORE HQTS,
         BZ    NQ450                BR TO TEST SPIN/HOLD REQ'TS
         ST    R1,NQHQTRK            ELSE SAVE HQT TRACK ADDRESS
         ST    NQHQT,PCEBUFAD      SET BUFFER ADDRESS FOR $EXCP     R41
         BAL   WE,NQREAD           THEN READ IN THE HQT
         B     NQ420                AND BR TO RESUME HQR SCAN
         SPACE 1
NQ470    LR    R1,NQ               STORE
         SL    R1,$JOBQPTR          JQE OFFSET
         ST    R1,IOTJQOFF           IN SPIN IOT
         NI    PDBFLAG1,255-PDB1PSO  INDICATE DATA SET ON            R4
         OI    PDBFLAG1,PDB1HOLD      SPIN QUEUE (NOT IN JOT)        R4
         MVC   IOTSPIOT,$UNSPUNQ   LIFO QUEUE IOT
         L     R1,IOTTRACK          TO SPIN QUEUE
         ST    NQIOT,PCEBUFAD        USING
         BAL   WE,NQWRITE             'COMPARE AND SWAP'
         CLC   IOTSPIOT,$UNSPUNQ   IF QUEUE HEAD CHANGED,
         BNE   NQ470                BR TO REQUEUE IOT
         MVC   $UNSPUNQ,IOTTRACK     ELSE UPDATE QUEUE HEAD
         LA    R1,1                   AND BUMP
         AH    R1,JQEJOECT             JOE
         STH   R1,JQEJOECT              COUNT
        $QCKPT (NQ)                THEN FORCE CHECKPOINT OF JQE
         SPACE 1                                                     R4
         DROP WA                   KILL PDDB ADDRESSABILITY          R4
         EJECT
NQ480    TM    IOTFLAG1,IOT1ALOC   IF NOT ALLOCATION IOT,
         BZ    *+8                  BR TO GET NEXT SPIN IOT
         BAL   WE,NQALLOC          ALLOCATE TRACKS IN IOT BIT MAP
         SPACE 1
NQ490    ICM   R1,15,IOTIOTTR      IF ANOTHER SPIN IOT,
         BNZ   NQ320                BR TO READ IT IN
         SPACE 1
***********************************************************************
*                                                                     *
*        N O   M O R E   S P I N   I O T S                            *
*                                                                     *
***********************************************************************
         SPACE 1
         LH    R0,$BUFLENG         FREE                              R4
         ICM   R0,8,=AL1(231)       CURRENT
         LR    R1,NQIOT              IOT
         FREEMAIN R,LV=(0),A=(1)      BUFFER
         SPACE 1
NQ500    L     R15,$SSVT           POINT TO SSVT                     R4
         MVC   NQDBL(4),$SVHOLDQ   SAVE CURRENT HOLD QUEUE HEAD      R4
         XC    $SVHOLDQ,$SVHOLDQ   ZERO CURRENT HOLD QUEUE HEAD
         SPACE 1
NQ505    ICM   NQIOT,15,NQHOLDQ    IF NO HOLD REQUESTS,
         BZ    NQ510                BR TO TEST FOR HQT UPDATE
         TM    IOTFLAG1,IOT1NTPR   WAS IOT PROCESSED...        @OZ25953
         BZ    NQCNTOK             BR IF YES, DON'T COUNT TWICE@OZ25953
         ST    NQIOT,PCEBUFAD      SET BUFFER ADDR. FOR $EXCP  @OZ25953
        $BFRBLD (NQIOT)            BUILD IOB IN THE IOT        @OZ25953
         NI    IOTFLAG1,255-IOT1NTPR  RESET NOT PROCESSED FLAG @OZ25953
         L     R1,IOTTRACK         GET SEEK ADDRESS FOR $EXCP  @OZ25953
         BAL   WE,NQWRITE          RE-WRITE IOT                @OZ25953
         TM    BUFECBCC-BUFDSECT(NQIOT),X'7F'  GOOD WRITE...   @OZ25953
         BM    NQ505               BR IF NO, BAD IOT           @OZ25953
         LH    R1,JQEHLDCT           ELSE BUMP
         AL    R1,=A(X'10')           HOLD
         STH   R1,JQEHLDCT             COUNT
        $QCKPT (NQ)                     AND FORCE CHECKPOINT OF JQE
NQCNTOK  DS    0H                                              @OZ25953
         L     R15,$SSVT           POINT TO SSVT                     R4
         MVC   NQHOLDQ,IOTIOT               THEN PREPARE TO
         LH    R0,IOTHQRCT                   QUEUE REQUEST TO
         LA    WA,$SVHOLDQ-(IOTIOT-IOTDSECT)  OFFICIAL HOLD RQST Q
         SPACE 1
         LR    WE,WA                     LOCATE APPROPRIATE
         ICM   WA,15,IOTIOT-IOTDSECT(WE)  QUEUE POSITION
         BZ    *+12                        USING
         CH    R0,IOTHQRCT-IOTDSECT(,WA)    ORDER OF
         BH    *-14                          UNALLOCATION
         SPACE 1
         ST    NQIOT,IOTIOT-IOTDSECT(,WE)  QUEUE NEW
         ST    WA,IOTIOT                    HOLD REQUEST AND LOOP
         B     NQ505                         UNTIL ALL REQUESTS Q'D
         SPACE 1
NQ510    LA    R1,$SVHOLDQ-(IOTIOT-IOTDSECT)  PREPARE TO SCAN QUEUE
         SPACE 1
         LR    NQIOT,R1            CHAIN TO
         ICM   R1,7,IOTIOT+1        END OF
         BNZ   *-6                   HOLD QUEUE
         SPACE 1
         MVC   IOTIOT,NQDBL        ADD PRIOR ELEMENTS TO END OF Q
         EJECT
***********************************************************************
*                                                                     *
*        T E S T   L O C A L   H O L D   Q U E U E                    *
*                                                                     *
***********************************************************************
         SPACE 1
NQ515    TM    HQTFLAG1,HQT1CKPT   IF HQT NOT UPDATED,
         BZ    *+8                  BR TO AVOID CHECKPOINT
         BAL   WE,NQHQTWR            ELSE RE-WRITE CURRENT HQT
         L     R15,$SSVT           POINT TO SSVT                     R4
         ICM   NQIOT,15,$SVHOLDQ   IF NO
         BZ    NQ530                REMAINING
         LR    R1,NQ                 HOLD REQUESTS
         SL    R1,$JOBQPTR            FOR
         CL    R1,IOTJQOFF             CURRENT JOB,
         BNE   NQ530                    BR TO READ 1ST REGULAR IOT
         MVC   NQDBL(1),JQEHQLOK     ELSE SAVE CURRENT
         NI    NQDBL,QUEBUSY          JOB HOLD QUEUE LOCK
         NI    JQEHQLOK,255-QUEBUSY    AND REMOVE LOCK FROM JQE
        $QCKPT (NQ)                FORCE CHECKPOINT OF JQE
         L     R1,$HOLDPCE         GET HOLD QUEUE PROCESSOR PCE ADDR R4
        $POST  (R1),WORK            AND WAKE HIM UP
         SPACE 1
NQ520   $WAIT  ABIT                $WAIT A LITTLE WHILE
        $QSUSE                     REQUEST ACCESS TO CHECKPOINT DATA
         TM    JQEHQLOK,QUEBUSY    IF LOCK STILL HELD,
         BNZ   NQ520                BR TO $WAIT SOME MORE
         OC    JQEHQLOK,NQDBL        ELSE GRAB THE LOCK
        $QCKPT (NQ)                   AND FORCE CKPT OF JQE
         B     NQ515               THEN BR TO RETEST FOR HOLD REQ'S
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        P R O C E S S   1 S T   R E G U L A R   I O T                *
*                                                                     *
***********************************************************************
         SPACE 1                                                     R4
NQ530    LTR   NQSE,NQSE           IF NODAL WARM START,              R4
         BZ    NQ540                BR TO READ 1ST REGULAR IOT
         TM    JQEFLAGS,QUEBUSY    IF JOB
         BZ    NQ610                NOT
         IC    R0,JQEFLAGS           ACTIVE ON
         N     R0,=A(QUEBUSY)         WARM STARTED
         CLM   R0,1,QSESIBSY           SYSTEM,
         BNE   NQ640                    BR TO TEST NEXT JQE
         SPACE 1                                                     R4
NQ540    L     NQIOT,NQIOTBF       GET BUFFER ADDRESS FOR IOT
         ST    NQIOT,PCEBUFAD      SET BUFFER ADDRESS FOR $EXCP
         L     R1,JCTIOT           GET TRK ADDR OF 1ST REGULAR IOT
         BAL   WE,NQREAD            READ IT IN AND
         BAL   WE,NQALLOC            ALLOCATE ITS DATA SETS' TRACKS
         TM    JQETYPE,$XEQ        IF BEYOND EXECUTION,
         BZ    NQ590                BR TO REQUEUE THE JOB
         CLI   JQETYPE,$XEQ        IF JOB IN OR AWAITING CONVERSION,
         BE    NQ590                BR TO REQUEUE THE JOB
         TM    NQSTAT,NQRESTRT     IF RESTARTING JES2,               R4
         BO    NQ590                BR TO ISSUE 'WAS EXECUTING' MSG
         L     WE,$IOTPDDB           POINT TO                        R4
         LA    WE,IOTPDBOJ(WE,NQIOT)  JCL DATA SET PDDB              R4
         TM    PDBFLAG1-PDBDSECT(WE),PDB1NULL  TEST JCL FILE         R4
         BZ    NQ550               BR IF JCL STILL ALLOCATED
         OC    PDBMTTR-PDBDSECT(,WE),PDBMTTR-PDBDSECT(WE)            R4
         BZ    NQ550               BR IF NO JCL FILE (REQ JOB ID)
         LA    R1,NQTERM           SET 'WAS TERMINATING' MSG         R4
         BAL   WE,NQWTO             AND INFORM THE OPERATOR
         B     NQ585               THEN BR TO RE-QUEUE JOB           R4
         SPACE 1
NQ550    TM    JQEFLAGS,QUEBUSY    IF JOB AWAITING EXECUTION,
         BZ    NQ640                BR TO TEST NEXT JQE
         LA    R1,NQEXEC           SET 'WAS EXECUTING' MSG           R4
         BAL   WE,NQWTO             AND INFORM THE OPERATOR          R4
         MVI   JCTJSFLG,SSJSWARM   SET WARM START BIT                R4
         TM    JCTJOBFL,JCTNOJNL   IF JOB WAS JOURNALLED,            R4
         BZ    NQ580                BR TO RE-WRITE THE JCT           R4
         TM    JCTJOBFL,JCTRSTRT   IF JOB NOT RESTARTABLE,           R4
         BZ    NQ585                BR TO RE-QUEUE FOR OUTPUT        R4
         OI    JCTJBOPT,JCTRERUN   INDICATE RE-RUN REQUEST          R41
         MVI   JCTJSFLG,0          RESET RESTART FLAGS               R4
         XC    JCTJSSTP,JCTJSSTP    AND RESTART STEP IN JCT          R4
         XC    JCTLINES,JCTLINES   RESET LINE COUNT            @OZ29915
         XC    JCTPUNCH,JCTPUNCH   RESET PUNCH OUTPUT COUNT    @OZ29915
         XC    JCTXOUT,JCTXOUT     RESET TOTAL OUTPUT COUNT    @OZ29915
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        RE-QUEUE NON-JOURNALLED RESTARTABLE JOB FOR RE-EXECUTION     *
*                                                                     *
***********************************************************************
         SPACE 1                                                     R4
NQ555    LH    R0,JCTPDDBO         GET DD NUMBER OF 1ST OUTPUT PDDB  R4
         L     R1,$IOTPDDB         GET OFFSET OF 1ST PDDB IN IOT     R4
         SPACE 1                                                     R4
NQ560    CL    R1,IOTPDDBP         IF NO MORE PDDBS IN THIS IOT,     R4
         BNL   NQ570                BR TO TEST FOR ANOTHER IOT       R4
         CH    R0,PDBDSKEY-PDBDSECT(R1,NQIOT)  1ST OUTPUT PDDB...    R4
         BL    NQ565               BR IF YES (NO SYSIN DDS).   @OZ26726
         LA    R1,PDBLENG(,R1)     POINT TO NEXT PDDB IN ANY CASE    R4
         BH    NQ560               BR IF NOT LAST DD * / DATA  @OZ26726
NQ565    DS    0H                                              @OZ26726
         ST    R1,IOTPDDBP         RESET OFFSET IN IOT               R4
         XC    IOTIOTTR,IOTIOTTR   TRUNCATE IOT CHAIN                R4
         L     R1,IOTTRACK         GET TRACK ADDRESS OF IOT          R4
         BAL   WE,NQWRITE           AND RE-WRITE IT                  R4
         B     NQ580               THEN BR TO RE-WRITE THE JCT       R4
         SPACE 1                                                     R4
NQ570    ICM   R1,15,IOTIOTTR      GET TRACK ADDRESS OF NEXT IOT     R4
         BZ    NQ580               BR IF END OF IOT CHAIN            R4
         BAL   WE,NQREAD            ELSE READ IN THE IOT             R4
         B     NQ555                 AND RESUME SEARCH               R4
         SPACE 1                                                     R4
NQ580    ST    NQJCT,PCEBUFAD      SET BUFFER ADDRESS FOR $EXCP      R4
         L     R1,JQETRAK          GET TRACK ADDRESS OF JCT          R4
         BAL   WE,NQWRITE           AND RE-WRITE THE JCT             R4
         LA    R1,NQREQU           POINT TO 'JOB REQUEUED' MSG       R4
         BAL   WE,NQWTO             AND INFORM THE OPERATOR          R4
         TM    JCTJOBFL,JCTNOJNL   IF JOB WAS JOURNALLED,            R4
         BZ    NQ595                BR TO SET SYSTEM AFFINITY        R4
         BAL   WE,NQRELSE          RELEASE ANY DUPLICATE JOBS        R4
         B     NQ600               BR TO RE-QUEUE JOB FOR EXECUTION  R4
         EJECT                                                       R4
NQ585    BAL   WE,NQRELSE          RELEASE ANY DUPLICATE JOBS        R4
         CLC   JQEJOBNO,=H'10000'  IF BATCH JOB,
         BL    *+8                  BR AROUND NEXT INSTRUCTION
         NI    JQEFLAG2,255-QUEINIT  ELSE RESET INIT BIT
         LA    R0,1*16             STARTING PRIORITY = 1       @OZ27492
         TM    JCTJBOPT,JCTPRICD   /*PRIORITY, OR 'PRTY='...   @OZ27492
         BNO   NQ588               BRANCH IF NOT, USE '1'      @OZ27492
         CLI   JQEPRIO,13*16       CHECK FOR HIGH PRIORITY     @OZ27492
         BL    NQ588               BRANCH IF NOT, USE '1'      @OZ27492
         LA    R0,15*16            RESET PRIORITY TO MAX       @OZ27492
NQ588    DS    0H                                              @OZ27492
         STC   R0,JQEPRIO          SET NEW PRIORITY IN JQE     @OZ27492
        $QPUT  (NQ),$OUTPUT        THEN REQUEUE JOB FOR OUTPUT
         B     NQ640               THEN BR TO TEST NEXT JQE
         SPACE 1                                                     R4
NQ590    TM    JQEFLAGS,QUEBUSY    IF JOB NOT ACTIVE,
         BZ    NQ610                BR TO TEST JOB FOR PURGE
         TM    JQETYPE,$XEQ        IF JOB
         BZ    NQ600                NOT IN
         CLI   JQETYPE,$XEQ          EXECUTION,
         BE    NQ600                  BR TO REQUEUE JOB
         LA    R1,NQEXEC           SET 'WAS EXECUTING' MSG           R4
         BAL   WE,NQWTO             AND INFORM THE OPERATOR
         TM    NQSTAT,NQRESTRT     IF RESTARTING JES2,               R4
         BO    NQ640                BR TO TEST NEXT JQE
         SPACE 1                                                     R4
NQ595    NI    JQEFLAG2,255-QUESYSAF  ENSURE                         R4
         IC    R1,JQEFLAGS             JOB                           R4
         N     R1,=A(QUEBUSY)           RE-EXECUTED
         LA    R1,NQSYSAF(R1)            ON SAME
         OC    JQEFLAG2,0(R1)             SYSTEM
         BAL   WE,NQRELSE          THEN RELEASE ANY DUPLICATE JOBS
         EJECT                                                       R4
NQ600    IC    R0,JQETYPE          REQUEUE THE JOB
        $QPUT  (NQ),(R0)            FOR CURRENT PHASE
         SPACE 1
NQ610    LH    R0,JQEHLDCT         GET CURRENT
         SRL   R0,4                 HOLD COUNT
         AH    R0,JQEJOECT           AND ADD TO IT THE JOE COUNT
         BNZ   NQ640               BR IF SUM IS NOT ZERO
         CLI   JQETYPE,$HARDCPY    TEST FOR HARDCPY PHASE
         BNE   NQ640               BR IF NO TO TEST NEXT JQE
         SPACE 1
NQ620    NI    JQEFLAGS,255-QUEOPCAN-QUEPURGE  RESET FLAGS           R4
        $QPUT  (NQ),$PURGE         REQUEUE JOB FOR PURGE             R4
         SPACE 1
***********************************************************************
*                                                                     *
*        G E T   N E X T   J O B   Q U E U E   E N T R Y              *
*                                                                     *
***********************************************************************
         SPACE 1
NQ640    NI    JQEHQLOK,255-QUEBUSY  REMOVE JOB HOLD QUEUE LOCK
        $QCKPT (NQ)                   AND FORCE CHECKPOINT OF JQE
         SPACE 1                                                    R41
NQ650    LA    NQ,NQCHAIN-QUECHAIN PREPARE TO PROCESS NEXT JQE      R41
         LTR   NQSE,NQSE           IF NODAL WARM START,              R4
         BZ    NQ210                BR TO TEST NEXT JQE
         B     NQ200                 ELSE BR TO RE-SCAN JOB QUEUE
         SPACE 1
NQ660    L     NQ,NQQUEUE          IF END OF                         R4
         S     NQ,=F'2'             ACTIVE JOB QUEUES,
         BZ    NQ670                 BR TO TERMINATE WARM START     R41
         ST    NQ,NQQUEUE             ELSE PREPARE TO PROCESS
         LA    NQ,$JQHEADS-2-QUECHAIN(NQ)  NEXT JOB QUEUE
         B     NQ210               THEN BR TO DO IT
         EJECT                                                      R41
***********************************************************************
*                                                                     *
*    IF NODAL WARMSTART, RE-ALLOCATE OLD NEWS TRACKS, IF REQUIRED     *
*                                                                     *
***********************************************************************
         SPACE 1                                                    R41
NQ670    LTR   NQSE,NQSE           SINGLE SYSTEM WARM START...      R41
         BNZ   NQ700               EXIT IF YES                      R41
         OC    $NEWSIOT,$NEWSIOT   SEE IF 'OLD NEWS' EXISTS,        R41
         BZ    NQ700                 EXIT IF NOT                    R41
         OC    $NEWNEWS,$NEWNEWS   'NEW NEWS' SPECIFIED AT INIT...  R41
         BNZ   NQ700                 ALLOW OLD NEWS TO VANISH IF SO R41
         SPACE 1                                                    R41
*        NODAL WARM START, NO NEW NEWS -- RE-ALLOCATE OLD NEWS TRACKS
         SPACE 1                                                    R41
         L     NQIOT,NQIOTBF       POINT TO BUFFER WITH IOT REG     R41
         ST    NQIOT,PCEBUFAD      SET BUFFER ADDR FOR READ         R41
         MVI   PCEDEVTP,PCEDARD    SET DA DCT TO 'READ'             R41
         MVC   PCESEEK,$NEWSIOT    SET SEEK ADDRESS FOR READ        R41
         LA    R1,PCEDADCT         POINT TO DA DCT                  R41
        $EXCP  (R1),WAIT=YES       READ IN IOT, WAIT FOR COMPLETION R41
         BNO   NQNEWSX1            BRANCH IF READ ERROR             R41
         CLC   NQNIOTKY,IOTJBKEY   VALIDATE 'JOB' KEY               R41
         BE    NQ680               BRANCH IF NEWS IOT               R41
         SPACE 1                                                    R41
NQNEWSX1 $DISTERR                  INDICATE CONTROL BLOCK ERROR     R41
        $QSUSE                     OBTAIN CONTROL OF QUEUES         R41
         XC    $NEWSIOT(8),$NEWSIOT CLEAR OUT HCT POINTERS IF ERROR R41
        $POST  $HASPECF,CKPT       FORCE CHECKPOINT                 R41
         B     NQ700               EXIT FROM NEWS PROCESSING        R41
         SPACE 1                                                    R41
NQ680    BAL   WE,NQALLOC          ALLOCATE OLD NEWS' TRACKS AGAIN  R41
         B     NQ700               EXIT FROM NEWS PROCESSING        R41
         TITLE 'HASP JOB QUEUE WARM START -- SUPPORT ROUTINES'
***********************************************************************
*                                                                     *
*        $ W A I T   P R O C E S S O R   F O R   N   S E C O N D S    *
*                                                                     *
*                                                                     *
*              TIME INTERVAL PROVIDED IN R0                           *
*              RETURN CODE N/A                                        *
*                                                                     *
***********************************************************************
         SPACE 3
         CNOP  0,8
NQSTIMER LA    R1,NQTQE            POINT TO PROCESSOR TQE
         ST    R0,ITIME(,R1)       STORE TIME INTERVAL
         ST    SAVE,IPOST(,R1)     SET POST ADDRESS IN TQE
        $STIMER (R1)               ISSUE STIMER
        $WAIT  WORK                $WAIT FOR INTERVAL TO ELAPSE
         BR    WA                  THEN RETURN
         EJECT
***********************************************************************
*                                                                     *
*        R E A D / W R I T E   A   C T L   B L O C K                  *
*                                                                     *
*                                                                     *
*              SEEK ADDRESS PROVIDED IN R1                            *
*                                                                     *
***********************************************************************
         SPACE 1                                                     R4
NQREAD   MVI   PCEDEVTP,PCEDARD    INDICATE READ OPERATION
         B     NQEXCP               AND GO DO IT
         SPACE 1
NQHQTWR  NI    HQTFLAG1,255-HQT1CKPT  RESET CHECKPOINT FLAG
         ST    NQHQT,PCEBUFAD      SET BUFFER ADDRESS FOR $EXCP
         L     R1,NQHQTRK          LOAD HQT TRACK ADDRESS
         SPACE 1
NQWRITE  MVI   PCEDEVTP,PCEDAWR    INDICATE WRITE OPERATION
         SPACE 1
NQEXCP   ST    R1,PCESEEK          SET SEEK ADDRESS FOR $EXCP
         LA    R1,PCEDADCT         GET DIRECT ACCESS DCT ADDRESS
        $EXCP  (R1),WAIT=YES        AND READ/WRITE CTL BLOCK         R4
        $QSUSE                     REQUEST ACCESS TO CHECKPOINT DATA
         TM    BUFECBCC-BUFDSECT(R1),X'7F'  RE-TEST I/O COMPLETION
         BM    NQDSTER             BR IF READ/WRITE ERROR            R4
         CLR   R1,NQIOT            IF IOT READ WRITE,
         BE    NQCKIOT              BR TO TEST IOT VALIDITY
         CLR   R1,NQHQT            IF HQT READ/WRITE,
         BE    NQCKHQT              BR TO TEST HQT VALIDITY
         L     R0,JCTJQE             ELSE
         AL    R0,$JOBQPTR            VALIDATE
         CLR   R0,NQ                   JCT
         BER   WE                  RETURN IF NO ERROR
         B     NQDSTER              ELSE BR TO ISSUE ERROR MSG      R41
         SPACE 1
NQCKHQT  CLC   HQTJBKEY,JCTJBKEY   IF NOT VALID HQT,
         BNE   NQDSTER              BR TO ISSUE ERROR MSG           R41
         CLC   HQTID,=CL4'HQT'     IF NOT DUMMY HQT,
         BER   WE                   RETURN
         B     NQHQTCK               ELSE BR TO PREPARE EMPTY HQT
         SPACE 1
NQCKIOT  CLC   IOTJBKEY,JCTJBKEY   IF VALID IOT,
         BER   WE                   RETURN                           R4
         EJECT
***********************************************************************
*                                                                     *
*        I/O ERROR READING/WRITING CONTROL BLOCK                      *
*                                                                     *
***********************************************************************
         SPACE 1                                                     R4
NQDSTER $DISTERR                   ISSUE DISASTEROUS ERROR MSG
        $QSUSE                     REQUEST ACCESS TO CKPT DATA      R41
         CLI   PCEDEVTP,PCEDAWR    IF WRITE ERROR,
         BER   WE                   RETURN
         CL    NQJCT,PCEBUFAD      IF NOT THE JCT,
         BNE   NQHQTCK              BR TO TEST FOR HQT
         XC    JQEHLDCT,JQEHLDCT   CLEAR HOLD COUNT
         OI    JQEFLAGS,QUEPURGE+QUEOPCAN  FLAG JOB FOR PURGE
        $QCKPT (NQ)                         AND FORCE CKPT OF JQE
        $#CAN  JQE=(NQ)            KILL ANY JOES NOT BUSY
         TM    JQEFLAGS,QUEBUSY    IF JOB NOT ACTIVE,
         BZ    NQ610                BR TO TEST NEXT JQE
         LTR   NQSE,NQSE           IF NODAL WARM START,              R4
         BZ    NQ590                BR TO REQUEUE THE JOB
         IC    R0,JQEFLAGS         IF JOB
         N     R0,=A(QUEBUSY)       ACTIVE ON
         CLM   R0,1,QSESIBSY         WARM STARTED SYSTEM,
         BE    NQ590                  BR TO REQUEUE THE JOB
         B     NQ640                   ELSE BR TO TEST NEXT JQE
         EJECT                                                       R4
NQHQTCK  CL    NQHQT,PCEBUFAD      IF NOT AN HQT,
         BNE   NQBADIOT             BR TO PROCESS IOT ERROR
         MVI   HQTFLAG1,HQT1HQT1     ELSE
         LA    R0,HQTHQR-HQTDSECT     INITIALIZE
         ST    R0,HQTHQRP              TO LOOK LIKE
         XC    HQTHQT,HQTHQT            EMPTY HQT
         BR    WE                  THEN RETURN
         SPACE 1
NQBADIOT CLC   NQIOTBF,PCEBUFAD    TEST FOR SPIN IOT
         BNE   NQSPIOT             BR IF SO
         LA    R0,IOTTGMAP+TGMAP-TGMDSECT  ELSE POINT TO IOT BIT MAP R4
         L     R1,$CYLMAPL         CLEAR                             R4
         SLR   R15,R15              IOT                              R4
         MVCL  R0,R14                BIT MAP                         R4
         L     R1,$IOTPDDB         POINT TO                          R4
         ALR   R1,NQIOT             JCL DATA SET PDDB                R4
         NI    PDBFLAG1-PDBDSECT+IOTPDBOJ(R1),255-PDB1NULL SHOW NULL R4
         BR    WE                  THEN RETURN
         SPACE 1
NQSPIOT  XC    IOTIOTTR,IOTIOTTR   SHOW END OF SPIN IOT CHAIN
         MVI   IOTFLAG1,0          PREVENT TRACK ALLOCATION
         L     R1,$IOTPDDB         POINT TO                          R4
         ALR   R1,NQIOT             SPIN DATA SET PDDB               R4
         OI    PDBFLAG1-PDBDSECT(R1),PDB1NSOT  PREVENT SPIN/HOLD     R4
         BR    WE                  THEN RETURN
         EJECT
***********************************************************************
*                                                                     *
*        I S S U E   $ W T O   M E S S A G E                          *
*                                                                     *
***********************************************************************
         SPACE 1
NQWTO    MVC   NQMSG,0(R1)         MOVE MESSAGE TO WORK AREA         R4
         LH    R0,JQEJOBNO         CONVERT HASP JOB NUMBER
         CVD   R0,NQDBL             TO PACKED DECIMAL
         CH    R0,=H'10000'        IF BATCH JOB,
         BL    NQMVO                BR TO ISSUE MESSAGE
         MVC   NQMSGID,=C'STC'     ASSUME STARTED TASK               R4
         CH    R0,=H'20000'        IF STARTED TASK,
         BL    NQMVO                BR TO ISSUE MESSAGE
         MVC   NQMSGID,=C'TSU'     MUST BE LOGON                     R4
         SPACE 1
NQMVO    MVO   NQDBL(4),NQDBL+4(4)  OFFSET NUMBER BY 1
         MVC   NQJOBNR,NQEDMSK     EDIT HASP JOB NUMBER
         ED    NQJOBNR,NQDBL+1      INTO MESSAGE
         SLR   R0,R0               PICK UP
         IC    R0,NQMSGLN           MESSAGE LENGTH
        $WTO   NQMSGST,(R0),JOB=NO,ROUTE=$LOG+$MAIN,   ISSUE MESSAGE R4C
               PRI=$ST,CLASS=$ALWAYS,WAIT=YES           TO OPERATOR
        $QSUSE                     REQUEST ACCESS TO CHECKPOINT DATA
         SPACE 1
         BR    WE                  THEN RETURN
         EJECT
***********************************************************************
*                                                                     *
*        L O C A T E   S J B   F O R   E X E C U T I N G   J O B      *
*                                                                     *
***********************************************************************
         SPACE 1
         USING SJBDSECT,WA         PROVIDE SJB ADDRESSABILITY
         SPACE 1
NQSJBLOC LH    R0,JQEJOBNO         GET JOB NUMBER
         CVD   R0,PCER1             AND CONSTRUCT
         MVO   PCER1,PCER1+4         SJB-FORM
         MVC   NQDBL+3(5),NQEDMSK     JES2
         ED    NQDBL+3(5),PCER1+1      JOB ID                        R4
         L     R15,$SSVT           POINT TO SSVT                     R4
         MVC   NQDBL(3),=C'JOB'    ASSUME BATCH JOB
         CH    R0,=H'10000'        IF BATCH JOB,
         BL    NQJOB                BR TO SEARCH FOR SJB
         MVC   NQDBL(3),=C'STC'    ASSUME STARTED TASK
         CH    R0,=H'20000'        IF STARTED TASK,
         BL    *+10                 BR TO SEARCH FOR SJB
         MVC   NQDBL(3),=C'TSU'    MUST BE LOGON
         MVC   PCER1(8),NQDBL      CONSTRUCT ALTERNATIVE FORM
         OC    PCER1+3(5),=C'00000' OF JOB ID
         LA    WA,$SVJTERM-(SJBXQCHN-SJBDSECT)  TERMINATION QUEUE
         BAL   R14,NQSJBLUP        TRY TO LOCATE SJB ON ABOVE QUEUE
         LA    WA,$SVJXNUM-(SJBXQCHN-SJBDSECT)  IN XEQ-BY-NUM Q
         BAL   R14,NQSJBLUP        TRY TO LOCATE SJB ON ABOVE QUEUE
         LA    WA,$SVJPNUM-(SJBXQCHN-SJBDSECT)  PENDING XEQ-BY-NUM Q
         BAL   R14,NQSJBLUP        TRY TO LOCATE SJB ON ABOVE QUEUE
         LA    WA,$SVJRENQ-(SJBXQCHN-SJBDSECT)  PENDING RE-ENQUEUE Q
         BAL   R14,NQSJBLUP        TRY TO LOCATE SJB ON ABOVE QUEUE
         BR    WE                  RETURN HERE IF SJB NOT FOUND
         SPACE 1
NQJOB    MVC   PCER1(8),NQDBL      CONSTRUCT ALTERNATIVE FORM
         OC    PCER1+3(5),=C'00000' OF JOB ID
         LA    WA,$SVJTERM-(SJBXQCHN-SJBDSECT)  TERMINATION QUEUE
         BAL   R14,NQSJBLUP        TRY TO LOCATE SJB ON ABOVE QUEUE
         LA    WA,$SVJXCLS-(SJBXQCHN-SJBDSECT)  IN XEQ-BY-CLS Q
         BAL   R14,NQSJBLUP        TRY TO LOCATE SJB ON ABOVE QUEUE
         LA    WA,$SVJRENQ-(SJBXQCHN-SJBDSECT)  PENDING RE-ENQUEUE Q
         BAL   R14,NQSJBLUP        TRY TO LOCATE SJB ON ABOVE QUEUE
         BR    WE                  RETURN HERE IF SJB NOT FOUND
         SPACE 1
NQSJBLUP ICM   WA,15,SJBXQCHN      IF END OF SJB CHAIN,
         BZR   R14                  RETURN
         CLC   SJBJOBID,NQDBL      IF CURRENT JOB,
         BER   WE                  RETURN IF SO WITH SJB
         CLC   SJBJOBID,PCER1        ELSE TEST ALTERNATE FORM
         BNE   NQSJBLUP            BR IF NO TO TEST NEXT SJB
         BR    WE                   ELSE RETURN HERE WITH SJB
         EJECT
***********************************************************************
*                                                                     *
*        S U B R O U T I N E   T O   A L L O C A T E   T R A C K S    *
*                                                                     *
***********************************************************************
         SPACE 1
NQALLOC  LTR   NQSE,NQSE           IF NOT NODAL WARM START,          R4
         BNZR  WE                   IGNORE ALLOCATE REQUEST
         ST    WE,NQTQE            SAVE RETURN ADDRESS               R4
         LA    WE,IOTTGMAP+TGMAP-TGMDSECT  POINT TO IOT TRK GRP MAP  R4
         LR    R0,WE               MOVE                              R4
         L     R1,$CYLMAPL          IOT                              R4
         L     R14,NQCYLMAP          TRACK GROUP MAP                 R4
         LR    R15,R1                 TO                             R4
         MVCL  R14,R0                  WORK AREA                     R4
         L     R0,$CYLMAPL         RESET BITS                        R4
         L     R15,$TGMAP           IN IOT                           R4
        $VFL   NC,(WE),(R15),(R0)    TRACK GROUP MAP                 R4
         L     R0,$CYLMAPL         REMOVE BITS                       R4
         L     R1,$TGMAP            FROM MASTER                      R4
        $VFL   XC,(R1),(WE),(R0)     TRACK GROUP MAP                 R4
         L     R14,NQCYLMAP        TEST                              R4
         L     R15,$CYLMAPL         RESULTING                        R4
         LR    R0,WE                 IOT                             R4
         LR    R1,R15                 TRACK GROUP MAP                R4
         CLCL  R14,R0                  VALIDITY                      R4
         L     WE,NQTQE            RESTORE RETURN ADDRESS            R4
         BER   WE                  RETURN IF ALLOCATION SUCCESSFUL   R4
         LA    R1,NQIBAD             ELSE POINT TO 'BAD IOT' MSG     R4
         BAL   WE,NQWTO               AND INFORM THE OPERATOR
         L     R1,IOTTRACK         GET TRACK ADDRESS OF IOT
         L     WE,NQTQE            RESTORE RETURN ADDRESS
         ST    NQIOT,PCEBUFAD      SET BUFFER ADDRESS FOR $EXCP     R41
         B     NQWRITE             THEN RE-WRITE IOT AND RETURN
         EJECT
***********************************************************************
*                                                                     *
*        R E L E A S E   A N Y   D U P L I C A T E   J O B S          *
*                                                                     *
***********************************************************************
         SPACE 1
         CNOP  4,8
NQRELSE  LA    R15,72              PREPARE
         L     R1,=V($QINDEX)       TO SCAN
         LA    WA,C'A'-(255-QUECLASS)  EXECUTION
         IC    WA,0(R1,WA)              QUEUES
         SPACE 1
NQRNXTQ  ST    R15,NQDBL           SAVE CURRENT QUEUE OFFSET
         LA    R1,0(R15,WA)        POINT TO START
         LA    R1,$JQHEADS-4-QUECHAIN(R1)  OF NEXT QUEUE
         SPACE 1
NQNXTJQE LH    R1,QUECHAIN(,R1)    GET OFFSET
         N     R1,=X'0000FFFF'     OF NEXT JQE
         BZ    NQRENDQ             BR IF END OF CURRENT QUEUE
         SLL   R1,2                 ELSE CONVERT OFFSET
         AL    R1,$JOBQPTR           TO ABSOLUTE ADDRESS
         TM    QUEFLAGS(R1),QUEHOLD2  IF JOB NOT HELD,
         BZ    NQNXTJQE                BR TO TEST NEXT JQE
         CLC   JQEJNAME,QUEJNAME(R1)  IF NOT SAME JOB NAME,
         BNE   NQNXTJQE                BR TO TEST NEXT JQE
         NI    QUEFLAGS(R1),255-QUEHOLD2  ELSE RESET HOLD BIT
        $QCKPT (R1)                        AND FORCE CKPT OF JQE
         B     NQNXTJQE            THEN BR TO TEST NEXT JQE
         SPACE 1
NQRENDQ  L     R15,NQDBL           RESTORE CURRENT QUEUE OFFSET
         BCTR  R15,0               IF ANOTHER JOB QUEUE,
         BCT   R15,NQRNXTQ          BR TO SCAN IT
         BR    WE                    ELSE RETURN
         SPACE 1
         DROP  NQIOT,NQHQT         KILL IOT, HQT ADDRESSABILITY
         DROP  R15                 KILL SSVT ADDRESSABILITY          R4
         TITLE 'HASP JOB QUEUE WARM START'                           R4
NQMAXQ   DC    A(L'JOTRDYWQ)       MAXIMUM JOE QUEUE OFFSET          R4
         SPACE 1
NQTSTAFF TM    JQEFLAG2,0          *** EXECUTE ONLY ***
         SPACE 1
NQEDMSK  DC    X'4020202021'       HASP JOB NUMBER EDIT MASK
NQSYSAF  DC    X'0001020408102040' SYSTEM AFFINITY TABLE
         SPACE 1
NQCLSTBL DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'  JOT CLASSES
         SPACE 1
         DROP  WD                  KILL JQE ADDRESSABILITY
         TITLE 'HASP JOB QUEUE WARM START -- OPERATOR MESSAGES'
***********************************************************************
*                                                                     *
*        H A S P   W A R M   S T A R T   M E S S A G E S              *
*                                                                     *
***********************************************************************
         SPACE 3
NQREQ   $MSG   400,'ENTER REQUESTS'
         SPACE 2
        $MID   403
NQDOWN   WTOR  '&MID.IS SYSTEM XXXX DOWN -- REPLY Y/N',                C
               ,L'NQREPLY,ROUTCDE=(1,2),DESC=(2),MF=L                R4
NQLOKID  EQU   *-26,4              SYSTEM ID FOR MESSAGE             R4
NQMSGIDC EQU   *-45,1              MSG ID CHARACTER FOR MSG          R4
         SPACE 2
NQIBAD   DC    AL1(NQIBADLN)       MESSAGE LENGTH
NQIBADST $MSG  404,'JOB NNNN - BAD IOT - ERRORS MAY OCCUR'
NQIBADLN EQU   *-NQIBADST          LENGTH OF TEXT
         SPACE 2
NQCORE   DC    AL1(NQCORELN)       MESSAGE LENGTH
NQCOREST $MSG  405,'JOB NNNN AWAITING BUFFER STORAGE'
NQCORELN EQU   *-NQCOREST          LENGTH OF TEXT
         EJECT
NQEXEC   DC    AL1(NQEXECLN)       MESSAGE LENGTH
NQEXECST $MSG  406,'JOB NNNN WAS EXECUTING'
NQEXECLN EQU   *-NQEXECST          LENGTH OF TEXT
         SPACE 2
NQTERM   DC    AL1(NQTERMLN)       MESSAGE LENGTH
NQTERMST $MSG  407,'JOB NNNN WAS TERMINATING'
NQTERMLN EQU   *-NQTERMST          LENGTH OF TEXT
         SPACE 2
NQREQU   DC    AL1(NQREQULN)       MESSAGE LENGTH                    R4
NQREQUST $MSG  408,'JOB NNNN QUEUED FOR RE-EXECUTION'                R4
NQREQULN EQU   *-NQREQUST          LENGTH OF TEXT                    R4
         SPACE 2
NQRDRM   DC    AL1(NQRDRMLN)       MESSAGE LENGTH
NQRDRMST $MSG  409,'JOB NNNN WAS ON READER'
NQRDRMLN EQU   *-NQRDRMST          LENGTH OF TEXT
         SPACE 2
NQPRPU   DC    AL1(NQPRPULN)       MESSAGE LENGTH
NQPRPUST $MSG  410,'JOB NNNN WAS PRINTING/PUNCHING'
NQPRPULN EQU   *-NQPRPUST          LENGTH OF TEXT
         TITLE 'HASP JOB QUEUE WARM START -- TERMINATION PROCESSING'
***********************************************************************
*                                                                     *
*        E N D   O F   J O B   Q U E U E   W A R M   S T A R T        *
*                                                                     *
***********************************************************************
         SPACE 1
         USING $SVDSECT,WD         PROVIDE SSVT ADDRESSABILITY       R4
         SPACE 1
NQ700    L     WD,$SSVT            POINT TO SSVT                     R4
         LTR   NQSE,NQSE           IF SPECIFIC SYSTEM WARM START,
         BNZ   NQBFREE              BR TO FREE BUFFERS               R4
         TM    $OPTSTAT,$OPTCOLD+$OPTFMT  IF NODAL COLD START,       R4
         BNZ   NQ720                       BR TO ANALYZE TRK GRP MAP
         L     R1,NQCYLMAP         POINT TO ALLOCATE WORK AREA       R4
         MVI   BUFTYPE-BUFDSECT(R1),BUFHASP  RESET BUFFER TYPE       R4
        $FREEBUF (R1)              THEN FREE THE WORK BUFFER         R4
         SPACE 1                                                     R4
NQBFREE $FREEBUF (NQJCT)           FREE JCT BUFFER                   R4
        $FREEBUF (NQHQT)           FREE THE HQT BUFFER
         L     R1,NQIOTBF          POINT TO THE IOT BUFFER
        $FREEBUF (R1)               AND FREE IT
         TM    NQSTAT,NQ$ESYS      IF WARM START FROM 'S JES2',      R4
         BZ    NQ720                BR TO FIRE UP REST OF JES2       R4
         CLI   $NUMSMFB,2          TEST SMF BUFFER COUNT             R4
         BL    NQ900               BR IF SMF NOT SUPPORTED           R4
         SPACE 1
         USING SMFDSECT,R1         PROVIDE SMF RECORD ADDRESSABILITY
         SPACE 1
        $GETSMFB WAIT=YES          CREATE TYPE 43 SMF RCRD FOR $ESYS
         MVI   SMFRDW+1,SMF43END-SMFRDW  LENGTH OF START JES2 RECORD
         MVI   SMFHDRTY,SMFSSSTP   START JES2 SMF RECORD TYPE
         MVI   SMFSSID+1,SMFHSPID  JES2 SUBSYSTEM ID FOR RECORD 43
         MVI   SMFSSLEN+1,SMF43END-SMF43RV1  LEN OF SUBSYSTEM PART
         OI    SMF43RST,SMF$ESYS   SET $ESYS INDICATOR BYTE
         MVC   SMF43EID,QSESID     SYSTEM ID FOR RESTARTED SYSTEM
        $QUESMFB                   WRITE RECORD TYPE 43
         B     NQ900               THEN BR TO RESET QSE POINTER      R4
         SPACE 1
         DROP  R1                  KILL SJB RECORD ADDRESSABILITY
         EJECT
NQ720    LTR   NQSE,NQSE           IF WARM STARTING SINGLE SYSTEM,
         BNZ   NQ750                BR TO AVOID TGM ANALYSYS        R41
         SPACE 1
***********************************************************************
*                                                                     *
*        C O M P U T E   A L L O C A T E D   T R A C K   G R O U P S  *
*                                                                     *
***********************************************************************
         SPACE 1
         L     R0,$SVTGTOT                       PREPARE TO
         SLR   WE,WE                              COMPUTE ALLOCATED
         L     R1,$CYLMAPL                         TRACK             R4
         L     R2,$TGMAP                            GROUPS           R4
         BCTR  R2,0                                  WITHIN          R4
         L     R3,=A(KNBITB)                          MAP            R4
         SPACE 1
NQ740    IC    WE,0(R1,R2)         GET NEXT BYTE FROM $TGMAP
         IC    WE,0(R3,WE)         WE = NUMBER OF BITS IN BYTE
         SLR   R0,WE               R0 = NUMBER OF ALLOCATED TRK GRPS
         BCT   R1,NQ740            PLOW THRU ENTIRE BIT MAP
         SPACE 1
         ST    R0,$SVTGALC         SAVE NUMBER OF ALLOCATED TRK GRPS
         SPACE 1
***********************************************************************
*                                                                     *
*        S H O W   S Y S T E M   N O W   U P                          *
*                                                                     *
***********************************************************************
         SPACE 1
         USING CVT,WA              PROVIDE CVT ADDRESSABILITY
         SPACE 1
NQ750    L     WA,CVTPTR           POINT TO THE CVT                 R41
        $GETLOK                    SERIALIZE WITH SSSM DECHAINING
         SLR   R0,R0               SET NEW HASP CONDITION
         ST    R0,$SVHASP           TO ZERO
        $FRELOK                    THEN RELEASE THE LOCK
         OI    NQSTAT,NQ$ESYS      SET 1ST TIME ENTRY SWITCH         R4
         EJECT
         TM    $SVSTUS,$SVSTUSP    IF NOT PRIMARY SUBSYSTEM,
         BZ    NQ760                BR TO CONTINUE                  R41
         TM    NQSTAT,NQRESTRT     IF RESTARTING JES2,               R4
         BO    NQ760                BR TO CONTINUE                  R41
         SPACE 1
***********************************************************************
*                                                                     *
*        P O S T   M A S T E R   S C H E D U L E R                    *
*                                                                     *
***********************************************************************
         SPACE 1
         L     R1,CVTMSER          POINT TO MASTER SCHEDULER WORK
         LA    R0,BASUBECB-BASE(,R1)  PREPARE
         ST    R0,NQTQE                CROSS
         L     R0,BAASCB-BASE(,R1)      MEMORY
         ST    R0,NQTQE+4                POST
         LA    R0,CVTBRET                 QUEUE
         ST    R0,NQTQE+8                  ELEMENT
         LA    R1,NQTQE            THEN POST
         POST  MF=(E,(1))           THE MASTER SCHEDULER
         SPACE 1                                                    R41
         DROP  WA                  KILL CVT ADDRESSABILITY          R41
         EJECT                                                      R41
***********************************************************************
*                                                                     *
*        DECREMENT CHECKPOINT DEVICE RESERVE COUNT                    *
*                                                                     *
***********************************************************************
         SPACE 1                                                    R41
NQ760    LTR   NQSE,NQSE           IF SINGLE SYSTEM WARM START,     R41
         BNZ   NQNEWS               BR TO CONTINUE                  R41
        $QSUSE                     REQUEST ACCESS TO CKPT DATA      R41
         L     R1,$SVRELSE                 GET ADDRESS OF           R41
         L     R1,IOSUCB-IOSB+SRBSIZE(,R1)  CKPT DEVICE UCB         R41
        $GETLOK                    SERIALIZE WITH SSSM              R41
         TM    $SVSTUS,$SVSTIRV    IF INIT RESERVE BIT NOT ON,      R41
         BZ    NQ770                BR TO BYPASS RESERVE COUNT DECR R41
         MODESET EXTKEY=ZERO       SET ZERO PROTECT KEY             R41
         IC    R0,UCBSQC-UCBDSECT(,R1)  DECREMENT                   R41
         BCTR  R0,0                      CKPT DEVICE                R41
         STC   R0,UCBSQC-UCBDSECT(,R1)    RESERVE COUNT             R41
         NI    $SVSTUS,255-$SVSTIRV  RESET INIT RESERVE BIT         R41
         SPACE 1                                                    R41
NQ770   $FRELOK                    RELEASE THE LOCK                 R41
         SPACE 1                                                    R41
         DROP  WD,NQSE             KILL SSVT, QSE ADDRESSABILITY    R41
         TITLE 'HASP JOB QUEUE WARM START -- ''NEWS'' PROCESSING'   R41
***********************************************************************
*                                                                     *
*                 P R O C E S S   'N E W S'   F O R                   *
*                                                                     *
*           P R I N T E R   S E P A R A T O R   P A G E S             *
*                                                                     *
***********************************************************************
         SPACE 1                                                    R41
NQNEWS   OC    $NEWNEWS,$NEWNEWS   'NEW NEWS' SPECIFIED AT INIT...  R41
         BZ    NQ800                 SKIP WHOLE SECTION IF NOT      R41
        $GETBUF ,                  GET A BUFFER TO BUILD/READ IOT   R41
         LR    NQIOT,R1            POINT IOT REG TO BUFFER          R41
         OC    $NEWSIOT,$NEWSIOT   SEE IF 'OLD NEWS' EXISTS         R41
         BZ    NQNCIOT               BRANCH TO CREATE IOT IF NOT    R41
         LTR   NQSE,NQSE           SINGLE SYSTEM WARM START...      R41
         BNZ   NQNRDIOT              BR IF YES TO READ OLD IOT      R41
         XC    $NEWSIOT(8),$NEWSIOT CLEAR 'OLD NEWS' PTRS IN HCT    R41C
                                   (WARMSTART WILL DEL OLD TRACKS)  R41
         SPACE 1                                                    R41
         USING IOTDSECT,NQIOT      PROVIDE IOT ADDRESSABILITY       R41
         SPACE 1                                                    R41
NQNCIOT  LA    R14,IOTSTART        STARTING ADDR FOR CLEARING IOT   R41
         LH    R15,$BUFSIZE        LENGTH FOR CLEAR                 R41
         SLR   R1,R1               ZERO PAD CHAR FOR FILL           R41
         MVCL  R14,R0              CLEAR IOT                        R41
         MVC   IOTID,=CL4'IOT'     SET IOT IDENTIFIER               R41
         MVC   IOTLENG,$BUFLENG    SET IOT LENGTH              @OZ31604
         MVC   IOTJBKEY,NQNIOTKY   SET SPECIAL 'JOB' KEY            R41
         MVI   IOTFLAG1,IOT1ALOC   SHOW 'ALLOCATION' IOT            R41
        $TRACK IOTMSTAB            OBTAIN MTTR FOR IOT              R41
         ST    R1,IOTTRACK         PUT IOT'S OWN MTTR IN IOT        R41
         MVI   TABUFCNT-TABDSECT+IOTMSTAB,0 FORCE DATA TO NEW TKCEL R41
         L     R1,$IOTPDDB         POINT R1 TO                      R41
         ALR   R1,NQIOT              PDDB LOCATION                  R41
         USING PDBDSECT,R1         SET UP ADDRESSABILITY            R41
         MVI   PDBLRECL,132        SET PDDB LOGICAL RECORD LENGTH   R41
         MVC   PDBDSKEY,NQNPDBKY   SET SPECIAL DS KEY               R41
         MVI   PDBCLASS,C'A'       FILL IN DEFAULT CLASS            R41
         MVI   PDBCOPYS,1          FILL IN COPY COUNT               R41
         MVI   PDBFLAG2,PDB2TCEL   SHOW 'TRACK-CELLED' PDDB         R41
         MVC   PDBFORMS,$STDFORM   SET DEFAULT FORM                 R41
         MVI   PDBFCB,C'*'         SET FCB, UCS IDS                 R41
         MVC   PDBFCB+1(L'PDBFCB+L'PDBUCS-1),PDBFCB TO DEFAULT      R41
         MVI   PDBCHAR1,C'*'       SET 3800 IDENTIFIERS TO DEFAULT  R41
         MVC   PDBCHAR1+1(PDBMODF-PDBCHAR1+L'PDBMODF-1),PDBCHAR1    R41
         L     R1,$IOTPDDB         SET POINTER IN IOT               R41
         LA    R1,PDBLENG(,R1)       BEYOND LAST                    R41
         ST    R1,IOTPDDBP           (ONLY) PDDB                    R41
         B     NQNPTEXT            GO PROCESS NEWS RECORDS          R41
         SPACE 1                                                    R41
         DROP  R1                  KILL PDDB ADDRESSABILITY         R41
         EJECT                                                      R41
NQNRDIOT ST    NQIOT,PCEBUFAD      SET BUFFER ADDRESS FOR READ      R41
         MVC   PCESEEK,$NEWSIOT    SET SEEK ADDRESS                 R41
         MVI   PCEDEVTP,PCEDARD    SET DA DCT TO 'READ'             R41
         LA    R1,PCEDADCT         ISSUE $EXCP AND                  R41
        $EXCP  (R1),WAIT=YES         $WAIT FOR COMPLETION           R41
         BNO   NQNEWSX2            BRANCH IF READ ERROR             R41
         CLC   NQNIOTKY,IOTJBKEY   VALIDATE 'JOB' KEY               R41
         BE    NQNEWTCL            BRANCH IF OK                     R41
         SPACE 1                                                    R41
NQNEWSX2 $DISTERR                  INDICATE CONTROL BLOCK ERROR     R41
         B     NQNCIOT             RE-BUILD IOT FROM SCRATCH        R41
         SPACE 1                                                    R41
NQNEWTCL MVI   TABUFCNT-TABDSECT+IOTMSTAB,0 FORCE DATA TO NEW TKCEL R41
         LR    R1,NQIOT            SET STARTING                     R41
         AL    R1,$IOTPDDB           MTTR IN                        R41
         SLR   R0,R0                 PDDB TO                        R41
         ST    R0,PDBMTTR-PDBDSECT(,R1) ZERO                        R41
         SPACE 1                                                    R41
*        MOVE NEWS LINES FROM VIRTUAL STORAGE BUFFER BUILT BY       R41
*        JES2 INITIALIZATION TO SPOOL BUFFERS                       R41
         SPACE 1                                                    R41
NQNPTEXT L     WA,$NEWNEWS         POINT TO TEXT BLOCK FROM INIT    R41
         USING NEWSBLOK,WA         SET UP ADDRESSABILITY ON BLOCK   R41
         LA    WB,NEWSTART         POINT TO 1ST NEWS LINE           R41
         USING BUFDSECT,WC         PROVIDE BUFFER ADDRESSABILITY    R41
         SLR   WC,WC               ZERO OUT CURRENT BUFFER POINTER, R41
         SLR   WD,WD                 CURRENT LRC POINTER,           R41
         SLR   WE,WE                 AMOUNT OF SPACE REMAINING      R41
         SPACE 1                                                    R41
NQNLOOP  CL    WB,NEWSPTR          SEE IF AT END OF NEWS LINES,     R41
         BNL   NQNEND                EXIT IF SO                     R41
         LA    R1,NEWSLENG(,WB)    POINT PAST END OF LINE           R41
         SPACE 1                                                    R41
NQNBCTR  BCTR  R1,0                BUMP BACK ONE CHARACTER          R41
         CLI   0(R1),C' '          CHECK FOR NON-BLANK              R41
         BE    NQNBCTR             CONTINUE SCAN IF NOT             R41
         LA    R10,NEWSLINE(,WB)   COMPUTE MACHINE LENGTH OF TEXT   R41
         SLR   R1,R10                FOR EXECUTED MOVE              R41
         LTR   R10,R1              TEST COMPUTED LENGTH             R41
         BNM   NQNLENOK            BRANCH IF LENGTH IS OK           R41
         SLR   R10,R10             SET LENGTH=0 FOR ONE BLANK CHAR  R41
         SPACE 1                                                    R41
NQNLENOK LA    R0,5(,R10)          COMPUTE TOTAL LEN REQ'D FOR LRC  R41
         CLR   R0,WE               SEE IF ENOUGH SPACE LEFT,        R41
         BL    NQNENUF             BRANCH IF SO                     R41
         EJECT                                                      R41
*        OBTAIN A SPOOL BUFFER FOR NEWS DATA                        R41
         SPACE 1                                                    R41
        $TRACK IOTMSTAB            GET AN MTTR FOR A DATA BUFFER    R41
         LTR   WC,WC               SEE IF CURRENT BUFFER EXISTS     R41
         BNZ   NQNBFADD            BRANCH TO ADD TO CHAIN IF SO     R41
         L     R14,$IOTPDDB        STORE DATA SET INITIAL MTTR IN   R41
         ST    R1,PDBMTTR-PDBDSECT(NQIOT,R14) PDDB IN IOT           R41
         ST    R1,PCESEEK          SAVE MTTR FOR EVENTUAL WRITE     R41
        $GETBUF ,                  OBTAIN A SPOOL BUFFER            R41
         LR    WC,R1               POINT WC TO ACQUIRED BUFFER      R41
         B     NQNGOTBF            BRANCH TO INITIALIZE BUFFER PTRS R41
         SPACE 1                                                    R41
NQNBFADD ST    R1,HDBNXTRK         ADD BUFFER TO CHAIN              R41
         ST    WC,PCEBUFAD         SET BUFFER ADDRESS FOR $EXCP     R41
         MVI   PCEDEVTP,PCEDAWR    SET DA DCT TO 'WRITE'            R41
         LA    R1,PCEDADCT         POINT TO DA DCT                  R41
        $EXCP  (R1),WAIT=YES       WRITE BUFFER TO SPOOL            R41
         MVC   PCESEEK,HDBNXTRK    SET NEXT MTTR FOR EVENTUAL WRITE R41
         SPACE 1                                                    R41
NQNGOTBF SLR   R0,R0               INDICATE                         R41
         ST    R0,HDBNXTRK          END-OF-FILE                     R41
         MVC   HDBKEY,NQNEWSKY     SET SPECIAL JOB/DS KEYS          R41
         LA    WD,HDBSTART         POINT TO FIRST SPOT FOR LRC      R41
         SPACE 1                                                    R41
         USING LRCDSECT,WD         PROVIDE LRC ADDRESSABILITY       R41
         SPACE 1                                                    R41
NQNENUF  LA    R0,1(,R10)          SET TEXT LENGTH                  R41
         STC   R0,LRCTLENG           IN LOGICAL RECORD CONTROL      R41
         MVI   LRCFLAG1,LRC1CCTL+LRC1TASA SHOW ASA CARRIAGE CONTROL R41
         MVI   LRCLRECL,132        SET CONSTANT LOGICAL RECORD LEN  R41
         MVC   LRCCCTL,NEWSCCTL(WB) MOVE CARRIAGE CONTROL BYTE      R41
         EX    R10,NQNEWSMV        MOVE TEXT                        R41
         LA    WD,LRCSOUT+1(R10)   POINT TO 1ST BYTE OF NEXT LRC    R41
         MVI   LRCTLENG,LRCBFEND   SEND 'END OF BLOCK' INDICATOR    R41
         LH    WE,$BUFLENG         COMPUTE                          R41
         ALR   WE,WC                 AMOUNT OF SPACE                R41
         SLR   WE,WD                 REMAINING IN BUFFER            R41
         LA    WB,NEWSLENG(,WB)    BUMP NEWS LINE POINTER           R41
         B     NQNLOOP             LOOP BACK FOR MORE NEWS LINES    R41
        EJECT                                                       R41
         SPACE 1                                                    R41
NQNEND   LTR   WC,WC               SEE IF BUFFER EXISTS             R41
         BZ    NQNFREEM              EXIT IF NOT                    R41
         ST    WC,PCEBUFAD         SET BUFFER ADDRESS FOR $EXCP     R41
         MVI   PCEDEVTP,PCEDAWR    SET 'WRITE' DEVICE TYPE          R41
         LA    R1,PCEDADCT         POINT TO DIRECT-ACCESS DCT       R41
        $EXCP  (R1),WAIT=YES       WRITE OUT LAST BUFFER            R41
        $FREEBUF (WC)              RELEASE DATA BUFFER              R41
         SPACE 1                                                    R41
         DROP  WC                  KILL BUFFER ADDRESSABILITY       R41
         SPACE 1                                                    R41
NQNFREEM L     R0,NQNEWSLN         LOAD SP AND LEN OF GETMAINED BLK R41
         LR    R1,WA               POINT TO START OF AREA           R41
         FREEMAIN R,LV=(0),A=(1)   RELEASE VIRTUAL STORAGE          R41
         SLR   R0,R0               ZERO OUT TEXT BLOCK              R41
         ST    R0,$NEWNEWS           POINTER IN HCT                 R41
         MVI   PCEDEVTP,PCEDAWR    SET DA DCT TO 'WRITE'            R41
         ST    NQIOT,PCEBUFAD      SET BUFFER ADDR FOR WRITE        R41
         MVC   PCESEEK,IOTTRACK    SET MTTR OF IOT FOR WRITE        R41
         LA    R1,PCEDADCT         POINT TO DA DCT                  R41
        $EXCP  (R1),WAIT=YES       WRITE OUT 'NEWS' IOT AND $WAIT   R41
         BNO   NQNFREEB            DON'T UPDATE HCT PTRS IF I/O ERR R41
        $QSUSE                     OBTAIN CONTROL OF CKPT RECORD    R41
         MVC   $NEWSIOT,IOTTRACK   SET 'NEWS' IOT POINTER IN HCT    R41
         L     R1,$IOTPDDB         SET 'NEWS' DATA SET              R41
         L     R1,PDBMTTR-PDBDSECT(R1,NQIOT) POINTER                R41
         ST    R1,$NEWSTTR           IN HCT                         R41
        $POST  $HASPECF,CKPT       FORCE CKPT OF HCT WITH NEW PTRS  R41
         EJECT                                                      R41
NQNFREEB LR    R1,NQIOT            FREE BUFFER USED                 R41
        $FREEBUF (R1)                FOR 'NEWS' IOT                 R41
         B     NQ800               BRANCH TO END OF WARMSTART       R41
         SPACE 1                                                    R41
NQNEWSMV MVC   LRCSOUT(*-*),NEWSLINE(WB) *** EXECUTE ONLY ***       R41
NQNEWSLN DC    0F'0',AL1(229),AL3(NEWSTOTL) SP AND LENGTH OF BLOCK  R41
         SPACE 1                                                    R41
NQNEWSKY DC    CL6'$$NEWS'         SPECIAL JOB/DS KEY FOR NEWS      R41
NQNIOTKY EQU   NQNEWSKY,4          SPECIAL JOB    KEY FOR NEWS      R41
NQNPDBKY EQU   NQNEWSKY+4,2        SPECIAL     DS KEY FOR NEWS      R41
         SPACE 1                                                    R41
         DROP  WD,NQIOT            KILL LRC, IOT ADDRESSABILITY     R41
         TITLE 'HASP JOB QUEUE WARM START -- TERMINATION EXIT'      R41
***********************************************************************
*                                                                     *
*        $ P O S T   P R O C E S S O R S   F O R   H O L D            *
*                                                                     *
***********************************************************************
         SPACE 1
         USING QSEDSECT,WC         PROVIDE QSE ADDRESSABILITY       R41
         SPACE 1                                                    R41
NQ800    TM    $OPTSTAT,$OPTREQ    IF OPERATOR REQUESTS SELECTED,   R41
         BO    NQ840                BR TO BYPASS PCE POSTING        R41
         LA    R1,$PCEORG-(PCENEXT-PCEDSECT)  PREPARE TO POST PCES
         SPACE 1
NQ820    L     R1,PCENEXT-PCEDSECT(,R1)  POINT TO NEXT PCE
         LTR   R1,R1               IF END OF PCE CHAIN,
         BZ    NQ900                BR TO CONTINUE                  R41
        $POST  (R1),HOLD             ELSE $POST PROCESSOR
         B     NQ820               THEN BR TO POST NEXT PCE
         SPACE 1
***********************************************************************
*                                                                     *
*        I S S U E   ' E N T E R   R E Q U E S T S '   M S G          *
*                                                                     *
***********************************************************************
         SPACE 1
NQ840    LA    R1,NQREQ            POINT TO REQUEST MESSAGE          R4
        $WTO   (R1),L'NQREQ,JOB=NO,ROUTE=$LOG+$MAIN,    ISSUE MSG    R4C
               PRI=$ST,CLASS=$ALWAYS,WAIT=YES            TO OPERATOR
         L     R1,$COMMPCE         THEN $POST                        R4
        $POST  (R1),HOLD            THE COMMAND PROCESSOR
         SPACE 1
NQ900    SLR   NQSE,NQSE           CLEAR POINTER TO
         ST    NQSE,$ESYSQSE        WARM STARTED SYSTEM QSE
        $DORMANT                   INDICATE PROCESSOR INACTIVE      R41
         NI    NQSTAT,255-NQRESTRT RESET RESTART FLAG                R4
         B     NQ000               THEN BR TO AWAIT $ESYS COMMAND
 TITLE 'HASP JOB QUEUE WARM START -- JOB QUEUE SCAN INITIALIZATION'
***********************************************************************
*                                                                     *
*        P R E P A R E   T O   W A R M   S T A R T   J O B   Q        *
*                                                                     *
***********************************************************************
         SPACE 1
         USING $SVDSECT,NQJCT      PROVIDE SSVT ADDRESSABILITY       R4
         USING JQEDSECT,WD         PROVIDE JQE ADDRESSABILITY
         SPACE 1
***********************************************************************
*                                                                     *
*        R E M O V E   A L L   H O L D   Q U E U E   L O C K S        *
*                                                                     *
***********************************************************************
         SPACE 1                                                     R4
NQINIT  $QSUSE                     REQUEST ACCESS TO CHECKPOINT DATA R4
         L     NQJCT,$SSVT         POINT TO SSVT                     R4
         SPACE 1                                                     R4
NQFRELOK LA    WB,$JQTYPES*2       PREPARE TO SCAN ALL JOB QUEUES    R4
         SPACE 1
NQNXTQ   LA    NQ,$JQHEADS-2-QUECHAIN(WB)  PREPARE TO SCAN JOB QUEUE
         SPACE 1
NQNXTJOB LH    NQ,JQECHAIN         GET OFFSET
         N     NQ,=X'0000FFFF'      OF NEXT JQE
         BZ    NQIEND              BR IF END OF JOB QUEUE
         SLL   NQ,2                 ELSE CONVERT OFFSET
         AL    NQ,$JOBQPTR           TO ABSOLUTE ADDRESS
         TM    JQEHQLOK,QUEBUSY    IF HOLD QUEUE LOCK NOT HELD,
         BZ    NQNXTJOB             BR TO TEST NEXT JQE
         LTR   NQSE,NQSE           IF NODAL WARM START,              R4
         BZ    NQIREM               BR TO REMOVE THE LOCK
         IC    R0,JQEHQLOK         IF SYSTEM
         N     R0,=A(QUEBUSY)       BEING
         CLM   R0,1,QSESIBSY         WARM STARTED,
         BE    NQIREM                 BR TO REMOVE THE LOCK
         BAL   WE,NQLOKREM             AND REMOVE LOCK CAREFULLY
         B     NQFRELOK            THEN BR TO RE-SCAN JOB QUEUES     R4
         SPACE 1
NQIREM   NI    JQEHQLOK,255-QUEBUSY  RESET JOB HOLD QUEUE LOCK
        $QCKPT (NQ)                   AND FORCE CHECKPOINT OF JQE
         B     NQNXTJOB            THEN BR TO TEST NEXT JQE
         SPACE 1
NQIEND   BCTR  WB,0                IF ANOTHER JOB QUEUE,
         BCT   WB,NQNXTQ            BR TO PROCESS IT
         EJECT
***********************************************************************
*                                                                     *
*        S E T   J O B   H O L D   Q U E U E   L O C K S              *
*                                                                     *
***********************************************************************
         SPACE 1
         LA    WB,$JQTYPES*2       PREPARE TO RE-SCAN ALL JOB QUEUES
         SPACE 1
NQNXTQUE LA    NQ,$JQHEADS-2-QUECHAIN(WB)  PREPARE TO SCAN NEXT Q
         SPACE 1
NQJOBNXT LH    NQ,JQECHAIN         GET OFFSET
         N     NQ,=X'0000FFFF'      OF NEXT JQE
         BZ    NQENDQ              BR IF END OF CURRENT JOB QUEUE
         SLL   NQ,2                 ELSE CONVERT OFFSET
         AL    NQ,$JOBQPTR           TO ABSOLUTE ADDRESS
         MVC   NQDBL(1),$SIDBUSY   SET
         LTR   NQSE,NQSE            JOB
         BZ    *+10                  HOLD
         MVC   NQDBL(1),QSESIBSY      QUEUE
         OC    JQEHQLOK,NQDBL          LOCK
        $QCKPT (NQ)                THEN FORCE CHECKPOINT OF JQE
         B     NQJOBNXT            THEN BR TO GET NEXT JQE
         SPACE 1
NQENDQ   BCTR  WB,0                IF ANOTHER JOB QUEUE,
         BCT   WB,NQNXTQUE          BR TO SCAN IT
         EJECT
***********************************************************************
*                                                                     *
*        R E L E A S E   H O L D   Q U E U E   P R O C E S S O R      *
*                                                                     *
***********************************************************************
         SPACE 1                                                     R4
         L     R1,$HOLDPCE         RELEASE                           R4
        $POST  (R1),HOLD            HOLD QUEUE PROCESSOR
         TM    $SVHASP,X'80'       IF NOT RE-STARTING JES2,
         BZ    NQBUFRS              BR TO GET BUFFERS
         SPACE 1
***********************************************************************
*                                                                     *
*        F R E E   P E N D I N G   H O L D   R E Q U E S T S          *
*                                                                     *
***********************************************************************
         SPACE 1
NQFRIOT  ICM   R1,15,$SVHOLDQ      IF END OF HOLD QUEUE,
         BZ    NQBUFRS              BR TO GET BUFFERS
         MVC   $SVHOLDQ,IOTIOT-IOTDSECT(R1)  ELSE
         LH    R0,$BUFSIZE                    FREE                   R4
         ICM   R0,8,=AL1(231)                  IOT
         FREEMAIN R,LV=(0),A=(1)                BUFFER
         B     NQFRIOT             THEN BR TO RE-TEST HOLD QUEUE
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        G E T   J C T / I O T / H C T   B U F F E R S                *
*                                                                     *
***********************************************************************
         SPACE 1
NQBUFRS $GETBUF WAIT=YES           GET BUFFER FOR JCT                R4
         LR    NQJCT,R1            RELOAD BUFFER ADDRESS             R4
        $GETBUF WAIT=YES           GET BUFFER FOR IOT                R4
         ST    R1,NQIOTBF          SAVE BUFFER ADDRESS               R4
        $GETBUF WAIT=YES           GET BUFFER FOR HQT                R4
         LR    NQHQT,R1            RELOAD BUFFER ADDRESS             R4
         LTR   NQSE,NQSE           IF NOT NODAL WARM START,          R4
         BNZ   NQ200                BR TO BEGIN WARM START           R4
        $GETBUF WAIT=YES           GET BUFFER FOR WORK AREA          R4
         ST    R1,NQCYLMAP         SAVE WORK AREA ADDRESS            R4
         B     NQ200               THEN BR TO BEGIN WARM START
         EJECT
***********************************************************************
*                                                                     *
*        R E M O V E   J O B   H O L D   Q U E U E   L O C K          *
*                                                                     *
***********************************************************************
         SPACE 1
NQLOKREM IC    R0,JQEHQLOK         GET SYSTEM ID
         N     R0,=A(QUEBUSY)       FROM HOLD QUEUE LOCK
         L     R1,$QSE1            PREPARE TO SCAN                   R4
         SH    R1,$QSEL             ACTIVE QSES                      R4
         SPACE 1
         AH    R1,$QSEL                   IF NOT THE SYSTEM          R4
         CLM   R0,1,QSESIBSY-QSEDSECT(R1)  HOLDING THE LOCK,
         BNE   *-8                          LOOP
         SPACE 1
         STCK  NQDBL                    IF SYSTEM
         L     R15,NQDBL                 HOLDING
         SL    R15,$SYNCTOL               THE LOCK                   R4
         CL    R15,QSESITIM-QSEDSECT(,R1)  APPEARS DOWN,
         BH    NQLOKMSG                     BR TO QUERY THE OPERATOR
         SPACE 1
***********************************************************************
*                                                                     *
*        L O C K   H E L D   B Y   A C T I V E   S Y S T E M          *
*                                                                     *
***********************************************************************
         SPACE 1
        $WAIT  ABIT                $WAIT A LITTLE WHILE
         SPACE 1
NQLOKTST $QSUSE                    REQUEST ACCESS TO CHECKPOINT DATA
         TM    JQEHQLOK,QUEBUSY    IF LOCK NO LONGER HELD,
         BZR   WE                   RETURN
         B     NQLOKREM              ELSE TRY AGAIN TO REMOVE IT
         EJECT
***********************************************************************
*                                                                     *
*        S U S P E C T   D O W N   S Y S T E M   - -   V E R I F Y    *
*                                                                     *
***********************************************************************
         SPACE 1
NQLOKMSG MVC   NQMSG,NQDOWN        MOVE MSG TO WORK AREA             R4
         MVC   NQMSGIDC-NQDOWN+NQMSG,$SVCOMCH           SET UP       R4
         MVC   NQLOKID-NQDOWN+NQMSG,QSESID-QSEDSECT(R1)  MSG         R4
         SPACE 1                                                     R4
NQDNWTOR MVI   NQREPLY,0                  ISSUE                      R4
         L     WA,$HASPECB                 QUERY                     R4
         WTOR  ,NQREPLY,,(WA),MF=(E,NQMSG)  TO OPERATOR              R4
         SPACE 1
NQREPL  $WAIT  ABIT                $WAIT FOR OPERATOR RESPONSE
         CLI   NQREPLY,0           IF NOT OPERATOR REPLY,
         BE    NQREPL               BR TO $WAIT A LITTLE LONGER
        $QSUSE                     REQUEST ACCESS TO CHECKPOINT DATA
         TM    JQEHQLOK,QUEBUSY    IF LOCK NO LONGER HELD,
         BZR   WE                   RETURN
         OI    NQREPLY,X'40'       FORCE UPPER CASE REPLY            R4
         CLI   NQREPLY,C'Y'        IF OPERATOR
         BE    NQREMLOK             HAS CONFIRMED
         CLI   NQREPLY,C'N'          THAT SYSTEM IS DOWN,            R4
         BNE   NQDNWTOR               BR TO REMOVE THE LOCK          R4
         LA    R0,60                   ELSE $WAIT
         BAL   WA,NQSTIMER              FOR 60 SECONDS
         B     NQLOKTST            THEN BR TO TEST LOCK AGAIN
         SPACE 1
NQREMLOK NI    JQEHQLOK,255-QUEBUSY  REMOVE JOB HOLD QUEUE LOCK
        $QCKPT (NQ)                   AND FORCE CHECKPOINT OF JQE
         BR    WE                  THEN RETURN
         SPACE 1                                                     R4
         DROP  NQJCT               KILL SSVT ADDRESSABILITY          R4
         TITLE 'HASP JOB QUEUE WARM START -- LITERAL POOL'           R4
         LTORG
         TITLE 'HASP DYNAMIC SPOOL ALLOCATION SUBTASK'               R4
***********************************************************************
*                                                                     *
* SUBTASK NAME -- HOSPOOL                                             *
*                                                                     *
* DESCRIPTIVE NAME -- JES2 DYNAMIC SPOOL ALLOCATION SUBTASK           *
*                                                                     *
* FUNCTION -- PROVIDE CAPABILITY TO DYNAMICALLY ALLOCATE A JES2       *
*             SPOOL VOLUME.                                           *
*                                                                     *
* NOTES -- THE ATTACHER OF THIS SUBTASK MUST REQUEST THE SYSTEM       *
*          TO PROVIDE A REGISTER SAVE AREA.  HE MUST ALSO PROVIDE,    *
*          IN REGISTER 1, THE ADDRESS OF A WORK AREA OBTAINED VIA     *
*          GETMAIN FROM SUBPOOL 229 AND DESCRIBED BY THE $SPL         *
*          MACRO.  THE FOLLOWING FIELDS IN THIS WORK AREA MUST BE     *
*          PROVIDED -- SPLFLG1, SPLTCBPT, SPLUNIT AND SPLVOLID.       *
*          IF SPLUCBPT IS SET, THEN SPLUNIT MUST CONTAIN THE          *
*          3-CHARACTER UCB NAME.  IF SPLUCBPT IS ZERO, THEN           *
*          SPLUNIT MUST CONTAIN THE 8-CHARACTER DEVICE TYPE.          *
*                                                                     *
* REGISTER CONVENTIONS -- R0  -- WORK REGISTER                        *
*                         R1  -- WORK REGISTER                        *
*                         R2  -- WORK REGISTER                        *
*                         R3  -- WORK REGISTER                        *
*                         R4  -- WORK REGISTER                        *
*                         R5  -- WORK REGISTER                        *
*                         WE  -- WORK/LINK REGISTER                   *
*                         WF  -- WORK REGISTER                        *
*                         WG  -- IOB ADDRESS                          *
*                         R9  -- UNUSED                               *
*                         R10 -- RB ADDRESS                           *
*                         R11 -- HCT ADDRESS (BASE1)                  *
*                         R12 -- BASE REGISTER (BASE2)                *
*                         R13 -- SPL ADDRESS                          *
*                                                                     *
***********************************************************************
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        HOSPOOL INITIAL ENTRY POINT                                  *
*                                                                     *
***********************************************************************
         SPACE 5                                                     R4
         USING S99RB,R10           PROVIDE RB ADDRESSABILITY         R4
         USING BUFDSECT,WG         PROVIDE IOB ADDRESSABILITY        R4
         USING SPLDSECT,R13        PROVIDE SPL ADDRESSABILITY        R4
         SPACE 1                                                     R4
HOSPOOL $ENTRY BASE=R15            PROVIDE SUBTASK ENTRY             R4
         STM   R14,R12,12(R13)     SAVE SYSTEM'S REGISTERS           R4
         SPACE 1                                                     R4
         DROP  R15                 PROVIDE                           R4
         LR    BASE2,R15            SUBTASK                          R4
         USING HOSPOOL,BASE2         ADDRESSABILITY                  R4
         SPACE 1                                                     R4
         ST    R1,8(,R13)          STORE FORWARD POINTER             R4
         ST    R13,4(,R1)          STORE BACKWARD POINTER            R4
         LR    R13,R1              SWITCH TO NEW SAVE AREA           R4
         L     BASE1,=V(HASPNUC)   GET HCT ADDRESS                   R4
         MVI   SPLFLG2,SPL2UNAL    SET ERROR FLAG BYTE               R4
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        CONTRUCT DYNAMIC ALLOCATION PARAMETER LIST                   *
*                                                                     *
***********************************************************************
         SPACE 1                                                     R4
         LA    R10,SPLDYNRB        GET RB ADDRESS                    R4
         ST    R10,SPLDYNAL        SET RB POINTER                    R4
         MVI   SPLDYNAL,S99RBPND   SET LAST INDICATOR                R4
         XC    S99RB(20),S99RB     CLEAR RB                          R4
         MVI   S99RBLN,20          SET RB LENGTH                     R4
         MVI   S99VERB,S99VRBAL    INDICATE ALLOCATION REQUEST       R4
         LA    R0,SPLTEXT          SET POINTER TO LIST               R4
         ST    R0,S99TXTPP          OF TEXT UNIT POINTERS            R4
         MVI   S99FLG21,SPALFLGS   SET ALLOCATION FLAGS              R4
         LA    R0,SPLDDTXT         SET POINTER TO                    R4
         ST    R0,SPLDDTA           DDNAME TEXT UNIT                 R4
         MVC   SPLDDTXT,SPDDTXT    SET DDNAME TEXT                   R4
         MVC   SPLDDNAM,SPLVOLID   MOVE DDNAME TO TEXT UNIT          R4
         LA    R0,SPLDSTXT         SET POINTER TO                    R4
         ST    R0,SPLDSNTA          DSNAME TEXT UNIT                 R4
         MVC   SPLDSTXT,SPDSNTXT   SET DSNAME TEXT                   R4
         MVI   SPLDSNAM,C' '       BLANK OUT ENTIRE DSNAME           JN
         MVC   SPLDSNAM+1(L'SPLDSNAM-1),SPLDSNAM  (LIKEWISE)         JN
         MVC   SPLDSNAM(8),$DSNPRFX SET PREFIX (DEFAULT = 'SYS1')    JN
         LA    R1,SPLDSNAM         SCAN FOR                          JN
SKIP90   LA    R1,1(,R1)             FIRST BLANK                     JN
         CLI   0(R1),C' '            FOLLOWING                       JN
         BNE   SKIP90                PREFIX                          JN
         MVC   0(8,R1),=CL8'.HASPACE' SET DSNAME FOR HASPACE         JN
         TM    SPLFLG1,SPL1CKPT    TEST FOR SYS1.HASPCKPT            R4
         BZ    SKIP100             BR IF NO                          R4
         MVC   5(4,R1),=CL4'CKPT'      ELSE RESET DSNAME             JN
         MVC   SPLDDNAM,=CL6'$CHKPT'    AND DDNAME                   R4
SKIP100  LA    R0,SPLVLTXT         SET POINTER TO                    R4
         ST    R0,SPLVOLTA          VOLUME SERIAL TEXT UNIT          R4
         MVC   SPLVLTXT,SPVOLTXT   SET VOLUME SERIAL TEXT            R4
         LA    R0,SPLDPTXT         SET POINTER TO                    R4
         ST    R0,SPLDSPTA          DATA SET DISPOSITION TEXT UNIT   R4
         MVI   SPLDSPTA,S99TUPLN   INDICATE LAST TEXT UNIT POINTER   R4
         MVC   SPLDPTXT,SPDSPTXT   SET DISP=OLD TEXT                 R4
         LA    R0,SPLUNTXT         SET POINTER TO                    R4
         ST    R0,SPLUNITA          UNIT NAME TEXT UNIT              R4
         MVC   SPLUNTXT,SPUNITXT   SET UNIT NAME TEXT                R4
         TM    SPLFLG1,SPL1UNAL    TEST FOR UNALLOCATE REQUEST       R4
         BO    SPUNALOC            BR IF YES                         R4
         OC    SPLUCBPT,SPLUCBPT   TEST FOR UCB ADDRESS              R4
         BNZ   SPDYNAL             BR IF YES - UNIT NAME PROVIDED    R4
         OI    S99FLG21,S99WTUNT+S99OFFLN    ELSE ALLOW              R4
         MVI   S99FLG22,S99UDEVT              WAIT ON                R4
         MVI   S99TULNG+1-S99TUNIT+SPLUNTXT,8  OFFLINE UNIT          R4
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        DYNAMIC ALLOCATE SPOOL/CHECKPOINT VOLUME                     *
*                                                                     *
***********************************************************************
         SPACE 1                                                     R4
SPDYNAL  LA    R1,SPLDYNAL         POINT TO PARAMETER LIST           R4
         DYNALLOC                   AND ALLOCATE THE VOLUME          R4
         LTR   R15,R15             TEST ALLOCATE                     R4
         BNZ   SPEXIT              BR IF ALLOCATE ERROR              R4
         NI    SPLFLG2,255-SPL2UNAL  RESET UNALLOCATE FLAG           R4
         L     R3,CVTPTR           GET CVT ADDRESS                   R4
         ICM   R4,15,SPLUCBPT      TEST FOR UCB ADDRESS              R4
         BNZ   SPUCBOK             BR IF PROVIDED                    R4
         SPACE 1                                                     R4
***********************************************************************
*                                                                     *
*        LOCATE SPOOL/CHECKPOINT VOLUME UCB                           *
*                                                                     *
***********************************************************************
         SPACE 1                                                     R4
         USING CVT,R3              PROVIDE CVT ADDRESSABILITY        R4
         USING UCBDSECT,R4         PROVIDE UCB ADDRESSABILITY        R4
         SPACE 1                                                     R4
         L     R15,CVTILK2         GET ADDRESS OF UCB                R4
         SH    R15,=H'2'            LOOK-UP TABLE (LESS 2)           R4
         SPACE 1                                                     R4
SPNXTUCB LA    R15,2(,R15)         GET NEXT LOOK-UP TABLE ENTRY      R4
         ICM   R4,3,0(R15)         GET UCB ADDRESS                   R4
         BZ    SPNXTUCB            IGNORE IF NULL ENTRY              R4
         CLI   UCBTBYT3,UCB3DACC   TEST DEVICE TYPE                  R4
         BNE   SPNXTUCB            IGNORE IF NOT DIRECT ACCESS       R4
         CLC   SPLVOLID,SRTEVOLI   TEST VOLUME SERIAL                R4
         BNE   SPNXTUCB            IGNORE IF NOT OUR VOLUME          R4
         ST    R4,SPLUCBPT          ELSE STORE UCB ADDRESS           R4
         SPACE 1                                                     R4
         USING QSEDSECT,R1         PROVIDE QSE ADDRESSABILITY        R4
         SPACE 1                                                     R4
SPUCBOK  L     R1,$QSE1            POINT TO 1ST QSE                  R4
         TM    QSEFLAGS,QSELAST    TEST FOR UNI-SYSTEM NODE          R4
         BO    SPOBTAIN            BR IF YES                         R4
         TM    UCBTBYT2,UCBRR      TEST FOR SHARED DASD              R4
         BO    SPOBTAIN            BR IF YES                         R4
         AH    R1,$QSEL            POINT TO 2ND QSE                 R41
         TM    QSEFLAGS,QSELAST    MORE THAN 2 CPU'S DEFINED...     R41
         BNO   SPUCBERR            BR IF YES, MUST BE SHARED        R41
         L     R5,UCBEXTPT         GET UCB EXTENSION ADDRESS,       R41
         USING UCBCMEXT,R5          AND SET ADDRESSABILTY           R41
         TM    UCBFLP1,UCBSHRUP    IS SHARED-UP GENERATED...        R41
         BO    SPOBTAIN            BR IF YES, TEST NEXT UCB         R41
SPUCBERR MVC   SPLMSG,SPSHRMSG      ELSE                            R41
         MVC   SPLSHRVL,SPLVOLID     INFORM                          R4
         BAL   WE,SPWTO               OPERATOR                       R4
         B     SPUNALOC                AND BR TO EXIT                R4
         SPACE 1                                                     R4
         DROP  R1                  KILL QSE ADDRESSABILITY           R4
         DROP  R5                  KILL UCB EXT. ADDRESSABILITY     R41
         SPACE 1                                                    R41
SPOBTAIN DS    0H                                                    JN
         MVI   SPLCMLST,193            PREPARE                       R4
         XC    SPLCMLST+1(3),SPLCMLST+1 CAMLST                       R4
         LA    R0,SPLDSNAM               TO                          R4
         ST    R0,SPLCMLST+4              OBTAIN                     R4
         LA    R0,SPLVOLID                 SPOOL/CHECKPOINT          R4
         ST    R0,SPLCMLST+8                VOLUME                   R4
         LA    R0,SPLDSCB                    EXTENT                  R4
         ST    R0,SPLCMLST+12                 DATA                   R4
         OBTAIN SPLCMLST           GET SPOOL/CHECKPOINT DSCB         R4
         LTR   R15,R15             TEST OBTAIN                       R4
         BZ    SPOBTOK             BR IF OBTAIN SUCCESSFUL           R4
         MVC   SPLMSG,SPOBTERM     MOVE MESSAGE TO WORK AREA         R4
         MVC   SPLOBTVL,SPLVOLID   FILL IN                           R4
         SRL   R15,1                PERTINENT                        R4
         LA    R2,SPATAB-2(R15)      INFORMATION                     R4
         MVC   SPLOBTCC,0(R2)         AND                            R4
         MVC   SPLOBTDS,SPLDSNAM       INFORM                        R4
         BAL   WE,SPWTO                 OPERATOR                     R4
         OI    SPLFLG2,SPL2OBT     INDICATE OBTAIN ERROR             R4
         B     SPUNALOC             AND BR TO EXIT                   R4
         SPACE 1                                                     R4
SPOBTOK  MVC   SPLSTRCC,SPLDSCB+63 EXTRACT EXTENT LIMITS             R4
         TM    SPLFLG1,SPL1CKPT    TEST FOR SYS1.HASPCKPT            R4
         BO    SPTEDVLS            BR IF YES                         R4
         EJECT                                                      R41
***********************************************************************
*                                                                     *
*        CONSTRUCT DIRECT ACCESS DCB AND DEB                          *
*                                                                     *
***********************************************************************
         SPACE 1                                                     R4
         USING DCBDSECT,R1         PROVIDE DCB ADDRESSABILITY        R4
         USING DEBDSECT,R2         PROVIDE DEB ADDRESSABILITY        R4
         SPACE 1                                                     R4
         LA    R1,SPLDCB           GET DCB ADDRESS                   R4
         LA    R2,SPLDEB           GET DEB ADDRESS                   R4
         MVC   DCBTIOT((3+8)*4),SPDCBDEB  MOVE IN SKELETON DCB/DEB   R4
         ST    R2,DCBDEBAD         SET DEB ADDRESS IN DCB            R4
         MVC   DEBTCBB,SPLTCBPT+1  SET TCB ADDRESS IN DEB            R4
         STCM  R1,7,DEBDCBB        SET DCB ADDRESS IN DEB            R4
         MVC   DEBAPPB,CVTXAPG+1   DON'T USE JES2 APPENDAGES         R4
         LA    R2,DEBBASND         POINT TO 1ST DEB EXTENT           R4
         SPACE 1                                                     R4
         USING DEBDASD,R2          PROVIDE DEB EXTENT ADDRESSABILITY R4
         SPACE 1                                                     R4
         MVC   DEBSTRCC(8),SPLSTRCC  MOVE IN DEB EXTENT SKELETON     R4
         STH   R4,DEBUCBAD+2       SET UCB ADDRESS IN DEB            R4
         SPACE 1                                                     R4
         DROP  R1,R2               KILL DCB, DEB ADDRESSABILITY      R4
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        OBTAIN VALUES FOR TED CONSTRUCTION                           *
*                                                                     *
***********************************************************************
         SPACE 1                                                     R4
SPTEDVLS SLR   R14,R14             GET DEVICE TYPE                   R4
         IC    R14,UCBTBYT4         FROM UCB                         R4
         L     R3,CVTZDTAB         POINT TO DEVICE                   R4
         IC    R14,0(R3,R14)        CHARACTERISTICS TABLE            R4
         ALR   R14,R3                ENTRY FOR DEVICE                R4
         SPACE 1                                                     R4
         DROP  R3,R4               KILL CVT, UCB ADDRESSABILITY      R4
         USING SPZ,R14             PROVIDE TBL ENTRY ADDRESSABILITY  R4
         SPACE 1                                                     R4
         LH    R6,$BUFSIZE         ASSUME SPOOL BUFFER SIZE    @OZ20010
         TM    SPLFLG1,SPL1CKPT    TEST FOR CKPT DATA SET      @OZ20010
         BNO   *+8                 BR IF NORMAL SPOOL ALLOC    @OZ20010
         LH    R6,=H'4096'         ELSE, USE 4K AS RECORD SIZE @OZ20010
         LR    R5,R6               SET NOT-LAST-RECORD LENGTH        R4
         SLR   R7,R7               CLEAR R7, AND R10                 R4
         LR    R10,R7               FOR INSERTS                      R4
         IC    R7,SPZU             GET SUBTRAHEND FOR UNKEYED BLOCKS R4
         IC    R10,SPZL            GET LAST-BLOCK OVERHEAD           R4
         TM    SPZF,SPZF2305       TEST FOR 2305                     R4
         BZ    SKIP110             BR IF NO                          R4
         LH    R10,SPZO             ELSE GET HALFWORD OVERHEAD       R4
SKIP110  ALR   R6,R10              ADD OVERHEAD, SUBTRAHEND UNKEYED  R4
         SLR   R6,R7                FOR TRUE LAST-BLOCK LENGTH       R4
         TM    SPZF,SPZFT          SHOULD WE APPLY TOLERANCE...      R4
         BZ    SKIP120             BR IF NO                          R4
         MH    R5,SPZT              ELSE MULTIPLY BY TOLERANCE       R4
         SRL   R5,9                  AND DIVIDE BY 512               R4
SKIP120  TM    SPZF,SPZF2305       TEST FOR 2305                     R4
         BO    SKIP130             BR IF YES                         R4
         IC    R10,SPZNL            ELSE GET NOT-LAST-BLOCK OVERHEAD R4
SKIP130  ALR   R5,R10              ADD OVERHEAD, SUBTRAHEND UNKEYED  R4
         SLR   R5,R7                FOR NOT-LAST-BLOCK LENGTH        R4
         LH    R7,SPZR             GET TRACK LENGTH                  R4
         SLR   R7,R6               TAKE AWAY LAST-BLOCK LENGTH       R4
         SLR   R6,R6               GET COUNT OF                      R4
         DR    R6,R5                NOT-LAST BLOCKS                  R4
         LA    R6,1(,R7)           ADD 1 FOR RECORDS PER TRACK       R4
         STH   R6,SPLTNRT          STORE RECORDS PER TRACK           R4
         LH    R5,SPZH             GET NUMBER OF HEADS PER CYLINDER  R4
         ST    R5,SPLTNTC          STORE NUMBER OF HDS PER CYLINDER  R4
         LH    R7,SPZA             GET NUMBER OF ALTERNATE TRACKS    R4
         SLR   R6,R6               COMPUTE NUMBER                    R4
         DR    R6,R5                OF ALTERNATE CYLINDERS           R4
         LH    R6,SPZC             GET NUMBER OF CYLINDERS           R4
         SLR   R6,R7                LESS ALTERNATES                  R4
         MR    R4,R6               GET NUMBER OF TRACKS IN VOLUME    R4
         LH    R7,$NUMTGV          GET NUMBER OF GROUPS PER VOLUME   R4
         DR    R4,R7               STORE NUMBER OF                   R4
         STH   R5,SPLTNTG           TRACKS PER GROUP                 R4
         SPACE 1                                                     R4
         DROP  R14                 KILL TABLE ENTRY ADDRESSABILITY   R4
         EJECT                                                       R4
         TM    SPLFLG1,SPL1CKPT    TEST FOR SYS1.HASPCKPT            R4
         BO    SPGRPS              BR IF YES                         R4
         LTR   R5,R5               TEST TRACKS PER GROUP COUNT       R4
         BNZ   SPBLDIOB            BR IF &NUMTGV VALID FOR VOLUME    R4
         MVC   SPLMSG,SPTGVERM      ELSE ISSUE                       R4
         MVC   SPLFMTV3,SPLVOLID     ERROR MESSAGE                   R4
         BAL   WE,SPWTO               TO OPERATOR                    R4
         B     SPUNALOC                AND BR TO EXIT                R4
         SPACE 1                                                     R4
***********************************************************************
*                                                                     *
*        CONSTRUCT DIRECT ACCESS IOB                                  *
*                                                                     *
***********************************************************************
         SPACE 1                                                     R4
SPBLDIOB LA    WG,SPLIOB           POINT TO IOB                      R4
         XC    IOBFLAG1(11*4),IOBFLAG1  CLEAR IOB                    R4
         MVI   IOBFLAG1,X'C2'      SET UNRELATED, CMD+DATA CHAINING  R4
         LA    R0,SPLDCB           SET POINTER TO                    R4
         ST    R0,IOBDCBPT          DIRECT ACCESS DCB                R4
         LA    R0,SPLECB           SET POINTER TO                    R4
         ST    R0,IOBECBPT          EXCP IOB                         R4
         MVC   IOBSEEK+8(2),$BUFSIZE  SET SPOOL BUFFER SIZE          R4
         TM    SPLFLG1,SPL1FMT     TEST FORMATTING REQUIREMENT       R4
         BO    SPFORMAT            BR IF SET                         R4
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        READ COUNT PORTION OF 1ST RECORD ON LAST TRACK OF 1ST        *
*        EXTENT OF VOLUME TO DETERMINE WHETHER OR NOT VOLUME          *
*        IS CORRECTLY FORMATTED.                                      *
*                                                                     *
***********************************************************************
         SPACE 1                                                     R4
         LA    R0,SPLCCWS          SET POINTER TO                    R4
         ST    R0,IOBSTART          CHANNEL PROGRAM                  R4
         MVC   IOBSEEK+2(4),SPLUPLIM  SET CCHH FOR READ COUNT        R4
         MVC   SPLCCWS(3*8),SPREADCT  MOVE IN SKELETON CHANNEL PGM   R4
         LA    R0,IOBSEEK+2        SET POINTER                       R4
         STCM  R0,7,SPLCCW1+1       TO CCHH                          R4
         LA    R0,SPLCCW1          SET ADDRESS                       R4
         STCM  R0,7,SPLCCW2+1       FOR TIC *-8                      R4
         LA    R0,SPLRDCT          SET ADDRESS OF                    R4
         STCM  R0,7,SPLCCW3+1       READ-IN AREA                     R4
         BAL   WE,SPEXCP           GO TRY TO READ COUNT              R4
         BO    SKIP140             BR IF READ OK                     R4
         OI    SPLFLG2,SPL2RDER     ELSE INDICATE READ ERROR         R4
SKIP140  MVI   SPLRDCT+4,0         SET READ-IN RECORD COUNT TO 0     R4
         CLC   SPLRDCT,IOBSEEK+2   COMPARE COUNT WITH EXPECTED       R4
         BE    SKIP150             BR IF EQUAL                       R4
         OI    SPLFLG2,SPL2RDER     ELSE INDICATE READ ERROR         R4
SKIP150  TM    SPLFLG1,SPL1NFMT    TEST FORMATTING REQUIREMENT       R4
         BO    SPGRPS              BR IF FORMATTING NOT ALLOWED      R4
         TM    SPLFLG2,SPL2RDER    TEST FOR READ ERROR               R4
         BZ    SPGRPS              BR IF NO                          R4
         NI    SPLFLG2,255-SPL2RDER  ELSE RESET READ ERROR FLAG      R4
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        FORMAT SYS1.HASPACE ON SPOOL VOLUME                          *
*                                                                     *
***********************************************************************
         SPACE 1                                                     R4
SPFORMAT MVC   SPLMSG,SPFMTMSG     ISSUE                             R4
         MVC   SPLFMTV1,SPLVOLID    FORMATTING MSG                   R4
         BAL   WE,SPWTO              TO OPERATOR                     R4
         LH    R2,SPLTNRT          GET NUMBER OF RECORDS PER TRACK   R4
         LR    R3,R2               SAVE IN R3                        R4
         SLL   R2,4                COMPUTE                           R4
         LA    R0,16(,R2)           WORK AREA                        R4
         ST    R0,SPLGMAIN           SIZE                            R4
         GETMAIN R,LV=(0)          OBTAIN WORK AREA                  R4
         ST    R1,IOBSTART         SET CHANNEL PROGRAM ADDRESS       R4
         ST    R1,8(,R1)           SET UP                            R4
         MVI   8(R1),8              TIC COMMAND                      R4
         MVC   0(8,R1),SPREADCT    SET                               R4
         LA    R0,IOBSEEK+2         SEARCH                           R4
         STCM  R0,7,1(R1)            COMMAND                         R4
         LA    R1,8(,R1)           POINT 8 BEFORE 1ST WRITE CCW      R4
         LR    R2,R3               GET NUMBER OF RECORDS PER TRACK   R4
         SLL   R2,3                POINT TO 8 BEFORE                 R4
         ALR   R2,R1                1ST COUNT FIELD                  R4
         ICM   R2,8,=X'1D'         SET WRITE COUNT-KEY-DATA          R4
         LR    R0,R3               GET CCW COUNT                     R4
         L     R3,SPFDATL          GET RIGHT HALF OF CCW             R4
         SPACE 1                                                     R4
SKIP160  AL    R2,=F'8'            CONSTRUCT                         R4
         LA    R1,8(,R1)            FORMAT                           R4
         STM   R2,R3,0(R1)           CHANNEL                         R4
         BCT   R0,SKIP160             PROGRAM                        R4
         SPACE 1                                                     R4
         NI    4(R1),X'BF'         TURN OFF LAST CCW'S CC FLAG       R4
         ST    R1,SPLCFLDS         SAVE PTR TO 8 BEFORE 1ST CT FIELD R4
         MVC   IOBSEEK+2(4),SPLOWLIM  STARTING CCHHRKDD              R4
         EJECT                                                       R4
SPFMTRK  LH    R0,SPLTNRT          GET NUMBER OF COUNT FIELDS        R4
         L     R1,SPLCFLDS         POINT TO 8 BEFORE THE FIRST       R4
         ICM   R2,15,IOBSEEK+2     STARTING                          R4
         ICM   R3,15,IOBSEEK+6      CCHHRKDD                         R4
         SPACE 1                                                     R4
SKIP170  AL    R3,=FS24'1'         ADD 1 TO RECORD NUMBER            R4
         LA    R1,8(,R1)           POINT TO NEXT COUNT FIELD         R4
         STM   R2,R3,0(R1)         SET COUNT FIELD                   R4
         BCT   R0,SKIP170          LOOP TO SET THE REST              R4
         SPACE 1                                                     R4
         BAL   WE,SPEXCP           GO FORMAT THE TRACK               R4
         BZ    SPFMTERR            BR IF I/O ERROR                   R4
         SLR   R2,R2               GET CURRENT                       R4
         ICM   R2,3,IOBSEEK+4       HEAD NUMBER                      R4
         LA    R2,1(,R2)           ADD 1 TO IT                       R4
         C     R2,SPLTNTC          TEST FOR MAX                      R4
         BL    SKIP180             BR IF NO                          R4
         SR    R2,R2                ELSE MAKE IT ZERO (AND SET CC)   R4
SKIP180  STCM  R2,3,IOBSEEK+4      SET NEW HEAD NUMBER               R4
         BNZ   SKIP190             BR IF SAME CYLINDER               R4
         ICM   R2,3,IOBSEEK+2       ELSE                             R4
         LA    R2,1(,R2)             ADD 1                           R4
         STCM  R2,3,IOBSEEK+2         TO CYLINDER NUMBER             R4
SKIP190  CLC   SPLUPLIM(4),IOBSEEK+2  IS FORMATTING COMPLETE...      R4
         BNL   SPFMTRK             BR IF NO                          R4
         SPACE 1                                                     R4
         BAL   WE,SPFREEWK         FREE WORK STORAGE                 R4
         B     SPGRPS              THEN BR TO GET TRK GROUP INFO     R4
         SPACE 1                                                     R4
SPFMTERR MVC   SPLMSG,SPFMTERM     ISSUE                             R4
         MVC   SPLFMTV2,SPLVOLID    ERROR MSG                        R4
         BAL   WE,SPWTO              TO OPERATOR                     R4
         OI    SPLFLG2,SPL2FMT     INDICATE I/O ERROR                R4
         BAL   WE,SPFREEWK         FREE WORK STORAGE                 R4
         B     SPUNALOC             AND BR TO EXIT                   R4
         SPACE 1                                                     R4
SPFREEWK L     R0,SPLGMAIN         FREE                              R4
         L     R1,IOBSTART          WORK                             R4
         FREEMAIN R,LV=(0),A=(1)     STORAGE                         R4
         BR    WE                  THEN RETURN                       R4
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        OBTAIN SYS1.HASPCKPT/SYS1.HASPACE EXTENT INFORMATION         *
*                                                                     *
*        R1 LEFT WITH NUMBER OF 1ST USABLE TRACK GROUP                *
*        R2 LEFT WITH COUNT OF USABLE TRACK GROUPS                    *
*                                                                     *
***********************************************************************
         SPACE 1                                                     R4
SPGRPS   LA    R0,SPLTGM           SET                               R4
         LH    R1,$NUMTGV           TRACK                            R4
         LA    R1,7(,R1)             GROUP                           R4
         SRL   R1,3                   MAP                            R4
         SLR   R15,R15                 TO                            R4
         MVCL  R0,R14                   ZERO                         R4
         LH    R1,SPLOWLIM         R14 = TRACK                       R4
         M     R0,SPLTNTC                 NUMBER                     R4
         AH    R1,SPLOWLIM+2               OF 1ST                    R4
         LR    R14,R1                       TRACK                    R4
         STH   R14,SPLOWTRK        SET LOWER ABSOLUTE TRACK NUMBER   R4
         LH    R2,SPLTNTG          R1 = TRACK                        R4
         DR    R0,R2                     GROUP NUMBER                R4
         LTR   R0,R0                      OF 1ST                     R4
         BZ    SKIP200                     USABLE                    R4
         LA    R1,1(,R1)                    TRACK GROUP              R4
SKIP200  LH    R15,SPLUPLIM        R15 = TRACK NUMBER                R4
         MH    R15,SPLTNTC+2              OF LAST                    R4
         AH    R15,SPLUPLIM+2              TRACK                     R4
         STH   R15,SPLUPTRK        SET UPPER ABSOLUTE TRACK NUMBER   R4
         LA    R0,1(,R15)          SET NUMBER                        R4
         SLR   R0,R14               OF TRACKS                        R4
         STH   R0,SPLNMTRK           IN EXTENT                       R4
         LH    R3,$NUMTGV          R3 = UNUSABLE                     R4
         MH    R3,SPLTNTG                TRACKS                      R4
         BCTR  R3,0                       BEYOND                     R4
         SR    R3,R15                      END                       R4
         BNM   SKIP210                      OF                       R4
         SLR   R3,R3                         EXTENT                  R4
SKIP210  SLR   R2,R2               R3 = UNUSABLE                     R4
         LH    R0,SPLTNTG                TRACK GROUPS                R4
         DR    R2,R0                      CAUSED                     R4
         LTR   R2,R2                       BY                        R4
         BZ    SKIP220                      UPPER                    R4
         LA    R3,1(,R3)                     EXTENT                  R4
SKIP220  LH    R2,$NUMTGV          R2 = NUMBER OF                    R4
         SLR   R2,R1                     USABLE TRACK                R4
         SR    R2,R3                      GROUPS                     R4
         ST    R2,SPLNUMTG         SET COUNT OF USABLE TRACK GROUPS  R4
         BNP   SPERRTST            EXIT IF NONE                      R4
         TM    SPLFLG1,SPL1CKPT    TEST FOR SYS1.HASPCKPT            R4
         BO    SPERRTST            BR IF YES                         R4
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        PREPARE BIT MAP FOR SPOOL VOLUME                             *
*                                                                     *
***********************************************************************
         SPACE 1                                                     R4
         LA    R14,SPLTGM          CLEAR                             R4
         LH    R15,$NUMTGV          VOLUME                           R4
         LA    R15,7(,R15)           TRACK                           R4
         SRL   R15,3                  GROUP                          R4
         SLR   R5,R5                   BIT                           R4
         MVCL  R14,R4                   MAP                          R4
         SLDL  R0,29               R15 = BYTE ADDRESS                R4
         LA    R15,SPLTGM                 IN VOLUME BIT MAP          R4
         ALR   R15,R0                      OF FIRST USABLE           R4
         SRL   R1,29                        TRACK GROUP              R4
         SPACE 1                                                     R4
SPNXTGRP IC    R3,SPBITBLE(R1)     GET BIT INTO R3                   R4
         EX    R3,SPBITSET         OR BIT INTO TRACK GROUP MAP       R4
         LA    R1,1(,R1)           ADD 1 TO BIT NUMBER               R4
         N     R1,=F'7'            ZERO ALL BUT LO-ORDER 3 BITS      R4
         BNZ   SKIP230             BR IF BIT IN SAME BYTE            R4
         LA    R15,1(,R15)          ELSE ADD 1 TO BYTE ADDRESS       R4
SKIP230  BCT   R2,SPNXTGRP         LOOP THRU ALL TRACK GROUPS        R4
         SPACE 1                                                     R4
         B     SPERRTST            THEN EXIT                         R4
         SPACE 1                                                     R4
SPBITSET OI    0(R15),*-*          *** EXECUTE ONLY ***              R4
         EJECT                                                       R4
SPERRTST CLI   SPLFLG2,0           TEST FOR ANY ERRORS               R4
         BE    SPEXIT              BR IF NO                          R4
         SPACE 1                                                     R4
***********************************************************************
*                                                                     *
*        ERROR DETECTED -- UNALLOCATE VOLUME                          *
*                                                                     *
***********************************************************************
         SPACE 1                                                     R4
SPUNALOC OC    SPLUCBPT,SPLUCBPT   TEST FOR UCB ADDRESS              R4
         BZ    SPEXIT              BR IF NO (VOLUME NEVER ALLOC'D)   R4
         LA    R10,SPLDYNRB        GET RB ADDRESS                   R41
         MVI   S99VERB,S99VRBUN    INDICATE UNALLOCATE REQUEST       R4
         OI    SPLFLG2,SPL2UNAL    INDICATE VOLUME UNALLOCATED      R41
         LA    R1,SPLDYNAL         POINT TO PARAMETER LIST           R4
         DYNALLOC                   AND UNALLOCATE THE VOLUME        R4
         SPACE 5                                                     R4
***********************************************************************
*                                                                     *
*        EXIT FROM SUBTASK                                            *
*                                                                     *
***********************************************************************
         SPACE 1                                                     R4
SPEXIT   L     R13,SPLSAVE+4       GET SYSTEM'S SAVE AREA ADDRESS    R4
         LM    R14,R12,12(R13)     RESTORE SYSTEM'S REGISTERS        R4
         BR    R14                  AND RETURN                       R4
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        SPEXCP -- EXCP SUBROUTINE                                    *
*                                                                     *
***********************************************************************
         SPACE 1                                                     R4
SPEXCP   EXCP  SPLIOB              INITIATE I/O OPERATION            R4
         WAIT  ECB=SPLECB          WAIT FOR I/O TO COMPLETE          R4
         TM    SPLECB,X'20'        TEST FOR ERROR                    R4
         BR    WE                  RETURN WITH CC SET                R4
         SPACE 3                                                     R4
***********************************************************************
*                                                                     *
*        SPWTO -- SUBROUTINE TO ISSUE MESSAGE TO OPERATOR             *
*                                                                     *
***********************************************************************
         SPACE 1                                                     R4
SPWTO   $$WTO  SPLMSG              ISSUE MESSAGE TO OPERATOR         R4
         BR    WE                  THEN RETURN                       R4
         SPACE 1                                                     R4
         DROP  ,                   KILL ALL ADDRESSABILITY           R4
         SPACE 5                                                     R4
         LTORG                                                       R4
         EJECT                                                       R4
SPALFLGS EQU   S99WTVOL+S99NORES+S99MOUNT  ALLOCATION FLAGS          R4
         SPACE 1                                                     R4
SPDCBDEB DS    0F                  DCB/DEB SKELETONS                 R4
         DC    AL2(0),AL1(DCBMRECP+DCBMRAPG)     DCBTIOT, DCBMACRF   R4
         DC    AL1(0),A(0),AL1(DCBOFOPN),AL3(0)  DCBOFLGS            R4
         DC    A(0),AL1(4),AL3(0)                DEBTCBAD, DEBAMLNG  R4
         DC    AL1(DEBDSMOD+DEBDCB),AL3(0)       DEBOFLGS            R4
         DC    AL1(DEBINOUT),AL3(0)              DEBINOUT            R4
         DC    AL1(1),AL3(0),A(0)                DEBNMEXT            R4
         DC    AL1(1*16+15),AL3(0)               DEBPROTG/DEBDEBID   R4
         DC    AL1(4),AL3(0)                     DEBEXSCL            R4
         SPACE 1                                                     R4
SPREADCT CCW   X'31',*-*,X'40',5   SEARCH ID EQUAL                   R4
         CCW   8,*-8,0,1           TIC *-8                           R4
         CCW   X'12',*-*,0,8       READ COUNT                        R4
         SPACE 1                                                     R4
SPDDTXT  DC    AL2(DALDDNAM,1,7)   MODEL DDNAME TEXT                 R4
         DC    C'$'                1ST CHARACTER OF DDNAME           R4
SPDSNTXT DC    AL2(DALDSNAM,1,13)  MODEL DSNAME TEXT                 R4
SPVOLTXT DC    AL2(DALVLSER,1,6)   MODEL VOLUME SERIAL TEXT          R4
SPUNITXT DC    AL2(DALUNIT,1,3)    MODEL UNIT NAME TEXT              R4
SPDSPTXT DC    AL2(DALSTATS,1,1),AL1(1)  MODEL DISPOSITION TEXT      R4
         SPACE 1                                                     R4
SPFDATL  DC    0F'0',X'60',AL3(8)  RIGHT HALF OF CCW                 R4
         SPACE 1                                                     R4
SPATAB   DC    C'4 8 121620'       OBTAIN ERROR CC TABLE       @OZ18393
SPBITBLE DC    X'8040201008040201' BITS-BY-BIT NUMBER TABLE          R4
         SPACE 2                                                     R4
***********************************************************************
*                                                                     *
*        DEVICE CHARACTERISTICS TABLE ENTRY DSECT                     *
*                                                                     *
***********************************************************************
         SPACE 1                                                     R4
SPZ      DSECT                     IECZDTAB DUMMY SECTION            R4
SPZC     DS    H                   NUMBER OF CYLINDERS PER VOLUME    R4
SPZH     DS    H                   NUMBER OF TRACKS PER CYLINDER     R4
SPZR     DS    H                   MAXIMUM TRACK LENGTH              R4
SPZO     DS    0H                  BLOCK OVERHEAD -- 2305            R4
SPZNL    DS    X                   BLOCK OVERHEAD -- KEYED           R4
SPZL     DS    X                   BLOCK OVERHEAD -- KEYED LAST      R4
SPZU     DS    X                   BLOCK OVERHEAD -- UNKEYED         R4
SPZF     DS    X                   FLAGS --                          R4
SPZFT    EQU   1                      APPLY TOLERANCE FACTOR         R4
SPZF2305 EQU   8                      DEVICE IS 2305                 R4
SPZT     DS    H                   TOLERANCE FACTOR IF SPZFT         R4
SPZA     DS    H                   NUMBER OF ALTERNATE TRACKS        R4
         SPACE 1                                                     R4
HASPMISC CSECT                     END OF IECZDTAB DUMMY SECTION     R4
         EJECT                                                       R4
        $MID   414                 SET MESSAGE NUMBER                R4
SPOBTERM WTO   '&MID.OBTAIN FAILED FOR ********.******** ON ****** WITHC
                CC **',MF=L                                         R41
SPLOBTDS EQU   *-38-SPOBTERM+SPLMSG,17  DATA SET NAME               R41
SPLOBTVL EQU   *-17-SPOBTERM+SPLMSG,6   VOLUME SERIAL                R4
SPLOBTCC EQU    *-2-SPOBTERM+SPLMSG,2   COMPLETION CODE              R4
         SPACE 2                                                     R4
        $MID   418                 SET MESSAGE NUMBER                R4
SPFMTERM WTO   '&MID.PERM I/O ERROR ON ****** WHILE FORMATTING',MF=L R4
SPLFMTV2 EQU   *-23-SPFMTERM+SPLMSG,6   VOLUME SERIAL                R4
         SPACE 2                                                     R4
        $MID   423                 SET MESSAGE NUMBER                R4
SPFMTMSG WTO   '&MID.****** IS BEING FORMATTED',MF=L                 R4
SPLMSGID EQU   *-34-SPFMTMSG+SPLMSG,1   MESSAGE ID CHARACTER         R4
SPLFMTV1 EQU   *-25-SPFMTMSG+SPLMSG,6   VOLUME SERIAL                R4
         EJECT                                                       R4
        $MID   438                 SET MESSAGE NUMBER                R4
SPTGVERM WTO   '&MID.&&NUMTGV EXCEEDS TRACKS ON VVVVVV',MF=L         R4
SPLFMTV3 EQU   *-6-SPTGVERM+SPLMSG,6  VOLUME SERIAL                  R4
         SPACE 2                                                     R4
        $MID   449                 SET MESSAGE NUMBER                R4
SPSHRMSG WTO   '&MID.VVVVVV MUST BE MOUNTED ON SHAREABLE DEVICE',    R4C
               MF=L                                                  R4
SPLSHRVL EQU   *-42-SPSHRMSG+SPLMSG,6  VOLUME SERIAL                 R4
         SPACE 2                                                     R4
$MISCLEN $DLENGTH                  COMPUTE CONTROL SECTION LENGTH    R4
         SPACE 5                                                     R4
APARNUM  DC    CL5'32185'          APAR NUMBER
         END   ,                                                     R4
