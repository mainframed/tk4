         TITLE 'DATA GEN ROUTINE-IFFAHA04'
*
*        THE DATA GENERATOR IS ENTERED FROM PLINE/PPNT,STPOS/MVPOS,
*        PSGMT,AND PLSTR. ITS FUNCTION IS TO GENERATE VECTORS AND
*        POINTS, BLANKED AND UNBLANKED,KEYED AND NOT KEYED,ABSOLUTE,
*        INCREMENTAL, OR OPTIMIZED. IT WILL PROVIDE THE INCLUDE/
*        OMIT STRUCTURE FOR BOTH SINGLE AND MULTIPLE ELEMENTS AND
*        WILL GENERATE THE REPOSITIONING VECTOR WHEN NECESSARY.
*
*                       DATA GENERATOR WILL BE ENTERED WITH
*                       THE ADDRESS OF THE FOLLOWING AREA IN
*                       REGISTER 1
*
*                       +0  KEY START
*                       +4  FLAGS
*                       +8  CORVAL
*                       +12 ADDR IN USER PROG TO PLACE KEY IN
*                       +16 GDSCB ADDR
*                       +20 RETURN CODE ARRAY ADDR
*                       +24 POSITIONING VECT X ABS
*                       +28 POSITIONING VECT Y ABS
*                       +32 POSIT VECT X INCR
*                       +36 POSIT VECT Y INCR
*                       +40 X ABS
*                       +44 Y ABS
*                       +48 X INCR
*                       +52 Y INCR
*                       +56 TOTAL X INCR
*                       +60 TOTAL Y INCR
*                       +64 ENTRY NUMBER (NOT USED BY THIS RTN)
*
*
*
*        EXTERNAL REFERENCES:
*
*        IFFAHA05-DATA STORE
*
*        EXTERNAL MACROS:
*
*        NONE
*
         EJECT
*        ON ENTRY THE REGISTERS ARE SAVED, THE SAVE AREAS ARE
*        CHAINED, SWITCHES ARE INITIALIZED, DSECTS ARE INITIALIZED,
*        AND THE ADDRESS OF DATA STORE IS OBTAINED FROM THE STATUS
*        TABLE AND SAVED.
*
IFFAHA04 CSECT
*A122000-122600,A204050-204800,D243100-245000,D263100-264966,    YM1963
*A325040-325800,C454000,D455500,A477200-477600,D496500-496600,   YM1963
*A509300-509600                                                  YM1963
*A319300-319600,A324500,C325040-325080,D325440-325640,       LD YA00805
*A325440-325540,C325680,D325760,D465600,C477200,             LD YA00805
*D477600
*C323000,C324500-325200,D325240-325400,A325300-325340,       LD YA01038
*A477900                                                     LD YA01038
*A325640-325668                                              JM YA02056
*C116000,A115540-115980,A117500,A120500,A477920-477980      L5 @ZA04162
*C325664,325800                                             L5 @ZA04160
*A166000-166800,A167500                                     D11 ZA04870
*A586200-586400,A743000                                     D11 ZA10055
*A400000-405400,C415000,609500                              D11 ZA14052
*A405600-406000                                             D11 ZA16577
*D609500,C612000-613000,D614000-615000                      D11 ZA17700
*
         SAVE  (14,12)
         BALR  BASE,0
         USING *,BASE              ADDRESSABILITY
         LR    WORK,PARM
         USING WORKAREA,WORK       SET UP WORK DSECT
         L     GDSREG,WRKGDS
         USING GDSCB,GDSREG        SET UP GDSCB DSECT
         ST    SAVE,WRKSAVE+4      CHAIN SAVE AREAS
         LA    REGA,WRKSAVE
         ST    REGA,EIGHT(SAVE)
         LR    SAVE,REGA
         L     REGFIFTN,WRKRTN     LOCATE THE ADDRESS
         L     REGFIFTN,STAT(REGFIFTN)  OF DATA STORE FROM
         L     REGFIFTN,DSTOR(REGFIFTN) THE STATUS TABLE AND
         ST    REGFIFTN,WRKDSTOR   PLACE IN THE WORK AREA
         LA    REGD,0              COUNT
         LA    REGC,WRKOUTPT+4     ADDR OF ORDERS
         XC    WRKOUTPT(4),WRKOUTPT    ZERO FIRST WORD
         MVI   WRKSW,FIRST         SET FIRST IN SW
         MVI   WRKSW+1,X'00'       SET NO POSIT VECT SW
         EJECT
*
*        A CHECK IS MADE TO SEE IF ENTRY IS MADE MERELY TO COMPLETE
*        A MULTIPLE KEY WHICH REQUIRES THE GENERATION OF A REPOSI-
*        TIONING VECTOR. IF SO A BRANCH IS MADE TO THAT PART OF THE
*        PROGRAM.
*
         TM    WRKBITS+2,REPONLY   CALLED FOR ONLY REPOS VECT
         BO    DAT01870            YES
*
*        WHEN THIS ROUTINE IS ENTERED THERE MAY BE ONE OR TWO
*        VECTORS OR POINTS TO BE GENERATED. NOTE: OFTEN I WILL
*        REFER TO BOTH VECTORS AND POINTS AS JUST VECTORS.
*        IF SCISSORING HAS OCCURED AND AS A RESULT A BLANKED
*        POSITIONING VECTOR IS NEEDED IN ADDITION TO THE VECTOR
*        REQUESTED THIS WILL EXPLAIN THE SECOND VECTOR. IF A
*        POSITIONING VECTOR IS REQUIRED IT IS MOVED INTO THE
*        WORK FIELD. IF NONE IS REQUIRED, THE FIRST SWITCH IS
*        TURNED OFF AND THE REQUESTED VECTOR IS MOVED INTO THE
*        WORK FIELD.
*
         CLC   WRKDATA1(SIXTN),ZERO IS THERE A POS VECT
         BE    DAT00400            NO
         MVC   WRKTXABS(SIXTN),WRKDATA1 MOVE POS VECT INTO WORK AREA
*
*        A CHECK IS MADE TO SEE IF THIS IS THE FIRST PASS, IN
*        OTHER WORDS, DOES AN INCLUDE OMIT STRUCTURE NEED TO
*        BE BUILT FIRST?
*
DAT00050 TM    WRKBITS+2,FRSTPASS  IS THIS THE FIRST PASS
         BNE   DAT00150            NO
*                                  IF NOT FIRST PASS, MODE IS ALREADY
*                                  SET OR OPTIMIZED SO DOESN'T MATTER
*                                  IF KEYED OR NOT
DAT00100 TM    WRKBITS+2,KEYED+CORVLD KEYED OR CORRELATED FIRST PASS
         BNE   DAT03400            YES, GO TO SET UP INCLUDE/OMIT STR.
*
*        THIS POINT IS WHERE THE DATA GENERATOR IS REENTERED
*        FROM SEVERAL PLACES. IF IT IS NOT A FIRST PASS THE
*        CODING FALLS THROUGH TO THIS POINT. IF THE SECOND
*        VECTOR IS TO BE GENERATED WHEN TWO ARE REQUIRED THIS
*        POINT IS BRANCHED TO. IF GENERATION OF THE FIRST
*        VECTOR IS TO BE DONE AFTER AN INCLUDE OMIT STRUCTURE
*        HAS BEEN BUILT, THIS POINT IS BRANCHED TO. AND LAST,
*        FOR THE REPOSITIONING VECTOR AT THE END OF THE ELEMENT
*        THIS POINT IS BRANCHED TO. AT THIS POINT THE PATHS
*        WILL SPLIT DEPENDING ON WHETHER ABSOLUTE, INCREMENTAL,
*        OR OPTIMIZED OUTPUT IS DESIRED. OPTIMIZED OUTPUT IS
*        MERELY THE PATH THAT DETERMINES WHETHER THE VECTOR
*        WOULD BEST BE PUT OUT AS INCREMENTAL OR ABSOLUTE.
*
DAT00150 TM    WRKBITS,ABS         ABSOLUTE
         BZ    DAT01100            YES
         TM    WRKBITS,INCR        INCREMENTAL
         BM    DAT01900            YES
         EJECT
*
*        WHEN OPTIMIZED OUTPUT IS DESIRED, THE LENGTH OF THE INCRE-
*        MENTAL VECTOR IS COMPUTED. THE TESTING PATHS WILL SPLIT
*        DEPENDING ON WHETHER POINT(S) OR VECTOR(S) ARE DESIRED.
*
*        DETERMINATION OF INCREMENTAL OR ABSOLUTE GENERATION
*        IS AS FOLLOWS:
*
*  A.    IF THE MODE SET IS CURRENTLY INCREMENTAL:
*        THREE OR LESS INCREMENTAL VECTORS WILL BE GENERATED
*        INCREMENTAL. IF MORE THAN THREE INCREMENTAL VECTORS
*        IS DESIRED THEY ARE GENERATED ABSOLUTE.
*  B.    IF THE MODE IS CURRENTLY ABSOLUTE:
*        IF ONE INCREMENTAL VECTOR IS DESIRED IT IS GENERATED
*        INCREMENTAL. OTHERWISE THE VECTOR IS GENERATED
*        ABSOLUTE.
*  C.    IF NEITHER MODE IS SET:
*        THREE OR LESS INCREMENTAL VECTORS WILL BE GENERATED
*        INCREMENTAL. IF MORE THAN THREE ARE DESIRED THEY ARE
*        GENERATED ABSOLUTE.
*
*        OPTIMIZED OUTPUT
DAT00200 L     REGA,WRKTXINC       LOAD INCR
         L     REGB,WRKTYINC       LOAD INCR
         LPR   REGA,REGA           COMPUTE +
         LPR   REGB,REGB           COMPUTE +
         SRA   REGA,2              DIV BY 4 TO 1024 BASE
         SRA   REGB,2              DIV BY 4 TO 1024 BASE
         SRA   REGA,6              DIV BY 64 TO COMPUTE NO OF INCR VECT
         SRA   REGB,6              REQD
         CR    REGB,REGA           FIND LARGEST IF ANY
         BL    DAT00500
DAT00300 LA    REGB,ONE(REGB)      ADD ONE FOR ONE SHIFTED OFF EVEN IF
*                                  EVEN MULT OF 64, LARGEST + VECT IS
*                                  63
         TM    WRKBITS,VECT        VECTOR
         BZ    DAT00800            YES
         TM    GDSGRMOD,PI         POINT,INCR=CURR MODE?
         BO    DAT00600            YES
         TM    GDSGRMOD,PA         POINT, ABS
         BO    DAT00700            YES
         C     REGB,THREE          THREE OR LESS INCR
         BH    DAT01250            GENERATE ABS & SET MODE-PT
         B     DAT02000            GENERATE INCR & SET MODE PT
         EJECT
DAT00400 MVI   WRKSW,OFF           TURN OFF FIRST SWITCH
         MVC   WRKTXABS(SIXTN),WRKXABS MOVE IN SECOND VECTOR
         B     DAT00050
DAT00500 LR    REGB,REGA           PLACE LARGEST IN REGB
         B     DAT00300
DAT00600 C     REGB,THREE          3 INCR RQD
         BH    DAT01250            MORE- GENERATE AN ABS PNT & SET MODE
         B     DAT02100            NO, GO GENERATE REQD INCR PNT
DAT00700 C     REGB,ONEFLD         1 INCR RQD
         BE    DAT02000            YES GEN INCR PNT  & SET MODE
         B     DAT01300            NO GENERATE ABS PNT
DAT00800 TM    GDSGRMOD,VI         VECTOR INCR= CURRENT MODE
         BO    DAT00900            YES
         TM    GDSGRMOD,VA         VECT ABS?
         BO    DAT01000            YES
         C     REGB,THREE          3 OR LESS INCR
         BH    DAT01700            GENER ABS & SET MODE-VECT
         B     DAT03100            GENER INCR & SET MODE-VECT
DAT00900 C     REGB,THREE          3 INCR RQD
         BH    DAT01700            MORE-GEN AN ABS VECT & SET MODE
         B     DAT02100            NO, GEN REQD INCR VECT
DAT01000 C     REGB,ONEFLD         1 INCR RQD
         BE    DAT03100            YES, GEN INCR VECT & SET MODE
         B     DAT01300            NO, GENERATE ABS VECT
         EJECT
*
*        WHEN ABSOLUTE OUTPUT IS TO BE GENERATED: A TEST IS
*        MADE TO SEE IF VECTORS OR POINTS ARE DESIRED, THEN IT
*        IS DETERMINED IF THE MODE IS ALREADY SET TO VECTOR
*        ABSOLUTE OR POINT ABSOLUTE, RESPECTIVELY. IF NOT,
*        THE SET MODE ORDER IS PLACED IN THE WORK AREA FOR
*        THE DATA STORE ROUTINE AND THE LENGTH OF THE ELEMENT
*        THUS FAR IS SET TO TWO. THE POINT AND VECTOR
*        PATH THEN COME TOGETHER AGAIN BECAUSE THE ACTUAL
*        COORDINATES APPEAR THE SAME REGARDLESS OF POINT OR
*        VECTOR.
* ABSOLUTE OUTPUT
* DAT01100  EQU  DAT01200
DAT01200 TM    WRKBITS,VECT        VECTOR
         BZ    DAT01700            YES
DAT01250 EQU   *                                            L5 @ZA04162
         L     REGA,GDSGTMCB       GET ADDR GTMCB           L5 @ZA04162
         TM    GTMUPDT(REGA),PPNTUPDT  POINT UPDATE?        L5 @ZA04162
         BNO   DAT01251            BRANCH IF NO             L5 @ZA04162
         L     REGA,WRKKEY         ADDRESS OF KEY           L5 @ZA04162
         TM    KEYWD2(REGA),STMODE  1'ST ORDER SET MODE?    L5 @ZA04162
         BO    DAT01252            IF YES,WE WILL ADD       L5 @ZA04162
*                                  ELSE IT MAY NOT FIT      L5 @ZA04162
DAT01251 EQU   *                                            L5 @ZA04162
         TM    GDSGRMOD,PA         MODE ALREADY SET
         BO    DAT01300            YES
DAT01252 EQU   *                                            L5 @ZA04162
         MVC   0(2,REGC),GEPMORD   MOVE IN SET MODE
         LA    REGD,2(REGD)        ADD TO COUNT
         LA    REGC,2(REGC)        POSIT OUTPUT AREA
DAT01253 EQU   *                                            L5 @ZA04162
         MVI   GDSGRMOD,PA         SET CURRENT MODE=PT   ABS
*
*        THE X AND Y VALUES ARE PLACED IN THE AREA FOR DATA
*        STORE . IF THIS IS THE FIRST VECTOR OF TWO THE BEAM
*        BIT IS TURNED ON TO INDICATE BLANKED. IF THIS IS
*        THE REPOSITIONING VECTOR IT IS ALSO BLANKED. FINALLY,
*        IF THE BEAM IS TO BE BLANKED AS IN A REQUEST FROM
*        STPOS THE BEAM IS SET TO BE BLANKED
DAT01300 MVC   GDSXCOR(8),ZERO          ZERO X AND Y CORR FACTOR YM1963
*                                       THE MODE FOR THIS GDS    YM1963
*                                       IS NOW ABSOLUTE          YM1963
         MVC   0(2,REGC),WRKTXABS+2     XABS IN OUT AREA         YM1963
         MVC   2(2,REGC),WRKTYABS+2 YABS
         CLI   WRKSW,FIRST         FIRST
         BE    DAT01350            NO
         CLI   WRKSW+1,REPOS       IS THIS THE REPOSITIONING VECT
         BE    DAT01350            YES BLANK IT
         TM    WRKBITS+2,BEAMON    BEAM ON
         BO    DAT01400            YES
DAT01350 OI    0(REGC),BEAMABS     TURN BEAM OFF
DAT01400 LA    REGD,4(REGD)        ADD LENGTH OF VECTOR
         LA    REGC,4(REGC)        POSITION OUTPUT AREA
DAT01500 CLI   WRKSW,FIRST         BOTH DONE
         BE    DAT01850
         EJECT
*
*        AT THIS POINT IF THE SECOND OR ONLY VECTOR HAS BEEN
*        GENERATED, THE TOTAL X AND Y INCREMENT FIELDS ARE
*        INCREASED BY THE INCREMENTS OF THIS CALL TO THE
*        GENERATOR. THESE FIELDS ARE USED BY THE DATA GENERATOR
*        TO GENERATE THE INCREMENTAL REPOSITIONING VECTOR IF
*        DESIRED. IF THIS IS NOT A SINGLE ENTRY, THE DATA
*        STORE ROUTINE IS CALLED TO PLACE THE DATA IN THE
*        GDOA AND OVERFLOW IF NECESSARY.
*
         L     REGA,WRKTOTX
         A     REGA,WRKDATA3       COMPUTE TOTAL X INCR
         A     REGA,WRKXINCR       THUS FAR
         ST    REGA,WRKTOTX
         L     REGA,WRKTOTY
         A     REGA,WRKDATA4       COMPUTE TOTAL Y INCR
         A     REGA,WRKYINCR       THUS FAR
         ST    REGA,WRKTOTY
         ST    REGD,WRKOUTPT       LENGTH OF DATA GENERATED
         TM    WRKBITS,MULT        MULTIPLE ENTRY
         BZ    DAT01800            NO GO SEE IF KEY NEEDS FIXING
DAT01550 MVC   WRKGDS1(EIGHT),WRKGDS
         LA    PARM,WRKGDS1
*//      CALL  DATA STORE
*//
         L     REGFIFTN,WRKDSTOR   ADDR OF DATA STORE
         BALR  RETURN,REGFIFTN
         LTR   REGFIFTN,REGFIFTN   SUCCESS
         BNE   ERR1                ALAS  NO
         TM    WRKBITS+2,FRSTPASS  TEST FOR A LAST PASS
         BO    DAT01870
         TM    WRKBITS,MULT        IS THIS A SINGLE ENTRY
         BO    DAT01600            NO, EXIT
*        THE LOGICAL ADDRESS IN THE KEY MUST BE SET PROPERLY ON A SINGL
*        ENTRY.   THIS IS WHAT IS DONE HERE
         L     REGA,GDSAOACB       ADDR OF OACB
         L     REGA,LOGCUR(REGA)   OBTAIN THE CURRENT LOGICAL ADDR
         SR    REGA,REGD           BACK IT UP THE LENGTH OF THE GENERAT
         STH   REGA,WRKADDR+2      STORE IT IN THE KEY
*
*        IF THIS IS NOT A LAST PASS AND IF THIS IS NOT A
*        SINGLE ENTRY THE ROUTINE WILL EXIT BACK TO THE CALLING
*        PROGRAM
*
DAT01600 L     SAVE,4(SAVE)
         RETURN (14,12),T,RC=0     GOOD RETURN
DAT01700 EQU   *                                            D11 ZA04870
         L     REGA,GDSGTMCB       ADDR OF GTMCB            D11 ZA04870
         TM    GTMUPDT(REGA),PPNTUPDT LINE UPDATE?          D11 ZA04870
         BNO   DAT01701            BRANCH IF NOT            D11 ZA04870
         L     REGA,WRKKEY         POINT TO KEY             D11 ZA04870
         TM    KEYWD2(REGA),STMODE 1ST ORDER SETMODE?       D11 ZA04870
         BO    DAT01702            YES,ADD TO UPDATE        D11 ZA04870
DAT01701 EQU   *                                            D11 ZA04870
         TM    GDSGRMOD,VA         ALREADY SET              D11 ZA04870
         BO    DAT01300            YES
DAT01702 EQU   *                                            D11 ZA04870
         MVC   0(2,REGC),GEVMORD   MOVE IN SET MODE
         LA    REGD,2(REGD)        ADD TO COUNT
         MVI   GDSGRMOD,VA         SET CURRENT MODE=VT ABS
         LA    REGC,2(REGC)        POSIT OUTPUT AREA
         B     DAT01300
DAT01800 TM    WRKBITS+2,KEYED+CORVLD KEYED OR CORRELATED
         BNE   DAT04050            YES,FINISH KEY
         B     DAT01550            CALL DATA GEN AND EXIT
*
*        IF THIS IS THE FIRST OF TWO VECTORS IT IS STORED BY DATA
*        STORE AND THE NEXT VECTOR IS MOVED INTO THE WORK AREA.
*        THEN CONTROL IS RETURNED TO THE START TO GENERATE THIS
*        VECTOR.
*
DAT01850 ST    REGD,WRKOUTPT        LENGTH IN OUTPUT AREA
         MVC   WRKGDS1(EIGHT),WRKGDS MOVE IN GDS ADDR
         LA    PARM,WRKGDS1        LOAD ADDR OF LIST
*//     CALL DATA STORE
         L     REGFIFTN,WRKDSTOR   ADDR OF DATA STORE
         BALR  RETURN,REGFIFTN
         LTR   REGFIFTN,REGFIFTN   SUCCESSFUL
         BNE   ERR1                NP
         LA    REGD,0
         LA    REGC,WRKOUTPT+4     RESET OUTPUT TO ZERO DATA
         MVI   WRKSW,OFF           TURN OFF FIRST SW
         MVC   WRKTXABS(SIXTN),WRKXABS MOVE IN SECOND VECTOR
         B     DAT00150
DAT01870 TM    WRKBITS+2,KEYED+CORVLD KEYED OR CORRELATED
         BNE   DAT04050                 YES
         B     DAT01600                 NO EXIT
         EJECT
*
*        WHEN INCREMENTAL OUTPUT IS DESIRED, THE NUMBER OF INCRE-
*        MENTAL VECTORS IS COMPUTED. THE VECTORS WILL BE GENERATED
*        AS NEARLY AT EQUAL LENGTH AS POSSIBLE. ANY REMAINDER
*        WHEN THE LENGTH IS DIVIDED BY THE NUMBER OF VECTORS IS
*        ADDED AT THE RATE OF ONE RASTER UNIT A VECTOR UNTIL IT
*        HAS BEEN USED UP. FIRST A CHECK IS MADE TO SEE IF THE
*        MODE IS ALREADY SET AND IF NOT A SET MODE ORDER IS PLACED
*        IN THE INPUT AREA TO THE DATA STORE ROUTINE.
* INCREMENTAL OUTPUT
* DAT01900 EQU DAT01950
DAT01950 TM    WRKBITS,VECT        VECTOR
         BZ    DAT03100
DAT02000 TM    GDSGRMOD,PI         MODE ALREADY SET
         BO    DAT02100
         MVC   0(2,REGC),GEPI2ORD  MOVE IN ORDER
         LA    REGD,2(REGD)        ADD TO CT
         LA    REGC,2(REGC)        REPOS OUTPUT AREA
         MVI   GDSGRMOD,PI         SET MODE POINT INCREMENTAL
DAT02100 L     REGA,WRKTXINC
         L     REGF,WRKTYINC
         A     REGA,GDSXCOR             ADD X CORR FACTOR OR 0   YM1963
         A     REGF,GDSYCOR             ADD Y CORR FACTOR OR 0   YM1963
         LR    REGB,REGA                SAVE X VALUE             YM1963
         LR    REGG,REGF                SAVE Y VALUE             YM1963
         SRA   REGA,2                   DIVIDE X BY 4            YM1963
         SRA   REGF,2                   DIVIDE Y BY 4            YM1963
         SLA   REGA,2                   RESTORE X                YM1963
         SLA   REGF,2                   RESTORE Y                YM1963
* NOTE THAT THE ABOVE SHIFTS WILL MAKE A NEGATIVE NUMBER MORE    YM1963
* NEGATIVE AND A POSITIVE NUMBER LESS POSSITIVE                  YM1963
         SR    REGB,REGA                NEW X CORR IN REG B      YM1963
         SR    REGG,REGF                NEW Y CORR IN REG G      YM1963
         ST    REGB,GDSXCOR             STORE NEW X CORR         YM1963
         ST    REGG,GDSYCOR             STORE NEW Y CORR         YM1963
         AR    REGA,REGB                RESET X REGISTER         YM1963
         AR    REGF,REGG                RESET Y REGISTER         YM1963
         SRDA  REGA,TR4            DIVIDE BY 4, AND
         SRDA  REGF,TR4            POSITION IN ODD REGISTER
         LPR   SAVE,REGB           POSITIVE X
         LPR   RETURN,REGG         POSITIVE Y
         CR    RETURN,SAVE
         BNL   DAT02200
         LR    RETURN,SAVE         LARGEST IN RETURN
DAT02200 SRDA  RETURN,32
         D     RETURN,SIX3         DIVIDE BY 63
         LTR   RETURN,RETURN       ANY REMAINDER?           D11 ZA14052
         BZ    DAT02250            NO,NUMBER OF VECTS IS OK D11 ZA14052
         LA    RETURN,1            1 VECT FOR REMAINDER     D11 ZA14052
DAT02250 AR    RETURN,REGFIFTN     AND ADD COMPUTED NUMBER  D11 ZA14052
         LTR   RETURN,RETURN  TOT. NUMBER OF VECTORS EQ 0?  D11 ZA14052
         BNZ   DAT02270            NO,PROCEED W DIVIDE      D11 ZA14052
* IF THE NUMBER OF VECTORS WANTED COMPUTES TO ZERO, WE HAVE D11 ZA14052
* SATISFIED THE CALLER'S REQUEST BY NOT GENNING ANYTHING,   D11 ZA14052
* BUT WE SHOULD GEN 1 VECTOR WITH MOVEMENT=0 IN CASE IT IS  D11 ZA16577
* A REPOSITIONING VECTOR, THE LACK OF WHICH CAUSES PROBLEMS.D11 ZA16577
         LA    RETURN,1            MUST GEN AT LEAST ONE    D11 ZA16577
*        THE NUMBER OF VECTORS REQD IS NOW IN RETURN
*        THE X INCR BASE 1024 IS IN REGB
*        THE Y INCR BASE 1024 IS IN REGG
*        THE VECTORS/POINTS GENERATED WILL BE OF EQUAL LENGTH
*        ERROR FACTORS OF ONE UNIT PER VECTOR WILL BE ADDED
*        UNTIL THE ENTIRE CORRECTION IS MADE
DAT02270 DR    REGA,RETURN                                  D11 ZA14052
         DR    REGF,RETURN
*        THE VECTOR/POINT LENGTH FOR EACH IS IN REGB AND REGG RESPECT.
*        THE ERROR FACTOR IS IN REGA AND REGF RESPECTIVELY
*        THE LAST VECTOR WILL HAVE NO CORRECTION FACTOR ADDED
         EJECT
         LTR   REGA,REGA           ANY X CORR FACT
         BZ    DAT03200            NO
         LA    SAVE,ONE
DAT02300 LTR   REGF,REGF           ANY Y CORR FACT
         BZ    DAT03300            NO
         LA    REGFIFTN,ONE
DAT02400 LTR   REGA,REGA           X NEG                         A29395
         BNL   DAT02500            NO
         LNR   SAVE,SAVE           LOAD -1
DAT02500 LTR   REGF,REGF           Y NEG                         A29395
         BNL   DAT02600
         LNR   REGFIFTN,REGFIFTN   LOAD -1
DAT02600 LPR   REGA,REGA           NO. OF CORR.
         LPR   REGF,REGF           NO. OF CORR.
*
*        WHEN GENERATING THE CORRECTION FACTOR IS ADDED TO THE
*        INCREMENTAL VECTOR.  THEY ARE SHIFTED LEFT ONE BIT BECAUSE
*        THE VECTOR APPEARS THIS WAY IN THE MACHINE. THE ONE BIT
*        IS TURNED ON IN THE X BECAUSE THE HARDWARE DOES NOT WANT
*        ITS INCREMENTAL VECTORS LOOKING LIKE SET MODE ORDERS.
*        THESE FIELDS ARE PLACED IN THE OUTPUT AREA. IF THIS IS
*        NOT A VECTOR THE BEAM IS SET TO BLANKED. IF VECTOR, IT
*        IS BLANKED IF IT IS A POSITIONING VECTOR, A REPOSITIONING
*        VECTOR, OR IF THE BEAM IS REQUESTED BLANKED.
DAT02700 LR    REGZERO,REGB        INCR IN ANOTHER REG (X)
         LR    PARM,REGG           INCR IN ANOTHER REG (Y)
         AR    REGZERO,SAVE        ADD CORRECTION FACTOR OR ZERO
         AR    PARM,REGFIFTN       ADD ERROR FACTOR OR ZERO
         SLA   REGZERO,ONE              POSITIVE FOR INCR        YM1963
         SLA   PARM,ONE                 POSITIVE FOR INCR        YM1963
         A     REGZERO,ONEFLD      ONE BIT ALWAYS SET IN X
*                                  BEAM ON CURRENTLYY
         STC   REGZERO,0(REGC)     PLACE IN OUTPUT
         STC   PARM,1(REGC)        PLACE IN OUTPUT
         TM    WRKBITS,VECT        VECTOR
         BNE   DAT02750            NO
         TM    WRKSW,FIRST         IF FIRST ONE, BEAN OFF
         BO    DAT02750
         CLI   WRKSW+1,REPOS       IS THIS THE REPOS VECT
         BE    DAT02750            YES, BLANK
         TM    WRKBITS+2,BEAMON    TURN BEAM OFF IF NEEDED
         BO    DAT02800            NOT NEEDED
DAT02750 OI    1(REGC),BEAMINCR    TURN BEAM OFF
         EJECT
*
*        HERE THE CORRECTION FACTOR REGISTERS ARE CHECKED TO SEE
*        IF MORE CORRECTION MUST TAKE PLACE. IF NOT THE REGISTERS
*        ARE SET TO ZERO.
DAT02800 LA    REGC,2(REGC)        POSITION OUTPUT AREA
         LA    REGD,2(REGD)        ADD TO COUNT
         BCT   REGA,DAT02900
         SR    SAVE,SAVE           X CORR ALL DONE
DAT02900 BCT   REGF,DAT03000
         SR    REGFIFTN,REGFIFTN   Y CORR ALL DONE
*
*        WHEN ALL INCREMENTAL VECTORS ARE GENERATED A CHECK IS MADE
*        TO SEE IF THE BEAM BIT NEEDS MODIFYING ON THE LAST ONE.
*        IF THIS IS THE POSITIONING VECTOR, THE REPOSITIONING VECTOR
*        OR THE REQUESTED BLANKED VECTOR THE BEAM REMAINS AS IS.
*        IF THIS IS POINT OR VECTOR OTHERWISE THE BEAM IS TURNED ON
*        BY TURNING OFF THE BLANK BIT. THEN THE DATA IS HANDLED
*        AS FOR ABSOLUTE BY  CALLING DATA STORE, ETC.
DAT03000 BCT   RETURN,DAT02700     ALL DONE
         LA    SAVE,WRKSAVE             RESET SAVE AREA REG      YM1963
         TM    WRKSW,FIRST         IF FIRST ONE, BEAM OFF
         BO    DAT01500
         CLI   WRKSW+1,REPOS       REPOS VECT
         BE    DAT01500       YES, BLANK
         TM    WRKBITS+2,BEAMON    YES, DOES LAST POINT NEED BEAM
         BZ    DAT01500            NO, GO TO STORE OR DO OTHER ONE
         BCTR  REGC,0              POSIT BACK
         NI    0(REGC),BEAMOFFI    TURN BEAM ON
         LA    REGC,ONE(REGC)      REPOSITION
         B     DAT01500            GO TO STORE OR DO TOHER ONE
DAT03100 TM    GDSGRMOD,VI         ALREADY SET
         BO    DAT02100
         MVC   0(2,REGC),GEVI2ORD  MOVE IN ORDER
         LA    REGD,2(REGD)        ADD TO COUNT
         LA    REGC,2(REGC)        POSITION IN OUTPUT AREA
         MVI   GDSGRMOD,VI         SET MODE VECTOR INCREMENTAL
         B     DAT02100
DAT03200 SR    SAVE,SAVE           ZERO REG WITH CORR FACT
         B     DAT02300
DAT03300 SR    REGFIFTN,REGFIFTN   ZERO REG WITH CORRECTION FACT
         B     DAT02400
         EJECT
*
*        IF THE INPUT DATA IS KEYED IT IS OF ONE OF TWO TYPES. IT
*        IS EITHER SINGLE OR MULTIPLE. IF IT IS MULTIPLE A GTRU
*        TO AN UNRESOLVED ADDRESS (OR A GNOP FOR INCLUDE) IS
*        GENERATED AND SENT OUT TO DATA STORE. A CORRECTION IS
*        MADE TO THE LOGICAL START ADDRESS IN THE KEY AND THEN
*        THE VECTORS ARE PROCESSED.
* KEYED INPUT FIRST ENTRY
DAT03400 TM    WRKBITS,MULT        MULTIPLE ENTRY
         BZ    DAT03700            NO
DAT03450 TM    WRKBITS,INCLUDE     INCLUDE STATUS
         BO    DAT03600            YES
         MVC   0(4,REGC),GTRUORD   MOVE IN GTRU
DAT03500 MVI   WRKOUTPT,UNRES      MOVE IN UNRES ADDR SW
         NI    GDSGRMOD,X'00'      SET TO CONTROL MODE
         LA    PARM,4              LENGTH
         STH   PARM,WRKOUTPT+2
         MVC   WRKGDS1(EIGHT),WRKGDS
         LA    PARM,WRKGDS1
*//
*//      CALL  DATA STORE
         L     REGFIFTN,WRKDSTOR   ADDR OF DATA STORE
         BALR  RETURN,REGFIFTN
         LTR   REGFIFTN,REGFIFTN   SUCCESSFUL
         BNE   ERR1                NO
         L     REGA,GDSAOACB       ADDR OF THE OACB
         L     REGA,LOGCUR(REGA)   LOGICAL ADDRESS OF CURRENT OLP
         S     REGA,FOUR           SUBTRACT FOUR FOR THE DATA WE
*        JUST PLACED OUT IN THE GDOA TO GET THE ACCURATE LOGICAL
*        ADDRESS FOR THE KEY
         STH   REGA,WRKADDR+2      STORE IT IT IN THE KEY
         B     DAT00150
DAT03600 MVC   0(4,REGC),GNOPORD   MOVE IN GNOP
         B     DAT03500
         EJECT
*
*        IF THIS IS A SINGLE ENTRY A CHECK IS MADE TO SEE IF INDEED
*        IT CAN BE GENERATED AS A SINGLE ENTRY. SINGLE ENTRIES
*        DO NOT HAVE INCLUDE/OMIT STRUCTURES. THEY MERELY HAVE
*        INFORMATION IN THE KEY WHICH ENABLES INCL OR OMIT TO
*        TURN THE BEAM BIT ON OR OFF.
*
*        IF THERE IS A POSITIONING VECTOR THIS CANNOT BECOME A
*        SINGLE ENTRY AND IT IS CHANGED TO A MULTIPLE ENTRY, LAST
*        PASS.  THEN THE BEGINNING OF THE MULTIPLE ENTRY IS GENER-
*        ATED BEFORE THE VECTORS ARE GENERATED.  IF NO REPOSITIONING
*        IS REQUIRED THIS MUST ALSO BE TREATED AS A MULTIPLE
*        AND THE ABOVE OCCURS.  IF IT IS ABSOLUTE A BRANCH IS MADE
*        TO THE ABSOLUTE GENERATION AREA.  OTHERWISE THE LENGTH OF
*        THE INCREMENTAL VECTOR IS COMPUTED.  IF IT IS TWO THE
*        INCREMENTAL PROCESSING AREA IS BRANCHED TO.  IF THE OUTPUT
*        IS OPTIMIZED, AN ABSOLUTE VECTOR IS GENERATED. OTHERWISE
*        THE INCREMENTAL VECTOR IS TREATED AS A MULTIPLE ENTRY.
*
DAT03700 CLC   WRKDATA1(SIXTN),ZERO POSITIONING VECTOR
         BNE   DAT03900            YES, MUST BE KEYED
         TM    WRKBITS+2,REPOSRQD  IS THIS A MOVE-SET POSIT ENTRY
         BO    DAT03900            YES, INCLUD/OMIT STR MUST BE BUILT
         TM    WRKBITS,ABS         OUTPUT INCR
         BZ    DAT01200
         L     REGA,WRKTXINC       XINCR
         L     REGB,WRKTYINC       YINCR
         A     REGA,GDSXCOR        ADD X COR OR 0            LD YA00805
         A     REGB,GDSYCOR        ADD Y COR OR 0            LD YA00805
         LPR   REGA,REGA           POSITIVE
         LPR   REGB,REGB           POSITIVE
         CR    REGA,REGB           WHICH LARGER
         BNL   NEGX                BRANCH IF X LARGER        LD YA01038
         LR    REGA,REGB
NEGY     TM    WRKTYINC,NEGATIVE   IS Y INCR NEG???          LD YA01038
         BZ    RPOS                BRANCH IF NO              LD YA01038
         LA    REGB,VLEN2          LOAD CRITICAL VALUE       LD YA01038
         B     DAT03800            BRANCH,GET VECTOR LENGTH  LD YA01038
NEGX     TM    WRKTXINC,NEGATIVE   IS X INCR NEG???          LD YA01038
         BZ    RPOS                BRANCH IF NO              LD YA01038
         LA    REGB,VLEN2          LOAD CRITICAL VALUE       LD YA01038
         B     DAT03800            BRANCH,GET VECTOR LENGTH  LD YA01038
RPOS     LA    REGB,VLEN1          INCR IS POSITIVE??        LD YA01038
DAT03800 LA    REGA,ONE(REGA)      ADD ONE BECAUSE 63 IS...  LD YA01038
*                                  ...LARGEST INCREMENT      LD YA01038
         TM    WRKBITS,OPT         CALLER WANT OPTIMIZED?   D11 ZA10055
         BO    DAT03802            YES,BRANCH               D11 ZA10055
ERR      CR    REGA,REGB     NO,SEE IF VECTOR IS IN RANGE    LD YA00805
         BL    DAT03801            BRANCH IF NO              LD YA00805
         SRA   REGA,EIGHT       DIVIDE BY 256                JM YA02056
         LTR   REGA,REGA        MORE THAN ONE INCR NEEDED    JM YA02056
         BNE   DAT01950         BRANCH IF YES               L5 @ZA04160
         B     DAT03803    ONLY ONE INCR VECT IS REQUIRED    JM YA02056
DAT03801 EQU   *                                             LD YA00805
         LR    REGF,REGA           SAVE VECTOR LENGTH        LD YA00805
         SRDA  REGF,32             POSITION IN ODD REG       LD YA00805
         D     REGF,SIX3                DIVIDE BY 252            YM1963
         B     DAT01950            GO GEN INCREMENTAL VECTOR  L5ZA04160
DAT03802 EQU   *                   OPTIMIZED TEST           D11  YM1963
         SRA   REGA,EIGHT          DIVIDE BY 256
         LTR   REGA,REGA           MOVE THAN ONE INCR REQD?
         BNZ   DAT04000            YES,GO SEE IF INCR
DAT03803 EQU   *                   OPT CAN BE GENNED AS INCR     YM1963
         NI    WRKBITS,OPTOFF      TURN OFF OPT-MAKE INCR
         B     DAT01900            GO GEN INCR VECTOR
DAT03900 OI    WRKBITS,MULT        SET MULT SW
         OI    WRKBITS+2,FRSTPASS  TURN ON LAST PASS SW
         B     DAT03450            SET UP KEY STRU.
DAT04000 TM    WRKBITS,INCR        INCREMENTAL MODE?
         BM    DAT04025             YES
         XI    WRKBITS,ABS
         B     DAT01200
DAT04025 NI    WRKBITS,OPTOFF      MAKE THE KEY INCR TYPE   D11 ZA17700
         B     DAT03900            THEN GO MAKE IT A MULT   D11 ZA17700
         EJECT
*
*        FOR A KEYED ELEMENT AFTER THE VECTOR OR VECTORS HAVE BEEN
*        GENERATED, IF THIS IS A SINGLE ENTRY OF IF THIS IS THE
*        LAST PASS OF A MULTIPLE ENTRY CERTAIN PROCESSING MUST
*        TAKE PLACE.  FOR THE SINGLE ENTRY, IF A SET MODE ORDER
*        IS  PRESENT A FLAG IS SET IN THE KEY. THE BYTE OF DATA
*        THAT CONTAINS THE BEAM BIT IS ALSO SET IN THE KEY.
*        IF IT IS IN OMIT STATUS THE BEAM IS BLANKED, OTHERWISE
*        IT IS UNBLANKED.  THEN THE ROUTINE EXITS.
*        KEYED OUTPUT LAST IN OR SINGLE
DAT04050 TM    WRKBITS,MULT        MULTIPLE
         BO    DAT04900            YES
         TM    WRKBITS,ABS         ABS
         BZ    DAT04400            YES
         C     REGD,FOUR           INCRE-SET MODE
         BNE   DAT04100            NO
         OI    WRKBITS,FRSTORD     SET SW
DAT04100 BCTR  REGC,0              BACK UP ONE TO BYTE WITH BEAM
         TM    WRKBITS,INCLUDE
         BZ    DAT04300
         NI    0(REGC),BEAMOFFI    TURN BEAM ON
DAT04200 MVC   WRKBITS+1(1),0(REGC) SAVE BYTE OF DATA
         B     DAT01550
DAT04300 OI    0(REGC),BEAMINCR    TURN BEAM OFF
         B     DAT04200
DAT04400 C     REGD,SIXFLD         FIRST ORDER=SET MODE
         BNE   DAT04500            NO
         OI    WRKBITS,FRSTORD     SET SW
DAT04500 S     REGC,FOUR           POSIT TO BEAM LOC
         TM    WRKBITS,INCLUDE     INCLUDE
         BZ    DAT04700            NO
         NI    0(REGC),BEAMOFFA    TURN BEAM ON
DAT04600 MVC   WRKBITS+1(1),0(REGC) SAVE ONE BYTE OF DATA
         B     DAT01550
DAT04700 OI    0(REGC),BEAMABS     TURN OFF BEAM
         B     DAT04600
         EJECT
*
*        FOR A MULTIPLE ELEMENT A CHECK IS MADE TO SEE IF THE
*        GENERATOR HAD JUST FINISHED PROCESSING THE REPOSITIONING
*        VECTOR.  IF NOT A CHECK IS MADE TO SEE IF A REPOSITIONING
*        VECTOR IS REQUIRED. IF NOT, A CALL IS MADE TO DATA STORE
*        TO RESOLVE THE UNRESOLVED ADDRESS IN THE INCLUDE OMIT
*        STRUCTURE AND THE ROUTINE EXITS.  OTHERWISE A CALL IS
*        MADE TO DATA STORE TO RESOLVE THE UNRESOLVED ADDRESS
*        IN THE INCLUDE OMIT STRUCTURE AS WELL AS GENERATE A
*        TRANSFER AROUND THE REPOSITIONING VECTOR.  THEN THE
*        REPOSITIONING VECTOR IS PLACED IN THE WORK FIELD, THE
*        SWITCH IS SET AND A BRANCH IS MADE TO GENERATE THE
*        REPOSITIONING VECTOR.
*
DAT04900 CLI   WRKSW+1,X'00'       WAS GENERATOR CALLED FOR INCR POS VT
         BNE   DAT05000            YES
         TM    WRKBITS+2,REPOSRQD  REPOS REQD
         BO    DAT05000            NO
         MVI   WRKSW,OFF           SET FOR ONLY ONE
         MVC   WRKOUTPT+4(4),GTRUORD MOVE IN GTRU AROUND POSIT VECT
         MVC   WRKOUTPT(4),FOUR    ELNGTH
         MVI   WRKOUTPT,RESOL+UNRES SET SW TO RESOLVE ONE ADDR AND ADD
*                                  AN UNRESOLVED TO HIS CHAIN
         LA    PARM,WRKGDS1
*//
*//      CALL DATA STORE
         L     REGFIFTN,WRKDSTOR   ADDR OF DATA STORE
         BALR  RETURN,REGFIFTN
         MVI   GDSGRMOD,X'00'      TURN OFF MODE SETTINGS
         MVC   WRKTXABS(EIGHT),WRKXABS MOVE IN POS VECT ABS
         MVC   WRKTXINC(EIGHT),WRKTOTX MOVE IN POS VECT INCR
         SR    REGD,REGD           ZERO COUNT
         LA    REGC,WRKOUTPT+4
         MVI   WRKSW+1,REPOS       SET SWITCH THIS IS REPOS VECT
         B     DAT00150            GENERATE POSIT VECT
         EJECT
*
*        IF THE REPOSITIONING VECTOR HAS ALREADY BEEN GENERATED
*        A CALL IS MADE TO THE DATA STORE ROUTINE TO RESOLVE
*        THE UNRESOLVED ADDRESS IN THE BRANCH AROUND THE
*        REPOSITIONING  VECTOR, THE CIRRENT MODE IS SET TO
*        CONTROL AND THE ROUTINE EXITS.
*
DAT05000 XC    WRKOUTPT(4),WRKOUTPT     ZERO
         MVI   WRKOUTPT,RESOL           SET SW TO RESOLVE AN ADDR
         LA    PARM,WRKGDS1
*//
*//      CALL DATA STORE
         L     REGFIFTN,WRKDSTOR   ADDR OF DATA STORE
         BALR  RETURN,REGFIFTN
         MVI   GDSGRMOD,X'00'      SET MODE TO CONTROL BECAUSE OF BRAN-
*        CH INTO THE NEXT ELEMENT
         B     DAT01600
         EJECT
ERR1     L     SAVE,4(SAVE)
         RETURN (14,12),T,RC=4     RETURN WITH ERROR CODE
         EJECT
* GDSGRMOD SWITCHES
VA       EQU   X'08'               VECTOR ABS
VI       EQU   X'04'               VECTOR INCR
PA       EQU   X'02'               POINT ABS
PI       EQU   X'01'               POINT INCR
         EJECT
* ORDERS
         GINIT
GEVMORD  GEVM
GEPMORD  GEPM
GEVI2ORD GEVI2
GEPI2ORD GEPI2
GTRUORD  GTRU  0
GNOPORD  GNOP4 0
         EJECT
BEAMOFFI EQU   X'FE'
BEAMOFFA EQU   X'BF'
BEAMABS  EQU   X'40'
BEAMINCR EQU   X'01'
*
FIRST    EQU   X'FF'
OFF      EQU   X'00'
RESOL    EQU   X'02'
         EJECT
* TO TEST FLAGS PASSED
* FLAGS+0
MULT     EQU   X'80'
FRSTORD  EQU   X'40'
VECT     EQU   X'38'
INCLUDE  EQU   X'04'
ABS      EQU   X'03'               TM WRKBITS,ABS--BZ       D11
INCR     EQU   X'03'               TM WRKBITS,INCR-BM       D11
OPT      EQU   X'03'               TM WRKBITS,OPT--BO       D11 OZ10055
OPTOFF   EQU   X'FD'  USED TO MAKE OPT (X'03') INTO INCR (X'01')
* FLAGS+1 ONE BYTE OF DATA
* FLAGS+2
FRSTPASS EQU   X'C0'
KEYED    EQU   X'20'
CORVLD   EQU   X'10'
BEAMON   EQU   X'08'
REPOSRQD EQU   X'04'
REPONLY  EQU   X'02'
         EJECT
* REGISTERS
REGZERO  EQU   0
PARM     EQU   1
REGA     EQU   2                   EVEN ODD PAIR
REGB     EQU   3                   EVEN ODD PAIR
REGC     EQU   4
WORK     EQU   5
REGF     EQU   6                   EVEN ODD PAIR
REGG     EQU   7                   EVEN ODD PAIR
GDSREG   EQU   8
BASE     EQU   9
ERRCD    EQU   10                                                YM1963
REGD     EQU   11
SAVE     EQU   13
RETURN   EQU   14
REGFIFTN EQU   15
         EJECT
* CONSTANTS AND EQUATES
ZERO     DC    4F'0'
ONEFLD   DC    F'1'
THREE    DC    F'3'
FOUR     DC    F'4'
SIXFLD   DC    F'6'
SIX3     DC    F'63'
FLAGS    DC    X'10'                                         LD YA00805
UNRES    EQU   X'01'
PATCH    DS    0F                  40 (DEC) BYTE PATCH AREA D11
         DC    40X'FF'             ALL THE LITTLE FOXES     D11
ONE      EQU   1
SIX      EQU   6
EIGHT    EQU   8
SIXTN    EQU   16
TR4      EQU   34
LOGCUR   EQU   52
REPOS    EQU   X'FF'
DSTOR    EQU   852
STAT     EQU   24
DAT01100 EQU   DAT01200
DAT01900 EQU   DAT01950
VLEN1    EQU   253                 CRITICAL POSITION RANGE   LD YA00805
VLEN2    EQU   251                      CRITICAL NEGATIVE RANGE  YM1963
NEGATIVE EQU   X'80'               USED TO TEST NEG INCR.    LD YA01038
GTMUPDT  EQU   X'3C'               PPNT FLG IN GTMCB        L5 @ZA04162
PPNTUPDT EQU   X'80'               SET BY PPNT IF UPDATE    L5 @ZA04162
KEYWD2   EQU   4                   2'ND WORD OF KEY         L5 @ZA04162
STMODE   EQU   X'40'               I'ST ORDER IS SET MODE   L5 @ZA04162
         EJECT
WORKAREA DSECT      MAP OF INPUT PARAMETER LIST             D11
WRKADDR  DS    F
WRKBITS  DS    F
WRKCORVL DS    F
WRKKEY   DS    F
WRKGDS   DS    F
WRKRTN   DS    F
WRKDATA1 DS    F
WRKDATA2 DS    F
WRKDATA3 DS    F
WRKDATA4 DS    F
WRKXABS  DS    F
WRKYABS  DS    F
WRKXINCR DS    F
WRKYINCR DS    F
WRKTOTX  DS    F
WRKTOTY  DS    F
WRKENTCT DS    F
WRKTXABS DS    F                   INITIALIZED BY SCALE
WRKTYABS DS    F                   INITIALIZED BY SCALE
WRKTXINC DS    F                   INITIALIZED BY SCALE
WRKTYINC DS    F                   INITIALIZED BY SCALE
WRKXERR  DS    F
WRKYERR  DS    F
WRKSW    DS    F
WRKDSTOR DS    F
WRKSAVE  DS    18F                 DATAGEN SAVEAREA
*
WRKGDS1  DS    F       GDS         DATASTORE PARAMETER LIST
WRKRTN1  DS    F       RETURNCODE ARRAY
WRKOUTPT DS    10F     DATA TO BE OUTPUT
         COPY  GDSCB
* FOLLOWING TWO (2) FIELDS LOGICALLY APPENDED TO GDSCB FOR  D11
* ADDRESSIBILITY PURPOSES.                                  D11
GDSXCOR  DS    F                        X CORR FACTOR FOR DGEN   YM1963
GDSYCOR  DS    F                        Y CORR FACTOR FOR DGEN   YM1963
         COPY  GTMCB
         COPY  GSPCB
         END
