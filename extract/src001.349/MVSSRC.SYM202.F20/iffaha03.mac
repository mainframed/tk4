*TITLE         KEY TABLE MANAGEMENT
*
*ENTRY POINT   IFFAHA03
*
*INPUT         IN REGISTER 1 THE ADDRESS OF A PARAMETER LIST
*                 +0 A(GDSCB)
*                 +4 A(CODE)
*                 +8 A(KEY) OR A(CORVAL)
*              THE CODES ARE INTEGER CONSTANTS
*                 CODE=1 ADD A KEY TO THE TABLE
*                      2 FIND A KEY IN THE TABLE
*                      3 RESET TO A KEY
*                      4 DELETE THE KEY TABLE
*                      5 FIND A CORRVAL IN THE TABLE
*
*OUTPUT        VARIES RCCORDING TO CODE
*                 CODE=1  NEW KEY TABLE ENTRY
*                 CODE=2  THE TABLE ADDRESS OF THE KEY IN REGISTER 1
*                 CODE=3  ALL KEYS FOLLOWING AND INCLUDING THE ONE
*                        SPECIFIED IN THE PARAMETER LIST ARE DELETED
*                 CODE=4  ALL STORAGE USED FOR KEY TABLES IS FREED
*                 CODE=5  THE TABLE ADDRESS OF THE KEY CONTAINING THE
*                        CORRVAL IN REGISTER 1.
*
*ERROR RETURNS REGISTER 15=0 IF GOOD RETURN
*                          4 IF KEY OR CORRVAL CANNOT BE FOUND
*              THE RETURN ARRAY IS NOT SET.
*
*FUNCTION      TO MAINTAIN A TABLE OF USER KEYS. UPON REQUEST TO ADD
*              NEW KEYS, TO RETURN THE TABLE ADDRESS OF A SPECIFIC KEY
*              OR CORRVAL, TO DELETE KEYS, TO DELETE THE KEY TABLE.
*
         EJECT
*
*REGISTER UTILIZATION
*
R0       EQU   0
R1       EQU   1                  PLIST REG/KEY TABLE ADDR
R2       EQU   2                  HOLDS OPTION CODE
R3       EQU   3                  HOLDS KEY/CORVAL ADDR
R4       EQU   4                  WORK REG
R5       EQU   5                  HOLDS KEY TABLE ADDR
R6       EQU   6                  LOOP CONTROL
R7       EQU   7                  LOOP CONTROL
R8       EQU   8                  GDSCB DSECT BASE
R9       EQU   9                  CSECT BASE
R11      EQU   11
R13      EQU   13                 SAVE AREA REG
R14      EQU   14                 RETURN REG
R15      EQU   15                 RETURN CODE REG
         EJECT
IFFAHA03 CSECT
*2230,711000,717000,720000                                         3840
         SAVE  (14,12)
         BALR  R9,R0
         USING *,R9               ESTABLISH CSECT ADDRESSABILITY
         LA    R11,N12(R1)
         USING WRKSECT,R11        ESTABLISH WORK AREA ADDRESSABILITY
         L     R8,N0(R1)          GET GDSCB ADDR FROM PLIST
         USING GDSCB,R8           ESTABLISH GDSCB DSECT ADDRESSABILITY
         L     R2,N4(R1)          GET CODE ADDR FROM PLIST
         L     R2,N0(R2)          GET CODE
         L     R3,N8(R1)          GET KEY ADDR/CORVAL ADDR FROM PLIST
*
*TEST OPTION CODE
*
         CH    R2,C1              TEST CODE
         BE    KEYELE1            CODE=1 ADD A KEY
         CH    R2,C2
         BE    KEYEMA1            CODE=2 SEARCH FOR KEY
         CH    R2,C3
         BE    KEYEME1            CODE=3 RESET TO KEY
         CH    R2,C4
         BE    KEYEMH1            CODE=4 DELETE KEY TABLE
         CH    R2,C5
         BE    KEYEMA1            CODE=5 SEARCH FOR CORVAL
         LA    R15,N8             ERROR RETURN - INCORRECT CODE
         B     KEYEMJ3
*
*ADD A KEY TO THE KEY TABLE. IF THERE IS NO KEY TABLE OR IF IT IS FULL
*A MAIN STORAGE AREA IS PROVIDED INITIALIZED AS A KEY TABLE. ANY
*NECESSARY CHAINING IS DONE.
*
*
*DETERMINE IF A KEY TABLE EXISTS, THE ADDRESS OF THE FIRST TABLE IN THE
*KEY TABLE CHAIN IS KEPT IN THE GDSCB.
*
KEYELE1  L     R5,GDSKEYTB        GET KEY TABLE ADDR FROM GDSCB
         LTR   R5,R5              IS THERE A KEY TABLE
         BZ    KEYELF1            NO
*
*THERE IS A KEY TABLE. FOLLOW CHAIN TO LAST TABLE.
*
KEYELE2  L     R4,N0(R5)          GET ADDR OF NEXT TABLE IN CHAIN
         LTR   R4,R4              HAS END OF CHAIN BEEN REACHED
         BZ    KEYELE3            YES
         LR    R5,R4
         B     KEYELE2
*
*DETERMINE IF TABLE IS FULL. IF IT IS GET CORE STORAGE FOR ANOTHER
*TABLE, CHAIN TABLES, ADD KEY. IF IT IS NOT FULL ADD THE KEY.
*
KEYELE3  CLC   N4(N4,R5),N8(R5)   IS KEY TABLE FULL
         BL    KEYELE4            NO
*
*EITHER THERE IS NO CURRENT TABLE OR IT IS FULL. GET CORE FOR TABLE.
*
KEYELF1  LA    R4,MFAREA
         GETMAIN EC,LV=496,A=AREA,SP=0,MF=(E,(4)) GET CORE FOR KEY TABL
         LTR   R15,R15            WAS REQUEST SATISFIED
         BP    KEYEMA3
*
*INITIALIZE POINTERS IN NEW TABLE.
*
         L     R1,AREA                 GET ADDR OF NEW KEY TABLE
         SR    R4,R4
         ST    R4,N0(R1)          IDENTIFY AS LAST TABLE IN CHAIN
         LA    R4,N12(R1)
         ST    R4,N4(R1)          INITIALIZE ENTRY PTR
         LA    R4,N492(R1)
         ST    R4,N8(R1)          SET TABLE END PTR
         LTR   R5,R5              IS THERE A CHAIN
         BZ    KEYELJ1            NO
         ST    R1,N0(R5)          CHAIN KEY TABLES
         B     KEYELF4
KEYELJ1  ST    R1,GDSKEYTB        START KEY TABLE CHAIN
         B     KEYELF4
KEYELE4  LR    R1,R5
KEYELF4  L     R4,N4(R1)          GET NEXT ENTRY ADDR
*
*PUT KEY IN TABLE AND RESET POINTERS.
*
         MVC   N0(N12,R4),N0(R3)  PUT KEY IN KEY TABLE
         LA    R4,N12(R4)
         ST    R4,N4(R1)          SET PTR TO NEXT ENTRY
         B     KEYEMJ3A
         EJECT
*
*SEARCH FOR KEY/SEARCH FOR CORVAL. A SEQUENTIAL SEARCH OF THE KEY TABLE
*IS PERFORMED. IF THE KEY OR CORRVAL IS FOUND THE TABLE ADDRESS OF THE
*KEY IS RETURNED IN REGISTER 1. IF IT IS NOT FOUND AN ERROR CODE OF
*FOUR IS RETURNED IN REGISTER 15.
*
*
*IF THERE IS NO KEY TABLE GIVE ERROR RETURN
*
KEYEMA1  L     R5,GDSKEYTB        GET KEY TABLE ADDR FROM GDSCB
         LTR   R5,R5              IS THERE A KEY TABLE
         BZ    KEYEMA3            NO
*
*DETERMINE IF SEARCH IS FOR KEY OR CORRVAL. IF SEARCH IS FOR KEY THE
*FIRST WORD OF EACH KEY TABLE ENTRY MUST BE COMPARED. IF SEARCH IS FOR
*CORVAL THE THIRD WORD OF EACH KEY TABLE ENTRY MUST BE COMPARED.
*
KEYEMB2  CH    R2,C5              SEARCH FOR KEY OR CORVAL
         BE    KEYEMC2            CORVAL
*
*SEARCH FOR KEY. SET POINTER TO FIRST WORD IN TABLE ENTRY. INITIALIZE
*SEARCH LOOP. THERE ARE FORTY KEYS IN A TABLE
*
         LA    R4,N12(R5)         GET ADDR OF FIRST KEY IN TABLE
KEYEMB3A LA    R7,N40             LOOP CONTROL
KEYEMB3  C     R4,4(R5)                HAS LAST KEY IN TABLE BEEN CHECK
         BNL   KEYEMA3                 YES
         CLC   N0(N4,R3),N0(R4)         HAS KEY/CORVAL BEEN FOUND
         BE    KEYEMB5            YES
         LA    R4,N12(R4)         GET ADDR OF NEXT KEY/CORVAL IN TABLE
         BCT   R7,KEYEMB3
*
*DETERMINE IF THE LAST TABLE ON THE CHAIN HAS BEEN SEARCHED. IF NOT
*SEARCH THE NEXT TABLE ON THE CHAIN. IF IT HAS, MAKE ERROR RETURN.
*
         SR    R4,R4
         C     R4,N0(R5)          HAS LAST KEY IN CHAIN BEEN CHECKED
         BE    KEYEMA3            YES
         L     R5,N0(R5)          GET ADDR OF NEXT TABLE ON CHAIN
         B     KEYEMB2
*
*
*
*KEY OR CORRVAL HAS BEEN FOUND. DETERMINE IF CALL IS FOR SEARCH OR
*RESET. IF RESET, CHANGE TABLE ENTRY POINTER. IF SEARCH, DETERMINE IF
*SEARCH WAS FOR KEY OR CORRVAL.
*
KEYEMB5  CH    R2,C3              WAS OPTION CODE 3 PASSED
         BE    KEYEMF1            YES
         CH    R2,C5              WAS SEARCH FOR CORVAL
         BE    KEYEMC5B           YES
*
*THE SEARCH WAS FOR A KEY. REGISTER FOUR CONTAINS THE ADDRESS OF THE
*KEY TABLE ENTRY IN WHICH THE KEY IS KEPT. RETURN THIS ADDRESS IN
*REGISTER ONE.
*
KEYEMC5A LR    R1,R4              PUT KEY ADDR/CORVAL AD IN RETURN REG
         B     KEYEMJ3B
*
*THE SEARCH WAS FOR A CORRVAL. SUBTRACT EIGHT TO GET THE ADDRESS OF
*THE KEY TABLE ENTRY IN WHICH THE CORRVAL IS KEPT.
*
KEYEMC5B SH    R4,C8              COMPUTE KEY ADDR
         B     KEYEMC5A
*
*SEARCH IS FOR CORRVAL. SET POINTER TO THIRD WORD IN TABLE ENTRY.
*
KEYEMC2  LA    R4,N20(R5)         GET ADDR OF FIRST CORVAL IN TABLE
         B     KEYEMB3A
KEYEMA3  LA    R15,N4             ERROR RETURN - KEY/CORVAL NOT FOUND
         B     KEYEMJ3
         EJECT
*
*RESET TO KEY. ALL KEYS, STARTING AT THE ONE SPECIFIED, ARE DELETED.
*ALL KEYS CAN BE DELETED BY SPECIFYING ZERO IN PLACE OF THE KEY ADDRESS
*PARAMETER. ALL TABLES CONTAINING ONLY DELETED KEYS ARE FREED.
*
*
*DETERMINE IF ALL KEYS SHOULD BE DELETED. IF YES, RESET ENTRY POINTER
*TO TOP OF FIRST TABLE. UNCHAIN AND FREE ALL OTHER TABLES.
*
KEYEME1  L     R4,N0(R3)          GET KEY VALUE
         LTR   R4,R4              SHOULD ALL KEYS BE DELETED
         BP    KEYEMA1            NO
*
*DELETE ALL KEYS IF THERE IS A KEY TABLE. IF THERE IS NOT GIVE AN ERROR
*RETURN.
*
         L     R5,GDSKEYTB        GET KEY TABLE ADDR FROM GDSCB
         LTR   R5,R5              IS THERE A KEY TABLE
         BZ    KEYEMA3            NO
         LA    R4,N12(R5)         GET FIRST ENTRY ADDR
KEYEMF1  ST    R4,N4(R5)          RESET ENTRY PTR
*
*UNCHAIN AND FREE ALL TABLES FOLLOWING THE ONE WHICH STILL HOLDS VALID
*KEYS. DO NOT FREE THE FIRST TABLE ON CHAIN BUT DO UNCHAIN IT SO THAT
*SUBSEQUENT REQUESTS TO EITHER RESET TO KEY OR DELETE KEY TABLE WILL
*NOT ATTEMPT TO FREE THE SAME AREA AGAIN.
*
KEYEMF2  LR    R6,R5
         L     R5,0(R5)                GET NEXT TABLE ADDR
         XC    0(4,R6),0(R6)           ZERO POINTER
KEYEMF3  LTR   R5,R5               HAS ED OF CHAIN BEEN REACHED    3840
         BZ    KEYEMJ3A                YES
         LR    R6,R5                                               3840
         L     R5,0(R6)            SAVE PTR TO NEXT AREA           3840
         FREEMAIN R,LV=496,A=(6)                                   3840
         B     KEYEMF3                                             3840
         EJECT
*
*DELETE KEY TABLE. ALL KEY TABLE AREAS ARE FREED AND THE KEY TABLE
*STRUCTURE IS DESTROYED.
*
*
*IF THERE IS NO KEY TABLE SIMPLY EXIT TO CALLER
*
KEYEMH1  L     R5,GDSKEYTB
         LTR   R5,R5                   IS THERE A KEY TABLE
         BZ    KEYEMJ3A                NO
*
*UNCHAIN AND FREE ALL AREAS STARTING AT THE FRONT END OF THE CHAIN.
*
         XC    GDSKEYTB(4),GDSKEYTB    ZERO KEY TABLE POINTER
KEYEMH3  LR    R6,R5              COPY KEY TABLE ADDR
         L     R5,N0(R5)          GET ADDR OF NEXT TABLE IN CHAIN
         XC    0(4,R6),0(R6)           ZERO CHAIN POINTER
         FREEMAIN R,LV=496,A=(6)  RELEASE KEY TABLE CORE
KEYEMH3A LTR   R5,R5              IS THERE ANOTHER TABLE ON CHAIN
         BZ    KEYEMJ3A           NO
         B     KEYEMH3
*
*RETURN FROM HERE IF REGISTER ONE CONTAINS KEY TABLE ENTRY ADDRSS.
*
KEYEMJ3A L     R1,N24(R13)        RESTORE REG1
*
*RETURN THROUGH HERE IF THERE HAS NOT BEEN AN ERROR.
*
KEYEMJ3B SR    R15,R15            INDICATE SUCCESSFUL COMPLETION
*
*RETURN THROUGH HERE IF THERE HAS BEEN AN ERROR.
*
KEYEMJ3  L     R14,N12(R13)       RESTORE REG14
         L     R0,N20(R13)        RESTORE REG0
         RETURN (2,12)
         EJECT
*
*DEFINED CONSTANTS
*
N0       EQU   0
N4       EQU   4
N8       EQU   8
N12      EQU   12
N20      EQU   20
N24      EQU   24
N40      EQU   40
N492     EQU   492
C1       DC    H'1'
C2       DC    H'2'
C3       DC    H'3'
C4       DC    H'4'
C5       DC    H'5'
C8       DC    H'8'
WRKSECT  DSECT
AREA     DS    F
MFAREA   DS    5F
         COPY  GDSCB
         END
