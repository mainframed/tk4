         TITLE 'IFFAHA13-UPDATE ROUTINE'
*
*        UPDATE IS ENTERED DIRECTLY FROM PLINE/PPOINT,PSEGMT,
*        MVPOS/STPOS, AND PTEXT. IT IS ALSO ENTERED BY ORGEN TO
*        SUPPLY WORK OACBS EVEN FOR A NON-UPDATE SITUATION.
*             THE UPDATE PARMLIST IS IDENTICAL TO THE DATAGEN
*        PARMLIST THESE ROUTINES USE.   REGISTER 1 WILL POINT TO
*        THE AREA DESCRIBED BELOW.
*
*
*                             +0   KEY
*                             +4   3F  IGNORED
*                             +16  A(GDS)
*                             +20  A(RTN ARRAY)
*                             +24  11F IGNORED
*                             +68  WORK AREA(30 WDS LONG)   D11
*
*
*        ENTRY POINTS:  IFFAHA13-TO OBTAIN THE GDOAS AND OACBS
*        FOR THE UPDATE.
*        IFFAHA14-TO WRITE OUT THE GDOAS ON A SUCCESSFUL UPDATE.
*        FOR AN UNSUCCESSFUL UPDATE, DATA STORE WILL FREE THE
*        STORAGE OBTAINED AND THIS ENTRY POINT WILL NEVER BE
*        CALLED.
*
*        EXTERNAL MACROS:          EXTERNAL ROUTINES:
*        GETMAIN                   DATASTORE (IFFAHA05)
*        WAIT
*        GWRITE
*        GCNTRL
*        FREEMAIN
*
*        NOTE: ORGEN WILL USE THE UPDATE MODULE TO CREATE GDOAS
*        AND OACBS FOR ITS WORK AREA EVEN THUUGH ORGEN IS NOT BEING
*        UPDATED. IT WILL EXIT BEFORE ANY BUFFER ADDRESSES ARE
*        COMPUTED.
*
         EJECT
*
*        ON ENTRY THE REGISTERS ARE SAVED, THE BASE REGISTER IS
*        ESTABLISHED, THE WORK AREA DSECT IS ESTABLISHED, THE
*        GDSCB DSECT IS ESTABLISHED, AND THE GTMCB DSECT IS
*        ESTABLISHED, THE SAVE AREAS ARE CHAINED AND THE RETURN
*        ARRAY ADDRESS IS PLACED IN A REGISTER.
*A806000                                                 1046,1557,1676
*A694000-696000                                                  A43072
*A152000-174000,816000                                       LD YA00808
*A474000                                                     LD YA00807
*A778000                                                    D11 ZA08043
*A726500-727000,742100-743960,818100-818400,926200-927000   D11 ZA11418
*A434600-435200,A454600-455200,C45600,45800,A480800-481600, D11 ZA10053
*C526000,A526600-527200,A85700                              D11 OZ10053
*A100010,A100030-100100,C102000,C580000-584000              D11 OZ15418
         EJECT                                              D11
IFFAHA13 CSECT                     EP FOR IFFAHA13
         USING *,REGFIFTN                                   D11 ZA15418
         SAVE  (14,12)
         B     STARTH13                                     D11 ZA15418
         DROP  REGFIFTN                                     D11 ZA15418
         ENTRY IFFAHA14                                     D11 ZA15418
IFFAHA14 DS    0H                  EP FOR IFFAHA14          D11 ZA15418
         USING *,REGFIFTN                                   D11 ZA15418
         SAVE  (14,12)                                      D11 ZA15418
         B     STARTH14                                     D11 ZA15418
         DROP  REGFIFTN                                     D11 ZA15418
STARTH13 BALR  BASE,0              STARTS HERE              D11 ZA15418
         USING *,BASE
         LR    WORK,PARM
         USING WORKAREA,WORK       WORKAREA
         L     GDSREG,WRKGDS
         USING GDSCB,GDSREG        GDSCB
         L     GTMREG,GDSGTMCB     GTMCB
         USING GTMCB,GTMREG
         LA    REGA,WRKSAVE        CHAIN SAVE AREAS
         ST    REGA,8(SAVE)
         ST    SAVE,4(REGA)
         LR    SAVE,REGA
         L     ERRCD,WRKRTN        RETURN ARRAY
         EJECT
*
*        THE LENGTH OF THE GDOAS AND ASSOCIATED OACBS IS COMPUTED
*        AND STORAGE IS OBTAINED FOR THEM. IF STORAGE IS NOT
*        AVAILABLE, AN ERROR CODE IS PLACED IN THE RETURN ARRAY
*        AND CONTROL IS RETURNED TO THE CALLING PROGRAM.
         LH    REGC,WRKADDR        LOG LENGTH AND
         LH    REGA,WRKADDR+2      LOG ADDR FROM KEYTAB
         SRDA  REGA,32             IN ODD REG
         LH    REGD,GDSGDOAL       GDOA LEN
         S     REGD,SIX            GDOA LEN - 6
         DR    REGA,REGD           CT IN REGB, REM IN REGA
         CLI   WAORFLGS(WORK),X'FC'     ORGEN CALL?          LD YA00808
         BNE   UPD00050            NO, BRANCH AROUND         LD YA00808
         LTR   REGA,REGA           ZERO REMAINDER?           LD YA00808
         BNZ   UPD00050            IF NO, PREVIOUS ELEMENT...LD YA00808
*                                  ...SIZE IS GIVEN BY...    LD YA00808
*                                  ...THE REMAINDER          LD YA00808
         LR    REGA,REGD           IF YES,GDOALEN-6......    LD YA00808
*                                  ...BECOMES PREVIOUS...    LD YA00808
*                                  ...ELEMENT SIZE           LD YA00808
         BCTR  REGB,0              DECREMENT COUNT           LD YA00808
* THE ADDITION OF (GDOALEN-6) IS BALANCED BY DECREMENTING   D11
* THE COUNT OF SECTIONS IN REGB.                            D11
UPD00050 EQU   *                                             LD YA00808
         ST    REGB,WRKSPACE       SAVE BCT COUNT            LD YA00808
         LA    REGE,ONE            ASSUME 1 GDOA IS ENOUGH
         LR    REGB,REGD           INIT.AVAIL LEN IN GDOA
         SR    REGB,REGA   - PREV ELEM LEN = CURR AVAIL LEN
         CR    REGC,REGB  THIS ELEM LEN LT CURR AVAIL LEN??
         BNH   UPD00200            YES,ONLY 1 GDOA NEEDED
         SR    REGC,REGB NO,SUB FROM THIS ELEMLEN 1GDOA  1046,1557,1676
UPD00100 LA    REGE,ONE(REGE)      ADD ONE GDOA TO RQMNT
         CR    REGC,REGD DOES REMNDR OF LOGLEN FIT IN THIS GDOA?
         BNH   UPD00200            YES,GO GET NUMBER OF GDOAS NEEDED
         SR    REGC,REGD  NO,DECR LOGLEN RMNDR BY A GDOALEN
         B     UPD00100            AND TRY AGAIN
         EJECT
UPD00200 LH    REGD,GDSGDOAL  LEN OF EACH GDOA
         A     REGD,OACBLEN   + LENGTH OF ITS OACB=TOT LEN FOR EACH
         L     REGB,WRKSPACE SAVE BFR CONT TABLE COUNT ACROSS GETMN
         MR    REGC,REGE     LEN PER EACH * NUMBER NEEDED
         GETMAIN EC,LV=(REGD),A=WRKSPACE+12,SP=0,MF=(E,WRKSPACE)
         LTR   REGFIFTN,REGFIFTN   CORE AVAIL?
         BNE   ERR1                NO,ERROR
*
*        THE OACB SET UP IS ONE WORD LONGER THAN THE OACB FOR
*        REGULAR GENERATION. THE START OF THE GETMAIN AREA
*        AND ITS LENGTH REPLACE CPU1 AND BUF1 RESPECTIVELY OF
*        THE ORIGINAL OACB.  THIS IS POSSIBLE BECAUSE UPDATE
*        TAKES PLACE ON AN ELEMENT ONLY, NOT AN A SEQUENCE OR
*        SUBROUTINE AND THERE CAN BE ONLY ONE UNRESOLVED ADDRESS
*        AT ANY ONE TIME. THE ADDRESSES ARE RESOLVED ON A LAST
*        IN FIRST OUT METHOD AND THEY ARE PLACED IN THE OACB
*        IN THE ONE THAT IS SET TO ZERO. THEREFORE, WHEN
*        DATA STORE LOOKS AT THE CPU1, BUF1 LOCATIONS AND FINDS
*        THEM NON ZERO IT WILL PLACE THE UNRESOLVED ADDRESS AT
*        CPU2, BUF2 WHICH IS EQUAL TO ZERO. WEHN DATA STORE
*        IS READY TO RESOLVE THE ADDRESS IT WILL RESOLVE CPU2,
*        BUF2, FIRST.  THE STATUS IN THE OACB IS SET TO X'20'.
*
         ST    REGB,WRKSPACE       RESTORE BCT COUNT
         L     REGC,WRKSPACE+12    ADDR OF AREA
         USING OACBAREA,REGC
         ST    REGD,LENGTH         LENGTH OF GETMAIN
         ST    REGC,FIRST          START OF GETMAIN
         XC    CPU2(8),CPU2        CPU AND BUF UNRES=0
         XC    STATUS,STATUS       STATUS=0
         OI    STATUS,UPDT         SET UPDATE SW
         EJECT
*
*        THE ADDRESS OF THE ORIGINAL OACB IS PLACED IN THE UPDATE
*        OACB. THE CRSA AND OLP ARE POSITIONED IN THE GDOA TO WHERE
*        THE ELEMENT STARTS. THE BUFLEN FIELD OF THIS OACB IS SET
*        TO THE LENGTH LEFT IN THE GDOA LESS TWO OF THE SIX CONTROL
*        THE LENGTH LEFT (LENLEFT) IS SET TO THE LENGTH LEFT IN THE
*        GDOA LESS SIX CONTROL BYTES. IF THE LENGTH LEFT IS GREATER
*        THAN THE LENGTH REQUIRED FOR THE UPDATE, LENLEFT AND BUF-
*        LEN ARE MODIFIED TO THE ACTUAL LENGTH REQUIRED FOR THE
*        UPDATE.
         MVC   ORIG,GDSAOACB       SAVE ADDR OF ORIG OACB
         LA    REGD,64(REGC)       ADDR OF GDOA (WHICH FOLLOWS OACB)
         ST    REGD,GDOA           SAVE IN OACB POINTER
         AR    REGD,REGA           ADD PREVIOUS ELEMENT LENGTH
         LA    REGD,2(REGD)        AND 2 FOR INITIAL MODESET
         ST    REGD,CRSA           GIVING CURR RTN ST ADDR,
         ST    REGD,OLP            AND (INITIALLY) ORDER LOAD PT.
         LH    REGD,GDSGDOAL       GDOALEN FROM GDS
         S     REGD,TWO            LESS TWO FOR INITIAL MODESET
         SR    REGD,REGA           LESS PREV ELEM LEN(LENLEFT IN GDOA)
         ST    REGD,BUFLEN         GIVES BUFFER LENGTH
         S     REGD,FOUR           LESS 4 FOR OVFLOW BR(END OF GDOA)
*   GIVES BUFFER LENGTH (UNLESS LEN REQUIRED IS LESS).
         CH    REGD,WRKADDR        IS LENGTH LEFT GR THAN LEN REQD
         BNL   UPD00400            YES,WILL NEED ONLY 1 OACB/GDOA
         ST    REGD,LENLEFT        ELSE SAVE ABOVE BUFLEN-4=LENLEFT
*
*  FOR THE ABOVE, PREVIOUS ELEMENT LENGTH IN REGA CAN BE EITHER A
*  TRUE PREV ELEM. LEN.; OR IF AN ELEMENT'S LOGSTART ADDR IS AN
*  EXACT MULTIPLE OF (GDOALEN-6), PREV ELEM LEN IS SET TO THE VALUE
*  OF (GDOALEN-1).(BFR CONTR TBL SECT NUM.IS ALSO DECRMNTD).
*
         LH    REGE,WRKADDR        NXT ROUTINE NEEDS LOGLEN  THIS ELEM.
         EJECT
*
*        IF ANY MORE OACB/DGOAS ARE REQUIRED, THE FIRST IS DUPLICATED
*        INTO THE NEXT. THE GDOA, CRSA, AND OLP ARE SET UP TO POINT
*        TO THE GDOA ADDRESS.  THE GDOAS AND OACBS ARE CYCLED THROUGH
*        UNTIL THE LAST ONE IS REACHED. ON THE LAST ONE THE LENGTH
*        LEFT AND BUFFER LENGTH ARE MODIFIED SO THAT THEY WILL
*        REFLECT THE SHORTENED GDOA.
*
UPD00300 SR    REGE,REGD LOGLEN-LENLEFT(THIS ELEM)=LEN REMNG TO DO
         L     REGD,OACBLEN        OACBLEN PLUS
         AH    REGD,GDSGDOAL       GDOALEN PLUS
         AR    REGD,REGC           THIS OACB = NEXT OACB
         ST    REGD,OTHER          PUT NXTOACB ON CHAIN
         MVC   0(64,REGD),0(REGC)  DUP OACB CONTENT (OLD TO NEW)
         LR    REGC,REGD           ADDR NEW OACB W USING REG
         LA    REGD,64(REGC)       POINT TO GDOA
         ST    REGD,CRSA           INIT CRSA,
         ST    REGD,GDOA           GDOA,
         ST    REGD,OLP            AND OLP.
         LH    REGD,GDSGDOAL       IS (GDOALENGTH
         S     REGD,SIX            LESS 6) LESS THAN ELEM LENGTH?
         CR    REGD,REGE           IF SO,THERE IS ANOTHER BLOCK TO DO
         BNL   UPD00350            NO,LAST BLOCK (OACB/GDOA) FINISHED
         ST    REGD,BUFLEN         ELSE GDOALEN-6=BUFLEN
         ST    REGD,LENLEFT        AND LEN LEFT
         B     UPD00300            AND GO DO NEXT BLOCK (OACB/GDOA).
UPD00350 ST    REGE,LENLEFT   LENLEFT (LASTOACB) = ELEM LEN
         LA    REGE,2(REGE)        RESET LENGTH TO GO IN BUFLEN
         B     UPD00500
UPD00400 LH    REGE,WRKADDR        LENGTH
         ST    REGE,LENLEFT        &LENLEFT
         EJECT
UPD00500 ST    REGE,BUFLEN         IN BUFLEN
         MVC   OTHER,ZERO          ZERO OTHER IN LAST OACB
         L     REGC,WRKSPACE+12    START OF UPD OACB CHAIN
         ST    REGC,GDSAOACB       ADDRESS OF TEMP OACB IN GDSCB
         LH    REGD,WRKADDR+2      ELEMENT LOG START ADDRESS
         ST    REGD,LOGSTRT        IS LOG START
         ST    REGD,LOGCURR        AND LOGCURR
         L     REGB,ORIG           POINT BACK TO THE ORIGINAL OACB
*
*        AT THIS POINT THE PHYSICAL BUFFER ADDRESSES FOR THESE
*        OACBS AND GDOAS MUST BE COMPUTED. FIRST THE START OF
*        THE CHAIN OF OACBS IS PLACED IN THE GDSAOACB LOCATION
*        IN THE GDSCB. THE LOGICAL ADDRESS OF THE KEY IS
*        PLACED IN THE LOGICAL START AND LOGICAL CURRENT LOCATION
*        IN THE FIRST OACB. THE OTHER LOGICAL ADDRESSES FOR
*        THE SUCCEEDING GDOAS WILL BE PLACED THERE BY DATA STORE.
*        THE PHYSICAL BUFFER ADDRESSES ARE COMPUTED USING THE
*        LOGICAL START ADDRESS AND THE BUFFER CONTROL TABLE.
*        CONTROL IS THEN RETURNED TO THE CALLING PROGRAM.
         CLC   CURLOG+2(2,REGB),WRKADDR+2
         BE    UPD00850            ORGEN ENTRY RETURN NOW
         L     REGB,GTMBCTBL       BFR CNTRL TABLE ADDRESS
         LH    REGD,GDSBCTEL       DISP FOR FIRST ENTRY
         MH    REGD,F3+2           INDEX INTO TABLE
         CLC   GDSGDOAL,SUBSEG     THIS A SUBSEGMENT ?
         BE    UPD00700            YES,BRANCH
         SR    REGE,REGE           CLEAR FOR IC
UPD00600 IC    REGE,2(REGB,REGD)   GET ASSIGNMENT NUM OF THIS SECTION
         CLC   WRKSPACE,MINUS1     ORIG LOGSTRT=0?          D11 OZ10053
         BE    UPD01000            YES,FIRST SECTION GOOD   D11 OZ10053
         C     REGE,WRKSPACE       FIRST FOUND(ASSGN NUM=WRKSPACE)?
         BE    UPD01000            YES,BR
         IC    REGE,1(REGB,REGD)   PICK UP PTR TO NEXT BCT ENTRY
         MH    REGE,F3+2           EACH ENTRY IS THREE LONG
         CR    REGE,REGD           ANY MORE ON CHAIN?
         BE    ERR2                NO-BAD KEY
         LR    REGD,REGE           NEW TABLE DISP
         SR    REGE,REGE           CLEAR FOR IC
         B     UPD00600            LOOK FOR NEXT
UPD00700 CLC   WRKSPACE,ZERO       IF CT NOT ZERO THEN
         BE    UPD00750            CAN BE ONLY ONE SUBSEG   D11 ZA10053
         CLC   WRKSPACE,MINUS1     BUT IT MAY BE LOGSTRT=0  D11 ZA10053
         BNE   ERR2                NO-BADKEY
UPD00750 AR    REGB,REGD           POINT TO GOOD ENTRY      D11 ZA10053
         M     REGC,F256           CONVERT-LEAVING
         D     REGC,F3             BUFFER ADDR IN REGD
         CLC   0(1,REGB),GDSBCTID  IN FIRST HALF
         BE    UPD00800            YES
         AH    REGD,SUBSEG         POSIT TO SECOND SUBSEG
         EJECT
UPD00800 AR    REGD,REGA
         A     REGD,TWO                                      LD YA00807
         L     REGC,WRKSPACE+12    ADDR OF 1ST WORK OACB
         ST    REGD,BUFSTART       PLACE ADDR IN BUFFER START
         CLC   OTHER,ZERO          MORE THAN 1 GDOA
         BE    UPD00825            NO,GO  STORE BLP         D11 ZA10053
         CLC   WRKSPACE,MINUS1     YES, MAY BE A LOGSTRT=0  D11 ZA10053
         BNE   ERR2                NO,BAD KEY
UPD00825 ST    REGD,BLP            PLACE ADDR IN BLP
UPD00850 SR    REGFIFTN,REGFIFTN   SET TO GOOD RETURN
UPD00900 L     SAVE,4(SAVE)        COME HERE IF R15 SET
         RETURN (14,12),T,RC=(15)
UPD01000 LR    REGE,REGD           SAVE DISP
         M     REGC,F256           MX256
         D     REGC,F3             D3
         AR    REGD,REGA           ADD DISP FROM TOP
         A     REGD,TWO
         L     REGA,WRKSPACE+12    ADDR OF 1ST WORK OACB
         DROP  REGC
         USING OACBAREA,REGA       ADDRESS 1ST WORK OACB
UPD01100 ST    REGD,BUFSTART       SAVE BUFFER START
         ST    REGD,BLP            BLP
         SR    REGD,REGD           ZERO REG
         CLC   OTHER,ZERO          ANOTHER
         BE    UPD00850            NO,DONE
         L     REGA,OTHER          GO TO NEXT
         IC    REGD,1(REGE,REGB)   DISP
         MH    REGD,F3+2           EACH BCT ENTRY IS 3 LONG
         CR    REGD,REGE           MORE SEGMENTS
         BNE   UPD01125            YES,DO NEXT SECTION      D11 OZ10053
         CLC   WRKSPACE,MINUS1     WAS ELEMENT LOGSTRT=0?   D11 OZ10053
         BNE   ERR2                NO,TRUE LOGIC ERROR      D11 OZ10053
UPD01125 LR    REGE,REGD           SAVE
         M     REGC,F256           COMPUTE BUFFER ADDR
         D     REGC,F3             EACH BCT ENTRY 3 LONG
         B     UPD01100
         EJECT
ERR1     MVI   CODE(ERRCD),NOCORE  INDICATE CORE EXHAUSTED
         MVC   STRG(4,ERRCD),FOUR
         L     REGFIFTN,FOUR
         B     UPD00900
ERR2     MVI   CODE(ERRCD),PARMERR INVALID KEY/CORVAL OR BAD GENCODE
         MVC   PRM(4,ERRCD),ZERO
         L     REGFIFTN,FOUR
         L     REGA,GDSAOACB       GET TEMP AREA
         MVC   GDSAOACB,ORIG       REPLACE ADDR OF ORIGINAL
         L     PARM,FIRST          ADDR OF GETMAIN
         L     REGZERO,LENGTH      LENGTH FOR FREEMAIN
         FREEMAIN R,LV=(0),A=(1)   FREE STORAGE
         B     UPD00900
         DC    C'ZAP PATCH AREA, 40 BYTES'
         DS    0H                  LINEUP PATCH             D11
PATCH13  DC    40X'FF'             PATCH AREA FOR IFFAHA13  D11
         EJECT
         DROP  REGA
         DROP  BASE
         EJECT
*
*        ENTRY AT IFFAHA14 IS MADE TO WRITE OUT A SUCCESSFUL
*        UPDATE. THE STANDARD INITIALIZATION TAKES PLACE FIRST.
*                                                           D11 ZA15418
*                                                           D11 ZA15418
STARTH14 BALR  BASE,0              STARTS HERE              D11 ZA15418
         USING *,BASE
         LR    WORK,PARM           WORK AREA
         L     GDSREG,WRKGDS       GDSCB
         LA    REGA,WRKSAVE        SAVE AREA CHAINING
         ST    REGA,8(SAVE)
         ST    SAVE,4(REGA)
         LR    SAVE,REGA           SET UP MY SAVE AREA
         L     GTMREG,GDSGTMCB     GTMCB
         USING OACBAREA,REGC
         L     REGC,GDSAOACB       OACB FOR UPDATE
*
*        THE LAST GDOA/OACB ON THE CHAIN IS LOCATED AND IF THE
*        UPDATE DID NOT COMPLETELY FILL THE PREVIOUS AREA A
*        FILL IN WILL TAKE PLACE. IF ONLY TWO BYTES ARE LEFT
*        A GNOP IS PLACED IN TNE TWO BYTES. OTHERWISE A GTRU
*        TO THE END OF THE SEGMENT IS PLACED IN THE GDPA WHERE
*        GENERATION COMPLETED.
         L     REGA,OLP            ORDER LOAD PT
         L     REGB,LENLEFT        LENGTH LEFT
         C     REGB,FOUR           GREATER THAN OR EQ 4?
         BL    UPD01300            NO
UPD01150 CLC   OTHER,ZERO          GO TO LAST OACB-FOUND
         BE    UPD01400            YES
         L     REGC,OTHER          GET NEXT
         B     UPD01150
UPD01160 L     REGC,FIRST          LOAD FIRST ONE
         MVC   GDSAOACB,ORIG       RESET REGULAR OACB
         TM    GDSFLAGS,EQUIV      IS THIS AN EQUIVALENCE GDS
         BO    UPD01600            YES MODIFY IN CORE COPY
         EJECT
*
*        UPDATE I/O CANNOT BE OVERLAPPED SO ANOTHER DECB IS CREATED
*
*
*        THE FIRST OACB/GDOA IS LOCATED AND THEY ARE ALL WRITEEN
*        OUT TO THE BUFFER. AFTER THEY ARE WRITTEN, A GCNTRL
*        MACRO IS ISSUED TO RESTART REGENERATION.
UPD01170 XC    WRKDECB(32),WRKDECB ZERO DECB
         L     REGA,GTMGRDCB       DCB ADDR
UPD01200 LA    PARM,WRKDECB
         L     REGB,CRSA           ROUTINE START ADDR
         MVC   WRKDECB+20(4),BUFLEN LENGTH IN DECB
         GWRITE (PARM),BUF,(REGA),,(REGB),BUFSTART+2,MF=E
         LA    PARM,WRKDECB
         WAIT  ECB=(1)             WAIT
         CLC   OTHER,ZERO        MORE TO WRITE
         BE    UPD01250            NO
         L     REGC,OTHER          NEXT ONE
         B     UPD01200            GO WRITE THE REST
UPD01250 LA    PARM,WRKDECB        RESTART DISPLAY
         CLI   0(PARM),X'7F'
         BNE   ERR3
         NI    0(PARM),X'BF'
         GCNTRL (PARM),STR,(REGA),GDSFCBUF,MF=E
         LA    PARM,WRKDECB                                      A43072
         WAIT  ECB=(1)                                           A43072
*
*        THE STORAGE OBTAINED FOR THE UPDATE IS FREED AND CONTROL
*        IS RETURNED TO THE CALLING PROGRAM.
*
*
*
UPD01270 L     PARM,FIRST
         L     REGZERO,LENGTH
         FREEMAIN R,LV=(0),A=(1)   FREE CORE FROM UPDATE
         L     SAVE,4(SAVE)
         RETURN (14,12),T,RC=0
         EJECT
UPD01300 C     REGB,TWO            TWO LEFT
         BL    UPD01500            NO
         MVC   0(2,REGA),GNOP      MOVE IN NO-OP
         A     REGA,TWO            BUMP PAST GNOP AND       D11 ZA11418
         ST    REGA,OLP            UPDATE OLP               D11 ZA11418
         B     UPD01500
UPD01400 L     REGB,BUFSTART       BUFSTART
         A     REGB,BUFLEN         + LEN IS START OF NEXT ELEM
         MVC   0(2,REGA),GTRU      MOVE IN GTRU
         STH   REGB,2(REGA)        TO NEXT ELEM
         B     UPD01160
UPD01500 CLC   OTHER,ZERO          IS THERE ANOTHER
         BE    UPD01160            NO
*                                                           D11 ZA11418
*   IF A REPOSITIONING VECTOR WAS JUST PUT OUT TO THE       D11 ZA11418
*   GDOA AND THERE IS NOT ENOUGH LENGTH REMAINING FOR THE   D11 ZA11418
*   TRANSFER ORDER,OVERFLOW MUST BE DONE AND THE TRANSFER   D11 ZA11418
*   VECTOR PUT IN THE NEXT GDOA. THIS CAN BE DONE BY        D11 ZA11418
*   CALLING DATASTORE WITH THE 'OVERFLOW ONLY' CODE.        D11 ZA11418
*                                                           D11 ZA11418
*                                                           D11 ZA11418
         CLI   GDSGRMOD,CNTRL      JUST DONE REPOS VECTOR?  D11 ZA11418
         BNE   UPD01550            NO,DONT DO OVERFLOW      D11 ZA11418
         LA    PARM,WRKGDS1        SETUP CALL TO DATASTOR   D11 ZA11418
         ST    GDSREG,WRKGDS1      GDS                      D11 ZA11418
         L     ERRCD,WRKRTN                                 D11 ZA11418
         ST    ERRCD,WRKRTN1       RTNARRAY PTR             D11 ZA11418
         XC    WRKFLGS1(4),WRKFLGS1 CLEAR FLAGS AND LENGTH  D11 ZA11418
         MVI   WRKFLGS1,OVERFLOW   INDICATE O'FLOW ONLY     D11 ZA11418
         L     REGFIFTN,STAT(,ERRCD) POINT TO STATABLE      D11 ZA11418
         L     REGFIFTN,DSTOR(,REGFIFTN) AND DATASTORE      D11 ZA11418
         BALR  RETURN,REGFIFTN     CALL HIM                 D11 ZA11418
         LTR   REGFIFTN,REGFIFTN   OVERFLOW OK?             D11 ZA11418
         BNZ   ERR4                OVERFLOW ERROR           D11 ZA11418
UPD01550 CLC   OTHER,ZERO          IS THERE ANOTHER OACB?   D11 ZA11418
         BE    UPD01160            NO                       D11 ZA11418
         L     REGC,OTHER          GET NEXT
         L     REGA,OLP            GET ORDER LOAD POINT
         B     UPD01150            GO BUILD TRANS ORDER
UPD01600 L     REGA,BUFSTART       START ADDR IN BUFFER
         L     REGB,CRSA           AND IN CORE FOR UPDATE
         LR    REGE,REGC           SAVE FIRST UPD OACB PTR
         L     REGD,BUFLEN             LENGTH OF UPDATE
         L     REGC,GDSAOACB       STORAGE COPY IN REG OACB
         S     REGA,BUFSTART       DISP IN REG OACB OF UPDATE
         A     REGA,CRSA
         BCTR  REGD,0              LENGTH FOR MOVE
         EX    REGD,MOVE           MOVE UPDATE IN
         LR    REGC,REGE           RESTORE FIRST UPD OACB PTR
         TM    GDSFLAGS,INBUF      IS THIS EQUIV IN BUFFER
         BO    UPD01170            YES WRITE OUT UPDATE
         B     UPD01270            NO FREE STORAGE AND EXIT
ERR3     L     ERRCD,WRKRTN
         OI    0(ERRCD),IO
ERR4     L     SAVE,4(,SAVE)       REPOINT TO CALLER SA     D11 ZA08043
         RETURN (14,12),RC=4
         EJECT
REGZERO  EQU   0
PARM     EQU   1
REGA     EQU   2
REGB     EQU   3
REGE     EQU   4
WORK     EQU   5
ERRCD    EQU   6
GTMREG   EQU   7
GDSREG   EQU   8
BASE     EQU   9
REGC     EQU   10
REGD     EQU   11
SAVE     EQU   13
RETURN   EQU   14
REGFIFTN EQU   15
         EJECT
WAORFLGS EQU   44                  ORGEN CALL                LD YA00808
CNTRL    EQU   0                   CONTROL MODE             D11 ZA11418
OVERFLOW EQU   X'20'               CODE FOR DATASTORE       D11 ZA11418
STAT     EQU   24                  STATBL DSPLCMNT          D11 ZA11418
DSTOR    EQU   852                 DSTOR IN STATBL          D11 ZA11418
PRM      EQU   16
IO       EQU   X'04'
PARMERR  EQU   X'08'
SUBSEG   DC    H'128'
F256     DC    F'256'
F3       DC    F'3'
         DC    C'40 BYTE PATCH AREA FOLLOWS'
         DS    0H     ITS NICE WHEN PATCH DOESNT GIVE 0C6!! D11
PATCH14  DC    40X'FF'             PATCH AREA FOR IFFAHA14  D11
CODE     EQU   0
NOCORE   EQU   X'10'
STRG     EQU   12
OACBLEN  DC    F'64'
UPDT     EQU   X'20'
CURLOG   EQU   52
ONE      EQU   1
SIX      DC    F'6'
FOUR     DC    F'4'
ZERO     DC    F'0'
TWO      DC    F'2'
MINUS1   DC    F'-1'               TO CHECK LOGSTRT=0 COND. D11 ZA10053
EQUIV    EQU   X'08'
INBUF    EQU   X'80'
MOVE     MVC   0(1,REGA),0(REGB)
         EJECT
         GINIT
GNOP     GNOP2
GTRU     GTRU  0
         EJECT
OACBAREA DSECT
OTHER    DS    F
GDOA     DS    F
STATUS   DS    F
CRSA     DS    F
OLP      DS    F
BLP      DS    F
BUFSTART DS    F
BUFLEN   DS    F
FIRST    DS    F
LENGTH   DS    F
CPU2     DS    F
BUF2     DS    F
LOGSTRT  DS    F
LOGCURR  DS    F
LENLEFT  DS    F
ORIG     DS    F
         EJECT
WORKAREA DSECT                     INP PARMLIST MAPPED HERE
WRKADDR  DS    F                   KEY
WRKSKIP1 DS    3F                  IGNORED
WRKGDS   DS    F                   A(GDS)
WRKRTN   DS    F                   A(RTN ARRAY)
WRKSKIP2 DS    11F                 IGNORED
WRKSPACE DS    4F                  WORKAREA
WRKSAVE  DS    18F
WRKDECB  DS    8F
*        PARMLIST TO DATASTORE FOLLOWS                      D11 ZA11418
WRKGDS1  DS    F                   GDS                      D11 ZA11418
WRKRTN1  DS    F                   RTNARRAY PTR             D11 ZA11418
WRKFLGS1 DS    H                   FLAGS                    D11 ZA11418
WRKLEN1  DS    H                   LENGTH                   D11 ZA11418
         COPY  GDSCB
         COPY  GTMCB
         COPY  GSPCB
         END
