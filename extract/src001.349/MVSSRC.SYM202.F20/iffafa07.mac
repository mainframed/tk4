*TITLE         ENSUB
*
*MODULE NAME   IFFAFA07
*
*INPUT         REGISTER 1 ADDRESS OF WORK AREA
*              FIRST WORD OF WORK AREA IS ADDRESS PARAMETER LIST
*                  +0 A(GDSCB)
*                  +4 A(KEY)  OPTIONAL
*              SECOND WORD OF WORK AREA IS ADDRESS OF GSPARRAY
*
*FUNCTION      TO TERMINATE A BUFFER SUBROUTINE
*
*OUTPUT        NONE TO CALLER. KEY IS COMPLETED IF LEVEL 1
         EJECT
*
*REGISTER UTILIZATION
*
R0       EQU   0
R1       EQU   1         PLIST REG
R2       EQU   2         ADDR OF USERS PLIST
R3       EQU   3         KEY ADDR
R4       EQU   4         WORK
R5       EQU   5         WORK
R6       EQU   6
R7       EQU   7         GTMCB
R8       EQU   8         GDSCB
R9       EQU   9         BASE
R10      EQU   10        WORK AREA
R11      EQU   11        GSPARRAY ADDR
R13      EQU   13        SAVE AREA
R14      EQU   14        RETURN REG
R15      EQU   15        BRANCH REG
*
*PROGRAM EQUATES
*
CVTLINK  EQU   8
KEYDISP  EQU   828
DATDISP  EQU   852
         EJECT
IFFAFA07 CSECT
*2239,810000,816000,822000-837000                                  000A
*
*PERFORM NORMAL HOUSEKEEPING FUNCTIONS - SAVE REGISTERS, ESTABLISH
*ADDRESSABILITIES, CHAIN SAVE AREAS
*
         SAVE  (14,12)                 SAVE REGS
         BALR  R9,R0
         USING *,R9                    ESTABLISH CSECT ADDRESSABILITY
         LA    R10,8(R1)
         USING WRKSECT,R10             ESTABLISH WORK AREA ADDRESSABLTY
         ST    R13,SVAREA+4            FORWARD CHAIN SAVE AREAS
         LA    R4,SVAREA
         ST    R4,8(R13)               BACK CHAIN SAVE AREAS
         LR    R13,R4                  SET SAVE AREA REG
*
*PERFORM INITIALIZATION FUNCTIONS
*
         L     R2,0(R1)                GET PLIST ADDR
         ST    R2,SAVEPAD
         L     R11,4(R1)               GET GSPARRAY ADDR
         XC    0(20,R11),0(R11)        ZERO GSPARRAY
         XC    TEMPKEY(4),TEMPKEY      ZERO TEMPORARY KEY
*
*ESTABLISH GDSCB ADDRESSABILITY
*
         L     R8,0(R2)                GET GDSCB PNTR FROM PLIST
         L     R8,0(R8)                GET GDSCB ADDR
         USING GDSCB,R8                ESTABLISH GDSCB ADDRESSABILITY
         NI    GDSGRMOD,X'00'          SET CURRENT MODE DEVICE FLAG
*
*TEST FOR VALID GDS. IF GDS IS NOT OPEN OR IF A GDSCB ADDR IS NOT A
*PARAMETER THE GSPARRAY IS SET AND AN ERROR RETURN IS MADE.
*
         CLC   GDSVALID(2),GDSID
         BE    NDBLSA3
         MVI   19(R11),X'01'           ERROR - GDS INVALID OR UNOPEN
NDBLSB2  MVI   0(R11),X'08'            PARAM ERROR
         B     NDBLSH5
*
*TEST IF A BUFFER SUBROUTINE HAS BEEN STARTED. IF NOT THE GSPARRAY IS
*SET AND AN ERROR RETURN IS MADE.
*
NDBLSA3  TM    GDSFLAGS,X'02'          HAS A SUBRTN BEEN STARTED
         BZ    NDBLSB2                 NO
*
*TEST FOR LRVEL OF SUPPORT. IF LEVEL 1 AND BGSUB WAS NOT CORRELATED
*ENSUB MUST BE KKEYED. IF LEVEL 2 ENSUB MUST BE KEYED,
*
         TM    GDSFLAGS,X'10'          WAS LEVEL 2 REQUESTED
         BO    NDBLSB4                 YES
*
*LEVEL 1 SUPPORT. TEST PARAMETERS
*
         TM    0(R2),X'80'             WAS KEY FIELD USED
         BO    NDBLSC2                 NO
         CLC   5(3,R2),21(R11)         HAS NULL VAR REPLACED KEY
         BE    NDBLSC2                 YES
*
*BGSUB WAS CORRELATED. FIND TEMPORARY KEY IN IN THE TABLE SO
*THAT A PERMANENT KEY CAN BE CREATED.
*
NDBLSD2  LH    R4,GDSKEYSV             GET LOG BFR ADDR OF START OF
*                                      SUBRTN FROM GDSCB
         STH   R4,TEMPKEY+2            SETUP TEMPORARY KEY FOR
         LA    R4,TEMPKEY              KEY TABLE SEARCH
*
*BUILD PARAMETER LIST FOR KEY TABLE MANAGEMENT.
NDBLSE3  LA    R5,KEYCODE2             CODE FOR KEY SEARCH
         ST    R5,KEYPLIST+4           PUT CODE ADDR IN PLIST
         ST    R8,KEYPLIST             PUT GDSCB IN PLIST
         ST    R4,KEYPLIST+8           PUT KEY ADDR IN PLIST
*
*LINK TO CODE THAT WILL INVOKE KEY TABLE MANAGEMENT
*
         LA    R15,NDBLSF3
         BALR  R4,R15
*
*TEST FOR SUCCESSFUL COMPLETION OF KEY TABLE MANAGEMENT
*
         LTR   R15,R15                 WAS RTN SUCCESSFUL
         BP    NDBLSB5                 NO
         ST    R1,KEYSV                SAVE KEY ADDR
         B     NDBLSC4
NDBLSB5  MVI   19(R11),X'02'           ERROR - KEY NOT FOUND
         B     NDBLSB2
*
*LEVEL 1 SUPPORT. ENDSUB HAS NOT BEEN KEYED. BEGSUB MUST HAVE BEEN
*CORRELATED, IF NOT THE KEY TABLE IS RESET AS IT WAS BEFOR BGSUB WAS
*CALLED AND AN ERROR RETURN IS MADE.
*
NDBLSC2  TM    GDSFLAGS,X'40'          WAS BGSUB CORRELATED
         BZ    NDBLSD2                 YES
*
*BUILD PARAMETER LIST FOR KEY TABLE MANAGEMENT - RESET TO KEY
*
         LA    R5,KEYCODE3
         ST    R5,KEYPLIST+4
         ST    R8,KEYPLIST
         MVC   TEMPKEY+2(2),GDSKEYSV
         LA    R4,TEMPKEY
         ST    R4,KEYPLIST+8
*
*LINK TO CODE THAT WILL INVOKE KEY TABLE MANAGEMENT
*
         LA    R15,NDBLSF3
         BALR  R4,R15
         B     NDBLSB2
*
*LEVEL 2 SUPPORT. ENDSUB MUST BE KEYED, IF NOT AN ERROR RETURN IS MADE
*
NDBLSB4  TM    0(R2),X'80'             WAS KEY FIELD USED
         BO    NDBLSB5                 NO
         CLC   5(3,R2),21(R11)         HAS NULL VAR REPLACED KEY
         BE    NDBLSB5                 YES
*
*A VALID LEVEL 2 SUBROUTINE HAS BEEN CREATED.  BUILD A DUMMY KEY FOR
*USE IN COMPUTING THE PHYSICAL BUFFER ADDRESS.
*
         SR    R1,R1
         LH    R1,GDSKEYSV             GET LOG BUFFER STARRT ADDR
         ST    R1,TEMPKEY              SETUP DUMMY KEY
         LA    R1,TEMPKEY
         ST    R1,KEYSV                SAVE KEY ADDR
*
*A SUBROUTINE HAS BEEN CORRECTLY CREATED. TEST FOR 128 BYTE GDOA.
*
NDBLSC4  LA    R4,128
         CH    R4,GDSGDOAL             IS GDOA 128 BYTES
         BE    NDBLSC5                 YES
*
*COMPUTE PHYSICAL BUFFER ADDRESS OF START OF SUBROUTINE.
*
*MULTIPLE 256 GDOA
*
         LH    R6,GDSGDOAL             GET GDOA LENGTH FROM GDSCB
         SH    R6,C6                   COMPUTE DIVISOR
         LH    R5,2(R1)                GET LOG BFR START ADDR FROM KEY
         M     R4,C1                   PROPAGATE SIGN BIT
         DR    R4,R6                   COMPUTE ELEMENT NUMBER IN GDS
*
*SEARCH BUFFER CONTROL TABLE FOR      BUFFER SEGMENT
*
         LH    R6,GDSBCTEL             GET BCT INDEX
         MH    R6,CH3                  EXPAND BCT INDEX
         L     R7,GDSGTMCB             GET GTMCB ADDR
         USING GTMCB,R7                ESTABLISH GTMCB ADDRESSABILITY
         L     R2,GTMBCTBL             GET BCT ADDR FROM GTMCB
NDBLSD4A SR    R3,R3
         IC    R3,2(R6,R2)             GET CT FIELD FROM BCT
         CR    R3,R5                   IS THIS THE LAST SEGMENT
         BE    NDBLSD4B                YES
*
*TEST LOGICAL BUFFER ADDRESS IN KEY FOR CORRECTNESS.
*
         SR    R3,R3
         IC    R3,1(R2,R6)             GET PTR TO NEXT SEGMENT
         MH    R3,CH3                  COMPUTE PTR TO NEXT SEGMENT
         CR    R6,R3                   ARE PTR AND INDEX EQUAL
         BE    NDBLSB2                 YES
         LR    R6,R3
         B     NDBLSD4A
*
*PROPER BUFFER CONTROL TABLE ENTRY HAS BEEN FOUND. COMPUTE PHYSICAL
*BUFFER ADDRESS.
*
NDBLSD4B LR    R5,R6                   PREPARE DIVIDEND
         LR    R6,R4                   TRANSFER REMAINDER
         M     R4,C1                   PROPAGATE SIGN BIT
         D     R4,C3                   COMPUTE SEGMENT NUMBER
         MH    R5,C256                 COMPUTE NUMBER OF BYTES
         LA    R5,6(R5,R6)             COMPUTE PHYS BFR ADDR
         B     NDBLSE4
*
*COMPUTE PHYSICAL BUFFER ADDRESS FOR 128 BYTE GDOA
*
NDBLSC5  LH    R3,GDSBCTEL             GET BCT INDEX
         LH    R6,2(R1)                GET LOG BFR START ADDR FROM KEY
         LR    R5,R3
         MH    R5,C256                 COMPUTE BFR START ADR OF SEGMENT
         MH    R3,CH3                  EXPAND BCT INDEX
         L     R7,GDSGTMCB
         L     R4,GTMBCTBL             GET BCT ADDR
         AR    R4,R3                   COMPUTE BCT SEGMENT ADDR
         CLC   0(1,R4),GDSBCTID        FIRST OR SECOND HALF OF SEGMENT
         BE    NDBLSC5A                FIRST
         LA    R5,134(R5,R6)           COMPUTE PHYS BUFFER ADDR
         B     NDBLSE4
NDBLSC5A LA    R5,6(R5,R6)             COMPUTE PHYS BUFFER ADDR
*
*SETUP DATA STORE PARAMETERS. GTRU TO START OF SUBROUTINE
*
NDBLSE4  ST    R8,DATSTOR              PUT GDSCB ADDR IN PLIST
         ST    R11,DATSTOR+4           PUT GSPARRAY ADDR IN PLIST
         MVC   DATSTOR+8(8),SUBCONST    SET FLAG FIELDS AND GTRU
         STH   R5,DATSTOR+14           COMPLETE GTRU
*
*INVOKE DATA STORE. THE DATA STORE ROUTINE IS USED TO PUT THE TRANSFER
*ORDER TO THE START OF THE ROUTINE IN THE GDOA.
*
         LA    R1,DATSTOR              GET PLIST ADDR
         L     R5,24(R11)              GET STATAB ADDR
         L     R15,DATDISP(R5)         GET EP ADDR
         BALR  R14,R15                 LINK WITH DATA STORE
*
*WAS DATA STORE SUCCESSFUL
*
         LTR   R15,R15                 WAS DATA STORE SUCCESSFUL
         BP    NDBLSH5                 NO
*
*SETUP PARAMETERS NEEDED BY DATA STORE TO RESOLVE SUBROUTINE ADDRESS
*
         MVI   DATSTOR+8,X'02'         INDICATE TO DATA STORE THET
         XC    DATSTOR+9(3),DATSTOR+9  IT SHOULD RESOLVE SUBRTN ADDR
         LA    R1,DATSTOR              GET PLIST ADDR
*
*INVOKE DATA STORE. THE DATA STORE ROUTINE IS USED TO RESOLVE THE
*TRANSFER ADDRESS PAST THE SUBROUTINE. THIS TRANSFER PREVENTS INLINE
*EXECUTION OF THE SUBROUTINE.
*
         L     R5,24(R11)              GET STATUS TABLE ADDR
         L     R15,DATDISP(R5)         GET EP ADDR
         BALR  R14,R15                 LINK WITH DATA STORE
*
*COMPLETE KEY BY INCLUDING SUBROUTINE LENGTH. RETURN THE KEY IN THE
*KEY RETURN WORD IF ONE WAS SPECIFIED.
*
         L     R3,KEYSV                GET KEY ADDR
         L     R2,SAVEPAD
         L     R4,GDSAOACB             GET OACB ADDR
         L     R5,52(R4)               GET BFR ORDER LOAD POINT
         SH    R5,2(R3)                COMPUTE LENGTH
         STH   R5,0(R3)                COMPLETE KEY
         TM    0(R2),X'80'             WAS KEY PARAM SPECIFIED
         BO    NDBLSH5                 NO
         L     R5,4(R2)                GET KEY RETURN WORD ADDR
         MVC   0(4,R5),0(R3)           RETURN KEY
NDBLSH5  L     R13,SVAREA+4
         NI    GDSFLAGS,X'BD'          TURN OFF SUBROUTINE BEGUN FLAG
         RETURN (14,12),T
*
*INVOKE KEY TABLE MANAGEMENT
*
NDBLSF3  L     R5,24(R11)              GET STATAB ADDR
         L     R15,KEYDISP(R5)         GET EP ADDR
         LTR   R15,R15                 HAS MODULE BEEN LOADED
         BZ    NDBLSB2             NO-ERROR                        000A
NDBLSF3A LA    R1,KEYPLIST
         BALR  R14,R15             BRANCH TO KEY TABLE MGMT        000A
         BR    R4
         EJECT
*
*DEFINED CONSTANTS
*
SUBCONST DC    F'4'
         GINIT
         GTRU  0
KEYCODE2 DC    F'2'
KEYCODE3 DC    F'3'
C1       DC    F'1'
C3       DC    F'3'
CF256    DC    F'256'
GDSID    DC    X'F203'
CH3      DC    H'3'
C6       DC    H'6'
C256     DC    H'256'
*
*WORK AREA DSECT
*
WRKSECT  DSECT
KEYSV    DS    F
SAVEPAD  DS    F
SVAREA   DS    18F
KEYPLIST DS    10F
TEMPKEY  DS    F
SUPPLIST DS    4F
DATSTOR  DS    12F
         COPY  GDSCB
         COPY  GTMCB
         END
