*
*
*                             RESET INPUT PARAMETER LIST
*
*                             +0   A(GDSVAR) VARIABLE CONTAINING
*                                            THE ADDRESS OF THE
*                                            GDSCB
*
*                             OPTIONAL:
*                             +4   A(CORVAL) CORRELATION VALUE
*                             +8   A(KEY)    KEY
*
*
*
*
*
*
*
*        RESET IS ENTERED FROM THE DIRECTOR PART 2 WHEN BEING CALLED
*        BY A PROGRAM EXTERNAL TO GSP.  INTERNALLY, RESET IS CALLED
*        FROM ANY DATA GENERATING ROUTINE (SUCH AS PLINE) WHICH
*        ENCOUNTERS AN ERROR WHILE GENERATING DATA AND MUST RESTORE
*        THE SYSTEM TO THE CONDITION BEFORE THE CALL.  THE WAY RESET
*        DETERMINES IF THE CALL IS FROM AN INTERNAL ROUTINE FOR A KEY
*        LEVEL 1 GDS IS THAT IS SEARCHES THE KEY TABLE FOR THE KEY.
*        IF THE KEY IS NOT FOUND, THE LENGTH FIELD OF THE KEY IS
*        CHECKED FOR ZERO.  IF THE LENGTH IS ZERO IT IS ASSUMED
*        THAT THE CALL IS FROM THE INTERNAL ROUTINE.
*
*        EXTERNAL ROUTINES REFERENCES ARE:
*        KEY TABLE MANAGEMENT-IFFAHA03
*        BUFFER MANAGEMENT-IFFAHA02
*        EXEC-IFFAFA11
*
*        EXTERNAL MACROS USED ARE:
*        LINK
*        GWRITE
*        WAIT
*
         EJECT
IFFAFA12 CSECT
*2101,111000,121000                                                000A
*
*        ON ENTRY RESET ESTABLISHES A BASE REGISTER, SET UP THE WORK
*        AREA DSECT, ZEROS THE RETURN ARRAY, AND CHAINS THE SAVE
*        AREAS.
         SAVE  (14,12)
         BALR  BASE,0
         USING *,BASE
         LR    WORK,PARM           SET UP WORK AREA DSECT
         USING WORKAREA,WORK
         L     PARM,WRKPARM        LOAD ADDR OF PARM LIST
         L     ERRCD,WRKRTNCD
         XC    WRKSPVSR(12),WRKSPVSR ZERO SUPERVISOR PARAMETER LIST
         XC    0(20,ERRCD),0(ERRCD) ZERO RETURN ARRAY
         ST    SAVE,WRKSAVE+4      CHAIN SAVE AREAS
         LA    REGA,WRKSAVE
         ST    REGA,8(SAVE)
         LR    SAVE,REGA
*
*        RESET PICKS UP THE FIRST PARAMETER, THE GDSCB ADDRESS, INIT-
*        IALIZES THE DSCET AND CHECKS ITS VALIDITY.  IF VALID IT
*        NEXT INITIALIZES THE GTMCB DSECT.  IT ZEROS THE CORVAL
*        AND KEY LOCATION.  THE KEY IS THE FULL THREE WORDS OF
*        THE ACTUAL KEY THAT WOULD BE EXPECTED BACK FROM KEY
*        TABLE MANAGEMENT.
         L     GDSREG,GDS(PARM)    PICK UP ADDRESS OF GDSCB
         L     GDSREG,0(GDSREG)
         USING GDSCB,GDSREG        SET UP DSECT
         C     GDSREG,GDSGDSCB     IS GDSCB VALID
         BNE   ERR1                NO
         L     GTMREG,GDSGTMCB
         USING GTMCB,GTMREG        SET UP GTMCB DSECT
         XC    WRKCORVL,WRKCORVL   ZERO CORVAL
         XC    WRKKEY(12),WRKKEY   ZERO KEY
         EJECT
*
*        A CHECK IS MADE TO SEE IF THE GDS IS THE LAST PARAMETER
*        PASSED IN WHICH CASE THE ENTIRE GDS MUST BE RESET.  IF
*        THIS IS THE CASE A DUMMY KEY IS SET UP WITH A LOGICAL
*        ADDRESS OF ZERO.
         TM    GDS(PARM),LAST      IS THERE ONLY ONE PARM
         BO    RST00800            YES, RESET ENTIRE GDS
*
*        THE ADDITIONAL PARAMETERS, KEY AND CORVAL ARE CHECKED.
*        IF THE KEY IS PASSED THAT IS WHAT IS USED TO SEARCH THE
*        KEY TABLE.  IF THE KEY IS NOT FOUND, AND IN FACT WAS
*        PASSED, AND THE LENGTH IF THE KEY IS ZERO IT IS ASSUMED
*        THAT THIS IS A GSP RESET AND THE KEY TABLE RESET IS
*        BYPASSED.  IF THE KEY IS FOUND IT IS PLACED IN THE WORK
*        AREA AND THEN THE KEY TABLE IS RESET.  NOTE THAT FOR
*        LEVEL TWO ALL KEY TABLE MANIPULATION IS BYPASSED.
*
         CLC   NULL+1(3,ERRCD),CORVL+1(PARM)
         BE    RST00100            YES
         L     REGB,CORVL(PARM)
         MVC   WRKCORVL,0(REGB)    PLACE CORVAL IN WORK AREA
RST00100 TM    CORVL(PARM),LAST    IS KEY PASSED
         BO    RST00850
         CLC   NULL+1(3,ERRCD),KEY+1(PARM) NULL
         BE    RST00850            YES
         L     REGB,KEY(PARM)
         MVC   WRKKEY,0(REGB)      YES, PLACE KEY IN WORK AREA
         TM    GDSFLAGS,LEVEL2     IS THIS LEVEL 2
         BO    RST00400            YES
         LA    REGB,WRKKEY
         ST    REGB,WRKPRLST+8     ADDR OF KEY
         LA    REGB,KEYSRCH        SEARCH ON KEY CODE
         EJECT
RST00200 ST    REGB,WRKPRLST+4
         ST    GDSREG,WRKPRLST     ADDRESS OF GDSCB
         LA    PARM,WRKPRLST
         L     REGB,GTMGSPCB       GET POINTER TO GSPCB            000A
         L     REGB,FE(REGB)       GET POINTER TO STATUS TABLE     000A
         L     REG15,ETE(REGB)     GET A&RS OF KEY TABLE MGMT      000A
         BALR  REG14,REG15         BRANCH TO KEY TABLE MGMT        000A
         LTR   REG15,REG15         FOUND
         BNE   RST01000            NO
         MVC   WRKKEY(12),0(PARM)  SAVE ENTIRE KEY
RST00300 LA    REGB,WRKKEY         BUILD PARM LIST TO RESET KEY TABLE
         ST    REGB,WRKPRLST+8     A KEY OF ZERO WILL RESET THE
         LA    REGB,RESETCDE       ENTIRE TABLE. FROM NOW ON A KEY
         ST    REGB,WRKPRLST+4     CONTAINING ZERO WILL
         ST    GDSREG,WRKPRLST     SIGNIFY RESET THE ENTIRE GDS
         LA    PARM,WRKPRLST
         L     REGB,GTMGSPCB       GET POINTER TO GSPCB            000A
         L     REGB,FE(REGB)       GET POINTER TO STATUS TABLE     000A
         L     REG15,ETE(REGB)     GET ADRS OF KEY TABLE MGMT      000A
         BALR  REG14,REG15         BRANCH TO KEY TABLE MGMT        000A
         EJECT
*
*        AT THIS POINT ALL POSSIBLE CASES THAT HAVE NOT EXITED
*        BECAUSE OF ERRORS ARE TOGETHER FOR THE LAST TIME.
*        WE HAVE A GUY RESETING THE GDS.  FOR THAT WRKKEY CONTAINS
*        ZERO.  THERE IS THE GUY RESETING A KEY OR CORVAL LEVEL
*        ONE.  FOR HIM WE HAVE A TWELVE BYTE KEY FROM THE KEY TABLE
*        CONTAINING ASSORTED INFORMATION ABOUT THE ELEMENT WE ARE
*        RESETING TO.  LAST WE HAVE A LEVEL TWO KEY OR A GSP
*        RESET KEY CONTAINING A LOGICAL BUFFER ADDRESS BUT NO
*        INFORMATION ABOUT THE ELEMENT WE ARE RESETING TO.
*        WE WILL SET UP THE OACB DSECT AND THE PROCESSING WILL
*        SPLIT INTO TWO PATHS.  ONE IS FOR THE RESET WHICH WILL
*        TAKE PLACE IN THE GDOA AND THE OTHER IS WHERE RESET
*        IN THE BUFFER.  NOTE THAT FOR EQUIVALENCE GDSS THE RESET
*        WILL ALWAYS BE IN THE GDOA.  ALSO, IF THE RESET IS
*        IN THE GDOA NO BUFFER WILL HAVE TO BE RELEASED SO THE
*        CALL TO BUFFER MANAGEMENT IS AT THE RESET TO THE BUFFER
*        ONLY.  A CHECK IS MADE TO SEE IF ANY DATA WAS EVER
*        GENERATED BECAUSE A RESET TO THE GDS MIGHT BE CALLED
*        BEFORE THIS.
*
RST00400 LH    REGA,WRKKEY+2       LOAD LOGICAL START ADDR
         L     OACB,GDSAOACB       INITIALIZE OACB DSECT
         USING OACBARA,OACB
         TM    STATUS,NO           WAS BUFFER EVER ASSIGNED
         BO    RST00500            EXIT
         C     REGA,LOGSTRT        IS DATA IN GDOA
         BL    RST00600            NO
         EJECT
*
*        IF THE RESET IS IN THE GDOA THE LOGICAL CURRENT ADDRESS
*        IS SET TO THE ADDRESS IN THE KEY.  FOR THE RESET OF A
*        GDS THIS IS ZERO.  THE OLP IS SET BACK THE LENGTH OF THE
*        RESET.  THE LENGTH LEFT IS INCREASED THE LENGTH OF THE
*        RESET.  THE UNRESOLVED ADDRESS POINTER WHICH WOULD ALWAYS
*        BE SET FOR AN ELEMENT (NOT SEQUENCE OR SUBROUTINE) IS
*        SET TO ZERO.
         L     REGB,LOGCURR        PICK UP LOGICAL CURRENT
         SR    REGB,REGA           SUBTRACT RESET LOGICAL TO DETERMINE
         ST    REGA,LOGCURR        LENGTH-KEY ADDR=NEW LOGCURR
         L     REGA,OLP            OLP
         SR    REGA,REGB           MINUS LENGTH OF RESET
         ST    REGA,OLP            IS NEW OLP
         A     REGB,LENLEFT        LENGTH LEFT INCREASED BY LENGTH
         ST    REGB,LENLEFT        OF RESET
         XC    CPU2(8),CPU2        ZERO UNRES ADDR POINTER
         EJECT
*
*        A CHECK IS MADE TO SEE IF THERE IS A SEQUENCE OR SUBROUTINE
*        OPEN BEFORE THE RESET.  IF SO A CHECK IS MADE TO SEE IF
*        WE ARE RESETING WITHIN THE SEQUENCE OR SUBROUTINE, TO IT,
*        OR BEYOND IT.  IF WE ARE STILL WITHIN IT ALL SEQUENCE,
*        SUBROUTINE UPDATING IS COMPLETE.  IF WE ARE RESETING TO
*        IT, THE SEQUENCE, SUBROUTINE SWITCH IS SET TO ZERO,
*        THE GDSKEYSV ADDRESS IS SET TO ZERO AND THE UNRESOLVED
*        ADDRESS IN THE OACB, CPU1 OR BUF1 IS SET TO ZERO.  IF
*        WE ARE RESETING BEYOND IT A CHECK IS MADE TO SEE IF THIS
*        IS A SEQUENCE OR SUBROUTINE MEMBER KEY.  FOR A GDS, OR
*        A LEVEL TWO KEY THIS WILL ALWAYS BE ZERO.  IF THE KEY
*        DOES NOT BELONG TO A SEQUENCE OR SUBROUTINE THE SAME
*        PROCESSING TAKES PLACE AS FOR A RESET TO A SEQUENCE OR
*        SUBROUTINE KEY.  OTHERWISE THE KEY TABLE IS SEARCHED
*        FOR THE LAST SEQUENCE OR SUBROUTINE KEY BEFORE THIS
*        KEY (NOTE IT HAS ALREADY BEEN RESET TO THIS KEY SO
*        THE LAST KEY FOR A SEQUENCE OR SUBROUTINE WILL BE THE
*        ONE TO WHICH OUR KEY BELONGS.  THE SEQUENCE OR
*        SUBROUTINE IS REOPENED BY SETTING THE LENGTH OF THE
*        SEQUENCE OR SUBROUTINE KEY IN THE KEY TABLE TO ZERO.
*        THE GDSKEYSV LOCATION IN THE GDSCB WILL BE SET TO THE
*        LOGICAL ADDRESS OF THE KEY AND THE SEQUENCE OR SUBROUTINE
*        STARTED WHICH WILL BE SET.  THE FLOW CONTROL RETURN ADDRESS
*        IS PLACED AT THE TOP OF THE SEQUENCE OR SUBROUTINE IN THE
*        GDOA AND THE CPU ADDRESS OF THE UNRESOLVED ADDRESS IS
*        SAVED IN THE CPU1 LOCATION IN THE OACB.
*
RST00410 TM    GDSFLAGS,SEQ+SUB    IS A SEQ,SUB ALREADY OPEN
         BZ    RST00413            NO
         CLC   GDSKEYSV,WRKKEY+2   IS THIS THE ONE ALREADY OPEN
         BL    RST00440            WITHIN STARTED SEQ A OK
         BE    RST03200            RESET TO SEQUENCE KEY
RST00413 TM    WRKKEY+7,SEQM+SUBM  IS THE KEY SEQ OR SUBR MEMBER
         BZ    RST03200            NO ZERO SEQ AND EXIT
         BAL   REG15,RST01920      SEARCH FOR DEQ KEY& CONVRT TO PHYSBF
         CLC   GDSGDOAL,H128       SUB SEG
         BNE   RST00415            NO
         BAL   REG14,RST01100      GO GET SUBSEG ADDR
         L     REGB,WRK128TP       PICK UP 128 START ADDR
RST00415 L     REGA,BLP            BUFFER LOAD POINT
         SR    REGB,REGA           MINUS PHYS BUFFER
         A     REGB,CRSA           POS IN GDOA OF START OF SEQ OR SUBR
         NI    GDSFLAGS,NTSEQSUB   ZERO SEQ/SUBR SW
         L     REGC,WRKSEQKY       LOAD SEQ/SUBR KEY
         TM    5(REGC),X'08'       SEQ
         BO    RST00420
         OI    GDSFLAGS,SEQ        SET SEQ SW
         B     RST00430
         EJECT
RST00420 OI    GDSFLAGS,SUB        SET SUBR SW
         LA    REGB,8(REGB)        UPDATE TO INCLUDE OMIT
RST00430 LA    REGB,2(REGB)        TO THE ADDR
         MVC   0(2,REGB),GDSOVDAT+2 MOVE IN FLOW CTL RTN ADDR
         ST    REGB,CPU1           SAVE CPU ADDR OF UNRES
         XC    BUF1,BUF1           ZERO BUFFER ADDR LOC
         CLC   8(4,REGC),ZERO      IS IT CORRELATED
         BNE   RST00440            NO
         OI    GDSFLAGS,CRVLPRES   SET CORRELATED FLAG IN GDS
*
*        A CHECK IS MADE TO SEE IF THIS IS AN EQUIVALENCE GDS WHICH
*        IS CURRENTLY IN THE BUFFER.  IF SO A CALL TO EXEC-IFFAFA11
*        IS MADE TO PLACE THE NEW COPY OF THE GDS OUT INTO THE BUFFER.
RST00440 TM    GDSFLAGS,EQUIV      IS THIS AN EQUIV IN THE BUFFER
         BZ    RST00500            NO EXIT
         LA    REGA,GDSGDSCB       GDSCB
         ST    REGA,WRKPRLST       IN PARM LIST
         OI    WRKPRLST,LAST       SET LAST PARM SW
         LA    REGA,WRKPRLST
         ST    REGA,WRKPRM         PARM LIST IN WORK AREA
         ST    ERRCD,WRKERR        FOR EXEC
         LA    PARM,WRKPRM
         EJECT
*//
*//      GO EXECUTE THIS EQUIVALENCE GDS
*//
         LINK  EP=IFFAFA11,MF=(E,(1)),SF=(E,WRKSPVSR)
*
*        THE CURRENT MODE SWITCH IS SET TO ZERO SO THAT THE NEXT
*        CALL TO A DATA GENERATING SUBROUTINE WILL GENERATE A SET
*        MODE ORDER.  CONTROL IS THEN RETURNED TO THE CALLING PROGRAM.
*
RST00500 MVI   GDSGRMOD,0          SET TO CONTROL MODE
RST00550 L     SAVE,4(SAVE)        RETURN
         RETURN (14,12),T
         EJECT
*
*        IT HAS BEEN DETERMINED THAT THE RESET MUST TAKE PLACE
*        IN THE BUFFER.  A CHECK IS MADE TO SEE IF THE GDOA LENGTH
*        IS 128.  IF NOT THE LOGICAL ADDRESS OF THIS KEY IS DIVIDED
*        BY THE GDOA LENGTH LESS SIX FOR THE CONTROL BYTES TO DETER-
*        MINE WHICH SEGMENT OF BUFFER THIS BELONGS IN.  THE
*        QUOTIENT OF THE DIVIDE IS THE COUNT FIELD INTO THE BUFFER
*        CONTROL TABLE AND THE REMAINDER IS THE DISTANCE FROM THE
*        TOP OF THE SEGMENT THAT THIS LOGICAL ADDRESS IS LOCATED
*        AT.
*
RST00600 CLC   GDSGDOAL,H128       IS GDOA A SUB SEGMENT
         BE    RST01050            YES, MUST BE HANDLED SEPARATELY
         SRDA  REGA,32             LOAD LOG INTO ODD REGISTER
         LH    REGC,GDSGDOAL       GDOA LEN
         S     REGC,SIX            MINUS SIX
         DR    REGA,REGC           DIVIDED INTO LOG ADDR=CT
         SR    REGD,REGD           ZERO REG
         LH    REGC,GDSBCTEL       PICK UP DISPLACEMENT
         MH    REGC,F3+2
         L     REG14,GTMBCTBL      TABLE ADDR
RST00700 IC    REGD,2(REGC,REG14)  PICK UP COUNT
         CR    REGD,REGB           EQUAL TO COUNT I HAVE
         BE    RST01300            YES
         IC    REGD,1(REGC,REG14)  PICK UP PTR TO NEXT
         MH    REGD,F3+2
         CR    REGD,REGC           IS THIS LAST
         BE    ERR2
         LR    REGC,REGD
         SR    REGD,REGD
         B     RST00700
RST00800 TM    GDSFLAGS,LEVEL2     LEVEL2
         BO    RST00400            YES, DO NOT RESET KEY TABLE
         CLC   GDSKEYTB,ZERO       IS THERE A KEY TABLE
         BE    RST00400            NO BYPASS DELETION
         B     RST00300            RESET ENTIRE KEY TABLE
         EJECT
RST00850 CLC   WRKCORVL,ZERO       IS IT CORRELATED
         BE    RST00800            RESET GDS
RST00900 LA    REGB,WRKCORVL       ADDR OF CORVL
         ST    REGB,WRKPRLST+8
         LA    REGB,CORVSRCH       SEARCH ON CORVAL CODE
         B     RST00200            GO SEARCH
RST01000 CLC   WRKKEY(2),ZERO      IS LENGTH IN KEY ZERO
         BE    RST00400            YES THIS IS A SYSTEM ERROR RESET
         B     ERR2                BAD KEY/CORVAL
*
*        IF THE GDOA IS A SUBSEGMENT THE PHYSICAL ADDRESS OF THE
*        SUBSEGMENT IS COMPUTED AND THE LOGICAL ADDRESS IS THE
*        DISPLACEMENT INTO THE SEGMENT WHERE THE ELEMENT IS LOCATED.
*
RST01050 LA    REG14,RST01400
RST01100 LH    REGD,GDSBCTEL       PICK UP ELEM
         M     REGC,F256
         LH    REGB,GDSBCTEL       DISP IN TABLE
         MH    REGB,F3+2
         A     REGB,GTMBCTBL       ADDR OF TABLE
         CLC   GDSBCTID,0(REGB)    IS SUBSEGMENT FIRST HALF
         BE    RST01200            YES
         AH    REGD,H128           NO, ADD 128 TO ADDR
RST01200 LH    REGA,WRKKEY+2       LOAD LOG ADDR
         ST    REGD,WRK128TP       SAVE 128 START
         AR    REGD,REGA           COMPUTE BUFFER LOC
         LA    REGD,2(REGD)        +2 FOR SET MODE
         BR    REG14               RETURN TO CALLER
         EJECT
RST01300 L     REGD,F256           256
         ST    REGC,WRKDSP         SAVE DISP
         M     REGC,WRKDSP         256 X DISP
         D     REGC,F3             DIV BY 3
         AR    REGD,REGA           PLUS DIST FROM TOP
         LA    REGD,2(REGD)        +2 FOR SET MODE
*
*        THE BUFFER ADDRESS IS SAVED.  THE CRSA IS SET EQUAL TO
*        THE GDOA AND SO IS THE OLP.  THE UNRESOLVED ADDRESS FOR AN
*        ELEMENT IS SET TO ZERO.  THE LOGICAL ADDRESS IN THE KEY
*        BECOMES THE LOGICAL CURRENT AND LOGICAL START ADDRESS.
*        THE BUFFER ADDRESS COMPUTED IS THE BLP.  IT IS ALSO THE
*        BUFFER START.  THE DISPLACEMENT INTO THE SEGMENT PLUS THE
*        SIX CONTROL BYTES SUBTRACTED FROM THE GDOA LENGTH BECOMES
*        THE LENGTH LEFT IN THE GDOA.  IF IT IS A SUBSEGMENT THE
*        CALL TO BUFFER MANAGEMENT IS BYPASSED.
*
RST01400 ST    REGD,WRKBUFR        SAVE BUFFER ADDRESS
         MVC   CRSA,GDOA           SET CRSA=GDOA
         MVC   OLP,GDOA            SET OLP=CRSA,GDOA
         XC    CPU2(8),CPU2        ZERO SECOND UNRES ADDR
         MVC   LOGSTRT+2(2),WRKKEY+2  SET UP NEW
         MVC   LOGCURR,LOGSTRT     LOG START AND LOG CURRENT
         ST    REGD,BLP            SET UP BUFFER LOAD POINT
         ST    REGD,BUFSTART       AND BUFFER START
         LH    REGB,GDSGDOAL       COMPUTE
         S     REGB,SIX            LENGTH
         SR    REGB,REGA           LEFT
         ST    REGB,LENLEFT        AND STORE
         A     REGB,FOUR           ADD FOUR FOR TRANS ORD
         ST    REGB,BUFLEN          IN BUFFER LENGTH
         CLC   GDSGDOAL,H128       IS THIS A SUBSEGMENT
         BE    RST01600            YES
         EJECT
*
*        HERE BUFFER MANAGEMENT IS CALLED PASSING IT IN DISPLACE-
*        MENT INTO THE BUFFER CONTROL TABLE OF THIS SEGMENT.  ANY
*        SUCCEEDING SEGMENTS WILL BE RELEASED TO THE SYSTEM BY
*        BUFFER MANAGEMENT.  A CHECK IS MADE TO SEE IF THE
*        REPLACEMENT DATA IF ANY IN THE GDSCB IS PART OF THE
*        RESET.  IF NOT IT IS LEFT AS IS.  IF YES THE FIELDS ARE
*        ZEROED AND THE FLAG TO SAVE THE NEXT FOUR BYTES AS
*        REPLACEMENT DATA ARE SET IN THE OACB FOR THE NEXT OVERFLOW.
*
         MVC   WRKPRLST(4),SIX     NO GO TO UBFFER MANAGEMENT
         ST    GDSREG,WRKPRLST+4   TO RESET BUFFER
         L     PARM,WRKDSP
         SR    REG0,REG0
         D     REG0,F3
         ST    PARM,WRKPRLST+8     DISP OF THIS ENTRY
         LA    PARM,WRKPRLST
         ST    PARM,WRKPRM
         LA    PARM,WRKPRM
         ST    ERRCD,WRKERR
         L     REG15,STAT(ERRCD)
         L     REG15,BMGT(REG15)
         BALR  REG14,REG15         CALL BUFFER MANAGEMENT
         LH    REGB,GDSREPPB       PICK UP REPLACEMENT DATA ADDR
         LTR   REGB,REGB           ANY REPL DATA
         BE    RST01600            NO
         EJECT
         M     REGA,F3
         D     REGA,F256           REFERENCE BCT FOR ENTRY FOR
         A     REGB,GTMBCTBL       THIS BUFFER ADDRESS
         CLI   0(REGB),0           HAS BEEN RESET
         BNE   RST03000            NO
RST01500 XC    GDSREPPB,GDSREPPB   ZERO REPLACEMENT DATA
         XC    GDSREPDT,GDSREPDT
         OI    STATUS,SAVEFOUR     SET  STATUS TO SAVE FOUR
RST01600 L     REGA,GTMDECB1       GRAPHIC DECB
         L     REGB,GTMGRDCB       DCB
         LR    PARM,REGA
         WAIT  ECB=(1)             WAIT ON OLD I/O
*
*        WE WILL NOW WRITE OUT A GTRU TO FLOW CONTROL
*        AT THE ADDRESS DETERMINED. IN ALL CASES IT MAY
*        NOT BE NEEDED BUT I CAN'T FIGURE OUT EASILY IF
*        IT IS OR NOT
*
         LR    PARM,REGA
         CLI   0(PARM),X'7F'
         BNE   ERR3
         NI    0(PARM),X'BF'
         GWRITE (PARM),STR,(REGB),4,GDSOVDAT,BUFSTART+2,GDSFCBUF,MF=E
         EJECT
*
*        A CHECK IS MADE TO SEE IF A SEQUENCE OR SUBROUTINE HAS BEEN
*        BEGUN BUT NOT COMPLETED.  IF YES A TEST IS MADE TO SEE IF
*        WE ARE RESETING WITHIN THE SEQUENCE OR SUBROUTINE, TO IT
*        OR BEYOND IT.  IF WE RESET TO THE SUBROUTINE OR SEQUENCE
*        THE FLAGS, UNRESOLVED ADDRESS AND LOGICAL ADDRESS OF THE
*        KEY IN THE GDSCB MUST BE SET TO ZERO.  IF WE ARE
*        RESETING BEYOND IT BUT NOT INTO ANOTHER SEQUENCE OR
*        SUBROUTINE THE SAME THING TAKES PLACE.  AFTER THIS CONTROL
*        IS RETURNED TO THE CALLING PROGRAM.
*
RST01700 TM    GDSFLAGS,SEQ+SUB    IS SEQ/SUB BEGUN
         BZ    RST01900            NO
         CLC   GDSKEYSV,WRKKEY+2   IS ELEMENT WITHIN THIS SEQ/SUB
         BL    RST00500            YES EXIT
         BH    RST01900            NO
RST01750 NI    GDSFLAGS,NTSEQSUB   SET GDS NOT SEQ OR SUBR
         XC    CPU1(8),CPU1        ZERO UNRES ADDR
         XC    GDSKEYSV,GDSKEYSV   ZERO ANY KEY
         B     RST00500
         EJECT
*
*        WE NOW MUST FIND THE KEY TO THIS SEQUENCE OR SUBROUTINE,
*        AND REOPEN IT.  WE MUST SET UP AN UNRESOLVED ADDRESS
*        FOR THIS SEQ-SUBR AND GO INTO THE BUFFER  AND CHANGE
*        THE BRANCH ADDRESS OF THE INCLUDE/OMIT STRUCTURE TO
*        THE FLOW CONTROL RETURN ADDRESS SO THAT IF HE OMITS AN
*        UNFINISHED SEQ-SUBR HE WILL NOT BRANCH INTO BUFFER THAT
*        MAY NO LONGER BELONG TO HIM OR THAT CONTAINS OVERFLOW DATA
*
RST01900 TM    WRKKEY+7,SEQM+SUBM  IS THIS A SEQ/SUB MEMBER
         BZ    RST01750            NO RESET SW AND EXIT
         LA    REG15,RST02750      SET TO FALL THROUGH
RST01920 LH    REGA,WRKKEY+2       LOGICAL START ADDR OF KEY
         L     REGB,GDSKEYTB       KEY TABLE ADDR
RST01950 LA    REGC,12(REGB)       ADDR OF FIRST KEY
         L     REGD,4(REGB)        ADDR OF NEXT FREE LOCATION
RST02000 TM    4(REGC),X'20'       IS THIS KEY SEQ,SUBR,EOS, OR STROKE
         BO    RST02200            YES
RST02100 LA    REGC,12(REGC)       NEXT KEY
         CR    REGC,REGD           ALL KEYS IN THIS TABLE CHECKED
         BNE   RST02000            NO
         L     REGB,0(REGB)        ALL TABLES CHECKED
         LTR   REGB,REGB
         BZ    RST02300            YES
         B     RST01950            GO AGAIN
         EJECT
*
*        BECAUSE THE SEQUENCE/SUBROUTINE KEY IS THE LAST ONE IN
*        THE KEY TABLE, THE ADDRESS OF ANY KEY IS SAVED. THE
*        SECOND KEY REPLACES THE FIRST,ETC UNTIL THE ENTIRE
*        TABLE(S) IS SEARCHED. WHEN THIS IS DONE THE ADDRESS
*        I HAVE IS THE ADDRESS OF THE KEY I WANT.
*
RST02200 TM    4(REGC),X'10'       IS THIS SEQ OR SUBR
         BO    RST02100            NO
         ST    REGC,WRKSEQKY       SAVE
         B     RST02100
RST02300 L     REGA,WRKSEQKY       PICK UP KEY ADDR
         MVC   0(2,REGA),ZERO      ZERO LENGTH IN KEY
         MVC   GDSKEYSV,2(REGA)    SAVE LOG ADDR OF KEY IN GDSCB
         LH    REGC,2(REGA)        OBTAIN LOGICAL ADDR OF KEY
         CLC   GDSGDOAL,H128       SUB SEGMENT
         BE    RST02500            YES-WE ALREADY HAVE THE ADDR
         SRDA  REGC,32             SHIFT INTO ODD REGISTER
         LH    REGB,GDSGDOAL       GDOA LEN
         S     REGB,SIX            MINUS SIX
         DR    REGC,REGB           DIVIDE
         L     REGA,GTMBCTBL
         LH    REGB,GDSBCTEL       BCT DISP
         MH    REGB,F3+2
         SR    REG14,REG14
RST02400 IC    REG14,2(REGA,REGB)  PICK UP CNT FROM ENTRY
         CR    REG14,REGD          IS THIS THE SUBSEGMENT
         BE    RST02600            YES
         IC    REG14,1(REGA,REGB)  GET PTR TO NEXT
         MH    REG14,F3+2
         CR    REG14,REGB          WAS THIS THE LAST
         BE    ERR2                YES
         LR    REGB,REG14          KEEP LOOKING
         SR    REG14,REG14
         B     RST02400
RST02500 L     REGB,WRK128TP       ADDR OF 128 SUBSEGMENT
         B     RST02700
         EJECT
*
*        THE PHYSICAL BUFFER ADDRESS OF THE SEQUENCE MUST BE
*        COMPUTED SO THAT THE FLOW CONTROL ADDRESS CAN REPLACE
*        THE PREVIOUS RESOLVING ADDRESS THAT BRANCHES TO THE
*        END OF THE SEQUENCE.
*
RST02600 M     REGA,F256
         D     REGA,F3             COMPUTE PHYSICAL BEFFER ADDRESS
RST02700 AR    REGB,REGC           DISPL INTO PHYS ADDR
         LA    REGB,2(REGB)        PLUS 2 FOR SET MODE
         L     REGA,WRKSEQKY       LOAD SEQ-SUB KEY
         BR    REG15
         EJECT
RST02750 NI    GDSFLAGS,NTSEQSUB   TURN OFF BOTH SWITCHES
         CLC   8(4,REGA),ZERO      CORRELATED
         BNE   RST02770            NO
         OI    GDSFLAGS,CRVLPRES   SET SW
RST02770 TM    4(REGA),X'08'       IS THIS A SEQUENCE
         BO    RST02800            NO
         OI    GDSFLAGS,SEQ        SET SEQ SW
         B     RST02900
RST02800 OI    GDSFLAGS,SUB        SET SUBR SW
RST02900 LA    REGB,2(REGB)        UPDATE TO ADDR LOCATION
         ST    REGB,WRKBUFR
         L     PARM,GTMDECB1       DECB
         WAIT  ECB=(1)             WAIT
         L     PARM,GTMDECB1
         CLI   0(PARM),X'7F'
         BNE   ERR3
         NI    0(PARM),X'BF'
         L     REGA,GTMGRDCB       DCB
*                                  WRITE OUT F/C ADDR
         GWRITE (PARM),STR,(REGA),2,GDSOVDAT+2,WRKBUFR+2,GDSFCBUF,MF=E
         ST    REGB,BUF1           SAVE LOC OF UNRES ADDR
         XC    CPU1,CPU1
         B     RST00500
RST03000 CLC   WRKBUFR+2(2),GDSREPPB IS ADDR GR THAN OURS
         BH    RST03300            NO
         L     REGC,WRKBUFR
         A     REGC,LENLEFT        COMPUTE ADDR OF
         LA    REGC,4(REGC)        END    OF SEGMENT
         EJECT
*
*        A CHECK IS MADE TO SEE IF THE REPLACEMENT DATA IS TO BE
*        RESET ALSO.  IF NOT IT IS LEFT AS IS.  IF YES, THE FIELDS
*        ARE SET TO ZERO AND THE FLAG TO SAVE THE NEXT FOUR BYTES
*        AS REPLACEMENT DATA ARE SET IN THE OACB FOR THE NEXT
*        OVERFLOW.
         CH    REGC,GDSREPPB       IS ADDR LESS THEN END
         BH    RST01500            YES IT IS WITHIN AREA RESET
         B     RST01600            NO DO NOT RESET
RST03200 NI    GDSFLAGS,NTSEQSUB   ZERO SEQ SUB SW
         XC    CPU1(8),CPU1        ZERO UNRES ADDR
         XC    GDSKEYSV,GDSKEYSV    SET SEQ KEY TO ZERO
         B     RST00440
RST03300 LH    REGC,GDSREPPB       ADDR FOR REPL DATA
         A     REGC,F2
         C     REGC,WRKBUFR        RESET HALF OF REP DATA
         BNE   RST01600            NO-DO NOT ZERO REP DATA
*        HALF THE REPLACEMENT DATA IS TO BE RESET. IT WILL BE RETURNED
*        TO THE GDOA AND THE PTRS WILL BE SET UP. THEN THE REPLACEMENT
*        DATA FIELDS IN THE GDSCB WILL BE ZEROED.
         L     REGC,BUFSTART
         S     REGC,F2
         ST    REGC,BUFSTART       BACK UP BUFFER START
         ST    REGC,BLP            AND BLP
         L     REGC,BUFLEN
         A     REGC,F2
         ST    REGC,BUFLEN         ADD TWO TO LENGTH
         L     REGC,OLP
         MVC   0(2,REGC),GDSREPDT  MOVE FIRST TWO BYTES IN GDOA
         A     REGC,F2
         ST    REGC,OLP            UPDATE OLP
         B     RST01500            RESET REP DATA
         EJECT
ERR1     LA    REGA,ONE            FIRST PARM IN ERROR
ERR1A    ST    REGA,PARER(ERRCD)
         OI    0(ERRCD),PRMER
         B     RST00550            RETURN
ERR2     LA    REGA,TWO            CODE-BAD CORVAL
         L     REGB,WRKKEY         IS THERE A KEY
         LTR   REGB,REGB
         BZ    ERR1A               NO
         LA    REGA,ONE(REGA)      YES CODE FOR BAD KEY
         B     ERR1A
ERR3     OI    0(ERRCD),IO
         B     RST00550
         EJECT
*
*REGISTERS
*
REG0     EQU   0
PARM     EQU   1
REGA     EQU   2
REGB     EQU   3
OACB     EQU   4
WORK     EQU   5                   RST35800
ERRCD    EQU   6
GTMREG   EQU   7                   RST36000
GDSREG   EQU   8
BASE     EQU   9
REGC     EQU   10
REGD     EQU   11
SAVE     EQU   13
REG14    EQU   14
REG15    EQU   15
         EJECT
GDS      EQU   0
CORVL    EQU   4
KEY      EQU   8
LAST     EQU   X'80'
NULL     EQU   20
LEVEL2   EQU   X'10'
NO       EQU   X'80'
SEQ      EQU   X'04'
SUB      EQU   X'02'
STAT     EQU   24
BMGT     EQU   816
SAVEFOUR EQU   X'40'
SEQM     EQU   X'40'
SUBM     EQU   X'80'
NTSEQSUB EQU   X'B9'
CRVLPRES EQU   X'40'
EQUIV    EQU   X'80'
ONE      EQU   1
PARER    EQU   16
PRMER    EQU   X'08'
TWO      EQU   2
IO       EQU   X'04'
ETE      EQU   828                                                 000A
FE       EQU   48                                                  000A
         EJECT
RESETCDE DC    F'3'
KEYSRCH  DC    F'2'
CORVSRCH DC    F'5'
H128     DC    H'128'
F256     DC    F'256'
F3       DC    F'3'
SIX      DC    F'6'
ZERO     DC    F'0'
FOUR     DC    F'4'
F2       DC    F'2'
         EJECT
WORKAREA DSECT
WRKPARM  DS    F
WRKRTNCD DS    F
WRKSAVE  DS    18F
WRKSPVSR DS    3F
WRKCORVL DS    F
WRKKEY   DS    3F
WRKPRLST DS    4F
WRKBUFR  DS    F
WRKDSP   DS    F
WRKSEQKY DS    F
WRK128TP DS    F
WRKPRM   DS    F
WRKERR   DS    F
         EJECT
OACBARA  DSECT
OTHER    DS    F
GDOA     DS    F
STATUS   DS    F
CRSA     DS    F
OLP      DS    F
BLP      DS    F
BUFSTART DS    F
BUFLEN   DS    F
CPU1     DS    F
BUF1     DS    F
CPU2     DS    F
BUF2     DS    F
LOGSTRT  DS    F
LOGCURR  DS    F
LENLEFT  DS    F
         COPY  GDSCB
         COPY  GTMCB
         END
