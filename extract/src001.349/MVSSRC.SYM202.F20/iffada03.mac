         TITLE 'IFFADA03 - ICURS - INSERT CURSOR'
*STATUS: CHANGE LEVEL 000
*
*FUNCTION/OPERATION:  THE PARAMETERS PASSED ARE CHECKED FOR VALIDITY.
*        IF LEVEL 1 CORRELATION IS USED, KEY TABLE MANAGEMENT IS
*        CALLED TO LOCATE THE FULL KEY. IF LEVEL 2 CORRELATION IS
*        USED, THE FIRST CHARACTER IS ASSUMED TO BE LOCATED AT THE
*        LOGICAL ADDRESS PASSED IN THE KEY. IF LEVEL 1 CORRELATION IS
*        USED, THE KEY IS CHECKED TO INSURE THE ELEMENT IS A TEXT
*        ELEMENT. IF IT IS, THE LOGICAL ADDRESS OF THE FIRST CHARACTER
*        IS COMPUTED. THE LOGICAL ADDRESS OF THE FIRST CHARACTER IS
*        THEN MODIFIED BY THE COUNT PARAMETER IF IT IS PRESENT IN BOTH
*        LEVEL 1 AND 2 CORRELATION.
*
*        THE PHYSICAL ADDRESS WHERE THE CURSOR IS TO BE PLACED IS THEN
*        COMPUTED FROM THE LOGICAL ADDRESS BY REFERENCING THE BUFFER
*        CONTROL TABLE.  IF A CURSOR IS IN THE TERMINAL, RCURS IS
*        CALLED TO REMOVE IT. THE OACB IS CHECKED TO SEE IF THE DATA
*        FOR THE CURSOR LOCATION IS STILL IN MAIN CORE. IF SO, THE
*        PHYSICAL ADDRESS OF THE CURSOR IS STORED AT GTMCRLOC. IF THE
*        DATA IS IN THE BUFFER, THE CURSOR IS INSERTED IN THE BUFFER
*        BY A GCNTRL.
*
*ENTRY POINTS: IFFADA03
*
*INPUT: REGISTER 1 POINTS TO A WORKAREA. THE FIRST WORD CONTAINS THE
*        ADDRESS OF THE PARAMETER LIST, THE SECOND, THAT OF THE RETURN
*        CODE ARRAY.
*
*        THE PARAMETER LIST IS
*    + 0 A(POINTER TO THE GDSCB)
*
*        AT LEAST ONE OF THE FOLLOWING TWO PARAMETERS MUST BE VALID IF
*        LEVEL 1 CORRELATION IS USED. IF LEVEL 2 CORRELATION IS USED,
*        A VALID KEY MUST BE PRESENT.
*    + 4 A(CORRVAL)
*
*    + 8 A(KEY)
*
*        THE LAST PARAMETER IS OPTIONAL. A COUNT OF 1 IS ASSUMED IF IT
*        IS NOT PRESENT
*    +12 A(CHARACTER COUNT)
*
*OUTPUT: NONE TO THE USER. THE GTMCB AND GDSCB CURSOR FIELDS ARE SET
*        APPROPRIATELY. IF THE ELEMENT IS IN THE BUFFER, THE CURSOR IS
*        INSERTED.
*
*EXTERNAL ROUTINES: RCURS, KEY TABLE MANAGEMENT, GCNTRL
*
*EXITS-NORMAL AND ERROR: VIA RETURN MACRO TO DIRECTOR
*
*TABLES/WORKAREAS: GSP WORKAREA, BUFFER CONTROL TABLE, OACB
*
*ATTRIBUTES: PROBLEM STATE, REENTRANT
*
IFFADA03 CSECT
*2025,220000,232000,246000-252000                                  000A
*2025                                                              9375
R0       EQU   0
R1       EQU   1                       SYSTEM USE
R2       EQU   2                       WORK
R3       EQU   3                       WORK
R4       EQU   4                       WORK
R5       EQU   5
R6       EQU   6
R7       EQU   7
PARBSE7  EQU   7                       PARAM LIST BASE
BASE8    EQU   8                       GSPCB BASE
BASE9    EQU   9                       INSCUR CSECT BASE
BASE10   EQU   10                      WORK AREA BASE
BASE11   EQU   11                      GDSCB BASE
BASE12   EQU   6                       GTMCB BASE
R13      EQU   13                      SYSTEM USE
R14      EQU   14                      SYSTEM USE
R15      EQU   15                      SYSTEM USE
D0       EQU   0
D1       EQU   1
D2       EQU   2
D4       EQU   4
D5       EQU   5
D6       EQU   6
D8       EQU   8
D16      EQU   16
D12      EQU   12
D24      EQU   24
D48      EQU   48
D52      EQU   52
D204     EQU   204
D828     EQU   828
EIGHT    EQU   8
HEX00    EQU   X'00'
HEX01    EQU   X'01'
HEX02    EQU   X'02'
HEX03    EQU   X'03'
HEX04    EQU   X'04'
HEX08    EQU   X'08'
HEX10    EQU   X'10'
HEX15    EQU   X'15'
HEX20    EQU   X'20'
HEX30    EQU   X'30'
HEX40    EQU   X'40'
HEX2A    EQU   X'2A'
HEX7F    EQU   X'7F'
HEXBF    EQU   X'BF'
HEXC0    EQU   X'C0'
HEXEB    EQU   X'EB'
HEXEC    EQU   X'EC'
HEXFF    EQU   X'FF'
L8       EQU   8
LASTPARM EQU   X'80'
LVL2     EQU   X'10'
TSTCUR   EQU   X'01'
TWO      EQU   2
         TITLE 'ICURS-IFFADA03-INSERT CURSOR'
INSCUR   SAVE  (14,12)
         BALR  BASE9,0                 INITIALIZE R9 AS CSECT BASE
         USING *,BASE9
         USING GSPCB,BASE8
         USING WKADSECT,BASE10
         USING GDSCB,BASE11
         USING GTMCB,BASE12
         USING PARLIST,PARBSE7
         LR    BASE10,R1               INITIALIZE R10 AS WORK AREA BASE
         L     PARBSE7,D0(R1)          INITIALIZE R7 AS PARAM LIST BASE
*                                      LOAD ADDR OF PARAM LIST
         L     R3,PARGDSNM             LOAD ADDR OF VARIABLE GDS
         L     BASE11,D0(R3)           INITIALIZE R11 AS GDSCB BASE
         L     BASE12,GDSGTMCB         INITIALIZE R12 AS GTMCB BASE
         L     BASE8,GTMGSPCB          INITIALIZE R8 AS GSPCB BASE
         XC    GSPARRAY(20),GSPARRAY   ZERO RETURN ARRAY
*   INITIALIZE SAVE FIELDS
         ST    R13,SAVE+4              CHAIN SAVE AREAS
         LA    R2,SAVE
         ST    R2,8(R13)
         LR    R13,R2                  ESTABLISH NEW SAVE AREA
*   IS THERE A VALID GDS
         CL    BASE11,GDSGDSCB         HAS THE GDS BEEN OPENED
         BNE   INVALID                 NO
         XC    CVSW(256),CVSW          ZERO WORK AREA
         XC    CVSW+256(256),CVSW+256  ZERO WORK AREA
         CLI   PARGDSNM,LASTPARM       IS GDSNAME LAST PARM
         BE    INVALID                 YES
TEMPSTRT EQU   *
*   TEST AND SAVE PARAMETERS BASED ON LEVEL 1 OR 2
         TM    GDSFLAGS,LVL2           IS GDS LEVEL 2
         BO    PARMCKL2                YES
*   I HAVE A LEVEL 1 GDS WHICH INDICATES THE PRESENCE OF A KEYTABLE
         L     R3,PARCVAL              LOAD SECOND PARM-CORRVAL
         CLC   PARCVAL+1(3),GSPNULLV+1     TEST FOR NULL
         BNE   SETCVSW                 NO-I HAVE GOOD CORRVAL
*   IF CORRVAL IS LAST PARM AND IT IS NULL AN INVALID CONDITION EXISTS
         CLI   PARCVAL,LASTPARM        IS CV LAST PARAMETER
         BE    NOCVKEY                 YES
*   NO CORRVAL PRESENT - TEST FOR KEY PRESENT
         CLC   PARKEY+1(3),GSPNULLV+1  IS KEY PARM = NULL
         BE    NOCVKEY                 YES-IT IS NULL KEY PRESENT
KEYSRCH  EQU   *
*   USE KEYTABLE ROUTINE TO GET ADDR OF KEY
         MVI   CVKEYSW,HEX10           SET SW EQUAL KEY SEARCH
         MVC   MYPARLST+8(4),PARKEY    PUT ADDR OF KEY INTO PARM LIST
         MVC   CODEADDR(4),CODE2
*   INVOKE KEYTABLE ROUTINE
KEYTBL   EQU   *
         L     R5,GSPASTAT             GET ADDR OF STATUS TABLE
         L     R15,D828(R5)            GET EP ADR OF KEYTABLE
         LTR   R15,R15                 IF ZERO,ROUTINE NOT IN
         BZ    INVALID             GO TO ERROR RTN                 000A
GOKT     LA    R3,CODEADDR
         ST    R3,MYPARLST+4
         ST    BASE11,MYPARLST         STORE ADDRESS OF GDS
         OI    MYPARLST+8,LASTPARM     INSERT LAST PARM BIT
         LA    R1,MYPARLST             PASS ADDR OF MY PARLIST
         BALR  R14,R15             BRANCH TO KEY TABLE MGMT        000A
         LTR   R15,R15                 ANY ERRORS
         BC    7,TEST
         CLI   CVKEYSW,HEX10           IS RETURN TO KEY
         BNE   TOCVAL                  NO, RETURN TO CORVAL
         B     TOKEY
*
*
**********
TOKEY    EQU   *
         LTR   R1,R1                   WAS ADDRESS FOUND
         BZ    PARMERR3                NO
         ST    R1,KEYCHAR              SAVE KEY ADDR
TSTCOUNT EQU   *
         CLI   PARKEY,LASTPARM         IS KEY LAST PARAMETER
         BE    NOCTPARM                YES
         L     R2,PARCOUNT             LOAD ADDR OF FOURTH PARAM-COUNT
         CLC   PARCOUNT+1(3),GSPNULLV+1   TEST FOR NULL
         BE    NOCTPARM                YES-THERE IS NO COUNT PARAM
         L     R3,D0(R2)               PICK UP COUNT FIELD
         STH   R3,COUNTSV              SAVE THE COUNT PARAM
TSTCVSW  EQU   *
*   TEST SWITCH TO SEE IF CORRVAL PRSEENT
         CLI   CVSW,HEX01              CORRVAL PRESENT
         BE    UPDATECV                YES-REPLACE OLD CORRVAL
COMMON   EQU   *
*   COUNTSV FIELD CONTAINS COUNT-IF ANY OR ZERO
*   KEYCHAR FIELD CONTAINS PTR TO KEYTABLE IF LVL 1 OR TO USER KEY
*   IF LVL 2
*   TEST OACB ADDRESSES TO SEE IF DATA IN MAIN STORAGE
         L     R2,KEYCHAR              GET ADDRESS OF KEY
         LH    R3,D2(R2)               GET LOG BUF ADDR FRM KEY
         L     R4,GDSAOACB             GET ADDR OF ACTIVE OACB
         L     R5,D48(R4)              GET LOG BUFF START ADDR FRM OACB
         CR    R5,R3                   BUF START OACB MORE THAN FRM KEY
         BH    COMPPHYS                YES-DATA HAS GONE TO BUFFER
         L     R2,D52(R4)              GET LOG ADDR NEXT AVAIL IN GDOA
         CR    R2,R3                   BUF END OACB MORE THAN FRM KEY
         BL    INVALID                 NO-NOT IN MAIN STORAGE OR BUFFER
*   DATA MUST BE IN MAIN STORAGE OF GDOA
*   SET FLAG TO INDICATE PHYS LOCATION IS STILL IN MAIN STORAGE
         MVI   MSTOSW,HEX01
COMPPHYS EQU   *
*   COMPUTE PHYS BUFF-ADDR INITIALIZE POINTER AND FLAGS
*   R3 MUST CONTAIN ADDRESS OF LOGICAL BUFFER UPON ENTRY
         ST    R2,TMPSV                SAVE R2
         STM   R4,R7,TMPSV+4           SAVE R4,R5,R6,R7
*   COMPUTE PHYSICAL ADDR FROM LOG ADDR FOR LVL1
         L     R2,KEYCHAR              GET ADDRESS OF KEY
         LH    R3,D2(R2)               GET LOG BUF ADDR FRM KEY
         TM    GDSFLAGS,LVL2           IS GDS LEVEL2
         BO    CTPARTST                YES
         TM    D4(R2),HEX08            DOES ELEMENT CONTAIN
         BZ    INDFPRER                CHARACTER OUTPUT
         TM    D4(R2),HEX30            NO, INVALID KEY, GDS
         BC    7,INDFPRER              OR CORRVAL
         LH    R4,D0(R2)               GET LOG BUF LNGTH FRM KEY
         SR    R5,R5
*   PICK YP COUNT OF CHAR FROM KEY WHICH IS NOT ON HALF WORD BOUNDARY
         IC    R5,D5(R2)               GET FIRST BYTE OF CHAR CT
         SLL   R5,L8                   SHIFT IT LEFT
         IC    R5,D6(R2)               PICK UP COUNT OF CHAR FRM KEY
         SR    R4,R5                   SUB CHAR CT FRM BUF LNGTH
         LA    R2,0(R3,R4)             ADD THE BUF LNGTH TO LOG ADDR
CTPARTST EQU   *
         LH    R1,COUNTSV              PICK UP COUNT PARAM
         LTR   R1,R1                   IS IT ZERO
         BC    7,ADDLGTH               NO
DVDGDOA  EQU   *
         LH    R7,GDSGDOAL             GET LENGTH OF GDOA
         S     R7,SIX
         SRDA  R2,32
         DR    R2,R7                   DVD GDOA-6 INTO MODIFIED LOG B A
         STH   R2,REMAINDR             SAVE THE REMAINDER
         LH    R4,GDSBCTEL             GET BUF CTL ELEMENT
STRTBCT  EQU   *
         MH    R4,THREE+2
         A     R4,GTMBCTBL             ADD START OF BCT(R4=POS IN BCT)
         SR    R2,R2
         IC    R2,D2(R4)               GET CT FIELD FROM BCT
         CR    R2,R3                   IS BCT CT FLD EQUAL QUOT OF DVDE
         BNE   NXTENTRY
         LR    R5,R4         SAVE BCT ENTRY ADR FOR HALF BFR CHECK 9375
         S     R4,GTMBCTBL             SUB START ADDR OF BCT
         LR    R2,R4                   PREPARE FOR DIVIDE
         SRDA  R2,32
         D     R2,THREE                DIVIDE BCT ELEMENT BY 3
         SLA   R3,EIGHT                MPY QUOT BY 256
         AH    R3,REMAINDR             ADD REMAINDER
         AH    R3,CONTWO               ADD TWO FOR SET MODE
         CLC   GDSBCTID,D0(R5)    IF NOT EQUAL ID IS IN BYTE 2,    9375
         BE    NOHALF               INDICATING 128 BYTE BFR SIZE   9375
         AH    R3,HALFBUF           LOCATED IN LAST HALF OF BFR    9375
NOHALF   EQU   *                                                   9375
*   R3 NOW CONTAINS PHYS ADDR
         L     R2,TMPSV                RESTORE R2
         LM    R4,R7,TMPSV+4           RESTORE R4,R5,R6,R7
*   IS THERE A CURSOR PRESENT IN THIS TERMINAL
         TM    GTMFLAGS,TSTCUR
         BO    RESET                   YES, REMOVE IT
*   R3 NOW CONTAINS THE PHYSICAL BUFF ADR FROM THE LOG VIA BCT
*   STORE PHYS ADDR OF LOCATION REQUIRING CURSOR IN GTMCB
RESETRTN EQU   *
         STH   R3,GTMCRLOC             PUT PHY BUF LOC NEEDING CUR GTM
         OI    GTMFLAGS,HEX01          SET GTM CURSOR IN FLAG
         OI    GDSFLAGS,HEX20          SET GDS CURSOR IN FLAG
*   TEST FLAG TO SEE IF DATA IS IN MAIN STORAGE
         CLI   MSTOSW,HEX01
         BE    ALLDONE
INSRTCUR EQU   *
**********
*** SET UP PARAMETERS AND ISSUE GCNTRL
**********
         STH   R3,INSADDR
         LA    R1,DUMYCTL1
         LA    R4,INSADDR
         L     R5,GTMGRDCB             GET ADDR OF TERM DCB
         XC    0(32,R1),0(R1)          ZERO DECB
         GCNTRL (R1),INS,(R5),(R4),MF=E   BUILD ECB AND INSERT CURSOR
         WAIT  ECB=DUMYCTL1
         CLI   DUMYCTL1,X'7F'          I/O SUCESSFUL
         BNE   IOERRTN                 NO
*   USE FLO CTL ADR FROM GDSCB FOR RESTART GENERATION
         L     R3,GTMGRDCB             GET ADR OF UNIT DCB
         L     R4,GTMFCTBL             GET POINTER TO BUFFER
         LA    R4,8(R4)                ADDRESS IN FCT
         XC    REGENCTL(32),REGENCTL    ZERO DECB
         GCNTRL REGENCTL,STR,(R3),(R4),MF=E  RESTART REGENERATION
         WAIT  ECB=REGENCTL
         CLI   REGENCTL,HEX7F          I/O SUCCESSFUR
         BNE   IOERRTN                 NO
         XC    GTMCRLOC(2),GTMCRLOC    ZERO CURSOR LOCATION AFTER
*                                      IT IS INSERTED
         B     ALLDONE                 RETURN CODE IS ZERO
IOERRTN  EQU   *
         MVI   GSPARRAY,HEX04          I/O ERROR
         MVI   GSPARRAY+19,HEX00       NO ADD INFO CODE
         B     ALLDONE
ADDLGTH  EQU   *
         AR    R2,R1                   ADD COUNT TO LOG ADDR
         S     R2,ONE
         L     R1,GDSAOACB             GET ADDRESS OF OACB
         C     R2,D52(R1)              ADDRESS LESS THAN OLP
         BNL   INDFPRER                NO, INVALID PARAMETER(S)
         C     R2,D48(R1)              IN BUFFER
         BL    DVDGDOA                 YES, GET PHYSICAL ADDRESS
         MVI   MSTOSW,HEX01            NO, SET IN CORE FLAG
         B     DVDGDOA
NXTENTRY EQU   *
*   IF OLD BCTL IS THE SAME AS THE PTR FIELD IN BCT AND CT FIELD IN
*   BCT DOES NOT EQUAL QUOT THEN THE PHYS ADDR IS NOT IN USERS BUFFER
         SR    R5,R5
         IC    R5,D1(R4)               GET PTR FLD FRM BCT
         CR    R2,R5                   CPR TO OLD BCTEL
         BE    ERR
         LR    R4,R5                   PUT NEW PTR INTO OLD BCTEL
         B     STRTBCT
NOCTPARM EQU   *
*   RESET COUNT PARAM SAVE AREA TO ZERO
         XC    COUNTSV(2),COUNTSV      ZERO COUNTSV FIELD
         B     TSTCVSW
UPDATECV EQU   *
*   REPLACE CORVAL IN KEY TABLE WITH CORRVAL FROM PARAM LIST
         L     R2,KEYCHAR
         L     R1,PARCVAL              GET ADDR OF CORVAL
         MVC   D8(D4,R2),D0(R1)        MOVE CV TO KEY
         B     COMMON
RESET    EQU   *
*   CONSTRUCT PARAM LIST AND INVOKE REMOVE CURSOR  TO CLEAN
*   TERMINAL BEFORE INSERTING NEW CURSOR
*   INVOKE RESET CURSOR ROUTINE
         MVC   MYPARLST(4),PARGDSNM    GDSNAME FOR RCURS
         OI    MYPARLST,LASTPARM       INSERT LAST PARAM BIT
         LA    R2,MYPARLST             POINTERS TO GDSNAME
         ST    R2,MYPARLST+4
         MVC   MYPARLST+8(4),WKADSECT+4 AND GSPARRAY
         LA    R1,MYPARLST+4
         XC    SUPVWORK(16),SUPVWORK   CLEAR SUPERVISOR AREA
         LA    R15,SUPVWORK            GET POINTER TO IT
         LINK  EP=IFFADA02,MF=(E,(1)),SF=(E,(15))
         CLI   GSPARRAY,HEX00          ANY ERRORS
         BNE   INVALID                 YES
         B     RESETRTN                NO, CONTINUE PROCESSING
PARMCKL2 EQU   *
*   IF LAST PARM BIT IS ON IN CV AN ERROR CONDITION EXISTS
         CLI   PARCVAL,LASTPARM        IS CV LAST PARAM
         BE    NOCVKEY
*   I HAVE A LEVEL TWO GDS NO KEYTABLE PRESENT
*   GET LOG BUF ADDR FROM USER SUPPLIED LOCATION
         CLC   PARKEY+1(3),GSPNULLV+1  IS KEY PARM = NULL
         BE    INDFPRER                YES, INVALID CALL
         MVC   KEYCHAR(4),PARKEY       SAVE ADDRESS OF USER KEY WORD
         B     TSTCOUNT
SETCVSW1 EQU   *
*   VALID CORRVAL-SEARCH USING R3 FOR CVAL ADDR
*   USE KEYTABLE RTN TO GET ADDR OF KEY ASSOCIATED WITH CV ADDR
         MVI   CVKEYSW,HEX00           SET SWITCH EQUAL TO CV SEARCH
SETCVSW2 EQU   *
         MVC   MYPARLST+8(4),PARCVAL   PUT ADDR OF CORL IN PARM LIST
         MVC   CODEADDR(4),CODE5
         B     KEYTBL
**********
TOCVAL   EQU   *
         LTR   R1,R1                   WAS ADDR FOUND
         BZ    NOCVKEY                 NO
         ST    R1,KEYCHAR              PUT INTO KEY SAVE
         CLI   CVKEYSW,HEX00           CORVAL LAST PARAMETER
         BE    TSTCOUNT                NO, TEST COUNT
         B     NOCTPARM                YES, SET COUNT=0
TEST     EQU   *
         CLI   CVKEYSW,HEX10
         BE    PARMERR3
         B     NOCVKEY
SETCVSW  EQU   *
*   IS CORRVAL LAST PARM
         CLI   PARCVAL,LASTPARM        LAST PARM BIT ON
         BE    NOPARM                  YES
*   I HAVE A LVL 1 CORRVAL-TEST FOR KEY PARM
         L     2,PARKEY                GET THE ADDRESS OF THE KEY
         CLC   PARKEY+1(3),GSPNULLV+1  IS KEY PARM = NULL
         BE    SETCVSW1                YES-IT IS NULL KEY PRESENT
         L     R3,D0(R2)               PICK UP KEY
NOPARTN  EQU   *
         MVI   CVSW,HEX01              PARM CV GOES TO KEY CV
         B     KEYSRCH
NOPARM   EQU   *
         MVI   CVKEYSW,HEX20           CORVAL SEARCH, NO KEY OR COUNT
         B     SETCVSW2
INDFPRER MVI   GSPARRAY,HEX08          INDEFINITE PARAMETER ERROR
         B     ALLDONE
INVALID  EQU   *
         MVI   GSPARRAY,HEX08          PARM ERROR
         MVI   GSPARRAY+19,HEX01       GDSNAME INVALID
         B     ALLDONE
NOCVKEY  EQU   *
         MVI   GSPARRAY,HEX08          PARM ERROR
         MVI   GSPARRAY+19,HEX02       CORRVAL PARM INVALID
         B     ALLDONE
PARMERR3 EQU   *
         MVI   GSPARRAY,HEX08          PARM ERROR
         MVI   GSPARRAY+19,HEX03       KEY   PARAM INVALID
         B     ALLDONE
ERR      EQU   *
*   NO SUCH ADDR
         MVI   GSPARRAY,HEX08          PARM ERROR
         MVI   GSPARRAY+19,HEX04       COUNT PARAM INVALID
ALLDONE  EQU   *
         L     R13,SAVE+4              RESTORE REG 13
         RETURN (14,12),T
MDFYCT   EQU   *
         DS    0F
GRDCBTMP EQU   *
TMPCURTO EQU   *
CONTWO   DC    H'2'
HALFBUF  DC    H'128'                  ADJUST TO LAST HALF OF BFR  9375
ZERO     DC    F'0'
ONE      DC    F'1'
CODE2    DC    F'2'
CODE5    DC    F'5'
THREE    DC    F'3'
SIX      DC    F'6'
ORDRTAB  DC    X'40414445505152FF'     TABLE OF POSSIBLE SET CHARACTER
*                                      MODE ORDER CODES
         EJECT
*   THIS DSECT PROVIDES SYMBOLIC REFERENCES TO
*   FIELDS OF THE WORK AREA OF USER CORE
WKADSECT DSECT
         DS    F                       CONTAINS POINTER TO PARM LIST
         DS    F                       POINTS TO RETURN ARRAY
SAVE     DS    18F                     INSCUR SAVE AREA
CVSW     DS    X                       IS CORRVAL PRESENT
SWONE    DS    X                       SET ON FIRST TEST FOR SM
MSTOSW   DS    X                       PHYS LOC IN MAIN STORAGE
CVKEYSW  DS    X
COUNTSV  DS    H                       CONTAINS COUNT PARM VALUE
REMAINDR DS    H                       PHYS BUF REM SAVE AREA
PRODUCT  DS    H                       PHYS BUF STRT ADDR ?
INSADDR  DS    H                       PTR TO CURSOR ISERT LOCATION
REGENCTL DS    19F                     GCNTL EXPANSION
KEYCHAR  DS    F                       CONTAINS ADDR OF KEY
TMPSV    DS    6F                      SAVE FOR COM PHY BUF RTN
DUMYCTL1 DS    19F                     DECB SAVE AREA FOR GCNTRL
SUPVWORK DS    4F
CODEADDR DS    F
MYPARLST DS    3F                      PAR LIST FOR MY CALLS
         EJECT
*   THIS DSECT PROVIDES SYMBOLIC REFERENCES TO
*   FIELDS IN THE PARAMETER LIST
PARLIST  DSECT
PARGDSNM DS    F                       GDSNAME
PARCVAL  DS    F                       CORRVAL(VALID ONLY IN LVL 1)
PARKEY   DS    F                       KEY
PARCOUNT DS    F                       CHAR COUNT (L1 COUNT VALUE IS
*                                      CHAR ONLY - L2 COUNT VALUE
*                                      INCLUDES CHAR AND ORDERS)
         COPY  GSPCB
         COPY  GTMCB
         COPY  GDSCB
         END
