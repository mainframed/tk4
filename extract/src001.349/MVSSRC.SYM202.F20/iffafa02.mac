         TITLE 'PSGMT --IFFAFA02'
***********************************************************************
*
*TITLE         PSGMT                                                  *
*                                                                     *
*MODULE NAME   IFFAFA02                                               *
*                                                                     *
*STATUS        CHANGE LEVEL 000                                       *
*                                                                     *
*FUNCTION/OPERATION                                                   *
*  TO PRODUCE LINE SEGMENTS ON THE GRAPHIC OUTPUT MEDIUM AT THE       *
*  POSITIONS SPECIFIED BY THE ARGUMENTS, AND TO UPDATE GRAPHIC        *
*  DATA PREVIOUSLY PRODUCED BY PSGMT. EACH LINE SEGMENT IS IS         *
*  DETERMINED BY TWO SUPPLIED ARGUMENT POINTS.                        *
*  EACH LINE SEGMENT TO BE DISPLAYED DEMANDS TWO CALLS TO THE DATA    *
*  GENERATION ROUTINE, THE FIRST TO MOVE THE BEAM TO THE SEGMENT      *
*  START POINT (BLANKED MODE), THE SECOND TO DISPLAY THE LINE         *
*  SEGMENT(UNBLANKED MODE).                                           *
*                                                                     *
*ENTRY POINT   IFFAFA02- CSECT NAME                                   *
*                                                                     *
*INPUT   REGISTER 1 CONTAINS THE ADDRESS OF A WORK/SAVE AREA. THE     *
*  FIRST WORD CONTAINS THE ADDRESS OF A VARIABLE LENGTH PARAMETER     *
*  LIST ON A FULL WORD BOUNDARY, THE SECOND WORD CONTAINS THE         *
*  ADDRESS OF THE RETURN ARRAY. THE NULL VARIABLE IS AT AN OFFSET     *
*  OF 20 FROM THE RETURN ARRAY, AND THE ADDRESS OF THE STATUS TABLE   *
*  IS AT AN OFFSET OF 24 FROM THE RETURN ARRAY.                       *
*FORMAT OF PARAMETER LIST                                             *
* REQUIRED PARAMETERS                                                 *
*                                                                     *
*  +0   A(VAR)      ADDRESS OF A VARIABLE WHICH CONTAINS THE GDSCB    *
*                   ADDRESS.                                          *
*  +4   A(UVAL1)    ADDRESS OF THE U VALUE PARAMETER FOR THE SEGMENT  *
*                   START.                                            *
*  +8   A(VVAL1)    ADDRESS OF THE V VALUE PARAMETER FOR THE SEGMENT  *
*                   START.                                            *
* +12   A(UVAL2)    ADDRESS OF THE U VALUE PARAMETER FOR THE SEGMENT  *
*                   END.                                              *
* +16   A(VVAL2)    ADDRESS OF THE V VALUE PARAMETER FOR THE SEGMENT  *
*                   END.                                              *
*                                                                     *
*  OPTIONAL PARAMETERS                                                *
*                                                                     *
* +20   A(CORRVAL)  ADDRESS OF A FULL WORD CONTAINING A CORRELATION   *
*                   VALUE.                                            *
* +24   A(KEY)      ADDRESS OF KEY VARIABLE
* +28   A(GENCODE)  ADDRESS OF THE CODE WHICH SPECIFIES THE TYPE OF
*                   OUTPUT - EITHER BLANKED, UNBLANKED, OR UPDATE     *
* +32   A(COUNT)    ADDRESS OF A VARIABLE WHICH CONTAINS THE COUNT    *
*                   OF THE NUMBER OF DATA ELEMENTS TO BE GENERATED.   *
* +36   A(U-INDEX1) ADDRESS OF THE INDEX TO BE USED IN OBTAINING THE  *
*                   NEXT U ELEMENT FOR THE START OF THE SEGMENT, WHEN *
*                   MORE THAN ONE DATA ELEMENT IS BEING GENERATED.    *
* +40   A(V-INDEX1) ADDRESS OF THE INDEX TO BE USED IN OBTAINING THE  *
*                   NEXT V ELEMENT FOR THE START OF THE SEGMENT, WHEN *
*                   MORE THAN ONE DATA ELEMENT IS BEING GENERATED.    *
* +44   A(U-INDEX2) ADDRESS OF THE INDEX TO BE USED IN OBTAINING THE  *
*                   NEXT U ELEMENT FOR THE END OF THE SEGMENT WHEN    *
*                   MORE THAN ONE DATA ELEMENT IS BEING GENERATED.    *
* +48   A(V-INDEX2) ADDRESS OF THE INDEX TO BE USED IN OBTAINING THE  *
*                   NEXT V.ELEMENT FOR THE END OF THE SEGMENT WHEN    *
*                   MORE THAN ONE DATA ELEMENT IS BEING GENERATED.    *
* +52   A(U-INCR1)  ADDRESS OF A VALUE TO BE ADDED TO THE UVAL1 TO    *
*                   OBTAIN THE NEXT UVAL1 FOR THE START OF THE LINE   *
*                   SEGMENT WHEN MORE THAN ONE DATA ELEMENT IS BEING  *
*                   GENERATED.                                        *
* +56   A(V-INCR1)  ADDRESS OF A VALUE TO BE ADDED TO THE VVAL1 TO    *
*                   OBTAIN THE NEXT VVAL1 FOR THE START OF THE LINE   *
*                   SEGMENT WHEN MORE THAN ONE DATA ELEMENT IS BEING  *
*                   GENERATED                                         *
* +60   A(U-INCR2)  ADDRESS OF A VALUE TO BE ADDED TO UVAL2 TO OBTAIN *
*                   THE NEXT UVAL2 FOR THE END OF THE LINE SEGMENT    *
*                   WHEN MORE THAN ONE DATA ELEMENT IS BEING GENER-   *
*                   ATED.                                             *
* +64   A(V-INCR2)  ADDRESS OF A VALUE TO BE ADDED TO VVAL2 TO OBTAIN *
*                   THE NEXT VVAL2 FOR THE END OF THE LINE SEGMENT    *
*                   WHEN MORE THAN ONE DATA ELEMENT IS BEING GENER-   *
*                   ATED.                                             *
*                                                                     *
*OUTPUT                                                               *
*  THE DATA WILL BE SCISSORED AND SCALED AND IF IT APPEARS ON THE     *
*  SCREEN AND/OR GRID, ORDERS WILL BE GENERATED FOR IT IN THE GDOA.   *
*                                                                     *
*EXTERNAL ROUTINES                                                    *
*  IFFAFA12 - RESET                                                   *
*  IFFAHA03 - KEY TABLE MANAGEMENT                                    *
*  IFFAHA04 - DATA GENERATION                                         *
*  IFFAHA06 - SCALE                                                   *
*  IFFAHA07 - SCISSOR                                                 *
*  IFFAHA13 - GET GDOA'S FOR UPDATE                                   *
*  IFFAHA14 - WRITE OUT UPDATE                                        *
*                                                                     *
*EXITS - NORMAL- BACK TO CALLER VIA REGISTER 14                       *
*      - ERROR - BACK TO CALLER VIA REGISTER 14                       *
*  APPROPRIATE CODES ARE SET IN THE RETURN ARRAY -VALUES = 0,1,2,3,4  *
*                                                                     *
*                                                                     *
*                                                                     *
*TABLES/WORKAREAS -  SEE WORKAREA DSECT                               *
*                                                                     *
*ATTRIBUTES       -  REENTRANT, PROBLEM PROGRAM MODE                  *
*                                                                     *
***********************************************************************
         EJECT
IFFAFA02 CSECT                          PSEGMT
*2024,695700-698400                                                000A
*D601500-601800                                                  YM1963
*A179300-179500,C570600,C572400-575100,C685800-688500       D11 ZA15418
         SPACE
* REGISTERS
REGZERO  EQU   0
PARM     EQU   1
LOOPCT   EQU   1
REGA     EQU   2
ERRCD    EQU   3
REGB     EQU   4
WORK     EQU   5
REGD     EQU   6
GTMREG   EQU   7
GDSREG   EQU   8
BASE     EQU   9
REGC     EQU   10
COUNT    EQU   11
REGE     EQU   11
SAVE     EQU   13
RETURN   EQU   14
REGFIFTN EQU   15
FLT2     EQU   2                        FLOATING POINT REG
         SPACE 2
*        PARAMETER LIST EQUATES
*                        REQUIRED PARAMETERS
GDS      EQU   0                        ADR OF VARIABLE HOLDING GDS ADR
X        EQU   4                        ADR OF X VALUE FOR SEGMT START
Y        EQU   8                        ADR OF Y VALUE FOR SEGMT START
X2       EQU   12                       ADR OF X VALUE FOR SEGMT END
Y2       EQU   16                       ADR OF Y VALUE FOR SEGMT END
*                        OPTIONAL PARAMETERS
FE       EQU   48                                                  000A
ETE      EQU   828                                                 000A
COR      EQU   20                       ADR OF CORRELATION VALUE
KEY      EQU   24                       ADR OF KEY LOCATION
GEN      EQU   28                       ADR OF CODE
CT       EQU   32                       ADR OF COUNT
XINDEX   EQU   36                       ADR OF X START INDEX
YINDEX   EQU   40                       ADR OF Y START INDEX
XINDEX2  EQU   44                       ADR OF X END INDEX
YINDEX2  EQU   48                       ADR OF Y END INDEX
XINCR    EQU   52                       ADR OF X START INCREMENT
YINCR    EQU   56                       ADR OF Y START INCREMENT
XINCR2   EQU   60                       ADR OF X END INCREMENT
YINCR2   EQU   64                       ADR OF Y END INCREMENT
         EJECT
ON       EQU   X'FF'
REPONLY  EQU   X'02'
UPDATE   EQU   X'FF'
INCLUDE  EQU   X'04'
SWOFF    EQU    X'3F'
OMIT     EQU   X'FB'
XINDX    EQU   X'C0'
YINDX    EQU   X'0C'
XINC     EQU   X'30'
YINC     EQU   X'03'
NOX      EQU   X'0F'
NOY      EQU   X'F0'
PRM      EQU   X'08'
STRG     EQU   X'10'
SCISSOR  EQU   X'40'
NOSCISS  EQU   X'10'
LEVEL2   EQU   X'10'
OPT      EQU   X'04'
INC      EQU   X'01'
INCSW    EQU   X'02'
ABS      EQU   X'02'
ABSSW    EQU   X'03'
SUBR     EQU   X'02'
MEMSUB   EQU   X'80'
SEQ      EQU   X'04'
MEMSEQ   EQU   X'40'
NFNL     EQU   X'40'
MULT     EQU   X'80'
BEAMSW   EQU   X'08'
CORRE    EQU   X'10'
KEYED    EQU   X'20'
REALY    EQU   X'0C'
REALX    EQU   X'C0'
ABSOLXY  EQU   X'AA'
XABS     EQU   X'A0'                    SWITCH SETTING IN GDSCB
YABS     EQU   X'0A'
XREALI   EQU   X'40'
YREALI   EQU   X'04'
XINTGI   EQU   X'10'
YINTGI   EQU   X'01'
LAST     EQU   X'80'
LASTIN   EQU   X'C0'
LASTON   EQU   X'1F'
XFOUR    EQU   X'FC'
STOR     EQU   12
PARMERR  EQU   16
NULL     EQU   20
NL       EQU   21
CURRLOG  EQU   52
STAT     EQU   24
DGEN     EQU   840
SCISS    EQU   876
SCALE    EQU   864
UPDH13   EQU   936         STATAB DISPL OF IFFAHA13 ENTRY   D11 ZA15418
UPDH14   EQU   948         STATAB DISPL OF IFFAHA14 ENTRY   D11 ZA15418
CVTLINK  EQU   8
         EJECT
*        THIS CODE ESTABLIHES ADDRESSABILITY FOR IFFAFA02, FOR THE
*        GDSCB AND FOR THE WORKAREA. THE RETURN ARRAY IS SET TO ZERO,
*        AND THE SAVE AREAS ARE CHAINED.
         SPACE
         USING *,15
         SAVE  (14,12)
         DROP  15
         LR    BASE,15                  LOAD CONTROL SECTION BASE
         USING IFFAFA02,BASE
         LR    WORK,PARM                LOAD WORK AREA BASE
         USING WORKAREA,WORK
         XC    WKSWITCH(8),WKSWITCH     ZERO SWITCH AREAS
         L     PARM,WKPARM              LOAD PARAMETER LIST ADDRESS
         L     ERRCD,WKRTNCD
         XC    0(20,ERRCD),0(ERRCD)     ZERO RETURN ARRAY
         L     GDSREG,GDS(PARM)         PICK UP ADDRESS OF GDS ADDRESS
         L     GDSREG,0(GDSREG)         ADDRESS OF GDSCB
         USING GDSCB,GDSREG
         L     COUNT,TWO                SET COUNT DEFAULT TO TWO
         LA    REGA,WKSAVE              CHAIN SAVE AREAS
         ST    REGA,8(SAVE)
         ST    SAVE,4(REGA)
         LR    SAVE,REGA                REG 13 CONTAINS ADR OF THIS
*                                          SAVE AREA
*
*        THE GDSCB PASSED IS CHECKED FOR VALIDITY, AND IF IT IS VALID,
*        A SKELETON PARAMETER LIST FOR DATA GENERATION IS SET UP,
*        WITH SWITCHES INITIALIZED TO MULTIPLE ENTRY, OUTPUT TYPE=
*        VECTOR, STATUS IS INCLUDE,OUTPUT IS OPTIMIZED, FIRST ENTRY,
*        NOT KEYED, NOT CORVALED, BEAM OFF.
*
         MVC   WKSWAREA+1(1),GDSDATMD  SAVE DATA MODE SW FROM GDSCB
         C     GDSREG,GDSGDSCB
         BNE   AFAERR10                 BRANCH IF INVALID GDSCB
         XC    WKSPVSR(12),WKSPVSR     ZERO PARM LIST FOR LINK MACRO
         XC    WKADDR(68),WKADDR        ZERO PARAMETER FIELDS
         MVC   WKBITS,BITS              MOVE OPTION SWITCHES,
         ST    GDSREG,WKGDS              GDSCB ADDRESS, AND
         MVC   WKRTN,WKRTNCD             RETURN CODE ARRAY ADDRESS
*                                       INTO PARAMETER LIST
         EJECT
*        REQUIRED PARAMETERS (X AND Y VALUES FOR START AND END OF
*        SEGMENT) ARE EXAMINED, AND THE TYPE OF DATA PASSED IS
*        DETERMINED.
         TM    GDS(PARM),LAST
         BO    AFAERR20                 BRANCH IF REQ PARMS NOT PRESENT
         MVC   WKSWITCH+3(1),GDSDATMD  IINITIALIZE DATA MODE SWITCH
*                                         IN WORK AREA
         TM    GDSFLAGS,SEQ
         BZ    AFAREQ03
         OI    WKBITS+3,MEMSEQ          OTHERWISE SET SWITCH IN KEY
AFAREQ03 TM    GDSFLAGS,SUBR
         BZ    AFAREQ05
         OI    WKBITS+3,MEMSUB         SET SWITCH IN KEY
         BAL   RETURN,AFAREQ90         IF SUBR, GO CHECK DATA MODE
AFAREQ05 TM    X(PARM),LAST
         BO    AFAERR20                 BRANCH IF REQ PARMS NOT PRESENT
         TM    Y(PARM),LAST
         BO    AFAERR20                 BRANCH IF REQ PARMS NOT PRESENT
         TM    X2(PARM),LAST
         BO    AFAERR20                 BRANCH IF REQ PARMS NOT PRESENT
         TM    Y2(PARM),LAST
         BO    AFAREQ10                 START PROCESSING PARMS
         TM    COR(PARM),LAST
         BO    AFAREQ10                 START PROCESSING PARMS
         TM    KEY(PARM),LAST
         BO    AFAREQ10             START PROCESSING PARMS
*
*CHECK FOR GENCODE OF 3- AND IF IT IS, PROCESS IT
*
         CLC   NL(3,ERRCD),GEN+1(PARM)
         BE    AFAREQ10                 BRANCH IF GENCODE NULL
         L     REGA,GEN(PARM)
         L     REGA,0(REGA)             PICK UP GENCODE
         C     REGA,THREE
         BE    AFAOPT10
*
AFAREQ10 L     REGA,X(PARM)             ADDRESS OF X START VALUE
         L     REGA,0(REGA)             X VALUE
         TM    WKSWITCH+3,XABS
         BZ    AFAREQ60                 BRANCH IF X INCREMENTAL
         ST    REGA,WKXABS              PUT ABSOLUTE VALUE IN PARM LIST
AFAREQ20 ST    REGA,WKXVAL              SAVE COPY OF X VALUE
         L     REGB,Y(PARM)             ADDRESS OF Y START VALUE
         L     REGB,0(REGB)             Y VALUE
         TM    WKSWITCH+3,YABS
         BZ    AFAREQ65                 BRANCH IF Y INCREMENTAL
         ST    REGB,WKYABS              PUT ABSOLUTE VALUE IN PARM LIST
AFAREQ30 ST    REGB,WKYVAL              SAVE COPY OF Y VALUE
         L     REGA,X2(PARM)            ADDRESS OF X END VALUE
         L     REGA,0(REGA)             X END VALUE
         ST    REGA,WKXVAL2             SAVE COPY OF X END VALUE
         TM    WKSWITCH+3,XABS
         BZ    AFAREQ50                 BRANCH IF X END INCREMENTAL
AFAREQ35 L     REGB,Y2(PARM)
         L     REGB,0(REGB)             Y END VALUE
         ST    REGB,WKYVAL2
         TM    WKSWITCH+3,YABS
         BZ    AFAREQ70                BRANCH IF Y END INCREMENTAL
AFAREQ40 TM    Y2(PARM),LAST
         BO    AFADAT10                 BRANCH IF NO OPTIONAL PARMS
         CLI   WKSWITCH,UPDATE
         BE    AFAOPT55                BRANCH IF UPDATE- CORRBAL,KEY
*                                       AND GENCODE ALREADY PROCESSED
         B     AFAOPT10
         EJECT
*INITIALIZATION OF INCREMENT TOTALS
*
AFAREQ60 ST    REGA,WKXINCR             PUT X INCR VALUE IN PARM LIST
         ST    REGA,WKXTOT               AND SAVE COPY FOR COMPUTING
         B     AFAREQ20
*
*
AFAREQ65 ST    REGB,WKYINCR             PUT Y INCR VALUE IN PARM LIST
         ST    REGB,WKYTOT               AND SAVE COPY FOR COM
         B     AFAREQ30
*
*REGA CONTAINS X END INCREMENT
*
AFAREQ50 TM    WKSWITCH+3,REALX
         BM    AFAREQ55                 BRANCH IF REAL NUMBER
         A     REGA,WKXTOT              1ST X END INCR IS FROM X START
         ST    REGA,WKXTOT2             KEEP CURRENT POINTER TO BEAM
         B     AFAREQ35
AFAREQ55 LE    FLT2,WKXVAL2
         AE    FLT2,WKXTOT              ADD X START INCREMENT
         STE   FLT2,WKXTOT2             SAVE TOTAL
         B     AFAREQ35
*
*REGB CONTAINS Y END INCREMENT
*
AFAREQ70 TM    WKSWITCH+3,REALY
         BM    AFAREQ75                 BRANCH IF REAL NUMBER
         A     REGB,WKYTOT              ADD TO Y START INCREMENT
         ST    REGB,WKYTOT2             SAVE TOTAL
         B     AFAREQ40
AFAREQ75 LE    FLT2,WKYVAL2
         AE    FLT2,WKYTOT              ADD Y START INCREMENT
         STE   FLT2,WKYTOT2             SAVE TOTAL
         B     AFAREQ40
         EJECT
*        RESETS DATA MODE SWITCHES IN TEMPORARY WORK AREA FOR
*        BUFFER SUBROUTINE. INPUT DATA SET TO INCREMENTAL MODE
*
AFAREQ90 MVI   WKSWITCH+3,X'00'         ZERO OUT SWITCH AREA
         TM    GDSDATMD,REALX
         BZ    AFAREQ96                 BRANCH IF X VALUE INTEGER
         OI    WKSWITCH+3,XREALI        SET SWITCH FOR REAL,INCR  X
AFAREQ92 TM    GDSDATMD,REALY
         BZ    AFAREQ98                 BRANCH IF Y VALUE INTEGER
         OI    WKSWITCH+3,YREALI        SET SWITCH FOR REAL,INCR  Y
         MVC   GDSDATMD(1),WKSWITCH+3  STORE NEW SWITCH IN GDSCB
         BR    RETURN
*
AFAREQ96 OI    WKSWITCH+3,XINTGI        SET SWITCH FOR INTEGER,INCR X
         B     AFAREQ92
AFAREQ98 OI    WKSWITCH+3,YINTGI        SET SWITCH FOR INTEGER,INCR Y
         MVC   GDSDATMD(1),WKSWITCH+3  STORE NEW SWITCH IN GDSCB
         BR    RETURN
         EJECT
*        THIS SECTION OF CODE EXAMINES THE OPTIONAL PARAMETERS
*        CORRVAL, KEY, AND GENCODE, AND TESTS THEM FOR VALIDITY
AFAOPT10 CLC   NL(3,ERRCD),COR+1(PARM)
         BE    AFAOPT15                 BRANCH IF CORRVAL NOT PASSED
         TM    GDSFLAGS,LEVEL2
         BO    AFAOPT15                BRANCH IF LEVEL 2 CORRVAL
         L     REGD,COR(PARM)           LOAD ADDRESS OF CORRVAL
         MVC   WKCORVL,0(REGD)          PLACE CORRVAL IN PARAM LIST
         OI    WKBITS+2,CORRE          SET CORRVAL SWITCH IN PARM LIST
AFAOPT15 TM    COR(PARM),LAST
         BO    AFADAT10                 BRANCH IF NO MORE PARAMETERS
         CLC   NL(3,ERRCD),KEY+1(PARM)
         BE    AFAOPT20                 BRANCH IF KEY NOT PASSED
         MVC   WKKEY,KEY(PARM)          PLACE ADDRESS OF KEY IN PARM
*                                           LIST
         TM    GDSFLAGS,LEVEL2
         BO    AFAOPT20                 BRANCH IF LEVEL 2 KEY
         OI    WKBITS+2,KEYED           OTHERWISE SET KEY SWITCH IN
*                                           PARM LIST
AFAOPT20 TM    KEY(PARM),LAST
         BO    AFADAT10                 BRANCH IF NO MORE PARAMETERS
         CLC   NL(3,ERRCD),GEN+1(PARM)
         BE    AFAOPT25                 BRANCH IF GENCODE NOT PASSED
         L     REGD,GEN(PARM)           PICK UP CODE ADDRESS
         L     REGD,0(REGD)             PICK UP ACTUAL CODE
         C     REGD,ONE
         BE    AFAOPT25                 BRANCH IF STATUS='INCLUDE'
*                                      (SWT ALREADY SET IN PARM LIST)
         CLC   WKCORVL(8),ZERO         CHECK FOR CORRVAL AND/OR KEY
         BZ    AFAERR30                 BRANCH IF STATUS NOT INCLUDE
*                                         AND ELEMENT NOT KEYED OR
*                                         CORRVALED-ERROR
         C     REGD,TWO
         BNE   AFAOPT30                 BRANCH IF STATUS NOT 'OMIT'
         TM    GDSFLAGS,LEVEL2
         BO    AFAERR30                 BRANCH IF LEVEL 2 AND 'OMIT'
*                                         STATUS SPECIFIED-ERROR
         NI    WKBITS,OMIT              TURN OFF INCLUDE SWITCH
AFAOPT25 TM    WKBITS+2,CORRE
         BZ    AFAOPT55                 BRANCH IF NOT CORRELATED
         CLC   WKCORVL,ZERO
         BE    AFAERR40                 BRANCH IF CORRVAL=0,-ERROR
         B     AFAOPT55
*
AFAOPT30 C     REGD,THREE
         BNE   AFAERR30                 BRANCH IF NOT 'UPDATE'  -ERROR
         TM    GDSFLAGS,SUBR
         BO    AFAERR20                 BRANCH IF UPDATE WHEN GENERAT-
*                                         ING SUBROUTINE -ERROR
         TM    GDSFLAGS,LEVEL2
         BO    AFAOPT45                 BRANCH IF LEVEL2 TO SET KEY
         TM    WKBITS+2,KEYED
         BZ    AFAOPT50                 BRANCH IF ELEMENT NOT KEYED
*                                       PREPARE PARAMS FOR KEY SEARCH
         L     REGD,KEY(PARM)           LOAD KEY ADDRESS
         ST    REGD,WKKADDR             AND PUT IN PARAMETER LIST
         LA    REGD,TWO                CODE FOR SEARCH ON KEY
AFAOPT35 ST    REGD,WKCODE              WORK CODE ADDRESS
         LA    REGD,AFAOPT37
         ST    REGD,WKTEMP             SAVE RETURN ADDRESS
*
*SEARCH ON KEY OR CORRVAL - ADDRESS IN REGISTER 1
*
         B     AFAKEY10
AFAOPT37 LTR   REGFIFTN,REGFIFTN       TEST RETURN CODE
         BNE   AFAERR20                 BRANCH IF INVALID KEY
         MVC   WKADDR,0(PARM)           MOVE KEY FIELDS INTO PARM LIST
         OC    WKBITS+3(1),7(PARM)      GET FLAGS FROM OLD KEY
         TM    WKBITS+3,MEMSUB
         BZ    AFAOPT38
         BAL   RETURN,AFAREQ90
AFAOPT38 TM    4(PARM),INCLUDE
         BO    AFAOPT39
         NI    WKBITS,OMIT              TURN OFF INCLUDE SWITCH
AFAOPT39 ST    PARM,WKSTORAD           SAVE KEY ADDR IN KEY TABLE
AFAOPT40 MVI   WKSWITCH,UPDATE          SET UPDATE SWITCH
AFAOPT42 L     PARM,WKPARM             RESTORE PARAMETER REG. POINTER
         B     AFAREQ10
*
*
*
*
AFAOPT45 L     REGD,KEY(PARM)           LOAD KEY ADDRESS
         MVC   WKADDR,0(REGD)           PLACE KEY IN PARM LIST
         B     AFAOPT40
*
AFAOPT50 CLC  WKCORVL,ZERO
         BE    AFAERR20                 BAD PARAMETER COMBINATION
*
*PREPARE FOR SEARCH ON CORRVAL
*
         LA    REGD,WKCORVL             LOAD CORRVAL ADDRESS
         ST    REGD,WKKADDR             AND PUT IN PARAMETER LIST
         LA    REGD,FIVE                 SEARCH
         B     AFAOPT35                 BRANCH TO GET REST OF PARAMS
*                                         AND TO CALL KEY MANAGEMENT
         EJECT
*        THIS SECTION EXAMINES THE COUNT PARAMETER, IF THE COUNT IS
*        NOT SPECIFIED IT IS SET TO TWO (TWO CALLS TO THE DATA
*        GENERATION ROUTINE ARE NEEDED FOR EACH LINE SEGMENT). IF
*        THE COUNT IS 0, NO DATA IS GENERATED AND CONTROL IS RETURNED
*        TO THE CALLER. IF THE COUNT IS LESS THAN ZERO AN ERROR
*        RETURN IS MADE. OTHERWISE THE COUNT IS MULTIPLIED BY TWO,
*        AND PROCESSING CONTINUES.
*
AFAOPT55 TM    GEN(PARM),LAST
         BO    AFADAT10                 BRANCH IF END OF PARM LIST
         CLC   NL(3,ERRCD),CT+1(PARM)
         BE    AFADAT10                 BRANCH IF COUNT NULL
         L     COUNT,CT(PARM)
         L     COUNT,0(COUNT)           LOAD COUNT
         LTR   COUNT,COUNT
         BZ    AFARET10                 RETURN IF COUNT = 0
         BM    AFAERR70                 ERROR IF COUNT LESS THAN ZERO
         SLA   COUNT,1                 MULTIPLY COUNT BY 2
         C     COUNT,TWO
         BE    AFADAT10                 BRANCH IF ONE LINE TO BE
*                                       DISPLAYED
         EJECT
*        THIS SECTION EXAMINES THE X START INDEX, Y START INDEX,
*        X END INDEX, Y END INDEX, X START INCR, Y START INCR,
*        X END INCR, AND Y END INCR PARAMETERS.
*        THESE PARAMETERS ARE CHECKED ONLY WHEN MORE THAN ONE LINE
*        SEGMENT IS TO BE DISPLAYED.
         TM    CT(PARM),LAST
         BO    AFAINX50                 BRANCH IF END OF PARAMETER LIST
         CLC   NL(3,ERRCD),XINDEX+1(PARM)
         BE    AFAINX10                 BRANCH IF X START INDEX NULL
         L     REGD,XINDEX(PARM)
         L     REGD,0(REGD)             PICK UP INDEX VALUE
         SLA   REGD,2                   MULTIPLY BY 4
         ST    REGD,WKXCHNG             SAVE INDEXING FACTOR
         OI    WKSWITCH+1,XINDX         SET SWITCH IN WORK AREA
AFAINX10 TM    XINDEX(PARM),LAST
         BO    AFAINX50                 BRANCH IF END OF PARAMETER LIST
         CLC   NL(3,ERRCD),YINDEX+1(PARM)
         BE    AFAINX15                 BRANCH IF Y START INDEX NULL
         L     REGD,YINDEX(PARM)
         L     REGD,0(REGD)             PICK UP INDEX VALUE
         SLA   REGD,2                   MULTIPLY BY 4
         ST    REGD,WKYCHNG             SAVE INDEXING FACTOR
         OI    WKSWITCH+1,YINDX         SET SWITCH IN WORK AREA
AFAINX15 TM    YINDEX(PARM),LAST
         BO    AFAINX50                 BRANCH IF END OF PARM LIST
         CLC   NL(3,ERRCD),XINDEX2+1(PARM)
         BE    AFAINX20                 BRANCH IF X END INDEX NULL
         L     REGD,XINDEX2(PARM)
         L     REGD,0(REGD)            PICK UP INDES VALUE
         SLA   REGD,2                   MULTIPLY BY 4
         ST    REGD,WKXCHNG2            SAVE INDEX FACTOR
         OI    WKSWITCH+2,XINDX        SET SWITCH IN WORK AREA
AFAINX20 TM    XINDEX2(PARM),LAST
         BO    AFAINX50                 BRANCH IF END OF PARM LIST
         CLC   NL(3,ERRCD),YINDEX2+1(PARM)
         BE    AFAINX25                 BRANCH IF Y END INDEX NULL
         L     REGD,YINDEX2(PARM)
         L     REGD,0(REGD)             PICK UP INDEX VALUE
         SLL   REGD,2                   MULTIPLY BY 4
         ST    REGD,WKYCHNG2            SAVE INDEX FACTOR
         OI    WKSWITCH+2,YINDX        SET SWITCH IN WORK AREA
         EJECT
AFAINX25 TM    YINDEX2(PARM),LAST
         BO    AFAINX50                 BRANCH IF END OF PARAMETER LIST
         CLC   NL(3,ERRCD),XINCR+1(PARM)
         BE    AFAINX30                 BRANCH IF X START INCR NULL
         TM    WKSWITCH+1,XINDX         WAS X START INDEX ALSO PASSED
         BO    AFAERR20                 BRANCH IF YES-ERROR
         L     REGD,XINCR(PARM)
         MVC   WKXCHNG,0(REGD)          SACE INCREMENT VALUE
         OI    WKSWITCH+1,XINC          SET SWITCH IN WORK AREA
AFAINX30 TM    XINCR(PARM),LAST
         BO    AFAINX50                 BRANCH IF END OF PARAMETER LIST
         CLC   NL(3,ERRCD),YINCR+1(PARM)
         BE    AFAINX35                 BRANCH IF Y START INCR NULL
         TM    WKSWITCH+1,YINC          WAS Y START INDEX ALSO PASSED
         BO    AFAERR20                 BRANCH IF YES- ERROR
         L     REGD,YINCR(PARM)
         MVC   WKYCHNG,0(REGD)          SAVE INCREMENT VALUE
         OI    WKSWITCH+1,YINC
AFAINX35 TM    YINCR(PARM),LAST
         BO    AFAINX50                 BRANCH IF END OF PARAMETER LIST
         CLC   NL(3,ERRCD),XINCR2+1(PARM)
         BE    AFAINX40                 BRANCH IF X END INCREMENT NULL
         TM    WKSWITCH+2,XINDX         WAS X END INDEX ALSO PASSED
         BO    AFAERR20                 BRANCH IF YES- ERROR
         L     REGD,XINCR2(PARM)
         MVC   WKXCHNG2,0(REGD)         SAVE INCREMENT VALUE
         OI    WKSWITCH+2,XINC          SET SWITCH IN WORK AREA
AFAINX40 TM    XINCR2(PARM),LAST
         BO    AFAINX50                 BRANCH IF END OF PARAMETER LIST
         CLC   NL(3,ERRCD),YINCR2+1(PARM)
         BE    AFAINX50                 BRANCH IF Y ENC INCREMENT NULL
         TM    WKSWITCH+2,YINDX         WAS Y END INDEX ALSO PASSED
         BO    AFAERR20                 BRANCH IF YES- ERROR
         L     REGD,YINCR2(PARM)
         MVC   WKYCHNG2,0(REGD)         SAVE INCREMENT VALUE
         OI    WKSWITCH+2,YINC          SET SWITCH IN WORK AREA
         EJECT
*        THIS SECTION CHECKS WHICH OF THE INDEX AND INCREMENT PARAMS
*        HAVE BEEN PASSED AND SETS UP DEFAULT CONDITIONS WHERE
*        NECESSARY.
*
AFAINX50 TM    WKSWITCH+1,XINDX+XINC
         BM    AFAINX55                 BRANCH IF X START IX/INC THERE
         MVC   WKXCHNG,FOUR              OTHERWISE, SET INDEX VALUE=4
         OI    WKSWITCH+1,XINDX         AND SET SWITCH IN WORK AREA
AFAINX55 TM    WKSWITCH+1,YINDX+YINC
         BM    AFAINX60                 BRANCH IF Y START IX/INC THERE
         MVC   WKYCHNG,FOUR              OTHERWISE, SET INDEX VALUE=4
         OI    WKSWITCH+1,YINDX          AND SET SWITCH IN WORK AREA
AFAINX60 TM    WKSWITCH+2,XINDX+XINC
         BM    AFAINX65                 BRANCH IF X END IX/INC PRESENT
         MVC   WKXCHNG2,FOUR             OTHERWISE, SET INDEX VALUE=4
         OI    WKSWITCH+2,XINDX          AND SET SWITCH IN WORK AREA
AFAINX65 TM    WKSWITCH+2,YINDX+YINC
         BM    AFADAT10                 BRANCH IF Y END IX/INC PRESENT
         MVC   WKYCHNG2,FOUR             OTHERWISE,SET INDEX VALUE=4
         OI    WKSWITCH+2,YINDX          AND SET SWOTCH IN WORK AREA
         EJECT
*        THIS SECTION COMPLETES THE PARAMETER LIST FOR THE CALL TO
*        THE DATA GENERATION ROUTINE AND, IF MORE THAN ONE LINE
*        SEGMENT IS TO BE DISPLAYED, SETS UP THE LOOP FOR FUTURE
*        ENTRIES. PSGMT WILL ALWAYS MAKE MULTIPLE ENTRIES TO THE
*        DATA GENERATION ROUTINE, AND OUTPUT WILL ALWAYS BE VECTOR.
*
AFADAT10 TM    WKBITS+3,MEMSUB
         BO    AFADAT70                BRANCH IF BUFFER SUBROUTINE
*                                        SUBROUTINE-OUTPUT INCREMENTAL
*TEST FOR OUTPUT DATA MODE
*
         TM    GDSCURMD,OPT
         BO    AFADAT20                 BRANCH IF OPTIMIZE MODE- SWITCH
*                                        ALREADY SET
         TM    GDSCURMD,INC
         BO    AFADAT70                 BRANCH IF INCREMENTAL MODE
         XI    WKBITS,ABSSW            SET SWITCH TO ABSOLUTE MODE
*
*
AFADAT20 MVC   WKXCURR(4),GDSXCURR      SAVE X-Y CURRENT VALUE
         MVC   WKXLAST(8),GDSXLAST      SAVE X-Y LAST VALUE
         CLI   WKSWITCH,UPDATE
         BE    AFADAT75                 BRANCH IF UPDATE
         L     REGD,GDSAOACB            GET OACB ADDRESS
         L     REGD,CURRLOG(REGD)       GET LOGICAL START AND
         STH   REGD,WKADDR+2             STORE IN PARAMETER LIST
         EJECT
*SET UP LOOP CONTROL IF MORE THAN ONE LINE SEGMENT TO BE GENERATED.
*
AFADAT25 C     COUNT,TWO
         BE    AFASSD10                 BRANCH IF ONE LINE TO GENERATE
AFADAT30 TM    WKSWITCH+1,XINDX
         BZ    AFADAT35                 BRANCH IF X START INCREMENTAL
         MVC   WKXVAL,X(PARM)           REPLACE X VALUE WITH X ADDR
AFADAT35 TM    WKSWITCH+1,YINDX
         BZ    AFADAT40                 BRANCH IF Y START INCREMENTAL
         MVC   WKYVAL,Y(PARM)           REPLACE Y VALUE WITH Y ADDR
AFADAT40 TM    WKSWITCH+2,XINDX
         BZ    AFADAT45                 BRANCH IF X END INCREMENTAL
         MVC   WKXVAL2,X2(PARM)         REPLACE X2 VALUE WITH X2 ADDR
AFADAT45 TM    WKSWITCH+2,YINDX
         BZ    AFASSD10                 BRANCH IF Y END INCREMENTAL
         MVC   WKYVAL2,Y2(PARM)         REPLACE Y2 VALUE WITH Y2 ADDR
         B     AFASSD10
*
*
*
AFADAT70 XI    WKBITS,INCSW
         B     AFADAT20
*/
*GET GDOA'S FOR UPDATE
*
AFADAT75 EQU   *                                            D11 ZA15418
         LA    PARM,WKADDR
         L     REGFIFTN,STAT(ERRCD)  POINT TO STATUS TABLE  D11 ZA15418
         L     REGFIFTN,UPDH13(REGFIFTN) POINT TO IFFAHA13  D11 ZA15418
         BALR  RETURN,REGFIFTN       GOTO IFFAHA13          D11 ZA15418
* IFFAHA13 IS NOW CALLED VIA GSP LOGIC TO SAVE SYS OVERHEAD D11 ZA15418
         LTR   REGFIFTN,REGFIFTN
         BNE   AFAERR90
         L     PARM,WKPARM             RESTORE PARAMETER POINTER
         B     AFADAT25
         EJECT
*THIS SECTION OF CODE IS ENTERED TWICE FOR EVERY LINE SEGMENT TO BE
*GENERATED. IT INCLUDES CALLS TO THE SCALE, SCISSOR(WHEN REQUESTED),
*AND DATA GENERATION ROUTINES.
         SPACE
AFASSD10 LA    PARM,WKGDS
*/       CALL  SCALE
*/
         L     REGFIFTN,STAT(ERRCD)     ADDRESS OF STATUS TABLE
         L     REGFIFTN,SCALE(REGFIFTN) ADDRESS OF SCALE
         BALR  RETURN,REGFIFTN          BRANCH TO SCALE
         LTR   REGFIFTN,REGFIFTN
         BNE   AFARES10
         TM    WKBITS+3,MEMSUB         TEST FOR BUFFER SUBROUTINE
         BO    AFASSD25                IF IS, NO SCISS, NO BEAM REPOS
         TM    GDSSCISS,NOSCISS
         BZ    AFASSD15                 BRANCH IF SCISSOR WANTED
*
*THESE VALUES ARE SET BY THE SCISSOR ROUTINE, SO ARE SET IN PSEGMT ONLY
*WHEN THERE IS TO BE NO SCISSORING
*
         MVC   GDSXLAST,WKXABS          * SET XLAST
         L     PARM,WKXABS
         SH    PARM,GDSXCURR            RECOMPUTE INCREMENT AND PUT
         ST    PARM,WKXINCR              IN PARAMETER LIST
         MVC   GDSXCURR,WKXABS+2        *     XCURR
         MVC   GDSYLAST,WKYABS          *     YLAST AND
         L     PARM,WKYABS
         SH    PARM,GDSYCURR            RECOMPUTE INCREMENT AND PUT
         ST    PARM,WKYINCR              IN PARAMETER LIST
         MVC   GDSYCURR,WKYABS+2        *     YCURR IN GDSCB
         NI    GDSSCISS,LASTON
         B     AFASSD25
*
*CALL TO SCISSOR ROUTINE
*
AFASSD15 LA    PARM,WKGDS
*/
*/       CALL  SCISSOR
         L     REGFIFTN,STAT(ERRCD)     ADDRESS OF STATUS TABLE
         L     REGFIFTN,SCISS(REGFIFTN) ADDRESS OF SCISSOR
         BALR  RETURN,REGFIFTN          BRANCH TO SCISSOR
         LTR   REGFIFTN,REGFIFTN
         BZ    AFASSD20                 BRANCH IF SCISSOR RETURN OK
         C     REGFIFTN,FOUR
         BE    AFARES10
         B     AFASSD30                 OTHERWISE SKIP CALL TO DATA GEN
         EJECT
AFASSD20 TM    WKBITS+2,LASTIN
         BZ    AFASSD25                ALWAYS GENERATE FIRST VECTOR
         CLC   WKXINCR(8),ZERO          IF NO MOVEMENT
         BE    AFASSD30                  BRANCH PAST CALL TO DATA GEN
*CALL TO DATA GENERATION ROUTINE
*
AFASSD25 LA    PARM,WKADDR
*/
*/       CALL  DATA GEN
*/
         L     REGFIFTN,STAT(ERRCD)     ADDRESS OF STATUS TABLE
         L     REGFIFTN,DGEN(REGFIFTN)  ADDRESS OF DATA GEN
         BALR  RETURN,REGFIFTN          BRANCH TO DATA GEN
         LTR   REGFIFTN,REGFIFTN
         BNE   AFARES10
         NI    WKBITS+2,SWOFF
         OI    WKBITS+2,NFNL            SET NOT FIRST NOT LAST SWITCH
         SPACE
AFASSD30 BCT   COUNT,AFASET05          BRANCH IF MORE TO DO
         TM    WKBITS+2,LASTIN
         BZ    AFAERR80                BRANCH IF FIRST PASS SWITCH
*                                      STILL ON - NO DATA GENERATED
         BO    AFASSD50                B-&NCH &F L&00 &&-   &&
*                                      CALL DATA GEN AGAIN
         CLI   WKSWITCH,UPDATE
         BE    AFASSD80                 BRANCH IF UPDATE
         SPACE
*PREPARE KEY
*
         L     COUNT,GDSAOACB
         L     COUNT,CURRLOG(COUNT)    GET CURRENT LOGICAL ADDRESS
         SH    COUNT,WKADDR+2          COMPUTE ELEMENT LENGTH
         LTR   COUNT,COUNT
         BZ    AFAERR80                 ERROR IF NO DATA GENERATED
         STH   COUNT,WKADDR            PLACE LENGTH IN KEY
         L     COUNT,WKKEY
         LTR   COUNT,COUNT
         BE    AFASSD35                 BRANCH IF NO USER VARIABLE
         MVC   0(4,COUNT),WKADDR       PLACE KEY IN USER VARIABLE
AFASSD35 TM    WKBITS+2,KEYED+CORRE
         BZ    AFARET10                BRANCH IF NOT KEYED OR CORREL
*
*   PREPARE PARAM LIST
         SPACE
         LA    REGA,ONE                CODE FOR ADDING KEY TO TABLE
         ST    REGA,WKCODE
         LA    REGA,AFASSD40           SAVE RETURN ADDRESS
         ST    REGA,WKTEMP
         LA    REGA,WKADDR
         ST    REGA,WKKADDR
         B     AFAKEY10
*
AFASSD40 LTR   REGFIFTN,REGFIFTN
         BNE   AFAERR90                 BRANCH IF NOT ENOUGH STORAGE
         SPACE
AFARET10 CLI   WKSWITCH,UPDATE
         BNE   AFARET15                 BRANCH IF NOT UPDATE
         TM    GDSFLAGS,LEVEL2
         BO    AFARET15                BRANCH IF LEVEL 2-NO KEY TABLE
         L     PARM,WKSTORAD
         MVC   4(4,PARM),WKBITS        MOVE IN NEW KEY SWITCHES
         TM    WKBITS+2,CORRE
         BZ    AFARET15                 BRANCH IF NO CORRVAL
         MVC   8(4,PARM),WKCORVL        MOVE IN NEW CORRVAL
AFARET15 MVC   GDSDATMD(1),WKSWAREA+1   RESTORE DATA MODE SWITCH
AFARET17 L     SAVE,4(SAVE)
AFARET20 RETURN (14,12),T
         SPACE 2
AFASSD50 OI  WKBITS+2,REPONLY          SET FLAG TO GENERATE REPOS VECT
         XC    WKDATA1(32),WKDATA1
         MVC   WKXABS+2(2),GDSXCURR    PLACE CURRENT BEAM POSITION
         MVC   WKYABS+2(2),GDSYCURR    FROM GDS INTO PARAMETER LIST
         LA    COUNT,1                 RESET COUNT REGISTER
         B     AFASSD25                CALL DATA GEN AGAIN
         EJECT
*CALL DATA STORE TO WRITE OUT UPDATE
*
*WRITE OUT UPDATE
*
AFASSD80 LA    PARM,WKADDR
         L     REGFIFTN,STAT(ERRCD) POINT TO STATUS TABLE   D11 ZA15418
         L     REGFIFTN,UPDH14(REGFIFTN) AND TO IFFAHA14    D11 ZA15418
         BALR  RETURN,REGFIFTN     GOTO IFFAHA14            D11 ZA15418
* IFFAHA14 IS NOW CALLED VIA GSP LOGIC TO AVOID SYS OVRHD   D11 ZA15418
         B     AFARET10
         SPACE
*
*LINKAGE TO KEY MANAGEMENT ROUTINE
*
AFAKEY10 ST    GDSREG,WKGDS1
         LA    PARM,WKGDS1
         L     REGA,GDSGTMCB       GET POINTER TO GTMCB            000A
         L     REGA,4(REGA)        GET POINTER TO GSPCB            000A
         L     REGA,FE(REGA)       GET POINTER TO STATUS TABLE     000A
         L     REGFIFTN,ETE(REGA)  GET ADRS OF KEY TABLE MGMT      000A
         BALR  RETURN,REGFIFTN     BRANCH TO KEY TABLE MGMT        000A
         L     RETURN,WKTEMP            PICK UP RETURN ADDRESS
         BR    RETURN
         EJECT
*THIS SECTION IS ENTERED ON RETURN FROM THE DATA GENERATION ROUTINE   *
*WHEN DATA REMAINS TO BE GENERATED. THE DATA AREA IN THE PARAMETER    *
*LIST IS ZEROED, AND THE BEAM OFF/ON SWITCH IS FLIPPED. THE X AND Y   *
*VALUES TO BE USED (X AN Y START IF THE BEAM IS OFF, AND X AND Y END  *
*IF THE BEAM IS ON) ARE UPDATED AND PLACED IN THE PARAMETER LIST
*
*RESETTING AND INITIALIZATION
*
AFASET05 XC    WKDATA1(32),WKDATA1      ZERO DATA FIELDS IN PARM LIST
         XI    WKBITS+2,BEAMSW          FLIP BEAM OFF/ON SWITCH
         LA    LOOPCT,2                 SET UP LOOP CONTROL FOR UPDATE
*
*INITIALIZE FOR FIRST PASS- X ENTRY
*
         SR    REGB,REGB                INDEX TO PARM LIST, FOR X=0
         MVC   WKSWAREA(1),WKSWITCH+3   MOVE DATA MODE SWITCH TO WORK
         NI    WKSWAREA,NOY              AREA AND ELIMINATE Y SWITCHES
         TM    WKBITS+2,BEAMSW
         BO    AFASET10                 BRANCH IF X AND Y END VALUES
*                                        TO BE USED
*INITIALIZE FOR X-Y START VALUES
         SR    REGD,REGD                INDEX TO WKAREAS =0 FOR X START
         LA    REGC,WKSWITCH+1          SWITCH ADDRESS FOR X-Y START
         B     AFASET15                 GO TO PROCESS
*
*INITIALIZE FOR X-Y END VALUES
*
AFASET10 LA    REGD,8                   INDEX TO WKAREAS=8 FOR X END
         LA    REGC,WKSWITCH+2          SWITCH ADDRESS FOR X-Y END
*
*LOOPCT= LOOP CONTROL INFORMATION
*REGB  = INDEX TO VALUES IN PARM LIST
*REGC  = ADDRESS OF SWITCH AREA
*REGD  = INDEX TO WORK AREA
*
AFASET15 TM    0(REGC),XINDX
         BZ    AFASET50                 BRANCH IF INCREMENT PARM PASSED
         EJECT
*THIS SECTION ENTERED WHEN INDEX PARAMETER PASSED
*
AFASET20 L     REGA,WKXVAL(REGD)        PICK UP POINTER TO DATA
         TM    WKSWAREA+2,ON
         BZ    AFASET90                 BRANCH IF 1ST TIME X-Y END USED
         A     REGA,WKXCHNG(REGD)       OTHERWISE, UPDATE POINTER
         ST    REGA,WKXVAL(REGD)         AND SAVE IT
         TM    WKSWAREA,ABSOLXY
         BZ    AFASET95                 BRANCH IF DATA MODE INCREMENTAL
AFASET25 LA    REGB,WKXABS(REGB)        GET POINTER TO PARM LIST ENTRY
         MVC   0(4,REGB),0(REGA)        MOVE VALUE INTO PARM LIST
AFASET30 BCT   LOOPCT,AFASET40          *
*
*X AND Y VALUES NOW UPDATED
         C     COUNT,ONE
         BE    AFASET35                 BRANCH IF LAST CALL TO DATA GEN
         OI    WKSWAREA+2,ON           SET SWITCH 1ST X,Y END USED
         B     AFASSD10
*
AFASET35 TM    WKBITS+2,LASTIN
         BZ    AFASET37      BRANCH IF NO DATA GENERATED YET
         OI    WKBITS+2,LASTIN         SET LAST PASS SWITCH
         B     AFASSD10
AFASET37 XI    WKBITS,MULT             MULT ENTRY HAS BECOME SINGLE
         B     AFASSD10
         EJECT
*INITIALIZATION FOR SECOND PASS THROUGH LOOP (Y VALUES)
*
AFASET40 LA    REGB,4                   IX VALUE FOR PARM LIST=4 FOR Y
         AR    REGD,REGB                IX TO WK AREA FOR Y=4 PLUS X IX
*                                       SWITCH ADDR (REG C) REMAINS
         MVC   WKSWAREA(1),WKSWITCH+3   MOVE DATA MODE SWITCH AND
         NI    WKSWAREA,NOX              ELIMINATE ANY X SWITCHES
         TM    0(REGC),YINDX
         BZ    AFASET50                 BRANCH IF INCREMENT PARM PASSED
         B     AFASET20
         EJECT
*INCREMENT PARAMETER PASSED, DATA MODE ABSOLUTE OR INCREMENTAL
*
AFASET50 TM    WKSWAREA+2,ON
         BZ    AFASET60                 BRANCH IF 1ST TIME X-Y END USED
         TM    WKSWAREA,ABSOLXY
         BZ    AFASET65                 BRANCH IF DATA MODE INCREMENTAL
         TM    WKSWAREA,REALX+REALY
         BM    AFASET55                 BRANCH IF INCREMENT REAL
         L     REGA,WKXVAL(REGD)
         A     REGA,WKXCHNG(REGD)       ADD INCREMENT
         ST    REGA,WKXVAL(REGD)        SAVE NEW VALUE AND
AFASET52 ST    REGA,WKXABS(REGB)         PLACE IT IN PARM LIST
         B     AFASET30                 RETURN TO CHECK LOOP COUNT
*
*INCREMENT VALUE REAL
         SPACE
AFASET55 LE    FLT2,WKXVAL(REGD)
         AE    FLT2,WKXCHNG(REGD)       ADD INCREMENT
         STE   FLT2,WKXVAL(REGD)        SAVE NEW VALUE AND
         STE   FLT2,WKXABS(REGB)         PLACE IT IN PARAMETER LIST
         B     AFASET30                 RETURN TO CHECK LOOP COUNT
*
* X OR Y END INCREMENTED, FIRST TIME REFERENCED
         SPACE
AFASET60 L     REGA,WKXVAL(REGD)        PICK UP VALUE
         TM    WKSWAREA,ABSOLXY
         BM    AFASET52                 BRANCH IF DATA MODE ABSOLUTE
         ST    REGA,WKXINCR(REGB)      PLACE INCR IN PARM LIST
         B     AFASET30                 RETURN TO CHECK LOOP COUNT
*
*DATA MODE INCREMENTAL, INCREMENT PARAMETER PASSED
*
AFASET65 L     REGA,WKXCHNG(REGD)
         ST    REGA,WKTEMP
         B     AFASUB10
         SPACE
* X OR Y END INDEXED, FIRST TIME REFERENCED
*
AFASET90 TM    WKSWAREA,ABSOLXY
         BM    AFASET25                 BRANCH IF DATA MODE ABSOLUTE
         LA    REGB,WKXINCR(REGB)       GET POINTER TO PARM LIST ENTRY
         MVC   0(4,REGB),0(REGA)        PLACE VALUE IN PARM LIST
         B     AFASET30
*
*X OR Y INDEXED, DATA MODE INCREMENTAL
*
AFASET95 MVC   WKTEMP,0(REGA)           MOVE INCREMENT INTO WORK AREA
         B     AFASUB10                 GO TO COMPUTE INCREMENT
         EJECT
*THIS ROUTINE COMPUTES THE INCREMENT TO BE PASSED TO THE SCALE
*ROUTINE. IT EXPECTS WKTEMP TO HOLD THE INCREMENT, AND THE VARIOUS
*REGISTERS AS SET UP- REGB-INDEX TO PARAMETER LIST, REGD-INDEX TO
*WORK AREAS, AND REGC-SWITCH ADDRESS. REGISTER 15 IS USED AS A
*WORK REGISTER
*
AFASUB10 LR    REGFIFTN,REGD
         C     REGFIFTN,EIGHT
         BL    AFASUB50                 BRANCH IF UPDATING X OR Y START
         S     REGFIFTN,EIGHT           ESTABLISH IX TO X OR Y START
AFASUB15 TM    WKSWAREA,REALX+REALY
         BM    AFASUB60                 BRANCH IF FLOATING POINT
         L     REGA,WKTEMP              PICK UP INCREMENT
         A     REGA,WKXTOT(REGD)         ADD TO CUMULATIVE POSITION
         ST    REGA,WKXTOT(REGD)         AND SAVE NEW TOTAL
         S     REGA,WKXTOT(REGFIFTN)    FIND DIFFERENCE FROM LAST POSIT
         ST    REGA,WKXINCR(REGB)      AND SAVE IN PARM LIST
         B     AFASET30                 RETURN TO CHECK LOOP COUNT
*
AFASUB50 LA    REGFIFTN,8(REGFIFTN)     ESTABLISH INDEX TO X OR Y END
         B     AFASUB15
*
*INCREMENT REAL NUMBER
*
AFASUB60 LE    FLT2,WKTEMP             PICK UP INCREMENT
         AE    FLT2,WKXTOT(REGD)         ADD TO CUMULATIVE POAITION
         STE   FLT2,WKXTOT(REGD)         AND SAVE NEW TOTAL
         SE    FLT2,WKXTOT(REGFIFTN)    COMPUTE INCREMENT
         STE   FLT2,WKXINCR(REGB)        AND PUT IN PARAMETER LIST
         B     AFASET30                 RETURN TO CHECK LOOP COUNT
         EJECT
AFAERR10 MVC   PARMERR(4,ERRCD),ONE     GDS INVALID
         OI     0(ERRCD),PRM
         B     AFARET17
*
AFAERR20 OI    0(ERRCD),PRM             PARAMETER ERROR
         B     AFARET15
*
AFAERR30 MVC   PARMERR(4,ERRCD),EIGHT   GENCODE ERROR
         B     AFAERR20
*
AFAERR40 MVC   PARMERR(4,ERRCD),SIX     CORRVAL ERROR
         B     AFAERR20
*
AFAERR70 MVC   PARMERR(4,ERRCD),NINE    COUNT ERROR
AFAERR80 OI    0(ERRCD),SCISSOR         NO DATA GENERATION
         B     AFARET15
*
AFAERR90 OI    0(ERRCD),STRG            MAIN STORAGE EXCEEDED
         MVC   STOR(4,ERRCD),FOUR
         B     AFARES10
*
*CALL RESET IF ERROR RETURN FROM SCALE OR DATA GEN
*
AFARES10 MVC   GDSXCURR(4),WKXCURR      RESTORE BEAM POINTERS
         MVC   GDSXLAST(8),WKXLAST
         CLI   WKSWITCH,UPDATE
         BE    AFARET15                BRANCH IF UPDATE-RESET NOT
*                                       NECESSARY
         MVC   WKDATA2(20),0(ERRCD)     SAVE RETURN ARRAY
         LA    REGA,GDSGDSCB            VAR HOLDING ADDR OF GDSCB
         ST    REGA,WKGDS
         LA    REGA,WKGDS               ADDRESS OF PARAMETER LIST
         ST    REGA,WKGDS1               STORED IN WORK AREA
         L     REGA,NULL(ERRCD)         NULL FOR CORRVAL IN PARM LIST
         ST    REGA,WKRTN
         LA    REGA,WKADDR              ADDRESS OF KEY IN PARM LIST
         ST    REGA,WKDATA1
         OI    WKDATA1,LAST             LAST PARM INDICATION
         ST    ERRCD,WKCODE             ADDRESS OF RETURN ARRAY
         LA    PARM,WKGDS1              ADDRESS OF WORK AREA
         L     REGA,16
         L     REGA,CVTLINK(REGA)       LINK LIB DCB
*      LINK EP=IFFAFA12,DCB=(REGA),MF=(E,(1)),SF=(E,WKSPVSR)
         LINK  EP=IFFAFA12,MF=(E,(1)),SF=(E,WKSPVSR)
         MVC   0(20,ERRCD),WKDATA2      RESTORE RETURN ARRAY
         B     AFARET15
         EJECT
*CONSTANTS
*
ZERO     DC    2F'0'
ONE      DC    F'1'
TWO      DC    F'2'
THREE    DC    F'3'
FOUR     DC    F'4'
FIVE     DC    F'5'
SIX      DC    F'6'
SEVEN    DC    F'7'
EIGHT    DC    F'8'
NINE     DC    F'9'
BITS     DC    B'10000111'              MULTIPLE,VECTOR,INCLUDE,
         DC    X'00'                     OPTIMIZED, FIRST PASS, NO KEY,
         DC    B'00000000'               NO CORRVAL, BEAM OFF
         DC    X'00'
PATCH    DC    64X'FF'             PATCH AREA               D11
         EJECT
WORKAREA DSECT
WKPARM   DS    F                        ADDRESS OF PARAMETER LIST
WKRTNCD  DS    F                        ADDRESS OF RETURN ARRAY
WKSAVE   DS    18F                      REGISTER SAVE AREA
WKSWITCH DS    F
*                                       BYTE 0 - UPDATE SWITCH
*                                       BYTE 1
*                                          X'C0' - X INDEX
*                                          X'0C' - Y INDEX
*                                          X'30' - X INCREMENT
*                                          X'03' - Y INCREMENT
*                                       BYTE 2
*                                          X'C0' - X2 INDEX
*                                          X'0C' - Y2 INDEX
*                                          X'30' - X2 INCREMENT
*                                          X'03' - Y2 INCREMENT
*                                       BYTE 3   - COPY OF INPUT DATA
*                                          MODE SWITCH FROM GDSCB
WKSWAREA DS    F
WKSPVSR  DS    3F
WKSTORAD DS    F
WKTEMP   DS    F
WKXCHNG  DS    F
WKYCHNG  DS    F
WKXCHNG2 DS    F
WKYCHNG2 DS    F
WKXVAL   DS    F
WKYVAL   DS    F
WKXVAL2  DS    F
WKYVAL2  DS    F
WKXTOT   DS    F
WKYTOT   DS    F
WKXTOT2  DS    F
WKYTOT2  DS    F
WKXCURR  DS    H                        *
WKYCURR  DS    H                        *SAVE AREA FOR INFORMATION
WKXLAST  DS    F                        *  FROM GDSCB
WKYLAST  DS    F                        *
* START OF PARAMETER LIST PASSED TO DATA GENERATION ROUTINE
*
WKADDR   DS    F                        BUFFER LENGTH & LOG. BUFF ADDR
WKBITS   DS    F                        SWITCHES
WKCORVL  DS    F                        CORRVAL
WKKEY    DS    F                        KEY
* START OF PARAMETER LIST PASSED TO SCALING AND SCISSORING ROUTINES
WKGDS    DS    F                        ADDRESS OF GDSCB
WKRTN    DS    F                        ADDRESS OF RETURN ARRAY
WKDATA1  DS    F                            *
WKDATA2  DS    F                            *
WKDATA3  DS    F                            *
WKDATA4  DS    F                        DATA ARRAY
WKXABS   DS    F                            *
WKYABS   DS    F                            *
WKXINCR  DS    F                            *
WKYINCR  DS    F                            *
WKTOTX   DS    F                        X INCREMENT THUS FAR
WKTOTY   DS    F                        Y INCREMENT THUS FAR
WKENDCT  DS    F
* PARAMETERS FOR KEY MANAGEMENT ROUTINE
WKGDS1   DS    F                        ADDRESS OF GDSCB
WKCODE   DS    F                        CODE FOR KEY MANAGEMENT
WKKADDR  DS    F                        ADDRESS OF KEY
         COPY  GDSCB
         COPY  GTMCB
         END
