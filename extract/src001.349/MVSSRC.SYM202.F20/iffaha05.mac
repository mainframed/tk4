*
*
*        THE DATA STORE ROUTINE IS ENTERED FROM:
*        DATA GENERATOR
*        BGSEQ/BGSUB
*        ENSEQ
*        ENSUB
*        LKSUB
*        PTEXT
*        ORGEN
*
*
*                        INPUT TO THE DATA STORE ROUTINE
*                        WILL BE POINTED TO BY REGISTER 1.
*
*                        +0   A(GDSCB)
*                        +4   A(GSPARRAY)
*                        +8   FLAGS
*                        +10  LENGTH
*                        +12  9 WORDS OF OUTPUT
*                        +48  WORK AREA
*
*
*        EXTERNAL MACROS:
*
*        GWRITE
*        WAIT
*
*        EXTERNAL ROUTINES:
*
*        BUFFER MANAGEMENT
*        FLOW CONTROL MANAGEMENT
*
*
         EJECT
*
*        THERE IS ONE ENTRY POINT AND THE FLAGS PASSED ARE USED TO
*        DETERMINE THE FUNCTION DESIRED.
*
*
*                        WHEN FLAGS+0 HAVE THE FOLLOWING
*                        SETTINGS THE INPUT WILL APPEAR
*                        AS FOLLOWS:
*
*   FROM BEGSEQ,DATA GEN 01   GTRU UNRES ADDR
*
*   FROM ENDSEQ,ENDSUB   02   NO DATA RESOLVE ADDR TO
*        DATA GEN             CURRENT LOCATION
*
*   FROM DATA GEN        03   GTRU UNRES ADDR
*                             ALSO RESOLVE PREVIOUS
*                             UNRESOLVED TO CURRENT+4
*
*    FROM BEGSUB         04   GTRU UNRES ADDR
*                             GTRU 0
*                             GDRD
*
*    FROM BEGSUB         14   GTRU UNRES ADDR
*                             GTRU 0
*                             GTRU *-4
*                             GDRD
*
*    FROM BUFSUB         08   GMVA LOC,*+10
*                             GTRU SUBR+4
*                             GPDI
*
*    FROM BUFSUB         18   GTRU *+14
*                             GMVA LOC,*+14
*                             GTRU SUBR+4
*                             GPDI
*
*        FROM ORGEN     20   OVERFLOW ONLY
*
*    ALL ADDRESSES NOTED AS *+ OR *- MUST BE RESOLVED BY DATA STORE
*
*
         EJECT
*
*        ON ENTRY THE WORK AREA DSECT IS INITIALIZED, THE BASE IS
*        SET UP, THE GDSCB DSECT IS INITIALIZED, THE GTMCB DSECT IS
*        INITIALIZED, AND THE SAVE AREAS ARE CHAINED.
*
IFFAHA05 CSECT
*A394500,394600;D396060,396120                                   A35620
*C595500                                                         A34801
*C132000,495000                                                  A33271
*117000-118000                                                   A27472
*138000,144000                                                   A25112
*D090000-091000,A090000-091200,C497000-498000,A540300-540600     YM1963
*A517500-517600                                                 OY02461
         SAVE  (14,12)
         BALR  BASE,0              ADDRESSABILITY
         USING *,BASE
         LR    WORK,PARM           WORKAREA
         USING WORKAREA,WORK
         L     GDSREG,WRKGDS       GDSCB
         USING GDSCB,GDSREG
         L     ERRCD,WRKRTNCD      ERROR LOCATION
         XC    WRKSPVSR(12),WRKSPVSR ZERO SUPERVISOR PARAMETER LIST
         L     OACB,GDSAOACB       OACB
         USING OACBAREA,OACB
         LA    REGA,WRKSAVE        CHAIN SAVE AREAS
         ST    SAVE,WRKSAVE+4
         ST    REGA,8(SAVE)
         LR    SAVE,REGA
         L     GTMREG,GDSGTMCB
         USING GTMCB,GTMREG        STMCB
         MVC   WRKRTN,WRKRTNCD     MOVE RETURN CODE ARRAY ADDR IN CALL
*                                  AREA FOR FUTURE CALLS
*
*        A CHECK IS MADE TO SEE IF DATA HAS EVER BEEN GENERATED
*        AND IF NOT BUFFER AND A FLOW CONTROL ENTRY ARE OBTAINED.
*
         TM    STATUS,NOBUF        HAS ANY DATA BEEN GENERATED FOR
         BO    STR00800            THIS GDS--NO-GO GET BUFFER AND ADD
*                                  TO FLOW CTL
         EJECT
*
*        IF NO FLAGS ARE PASSED IT IS ASSUMED THAT DATA IS TO BE
*        PLACED IN THE GDOA.  A CHECK IS MADE TO SEE IF THE :ATA
*        WILL FIT.  IF SO IT IS MOVED INTO THE GDOA.  THE LENGTH
*        LEFT IS REDUCED BY THE LENGTH OF THE DATA AND THE LOGICAL
*        START ADDRESS IS UPDATED BY THE LENGTH OF THE DATA.  THE
*        OLP IS ALSO UPDATED BY THE LENGTH OF THE DATA.
*
STR00100 CLC   WRKFLAGS,ZERO       ANY FLAGS SET
         BNE   STR01100            YES GO HANDLE THEM
STR00150 LH    REGA,WRKLEN         PICK UP LENGTH
         LTR   REGA,REGA           ANY DATA TO BE GENERATED
         BZ    STR00200            NO,EXIT
         C     REGA,LENLEFT        DOES IT FIT
         BH    STR00300            NO
         L     REGB,OLP            ORDER LOAD PT
         BCTR  REGA,0              REDUCE LEN BY 1
         EX    REGA,MOVE           MOVE INTO OUTPUT AREA
         LH    REGA,WRKLEN
         AR    REGB,REGA
         ST    REGB,OLP            UPDATE OLP
         L     REGB,LENLEFT        REDUCE LENGTH LEFT
         SR    REGB,REGA           BY LENGH OF DATA GENERATED
         ST    REGB,LENLEFT
         A     REGA,LOGCURR
         ST    REGA,LOGCURR        UPDATE CURRENT LOGICAL ADDR
         SPACE 3
*
*        HERE THE ROUTINE RETURNS TO THE CALLING PROGRAM.
*
STR00200 LA    REGFIFTN,CODE0      RETURN CODE FOR CALLER        YM1963
STR00205 L     SAVE,4(SAVE)        RESTORE PTR TO CALLER'S SAVE  YM1963
         RETURN (14,12),T,RC=(15)  RETURN TO CALLER              YM1963
         EJECT
*
*        IF THE DATA DOES NOT FIT IN THE GDOA THE ROUTINE MUST
*        OVERFLOW.  IF THE GDOA LENGTH IS 128 NO MORE BUFFER CAN
*        BE OBTAINED AND THE ROUTINE EXITS.  A CHECK IS MADE TO
*        SEE IF THE DATA CAN BE SPLIT BY COMPARING THE LENGTH TO
*        SIX.  IF THE DATA IS ABSOLUTE ORDERS THE MAXIMUM LENGTH
*        TO DATA STORE IS SIX.  IF IT IS INCREMENTAL ORDERS OR
*        TEXT THE DATA CAN BE SPLIT ON ANY HALF WORD BOUNDARY SO
*        AS MUCH AS POSSIBLE IS MOVED IN.
*
STR00300 CLC   GDSGDOAL,F128+2
         BE    ERR2
         TM    GDSGRMOD,X'F0'      TEXT
         BM    STR00320
         C     REGA,SIX            CAN THE DATA BE SPLIT
         BNH   STR01000            NO
STR00320 L     REGB,OLP            LOAD THE OLP
         L     REGA,LENLEFT        LOAD THE LENGTH REMAINING
         LTR   REGA,REGA           ANY DATA SPACE LEFT
         BZ    STR03600            NO
         BCTR  REGA,0
         EX    REGA,MOVE           MOVE IN AS MUCH AS POSSIBLE
         LH    REGB,WRKLEN         LENGTH DESIRED
         LA    REGA,1(REGA)        RESET COUNT
         SR    REGB,REGA           LENGTH TO GO
         L     REGD,OLP
         AR    REGD,REGA
         ST    REGD,OLP            UPDATE OLP
         LA    REGC,WRKOUTPT(REGA) ADDR OF NEXT DATA
         A     REGA,LOGCURR
         ST    REGA,LOGCURR        UPDATE LOGICAL BUFFER ADDR
         EJECT
*
*        THE MAIN PART OF THE OVERFLOW ROUTINE IS ENTERED BY
*        LOADING THE RETURN ADDRESS IN REGISTER 14 SO THAT THE
*        PROGRAM WILL FALL THROUGH WHEN THE MAIN PORTION OF OVERFLOW
*        IS COMPLETE.  THE ENTRY POINTS WHICH BUILD INCLUDE/OMIT
*        STRUCTURES OR SEQUENCE OR SUBROUTINE STRUCTURES OR SUBROUTINE
*        LINKAGE OR THE ENTRY FOR JUST OVERFLOW WILL USE THIS PORTION
*        OF THE PROGRAM TO PROVIDE THEIR OVERFLOW FUNCTIONS ALSO.
         SPACE
STR00330 LA    RETURN,STR00550     SET TO FALL THROUGH
         SPACE 3
*
*        IF THIS IS A UPDATE OVERFLOW THE ROUTINE FREES THE STORAGE
*        FOR THE UPDATE AND RETURNS A RETURN CODE TO THE CALLING
*        PROGRAM AS WELL AS PLACING ONE IN THE RETURN ARRAY.  IF
*        THIS IS AN EQUIVALINCE GRAPHIC DATA SET THE RETURN CODE
*        IS PLACED IN THE RETURN ARRAY AND A RETURN CODE IS ALSO
*        RETURNED TO THE CALLING PROGRAM.
         SPACE
STR00350 TM    STATUS,UPDT         UPDATE OVERFLOW
         BO    STR00520            YES
         TM    GDSFLAGS,EQUIV      IS THIS AN EQUIV
         BO    ERR2                YES NO MORE BUFFER CAN BE OBTAINED
         EJECT
*
*        IF THE CALL WAS TO OVERFLOW ONLY THE GTRU TO THE NEXT
*        BUFFER SEGMENT IS ALREADY IN THE GDOA AND ORGEN HAS ALREADY
*        OBTAINED THE NEXT BUFFER SEGMENT SO THIS PORTION OF THE
*        OVERFLOW ROUTINE IS BYPASSED.  OTHERWISE A GTRU IS MOVED
*        INTO THE GDOA AND BUFFER IS OBTAINED.  THE BUFFER ADDRESS
*        OBTAINED IS PLACED IN THE GTRU ORDER.
         SPACE 2
         TM    WRKFLAGS,BFROVFLW   IS BUFFER REQUIRED FOR OVERFL A27472
         BM    STR00370               IF YES, GET NEXT SEGMENT   A27472
         L     REGD,OLP            LOAD THE OLP
         MVC   0(2,REGD),GTRU      MOVE IN GTRU TO NEXT SEGMENT
         MVC   WRKPRLST,THREE      CODE FOR ADDL BUFFER
         ST    GDSREG,WRKPRLST+4   GDSCB IN AREA
         LA    REGA,WRKPRLST
         ST    REGA,WRKPRM
         LA    PARM,WRKPRM
         ST    RETURN,WRKTEMP
*//      CALL  BUFFER MGT          GET BUFFER
         L     REGA,STAT(ERRCD)    ADDRESS OF STATUS TABLE
         L     REGFIFTN,BMGT(REGA) ADDR OF BUFFER MTGT
         BALR  RETURN,REGFIFTN     BRANCH TO BUFFER MANAGEMENT
         LTR   REGFIFTN,REGFIFTN   SUCCESSFUL
         BNE   ERR01               NO, RETURN                    A33271
         L     RETURN,WRKTEMP
         ST    PARM,WRKBUFR        SAVE BUFFER ADDR
         STH   PARM,2(REGD)        STORE BUFFER ADDR IN PREV GDOA
         EJECT
*
*        HERE WE PICK UP THE OVERFLOW ONLY PATH AGAIN AS WELL AS
*        THE OTHERS AND WE DETERMINE IF THERE ARE ANY UNRESOLVED
*        ADDRESSES IN THE GDOA.  IF THERE ARE THE ASSOCIATED BUFFER
*        ADDRESS IS COMPUTED AND THE CPU ADDRESS IS ZEROED AND THE
*        BUFFER ADDRESS IS SET IN THE OACB.
STR00370 CLC   CPU1,ZERO           ANY UNRES ADDR IN GDOA
         BE    STR00390           CK IF CPU2 STILL UNRESOLVED      9293
         L     REGA,CPU1           PICK UP CPU ADDR
         S     REGA,CRSA           SUBTRACT TO FIND DISP FROM TOP
         A     REGA,BUFSTART       ADD BUFFER START
         ST    REGA,BUF1           SAVE BUFFER ADDR FOR RESOLUTION
         MVC   CPU1,ZERO           SET CPU TO ZERO
STR00390 CLC   CPU2,ZERO          ANOTHER UNRES                    9293
         BE    STR00400            NO
         L     REGA,CPU2           PICK UP CPU
         S     REGA,CRSA           FIND DIS
         A     REGA,BUFSTART       ADD BUFFER START
         ST    REGA,BUF2           SAVE BUFFER ADDR
         MVC   CPU2,ZERO           SET CPU TO ZERO
         EJECT
*
*        NOW WE ARE READY TO WRITE THE DATA OUT.  IF FOUR BYTES OF
*        DATA MUST BE SAVED IN THE GDSCB (THESE FOUR BYTES WILL
*        BE WRITTEN OUT AT EXEC TIME TO OVERLAY THE PREVIOUS GTRU
*        TO FLOW CONTROL AND THE DATA GENERATED SINCE THE LAST
*        EXEC WILL THEN APPEAR)  THEY ARE PLACED THERE AND THE
*        START OF THE GDOA AND THE BUFFER ADDRESS WILL BY UPDATED
*        BY FOUR.
STR00400 L     REGA,GTMDECB1
         LR    PARM,REGA
         L     REGE,BUFLEN         LENGTH
         TM    STATUS,SAVEFOUR     MUST FOUR BE SAVED IN GDS
         BO    STR00700
         L     REGD,CRSA
         EJECT
*        THE PREVIOUS I/O OPERATION IS WAITED ON THEN THE GDOA IS
*        WRITTEN OUT TO THE 2250 BUFFER.
STR00500 WAIT  ECB=(1)
         ST    REGE,LEN(REGA)       MACRO REQUIRES INTEGER
         L     REGE,GTMGRDCB
         ST    RETURN,WRKTEMP
         LR    PARM,REGA
         CLI   0(PARM),X'7F'
         BNE   ERR3
         NI    0(PARM),X'BF'
         GWRITE (PARM),STR,(REGE),,(REGD),BUFSTART+2,GDSFCBUF,MF=E
         LTR   REGFIFTN,REGFIFTN   WAS I/O START SUCCESSFUL        000B
         BNZ   ERR3                  IF NO, USE I/O ERROR CODE     000B
         L     RETURN,WRKTEMP      RESET RETURN REGISTER
         EJECT
*
*        THE NEXT OACB/GDOA WILL BE INITIALIZED BY DUPLICATING
*        THE STATUS, SETTING THE LOGICAL CURRENT AND LOGICAL
*        START ADDRESS TO THE LOGICAL CURRENT ADDRESS IN THIS
*        GDOA/OACB, SETTING THE BUFFER LENGTH TO THE GDOA LENGTH
*        AND SETTING THE OLP AND CRSA ADDRESSES TO THE GDOA
*        ADDRESS.  THE BUFFER OBTAINED WILL BE PLACED IN THE
*        BUFFER START FIELD.  IF THE ENTRY WAS FOR OVERFLOW ONLY
*        IT WILL EXIT THE OVERFLOW PORTION HERE.
STR00505 L     REGA,OTHER          PICK UP OTHER OACB
         L     ERRCD,WRKRTNCD      RESET ERROR REG
         MVC   STAT1(4,REGA),STATUS     SAVE STATUS
         MVC   LOGCURR1(4,REGA),LOGCURR LOG CURRENT
         MVC   LOGSTRT1(4,REGA),LOGCURR LOG START
         LH    REGD,GDSGDOAL            LENGTH
         ST    REGD,BUFLN1(REGA)   IN OACB
         S     REGD,SIX            FOR OVERHEAD BYTES
         ST    REGD,LENLFT1(REGA)       IN LENGTH LEFT
         MVC   CPU3(16,REGA),CPU1       UNRES ADDRS
         LR    OACB,REGA                RESET DSECT
         L     REGA,GDOA           SET UP
         ST    REGA,OLP            OLP
         ST    REGA,CRSA           CRSA
         MVC   BUFSTART,WRKBUFR
         MVC   BLP,WRKBUFR
         TM    WRKFLAGS,OVERFLOW   OVERFLOW ONLY
         BZ    STR00510            NO
         BR    RETURN              YES, RETURN
         EJECT
*
*        THE CURRENT MODE SETTING IS DETERMINED AND THAT ORDER IS
*        MOVED INTO THE FIRST TWO BYTES OF THE GDOA.
STR00510 LA    REGD,CHRBP          ADDR OF LIST OF ORDERS PT TO CHAR BP
         TM    GDSGRMOD,CBP        IS IT CHAR BASIC PROT
         BO    STR00600            YES
         LA    REGD,2(REGD)        NO, POINT TO CLP
         TM    GDSGRMOD,CLP        CHAR LGE PROT
         BO    STR00600            YES
         LA    REGD,2(REGD)        NO, POINT TO CBU
         TM    GDSGRMOD,CBU        CHAR BASIC UNPROT
         BO    STR00600            YES
         LA    REGD,2(REGD)        NO, POINT TO CLU
         TM    GDSGRMOD,CLU        CHAR LGE UNPROT
         BO    STR00600            YES
         LA    REGD,2(REGD)        NO POINT TO VA
         TM    GDSGRMOD,VA         VECT ABS
         BO    STR00600            YES
         LA    REGD,2(REGD)        NO PT TO VI
         TM    GDSGRMOD,VI         VECT INCR
         BO    STR00600            YES
         LA    REGD,2(REGD)        NO POINT TO PA
         TM    GDSGRMOD,PA         POINT ABS
         BO    STR00600            YES
         LA    REGD,2(REGD)        NO, POINT TO PI
         TM    GDSGRMOD,PI         POINT INCR
         BO    STR00600            YES
         LA    REGD,2(REGD)        NO, POINT TO NO OP
         B     STR00600            STORE GNOP
STR00520 LR    REGD,OACB           SAVE OLD OACB
         L     REGA,OLP            LOCATION OF GTRU TO NEXT SEG
         L     OACB,OTHER          GET NEXT ON CHAIN
         LTR   OACB,OACB           ANY MORE
         BZ    ERR2A               NO, UPDATE OVERFLOW
         MVC   0(2,REGA),GTRU      MOVE IN GTRU
         MVC   2(2,REGA),BUFSTART+2 MOVE IN ADDR
         MVC   CPU2,40(REGD)       SAVE CPU ADDR OF UNRES LOC
         L     REGA,GDOA           GET NEXT
         B     STR00510
         EJECT
*
*        HERER THE DATA IS MOVED INTO THE BUFFER AND THE FIELDS ARE
*        UPDATED AND THE ROUTINE RETURNS TO THE CALLING PROGRAM.
STR00550 BCTR  REGB,0              REDUCE LENGTH BY ONE
         EX    REGB,MOVE1          MOVE DATA IN OUTPUT AREA
         LA    REGB,ONE(REGB)
         L     REGD,LOGCURR
         AR    REGD,REGB
         ST    REGD,LOGCURR        UPDATE LOGICAL CURRENT
         L     REGD,LENLEFT        LENGTH LEFT
         SR    REGD,REGB           REDUCE BY DATA LENGTH
         ST    REGD,LENLEFT
         LA    REGB,2(REGB)        ADD LENGTH OF SET MODE
         AR    REGB,REGA           ADD GDOA START
         ST    REGB,OLP            IN ORDER LOAD PT
         B     STR00200            EXIT
*
*        HERE THE OVERFLOW ROUTINE PLACES THE ORDER IN THE GDOA.
*        AND RETURNS TO THE PORTION OF DATA STORE AS NEEDED BY
*        THE INPUT.
STR00600 MVC   0(2,REGA),0(REGD)   MOVE IN ORDER TO RESET MODE
         ST    OACB,GDSAOACB       RESET OACB ADDR IN GDSCB
         BR    RETURN
*
*        THIS PORTION MOVES THE DATA INTO THE GDSCB IF ON OVERFLOW
*        IT WAS REQUIRED.  IT CHECKS TO SEE IF ANY DATA NEEDS TO
*        BE WRITTEN AFTER THE FOUR BYTES HAVE BEEN SAVED.  IF NOT
*        IT BYPASSES THE WRITE ON THE RETURN.
STR00700 S     REGE,FOUR           REDUCE LENGTH BY FOUR
         L     REGD,BUFSTART
         STH   REGD,GDSREPPB       SAVE IN GDS
         A     REGD,FOUR
         ST    REGD,BUFSTART       NEW BUFFER START
         L     REGD,CRSA
         MVC   GDSREPDT,0(REGD)    SAVE REPL DATA
         XI    STATUS,SAVEFOUR     TURN OFF SW
         A     REGD,FOUR           NEW WRITE ADDR
         LTR   REGE,REGE           IS LENGTH ZERO
         BZ    STR00505            IYES DO NOT WRITE
         B     STR00500
         EJECT
*
*        THIS PORTION OF THE DATA STORE ROUTINE OBTAINS THE BUFFER
*        AND THE FLOW CONTROL ENTRY WHEN A DATA GENERATION ROUTINE HAS
*        BEEN CALLED FOR THE FIRST TIME.  IT DETERMINES THE LENGTH OF
*        BUFFER REQUIRED AND OBTAINS IT FROM BUFFER MANAGEMENT.  THEN
*        IT CALLS FLOW CONTROL MANAGEMENT FOR A FLOW CONTROL ENTRY.
STR00800 LA    REGA,ONE            CODE FOR 128 SEGMENT
         LH    REGB,GDSGDOAL
         C     REGB,F128           IS 128 DESIRED
         BNH   STR00900            YES
         LA    REGA,ONE(REGA)      CODE FOR 256 MULTIPLE
         ST    REGB,WRKPRLST+8     LENGTH IN LIST
STR00900 ST    REGA,WRKPRLST       CODE IN LIST
         ST    GDSREG,WRKPRLST+4   GDSCB IN LIST
         LA    REGA,WRKPRLST
         ST    REGA,WRKPRM
         LA    PARM,WRKPRM
*//
*//      CALL BUFFER MGT
*//
         L     REGB,STAT(ERRCD)    ADDR OF STATUS TABLE
         L     REGFIFTN,BMGT(REGB) ADDR OF BUFFER MGT
         BALR  RETURN,REGFIFTN     BRANCH TO BUFFER MGT
         LTR   REGFIFTN,REGFIFTN   AVAILABLE
         BNE   ERR1                NO EXIT
         LR    REGA,PARM           SAVE BUFFER ADDR
         ST    PARM,WRKPRLST+8     ADDR FOR FLOW CTL
         MVC   WRKPRLST,TWO        CODE TO ADD FLOW CTL ENTRY
         LA    PARM,WRKPRM
*//
*//      CALL FLOW CONTROL MANAGEMENT
         LINK  EP=IFFAHA01
         LTR   REGFIFTN,REGFIFTN
         BNE   ERR1A               FREE BUFFER AND EXIT
         EJECT
*
*        IF SLPAT HAS BEEN CALLED BEFORE A CALL TO A DATA GENERATION
*        ROUTINE AND HAS CHANGED THE PEN MODE TO PERMIT THE PERMIT
*        ORDER IS WRITTEN OUT TO THE FLOW CONTROL ENTRY AT THIS TIME.
*
         TM    GDSFLAGS,PERMIT     IS PEN MODE PERMIT
         BZ    STR00920            NO, NO ORDER NEED BE WRITTEN
         LA    REGB,GESD           ADDR OF ORDER
         L     REGC,GTMGRDCB       ADDR OF DCB
         L     PARM,GTMDECB1       ADDR OF DECB
         WAIT  ECB=(1)             WAIT ON I/O
         L     PARM,GTMDECB1       ADDR OF DECB
         CLI   0(PARM),X'7F'
         BNE   ERR3
         NI    0(PARM),X'BF'
         GWRITE (PARM),STR,(REGC),2,(REGB),GDSFCBUF,GDSFCBUF,MF=E
         LTR   REGFIFTN,REGFIFTN   WAS I/O START SUCCESSFUL        000B
         BNZ   ERR3                  IF NO, USE I/O ERROR CODE     000B
         EJECT
*
*        THIS INLINE SUBROUTINE TURNS OFF THE BUFFER REQUIRED FLAG
*        AND SETS THE SAVE FOUR FLAG.
*
STR00920 LA    RETURN,STR00950     SET TO FALL THROUGH
STR00930 ST    REGA,BUFSTART       SAVE BUFFER ADDR
         ST    REGA,BLP            SAVE BUFFER LOAD PT
         NI    STATUS,BUFACQ       TURN OFF BUFFER REQ SW
         OI    STATUS,SAVEFOUR     SAY ON OVERFLOW TO SAVE FOUR BYTES
         BR    RETURN              RETURN
*
*        IF THIS IS AN EQUIVALENCE GRAPHIC DATA SET ALL OTHER
*        EQUIVALENCE GRAPHIC DATA SETS MUST BE SET UP TO SHOW THAT
*        BUFFER HAD BEEN OBTAINED, WHERE THE BUFFER IS AND WHAT
*        THE FLOW CONTROL ENTRY IS.
STR00950 TM    GDSFLAGS,EQUIV      IS IT EQUIV
         BZ    STR00100            NO
         LR    REGB,GDSREG         SAVE GDS ADDR
         LR    REGC,OACB           SAVE OACB ADDR
         L     REGD,GDSSHDFD       PICK UP SHARED FOREWARD FLAG
         L     REGZERO,GDSOVDAT    PICK UP FLOW CONTROL DATA
         LH    PARM,GDSFCBUF
         LH    REGFIFTN,GDSBCTEL   BUFFER CONTROL TABLE ELEMENT
         MVC   WRKTEMP(1),GDSBCTID
STR00960 L     GDSREG,GDSSHDBK     LOAC WITH SHARED BACK
         LTR   GDSREG,GDSREG       ALL BACK PTRS DONE
         BZ    STR00970            YES
         L     OACB,GDSAOACB       PICK UP OACB
         ST    REGZERO,GDSOVDAT    STORE IN EQUIV
         STH   PARM,GDSFCBUF
         STH   REGFIFTN,GDSBCTEL   BUFFER CONTROL TABLE ELEMENT
         MVC   GDSBCTID(1),WRKTEMP
         BAL   RETURN,STR00930     GO DET FLAGS AND SAVE BUFFER ADDR
         B     STR00960            GO TO NEXT
STR00970 LR    GDSREG,REGD         PICK UP FOREWARD FLAGS
STR00980 LTR   GDSREG,GDSREG       ALL FOREWARD DONE
         BZ    STR00990            YES
         L     OACB,GDSAOACB       GET OACB
         ST    REGZERO,GDSOVDAT    STORE IN EQUIV
         STH   PARM,GDSFCBUF
         STH   REGFIFTN,GDSBCTEL
         MVC   GDSBCTID(1),WRKTEMP
         BAL   RETURN,STR00930     GO SET FLAGS AND SAVE BUFFER ADDR
         L     GDSREG,GDSSHDFD     GET NEXT
         B     STR00980
STR00990 LR    GDSREG,REGB         RESET GDSCB
         LR    OACB,REGC           RESET OACB
         B     STR00100
         EJECT
*
*        THIS SECTION OF DATA DETERMINES IF THERE IS ANY
*        ROOM LEFT IN THE GDOA WHEN OVERFLOW WAS REQUIRED AND THE
*        DATA IS NOT TO BE SPLIT UP.  A GNOP ORDER IS PLACED IN THE
*        GDOA AND ANY REMAINING AREA IS ZEROED OUT.
STR01000 L     REGA,LENLEFT        LOAD THE LENGTH LEFT
         LTR   REGA,REGA           ANY ROOM LEFT
         BE    STR03600            NO
         BCTR  REGA,0              REDUCE LENGTH FOR EXECUTE
         L     REGB,OLP            ADDRESS OF OLP
         EX    REGA,ZEROOU         ZERO IT OUT
         MVC   0(2,REGB),GNOP2     MOVE IN NOP AT START
         LA    REGA,1(REGA)        ADD LENGTH TO RESET
         AR    REGB,REGA           ADD LENGTH TO OLP
         ST    REGB,OLP            STORE BACK
         A     REGA,LOGCURR        UPDATE LOGICAL CURRENT ADDR
         ST    REGA,LOGCURR        LOGICAL CURRENT
         B     STR03600
         EJECT
*
*        AT THIS LOCATION THE INPUT FLAGS ARE CHECKED TO DETERMINE WHAT
*        SPECIAL SERVICE IS DESIRED.
STR01100 TM    WRKFLAGS,RESOLVE    RESOLVING ADDR
         BO    STR01300            YES
STR01200 TM    WRKFLAGS,CONTUNRE   CONTAIN UNRES ADDR
         BO    STR02200
         TM    WRKFLAGS,BEGSUB     BEGIN SUBR LINKAGE
         BO    STR02600
         TM    WRKFLAGS,BUFSUB     BUFSUB LINKAGE
         BO    STR03100
         TM    WRKFLAGS,OVERFLOW   OVERFLOW ONLY
         BZ    STR00200            NO
         BAL   RETURN,STR00350     OVERFLOW
         ST    OACB,GDSAOACB       RESET GDSCB
         B     STR00200            EXIT
         EJECT
*
*        THIS ENTRY IS MADE TO RESOLVE AN UNRESOLVED ADDRESS.  IT
*        MAY BE MADE NO DATA TO BE PLACED IN THE GDOA IN WHICH
*        CASE THE ADDRESS IS RESOLVED TO THE CURRENT ADDRESS OR
*        IT MAY BE MADE WITH A GTRU THAT CONTAINS AN UNRESOLVED
*        ADDRESS AS WELL IN WHICH CASE THE ADDRESS IS RESOLVED
*        TO THE CURRENT LOCATION PLUS FOUR.  THE ADDRESSES ARE
*        RESOLVED IN A LAST IN FIRST OUT METHOD THEREFORE THE
*        LOCATIONS CPU2, BUF2 ARE CHECKED FOR AN ADDRESS FIRST.
*        NOTE THAT IF THE ADDRESS MUST BE RESOLVED TO THE CURRENT
*        LOCATION PLUS FOUR A CHECK IS MADE TO SEE IF THERE ARE
*        AT LEAST FOUR BYTES IN THE GDOA AND IF NOT THE ROUTINE
*        WILL OVERFLOW FIRST.
*
STR01300 L     REGB,OLP            PICK UP ORDER LOAD PT
         TM    WRKFLAGS,CONTUNRE   UNRES ALSO
         BZ    STR01500            NO, RESOLVE TO CURRENT
         CLC   LENLEFT,FOUR
         BL    STR02100            ENOUGH SPACE TO FIT
STR01400 LA    REGB,4(REGB)        POSITION TO END OF GTRU
*
*        THE RESOLVING ADDRESS IS COMPUTED.  IF IT IS TO BE PLACED
*        IN THE CPU IT IS MOVED IN AND THE ADDRESS IS ZEROED OUT.
*        IF IT IS TO BE PLACED IN THE BUFFER IT IS WRITTEN OUT
*        TO THE BUFFER AND THE ADDRESS IN THE OACB IS THEN ZEROED OUT.
STR01500 S     REGB,CRSA           DISP FROM TOP
         A     REGB,BUFSTART       ADDR TO RESOLVE WITH
         CLC   CPU2(8),ZERO        IS THERE A SECOND ADDR
         BZ    STR01600            NO
         CLC   CPU2,ZERO           IN CPU
         BE    STR01700            NO
         L     REGA,CPU2           WHERE TO BE RESOLVED
         STH   REGB,0(REGA)        RESOLVE IT
         MVC   CPU2(8),ZERO        ZERO IT OUT
         B     STR01200
STR01600 CLC   CPU1,ZERO           IN CPU
         BE    STR01800            NO
         L     REGA,CPU1           WHERE TO BE RESOLVED
         STH   REGB,0(REGA)        RESOLVE IT
         MVC   CPU1(8),ZERO        ZERO OUT
         B     STR01200
STR01700 LA    REGA,BUF2+2         ADDR WHERE
         B     STR01900
         EJECT
STR01750 STH   REGB,0(REGD)        STORE RESOLVING ADDR IN REP DATA
         XC    0(2,REGA),0(REGA)   ZERO OUT ADDR
         B     STR02000            CONTINUE
STR01800 LA    REGA,BUF1+2         ADDR WHERE
*
*        IF THE ADDRESS IS TO BE PLACED IN THE BUFFER A CHECK IS
*        MADE TO SEE IF IT HAPPENS TO BE IN THE GDSCB INSTEAD OF
*        IN THE BUFFER ALREADY.  IF YES IT IS PLACED IN THE GDSCB.
*        OTHERWISE IT IS WRITTEN OUT.
STR01900 LH    REGC,GDSREPPB       GET BUFFER ADDR OF REPLACEMENT DAT
         CLC   GDSREPDT,ZERO       IS IT ZERO
         BE    STR01920            YES
         LA    REGD,GDSREPDT       ADDR OF REP DATA IN GDSCB
         CH    REGC,0(REGA)        IS IT IN THE FIRST HALF
         BE    STR01750            YES
         LA    REGD,2(REGD)        UPDATE TO SECOND HALF
         LA    REGC,2(REGC)        UPDATE ADDR BY TWO
         CH    REGC,0(REGA)        IS IT IN THE SECDOND HALF
         BE    STR01750            YES
STR01920 L     REGC,OTHER
         L     REGC,GDOA1(REGC)    ADDR OF OTHER GDOA
         L     PARM,GTMDECB1      GET GSP DECB FOR I/O           A35620
         WAIT ECB=(1)             WAIT ON OVERLAPPED I/O         A35620
         STH   REGB,0(REGC)        PLACE ADDR IN OTHER GDOA
         MVC   2(2,REGC),0(REGA)   MOVE BUFFER ADDR TO A SAFE PLACE
         XC    0(2,REGA),0(REGA)
         LA    REGA,2(REGC)
         L     PARM,GTMDECB1       DECB
         CLI   0(PARM),X'7F'
         BNE   ERR3
         EJECT
         NI    0(PARM),X'BF'
         L     REGD,GTMGRDCB
         GWRITE (PARM),STR,(REGD),2,(REGC),(REGA),GDSFCBUF,MF=E
         LTR   REGFIFTN,REGFIFTN   WAS I/O START SUCCESSFUL        000B
         BNZ   ERR3                  IF NO, USE I/O ERROR CODE     000B
STR02000 CLC   WRKLEN,ZERO         ANY DATA TO BE GENERATED
         BE    STR00200            NO EXIT
         B     STR01200
STR02100 L     REGD,OLP            PICK UP OLP
         CLC   LENLEFT,ZERO
         BE    STR02150
         MVC   0(2,REGD),GNOP2     MOVE IN A NO OP IN REMAIN 2 BYTES
         LA    REGD,2(REGD)        POSITION TO GTRU
         ST    REGD,OLP            STORE OLP                       4743
         L     REGD,LOGCURR                                        4743
         A     REGD,TWO            UPDATE LOGICAL ADDR             4743
         ST    REGD,LOGCURR                                        4743
STR02150 BAL   RETURN,STR00350          GO OVERFLOW
         L     REGB,OLP            RETURN TO ADDR SOLUTION
         MVC   0(2,REGB),GNOP2                                     4743
         LA    REGB,2(REGB)         RESET MODE IS A NOOP           4743
         ST    REGB,OLP                                            4743
         B     STR01400
         EJECT
*
*        IF THE DATA TO BE GENERATED CONATINS AN UNRESOLVED ADDRESS
*        ITS LENGTH IS FOUR BYTES.  A CHECK IS MADE TO SEE IF THERE
*        ARE FOUR BYTES LEFT IN THE BUFFER.  IF NOT, IT WILL OVERFLOW.
*        OTHERWISE AN UNRESOLVED ADDRESS NOTATION IS SET UP IN THE
*        OACB FOR THIS ADDRESS AND THEN THE ROUTINE BRANCHES TO
*        THAT PORTION OF DATA STORE THAT WILL PLACE THE ORDER IN
*        THE GDOA.
*
STR02200 CLC   LENLEFT,FOUR        LENGTH LEFT GREATER THAN 2
         BL    STR02500            NO
STR02300 L     REGD,OLP            LOAD OLP
         LA    REGD,2(REGD)        GET CPU ADDR OF ADDR TO BE RESOLVED
         CLC   CPU1(8),ZERO        CPU1 IN USE
         BNE   STR02400            YES
         ST    REGD,CPU1           NO SAVE ADDR
         B     STR00150            GO STORE DATA
STR02400 ST    REGD,CPU2           PLACE IN CPU2
         B     STR00150            GO STORE DATA
         EJECT
*
*        THIS SECTION WILL TAKE CARE OF OVERFLOW FOR THE SPECIAL
*        CASES.  A CHECK IS MADE TO SEE IF THERE IS ANY ROOM LEFT
*        IN THE GDOA.  IF SO IT WILL MOVE IN A GNOP AND POSITION
*        TO THE GTRU WHICH IS TO BE PLACED IN THE GDOA BY THE
*        OVERFLOW ROUTINE.
STR02500 CLC   LENLEFT,ZERO        ANY LENGTH LEFT
         BE    STR02550            NO
         L     REGD,OLP            PI K UP OLP
         MVC   0(2,REGD),GNOP2     PLACE NO OP IN REMAINING 2 BYTES
         LA    REGD,2(REGD)        POSITION TO GTRU
         ST    REGD,OLP            RETURN TO OLP
         L     REGD,LOGCURR        PICK UP LOGICAL CURRANT
         A     REGD,TWO            ADD TWO FOR NOP
         ST    REGD,LOGCURR        RETURN TO LOGICAL CURRENT
STR02550 BAL   RETURN,STR00350     GO GET NEW BUFFER
         L     REGD,OLP            ADDR OF OLP
         MVC   0(2,REGD),GNOP2     MOVE IN NOP TO CONTROL
         LA    REGD,2(REGD)        ADDRESS OF OLP UPDATED
         ST    REGD,OLP            STORE IN OLP
         B     STR02300            GO TO HANDLE UNRES ADDR
         EJECT
*
*        THIS PART OF THE PROGRAM PUTS OUT THE BGSUB LINKAGE.
*        IF IT WILL NOT FIT IT WILL OVERFLOW FIRST, OTHERWISE THE
*        LOCATION OF THE UNRESOLVED ADDRESS IS NOTED.  THE BRANCHES
*        WITHIN THEMSELVES ARE COMPUTED AND STORED IN THE INPUT AREA
*        FROM THE CALLING ROUTINE AND THEN THE STORE PORTION OF
*        THIS PROGRAM WILL PLACE THE ORDERS IN THE GDOA.
*
STR02600 CLC   LENLEFT,FRTN        FIT IN OUT AREA
         BL    STR02800            NO MAYBE NO
STR02700 L     REGD,OLP
         LA    REGD,2(REGD)
         ST    REGD,CPU1           UNRES CPU ADDR SAVED
         TM    WRKFLAGS,INCL       IS INCLUDE OMIT STRUCTURE PRESENT
         BZ    STR00150            NO, GO STORE DATA
         LA    REGD,2(REGD)        UPDATE TO RESOLVING ADDR OF
*                                  FUTURE GTRU
         S     REGD,CRSA
         A     REGD,BUFSTART       ADDR USED TO RESOLVE
         STH   REGD,WRKOUTPT+10    STORE IN OUTPUT
         B     STR00150            GO STORE DATA
STR02800 TM    WRKFLAGS,INCL       DO WE REALLY ONLY NEED 10
         BO    STR03000            NO, WE NEED 14
         CLC   LENLEFT,TEN         DO WE HAVE TEN AT LEAST
         BNL   STR02700            YES
STR03000 LA    REGB,STR02700
*
*        HERE IF OVERFLOW IS NECESSARY THE GDOA IS ZEROED AND
*        A GNOP MOVED IN BEFORE GOING TO THE OVERFLOW ROUTINE.
STR02900 CLC   LENLEFT,ZERO        ANY LENGTH LEFT
         BE    STR02950            NO
         L     REGC,LENLEFT        POCK UP LENGTH LEFT
         BCTR  REGC,0              REDUCE BY 1
         L     REGD,OLP            PICK UP OLP
         EX    REGC,ZEROOUT        ZERO OUT TO NULL UP TO TRANS ORD
         MVC   0(2,REGD),GNOP2     MOVE IN A NO OP
         A     REGD,LENLEFT        POSITION TO GTRU
         ST    REGD,OLP            RESTORE LLP
         L     REGD,LOGCURR        LOCICAL CURR
         A     REGD,LENLEFT        ADD LENGTH LEFT
         ST    REGD,LOGCURR        STORE
STR02950 BAL   RETURN,STR00350     GO GET NEW BUFFER
         L     REGD,OLP            ADDR OF OLP
         MVC   0(2,REGD),GNOP2     MOVE IN NOP TO CONTROL
         LA    REGD,2(REGD)        ADDRESS OF OLP UPDATED
         ST    REGD,OLP            STORE IN OLP
         BR    REGB
         EJECT
*
*        THIS ENTRY IS MADE TO GENERATE A SUBROUTINE LINKAGE.  IF
*        IT WILL NOT FIT IN THE GDOA THE ROUTINE WILL OVERFLOW
*        FIRST.  OTHERWISE THE TRANSFERS ARE RESOLVED AND THE
*        ROUTINE GOES TO THE STORE PORTION OF THE PROGRAM.
*
STR03100 CLC   LENLEFT,SXTN        SIXTEEN OR MORE LEFT
         BL    STR03400            NO
STR03200 L     REGC,OLP
         LA    REGC,10(REGC)       ADDR WHICH WILL RESOLVE IF NO INCLUD
         S     REGC,CRSA
         A     REGC,BUFSTART
         TM    WRKFLAGS,INCL       INCLUDE STRUCTURE
         BO    STR03300            YES
         STH   REGC,WRKOUTPT+4     RESOLVE ADDR
         B     STR00150            GO TO STORE DATA
STR03300 LA    REGC,4(REGC)        LENGTH TO END 4 GR WITH INCL/OMIT
         STH   REGC,WRKOUTPT+2     RESOLVE ADDR IN INCL/OMIT
         STH   REGC,WRKOUTPT+8     RESOLVE ADDR IN OTHER
         B     STR00150            GO TO STORE DATA
STR03400 TM    WRKFLAGS,INCL       INCLUDE
         BO    STR03500            NO
         CLC   LENLEFT,TWLV        MORE THAN 12
         BNL   STR03200            YES
STR03500 LA    REGB,STR03200       GO GET BUFFER
         B     STR02900
STR03600 LA    REGC,WRKOUTPT       OUTPUT ADDRESS
         LH    REGB,WRKLEN         PICK UP ENTIRE LENGTH IN REGISTER
         B     STR00330
         EJECT
ERR01    SR    REGZERO,REGZERO     SET LENGTH TO ZERO            A33271
         ST    REGZERO,LENLEFT                                   A33271
ERR1     OI    0(ERRCD),STORAGE    SET STORAGE EXCEED FLAG       A33271
         MVC   STOR(4,ERRCD),THREE  BUFFER
ERREXIT  LA    REGFIFTN,CODE8      RETURN CODE TO CALLER         YM1963
         B     STR00205            RETURN TO CALLER              YM1963
ERR1A    LA    REGA,4
         CLC   GDSGDOAL,F128+2     128 SEGMENT, CODE OK
         BE    ERR1B
         LA    REGA,1(REGA)        CODE FOR IKL RELEASE
ERR1B    ST    REGA,WRKPRLST
         LA    PARM,WRKPRM
*//      CALL BUFFER MGT
         L     REGFIFTN,STAT(ERRCD)
         L     REGFIFTN,BMGT(REGFIFTN)
         BALR  RETURN,REGFIFTN
         B     ERREXIT             EXIT
ERR2A    LR    OACB,REGD           RESET OACB ADDR
         L     REGD,ORIG
         ST    REGD,GDSAOACB       RESET ORIG OACB
         L     REGZERO,BUF1        LENGTH FOR FREEMAIN
         L     PARM,CPU1           ADDR OF FREEMAIN
         FREEMAIN R,LV=(0),A=(1)   FREEMAIN OF CORE FROM UPDATE
         OI    0(ERRCD),STORAGE
         OI    STOR+3(ERRCD),ONE   UPDATE OVERFLOW
         B     ERREXIT
ERR2     OI    0(ERRCD),STORAGE    SET STORAGE EXCEEDED FLAG
         MVC   STOR(4,ERRCD),TWO   SELF DEFINED LIMIT EXCEEDED
         SR    REGZERO,REGZERO      SET LENGTH TO ZERO          OY02461
         ST    REGZERO,LENLEFT      STORE IN LENLEFT FIELD      OY02461
         B     ERREXIT
ERR3     L     ERRCD,WRKRTNCD
         OI    0(ERRCD),IO
         B     ERREXIT
         EJECT
* REGISTERS
REGZERO  EQU   0
PARM     EQU   1
REGA     EQU   2
REGB     EQU   3
REGC     EQU   4
WORK     EQU   5
ERRCD    EQU   6
*//*//*
*//*//*  CAUTION: REGE IS THE SAME REGISTER AS ERRCD
*//*//*  ERRCD WILL BE RESET AT STR00505
*//*//*
REGE     EQU   6         ///*** CAUTION--SAME REGISTER AS ERRCD
GTMREG   EQU   7
GDSREG   EQU   8
BASE     EQU   9
OACB     EQU   10
REGD     EQU   11
SAVE     EQU   13
RETURN   EQU   14
REGFIFTN EQU   15
CODE0    EQU   0                   RETURN CODE 0                 YM1963
CODE8    EQU   8                   RETURN CODE 8-GDOA FREED      YM1963
         EJECT
         GINIT
CHRBP    GECP  B                   D     R     T     P     R
CHRLP    GECP  L                    O     E     H     H     S
CHRBU    GECF  B                           O     E     I
CHRLU    GECF  L                      N     R     S     C
VABS     GEVM  A                       O     D     E
VINC     GEVI2                          T     E           O
PABS     GEPM  A                               R    G      R
PINC     GEPI2                                       R      D
GNOP2    GNOP2                                        A      E
GESD     GESD
         EJECT
CBP      EQU   X'80'               SWITCH SETTINGS FOR GDSGRMOD
CLP      EQU   X'40'
CBU      EQU   X'20'
CLU      EQU   X'10'
VA       EQU   X'08'
VI       EQU   X'04'
PA       EQU   X'02'
PI       EQU   X'01'
GDOA1    EQU   4
STAT1    EQU   8
CRSA1    EQU   12
OLP1     EQU   16
BLP1     EQU   20
BUFSTRT1 EQU   24
BUFLN1   EQU   28
CPU3     EQU   32
LOGSTRT1 EQU   48
LOGCURR1 EQU   52
LENLFT1  EQU   56
STOR     EQU   12
STORAGE  EQU   X'10'
UPDT     EQU   X'20'
         EJECT
MOVE1    MVC   2(1,REGA),0(REGC)
ZEROOUT  XC    0(1,REGD),0(REGD)
MOVE     MVC   0(1,REGB),WRKOUTPT
CONTUNRE EQU   X'01'
RESOLVE  EQU   X'02'
BEGSUB   EQU   X'04'
INCL     EQU   X'10'
BUFSUB   EQU   X'08'
NOBUF    EQU   X'80'
ONE      EQU   1
BUFACQ   EQU   X'7F'
SAVEFOUR EQU   X'40'
LEN      EQU   20
EQUIV    EQU   X'08'
CVTLINK  EQU   8
BMGT     EQU   816
STAT     EQU   24
CURSOR   EQU   X'20'
OVERFLOW EQU   X'20'
BFROVFLW EQU   X'60'         ORGEN REQUIRES BUFFER FOR OVERFLOW  A34801
PERMIT   EQU   X'01'
IO       EQU   X'04'
FOUR     DC    F'4'
ZERO     DC    2F'0'
TWO      DC    F'2'
F128     DC    F'128'
THREE    DC    F'3'
FRTN     DC    F'14'
SXTN     DC    F'16'
TEN      DC    F'10'
TWLV     DC    F'12'
GTRU     GTRU  0
SIX      DC    F'6'
ZEROOU   XC    0(1,REGB),0(REGB)   ZERO OUT AN AREA
         EJECT
WORKAREA DSECT
WRKGDS   DS    F
WRKRTNCD DS    F
WRKFLAGS DS    H
WRKLEN   DS    H
WRKOUTPT DS    9F
WRKSAVE  DS    18F
WRKSPVSR DS    3F
WRKTEMP  DS    F
WRKPRLST DS    4F
WRKBUFR  DS    F
WRKPRM   DS    F
WRKRTN   DS    F
         EJECT
OACBAREA DSECT
OTHER    DS    F
GDOA     DS    F
STATUS   DS    F
CRSA     DS    F
OLP      DS    F
BLP      DS    F
BUFSTART DS    F
BUFLEN   DS    F
CPU1     DS    F
BUF1     DS    F
CPU2     DS    F
BUF2     DS    F
LOGSTRT  DS    F
LOGCURR  DS    F
LENLEFT  DS    F
ORIG     DS    F
         COPY  GDSCB
         COPY  GTMCB
         COPY  GSPCB
         END
