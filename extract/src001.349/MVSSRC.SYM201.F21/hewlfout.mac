         TITLE    'HEWLFOUT  - INTERMEDIATE OUTPUT PROCESSOR'
*                                                                     *
*STATUS:CHANGE LEVEL                                                  *
*                                                                     *
*FUNCTION/OPERATION:                                                  *
*        1- OUTPUT THE COMPOSITE EXTERNAL SYMBOL DICTIONARY(EDITABLE) *
*        2- BUILDS HALF EXTERNAL SYMBOL DICTIONARY                    *
*        3- BUILDS AND OUTPUTS CONTROL RECORD AND SEGTAB (1ST TXT) WHEN
*              THE PROGRAM IS IN OVERLAY                              *
*        4- BUILDS AND OUTPUTS THE SCATTER/TRANSLATION RECORDS WHEN   *
*              THE PROGRAM IS IN SCATTER                              *
*        5- READS IN THE TEXT AND RLD NOTE LISTS                      *
*        6- DETERMINES THE CONTROL SECTIONS WITH THE HIGHEST ESD ID   *
*              PER SEGMENT                                            *
*        7) INITIALIZES FOR 2ND PASS - HEWLKSCD                       *
*           A - SET 2 DECBS TO COMPLETE STATUS                        *
*           B - COMPUTES END ADDRESSES FOR 3 RLD BUFFERS              *
*           C - SETS CONTROL INFORMATION (16 BYTES) TO ZERO  IN CONTROL
*               RECORD BUFFER                                         *
*           D - PASSES PARAMETERS IN 3 GENERAL PURPOSE REGISTERS      *
*           E - COMPUTES END OF HESD ADDRESS                          *
*           F - CONVERTS TXTIO TABLE CURRENT NO.BYTES TO NO. OF ENTRYS*
*           G - SETS TTR LIST TO ZERO
*
*ENTRY POINT  HEWLFOUT - CONTROL SECTION NAME                         *
*                                                                     *
*INPUT:  TABLES - LISTED BELOW                                        *
*                                                                     *
*OUTPUT: TABLES - LISTED BELOW                                        *
*                                                                     *
*EXTERNAL ROUTINES: HEWLFLOG - ERROR DIAGNOSTIC ROUTINE               *
*                                                                     *
*EXITS - NORMAL   HEWLFSCD - SECOND PASS PROCESSOR                    *
*                                                                     *
*        ERRORS   HEWLFFNL - FINAL PROCESSOR - WHEN THERE IS NO TEXT IN
*              THE OUTPUT LOAD MODULE THE SECOND PASS IS BY PASSED    *
*TABLES/WORK AREA:                                                    *
*                                                                     *
*        1- ALL PURPOSE TABLE                                         *
*        2- COMPOSITE EXTERNAL SYMBOL DICTIONARY                      *
*        3- RELOCATION CONSTANT TABLE                                 *
*        4- SEGMENT TABLE ONE                                         *
*        5- TEXT NOTE LIST 1 AND 2                                    *
*        6- RLD  NOTE LIST 1 AND 2                                    *
*        7- SCATTER AND TRANSLATION TABLES                            *
*        8- HALF EXTERNAL DICTIONARY                                  *
*                                                                     *
*ATTRIBUTES:                                                          *
*                                                                     *
*NOTES:                                                               *
*                                                                     *
*                                                                     *
HEWLFOUT CSECT
***********************************************************************
*086800-105000,114100-163100,198800-195500,200900-201600         S21026
*210000-211400,622300-947800                                     S21026
*231700-289800,301700-303800,307300,308100,378700-382900         S01904
*392000,393400,406000,420000-425600                              S01904
*A375900,D423500,C425600                                        OX00029
*C308700,A309200,D634200-635600,A635400-635500,D716100-717500,   XM5480
*A718000-718100,D720300-721700,A721800-722300                    XM5480
*C277200-277900                                                  YM4013
*A718000-718100,740200-786200,A930100                           0X04245
*        REFER TO FIX FOR XM5480                        OX03509,OY03049
* D221900-226100,I298000,C300300                                 XM6065
* A604100,I299600                                                XM9089
* C914200                                                       ZA01402
* C566500                                                      @ZA07600
* A747910,747920 PREVENT ABEND0C4 WITH INCORRECT XLATOR IDR    @ZA17975
*
         EJECT
***********************************************************************
*
*              INTERMEDIATE OUTPUT PROCESSOR
*
***********************************************************************
*              REGISTER ASSIGNMENT                                    *
***********************************************************************
ERRCODE  EQU   0                        ERR CODE
NOTL1MXE EQU   0                        MAXIMUM NO.ENTRIES IN NOTE LST1
WRITECT  EQU   0
ENDTXTIO EQU   0      USED ON BUILD SCATR/TRANS LOOP
REG0     EQU   0
REG1     EQU   1
TEMP4    EQU   1
NOTL1CTE EQU   1                        CURRENT NO.ENTRIES IN NOTE LST1
TTRREG   EQU   1
APT      EQU   2
REG2     EQU    2
ADTXTIOT EQU   3      USED ON BUILD SCATR/TRANS LOOP
CESDCRCT EQU   3
IOCTLADD EQU   3                        ADD OF IO CONTROL TABLE
TEMP5    EQU   3                        TEMPORARY REGISTER
REG3     EQU   3
CESDADD  EQU   4
TRANSADD EQU   4                        ADD OF TRANSLATION  TABLE
IOCTLCTB EQU   4                        CURRENT NO.BYTES IN IO CTL TBL
TXTIOADD EQU   4                        ADD OF TXT IO TABLE
REG4     EQU   4
HESDCT   EQU   5
NOTL2ADD EQU   5                        ADD OF NOTE LIST 2
TXTIOCT  EQU   5                        CT OF CURRENT NO BYTES IN TXTIO
REG5     EQU   5
BUFFRSIZ EQU   6                        SIZE OF NOTE LIST 1
CESDID   EQU   6
SEGCT    EQU   6                        SEGMENT NO.
HIARAD   EQU   6    USED IN LOOP TO BUILD SCTR TABLE IF HIAR SPECIFIED
REG6     EQU   6
HIIDTAB  EQU   7                        ADD OF HI ID TABLE
WRITEADD EQU   7
REG7     EQU   7
INDCBADD EQU   8                        ADDRESS OF INT. DCB
SCATTADD EQU   WRITEADD
NOTL1ADD EQU   8                        ADD OF NOTE LIST 1
OTDCBADD EQU   8                        ADDRESS OF OUT. DCB
TEMPRTN  EQU   8                        TEMP RETURN REG            DISP
REG8     EQU   8
DCBADD   EQU   9
RETPARM  EQU   9                        NO ENTRIES IN NOTE LIST 2
REG9     EQU   9
EVENREG  EQU   10                       EVEN REG OF AN EVEN ODD PAIR
HESDADD  EQU   10
WORK1    EQU   10                       WORK REG
REG10    EQU   10
ODDREG   EQU   11                       ODD  REG OF AN EVEN ODD PAIR
RCTADD   EQU   11
REG11    EQU   11
BASE     EQU   12
BYTSPERE EQU   13                       NO.OF BYTES PER ENTRY
SAVEAREA EQU   13
TEMP1    EQU   13
TEMPREG  EQU   X'D'
REG13    EQU   13
REG14    EQU   14
RETURN   EQU   14                       RETURN REGISTER
TEMP2    EQU   14
REG15    EQU   15
BRANCH   EQU   15                       BRANCH REGISTER
FIFTEEN  EQU   15
TEMP3    EQU   15
         SPACE 1                                                 S21016
*****************REGISTERS USED BY SUBROUTINE IDROUT*************S21016
         SPACE 1                                                 S21016
TABADD   EQU   10                      POINTER TO BEGINNING OF   S21016
*                                      AN IDR DATA TABLE         S21016
TABEND   EQU   11                      POINTER TO END OF AN IDR  S21016
*                                      DATA TABLE                S21016
DATAPTR  EQU   4                       POINTER TO BEGINNING OF   S21016
*                                      DATA IN AN IDR DATA TABLE S21016
DATALEN  EQU   5                       LENGTH OF DATA IN AN IDR  S21016
*                                      DATA TABLE                S21016
RECLEN   EQU   3                       LENGTH OF DATA IN ONE     S21016
*                                      RECORD (USED AS DECREMENT S21016
*                                      FOR UPDATING DATALEN)     S21016
MVCPTR   EQU   3                       POINTER TO DESTINATION IN S21016
*                                      EXECUTED MOVE             S21016
DATASIZE EQU   4                       LENGTH OF DATA IN A       S21016
*                                      RECORD                    S21016
ZPCOUNT  EQU   5                       NUMBER OF ENTRIES IN      S21016
*                                      AN SPZAP DATA RECORD      S21016
TIME     EQU   0                       TIME OF DAY RETURNED BY   S21016
*                                      TIME MACRO                S21016
DATE     EQU   1                       DATE RETURNED BY TIME     S21016
*                                      MACRO                     S21016
ZAPCMPR  EQU   4                       COMPARISON VALUE USED TO  S21016
*                                      DETERMINE WHETHER AN      S21016
*                                      EXTRA SPZAP IDR SHOULD    S21016
*                                      BE CREATED                S21016
OBUFPTR  EQU   6                       CURRENT POSITION IN IDR  OX04245
*                                      BUFFER                   OX04245
***********************************************************************
*              MASKS                                                  *
***********************************************************************
ESDWTBIT EQU   X'01'
HIAROP   EQU   X'04'                    HIAR MASK
INC      EQU   4
SDPCCM   EQU   X'02'
SCATTBIT EQU   X'04'                    SCATTER MASK               DISP
OVRLYBIT EQU   X'20'                    OVERLAY MASK               DISP
CESDCNTL EQU   X'20'
ESDWTOFF EQU   X'FE'
         SPACE 1                                                 S21016
*******MASKS AND IMMEDIATE BYTES USED BY SUBROUTINE IDROUT*******S21016
         SPACE 1                                                 S21016
CHAIN    EQU   X'40'                   CHAIN BIT IN DATA COUNT   S21016
*                                      FIELD OF SPZAP TYPE IDR   S21016
ZAPMAX   EQU   X'53'                   VALUE OF COUNT FIELD IN   S21016
*                                      SPZAP TYPE IDR WHEN ALL   S21016
*                                      ENTRIES ARE USED AND      S21016
*                                      CHAIN BIT IS ON           S21016
NOZPDATA EQU   X'00'                   VALUE OF COUNT FIELD IN   S21016
*                                      SPZAP TYPE IDR WHEN NO    S21016
*                                      ENTRIES ARE USED AND      S21016
*                                      CHAIN BIT IS OFF          S21016
LASTIDR  EQU   X'80'                   FLAG IN IDR SUBTYPE FIELD S21016
*                                      TO INDICATE THE LAST IDR  S21016
*                                      FOR AN OUTPUT LOAD MODULE S21016
TRNSTYPE EQU   X'04'                   SUBTYPE INDICATOR FOR     S21016
*                                      IDR'S WITH TRANSLATOR     S21016
*                                      DATA                      S21016
USERTYPE EQU   X'08'                   SUBTYPE INDICATOR FOR     S21016
*                                      IDR'S WITH USER-DATA      S21016
TRUDMAX  EQU   X'FF'                   MAXIMUM BYTE COUNT FOR    S21016
*                                      TRANSLATOR AND USER-DATA  S21016
*                                      IDR'S                     S21016
ZEROFILL EQU   X'00'                   ZEROES FOR PADDING        S21016
ON       EQU   X'01'                   MASK FOR SWITCH           S21016
*                                      INDICATING A TEMPORARY    S21016
*                                      NEEDED FOR A MOVE         S21016
OFF      EQU   X'FE'                   IMMEDIATE BYTE TO TURN    S21016
*                                      OFF 'TEMPORARY NEEDED'    S21016
*                                      SWITCH                    S21016
***********************************************************************
*              DISPLACEMENTS                                          *
***********************************************************************
LASTESD  EQU   X'08'                   MASK FOR LAST ESD RCD IN MODULE
         SPACE 1                                                 S21016
**********SYMBOLIC DISPLACEMENTS AND LENGTHS USED BY*************S21016
*********************SUBROUTINE IDROUT***************************S21016
         SPACE 1                                                 S21016
HDRLEN   EQU   4                       LENGTH OF IDR SPZAP       S21016
*                                      HEADER                    S21016
ZAPLEN   EQU   247                     LENGTH OF SPZAP DATA IN   S21016
*                                      ONE RECORD                S21016
ZPLEN    EQU   246                     LENGTH OF SPZAP DATA - 1  S21016
*                                      (USED TO PAD WITH ZEROES) S21016
LOC      EQU   0                       NULL OFFSET               S21016
ZPRECLEN EQU   251                     LENGTH OF AN IDR SPZAP    S21016
*                                      RECORD                    S21016
UNIT     EQU   1                       OFFSET OF 1 BYTE          S21016
LEN2     EQU   2                       TWO-BYTE LENGTH           S21016
LEN3     EQU   3                       THREE-BYTE LENGTH         S21016
LEN4     EQU   4                       FOUR-BYTE LENGTH          S21016
LEN8     EQU   8                       EIGHT-BYTE LENGTH         S21016
CMPRSIZE EQU   14                      COMPARISON VALUE FOR MAX  S21016
*                                      NUMBER OF ENTRIES ALLOWED S21016
*                                      IN AN IDR SPZAP RECORD    S21016
*                                      BEFORE ADDING AN ADDI-    S21016
*                                      TIONAL SPARE RECORD       S21016
LKRECLEN EQU   18                      LENGTH OF IDR LKED RECORD S21016
LKLEN    EQU   15                      LENGTH OF IDR LKED DATA   S21016
*                                      EXCEPT FOR DATE OF LKED   S21016
DATELEN  EQU   3                       LENGTH OF PACKED DEC DATE S21016
*                                      RETURNED BY TIME MACRO    S21016
TRUDLEN  EQU   253                     GREATEST AMOUNT OF USER   S21016
*                                      OR TRANSLATOR DATA WHICH  S21016
*                                      CAN GO ONTO ONE RECORD    S21016
TURECLEN EQU   256                     MAXIMUM TRANSLATOR AND    S21016
*                                      USER-DATA RECORD SIZE     S21016
ADDLEN   EQU   3                       THREE-BYTE ADJUSTMENT FOR S21016
*                                      DETERMINING BYTE COUNT OF S21016
*                                      TRANSLATOR AND USER-DATA  S21016
*                                      RECORDS SHORTER THAN MAX  S21016
ONETRNS  EQU   0                       FLAG FOR SINGLE TRANS    OX04245
*                                      ITEM                     OX04245
HDLEN1   EQU   6                       LENGTH OF HEADER         OX04245
*                                      FOR SINGLE TRANS IDR     OX04245
HDLEN2   EQU   9                       LENGTH OF HEADER         OX04245
*                                      FOR DOUBLE TRANS IDR     OX04245
INDCTRLN EQU   1                       LENGTH OF FALG FIELD     OX04245
*                                      FOR TRANS IDR ITEM       OX04245
TRNMLEN  EQU   12                      LENGTH OF TRANS NAME/LVL OX04245
*                                      FOR TRANS IDR ITEM       OX04245
PKLEN2   EQU   3                       LENGTH OF DATE FOR       OX04245
*                                      TRANS IDR ITEM           OX04245
***********************************************************************
*              SECOND PASS DISPLACEMENTS,REGISTERS AND MASKS          *
***********************************************************************
NOEDIT2P EQU   X'02'                   NOT EDIT MASK FOR 2ND PASS
NOTEDIT  EQU   X'08'                   NOT EDITABLE MASK
         EJECT
         EXTRN HEWLCUDB
         EXTRN HEWLCMDB
         EXTRN SEGLNTAB
*              OUTPUT CESD AND  BUILD HESD
         USING OUT00100+2,BASE
         USING APTDSECT,APT
OUT00100 BALR  BASE,0
***********************************************************************
*              BUILD HESD & OUTPUT CESD(IF PGM IS NOT- NOT EDITABLE   *
*              ALSO MARK LAST ESD RECORD IF THERE IS NO TEXT          *
***********************************************************************
         BC    15,OVERNAME             BRANCH AROUND MODULE IDENT
         DC    C' 02/24/77 OZ17975'    DATE/APAR NUMBER
MODID    DC    C' HEWLFOUT ',0H'0'     MOD ID
OVERNAME TM    APT0,X'20'              IS MAP REQUESTED
         BC    1,OUT00105              YES
         TM    APT0,X'40'              NO--IS XREF REQUESTED
         BC    8,OUT00110              NO
         TM    NEWSW,X'20'             YES--ARE RLDS IN CORE
         BC    1,OUT00110              NO--DON'T DO XREF NOW
OUT00105 L     REG15,MAPAD             YES--GO TO MAP/XREF
         OI    NEWSW,X'40'             SET ENTRY FROM INTERMEDIATE BIT
         BALR  REG14,REG15
         NI    NEWSW,X'BF'             TURN OFF INTERMEDIATE ENTRY BIT
OUT00110 L     CESDADD,CHESD      LOAD CESD ADDRESS
         LA    CESDID,1                 SET FIRST ID TO 1
         L     HESDADD,HESD       HESD ADDRESS
         OI    APT1,ESDWTBIT      SET FIRST ESD WRITE ON FOR NOTE
         LH    CESDCRCT,ENCDC     CURR NO CESD ENTRIES
         OI    APT3,NOEDIT2P
OUT00200 LA    FIFTEEN,15               PUT 15  IN FIFTEEN
         XC    8(4,CESDADD),8(CESDADD) SET HI WORD OF CONTROL TO ZERO
         SR    CESDCRCT,FIFTEEN         REMAING NO. CESD ENTRIES TO WT
         BC    2,OUT00300              BRANCH IF REMAINDER GTR THAN 0
         AR    FIFTEEN,CESDCRCT         REMAINDER LESS 0 /RESTORE CT
         OC    ENTOC(2),ENTOC     IS THERE ANY TEXT IN MODULE
         BC    4,OUT00300              YES
         OI    8(CESDADD),LASTESD      NO/SET LAST RCD IN MODULE IND
OUT00300 LR    HESDCT,FIFTEEN           COUNT OF PRESENT CESD WT COUNT
         SLL   FIFTEEN,4                16(Y); Y= NO CESD LINES TO WT.
         STH   FIFTEEN,14(CESDADD)      PUT BYTE CT IN CONTROL
         STH   CESDID,12(CESDADD)       PUT ESDID IN CONTROL
         OI    8(CESDADD),CESDCNTL      SET HI BYTE TO 20 (ESD ITEM)
         LA    WRITECT,8(FIFTEEN)       INC WT BYTE CT BY 8
         LA    WRITEADD,8(CESDADD)      INC WT BYTE ADD BY 8
         TM    PDSE8,NOTEDIT      IS MODULE NOT EDITABLE
         BO    OUT00350                IF YES, DO NOT TURN 2ND   S21016
*                                      PASS NE SWITCH            S21016
         NI    APT3,X'FD'         SET NOT EDITABLE OFF
OUT00350 BAL   TEMPRTN,OUT00990        GO TO WRITE/CHECK/NOTE    S21016
*                                      SUBROUTINE                S21016
         LTR   TTRREG,TTRREG            TTR EXISTS ON FIRST WT/ESD&SCAT
         BC    8,OUT00400               BRANCH ON ALL OTHER WTS
         ST    TTRREG,CTTR        SAVE TTR OF CESD
OUT00400 LA    HESDADD,8(HESDADD)       INCREMENT HESD ADDRESS PTR
         LA    CESDADD,16(CESDADD)      INCREMENT CESD ADDRESS PTR
         LM    TEMP1,TEMP2,8(CESDADD)   LOAD LAST 4 BYTES OF A CESD LIN
         STM   TEMP1,TEMP2,0(HESDADD)   STORE IT IN HESD
         BCT   HESDCT,OUT00400          BRANC IF LOOP NOT DONE
         LA    CESDID,15(CESDID)        INC ESDID BY 15
         LTR   CESDCRCT,CESDCRCT        HAVE ALL CESD LINES BEEN WRITEN
         BC    2,OUT00200               NO /CONTINUE WRITE OUT
         BAL   TEMPRTN,IDROUT          AFTER LAST CESD LINE IS   S21016
*                                      WRITTEN, GO TO PROCESS    S21016
*                                      IDR'S                     S21016
         XC    8(8,HESDADD),8(HESDADD) SET LINE AFTER LAST = 0
***********************************************************************
*              IF THERE IS NO TEXT IN MODULE BY PASS 2ND PASS/GO TO   *
*              FINAL PROCESSOR - ALSO PRINT MESSAGE - NO TEXT         *
***********************************************************************
OUT00525 SR    TEMP1,TEMP1
         CH    TEMP1,ENTOC        ANY ENTRIES IN TXT ID TBL
         BC    8,OUT00970              NO / NO TXT / GO TO FINAL PROC
***********************************************************************
*              TEST FOR OVERLAY - YES GO TO BUILD  SEGTAB CONTROL RCD *
*              AND SEGTAB RECORD  AND WRITE OUT BOTH                  *
***********************************************************************
OUT00550 TM    PDSE7,OVRLYBIT     IS PROGRAM IN OVERLAY
         BC    1,OUT01000               YES/ GO OUT PUT SEGTAB RCDS
***********************************************************************
*              READ IN TEXT NOTE LIST AND RLD NOTE LIST
***********************************************************************
*              INITIALIZE REGS FOR TXT NOTE LIST READ IN
***********************************************************************
OUT00560 LA    BYTSPERE,7              7 BYTES/ENTRY IN TXT NOTELIST
         LA    IOCTLADD,IOCT      ADDRESS OF TXT IO  CTL TBL
         XR    REG4,REG4              CLEAR REGISTER             S01904
         XR    REG9,REG9              CLEAR REGISTER             S01904
         IC    REG4,ENITC+1                                      S01904
         IC    REG9,ENITC                                        S01904
         L     NOTL1ADD,TNT1          TXT NOTELIST1 ADDR         S01904
         L     NOTL2ADD,TNLS2         TXT NOTELIST2 ADDR         S01904
         LH    NOTL1CTE,ENT1C         CURR NO ENTRIES IN TNL1    S01904
         LH    REG0,ENT1X1                                       S01904
         LH    REG7,ENT1X                                        S01904
         BAL   RETURN,OUT00600        GO TO TXT TLD READIN RTN   S01904
         MVC   ENT2C(2),ENTRYSV                                  S01904
         EJECT
         TM    APT4,ORDERR            IS ORDERING FLAG ON?       S01904
         BZ    OUT560B                NO,BRANCH OUT              S01904
         SPACE 2
****************
*  REARRANGE THE TEXT I/O TABLE AND TEXT NOTELIST 2 TO
*  MATCH THE ORDER IN WHICH CSECTS APPEAR IN THE ORDER TABLE
*  (THE ORDER IN WHICH ADDRESSES WERE ASSIGNED IN HEWLFADA)
****************
         SPACE 1
         STM   REG0,REG15,BRNCHSV     SAVE REGISTERS
         LH    REG1,ORDRCUR           CURR NO OF BYTES IN ORDR TBL
         LTR   REG1,REG1              IS THERE AN ENTRY?         S01904
         BZ    OUT560A                NO,BRANCH OUT              S01904
********** THE FOLLOWING BLOCK OF INSTRUCTIONS ARE SETUP FOR
********** TWO NESTED BXLE INSTRUCTIONS THAT LOOP THROUGH THE ORDER
********** TABLE AND THE TEXTIO TABLE/TEXT NOTELIST 2
**********
         L     REG3,ORDRADR           GET ADDR OF ORDER TABLE    S01904
         AR    REG1,REG3              CALC THE ADDR OF LAST ENTRY
         LA    REG0,3                 IN THE ORDER TABLE         S01904
*                                     REG0=INCREMENT FOR BXLE    S01904
         SR    REG1,REG0              REG1 -> LAST ENTRY         S01904
*                                     (COMPARAND FOR BXLE)       S01904
         LH    REG5,ENTOC             CURR NO OF BYTES ON TXT IO TBL
         LTR   REG5,REG5              ANY ENTRIES?               S01904
         BZ    OUT560A                NO,BRANCH OUT              S01904
         L     REG13,TXTIO            ADDR OF TEXT IO TABLE      S01904
         AR    REG5,REG13             CALC THE ADDR OF THE LAST ENTRY
         LA    REG4,4                 IN THE TXT IO TABLE        S01904
*                                     REG4=INCREMENT FOR BXLE    S01904
         SR    REG5,REG4              REG5 -> LAST TXTIO ENTRY   S01904
*                                     (COMPARAND FOR BXLE)       S01904
         LR    REG7,REG13             REG7 -> TXTIO TAB START    S01904
********** END OF SETUP FOR NESTED BXLE'S
         SPACE 1
OUT561   TM    0(REG3),X'A0'          IS THE ORDR TBL ENTRY MATCHED?
         BNO   OUT564                 NO,CONTINUE SCAN OF TABLE
OUT562   CLC   1(2,REG3),0(REG13)     FIND MATCH OF ID IN TXT IO TBL
*                                     (COMPARE CESDID IN ORDER
*                                     TABLE ENTRY WITH CESDID IN
*                                     TEXTIO TABLE ENTRY)
         BE    OUT565                 IF MATCHED, BRANCH OUT     S01904
OUT563   BXLE  REG13,REG4,OUT562      SCAN THRU TEXTIO TABLE     S01904
         LR    REG13,REG7             RESTORE PTR TO TXT IO TBL
OUT564   BXLE  REG3,REG0,OUT561       CONTINUE SCAN OF ORDER TBL
         B     OUT560A                EXIT AFTER THE LAST ENTRY  S01904
*                                     IN THE ORDER TABLE HAS     S01904
*                                     BEEN PROCESSED             S01904
OUT565   CR    REG7,REG13             MATCHED ENTRY FIRST IN TXTIO?
         BE    OUT569A                YES,BRANCH OUT -NO REORDERING
*                                     (I.E. THE TXTIO TABLE ENTRY IS,
*                                     BY CHANCE, ALREADY IN THE
*                                     REQUIRED POSITION TO SATISFY
*                                     THE ORDER TABLE)
         LR    REG11,REG13            POINT TO TXTIO TABLE ENTRY S01904
*                                     TO BE MOVED UP             S01904
         LR    REG9,REG7              POINT TO TARGET FOR TXTIO  S01904
*                                     TABLE ENTRY BEING ORDERED  S01904
*                                     TO BE MOVED TO             S01904
         LA    REG6,3                 LENGTH OPERAND FOR         S01904
*                                     EXECUTED MOVE (WIDTH OF    S01904
*                                     ONE TXTIO TABLE ENTRY)     S01904
         LA    REG8,255               LENGTH OPERAND FOR         S01904
*                                     EXECUTED MOVE OF TXTIO TBL S01904
*                                     256 BYTES AT A TIME TO THE S01904
*                                     RIGHT TO MAKE ROOM FOR     S01904
*                                     ENTRY BEING ORDERED        S01904
OUT565A  EX    REG6,MOVE1             SAVE MATCHED TABLE ENTRY
*                                     (EXECUTE MOVE OF ENTRY BEING
*                                     ORDERED TO TEMP SAVEAREA)
         LR    REG10,REG13            POINT TO END OF AREA TO BE S01904
*                                     MOVED                      S01904
         LR    REG14,REG13            CALC IF THERE ARE MORE THAN 256
         SR    REG14,REG7             BYTES FROM MATCHED ENTRY ADDR TO
         SRDL  REG14,REG8             BEGIN OF LAST ORDRD ENTRY
         LTR   REG14,REG14            ARE THERE MORE THAN 256?
         BZ    OUT567                 NO, BRANCH                 S01904
OUT566   SH    REG10,HEX100           MOVE THE LOWER 256 BYTES   S01904
         EX    REG8,MOVE3             INTO A TEMP SAVEAREA       S01904
         AR    REG10,REG6             LEAVE ROOM FOR ENTRY TO BE REORDR
         EX    REG8,MOVE4             MOVE BACK THE 256 BYTES TO TXT IO
*                                     TABLE/TNL (MOVED ONE ENTRY S01904
*                                     TO THE RIGHT OF WHERE IT   S01904
*                                     PREVIOUSLY WAS IN TABLE)   S01904
         SR    REG10,REG6             RESET REG10 TO CONTINUE    S01904
*                                     MOVE LOOP -- REG10 ALWAYS  S01904
*                                     POINTS TO FROM-LOCATION    S01904
*                                     FOR MOVE (IT POINTS 256    S01904
*                                     BYTES FURTHER TO THE LEFT  S01904
*                                     ON EACH ITERATION THRU THE S01904
*                                     MOVE LOOP)                 S01904
         BCT   REG14,OUT566           ANY MORE MOVE TO BE DONE?
OUT567   SRL   REG15,24               REG15=REMAINDING NUMBER    S01904
*                                     OF BYTES TO BE MOVED IF    S01904
*                                     TOTAL NUMBER OF BYTES TO   S01904
*                                     BE MOVED WAS NOT AN EVEN   S01904
*                                     MULTIPLE OF 256            S01904
         LTR   REG15,REG15            ANY REMAINDER  TO BE MOVED?
         BZ    OUT568                 NO,MOVE IS ALL DONE        S01904
*                                     IF THE AREA TO BE MOVED    S01904
*                                     WAS AN EVEN MULTIPLE OF    S01904
*                                     256 BYTES IN SIZE, ALL     S01904
*                                     MOVING IS NOW COMPLETE,    S01904
*                                     EXCEPT TO MOVE THE ENTRY   YM4013
*                                     BEING ORDERED UP TO ITS    YM4013
*                                     NEW POSITION IN THE TABLE  YM4013
         SR    REG10,REG15            IF NOT, POINT TO START OF  S01904
*                                     REMAINING AREA TO BE MOVED S01904
         BCTR  REG15,0                MACHINE LENGTH OF REMAINDER
         EX    REG15,MOVE3            MOVE THE REMAINING BYTES   S01904
         AR    REG10,REG6             POINT ONE ENTRY TO RIGHT   S01904
         EX    REG15,MOVE4            MOVE THE TXT ENTRY FOR ORDERING
OUT568   EX    REG6,MOVE2             MOVE THE ENTRY      S01904,YM4013
*                                     BEING ORDERED TO    S01904,YM4013
*                                     ITS NEW POSITION IN S01904,YM4013
*                                     THE TABLE           S01904,YM4013
         C     REG6,SIX               HAS TEXT NOTELIST2  S01904,YM4013
*                                     JUST BEEN MOVED?           S01904
         BE    OUT569                 IF SO, BRANCH              S01904
         S     REG13,TXTIO            CALC OLD TXT IO ENTRY NUMBER
         SRL   REG13,2                DIVIDE REL ADDR OF TXTIO   S01904
*                                     ENTRY BY 4 (ENTRY SIZE)    S01904
*                                     TO GET REL ENTRY NUMBER    S01904
         MH    REG13,SEVEN            MULTIPLY BY SEVEN          S01904
         A     REG13,TNLS2            TO LOCATE CORR TNL2 ENTRY
         S     REG7,TXTIO             CALC NEW TXT IO ENTRY NO   S01904
         SRL   REG7,2                 DIVIDE REL ADDR BY 4       S01904
         MH    REG7,SEVEN             LOCATE CORR TNL2 ENTRY     S01904
         A     REG7,TNLS2             GET ABSOLUTE ADDR IN TNL2  S01904
         LA    REG6,6                 REG6=WIDTH OF TNL2 ENTRY   S01904
*                                     (MINUS 1 FOR EXECUTED MVC) S01904
         B     OUT565A                BRANCH OUT TO PERFORM MOVE TNL2
OUT569   LR    REG13,REG11            RESTORE PTRS TO ORDER AND TXT IO
         LR    REG7,REG9              TABLE ENTRIES              S01904
OUT569A  LA    REG7,4(REG7)           INCREMENT TO NEXT TXTIO    S01904
*                                     TABLE ENTRY                S01904
         B     OUT563                 RETURN TO COMPLETE TBL SCAN
OUT560A  LM    REG0,REG15,BRNCHSV     RESTORE REGISTERS          S01904
         B     OUT560B                AND CONTINUE NORMAL        S01904
*                                     PROCESSING
         SPACE 3
MOVE1    MVC   TEMPSV1(1),0(REG13)    MOVE TABLE ENTRY BEING ORDERED
*                                     TO TEMPORARY SAVE AREA
MOVE2    MVC   0(1,REG7),TEMPSV1      MOVE ENTRY BEING ORDERED FROM
*                                     TEMP SAVE AREA TO NEW (ORDERED)
*                                     POSITION IN TABLE
MOVE3    MVC   TEMPSV2(1),0(REG10)    MOVE 256 BYTES OF TABLE TO
*                                     TEMPORARY SAVE AREA
MOVE4    MVC   1(1,REG10),TEMPSV2     MOVE 256 BYTES OF TABLE FROM
*                                     TEMP SAVE AREA BACK TO TABLE
*                                     ONE ENTRY TO RIGHT OF PREVIOUS
*                                     LOCATION (TO MAKE ROOM FOR
*                                     ENTRY BEING ORDERED)
         SPACE 2
SIX      DC    F'6'                   MACHINE LENGTH OF TNL2 ENTRIES
TEMPSV1  DC    XL7'0'                 SAVE FOR 1 TXTIO/TNL2 ENTRY
TEMPSV2  DC    XL256'0'               SAVE FOR 256 BYTES OF TABLE
SEVEN    DC    H'7'                   WIDTH OF TNL2 ENTRIES
HEX100   DC    H'256'                 WIDTH OF ONE 256 BYTE TABLE MOVE
ENTRYSV  DC    H'0'                   TEMP SAVE FOR TNL2 READIN
         EJECT
***********************************************************************
*              TEST FOR SCATTER - YES -BUILD SCATTER / TRANSLATION    *
*              TABLES AND OUTPUT BOTH AS ONE ENITY- OUT IN RECORDS    *
*              OF 1024 DEC BYTES                                      *
***********************************************************************
OUT560B TM    PDSE7,SCATTBIT     IS PROGRAM IN SCATTER           XM6065
        BC    1,OUT02000         YES, GO WRITE SCATTER RCD       XM6O65
***********************************************************************
*              INITIALIZE REGS FOR RLD NOTE LIST READ IN
***********************************************************************
OUT560C  EQU   *                                                 XM9089
        LA    BYTSPERE,9              9 BYTES/ENTRY IN RLD NOTELIST
         LA    IOCTLADD,IOCT+12   ADDRESS OF RLD IO CTL TBL
         XR    REG4,REG4              CLEAR REGISTER             S01904
         XR    REG9,REG9              CLEAR REGISTER             S01904
         IC    REG9,ENIRC             BYTES IN OLD RLD IO TBL    S01904
         IC    REG4,ENIRC+1           BYTES IN REALOC RLD TBLE   S01904
         L     NOTL1ADD,RNT1      ADDR RLD  NOTELIST 1
         L     NOTL2ADD,RNLS2     ADDR RLD  NOTELIST 2
         LH    NOTL1CTE,ENR1C     CURRNT NO. ENTRIES IN RLD NOTELIST 1
         LH    NOTL1MXE,ENR1X1    MAX NO. OF ENTRIES IN RLD NOTELIST 1
         LH    REG7,ENR1X                                        S01904
         BAL   RETURN,OUT00600          GO TO TXT- RLD READ IN RT
         MVC   ENR2C(2),ENTRYSV     ST CUR NO ENTRIES IN RLDNL2  XM5480
         MVC   ENR1C(2),ENTRYSV     ST CUR NO ENTRIES IN RLDNL1  XM5480
**********************************************************************$
*              DETERMINE ID OF LAST TXTIOT ENTRY PER SEGMENT          *
*              ALSO SAVE HIGEST SEGMENT NUMBER CONTAINING TEXT
**********************************************************************$
*
OUT00570 SR    TEMP4,TEMP4              ZERO CT OF TXTIO FOR LOOP
         L     HIIDTAB,ADHIID
         L     HIIDTAB,0(HIIDTAB)      ADDRESS OF HI ID TABLE
         LR    TEMP1,HIIDTAB        GET START OF TABLE ADDRESS
         XC    0(256,TEMP1),0(TEMP1)   CLEAR 1ST HALF OF TABLE
         XC    256(256,TEMP1),256(TEMP1)   CLEAR 2ND HALF OF TABLE
OUT00580 L     TXTIOADD,TXTIO     ADD OF  TXTIO TABLE
         AR    TXTIOADD,TEMP4           ADD OF NEXT ID IN TXTIO TABLE
         TM    2(TXTIOADD),X'20'        IS IT OUT OF ORDER TXT
         BC    1,OUT00581               YES--TEST END OF TXTIOT LOOP
         MVC   WORD(2),0(TXTIOADD)      MOVE ID FROM TXTIO TO WORK
         LH    TEMP1,WORD               LOAD ID
         LR    TEMP2,TEMP1              SAVE ID
         SLL   TEMP2,3                  RELATIVE HESD ADD FOR THIS ID
         A     TEMP2,HESD         ABSOLUTE HESD ADR FOR THIS ID
         SR    TEMP3,TEMP3              ZERO SEGMENT NO REG
         IC    TEMP3,4(TEMP2)           THIS ID LIES IN THIS SEGMENT
         AR    TEMP3,TEMP3              DOUBLE SEG NO - REL. ADD TOHIID
         LH    WORK1,0(HIIDTAB,TEMP3)   GET CURRENT HI-ID IN TABLE
         LTR   WORK1,WORK1              WAS THERE ANY PREVIOUS ID
         BC    8,NOPRVID          BR IF THIS IS THE FIRST ID FOR SEG.
         SLL   WORK1,3                  CALCULATE HESD ADDRESS
         A     WORK1,HESD               FOR THIS ID
         CLC   1(3,TEMP2),1(WORK1)      IS NEW ID LOCATED AT A HIGHER
*                                       ADDRESS THAN PREVIOUS ID IN SEG
         BC    12,OUT00581        BR IF NOT AT A HIGHER ADDRESS
NOPRVID  EQU   *        THIS SHOULD BE AT THE STORE ID INSTRUCTION
         STH   TEMP1,0(HIIDTAB,TEMP3)   SAVE LAST TXTIOT ENTRY FOR SEG
OUT00581 LA    TEMP4,4(TEMP4)      INCREMENT TEXTIO BYTE COUNT
         CH    TEMP4,ENTOC        IS CURR. CT =  SAVED CT
         BC    4,OUT00580               NO - GO TO CONTINUE LOOP
         SR    TEMP1,TEMP1
         LH    SEGCT,CSNO         TOTAL CURRENT NO. SEGMENTS
OUT00582 LA    TEMP1,1(TEMP1)           INC BY 1 (CURRENT SEG)
         LR    TEMP3,TEMP1              SAVE CURRENT SEG NO.
         AR    TEMP3,TEMP3             DOUBLE CURR SEG NO
         LH    TEMP2,0(HIIDTAB,TEMP3)   LAST TXTIOT ENTRY FOR THIS SEG
         LTR   TEMP2,TEMP2              IS ID = 0
         BC    8,OUT00583               YES  NO TXT IN THIS SEGMENT
         STH   TEMP1,ENSPC        SAVE HI SEG WITH TEXT
         SLL   TEMP2,3                  MULT BY 8
         A     TEMP2,HESD         ADDRESS OF HESD ENTRY
         OI    0(TEMP2),X'40'     SET LAST TXTIOT ENTRY ON IN HESD
OUT00583 BCT   SEGCT,OUT00582           BRANCH IF LOOP NOT DONE
***********************************************************************
* AT THIS POINT SECOND PASS INITIALIZATION IS PERFORMED
***********************************************************************
OUT00575 L     REG7,TTRLIST       ADDRESS OF TTR LIST
         BCT   TEMP1,OUT00576     BRANCH TO ZERO TTR LIST
         BC    15,OUT00577        BRANCH AROUND ZEROING TTR LIST
OUT00576 SLL   TEMP1,2       CURR NO SEGMENTS -1 TIMES 4
*                                     RESTORE SEGMENT CT IF IN OVERLAY
         LA    TEMP1,3(TEMP1)     UPDATE COUNT FOR EX INSTRUCTION
         LA    REG1,256
OUT00578 SR    TEMP1,REG1              CHECK FOR 256 OR MORE BYTES
         BC    4,OUT00579              NO
         XC    0(256,REG7),0(REG7)     YES--CLEAR 256 BYTES
         AR    REG7,REG1               INCREMENT BY 256
         BC    15,OUT00578
OUT00579 AR    TEMP1,REG1              RESTORE COUNT
         EX    TEMP1,ZEROHIID          ZERO TTR L
OUT00577 SR    REG0,REG0
         LA    WORK1,9
         MH    WORK1,ENR2C
         A     WORK1,RNLS2
         ST    WORK1,SPACES+48         RLD NOTELIST LAST ENTRY ADDR.
         L     WORK1,TXTIO
         AH    WORK1,ENTOC
         SH    WORK1,FOUR
         ST    WORK1,SPACES+44         TEXT I/O TABLE LAST ENTRY ADDR
         LH    WORK1,ENCDC
         SLL   WORK1,3
         A     WORK1,HESD
         ST    WORK1,SPACES+52         HESD LAST ENTRY ADDR
         LH    REG1,ENSPX              SEGTAB ID
         CR    REG1,REG0
         BC    8,SCDGETID
OUTSCDIN SLL   REG1,3
         A     REG1,HESD
         LA    REG1,8(0,REG1)          ADDR. FIRST HESD ENTAB ENTRY
         L     BRANCH,TPASSVCN
         BR    BRANCH                  GO TO SECOND PASS
SCDGETID LH    REG1,ENCDC              LAST ID
         B     OUTSCDIN
***********************************************************************
*
*              TXT - RLD MOVE AND READ IN ROUTINE
*
***********************************************************************
OUT00600 STM   RETURN,BRANCH,SAVE1415
         SRL   IOCTLCTB,2               NO.OF BUFFERINGS
         SRL   REG9,2                   NO. OF BUFFERINGS       OX00029
         LR    EVENREG,IOCTLCTB         NO,OF NOTE LIST BUFFERINGS
         LR    ODDREG,NOTL1MXE          NO.OF ENTRIES PER BUFFERING
         MR    EVENREG,EVENREG          TOTAL NO.OF BUFFER ENTRIES
         LA    REG6,0(ODDREG,NOTL1CTE)                           S01904
         LTR   REG9,REG9              WAS TNL REALLOCATED?       S01904
         BZ    OUT00610               NO,BRANCH AROUND           S01904
         LR    ODDREG,REG9            NO OF REALLOC BUFFERINGS   S01904
         MR    EVENREG,REG7           TOTAL NO OF NEW BUFFER ENTRIES
         LA    REG6,0(ODDREG,REG6)                               S01904
OUT00610 STH   REG6,ENTRYSV                                      S01904
         LR    EVENREG,BYTSPERE         NO BYTES PER ENTRY
         LR    ODDREG,NOTL1MXE          MAX NO.NOTE LIST 1 ENTRIES
         MR    EVENREG,EVENREG          NO. BYTES IN BUFFER (NOTE LST1)
*                                       ANS IN ODDREG
         LR    BUFFRSIZ,ODDREG          SAVE BUFFER SIZE
         LR    EVENREG,IOCTLCTB         NO.OF BUFFERINGS
         MR    EVENREG,EVENREG          RELAITIVE ADD  OF WHERE TO MOVE
*                                       CONTENTS OF NOTE LIST1-ANS-ODDR
         ST    NOTL2ADD,SAVEWORD
         AR    NOTL2ADD,ODDREG          ADD OF WHERE TO 1PT OF NL1TONL2
         LR    ODDREG,REG7            NO OF ENTRIES IN REALLOC BUFFER
         MR    EVENREG,BYTSPERE       MULT BY NO OF BYTES/ENTRY
         LR    REG7,ODDREG            SAVE NEW BUFFER SIZE       S01904
         MR    EVENREG,REG9           MULT BY NO OF NEW BUFFERS
         AR    NOTL2ADD,ODDREG                                   S01904
         LR    EVENREG,BYTSPERE         NO,BYTES PER ENTRY IN NOTE LIST
         LTR   ODDREG,NOTL1CTE          NO.ENTRIES IN NOTE LIST 1
         BC    8,OUT00850
         MR    EVENREG,EVENREG          CURRENT NO BYTES IN NOTE LIST 1
         SR    TEMP3,TEMP3
OUT00700 LA    TEMP1,256
         SR    ODDREG,TEMP1             REMAINDER TO MOVE TO NOTE LIST2
         BC    10,OUT00800              BRANCH IF REMAINDER GTR,=  0
         AR    TEMP1,ODDREG             RESTORE NO.BYTES TO MOVE
OUT00800 BCTR  TEMP1,0                  DECREMENT BY 1 FOR EX MOVE INST
         LA    TEMP2,0(NOTL2ADD,TEMP3)  ADD.OF WHERE TO MV NL1 TO NL2
         EX    TEMP1,MOVEINST           MOVE NOTE LIST 1 TO NOTE LIST 2
         LA    TEMP3,256(TEMP3)         INC BY 256
         LA    NOTL1ADD,256(NOTL1ADD)   INC ADD OF NOTE LIST TO MOVE AD
         LTR   ODDREG,ODDREG            ANY MORE NOTE LST TO BE MOVED
         BC    2,OUT00700               BRANCH ON YES - GO TO MOVE
OUT00850 EQU   *
         L     NOTL2ADD,SAVEWORD                                 XM0834
         LTR   IOCTLCTB,IOCTLCTB ANY PRE-REALLOCATION BUFFERINGS XM0834
         BZ    OUT00940                 NO                       XM0834
OUT00900 LA    SAVEAREA,SPACES    SAVE AREA FOR POINT MACRO
         L     INDCBADD,DCBINTER        INTER DCB ADDRESS
***********************************************************************
*              POINT TO NEXT RECORD TO READ                           *
***********************************************************************
         POINT (INDCBADD),(IOCTLADD)
*                                                                     *
*              READ NEXT RECORD
***********************************************************************
         READ  DECB,SF,(INDCBADD),(NOTL2ADD),(BUFFRSIZ)
***********************************************************************
*              CHECK FOR COMPLETION OF READ                           *
***********************************************************************
         CHECK DECB
         LA    IOCTLADD,4(IOCTLADD)     ADD OF NEXT TTR
OUT00930 AR    NOTL2ADD,BUFFRSIZ
         BCT   IOCTLCTB,OUT00900        BRANC IF MORE TO READ IN
OUT00940 LTR   REG9,REG9              IS THERE A REALLOC BUFFER
         BZ    OUT00950               NO - RETURN                S01904
         LA    REG6,0(REG6)                                      S01904
         LA    REG7,0(REG7)                                      S01904
         CR    REG6,REG7              HAVE THE NEW BUFFERS BEEN READ?
         BE    OUT00950               YES,RETURN                 S01904
         LR    REG6,REG7              GET NEW BUFFER SIZE        S01904
         LR    REG4,REG9              GET NEW BUFFER COUNT       S01904
         B     OUT00900               RETURN TO READ     OX00029,S01904
OUT00950 LM    RETURN,BRANCH,SAVE1415   RESTORE  2 REGS
         BCR   15,RETURN                RETURN TO CALLER
SAVEWORD DC    F'0'
***********************************************************************
*              PASS ERROR PARM TO ERROR ROUTINE - NO TEXT             *
***********************************************************************
OUT00970 EQU   *
IEW0143  LH    ERRCODE,ERRPARM1         NO TXT IN LOAD MODULE
         L     BRANCH,ERDIG       ADDR OF ERROR ROUTINE
         BALR  RETURN,BRANCH            GO TO ERR DIAGNOSTIC ROUTINE
         L     BRANCH,FNALVCON          ADD OF FINAL PROC
         BCR   15,BRANCH                GO TO ERR ROUT
**********************************************************************
*              WRITE - CHECK - NOTE   SUBROUTINE                      *
**********************************************************************
*                   REQUIRED REGISTERS
*
*              TEMPRTN             -RETURN ADDRESS
*              WRITEADD            -ADDRESS OF WRITE AREA
*              WRITECT             -WRITE BYTE CT
*
*                   REGISTERS THAT ARE ALSO USED (NOT SAVED)
*
*              DCBADD
*              SAVEAREA
*              TTRREG
*
*              APT
*              BASE
*              REGS 14 - 1
OUT00990 L     DCBADD,DCBLMOD          SYSLMOD DCB
         LA    SAVEAREA,REGSA     ADDRESS OF SAVE AREA
***********************************************************************
*              WRITE THE NEXT RECORD                                  *
***********************************************************************
         WRITE WDECB,SF,(DCBADD),(WRITEADD),(WRITECT)
         CHECK WDECB
         SR    TTRREG,TTRREG            TTR REG SET TO ZERO
         TM    APT1,ESDWTBIT      IS FIRST ESD WT IND = ON
         BCR   8,TEMPRTN      NO        NO
         NI    APT1,ESDWTOFF      SET FIRST ESD WT IND = OFF
         NOTE  (DCBADD)
         BCR   15,TEMPRTN               RETURN TO CALLER
***********************************************************************
*              SETUP SEGTAB CONTROL RECORD
***********************************************************************
OUT01000 L     WRITEADD,TNLS2     ESD ADDRESS/WRITE OUT AREA
         LA    WRITEADD,5(WRITEADD)     WRITE OUT AREA
         XC    0(20,WRITEADD),0(WRITEADD) ZERO CONTROL RCD AREA
         OI    0(WRITEADD),X'01'        SET CONTROL IND.(TXT TO FOLLOW)
         OI    5(WRITEADD),X'04'        SET NO. BYTES ESD ID IN CTL
         OI    8(WRITEADD),X'06'        SET READ CCW FOR FETCH
         OI    12(WRITEADD),X'40'       SET FLAG FIELD FOR FETCH
         MVC   14(2,WRITEADD),PDSE10  PUT SEGTAB LENGTH IN CONTROL
         MVC   18(2,WRITEADD),PDSE10  PUT SEGTAB LENGTH IN CONTROL
         MVC   16(2,WRITEADD),ENSPX   PUT SEGTAB ID IN CONTROL
         MVC   WORD(2),PDSE10     LENGTH OF SEGTAB
         LH    TEMP5,WORD              LENGTH OF SEGTAB
***********************************************************************
*              SETUP FOR WRITE OF CONTROL RECORD
***********************************************************************
         NI    APT1,ESDWTOFF      SET NOTE IND= OFF
         LA    WRITECT,20               SET WRITE CT TO 20 BYTES
         NI    APT3,X'FD'         SET 2ND PASS NOT EDIT BIT OFF
*              WHEN THIS BIT IS ON 2ND PASS DOES NOT WRITE HIS 1ST
*              CONTROL RECORD ---- IN OVERLAY HIS 1ST CONTROL RECORD
*              IS NOT THE 1ST CONTROL RECORD IN THE PGM & MUST BE WRITT
         TM    PDSE8,NOTEDIT      IS MODULE NOT EDITABLE
         BC    1,OUT01100              YES/DO NOT OUTPUT CONTROL RECORD
         BAL   TEMPRTN,OUT00990         GO TO WT OUT SEG TAB CONTROL RD
***********************************************************************
*              BUILD IST TEXT RECORD  (SEGTAB)                        *
***********************************************************************
*
OUT01100 LR    TEMP2,WRITEADD          ADDRESS OF AREA TO SET TO 0
         LR    TEMP1,TEMP5              BYTES OF SEGTAB TO 0  (CT)
         LA    TEMP3,256
OUT01200 SR    TEMP1,TEMP3             IS REMAINDER LESS THAN 256
         BC    4,OUT01300               YES
         BCTR  TEMP3,0                 DECREMENT COUNT TO 255
         EX    TEMP3,ZEROHIID          ZERO 255 BYTES
         LA    WRITEADD,256(WRITEADD)   INCREMENT ADD BY 256
         BC    15,OUT01200              RETURN TO 0 REMAINDER
OUT01300 AR    TEMP1,TEMP3             RESTORE COUNT
         BCTR  TEMP1,0                 DECREMENT COUNT BY 1
         EX    TEMP1,ZEROHIID          ZERO REMAINDER
         LR    WRITEADD,TEMP2           RESTORE BEGIN OF SEGTAB AREA
         LR    WRITECT,TEMP5                 SEGTAB LENGTH
         MVC   8(1,WRITEADD),LSTS PUT LST SEG OF REG0 SEGTAB
         MVC   10(1,WRITEADD),LSTS+1   PUT LST SEG OF REG 1 SEGTAB
         MVC   12(1,WRITEADD),LSTS+2   PUT LST SEG OF REG 2 SEGTAB
         MVC   14(1,WRITEADD),LSTS+3   PUT LST SEG OF REG 3 SEGTAB
         MVI   9(WRITEADD),X'01'
*
*
         SR    TEMP1,TEMP1
         LA    TEMP2,20(WRITEADD)
OUT01500 L     TEMP3,SGT1         ADD OF SEGTAB 1 (-1)
         LA    TEMP1,1(TEMP1)                INC ADD OF SEGTAB
         AR    TEMP3,TEMP1              ADD OF NEXT ITEM IN SEGTA1
         LA    TEMP2,4(TEMP2)                INC ADD OF PRV SG IN SEGTB
         MVC   0(1,TEMP2),0(TEMP3)           MOVE PRV SG NO  TO SEGTAB
         MVI   3(TEMP2),X'03'                SET STATUS - NOT IN CORE
         CH    TEMP1,CSNO         IS LOOP DONE
         BC    4,OUT01500                    NO
         MVI   27(WRITEADD),X'02'            SET STATUS - IN CORE/SEG 1
***********************************************************************
*              SETUP FOR WRITE OF SEGTAB RECORD
***********************************************************************
         OI    APT1,ESDWTBIT      SET NOTE IND = ON
         BAL   TEMPRTN,OUT00990         GO TO WRITE SEGTAB RCD
         ST    TTRREG,PDSE4       SAVE TTRO OF SEGTAB IN PDS
         BC    15,OUT00560             GO BUILD REST OF HESD
***********************************************************************
*              INITIALIZE FOR BUILDING SCATTER/TRANSLATION TABLES     *
***********************************************************************
OUT02000 LA    TEMP5,2
         LH    HESDCT,ENCDC       HESD CT = X
         L     HESDADD,HESD            HESD ADDRESS
         LA    SCATTADD,1(HESDCT)       X+1
         LR    TRANSADD,SCATTADD        X+1
         SLL   TRANSADD,3               8(X+1)
         AR    TRANSADD,HESDADD         8(X+1) +HESD ADD = TRANS ADD
         AR    SCATTADD,SCATTADD        2(X+1)   / SLATION TABLE -4
         AR    SCATTADD,TEMP5           2(X+1)+2  - EXTRA 2 FOR PAD
         AR    TEMP5,TEMP5              4
         XC    4(2,TRANSADD),4(TRANSADD)  SET IST TRANSADD ENTRY = 0
         LCR   TEMP1,TEMP5              2'S COMP OF 4 = FFFFFFFC
         NR    SCATTADD,TEMP1           LENGTH OF TRANSLATION TABLE
*                                       WITH PAD REMOVED IF NOT NEEDED
         STH   SCATTADD,WORD            PUT LENGTH IN PDS
         MVC   PDSE14(2),WORD
         LA    TEMP4,0(SCATTADD,TRANSADD)    ADD OF SCATTER TABLE -TRUE
         XC    0(8,TEMP4),0(TEMP4)      SET 1ST SCAT ENTRY = 0
         LA    SCATTADD,8(TEMP4)        ADD OF 2ND ENTRY IN SCATTER TBL
         AR    TRANSADD,TEMP5           TRUE ADD OF TRANSLATION TABLE
         AR    TEMP4,TEMP5
***********************************************************************
*                BUILD SCATTER/TRANSLATION TABLES                     *
*                  FIRST PASS REFERENCED TXTIOT                       *
***********************************************************************
*                                                                     *
* SET UP SEARCH OF TXTIOT                                             *
          SR    ENDTXTIO,ENDTXTIO   CLEAR REGISTER FOR COMPARE TO 0
         CH    ENDTXTIO,ENTOC      IS THERE AN Y TEXT
         BC    11,OUT02050         NO/ SKIP 1ST SEARCH AND SEARCH HESD
         OI    SWITCH,TXTIOLP      SET SWITCH INDICATION TXTIO LOOP
         L     ADTXTIOT,TXTIO      ADDRESS TXTIO TABLE
         LR    ENDTXTIO,ADTXTIOT   ADDRESS TXTIO TABLE
         AH    ENDTXTIO,ENTOC      END ADDRESS OF TXTIO TABLE
* PROCESS TXTIOT ENTRY
OUT02023 CR    ADTXTIOT,ENDTXTIO   ANY MORE TXT IN TXTIOT
         BC    11,OUT02035         NO- SET IN TXTIOT LOOP OFF
         TM    2(ADTXTIOT),X'20'   IS IT OUT OF ORDER TEXT
         BC    1,OUT02033          YES--THEN ID FOR TXTIO ENTRY ALREADY
*                                     PROCESSED, CHECK NEXT ENTRY.
* FIND HESD ENTRY
         LH    TEMP1,0(ADTXTIOT)   HESD ENTRY ID (FROM TXTIOT)
         SLL   TEMP1,3             FIND REL ADDRESS HESD  (* 8)
         A     TEMP1,HESD          ADDRESS OF HESD ENTRY
         TM    0(TEMP1),X'08'          HAS HESD ENTRY BEEN PROCESSED
         BC    1,OUT02033          YES/ CHECK NEXT TXTIOT ENTRY
         B     OUT02110            NO/ PROCESS ENTRY
OUT02030 OI    0(TEMP1),X'08'      SET PROCESSED SWITCH
OUT02033 LA    ADTXTIOT,INC(ADTXTIOT)  UPDATE ADDR TXTIOT ENTRY
         B     OUT02023
OUT02035 NI    SWITCH,X'7F'        TURN TXTIO LOOP SWITCH OFF
         B     OUT02050            SEARCH HESD
OUT02036 NI    0(TEMP1),X'F7'      TURN PROCESSED SWITCH OFF
         B     OUT02300            CHECK END OF LOOP
OUT02050 LR    TEMP5,HESDCT        SAVE NUMBER OF ENTRIES IN HESD
         LR    TEMP1,HESDADD            HESD ADD  // 1ST ENTRY = 0
***********************************************************************
***********************************************************************
*              BUILD SCATTER/TRANSLATION TABLES                       *
***********************************************************************
OUT02100 LA    TEMP1,8(TEMP1)           INC HESD ADD
         TM    0(TEMP1),X'08'      HAS HESD ENTRY BEEN PROCESSED
         BC    1,OUT02036          YES- TURN OFF SWITCH/ CHECK END OF
*                                      LOOP
         TM    NEWSW,HIAROP             IS HIAR OPTION ON
         BC    8,OUT02120               NO
         LR    HIARAD,TEMP1        HESD ADDRESS
         S     HIARAD,HESD         RELATIVE HESD ADDRESS
         SRL   HIARAD,3            DIVIDE BY 8 TO GET HESD ID
         B     OUT02115
OUT02110 TM    NEWSW,HIAROP        IS HIAR OPTION ON
         BC    8,OUT02120           NO
         LH    HIARAD,0(ADTXTIOT)  HESD ID (REL. ADDR ON HIAR TABLE)
OUT02115 A     HIARAD,HIARADD      ADDRESS OF ENTRY OF HIERARCHY TABLE
OUT02120 TM    0(TEMP1),X'02'           IS HESD TYPE SD,PC OR CM
         BC    1,OUT02300               NO
         TM    NEWSW,HIAROP             IS HIAR OPTION ON
         BC    8,OUT02140               NO
         MVC   0(1,SCATTADD),0(HIARAD)  PUT HN IN HIGH ORDER BYTE
         B     OUT02150
OUT02140 MVI   0(SCATTADD),X'00'        NO HIAR- PUT 00 IN HIGH BYTE
OUT02150 MVC   1(3,SCATTADD),1(TEMP1)   PUT SD,PC OR CM ADD IN SCTR TAB
         LR    TEMP3,SCATTADD           SAVE SCATTER ADD FOR THIS ENTRY
         SR    TEMP3,TEMP4              REL SCATTER ADD
         SRL   TEMP3,2                  SCAT ID
         LA    SCATTADD,4(SCATTADD)     INC TO NEXT AVAILABLE SCATENTRY
         CL    SCATTADD,TNLS2   CF SCTR TBL END:TXTNL BEGIN    @ZA07600
         BL    OUT02200         BR IF SCTR TBL DOESN'T OVLY    @ZA07600
IEW0364  LA    ERRCODE,X'0424'  NEED MORE SIZE1 PARM           @ZA07600
         L     15,ERDIG         LOAD ERR ADDR                  @ZA07600
         BCR   15,15            BR TO ERROR RTN                @ZA07600
OUT02200 LR    TEMP2,TEMP1              SAVE HESD ADD FOR THIS ENTRY
         SR    TEMP2,HESDADD            REL HESD ADD
         SRL   TEMP2,2                  2(HESD ID) OR REL TRANS ADD
         STH   TEMP3,0(TRANSADD,TEMP2)  PUT PTR TO SCAT ENT IN TRANS TB
         TM    SWITCH,TXTIOLP       IS PGM IN TXTIO TABLE SEARCH
         BC    1,OUT02030          YES SET ENTRY PROCESSED/ GO TO  NEXT
*                                         TXTIOT ENTRY
OUT02300 BCT   HESDCT,OUT02100          BRANCH IF HESD LOOP NOT DONE
         LR    TEMP1,HESDADD           ADDRESS OF HESD
OUT02400 LA    TEMP1,8(TEMP1)          INC HESD ADD
         SR    TEMP3,TEMP3              0 TO BE USED AS TRANSPTER,PR,NL
         TM    0(TEMP1),X'02'           IS HESD TYPE SD,PC OR CM
         BC    8,OUT02470              YES
         TM    0(TEMP1),X'07'           IS TYPE = NULL
         BC    1,OUT02450               YES / GO TO PUT 0 PTR IN TRANS
         TM    0(TEMP1),X'03'           IS TYPE = LR
         BC    12,OUT02450              NO - ER,PR /GO PUT 0 IN TRANS
         LH    TEMP2,6(TEMP1)           PICK UP ID THAT PTS TO SD OR PC
         AR    TEMP2,TEMP2              DOUBLE ID - REL TRANS TBL ADD
         LH    TEMP3,0(TRANSADD,TEMP2)  PICK UP PTR TO SCATT FOR SD -PC
OUT02450 LR    TEMP2,TEMP1              SAVE HESD ADD FOR THIS ENTRY
         SR    TEMP2,HESDADD            REL HESD ADD
         SRL   TEMP2,2                  2(HESD ID) OR REL TRANS ADD
         STH   TEMP3,0(TRANSADD,TEMP2)  PUT PTR TO SCAT ENT IN TRANS TB
OUT02470 BCT   TEMP5,OUT02400           BRANCH IF HESD LOOP NOT DONE
***********************************************************************
*              SET UP LOOP TO WRITE OUT SCATTER - TRANSLATION RECORD  *
***********************************************************************
         LR    TEMP1,SCATTADD           ADD OF LAST SCATTER ENTRY + 4
         SR    TEMP1,TEMP4              NO BYTES OF SCATTER TABLE
         STH   TEMP1,WORD
         MVC   PDSE13(2),WORD     PUT NO SCATT BYTES IN PDS
         LR    TEMP5,SCATTADD
         SR    TEMP5,TRANSADD           NO BYTES     TO WRITE OUT
         OI    APT1,ESDWTBIT      SET BIT TO NOTE FIRST WRITE
OUT02500 LA    TEMP1,1020               1020
         SR    TEMP5,TEMP1              BYTES REMAINING TO WRITE
         BC    10,OUT02600              BRANCH IF REMAINDER GREATER 0
         AR    TEMP1,TEMP5              WRITE CT = OR LESS 1020
OUT02600 LA    WRITECT,4(TEMP1)         CT + 4
         SR    SCATTADD,WRITECT         WRITE ADDRESS
         L     WORK1,0(SCATTADD)        SAVE 4 BYTES
         ST    TEMP1,0(SCATTADD)        PUT WRITE CT IN HEADER - CTL
         MVI   0(SCATTADD),X'10'        PUT IN SCAT CONTROL
         BAL   TEMPRTN,OUT00990         GO WRITE OUT SCATT RCD
         ST    WORK1,0(SCATTADD)        RESTORE  4 B
         LA    SCATTADD,4(SCATTADD)
         LTR   TTRREG,TTRREG            WAS A NOTE DONE ON THIS WRITE
         BC    8,OUT02700               NO
         ST    TTRREG,WORD              SAVE TTR
         MVC   PDSE5(3),WORD      PUT TTR IN PDS
OUT02700 LTR   TEMP5,TEMP5              ANY MORE DATA TO WRITE
         BC    2,OUT02500               YES
         BC    15,OUT560C               NO/RETURN TO MAIN LOOP   XM9089
         EJECT                                                   S21016
***********************************************************************
*                                                                     *
*              IDROUT -- SUBROUTINE TO PROCESS IDR OUTPUT             *
*                                                                     *
***********************************************************************
*                                                                     *
*                  SUBROUTINE IDROUT RECEIVES CONTROL                 *
*                  AFTER THE LAST CESD RECORD HAS BEEN                *
*                  WRITTEN ON THE SYSLMOD DATA SET.                   *
*                  ITS FUNCTION IS TO CREATE AND WRITE                *
*                  THE CSECT IDENTIFICATION RECORDS OF                *
*                  A LOAD MODULE IMMEDIATELY FOLLOWING                *
*                  ALL CESD RECORDS ON THE SYSLMOD                    *
*                  DATA SET.                                          *
*                  IT USES THREE TABLES CREATED DURING                *
*                  INPUT PROCESSING:                                  *
*                            IDRZPTAB - IMASPZAP DATA                 *
*                            IDRTRTAB - TRANSLATOR DATA               *
*                            IDRUDTAB - USER DATA                     *
*                  THESE TABLES, COLLECTIVELY, CONTAIN                *
*                  ALL IDR DATA RECEIVED FROM ALL                     *
*                  INPUT LOAD AND OBJECT MODULES PLUS                 *
*                  USER-SUPPLIED IDR DATA RECEIVED                    *
*                  VIA THE IDENTIFY CONTROL STATEMENT.                *
*                                                              S21016 *
***********************************************************************
         SPACE 2                                                 S21016
IDROUT   STM   WRITECT,TABEND,TEMPSAVE   SAVE REGISTERS          S21016
         SPACE 1                                                 S21016
***********************************************************************
*                                                                     *
*              PROCESS IDR IMASPZAP RECORD(S)                         *
*                                                              S21016 *
***********************************************************************
         SPACE 1                                                 S21016
         MVC   IDRBUF(HDRLEN),IDRZHDR  MOVE IDR SPZAP RECORD     S21016
*                                      HEADER INTO IDR BUFFER    S21016
         LA    WRITEADD,IDRBUF         POINT TO IDR BUFFER FOR   S21016
*                                      WRITE ROUTINE             S21016
         LA    WRITECT,ZPRECLEN        LOAD RECORD LENGTH FOR    S21016
*                                      WRITE ROUTINE             S21016
         L     TABADD,IDRZPTAB         GET TABLE START ADDRESS   XM5480
         L     TABEND,IDRZPEND         GET TABLE END ADDRESS     XM5480
*                                      TABLE                     S21016
         CR    TABADD,TABEND           ANY DATA IN TABLE?        S21016
         BE    NOZAP                   IF NOT, BRANCH            S21016
         LR    DATAPTR,TABADD          IF THERE IS DATA, POINT   S21016
*                                      TO IT                     S21016
         LR    DATALEN,TABEND          GET ENDING ADDRESS OF     S21016
*                                      DATA                      S21016
         SR    DATALEN,TABADD          SUBTRACT STARTING ADDRESS S21016
*                                      TO GET TOTAL LENGTH OF    S21016
*                                      DATA IN TABLE             S21016
         LA    RECLEN,ZAPLEN           LOAD DATA LENGTH FOR ONE  S21016
*                                      SPZAP RECORD              S21016
ZAPLOOP  CR    DATALEN,RECLEN          COMPARE LENGTH OF DATA IN S21016
*                                      TABLE TO LENGTH WHICH CAN S21016
*                                      GO ONTO ONE SPZAP RECORD  S21016
         BNH   LASTZAP                 IF ALL DATA REMAINING IN  S21016
*                                      TABLE CAN GO ONTO A       S21016
*                                      SINGLE RECORD, BRANCH     S21016
MOVEDATA MVC   ZAPDATA(ZAPLEN),LOC(DATAPTR)  IF NOT, MOVE DATA   S21016
*                                      TO FILL 1 REC TO BUFFER   S21016
         OI    ZAPCNT,ZAPMAX           SET COUNT FIELD OF REC TO S21016
*                                      SHOW 19 ENTRIES (MAXIMUM) S21016
*                                      AND TURN ON CHAIN BIT     S21016
*                                      (BIT 1 OF COUNT BYTE)     S21016
         BAL   TEMPRTN,OUT00990        GO TO WRITE THE RECORD    S21016
         LA    DATAPTR,ZAPLEN(DATAPTR) UPDATE POINTER TO DATA BY S21016
*                                      THE AMOUNT JUST WRITTEN   S21016
         SR    DATALEN,RECLEN          SUBTRACT AMOUNT JUST      S21016
*                                      WRITTEN FROM LENGTH OF    S21016
*                                      DATA REMAINING TO BE      S21016
*                                      PROCESSED                 S21016
         B     ZAPLOOP                 LOOP TO CONTINUE          S21016
*                                      PROCESSING THE REMAINING  S21016
*                                      DATA                      S21016
NOZAP    NI    ZAPCNT,NOZPDATA         TURN CHAIN BIT OFF AND    S21016
*                                      SET COUNT TO ZERO ENTRIES S21016
*                                      FOR THIS RECORD           S21016
         MVI   ZAPDATA,ZEROFILL        PAD UNUSED DATA PORTION   S21016
         MVC   ZAPDAT1(ZPLEN),ZAPDATA  OF RECORD WITH ZEROES     S21016
SHRTZAP  BAL   TEMPRTN,OUT00990        GO TO WRITE THE RECORD    S21016
         B     LKEDREC                 GO TO PROCESS LKED DATA   S21016
*                                      FOR IDR                   S21016
LASTZAP  BCTR  DATALEN,LOC             SUBTRACT ONE FROM DATA    S21016
*                                      LENGTH FOR ZERO-ORIENTED  S21016
*                                      MOVE LENGTH               S21016
         MVI   ZAPDATA,ZEROFILL        PAD UNUSED DATA PORTION   S21016
         MVC   ZAPDAT1(ZPLEN),ZAPDATA  OF RECORD WITH ZEROES     S21016
         EX    DATALEN,MOVEDATA        EXECUTE MOVE OF DATA TO   S21016
*                                      IDR BUFFER FOR SPZAP REC  S21016
         LA    DATALEN,UNIT(DATALEN)   ADD ONE TO DATA LENGTH    S21016
*                                      TO RESTORE NORMAL ONE-    S21016
*                                      ORIENTATION               S21016
         XR    DATAPTR,DATAPTR         ZERO OUT EVEN REG         S21016
*                                      TO CLEAR SIGN BIT         S21016
*                                      FOR DIVIDE (ALWAYS        S21016
*                                      A POSITIVE NUMBER)        S21016
         D     DATASIZE,ZAPSIZE        DIVIDE LENGTH OF DATA     S21016
*                                      IN RECORD BY LENGTH OF    S21016
*                                      A SINGLE DATA ITEM TO     S21016
*                                      DETERMINE THE NUMBER OF   S21016
*                                      ENTRIES IN THIS RECORD    S21016
         STC   ZPCOUNT,ZAPCNT          SET COUNT FIELD OF REC TO S21016
*                                      CORRECT NUMBER OF ENTRIES S21016
*                                      IN THIS RECORD WITH CHAIN S21016
*                                      BIT OFF                   S21016
         LA    ZAPCMPR,CMPRSIZE        GET COMPARISON VALUE      S21016
*                                      FOR NUMBER OF ENTRIES     S21016
*                                      ALLOWED WITHOUT CREATING  S21016
*                                      AN EXTRA (BLANK) REC FOR  S21016
*                                      POSSIBLE FUTURE OVERFLOW  S21016
         CR    ZPCOUNT,ZAPCMPR         DOES THIS RECORD CONTAIN  S21016
*                                      MORE THAN THE CRITICAL    S21016
*                                      NUMBER OF ENTRIES?        S21016
         BNH   SHRTZAP                 IF NOT, BRANCH (THIS WILL S21016
*                                      BE THE LAST IDR WITH      S21016
*                                      SPZAP DATA)               S21016
         OI    ZAPCNT,CHAIN            IF AN ADDITIONAL RECORD   S21016
*                                      IS NEEDED, TURN ON THE    S21016
*                                      CHAIN BIT IN THIS RECORD  S21016
         BAL   TEMPRTN,OUT00990        GO TO WRITE THIS RECORD   S21016
         B     NOZAP                   BRANCH TO CREATE A SPARE  S21016
*                                      RECORD                    S21016
         SPACE 1                                                 S21016
***********************************************************************
*                                                                     *
*              PROCESS IDR LINKAGE EDITOR RECORD                      *
*                                                              S21016 *
***********************************************************************
         SPACE 1                                                 S21016
LKEDREC  LA    WRITECT,LKRECLEN        SET UP RECORD LENGTH FOR  S21016
*                                      WRITE ROUTINE             S21016
         L     REG1,DEFADDR            GET ADDR. OF MDEF         S21016
         USING DEFDSECT,REG1           SET UP ADRESSABABILITY    S21016
*                                      FOR MDEF DSECT            S21016
         PACK  LKRELNO(LEN2),SGRELNO(LEN3)  PACK SYSGEN-ASSIGNED S21016
*                                      OS RELEASE NO. TO LKED    S21016
*                                      IDR HEADER                S21016
         DROP  REG1                    NO LONGER NEEDED          S21016
         SR    REG1,REG1               ZERO OUT REGISTER         S21016
         IC    REG1,LKRELNO+1          GET 2ND BYTE OF REL.NO.   S21016
         SRL   REG1,LEN4               SHIFT OUT SIGN            S21016
         STC   REG1,LKRELNO+1          STORE MODIFICATION LEVEL  S21016
*                                      WITH A LEADING ZERO       S21016
         MVC   IDRBUF(LKLEN),LKIDR     MOVE RECORD HEADER AND    S21016
*                                      LKED IDENTIFYING INFO     S21016
*                                      TO IDR BUFFER             S21016
         ST    TIME,TIMESAVE           SAVE REGISTER 0 BEFORE    S21016
*                                      ISSUEING TIME MACRO       S21016
         TIME  ,            ISSUE TIME MACRO TO GET TODAY'S DATE S21016
         ST    DATE,DATESAVE           STORE TODAY'S DATE AS     S21016
*                                      RETURNED BY TIME MACRO    S21016
         MVC   LKDATE(DATELEN),DATESAV  MOVE TODAY'S DATE TO     S21016
*                                      DATE FIELD OF RECORD (IN  S21016
*                                      PACKED DECIMAL FORMAT)    S21016
         L     TIME,TIMESAVE           RESTORE REGISTER ZERO     S21016
         L     TABADD,IDRTITAB         GET TABLE START ADDRESS  OX04245
         L     TABEND,IDRTIEND         GET TABLE END ADDRESS    OX04245
         CR    TABADD,TABEND           ANY DATA IN TABLE?        S21016
         BNE   TRNSREC                 IF SO, BRANCH TO          S21016
*                                      PROCESS TRANSLATOR DATA   S21016
TRNSDONE EQU   *                       TRNSDONE                  XM5480
         L     TABADD,IDRUDTAB         GET TABLE START ADDRESS   XM5480
         L     TABEND,IDRUDEND         GET TABLE END ADDRESS     XM5480
         CR    TABADD,TABEND           ANY DATA IN TABLE?        S21016
         BNE   USERREC                 IF SO, BRANCH TO          S21016
*                                      PROCESS USER DATA         S21016
USERDONE OI    SUBTYPE,LASTIDR         TURN ON FLAG IN SUBTYPE   S21016
*                                      FIELD OF THIS RECORD TO   S21016
*                                      INDICATE THAT IT IS THE   S21016
*                                      LAST IDR FOR THE LOAD     S21016
*                                      MODULE                    S21016
         BAL   TEMPRTN,OUT00990        GO TO WRITE THE LAST REC  S21016
         LM    WRITECT,TABEND,TEMPSAVE RESTORE REGISTERS         S21016
         BR    TEMPRTN                 RETURN TO CALLER          S21016
         SPACE 1                                                 S21016
***********************************************************************
*                                                                     *
*              PROCESS IDR TRANSLATOR RECORD(S)                       *
*                                                              S21016 *
***********************************************************************
         SPACE 1                                                 S21016
TRNSREC  BAL   TEMPRTN,OUT00990        GO TO WRITE THE LKED IDR  S21016
         MVI   SUBTYPE,TRNSTYPE        MOVE INDICATOR FOR        S21016
*                                      TRANSLATOR DATA TO        S21016
*                                      IDR SUBTYPE FIELD         S21016
         LA    WRITECT,TURECLEN        LOAD RECORD LENGTH FOR    S21016
*                                      WRITE ROUTINE             S21016
         LA    RECLEN,TRUDLEN          LOAD DATA LENGTH FOR ONE OX04245
*                                      OUTPUT RECORD            OX04245
         LA    OBUFPTR,TRUDATA         GET ADDRESS OF OUTPT     OX04245
*                                      BUFFER                   OX04245
         LR    DATAPTR,OBUFPTR         MAHE A COPY IN ORDER TO  OX04245
         AR    DATAPTR,RECLEN          COMPUT POINTER TO END    OX04245
*                                      OF RECORD                OX04245
         ST    DATAPTR,OBUFEND         STORE FOR COMPARISON     OX04245
         LR    DATAPTR,TABADD          POINT TO START OF DATA    S21016
TRNSLOOP EQU   *                       LOOP TO MOVE ONE         OX04245
*                                      TRANSLATOR IDR ITEM      OX04245
         CR    DATAPTR,TABEND          TEST FOR END OF TABLE    OX04245
         BNL   LASTRANS                BRANCH TO WRITE LAST     OX04245
*                                      RECORD                   OX04245
         LA    MVCPTR,HDLEN2(DATAPTR)  POINT TO FIRST ID        OX04245
*                                      OF DOUBLE ITEM           OX04245
         CLI   LOC(DATAPTR),ONETRNS    IS THIS A SINGLE ITEM?   OX04245
         BNE   TRNSID                  NO,  BRANCH              OX04245
         LA    MVCPTR,HDLEN1(DATAPTR)  POINT TO FIRST ID        OX04245
TRNSID   EQU   *                                                OX04245
         LR    DATALEN,MVCPTR          SAVE MVCPTR IN DATALEN   OX04245
*                                      FOR USE AS INDEX         OX04245
TRIDLOOP EQU   *                       ID SEARCH LOOP           OX04245
         CR    DATALEN,TABEND          TEST FOR END OF TABLE    @Z17975
         BNL   LASTRANS                BRANCH TO WRITE LAST REC @Z17975
         TM    LOC(DATALEN),LASTIDR      WAS THIS THE LAST ID?  OX04245
         BO    MOVID                   YES, MOVE IDS            OX04245
         LA    DATALEN,LEN2(DATALEN)   POINT TO NEXT ID         OX04245
         B     TRIDLOOP                BRANCH TO CONTINUE LOOP  OX04245
MOVID    EQU   *                                                OX04245
         LA    DATALEN,LEN2(DATALEN)   POINT PAST LAST ID       OX04245
         ST DATALEN,DPTRSAV            SAVE ADR OF NEXT TAB     OX04245
*                                      ENTRY FOR LATER USE      OX04245
         SR    DATALEN,MVCPTR          COMPUTE DATA LENGTH      OX04245
         BAL   TEMPRTN,TRMOV           YES,MOVE THE IDS         OX04245
         LA    DATALEN,INDCTRLN        GET LENGTH OF FLAG FIELD OX04245
         LR    MVCPTR,DATAPTR          POINT TO START OF HEADER OX04245
         BAL   TEMPRTN,TRMOV           BRANCH TO MOVE THE FLAG  OX04245
         SR    MVCPTR,MVCPTR           ZERO OUT REGISTER        OX04245
         IC    MVCPTR,NAMEPTR(DATAPTR) GET FIRST BYTE OF TABLE  OX04245
*                                      POINTER                  OX04245
         SLL   MVCPTR,LEN8             SHIFT LEFT ONE BYTE      OX04245
         IC    MVCPTR,NAMEPTR+1(DATAPTR) GET SECOND BYTE OF     OX04245
*                                      TABLE POINTER            OX04245
         A     MVCPTR,IDRTRTAB          ADD START ADDRESS OF    OX04245
*                                      TRANSLATOR DATA TABLE    OX04245
         ST    MVCPTR,TEMPSAVE         SAVE POINTER TO TABLE    OX04245
         LA    DATALEN,TRNMLEN         GET TRANSLATOR NAME LEN  OX04245
         BAL   TEMPRTN,TRMOV           BRANCH TO MOV TRANS NAME OX04245
         LA    MVCPTR,YYDDD(DATAPTR)   GET PTR TO FIRST DATE    OX04245
         LA    DATALEN,PKLEN2          GET LENGTH OF FIRST DATE OX04245
         BAL   TEMPRTN,TRMOV           BRANCH TO MOVE           OX04245
*                                      TRANSLATOR DATE          OX04245
         CLI   INDCTR(DATAPTR),ONETRNS IS THIS A DOUBLE ITEM?   OX04245
         BE    TRNSNXT                 IF NOT, BRANCH TO SKIP   OX04245
*                                      REMAINDER OF MOVE        OX04245
         L     MVCPTR,TEMPSAVE         RETRIEVE TABLE POINTER   OX04245
         LA    MVCPTR,TRNMLEN(MVCPTR)  INCREMENT TO NEXT TABLE  OX04245
*                                      ENTRY                    OX04245
         LA    DATALEN,TRNMLEN         GET LENGTH OF TRANSLATOR OX04245
*                                      NAME                     OX04245
         BAL   TEMPRTN,TRMOV           BRANCH TO MOVE 2ND       OX04245
*                                      TRANSLATOR NAME          OX04245
         LA    MVCPTR,YYDDD2(DATAPTR)  GET ADDRESS OF 2ND DATE  OX04245
         LA    DATALEN,PKLEN2          GET LENGTH OF 2ND DATE   OX04245
         BAL TEMPRTN,TRMOV             MOVE IN 2ND DATE         OX04245
TRNSNXT  EQU   *
         L     DATAPTR,DPTRSAV         RETRIEVE POINTER         OX04245
         B     TRNSLOOP                CONTINUE SEARCHING       OX04245
*        ROUTINE TO MOVE ONE FIELD INTO OUTPUT RECORD           OX04245
TRMOV    EQU   *                                                OX04245
         LR    REG10,OBUFPTR           COPY CURRENT BUFFER      OX04245
*                                      POINTER                  OX04245
         AR    REG10,DATALEN           ADD LENGTH OF DATA TO BE OX04245
*                                      MOVED                    OX04245
         C     REG10,OBUFEND           IS THERE ROOM FOR THIS   OX04245
*                                      MOVE?                    OX04245
         BNL   TRMOV1                  NO,BRANCH TO PROCESS     OX04245
*                                      PARTIAL ITEM             OX04245
TRNSREC0 EQU   *                                                OX04245
         BCTR  DATALEN,REG0            DECRE LENGTH FOR MOVE    OX04245
         EX    DATALEN,TREXC           EXECUTE THE MOVE         OX04245
         LR    OBUFPTR,REG10           ADVANCE BUFFER POINTER   OX04245
         BR    TEMPRTN                 RETURN                   OX04245
TREXC    EQU   *                                                OX04245
         MVC   LOC(LOC,OBUFPTR),LOC(MVCPTR) MOVE                OX04245
*                                      INSTRUCTION FOR EXECUTE  OX04245
TRMOV1   EQU   *                       NO ROOM - MOVE AS MUCH   OX04245
*                                      AS POSSIBLE              OX04245
         L     REG10,OBUFEND           GET POINTER TO BUFF END  OX04245
         SR    REG10,OBUFPTR           COMPUTE AVAILABLE SPACE  OX04245
         SR    DATALEN,REG10           COMPUTE LEFTOVER LENGTH  OX04245
         BCTR  REG10,REG0              DECREMENT LENGTH FOR MOV OX04245
         EX    REG10,TREXC             MOVE THE PARTIAL LENGTH  OX04245
         MVI   IDRBYTCT,TRUDMAX        SET BYTE COUNT FOR ONE   OX04245
*                                      RECORD                   OX04245
         AR    MVCPTR,REG10            POINT TO NEW DATA START  OX04245
         LA    MVCPTR,UNIT(MVCPTR)     ADJUST POINTER           OX04245
         LR    REG10,TEMPRTN           SAVE TEMPRTN             OX04245
         BAL   TEMPRTN,OUT00990        GO TO WRITE THE RECORD   OX04245
         LA    OBUFPTR,TRUDATA         GET ADDRESS OF OUTPUT    OX04245
*                                      BUFFER                   OX04245
         LR    TEMPRTN,REG10           RESTORE TEMPRTN          OX04245
         B     TRMOV                   BRANCH TO CONT OUTPUT    OX04245
LASTRANS EQU   *                       END OF TRANSLATOR IDR    OX04245
*                                      DATA                     OX04245
         LA    REG10,IDRBYTCT          GET ADR TO COMPUTE       OX04245
*                                      BYTE COUNT OF OUTPUT RECORD
         SR    OBUFPTR,REG10           SUBTRACT START ADR FROM  OX04245
*                                      CURRENT POINTER          OX04245
         STC   OBUFPTR,IDRBYTCT        STORE BYTE COUNT         OX04245
*                                      INTO BUFFER              OX04245
         LA    WRITECT,UNIT(OBUFPTR)   ADD ONE TO BYTE COUNT    OX04245
*                                      FOR ACTUAL RECORD LENGTH OX04245
         B     TRNSDONE                GO TO PROCESS TRANSLATOR  S21016
*                                      RECORD JUST BUILT AND     S21016
*                                      USER-DATA IDR'S, IF ANY   S21016
         SPACE 1                                                 S21016
***********************************************************************
*                                                                     *
*               PROCESS IDR USER-DATA RECORD(S)                       *
*                                                              S21016 *
***********************************************************************
         SPACE 1                                                 S21016
USERREC  BAL   TEMPRTN,OUT00990        GO TO WRITE LAST IDR WITH S21016
*                                      TRANSLATOR DATA           S21016
         MVI   SUBTYPE,USERTYPE        MOVE INDICATOR FOR        S21016
*                                      USER-SUPPLIED DATA TO     S21016
*                                      IDR SUBTYPE FIELD         S21016
         LA    WRITECT,TURECLEN        LOAD RECORD LENGTH FOR    S21016
*                                      WRITE ROUTINE             S21016
         LR    DATAPTR,TABADD          POINT TO START OF DATA    S21016
         LR    DATALEN,TABEND          LOAD ENDING ADDRESS OF    S21016
*                                      DATA IN TABLE             S21016
         SR    DATALEN,TABADD          SUBTRACT STARTING ADDRESS S21016
*                                      TO OBTAIN LENGTH OF DATA  S21016
USERLOOP LA    RECLEN,TRUDLEN          LOAD DATA LENGTH FOR ONE  S21016
*                                      RECORD                    S21016
         CR    DATALEN,RECLEN          COMPARE LENGTH OF DATA    S21016
*                                      TO LENGTH OF 1 RECORD     S21016
         BNL   USER0020                IF DATA LENGTH IS NOT <   S21016
*                                      RECORD LENGTH, BRANCH     S21016
         LR    RECLEN,DATALEN          ELSE, GET DATA LENGTH     S21016
USER0020 ST    DATAPTR,DPTRSAV         SAVE POINTER TO START OF  S21016
*                                      DATA                      S21016
USER0040 CLC   LOC(LEN2,DATAPTR),NULITEM  IS THIS THE START OF   S21016
*                                      A NULL ITEM?              S21016
         BE    USER0060                IF SO, GO TO SKIP IT      S21016
         LA    DATAPTR,UNIT(DATAPTR)   UPDATE BY ONE BYTE        S21016
         BCT   RECLEN,USER0040         GO TO CONTINUE SCANNING   S21016
*                                      FOR A NULL ITEM UNTIL THE S21016
*                                      COUNT IS EXHAUSTED        S21016
         LA    RECLEN,TRUDLEN          RESTORE NORMAL REC.LENGTH S21016
         L     DATAPTR,DPTRSAV         RESTORE DATA POINTER      S21016
         B     USER0100                GO TO PROCESS THE DATA    S21016
USER0060 ST    DATALEN,DLENSAV         SAVE LENGTH OF DATA       S21016
         MVC   NULLEN(LEN2),LEN2(DATAPTR)  GET LENGTH OF NULL    S21016
*                                      ITEM                      S21016
         LR    DATALEN,DATAPTR         GET STARTING ADDR. OF     S21016
*                                      NULL ITEM                 S21016
         S     DATALEN,DPTRSAV         SUBTRACT STARTING ADDR.   S21016
*                                      OF DATA FOR LENGTH OF     S21016
*                                      GOOD DATA PRECEEDING THE  S21016
*                                      NULL ITEM                 S21016
         LTR   DATALEN,DATALEN         TEST LENGTH OF GOOD DATA  S21016
         BZ    USER0080                IF ZERO, BRANCH           S21016
         CH    DATALEN,NULLEN          IS LENGTH OF GOOD DATA >  S21016
*                                      LENGTH OF NULL ITEM?      S21016
         BNH   USER0070                IF NOT, BRANCH            S21016
         OI    TEMPSW,ON               TURN SWITCH TO INDICATE   S21016
*                                      A TEMPORARY MUST BE USED  S21016
*                                      TO MOVE DATA              S21016
USER0070 LR    MVCPTR,DATAPTR          GET STARTING ADDR. OF     S21016
*                                      NULL ITEM                 S21016
         AH    MVCPTR,NULLEN           ADD LENGTH OF NULL ITEM   S21016
*                                      TO POINT TO END OF IT     S21016
         SR    MVCPTR,DATALEN          SUBTRACT LENGTH OF GOOD   S21016
*                                      DATA TO DETERMINE ADDR.   S21016
*                                      GOOD DATA SHOULD GO TO    S21016
         BCTR  DATALEN,LOC             SUBTRACT 1 FROM LENGTH OF S21016
*                                      GOOD DATA FOR MOVE        S21016
         L     DATAPTR,DPTRSAV         POINT BACK TO START OF    S21016
*                                      GOOD DATA                 S21016
         TM    TEMPSW,ON               IS TEMPORARY NEEDED FOR   S21016
*                                      MOVE?                     S21016
         BNO   USER0075                IF NOT, BRANCH            S21016
         ST    MVCPTR,MPTRSAV          SAVE POINTER TO MOVE      S21016
*                                      DESTINATION               S21016
         LA    MVCPTR,DATATEMP         POINT TO TEMPORARY        S21016
         EX    DATALEN,DATAMVC         MOVE DATA TO TEMPORARY    S21016
         LR    DATAPTR,MVCPTR          POINT TO TEMPORARY        S21016
         L     MVCPTR,MPTRSAV          RESTORE MOVE DESTINATION  S21016
         NI    TEMPSW,OFF              TURN OFF SWITCH           S21016
USER0075 EX    DATALEN,DATAMVC         MOVE THE GOOD DATA OVER   S21016
*                                      THE NULL ITEM             S21016
USER0080 L     DATALEN,DLENSAV         RESTORE THE LENGTH OF     S21016
*                                      DATA REMAINING IN TABLE   S21016
         SH    DATALEN,NULLEN          SUBTRACT LENGTH OF NULL   S21016
*                                      ITEM JUST OVERWRITTEN     S21016
         L     DATAPTR,DPTRSAV         RESTORE THE ADDR. OF NEXT S21016
*                                      DATA TO BE PROCESSED      S21016
         AH    DATAPTR,NULLEN          ADD LENGTH OF NULL ITEM   S21016
         B     USERLOOP                GO TO SEE IF THERE ARE    S21016
*                                      MORE NULL ITEMS           S21016
USER0100 CR    DATALEN,RECLEN          COMPARE LENGTH OF DATA IN S21016
*                                      TABLE TO AMOUNT OF DATA   S21016
*                                      WHICH CAN GO ONTO ONE REC S21016
         BNH   LASTUSER                IF REMAINING DATA CAN GO  S21016
*                                      ONTO ONE RECORD, BRANCH   S21016
         MVI   IDRBYTCT,TRUDMAX        ELSE, SET BYTE COUNT TO   S21016
*                                      MAX LENGTH FOR ONE REC    S21016
         MVC   TRUDATA(TRUDLEN),LOC(DATAPTR)  MOVE DATA FROM     S21016
*                                      TABLE TO FILL ONE RECORD  S21016
*                                      IN BUFFER                 S21016
         BAL   TEMPRTN,OUT00990        GO TO WRITE THE RECORD    S21016
         LA    DATAPTR,TRUDLEN(DATAPTR)  UPDATE POINTER TO DATA  S21016
*                                      BY AMOUNT JUST WRITTEN    S21016
         SR    DATALEN,RECLEN          UPDATE LENGTH OF DATA     S21016
*                                      REMAINING IN TABLE        S21016
         B     USERLOOP                LOOP TO CONTINUE          S21016
*                                      PROCESSING THE            S21016
*                                      REMAINING DATA            S21016
LASTUSER BCTR  DATALEN,LOC             SUBTRACT ONE FROM DATA    S21016
*                                      LENGTH FOR ZERO-ORIENTED  S21016
*                                      MOVE LENGTH               S21016
         EX    DATALEN,MOVETRUD        EXECUTE MOVE OF REMAINING S21016
*                                      DATA TO IDR BUFFER        S21016
         LA    DATALEN,ADDLEN(DATALEN) ADD 3 TO MOVE LENGTH TO   S21016
*                                      GET CORRECT BYTE COUNT    S21016
*                                      FOR THIS RECORD           S21016
         STC   DATALEN,IDRBYTCT        STORE BYTE COUNT INTO     S21016
*                                      BUFFER                    S21016
         LA    WRITECT,UNIT(DATALEN)   ADD ONE TO BYTE COUNT FOR S21016
*                                      ACTUAL RECORD LENGTH      S21016
         B     USERDONE                GO TO PROCESS LAST REC    S21016
*                                                                     *
MOVETRUD MVC   TRUDATA(TRUDLEN),LOC(DATAPTR)
MOVEINST MVC   0(1,TEMP2),0(NOTL1ADD)     MOVE NOTE LIST 1 TO NOTE LST2
ZEROHIID XC    0(1,HIIDTAB),0(HIIDTAB)   ZERO
SAVE1415 DC    2F'0'                    SAVE AREA FOR REGS 14 AND 15
WORD     DC    F'0'
FOUR     DC    H'4'
SWITCH   DC    X'00'               SWITCHES AND INCICATORS
TXTIOLP  EQU   X'80'               TXTIO LOOP INDICATOR
*        OTHER BITS OF SWITCH --SPARE
***********************************************************************
***********************************************************************
TPASSVCN DC    V(HEWLFSCD)              ADDR OF 2ND PASS PROCESSOR
FNALVCON DC    V(HEWLFFNL)              ADDR OF FINAL  PROCESSOR
MAPAD    DC    V(HEWLFMAP)             ADDRESS OF MAP PROCESSOR
DEFADDR  DC    V(HEWLFDEF)             ADDRESS OF MDEF CSECT     S21016
ADHIID   DC    A(SEGLNTAB)         ADDRESS OF ADDRESS OF TABLE
DCBINTER DC    AL4(HEWLCUDB)            SYSUT1 DCB
SYSMDDCB EQU   *
DCBLMOD  DC    AL4(HEWLCMDB)            SYSLMOD DCB
         SPACE 1                                                 S21016
******************** IDR DEFINED CONSTANTS **********************S21016
         SPACE 1                                                 S21016
IDRZHDR  DC    X'80FA0100'             RECORD HEADER FOR IDR     S21016
*                                      SPZAP RECORDS             S21016
ZAPSIZE  DC    F'13'                   SIZE OF AN SPZAP ENTRY    S21016
LKIDR    DC    X'801102'               LKED IDR HEADER           S21016
         DC    CL10'5752SC104'         LKED COMP NAME    S21016,ZA01402
LKRELNO  DS    XL2'2100'               LKED VERSION/MODIFICATION S21016
*                                      LEVEL (=OS RELEASE LEVEL) S21016
NULITEM  DC    X'FFFF'                 NULL ITEM INDICATOR        M1602
DATAMVC  MVC   LOC(LOC,MVCPTR),LOC(DATAPTR)  EXECUTED MOVE       S21016
TEMPSW   DC    X'00'                   'TEMPORARY NEEDED FOR     S21016
*                                      MOVE' SWITCH (WHEN LOW    S21016
*                                      ORDER BIT = 1)            S21016
         SPACE 1                                                 S21016
******************** IDR DEFINED STORAGE ********************    S21016
         SPACE 1                                                 S21016
IDRBUF   DS    CL256                   IDR BUFFER                S21016
DATATEMP DS    CL253                   WORK AREA FOR DATA MOVING S21016
MPTRSAV  DS    F                       SAVEAREA FOR MOVE POINTER S21016
DPTRSAV  DS    F                       SAVEAREA FOR DATA POINTER S21016
DLENSAV  DS    F                       SAVEAREA FOR DATA LENGTH  S21016
TEMPSAVE DS    12F                     TEMPORARY SAVE AREA FOR   S21016
*                                      IDR OUTPUT SUBROUTINE     S21016
TIMESAVE DS    F                       SAVE AREA FOR REG 0       S21016
*                                      FOR TIME MACRO            S21016
DATESAVE DS    F                       SAVE AREA FOR REG 1       S21016
*                                      FOR TIME MACRO            S21016
NULLEN   DS    H                       LENGTH OF A NULL ITEM     S21016
OBUFEND  DS    F                       SAVEAREA FOR BUFFER END  OX04245
         SPACE 2                                                 S21016
*****************************************************************S21016
**********         SYMBOLIC DISPLACEMENTS WITHIN       **********S21016
**********          IDR DEFINED STORAGE FIELDS         **********S21016
*****************************************************************S21016
         SPACE 2                                                 S21016
ZAPDATA  EQU   IDRBUF+4                LOCATION IN IDR BUFFER    S21016
*                                      WHERE SPZAP DATA IS       S21016
*                                      PLACED                    S21016
ZAPDAT1  EQU   IDRBUF+5                SECOND BYTE OF SPZAP DATA S21016
ZAPCNT   EQU   IDRBUF+3                LOCATION OF COUNT FIELD   S21016
*                                      IN IDR BUFFER FOR SPZAP   S21016
*                                      DATA                      S21016
LKDATE   EQU   IDRBUF+15               LOCATION FOR LKED DATE    S21016
*                                      IN IDR BUFFER             S21016
DATESAV  EQU   DATESAVE+1              LOCATION OF 1ST BYTE OF   S21016
*                                      PACKED DECIMAL DATE IN    S21016
*                                      WORD RETURNED BY TIME     S21016
*                                      MACRO                     S21016
SUBTYPE  EQU   IDRBUF+2                LOCATION OF SUBTYPE FIELD S21016
*                                      IN IDR BUFFER             S21016
IDRBYTCT EQU   IDRBUF+1                IDR BYTE COUNT FIELD      S21016
TRUDATA  EQU   IDRBUF+3                STARTING LOCATION OF USER S21016
*                                      OR TRANSLATOR DATA IN IDR S21016
*                                      BUFFER                    S21016
***************** END OF IDR SUPPORT ADDITIONS ***************** S21016
         SPACE 3                                                 S21016
PATCH    DC    C'PATCH AREA',43F'0'  *** MAINTENANCE AREA ***
*
*              TEMPORY ERROR PARMS  -  MESSAGE NUMBER IN DECIMAL
*
DISP1    EQU   X'03'                    DISP=0  SEV = 3
MESS1    EQU   14                       NO TXT IN LOAD MOD
         DS    0F
*
ERRPARM1 DC    AL1(DISP1)               NO TXT IN LOAD MODULE
         DC    AL1(MESS1)
         HEWAPT
DEFDSECT DSECT
         DS    CL4                                               S21016
         DS    AL4                                               S21016
         DS    AL4                                               S21016
         DS    AL4                                               S21016
         DS    CL4                                               S21016
SGRELNO  DS    CL4                     SYSGEN-ASSIGNED OS        S21016
*                                      RELEASE NUMBER            S21016
         END
