         TITLE '***HEWLFIDR*** CSECT IDENTIFICATION RECORD PROCESSOR'
**** START OF SPECIFICATIONS ******************************************
*                                                                     *
*1MODULE-NAME = HEWLFIDR                                              *
*1DESCRIPTIVE-NAME = CSECT IDENTIFICATION RECORD PROCESSOR            *
*1DESCRIPTION = THE IDR MODULE PROCESSES INCOMING LOAD MODULE IDR'S,  *
*              IDR DATA ON OBJECT MODULE END RECORDS, AND USER -      *
*              SUPPLIED IDR DATA FROM THE IDENTIFY CONTROL STATEMENT. *
*1ASSUMPTIONS = N/A                                                   *
*1PERFORMANCE = NOT YET AVAILABLE                                     *
*1FUNCTION = THE FUNCTIONS OF THE CSECT IDENTIFICATION RECORD         *
*            PROCESSOR ARE DEPENDENT ON THE TYPE OF IDR INPUT         *
*            BEING PROCESSED:                                         *
*              LOAD MODULE IDR'S --                                   *
*                  THE IDR DATA IS EXTRACTED FROM THESE RECORDS,      *
*                  EXCEPT FOR THE LINKAGE EDITOR IDR, WHICH IS        *
*                  IGNORED. A CHECK IS MADE TO SEE WHETHER ANY OF THE *
*                  CSECT'S IDENTIFIED IN THE IDR ARE BEING DELETED    *
*                  FROM THE OUTPUT LOAD MODULE. IF SO, THE IDR DATA   *
*                  ASSOCIATED WITH SUCH CSECT'S ARE ALSO DELETED. THE *
*                  DATA WHICH IS NOT TO BE DELETED IS THEN PLACED AT  *
*                  THE END OF THE APPROPRIATE IDR DATA TABLE. IN THE  *
*                  CASE OF TRANSLATOR DESCRIPTIONS, A CHECK IS MADE   *
*                  TO SEE WHETHER AN IDENTICAL DESCRIPTION HAS        *
*                  ALREADY BEEN ENTERED INTO THE TABLE. IF SO, THE    *
*                  CSECT'S ASSOCIATED WITH THE INCOMING ITEM AND      *
*                  THOSE ASSOCIATED WITH THE EXISTING ITEM ARE        *
*                  GROUPED INTO A SINGLE TABLE ENTRY TO AVOID         *
*                  NEEDLESS REPETITION.                               *
*              OBJECT MODULE END RECORDS --                           *
*                  WHEN THESE RECORDS CONTAIN THE IDR DATA FIELD      *
*                  (ONLY PRESENT IF THE TRANSLATOR WHICH PRODUCED THE *
*                  OBJECT MODULE CONTAINS IDR SUPPORT), THAT FIELD IS *
*                  EXTRACTED FROM THE RECORD. THE RENUMBERING TABLE   *
*                  IS SCANNED TO DETERMINE THE CORRECT ESDID'S OF THE *
*                  CSECT'S TO WHICH THE INCOMING TRANSLATOR           *
*                  DESCRIPTION APPLIES. IF ANY OF THESE CSECT'S ARE   *
*                  TO BE DELETED, THEY ARE NOT IDENTIFIED ON THE IDR  *
*                  OUTPUT. IF AT LEAST ONE OF THE CSECT'S ARE TO BE   *
*                  KEPT, THE TRANSLATOR DESCRIPTION IS ADDED TO THE   *
*                  TABLE. AS IN LOAD MODULE INPUT, A CHECK IS MADE    *
*                  FOR A DUPLICATE ITEM AND, IF FOUND, THE TWO ARE    *
*                  COMBINED.                                          *
*              IDENTIFY CONTROL STATEMENT --                          *
*                  THE CESD LINE ASSOCIATED WITH THE CSECT NAME TO BE *
*                  IDENTIFIED IS CHECKED. IF THE NAME IS NOT FOUND IN *
*                  THE CESD AS AN SD-TYPE ENTRY, AN ERROR MESSAGE     *
*                  IS LOGGED, AND PROCESSING TERMINATES. IF THE CSECT *
*                  IS TO BE DELETED, THE IDENTIFY DATA IS IGNORED. IF *
*                  NOT, A CHECK IS MADE TO SEE IF THERE PREVIOUSLY    *
*                  WAS ANY USER-SUPPLIED DATA ASSOCIATED WITH THAT    *
*                  CSECT. IF SO, THE OLD DATA IS REPLACED WITH THE    *
*                  NEW INCOMING DATA. IF NOT, THE INCOMING DATA IS    *
*                  ADDED TO THE END OF THE TABLE.                     *
*            WHENEVER ANY TYPE OF DATA IS BEING ADDED TO ONE OF THE   *
*            TABLES, A CHECK IS FIRST MADE TO DETERMINE WHETHER THE   *
*            ADDITION OF THAT DATA WILL CAUSE A TABLE OVERFLOW        *
*            CONDITION. IF IT WILL, AN ERROR MESSAGE INDICATING THIS  *
*            IS LOGGED, AND PROCESSING IS TERMINATED AT THAT POINT.   *
*1RESTRICTIONS = NONE                                                 *
*1MODULE-TYPE = PROCEDURE                                             *
*    2PROCESSOR = ASSEMBLER                                           *
*    2MODULE-SIZE = NOT YET KNOWN                                     *
*    2CODE-ATTRIBUTES = REUSABLE                                      *
*    2LOAD-ATTRIBUTES = OVERLAY                                       *
*    2MAIN-ENTRY-POINT = HEWLFIDR - TO PROCESS INPUT LOAD MODULE      *
*                                   IDR'S AND OBJECT MODULE END       *
*                                   RECORDS WITH THE IDR FIELD        *
*         3LINKAGE = BALR 14,15                                       *
*         3PARAMETER-RECEIVED = POINTER-TO-PARAMETER-LIST             *
*             4HOW-PASSED = REGISTER 1                                *
*             4LENGTH-OF-LIST = 4 BYTES                               *
*                  5FIELD = POINTER TO INPUT BUFFER                   *
*                       6DISPLACEMENT = 0 BYTES                       *
*                       6TYPE = ADDRESS                               *
*    2SECONDARY-ENTRY-POINT = HEWLCIDR - TO PROCESS IDENTIFY CONTROL  *
*                                        STATEMENT                    *
*         3LINKAGE = BALR 14,15                                       *
*         3PARAMETER-RECEIVED = POINTER-TO-PARAMETER-LIST             *
*             4HOW-PASSED = REGISTER 1                                *
*             4LENGTH-OF-LIST = 12 BYTES                              *
*                  5FIELD = POINTER TO CSECT NAME TO BE IDENTIFIED    *
*                       6DISPLACEMENT = 0 BYTES                       *
*                       6TYPE = ADDRESS                               *
*                  5FIELD = POINTER TO IDENTIFY STRING LENGTH         *
*                       6DISPLACEMENT = 4 BYTES                       *
*                       6TYPE = ADDRESS                               *
*                  5FIELD = POINTER TO IDENTIFY STRING                *
*                       6DISPLACEMENT = 8 BYTES                       *
*                       6TYPE = ADDRESS                               *
*    2EXIT = FINISH                                                   *
*         3PARAMETER-RETURNED = COMPLETION CODE                       *
*             4HOW-PASSED = REGISTER 15                               *
*             4TYPE = ARITHMETIC                                      *
*                 5MODE = BINARY                                      *
*                 5LENGTH = 32 BITS                                   *
*                 5SCALING = N/A                                      *
*                 5VALUE = 0 (NORMAL COMPLETION)                      *
*    2EXIT = ABORT                                                    *
*         3PARAMETER-RETURNED = ERROR CODE                            *
*             4HOW-PASSED = REGISTER 0                                *
*             4TYPE = ARITHMETIC                                      *
*                 5MODE = BINARY                                      *
*                 5LENGTH = 16 BITS                                   *
*                 5VALUE = X'0446' (MSG. IEW0704)                     *
*    2EXIT = TABOVFLO                                                 *
*         3PARAMETER-RETURNED = ERROR CODE                            *
*             4HOW-PASSED = REGISTER 0                                *
*             4TYPE = ARITHMETIC                                      *
*                 5MODE = BINARY                                      *
*                 5LENGTH = 16 BITS                                   *
*                 5VALUE = X'0445' (MSG. IEW0694)                     *
*    2EXTERNAL-PROCEDURE = HEWLFLOG (TO LOG DIAGNOSTIC MESSAGES)      *
*         3PARAMETER-PASSED = MESSAGE CODE (IN REGISTER 0)            *
*         3PARAMETER-RETURNED = NONE                                  *
*    2EXTERNAL-MACRO = HEWAPT                                         *
*         3PARAMETER-PASSED = NONE                                    *
*         3PARAMETER-RETURNED = NONE                                  *
*    2SYSTEM-MACROS = SAVE, RETURN, OPEN, SNAP, CLOSE AND DCB         *
*    2EXTERNAL-TABLES = CESD, RENUMBERING TABLE AND IDR DATA TABLES   *
*                       (IDRTRTAB, IDRUDTAB AND IDRZPTAB)             *
*                                                                     *
**** END OF SPECIFICATIONS ********************************************
         EJECT
***********************************************************************
*                                                                     *
*                 *******************************                     *
*                * MAIN ENTRY POINT --HEWLFIDR-- *                    *
*                 *******************************                     *
*                                                                     *
*        CONTROL IS RECEIVED AT THIS POINT FROM MODULE HEWLFINP       *
*        FOR THE PURPOSE OF ACCEPTING IDR DATA OBTAINED FROM INPUT    *
*        LOAD MODULES AND/OR INPUT OBJECT MODULES.                    *
*                                                                     *
***********************************************************************
         SPACE
HEWLFIDR CSECT
*A000000                                                         S21016
*                                                                XM5507
*C229000-229500,319500-320000,358500-359000                      XM6300
*A311100,C339500-340000,A604600                                 OX01989
*C529000-529275                                                  XM4628
*  SEE FIX FOR XM4628                                           OX02833
*C529125,A604620-604700,D311100,C339500-340000,D604600           XM4950
*D214500-215500,A214100-214400,A219100                           XM4950
* SEE FIX FOR XM4950                                            OX03393
*C137100-137200,138100-138440,140600,154500-156400,             OX04245
* 159500-161400,197000-360766,487000-487400,518100-518400,      OX04245
* 532600-532680,588700-590700,604600-604608                     OX04245
*A360000,I360118                                        XA05783,YM08524
*I199100                                                XA05783,YM08532
*D360118,I280600-280960                                 XA05783,YA04546
*I358986,I359498                                        XA05450,YA05599
*A09960,A599900-599920,A358970-359020,A359495,A359602           OZ01412
*  SEE FIX FOR OZ01412                                          OZ01412
* C349500 AND C351500                                           OZ11107
         SPACE
***********************************************************************
*                                                                     *
*                  EXTERNAL ENTRY POINT DEFINITION                    *
*                                                                     *
***********************************************************************
         SPACE
         ENTRY HEWLCIDR
********************CONTROL PASSED TO THIS EP FROM HEWLFSCN************
         SPACE 3
***********************************************************************
*                                                                     *
*                  SYMBOLIC EQUATES                                   *
*                                                                     *
***********************************************************************
         SPACE 2
********************GENERAL REGISTER EQUATES***************************
         SPACE
NULLREG  EQU   0                       REGISTER USED WHEN NO BRANCHING
*                                      IS DESIRED
GREG0    EQU   0                       GENERAL PURPOSE WORK REGISTER
PARMPTR  EQU   1                       POINTER TO PARAMETER LIST PASSED
*                                      BY CALLING PROGRAM
BUFPTR   EQU   1                       POINTER TO RECORD BEING
*                                      PROCESSED IN INPUT BUFFER
GREG1    EQU   1                       GENERAL PURPOSE WORK REGISTER
APTBASE  EQU   2                       BASE ADDRESS FOR THE ALL
*                                      PURPOSE TABLE DSECT
TABPTR   EQU   3                       POINTER TO START OF IDR DATA
*                                      TABLE
TABNXT   EQU   4                       POINTER TO NEXT AVAILABLE BYTE
*                                      IN IDR DATA TABLE
TABEND   EQU   5                       MAXIMUM LENGTH OF IDR DATA TABLE
ITEMPTR  EQU   6                       POINTER TO IDR ITEM BEING
*                                      PROCESSED
DATAPTR  EQU   7                       POINTER TO PORTION OF ITEM
*                                      BEING EXAMINED
GREG7    EQU   7                       GENERAL PURPOSE WORK REGISTER
ENDBUF   EQU   8                       POINTER TO END OF INPUT RECORD
GREG8    EQU   8                       GENERAL PURPOSE WORK REGISTER
TEMPRTN  EQU   9                       RETURN REGISTER FOR INTERNAL
*                                      SUBROUTINE LINKAGES
CESDPTR  EQU   9                       POINTER TO THE START OF THE
*                                      COMPOSITE ESD TABLE
GREG9    EQU   9                       GENERAL PURPOSE WORK REGISTER
RNTPTR   EQU   10                      POINTER TO THE START OF THE
*                                      RENUMBERING TABLE
GREG10   EQU   10                      GENERAL PURPOSE WORK REGISTER
GREG11   EQU   11                      GENERAL PURPOSE WORK REGISTER
IDRBASE  EQU   12                      BASE ADDRESS FOR MODULE
SAPTR    EQU   13                      POINTER TO CALLING PROGRAM'S
*                                      SAVE AREA
GREG13   EQU   13                      GENERAL PURPOSE WORK REGISTER
RETURN   EQU   14                      RETURN ADDRESS IN CALLING
*                                      PROGRAM
GREG14   EQU   14                      GENERAL PURPOSE WORK REGISTER
ENTRYPT  EQU   15                      ENTRY POINT ADDRESS FOR SYSTEM
*                                      LINKAGES
GREG15   EQU   15                      GENERAL PURPOSE WORK REGISTER
         SPACE 2
*****************SYMBOLIC MASKS AND IMMEDIATE BYTES********************
         SPACE
EXCON    EQU   X'0100'                 INCREMENT CONSTANT       OZ01412
SPZAP    EQU   X'01'                   SUBTYPE VALUE FOR IMASPZAP IDR
LKED     EQU   X'02'                   SUBTYPE VALUE FOR LINK-EDIT IDR
TRANS    EQU   X'04'                   SUBTYPE VALUE FOR TRANSLATOR IDR
USER     EQU   X'08'                   SUBTYPE VALUE FOR USER-DATA IDR
INDTR    EQU   0                       TRANS.TABLE BEING PROCESSED
INDUD    EQU   4                       USER DATA TABLE BEING PROCESSED
INDZP    EQU   8                       IMASPZAP TABLE BEING PROCESSED
INDBR    EQU   12                      TRANS-TAB BEING PROCESSED XM5507
*                                      NOT USING POSTIDR RTN     XM5507
INDNT    EQU   16                      NO TABLE BEING PROCESSED  XM7705
BLANK    EQU   C' '                    FLAG VALUE FOR NO IDR DATA
*                                      ON AN OBJECT MODULE END CARD
SINGLE   EQU   C'1'                    FLAG VALUE FOR SINGLE IDR ENTRY
*                                      ON AN OBJECT MODULE END CARD
DOUBLE   EQU   C'2'                    FLAG VALUE FOR DOUBLE IDR ENTRY
*                                      ON AN OBJECT MODULE END CARD
ONETRNS  EQU   X'00'                   INDICATOR VALUE FOR A SINGLE
*                                      IDR TRANSLATOR DESCRIPTION
DBLSWS   EQU   X'01'                   INDICATOR VALUE FOR A DOUBLE
*                                      IDR TRANSLATOR DESCRIPTION
SWSOFF   EQU   X'00'                   IMMEDIATE BYTE TO RE-INITIALIZE
*                                      ALL IDR SWITCHES TO ZEROES
SWSINIT  EQU   X'13'                   IMMEDIATE BYTE TO RE-INITIALIZE
*                                      THE IDR SWITCHES IN THE APT
PARTOFF  EQU   X'EF'                   IMMEDIATE BYTE TO TURN OFF
*                                      PARTIAL ENTRY INDICATOR
LASTID   EQU   X'80'                   MASK VALUE TO DETERMINE LAST ID
*                                      IN A STRING OF ESDID'S ON AN IDR
*                                      TRANSLATOR ITEM
LSTIDOFF EQU   X'7F'                   IMMEDIATE BYTE TO TURN OFF THE
*                                      HIGH ORDER BIT IN THE LAST
*                                      CESDID IN A STRING OF CESDID'S
LSTIDFND EQU   X'80'                   SWITCH VALUE INDICATING THE
*                                      LAST ID IN A STRING OF CESDID'S
*                                      HAS BEEN FOUND
DELETE   EQU   X'10'                   SUB-CLASSIFICATION OF A CESD
*                                      TYPE MARKED FOR DELETION
AL1VLD   EQU   X'40'                   SWITCH VALUE INDICATING AT
*                                      LEAST ONE CESDID IN A STRING
*                                      IS VALID (NOT DELETE)
TRSWOFF  EQU   X'3F'                   IMMEDIATE BYTE TO TURN OFF
*                                      SWITCHES AL1VLD AND LSTIDFND
*                                      IN LCLSWS
CNTDITM  EQU   X'20'                   SWITCH VALUE INDICATING A
*                                      CONTINUED ENTRY IS BEING
*                                      PROCESSED
CNTDOFF  EQU   X'DF'                   IMMEDIATE BYTE TO TURN OFF
*                                      CONTINUED ENTRY INDICATOR
CNTDID   EQU   X'10'                   SWITCH VALUE INDICATING A
*                                      CONTINUED CESDID IS BEING
*                                      PROCESSED
CNTIDOFF EQU   X'EF'                   IMMEDIATE BYTE TO TURN OFF
*                                      CONTINUED CESDID INDICATOR
ZCHNOFF  EQU   X'BF'                   IMMEDIATE BYTE TO TURN OFF THE
*                                      'CHAIN' BIT IN AN IMASPZAP IDR
SECTDEF  EQU   X'0F'                   MASK VALUE FOR SD TYPE IN CESD
PRIVATE  EQU   X'04'                   MASK VALUE FOR PC IN CESD TYPE
OTHTYPE  EQU   X'0B'                   MASK VALUE FOR ALL BITS IN CESD
*                                      TYPE OTHER THAN PC
LOGIDNT  EQU   X'20'                   SWITCH VALUE TO INDICATE TO THE
*                                      ERROR LOG ROUTINE TO LOG A CARD
*                                      IMAGE WHOSE ADDRESS IS IN REG.1
LOGSOFF  EQU   X'DF'                   MASK VALUE TO TURN OFF LOGIDNT
*                                      SWITCH
HIDSW    EQU   4                       PARTIAL ID INDICATOR
STRSW    EQU   12                      PARTIAL ID-STRING INDICATOR
ITMSW    EQU   8                       PARTIAL TRANS.ITEM INDICATOR
         SPACE 2
*****************SYMBOLIC DISPLACEMENTS AND LENGTHS********************
         SPACE
NODISP   EQU   0                       DISPLACEMENT OF ZERO
SUBTYPE  EQU   2                       SUBTYPE FIELD IN LOAD MOD IDR'S
OBJFLAG  EQU   32                      FLAG FIELD IN OBJECT END CARDS
HEADLEN  EQU   3                       LENGTH OF IDR RECORD-HEADER
NEXTID   EQU   2                       LENGTH OF CESDID FIELD IN IDR
*                                      DATA ITEMS
SNGTRN   EQU   16                      LENGTH OF A SINGLE IDR
*                                      TRANSLATOR DESCRIPTION
SNGTRN1  EQU   12                      LENGTH OF A SINGLE IDR   OX04245
*                                      TRANSLATOR NAME, LEVEL   OX04245
DBLTRN   EQU   31                      LENGTH OF A DOUBLE IDR
*                                      TRANSLATOR DESCRIPTION
DBLTRN1  EQU   24                      LENGTH OF A DOUBLE IDR   OX04245
*                                      TRANSLATOR NAME, LEVEL   OX04245
IDHDR1   EQU   6                       LENGTH OF FLAG,PTR,DATE  OX04245
*                                      HEADER IN TRANS ID TABLE OX04245
IDHDR2   EQU   9                       LENGTH OF FLAG,PTR, TWO  OX04245
*                                      DATES IN TRANS ID TABLE  OX04245
COUNT    EQU   1                       DISPLACEMENT TO THE BYTE COUNT
*                                      FIELD IN LOAD MODULE IDR'S
ADJ      EQU   1                       ADJUSTMENT VALUE FOR COMPUTING
*                                      THE ENDING ADDR. OF A REC.
HALFID   EQU   8                       SHIFT VALUE FOR ONE BYTE
BYTE1    EQU   8                       ONE-BYTE SHIFT           OX04245
BYTE2    EQU   1                       ONE-BYTE DISPLACEMENT
RNTINDX  EQU   2                       SHIFT VALUE TO GET INDEX INTO
*                                      THE RENUMBERING TABLE
CESDINDX EQU   4                       SHIFT VALUE TO GET INDEX INTO
*                                      THE CESD
IDLEN    EQU   2                       LENGTH OF A CESDID
HIDLEN   EQU   1                       LENGTH OF HALF A CESDID
TYPE     EQU   8                       DISPLACEMENT OF TYPE FIELD IN
*                                      A CESD ENTRY
NOLEN    EQU   0                       NULL LENGTH
CESDWDTH EQU   16                      WIDTH OF CESD TABLE
FSTID    EQU   1                       VALUE OF 1ST CESDID
NAMELEN  EQU   8                       LENGTH OF A CSECT NAME
UDCNT    EQU   5                       DISPLACEMENT TO BYTE COUNT FIELD
*                                      IN USER DATA IDR
UDHEAD   EQU   6                       HEADER LENGTH IN USER DATA IDR
FULWD    EQU   4                       LENGTH OF A FULL WORD
HALFWD   EQU   2                       LENGTH OF A HALF WORD     XM4628
USTRLEN  EQU   4                       DISPLACEMENT TO ADDR. OF
*                                      IDENTIFY STRING LENGTH IN
*                                      PARAMETER LIST
UDSTR    EQU   8                       DISPLACEMENT TO ADDRESS OF
*                                      IDENTIFY STRING IN PARAMETER
*                                      LIST
UDLEN    EQU   40                      LENGTH OF IDENTIFY STRING
DATELEN  EQU   3                       LENGTH OF DATE FIELD
RNTYPE   EQU   3                       DISPLACEMENT TO THE ESD TYPE
*                                      FIELD IN AN RNT ENTRY
PKLEN1   EQU   2                       PACKED LENGTH OF V/M     OX04245
*                                      LEVEL IN TRANSLATOR ITEM OX04245
PKLEN2   EQU   3                       PACKED LENGTH OF DATE    OX04245
*                                      IN TRANSLATOR ITEM       OX04245
PKLEN    EQU   PKLEN1+PKLEN2           PACKED LENGTH OF V/M     OX04245
*                                      LEVEL, DATE IN TRANS IDR ITEM
UPLEN    EQU   9                       UNPACKED LENGTH OF V/M   OX04245
*                                      LEVEL,DATE IN OBJ.END    OX04245
*                                      RECD IDR FIELD           OX04245
PCKADJ   EQU   14                      OFFSET FOR PAKING ALGORITHM
*                                      EQUALS VVMM+UPLEN-PKLEN  OX04245
TRNMLEN  EQU   10                      LENGTH OF TRANSLATOR NAME IN
*                                      OBJ.END REC. IDR FIELD
TRNM1    EQU   33                      DISPLACEMENT TO THE TRANSLATOR
*                                      NAME ON AN OBJ.END WITH IDR
TRNM2    EQU   52                      DISPLACEMENT TO THE 2ND TRANS.
*                                      NAME ON AN OBJ.END WITH IDR
VM1      EQU   43                      DISPLACEMENT TO THE V/M  OX04245
*                                      LEVEL ON AN OBJ.END IDR  OX04245
VM2      EQU   62                      DISPLACEMENT TO THE 2ND  OX04245
*                                      V/M LVL ON AN OBJ.END WITH IDR
YD1      EQU   47                      DISPLACEMENT TO DATE     OX04245
*                                      ON OBJ END IDR           OX04245
YD2      EQU   66                      DISPLACEMENT TO 2ND DATE OX04245
*                                      ON OBJ END IDR           OX04245
UDMAXLEN EQU   46                      MAXIMUM LENGTH OF A USER DATA
*                                      ITEM ON A LOAD MODULE IDR
ZAPLEN   EQU   13                      LENGTH OF AN IMASPZAP DATA ENTRY
MSGLEN   EQU   79                      LENGTH OF MESSAGE LINE - 1
         SPACE 3
***********************************************************************
*                                                                     *
*                  END OF SYMBOLIC EQUATES                            *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
***********************************************************************
**********                                                   **********
**********           EXECUTEABLE CODE BEGINS HERE            **********
**********                                                   **********
***********************************************************************
***********************************************************************
         SPACE 2
         SAVE  (14,12),T,*             SAVE CALLING PROGRAM'S REGISTERS
         BALR  IDRBASE,NULLREG         LOAD BASE ADDRESS
         USING START,IDRBASE           ESTABLISH ADDRESSABILITY FOR
*                                      MODULE
         USING APTDSECT,APTBASE        ESTABLISH ADDRESSABILITY FOR
*                                      THE ALL PURPOSE TABLE
START    MVI   TABIND,INDNT            INITIALIZE TABLE TYPE INDICATOR
         L     BUFPTR,NODISP(PARMPTR)  LOAD ADDR. OF INPUT RECORD
         TM    IDRSWS,OBJIDR           IS INPUT AN OBJECT END CARD?
         BZ    TESTLMOD                NO, BRANCH
         CLI   OBJFLAG(BUFPTR),BLANK   IF IT IS, DOES IT CONTAIN THE
*                                      IDR FIELD?  (BLANK IN COL.33
*                                      INDICATES NO IDR DATA PRESENT)
         BE    FINISH                  IF NOT, RETURN
         CLI   OBJFLAG(BUFPTR),DOUBLE  IS IDR DATA A DOUBLE ENTRY?
         BNE   ONENTRY                 IF NOT, BRANCH
         OI    IDRSWS,DBLOBJ           IF IT IS, TURN ON THE DOUBLE
*                                      ENTRY INDICATOR
         B     IDRTRANS                GO TO PROCESS THE IDR DATA
ONENTRY  CLI   OBJFLAG(BUFPTR),SINGLE  IS IDR DATA A SINGLE ENTRY?
         BNE   FINISH                  IF NOT, THE FLAG FIELD IS
*                                      INVALID FOR IDR -- IGNORE
*                                      THE RECORD
         B     IDRTRANS                IF IT IS, GO TO PROCESS IT
TESTLMOD TM    IDRSWS,LMDIDR           IS INPUT A LOAD MODULE IDR?
         BNO   ABORT                   IF NOT, IT IS AN ERROR
         TM    SUBTYPE(BUFPTR),LKED    IS IT A LINK-EDIT RECORD?
         BO    FINISH                  IF IT IS, RETURN
         SR    ENDBUF,ENDBUF           ZERO REGISTER TO RECEIVE COUNT
         IC    ENDBUF,COUNT(BUFPTR)    GET BYTE COUNT FOR RECORD
         LA    ENDBUF,ADJ(ENDBUF,BUFPTR) GET ADDRESS OF END OF RECORD
         TM    SUBTYPE(BUFPTR),SPZAP   IS THIS AN IMASPZAP RECORD?
         BO    IDRSPZAP                IF IT IS, BRANCH
         TM    SUBTYPE(BUFPTR),TRANS   IS IT A TRANSLATOR RECORD?
         BO    IDRTRANS                IF IT IS, BRANCH
         TM    SUBTYPE(BUFPTR),USER    IS IT A USER-DATA RECORD?
         BO    IDRIDENT                IF IT IS, BRANCH
         B     ABORT                   IF NONE OF THE ABOVE BRANCHES
*                                      HAVE BEEN TAKEN, THE SUBTYPE
*                                      FIELD OF THE RECORD CONTAINS
*                                      AN INVALID CODE
         EJECT
***********************************************************************
***********************************************************************
****                                                               ****
****     SUB-PROGRAM IDRTRANS PROCESSES INPUT LOAD MODULE IDR'S    ****
****     WITH TRANSLATOR DATA AND OBJECT MODULE END RECORDS        ****
****     WITH THE IDR TRANSLATOR IDENTIFICATION FIELD              ****
****                                                               ****
***********************************************************************
***********************************************************************
         SPACE 2
IDRTRANS EQU   *                                                OX04245
         LA    TABNXT,IDRTRCUR         GET CURRENT TAB SIZE PTR OX04245
         ST    TABNXT,TABCURAD         SAVE THE POINTER         OX04245
         L     TABNXT,IDRTIEND         GET ADDRESS OF NEXT      OX04245
*                                      BYTE IN TABLE
         L     TABEND,IDRTITAB         GET STARTING ADDRESS OF  OX04245
*                                      TRANSLATOR ID TABLE      OX04245
         LR    TABPTR,TABEND           INIT TABPTR FOR CLEANUP  YM08532
         AH    TABEND,IDRTILEN         GET ENDING ADDRESS OF    OX04245
*                                      TRANSLATOR ID TABLE      OX04245
         L     RNTPTR,RECNT            GET ADDRESS OF RNT       OX04245
         L     CESDPTR,CHESD           GET THE ADDRESS OF THE CESD
         LA    ITEMPTR,HEADLEN(BUFPTR) POINT TO FIRST DATA ITEM IN REC
         TM    IDRSWS,PARTENT          IS LAST ITEM IN TABLE A PARTIAL
*                                      ENTRY?
         BO    CONTIN                  IF SO, BRANCH
         C     TABNXT,IDRTITAB         FIRST ENTRY IN TABLE?    OX04245
         BNE   HDPTR                   NO, USE IDRTICUR         OX04245
         SR    GREG11,GREG11           ZERO OUT WORK REGISTER   OX04245
         STH   GREG11,LASTPTR          INITIALIZE LASTPTR       OX04245
         B     HDPTR1                  BRANCH TO ZERO TABNXTSV  OX04245
HDPTR    EQU   *                                                OX04245
         LR    GREG11,TABNXT           COPY NEXT AVAILABLE BYTE OX04245
         S     GREG11,IDRTITAB         MAKE A RELATIVE ADR      OX04245
*                                      DONT USE IDRTICUR        OX04245
HDPTR1   EQU   *                                                OX04245
         STH   GREG11,TABNXTSV         SAVE AS POINTER TO START OX04245
*                                      OF HEADER                OX04245
         LA    TABNXT,IDHDR2(TABNXT)   SET POINTER TO           OX04245
*                                      TEMPORARY WORK AREA      OX04245
         TM    IDRSWS,OBJIDR           IS OBJECT MODULE INDICATOR ON?
         BO    TRANSOBJ                IF SO, GO TO POST        OX04245
         TM    IDRSWS,LMDIDR           IS LOAD MODULE INDICATOR ON?
         BNO   ABORT                   IF NOT, IT IS AN ERROR   OX04245
SCNITM   EQU   *                                                OX04245
         LR    DATAPTR,ITEMPTR         POINT TO START OF DATA FOR
*                                      CURRENT ITEM
SCNITM1  EQU   *                                                OX04245
         LA    GREG11,NEXTID(DATAPTR)  GET ENDING ADDR. OF THIS ID
         TM    LCLSWS,CNTDID           IS THIS A CONTINUED ID?
         BO    SCNITM04                IF SO, BRANCH
         CR    GREG11,ENDBUF           IS IT COMPLETE IN THIS RECORD?
         BH    PRTLID                  IF NOT, BRANCH
SCNITM04 TM    NODISP(DATAPTR),LASTID  IS THIS THE LAST CESDID FOR THE
*                                      CURRENT ITEM?
         BNO   SCNITM3                 IF NOT, BRANCH           OX04245
         OI    LCLSWS,LSTIDFND         TURN ON 'LAST ID FOUND' SWITCH
         NI    NODISP(DATAPTR),LSTIDOFF  TURN OFF HIGH ORDER BIT OF ID
SCNITM3  SR    GREG11,GREG11           ZERO WORK REG 11         OX04245
         IC    GREG11,NODISP(DATAPTR)  GET 1ST BYTE OF ID       OX04245
         SLL   GREG11,HALFID           SHIFT FOR SECOND BYTE    OX04245
         IC    GREG11,BYTE2(DATAPTR)   GET SECOND BYTE          OX04245
         SLL   GREG11,RNTINDX          MULT BY 4 TO GET INDEX   OX04245
*                                      TO RNT TABLE             OX04245
         LA    GREG11,NODISP(RNTPTR,GREG11)  GET ADDRESS OF     OX04245
*                                      RENUMBERED  ESDID        OX04245
         TM    RNTYPE(GREG11),DELETE   ENTRY MARKED DELETE?     OX04245
         BO    SCNITM6                 IF SO, BRANCH TO SKIP    OX04245
*                                      FURTHER PROCESSING       OX04245
         MVC   NODISP(IDLEN,DATAPTR),NODISP(GREG11) MOVE        OX04245
*                                      NEW ID TO INPUT          OX04245
*                                      BUFFER FOR PROCESSING    OX04245
         LH    GREG11,NODISP(GREG11)   GET RENUMBERED CESDID    OX04245
         SLL   GREG11,CESDINDX         MULTIPLY BY 16 TO        OX04245
*                                      GET CESD INDEX           OX04245
         AR    GREG11,CESDPTR          GET ADDRESS OF CESD LINE OX04245
         TM    TYPE(GREG11),DELETE     SECTION MARKED FOR DELETION?
         BO    SCNITM6                 YES, DONT MOVE TO ID TABLE
         BAL   GREG14,MOVEID0          MOVE ID TO TRANS ID TAB  OX04245
SCNITM6  EQU   *                                                OX04245
         TM    LCLSWS,AL1VLD+LSTIDFND  AT LEAST ONE VALID ID    OX04245
*                                      FOUND OR LAST ID         OX04245
*                                      FOUND?                   OX04245
         BNO   GETNXT                  IF NOT BOTH TRUE,        OX04245
*                                      BRANCH                   OX04245
         BCTR  TABNXT,NULLREG          BACK UP ONE ID           OX04245
         BCTR  TABNXT,NULLREG          TO GET TO PREVIOUS       OX04245
         OI    NODISP(TABNXT),LASTID   MARK LAST ID             OX04245
GETNXT   EQU   *                                                OX04245
         LA    ITEMPTR,NEXTID(ITEMPTR)  INCREMENT BUFFER POINTER
*                                      TO NEXT ID               OX04245
         CR    ITEMPTR,ENDBUF          AT END OF RECORD?        OX04245
         BNL   PRTLSTR                 IF SO, BRANCH TO PROCESS BROKEN
*                                      STRING                   OX04245
STCNTIN  EQU   *                                                OX04245
         NI    LCLSWS,CNTDOFF          TURN OFF CONT ID SWITCH  OX04245
         TM    LCLSWS,LSTIDFND         WAS THIS THE LAST CESDID OX04245
         BNO   SCNITM                  NO, LOOP TO CONTINUE SCN OX04245
PREDESC  EQU   *                                                OX04245
         L     GREG11,IDRTITAB         GET ADDRESS OF HEADER    OX04245
         AH    GREG11,TABNXTSV         FROM SAVED POINTER       OX04245
         CLI   INDCTR(ITEMPTR),ONETRNS IS THIS ITEM A SINGLE    OX04245
*                                      TRANSLATOR DESCRIPTION?  OX04245
         BNE   PREDESC2                NO,BRANCH                OX04245
         LA    DATAPTR,SNGTRN(ITEMPTR) GET ADDRESS OF END OF    OX04245
*                                      ITEM                     OX04245
         TM    LCLSWS,CNTDITM          CONTINUED ITEM          @ZA14611
         BO    CNTITEM1                YES, BRANCH             @ZA14611
         CR    DATAPTR,ENDBUF          COMPLETE IN THIS RECORD? OX04245
         BH    PRTLITEM                NO,BRANCH                OX04245
CNTITEM1 TM    LCLSWS,AL1VLD           AT LEAST ON VALID ID?   @ZA14611
         BZ    TRFIN                   NO, DONT MOVE TRANS DATA OX04245
         LA    ITEMPTR,ADJ(ITEMPTR)    INCREMENT TO POINT       OX04245
*                                       TO FIRST TRANS NAME     OX04245
         MVC   YYDDD(DATELEN,GREG11),SNGTRN1(ITEMPTR) MOVE FIRST
*                                      DATE TO HEADER           OX04245
         B     TRDESC0                 BRANCH TO PROCESS        OX04245
PREDESC2 EQU   *                                                OX04245
         LA    DATAPTR,DBLTRN(ITEMPTR) GET ADDRESS OF END OF ITEM
         TM    LCLSWS,CNTDITM          CONTINUED ITEM?         @ZA14611
         BO    CNTITEM2                YES, BRANCH             @ZA14611
         CR    DATAPTR,ENDBUF          COMPLETE IN THIS RECORD? OX04245
         BH    PRTLITEM                NO, BRANCH TO PROCESS    OX04245
*                                      CONTINUED RECORD         OX04245
CNTITEM2 TM    LCLSWS,AL1VLD           AT LEAST ONE VALID ID?  @ZA14611
         BZ    TRFIN                   NO, DONT MOVE TRANS DATA OX04245
         LA    GREG7,SNGTRN(ITEMPTR)  POINT TO SECOND ITEM      OX04245
         LA    ITEMPTR,ADJ(ITEMPTR)    INCREMENT TO POINT       OX04245
*                                      TO FIRST TRANS NAME      OX04245
         MVC   YYDDD(DATELEN,GREG11),SNGTRN1(ITEMPTR) MOVE FIRST
*                                      DATE TO HEADER           OX04245
         MVC   YYDDD2(DATELEN,GREG11),SNGTRN1(GREG7) MOVE 2ND   OX04245
*                                      TRANSLATOR DATE          OX04245
         MVC   SNGTRN1(SNGTRN1,ITEMPTR),NODISP(GREG7) SQUISH    OX04245
*                                      NAMES TOGETHER FOR TABLE SEARCH
         OI    IDRSWS,DBLOBJ           TURN ON DOUBLE SWITCH    OX04245
         B     DBLTRNS                 BRANCH TO PROCESS DATA
         EJECT
         SPACE 3
*********************************************************************
*******            THE FOLLOWING SECTION OF CODE              *******
*******          HANDLES TRANSLATOR IDR ITEMS THAT            *******
*******            ARE EXPECTED TO BE CONTINUED               *******
*******                 ON THE NEXT RECORD                    *******
*********************************************************************
         SPACE 1
PRTLID   MVI   PTLSWCH,HIDSW           TURN ON THE HALF-ID INDICATOR
         MVC   ID1ST(HIDLEN),NODISP(DATAPTR)  MOVE IN THE HALF-ID
         B     PARTIAL                 GO TO POST THE PARTIAL ITEM
PRTLSTR  MVI   PTLSWCH,STRSW           TURN ON THE STRING INDICATOR
PARTIAL  EQU   *                                                OX04245
         ST    TABNXT,IDRTIEND         UPDATE ID TABLE POINTER  OX04245
         MVC   CPYLCLS(ADJ),LCLSWS     COPY LOCAL SWITCHES      OX04245
         OI    IDRSWS,PARTENT          TURN ON PARTIAL ENTRY FLAG
         B     TRFIN3                  LEAVE ROUTINE            OX04245
PRTRMOV  MVC   OBJTRN(NOLEN),NODISP(ITEMPTR)  MOVE PARTIAL TRANSLATOR
*                                      DESCRIPTION TO WORK AREA OX04245
PRTLITEM EQU   *                       HANDLE PARTIAL DESCRIPTION
         SR    DATAPTR,ITEMPTR         GET EXPECTED LENGTH OF ITEM
         SR    ENDBUF,ITEMPTR          GET LENGTH OF PARTIAL ITEM
         STC   ENDBUF,PTLTRLN          SAVE PARTIAL LENGTH      OX04245
         LR    GREG11,ENDBUF           SAVE FOR LATER COMPUTATION
         BCTR  ENDBUF,NULLREG          SUBTRACT 1 FOR MOVE LENGTH
         EX    ENDBUF,PRTRMOV          MOVE IN PARTIAL ITEM DATAOX04245
         SR    DATAPTR,GREG11          COMPUTE CONTINUATION LENGTH
         STC   DATAPTR,XPTRLEN         SAVE CONTINUATION LENGTH OX04245
         MVI   PTLSWCH,ITMSW           TURN ON THE ITEM INDICATOR
         B     PARTIAL                 BRANCH TO SET SWITCHES   OX04245
***********************************************************************
**** CODE TO PROCESS ENTRIES CONTINUED FROM A PREVIOUS RECORD      ****
***********************************************************************
CONTIN   EQU   *
         MVC   LCLSWS(ADJ),CPYLCLS     SET LOCAL SWITCHES TO REFLECT
*                                      STATUS OF PROCESSING FOR
*                                      CONTINUED ITEM
         NI    IDRSWS,PARTOFF          TURN OFF PARTIAL ITEM FLAG
         TM    LCLSWS,AL1VLD           AT LEAST ONE VALID ID?   XA05783
         BO     CONTOK                 YES, BRANCH TO CONTINUE  XA05783
         L     GREG11,IDRTIEND         PREPARE TO RESET PTR     XA05783
         SH    GREG11,HDLEN2           BACK UP NINE BYTES       XA05783
         ST    GREG11,IDRTIEND         RESET IN APT             XA05783
CONTOK   EQU   *                                                XA05783
         TM    PTLSWCH,STRSW           IS IT A CONTINUED ID STRING?
         BO    STCNTIN                 YES, BRANCH TO CONTINUE  OX04245
*                                      PROCESSING THE STRING OF OX04245
*                                      CESDID'S                 OX04245
CONTIN1  EQU   *                                                OX04245
         TM    PTLSWCH,HIDSW           IS IT A CONTINUED ID?    OX04245
         BNO   DSCNTIN                 NO, DO CONTINUED TRANSLATOR
*                                      DATA PROCESSING          OX04245
         IC    GREG11,HEADLEN(BUFPTR)  GET 2ND HALF OF CESDID FROM
*                                      CONTINUATION RECORD
         STC   GREG11,ID2ND            MOVE IT TO WORK AREA
         OI    LCLSWS,CNTDID           TURN ON CONTINUED ID SWITCH
         BCTR  ITEMPTR,NULLREG         CORRECT ITEMPTR POSITIONING
         LA    DATAPTR,ID1ST           POINT TO CONTINUED CESDID
         B     SCNITM1                 GO TO PROCESS IT
DSCNTIN  EQU   *
         SR    GREG7,GREG7             ZERO OUT WORK REGISTER   OX04245
         IC    GREG7,XPTRLEN           GET EXPECTED CONTINUATIONOX04245
*                                      LENGTH                   OX04245
         SR    GREG11,GREG11           ZERO OUT WORK REGISTER   OX04245
         IC    GREG11,PTLTRLN          GET PARTIAL LENGTH       OX04245
         BCTR  GREG7,NULLREG           SUBTRACT ONE FOR MOVE    OX04245
         LA    GREG11,OBJTRN(GREG11)  GET WORK AREA ADDRESS     OX04245
         EX    GREG7,CTDMV             MOVE CONTINUATION TO     OX04245
*                                      TO WORK AREA             OX04245
         LA    BUFPTR,HEADLEN+1(BUFPTR,GREG7) ADJUST BUFFER POINTER
*                                      TO START OF NEXT RECORD  OX04245
         OI    LCLSWS,CNTDITM          TURN ON PARTIAL ITEN INDICATOR
         LA    ITEMPTR,OBJTRN          GET ADR TO ITEMPTR       OX04245
         B     PREDESC                 BRANCH TO HANDLE DESCRIPTION
CTDMV    MVC   NODISP(NOLEN,GREG11),HEADLEN(BUFPTR)  MOVE CONTINUATION
*                                      OF TRANSLATOR DESCRIPTION TO
*                                      WORK AREA
         EJECT
*********************************************************************
*******            THE FOLLOWING SECTION OF CODE              *******
*******             HANDLES THE IDR FIELD OF AN               *******
*******            OBJECT MODULE END RECORD, WHEN             *******
*******                      PRESENT                          *******
*********************************************************************
         SPACE 1
TRANSOBJ EQU   *
         SR    GREG8,GREG8             ZERO REGISTER 8
         LA    DATAPTR,IDTEMP          POINT TO TEMP ID SPACE   OX04245
RNTLOOP  LA    RNTPTR,FULWD(RNTPTR)    UPDATE POINTER TO NEXT RNT ENTRY
         CH    GREG8,NODISP(RNTPTR)    IS THIS ENTRY ZEROES ( END OF
*                                      THE RNT)?
         BE    ADDITEM                 IF SO, BRANCH
         TM    RNTYPE(RNTPTR),SECTDEF  IS THIS AN SD?
         BZ    ADDID                   IF SO, BRANCH TO ADD IT
         TM    RNTYPE(RNTPTR),PRIVATE  COULD THIS BE A PC?
         BNO   RNTLOOP                 IF NOT, GO TO TRY NEXT ENTRY
         TM    RNTYPE(RNTPTR),OTHTYPE  IS THIS ENTRY A PC?
         BNZ   RNTLOOP                 IF NOT, GO TO TRY NEXT ENTRY
ADDID    TM    RNTYPE(RNTPTR),DELETE   IS IT MARKED FOR DELETION?
         BO    RNTLOOP                 IF SO, GO TO TRY NEXT ENTRY
         MVC   IDTEMP(IDLEN),NODISP(RNTPTR)    MOVE ID TO TEMP SPACE
         BAL   GREG14,MOVEID0          ADD ID TO THE TANS ID TABLE
         B     RNTLOOP                 GO TO CONTINUE SEARCH LOOP
ADDITEM  EQU   *                                                OX04245
         LA    ITEMPTR,TRNM1(BUFPTR)  GET ADDRESS OF IDR FIELD  OX04245
         TM    LCLSWS,AL1VLD           WAS AT LEAST 1 VALID ID FOUND?
         BNO   FINISH                  IF NOT, RETURN
         L     GREG11,IDRTITAB         GET ADDRESS OF HEADER    OX04245
         AH    GREG11,TABNXTSV         FROM SAVED POINTER       OX04245
         BCTR  TABNXT,NULLREG          BACK UP 1 ID             OX04245
         BCTR  TABNXT,NULLREG          TO POINT TO LAST         OX04245
         OI    NODISP(TABNXT),LASTID   TURN ON LASTID BIT       OX04245
         PACK  PCKADJ(PKLEN,ITEMPTR),VM1(UPLEN,BUFPTR)          OX04245
*                                      PACK V/M LVL DATE FIELDS OX04245
         MVC   VVMM(PKLEN1,ITEMPTR),PCKADJ(ITEMPTR)             OX04245
*                                      MOVE V/M LVL TO PACKED LOC
         MVC   YYDDD(PKLEN2,GREG11),PCKADJ+PKLEN1(ITEMPTR) MOVE OX04245
*                                      DATE TO HEADER           OX04245
         TM    IDRSWS,DBLOBJ           IS THIS A DOUBLE TRANSLATOR
*                                      DESCRIPTION?             OX04245
         BNO   TRDESC0                 IF NOT SO,BRANCH         OX04245
         MVC   TRNAME2(TRNMLEN,ITEMPTR),TRNM2(BUFPTR) MOVE 2ND TRANS
*                                      NAME TO PACKED LOCATION  OX04245
         PACK  VVMM2(PKLEN,ITEMPTR),VM2(UPLEN,BUFPTR) CONVERT   OX04245
*                                      2ND V/M LVL TO PACKED    OX04245
*                                      FORMAT AND MOVE          OX04245
         MVC   YYDDD2(PKLEN2,GREG11),VVMM2+PKLEN1(ITEMPTR) MOVE OX04245
*                                      2ND DATE TO HEADER       OX04245
         B     DBLTRNS                 BRANCH TO TRANSLATOR DESCRIPTION
*                                      PROCESSING
***********************************************************************
*****    ROUTINE TO ADD ONE ID TO TRANSLATOR ID TABLE            ******
***********************************************************************
MOVEID0  EQU   *                                                OX04245
         OI    LCLSWS,AL1VLD           TURN ON 1 VALID CESDID SWITCH
         LA    GREG11,NEXTID(TABNXT)   GET NEXT ID LOC          OX04245
         CR    GREG11,TABEND           WILL ADDING ID OVERFLOW TABLE?
         BNH   MOVEID1                 NO,NO NEED TO REALLOCATE OX04245
         ST    ENDBUF,SAVR8            SAVE ENDBUF REGISTER     OX04245
         S     RNTPTR,RECNT            MAKE RNT OFFSET RELATIVE OX04245
         S     TABNXT,IDRTITAB         SUBTRACT START ADDRESS   OX04245
*                                      FROM NEXT AVAIL LOC      OX04245
         STH   TABNXT,IDRTICUR         STORE CURRENT TABLE SIZE OX04245
         MVI   TABIND,INDBR            INDICATE RETURN BY REGISTER
         BAL   GREG11,CHKALLOC         GO TO REALLOCATE         OX04245
         L     ENDBUF,SAVR8            RESTORE END BUF REGISTER OX04245
         A     RNTPTR,RECNT            RESTORE PTR TO RNT       OX04245
MOVEID1  EQU   *                                                OX04245
         TM    LCLSWS,LSTIDFND         WAS IT THE LAST ID?      OX04245
         BZ    MOVEID2                  NO,BRANCH               OX04245
         OI    NODISP(DATAPTR),LASTID  TURN ON LAST ID INDIC    OX04245
MOVEID2  EQU   *                                                OX04245
         MVC   NODISP(IDLEN,TABNXT),NODISP(DATAPTR) MOVE ID TO END OF
*                                      TRANSLATOR ID TABLE      OX04245
         LA    TABNXT,NEXTID(TABNXT)   INCREMENT POINTER TO TAB OX04245
         BR    GREG14                  CONTINUE                 OX04245
         EJECT
         SPACE 3
*********************************************************************
*******            THE FOLLOWING SECTION OF CODE              *******
*******            SCANS THE IDR TRANSLATOR TABLE             *******
*******             FOR TRANSLATOR DESCRIPTIONS               *******
*******            IDENTICAL TO THAT ON THE INPUT             *******
*******             RECORD -- IF FOUND, NO NEW                *******
*******                 ENTRY IS MADE                         *******
*********************************************************************
         SPACE 1
TRDESC0  EQU   *                       PREPARE FOR TRANS DATA   OX04245
*                                      TABLE PROCESSING         OX04245
         LA    DATAPTR,SNGTRN1(ITEMPTR) SET DATAPTR TO POINT    OX04245
*                                      TO END OF ITEM           OX04245
         MVI   INDCTR(GREG11),ONETRNS  INDICATE A SINGLE ENTRY  OX04245
         B     TRDESC                  BRANCH TO SCAN ROUTINE   OX04245
DBLTRNS  LA DATAPTR,DBLTRN1(ITEMPTR)   SET DATAPTR TO           OX04245
*                                      POINT TO END OF ITEM     OX04245
         MVI   INDCTR(GREG11),DBLSWS   INDICATE A DOUBLE ENTRY  OX04245
TRDESC   EQU   *                                                OX04245
         LA    TABNXT,NEXTID(TABNXT)   POINT TO NEXT AVAILABLE BYTE
         ST    TABNXT,IDRTIEND         SAVE ID TABLE POINTER    OX04245
         S     TABNXT,IDRTITAB         SUBTRACT START ADDRESS   OX04245
         STH   TABNXT,IDRTICUR         SAVE CURRENT SIZE        OX04245
         L     TABPTR,IDRTRTAB         GET ADR OF TRANSLATOR DATA
*                                      TABLE                    OX04245
         L     TABNXT,IDRTREND         GET ADR OF NEXT AVAILABLE BYTE
         LR    TABEND,TABPTR           SAVE POINTER TO COMPUTE  OX04245
         AH    TABEND,IDRTRLEN         ENDING ADDRESS OF TABLE  OX04245
         MVI   TABIND,INDTR            INDICATE TRANSLATOR DATA OX04245
*                                      TABLE PROCESSING         OX04245
SCANTRT0 EQU   *                       SEARCH FOR A MATCH IN    OX04245
*                                      TRANSLATOR DATA TABLE    OX04245
         CR    TABPTR,TABNXT           AT END OF TABLE?         OX04245
         BNL   NEWITEM                 YES, BRANCH TO ADD NEW ITEM
         TM    IDRSWS,DBLOBJ           IS THIS A DOUBLE ENTRY?  OX04245
         BO    SCANDBL                 YES, BRANCH TO TEST DOUBLE
*                                      LENGTH                   OX04245
         CLC   NODISP(SNGTRN1,ITEMPTR),NODISP(TABPTR) ARE THE  @ZA11107
*                                      TRANSLATORS EQUAL ?     @ZA11107
         BE    MATCH1                  YES, BRANCH TO ROUTINE FOR
*                                      IDENTICAL DESCRIPTIONS   OX04245
         B     SCANTRT1                ELSE BRANCH TO CONTINUE SCAN
SCANDBL  CLC   NODISP(DBLTRN1,ITEMPTR),NODISP(TABPTR) IS THE   @ZA11107
*                               DOUBLE LENGTH ITEM IDENTICAL?  @ZA11107
         BE    MATCH1                  YES, WE HAVE A MATCH - BRANCH
*                                      TO PROCESS IT            OX04245
SCANTRT1 LA    TABPTR,SNGTRN1(TABPTR)   INCREMENT TO NEXT ENTRY OX04245
         B     SCANTRT0                BRANCH TO CONTINUE SCAN  OX04245
***********************************************************************
****     THE FOLLOWING SECTION OF CODE CHECKS FOR                 ****
****       AN IDENTICAL HEADER AND                                ****
****       ADJUSTS IDS AS NECESSARY                               ****
***********************************************************************
NEWITEM  EQU   *                                                OX04245
         BAL   TEMPRTN,POSTIDR         ADD THE NEW ITEM TO TABLE
         ST    TABNXT,IDRTREND         UPDATE TRANS DATA TABLE PTR
         S     TABNXT,IDRTRTAB         COMPUTE CURRENT NO BYTES OX04245
         STH   TABNXT,IDRTRCUR         AND UPDATE IDRTRCUR      OX04245
*        COMPARE LAST ID/DATE ENTRY TO THE CURRENT ONE          OX04245
MATCH1   EQU   *                                                OXO4245
         L     TABNXT,IDRTITAB         GET TRANS ID TABLE PARAMETERS
         AH    TABNXT,TABNXTSV         GET NEXT AVAILABLE BYTE  OX04245
*                                      POINTER                  OX04245
         S     TABPTR,IDRTRTAB         MAKE TABPTR A RELATIVE   OX04245
*                                      POINTER                  OX04245
         STC   TABPTR,NAMEPTR+1(TABNXT)   SAVE ADR OF TRANS NAME
*                                      DATA IN THE WORK AREA    OX04245
         SRL   TABPTR,BYTE1            SHIFT NEXT CHARACTER
         STC   TABPTR,NAMEPTR(TABNXT) STORE 2ND HALF OF POINTER
         L     TABPTR,IDRTITAB         GET ADR OF TRANS ID TAB  OX04245
         L     GREG11,IDRTIEND         RETRIEVE END OF ID STRNG OX04245
         LR    GREG7,TABPTR            COPY PTR TO START OF TAB OX04245
         AH    GREG7,LASTPTR           GET ABS ADR OF LASTPTR   OX04245
         TM    IDRSWS,DBLOBJ           IS THIS A DOUBLE ENTRY?  OX04245
         BNO   SNGHDR                  NO,BRANCH                OX04245
         CR    TABNXT,TABPTR           TEST FOR FIRST ENTRY     OX04245
         BE    TRFIN0                  YES, DONT ATTEMPT SHIFT  OX04245
         CLC   NODISP(IDHDR2,GREG7),INDCTR(TABNXT) THIS HEADER  OX04245
*                                      SAME AS LAST PREVIOUS?   OX04245
         BNE   MATCH2                  NO,NO ADJUSTMENT NEEDED  OX04245
NOHDRSH  EQU   *                       SHIFT NINE SPACES        OX04245
         SH    GREG11,HDLEN2           ADJUST TO POINT TO       OX04245
*                                      NEW END OF TRANS ID TAB  OX04245
         ST    GREG11,IDRTIEND         SAVE POINTER TO END OF TABLE
         SR    GREG11,TABNXT           COMPUTE LENGTH OF MOVE   OX04245
         BCTR  GREG11,NULLREG          DECREMENT FOR MOVE       OX04245
         ST    TABNXT,TABNXTSA         SAVE POINTER             OZ01412
EXLOOP2  EQU   *
         CH    GREG11,H100             LESS THAN 100HEX         OZ01412
         BL    EXMOVE2                 YES GO TO EXMOVE2        OZ01412
         MVC   NODISP(EXCON,TABNXT),IDHDR2(TABNXT)  MOVE 100HEX OZ01412
         LA    TABNXT,EXCON(0,TABNXT)  UPDATE POINTER           OZ01412
         SH    GREG11,H100             UPDATE MOVE COUNT        OZ01412
         BP    EXLOOP2                 IF PLUSS GO TO EXLOOP2   OZ01412
EXMOVE2  EQU   *
         EX    GREG11,IDMOV            SHIFT THE CHARACTERS     OX04245
         L     TABNXT,TABNXTSA         RESTORE POINTER          OZ01412
         L     GREG11,IDRTIEND       CLEANUP AFTER MOVE YA05599,XA05450
         XC    0(IDHDR2,GREG11),0(GREG11)               YA05599,XA05450
         B     MATCH3                  BRANCH TO ENDING ROUTINE OX04245
IDMOV    MVC   NODISP(NOLEN,TABNXT),IDHDR2(TABNXT) DOUBLE LENGTH MOVE
SNGMOV   MVC   IDHDR1(NOLEN,TABNXT),IDHDR2(TABNXT) SINGLE LENGTH MOVE
SNGHDR   EQU   *                                                OX04245
         CR    TABNXT,TABPTR           FIRST TABLE ENTRY?       OX04245
         BE    FSTHDR                  YES, BRANCH TO SHIFT THREE
         CLC   NODISP(IDHDR1,GREG7),INDCTR(TABNXT) THIS ENTRY   OX04245
*                                      SAME AS LAST?            OX04245
         BE    NOHDRSH                 BRANCH TO SHIFT ROUTINE  OX04245
FSTHDR   EQU   *                                                OX04245
         SH    GREG11,HDLEN1           ADJUST TO POINT TO       OX04245
*                                      NEW END OF TABLE         OX04245
         ST    GREG11,IDRTIEND         SAVE POINTER TO END      OX04245
         SR    GREG11,TABNXT           COMPUTE LENGTH OF MOVE   OX04245
         BCTR  GREG11,NULLREG          DECREMENT FOR MOVE       OX04245
         ST    TABNXT,TABNXTSA         SAVE POINTER             OZ01412
EXLOOP   EQU   *
         CH    GREG11,H100             COUNT LESS THAN 100X     OZ01412
         BL    EXMOVE                  YES GO TO EXMOVE         OZ01412
         MVC   IDHDR1(EXCON,TABNXT),IDHDR2(TABNXT) MOVE 100 HEX OZ01412
         LA    TABNXT,EXCON(0,TABNXT)  UPDATE POINTER           OZ01412
         SH    GREG11,H100             UPDATE MOVE COUNT        OZ01412
         BP    EXLOOP                  IF PLUSS GO TO EXLOOP    OZ01412
EXMOVE   EQU   *
         EX    GREG11,SNGMOV           DO THE MOVE              OX04245
         L     TABNXT,TABNXTSA         RESTORE POINTER          OZ01412
         L     GREG11,IDRTIEND       CLEANUP AFTER MOVE YA05599,XA05450
         XC    0(IDHDR2,GREG11),0(GREG11)               YA05599,XA05450
MATCH2   EQU   *                                                OX04245
         LR    GREG7,TABNXT            COPY TABNXT              OX04245
         SR    GREG7,TABPTR            MAKE INTO RELATIVE PTR   OX04245
         STH   GREG7,LASTPTR           SAVE POINTER FOR NEXT    OX04245
*                                      TIME                     OX04245
         B     TRFIN0                                           OX04245
MATCH3   EQU   *                                                OX04245
         LR GREG7,TABNXT               COPY TABNXT              OX04245
         BCTR GREG7,NULLREG            BACK UP TO LAST          OX04245
         BCTR GREG7,NULLREG            ID AND ERASE LASTID      OX04245
         NI NODISP(GREG7),LSTIDOFF     FLAG                     OX04245
***********************************************************************
*        FINAL CLEANUP ROUTINE
***********************************************************************
TRFIN0   EQU   *                                                OX04245
         BCTR  ITEMPTR,NULLREG         BACK TO SING/DBLE FLAG   OX04245
TRFIN    EQU   *                       ENTRY IF NO VALID ID     OX04245
         L     TABNXT,IDRTIEND         GET CURR TRANS ID TAB ENDOX04245
         TM    IDRSWS,LMDIDR           WAS IT A LOAD MODULE?    OX04245
         BNO   TRFIN3                  NO, BRANCH TO EXIT ROUTINE
         TM    LCLSWS,CNTDITM          WAS THIS A CONTINUED ITEM?
         BO    ENDTEST                 YES,NO ADJUSTMENT NEEDED YM08524
         CLI   NODISP(ITEMPTR),ONETRNS SINGLE TRANSLATOR ITEM?  OX04245
         BNE   DBLINC                  NO,BRANCH                OX04245
         LA    BUFPTR,SNGTRN(ITEMPTR)  YES, INCREMENT BUFF PTR  OX04245
         B     ENDTEST                 BRANCH TO OVERFLOW TEST  OX04245
DBLINC   EQU   *                                                OX04245
         LA    BUFPTR,DBLTRN(ITEMPTR)  INCREMENT FOR DOUBLE ITEMOX04245
ENDTEST  EQU   *                                                OX04245
         CR    BUFPTR,ENDBUF           ANY MORE ITEMS IN THIS RECORD?
         BNL   TRFIN3                  NO, EXIT                 OX04245
         MVI   LCLSWS,SWSOFF           RESET LOCAL SWITCHES     OX04245
         LR    ITEMPTR,BUFPTR         POINT TO NEXT ITEM IN RECORD
         NI    IDRSWS,SWSINIT          RE-INITIALIZE IDR SWITCHES
         LR    TABEND,TABPTR           REINIT POINTER TO ID     OX04245
         AH    TABEND,IDRTILEN         TABLE END                OX04245
         L     CESDPTR,CHESD           RESTORE PTR TO CESD      OX04245
         L     RNTPTR,RECNT            RESTORE RNT TABLE PTR    OX04245
         B     HDPTR                   LOOP TO SCAN NEXT ITEM   OX04245
TRFIN3   EQU   *                       TABNXT MUST POINT AT TIEND
         S     TABNXT,IDRTITAB         SUBTRACT START ADR       OX04245
         STH   TABNXT,IDRTICUR         SAVE CURRENT SIZE        OX04245
         B     FINISH                  BRANCH TO EXIT           OX04245
         EJECT
***********************************************************************
***********************************************************************
****                                                               ****
****     SUB-PROGRAM IDRIDENT PROCESSES INPUT LOAD MODULE IDR'S    ****
****     WITH USER DATA AND USER DATA SPECIFIED VIA THE IDENTIFY   ****
****                    CONTROL STATEMENT                          ****
****                                                               ****
***********************************************************************
***********************************************************************
         SPACE 2
IDRIDENT L     TABPTR,IDRUDTAB         GET ADDRESS OF USER DATA TABLE
         LA    TABNXT,IDRUDCUR         GET CURRENT TAB SIZE PTR  YM2013
         ST    TABNXT,TABCURAD         SAVE THE POINTER          YM2013
         L     TABNXT,IDRUDEND         GET ADDRESS OF NEXT AVAILABLE
*                                      BYTE IN TABLE
         LR    TABEND,TABPTR           GET STARTING ADDRESS OF TABLE
         AH    TABEND,IDRUDLEN         GET ENDING ADDRESS OF TABLE
         MVI   TABIND,INDUD            INDICATE USER TABLE PROCESSING
         TM    IDRSWS,LMDIDR           IS LOAD MODULE INDICATOR ON?
         BO    LMODUD                  IF SO, BRANCH
         TM    IDRSWS,USEIDR           IS IDENTIFY CARD SWITCH ON?
         BNO   ABORT                   IF NOT, IT IS AN ERROR
         STM   GREG14,GREG15,SAVR14    SAVE WORK REG. CONTENTS
         ST    GREG10,SAVR10           SAVE WORK REG. CONTENTS
         L     GREG10,NODISP(PARMPTR)  GET ADDRESS OF CSECT NAME
         L     CESDPTR,CHESD           GET CESD ADDRESS - 16
         LA    GREG14,CESDWDTH         PLACE 16 IN INCREMENT REGISTER
         ST    GREG8,SAVR8             SAVE WORK REG. CONTENTS
         LA    GREG8,FSTID             PLACE CESDID OF 1 FOR 1ST ITEM
         LH    GREG15,ENCDC            GET NO. OF ITEMS IN CESD
         SLL   GREG15,CESDINDX         MULT. BY 16 FOR CESD SIZE
         AR    GREG15,CESDPTR          ADD ADDR.OF CESD TP POINT TO
*                                      LAST ENTRY IN THE CESD
         B     INCRMNT                 GO TO INCREMENT THE CESD POINTER
CESDSRCH CLC   NODISP(NAMELEN,GREG10),NODISP(CESDPTR)  COMPARE CSECT
*                                      NAME TO BE IDENTIFIED WITH THIS
*                                      ENTRY IN THE CESD
         BE    NAMEFND                 IF THEY MATCH, BRANCH
BADMTCH  LA    GREG8,FSTID(GREG8)      UPDATE TO NEXT CESDID
INCRMNT  BXLE  CESDPTR,GREG14,CESDSRCH UPDATE POINTER TO NEXT ENTRY IN
*                                      CESD, COMPARE TO END ADDR. OF
*                                      CESD, IF NOT AT END, BRANCH TO
*                                      CONTINUE IN SEARCH LOOP
         B     BADIDENT                NAME NOT FOUND IN CESD -- GO TO
*                                      LOG ERROR MESSAGE
NAMEFND  TM    TYPE(CESDPTR),SECTDEF   IS MATCHING CESD ENTRY AN SD?
         BNZ   BADMTCH                 IF NOT, BRANCH BACK INTO LOOP
         TM    TYPE(CESDPTR),DELETE    IS THIS SD MARKED FOR DELETION?
         BO    BADMTCH                 IF SO, BRANCH BACK INTO LOOP
         STH   GREG8,HTEMP             SAVE MATCHED CESDID
         SPACE 3
*********************************************************************
*******            THE FOLLOWING SECTION OF CODE              *******
*******            SCANS THE IDR USER DATA TABLE              *******
*******            FOR ANY PREVIOUS ENTRY WHICH               *******
*******            SPECIFIES THE SAME CSECT AS                *******
*******            THE IDENTIFY CONTROL CARD BEING            *******
*******            PROCESSED -- IF FOUND, THE OLD             *******
*******            DATA IS REPLACED BY THE NEW DATA           *******
*********************************************************************
         SPACE 1
UDTABSCH CR    TABPTR,TABNXT           TABLE POINTER AT END OF TABLE?
         BE    POSTUD                  IF SO, BRANCH
         CLC   NODISP(IDLEN,TABPTR),HZERO  IS THIS A NULL ITEM?
         BNE   UDTBSR05                IF NOT, BRANCH
         MVC   HTEMP2(IDLEN),NEXTID(TABPTR)  GET LENGTH OF NULL ITEM
         AH    TABPTR,HTEMP2           POINT AFTER NULL ITEM
         B     UDTABSCH                GO TO CONTINUE SCAN
UDTBSR05 SR    GREG8,GREG8             ZERO OUT WORK REGISTER
         IC    GREG8,UDCNT(TABPTR)     GET BYTE COUNT OF USER DATA IN
*                                      THIS ITEM
         LA    GREG8,UDHEAD(GREG8)     GET TOTAL LENGTH OF ITEM
         CLC   NODISP(IDLEN,TABPTR),HTEMP  DOES CESDID OF THIS ITEM
*                                      MATCH ID IN TABLE?
         BE    UDMATCH                 IF SO, BRANCH
         AR    TABPTR,GREG8            UPDATE TO POINT TO NEXT ITEM
         B     UDTABSCH                GO TO CONTINUE SEARCH LOOP
UDMATCH  ST    GREG8,FTEMP             SAVE ITEM LENGTH
         MVC   NODISP(FULWD,TABPTR),FTEMP  NULL ITEM WITH 2 BYTES OF
*                                      ZEROES AND 2-BYTE COUNT
         MVC   NODISP(IDLEN,TABPTR),HZERO  NULL THE ITEM          M1602
POSTUD   MVC   UDID(IDLEN),HTEMP       SAVE CESDID OF THIS ITEM
         L     GREG8,USTRLEN(PARMPTR)  GET ADDR. OF DATA LENGTH
         LH    GREG8,NODISP(GREG8)     GET LENGTH OF IDENTIFY DATA
         STC   GREG8,UDBTCT            STORE DATA LENGTH
         LA    ITEMPTR,UDITEM          GET ADDR. OF ITEM TO BE POSTED
         LA    GREG8,UDHEAD(GREG8)     GET LENGTH OF ITEM
         LR    DATAPTR,ITEMPTR         GET BEGINNING ADDR. OF ITEM
         AR    DATAPTR,GREG8           GET ENDING ADDR. OF ITEM
         L     GREG8,UDSTR(PARMPTR)    GET ADDR. OF USER DATA
         MVC   UDATA(UDLEN),NODISP(GREG8)  MOVE USER DATA
         STM   GREG0,GREG1,SAVR0       SAVE WORK REG. CONTENTS
         TIME  ,                       GET TODAY'S DATE
         ST    GREG1,FTEMP             SAVE DATE
         MVC   UDATE(DATELEN),DATESAV  MOVE DATE TO ITEM
         LM    GREG0,GREG1,SAVR0       RESTORE WORK REG. CONTENTS
         BAL   TEMPRTN,POSTIDR         GO TO POST THIS ITEM
         LM    GREG14,GREG15,SAVR14    RESTORE WORK REG. CONTENTS
         L     GREG8,SAVR8             RESTORE WORK REG. CONTENTS
         L     GREG10,SAVR10           RESTORE WORK REG. CONTENTS
         ST    TABNXT,IDRUDEND         UPDATE POINTER TO NEXT
*                                      AVAILABLE BYTE IN TABLE
         MVI   MSGBUF,BLANK            PLACE BLANK IN MSG BUFFER
         MVC   MSGBUFF(MSGLEN),MSGBUF  BLANK OUT MESSAGE LINE
         L     GREG14,NODISP(PARMPTR)  GET ADDRESS OF CSECT NAME
         MVC   MSGNAME(NAMELEN),NODISP(GREG14)  MOVE CSECT NAME INTO
*                                      MESSAGE LINE
         L     GREG14,UDSTR(PARMPTR)   GET ADDRESS OF USER DATA
         MVC   MSGDATA(UDLEN),NODISP(GREG14)  MOVE USER DATA INTO
*                                      MESSAGE LINE
         LH    GREG0,GOODIDNT          GET MESSAGE CODE
         ST    GREG1,SAVR1             SAVE REG. 1 CONTENTS
         LA    GREG1,MSGBUF            POINT TO MESSAGE BUFFER
         OI    IDRSWS,LOGIDNT          TURN IDENT OPTION SWITCH FOR LOG
         L     ENTRYPT,ERDIG           GET ADDRESS OF MESSAGE LOGGING
*                                      ROUTINE
         BALR  RETURN,ENTRYPT          LINK TO LOGGING ROUTINE
         NI    IDRSWS,LOGSOFF          TURN OFF LOG SWITCH
         L     GREG1,SAVR1             RESTORE REG. 1
         B     USERCUR                 RETURN TO CALLING ROUTINEOX04245
         EJECT
*********************************************************************
*******            THE FOLLOWING SECTION OF CODE              *******
*******              HANDLES LOAD MODULE IDR'S                *******
*******             CONTAINING USER DATA ITEMS                *******
*********************************************************************
         SPACE 1
LMODUD   LA    ITEMPTR,HEADLEN(BUFPTR) GET STARTING ADDR. OF 1ST ITEM
*                                      ON THE RECORD
         TM    IDRSWS,PARTENT          IS THIS A CONTINUATION FROM THE
*                                      PREVIOUS RECORD?
         BNO   RECSCAN                 IF NOT, BRANCH
         MVC   PRTLEN(FULWD),NODISP(TABNXT)  GET THE LENGTH OF THE
*                                      PARTIAL ITEM
         STM   GREG8,GREG9,SAVR8       SAVE WORK REG. CONTENTS
         L     GREG8,PRTLEN            GET PARTIAL ITEM LENGTH
         BCTR  GREG8,NULLREG           SUBTRACT 1 FOR MOVE LENGTH
         EX    GREG8,CNTDMOV           MOVE PARTIAL ITEM TO WORK AREA
         LA    GREG8,UDMAXLEN          GET MAXIMUM LENGTH OF A USER
*                                      DATA ITEM
         L     GREG9,PRTLEN            GET LENGTH OF PARTIAL ITEM
         SR    GREG8,GREG9             GET LENGTH OF CONTINUED ITEM
         LA    ITEMPTR,UDITEM          POINT TO START OF ITEM
         AR    GREG9,ITEMPTR           GET ADDR. FOR CONTINUATION TO
*                                      START
         BCTR  GREG8,NULLREG           SUBTRACT 1 FOR MOVE LENGTH
         EX    GREG8,MOVCTN            MOVE CONTINUATION OF ITEM TO
*                                      WORK AREA
         OI    LCLSWS,CNTDITM          TURN ON CONTINUATION SWITCH
         NI    IDRSWS,PARTOFF          TURN OFF PARTIAL ENTRY SWITCH
         LM    GREG8,GREG9,SAVR8       RESTORE WORK REGISTERS
RECSCAN  LA    DATAPTR,UDHEAD(ITEMPTR) GET STARTING ADDR. OF DATA
         TM    LCLSWS,CNTDITM          IS THIS A CONTINUED ITEM?
         BO    RCSCN040                IF SO, BRANCH
         CR    DATAPTR,ENDBUF          IS THIS A PARTIAL ENTRY?
         BH    PRTLUD                  IF SO, BRANCH
RCSCN040 SR    GREG0,GREG0             ZERO WORK REGISTER
         IC    GREG0,UDCNT(ITEMPTR)    GET DATA BYTE COUNT
         AR    DATAPTR,GREG0           GET ENDING ADDR. OF ITEM
         TM    LCLSWS,CNTDITM          IS THIS A CONTINUED ITEM?
         BO    RCSCN080                IF SO, BRANCH
         CR    DATAPTR,ENDBUF          IS THIS A PARTIAL ENTRY?
         BH    PRTLUD                  IF SO, BRANCH
RCSCN080 MVC   HTEMP(IDLEN),NODISP(ITEMPTR)  SAVE INPUT CESDID
         LH    RNTPTR,HTEMP            GET INPUT CESDID
         SLL   RNTPTR,RNTINDX          GET INDEX INTO THE RNT
         A     RNTPTR,RECNT            ADD STARTING ADDR. OF RNT
         TM    RNTYPE(RNTPTR),DELETE   IS THIS CSECT MARKED DELETE?
         BO    NXTITEM                 IF SO, SKIP THIS ITEM
         MVC   NODISP(IDLEN,ITEMPTR),NODISP(RNTPTR)  MOVE RENUMBERED
*                                      CESDID TO THE ITEM
         BAL   TEMPRTN,POSTIDR         GO TO POST THE ITEM
NXTITEM  TM    LCLSWS,CNTDITM          WAS THIS A CONTINUED ITEM?
         BNO   NOTCNTD                 IF NOT, BRANCH
         SR    DATAPTR,ITEMPTR         GET LENGTH OF ITEM
         S     DATAPTR,PRTLEN          GET LENGTH OF CONTINUATION
         STH   DATAPTR,HTEMP           SAVE LENGTH OF CONTINUATION
         LA    DATAPTR,HEADLEN(BUFPTR) GET STARTING ADDR. OF DATA ON
*                                      THE RECORD
         AH    DATAPTR,HTEMP           GET ADDR. OF 1ST ITEM ON RECORD
*                                      AFTER CONTINUATION
         NI    LCLSWS,CNTDOFF          TURN OFF CONTINUATION SWITCH
NOTCNTD  LR    ITEMPTR,DATAPTR         UPDATE TO POINT TO NEXT ITEM
         CR    DATAPTR,ENDBUF          IS THIS THE LAST ITEM ON THE
*                                      RECORD?
         BE    UDFIN                   IF SO, BRANCH
         B     RECSCAN                 GO TO CONTINUE SCANNING RECORD
CNTDMOV  MVC   UDITEM(NOLEN),FULWD(TABNXT)  MOVE PARTIAL ITEM SAVED IN
*                                      TABLE TO WORK AREA
MOVCTN   MVC   NODISP(NOLEN,GREG9),HEADLEN(BUFPTR)  MOVE CONTINUATION
*                                      OF PARTIAL ITEM TO WORK AREA
PRTLMOV  MVC   UDITEM(NOLEN),NODISP(ITEMPTR)  MOVE PARTIAL USER DATA
*                                      ITEM TO WORK AREA
         SPACE 3
*********************************************************************
*******            THE FOLLOWING SECTION OF CODE              *******
*******             HANDLES USER DATA IDR ITEMS               *******
*******             THAT ARE INCOMPLETE ON THE                *******
*******           RECORD CURRENTLY BEING PROCESSED            *******
*********************************************************************
         SPACE 1
PRTLUD   OI    IDRSWS,PARTENT          TURN ON PARTIAL ENTRY SWITCH
         LR    GREG11,ENDBUF           GET ENDING ADDR. OF PARTIAL ITEM
         SR    GREG11,ITEMPTR          GET LENGTH OF PARTIAL ITEM
         ST    GREG11,PRTLEN           SAVE LENGTH OF PARTIAL ITEM
         BCTR  GREG11,NULLREG          SUBTRACT 1 FROM LENGTH FOR
*                                      ZERO-ORIENTED MOVE LENGTH
         EX    GREG11,PRTLMOV          MOVE PARTIAL ITEM TO WORK AREA
         LA    ITEMPTR,SAVPTLUD        GET ADDRESS OF PARTIAL ITEM
         L     DATAPTR,PRTLEN          GET LENGTH OF PARTIAL ITEM
         LA    DATAPTR,FULWD(ITEMPTR,DATAPTR)  ADD LENGTH OF ITEM BYTE
*                                      COUNT AND STARTING ADDRESS OF
*                                      ITEM TO GET ENDING ADDRESS
         BAL   TEMPRTN,POSTIDR         POST PARTIAL ITEM
         L     TABNXT,PARTBEG          RESTORE ADDRESS OF NEXT BYTE IN
*                                      TABLE TO START OF PARTIAL ENTRY
UDFIN    ST    TABNXT,IDRUDEND         UPDATE POINTER TO NEXT
*                                      AVAILABLE BYTE IN TABLE
USERCUR  EQU   *                                                OX04245
         L     GREG8,IDRUDEND          GET NEXT USER TAB ADR    OX04245
         S     GREG8,IDRUDTAB          SUBTRACT START ADR       OX04245
         STH   GREG8,IDRUDCUR          STORE CURRENT NO BYTES   OX04245
         B     FINISH                  RETURN TO CALLING ROUTNE OX04245
BADIDENT EQU   *                       LOG ERR. FOR NO SUCH CSECT FOUND
         MVI   MSGBUF,BLANK            PLACE BLANK IN MSG BUFFER
         MVC   MSGBUFF(MSGLEN),MSGBUF  BLANK OUT MESSAGE LINE
         MVC   MSGNAME(NAMELEN),NODISP(GREG10)  MOVE CSECT NAME INTO
*                                      MESSAGE LINE
         L     GREG10,UDSTR(PARMPTR)   GET ADDRESS OF USER DATA
         MVC   MSGDATA(UDLEN),NODISP(GREG10)  MOVE USER DATA INTO
*                                      MESSAGE LINE
         LH    GREG0,BADIDNT           GET MESSAGE CODE
         ST    GREG1,SAVR1             SAVE REG. 1 CONTENTS
         LA    GREG1,MSGBUF            POINT TO MESSAGE BUFFER
         OI    IDRSWS,LOGIDNT          TURN ON OPTION TO LOG A CARD
*                                      NOT IN THE SYSTEM BUFFER
         L     ENTRYPT,ERDIG           GET ADDRESS OF MESSAGE LOGGING
*                                      ROUTINE
         BALR  RETURN,ENTRYPT          LINK TO LOGGING ROUTINE
         NI    IDRSWS,LOGSOFF          TURN OFF LOG OPTION SWITCH
         L     GREG1,SAVR1             RESTORE REG. 1
         B     USERCUR                  RETURN
         EJECT
***********************************************************************
***********************************************************************
****                                                               ****
****     SUB-PROGRAM IDRSPZAP PROCESSES INPUT LOAD MODULE IDR'S    ****
****     WITH DATA ENTERED BY THE SERVICE AID PROGRAM IMASPZAP     ****
****                                                               ****
***********************************************************************
***********************************************************************
         SPACE 2
IDRSPZAP L     TABPTR,IDRZPTAB         GET ADDRESS OF IMASPZAP DATA
*                                      TABLE
         LA    TABNXT,IDRZPCUR         GET CURRENT TAB SIZE PTR  YM2013
         ST    TABNXT,TABCURAD         SAVE THE POINTER          YM2013
         L     TABNXT,IDRZPEND         GET ADDRESS OF NEXT AVAILABLE
*                                      BYTE IN TABLE
         LR    TABEND,TABPTR           GET STARTING ADDRESS OF TABLE
         AH    TABEND,IDRZPLEN         GET ENDING ADDRESS OF TABLE
         MVI   TABIND,INDZP            INDICATE ZAP TABLE PROCESSING
         SR    GREG11,GREG11           ZERO WORK REGISTER
         NI    HEADLEN(BUFPTR),ZCHNOFF TURN OFF THE CHAIN BIT IN THE
*                                      IMASPZAP COUNT FIELD
         IC    GREG11,HEADLEN(BUFPTR)  GET COUNT OF IMASPZAP ENTRIES
         LTR   GREG11,GREG11           TEST THE ENTRY COUNT
         BZ    ZAPCUR                  IF THERE ARE NO ENTRIES ON THIS
*                                      RECORD, RETURN
         L     RNTPTR,RECNT            GET ADDRESS OF THE RNT - 4
         LA    ITEMPTR,FULWD(BUFPTR)   GET ADDRESS OF 1ST ENTRY ON REC.
ZAPLOOP  LA    DATAPTR,ZAPLEN(ITEMPTR) GET ENDING ADDRESS OF THIS ENTRY
         MVC   HTEMP(IDLEN),NODISP(ITEMPTR)  SAVE THE CESDID OF THE
*                                      ENTRY
         LH    GREG15,HTEMP            GET THE CESDID
         SLL   GREG15,RNTINDX          MULTIFLY THE ID BY 4 TO GET AN
*                                      INDEX INTO THE RNT
         AR    GREG15,RNTPTR           ADD THE ADDRESS OF THE RNT-4
         TM    RNTYPE(GREG15),DELETE   IS THIS CSECT MARKED DELETE?
         BO    DELZAP                  IF SO, BRANCH
         MVC   NODISP(IDLEN,ITEMPTR),NODISP(GREG15)  MOVE THE
*                                      RENUMBERED CESDID INTO THE ENTRY
         BAL   TEMPRTN,POSTIDR         GO TO POST THE ENTRY
DELZAP   LR    ITEMPTR,DATAPTR         POINT TO THE NEXT ENTRY
         BCT   GREG11,ZAPLOOP          GO TO CONTINUE PROCESSING
*                                      CONSECUTIVE ENTRIES UNTIL
*                                      THE COUNT IS EXHAUSTED
         ST    TABNXT,IDRZPEND         UPDATE POINTER TO NEXT
*                                      AVAILABLE BYTE IN TABLE
ZAPCUR   EQU   *                                                OX04245
         L     GREG8,IDRZPEND          GET NEXT ZAP TABLE ADR   OX04245
         S     GREG8,IDRZPTAB          SUBTRACT START ADDRESS   OX04245
         STH   GREG8,IDRZPCUR          STORE CURRENT # BYTES    OX04245
         B     FINISH                  RETURN TO CALLING ROUTINE
         EJECT
***********************************************************************
***********************************************************************
****                                                               ****
****     SUB-PROGRAM POSTIDR ADDS INPUT IDR DATA TO ONE OF THE     ****
****     THREE IDR DATA TABLES:  1) IDRTRTAB -- TRANSLATOR DATA    ****
****                             2) IDRZPTAB -- IMASPZAP DATA      ****
****                             3) IDRUDTAB -- USER DATA          ****
****                                                               ****
***********************************************************************
***********************************************************************
         SPACE 2
POSTIDR  ST    GREG8,SAVR8             SAVE WORK REG. CONTENTS
PSTRETRY TM    IDRSWS,PARTENT          IS THIS ITEM A PARTIAL ENTRY?
         BNO   NOTPART                 IF NOT, BRANCH
         ST    TABNXT,PARTBEG          SAVE STARTING ADDR. OF PARTIAL
*                                      ENTRY IN TABLE
NOTPART  LR    GREG8,DATAPTR           GET ENDING ADDR. OF ITEM
         SR    GREG8,ITEMPTR           GET LENGTH OF ITEM
         AR    GREG8,TABNXT            ADD NEXT TABLE ADDR.
         CR    GREG8,TABEND            COMPARE TO END OF TABLE
         BH    PREALLOC                IF HIGH, IT IS AN         YM2013
*                                      OVERFLOW CONDITION -- GO
*                                      TRY TO REALLOCATE THE TABLES
         SR    GREG8,TABNXT            GET ITEM LENGTH AGAIN
         ST    GREG8,FTEMP             SAVE LENGTH OF ENTRY
         BCTR  GREG8,NULLREG           SUBTRACT 1 FOR MOVE LENGTH
         EX    GREG8,MOVEIDR           MOVE THE PARTIAL ENTRY TO THE
*                                      NEXT POSITION IN THE TABLE
         L     GREG8,FTEMP             RESTORE CORRECT ENTRY LENGTH
         AR    TABNXT,GREG8            UPDATE POINTER TO NEXT AVAILABLE
*                                      BYTE IN TABLE
         L     GREG8,SAVR8             RESTORE WORK REG. CONTENTS
         BR    TEMPRTN                 RETURN TO PROCESSOR
PREALLOC EQU   *                                                 XM4628
         STM   GREG9,GREG11,BRNCHSV    SAVE WORK REGISTERS       XM4628
         L     GREG10,TABCURAD         GET CURRENT TAB.SIZE PTR  XM4628
         LR    GREG9,GREG10            PUT IT IN 9               XM4628
         SH    GREG9,TABSTCON          GET TO TAB START FIELD    XM4950
         L     GREG9,NODISP(GREG9)     GET TAB START ADDRESS     XM4628
         LR    GREG11,TABNXT           GET PTR TO NEXT BYTE      XM4628
         SR    GREG11,GREG9            SUBTRACT START ADDRESS    XM4628
         STH   GREG11,NODISP(GREG10)   UPDATE CURRENT TAB.SIZE   XM4628
         LM    GREG9,GREG11,BRNCHSV    RESTORE WORK REGISTERS    XM4628
CHKALLOC EQU   *                                                 XM4628
         TM    APT4,REALOCTE           IS REALLOCATION POSSIBLE? XM4628
         BO    TABOVFLO                IF NOT, SIGNAL OVERFLOW
         STM   GREG0,GREG15,BRNCHSV    SAVE REGISTERS
         L     GREG15,ERDIGA           GET ALLOCATION RTN.ADDR.
         BALR  GREG14,GREG15           REALLOCATE
         LM    GREG0,GREG15,BRNCHSV    RESTORE REGISTERS
         SR    GREG8,GREG8             CLEAR REGISTER 8
         IC    GREG8,TABIND            USE AS INDEX REGISTER
         B     NEWTAB(GREG8)           GO TO APPROPRIATE RTN.
NEWTAB   EQU   *
         B     NEWTABTR                GET TRANS.TABLE PTR'S.
         B     NEWTABUD                GET USER TABLE PTR'S.
         B     NEWTABZP                GET ZAP TABLE PTR'S.
         B     NEWTABBR                GET TRANS.TABLE PTR'S.    XM5507
NEWTABTR EQU   *
         L     TABPTR,IDRTRTAB         GET ADDR. OF TRANS.TABLE
         L     TABNXT,IDRTREND         GET ADDR. OF NEXT AVAILABLE
*                                      BYTE IN TABLE
         LR    TABEND,TABPTR           GET STARTING ADR OF TABLE
         AH    TABEND,IDRTRLEN         GET ENDING ADDR OF TABLE
         B     PSTRETRY                RE-CHECK
NEWTABBR L     TABPTR,IDRTITAB         GET ADDR. OF TRANS.TABLE OX04245
         L     TABNXT,IDRTIEND         GET ADDR. OF NEXT        OX04245
*                                      AVAILABLE BYTE IN TABLE  OX04245
         LR    TABEND,TABPTR           GET STARTING ADDR OF TAB OX04245
         AH    TABEND,IDRTILEN         GET END ADR OF TABLE     OX04245
         BR    GREG11                  RETURN TO RETRY           XM5507
NEWTABUD EQU   *
         L     TABPTR,IDRUDTAB         GET ADDR. OF USER TABLE
         L     TABNXT,IDRUDEND         GET ADDR. OF NEXT AVAILABLE
*                                      BYTE IN TABLE
         LR    TABEND,TABPTR           GET STARTING ADDR. OF TABLE
         AH    TABEND,IDRUDLEN         GET ENDING ADDR. OF TABLE
         B     PSTRETRY                RE-CHECK
NEWTABZP EQU   *
         L     TABPTR,IDRZPTAB         GET ADDR. OF ZAP TABLE
         L     TABNXT,IDRZPEND         GET ADDR. OF NEXT AVAILABLE
*                                      BYTE IN TABLE
         LR    TABEND,TABPTR           GET STARTING ADDR. OF TABLE
         AH    TABEND,IDRZPLEN         GET ENDING ADDR. OF TABLE
         B     PSTRETRY                RE-CHECK
MOVEIDR  MVC   NODISP(NOLEN,TABNXT),NODISP(ITEMPTR)  MOVE IDR ITEM TO
*                                      THE NEXT AVAILABLE POSITION IN
*                                      THE TABLE
TABOVFLO EQU   *                       LOG OVERFLO MSG & TERMINATE
         LH    GREG0,OVFLMSG           GET OVERFLOW MESSAGE CODE
         L     ENTRYPT,ERDIG           GET ADDRESS OF ERROR LOGGING
*                                      ROUTINE
         BR    ENTRYPT                 GO TO LOG ROUTINE
*                  THIS IS A TERMINAL ERROR -- THE LOG ROUTINE WILL
*                  PASS CONTROL TO HEWLFFNL TO PRINT THE MESSAGE
*                  AND TERMINATE LINKAGE EDITOR PROCESSING
         TITLE '***HEWLFIDR*** IDENTIFY CONTROL CARD PROCESSOR'
***********************************************************************
*                                                                     *
*               ************************************                  *
*              * SECONDARY ENTRY POINT --HEWLCIDR-- *                 *
*               ************************************                  *
*                                                                     *
*        CONTROL IS RECEIVED AT THIS POINT FROM MODULE HEWLFSCN       *
*        FOR THE PURPOSE OF ACCEPTING IDR DATA SUPPLIED BY THE        *
*        USER AND PASSED TO THE LINKAGE EDITOR BY MEANS OF THE        *
*        IDENTIFY CONTROL STATEMENT.                                  *
*                                                                     *
***********************************************************************
         SPACE 2
HEWLCIDR SAVE  (14,12),T,*             SAVE CALLING PROGRAM'S REGISTERS
         L     IDRBASE,ADDISP(ENTRYPT) LOAD BASE ADDRESS FOR MODULE
         B     CSTART                  BRANCH AROUND ADRESS CONSTANT
STARTAD  DC    A(START)                ADDR OF 1ST INSTR FOR MOD BASE
ADDISP   EQU   STARTAD-HEWLCIDR        DISPLACEMENT BEYOND ENTRY POINT
*                                      TO OPTAIN BASE ADDRESS FOR THE
*                                      MODULE WHEN ENTERED HERE
CSTART   OI    IDRSWS,USEIDR           TURN ON IDENTIFY CONTROL CARD
*                                      INDICATOR
         B     IDRIDENT                GO TO PROCESS THE DATA ON THE
*                                      IDENTIFY CARD
***********************************************************************
***      THE FOLLOWING SECTION OF CODE RESETS SWITCHES            *****
***            AND RETURNS CONTROL TO                             *****
***               THE CALLING PROGRAM                  OX04245    *****
***********************************************************************
FINISH   NI    IDRSWS,SWSINIT          RE-INITIALIZE IDR SWITCHES
         MVI   LCLSWS,SWSOFF           RE-INITIALIZE ALL LOCAL
*                                      SWITCHES TO ZEROES
NOUPDT   EQU   *
         RETURN    (14,12),T,RC=0      RESTORE REGISTERS AND RETURN
ABORT    LH    GREG0,INTERR            GET MESSAGE CODE FOR ERROR
*                                      IN IDR INPUT
         L     ENTRYPT,ERDIG           GET ADDRESS OF LOG ROUTINE
         BR    ENTRYPT                 GO TO LOG THE ERROR
*                                      -- THIS IS A TERMINAL
*                                         ERROR CONDITION
*                                      -- THE LOG ROUTINE
*                                         WILL NOT RETURN
         TITLE '***HEWLFIDR*** CSECT IDENTIFICATION RECORD PROCESSOR'
***********************************************************************
*                                                                     *
*                    DEFINED STORAGE AND CONSTANTS                    *
*                                                                     *
***********************************************************************
         SPACE 2
SAVR0    DS    1F                      GENERAL PURPOSE REG SAVE AREA
SAVR1    DS    1F                      GENERAL PURPOSE REG SAVE AREA
SAVR8    DS    1F                      GENERAL PURPOSE REG SAVE AREA
SAVR9    DS    1F                      GENERAL PURPOSE REG SAVE AREA
SAVR10   DS    1F                      GENERAL PURPOSE REG SAVE AREA
SAVR11   DS    1F                      GENERAL PURPOSE REG SAVE AREA
SAVR13   DS    1F                      GENERAL PURPOSE REG SAVE AREA
SAVR14   DS    1F                      GENERAL PURPOSE REG SAVE AREA
SAVR15   DS    1F                      GENERAL PURPOSE REG SAVE AREA
FTEMP    DS    1F                      FULLWORD TEMPORARY SAVE AREA
DATESAV  EQU   FTEMP+1                 START OF PACKED DECIMAL DATE
*                                      RETURNED BY TIME MACRO
PARTBEG  DS    1F                      SAVE AREA FOR STARTING ADDR. OF
*                                      A PARTIAL ITEM IN AN IDR TABLE
TABCURAD DS    1F                      SAVE AREA FOR CURRENT     YM2013
*                                      TABLE SIZE POINTER        YM2013
SAVPTLUD DS    0F                      SAVE AREA FOR A PARTIAL USER
*                                      DATA ITEM
PRTLEN   DS    1F                      LENGTH OF THE PARTIAL ITEM
UDITEM   EQU   *                       WORKING COPY OF A USER DATA ITEM
UDID     DS    XL2                     CESDID
UDATE    DS    XL3                     TODAY'S DATE
UDBTCT   DS    XL1                     BYTE COUNT OF USER DATA
UDATA    DS    XL40                    USER DATA
HTEMP    DS    1H                      HALFWORD TEMPORARY FOR CESDID
HTEMP2   DS    1H                      HALFWORD TEMPORARY WORK AREA
IDTEMP   DS    0H                      WORK AREA FOR A CONTINUED CESDID
ID1ST    DS    XL1                     1ST HALF OF THE CESDID
ID2ND    DS    XL1                     2ND HALF OF THE CESDID
SAVPTLTR DS    0F                      SAVE AREA FOR A PARTIAL
*                                      TRANSLATOR ITEM
PTLSWCH  DS    XL1                     INDICATOR FOR TYPE OF PARTIAL
*                                      ITEM (BINARY VALUE):
*                                        4 = HALF OF A CESDID FOLLOWS
*                                        8 = A PARTIAL TRANSLATOR
*                                            DESCRIPTION FOLLOWS
*                                       12 = NO DATA FOLLOWS (ITEM WAS
*                                            BROKEN AFTER A COMPLETE
*                                            CESDID)
CPYLCLS  DS    XL1                     COPY OF LCLSWS REFLECTING
*                                      CURRENT STATUS OF PROCESSING
*                                      FOR THIS ITEM
PTLTRLN  DS    XL1                     LENGTH OF PARTIAL DESCRIPTION
*                                      WHICH FOLLOWS (IF PTLSWCH=8)
XPTRLEN  DS    XL1                     EXPECTED LENGTH OF DESCRIPTION
*                                      (IF PTLSWCH=8)
HIDSAV   EQU   XPTRLEN                 1ST HALF OF THE CESDID BEING
*                                      PROCESSED (IF PTLSWCH=4)
OBJTRN   DS    CL31                    IDR TRANSLATOR DATA FIELD ON AN
*                                      OBJECT MODULE END RECORD
LASTPTR  DC    H'0'                    POINTER TO START OF LAST
*                                      PREVIOUS ID TRANSLATOR TABLE
*                                      ENTRY                    OX04245
HDLEN1   DC    H'3'                    SHIFT LENGTH FOR SINGLE IDR
*                                      TRANSLATOR ITEM          OX04245
HDLEN2   DC    H'9'                    SHIFT LENGTH FOR IDR TRANSLATOR
*                                      ITEM WITH HEADER SAME AS LAST
MSGBUF   DS    CL80                    BUFFER FOR BUILDING DIAGNOSTIC
*                                      MESSAGES TO BE PASSED TO THE
*                                      LOGGING ROUTINE
MSGBUFF  EQU   MSGBUF+1                FOR INITIALIZING THE BUFFER
MSGNAME  EQU   MSGBUF+10               FOR A CSECT NAME
MSGDATA  EQU   MSGBUF+30               FOR USER DATA FROM AN IDENTIFY
*                                      CONTROL STATEMENT
TABIND   DS    XL1                     TABLE TYPE INDICATOR
HZERO    DS    0H                      HALFWORD OF F'S TO TEST    M1602
         DC    X'FFFF'                 FOR NULL ITEMS             M1602
TABNXTSA DS    1F                      TABNXT SAVE AREA         OZ01412
H100     DC    H'256'                  INCREMENT CONSTANT       OZ01412
         DS    0H                      HALF-WORD ALIGNMENT
GOODIDNT DC    X'1043'                 MESSAGE INDICATING IDENTIFY
*                                      HAS BEEN ADDED
BADIDNT  DC    X'1244'                 MESSAGE INDICATING CSECT NAME
*                                      ON AN IDENTIFY CARD CANNOT BE
*                                      FOUND IN THE CESD
OVFLMSG  DC    X'0445'                 ERROR MESSAGE CODE FOR IDR
*                                      TABLE OVERFLOW -- TERMINAL ERROR
INTERR   DC    X'0446'                 ERROR MESSAGE CODE FOR INVALID
*                                      IDR INPUT -- TERMINAL ERROR
TABNXTSV DC    H'0'                    STORE OFFSET TO START    OX04245
*                                      OF HEADER IN TRANS ID    OX04245
*                                      TABLE HERE               OX04245
         DS    0H                      ALIGNMENT                 XM4950
TABSTCON DC    AL2(IDRTRCUR-IDRTRTAB)  ADCON FOR SUBTRACT        XM4950
         EJECT
LCLSWS   DC    X'00'                   LOCAL SWITCHES *****************
*     ***********************************************************     *
*     *                BIT DESCRIPTIONS                         *     *
*     ***********************************************************     *
*     *  SYMBOLIC  *       *        *    MEANING OF BIT WHEN    *     *
*     *  NAME  OF  *  BIT  *  MASK  *         TURNED ON         *     *
*     *    MASK    *       *        *        (VALUE = 1)        *     *
*     ***********************************************************     *
*     *            *       *        *  THE LAST ID IN A STRING  *     *
*     *  LSTIDFND  *   0   *  X'80' *   OF CESDID'S HAS BEEN    *     *
*     *            *       *        *          FOUND            *     *
*     ***********************************************************     *
*     *            *       *        *  AT LEAST ONE CESDID IN   *     *
*     *   AL1VLD   *   1   *  X'40' *  A STRING IS VALID (NOT   *     *
*     *            *       *        *      MARKED DELETE)       *     *
*     ***********************************************************     *
*     *            *       *        *    THE IDR ITEM BEING     *     *
*     *  CNTDITM   *   2   *  X'20' *  PROCESSED IS CONTINUED   *     *
*     *            *       *        *  FROM THE PREVIOUS IDR    *     *
*     ***********************************************************     *
*     *            *       *        *  A CESDID IN A STRING OF  *     *
*     *   CNTDID   *   3   *  X'10' *    CESDID'S, CONTINUED    *     *
*     *            *       *        *  FROM A PREVIOUS TRANS.   *     *
*     *            *       *        *  IDR IS BEING PROCESSED   *     *
*     ***********************************************************     *
*     *    N/A     *   4   *  X'08' *         RESERVED          *     *
*     ***********************************************************     *
*     *    N/A     *   5   *  X'04' *         RESERVED          *     *
*     ***********************************************************     *
*     *    N/A     *   6   *  X'02' *         RESERVED          *     *
*     ***********************************************************     *
*     *    N/A     *   7   *  X'01' *         RESERVED          *     *
*     ***********************************************************     *
************* NOTE--INITIAL VALUE OF ALL BITS IS ZERO *****************
         EJECT
***********************************************************************
*                                                                     *
*                     MODULE MAINTENANCE AREA                         *
*             160 BYTES ALIGNED ON A DOUBLE WORD BOUNDARY             *
*                  (APPROXIMATELY 8% OF MODULE SIZE)                  *
*                                                                     *
***********************************************************************
         SPACE
         DS    0D                      DOUBLE WORD ALIGNMENT
         DC    CL32'HEWLFIDR MAINTENANCE AREA BEGINS'  AREA IDENTIFIER
         DC    160X'00'                MAINTAINENCE SPACE
         DC    CL21'MAINTENANCE AREA ENDS'  END OF AREA IDENTIFIER
         SPACE
         HEWAPT
         END
*/*TRANSIDR:      CHART */
*/*HEADER
*/*               SUBPROGRAM TO PROCESS TRANSLATOR IDRS
*/*SEPTEMBER 73                                     PAGE #       */
*/*IDRTRANS:      E TRANSLATOR IDR DETECTED */
*/*               P SET REGISTERS TO POINT TO TRANS ID TABLE */
*/*               M SET INDICATOR FOR TRANS TABLE PROCESSING */
*/*               P SET POINTER TO ID TABLE PAST HEADER SPACE */
*/*               P GET ADDRESS OF RNT */
*/*               D (YES,TRANSOBJ,NO,) OBJECT MODULE? */
*/*               D (YES,,NO,ABORT) LOAD MODULE? */
*/*               P GET ADDRESS OF CESD */
*/*               P POINT TO FIRST DATA IN INPUT BUFFER */
*/*               D (YES,CONTIN,NO,) ITEM CONT FROM PREV RECORD? */
*/*               P SAVE OFFSET TO START OF HEADER IN ID TABLE */
*/*SCNITM:        P SET DATAPTR TO POINT TO START OF ITEM */
*/*SCNITM1:       D (YES,SCNITM04,NO,) ID CONT FROM PREV RECORD? */
*/*               D (YES,PRTLID,NO,) ID CONT TO NEXT RECORD? */
*/*SCNITM04:      D (YES,,NO,SCNITM3) LAST ID? */
*/*               M SET 'LAST ID FOUND' SWITCH */
*/*               M TURN OFF HIGH ORDER BIT OF ID */
*/*SCNITM3:       P USE ID TO COMPUT INDEX INTO RNT */
*/*               P GET CORRECT CESD LINE NUMBER */
*/*               D (YES,SCNITM6,NO,) SECTION MARKED DELETE? */
*/*               S MOVEID0:MOVE ID TO TRANS ID TABLE */
*/*SCNITM6:       D (NO,GETNXT,YES,) 'LAST ID' SWITCH ON? */
*/*               D (NO,TRFIN0,YES,)  AT LEAST ONE VALID ID? */
*/*               P MARK LAST ID IN TABLE */
*/*GETNXT:        P INCREMENT POINTER TO NEXT ID INPUT */
*/*               D (YES,PRTLSTR,NO,) AT END OF INPUT RECORD? */
*/*STCNTIN:       D (YES,,NO,SCNITM) 'LAST ID' SWITCH ON? */
*/*               M TURN OFF 'CONTINUED ID' SWITCH */
*/*PREDESC:       P POINT TO START OF HEADER IN TRANS ID TABLE */
*/*               D (NO,PREDESC2,YES,) SINGLE TRANS DESCRIPTION? */
*/*               P INCREMENT DATAPTR TO END OF SINGLE ITEM */
*/*               D (NO,PRTLITEM,YES,) IS ITEM COMPLETE IN THIS RECORD?
*/* */
*/*               P (,TRDESC0) MOVE FIRST DATE TO HEADER SPACE */
*/*PREDESC2:      P INCREMENT DATAPTR TO END OF DOUBLE ITEM */
*/*               D (NO,PRTLITEM,YES,) IS ITEM COMPLETE IN THIS RECORD?
*/* */
*/*               P MOVE TWO DATES TO HEADER SPACE */
*/*               P PACK TRANSLATOR NAMES TOGETHER */
*/*               M (,DBLTRNS) TURN ON DOUBLE ITEM SWITCH IN APT */
*/*PRTLID:        M TURN ON HALF ID INDICATOR */
*/*               P (,PARTIAL) SAVE THE HALF ID */
*/*PRTLSTR:       M TURN ON CONT STRG INDICATOR */
*/*PARTIAL:       M SET PARTIAL ENTRY FLAG IN APT */
*/*               P COPY LOCAL SWITCHES */
*/*               P (,TRFIN3) UPDATE END OF TABLE PTR TO CURRENT POS */
*/*PRTLITEM:      P COMPUTE AND SAVE EXPECTED TOTAL ITEM LENGTH */
*/*               P SAVE LENGTH OF PARTIAL ITEM */
*/*               P SAVE PARTIAL ITEM */
*/*               M (,PARTIAL) TURN ON CONTINUED ITEM INDICATOR */
*/*CONTIN:        P COPY THE SAVED LOCAL SWITCHES */
*/*               M TURN OFF PARTIAL ITEM FLAG IN APT */
*/*               P RETRIEVE CURRENT END OF TABLE POINTER */
*/*               D (YES,STCNTIN,NO,) STRING OF CONTINUED IDS */
*/*               D (YES,,NO,DSCNTIN) CONTINUED ID? */
*/*               P MOVE 2ND HALF ID TO WORK AREA */
*/*               M SET 'CONTINUED ID' SWITCH */
*/*               P (,SCNITM1) POINT TO CONTINUED ID */
*/*DSCNTIN:       P MOVE CONTINUATION TO WORK AREA AND POINT TO IT */
*/*               P ADJUST BUFPTR TO START OF NEXT RECORD */
*/*               M (,PREDESC) TURN ON 'PARTIAL ITEM' INDICATOR */
*/*TRANSOBJ:      P SAVE ADDRESS OF START OF HEADER */
*/*RNTLOOP:       P INCREMENT PTR TO NEXT RNT ENTRY */
*/*               D (YES,ADDITEM,NO,) AT END OF RNT? */
*/*               D (YES,ADDID,NO,) IS THIS AN SD? */
*/*               D (YES,,NO,RNTLOOP) IS THIS A PC? */
*/*ADDID:         D (YES,RNTLOOP,NO,) MARKED DELETE? */
*/*               S (,RNTLOOP) MOVEID0:MOVE ID TO TRANS ID TABLE */
*/*ADDITEM:       D (NO,FINISH,YES,) AT LEAST ONE VALID ID FOUND? */
*/*               P CONVERT V/M,LVL TO PACKED FORM AND SQUISH */
*/*               P PACK DATE AND MOVE TO HEADER */
*/*               D (NO,TRDESC0,YES,) DOUBLE TRANSLATOR ITEM? */
*/*               P MOVE SECOND TRANSLATOR NAME AFTER FIRST */
*/*               P PACK 2ND V/M LVL AND MOVE */
*/*               P (,DBLTRNS) PACK 2ND DATE AND MOVE TO HEADER */
*/*TRDESC0:       P SET DATAPTR TO POINT TO END OF ITEM */
*/*               P (,TRDESC) INDICATE SINGLE ENTRY IN HEADER */
*/*DBLTRNS:       P SET DATAPTR TO POINT TO END OF ITEM */
*/*               P INDICATE DOUBLE ENTRY IN HEADER */
*/*TRDESC:        P SAVE POINTER TO END OF ID STRING */
*/*               P SET REGISTERS TO POINT TO TRANS DATA TABLE */
*/*SCANTRT0:      D (YES,NEWITEM,NO,) AT END OF TABLE? */
*/*               D (YES,SCANDBL,NO,) DOUBLE ENTRY? */
*/*               D (YES, MATCH1,NO,SCANTRT1) IS THIS A MATCH WITH
*/*CURRENT ITEM? */
*/*SCANDBL:       D (YES,MATCH1,NO,) IS THIS A MATCH WITH CURRWNT
*/*(DOUBLE) ITEM? */
*/*SCANTRT1:      P (,SCANTRT0) INCREMENT TO NEXT DATA TABLE ENTRY */
*/*NEWITEM:       L POSTIDR: ADD ITEM TO TABLE */
*/*               P UPDATE TRANS DATA TABLE END POINTER */
*/*MATCH1:        P SET REGISTERS TO POINT TO TRANS ID TABLE */
*/*               P STORE POINTER TO TRANS DATA ENTRY IN HEADER */
*/*               D (YES,,NO,SNGHDR) IS THIS A DOUBLE ITEM? */
*/*               D (YES,,NO,TRFIN0) IS THIS HEADER SAME AS LAST
*/*PREVIOUS? */
*/*NOHDRSH:       P COMPUTE LENGTH OF ID STRING */
*/*               P (,MATCH2) SHIFT STRING NINE BYTES */
*/*SNGHDR:       D (YES,NOHDRSH,NO,) IS THIS ENTRY SAME AS LAST
*/*PREVIOUS? */
*/*               P COMPUTE LENGTH OF ID STRING */
*/*               P SHIFT STRING THREE BYTES */
*/*MATCH2:        P SAVE NEW END OF TABLE LOCATION */
*/*TRFIN0:        D (NO,TRFIN3,YES,) LOAD MODULE? */
*/*               D (NO,,YES,ENDTEST) ITEM CONTINUED FROM LAST RECORD?
*/**/
*/*               D (NO,DBLINC,YES,) SINGLE TRANSLATOR ITEM? */
*/*               P (,ENDTEST) INCREMENT BUFFER POINTER TO NEXT ITEM */
*/*DBLINC:        P INCREMENT BUFFER POINTER FOR DOUBLE ITEM */
*/*ENDTEST:       D (NO,TRFIN3,YES,) ANY MORE ITEMS IN THIS RECORD? */
*/*               P (,SCNITM) RESET LOCAL SWITCHES */
*/*TRFIN3:        P UPDATE APT TABLE INFORMATION */
*/*FINISH:        R RESET SWITCHES AND EXIT MODULE */
*/*ABORT:         R FATAL ERROR - ABORT LINK EDIT */
*/*MOVEID0:       E ROUTINE TO MOVE ID TO TABLE */
*/*               M TURN ON 'ONE VALID ID' SWITCH */
*/*               D (YES,MOVEID1,NO,) ROOM IN TABLE? */
*/*               L CHKALLOC: BRANCH TO CALL REALLOCATE */
*/*MOVEID1:       D (NO,MOVEID2,YES,) LAST ID? */
*/*               P TURN ON LAST ID INDICATOR */
*/*MOVEID2:       P MOVE ID TO TRANSLATOR ID TABLE */
*/*               P INCREMENT ID TABLE POINTER */
*/*               R CONTINUE PROCESSING */
*/*TRANSIDR:      END */
