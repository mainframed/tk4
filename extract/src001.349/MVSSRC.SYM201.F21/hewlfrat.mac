         TITLE 'HEWLFRAT   RLD/TXT PROCESSOR'
*                 R L D / T X T    P R O C E S S O R
         SPACE 2
*FUNCTION/OPERATION -- THIS MODULE WILL HANDLE TEXT AND RLD RECORDS   *
*  FROM BOTH LOAD MODULES AND OBJECT MODULES.  IT WILL RECEIVE CONTROL*
*  FROM THE INPUT PROCESSOR AND WILL PUT ITS OUTPUT ON AN INTERMEDIATE*
*  FILE FOR USE BY THE SECOND PASS IF THE OUTPUT EXCEEDS THE SPACE    *
*  AVAILABLE IN THE OUTPUT BUFFER.  IN GENERAL THE RLD/TXT PROCESSOR  *
*  ORDERS THE INFORMATION FOR THE SECOND PASS PROCESSOR.              *
*                                                                     *
*ENTRY POINTS -- CONTROL IS PASSED BY THE INPUT PROCESSOR TO LOCATION *
*  HEWLFRAT                                                           *
*                                                                     *
*INPUT -- THE INPUT PROCESSOR SUPPLIES INFORMATION IN REGISTERS       *
*  REG 4 (RLD ONLY) -- BYTE COUNT OF RLD INPUT
*  REG 6 (RLD ONLY) -- LOCATION IN STORAGE OF RLD INPUT
*  REG 3 (TXT ONLY) -- ASSEMBLED ADDRESS OF FIRST BYTE OF TEXT        *
*  REG 6 (TXT ONLY) -- ID OF THIS TEXT RECORD                         *
*  REG 8 (TXT ONLY) -- LENGTH OF LOAD MODULE INPUT
*                                                                     *
*OUTPUT -- IF ALL THE OUTPUT INFORMATION CAN BE CONTAINED IN THE OUT- *
*  PUT BUFFER, IT REMAINS IN STORAGE.  IF IT EXCEEDS THE CAPACITY OF  *
*  THE BUFFER ALL OF THE INFORMATION IS WRITTEN OUT ON AN INTERMEDIATE*
*  FILE.                                                              *
*                                                                     *
*EXTERNAL ROUTINES.                                                   *
*  ERROR DIAGNOSTIC ROUTINE -- OUTPUTS ERROR MESSAGES                 *
*  ESD PROCESSOR -- PLACES ENTRIES IN DELINK TABLE                    *
*                                                                     *
*EXITS                                                                *
*  NORMAL -- RETURN TO INPUT PROCESSOR                                *
*  ERRORS -- INTERNAL TABLES MAY OVERFLOW                             *
*     A)  CALLS LIST -- TOO MANY CALLS IN OVERLAY STRUCTURE           *
*     B)  RLD NOTE LIST -- TOO MANY CONTROL SECTIONS THAT CONTAIN RLD *
*           ITEMS                                                     *
*     C)  TEXT NOTE LIST -- TOO MANY CONTROL SECTIONS THAT CONTAIN    *
*           TEXT OR THERE ARE EXCESSIVE RE-ORIGINS WITHIN THE INPUT   *
*     D)  TEXT ID IS ILLEGAL.  TEXT RECORD IS IGNORED.                *
*                                                                     *
*TABLES                                                               *
*  THE FOLLOWING TABLES IN THE ALL PURPOSE TABLE ARE USED --          *
*                                                                     *
*     CALLS LIST-IN OVERLAY, LIST OF CALLS TO OTHER CONTROL SECTIONS, *
*        USED IN CREATION OF ENTABS                                   *
*                                                                     *
*     COMPOSITE ESD - USED TO GET ASSEMBLED ADDRESS OF CONTROL SECTION*
*                                                                     *
*     RENUMBERING TABLE -- USED TO RENUMBER RLD AND TEXT ITEMS        *
*                                                                     *
*  TEXT I/O TABLE -- 4 BYTES PER ENTRY                                *
*                                                                     *
*        *************************                                    *
*        *           *           *                                    *
*        *     ID    * FLG--MULT *                                    *
*        *           *           *                                    *
*        *************************                                    *
*        '           '           '                                    *
*        '  2 BYTES  '  2 BYTES  '                                    *
*        '           '           '                                    *
*                                                                     *
*  FOR EACH CHANGE, IN THE INPUT STREAM, OF AN ID OR A MULTIPLICITY,  *
*  AN ENTRY IS MADE IN THE TEXT I-O TABLE.  THE 'ID' IS THE ID OF A   *
*  TXT RECORD.  THE 'MULTIPLICITY' IS CALCULATED FOR EACH TEXT RECORD *
*  THAT IS PRESENTED.  A CHANGE IN MULTIPLICITY WILL OCCUR --         *
*    1) FOR EACH TEXT RECORD THAT IS A MULTIPLE OF UT1SIZE.           *
*      (UT1SIZE IS THE SIZE OF THE TEXT BUFFER AND THE MAXIMUM SIZE   *
*      OF A TEXT RECORD FROM A LOAD MODULE)                           *
*    2) FOR EACH RE-ORIGIN OF TEXT WITHIN A CONTROL SECTION (THE CON- *
*      TROL SECTION BEING GREATER THAN UT1SIZE).                      *
*                                                                     *
*  TEXT NOTE LIST -- 7 BYTES PER ENTRY                                *
*                                                                     *
*  THERE IS A ONE-TO-ONE CORRESPONDENCE BETWEEN THE TEXT I-O TABLE    *
*  AND THE TEXT NOTE LIST.  THE 'NTH' ENTRY OF THE TEXT I-O TABLE     *
*  REFERS TO THE 'NTH' RECORD OF THE TEXT NOTE LIST.  THE NOTE LIST   *
*  RELATES WHERE THE TEXT RECORD HAS BEEN WRITTEN ON THE DISK THROUGH *
*  THE 3 BYTE TTR ENTRY.  IF THE INPUT DECK HAS BEEN SHUFFLED OR IF   *
*  THERE ARE RE-ORIGINS WITHIN THE CONTROL SECTION (REPRESENTED BY    *
*  THE ID IN THE TXT I/O TABLE) THEN THE CONTROL SECTION CAN NOT BE   *
*  GATHERED AT ONE TIME.  THEREFORE, 'PIECES' OF TEXT WHICH ARE CALLED*
*  'DENSE' RECORDS ARE PLACED ON THE INTERMEDIATE FILE.  THE 2 BYTE   *
*  RELATIVE ADDRESS (OFFSET) DEFINES WHERE THIS 'PIECE' OF TEXT OCCURS*
*  WITHIN THE TEXT BUFFER.  THE SECOND PASS PROCESSOR WILL GATHER ALL *
*  THE 'PIECES' FOR EACH CONTROL SECTION AND MERGE THEM.              *
*                                                                     *
*        *******************************************                  *
*        *            *                *           *                  *
*        *   OFFSET   *  TTR/STG ADDR  *  LENGTH   *                  *
*        *            *                *           *                  *
*        *******************************************                  *
*        '            '                '           '                  *
*        '  2 BYTES   '    3 BYTES     '  2 BYTES  '                  *
*        '            '                '           '                  *
*                                                                     *
*                                                                     *
*                                                                     *
*                                                                     *
*  TEXT I/O CONTROL TABLE -- 4 BYTES PER ENTRY                        *
*                                                                     *
*  TO SAVE SPACE THE TEXT NOTE LIST IS NOT KEPT 'COMPLETELY' IN CORE. *
*  INSTEAD, WHEN IT REACHES A MAXIMUM VALUE, IT IS WRITTEN ON AN      *
*  INTERMEDIATE FILE AND THE RESULTANT TTR IS PLACED IN THE TEXT I/O  *
*  CONTROL TABLE.                                                     *
*                                                                     *
*                                                                     *
*        ************************                                     *
*        *      *               *                                     *
*        *   0  *      TTR      *                                     *
*        *      *               *                                     *
*        ************************                                     *
*        '      '               '                                     *
*        '   1  '               '                                     *
*        ' BYTE '    3 BYTES    '                                     *
*        '      '               '                                     *
*                                                                     *
*                                                                     *
*                                                                     *
*                                                                     *
*  RLD NOTE LIST -- 9 BYTES PER ENTRY                                 *
*                                                                     *
*        ****************************************************         *
*        *1.         *2.         *3.         *4.            *         *
*        *     ID    * FLG--MULT *  LENGTH   * TTR/ACCM LNG *         *
*        *           *           *           *              *         *
*        ****************************************************         *
*        '           '           '           '              '         *
*        '  2 BYTES  '  2 BYTES  '  2 BYTES  '   3 BYTES    '         *
*        '           '           '           '              '         *
*                                                                     *
*  1. THE ID IS THE ID OF THE CONTROL SECTION IN WHICH THE RLD ITEMS  *
*     OCCUR                                                           *
*  2. THE LOWEST MULTIPLICITY OF AN ADDRESS FIELD, OF AN RLD ITEM IN  *
*     THIS RLD RECORD, IS STORED HERE.                                *
*  3. THE NUMBER OF BYTES IN THE RLD RECORD IS DIVIDED BY 4 AND SAVED *
*     IN THIS TWO BYTE ENTRY.  (WORD COUNT)                           *
*  4. THE ACCUMULATED WORD COUNT OF GROUPED ENTRIES IS SAVED HERE,    *
*     EXCEPT WHEN IT IS IN THE LAST ENTRY OF A RECORD WRITTEN OUT ON  *
*     THE INTERMEDIATE DATA SET.  THEN IT HOLDS THE TTR OF THE RECORD.*
*                                                                     *
*                                                                     *
*                                                                     *
*  THE RLD I/O CONTROL TABLE - 4 BYTES PER ENTRY                      *
*                                                                     *
*  TO SAVE SPACE THE RLD NOTE LIST IS NOT KEPT 'COMPLETELY' IN CORE.  *
*  INSTEAD, WHEN IT REACHES A MAXIMUM VALUE, IT IS WRITTEN ON AN      *
*  INTERMEDIATE DATA SET AND THE RESULTANT TTR IS PLACED IN THE RLD   *
*  I/O CONTROL TABLE.                                                 *
*                                                                     *
*        ************************                                     *
*        *      *               *                                     *
*        *   0  *      TTR      *                                     *
*        *      *               *                                     *
*        ************************                                     *
*        '      '               '                                     *
*        '   1  '               '                                     *
*        ' BYTE '    3 BYTES    '                                     *
*        '      '               '                                     *
*                                                                     *
*                                                                     *
*                                                                     *
*                                                                     *
*ATTRIBUTES                                                           *
*  1) REUSABLE                                                        *
*                                                                     *
*NOTES -- SPECIAL TEXT....... SET ON WITH 'SPTXTON' AND TESTED        *
* JUST AFTER LABEL TXT002X.  THIS IS USED FOR TWO CASES.......        *
* 1) LARGE DS AREAS WITHIN A CSECT WHICH CAUSE THE FOLLOWING          *
* TEXT TO USE AN ADDITIONAL MULTIPLICITY WHIC CANNOT BE NOTED         *
* ANY OTHER WAY...                                                    *
* 2) A CSECT WITHIN A LOAD MODULE STARTING WITH A LARGE DS AREA
* FOLLOWED BY CODE WHICH WILL USE AN ADDITIONAL MULTIPLICITY
* WHICH CANNOT BE NOTED ANY OTHER WAY....
* ...WITHOUT THIS CODE THE MODULE CREATED WILL LOSE SOME TEXT
* WHICH IS LOCATED INTO THE NEXT MULTIPLICITY OR BUFFER......
*    *    *    *    *    *    *    *    *    *    *    *    *    *    *
*                                                                     *
*    *    *    *    *    *    *    *    *    *    *    *    *    *    *
         SPACE 2
     TITLE  'HEWLFRAT   RLD/TXT PROCESSOR  --  RLD EQUIVALENCIES'
HEWLFRAT CSECT                 ENTRY POINT
*
*217900-218300,219500-221100,359100-359500,360700-362300         S01904
*367500-369500,372300-374300,543900-545500,602700-603100         S01904
*604300-611100,613100-621500,721100-729500,826700-828700         S01904
*831100-831900                                                   S01904
*C244620,A244620                                                 A49482
*C217500                                                         A52402
*A162700,A182700,A448700                                         A53300
*C367900,C368700,A372700,A831500,C834700,A953100                OX00029
*C162900,C182900                                                 XM1384
*A244480-244632                                                 OY00137
*C059100                                                        OY00131
*A484400-484500,C507500,A517200-517300,A747920,A817600-817860   OY00356
*C817900,D818300,C818700,C943900-9466400                        OY00356
*I302300,I350300,C352700                                OX03655,OY03146
*I360300,I361900                                        OX03721,OY03423
*I509500,I655900,I656300                                OX04241,OY03414
*C541811,I557500,C766100                                        XA05128
* SEE FIX FOR XA05128                                           YA03165
*I183100,I447100                                                XA04649
* SEE FIX FOR XA04649                                           YA03751
*I350400,C352700                                                XA05742
* SEE FIX FOR XA05742                                           YA04541
*I509500,I655900,I656300                                        XA05743
* SEE FIX FOR XA05743                                           YA04540
*I360300,C360700,I361900                                        YA05040
* SEE FIX FOR YA05040                                           XA05444
*I365600-366132,I413200-413300                                  XA05132
* SEE FIX FOR XA05132                                           YA04538
*C611500-612700,D629500,D631100,C631500,I632700                 XA05445
*D640300-640700,C642700,C643500                                 XA05445
* SEE FIX FOR XA05445                                           YA04542
* SEE FIX FOR XA05445                                           ZA00715
*I187500,I188300                                                XA05656
* SEE FIX FOR XA05656                                   ZA00717,YA04545
*A612600,A612900,I628700                                        XM08070
*A644700                                                        XM09517
*A612900,A621500,D629900,I611600                                XM09521
*I825600-826132,D097500,I097100,D486700-501100  ZA00723,YA04548,XA06144
* C503100-503900,C505100-505500,I514700,I518700                 ZA01405
* C528300-528700,D604700-606700,D608300-610700                  ZA01405
* D615100-617100,D618700-621100,I630700,I631500,I670700         ZA01405
* I685500,I705100,I713500,I715900,D723100-725100                ZA01405
* D726700-729100,I735500,D837100,I842300,C917900                ZA01405
* D612700                                                       ZA01409
* C059100                                                      @XA11151
* C603500,C614300,C722300                                      @ZA07602
* C9815000,A9816200-98121000 OZ28721 SYSRTE FROM OY19267       @ZA28721
* A098179-098180,C098184-098185                                @ZA33611
*
         EJECT
         SPACE 1
         EXTRN HEWLCUDB
         SPACE 2
*                  MASKS, FLAGS, OFFSETS AND VALUES
         SPACE 2
*                       FOR ALL PURPOSE TABLE
         SPACE 1
EOD      EQU   X'01'     END-OF-DATA FLAG IN NEWSW
RT       EQU   X'02'     TEXT FLAG IN APT0  (RLD/TEXT)
DEL      EQU   X'10'     DELETE FLAG IN APT1
EX       EQU   X'20'     LOAD MODULE FLAG IN APT1  (LD MOD/OBJ MOD)
OI       EQU   X'20'     OVERLAY FLAG IN PDSE7
TUPAS    EQU   X'20'     2 PASS OPERATION IS CURRENT
DELOFF   EQU   X'EF'     MASK OUT DELETE FLAG IN APT1
ANY      EQU   X'EF'     FLAGS FOR ANY RLD ATTRIBUTES IN PDSE8
         SPACE 2
*                       FOR RENUMBERING TABLE
         SPACE 1
DID      EQU   0         OFFSET FOR 'R' ID
DF       EQU   2         OFFSET FOR FLAG IN RNT
DT       EQU   3         OFFSET FOR TYPE IN RNT
DSAV     EQU   X'04'     DELINK VALUE SAVED FLAG IN RNT
CH       EQU   X'40'     CHAINED FLAG FOR TYPE IN RNT
         SPACE 2
*                             FOR DCB
         SPACE 1
PHL      EQU   0         INITIAL DATA COUNT
PHADD    EQU   0         INITIAL DATA AREA LOCATION
LENGTH   EQU   6         OFFSET FOR DATA COUNT
ADD      EQU   12        OFFSET FOR DATA AREA LOCATION
DCBOPN   EQU   X'10'     SUCCESSFUL OPEN
OPNFLGS  EQU   48        OPEN FLAGS IN DCB
         SPACE  2
*                           FOR RLD ITEM
         SPACE 1
CONT     EQU   1         CONTINUATION FLAG IN FA
RELOFF   EQU   X'7F'     MASK OUT RELATIVE FLAG
NREL     EQU   X'80'     NONRELATIVE FLAG IN 'R' POINTER
REL      EQU   X'80'     RELATIVE FLAG IN FA FIELD
CONTN    EQU   X'FE'     CONTINUATION FLAG IN FA MASK OUT
ANYR     EQU   X'F0'     ANY TYPE FLAGS IN FA
*                            FOR MODULE
         SPACE 1
BUFFRN2  EQU   X'01'     BUFFER 2 IS CURRENT
BUFF1    EQU   X'02'     BUFFER 1 FULL
FNLCHK   EQU   X'02'     FINAL CHECK AT EOD
CHKNOW   EQU   X'04'     CHECK LAST WRITE NOW
BUFF2    EQU   X'04'     BUFFER 2 FULL
FULL2    EQU   X'06'     BUFFERS 1 AND 2 BOTH FULL
BUFW1    EQU   X'08'     BUFFER 1 WRITTEN
PURGE    EQU   X'08'     PURGE FLAG
BUFW2    EQU   X'10'     BUFFER 2 WRITTEN
RNBUF2   EQU   X'10'     RLD'S-IN-BUFFER-2 FLAG
NLFULL   EQU   X'10'     NOTE LIST FULL FLAG
MCT      EQU   12        MAX SIZE FOR RLD/TXT I/O CONTROL TABLE
CKNNLF   EQU   X'14'     CHECK NOW AND NOTE LIST FULL
WRIT2    EQU   X'18'     BUFFERS 1 AND 2 BOTH WRITTEN
FULLR    EQU   X'20'     RLD I/O CONTROL TABLE FULL FLAG
BUF1CHK  EQU   X'20'     BUFFER 1 CHECKED FLAG
BUF2CHK  EQU   X'40'     BUFFER 2 CHECKED FLAG
NOPNR1   EQU   X'7F'     BUFFER 1 OPENER FLAG MASK OUT
CONTOVN  EQU   X'7F'     CONTINUATION OVERFLOW FLAG MASK OUT
CONTOV   EQU   X'80'     CONTINUATION OVERFLOW FLAG
OPNR1    EQU   X'80'     BUFFER 1 OPENER FLAG
OP1BF2   EQU   X'81'     OPENER 1 AND BUFFER 2 NOW FLAGS
NBUF2CHK EQU   X'BF'     BUFFER 2 CHECKED FLAG MASK OUT
NBUF1CHK EQU   X'DF'     BUFFER 1 CHECKED FLAG MASK OUT
N2BUFWF  EQU   X'E1'     BOTH BUFFERS FULL AND WRITTEN FLAGS MASK OUT
NBUF2WF  EQU   X'EB'     BUFFER 2 FULL-WRITTEN FLAGS MASK OUT
NLFLCHKN EQU   X'EB'     NOTE LIST FULL + CHK NOW FLAGS MASK OUT
NBUFW2   EQU   X'EF'     BUFFER 2 WRITTEN FLAG MASK OUT
RNBUF1   EQU   X'EF'     RLD'S-IN-BUFFER-1 MASK
NBUF1WF  EQU   X'F5'     BUFFER 1 FULL-WRITTEN FLAGS MASK OUT
NBUFW1   EQU   X'F7'     BUFFER 1 WRITTEN FLAG MASK OUT
NPURGE   EQU   X'F7'     PURGE FLAG MASK OUT
NCHKNOW  EQU   X'FB'     CHECK NOW FLAG MASK OUT
NBUFF2   EQU   X'FB'     BUFFER 2 FULL FLAG MASK OUT
NBUFF1   EQU   X'FD'     BUFFER 1 FULL FLAG MASK OUT
NFNLCHK  EQU   X'FD'     FINAL CHECK FLAG MASK OUT
BUFLIP   EQU   X'FE'     EXTRACT CURRENT BUFFER FLAG MASK
BUFFRN1  EQU   X'FE'     BUFFER 1 CURRENT MASK
STMULT   EQU   X'02'               FOR MAXIMUM STRING
STMULT1  EQU   X'00'                  MULTIPLICITY
*                           FOR NOTE LIST
         SPACE 1
NFLGS    EQU   X'03'     NO FLAGS MASK
BUFN2    EQU   X'10'     BUFFER 2 HOLDS CURRENT RLD'S
TTRF     EQU   X'40'     TTR IS PRESENT/END-OF-BUFFER
NICF     EQU   X'6F'     RLD'S NOT-IN-CORE MASK
INCF     EQU   X'80'     RLD'S IN-CORE FLAG
GPF      EQU   X'BF'     SET GROUP FLAG MASK
FLGS     EQU   X'FC'     ALL FLAGS MASK
XPDIND   EQU   X'80'                   EXPAND REQUEST SWITCH     Y01031
*                                      (IN APTSW3; ONE=ACTIVE)   Y01031
         SPACE 2
*                             FOR CESD
         SPACE 1
DSAVOF   EQU   X'EF'     MASK OUT DELETE FLAG IN CESD
         SPACE 2
******** ERROR MSG ****************************************************
MSG      EQU   0       ALSO SEE IEW0284/IEW0222/IEW0614
IEW0234  EQU   X'417'  LOAD MODULE SOURCE ERROR        OY00131,@XA11151
IEW0354  EQU   X'423'  CALLS LIST OVERFLOW
IEW0622  EQU   X'023E'
IEW0374  EQU   X'425'  RLD I/O CONTROL TABLE OVERFLOW
IEW0382  EQU   X'226'
IEW0364  EQU   X'424'
***********************************************************************
*                       REGISTER ASSIGNMENTS
         SPACE 1
R0       EQU   0         SAVE/RESTORE, ERROR CODE, WORK REG
GR1      EQU   1         CESD ID, LINK THROUGH MULTDET, RESULTANT TTR
XS3      EQU   1         'R' ID
XAPT     EQU   2         POINTER TO APT
XRMK2    EQU   3         BYTE CT OF PROCESSED ENTRIES IN RLD I/O CTL TB
XAA      EQU   3         CURRENT LOC IN TEXT BUFFER
GR3      EQU   3         POINTER TO CESD, ASSEMBLED ADDR IN FA
XJM1     EQU   4         INPUT REC BYTE CT, TEXT OUTPUT BUFFER BYTE CT
XPSAV    EQU   4         'P' ID, POINTER TO ID IN RNT
GR4      EQU   4         START OF RLD STRING, DIVISION WORK REG
GR5      EQU   5         START RNT, DIVISION WORK REG
XRET2    EQU   5         LINK THROUGH WRITE ROUTINE
XPRLD    EQU   6         ORIGINAL POINTER TO START OF RLD STRING,
*                            CURRENT FA POINTER
XBCNT    EQU   7         BYTE COUNT OF PROCESSED ITEMS
XIBCNT   EQU   8         RLD STRING BYTE COUNT
XRET     EQU   9         LINK THROUGH BUFFERING ROUTINE
GR9      EQU   9         CURRENT RNT ENTRY POINTER
XOBCNT   EQU   10        BYTE COUNT OF ITEMS IN RLD BUFFER
XDCB     EQU   10        POINTER TO SYSUT1 DCB
XSTR     EQU   11        POINTER TO START OF RLD STRING
RBASE    EQU   12        MODULE BASE REGISTER
GR13     EQU   13        BASE REGISTER FOR MODULE SAVE AREA, POINTER
*                            TO CURRENT CESD ENTRY
R14      EQU   14        RETURN LINK, WRITE DATA LENGTH
XS1      EQU   14        POINTER TO CURRENT DELINK ENTRY, TO CURRENT
*                            CALLS LIST ENTRY, TO CURRENT CESD ENTRY,
*                            TEXT NOTE LIST OFFSET
XS2      EQU   15        POINTER TO CURRENT RLD BUFFER ENTRY,
*                            TO CURRENT TEXT NOTE LIST ENTRY, TO
*                            CURRENT TEXT BUFFER ENTRY, WORK REG
R15      EQU   15        BRANCH ADDRESS, WRITE DATA LOC, CURRENT LOAD
*                            MODULE BUFFER ENTRY, WORK REG
XRIO     EQU   15        CURRENT RLD NOTE LIST ENTRY POINTER
WRKREG0  EQU   0                   WORK REGISTER 0
WRKREGF  EQU   15                  WORK REGISTER 15
RETURN   EQU   14                  RETURN REGISTER
BRANCH   EQU   15                  BRANCH REGISTER
         TITLE 'HEWLFRAT   RLD/TXT PROCESSOR  --  ENTRY AND EXIT'
*                           R L D / T X T
*              C O M M O N   E N T R Y   AND   E X I T
*                              ROUTINE
         SPACE 2
*     THIS ROUTINE RECEIVES CONTROL FROM THE INPUT PROCESSOR.  IT SAVES
*  THE RETURN ADDRESS, DIFERENTIATES BETWEEN RLD AND TEXT MATERIAL, AND
*  PASSES CONTROL TO THE PROPER PROCESSING ROUTINE.  AT THE CONCLUSION
*  OF THIS PROCESSING, IT RE-ESTABLISHES THE RETURN ADDRESS AND RETURNS
*  CONTROL THERETO.
*     EVENT SEQUENCE FOR ENTRY --
*        ESTABLISH BASE REGISTER FOR COMMON ROUTINES AND RLD PROCESSOR.
*        SAVE RETURN ADDRESS.
*        LOAD REMAINING BUFFERRED BYTE COUNT
*        PROCEED TO PURGE RLD AND TEXT BUFFERS IF ENTRY IS FROM
*           END-OF-DATA.
*        DIRECT CONTROL TO EITHER THE RLD OR TEXT PROCESSING ROUTINE.
*        RELINQUISH CONTROL TO ERROR ROUTINE IF INPUT LENGTH IS
*           GREATER THAN MAXIMUM.
*        CLEAR STRING COUNT AND SAVE INPUT BYTE COUNT FOR RLD
*           PROCESSING ROUTINE.
*     EVENT SEQUENCE FOR PURGE/EXIT --
*        PURGE --
*           CLEAR STRING COUNT ACCUMULATOR
*           LINK TO RLD PURGE ROUTINE.
*           LINK TO TEXT PURGE ROUTINE.
*        EXIT --
*           SAVE RLD BUFFERRED BYTE COUNT (RLD RETURN).
*           LOAD RETURN ADDRESS (TEXT RETURN).
*           RETURN TO CALLER.
         SPACE 2
*HEWLFRAT  CSECT               ENTRY POINT AND NAME
         BALR  RBASE,R0        L BASE REGISTER
RATLOC   EQU   *               DEFINE BASE LOCATION
         USING *,RBASE         DEFINE BASE REGISTER
         USING APTDSECT,XAPT
         B     OVERNAME        SKIP IDENTITY
DATE     DC    C' 06/15/78 OZ33611 ' DATE/APAR NUMBER
MODID1   DC    C' HEWLFRAT ',0H'0'   MOD ID
OVERNAME L     XBCNT,TXT001AD  L BASE REGISTER FOR TEXT PROCESSING RTN
         USING HEWLFTXT,XBCNT  DEFINE BASE REGISTER FOR TEXT PROCESSOR
         ST    R14,INADD1      SAVE CALLER RETURN ADDRESS
         LH    XOBCNT,OBCNT    L REMAINING BUFFERRED COUNT
         TM    NEWSW,EOD       CHK FOR END-OF-DATA
         BC    7,ECPRG         BC IF YES TO PURGE ROUTINES
         LTR   XJM1,XJM1       NO -- CHK IF INPUT BYTE COUNT IS ZERO
         BC    8,TXTRET        IGNORE ZERO LENGTH TXT OR RLD INPUT
         TM    APT0,RT         CHK IF RLD OR TEXT
         BC    8,RATIN         BC IF RLD
         L     XS2,TXTBFEND    L LOC OF END OF TEXT BUFFER
         S     XS2,TXTBFBEG    LESS LOC OF START OF TEXT BUFFER
         CR    XJM1,XS2        CHK IF INPUT GREATER THAN SPAN
         BC    2,ERR3        INPUT RECORD LARGER THAN TXTBUFFER
         TM    APT1,EX         IS IT A LOAD MODULE?
         BO    TXTLM           BRANCH IS YES
TXT0011  LTR   RID,RID         IS TXT ID EQUAL ZERO?
         BC    8,TXTILL        YES, ERROR COND
         CH    RID,ENCDX       TXT ID G.T. NUMBER OF ESD ITEMS
         BH    TXTILL          YES, ERROR COND
         TM    APTSW3,XPDIND   EXPAND REQUEST?                   Y01031
         BO    TXT0151X        IF SO BRANCH                      Y01031
         SLL   RID,2           CALCULATE RENUMBER LINE
         A     RID,RECNT       ENTRY
         CLC   DID(2,RID),CONZO1 IS RENUMBERED ID EQU ZERO
         BE    TXTILL          YES, ERROR COND
         TM    DT(RID),DEL     IS THIS ID TO BE DELETED
         BO    TXTLM2          BRANCH IF SO
         TM    DT(RID),DT      TYPE NOT SD OR PC - INVALID
         BZ    TXT00151
*   IF ERROR BRANCH IS TAKEN, MODULE MARKED NOT
*   EXECUTABLE UNLESS 'LET' IS SPECIFIED
TXTILL   LA    MSG,IEW0382
         TM    APT1,EX         IS IT A LOAD MODULE?              A43127
         BO    ERR3A           YES,ISSUE MSG AND FLUSH NEXT REC  A43127
         B     ERROR
TXT00151 LH    RID,DID(RID)    RID=NEW UPDATED ID
TXT0151X LR    XS1,RID         XS1=NEW UPDATED ID                Y01031
         STH   XS1,CURID
*DETERMINE MULTIPLICITY AND CHECK FOR '512' MAXIMUM
         SLL   XS1,4
         A     XS1,CHESD       XS1=ABSOLUTE ADDR OF ENT. IN CESD
         L     XS1,8(XS1)      XS1=TYPE AND ASSEMBLED ADDRESS
         LA    XS1,0(XS1)      XS1=ASSEMBLED ADDR. OF CONTROL SECTION
         TM    APTSW3,XPDIND   EXPAND REQUESTED?                 Y01031
         BO    TXT0152X        IF SO BRANCH                      Y01031
         SR    XAA,XS1         ASSM ADDR NOW RELATIVE TO ZERO
TXT0152X LR    GR9,XAA                                           Y01031
         SR    GR8,GR8         DIVIDE BY SYSLMOD SIZE TO
         D     GR8,MULTSIZE    DETER. MULTIPLICITY AND DISPLACEMENT
         STH   GR9,CMULN
         STH   GR8,CDISP
         CH    GR9,MAXMULT     BRANCH IF WE HAVE NOT EXCEEDED
         BL    SPLTXT1         THE NUMBER OF MULTIPLICITIES    @ZA28721
         LA    MSG,IEW0364     INPUT HAS EXCEEDED MULT LIMIT
         B     ERROR
*
* SPECIAL TEXT IS SET ON IF THIS IS THE FIRST TEXT RECORD
* OF A CSECT IN A LOAD MODULE AND A LARGE DEFINE STORAGE
* IS THE FIRST THING IN THE CSECT AND THE DS AREA CROSSES
* A MULTIPLICITY.
*
SPLTXT1  EQU *                                                 @ZA28721
         LTR   XAA,XAA         TST FOR REMAINDER               @ZA28721
         BC    8,TXTINT        BR IF ZERO                      @ZA28721
         TM    APT1,EX         IS IT A LOAD MODULE?            @ZA28721
         BNO   TXTINT          BYPASS IF NOT                   @ZA28721
         CLC   PID(2),CURID    CURRENT ID A REPEAT?            @ZA33611
         BE    TXTINT          BRANCH IF YES                   @ZA33611
         TM    APTSW3,XPDIND   EXPAND REQUESTED?               @ZA28721
         BO    TXTINT          BYPASS IF EXPAND REQUESTED      @ZA28721
         SR    GR9,GR9         CLEAR REG 9                     @ZA28721
         AR    GR9,COUNT       ADD THE RECORD COUNT  TO  THE   @ZA33611
         AH    GR9,CDISP       DISPLACEMENT OF THE FIRST TXT   @ZA33611
         C     GR9,MULTSIZE    AND TEST IF IT CROSSES TO NXT   @ZA28721
         BNH   TXTINT          MULTIPLICITY,BR IF IT DOESN'T!  @ZA28721
         OI    SWITCH+1,SPTXTON  TURN SPECIAL TXT ON           @ZA28721
         B     TXTINT                                          @ZA28721
*   PASS INITIAL CHECKS
         BCR   15,XBCNT        GO TO PROCESS TEXT
RATIN    LH    XS2,ENRLD2X     RLD -- L SIZE OF RLD INPUT BUFFER
         CR    XJM1,XS2        CHK IF INPUT GREATER
         BC    2,ERR1          BC IF YES -- ERROR
         SR    XIBCNT,XIBCNT   CLEAR STRING COUNT ACCUMULATOR
         STH   XJM1,TTR1       SAVE RLD INPUT BYTE COUNT
RATINX   BC    15,RLD001       GO TO PROCESS RLD'S
         SPACE 1
ECPRG    SR    XIBCNT,XIBCNT   CLEAR STRING COUNT ACCUMULATOR
         BAL   XRET,RLDBUF     INPUT BYTE CT ZERO -- PURGE RLD
ECPRGX   STH   XIBCNT,OBCNT    CLEAR PREVIOUS BUFFERRED COUNT
         LA    XRET,TXTRET     SET INTERMEDIATE RETURN
         L     R14,TXTBUFAD    L LOC OF TEXT PURGE ROUTINE
         BCR   15,R14          GO TO TEXT PURGE ROUTINE
         SPACE 1
RLDRET   STH   XOBCNT,OBCNT    SAVE BUFFERRED BYTE COUNT
         SPACE 1
TXTRET   L     R15,INADD1      L RETURN ADDRESS
         BALR  R14,R15         RETURN (WITH LINK)
         SPACE 1
MOVEJM1  MVC   0(0,XS2),0(XSTR)  MOVE INSTR TO MOVE ITEM TO BUFFER
         BC    15,RLD0161      CONTINUE PROCESSING IF LINKED
         SPACE 1
MOVEJM1A MVC   0(4,XS2),SAVIDS   MOVE 'R' AND 'P' ID'S INTO BUFFER
         SPACE 1
         TITLE 'HEWLFRAT   RLD/TXT PROCESSOR  --  WRITE ROUTINE'
*                          R L D / T X T
*                     C O M M O N   W R I T E
*                             ROUTINE
         SPACE 1
*  THIS ROUTINE WRITES THE RLD AND TEXT INTERMEDIATE OUTPUT AS WELL   *
*  AS THE RLD AND TEXT NOTE LISTS AS REQUIRED.  AT ENTRY A TEST IS    *
*  MADE FOR RECORD SIZE ZERO.  ZERO SHOWS THE INPUT MODULE CONTAINED  *
*  NO TEXT OR RLD ITEMS OR THAT THE RLD ITEMS OCCURRED IN A MODULE    *
*  MARKED DELETE.  IN THE ZERO LENGTH CASE NO WRITE TAKES PLACE.      *
*  IF SYSUT1 HAS NOT BEEN OPENED PREVIOUSLY, IT IS OPENED NOW.
         SPACE 2
RLDBUFR  LTR   R14,R14         CHK IF SIZE IS ZERO OR LESS
         BCR   12,XRET         BC IF YES -- RETURN
COMBUF   LA    GR13,REGSA      SIZE NOT ZERO -- L LOC OF SAVE AREA
BUFFRET  L     XDCB,DCBAD      L LOC OF SYSUT1 DCB
         STH   R14,DECBJM+LENGTH   SET DATA LENGTH IN DECB
         ST    R15,DECBJM+ADD   SET DATA AREA LOC IN DECB
         SPACE 1
         TM    OPNFLGS(XDCB),DCBOPN  CHK IF DCB OPENED
         BC    1,COMBUF2       BC IF YES
         SPACE 1
         MVC   DDNAME(8),40(XDCB)   NO -- RESERVE DD NAME
         OPEN  ((XDCB),(OUTIN))   OPEN SYSUT1 DCB
         SPACE 1
         TM    OPNFLGS(XDCB),DCBOPN   CHK IF OPEN SUCCESSFUL
         BC    1,COMBUF2       BC IF YES
ABEND1   LA    GR1,DDNAME      NO -- L LOC OF DD NAME
         LH    MSG,IEW0284     L ERROR CODE
         LA    R14,TXTRET      L RETURN ADDRESS
         L     R15,ERDIG       L LOC OF ERROR ROUTINE
         BCR   15,R15          GO TO ERROR ROUTINE
         SPACE 1
COMBUF2  WRITE DECBJM,SF,(XDCB),PHADD,PHL
         BCR   15,XRET2        RETURN
         SPACE  1
COMCHK   LA    GR13,REGSA      L LOC OF SAVE AREA
         L     XDCB,DCBAD      L ADDRESS OF SYSUT1 DCB
         SPACE  1
         CHECK DECBJM
         SPACE 1
         NOTE  (XDCB)
         SPACE 1
         SR    XOBCNT,XOBCNT   CLEAR BUFFERRED BYTE COUNT
         BCR   15,XRET2        RETURN
         SPACE 2
DDNAME   DC    C'SYSUT1  '
         SPACE 2
   TITLE 'HEWLFRAT   RLD/TXT PROCESSOR  --  ERROR ROUTINE INTERFACE'
*                    E R R O R     R O U T I N E
*                         I N T E R F A C E
         SPACE 2
         SPACE 1
ERR1     LH    MSG,IEW0222     L OBJECT MODULE ERROR CODE
         TM    APT1,EX         CHK IF IS OBJECT MODULE
         BC    8,ERROR         BC IF YES TO ERROR ROUTINE INTERFACE
ERR2     LA    MSG,IEW0234     NO -- L ERROR CODE FOR LOAD MODULE
         SPACE 2
*                   COMMON EXIT TO ERROR ROUTINE
         SPACE 1
ERROR    L     R15,ERDIG
         LA    R14,TXTRET
         BCR   15,R15
         SPACE
*     ERROR CAUSE BY INPUT EECORD LARGER THAN THAN THE TEXT BUFFER
*        REQUIRE ERROR MSG AND A DUMMY READ
         SPACE
ERR3     LA    MSG,IEW0234    LOAD MODULE RRROR MSG
ERR3A    L     R15,ERDIG      ESTABLISH ADDR OF ERROR RTN        A43127
         BALR  R14,R15    PRINT ERROR MSG AND RETURN TO
         LA    GR9,1            ISSUE BUMMY READ OF 1 TO ADVANCE TO
         B     READ0        TO THE NEXT RECORD
     TITLE 'HEWLFRAT   RLD/TXT PROCESSOR  --  MULTIPLICITY ROUTINE'
*                            C O M M O N
*        M U L T I P L I C I T Y   D E T E R M I N A T O R
*                              ROUTINE
         SPACE 2
*     THIS ROUTINE DETERMINES THE LOWEST MULTIPLICITY IDENTITY
*  AND RELOCAND OF TEXT ITEM
*     XS1 AND XS2 = CBRC
*     XAA = ASSEMBLED ADDRESS OF 1ST BYTE OF TEXT
*     XAA = GR3, GR3 = ADDRESS FIELD FOR RLD ITEM
         SPACE 2
         SPACE 2
MULTDET  SLL   XS1,4           MULTIPLY 'ID' BY 16 (CESD LENGTH)
         A     XS1,CHESD       ADD LOC OF START OF CESD
         L     XS1,8(XS1)      L TYPE/ADDRESS FROM EXTRACTED ENTRY
         LA    XS1,0(XS1)      CLEAR TO ASSEMBLED ADDRESS
         LCR   XS1,XS1         FORM COMPLEMENTED ADDRESS
         A     XS1,TXTBFBEG    ADD LOC OF TEXT BUFFER TO FORM CURRENT
*                                   BUFFER RELOCATION CONSTANT  (CBRC)
         LR    XS2,XS1         L CBRC IN XS2
         LR    R0,XS1          SAVE REGISTER  (CBRC)
         AR    XS2,XAA         ADD ASSEMBLED ADDRESS OF TEXT TO CBRC
         S     XS2,TXTBFBEG    SUBTRACT LOC OF TEXT BUFFER
         SR    XS1,XS1         CLEAR REMAINDER REGISTER
         D     XS1,MULTSIZE    DIVIDE BY BUFFER SIZE FOR MULTIPLICITY
         N     XS2,STRUNC      LIMIT MULTIPLICITY TO 10 BITS
         BCR   15,GR1          RETURN
         SPACE 2
         TITLE 'HEWLFRAT   RLD/TXT PROCESSOR  --  RLD PROCESSING'
*                 R L D    P R O C E S S I N G
*                            ROUTINE
         SPACE 2
*     THIS ROUTINE IS ENTERED FOR EACH 'R' AND 'P' FIELD.  IT RENUMBERS
*  THE 'R' AND 'P' POINTERS VIA THE RENUMBERING TABLE AND DETERMINES
*  WHEN IT IS NECESSARY TO ENTER THE DELINK ROUTINE.  THE ACTUAL
*  SETTING OF THE DELINK ENTRY WAS DONE BY THE ESD PROCESSOR.
*     XBCNT = CUMULATIVE BYTE COUNT OF INPUT RLD ITEMS WHICH HAVE BEEN
*        PROCESSED.  WHEN XBCNT = TTR1, END OF INPUT HAS BEEN REACHED.
*     XIBCNT = STRING BYTE COUNT.   A STRING CONSISTS OF A GROUP OF
*        CONTIGUOUS RLD ITEMS, EACH WITH A 'P' ID FIELD OF THE SAME ID.
*        ONE ENTRY FOR EACH STRING IS MADE IN THE RLD NOTE LIST.
*     XSTR = POINTER TO START OF A STRING -- INITIAL 'R' ID.
*     XPRLD = POINTER TO CURRENT FLAG-ADDRESS ITEM.  AT ENTRY XPRLD
*        HOLDS THE LOCATION OF THE FIRST RLD ITEM IN AN INPUT RECORD.
*        SUBSEQUENTLY IT IS THE POINTER TO THE FA FIELD OF EACH CURRENT
*        ITEM.
         SPACE 1
RLD001   SR    XBCNT,XBCNT     INITIALIZE INPUT COUNT TO ZERO
         MVC   ENCT(2),ENR1C   SET CURRENT NOTE LIST ENTRY COUNT
RLD002   SR    XIBCNT,XIBCNT   INITIALIZE STRING COUNT TO ZERO
         SPACE 1
RLD002A  LA    XBCNT,8(XBCNT)  STEP BY 8 NO OF BYTES PROCESSED
         LR    XSTR,XPRLD      L START OF CURRENT STRING
         L     R14,BUFSTLOC    L BUFFERED STRING LOCATION
         LTR   R14,R14         CHK IF LOCATION SET
         BC    7,RLD002B       BC IF YES
         ST    XSTR,BUFSTLOC   NO -- SET WITH CURRENT STRING LOC
RLD002B  MVC   SAVIDS(4),0(XSTR)   RESERVE 'R' AND 'P' ID'S
         MVC   SAVIDR(2),0(XSTR)   SAVE RLD ITEM 'R' ID
         LA    XPRLD,4(XPRLD)  STEP TO LOC OF NEXT FA FIELD
         MVI   STM,STMULT      RESET STRING MULTIPLICITY
         LH    XPSAV,SAVIDS+2           L 'P' NUMBER AND
         SLL   XPSAV,2           QUADRUPLE  (ID FIELD LENGTH)
         A     XPSAV,RECNT     ADD LOC OF RNT-4 TO FORM CURRENT RNT LOC
         CLC   DID(2,XPSAV),CONZO  IS RENUMBERED ID ZERO
         BC    8,ERR1          BC IF ZERO -- ERROR
         LH    GR3,ENCDX               MAX # CESD = MAX # RNT'S  A53300
         SLL   GR3,2                   MULTIPLY BY 4             XM1384
         A     GR3,RECNT               GET HIGHEST ADDR OF RNT-4 A53300
         A     GR3,FOUR                HIGHEST VALID ADDR OF RNT A53300
         CR    GR3,XPSAV               IS IT A VALID P PTR?      A53300
         BL    ERR1                    NO - IEW0222              A53300
         OI    APT1,DEL        SET DELETE FLAG
         TM    DT(XPSAV),DEL   IS P A DELETE
         BC    1,RLD012        BC IF YES TO SKIP PROCESSING
         NI    APT1,DELOFF     NO -- RESET DELETE FLAG OFF
RLD003   CLC   DID(2,XPSAV),PREP  IS CURRENT P SAME AS PREVIOUS P
         BC    8,RLD0042       BC IF YES TO CONTINUE STRING
         LR    XRET,XOBCNT     L BUFFERRED BYTE COUNT
         AR    XRET,XIBCNT     ADD CURRENT STRING COUNT
         LA    XRET,4(XRET)    STEP BY 4
         C     XRET,RLDSIZE    CHK AGAINST MAXIMUM BUFFER SIZE
         BC    10,RLD0042      BC IF EQUAL OR GREATER
RLD0031  BAL   XRET,RLDBUF     NO -- GO TO BUFFER PREVIOUS STRING
*                                NOTE -- BUFFERING WILL NOT OCCUR IF
*                                    PREVIOUS P WAS A DELETE OR IF THIS
*                                    IS THE FIRST P POINTER IN A MODULE
RLD004   SR    XIBCNT,XIBCNT   RESET STRING COUNT TO ZERO
         TM    RLDFLGS,CONTOV  CHK FOR CONTINUATION OVERFLOW FLAG
         BC    8,RLD0041       BC IF NO
         NI    RLDFLGS,CONTOVN   CLEAR CONTINUATION OVERFLOW FLAG
         CH    XBCNT,TTR1      CHK IF INPUT EXHAUSTED
         BC    10,RLDRET       RETURN IF YES
         L     XSTR,SBACKUP    SET NEW STRING ORIGIN
         ST    XSTR,BUFSTLOC   SET NEW BUFFERRED STRING LOC
         LR    XPRLD,XSTR      L NEW STRING ORIGIN
         LA    XPRLD,4(XPRLD)   SET TO LOC OF NEXT FA FIELD
         LA    XBCNT,4(XBCNT)  STEP BY 4 NO OF INPUT BYTES PROCESSED
         LA    XPSAV,SAVIDS+2  RESERVE 'P' ID
         BC    15,RLD0041A
RLD0041  ST    XSTR,BUFSTLOC   SET NEW BUFFERRED STRING LOC
RLD0041A MVC   PREP(2),DID(XPSAV)   RESERVE CURRENT 'P' AS PREVIOUS 'P'
RLD0042  MVC   SAVIDS+2(2),0(XPSAV)   SAVE NEW 'P' ID FOR RLD ITEM
RLD0043  NI    PDSE8,ANY       SET RLD FLAG ON
         LA    XIBCNT,8(XIBCNT)  STEP STRING COUNT BY 8
         LH    GR4,SAVIDR      L 'R' ID OF CURRENT ITEM
         N     GR4,RIDMSK      CLEAR TO 'R' ID
         LA    R14,RLD010      L PROCEED ADDRESS FOR 'P' RENUMBERING
         SPACE 2
*                  RENUMBER 'ID' POINTER ROUTINE
*                     WITH DELINK IF REQUIRED
         SPACE 1
RLD004A  LR    R0,R14          SAVE REGISTER 14
         L     GR3,CHESD       L START OF CESD
         L     GR5,RECNT       L START OF RNT-4
         LR    GR9,GR4         L RLD 'ID'
         SLL   GR9,2           QUADRUPLE  (ENTRY LENGTH)
         AR    GR9,GR5         ADD RNT START TO FORM CURRENT ENTRY LOC
         TM    0(XPRLD),X'30'  IS RLD A PSEUDO-REGISTER
         BC    1,RLD012        BC IF YES -- SKIP RENUMBERING
         CLC   DID(2,GR9),CONZO  IS RENUMBERED ID ZERO
         BC    8,ERR1          BC IF YES -- ERROR
         LH    GR3,ENCDX               MAX # CESD = MAX # RNT'S  A53300
         SLL   GR3,2                   MULTIPLY BY FOUR          XM1384
         A     GR3,RECNT               GET HIGHEST ADDR OF RNT-4 A53300
         A     GR3,FOUR                HIGHEST VALID RNT ADDR    A53300
         CR    GR3,GR9                 VALID R PTR?              A53300
         L     GR3,CHESD               RESTORE START OF CESD -   A53300
*                                      DOESN'T CHANGE COND CODE  A53300
         BL    ERR1                    NO - IEW0222              A53300
         LH    GR1,DID(GR9)    L UPDATED ID
         MVC   TEMP(1),3(GR9)          GET RNT TYPE             XA04649
         NI    TEMP,X'0F'              GET RID OF FLAGS         XA04649
         CLI   TEMP,X'04'              TEST FOR PC TYPE         XA04649
         BNE   RLD004B                 BRANCH IF NOT PC         XA04649
         TM    3(GR9),X'10'            TEST FOR DELETE FLAG     XA04649
         BNO   RLD004B                 BRANCH IF NOT PC DELETE  XA04649
         LR    GR13,GR1                SET UP WORK REG          XA04649
         SLL   GR13,4                  CALC CESD OFFSET         XA04649
         AR    GR13,GR3                GET CESD POINTER         XA04649
         NC    13(3,GR13),13(GR13)     TEST FOR 0-LENGTH PC     XA04649
         BNZ   RLD004B                 BRANCH IF NOT 0-LENGTH   XA04649
         LA    R0,IEW0622              SET UP MESSAGE IEW0622   XA04649
         B     ERROR                   GO TO LOG MESSAGE        XA04649
RLD004B  EQU   *                                                XA04649
         LR    GR13,GR1        USE UPDATED ID
         SLL   GR13,4          MULTIPLY BY 16  (ENTRY LENGTH)
         AR    GR13,GR3        ADD START OF CESD TO FORM CURRENT LOC
         TM    DT(GR9),DEL     IS TYPE IN RNT A DELETE
         BC    8,RLD008        BC IF NO
         TM    DF(GR9),DSAV    YES, IS DELETE -- IS DELINK VALUE SAVED
         BC    1,RLD007        BC IF YES
         TM    0(XPRLD),ANYR   DELINK NOT SAVED -- IS TYPE NON-BRANCH
         BC    5,RLD0061       BC IF NO TO SKIP DELINKING
         SPACE 1
RLD005   L     R15,ADDEL       NON-BRANCH TYPE -- L LOC OF DELINK RTN
         S     GR9,RECNT               HOLD RNT OFFSET          XA05656
         BALR  R14,R15         GO TO PERFORM DELINK
         LR    R14,R0          RESTORE REGISTER 14
         A     GR9,RECNT               RECALC RNT ADDR          XA05656
         SPACE 1
RLD0061  NI    8(GR13),DSAVOF  SET DELETE FLAG OFF IN CESD
         TM    DF(GR9),DSAV    IS DELINK VALUE SAVED
         BC    8,RLD008        BC IF NO
RLD007   TM    0(XPRLD),ANYR   IS RNT TYPE A NON-BRANCH
         BC    5,RLD009        BC IF NO
MOVEJM2  MVC   DELR(2),DID(GR9)  SAVE RENUMBERED ID
         OI    APTSWS,X'08'    SET DELINKED 'R' RECEIVED FLAG
         BCR   15,R14          RETURN TO DELINK CALLER
         SPACE 1
RLD008   TM    DT(GR9),CH      IS RNT TYPE FLAGGED AS CHAINED
         MVC   SAVIDS(2),DID(GR9)   SAVE RENUMBERED ID FOR OUTPUT
*                                NOTE -- THIS INSTRUCTION DOES NOT
*                                  CHANGE CONDITION CODE
         BCR   8,R14           NOT CHAINED -- MOVE INSTR OK -- RETURN
         MVC   SAVIDS(2),14(GR13)   CHAINED -- OVERWRITE FIRST MOVE
         BCR   15,R14          RETURN TO CALLER
         SPACE 1
RLD009   LA    XS1,5           L SIZE OF DELINK TABLE ENTRY
         MH    XS1,0(GR9)      MULTIPLY BY ENTRY NUMBER
         A     XS1,DLKT        ADD START OF DELINK TABLE TO FORM DELINK
*                                ENTRY LOC
         MVC   SAVIDS(2),0(XS1)   RENUMBER 'R' WITH DELINK TABLE ID
         LR    R14,R0          RESTORE REGISTER 14
         BCR   15,R14          RETURN TO CALLER
         SPACE 2
         EJECT
*                 OVERLAY CALLS LIST ENTRY ROUTINE
         SPACE 1
*         IF OVERLAY IS SPECIFIED,  AND IF THE REFERENCE IS TO A 4-BYTE
*  CONSTANT, THIS ROUTINE IS ENTERED.  IF THE REFERENCE AND THE POINTER
*  ARE IN THE SAME CSECT NO ACTION IS TAKEN.  IF THE 'P' ID IS DIFERENT
*  FROM THE PREVIOUS 'P' ENTERED, THE 2 BYTE CHAINING FIELD IS CLEARED,
*  THE NEW 'P' IS INSERTED IN THE NEXT 2 BYTE AREA, AND THE CURRENT 'R'
*  ID FOLLOWS IN THE NEXT 2 BYTE AREA.  IF THE NEW 'P' ID MATCHES THE
*  PREVIOUS 'P', THE CURRENT 'R' ID IS ENTERED DIRECTLY IN THE FIRST 2
*  BYTES.  THE UPDATED CUMULATIVE CALLS LIST BYTE COUNT IS SAVED IN APT
*  (ENCLC).  WHEN THIS CALLS LIST LENGTH EXCEEDS MAXIMUM (ENCLX),  AN
*  ERROR INDICATION IS GENERATED.
         SPACE 1
RLDCALL  TM    PDSE7,OI        CHK FOR OVERLAY
         BC    8,RLD012        BC IF NO -- SKIP CALLS LIST ENTRY
         TM    0(XPRLD),X'0C'  IS OVERLAY -- CHK IF 4 BYTE CONSTANT
         BC    12,RLD012       BC IF NO -- SKIP CALLS LIST ENTRY
         SPACE 1
         LH    XS1,ENCLC       L CURRENT BYTE COUNT OF CALLS LIST
         A     XS1,CLLT        ADD START OF CALLS LIST TO FORM CURRENT
*                                  ENTRY LOCATION
         LH    XS3,SAVIDS      L CURRENT 'R' ID
         N     XS3,RIDMSK      CLEAR TO 'R' ID
         TM    APTSWS,X'08'            IS DELINK VALUE SAVED?
         BZ    RLDCLA                  NO, BRANCH OUT
         MH    XS3,FIVEFIVE            YES, MULT DELINK ID BY 5
         A     XS3,DLKT                ADD TO DELINK TABLE ADDR
         MVC   DLKTSAVE(2),0(XS3)      SAVE TRUE R ID
         LH    XS3,DLKTSAVE            PICK UP TRUE R ID
RLDCLA   LH    XS2,SAVIDS+2            PICK UP CURRENT P ID
         CR    XS2,XS3         CHK IF 'R' EQUALS 'P'  (IN SAME CSECT)
         BC    8,RLD012        RETURN IF YES -- NO ENTRY REQUIRED
         CH    XS2,CALLCURP    DOES 'P' EQUAL PREVIOUS 'P'
         BC    8,CALLR         BC IF YES
CALLPANR MVI   0(XS1),0        NO --    CLEAR
         MVI   1(XS1),0             CHAINING FIELD
         STH   XS2,2(XS1)      SET CURRENT 'P' IN CALLS LIST
         STH   XS2,CALLCURP    SAVE NEW 'P' FOR FUTURE CHECK
         LA    XS1,4(XS1)      STEP ENTRY POINTER BY 4 TO 'R' AREA
CALLR    STH   XS3,0(XS1)      SET CURRENT 'R' IN CALLS LIST
         LA    XS1,2(XS1)      STEP ENTRY POINTER TO NEXT 'R' FIELD
*                                   (OR NEXT ENTRY)
         S     XS1,CLLT        SUBTRACT CALLS LIST START TO GET BYTE CT
         STH   XS1,ENCLC       SAVE UPDATED CALLS LIST BYTE COUNT
         AH    XS1,SIX                 ADD 6 BYTES TO COUNT      XM6209
CALLR02  CH    XS1,ENCLX       CHK IF BYTE CNT IS AT OVRFLO SIZE XM6209
         BNH   CALLR01       NO -- CONTINUE               A52402,XM6209
         TM    APT4,REALOCTE    IS REALOC POSSIBLE?              S01904
         BNO   CALLR1            YES,TRY REALLOCATING            S01904
         LA    MSG,IEW0354     YES -- L CALLS LIST OVERFLOW ERROR CODE
         BC    15,ERROR        GO TO ERROR ROUTINE INTERFACE
CALLR01  SH    XS1,SIX                 SET BACK TO TRUE COUNT    XM6209
         B     RLD012                  CONTINUE PROCESSING       XM6209
SIX      DC    H'6'                    SIX BYTES                 XM6209
CALLR1   STM   WRKREG0,WRKREGF,BRNCHSV SAVE REGISTERS            S01904
         L     BRANCH,ERDIGA       GET ADDR OF REALOC RT         S01904
         BALR  RETURN,BRANCH       GO TO REALLOCATE              S01904
         LM    WRKREG0,WRKREGF,BRNCHSV  RESTORE REGISTERS        S01904
         B     CALLR02             CONTINUE               S01904,XM6209
         SPACE 2
         EJECT
*     THIS SEQUENCE IS ENTERED FOR EACH FLAG-ADDRESS FIELD (FA).  IT
*  POSTS THE FLAG FIELD WITH THE PROPER INDICATION FOR AN ABSOLUTE OR
*  A RELATIVE RELOCATION CONSTANT OR FOR A PSEUDO-REGISTER.  IT FINDS
*  THE LOWEST MULTIPLICITY IN A STRING OF RLD ITEMS OF THE SAME 'P'
*  POINTER AND ENTERS THAT MULTIPLICITY IN THE RLD NOTE LIST ENTRY FOR
*  THAT 'P' POINTER.
         SPACE 2
RLD010   EQU   *               DEFINE SYMBOL
         NI    0(XPRLD),X'7F'          CLEAR POSSIBLE FLAGS FROM
*                                   PREVIOUS SECOND PASS PROCESSING
*                                        (IF EXECUTABLE MODULE)
         TM    0(XPRLD),X'30'  IS THIS A PSEUDO-REGISTER
         BC    1,RLD012        YES -- SKIP PROCESSING
         TM    0(XPRLD),X'10'  IS FLAG A BRANCH TYPE
         BC    1,RLDCALL       YES -- GO TO CHK FOR OVERLAY
         TM    DT(GR9),DEL     CHK IF DELETE FLAG IN RNT
         BC    8,RLD010A       BC IF NOT DELETE
         SPACE 1
         BAL   R14,RLD004A     DELETE -- DELINK IF REQUIRED
         SPACE 1
RLD010A  MVC   FLAG(1),DT(GR9) GET TYPE BYTE FROM RNT
         NI    FLAG,X'07'      ISOLATE TYPE FLAGS
         CLI   FLAG,X'06'      IS PSEUDO-REGISTER
         BC    7,RLD011        BC IF NO
         OI    0(XPRLD),X'20'  YES -- FLAG RLD ITEM AS PR
         BC    15,RLD012
         SPACE 1
RLD011   CLI   FLAG,X'02'      IS EXTERNAL REFERENCE
         BC    8,RLD012        BC IF YES
         TM    DT(GR9),DEL     NO -- CHK FOR DELETE IN RNT
         BC    1,RLD012        YES -- FLAG REMAINS ABSOLUTE
         OI    0(XPRLD),REL    NOT DELETE -- FLAG AS RELATIVE
RLD012   LH    XS1,SAVIDS+2    L CURRENT 'P' ID
         L     GR3,0(XPRLD)         EXTRACT ASSEMBLED ADDRESS
         LA    GR3,0(GR3)               FROM RLD FA FIELD
         TM    APT1,DEL        IS 'P' A DELETE
         BC    1,RLD0122       YES -- GO TO CHK FOR CONTINUED STRING
         SPACE 2
*                ESTABLISH MULTIPLICITY OF CURRENT ITEM
         SPACE 1
         BAL   GR1,MULTDET     NOT DELETE -- GO TO OBTAIN MULTIPLICITY
         SPACE 1
         STH   XS2,POSMULT     RESERVE POSSIBLE NEW LOWEST MULTIPLICITY
         MVC   NFLG(1),RLDMULT      EXTRACT FLAGS FROM
         NI    NFLG,FLGS              NOTE LIST MODEL
         NI    RLDMULT,NFLGS   CLEAR FLAGS IN MODEL (ID MULTIPLICITY)
         NI    STM,NFLGS       CLEAR FLAGS IN STRING MULTIPLICITY
         LR    R0,XIBCNT               CURRENT STRING LENGTH     A38313
         AR    R0,XOBCNT               ADD BUFFER BYTE COUNT     A38313
         CLC   SAVIDS+2(2),PREP        SAME P PTR?              OY00137
         BNE   RLD01202                IF NOT BRANCH            OY00137
         TM    APTSWS,X'08'            TEST DELINK R PTR SAVED  OY00137
         BNO   RLD01200                BRANCH IF NOT ON         OY00137
         CLC   DELR(2),PRER            SAME R PTR?              OY00137
         BNE   RLD01202                BRANCH IF NOT            OY00137
         B     RLD01201                BRANCH                   OY00137
RLD01200 CLC   SAVIDS(2),PRER          SAME                     OY00137
         BNE   RLD01202                BRANCH IF NOT            OY00137
RLD01201 SH    R0,SFOUR                ALLOW FOR CHAINED ITEM   OY00137
RLD01202 EQU   *
         C     R0,RLDSIZE              COMPARE TO MAX BUFF COUNT A38313
         BH    RLD0120                 GREATER, SKIP      A49482,A38313
*                                      MULT DETER         A49482,A38313
         CLC   POSMULT(2),RLDMULT  IS THIS LOWEST MULTIPLICITY OF ID
         BC    10,RLD0120      BC IF NO TO CHK STRING MULTIPLICITY
         STH   XS2,RLDMULT     YES -- SET NEW LOWEST MULT IN MODEL
RLD0120  CLC   POSMULT(2),STM  IS THIS LOWEST MULTIPLICITY OF STRING
         BC    10,RLD0121      NO -- GO TO CHK FOR CONTINUATION
         STH   XS2,STM         YES -- SAVE NEW LOWEST STRING MULT
RLD0121  OC    RLDMULT(1),NFLG SET FLAGS IN RLD MODEL
         OC    STM(1),NFLG     SET FLAGS IN STRING COMPARATOR
RLD0122  TM    APTSWS,X'08'
         BC    8,RLD0122X         BRANCH IF NOT
         MVC   SAVIDS(2),DELR     MOVE DELINK 'R' POINTER
         OI    SAVIDS,NREL        SET NON-RELATIVE FLAG
RLD0122X TM    0(XPRLD),CONT      CHK FOR CONTINUATION FLAG
         LA    XPRLD,4(XPRLD)  STEP TO NEXT FA FIELD (OR END OF STRING)
*                              NOTE -- THIS INSTRUCTION WILL NOT CHANGE
*                                CONDITION CODE
         BC    8,RLD013A       BC IF NO
         TM    APT1,DEL        IS 'P' A DELETE
         BC    1,RLD0124       BC IF YES
         LR    R0,XIBCNT       CONTINUE STRING -- L CURRENT STRING CT
         AR    R0,XOBCNT       ADD BUFFERRED BYTE COUNT
         LR    XS1,XPRLD       L CURRENT STRING ITEM POINTER
         SH    XS1,SFOUR       SUBTRACT 4
         C     XIBCNT,RLDSIZE  CHK IF STRING EQUALS BUFFER
         BC    8,RLD0125       BC IF YES
         C     R0,RLDSIZE      STRING IS LESS, CHK TOTAL COUNT
         BC    4,RLD0124       BC IF TOTAL LESS THAN BUFFER
         CLC   SAVIDS(2),PRER  CHK IF CURRENT 'R' SAME AS PREVIOUS 'R'
         BC    7,RLD0122A      BC IF NOT SAME
         CLC   SAVIDS+2(2),PREP  SAME -- CHK 'P' SAME AS PREVIOUS 'P'
         BC    8,RLD0123       BC IF SAME
RLD0122A C     R0,RLDSIZE      NOT SAME -- CHK TOTAL WITH BUFFER SIZE
         BC    8,RLD0125       BC IF EQUAL
         SH    XS1,SFOUR       SUBTRACT 4 FROM STRING POINTER
         BC    15,RLD0125
RLD0123  C     R0,RLDSIZE      CHK TOTAL WITH BUFFER SIZE
         BC    2,RLD0125       BC IF GREATER
RLD0124  LA    XBCNT,4(XBCNT)  SAME -- STEP BY 4 INPUT BYTE COUNT
         LA    XIBCNT,4(XIBCNT)  STEP BY 4 CURRENT STRING COUNT
         TM    APT1,DEL        IS 'P' A DELETE
         BC    1,RLD0122X         YES - GO TO END OF STRING
         BC    15,RLD010       NO -- GO TO CHECK NEXT FA ITEM
         SPACE 1
RLD0125  OI    RLDFLGS,CONTOV  SET CONTINUATION-OVERFLOW FLAG
         ST    XS1,SBACKUP     SAVE FOR REPLACEMENT STRING POINTER
*
*      IF DELINKING HAS TAKEN PLACE, THIS ROUTINE MOVES THE DELINKED
*  'R' POINTER INTO THE STRING ID, CLEARS THE DELINK FLAG IN APT, SETS
*  THE NON-RELATIVE FLAG IN THE 'R' ID AND CLEARS THE RELATIVE FLAG
*  IN EACH FA FIELD IN THE STRING.
*
RLD013A  TM    APTSWS,X'08'    CHK IF ANY DELINK 'R' RECEIVED
         BC    8,RLD013        BC IF NO -- CONTINUE RLD PROCESSING
         NI    APTSWS,X'F7'    CLEAR DELINK FLAG IN APT
         LR    R0,XSTR         SAVE START OF STRING
         LA    XSTR,4(0,XSTR)  INCREMENT TO FA FIELD
RLD013B  NI    0(XSTR),RELOFF  CLEAR RELATIVE FLAG IN FA
         LA    XSTR,4(0,XSTR)  INCREMENT TO NEXT FLAG FIELD
         CR    XSTR,XPRLD      CHK IF AT END OF STRING
         BC    5,RLD013B       BC IF NO TO CONTINUE STRING PROCESSING
         LR    XSTR,R0         YES -- RESTORE STRING POINTER
         SPACE  2
*IF CONTINUATION BIT NOT SET, NEXT ITEM IS A NEW R+P OR WE ARE AT
*THE END OF OUR INPUT RECORD
         SPACE 1
RLD013   TM    APT1,DEL        IS 'P' A DELETE
         BC    1,RLD0156       IF YES, GO TO CHK END-OF-INPUT
         SPACE 1
*        WE HAVE COME TO THE END OF A STRING OF
*RLD ITEMS. WHAT FOLLOWS THIS STRING MAY BE ANOTHER RLD ITEM WITH A NEW
*R AND P OR WE MAY BE AT THE END OF THE RLD INPUT. BEFORE WE FIND
*OUT WHICH IS TRUE, THE OLD STRING MUST BE MOVED INTO THE RLD BUFFER.
*IF THE RLD STRING WILL NOT FIT INTO THE BUFFER, THE BUFFER IS FIRST
*PURGED. THE OLD STRING WILL THEN BE MOVED IN.
         SPACE 1
RLD014   L     XS2,RLDOUT1     L START OF RLD BUFFER 1 -- DATA LOC
         TM    BUFFS,BUFFRN2   CHK IF BUFFER 2 IS CURRENT
         BC    8,*+8           BC IF NO
         L     XS2,RLDOUT2     L START OF RLD BUFFER 2 -- DATA LOC
         AR    XS2,XOBCNT      ADD BUFFERRED COUNT TO BUFFER LOC
         LR    XS1,XIBCNT             L CURRENT STRING BYTE COUNT
         AR    XS1,XOBCNT          AND FORM CURRENT BUFFER BYTE COUNT
RLD0151  BCTR  XIBCNT,0        REDUCE FOR EXACT MOVE COUNT
         CLC   SAVIDS(4),PRER  CHK IF CURRRNT 'ID'S' SAME AS PREVIOUS
         BC    7,RLD0152       BC IF NOT BOTH SAME
RLD015   SH    XS2,SFOUR       GET ADDRESS OF PREVIOUS FA FIELD
         OI    0(XS2),CONT     SET CONTINUATION FLAG IN PREVIOUS FA
         LA    XS2,4(XS2)      RESTORE BUFFER LOC
         LA    XSTR,4(XSTR)    STEP INPUT POINTER TO SKIP 'R' AND 'P'
         SH    XIBCNT,SFOUR    REDUCE STRING COUNT  (LESS 'R' AND 'P')
         EX    XIBCNT,MOVEJM1   MOVE CURRENT STRING INTO OUTPUT BUFFER
         BC    15,RLD015X      SKIP INSERT OF ID'S
         SPACE 1
RLD0152  C     XS1,RLDSIZE     CHK AGAINST MAXIMUM BUFFER SIZE
         BC    12,RLD0153      BC IF EQUAL OR LESS
         TM    RLDFLGS,CONTOV  MORE -- CHK FOR CONTINUATION-OVERFLOW
         BC    8,RLD016        BC IF NO TO PURGE BUFFER
         LA    XIBCNT,1(XIBCNT)   YES -- RECOMPENSATE STRING COUNT
         BC    15,RLD0031      BC TO CONTINUATION PURGE
RLD0153  EX    XIBCNT,MOVEJM1  MOVE CURRENT STRING INTO OUTPUT BUFFER
RLD0154  EX    0,MOVEJM1A      MOVE CURRENT STRING ID'S INTO BUFFER
RLD015X  L     R14,BUFSTCT     L BUFFERRED STRING COUNT
         LA    XIBCNT,1(XIBCNT)  RECOMPENSATE STRING COUNT
         AR    R14,XIBCNT      ADD CURRENT STRING COUNT
         ST    R14,BUFSTCT     SAVE UPDATED BUFFERED STRING COUNT
         LR    R14,XS2         L LOC OF CURRENT OUT BUFFER STRING
         AR    R14,XIBCNT      ADD CURRENT STRING COUNT
         SH    R14,SFOUR       GET LOC OF TERMINAL F/A FIELD
         NI    0(R14),CONTN    CLEAR TERMINAL ITEM CONTINUATION FLAG
         AR    XOBCNT,XIBCNT   UPDATE BUFFER BYTE COUNT
         STH   XOBCNT,OBCNT    SAVE UPDATED COUNT IN MODEL
         TM    RLDFLGS,CONTOV  CHK FOR CONTINUATION OVERFLOW FLAG
         BC    1,RLD0031       BC IF YES TO PURGE BUFFER
         C     XOBCNT,RLDSIZE  CHK BUFFERRED CT WITH MAXIMUM BUFFER
         LA    XRET,RLD0156    L RETURN ADDRESS
*                                   NOTE -- THIS INSTRUCTION DOES NOT
*                                      CHANGE CONDITION CODE
         BC    11,RLDBUF       BC IF NOT LESS TO PURGE BUFFER
RLD0155  MVC   PRER(4),SAVIDS  SAVE CURRENT 'ID'S' AS PREVIOUS 'ID'S'
RLD0156  CH    XBCNT,TTR1      CHK IF END-OF-INPUT
         BC    4,RLD002        NO -- CONTINUE PROCESSING RLD ITEMS
RLDRETX  BC    15,RLDRET       YES -- RETURN TO CALLER
***                                 CLOSE TIMER HOOK
         SPACE 2
RLD016   LA    XIBCNT,1(XIBCNT)   RECOMPENSATE STRING COUNT
RLD0161  BAL   XRET,RLDBUF     PURGE RLD BUFFER
         MVC   PREP(2),SAVIDS+2  INITIALIZE 'P' ID FOR NEW BUFFER
         MVC   RLDMULT(2),STM  SET STRING MULTIPLICITY IN ID MULTIPCTY
         B     RLD014               THEN INSERT STRING
         EJECT
*             FORM RLD NOTE LIST AND INITIATE WRITE OUT
*                  RLD BUFFER/RLD NOTE LIST ROUTINE
         SPACE 1
RLDBUF   L     R14,BUFSTCT     L BUFFERED STRING COUNT
         LTR   R14,R14         CHK IF ANY BYTE COUNT
         BC    7,RLDBUF1       BC IF SOME
         LR    R14,XIBCNT      L CURRENT STRING BYTE COUNT
         LTR   XIBCNT,XIBCNT   CHK IF ANY
         BC    7,RLDBUF1       BC IF SOME
RLDBUFA  TM    NEWSW,EOD       NONE -- CHK FOR END-OF-DATA
         BCR   8,XRET          RETURN IF NOT
         LTR   XOBCNT,XOBCNT   EOD -- CHK FOR ANY BUFFERED CT REMAINING
         BC    7,RLDBUF1A      CONTINUE IF ANY
         TM    NEWSW,TUPAS     NONE -- CHK FOR 2 PASS NOW
         BC    8,RLDBFRTN      RETURN IF NO
         OI    RLDFLGS,FNLCHK                                   OX03655
         BC    15,RLDBUF3B     YES, 2 PASS -- CONTINUE PURGE CHECK
         SPACE 1
RLDBUF1  TM    APT1,EX         CHK IF EXECUTABLE (LOAD) MODULE
         BC    8,RLDBUF1A      BC IF NO
         CLC   TTR1(2),ENRLD2X   LD MODULE -- CHK IF INPUT OVER MAXIMUM
         BC    2,ERR2          BC IF OVER MAXIMUM -- ERROR
         SPACE 1
RLDBUF1A SRL   R14,2           DIVIDE BUFFERRED STRING COUNT BY 4
         STH   R14,WDCNT       SAVE WORD COUNT IN MODEL
         TM    NEWSW,TUPAS     CHK FOR 2 PASS NOW
         BC    1,RLDBUF1C      BC IF YES
         NI    RLDMULT,RNBUF1  SET RLD'S-IN-BUFFER-1 FLAG
         L     R14,RLDOUT1     L LOC OF OUT-BUFFER 1
         TM    BUFFS,BUFFRN2   CHK IF BUFFER 2 IS CURRENT
         BC    8,RLDBUF1B      BC IF NO
         OI    RLDMULT,RNBUF2  YES -- SET RLD'S-IN-BUFFER-2 FLAG
         L     R14,RLDOUT2     L LOC OF OUT-BUFFER 2
RLDBUF1B NI    RLDMULT,GPF     SET GROUP FLAG IN MODEL
         OI    RLDMULT,INCF    SET RLD-IN-CORE FLAG IN MODEL
RLDBUF1C LR    R15,XOBCNT      L CURRENT BUFFERRED BYTE COUNT
         SLL   R15,6           REDUCE TO WORD COUNT IN MODEL POSITION
         ST    R15,RTTR1       SAVE ACCUMULATED WORD COUNT IN MODEL
         SPACE 1
         MVC   SFLIP(1),BUFFS  HOLD CURRENT BUFFER FLAG
         NI    SFLIP,BUFFRN2   EXTRACT CURRENT BUFFER FLAG
         XI    SFLIP,BUFFRN2   FLIP NEXT BUFFER FLAG
         LR    XS1,XIBCNT      L STRING COUNT
         AR    XS1,XOBCNT      ADD BUFFERED BYTE COUNT
         C     XS1,RLDSIZE     CHK AGAINST MAXIMUM BUFFER COUNT
         BC    13,RLDBUF3      BC IF NOT GREATER
RLDBUF2  OI    RLDMULT,TTRF    SET END-OF-BUFFER FLAG IN MODEL
         TM    BUFFS,BUFFRN2   CHK IF BUFFER 2 IS CURRENT
         BC    8,RLDBUF2A      BC IF NO
         OI    BUFFS,BUFF2     YES -- SET BUFFER 2 FULL FLAG
         BC    15,RLDBUF2B
RLDBUF2A OI    BUFFS,BUFF1     SET BUFFER 1 FULL FLAG
RLDBUF2B TM    NEWSW,TUPAS     CHK FOR 2 PASS NOW
         BC    1,RLDBUF4A      BC IF YES
         TM    BUFFS,BUFFRN2   NO -- CHK IF BUFFER 2 IS CURRENT
         BC    1,RLDBUF4       BC IF YES
         STH   XOBCNT,OBCNT    SAVE CURRENT BUFFERRED BYTE COUNT
         MVC   OPREP(14),PREP  SAVE CURRENT MODEL FOR OPENER 1
         OI    BUFFS,OP1BF2    SET OPENER AND BUFFER 2 NOW FLAGS
         SR    XOBCNT,XOBCNT   CLEAR BUFFER 1 COUNT
         SPACE 1
         SPACE 1
RLDBUF3  LH    XRIO,ENR1C      L CURRENT NOTE LIST ENTRY COUNT
         LA    XRIO,1(XRIO)    STEP FOR CHECK
         CH    XRIO,ENR1X      CHK IF NOTE LIST WILL BE FULL
         BC    4,RLDBUF3A      BC IF NO
         TM    NEWSW,TUPAS     CHK FOR TWO PASS MODE
         BC    1,RLDBUF32      BC IF YES
         TM    BUFFS,BUFFRN2   ONE PASS MODE -- CHK FOR BUFFER 2 NOW
         BC    1,RLDBUF32      BC IF YES
RLDBUF31 OI    RLDFLGS,NLFULL  SET NOTE LIST FULL FLAG
RLDBUF32 OI    RLDFLGS,CHKNOW  SET CHECK NOW FLAG
         OI    NEWSW,TUPAS     SET 2 PASS NOW FLAG
         BC    15,RLDBUF2
RLDBUF3A TM    NEWSW,EOD       CHK FOR END-OF-DATA NOW
         BC    8,RLDBUF6C      BC IF NO
RLDBUF3B OI    RLDMULT,TTRF    SET END-OF-BUFFER FLAG IN MODEL
         TM    NEWSW,TUPAS     CHK FOR TWO PASS FLAG
         BC    8,RLDBUF6C      BC IF NO
         SPACE 1
RLDBUF4  OI    NEWSW,TUPAS     SET 2 PASS FLAG
RLDBUF4A TM    BUFFS,OPNR1     CHK FOR BUFFER 1 OPENER FLAG
         BC    8,RLDBUF5       BC IF NO
         STH   XOBCNT,OBCNT    SAVE CURRENT BUFFERRED BYTE COUNT
         MVC   CPREP(14),PREP  SAVE CURRENT MODEL FOR RESUME
         MVC   PREP(14),OPREP  RESTORE OPENER 1 MODEL TO CURRENT MODEL
         LH    XOBCNT,OBCNT    RESTORE OPENER 1 BUFFERRED BYTE COUNT
         NI    BUFFS,BUFFRN1   SET BUFFER 1 CURRENT FLAG
         SPACE 1
RLDBUF5  L     XRIO,RNT1       L NOTE LIST STARTING LOC
         SH    XRIO,SNINE      LESS 9 -- 1 ENTRY LENGTH
         LH    XS1,ENR1C       L NOTE LIST ENTRY COUNT
         LTR   XS1,XS1         CHK IF ANY COUNT
         BC    7,*+8           BC IF SOME
         LA    XS1,1(XS1)      NONE -- SET TO ONE
RLDBUF5A LA    XRIO,9(XRIO)    STEP NOTE LIST ENTRY LOC ONE ENTRY
         NI    2(XRIO),NICF    CLEAR IN-CORE AND BUFFER 2 FLAGS
         BCT   XS1,RLDBUF5A    LOOP TO NEXT ENTRY
         SPACE 1
RLDBUF6  TM    BUFFS,WRIT2     CHK IF ANY BUFFER WRITTEN YET
         BC    8,RLDBUF7C      BC IF NONE
         OI    RLDFLGS,CHKNOW  SET CHECK NOW FLAG
RLDBUF6A STH   XOBCNT,OBCNT    SAVE CURRENT BUFFERRED BYTE COUNT
         MVC   CPREP(14),PREP  SAVE CURRENT MODEL FOR CHECK
         MVC   PREP(14),LPREP  RESTORE RESERVE MODEL TO CHECK
         LH    XOBCNT,OBCNT    RESTORE RESERVED BUFFERRED BYTE COUNT
         SPACE  1
RLDWCHK  L     GR1,SAVETTR     L RESERVED TTR
****             REMOVE ABOVE INSTRUCTION IF OVERLAP IS ADDED
****                           AND REPLACE WITH
****     BAL   XRET2,COMCHK    CHECK AND NOTE
         SPACE  1
         SPACE 1
         NI    RLDMULT,NICF    SET NOT-IN-CORE FLAG IN MODEL
         OI    RLDMULT,TTRF    SET TTR FLAG IN MODEL
         ST    GR1,RTTR1       SET TTR IN MODEL
         SPACE 1
         TM    BUFFS,BUFFRN2   CHK IF BUFFER 2 IS CURRENT
         BC    1,RLDBUF6B      BC IF YES
         OI    BUFFS,BUF2CHK   NO -- SET BUFFER 2 CHECKED FLAG
         NI    BUFFS,NBUF2WF   CLEAR BUFFER 2 FULL AND WRITTEN FLAGS
         BC    15,RLDBUF6C
RLDBUF6B OI    BUFFS,BUF1CHK   SET BUFFER 1 CHECKED FLAG
         NI    BUFFS,NBUF1WF   CLEAR BUFFER 1 FULL-WRITTEN FLAGS
RLDBUF6C LA    XRIO,9          L RLD NOTE LIST ENTRY LENGTH
         MH    XRIO,ENCT       MULTIPLY BY ENTRY COUNT
         A     XRIO,RNT1       ADD NOTE LIST STARTING LOC TO FORM
*                                   CURRENT ENTRY LOC
         MVC   0(9,XRIO),PREP  MOVE MODEL INTO RLD NOTE LIST ENTRY
RLDBUF6D SR    R14,R14         CLEAR REGISTER
RLDBUF6X ST    R14,BUFSTCT     CLEAR BUFFERRED STRING COUNT
         ST    R14,BUFSTLOC    CLEAR BUFFERED STRING LOCATION
         TM    RLDFLGS,CHKNOW  CHK FOR CHECK NOW
         BC    8,RLDBUF7       BC IF NO
         MVC   PREP(14),CPREP  YES -- RESTORE CURRENT MODEL
         LH    XOBCNT,OBCNT    RESTORE CURRENT BUFFERRED BYTE COUNT
         TM    RLDFLGS,FNLCHK          CHECK FOR NO DATA        XA05742
         BO    RLDBUF71                BRANCH IF NO DATA        XA05742
RLDBUF7  LH    XRIO,ENCT       L RLD NOTE LIST ENTRY COUNT
         LA    XRIO,1(XRIO)    UPDATE BY 1
         STH   XRIO,ENR1C      SAVE NEW COUNT IN APT
         CH    XRIO,ENR1X      CHK IF NOTE LIST IS FULL
         BC    10,RLDBUF7A     BC IF NOT LESS
RLDBUF71 NI    RLDFLGS,NCHKNOW   LESS -- CLEAR CHECK NOW FLAGS  XA05742
         BC    15,RLDBUF7C     GO TO WRITE
RLDBUF7A TM    RLDFLGS,NLFULL  NOT LESS -- CHK FOR NOTE LIST FULL FLAG
         BC    1,RLDBUF7B      BC IF YES
         OI    RLDFLGS,NLFULL  NO -- SET NOTE LIST FULL FLAG NOW
         BC    15,RLDBUF7C     GO TO WRITE
RLDBUF7B NI    RLDFLGS,NLFLCHKN  CLEAR NOTE LIST FULL + CHK NOW FLAGS
         SPACE 1
*THE RLD NOTE LIST IS FULL. AN ENTRY IS NOW MADE IN THE RLD I/O CONTROL
*TABE.IT CONTAINS A MAXIMUM OF 3 TTR'S OF THE RLD NOTE LIST. AN OVER-
*FLOW CONDITION WILL OCCUR IF THE NOTE LIST MUST BE PURGED AND THE RLD
*I/O CONTROL TABLE IS FULL.THE WORDS 'NOTE' AND 'MARK' ARE INTER-
*CHANGEABLE. HISTORICALLY BOTH TERMS HAVE BEEN USED.
         SPACE 1
BUFRMK2  TM    RLDFLGS,FULLR   CHK IF I/O CONTROL TABLE FULL
         BC    8,BUFROK        BC IF NOT FULL -- CONTINUE
         TM    APT4,REALOCTE       IS REALLOC POSSIBLE?          S01904
         BNO   BUFRMK2A            YES,TRY REALLOCATION          S01904
         LA    MSG,IEW0374     L ERROR CODE FOR I/O CTL TABLE OVERFLOW
         BC    15,ERROR        GO TO ERROR ROUTINE INTERFACE
BUFRMK2A S     XPSAV,RECNT             CALC RRNT OFFSET         YA05040
         STM   WRKREG0,WRKREGF,BRNCHSV  SAVE REGISTERS   S01904,YA05040
         L     BRANCH,ERDIGA       GET ADDR OF REALLOC RTN       S01904
         BALR  RETURN,BRANCH       GO TO REALLOC RTN             S01904
         LM    WRKREG0,WRKREGF,BRNCHSV  RESTORE REGISTERS        S01904
         A     XPSAV,RECNT             RELOCATE RNT POINTER     YA05040
         B     RLDBUF7C                                          S01904
         SPACE 1
BUFROK   LA    R14,9           L LENGTH OF NOTE LIST ENTRY
         MH    R14,ENR1C       MULTIPLY BY ENTRY CT TO FORM DATA CT
         L     R15,RNT1        L DATA LOC
         SPACE 1
         BAL   XRET2,RLDBUFR   GO TO WRITE OUT NOTE LIST
         SPACE 1
         BAL   XRET2,COMCHK    GO TO CHECK LAST WRITE
         LA    R15,9           PREPARE TO CLEAR BUFFER  OX05132,OY04538
         MH    R15,ENR1C       COMPUTE NOTELIST LENGTH  OX05132,OY04538
         L     XRET2,RNT1      POINT TO NOTELIST START  OX05132,OY04538
         XR    R14,R14         CLEAR FOR DIVIDE         OX05132,OY04538
         D     R14,HEX100      HOW MANY MOVES?          OX05132,OY04538
         LTR   R15,R15         LESS THAN 256 BYTES?     OX05132,OY04538
         BZ    BUFRLEFT        YES, CHECK FOR REMAINDER OX05132,OY04538
BUFRCLR  EQU  *                                         OX05132,OY04538
         XC    0(256,GR5),0(GR5)  CLEAR 256 BYTES       OX05132,OY04538
         A     XRET2,HEX100     BUMP BUFFER POINTER     OX05132,OY04538
         BCT   R15,BUFRCLR      IF MORE TO MOVE, LOOP   OX05132,OY04538
BUFRLEFT EQU   *                                        OX05132,OY04538
         LTR   R14,R14          ANY REMAINDER?          OX05132,OY04538
         BZ    BUFRCLRD         NO, WE ARE DONE         OX05132,OY04538
         BCTR  R14,0            DECREMENT FOR EXECUTE   OX05132,OY04538
         EX    R14,CLEARIT      CLEAR REMAINDER         OX05132,OY04538
BUFRCLRD EQU   *                                        OX05132,OY04538
         SPACE 1
         SPACE
         LA    XS1,IOCT+12     L LOC OF START OF RLD I/O CTL TABLE
         LR    XRMK2,XS1              L SAME IN XRMK2 AND
         SR    XRET2,XRET2         CLEAR REGISTER                S01904
         IC    XRET2,ENIRC         LNGTH IN REALLOC TBLE OX00029,S01904
         SR    WRKREG0,WRKREG0     CLEAR REGISTER                S01904
         IC    WRKREG0,ENIRC+1     LENGTH IN ORIG TABLE  OX00029,S01904
         AR    XRET2,WRKREG0       CURRENT LENGTH OF TABLE       S01904
         AR    XRMK2,XRET2                                       S01904
*THE TTR CONTAINED IN REG 1, IS STORED IN THE CURRENT RLD I/O CONTROL
*TABLE ENTRY
         ST    GR1,0(XRMK2)    SAVE RLD NOTE LIST TTR IN CURRENT RLD
*                                 I/O CONTROL TABLE ENTRY
         LA    XRMK2,4(XRMK2)  STEP TO NEXT ENTRY LOC
         SR    XRMK2,XS1       SUBTRACT LOC OF TABLE START
         TM    APT4,REALOCTE       WAS REALLOC DONE?             S01904
         BNO   BUFRMK2D            NO,USE BOTH BYTES OF ENIRC    S01904
         SR    XRMK2,WRKREG0            GET NEW TBL BYTES       OX00029
         STC   XRMK2,ENIRC         USE FIRST BYTE OF ENIRC       S01904
         B     BUFRMK2E                                          S01904
BUFRMK2D STH   XRMK2,ENIRC     SAVE UPDATED TABLE BYTE COUNT IN APT
BUFRMK2E LA    XRET2,4(XRET2)                                    S01904
*IF THE RLD I/O CONTROL TABLE IS FULL, THE 'FULLR' INDICATOR IS SET
*THIS MEANS THAT NO MORE BUFFERINGS OF THE RLD NOT LIST CAN OCCUR.
         CH    XRET2,XII       CHK IF RLD I/O CTRL TABLE FULL
         BC    4,BUFRMK3       BC IF NO TO CONTINUE
         OI    RLDFLGS,FULLR   YES -- SET OVERFLOW FLAG
BUFRMK3  SR    R0,R0                      RESET TO ZERO
         NI    BUFFS,N2BUFWF   RESET BOTH FULL AND WRITTEN FLAGS
         STH   R0,ENR1C             RLD NOTE LIST ENTRY COUNT
         STH   R0,ENCT         RESET ENTRY COUNT IN MODEL
         OI    RLDFLGS,PURGE       SET PURGE FLAG
         SPACE 2
RLDBUF7C TM    NEWSW,TUPAS     CHK FOR 2 PASS FLAG
         BC    8,RLDBUFBK      NO -- GO TO RETURN
RLDBUF7D LTR   XOBCNT,XOBCNT   CHK FOR ANY BUFFERRED COUNT
         BC    8,RLDBUF8A      BC IF NONE
         TM    RLDMULT,TTRF    CHK FOR END-OF-BUFFER FLAG
         BC    8,RLDBUF8A      BC IF NO
         LR    R14,XOBCNT      L BUFFERED BYTE COUNT IN REG E
         TM    BUFFS,BUFFRN2   CHK IF BUFFER 2 IS CURRENT
         BC    1,RLDBUF7E      BC IF YES
         L     R15,RLDOUT1     NO -- L LOC OF BUFFER 1
         SPACE 1
         BAL   XRET2,RLDBUFR   GO TO WRITE OUT BUFFER 1
         BAL   XRET2,COMCHK            CHECK AND NOTE
****             REMOVE ABOVE INSTRUCTION IF OVERLAP IS ADDED
         ST    GR1,SAVETTR             SAVE TTR
****             REMOVE ABOVE INSTRUCTION IF OVERLAP IS ADDED
         SPACE 1
         OI    BUFFS,BUFW1     SET BUFFER 1 WRITTEN FLAG
         NI    BUFFS,NBUF1CHK  CLEAR BUFFER 1 CHECKED FLAG
         BC    15,RLDBUF7F
RLDBUF7E L     R15,RLDOUT2     L LOC OF BUFFER 2
         SPACE 1
         BAL   XRET2,RLDBUFR   GO TO WRITE OUT BUFFER 2
         BAL   XRET2,COMCHK            CHECK AND NOTE
****             REMOVE ABOVE INSTRUCTION IF OVERLAP IS ADDED
         ST    GR1,SAVETTR             SAVE TTR
****             REMOVE ABOVE INSTRUCTION IF OVERLAP IS ADDED
         SPACE 1
         OI    BUFFS,BUFW2     SET BUFFER 2 WRITTEN FLAG
         NI    BUFFS,NBUF2CHK  CLEAR BUFFER 2 CHECKED
RLDBUF7F STH   XOBCNT,OBCNT    SAVE CURRENT BUFFERRED BYTE COUNT
         MVC   LPREP(14),PREP  SAVE WRITTEN MODEL FOR CHECK
         SR    XOBCNT,XOBCNT   CLEAR BUFFERRED BYTE COUNT
         TM    BUFFS,OPNR1     CHK FOR BUFFER 1 OPENER FLAG
         BC    8,RLDBUF8       BC IF NO
         MVC   PREP(14),CPREP  RESTORE CURRENT MODEL
         LH    XOBCNT,OBCNT    RESTORE CURRENT BUFFERRED BYTE COUNT
         OI    BUFFS,BUFFRN2   SET BUFFER 2 CURRENT FLAG
         NI    BUFFS,NOPNR1    CLEAR BUFFER 1 OPENER FLAG
RLDBUF8  TM    BUFFS,FULL2     CHK FOR 2 BUFFERS FULL
         BC    1,RLDBUF6       LOOP TO CHECK, THEN WRITE
         TM    RLDFLGS,PURGE   CHK FOR PURGE FLAG
         BC    8,RLDBUF8A      BC IF NONE
         NI    RLDFLGS,NPURGE  YES -- CLEAR PURGE FLAG
         BC    15,RLDBUF6D     GO TO STEP NOTE LIST ENTRY COUNT
RLDBUF8A TM    RLDFLGS,CHKNOW  CHK FOR CHECK NOW FLAG
         BC    1,RLDBUF6A      BC IF YES TO CHECK
         TM    RLDFLGS,FNLCHK  CHK IF FINAL CHECK FLAG
         BC    1,RLDBUF8B      BC IF YES
         TM    NEWSW,EOD       CHK FOR END-OF-DATA NOW
         BC    8,RLDBUF8C      BC IF NO
         OI    RLDFLGS,FNLCHK  SET FINAL CHECK FLAG
         BC    15,RLDBUF3B     LOOP TO FINAL CHECK
RLDBUF8B NI    RLDFLGS,NFNLCHK    CLEAR FINAL CHECK FLAG
RLDBUF8C TM    RLDMULT,TTRF    CHK FOR END-OF-BUFFER FLAG
         BC    8,RLDBUFBK      BC IF NO
         NI    BUFFS,BUFFRN1   CLEAR BUFFER 2 CURRENT FLAG
         OC    BUFFS(1),SFLIP  SET FLAG FOR NEXT BUFFER
RLDBUFBK SR    XRIO,XRIO       CLEAR REGISTER
         BCTR  XRIO,0          INVERT
         STH   XRIO,PRER       RESET PREVIOUS 'R' ID
         STH   XRIO,PREP       RESET PREVIOUS 'P' ID
RLDBFBK1 LH    XRIO,ENR1C         L UPDATED NOTE LIST ENTRY COUNT
         STH   XRIO,ENCT                  AND SET IN MODEL
         MVI   RLDMULT,STMULT  RESET RLD ITEM MULTIPLICITY
         SPACE 1
*       CHECK FOR END-OF-OUTPUT-MODULE FLAG.  INITIALIZE PROCESS
*                 FLAGS IF FOUND AND RETURN TO CALLER.
         SPACE 1
RLDBFRTN TM    NEWSW,EOD       CHK FOR END-OF-OUTPUT-MODULE FLAG
         BCR   8,XRET          RETURN IF NO
         MVI   PRER,X'FF'      YES -- INITIALIZE PREVIOUS 'R' ID
         MVC   PRER+1(3),PRER  INITIALIZE PREVIOUS 'P' ID
         MVI   WDCNT,X'00'            INITIALIZE
         MVC   WDCNT+1(21),WDCNT    CONTROL AREAS
           MVC   CALLCURP(2),CONZO
         BCR   15,XRET         RETURN
         SPACE 2
     TITLE 'HEWLFRAT   RLD/TXT PROCESSOR  --  RLD CONSTANTS'
DCBAD    DC    A(HEWLCUDB)
ADDEL    DC    V(HEWLCDLK)
*                                    PROCESSED CSECTS IN BUFFER
DELR     DC    X'0000'          DELINKED R POINTER SAVE AREA
CONZO    DC    H'0'
******** ERROR MSG ****************************************************
IEW0284  DC    X'241C'  FAILURE TO OPEN DCB CODE
IEW0222  DC    X'1216'
IEW0614  DC    X'243D'      NO LENGTH SPACIFIED IN CESD
***********************************************************************
XII      DC    H'12'
CLEARIT  XC    0(0,XRET2),0(XRET2)     FOR RLD NOTELIST CLR     OX05132
HEX100   DC    F'256'                  FOR RLD NOTELIST CLR     OX05132
         SPACE 2
*                    RLD NOTE LIST ENTRY MODEL
         SPACE 1
         CNOP  0,4       ALIGN TO START PREP ON HALF WORD
PRER     DC    X'FFFF'   PREVIOUS 'R' ID
PREP     DC    X'FFFF'   PREVIOUS 'P' ID
RLDMULT  DC    X'0200'   FLAG-MULTIPLICITY FIELD
*                          BIT 0 -- 0 -- RLD NOT IN CORE
*                                   1 -- RLD IN CORE
*                          BIT 1 -- 0 -- GROUPED ENTRY
*                                   1 -- TTR ENTRY
*                          BIT 2 -- RESERVED
*                          BIT 3 -- 0 -- IN BUFFER 1
*                                   1 -- IN BUFFER 2
*                          BIT 4 -- RESERVED
*                          BIT 5 -- RESERVED
*                          BITS 6-15 -- MULTIPLICITY ID
WDCNT    DC    X'0000'   RLD WORD COUNT
RTTR1    DC    X'00000000'   TTR/ACCUMULATED WORD COUNT FIELD
OBCNT    DC    X'0000'   RLD BYTE COUNT
ENCT     DC    X'0000'   RLD NOTE LIST ENTRY COUNT
         DC    X'0000'   RESERVED
RLDFLGS  DC    X'0'      RLD PROCESSING FLAGS
*                          BIT 0 -- 1 -- CONTINUED STRING OVERFLOWS
*                                          BUFFER
*                          BIT 1 -- 1 -- NEW GROUPED STRING OVERFLOWS
*                                          BUFFER
*                          BIT 2 -- 0 -- I/O CONTROL TABLE NOT FULL
*                                   1 -- I/O CONTROL TABLE FULL
*                          BIT 3 -- 0 -- NOTE LIST NOT FULL
*                                   1 -- NOTE LIST FULL
*                          BIT 4 -- 0 -- NO NOTE LIST PURGE NOW
*                                   1 -- NOTE LIST PURGED NOW
*                          BIT 5 -- 0 -- NO CHECK LAST WRITE NOW
*                                   1 -- CHECK LAST WRITE NOW
*                          BIT 6 -- 0 -- NOT FINAL CHECK
*                                   1 -- FINAL CHECK AT EOD
         EJECT
BUFFS    DC    X'0'      RLD BUFFER CONTROL FLAGS
*                          BIT 0 -- 1 -- BUFFER 1 OPENER
*                          BIT 1 -- 1 -- BUFFER 2 CHECKED
*                          BIT 2 -- 1 -- BUFFER 1 CHECKED
*                          BIT 3 -- 1 -- BUFFER 2 WRITTEN
*                          BIT 4 -- 1 -- BUFFER 1 WRITTEN
*                          BIT 5 -- 1 -- BUFFER 2 FULL
*                          BIT 6 -- 1 -- BUFFER 1 FULL
*                          BIT 7 -- 0 -- BUFFER 1 CURRENT
*                                   1 -- BUFFER 2 CURRENT
         SPACE 1
         SPACE 1
BUFSTCT  DC    F'0'      BUFFERRED STRING COUNT
BUFSTLOC DC    F'0'      BUFFERRED STRING STARTING LOCATION
         SPACE 2
*          MODEL TO HOLD WRITE TIME ENVIRONMENT FOR CHECK USE
         SPACE 1
         CNOP  2,4       ALIGN TO START LPREP ON HALF WORD
LPREP    DC    X'0000'   CESD ID FIELD
LRLDMULT DC    X'0200'   FLAG-ADDRESS FIELD
LWDCNT   DC    X'0000'   RLD WORD COUNT
LRTTR1   DC    X'00000000'     TTR/STORAGE ADDRESS FIELD
LOBCNT   DC    X'0000'   RLD BYTE COUNT
LENCT    DC    X'0000'   RLD NOTE LIST ENTRY COUNT
         DC    X'0000'   RESERVED
         SPACE 2
*            MODEL TO HOLD INITIAL BUFFER LOAD ENVIRONMENT
         SPACE 1
         CNOP  2,4       ALIGN TO START OPREP ON HALF WORD
OPREP    DC    X'0000'   CESD ID FIELD
ORLDMULT DC    X'0200'   FLAG-ADDRESS FIELD
OWDCNT   DC    X'0000'   RLD WORD COUNT
ORTTR1   DC    X'00000000'     TTR/STORAGE ADDRESS FIELD
OOBCNT   DC    X'0000'   RLD BYTE COUNT
OENCT    DC    X'0000'   RLD NOTE LIST ENTRY COUNT
         DC    X'0000'   RESERVED
         SPACE 2
*      MODEL TO HOLD CURRENT ENVIRONMENT WHILE PREVIOUS ONE IS USED
         SPACE 1
         CNOP  2,4       ALIGN TO START CPREP ON HALF WORD
CPREP    DC    X'0000'   CESD ID FIELD
CRLDMULT DC    X'0200'   FLAG-ADDRESS FIELD
CWDCNT   DC    X'0000'   RLD WORD COUNT
CRTTR1   DC    X'00000000'     TTR/STORAGE ADDRESS FIELD
COBCNT   DC    X'0000'   RLD BYTE COUNT
CENCT    DC    X'0000'   RLD NOTE LIST ENTRY COUNT
         DC    X'0000'   RESERVED
         SPACE 2
TEMP     DS    X                                                XA04649
TXT001AD DC    A(HEWLFTXT)     LOC OF TEXT PROCESSING ROUTINE
TXTBUFAD DC    A(TXTBUF) LOC OF TEXT PURGE ROUTINE
RATADR   DC    A(RATLOC) RLD STANDARD BASE REGISTER VALUE
FOUR     DC    F'4'                    OFFSET FOR RNT TABLE      A53300
TTR1     DC    F'0'      STORAGE FOR TTR OR INPUT COUNT
INADD1   DC    F'0'      RETURN TO INPUT PROCESSOR
SBACKUP  DC    F'0'      SAVE AREA FOR REPLACEMENT STRING POINTER
SAVIDS   DC    F'0'      SAVE AREA FOR REPLACEMENT ID'S
SAVETTR  DC    F'0'      SAVE AREA FOR TTR
STRUNC   DC    X'000003FF'     MULTIPLICITY SIZE LIMITOR
RIDMSK   DC    X'00007FFF'     MASK FOR 'R' ID
         SPACE 1
SAVIDR   DC    H'0'      RESERVE AREA FOR RLD ITEM 'R' ID
CALLCURP DC    H'0'
POSMULT  DC    H'0'      RESERVE AREA FOR POSSIBLE LOWEST MULTIPLICITY
STM      DC    X'0200'   RESERVE AREA FOR STRING MULTIPLICITY
SONE     DC    H'1'      DECIMAL 1
SFOUR    DC    H'4'      DECIMAL 4
SSEVEN   DC    H'7'      DECIMAL 7
SNINE    DC    H'9'      DECIMAL 9
         SPACE 1
NFLG     DC    X'0'      TEMPORARY RESERVE AREA FOR FLAGS
FLAG     DC    X'0'
         SPACE 1
SFLIP    DC    X'00'     TEMPORARY STORAGE FOR BUFFER FLAGS
         DS    0H
FIVEFIVE DC    H'5'
DLKTSAVE DC    H'0'
         SPACE 2
PATCH1   DC    35D'0'
     TITLE 'HEWLFRAT   RLD/TXT PROCESSOR  --  TEXT PROCESSING'
HEWLFTXT CSECT
         SPACE 3
*
*                     T E X T    P R O C E S S O R
*
         SPACE 2
*      THIS ROUTINE PROCESSES ALL TXT INPUT FOR EVERY LINKEDIT. THE ID
*  IS RENUMBERED VIA THE RENUMBERING TABLE AND THE MULTIPLICITY IS
*  DETERMINED AS A FUNCTION OF A SYSLMOD RECORD.   AFTER SPACE HAS BEEN
*  ALLOCATED IN THE TXTBUFFER AND AN ENTRY MADE IN THE TXTIO TABLE AND
*  TEXT NOTELIST(FIRST APPEARANCE ONLY),THE TEXT IS MOVED(OBJ) OR READ
*  DIRECTLY(LM) INTO THE TXTBUFFER.
         SPACE 2
*
*              GENERAL  REGISTER UTILIZATION
*
RID1     EQU   1         GENERAL WORK REGISTER IN INITIAL LOAD MODULE
*                             PROCESSING
COUNT    EQU   4         WILL MAINTAIN INPUT COUNT AS PASSED BY LMINP
RID      EQU   5         WILL MAINTAIN RENUMBERED ID
REG6     EQU   6         WORK REGISTER FOR LM PROCESSING & TXTBUF
RIP      EQU   6         LOCATION OF OBJECT MODULE TEXT PRIOR TO MOVE
*                        INTO PROPER LOCATION IN THE TEXT BUFFER
TXTBASE  EQU   7         BASE REGISTER FOR TEXT PROCESSOR -
*                        REG 12 IS BASE FOR RLD PROCESSOR
XSTX     EQU   7         LINK REGISTER WHEN RETURNING TO MINP FOR LM
DCBADD   EQU   8         READ. REG 8 HAS DCB ADDRESS
GR8      EQU   8         GENERAL WORK REG
XTMK2    EQU   8         WORK REG WHEN TEXT NOTE LIST WRITTEN
READCNT  EQU   9         REGISTER TO PASS LENGTH TO MINP FOR LM READ
RLK      EQU   9         GENERAL
BUFFADDR EQU   10        LOCATION FOR LM READ PASSED TO MINP
XP1      EQU   10        GENERAL
XP2      EQU   11        GENERAL
* REG12 - RLD PROCESSOR BASE - REQUIRED WHEN RETURNING FOR ANY COMMON
*     AREA (WRITE ROUTINE,ERROR HANDLING,AND NORMAL RETURN )
         EJECT
         SPACE
*
*                   MASKS AND FLAGS FOR HEWLFTXT
*
         SPACE
FLAGOUT  EQU   X'03'            MASK TO ZERO FLAG FIELD IN TXTIO
READSW   EQU   X'04'      INDICATOR WHEN A READ IS TO BE ISSUED
READOFF  EQU   X'FB'        TURN OFF THE READ SW
DENSE1   EQU   X'40'        FOR INTERNAL INDICATOR
DENSE    EQU   X'20'
TTRDEN   EQU   X'60'              MASK FOR TTR AND DENSE RECORD
INCORE   EQU   X'80'              MASK FOR TXTIO FLAG
NOLEN    EQU   X'80'
EOF      EQU   X'01'     END OF INPUT SWITCH
FULLT    EQU   X'40'
SHORTRD  EQU   X'20'            MASK FOR SHORT READ FOR LM
*                     ALL ITEMS IN CONTROL RECORD TO BE DELETED
SHORTRD1 EQU   X'DF'         MASK TO RESET SHORT READ SWITCH
NOLEN1   EQU   X'10'
NOLEN2   EQU   X'08'       NOLENGTH INDICATOR FOR NAME CARD
NOLEN3   EQU   X'18'          MASK FOR NOLENGTH IN GENERAL
NOGRPPG  EQU  X'10'           FLAG SIGNIFING A NONGROUPED PURGE REQ
SPTXTON  EQU   X'80'                    FLAG FOR SPEC LM TEXT   OY00356
SPTXTOFF EQU   X'7F'                    RESET SPEC LM TEXT FLAG OY00356
         SPACE 2
*    *    *    *    *    *    *    *    *    *    *    *    *    *    *
         EJECT
         B     TXTINT         BRANCH AROUND IDENTIFIER
MODID2   DC    C' START TXT CSECT  '
         DC    0H'0'
* INITIALIZE     -  WILL SAVE MUCH REPETITION LATER
*       TXTFREE - ADDRESS OF NEXT FREE ENTRY IN TXTIO TABLE
*       TNTFREE - ADDRESS OF NEXT FREE ENTRY IN TXT NOTE LIST
TXTINT   LH    GR1,ENTOC             PICK UP TXTIO OFFSET       ZA01405
         ST    GR1,TXTFREE           PRESERVE TXTIO OFFSET      ZA01405
         A     GR1,TXTIO             COMPUTE TXTIO POINTER      ZA01405
         LA    R0,7                  CALC 7 BYTES PER TNT ENTRY
         MH    R0,ENT1C              TIMES CURRENT NO. OF ENTRIES
         ST    R0,TNTFREE            PRESERVE TNT OFFSET        ZA01405
         A     R0,TNT1               COMPUTE TNT POINTER
* WE KNOW THE CURRENT ID AND MULTIPLICITY
         TM    APTSW3,XPDIND           EXPAND REQUEST?           Y01031
         BO    TXT002A                 IF SO, BRANCH             Y01031
         CLC   PID(2),CURID   CHECK IF ID IA A REPEAT
         BC    7,TXT002          NO - BRANCH
         CLC   PMULN(2),CMULN   HAS THE MULT CHANGED
         BC    7,TXT002X     YES - BRANCH                       OY00356
         TM    APT1,EX    IS THIS A LOAD MODULE
         BC    1,TXTLM3       YES BRANCH  ID ID THE SAME
         TM    SWITCH,DENSE1  WAS LAST THING WE WE DEALING WITH A DENSE
         BC    1,TXTDEN         RECORD
         L     GR1,LASTTNT      OBTAIN LAST NOTELIST ADDR
         A     GR1,TNT1                RELOCATE TNL POINTER     XA05743
         B     TXTINSRT
* SECOND PHASE
* THE ID  AND OR MULT HAVE CHANGED -
*
*
TXT002   TM    SWITCH,NOLEN   WAS PREVIOUS ENTRY A NO LENGTH
         BC    14,TXT002A
*
TXTN1    MVC   HOLD1(4),CURID      PRESERVE CURRENT ID
         MVC   CURID(2),PID        RESTORE OLD ID
         TM    SWITCH,DENSE1        IS THERE DENSE ENTRY TO CLEAR UP
         BC    14,TXTN5         NO - BRANCH
         L     XS1,TNTFREE             PICK UP TNT OFFSET
         A     XS1,TNT1                COMPUTE TNT POINTER      ZA01405
         SH    XS1,TSEVEN              SET UP PARAMETER FOR DENSE PURGE
         BAL   XP2,TXTNIO         GO TO DENSE PURGE
TXTN5    NI    SWITCH,X'3F'      CLEAR DENSE AND NOLEN BITS
         OI    SWITCH,NOLEN2
         B     BUFFALL    FIND NUMBER OF MULT AND LENGTH OF
*                                   LAST ONE
TXT002X  EQU   *                                                OY00356
         OI    SWITCH+1,SPTXTON         INDICATE CHANGED MULT   OY00356
TXT002A  TM    SWITCH,DENSE1   WAS PREVIOUS ENTRY DENSE
         BC    14,TXT002B         BRANCH LAST NOT DENSE
         NI    SWITCH,X'BF'   TUNN OF INDICATOR
         L     XS1,TNTFREE             PICK UP TNT OFFSET
         A     XS1,TNT1                COMPUTE TNT POINTER      ZA01405
         SH    XS1,TSEVEN   SET UP NOTELIST ADDR
         BAL   XP2,TXTNIO         WRITE OUT LAST PIECE
TXT002B  MVC   PID(4),CURID    UPDATE PAST ID TO AGREE WITH CURRENT
         TM    APT1,EX      IS THIS A LOAD MOD
         BC    8,TXT003      NO - BRANCH
         TM    SWITCH,READSW     HAS THE READ BEEN ISSUED
         BC    8,TXT002BB       YES  BRANCH
         L     R0,TXTBFBEG     ADD THE TXTBUF ADDR TO THE
         A     R0,BUFDISP       DISPLAC IN THE BUFF TO FIND
         AR    R0,COUNT                IF THE NEXT READ WILL FIT
         AH    R0,CDISP                ADD WHAT'S BEEN ALLOCATED A38306
         C     R0,TXTBFEND
         BC    12,TXT002BB       BR IF IT WILL FIR
         BAL   RLK,TXTBUF
         SR    RLK,RLK     RESET DISPLACE IN TXTBUF TO
         ST    RLK,BUFDISP      XERO
TXT002BB TM    APTSW3,XPDIND           EXPAND REQUEST?           Y01031
         BO    TXT003                  IF SO, BRANCH             Y01031
         TM    APT1,EX                                           Y01031
         BC    1,BUFALLOC
*
*  NOW CAN SEARCH TXTIO TO SEE IF THIS ID AND MULT HAVE EVER APPEARED
*     BEFORE
*
TXT003   SR    GR8,GR8        GR8 WILL CONTAIN NOTE LIST DISPLACEMENT
         L     XS2,TXTIO               PICK UP TXTIO ADDR       ZA01405
         LR    XS1,XS2                 COPY FOR POINTER CALC    ZA01405
         A     XS1,TXTFREE             COMPUTE TXTIO POINTER    ZA01405
         CR    XS1,XS2        ANYTHING IN THE TABLE
         BC    8,TXTNEW
TXT003A  CLC   CURID(2),0(XS2) COMPARE ID FIELD FIRST
         BC    8,TXT003B       BRANCH ON A MATCH
TXT003C  LA    XS2,4(XS2)
         LA    GR8,7(GR8)
         CR    XS2,XS1
         BC    4,TXT003A
*  HAVE NEW ID  - TEST IF LENGTH PRESENT IN CESD
TXTNEW   TM    SWITCH,NOLEN3
         BC    7,TXTNL6B        ENTRY NO FOUND  RETURN
         LH    XS1,CURID
         SLL   XS1,4
         A     XS1,CHESD
         CLC   13(3,XS1),CONZO1    CESD LENGTH EQU ZERO
         BC    7,TXT003D      BRANCH IF LENGTH SPECIFIED
         OI    SWITCH,NOLEN
TXT003D  B     BUFALLOC
*
*ID MATCHED-MUST CHECK MULT -  FIRST 10 BITS OF TXTIO ENTRY
TXT003B  LH    GR5,2(XS2)
         N     GR5,MULTONLY     ZERO OUT THE TOP 22 BITS
         CH    GR5,CMULN
         BC    8,TXTOLD       CONTINUE PROCESS ON A MATCH
         SH    XS1,SFOUR    POSITION TO LAST ENTRY IN TXTIO
         CLC   0(2,XS1),CURID  HAS THE ID CHANGED WE ARE PROCESSING
         BC    7,ABAFIX             YES-  MUST SET NONGRP PURGE NEC
TXT003B1 LA    XS1,4(XS1)     RESTORE THE ADDR OF FREE TXTIO ADDR
         B     TXT003C        OR CONTINUE SEARCH
*
ABAFIX   OI    SWITCH+1,NOGRPPG   SIGNIFY A NONGROUPED PURGE NEC
         B     TXT003B1          GO BACJ TO RESTORE TXTIO FREE ADDR
TXTOLD   TM    APTSW3,XPDIND           EXPAND REQUEST?           Y01031
         BNO   TXTOLDX                 IF NOT, BRANCH            Y01031
         OI    SWITCH+1,NOGRPPG        SIGNIFY NON-GROUPED       Y01031
*                                      PURGE NECESSARY           Y01031
         AH    COUNT,CDISP             ADD TEXT LENGTH TO        Y01031
*                                      DISPLACEMENT IN MULT.     Y01031
         C     COUNT,MULTSIZE          DOES IT FILL THE MULT.?   Y01031
         BH    TXTOLDXX                IF SO, BRANCH     Y01031,XA05128
         OI    2(XS2),X'08'            INDICATE UNTRUE LENGTH    Y01031
*                                      IN PREVIOUS ENTRY         Y01031
TXTOLDXX SH    COUNT,CDISP             RESET TEXT LENGTH         Y01031
TXTOLDX  TM    SWITCH,NOLEN3                                     Y01031
         BC    7,TXTNL3
         TM    2(XS2),INCORE       CHECK IF ALREADY WRITTEN
*  XP1- SIZE LAST MULT   XS2-TXTIO ADDR   GR8-TNT1 DISP
         BC    8,TXTOLD1      BRANCH IF NOT
         XR    RLK,RLK             CLEAR REGISTER                S01904
         XR    GR1,GR1             CLEAR REGISTER                S01904
         IC    GR1,ENITC+1         BYTES IN REALOC TXTIO CNTRL   S01904
         IC    RLK,ENITC           BYTES IN OLD TXTIO CNTRL      S01904
         AR    GR1,RLK             TOTAL BYTES IN CURRENT TBL    S01904
         LTR   GR1,GR1           TBL IN USE?
         BC    8,TXTOLDA         IF NOT  BRANCH
         LA    GR1,7
         MH    GR1,TXTNOTE
         SR    GR8,GR1          SUB ACTUAL BYTES WRITTEN
TXTOLDA  L     GR1,TNT1
         AR    GR1,GR8
         TM    APTSW3,XPDIND           EXPAND REQUEST?           Y01031
         BNO   TXTINSRT             IF NOT, BRANCH
TXTOLD1  L     GR8,BUFDISP     BEFORE SIGNALLING DENSE INFO
         A     GR8,MULTSIZE         CHECK THAT MULT SIZE CAN BE ALLOC
         A     GR8,TXTBFBEG          IF NOT  IT WILL ENTER PURGE
         C     GR8,TXTBFEND       EXPECTING LAST ITEM TO BE DENSE
         BC    12,TXTOLD2
         BAL   RLK,TXTBUF2          PURGE BEFORE SETTING SENSE
         SR    RLK,RLK            RESET PARA AFTER PURGE
         ST    RLK,BUFDISP
TXTOLD2  OI    SWITCH,DENSE1
         B     BUFALLOC
*
*BUFALLOC  THIS ROUTINE WILL ALLOCATE REQUIRED SIZE IN BUFFER
*        PIECE     1 MULT
*        CSECT     1 MULT EXECPT FOR LAST
*                       LAST MULT ACTUAL SIZE
*
BUFALLOC TM    SWITCH,DENSE1  DEALING WITH OUT OF ORDER TEXT
         BC    8,BUFFALL               NO,BRANCH
         TM    APT1,EX                 IS IT LOAD MODULE
         BC    8,BUF1                  NO,BRANCH
         L     XS2,MULTSIZE            YES,PICK UP OUTPUT RECSIZE
         SH    XS2,CDISP               MULTSIZE-CDISP=TRUE SIZE
         TM    APTSW3,XPDIND           EXPAND TXT IN PROCESS    XA05128
         BNO   BUFOUT                  BRANCH IF NOT            XA05128
         CR    XS2,COUNT               LT REMAINDER OF MULT     XA05128
         BNH   BUFOUT                  BRANCH IF NOT            XA05128
         LR    XS2,COUNT               ALLOC ONLY EXPAND LENGTH XA05128
         B     BUFOUT                  GO TO ALLOCATE THAT MUCH
BUFFALL  TM    SWITCH,NOLEN   NOLENGTH WILL ALSO GET FULL MULT ALLOC
         BC    1,BUF1         UNTIL REAL SIZE KNOWN
         LH    XS1,CURID      MUST CHECK SIZE IN CESD
         SLL   XS1,4
         A     XS1,CHESD
         CLC   13(3,XS1),CONZO1     IS CESD LENGTH ZERO
         BC    7,BUFFALL1
         LH    R0,IEW0614      LOAD ERROR PARA
         LR    GR1,XS1
         B     ERROR
BUFFALL1 CLC   13(3,XS1),MULTSIZE+1  IF THE CESD SIZE EXCEEDS MULT
         BC    2,BUF2              BRANCH
         LH    XS2,14(XS1)         SIZE = CESD SIZE
         SR    XP2,XP2     SET HIGHEST MULT TO ZER/
         B     BUFOUT11
BUF2     L     XP2,12(XS1)    PICK UP ACTUAL CESD LENGTH
         LA    XP2,0(XP2)    CLEAR HIGH ORDER BYTE
         SR    XP1,XP1
         D     XP1,MULTSIZE
         LTR   XP1,XP1            IF THE REMAINDER IS ZERO IT IS
         BC    7,BUF1A            NECESSARY TO DECREMENT THE MULT ONE
         BCTR  XP2,0
         L     XP1,MULTSIZE       INSERT FULL SIZE
BUF1A    TM    SWITCH,NOLEN3
         BC    7,BUF1A1
         CH    XP2,CMULN           IS THIS THE LAST MULT
         BC    7,BUF1               FULL MULT
BUF1A1   LR    XS2,XP1          GET CORRECT LENGTH FOR NO LEN
BUFOUT11 LA    XS2,7(XS2)              MUST ALLOC THE LAST MULT ON
         N     XS2,DBLWRD                 A DOUBLEWORD BOUNDARY
         TM    SWITCH,NOLEN3
         BC    8,BUFOUT
         LR    XP1,XS2          SAVE LENGTH FOR NO LENGTH
         B     TXTNL2
BUF1     L     XS2,MULTSIZE
BUFOUT   LR    R0,R15
         L     GR1,BUFDISP
         A     GR1,TXTBFBEG
         ST    GR1,BUFSTART
         A     R0,BUFDISP
         ST    R0,BUFDISP
         A     R0,TXTBFBEG        HAVE WE EXCEEDED BUFFER LIMITS
         C     R0,TXTBFEND
         BC    12,BUFCLR     ******REMOVE WHENBUFCLR NO LONGER
*         NECESSARY    REPLACE WITH    BC   10,BUFENT
         ST    XS2,BUFDISP
         ST    XS2,SPACES
         BAL   RLK,TXTBUF          YES - PURGE
         TM    APT1,EX     IS THIS A LOAD MOD
         BC    14,BUFOUT1
         L     XP1,LMLEN     SET LENGTH PARA FOR MOVE
         L     GR8,TXTBFBEG        SET UP TO ADDR
         L     GR9,BUFSTART    SET UP FROM AD
         BAL   XP2,LMMOVE
BUFOUT1  L     GR1,TXTBFBEG    RESER POINTERS
         L     XS2,SPACES
         ST    GR1,BUFSTART
         B     BUFCLR       ********REMOVE WHEN BUFCLR NO LONGER
*         NECESSARY    REPLACE WITH    B   BUFENT
*
TXTNL2   STH   XP2,CMULN           KNOW IDENTIFICATION OF LAST MULT
         B     TXT003              GO SEARCH TXTIO FOR ENTRY TO CORRECT
*                                   LENGTH
*
*           THIS IS A SUBROUTINE TO CLEAR THE ALLOCATED
*           PORTION OF THE BUFFER -   THIS IS NECESSARY IN ORDER TO
*             SYSGEN THE NUCLEUS AND SHOULD BE REMOVED WHEN
*            FETCH NO LONGER REQUIRES ZEROS IN BUFFER
*
BUFCLR   TM    APTSW3,XPDIND           EXPAND REQUEST?           Y01031
         BO    BUFCLR4                 IF SO, BRANCH             Y01031
         TM    PDSE7,X'04'        IF SCATTER NOT SPECIFIED -     Y01031
         BC    8,BUFENT           WILL AVOID CLEARING BUFFER
         TM    APT1,EX            MUST ALSO AVOID IF LOAD MOD INPUT
         BC    8,BUFCLR4       IF IS LM   WILL AVOID CLEARING IF
         TM    SWITCH,READSW        THE READ HAS BEEN ISSUED
         BC    8,BUFENT         SINCE IT IS IMPOSSIBLE TO TELL
BUFCLR4  LR    XP2,XS2      WHAT THE GROUPING WAS
         LA    XP1,256
         L     GR1,BUFSTART       GR1 - STARTING ADDR OF AREA
BUFCLR1  CR    XP1,XP2            LENGTH GT 256
         BC    10,BUFCLR2         NO - BRANCH
         XC    0(256,GR1),0(GR1)
         SR    XP2,XP1            DECREMENT COUNT
         AR    GR1,XP1            INCREMENT ADDR
         B     BUFCLR1
BUFCLR2  BCTR  XP2,0
         EX    XP2,BUFCLR3
         B     BUFENT
*
BUFCLR3  XC    0(1,GR1),0(GR1)
*
*
* BUFENT MAKES ALL NECESSARY ENTRIES IN TXTIO TABLE AND TXT NOTE LIST
*        R15 CONTAINS ALLOCATED SIZE
*        BUFSTART CONTAINS BUFF STARTING ADDR FOR AREA
BUFENT  SR     XP2,XP2
         TM    SWITCH,DENSE1
         BC    1,BUFENT1      AVOID THE DIVIDE BUT CHECK FOR FULL TABLE
         C     XS2,UT1SIZE    WAS LARGER THAN UT1 ALLOC
         BC    12,BUFENT1     NO - BRANCH
         LR    XP2,XS2
         SR    XP1,XP1
         D     XP1,UT1SIZE
         ST    XP1,DISPLAC    DISPLAC IN LAST SECTION
         LTR   XP1,XP1        WILL THE DIVIDE COME OUT EVEN
         BC    8,BUFENT1A
BUFENT1  LA    XP2,1(XP2)     XP2 HAS NUMBER OF ENTRIES REQUIRED
BUFENT1A LR    GR9,XP2
         SLL   GR9,2        MUST INSURE THAT THE TXTIO
         AH    GR9,ENTOC       HAS NOT BEEN OVERFLOWED
BUFENT3A CH    GR9,ENTOX         IF IT HAS  IT IS A
         BC    12,BUFENT1B       UNRECOVERABLE ERROR
         TM    APT4,REALOCTE       HAS REALLOC BEEN DONE?        S01904
         BNO   BUFENT2A            NO,TRY REALLOCATION           S01904
QUIT     LA    MSG,IEW0364     TXTIO OVFLOW - TERMINATE JOB    @ZA07602
         B     ERROR
BUFENT2A STM   WRKREG0,WRKREGF,BRNCHSV  SAVE REGISTERS           S01904
         L     BRANCH,ERDIGA       GET ADDR OF REALLOC RTN       S01904
         BALR  RETURN,BRANCH       GO TO REALLOC RTN             S01904
         LM    WRKREG0,WRKREGF,BRNCHSV  RESTORE REGISTERS        S01904
         B     BUFENT3A            CHECK FOR OVERFLOW AGAIN      S01904
BUFENT1B ST    XS2,HOLD3               MUST PRESERVE ALLOC LEN  XA05445
         ST    XS2,HOLD                LENGTH IN HOLD           XM09521
         MVC   HOLD1(4),CURID          SETUP FOR TXTIOT         XM09521
BUFENT1E LA    GR9,7                   GET LEN OF TNL ENTRY     XA05445
         MH    GR9,ENT1X               GET LEN OF CURRENT TNL   XM08070
         C     GR9,TNTFREE             TEST FOR END OF TNL      XA05445
         BH    BUFENT2B         BRANCH IF NOT REACHED   XM08070,XM09521
         TM    IOCTSTAT,FULLT      IO CNTRL TBL OVFLOW?          S01904
         BZ    BUFENT1C            NO,BRANCH OUT                 S01904
         TM    APT4,REALOCTE       HAS REALLOC BEEN DONE         S01904
         BO    QUIT                YES,TOO MUCH INPUT          @ZA07602
         STM   WRKREG0,WRKREGF,BRNCHSV  SAVE REGISTERS           S01904
         L     BRANCH,ERDIGA       GET ADDR OF REALLOC RTN       S01904
         BALR  RETURN,BRANCH       GO TO REALLOC RTN             S01904
         LM    WRKREG0,WRKREGF,BRNCHSV  RESTORE REGISTERS        S01904
         B     BUFENT2B                                         XM09521
BUFENT1C LR    GR3,XP2      SAVE REG XP2 WHEN ENTERING PURGES
         MVC   HOLD3+8(1),SWITCH       MUST MAINTAIN SWITCH
         ST    XS2,BUFDISP
         BAL  RLK,TXTBUF2
         TM    APT1,EX       IS THIS A LOAD MODULE
         BC    14,BUFENT1D        IF NOT  BRANCH
         L     RLK,BUFSTART       WAS THERE ANY THING IN THE
         C     RLK,TXTBFBEG        THAT WAS NOT ALLOC I
         BC    8,BUFENT1D         IF NOT   NO SWEAT
         L     XP1,LMLEN       IF THERE WAS  IT MUST
         L     GR8,TXTBFBEG         IT MUST BE MOBED TO THE FRONT
         BAL   XP2,LMMOVE     OF THE BUFFER AND RECORDED
BUFENT1D L     RLK,TXTBFBEG
         MVC   SWITCH(1),HOLD3+8         RESTORE SWITCH AFTER PURGE
         ST    RLK,BUFSTART
         BAL   RLK,BUFTMK2
         L     XS2,BUFDISP
         LR    XP2,GR3
         ST    XS2,HOLD3                 SAVE ALLOCATED LENGTH  XM08070
BUFENT2  ST    XS2,HOLD        LENGTH IN HOLD
BUFENT2B EQU   *                                                XM09521
         OI    HOLD1+2,INCORE  MARK ENTRY AS INCORE
         L     GR8,TNTFREE             PICK UP TNT OFFSET
         A     GR8,TNT1                COMPUTE TNT POINTER      ZA01405
         L     GR1,TXTFREE             PICK UP TXTIO OFFSET     XA05445
         A     GR1,TXTIO               COMPUTE TXTIO POINTER    ZA01405
         TM    SWITCH,DENSE1
         BC    1,BUFDEN
BUFENTA  MVC   0(4,GR1),HOLD1      INSERT ID & MULT IN TXTIO
         MVC   0(2,GR8),HOLD+6         PUT OFFSET IN TNL ENTRY  XA05445
         MVC   5(2,GR8),HOLD+2     PUT LENGTH IN NOTELIST
         MVC   2(3,GR8),BUFSTART+1  AND STARTING ADDR
         BAL   GR1,TXTPTR           UPDATE ALL INTERNAL PTRS
         BCT   XP2,BUFENT4         HAVE WE MADE ALL NECESARY ENTRIES
         L     XS2,HOLD3      MUST PRESERVE THE ALLOC LENGTH
         ST    XP2,HOLD+4          ZERO AREA AS WE LEAVE
         TM    APT1,EX            IS THIS A LOAD MODULE
         BC    8,BUFENTA1          BR ON OBJENT INPUT
         TM    SWITCH,READSW       HAS THE READ BEEN ISSUED
         BC    8,TXTLM5       YES  BRANCH
         LA    GR3,TXTLM5        SET RETURN ADDR AFTER READ
         B     TXTREAD
BUFENTA1 LR    GR1,GR8     SET UP A PARA FOR OBJ INPUT
         B     TXTINSRT
BUFENT4  OI    HOLD1+2,DENSE
         LH    R0,HOLD+6           UPDATE DISP
         A     R0,UT1SIZE
         STH   R0,HOLD+6
         S     XS2,UT1SIZE
         C     XS2,UT1SIZE
         BC    10,BUFENT6           HIGH OR EQU
         MVC   HOLD+2(2),DISPLAC+2 MOVE APPROP LEN INTO HOLD AREA
         B     BUFENT1E              RETURN FOR NEXT ENTRY      XA05445
BUFENT6  MVC   HOLD+2(2),UT1SIZE+2 MOVE APPROP LEN INTO HOLD AREA
         B     BUFENT1E              RETURN FOR NEXT ENTRY      XA05445
*
*
BUFDEN   MVC   HOLD+6(2),CDISP   WILL ONLY BE THRU HERE ONCE    XM09517
         OI    HOLD1+2,DENSE      MARK WORK AREA DENSE FOR ENTRY
         L     R0,BUFSTART           MUST REESTABLISH THE
         AH    R0,CDISP         FROMAD FOR THE PURGE    TXTNIO
         ST    R0,FROMAD           THIS WILL BE THE STARTING ADDR
         TM    APT1,EX     CAN BE A LOAD WHEN CONFIG REQUIRES THAT A
         BC    1,BUFDEN1         ID BE READ BUT WILL NOT FIT IN BUFFER
*       BUT HAS BEEN ALLOCATED - CAUSED BY GROUPED INPUT
         ST    GR4,HOLD
         AR    R0,GR4
         ST    R0,TOADDR
         LH    XP1,CDISP
         AR    XP1,GR4    WILL PIECE EXTEND BEYOND MYLT
         C     XP1,MULTSIZE     NO   BRANCH
         BC    12,BUFENTA
         SR    XP1,GR4     OBTAIN TRUE ADDR THAT WILL FIT
         LNR   XP1,XP1
         A     XP1,MULTSIZE
         ST    XP1,HOLD
         ST    XP1,TOADDR     CHANGE TO ADDR TO PREVENT LATTER MATCH
         B     BUFENTA
BUFDEN1  SH    R0,CDISP                REALIGN
         ST    R0,FROMAD               FROM ADDR
         B     BUFENTA
* THE TXT IS ADDED IN THE BUFFER AS THE LAST STEP - SPACE HAS BEEN
*  ALLOCATED IF NECESSARY AND RECORDED IN THE TXTIOT AND TXT NOTE LIST
*        REG1 WILL CONTAIN THE APPROP NOTE LIST ADDR
*
TXTINSRT LH    R0,CDISP       TEST IF END OF PIECE WILL EXCEED
         S     GR1,TNT1                CALC TNL OFFSET          XA05743
         ST    GR1,LASTTNT        SAVE NOTE LIST ADDR
         A     GR1,TNT1                RESTORE TNL POINTER      XA05743
         AR    R0,GR4             MULTIPLICITY BOUNDRY
         C     R0,MULTSIZE
         BC    2,TXTSPLT      BRANCH IF SPLITTING NECESSARY
         BAL   RLK,TXTMOVE
         B     TXTRET
*
TXTMOVE  MVC   HOLD+1(3),2(GR1)    OBTAIN BUFFER ADDR
         L     GR1,HOLD
         AH    GR1,CDISP
         BCTR  GR4,0               DECREMENT LENGTH
         EX    GR4,TXTMVE          MOVE  INTO  BUFFER
         LA    GR4,1(GR4)          RESET LENGTH
         BR    RLK
*
TXTMVE   MVC   0(1,GR1),0(RIP)
*
TXTSPLT  LR    GR8,GR4      THE TXT HAS SPANNED TEO MULTIPLICITIES
         L     GR4,MULTSIZE      MOVE AS MUCH AS WILL FIT
         SH    GR4,CDISP         READJUST PARAMETERS AND REENTER
         BAL   RLK,TXTMOVE
         SR    GR8,GR4        UPDATE LOCATION
         AR    RIP,GR4       -UPDATE LOCATION
         LR    GR4,GR8           RESTORE LINGTH
         LA    R0,1
         AH    R0,CMULN
         STH   R0,CMULN       UPDATE MULTIPLICITY
         SR    R0,R0          AND
         STH   R0,CDISP       ZERO DISPLACEMENT
         B     TXT002A
*
* TXTEND - EOF RECEIVED - IF NOLENGTH CSECT - LENGTH MUST BE POSTED
*         AT THIS TIME -  ALSO THE BUFFER MUST BE CLEANED IF NECESSARY
*
TXTEND   TM    SWITCH,DENSE1
         BC    14,TXTENDA
         L     XS1,TNTFREE             PICK UP TNT OFFSET
         A     XS1,TNT1                COMPUTE TNT POINTER      ZA01405
         SH    XS1,TSEVEN         OBTAIN LAST NOTELIST ADDR FOR TXTNIO
         BAL   XP2,TXTNIO
         NI    SWITCH,X'BF'        CLEAN UP DENSE SW
TXTENDA  TM    APTSW3,XPDIND           EXPAND REQUEST?           Y01031
         BO    TXTEND2A                IF SO, BRANCH             Y01031
         TM    SWITCH,NOLEN
         BC    14,TXTEND1   BRANCH IF NOT NOLENGTH
         OI    SWITCH,NOLEN1      NOLENGTH CLEANUP
         ST    RLK,RETURNAD       SAVE RETURN ADDR
         B     TXTN1
TXTENDNL NI    SWITCH,X'EF'         TURN OFF CLEAN UP
         L     RLK,RETURNAD      RESTORE RETURN ADDR
TXTEND1  L     GR1,TXTIO    TEST FIRST ENTRY TXTIO TABLE TO SEE
         TM    2(GR1),INCORE         IF IT HAS BEEN WRITTEN OUT
         BC    1,TXTEND2A    NO   TEST IF OVERLAY IS SPECIFIED
TXTEND1A ST    RLK,RETURNAD        SAVE RETURN ADDR
         BAL   RLK,TXTBUF2    CLEAR TXTBUFFER
         L     RLK,RETURNAD      RESTORE RETURN ADDR
TXTEND2  SR    R0,R0
         STH   R0,SWITCH     CLEAN UP  SWITCH FOR NEXG INTERATION
         ST    R0,BUFDISP    CLEAR BUFFER DISP
         STH   R0,PID           MADE RAT REENTERABLE
         STH   R0,TXTNOTE          REINITIALIZE TO ZER/
         STH   R0,TXTWR     CLEAR NUMBER OF ENTRIES WR IN TXTIO
         BR    RLK
TXTEND2A TM    PDSE7,X'20'        IF OVLY SPEC  MUST FORCE
         BC    1,TXTEND1A          2 PASS SITUATION
         TM    APT4,ORDERR         IS ORDERING REQUIRED?         S01904
         BO    TXTEND1A            YES,MUST FORCE PURGE          S01904
         TM    SWITCH+1,NOGRPPG      IS A NONGROUPED PURGE REQUIRED
         BC    1,TXTEND1A          YES  BRANCH TO PURGE
         B     TXTEND2
*THIS ROUTINE  WILL CHECK IF THE NEW DENSE PIECE IS CONTIGUOUS WITH
* THE EXISTING  DENSE RECORD IN THE BUFFER
*   IF IT IS IT WILL BE ADDED
*  -IF NOT-  THE EXISTING PIECE WILL BE WRITTEN AND NEW ONE ADDED
*              KNOW ID AND MULT ARE SAME AS PREVIOUS
*
TXTDEN   L     XS1,TNTFREE             PICK UP TNT OFFSET
         A     XS1,TNT1                COMPUTE TNT POINTER      ZA01405
*                            IF A DENSE RECORD PRESENT IT WILL ALWAYS
         SH    XS1,TSEVEN    BE THE LAST ENTRY  CORRECT TNT1 ADDR
         MVC   HOLD+1(3),2(XS1) OBTAIN BUFFER ADDR
         L     GR9,HOLD
         AH    GR9,CDISP       GR9 CONTAINS WHERE NEW PIECE WOULD BEGIN
         L     GR1,TOADDR
         CR    GR9,GR1         PIECE
         BC    8,TXTDEN1      IF EQU NEW CAN BE ADDED AFTER OLD AFTER
*                             FIRST ENSURING LENGTH WON'T EXCEED MULT
         AR    GR9,GR4
         C     GR9,FROMAD      PIECE WE WISH TO ADD EQ BEGINNING OF OLD
         BC    7,TXTDEN2      NO BRANCH
         SR    GR9,GR4
         ST    GR9,FROMAD     AND INCREMENT LENGTH
         MVC   0(2,XS1),CDISP      DD OF PIECE
         LR    R0,GR4
TXTDENA1 MVC   HOLD+2(2),5(XS1) RETRIEVE OLD LENGTH
         AH    R0,HOLD+2
         STH   R0,HOLD+2        ADD ADDITIONAL
         MVC   5(2,XS1),HOLD+2
         LR    GR1,XS1         SET UP PARA FOR TXTINSRT
         B     TXTINSRT
* THE TXT IS TO BE ADDED BEHIND PRESENT PIECE - MUST CHECK FIRST TO
*  ENSURE DOESN'T EXCEED MULT BOUNDRIES
TXTDEN1  LH    GR9,CDISP
         AR    GR9,GR4
         LR    R0,GR4
         L     GR1,TOADDR          BRANCH IF ALL FIT -
         AR    GR1,GR4        SIMPLY INCREASE LENGTH
         ST    GR1,TOADDR
         C     GR9,MULTSIZE
         BC    12,TXTDENA1
         SR    GR9,GR4            IF EXCEEDS MULT LIMIT - ENTER SIZE
         LNR   GR9,GR9             THAT WILL FIT - INSERT ROUTINE WILL
         A     GR9,MULTSIZE        TAKE CARE OF OVERLAP
         LR    R0,GR9         SET UP REG ZERO WITH CORRECT LEN
         B     TXTDENA1
*
*THE TXT WAS NOT CONTIGUOUS  -  WILL WRITE OUT EXISTING PIECE
*
TXTDEN2  LA    XP2,BUFALLOC
         B     TXTNIO
*
* THIS ROUTINE  IS USED WHENEVER A  SECTION OF OUT OF ORDER TEXT IS TO
*   BE WRITTEN OUT  -  IT WILL MAKE ADDITIONAL ENTRIES IF SIZE OF
*   PIECE EXCEEDS UT1
*
TXTNIO   LR    GR8,XS1
         ST    XRET2,HOLD3    RESERVE REG5
         L     GR1,TXTFREE             PICK UP TXTIO OFFSET
         A     GR1,TXTIO               COMPUTE TXTIO POINTER    ZA01405
*                             CHECK IF LAST ENTRY HAS ALREADY BEEN
         SH    GR1,SFOUR      WRITTEN  CAN HAPPEN IN ISOLATED
         TM    2(GR1),DENSE      WAS THE LAST ENTRY MADE DENSE
         BCR   8,XP2       IF NOT  RETURN IMMEDIATLY
         TM    2(GR1),INCORE       HAS THE LAST DENSE ENTRY
         BCR   8,XP2     WRITTEN  --     YES RETURN
         L     XS2,FROMAD
TXTNIOA  MVC   HOLD+2(2),5(GR8)    RETRIEVE  LENGTH
         LH    XS1,HOLD+2       IF PIECE SIZE EXCEEDS UT1 - BRANCH
         CH    XS1,UT1SIZE+2
         BC    2,TXTNI1
         BAL   XRET2,COMBUF
         BAL   XRET2,COMCHK
         ST    GR1,HOLD
         MVC   2(3,GR8),HOLD      RECORD TTR
         TM    APT1,EX    IS THIS A LOAD MODULE
         BC    1,TXTNIOB
         L     R0,BUFDISP
         S     R0,MULTSIZE
         ST    R0,BUFDISP         FREE ALLOC BUFFER AREA
TXTNIOB  LA    R0,4        SET TO DECREMENT TO LAST TXTIO ENTRY
         L     GR1,TXTFREE             PICK UP TXTIO OFFSET
         A     GR1,TXTIO               COMPUTE TXTIO POINTER    ZA01405
         SR    GR1,R0
         NI    2(GR1),FLAGOUT      ZERO FLAG FIELD
         OI    2(GR1),TTRDEN
         L     XRET2,HOLD3   PRESERVE REG5
         BR    XP2
TXTNI1   L     GR1,TXTFREE             PICK UP TXTIO OFFSET
         A     GR1,TXTIO               COMPUTE TXTIO POINTER    ZA01405
         LA    R0,4                    MAKE ADDITIONAL ENTRY
         SR    GR1,R0
         MVC   4(4,GR1),0(GR1)
         MVC   5(2,GR8),UT1SIZE+2     INSERT UT1 LENGTH
         S     XS1,UT1SIZE
         STH   XS1,HOLD1+4        NEW LENGTH
         MVC   HOLD1+1(3),2(GR8)     OBTAIN BUFFER ADDR
         MVC   HOLD1+6(2),0(GR8)         AND THE DISPLACEMENT
         LA    R0,1                THE LENGTH OF THE ENTRY EXCEEDS
         AH    R0,ENT1C       UT1 -  FIRST MAKE EXTRA TABLE
         CH    R0,ENT1X       ENTRIES
         BC    12,TXTN3
         TM    IOCTSTAT,FULLT      IO CNTRL TBL OVFLOW?          S01904
         BNO   TXTNI11             NO,BRANCH OUT                 S01904
         TM    APT4,REALOCTE       HAS REALLOC BEEN DONE?        S01904
         BO    QUIT                YES,TOO MUCH INPUT          @ZA07602
         STM   WRKREG0,WRKREGF,BRNCHSV  SAVE REGISTERS           S01904
         L     BRANCH,ERDIGA       GET ADDR OF REALLOC RTN       S01904
         BALR  RETURN,BRANCH       GO TO REALLOC RTN             S01904
         LM    WRKREG0,WRKREGF,BRNCHSV  RESTORE REGISTERS        S01904
         B     TXTN3                                             S01904
TXTNI11 STM   XS1,XS2,SPACES
         BAL   RLK,TXTBUF1     PURGE AVOIDING DENSE CHECK
         SR    RLK,RLK   ZERO BUFFER DISPLACEMENT AFTER
         ST    RLK,BUFDISP    PURGING BUFFER
         BAL   RLK,BUFTMK2
         LM    XS1,XS2,SPACES
         B     TXTN2
TXTN3    L     XS1,UT1SIZE         CORRECT LENGTH FOR FIRST WRITE
         NI    2(GR1),FLAGOUT      ZERO FLAG FIELD
         OI    2(GR1),TTRDEN
         BAL   XRET2,COMBUF
         BAL   XRET2,COMCHK
         ST    GR1,HOLD
         MVC   2(3,GR8),HOLD      STORE TTR
TXTN2    L     GR8,TNTFREE             PICK UP TNT OFFSET
         A     GR8,TNT1                COMPUTE TNT POINTER      ZA01405
         LH    GR1,HOLD1+6
         A     GR1,UT1SIZE
         STH   GR1,HOLD1+6
         MVC   0(2,GR8),HOLD1+6
         MVC   2(5,GR8),HOLD1+1
         BAL   GR1,TXTPTR
         LH    XS2,HOLD1+6
         A     XS2,HOLD1         RESET STARTING ADDR
         LA    XS2,0(XS2)
         B     TXTNIOA        REENTER CHECKING NEWLY CREATED ENTRY WITH
*                        DECREMENTED LENGTH
*
TXTPTR   LA    R0,1
         AH    R0,ENT1C          INCREMENT COUNT OF ENTRIES
         STH   R0,ENT1C          TXT NOTE LIST
         LA    R0,4
         AH    R0,ENTOC          INCREMENT COUNT OF BYTES
         STH   R0,ENTOC          TXT IO TABLE
         LA    R0,4
         A     R0,TXTFREE        UPDATE PTR TO FIRST FREE ENTRY IN
         ST    R0,TXTFREE          TXT IO TABLE
         LA    R0,7
         A     R0,TNTFREE           UPDATE PTR TO FIRST FREE ENTRY IN
         ST    R0,TNTFREE           TEXT NOTE LIST
         BR    GR1
*
* LOAD MODULE PROCESSOR
*
*      FIRST STEP IS TO DETERMINE IF ALL ID'S ARE TO BE DELETED
*       IF SO - READ WILL BE ISSUED WILL ZERO LENGTH
TXTLM    LA    READCNT,1    SET UP PARA FOR ZERO READ
         NI    SWITCH+1,SPTXTOFF        RESET SPEC TEXT FLAG    OY00356
         TM    APTSW3,XPDIND           EXPAND REQUEST?           Y01031
         BO    TXTLMX                  IF SO, BRANCH             Y01031
         L     REG6,RLDINPAD   INITIALIZE ID-LENGTH PTR
         L     COUNT,12(REG6)      COUNT SET FOR TOTAL INPUT
         LA    COUNT,0(COUNT)     CLEAR THE HIGH ORDER BYTE
TXTLMX   ST    COUNT,LMLEN         SAVE INPUT RECORD LENGTH      Y01031
         TM    APTSW3,XPDIND           EXPAND REQUEST?           Y01031
         BO    TXTLM1X                 IF SO, BRANCH             Y01031
         LH    R0,4(REG6)
         AH    REG6,6(REG6)
         LA    REG6,16(REG6)
         ST    REG6,IDLENPTR
         AR    R0,REG6
         ST    R0,CREND  INIT ID-LENGTH LIST END PTR
         LR    RID1,RID       CALCULATE RENUMBER
TXTLM1   SLL   RID1,2          ENTRY
         A     RID1,RECNT
         TM    DT(RID1),DEL    IS THIS ID TO BE DELETED
         BC    7,TXTLM1A          CONTINUE SEARCH IF DELETE
TXTLM1X  OI    SWITCH,READSW         INDICATE READ IS REQUIRED   Y01031
         B     TXT0011
TXTLM1A  LA    RIP,4(RIP)          ONTINUE SEARCH
         C     RIP,CREND     WAS THAT THE LAST ONE
         BC    10,READ0
         LH    RID1,0(RIP)
         B     TXTLM1
READ0    OI    SWITCH,SHORTRD      ALL ITEMS IN THIS RECORD ARE TO BE
*      DELETED
         LA    BUFFADDR,HOLD1        BUMMY AREA FOR ARTIFICAL
         B     READ0A          READ
TXTREAD  LR    READCNT,COUNT        SET UP COUNT FOR READ
         ST    XS2,TXTALLOC
         L     BUFFADDR,BUFSTART
         AH    BUFFADDR,CDISP         COMPUTE CORRECT LOCATION
         TM    SWITCH,DENSE1           IS THIS RECORD DENSE
         BC    8,READ0B                NO, BRANCH
         SH    BUFFADDR,CDISP          YES,RESET BUFR START ADDR
READ0B   NI    SWITCH,READOFF          ALL SET TO READ
READ0A   L     DCBADD,HEWLCLAC      ADDR OF CURRENT READ BLOCK
         L     DCBADD,0(DCBADD)           ADDR OF DECB FOR THE READ
         L     REG6,INPADD         ESTABLISH  BASE FOR READ
         L     XP2,RDMACRO
         LR    COUNT,TXTBASE     REG4 WILL HOLD BASE UNTIL RETURN
         TM    APTSW3,XPDIND           EXPAND REQUEST?           Y01031
         BO    READ0AX                 IF SO, BRANCH             Y01031
         BALR  XSTX,XP2
         LR    TXTBASE,COUNT
         TM    SWITCH,SHORTRD       A SHORT READ TO BE ISSUED
         BC    14,TXTGREAD        NO  BRANCH
         NI    SWITCH,SHORTRD1      RESET SWITCH
         B     TXTRET
READ0AX  LH    RID,CURID               RESTORE ESDID             Y01031
         L     COUNT,LMLEN             RESTORE TXT COUNT Y01031,XA05128
         B     GREADX                  CONTINUE                  Y01031
TXTGREAD L     COUNT,IDLENPTR
         LH    RID,0(COUNT)   MUST RESTOTE ID
         LH    COUNT,2(COUNT)
GREADX   SR    GR1,GR1      PREPARE TO ZERO ACCUNLEN             Y01031
         ST    GR1,ACUMLEN
         L     XS2,TXTALLOC       OBTAIN AMOUNT OF BUFFER ALLOC
         BR    GR3
*
*   ID IS TO BE DELETED
*
TXTLM2   TM    APT1,EX
         BC    8,TXTRET     RETURN FOR OBJECT MODULES
         TM    SWITCH,READSW       HAS THE READ BEEN ISSUED
         BC    8,TXTLM2A       YES  BRANCH
         TM    SWITCH,NOLEN      IS A NOLEN OUTSTANDING
         BC    14,TXTLM2C          NO -  AVOID NOLEN CLEAN UP
         OI    SWITCH,X'20'            SET FLAG TO RETURN
         B     TXTN1          START NOLEN CLEAN UP
TXTLM2D  NI    SWITCH,X'DF'          RESET INCICATOR
TXTLM2C  L     GR3,BUFDISP         SET TO DO THE READ
         A     GR3,TXTBFBEG            NEW
         ST    GR3,BUFSTART            BEFSTART
         SR    GR3,GR3
         STH   GR3,CDISP               CLEAR DISP
         L     R0,TXTBFBEG       ESTABLISH BEGINNING OF TXTBUF
         A     R0,BUFDISP        AND OBTAIN THE FIRST FREE AREA
         AR    R0,COUNT        AND ADD TOTAL LENGTH OF INPUT RECORD
         C     R0,TXTBFEND       WILL IT OVERFLOW BUFFER
         BC    12,TXTLM2B         BRANCH IF IT WILL FIT
         BAL   RLK,TXTBUF      PURGE THE TXTBUF
         SR    RLK,RLK         AND ZERO THE BUFFER DISPLACEMENT
         ST    RLK,BUFDISP
         L     RLK,TXTBFBEG       MUST RESET BUFSTART TO THR BEG
         ST    RLK,BUFSTART        OF THE BUFFER TO POSITION READ
TXTLM2B  BAL   GR3,TXTREAD          NOW DO THE READ BEFORE COMTINUING
TXTLM2A  L     RLK,IDLENPTR
         LR    XS1,RLK
         LA    RLK,4(RLK)
         C     RLK,CREND    IF THIS IS THE LAST ID  THERE IS NO NEED
         BC    10,TXTRET    TO MOVE THE REMAINING BUFFER ENTY UP
         LH    XS1,2(XS1)   XS1 CONTAINS LENGTH TO BE DELETED
         LNR   XP1,XS1
         A     XP1,LMLEN    XP1 CONTAIN AMOUNT OF TXT IN BUFFER TO BE
         L     GR8,BUFDISP  MOVED
         A     GR8,TXTBFBEG
         LR    RLK,GR8
         AR    RLK,XS1      FROMAD
         BAL   XP2,LMMOVE
         B     TXTLM4
* THIS RTN WILL BE USED TO OVERLAY DELETED ID'S IN THE BUFFER AND
*  MOVE ANY REMAINING TXT IN THE BUFFER TO THE BEGINNING IF A FULL
*  MULTIPLICITY CAN NOT BE ALLOCATED
*
* INCOMING PARAMETERS ARE     GR8  - TO ADDR
*                             GR9  - FROMAD
*                             XP1  - AMOUNT TO BE MOVED
LMMOVE   LA    GR1,256        SET UP TEST COUNT
LMMOVE3  CR    GR1,XP1        IF THE INCOMING COUNT IS LESS THAN THAT
         BC    10,LMMOVE1    WE ONLY HAVE ONE MOVE
         MVC   0(256,GR8),0(RLK)    MOVE COUNT
         SR    XP1,GR1      AND THE PARAMETERS ADJUSTED ACCORDINGLY
         AR    GR8,GR1         INCREMENT TO AND FROM ADDRESSES
         AR    RLK,GR1
         B     LMMOVE3
LMMOVE1  BCTR  XP1,0
         EX    XP1,TLMMVE
LMMOVE2  BR    XP2
*
TLMMVE   MVC   0(1,GR8),0(RLK)
*
* ID & MULT AGREE WITH LAST - THIS MULT HAS BE ALLOCATED BUT IF LENGTH
*     EXCEEDS PRESENT BUFFER BOUNDRIES - ANOTHER MUST BE ALLOC
*
TXTLM3   NI    SWITCH,X'BF'   INSURE DENSE SW IS OFF
         SH    GR1,SFOUR     OBTAIN LAST TXTIO ADDR
         TM    2(GR1),INCORE    HAS THAT ENTRY BEEN WRITTEN
         BC    1,TXTLM3A         BRANCH IF STILL IN CORE
TXTLM3D  OI    SWITCH,DENSE1    MARK ENTRY OUT OF ORDER
         B     BUFALLOC       AND ALLOC AND ENTER IN TABLES
TXTLM3A  L     R0,BUFSTART        CHECK IF RECORD WILL FIT IN BUFFER
         AH    R0,CDISP          ADD THE BUFFER START AND THE DISP
         AR    R0,COUNT        AND THE LENGTH OF THE INCOMING RECORD
         C     R0,TXTBFEND        DIES THE INCOMING RECORD EXCEED
         BC    12,TXTLM3C        BUFFER LIMITS
         BAL   RLK,TXTBUF
         SR    RLK,RLK     PURGE AND RESET BUFFER INCREMENT
         ST    RLK,BUFDISP        TO ZERO
         B     TXTLM3D    SINCE JUST PURGED MUST MARK OUT OF ORDER
TXTLM3C  BAL   GR3,TXTREAD       READ THJ LOAD MOD INPUT RECORD
         LH    GR8,CDISP           WILL THIS INPUT EXCEED MUL
         AR    GR8,COUNT
         C     GR8,MULTSIZE
         BC    12,TXTLM4      BRANCH ON LOW OR EQUAL
*  IT IS NECESSARY TO READJUSNT TO THE TRUE AMOUNT THAT
*         MUST BE ALLOCATED
         S     GR8,MULTSIZE         CDISP+COUNT-MULTSIZE IS
         LR    COUNT,GR8      THE TRUE AMOUNT LEFT TO ALLOC
         LH    GR9,CMULN
         LA    GR9,1(GR9)     BUMP MULT
         STH   GR9,CMULN      AND ALLOCATE SPACE IN BUFFER
         STH   GR9,PMULN          UPDATE TO CHECK NEXT ENTRY
         B     BUFALLOC
*
* THE PRESENT ENTRY HAS BEEN FULLY PROCESSED - IF THAT WAS LAST ENTRY
*  WE WILL RETURN - IF NOT WE WILL READJUST PARAMETERS AND REENTER
*
TXTLM4   TM    APTSW3,XPDIND           EXPAND REQUEST?           Y01031
         BNO   TXTLM4X                 IF NOT, BRANCH            Y01031
         BAL   RLK,TXTEND              DO EOF CLEAN-UP           Y01031
         B     TXTRET                  RETURN                    Y01031
TXTLM4X  L     GR8,IDLENPTR
         LR    GR9,GR8
         LA    GR8,4(GR8)     BUMP IDLENPTR AND SEE
         C     GR8,CREND      IF PAST END OF CONTROL RECORD
         BC    10,TXTRET    BRANCH HIGH OR EQY
         LH    GR9,2(GR9)     PICK UP NEXT LENGTH
         LR    GR1,GR9
         LNR   GR1,GR1
         A     GR1,LMLEN
         ST    GR1,LMLEN
         A     GR9,ACUMLEN
         ST    GR9,ACUMLEN
         L     XAA,RLDINPAD   NOW OBTAIN ASSM OF THIS ID
         L     XAA,8(XAA)
         LA    XAA,0(XAA)
         AR    XAA,GR9
         ST    GR8,IDLENPTR        KEEP UPDATED IDLENPTR
         LH    COUNT,2(GR8)        OBTAIN NEW LENGTH
         LH    RID,0(GR8)           AND ID
         B     TXT0011
* ONE MULTIPLICITY HAS BE ALLOCATED - TEST IF THERE IS MORE PRESENTLY
* IN THE BUFFER THAT MUST BE ALLOCATED AND ENTERED IN TABLES
*
TXTLM5   EQU   *                                                OY00356
         TM    SWITCH+1,SPTXTON         CHECK FOR SPEC TXT      OY00356
         BNO   TXTLM5A                  BRANCH IF NOT APPLIC    OY00356
         NI    SWITCH+1,SPTXTOFF        SET FLAG OFF            OY00356
         AH    COUNT,CDISP              ADJUST FOR TEXT DISPLAC OY00356
TXTLM5A  EQU   *                                                OY00356
         SR    COUNT,XS2   SUBTRACT ALLOCATED SIZE FROM LENGTH  OY00356
         BNP   TXTLM4      BRANCH ON ZERO OR LESS CHECK NEXT ID OY00356
         LH    GR9,CMULN
         LA    GR9,1(GR9)     IF NOT FINISHED WITH THIS ID - BUMP MULT
         STH   GR9,CMULN      AND REALLOCATE
         STH   GR9,PMULN          UPDATE TO CHECK NEXT ENTRY
         B     TXT002A
*AN ENTRY IS TO BE MADE IN THE TXT I/O CONTROL TABLE. UNLESS IT IS FULL
BUFTMK2  TM    IOCTSTAT,FULLT    IS TXT I/O CNTL TABLE FULL
         BC    8,BUFTOK
*TABLE IS FULL. ERROR
         LA    MSG,IEW0364
         B     ERROR
BUFTOK   LA    R14,7
         MH    R14,ENT1X
*R14=NUMBER OF BYTES IN NOTE LIST.
         L     R15,TNT1           R15=START OF MARK LIST
         BAL   XRET2,COMBUF
         BAL   XRET2,COMCHK
         LA    R15,7                   LOAD NOTELIST ENTRY LEN  XA06144
         MH    R15,ENT1X               MULT BY ENTRY COUNT      XA06144
         L     XRET2,TNT1              GET ADDRESS OF NOTELIST  XA06144
         XR    R14,R14                 CLEAR REG 14 FOR DIVIDE  XA06144
         D     R14,HEX100              DIVIDE FOR CLEARING      XA06144
         LTR   R15,R15                 TEST QUOTIENT            XA06144
         BZ    TXT0161                 IF ZERO, BRANCH          XA06144
TXT0160  EQU   *                                                XA06144
         XC    0(256,XRET2),0(XRET2)   CLEAR 256 BYTES          XA06144
         A     XRET2,HEX100            BUMP BUFFER POINTER      XA06144
         BCT   R15,TXT0160             IF MORE TO MOVE, LOOP    XA06144
TXT0161  EQU   *                                                XA06144
         LTR   R14,R14                 ANY REMAINDER?           XA06144
         BZ    TXT0162                 NO, WE ARE DONE          XA06144
         BCTR  R14,0                   DECREMENT FOR EXECUTE    XA06144
         EX    R14,CLEARIT             CLEAR REMAINDER          XA06144
TXT0162  EQU   *                                                XA06144
         LA    XTMK2,IOCT
         LR    XS1,XTMK2
         XR    R0,R0               CLEAR REGISTER                S01904
         XR    XRET2,XRET2         CLEAR REGISTER                S01904
         IC    XRET2,ENITC         GET OLD COUNT IN TXTIO TBL    S01904
         IC    R0,ENITC+1          GET NEW COUNT OF BYTES USED   S01904
         AR    XRET2,R0            ADD BOTH COUNTS               S01904
         AR    XTMK2,XRET2         ADD TO CURRENT ENTRY ADDR     S01904
*STORE THE TTR IN THE CURRENT ENTRY OF THE TXT I/O CONTROL TABLE
         ST    GR1,0(XTMK2)   STORE TTR OF TXT NOTE LIST
         LA    XTMK2,4(XTMK2)
         SR    XTMK2,XS1      SUBTRACT TO OBTAIN REL ADDR
*THE UPDATED BYTE COUNT IS NOW STORED
         TM    APT4,REALOCTE       HAS REALLOC BEEN DONE?        S01904
         BNO   TXT016              NO-BRANCH OUT                 S01904
         SR    XTMK2,R0                 GET NEW TBL BYTES       OX00029
         STC   XTMK2,ENITC         USE FIRST BYTE OF ENITC       S01904
         B     TXT016A             BRANCH AROUNG REG UPDATE OF ENITC
TXT016   STH   XTMK2,ENITC        STORE BYTE COUNT
TXT016A  LH    R0,ENT1C       KEEP TRACK OF ACTUAL ENTERIES
         AH    R0,TXTNOTE    WRITTEN
         STH   R0,TXTNOTE
*TEST FOR OVERFLOW
         LA    XRET2,4(,XRET2)          ADJUST TOTAL LENGTH     OX00029
         CH    XRET2,X12                IS TXT I/O TBL FULL     OX00029
         BC    4,TXT017    NO,CONTINUE
         OI    IOCTSTAT,FULLT    INDICATE TXT I/O CNTL TABLE IS FULL
*                          CAN NOT BE PURGED AGAIN
TXT017   SR    R0,R0
         STH   R0,ENT1C  RESET TXT NOTELIST CURRENT BYTE COUNT TO ZERO
         ST    R0,TNTFREE
         BCR   15,RLK
*                                    PROCESSED CSECTS IN BUFFER
*
* THIS ROUTINE WILL CLEAR THE BUFFER AND MARK ENTRIES WRITTEN*
*
TXTBUF   TM    NEWSW,EOF        IS THIS END OF INPUT
         BC    1,TXTEND
         LTR   COUNT,COUNT    ZERO LENGTH IS IGNORED
         BCR   8,RLK
TXTBUF2  TM    SWITCH,DENSE1      FIRST CHECK IF LAST THISG IN BUFFER
         BC    14,TXTBUF1         IS A PIECE OF OUT OF ORDER TEXT
         L     XS1,TNTFREE             PICK UP TNT OFFSET
         A     XS1,TNT1                COMPUTE TNT POINTER      ZA01405
         SH    XS1,TSEVEN      SET UP PARAMETER FOR TXTNIO
         BAL   XP2,TXTNIO         WRITE IT AND RET
         NI    SWITCH,X'BF'
TXTBUF1  CLC   TXTWR(2),ENTOC     ANYTHING IN TABLE
         BCR   8,RLK
         STM   RID,REG6,HOLD3         MUST MAINTAIN REGS 5 AND 6
         TM    PDSE7,X'20'        OVERLAY OPTION SPECIFIED
         BC    1,TXTENT1          WRITE ON E RECORD PER ENTRY
         CLC   MULTSIZE(4),UT1SIZE
         BC    2,TXTENT1          BRANCH MULT HIGH
         TM    SWITCH,NOLEN        IS THERE AN OUTSTANDING NOLEN TO
         BC    1,TXTENT1     BE POSTED   YES   WE CAN NOT GROUP
         TM    SWITCH+1,NOGRPPG       DO WE NEED A NON GROUPED PURGE
         BC    1,TXTENT1      YES  PURGE WITHOUT GROUPING
*
*   AFTER HERE SYSUT1 WILL BE GROUPED AS MUCH AS POSSIBLE
*
*
*
         LH    REG6,ENTOC    REG6 WILL BE USED TO PROVIDE LIMIT
         A     REG6,TXTIO
         ST    REG6,TSCNEND    SAVE END ADDR
         LH    REG6,TXTWR    BYTES WRITTEN IN TXTIO
         LR    GR8,REG6        TO TXTIO ENTRY
         SRL   GR8,2
         SH    GR8,TXTNOTE        SUB NUMBER OF ENTERIES WRITTEN
TXTB2A   A     REG6,TXTIO    NOW REGS XSTX AND GR8 CONTAIN EFFECTIVE
         MH    GR8,TSEVEN
         A     GR8,TNT1       ADDR OF ENTRIES TO BE WRITTEN
TXTB2    TM    2(REG6),INCORE
         BC    1,TXTB1
         LH    GR1,TXTACUM        HIT OUT OF ORDER
         LTR   GR1,GR1           CLEAR PREVIOUS GROUPING IF NEC
         BC    7,TXTBWR             OR ADVANCE TO ENEXT
TXTB2C   LA    REG6,4(REG6)   BUMP PTRS TO NEXT ENTRY
         LA    GR8,7(GR8)
         C     REG6,TSCNEND
         BC    10,TXTBEND
         B     TXTB2
*
TXTB1    NI    2(REG6),X'7F'  MARK THIS ENTRY NOT IN CORE
         LH    GR1,TXTACUM    HAVE WE STARTED A GROUPING
         LTR   GR1,GR1
         BC    7,TXTB3        YES - BRANCH
         MVC   HOLD+2(2),5(GR8)   PARAMETER FOR WRITE
         LH    XS1,HOLD+2      ACQUIRE LENGTH
         MVC   HOLD+1(3),2(GR8) AND
         L     XS2,HOLD             BUFFER ADDR
TXTB1A   STH   XS1,TXTACUM
         B     TXTB2C
*
*  GROUPING HAS STARTED - FIRST TEST WILL SEE IF ADDITIONAL LENGTH WILL
*    EXCEED LIMITS REGARDLESS OF ABILITY TO BE GROUPED - IF IT WOULD
*    FIT - THEN ELIGIBILITY IS TESTED
*
TXTB3    MVC   HOLD+2(2),5(GR8)    ADD NEW LENGTH TO ACUM LENGTH
         AH    GR1,HOLD+2           AND TEST AGAINST UT1SIZE
         C     GR1,UT1SIZE
         BC    2,TXTBWR            WRITE PREVIOUS ENTRY
         LA    R0,4                ADDITIONAL LENGTH WILL FIT - IS LAST
         SR    REG6,R0              MULT ZERO
         MVC   HOLD(4),0(REG6)
         NI    HOLD+2,FLAGOUT
         LA    GR1,1        CONSECUTIVE
         A     GR1,HOLD      BUMP
         AR    REG6,R0      RESTORE PTR TO PRESENT TXTIO ENTRY
         C     GR1,0(REG6)    WAS LAST ONE GREATER THAN PRESENT
         BC    8,TXTB3A
         CLC   2(2,REG6),CONZO1   IF PRESENT MULT=0  CHECK IF LAST
*                ENTRY IS LAST MULT
         BC    7,TXTBWR
         SR    REG6,R0
*  SINCE PRESENT ENTRY IS MULT ZERO  AND AFTER INSURING ID
*   NOT THE SAME   CHECK IF PREVIOUS ISLAST ONE
         CLC   0(2,REG6),4(REG6)       ARET THE ID S THE SAME
         BC    8,TXTBWR1
         CLC   2(2,REG6),CONZO1    MULT CHANGE
         BNE   TXTBWR1
         LH    GR1,0(REG6)
         AR    REG6,R0          RESTORE TO PRESENT ENTRY
         SLL   GR1,4              WAS COMPLETE CSECT SO THE PRESENT
         A     GR1,CHESD          ENTRY CAN BE GROUPED WITH IT
         L     XP2,12(GR1)
         LA    XP2,0(XP2)     OBTAIN LENGTH FROM CESD
         SR    XP1,XP1
         D     XP1,MULTSIZE
         LTR   XP1,XP1
         BC    7,TXTB4A
         BCTR  XP2,0
TXTB4A   CH    XP2,HOLD+2   HIGHEST MULT EQU LST
         B     TXTBWR              NO GROUPING OF CSECTS IN UT1 AOS
TXTB3A   MVC   HOLD+2(2),5(GR8)   - UPDATE ACUM LENGTH
         AH    XS1,HOLD+2
         B     TXTB1A
*
*
TXTBEND  LH    GR1,ENTOC
         STH   GR1,TXTWR        UPDATE NUMBER OF BYTES WRITTEN
         LH    GR1,TXTACUM      BEFORE LEAVEING MUST WRITE ANY
         LTR   GR1,GR1             PARTIAL GROUPING
         BC    8,TXTENTRT
         OI    SWITCH,X'01'       END SW
         B     TXTBWR
TXTBWR1  AR    REG6,R0      RESTORE PTR TO PRESENT TXTIO
TXTBWR   BAL   XRET2,COMBUF
         BAL   XRET2,COMCHK
         ST    GR1,HOLD          SAVE TTR IN LAST
         LA    GR1,7               PROCESSED ENTRY
         SR    GR8,GR1
         MVC   2(3,GR8),HOLD      STORE TTR
         AR    GR8,GR1
         LA    R0,4      RESET R0
         SR    REG6,R0              AND
         OI    2(REG6),X'40'       TTR FLAG IN TXTIO
         AR    REG6,R0
         SR    GR1,GR1
         STH   GR1,TXTACUM         NO LONGER GROUPING - THIS GROUP
         TM    SWITCH,X'01'            LAST WRITE SWITCH ON?
         BC    14,TXTENT2              NO, GO TEST DENSE SWITCH
         NI    SWITCH,X'FE'            YES, TURN THE SWITCH OFF
         B     TXTENTRT                RETURN
TXTENT2  TM    2(REG6),DENSE           IS NEXT RECORD DENSE
         BC    1,TXTB2C                YES, SKIP IT
         B     TXTB1                   NO, PROCESS IT
TXTENT1  CLC   TXTWR(2),ENTOC     ONE RECORD PER ENTRY  LENGHT WILL
         BC    7,TXTENT11       BE UT1 OR ACTUAL WHICHEER
TXTENTRT LM    RID,REG6,HOLD3         MUST MAINTAIN REGS 5 AND 6
         BCR   15,RLK
TXTENT11 LH    GR13,TXTWR
         LA    R0,4
         AR    R0,GR13
         STH   R0,TXTWR           BUMP TXTWR
         A     GR13,TXTIO
         TM    2(GR13),INCORE    WAS THE FIRST ENTRY ALREADY WR
         BC    14,TXTENT1
         NI    2(GR13),X'7F'      TURN OFF OLD INDICATOR
         OI    2(GR13),X'40'       MARK TTR
         S     GR13,TXTIO
         SRL   GR13,2
         LA    R0,7      SIZE OF ONE NOTE LIST ENTRY
         STH   R0,HOLD+2
         SH    GR13,TXTNOTE
         MH    GR13,HOLD+2
         A     GR13,TNT1
         MVC   DISPLAC(2),0(GR13)
         MVC   HOLD+1(3),2(GR13)
         L     XS2,HOLD           ADDR CORRECT AND ADD ANY DISP
         AH    XS2,DISPLAC         TO IT   USUALLY ZERO
         MVC   HOLD+2(2),5(GR13)   OBTAIN ENTRY LENGTH
         CLC   HOLD+2(2),UT1SIZE+2   INSURE SPECIFY LINGTH LESS  UT1
         BC    4,TXTENT2A      IF LENGTH SPECIFIES LESS THAN UT1
         L     XS1,UT1SIZE        USE ACTUAL LENGTH
         B     TXTENT3
TXTENT2A LH    XS1,HOLD+2
TXTENT3  LR    REG6,GR13
         BAL   XRET2,COMBUF
         BAL   XRET2,COMCHK
         ST    GR1,HOLD     SAVE TTR
         MVC   2(3,REG6),HOLD      SAVE TTR
         B     TXTENT1
***********************************************************
*
*                     WHERE THE ACTUAL LENGTH IS POSTED FOR
*                    NOLENGTH CSECTS
*
***********************************************************
TXTNL3   LR    XS1,XS2
         TM    2(XS2),INCORE    IS THE PRESENT ENTRY TO BE POSTED
         BC    8,TXTNLB       IN CORE NOW -  YES POST GOOD LEN
         S     XS1,TXTIO      OBTAIN NUMBER OF ENTRIES IN TXTIO
         SRL   XS1,2          IF THAT NUMBER EXCEEDS MAX ALLOWABLE AT
         LA    XS1,1(XS1)   ADD ONE TO GET TRUE ENTRY NUMBER
         LH    RLK,TXTNOTE
TXTNL4   CH    XS1,TXTNOTE    COMPARE THE ENTRY NUMBER TO THE
*   NUMBER OF ENTRIES WRITTEN.   IF LESS OR EQU WILL HAVE UNTRUE
*   LENGTH POSTED
         BC    4,TXTNLB        MUST POST UNTRUE LENGTH INDIC
         BC    7,TXTNLC    BRANCH NOT EQU   EQU  CHECK FOR ZERO
         LTR   RLK,RLK     FALL THRU IF NORELIST NEVER WR
         BC    7,TXTNLB      COMPUTE TRUE NOTELIST
TXTNLC   MH    RLK,TSEVEN       DISPLACEMENT
         SR    GR8,RLK       TRUE DISPLACEMENT
TXTNL6   STH   XP1,HOLD+2      POSTED -
         A     GR8,TNT1          OBTAIN NOTE LIST ADDR AND POST
         MVC   5(2,GR8),HOLD+2     PROPER LENGTH
TXTNL6A  CLC   MULTSIZE(4),UT1SIZE WAS MORE THAN ONE ENTRY MADE
         BC    2,TXTNL5            YES - BRANCH
TXTNL6B  LA    GR8,7(GR8)     WAS THE HIGHEST MULT THE LAST ENTRY
         L     RLK,TNT1                PICK UP TNT ADDRESS      ZA01405
         A     RLK,TNTFREE             COMPUTE TNT POINTER      ZA01405
         CR    GR8,RLK                 IF SO, IT'S LAST IN      ZA01405
         BC    8,TXTNL7         BUFFER AND THE BUFFER DISP CAN BE ADJ
         BAL   RLK,TXTBUF1     IF NOT  WE MUST FORCE TWO PASS TO CLEAR
         SR    RLK,RLK         RESET THE BUFFER DISPLACEMENT TO
         ST    RLK,BUFDISP       ZERO
TXTNL6C  NI    SWITCH,X'F7'    ANY GAPES IN THE BUFFER
         TM    SWITCH,X'20'       SHOULD RETURN TO LM DELETE
         BC    1,TXTLM2D          YES
         TM    SWITCH,NOLEN1    NO LENGTH CLEAN UP
         BC    1,TXTENDNL
         MVC   CURID(4),HOLD1      RESTORE PARA FOR PRESENT ID
         B     TXT002B
*THE NOTELIST HAS BEEN WRITE OUT AT LEAST ONCE - BE CERTAIN APPLICABLE
* ENTRY STILL IN CORE
TXTNLB   OI    2(XS2),X'08'    IF NOT  SET BIT FOR UNTRUE LENGTH
         B     TXTNL6C            AND RETURN
TXTNL7   L     GR8,BUFDISP    PRESENT DISPLACEMENT MINUS ALLOC
         S     GR8,MULTSIZE     SIZE   PLUS THE READ LENGTH  IS THE
         AH    GR8,HOLD+2
         ST    GR8,BUFDISP     NEW PROPER BUFFER DISP
         B     TXTNL6C
TXTNL5   LA    XS2,4(XS2)      INCREMENT TXTIO ADDR
         LA    GR8,7(GR8)     LESS THAN MULT- POSSIBLE THAT EXTRA
         S     XP1,UT1SIZE    ENTRIES HAVE BEEN MADE
         C     XP1,UT1SIZE
         BC    2,TXTNL5
         LTR   XP1,XP1            BRANCH IF LESS THAN ZERO
         BC    12,TXTNL9    VAL 0 OR NEG PRESENT ENTRY NOT REQ
         STH   XP1,HOLD
         MVC   5(2,GR8),HOLD   NOVE IN PROPER LENGTH TO LAST PIECE
TXTNL5A  CLC   0(4,XS2),4(XS2)    IS THE NEXT ONE THE AAME
         BC    7,TXTNL6B     PREPARE TO RETURN
         LA    XS2,4(XS2)      INCREMENT TXTIO ADDR
         LA    GR8,7(GR8)         INCREMENT NOTELIST ADDR
TXTNL9   CLC   0(4,XS2),4(XS2)    IS THE NEXT ONE THE SAME
         BC    8,TXTNL8        YES  BRANCH
         MVC   0(2,XS2),CONZO1     ZERO THE EXTRA ID
         B     TXTNL6B
TXTNL8   MVC   0(2,XS2),CONZO1
         LA    XS2,4(XS2)      INCREMENT TXTIO ADDR
         LA    GR8,7(GR8)         INCREMENT NOTELIST ADDR
         B     TXTNL9    CONTINUE    TO CHECK OOR END
*
         DS    0F
DBLWRD   DC    X'FFFFFFF8'          MASK TO ZERO LST THREE BITS
MULTONLY DC    X'000003FF'           MASK TO ZERO ALL BUT MULT
IOCTSTAT DC    X'00'       I/O CONTROL TABLE OVFLO IND
*         ENTRIES WRITTEN
TXTWR    DC    H'0'     CONTAINS DISPLACEMENT IN TXTIO TABLE OF
BUFSTART DC    F'0'
BUFDISP  DC    F'0'
HOLD     DC    2F'0'          MISC  FOR ENTER INFO INTO TABLES
TXTFREE  DC    F'0'           FIRST FREE ADDR IN TXTIO
TNTFREE  DC    F'0'           FIRST FREE ADDR IN NOTELIST
TXTNOTE  DC    H'0'     HOLDS THE ACTUAL NUMBER OF ENTRIES OF THE
*  TXT NOTELIST THAT HAVE BEEN WRITTEN.   IT WILL NOT GE THE MAX IN
*  SITUATIONS REQUIRE MULTIPLE ENTRIES
CURID    DC    2X'0'          MAINTAINS CURRENT ID AND MULTIPLICITY
CMULN    DC    2X'0'
PID      DC    2X'0'          MAINTAINS  PAST ID & MULT
PMULN    DC    2X'0'
MAXMULT  DC    H'512'
TSEVEN   DC    H'7'       CCONSTANT USED TO DECREMENT NOTELIST ADDR
SWITCH   DC    XL2'00'
*   BIT 0      NO LENGTH INDICATOR
*   BIT 1      DENSE INDICATOR  (NOT RELATED TO TXTIO FLAG)
*   BIT 2      LOAD MODULE INDICATOR FOR DUMMY READ
*   BIT 3      NOLENGTH AND HAVE RECEIVED NEW ID   POST TRUE LEN
*   BIT 4      NOLEN CLEAN UP ON END OF ENPUT
*   BIT 1      DENSE INDICATOR  (NOT RELATED TO TXTIO FLAG)
*   BIT 2      LOAD MODULE INDICATOR FOR DUMMY READ
*   BIT 3      NOLENGTH AND HAVE RECEIVED NEW ID   POST TRUE LEN
*   BIT 4      NOLEN CLEAN UP ON END OF ENPUT
*   BIT 5      LOAD MODULE READ TO BE ISSUED
*   BIT 6      RESERVED
*   BIT 7      LAST WRITE SIGNAL WHEN GROUPING ON UT1
*   BIT 8      FLAG FOR SPECIAL LOAD MODULE TEXT SITUATION      OY00356
*   BIT 9-10   RESERVED
*   BIT 11     FLAG FOR NONGROUPED PURGE REQUIRED
*   BIT 12-15  RESERVED
HOLD1    DS    2F
DISPLAC  DC    F'0'
TXTALLOC EQU   *       USED FOR LM TO MAINTAIN ALLOC SIZE
LASTTNT  DC    F'0'               MAINTAIN LAST NOTELIST ADDR
FROMAD   DC    F'0'      START & END FOR DENSE RECORDS
TOADDR   DC    F'0'
CDISP    DC    H'0'                DISPLACEMENT IN MULTIPLICITY
RDMACRO  DC    V(HEWLERDM)
INPADD   DC    V(HEWLCINP)
ACUMLEN  DC    F'0'      WILL ACCUMULATE LENGTH OF LM RECORD TO ENABLE
LMLEN    DS    F      WILL HOLD TOTAL LENGTH OF LM INPUT RECORD
*                    RECOMPUTATION OF ASSM ADDR
RETURNAD EQU   *               SAVES RETURN WHEN PROCESS FINISHED
IDLENPTR DS    1F                  PTR TO ID-LENGTH ENTRY
CREND    DS    1F                  PTR TO END OF ID-LENGTH LIST
CONZO1   DC    F'0'      CONSTANT OF ZERO
TXTACUM  DC    H'0'
X12      DC    H'12'                    LNGTH LIMIT FOR TXT I/O OX00029
TSCNEND  DS    F      END OF SCN
HOLD3    DS    3F
***********************************************************************
*        PATCH AREA                                                   *
***********************************************************************
PATCH2   DC    50F'0',C'PATCH AREA ' FOR PROG MAINT
         HEWAPT
         END
