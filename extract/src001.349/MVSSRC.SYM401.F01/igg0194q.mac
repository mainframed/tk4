         TITLE 'IGG0194Q - BTAM OPEN LOAD 3 FOR LOCAL 3270'
IGG0194Q CSECT
*                                                              @YA02128
*              FOLLOWING CHANGES APPLIED:                      @YA02128
* C158500                                                    LD YA03953
*                                                              @YA02128
*
* STATUS - CHANGE LEVEL 000
*
* FUNCTION/OPERATION - THIS ROUTINE IS BROUGHT INTO CORE AND EXECUTED
*    WHEN THE BTAM OPEN LOAD 2 FOR 3270 ISSUES 'XCTL' TO IGG0194Q.
*    THIS ROUTINE LOADS THE REQUIRED MODULES, STORES THE ID'S OF THE
*    MODULES AND A COUNT OF MODULES LOADED INTO THE DEB, SETS UP 3270
*    ATTENTION HANDLING AND SETS UP OLT IF REQUIRED.
*
* ENTRY POINT - ENTRY IS TO THE FIRST BYTE OF THE MODULE AS A RESULT OF
*    AN XCTL TO IGG0194Q.
*
* INPUT - REGISTERS 5, 6, 7, AND 8 ARE THE INPUT
*    5 - BEGINNING OF THE DCB PARAMETER LIST
*    6 - BEGINNING OF THE WHERE-TO-GO TABLE
*    7 - ADDRESS OF THE CURRENT ENTRY IN THE DCB PARAMETER LIST
*    8 - ADDRESS OF THE CURRENT ENTRY IN THE WHERE-TO-GO TABLE.
*
* OUTPUT - THE REGISTERS WILL BE POSITIONED TO THE NEXT UNFINISHED
*    ENTRY IN THE WHERE-TO-GO TABLE.  THE REQUIRED BTAM MODULES ARE
*    LOADED.  IRB'S AND IQE'S ARE BUILT AS REQUIRED.
*
* EXTERNAL ROUTINES - ABEND (SVC 13)
*         CIRB (SVC 43)
*         LOAD (SVC 8)
*         XCTL (SVC 7)
*
* EXITS, NORMAL - THIS ROUTINE NORMALLY TERMINATES BY LOCATING THE NEXT
*    NON-ZERO ENTRY IN THE WHERE-TO-GO TABLE AND EXECUTING AN XCTL TO
*    THAT ROUTINE.
*
* EXITS, ERROR - IF THE VECTOR TABLE IN THE READ/WRITE ROUTINE
*    (IGG019MA) IS FULL AND ANOTHER ENTRY IS REQUIRED, THE TASK IS
*    ABENDED WITH A SYSTEM CODE OF 097.
*
* TABLES/WORK AREAS - THE DCB PARAMETER LIST CONTAINS THE ADDRESS OF
*    EACH DCB SPECIFIED IN THE OPEN MACRO.  THE WHERE-TO-GO TABLE
*    CONTAINS THE ID AND TTR OF THE ROUTINE NEEDED TO PROCESS THE DCB
*    CORRESPONDING TO THIS ENTRY.  THE IDTTRL TABLE CONTAINS THE ID'S
*    REQUIRED TO LOAD THE REQUIRED BTAM MODULES.
*
* ATTRIBUTES - THIS ROUTINE IS EXECUTED IN THE TRANSIENT AREA AS
*    ENABLED, PRIVELEDGED, AND REENTRANT.
*
* NOTES - THIS ROUTINE COMPLETES THE OPEN PROCESSING FOR BTAM-SUPPORTED
*    3270'S.  THEREFORE, THE WHERE-TO-GO ENTRY WILL BE SET TO ZERO.
*
         EJECT
*/*IGG0194Q: CHART */
*/* HEADER
*/*BTAM OPEN LOAD 3 FOR LOCAL 3270 DEVICES                          */
*/*IGG0194Q: E ENTRY FROM IGG0194P VIA XCTL */
*/* M ESTABLISH BASES FOR DCB AND DEB DSECTS */
*/* D (NO,,YES,GETIOB) BUFFER POOL PROVIDED BY USER? */
*/* D (YES,,NO,GETIOB) ANY BUFFERS REQUESTED? */
*/* D (NO,,YES,GETIOB) IS BUFFER LENGTH ZERO? */
*/* P ROUND BUFFER LENGTH TO NEXT FULL WORD AND STORE LENGTH IN DCB */
*/* P COMPUTE TOTAL SIZE OF BUFFERS PLUS BUFFER CONTROL BLOCK */
*/* L GETMAIN FOR BUFFER POOL */
*/* P STORE ADDRESS OF BUFFER CONTROL BLOCK IN DCB */
*/* P INITIALIZE THE BUFFER CONTROL BLOCK AND LINK BUFFERS TOGETHER */
*/*GETIOB: M OBTAIN ADDRESS OF DEB SUBID FIELD */
*/* D (YES,,NO,TESTBPM) OLT'S REQUIRED? */
*/* S LOADRTN: LOAD LOCAL 3270 OLT CONTROL RTN */
*/* S BLDIRB: BUILD IRB AND IQE'S FOR OLT */
*/* P STORE IRB ADDRESS IN IRB POINTER AREA */
*/*TESTBPM: D (YES,,NO,LOADCEA) BUFFER MANAGEMENT REQUIRED? */
*/* S LOADRTN: LOAD BUFFER MANAGEMENT ROUTINE */
*/* P STORE ADDRESS OF BUFFER MANAGEMENT ROUTINE IN DEB */
*/*LOADCEA: S LOADRTN: LOAD LOCAL 3270 CEA/XEA RTN */
*/* P STORE ADDRESS OF CEA/XEA IN DEB CEA AND XEA VECTORS */
*/* S LOADRTN: LOAD BTAM READ/WRITE ROUTINE */
*/* P STORE ADDRESS OF READ/WRITE ROUTINE IN DCB */
*/* M LOCATE DDM VECTOR TABLE */
*/*RWVDLP: D (YES,,NO,VDLPINDX) VECTOR TABLE ENTRY = ZERO? */
*/*DDMIN: P STORE INDEX TO VECTOR IN DCB */
*/* S LOADRTN: LOAD LOCAL 3270 DDM */
*/* P STORE ADDRESS AND DEVICE CODE IN VECTOR TABLE */
*/*ENBLATN: S LOADRTN: LOAD 2ND LEVEL ATTN RTN */
*/* S BLDIRB: BUILD IRB & 1 IQE FOR ATTN HANDLING */
*/* P STORE IRB ADDRESS IN ALL UCB'S OF LINE GROUP */
*/* D (YES,,NO,NORDYQ) READYQ SPECIFIED IN DCB ? */
*/* D (YES,BLDRDYRB,NO,) USER PROVIDE ROUTINE ? */
*/* S LOADRTN: LOAD BTAM'S READY EXIT ROUTINE */
*/* P FLAG USING BTAM'S ROUTINE IN DCB */
*/* P STORE ADDRESS OF ROUTINE IN DCB */
*/*BLDRDYRB: D (YES,USEUSER,NO,) USER PROVIDE ROUTINE ? */
*/* S (,RDYIRBDN) BLDIRB: BUILD IRB AND IQE'S FOR BTAM READY */
*/*USEUSER: S BLDPIRB: BUILD IRB AND IQE'S FOR USER READY */
*/*RDYIRBDN: P SET GRAF FLAGS AND STORE IRB ADDRESS IN ALL UCB'S */
*/*ENDLOAD: P CHECK ALL UCB'S FOR READY DURING OPEN */
*/*NORDYQ: P CLEAR WHERE-TO-GO ID TO INDICATE END OF OPEN */
*/* R GO TO STANDARD WHERE-TO-GO CODE */
*/*VDLPINDX: D (NO,,YES,DDMIN) VECTOR FOR LOCAL 3270? */
*/* D (NO,,YES,VDOVRFLO) END OF TABLE ENTRY? */
*/* M (,RWVDLP) INCR INDICES FOR NEXT ENTRY */
*/*VDOVRFLO: R ABEND WITH SYSTEM 097 CODE */
*/*LOADRTN: E ENTRY */
*/* P CONSTRUCT BLDL LIST ENTRY IN OPEN WORK AREA FROM IDTTRL ENTRY */
*/* D (NO,,YES,THREERCD) RTN REQUESTED = READ/WRITE RTN? */
*/*COMPL: D (NO,,YES,LONGLOAD) RTN SIZE EXCEEDS 1024 BYTES? */
*/* P LENGTH OF FIRST TEXT RCD = SIZE OF ROUTINE */
*/*LOAD: L LOAD RTN FROM SYS1.SVCLIB */
*/* P STORE ID IN CURRENT DEB SUBID ENTRY */
*/* M INCREMENT POINTER TO NEXT DEB SUBID ENTRY */
*/* R RETURN */
*/*THREERCD: P ADD X'800' TO RTN LENGTH DERIVED FROM IDTTRL*/
*/*LONGLOAD: P LENGTH OF FIRST TEXT RECORD = 1024 BYTES */
*/* P (,LOAD) MODIFY LOAD ATTRIBUTES FOR MULTIPLE TEXT RECORDS */
*/*BLDIRB: E ENTRY */
*/* P COMPUTE LENGTH OF IRB WORKAREA */
*/* L INVOKE CIRB TO BUILD IRB */
*/*IQEINIT: P INITIALIZE IQE'S AND LINK THEM TOGETHER */
*/* P SET LINK OF LAST IQE = ZERO */
*/* R RETURN */
*/*BLDPIRB: E ENTRY */
*/* P COMPUTE LENGTH OF IRB WORKAREA */
*/* L (,IQEINIT) INVOKE CIRB TO BUILD PROB PROG IRB */
*/*IGG0194Q: END */
         EJECT
*              REGISTER EQUATES
RPARM2   EQU   0                   SECOND PARAMETER REGISTER
RPARM1   EQU   1                   FIRST PARAMETER REGISTER
REVN     EQU   2                   WORK REGISTER- EVEN
RODD     EQU   3                   WORK REGISTER- ODD
RCORE    EQU   4                   POINTER TO GETMAIN'ED CORE
RPAR     EQU   5                   START OF PARAMETER LIST
RWTG     EQU   6                   START OF WTG TABLE
RPARC    EQU   7                   CURRENT ENTRY IN PARAMETER LIST
RWTGC    EQU   8                   CURRENT ENTRY IN WTG TABLE
RUCB     EQU   9                   POINTER TO UCB
RDEB     EQU   10                  POINTER TO DEB
RBASE    EQU   11                  BASE REGISTER FOR CSECT
RDCB     EQU   12                  POINTER TO DCB
RW3      EQU   13                  WORK REGISTER
RRTRN    EQU   14                  RETURN POINT REGISTER
RRTN     EQU   14
REPR     EQU   15                  ENTRY POINT REG
*
RW1      EQU   2                   ALTERNATE ASSIGNMENTS
RW2      EQU   3                       FOR WORK REGISTERS
RSUBID   EQU   9                   POINTER TO NEXT DEB SUB-ID FIELD
*
ANRDEVTP EQU   X'FE'               DCBDEVTP CODE FOR 3270
CVTAD    EQU   16
DEBAVT   EQU   28                  DISP TO VECTOR TO DEB APPENDAGE TAB
EQ       EQU   8                   CC MASK = 8
EIGHT    EQU   X'08'
FIVE     EQU   5
ONE28    EQU   128
FOUR     EQU   4
FREEPOOL EQU   X'04'                FLAG TO CLOSE TO RELEASE BUFFERS
GRAF     EQU   28                  OFFSET TO GRAPHICS STATUS   @YA02128
IQEIRB   EQU   8                   DISP TO IRB ADDR FIELD IN IQE
IQELNGTH EQU   16                  LENGTH OF AN IQE IN BYTES
IQELNK   EQU   0                   DISP TO LINK FIELD IN IQE
IQETCB   EQU   12                  DISP TO TCB ADDR FIELD IN IQE
IRBAD    EQU   28                  DISP TO IRB ADDR IN UCB EXTENSION
LOADATB  EQU   X'CB'               STANDARD LOAD ATTRIBUTES
*    REENTERABLE, ONLY LOADABLE, EXECUTABLE, ONLY ONE TEXT RECORD, NO
*    RLD RECORD, ORIGIN IS ZERO, ENTRY IS ZEROS EERO, AND CANNOT BE
*    REPROCESSED BY THE LINKAGE EDITOR.
LOADATB1 EQU   X'CA'               LOAD ATTRIBUTES FOR MODULES
*    LARGER THAN 1024 BYTES - SAME AS LOADATB BUT MORE THAN ONE
*    TEXT RECORD.
NDVTRTBL EQU   X'FF'               END OF VECTOR TABLE CODE
OLT      EQU   X'10'               DCB OLT FLAG
ONE      EQU   1
PLOFF    EQU   4                   OFFSET IN PARM LIST
RBNEXAV  EQU   96                  DISP TO IQE POINTER IN IRB
RDYOFF   EQU   X'EF'               TURN OFF READY IN OPEN FLG  @YA02128
RDYQ     EQU   32                  UCB OFFSET TO READY IRB AD  @YA02128
SEVEN    EQU   7
SIX      EQU   6
SVCDCB   EQU   84                  DISP TO DCB FOR SYS1.SVCLIB IN CVT
TENAND4  EQU   14
THREE    EQU   3
TWENTY2  EQU   22
TWENTY4  EQU   24
TWENTY5  EQU   25
TWENTY6  EQU   26
TWENTY7  EQU   27
TWO      EQU   2
VDOFFSET EQU   12                  DISP TO VECTOR TABLE IN READ/WRITE
*                                      RTN
WAOFF    EQU   32                  OFFSET OF FIRST WTG ENTRY FROM
*                                      BEGINNING OF TABLE
WGOFF    EQU   8                   OFFSET IN WTG TABLE
ZERO     EQU   0
*
*
         USING IHADCB,RDCB
         USING IECTDEB,RDEB
         USING WTG,RWTG                                          Y02947
         USING WTGENTRY,RWTGC
         BALR  RBASE,0             ESTABLISH ADDRESSABILITY FOR CSECT
         USING *,RBASE
         B     CONTIN                  BRANCH AROUND ID        @YA02128
         DC    CL8'IGG0194Q'           NAME                    @YA02128
         DC    XL2'4072'                 AND DATE
PATCH    DC    15F'0'                  PATCH AREA            LD YA03953
CONTIN   DS    0H                                              @YA02128
         L     RDCB,0(RPARC)       ADDRESSABILITY FOR DCB
         L     RDEB,DCBDEBAD       GET DEB ADDRESS
         L     RDEB,DEBAVT(RDEB)   GET START OF APPENDAGE VECTOR TABLE
*
*
*              DETERMINE IF A BUFFER POOL MUST BE OBTAINED
         CLI   DCBBUFCB+3,ONE      BUFFER POOL PROVIDED BY USER
         BNE   GETIOB               YES, GO GET IOB'S
         CLI   DCBBUFNO,ZERO        NO. ARE ANY BUFFERS REQUESTED
         BE    GETIOB               NO, BUFFER POOL NOT REQUIRED.
*                                   GO GET IOB'S
         CLC   DCBBUFL(TWO),ZEROS  BUFFER LENGTH EQUAL TO ZERO
         BE    GETIOB               YES, GO GET IOB'S
*
*              CONSTRUCT BUFFER POOL
         SR    RW1,RW1
         IC    RW1,DCBBUFNO         GET NUMBER OF BUFFERS
         LH    RW2,DCBBUFL          GET BUFFER LENGTH
         LA    RW2,THREE(RW2)       ROUND TO
         SRL   RW2,TWO                  NEXT HIGHEST
         SLL   RW2,TWO                      FULL WORD
         STH   RW2,DCBBUFL          STORE ROUNDED LENGTH IN DCB
         LR    RPARM1,RW1
         MR    RPARM2,RW2           COMPUTE SIZE OF BUFFER AREA
         LA    RPARM2,EIGHT(RPARM1) ADD 8 FOR BUFFER CONTROL BLOCK
         O     RPARM2,IOBPOOL       PLACE SUBPOOL NUMBER IN
*                                   HIGH-ORDER BYTE OF PARM REG
         L     RW3,WTGCORE-ONE      ADDR OF OPEN WORK AREA       Y02947
         USING FORCORE,RW3                                       Y02947
         MODESET KEYADDR=DXUKEY,WORKREG=14    ASSUME USER KEY    Y02947
         GETMAIN  R,LV=(0)          GET CORE FOR BUFFER POOL
         LR    RRTN,RPARM1         SAVE ADDR OF GETMAIN'ED AREA  Y02947
         STH   RW1,FOUR(RPARM1)    STORE NO. OF BUFFERS IN BUFCB
         STH   RW2,SIX(RPARM1)     STORE SIZE OF BUFFERS IN BUFCB
*              BUILD BUFFER CHAIN
         LR    RCORE,RPARM1
         LA    RPARM1,EIGHT(RPARM1) GET ADDRESS OF FIRST BUFFER
         ST    RPARM1,0(RCORE)      STORE ADDRESS OF FIRST BUFFER
*                                       IN BUFFER CONTROL BLOCK
TESTBUFC BCT   RW1,NEXTBUF          IF MORE BUFFERS, BRANCH
         ST    RW1,0(RPARM1)        ZERO LAST LINK FIELD
         MODESET EXTKEY=DATAMGT    GO BACK TO DATA MGT KEY       Y02947
         OI    DCBMACRF,FREEPOOL    TELL CLOSE TO FREE BUFFER POOL
         B     GETIOB               GO GET THE IOB'S
*
NEXTBUF  LR    RCORE,RPARM1         SAVE ADDRESS OF CURRENT BUFFER
         ALR   RPARM1,RW2           COMPUTE ADDRESS OF NEXT BUFFER
         ST    RPARM1,0(RCORE)      STORE ADDRESS OF NEXT BUFFER IN
*                                       LINK FIELD OF CURRENT BUFFER
         B     TESTBUFC            LOOP TO PROCESS NEXT BUFFER
*
GETIOB   EQU   *
         STCM  RRTN,SEVEN,DCBBUFCA STORE BUFFCB ADDRESS          Y02947
         SR    RSUBID,RSUBID
         IC    RSUBID,DEBNMEXT     GET NO. OF DEVICES IN THE LINE GROUP
         SLL   RSUBID,TWO          MULT BY 4 TO GET LENGTH OF UCB LIST
         LA    RSUBID,DEBUCBAD(RSUBID)  GET ADDRESS OF AM AREA
         IC REVN,DCBOFLGS          SAVE DCB OPEN FLAGS
         ST    RSUBID,DCBREAD      SAVE ADDRESS OF ACCESS METHOD AREA
         STC   REVN,DCBOFLGS       RESTORE DCB OPEN FLAGS
*
         SR    REVN,REVN
         IC    REVN,DEBAMLNG       GET LENGTH OF ACCESS METHOD AREA
         AR    RSUBID,REVN         ADD TO GET ADDRESS OF SUB-ID'S
*
         TM    DCBERROP,OLT        ON-LINE TESTS REQUIRED
         BNO   TESTBPM             NO, TEST FOR BUFFER MANAGEMENT RTN
         L     RCORE,DEBIRBAD-1    GET ADDRESS OF DEB IRB POINTERS
         LA    RPARM1,OLTCTL       GET ADDRESS OF IDTTRL ENTRY
         BAL   RRTRN,LOADRTN       LOAD OLT CTL MODULE
         SR    RPARM1,RPARM1
         IC    RPARM1,DEBNMEXT     NO. OF IQE'S = NO. OF DEVICES
         SLA   RPARM1,ONE               & MULTIPLY BY 2
*                                  BECAUSE EXISTING BTAM EXPECTS IT
         BAL   RRTRN,BLDIRB        BUILD IRB AND IQE'S FOR OLT
         ST    RPARM1,0(RCORE)     STORE IRB ADDRESS IN POINTER
         B     CONTINUE                                       LD Y02947
*
TESTBPM  EQU   *                                              LD Y02947
         MODESET EXTKEY=ZERO                                  LD Y02947
CONTINUE EQU   *                                              LD Y02947
         CLI   DEBAMLNG,ZERO       BUFFER MANAGEMENT REQUIRED
         BZ    LOADCEA             NO, GO LOAD CEA/XEA
         LA    RPARM1,BPMR         GET ADDRESS OF IDTTRL ENTRY
         BAL   RRTN,LOADRTN        LOAD BUFFER POOL MANAGEMENT ROUTINE
         L     REVN,DCBREAD        GET ADDRESS OF AM SECTION IN DEB
         ST    RPARM2,0(REVN)      STORE ADDR OF ROUTINE IN DEB
*
LOADCEA  LA    RPARM1,CHENDAPP     GET ADDRESS OF IDTTRL ENTRY
         BAL   RRTN,LOADRTN        LOAD CEA/XEA
         ST    RPARM2,DEBCEA       STORE RTN ADDR IN DEB VECTOR TO CEA
         ST    RPARM2,DEBXCEA          AND XEA
*
         LA    RPARM1,SIOAPPN          ADDR OF SIO APPENDAGE TTR
         BAL   RRTN,LOADRTN            LOAD SIO APPENDAGE
         ST    RPARM2,DEBSIOA          STORE ADDRESS IN DEB PREFIX
         OI    DEBSIOA,SIOFIX      FLAG PAGE FIX APP IN SIO       3876
*
         LA    RPARM1,RDWRTRTN     GET ADDRESS OF IDTTRL ENTRY
         BAL   RRTN,LOADRTN        LOAD READ/WRITE ROUTINE
         IC    REVN,DCBOFLGS       SAVE DCBOFLAGS
         ST    RPARM2,DCBREAD      STORE ADDRESS OF READ/WRITE RTN
         STC   REVN,DCBOFLGS       RESTORE OPEN FLAGS DESTROYED BY
*                                      PREVIOUS STORE.
*
         LR    RCORE,RPARM2        GET ADDR OF READ/WRITE RTN
         LA    RCORE,VDOFFSET(RCORE)    GET BEGINNING OF VECTOR TABLE
         SR    REVN,REVN           INITIALIZE INDEX COUNTER
         SR    RODD,RODD           INITIALIZE COMPARAND OF ZERO
*
RWVDLP   C     RODD,0(RCORE)       VECTOR TABLE ENTRY EQUAL ZERO
         BNZ   VDLPINDX            BRANCH IF FIELD NON-ZERO
         MVI   TWO(RCORE),ANRDEVTP MAKE FIELD NON-ZERO
DDMIN    STC   REVN,DCBDEVTP       STORE INDEX TO VECTOR IN DCB
         LA    RPARM1,DDM          GET ADDRESS OF IDTTRL ENTRY
         BAL   RRTN,LOADRTN        LOAD 3270 LOCAL DDM
         ST    RPARM2,0(RCORE)     STORE ADDRESS IN VECTOR TABLE
         MVI   0(RCORE),ANRDEVTP   STORE DEVICE TYPE CODE IN HIGH-ORDER
         MODESET EXTKEY=DATAMGT    DATAMGT KEY                LD Y02947
*                                      BYTE
         B     ENBLATN             BRANCH TO LOAD 2ND LEVEL ATTN RTN
*
VDLPINDX CLI   0(RCORE),ANRDEVTP   VECTOR FOR ANR
         BE    DDMIN               YES, USE IT
         CLI   0(RCORE),NDVTRTBL   END OF TABLE
         BE    VDOVRFLO            YES, GIVE ABEND
         LA    RCORE,FOUR(RCORE)   INCR TO NEXT ENTRY
         LA    REVN,ONE(REVN)      BUMP INDEX
         B     RWVDLP              CHECK NEXT ENTRY
*
VDOVRFLO L     RPARM1,ERR6         VECTOR DIRECTORY OVERFLOW ERROR
         ABEND (1)
*
ENBLATN  LA    RPARM1,ATNRTN2      GET IDTTRL ENTRY
         BAL   RRTN,LOADRTN        LOAD SECOND LEVEL ATTN RTN
         LA    RPARM1,TWO          NO. OF IQE'S = TWO        LD YA03953
         BAL   RRTN,BLDIRB         BUILD IRB AND IQE FOR ATTENTION
*                                  HANDLING
         LR    RW3,RSUBID          SAVE SUB ID PTR             @YA02128
         SR    REVN,REVN           INITIALIZE UCB LIST INDEX
         SR    RODD,RODD
         IC    RODD,DEBNMEXT       INITIALIZE LOOP COUNTER
         MODESET EXTKEY=ZERO       NEED KEY 0 TO STORE IN UCB    Y02947
ATNIRBLP L     RUCB,DEBUCBAD(REVN) GET UCB ADDRESS
         LA    RPARM1,0(RPARM1)    INSURE HIGH BYTE CLEAR      @YA02128
         IC    RPARM2,IRBAD(RUCB)  PICK UP GRAF FLAGS          @YA02128
         SLL   RPARM2,TWENTY4      PUT IN HIGH BYTE            @YA02128
         OR    RPARM1,RPARM2       SAVE GRAF FLAGS             @YA02128
         ST    RPARM1,IRBAD(RUCB)  STORE IRB ADDR IN UCB EXTENSION
         LA    REVN,FOUR(REVN)     INDEX TO NEXT UCB ADDRESS
         BCT   RODD,ATNIRBLP       LOOP IF NOT FINISHED
         L     RDCB,ZERO(RPARC)        POINT TO DCB
         MODESET EXTKEY=DATAMGT
         TM    DCBLERB,X'02'       ADDRESS VIA READYQ ?        @YA02128
         BNO   NORDYQ              NO, DON'T SETUP IRB         @YA02128
         L     REVN,52(RDCB)       PICK POINTER TO USER        @YA02128
*                                  SUPPLIED READY ROUTINE      @YA02128
         LA    REVN,0(REVN)        CLEAR HIGH BYTE             @YA02128
         LTR   REVN,REVN           ADDRESS SUPPLIED ?          @YA02128
         BNZ   BLDRDYRB            YES, USE IT                 @YA02128
         LR    RSUBID,RW3          RESTORE SUB ID PTR          @YA02128
         OI    DCBLERB,X'01'       FLAG USING BTAM'S           @YA02128
         LA    RPARM1,READYM       POINT TO IDTTRL             @YA02128
         BAL   RRTN,LOADRTN        LOAD READYQ - IGG019UP      @YA02128
         LR    REVN,RPARM2         GET ENTRY POINT             @YA02128
         LA    REVN,0(REVN)        CLEAR HIGH BYTE             @YA02128
         O     REVN,DCBLERB        PICK UP FLAGS               @YA02128
         ST    REVN,DCBLERB        SAVE THE ADDRESS            @YA02128
         LA    REVN,0(REVN)        CLEAR HIGH BYTE             @YA02128
BLDRDYRB EQU   *                   BUILD THE IRB               @YA02128
         LR    RPARM2,REVN         SET EP ADDRESS              @YA02128
         SR    RPARM1,RPARM1       CLEAR IQE COUNT REG         @YA02128
         IC    RPARM1,DEBNMEXT     GET NUMB IQE'S - ONE / UCB  @YA02128
         TM    DCBLERB,X'01'       USING BTAM'S ?              @YA02128
         BNO   USEUSER             NO, BUILD PP IRB            @YA02128
         BAL   RRTN,BLDIRB         BUILD A SUPR IRB            @YA02128
         MODESET EXTKEY=DATAMGT                              LD YA02128
         B     RDYIRBDN            GO SET UP UCB'S             @YA02128
USEUSER  EQU   *                   BUILD USER IRB              @YA02128
         BAL   RRTN,BLDPIRB        GO BUILD THE READY QUEUE    @YA02128
         MODESET EXTKEY=DATAMGT                              LD YA02128
RDYIRBDN EQU   *                   IRB IS BUILT                @YA02128
         SR    REVN,REVN           CLEAR A WORK REGISTER       @YA02128
         SR    RODD,RODD           CLEAR A WORK REGISTER       @YA02128
         IC    RODD,DEBNMEXT       INITIALIZE LOOP COUNTER     @YA02128
RDYIRBLP L     RUCB,DEBUCBAD(REVN) GET UCB ADDRESS             @YA02128
         MODESET EXTKEY=ZERO                                 LD YA02128
         ST    RPARM1,RDYQ(RUCB)   STORE IRB ADDRESS IN UCB    @YA02128
         TM    DCBLERB,X'01'       USING BTAM'S ?              @YA02128
         BZ    SETUSER             NO, FLAG USER               @YA02128
         OI    GRAF(RUCB),X'10'    SAY BTAM                    @YA02128
         B     TYPESET             CONTINUE                    @YA02128
SETUSER  EQU   *                   INDICATE USER ROUTINE       @YA02128
         OI    GRAF(RUCB),X'08'    SAY USER                    @YA02128
TYPESET  EQU   *                   TYPE OF ROUTINE FLAGGED     @YA02128
         MODESET EXTKEY=DATAMGT                              LD YA02128
         LA    REVN,FOUR(REVN)     INDEX TO NEXT UCB ADDRESS   @YA02128
         BCT   RODD,RDYIRBLP       LOOP IF NOT FINISHED        @YA02128
ENDLOAD  EQU   *                   BTAM OPEN DONE              @YA02128
         SR    RODD,RODD           CLEAR A WORK REGISTER       @YA02128
         SR    REVN,REVN           CLEAR A WORK REGISTER       @YA02128
         IC    RODD,DEBNMEXT       INITIALIZE LOOP COUNTER     @YA02128
CHKOPRDY EQU   *                   CHECK FOR READY DURING OPEN @YA02128
         L     RUCB,DEBUCBAD(REVN) GET UCB ADDRESS             @YA02128
         MODESET EXTKEY=ZERO                                 LD YA02128
         NI    GRAF(RUCB),X'7F'    TURN OPEN IN PROGRESS       @YA02128
         TM    GRAF(RUCB),X'40'    READY DURING OPEN ?         @YA02128
         BNO   SCHEDRET            NO, CONTINUE                @YA02128
         NI    GRAF(RUCB),X'BF'    TURN OFF OPEN READY         @YA02128
         SR    RDCB,RDCB           CLEAR EVEN REG              @YA02128
         LA    RW3,X'58'           PICK UP IOB LENGTH          @YA02128
         IC    RDCB,36(RUCB)       GET RLN FOR DEVICE          @YA02128
         MR    RDCB,RDCB           DISP INTO IOB POOL          @YA02128
         MODESET EXTKEY=DATAMGT                              LD YA02128
         L     RDCB,0(RPARC)       GET DCB ADDRESS             @YA02128
         L     RDCB,28(RDCB)       GET ADDRESS OF IOB POOL     @YA02128
         LA    RDCB,0(RW3,RDCB)    POINT TO THIS RLN'S IOB     @YA02128
         USING FORCORE,RW3          WORKAREA ADDRESSABILITY  LD YA02128
         L     RW3,WTGCORE-ONE      WORKAREA ADDRESS         LD YA02128
         MODESET KEYADDR=DXUKEY,WORKREG=13                   LD YA02128
         DROP  RW3
         NI    28(RDCB),X'7F'      TURN OFF OPEN FAILED        @YA02128
         MODESET EXTKEY=DATAMGT                              LD YA02128
         L     RDCB,0(RPARC)       RESTORE DCB ADDRESS         @YA02128
SCHEDRET LA    REVN,FOUR(REVN)     INDEX TO NEXT UCB           @YA02128
         MODESET EXTKEY=DATAMGT                              LD YA02128
         BCT   RODD,CHKOPRDY       LOOP IF NOT FINISHED        @YA02128
NORDYQ   EQU   *                   THIS LOAD FINISHED          @YA02128
         XC    0(TWO,RWTGC),0(RWTGC) CLEAR ID TO INDICATE DONE @YA02128
         L     RCORE,4(RWTGC)      WORKAREA ADDRESS           LD Y02947
         L     REPR,WTGPREFX                                     Y02947
         STM   RRTN,RDCB,IECREGSV-IECPREFX(REPR) SAVE REGS       Y02947
         IECRES INIT,DCBCOPY=FRWKAR  REFRESH USER'S DCB FROM 'COPY'
         LR    REPR,RWTG            REG SAVEAREA ADDR            YM5668
         LM    RRTN,RDCB,IECREGSV-IECPREFX(REPR)  RESTORE REGS   Y02947
         XC    0(TWO,RWTGC),0(RWTGC)  CLEAR ID TO INDICATE COMPLETION
         L     REPR,FOUR(RWTGC)    GET ADDR OF  WORK AREA        Y02947
         USING FORCORE,REPR
*
RELOOP   LA    RWTGC,WGOFF(RWTGC)  INCR CURRENT WTG REGISTER
         LA    RPARC,PLOFF(RPARC)  INCR CURRENT PARM LIST REGISTER
         CLC   0(TWO,RWTGC),AMIDCNST   IF THE NEXT WTG ENTRY REQUIRES
         BCR   EQ,RBASE            THIS EXECUTOR, EXEC MODULE AGAIN
         CLC   0(TWO,RWTGC),OPIDCNST   END OF TABLE
         BNE   RELOOP              NO, CHECK NEXT ENTRY IN TABLE
*
         LR    RPARC,RPAR          REINITIALIZE CURRENT PARM LIST REG
         LA    RWTGC,WAOFF(RWTG)       AND WTG REGISTER
*
ZCHECK   CLI   0(RWTGC),ZERO       IF ENTRY NON-ZERO,
         BNE   XCTLRTNE                GO TO TRANSFER CONTROL
         LA    RWTGC,WGOFF(RWTGC)  IF ZERO, GET NEXT ENTRY
         LA    RPARC,PLOFF(RPARC)
         B     ZCHECK                  AND CHECK IT
*
XCTLRTNE EQU   *
         LA    REPR,DXCCW12            POINT TO DOUBLE WORD LIST
         DROP  REPR
         MVC   SIX(TWO,RWTG),0(RWTGC)  MOVE ID TO NAME FIELD
         MVC   TENAND4(THREE,RWTG),TWO(RWTGC)  MOVE TTR TO WTG FIELD
         MVC   TWENTY2(SEVEN,RWTG),CONATB  RESTORE XCTL ATTRIBUTES
*                                  & LENGTH
         XCTL  DE=(RWTG),SF=(E,(15))
*
*
*        THIS SUBROUTINE IS USED TO LOAD ROUTINES FOR OPEN
*  INPUT - REGISTER 1 - ADDR OF IDTTRL ENTRY OF MODULE TO BE LOADED
*  OUTPUT - REGISTER 0 - ADDR OF THE LOADED ROUTINE
*  RETURN ADDR IN REGISTER 14
LOADRTN  MVI   TWENTY2(RWTG),LOADATB  SET STANDARD LOAD ATTRIBUTES
         MVC   SIX(TWO,RWTG),0(RPARM1)  MOVE ID TO LAST 2 BYTES OF
*                                  NAME
         MVC   TENAND4(THREE,RWTG),TWO(RPARM1)  MOVE TTR FROM TABLE
         SR    REVN,REVN
         IC    REVN,FIVE(RPARM1)   GET LENGTH IN DOUBLE WORDS
         SLL   REVN,3                  AND CONVERT TO BYTES
         ST    REVN,TWENTY4(RWTG)  STORE LENGTH IN PARM LIST
         MVC   TWENTY5(TWO,RWTG),TWENTY6(RWTG)  MOVE LENGTH
         CLC   0(TWO,RPARM1),RDWRTRTN  MOD REQUESTED = READ/WRITE RTN
         BE    THREERCD            YES, ADJUST LENGTH TO THREE RECORDS
*                                      TOTAL LENGTH OF MODULE
CMPL     CLI   FIVE(RPARM1),ONE28  IF MOD MORE THAN 128 DOUBLE WORDS
         BH    LONGLOAD                (1024 BYTES)  LONG, GO TO
*                                       SET UP LONG LOAD
         MVC   TWENTY7(TWO,RWTG),TWENTY5(RWTG)  MOVE LENGTH TO FIELD
*                                       WHICH INDICATES LENGTH OF
*                                       FIRST TEXT RECORD
LOAD     LR    RPARM2,RWTG         POINT TO PARAMETER LIST
         L     RPARM1,CVTAD        GET ADDRESS OF CVT
         L     RPARM1,SVCDCB(RPARM1)   GET ADDR OF DCB FOR SYS1.SVCLIB
         LR    RODD,RRTN           SAVE RETURN ADDRESS
         CLC   SIX(TWO,RWTG),RDWRTRTN  R/W MODULE                YM4057
         BE    LOADSVC             LOAD R/W ROUTINE FROM SVCLIB  YM4057
         CLC   SIX(TWO,RWTG),BPMR  BUFF.MNGMT RTN             LD YM5661
         BE    LOADSVC2            LOAD RTN FROM SVCLIB       LD YM5661
         LOAD  DE=(0),DCB=(1)
MOVEID   EQU   *                                                 YM4057
         MVC   0(TWO,RSUBID),SIX(RWTG)  MOVE ID TO DEB
         LA    RSUBID,TWO(RSUBID)  INCR TO NEXT SUB-ID IN DEB
         SR    REVN,REVN
         IC    REVN,DEBNMSUB       GET NO. OF SUBROUTINES LOADED
         LA    REVN,ONE(REVN)      ADD ONE
         STC   REVN,DEBNMSUB       STORE UPDATED COUNT IN DEB
PAGEFIXR EQU   *                   AOS PAGE FIX FOR APPENDS       3876
         LR    REVN,RPARM2         TEMP SAVE EP ADDRESS           3876
         SLL   RPARM1,3            SUBP OUT AND CONV TO BYTES     3876
         LA    RPARM1,PAGESIZE(RPARM1,REVN) BUMP BY PAGE SIZE     3876
         N     RPARM2,PAGEBDRY     PUT ON PAGE BOUNDRY            3876
         SLR   RPARM1,RPARM2       REMOVE EXTRA BYTES             3876
         SRL   RPARM1,PAGESHFT     GET NUMBER OF PAGES            3876
         SLL   RPARM1,24           GET SET FOR OR INTO ADDRESS    3876
         LR    RPARM2,REVN         RESTORE ADDRESS                3876
         OR    RPARM2,RPARM1       PUT FIX COUNT IN               3876
         BR    RODD                RETURN TO NSI
LOADSVC  LOAD  EPLOC=IGG019MA,DCB=(1)                            YM4057
         B     MOVEID              MOVE R/W ID                   YM4057
LOADSVC2 EQU   *                                              LD YM5661
         LOAD  EPLOC=IGG019MS,DCB=(1)                         LD YM5661
         B     MOVEID              MOVE BUFF.MNGMT ID         LD YM5661
         DS    0F                                                Y02947
PAGEBDRY DC    X'00FFF000'         AOS2 PAGE BOUNDRY MASK         3876
IGG019MA DC    C'IGG019MA'         R/W MODULE ID                 YM4057
IGG019MS DC    C'IGG019MS'         BUFF.MNGMT MODULE ID       LD YM5661
PAGESHFT EQU   12                  AOS2 PAGE SHIFT COUNT          3876
PAGESIZE EQU   4095                AOS2 PAGE SIZE -1              3876
*
THREERCD OI    TWENTY5(RWTG),EIGHT ADD X'800' TO TTR LENGTH
LONGLOAD MVC   TWENTY7(TWO,RWTG),CONATB+3  SET LENGTH OF FIRST TEXT
*                                  RECORD TO 1024 (X'400') BYTES
         MVI   TWENTY2(RWTG),LOADATB1  MODIFY ATTRIBUTES FOR MORE
*                                      THAN ONE TEXT RECORD
         B     LOAD
*
*        THIS SUBROUTINE IS USED TO BUILD AN IRB AND REQUIRED IQE'S
*        FOR OPEN
* INPUT - REGISTER 0 - ADDRESS OF THE ROUTINE ENTRY POINT TO BE USED
*         REGISTER 1 - NUMBER OF IQE'S TO BE BUILT
*
* OUTPUT - REGISTER 1 - ADDRESS OF THE INITIALIZED IRB
*
* RETURN ADDRESS PASSED IN REGISTER 14
*
BLDPIRB  EQU   *                   BUILD PP IRB                @YA02128
         LR    REVN,RPARM1         SAVE NO. IQE'S              @YA02128
         SLL   REVN,1              MULTIPLY BY TWO             @YA02128
         LA    REVN,ONE(REVN)      ADD ONE FOR LNGTH OF WKAREA @YA02128
         LR    RW3,RRTN            SAVE RETURN PTR             @YA02128
         CIRB  EP=(RPARM2),KEY=PP,MODE=PP,STAB=(RE),WKAREA=(REVN),     X
               SVAREA=YES                                      @YA02128
         B     IRBSETUP            GO SET IT UP                @YA02128
*                                                              @YA02128
BLDIRB   LR    REVN,RPARM1         SAVE NO. OF IQE'S
         SLL   REVN,1              MULTIPLY BY TWO
         LA    REVN,ONE(REVN)      ADD ONE TO GET LENGTH OF WORKAREA
         LR    RW3,RRTN                IN DOUBLE WORDS
         CIRB  EP=(RPARM2),KEY=SUPR,MODE=SUPR,STAB=(RE),WKAREA=(REVN)
*
IRBSETUP EQU   *                                               @YA02128
         SRL   REVN,1              GET NUMBER OF IQE'S
         LA    RODD,RBNEXAV(RPARM1)    GET ADDR OF IRB'S IQE POINTER
         LR    RRTN,RW3            RESTORE RETURN ADDRESS
         L     RPARM2,DEBTCBAD-1   GET TCB ADDRESS
         LA    RW3,FOUR(RODD)
IQEINIT  EQU   *
         MODESET EXTKEY=ZERO       KEY ZERO                   LD Y02947
         ST    RW3,IQELNK(RODD)    STORE ADDR OF NEXT IQE IN CURRENT
*                                      LINK
         ST    RPARM1,IQEIRB(RW3)  STORE IRB ADDR IN IQE
         ST    RPARM2,IQETCB(RW3)  STORE TCB ADDR IN IQE
         MVI   IQETCB(RW3),ZERO    CLEAR HIGH ORDER BYTE
         LR    RODD,RW3            SAVE ADDR OF THIS IQE
         LA    RW3,IQELNGTH(RW3)   STEP TO NEXT
         BCT   REVN,IQEINIT        LOOP IF MORE TO DO
         ST    REVN,IQELNK(RODD)   ZERO LINK FIELD OF LAST IQE
*
         BR    RRTN                RETURN TO CALLING POINT
*
*
AMIDCNST DC    C'4Q'               ID OF THIS EXECUTOR
OPIDCNST DC    C'0S'               ID OF LAST OPEN LOAD
         DS    0F                  FORCE FULL WORD ALIGNMENT
ZEROS    DC    F'0'                WORD OF ZEROS
ECB      DC    F'0'                    ECB FOR PAGE FIX
IOBPOOL  DC    X'FA000000'         SUBPOOL NO. FOR IOB'S AND BUFFERS
ERR6     DC    X'80097000'         ABEND CODE FOR VECTOR TABLE OVERFLOW
CONATB   DC    X'C3780004000400'   XCTL ATTRIBUTES AND LENGTH
*
*        IDTTRL TABLE FOR THE BTAM ROUTINES USED FOR THE LOCAL 3270.
*    EACH ENTRY CONSISTS OF THE LAST TWO CHARACTERS OF THE MODULE NAME,
*    THE RELATIVE TRACK AND RECORD ADDRESS OF THE CORRESPONDING LOAD
*    MODULE ON SYS1.SVCLIB, AND THE LENGTH OF THE MODULE IN DOUBLE
*    WORDS. THE TTR AND LENGTH ARE INSERTED BY THE IEHIOSUP UTILITY
*    DURING STAGE 2 OF SYSGEN. IF ANY OF THESE MODULES ARE CHANGED,
*    REPLACED, OR MOVED, IEHIOSUP MUST BE EXECUTED AGAIN.
*
ONEPAGE  EQU   X'02'    NUMBER OF PAGES A ONE PAGE MODULE MAY SPAN
SIOFIX   EQU   X'80'    INDICATES EXISTENCE OF PAGE FIX APPENDAGE
NENT     EQU   8                   NUMBER OF IDTTRL'S          @YA02128
LENGTH   EQU   NENT*6+6                LENGTH OF IDTTRL'S
NODBWDS  EQU   (LENGTH+7)/8            DBL WORDS WITH PADDING
RDWRTRTN DC    C'MA',XL4'0'        READ/WRITE RTN
BPMR     DC    C'MS',XL4'0'        BUFFER POOL MANAGEMENT RTN
CHENDAPP DC    C'PA',XL4'0'        LOCAL 3270 CEA/XEA RTN
ATNRTN2  DC    C'PG',XL4'0'        LOCAL 3270 SECOND LEVEL ATTN RTN
DDM      DC    C'PH',XL4'0'        LOCAL 3270 DEVICE DEPENDENT MODULE
OLTCTL   DC    C'PI',XL4'0'        LOCAL 3270 OLT CONTROL RTN
READYM   DC    C'UP',XL4'0'        LOCAL 3270 READY ROUTINE    @YA02128
SIOAPPN  DC    C'LP',XL4'0'            START I/O APPENDAGE
IDEND    DC    XL2'0'              END OF IDTTRL TABLE
         CNOP  4,8                 PADDING
LOADID   DC    C'019'              OPEN SVC CODE
         DC    YL1(X'80'-NODBWDS)  POINTER FOR IEHIOSUP
*
*        END OF IDTTRL TABLE
*
         DCBD  DSORG=BX,DEVD=BS
         IECTDEBX
         IECDSECS MAIN,WTG,PREFX,CVT,EXPAND=YES
         IHAPSA
         END
