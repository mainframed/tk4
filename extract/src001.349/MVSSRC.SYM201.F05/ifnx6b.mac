* /* START OF SPECIFICATIONS ****
*02* PROCESSOR = ASSEMBLER
**** END OF SPECIFICATIONS ***/
         MACRO
         BLDPRM &SW,&PARM
.*  THIS MACRO IS USED TO BUILD THE ASSEMBLER OPTIONS PRINT LINES FOR
.*   THE STATISTICS PRINT ROUTINE.
         GOIF  &SW,ON=MV&PARM           CHECK OPTION SWITCH
         EX    R0,MVNO                  IF OFF MOVE IN THE WORD NO
         LA    COUNT,L'NO(COUNT)        BUMP PRINT LINE INDEX
MV&PARM  LA    R2,P&PARM                GET ADDRESS AND
         LA    R1,L'P&PARM.-D1(R0)          LENGTH OF PARM
         EX    R1,MVPARM                MOVE IN PARM
         AR    COUNT,R1                 BUMP PRINT LINE INDEX
         LA    COUNT,D1(COUNT)          ADD 1 TO PRINT LINE INDEX
         MEND
         SPACE 5
         GBLC  &COMPNM,&ASMID           GLOBAL VARIABLES
         SPACE 5
         JHEAD 'DIAGNOSTIC PHASE - PROLOG',                            C
               PHASEID=X6B,                                            C
               LEVEL=10
*FUNCTION/OPERATION-                                                  *
*   THE DIAGNOSTIC PROCESSOR PHASE DECODES ERROR RECORDS AND LISTS    *
*   THE ASSOCIATED ERROR MESSAGES COMPLETE WITH DATA APPENDED TO THE  *
*   ERROR RECORDS INSERTED INTO THE MESSAGES AT THE POINTS NECESSARY  *
*   FOR INTELLEGENT READING.  IF THE RELOCATABLE YCON OR RE-ENTRANT   *
*   TEST FAILURE FLAGS ARE SET, THEIR ASSOCIATED WARNINGS ARE ALSO    *
*   LISTED.  OPTION STAT PRODUCES THE FOLLOWING STATISTICS AT THE     *
*   END OF THE ASSEMBLY LISTING-                                      *
*                                                                     *
*   1.  HIGHEST SEVERITY CODE ENCOUNTERED (IF ANY).                   *
*   2.  OPTIONS FOR THE ASSEMBLY.                                     *
*   3.  TOTAL RECORDS READ FROM SYSIN.                                *
*   4.  TOTAL RECORDS READ FROM SYSLIB.                               *
*   5.  TOTAL LINES PRINTED.                                          *
*   6.  TOTAL CARDS PUNCHED.                                          *
*                                                                     *
*   FINALLY IF  OPTION DECK IS EXERCISED AND THE ASSEMBLY HAS         *
*   PRODUCED OBJECT OUTPUT, AN END CARD WILL BE PUNCHED CONTAINING    *
*   THE FOLLOWING INFORMATION-                                        *
*                                                                     *
*   COLUMNS         CONTENTS                                          *
*     1             12-2-9 PUNCH                                      *
*     2-4           END                                               *
*     5             BLANK                                             *
*     6-8           ENTRY ADDRESS FROM SOURCE DECK END CARD OPERAND   *
*                   (BLANK IF NO OPERAND)                             *
*     9-14          BLANK                                             *
*     15-16         ESDID OF ENTRY POINT (BLANK IF NO OPERAND)        *
*     17 - 32       BLANK                                             *
*     33            NUMBER OF IDR ITEMS FOLLOWING                     *
*     34 - 43       TRANSLATOR IDENTIFICATION, PADDED                 *
*     44 - 45       VERSION LEVEL OF PROCESSOR                        *
*     46 - 47       MODIFICATION LEVEL OF PROCESSOR                   *
*     48 - 49       LAST TWO DIGITS OF YEAR                           *
*     50 - 52       DAY OF YEAR                                       *
*     53 - 71       SAME AS 34 - 52 FOR SECOND IDR IF PRESENT         *
*     72            BLANK                                             *
*     73-76         DECK ID (FROM FIRST TITLE CARD)                   *
*     77-80         CARD SEQUENCE NUMBER                              *
*                                                                     *
*                                                                     *
*                                                                     *
*                                                                     *
*ENTRY POINT-                                                         *
*   BEGIN                                                             *
*                                                                     *
*                                                                     *
*INPUT-                                                               *
*   ERROR RECORDS.  THE RECORD FORMAT IS-                             *
*                                                                     *
*   BYTE       CONTENTS                                               *
*   0-1        RECORD LENGTH                                          *
*   2          FLAG A                                                 *
*   3          FLAG B                                                 *
*   4          INTERNAL OP CODE                                       *
*   5          COLUMN POINTER                                         *
*   6-7        ERROR NUMBER CODE                                      *
*   8-9        STATEMENT NUMBER                                       *
*   10         NUMBER OF APPENDED 8-BYTE DATA ITEMS (MAXIMUM 10)      *
*   11-90      APPENDED 8-BYTE DATA ITEMS                             *
*                                                                     *
*OUTPUT-                                                              *
*   ERROR MESSAGES, NUMBER OF STATEMENTS FLAGGED, AND ASSEMBLY        *
*   STATISTICS WRITTEN TO THE PRINT FILE.  END CARD WRITTEN TO THE    *
*   PUNCH FILE.                                                       *
*                                                                     *
*EXTERNAL ROUTINES-                                                   *
*   N/A                                                               *
*EXITS, NORMAL-                                                       *
*   JRETURN                                                           *
*                                                                     *
*EXITS, ERROR-                                                        *
*   NONE                                                              *
*                                                                     *
*ATTRIBUTES-                                                          *
*   REFRESHABLE                                                       *
*                                                                     *
*                                                                     *
*                                                                     *
         SPACE 3
         PRINT OFF                      DON'T PRINT JCOMMON COPY CODE
         COPY  JCOMMON
         PRINT OFF                      DON'T PRINT JTEXT COPY CODE
         COPY  JTEXT
         PRINT OFF                      DON'T PRINT JERRCD COPY CODE
         COPY  JERRCD
         PRINT ON                       THAT'S ALL THE COPY CODE
         SPACE 2
    TITLE '&COMPNM&ASMID - DIAGNOSTIC PHASE - X6B COMMON AREA (X6BCOM)'
X6BCOM   DSECT                          X6B COMMON AREA
STRTCOM  DS    0D                       START OF X6B COMMON
DWORD1   DS    D                        DOUBLEWORD1
DWORD2   DS    D                        DOUBLEWORD2
DBLWD1   DS    D                        WORK
DBLWD2   DS    0D                           AREAS
         DS    CL3
CSTMT    DS    0CL5                     CONVERTED STATEMENT NUMBER
         DS    C
CERROR   DS    0CL4                     CONVERTED ERROR CODE
CPAGE    DS    0CL4                     CONVERTED PAGE NUMBER
         DS    CL1
CCOLPTR  DS    CL3                      CONVERTED COLUMN POINTER
SAVERTN1 DS    F                        SAVE AREAS FOR
SAVERTN2 DS    F                             RTN REGISTER
SVPRTBAS DS    F                        PRINT BUFFER BASE SAVE AREA
ERDATADR DS    F                       SAVE AREA FOR APPENDED DATA ADDR
FLDSAVE  DS    F                        SAVE AREA
STRADR   DS    F                        STRING ADDRESS
LSTMTNO  DS    F                        LAST STATEMENT NUMBER SAVE AREA
PGLINES  DS    H                        LINES PRINTED ON CURRENT PAGE
ERRQTY   DS    H                        COUNT OF STATEMENTS FLAGGED
CDSTMT   DS    H                        CARD WITHIN STMT
HWD      DS    H                        HALFWORD SAVE AREA
COLSAV   DS    H                        COLUMN SAVE AREA
SWITCHES DSW   STATSW,                  TO CONTROL STMT-ERROR-MSG HDNG X
               NOBLK,                   LEFT ZERO SUPPRESSION CONTROL  *
               ERRSW,                   UNDEFINED ERROR CODE SWITCH    X
               ERLIT,                   ERROR AFTER LITERAL            X
               COLOVLP                  COLUMN OVERLAP CHECK BIT
CARDP    DSW   CDPTR1                   CARD PTR FLAG
TSPRINT  EQU   12                       TSO PRINT
SEVCDE   DS    C                        SEVERITY CODE SAVE AREA
PRTLNSAV DS    CL120                    PRINT LINE SAVE AREA
BUFTERM  DS    31F                      124 BYTES FOR TERMINAL BUFFER
MNDX     EQU   R2                      MESSAGE INDEX
MTABPTR  EQU   R3                      MTABLE BASE
COUNT    EQU   R4                       COUNTING REGISTER
RTN      EQU   R5                       INTERNAL RETURN LINKAGE
INBASE   EQU   R6                       JGETL BUFFER BASE REGISTER
FILEREG  EQU   R10                      JGETL FILENAME PARAMETER REG
MSGLN    EQU   R10                     MESSAGE LENGTH
PRTBASE  EQU   R11                      PRINT BUFFER BASE REGISTER
EJCT     EQU   X'00'                    EJECT THEN PRINT
SPACE1   EQU   X'01'                    SINGLE SPACE THEN PRINT
SPACE2   EQU   X'02'                    DOUBLE SPACE THEN PRINT
SPACE3   EQU   X'03'                    TRIPLE SPACE THEN PRINT
ENDCOM   EQU   *                        END OF X6BCOM COMMON AREA
    TITLE '&COMPNM&ASMID - DIAGNOSTIC PHASE - TERMINAL BUFFER DSECT ANDX
                JTEXTA DSECT'
TERMBUF  DSECT
BUFC     DS    C                        BUFFER RECORD LENGTH
PRTIMG   DS    0CL120                   LENGTH OF PRINTLINE
SEQNO    DS    CL8                      SEQUENCE NUMBER
BLNK1    DS    CL4                      BLANKS
STMTNO   DS    CL5                      STMT NUMBER
GENFLG   DS    CL1                      GENERATED STMT FLAG
SOURCE   DS    CL80                     SOURCE IMAGE
         ORG   SOURCE+72
SEQNUM   DS    CL8                      SEQ NUM FROM SOURCE
         ORG   PRTIMG
ERCDE    DS    CL6                      ERROR CODE
BLNK2    DS    CL1                      BLANK
ERMSG    DS    CL101                    ERROR MESSAGE
         SPACE 5
JTEXTA   DSECT                          JTEXTA DSECT
         ORG   JTOCO
OPTR     DSW   CDPTR                    CARD PTR FLAG
         ORG   JTOCO                    REORG FOR OTHER PTRS
OCPTR    DS    C                        OUTPUT COLUMN PTR
LENGTH   DS    C                        LENGTH OF FIELD
FIELD    EQU   *                        FIELD IN TEXT RECORD
         SPACE 3
         TITLE '&COMPNM&ASMID - DIAGNOSTIC PHASE - PRINT BUFFER DSECT AX
               ND PUNCH BUFFER DSECT'
*                             GENERAL MESSAGE LINE HEADING
PRTBUF   DSECT
         USING PRTBUF,R11               USING FOR ALL PRINT LINES
CNTRL    DS    C                        CONTROL BYTE
PRTLINE  DS    0CL120                   GENERAL PURPOSE PRINT LINE
         DS    CL19
MSGBEG   DS    CL101                    MESSAGE BEGINING
*
*                             PAGE HEADING FORMAT
*
         ORG   PRTLINE
HLDIAG2  DS    0C                      STMT - ERROR-CODE - MESSAGE
HLTITLE  DS    CL4                      TITLE ID
         DS    CL46
HLDIAG   DS    CL11                     DIAGNOSTIC HEADING
         DS    CL35
HLDATE   DS    CL15                     DATE
HLPAGE   DS    CL4                      PAGE
         DS    C
HLPGENO  DS    CL4                      PAGE NUMBER
*
*                             ERROR MESSAGE FORMAT
*
         ORG   PRTLINE
ELSTMTNO DS    CL5                      ERROR STATEMENT NUMBER
         DS    CL2
ELERPFIX DS    CL2                      COMPONENT PREFIX
ELERRCDE DS    CL4                      ERROR CODE
         DS    CL6
ELERMSG  DS    CL101                    BEGINING OF ERROR MESSAGE
         SPACE 3
PCHBUF   DSECT
PCNTRL   DS    C                        12-2-9 PUNCH
PCLINE   DS    0CL71                    PUNCH LINE
PCEND    DS    CL3                      END
         DS    C                        BLANK
PCENTAD  DS    CL3                      ENTRY FROM SOURCE END CD OPND
         DS    CL6                      BLANK
PCESDID  DS    CL2                      ESDID OF ENTRY POINT
         DS    CL16                    BLANK
PCCOMP   DS    CL(L'JIDR)              IDR
MTBLE    DSECT
MADDR    DS    H                        MESSAGE ADDRESS
MLN      DS    H                        MOVE LENGTH OF MESSAGE
         SPACE 2
    TITLE '&COMPNM&ASMID - DIAGNOSTIC PHASE '
         JCSECT (X6B00)
* VS1 RELEASE 5.0 CHANGES
*A560304,680370                                                @OX09734
*C669600                                                       @OX09734
*A664600                                                       @OX12916
*A557024,557028,557081-557083,667520,600400-600820             @AZ13738
*A681400,560305-560408                                         @AZ13738
*C681700,680370                                                @AZ13738
         JMODID
***********************************************************************
*              THIS IS THE MAIN LINE OF THE PHASE.  IT PERFORMS ANY   *
*              INITIALIZATION NECESSARY AND CHECKS THE OPTIONS        *
*              DESIRED (LIST, DECK, LINK).  IF NONE OF THESE OPTIONS  *
*              ARE REQUESTED, IT TERMINATES.  IN ADDITION, IF THE     *
*              FLAG IS SET TO INDICATE THE PRESENCE OF A RELOCATABLE  *
*              YCON, THAT MESSAGE IS CREATED.  IT THEN CHECKS THE     *
*              ERROR FLAG FOR OTHER ERRORS.  IF IT IS OFF, CONTROL IS *
*              PASSED TO THE NO-ERROR ROUTINE.  OTHERWISE IT BEGINS   *
*              GETTING RECORDS FROM THE INPUT FILE AND CHECKING THEM  *
*              FOR END-OF-DATA OR ERROR-RECORD FLAGS.  IF NEITHER OF  *
*              THESE FLAGS IS PRESENT, IT GETS ANOTHER RECORD.  OTHER-*
*              WISE IT TRANSFERS CONTROL TO THE APPROPRIATE SUBROUTINE*
***********************************************************************
BEGIN    JSAVE
         JENTRY (X6B01=BEGIN)
         USING X6BCOM,R7                USING FOR X6B COMMON
         LA    R10,(ENDCOM-STRTCOM+D7)/D8 SIZE OF COMMON
         JGETCORE DBL=(R10)
         LR    R7,R10                   BASE FOR X6B COMMON
         LA    R15,D1(R0)               INIT LINE CNT TO FORCE PG HDNG
         STH   R15,PGLINES               ON FIRST PRINT ATTEMPT
         L     R0,=H'-1'
         ST    R0,LSTMTNO               SET TO NEG TO COUNT STMT 0 ERR
         SR    R0,R0                    CLEAR REGISTER
         ST    R0,JFWORD1               CLEAR WORK AREA
         STH   R0,ERRQTY                INITIALIZE ERROR COUNT TO ZERO
         MVC   SEVCDE(L'SEVCDE),JSEVER  AND SEVERITY CODE
         STC   R0,SWITCHES              SET ALL SWITCHES TO OFF
         GOIF  (JDECK,JLINK),NONE=NPCH  IF NODECK NOLINK SKIP END CARD
         GOIF  JENDCHK,OFF=NPCH         IF END CARD SW OFF DONT PCH
         BAL   RTN,PUNCHEC                  ELSE GO TO END CARD ROUTINE
NPCH     GOIF  JTERM,OFF=SKTERM1        BRANCH IF TERM OFF
         USING TERMBUF,R11              SET UP USING FOR TERM BUFEER
         BAL   RTN,BUFINIT              INITIALIZE BUFFER
         MVI   BUFC,EJCT                MAKE A NEW PAGE
         MVC   PRTIMG(L'ASMXF),ASMXF    PRINT XF DONE MESSAGE
         JTPRINT                        GET TERMINAL BUFFER
         BAL   RTN,BUFINIT              CLEAR BUFFER
SKTERM1  EQU   *                        BRANCH LABEL
         USING PRTBUF,R11               SET UP USING FOR PRINTBUF
         LA    R11,BUFTERM              PT TO TERM BUF INCASE NOLIST
         GOIF  JLIST,OFF=NPRT           BRANCH IF LIST OFF
         JPRINT
NPRT     GOIF  (JMISLIN,JMISPCH,JINVOPT,JMISPRT,JMISTERM,JMISLIB),     *
               NONE=REYCONCK                 CHECK FOR JCL ERRORS
         GOIF  JMISLIB,OFF=CKLDDER      SYSLIB DD CARD MISSING
         MVC   ELERRCDE+1(L'ELERRCDE-1),=AL1(J2,J6,J9)  SET UP ERR CDE
         MVC   ELERPFIX(L'JPREFIX),JPREFIX               AND PREFIX
         MVC   ELERMSG(L'S269),S269     MOVE MESSAGE TO PRINT LINE
         BAL   RTN,TERMERR              PRINT ON SYSTERM TOO
         BAL   RTN,PRINT                GO TO PRINT ROUTINE
         CLI   SEVCDE,X'10'             IS SEVCDE HIGHER THAN 16
         BNL   CKLDDER                  YES - DON'T SAVE SEV CODE
         MVI   SEVCDE,X'10'             NO - SAVE SEV CODE
         SPACE
CKLDDER  GOIF  JMISLIN,OFF=CKPRTER      SYSLIN DD CARD ERROR TEST
         MVC   ELERRCDE+1(L'ELERRCDE-1),=AL1(J2,J5,J6)  SET UP ERR CDE
         MVC   ELERPFIX(L'JPREFIX),JPREFIX         AND PREFIX
         MVC   ELERMSG(L'S256),S256     MOVE MESSAGE TO PRINT LINE
         BAL   RTN,TERMERR              PRINT ON SYSTERM IF SO
         BAL   RTN,PRINT                GO TO PRINT ROUTINE
         CLI   SEVCDE,X'10'             IS SEV CODE HIGHER THAN 16
         BNL   CKPRTER                  YES - DON'T SACE SEV CODE
         MVI   SEVCDE,X'10'             NO - SAVE SEVERITY CODE
         SPACE
CKPRTER  GOIF  JMISPRT,OFF=CKPDDER      SYSPRINT DD CARD ERROR TEST
         MVC   ELERRCDE+1(L'ELERRCDE-1),=AL1(J2,J6,J7) SET UP ERR CODE
         MVC   ELERPFIX(L'JPREFIX),JPREFIX       AND PREFIX
         MVC   ELERMSG(L'S267),S267     MOVE MSG TO PRINT LINE
         BAL   RTN,TERMERR              PRINT ON SYSTERM IF SO
         BAL   RTN,PRINT                GO TO PRINT ROUTINE
         CLI   SEVCDE,X'10'             IS SEV CODE HIGHER THAN 16
         BNL   CKPDDER                  YES - DONT SAVE SEV CODE
         MVI   SEVCDE,X'10'             NO - SAVE SEVERITY CODE
         SPACE
CKPDDER  GOIF  JMISPCH,OFF=CKTDDER      SYSPUNCH DD CARD ERROR TEST
         MVC   ELERRCDE+1(L'ELERRCDE-1),=AL1(J2,J5,J7)  SET UP ERR CDE
         MVC   ELERPFIX(L'JPREFIX),JPREFIX         AND PREFIX
         MVC   ELERMSG(L'S257),S257     MOVE MESSAGE TO PRINT LINE
         BAL   RTN,TERMERR              PRINT ON SYSTERM IF SO
         BAL   RTN,PRINT                GO TO PRINT ROUTINE
         CLI   SEVCDE,X'10'             IS SEV CODE HIGHER THAN 16
         BNL   CKTDDER                  YES - DON'T SAVE SEV CODE
         MVI   SEVCDE,X'10'             NO - SAVE SEVERITY CODE
         SPACE
CKTDDER  GOIF  JMISTERM,OFF=CKOPTER     SYSTERM DD CARD MISSING
         MVC   ELERRCDE+1(L'ELERRCDE-1),=AL1(J2,J6,J8)  SET UP ERR CDE
         MVC   ELERPFIX(L'JPREFIX),JPREFIX         AND PREFIX
         MVC   ELERMSG(L'S268),S268     MOVE MESSAGE TO PRINT LINE
         BAL   RTN,TERMERR              PRINT ON SYSTERM IF SO
         BAL   RTN,PRINT                GO TO PRINT ROUTINE
         CLI   SEVCDE,X'10'             IS SEV CODE HIGHER THAN 16
         BNL   CKOPTER                  YES - DON'T SAVE SEV CODE
         MVI   SEVCDE,X'10'             NO - SAVE SEVERITY CODE
         SPACE
CKOPTER  GOIF  JINVOPT,OFF=REYCONCK     INVALID OPTION ERROR TEST
         MVC   ELERRCDE+1(L'ELERRCDE-1),=AL1(J2,J5,J8)  SET UP ERR CDE
         MVC   ELERPFIX(L'JPREFIX),JPREFIX         AND PREFIX
         MVC   ELERMSG(L'S258),S258     MOVE MESSAGE TO PRINT LINE
         BAL   RTN,TERMERR              PRINT ON SYSTERM IF SO
         BAL   RTN,PRINT                GO TO PRINT ROUTINE
         CLI   SEVCDE,X'10'             IS SEV CODE HIGHER THAN 16
         BNL   REYCONCK                 YES - DON'T SAVE SEV CODE
         MVI   SEVCDE,X'10'             NO - SAVE SEVERITY CODE
         SPACE
REYCONCK GOIF  JESDOFLO,OFF=YCONCHK     BRANCH IF NO ESDID OVERFLOW
         MVC   ELERRCDE+D1(L'ELERRCDE-D1),=AL1(J2,J6,J4) SETUP ERR CODE
         MVC   ELERPFIX(L'JPREFIX),JPREFIX  SETUP PREFIX
         MVC   ELERMSG(L'S264),S264     MOVE MSG TO PRINT LINE
         BAL   RTN,TERMERR              PRINT ON SYSTERM IF SO
         BAL   RTN,PRINT                GO TO PRINT ROUTINE
         CLI   SEVCDE,X'10'             IS SEV CODE HIGHER THAN 16
         BNL   YCONCHK                  YES - DON'T SAVE SEV CODE
         MVI   SEVCDE,X'10'             NO - SAVE SEVERITY CODE
         SPACE
YCONCHK  GOIF  JYCON,OFF=ERRCHK         IF YCON SW OFF GO TEST ERROR SW
         MVC   ELERRCDE+1(L'ELERRCDE-1),=AL1(J2,J5,J9)  SET UP ERR CDE
         MVC   ELERPFIX(L'JPREFIX),JPREFIX         AND PREFIX
         MVC   ELERMSG(L'S259),S259     MOVE MESSAGE TO PRINT LINE
         BAL   RTN,TERMERR              PRINT ON SYSTERM IF SO
         BAL   RTN,PRINT                GO TO PRINT ROUTINE
         CLI   SEVCDE,X'04'             IS SEV CODE HIGHER THAN 4
         BH    ERRCHK                   YES - DON'T SAVE SEV CODE
         MVI   SEVCDE,X'04'             NO - SAVE SEVERITY CODE
ERRCHK   EQU   *
         TM    JPRTONLY,JPRONLY         SYMBOL TABLE OVERFLOWED
         BZ    ERRCHK1                  BRANCH IF NOT
         MVC   ELERRCDE+D1(L'ELERRCDE-D1),=AL1(J2,J6,J5) SETUP ERRCDE
         MVC   ELERPFIX(L'JPREFIX),JPREFIX    AND PREFIX
         MVC   ELERMSG(L'S265),S265     MOVE MSG TO PRINT LINE
         BAL   RTN,TERMERR              PRINT ON SYSTERM IF SO
         BAL   RTN,PRINT                GO PRINT MSG
         CLI   SEVCDE,X'10'             IS SEV CODE HIGHER THAN 16
         BNL   ERRCHK1                  YES - DON'T SAVE SEV CODE
         MVI   SEVCDE,X'10'             NO - SAVE SEVERITY CODE
ERRCHK1  EQU   *                        BRANCH LABEL
         GOIF  JERRCHK,OFF=NOERR        IF NO ERRORS GO TO NO ERROR RTN
GETRCD   EQU   *
         LH    FILEREG,JINFILE          GET NAME OF INPUT FILE
         ST    PRTBASE,SVPRTBAS         SAVE PRINT BUFFER BASE REG
         JGETL FILE=(FILEREG)
         LR    INBASE,R11               ESTABLISH BASE FOR INPUT RCD
         USING JERRCD,INBASE            USING FOR INPUT RECORD
         L     PRTBASE,SVPRTBAS         RESTORE PRINT BUFFER BASE REG
         GOIF  JEEOF,EQ=EODRTN          CHECK FOR END-OF-DATA FLAG
         GOIF  JTERM,OFF=GETRCD1        TSO ON?
         CLI   D4(INBASE),JT            IS IT A TEXT RECORD
         BNE   GETRCD1                  BRANCH IF NOT EQUAL
         LH    R1,D14(,INBASE)          GET STRING POINTER
         AR    R1,INBASE                POINT TO STRING GROUP
         ST    R1,STRADR                SAVE STRING GROUP POINTER
         MVC   CDSTMT,=H'1'             RESET CARD-WITHIN-STMT
         JCALL PRINTEXT                 CALL PRINT TEXT RECORD
         L     PRTBASE,SVPRTBAS         RE-RESTORE PRINT BUF BASE REG
         SET   ERLIT,OFF                RESET ERROR-AFTER LITERAL BIT
         B     GETRCD                   GO GET NEXT RECORD
GETRCD1  EQU   *                        BRANCH LABEL
         GOIF  JEOPCOD,NE=GETRCD2       IS IT ERROR RECORD?
         BAL   RTN,ERRORTN              GO PROCESS ERROR RECORD
         B     GETRCD                   GET NEXT RECORD
GETRCD2  EQU   *                        BRANCH LABEL
         GOIF  JTERM,OFF=GETRCD         TSO ON?
         CLI   D4(INBASE),JY            IS IT A LITERAL XREF
         BNE   GETRCD                   BRANCH TO GET RECORD IF NOT
         CLI   D4(INBASE),BIT6          IS IT LITERAL REFERENCE
         BE    GETRCD                   YES,GO GET NEXT RECORD
         SET   ERLIT,ON                 START OF LITERALS
         B     GETRCD                   GET NEXT RECORD
BUFINIT  EQU   *                        INITIALIZE BUFFER
         USING TERMBUF,R11              USING FOR TERMINAL BUFFER
         LA    R11,BUFTERM              GET ADDRESS OF BUFFER
         MVI   BUFC,SPACE1              DO SINGLE SPACE
         MVI   PRTIMG,JBLANK            SET 1ST CHAR TO BLANK
         MVC   PRTIMG+D1(L'PRTIMG-D1),PRTIMG  BLANK OUT BUFFER
         BR    RTN                      RETURN TO CALLER
EODRTN   EQU   *
         USING PRTBUF,R11               SET UP USING FOR PRINTBUF
         B     STATRTN                  GO TO STATISTICS ROUTINE
         EJECT
ERRORTN  EQU   *
*              THIS ROUTINE RECEIVES CONTROL FROM THE MAIN LINE ONLY  *
*              IF THE ERROR FLAG (JERRCHK) IS ON.  IT PERFORMS THE    *
*              FOLLOWING FUNCTIONS-                                   *
*                                                                     *
*                  1.  INCREMENT COUNT OF STATEMENTS FLAGGED.         *
*                  2.  STORE HIGHEST SEVERITY CODE FROM ERROR RECORDS.*
*                  3.  SET UP PRINT LINE WITH STATEMENT NUMBER, ERROR *
*                      CODE AND COMPONENT PREFIX, AND ERROR MESSAGE.  *
*                  4.  INSERT A COLUMN POINTER OR APPENDED DATA FROM  *
*                      ERROR RECORD WHERE INDICATED IN MESSAGE.       *
*                  5.  TRANSFER CONTROL TO THE PRINT ROUTINE.         *
*                  6.  RETURN TO MAIN LINE.                           *
*                                                                     *
*              INPUT-                                                 *
*                                                                     *
*                  1.  ERROR RECORD POINTED TO BY INBASE.             *
*                  2.  OUTPUT BUFFER POINTED TO BY PRTBASE.           *
***********************************************************************
         ST    RTN,SAVERTN1             SAVE RETURN LINKAGE
         MVC   JFWORD1+D4-L'JESTMTNO(L'JESTMTNO),JESTMTNO  GET
         L     COUNT,JFWORD1            STATEMENT NUMBER
         C     COUNT,LSTMTNO            IF SAME STATEMENT NUMBER
         BE    NOCOUNT                     DON'T COUNT IT AGAIN
         ST    COUNT,LSTMTNO            ELSE SAVE IT IF DIFFERENT
         LH    R0,ERRQTY                INCREMENT NUMBER OF STATEMENTS
         AH    R0,=H'01'                 FLAGGED AND
         STH   R0,ERRQTY                   STORE IT BACK
         SPACE
NOCOUNT  BAL   RTN,CONVERT              CONVERT IT
         MVC   ELSTMTNO(L'CSTMT),CSTMT      MOVE IT TO PRINT LINE
CONTINUE SR    COUNT,COUNT              CLEAR COUNT REGISTER
         IC    COUNT,JERCDE             GET ERROR CODE FROM RECORD
         SET   NOBLK,ON                 TURN OFF LEFT ZERO SUPPRESSION
         BAL   RTN,CONVERT              CONVERT IT
         SET   NOBLK,OFF                TURN ON LEFT ZERO SUPPRESSION
         MVC   ELERRCDE(L'CERROR),CERROR    MOVE IT TO PRINT LINE
         MVC   ELERPFIX(L'JPREFIX),JPREFIX  MOVE IN COMPONENT PREFIX
         SLL   COUNT,D2                 COMPUTE OFFSET IN MSG ADDT TBLE
         L     MNDX,=A(ERRMSGS)         GET ADDR OF START OF MSGS
         L     MTABPTR,=A(MTABLE)       BASE FOR MSG ADDR INDEX TABLE
         USING MTBLE,MTABPTR            USING FOR MSG ADDR INDEX TABLE
         AH    MNDX,MADDR(COUNT)        ADD OFFSET FOR MESSAGE
         LH    MSGLN,MLN(COUNT)         GET MESSAGE LENGTH
         GOIF  (MSGLN),NOTZERO=MOVEIT   TEST FOR UNDEFINED ERROR CODE
         SR    COUNT,COUNT                  UNDEFINED ERROR- GET LGTH
         LH    MSGLN,MLN(COUNT)             OF UNDEFINED ERR CDE MSG
         SET   ERRSW,ON                 TURN ON UNDEFINED ERROR CODE SW
         CLI   SEVCDE,X'10'             USE SEV OF 16
         BNH   MOVEIT
         MVI   SEVCDE,X'10'             SAVE HIGHEST SEVERITY CODE
         DROP  MTABPTR
MOVEIT   EQU   *
         STH   MSGLN,HWD                SAVE MESSAGE LENGTH
         EX    MSGLN,MOVEMSG            MOVE MSG TO PRINT LINE
         LA    R14,ELERMSG              INITIALIZE REG FOR TRT SCAN
         GOIF  ERRSW,OFF=GOODERCD       CHECK UNDEFINED ERROR CODE SW
         SET   ERRSW,OFF                TURN IT OFF IF IT IS ON
         AR    R14,MSGLN                FIND END OF UNDEFINED ERROR
         MVC   D2(D7,R14),ELERPFIX      MOVE UNDEF ERR CODE TO MESS
         MVC   ELERRCDE+D1(D3),=F'0'    MESSAGE NUMBER SHOULD BE ZERO
         LA    MSGLN,D8(MSGLN)          ADD ERROR NUMBER LENGTH
         STH   MSGLN,HWD                SAVE IT
         LH    R14,JERECL               GET RECORD LENGTH
         B     ENDSCAN                  GO PRINT MESSAGE
GOODERCD EQU   *
         GOIF  JESEV,SEVCDE,LE=APPDATA  CHECK SEVERITY CODE
         MVC   SEVCDE(L'JESEV),JESEV    SAVE HIGHEST SEVERITY CODE
APPDATA  EQU   *
         LA    R0,JEDATA                GET INITIAL APPENDED DATA ADDR
         ST    R0,ERDATADR                  AND SAVE IT
SCANMSG  SR    MNDX,MNDX                CLEAR FUNCTION REGISTER
         EX    MSGLN,SCANTRT            SCAN MSG FOR DATA INSERT FLAGS
         BZ    ENDSCAN                  SCAN COMPLETED
         BAL   RTN,BRTABLE(MNDX)        GO TO BRANCH TABLE
         LR    COUNT,R1                 CHECK TO DETERMINE IF ALL OF
         SR    COUNT,R14                    MSG HAS BEEN SCANNED
         GOIF  (COUNT),(MSGLN),GE=ENDSCAN   IF SO TERMINATE SCAN
         SR    MSGLN,COUNT              IF NOT COMPUTE REMAINING LENGTH
         LR    R14,R1                       AND SCAN CONTINUE POINT
         B     SCANMSG                      AND RESUME SCAN
MOVEMSG  MVC   ELERMSG(0),0(MNDX)       EXECUTED MOVE FOR ERROR MSG TXT
SCANTRT  TRT   0(0,R14),TRTABLE         EXECUTED TRT FOR POUND OR DOLLR
MOVEDATA EQU   *
         L     MNDX,ERDATADR            GET ADDR OF APPENDED DATA
         MVC   D0(D8,R1),D0(MNDX)       MOVE APPENDED DATA TO OVLAY FLG
         LA    MNDX,D8(MNDX)            INCREMENT TO NEXT APPENDED ITEM
         ST    MNDX,ERDATADR                AND SAVE IT
         LA    R1,D8(,R1)               INCREMENT BY 8 FOR '$        '
         BR    RTN                      RETURN TO CALLER
MOVECOL  EQU   *
         ST    RTN,SAVERTN2             SAVE RETURN LINKAGE
         LNR   COUNT,R1                 COMPUTE REMAINING LENGTH OF
         AR    COUNT,R14                    MESSAGE NOT YET SCANNED
         AR    COUNT,MSGLN                  THEN SUBTRACT 1 BECAUSE NOT
         LR    MNDX,COUNT                   MOVING FLAG ITSELF
         BCTR  COUNT,R0                 SAVE LENGTH OF REMAINING MSG
         AR    MNDX,R1                  ADD ADDRESS OF FLAG = MSG END
         LR    R15,MNDX                 SAVE BEGINING ADDR OF MOVE
         A     MNDX,=A(L'COLMSG)        ADD COLMSG LGTH TO TARGET ADDR
SHIFTMSG MVC   D0(D1,MNDX),D0(R15)      SHIFT LAST BYTE OF MSG TO RIGHT
         BCTR  MNDX,R0                  DECREMENT TO AND FROM ADDRESSES
         BCTR  R15,R0                       TO GET NEXT BYTE TO LEFT
         BCT   COUNT,SHIFTMSG           IF ALL OF MSG SHIFTED - STOP
         MVC   D0(L'COLMSG,R1),COLMSG   MOVE COL MSG TO VACATED AREA
         LH    COUNT,HWD                GET SAVED MSG LENGTH
         A     COUNT,=A(L'COLMSG)       MAKE LENGTH INCLUDE COLMSG
         STH   COUNT,HWD                SAVE NEW LENGTH FOR ENDSCAN
         SR    COUNT,COUNT              CLEAR COUNT REGISTER
         IC    COUNT,JECOLPTR           GET COLUMN POINTER
         BAL   RTN,CONVERT              CONVERT IT
         MVC   L'COLMSG(L'CCOLPTR,R1),CCOLPTR  MOVE IT TO PRINT LINE
         LA    R1,D2(,R1)               INCREMENT BY 2 FOR '# ' IN MSG
         L     RTN,SAVERTN2             RETURN TO
         BR    RTN                          CALLER
ENDSCAN  LH    MNDX,HWD                 PICK UP SAVED MESSAGE LENGTH
         LA    R1,ELERMSG               GET ADDRESS OF MESSAGE IN TWO
         LR    R3,R1                     REGISTERS
         AR    MNDX,R1                  COMPUTE END OF MESSAGE
ENDSCANA CLI   D0(R3),X'2F'             IS CHAR A BLANK
         BNE   ENDSCANB                 NO - GO MOVE CHAR
         CLI   D1(R3),X'2F'             IS THERE A SECOND BLANK
         BNE   ENDSCANB                 NO - GO MOVE CHAR
         LA    R3,D1(R3)                UPDATE SCAN INDEX
         CR    R3,MNDX                  END OF MESSAGE REACHED
         BNH   ENDSCANA                 NO
         B     ENDSCANC                 YES
ENDSCANB MVC   D0(D1,R1),D0(R3)         MOVE ONE CHAR
         LA    R1,D1(R1)                UPDATE INSERT INDEX
         LA    R3,D1(R3)                UPDATE SCAN INDEX
         CR    R3,MNDX                  END OF MESSAGE ?
         BNH   ENDSCANA                 NO - GO SCAN NEXT CHAR
ENDSCANC MVI   D0(R1),X'2F'             YES - FILL WITH BLANKS
         LA    R1,D1(R1)                UPDATE INSERT INDEX
         CR    R1,MNDX                  END OF MESSAGE REACHED
         BNH   ENDSCANC                 NO
ENDSCAN2 BAL   RTN,TERMERR              GO PRINT ON SYSTERM IF SO
         BAL   RTN,PRINT                GO PRINT LINE
         L     RTN,SAVERTN1             RETURN TO
         BR    RTN                          CALLER
         EJECT
*    PRINT ERROR MESSAGE ON SYSTERM DATA SET
*    TAKE MESSAGE FROM SYSPRINT BUFFER AND
*    REMOVE UNNESSASARYBLANKS
         USING TERMBUF,R11              ESTABLISH BASE FOR TERM BUFFER
TERMERR  GOIF  JTERM,OFF=(RTN)          RETURN IF NOTERMINAL USED
         LR    R4,R11                   SAVE SYSPRINT BUFFER POINTER
         LR    R3,RTN                   SAVE RETURN REGISTER
         LA    R11,BUFTERM              GET TERM BUFFER ADDR
         MVC   ERCDE,D8(R4)             MOVE MESSAGE NUMBER
         MVC   ERMSG,D20(R4)            MOVE MESSAGE TEXT
         JTPRINT                        PRINT BUFFER
         BAL   RTN,BUFINIT              INITIALIZE BUFFER
         LR    RTN,R3                   RESTORE RETURN REGISTER
         LR    R11,R4                   RESTORE BUFFER POINTER
         BR    RTN                      RETURN TO CALLER
         SPACE 3
*  PRINT STATISTICS LINES ON SYSTERM IF TERM OPTION USED
TERMSTAT GOIF  JTERM,OFF=(RTN)          RETURN IF NOTERMINAL USED
         LR    R4,R11                   SAVE SYSPRINT BUFFER POINTER
         ST    R3,JFWORD2               SAVE  THIS REGISTER IF SYSPARM
         LR    R3,RTN                   SAVE RETURN REGISTER
         LA    R11,BUFTERM              GET TERM BUFFER ADDR
         MVC   PRTIMG(L'PRTLINE),D1(R4)  MOVE LINE TO SYSTERM BUF
         JTPRINT                        PRINT IT
         BAL   RTN,BUFINIT              INITIALIZE BUFFER
         LR    RTN,R3                   RESTORE RETURN REG
         LR    R11,R4                   RESTORE BUFFER POINTER
         L     R3,JFWORD2               RESTORE REG AGAIN
         BR    RTN                      RETURN TO CALLER
          EJECT
         USING PRTBUF,R11               ESTABLISH BASE
PRINT    EQU   *
***********************************************************************
*              THE PRINT ROUTINE CONTROLS PAGE SKIPPING AND PAGE      *
*              HEADING.                                               *
***********************************************************************
         GOIF  JLIST,OFF=(RTN)          RETURN IF LIST IS OFF
         ST    RTN,SAVERTN2             SAVE RETURN LINKAGE
         LH    COUNT,PGLINES            CHECK FOR END OF PAGE.  IF NOT
         BCT   COUNT,WRITEMSG             END OF PAGE GO WRITE MSG.
*                                         ELSE SET UP AND PRINT NEW
*                                         PAGE HEADING ON NEW PAGE.
         LH    COUNT,JPAGENO            GET PAGE NUMBER
         AH    COUNT,=H'01'             INCREMENT PAGE NUMBER
         STH   COUNT,JPAGENO            PUT BACK NEW PAGE NUMBER
         MVC   PRTLNSAV(L'PRTLINE),PRTLINE  SAVE PRINT LINE IN BUFFER
         MVI   PRTLINE,JBLANK           BLANK PRINT BUFFER
         MVC   PRTLINE+D1(L'PRTLINE-D1),PRTLINE
         MVI   CNTRL,EJCT               INSERT EJECT CONTROL CHARACTER
         MVC   HLTITLE(L'JDECKID),JDECKID TITLE PART OF FIRST HDNG LINE
         MVC   HLDIAG(L'HDNG1),HDNG1    MOVE IN HDNG PART OF FIRST LINE
         MVC   HLPAGE(L'PAGE),PAGE      MOVE IN 'PAGE'
         BAL   RTN,CONVERT              CONVERT PAGE NUMBER
         MVC   HLPGENO(L'CPAGE),CPAGE   MOVE IN PAGE NUMBER
         JPRINT
         GOIF  STATSW,ON=STATONLY       CHECK STATSW BEFORE NEXT INSTR
         MVC   HLDIAG2(L'HDNG2),HDNG2   STMT-ERROR-CODE-MESSAGE HEADING
STATONLY MVI   CNTRL,SPACE3             TRIPLE SPACE
         MVC   HLDATE(L'JLVTMDT),JLVTMDT  COMP-LEVEL-TIME-DATE
         JPRINT
         MVI   CNTRL,SPACE2             INSERT DOUBLE SPACE CHAR
         MVC   PRTLINE(L'PRTLNSAV),PRTLNSAV  RESTORE ORIG PRINT LINE
         LH    COUNT,JLNCT              RESET LINE COUNT PER PAGE
WRITEMSG EQU   *
         JPRINT
         STH   COUNT,PGLINES            SAVE LINE COUNT PER PAGE
         L     RTN,SAVERTN2             RESTORE LINKAGE TO CALLER
         BR    RTN                      RETURN TO CALLER
         EJECT
CONVERT  EQU   *
***********************************************************************
*              THE CONVERT ROUTINE RECIEVES A BINARY NUMBER IN COUNT  *
*              (REGISTER 4) AND CONVERTS IT TO INTERNAL FORMAT IN     *
*              DBLWD2.  IT ALSO SUPPRESSES LEADING ZEROS BASED UPON   *
*              THE SETTING OF THE FLAG NOBLK.                         *
***********************************************************************
         CVD   COUNT,DBLWD1             CONVERT BINARY NO. TO DECIMAL
         UNPK  DBLWD2,DBLWD1            UNPACK IT
         NC    DBLWD2,=X'0F0F0F0F0F0F0F0F'  STRIP ZONES FOR INTL FORMAT
         GOIF  NOBLK,ON=GOBACK          IF LEFT ZERO SUPP OFF EXIT
         LA    R15,DBLWD2               ADDRESS OF NUMBER
         LA    R14,L'DBLWD2-1           LENGTH OF NUMBER
SZEROS   CLI   D0(R15),J0               SCAN FOR LEADING ZERO
         BNE   GOBACK                   IF NOT ZERO EXIT
         MVI   D0(R15),JBLANK           IF ZERO - BLANK IT
         LA    R15,D1(R15)              INDEX TO NEXT CHARACTER
         BCT   R14,SZEROS               GO BACK AND SCAN IT
GOBACK   BR    RTN                      RETURN TO CALLER
*  SUPPRESS LEADING BLANKS IN THE FLAG AND LINECOUNT OPTION VALUES
*  IN THE OPTIONS PRINT BUFFER AND RETURNS WITH R1 POINTING TO THE
*  LAST CHARACTER IN THE VALUE
BLNKSUP  EQU   *
         LA    COUNT,L'CPAGE-1          GET MOVE LENGTH OF FIELD
SBLANKS  GOIF  D0(R1),JBLANK,NE=BACK    RETURN ON FIRST NONBLANK
         EX    COUNT,MVFIELD            DELETE ONE BLANK CHAR
         BCT   COUNT,SBLANKS            DECREMENT MOVE LENGTH
BACK     AR    R1,COUNT                 POINT TO LAST CHAR IN VALUE
         LA    R1,D1(R1)
         BR    RTN                      RETURN TO CALLER
MVFIELD  MVC   D0(COUNT,R1),D1(R1)      MOVE ONE CHAR TO THE LEFT
         EJECT
NOERR    EQU   *
         USING PRTBUF,R11               SET UP USING FOR PRINTBUF
STATRTN  EQU   *
         SET   STATSW,ON                TURN ON STATISTICS SWITCH
         LH    R0,PGLINES               CHECK NUMBER OF LINES LEFT ON
         CH    R0,=H'15'                   PAGE. IF GT/EQ TO THE REQ'D
         BNL   DSKIP                       NUMBER DONT EJECT PAGE.
         LA    COUNT,D1(R0)             FORCE SKIP TO
         STH   COUNT,PGLINES                NEW PAGE
DSKIP    MVI   CNTRL,SPACE2             SET UP DOUBLE SPACE
         LH    COUNT,ERRQTY             GET TOTAL COUNT OF ERRORS
         GOIF  (COUNT),ZERO=NOERRS      ANY ERRORS.  BRANCH IF NONE
         MVC   PRTLINE(L'ERCTMSG),ERCTMSG  SET UP NR OF ERRS MSG
         BAL   RTN,CONVERT              CONVERT NUMBER OF ERRORS
         MVC   PRTLINE+L'ERCTMSG(L'CSTMT),CSTMT  MOVE IT TO PRINT LINE
         B     NOEPRINT                 BRANCH TO PRINT IT
NOERRS   MVC   PRTLINE(L'NOERMSG),NOERMSG  NO ERROR MSG
NOEPRINT BAL   RTN,TERMSTAT             PRINT ON SYSTERM TOO
         BAL   RTN,PRINT                GO PRINT MESSAGE
         MVC   PRTLINE(L'SEVMSG),SEVMSG  SET UP SEVERITY CODE MESSAGE
         SR    COUNT,COUNT              CLEAR COUNT REGISTER
         IC    COUNT,SEVCDE             GET HIGHEST SEVERITY CODE
         BAL   RTN,CONVERT              AND CONVERT IT
         MVC   PRTLINE+L'SEVMSG(L'CPAGE),CPAGE  MOVE IT TO PRINT LINE
         BAL   RTN,TERMSTAT             PRINT ON SYSTERM TOO
         BAL   RTN,PRINT                GO PRINT IT
         MVC   PRTLINE(L'OPTM1),OPTM1   MOVE IN ASM OPTNS MESSAGE
         BAL   RTN,TERMSTAT             PRINT ON SYSTERM TOO
         BAL   RTN,PRINT                PRINT IT
         LA    COUNT,PRTLINE+D2(R0)     START OF MESSAGE
         BLDPRM JALGN,ALGN
         BLDPRM JALOGIC,ALOGIC
         LA    R2,PBUF                  GET ADDRESSS AND LENGTH OF PARM
         LA    R1,L'PBUF-D1(R0)
         EX    R1,MVPARM                MOVE IN PARM
         AR    COUNT,R1                 BUMP PRINT LINE INDEX
         TM    JPARM3,JMINBUF           MINIMUM BUFFER SIZE
         BO    MVMIN                    YES
         TM    JPARM4,JMBUF             BR IF MULTIPEL-        @AZ13738
         BO    MVMAX                    BUFFERS USED.          @AZ13738
         MVC   D0(L'STD,COUNT),STD      STANDARD BUFFER SIZE USED
         LA    COUNT,L'STD(COUNT)       BUMP PRINT LINE INDEX
         B     MVBUF                    TAKE NEXT OPTION
MVMAX    MVC   D0(L'MAX,COUNT),MAX      MBUF USED              @AZ13738
         LA    COUNT,L'MAX(COUNT)       BUMP PRINT LINE INDEX  @AZ13738
         B     MVBUF                    TAKE NEXT OPTION       @AZ13738
MVMIN    MVC   D0(L'MIN,COUNT),MIN      MINIMUM BUFFER SIZE USED
         LA    COUNT,L'MIN(COUNT)       BUMP PRINT LINE INDEX
MVBUF    LA    COUNT,D1(COUNT)          ADD 1 TO PRINT LINE INDEX
         BLDPRM JDECK,DECK
         BLDPRM JESD,ESD
         LR    R1,COUNT                 TRANSFER POSITION PTR TO R1
         MVC   D0(L'PFLAG,R1),PFLAG      MOVE IN FLAG(
         LA    R1,L'PFLAG(R1)           BUMP PRINT LINE INDEX
         SR    COUNT,COUNT              CLEAR COUNT REGISTER
         IC    COUNT,JMSGL              GET MESSAGE LEVEL
         BAL   RTN,CONVERT                AND CONVERT IT
         MVC   D0(L'CPAGE,R1),CPAGE     MOVE IN CONVERTED MSGLEVEL
         BAL   RTN,BLNKSUP              SUPRESS LEADING BLANKS
         MVI   D0(R1),JRPARN            SUPPLY RIGTH PAREN
         LA    R1,D1(R1)                ADD 1 TO PRINT LINE INDEX
         MVC   D0(L'PLC,R1),PLC         MOVE IN ', LINECOUNT('
         LA    R1,L'PLC(R1)             BUMP PRINT LINE INDEX
         LH    COUNT,JLNCT              GET LINE COUNT
         BAL   RTN,CONVERT                AND CONVERT IT
         MVC   D0(L'CPAGE,R1),CPAGE     MOVE IN CONVERTED LINE COUNT
         BAL   RTN,BLNKSUP              SUPRESS LEADING BLANKS
         MVI   D0(R1),JRPARN            SUPPLY RIGTH PAREN
         MVI   D1(R1),JCOMMA                 AND COMMA
         MVI   D2(R1),JBLANK               AND A BLANK
         LA    R1,D3(R1)                ADD 1 TO PRINT INE INDEX
         LR    COUNT,R1                 RESTORE PRINT LINE INDEX
         BLDPRM JLIST,LIST
         BLDPRM JCALLS,CALLS
         BLDPRM JYFLAG,YFLAG                                   @OX09734
         LR    R1,COUNT                 TRASF.PRT LINE INDX    @AZ13738
         MVC   D0(L'PSIZE,R1),PSIZE     MOVE IN 'WORKSIZE('    @AZ13738
         LA    R1,L'PSIZE(R1)           BUMP PRINT LINE INDEX  @AZ13738
         L     COUNT,CORESIZE           GET REQUESTED CORE     @AZ13738
         BAL   RTN,CONVERT              CONVERT VALUE          @AZ13738
         MVC   D0(L'DBLWD2,R1),DBLWD2   MOVE VALUE TO PRINT LN @AZ13738
         LA    COUNT,L'DBLWD2-1         GET MOVE LENGH         @AZ13738
         BAL   RTN,SBLANKS              SUPPR LEADING BLANKS   @AZ13738
         MVI   D0(R1),JRPARN            SUPPLY RIGHT PAREN     @AZ13738
         LA    R1,D1(,R1)               ADD 1 TO PRINT INDEX   @AZ13738
         LR    COUNT,R1                 RESTORE PRINT LINE NDX @AZ13738
         BAL   RTN,TERMSTAT             PRINT ON SYSTERM
         BAL   RTN,PRINT                PRINT THIS OPTION LINE
         LA    COUNT,PRTLINE+D2         START OF MESSAGE LINE
         BLDPRM JMLOGIC,MLOGIC
         BLDPRM JNUM,NUM
         BLDPRM  JLINK,LOAD
         BLDPRM JRENT,RENT
         BLDPRM JRLD,RLD
         BLDPRM JSTMT,STMT
         BLDPRM  JSYSMAC,SYSMAC
         BLDPRM JTERM,TERM
         BLDPRM JTEST,TEST
         BLDPRM JXREF,XREF
         GOIF  JMINXREF,OFF=XRFPRT      SHORT XREF
         BCTR  COUNT,R0                 DECR COUNT TO GET NO BLANK
         MVC   D0(L'SHORT,COUNT),SHORT  YES TELL IT
         LA    COUNT,L'SHORT+D1(COUNT)  UPDATE POINTER
XRFPRT   BAL   RTN,TERMSTAT             PRINT ON SYSTERM
         BAL   RTN,PRINT                GO PRINT IND LINE OF ASM OPTNS
         LA    R1,PRTLINE+D2            START OF MESSAGE LINE
         MVC   D0(L'PSYSPARM,R1),PSYSPARM  MOVE IN 'SYSPARM = '
         LA    R1,L'PSYSPARM(R1)        BUMP PRINT LINE INDEX
         L     R2,JSYSPARM              GET ADDRESS OF SYSPARM
         GOIF  (R2),ZERO=PRTSTAT        IF NO SYSPARM SKIP CODE TO MOVE-
                                            IT TO PRINT LINE.
         SR COUNT,COUNT                 CLEAR COUNT REGISTER
         IC    COUNT,D0(R2)             GET LENGTH OF SYSPARM
         SH    COUNT,=H'01'             COMPUTE MV LGTH OF SYSPARM
         LA    R3,L'PRTLINE-L'PSYSPARM-D2(R0)  COMPUTE LGTH OF PRT LINE-
                                            AVAILABLE FOR SYSPARM MSG
         SR    COUNT,R3                 DETERMINE NO OF LINES NEEDED
         BNM   LINE2                    BRANCH IF 2 OR 3
         AR    COUNT,R3                 MAKE COUNT EQUAL TO MOVE LENGTH
         B     LPRT                     PRIMT
LINE2    EX    R3,MSYSPARM              MOVE LINE 1 TO BUFFER
         STH   COUNT,HWD                SAVE LENGTH OF REMAINDER
         BAL   RTN,TERMSTAT             PRINT ON SYSTERM
         BAL   RTN,PRINT                PRINT
         AR    R2,R3                    UPDATE SYSPARM MESSAGE INDEX
         LA    R1,PRTLINE+D2            MAKE 2 BLANKS FIRST IN LINE
         LA    R3,L'PRTLINE-D2(R0)      COMPUTE  LENGTH OF FULL LINE
         LH    COUNT,HWD                RESTORE LENGTH OF REMAINDER
         SR    COUNT,R3                 IS 3 LINES NEEDED
         BNM   LINE3                    BRANCH IF YES
         AR    COUNT,R3                 MAKE COUNT MOVE LENGTH OF REM
         B     LPRT                     PRIMT
LINE3    EX    R3,MSYSPARM              MOVE 2ND LINE OF 3
         STH   COUNT,HWD                SAVE LENGTH OF REMAINDER
         BAL   RTN,TERMSTAT             PRINT ON SYSTERM
         BAL   RTN,PRINT                PRINT
         AR    R2,R3                    UPDATE SYSPARM MESSAGE INDEX
         LA    R1,PRTLINE+D2            POINT TO BUFFER +2
         LH    COUNT,HWD                RESTORE LENGTH OF REMAINDER
LPRT     EX    COUNT,MSYSPARM           MOVE REMAINING CHARATERS
         AR    R1,COUNT                 BUMP PRINT LINE INDEX
         LA    R1,D1(R1)                BUMP PRINT LINE INDEX
PRTSTAT  MVI   D0(R1),JRPARN            SUPPLY RIGTH PAREN
         BAL   RTN,TERMSTAT             PRINT ON SYSTERM
         BAL   RTN,PRINT                GO PRINT SYSPARM
         LA    R1,PRTLINE               GET BUFFER ADDRESS
         MVC   D0(L'PBUFSIZE,R1),PBUFSIZE MOVE BUFSIZE MSG
         LA    R1,L'PBUFSIZE(R1)        BUMP PRINT LINE INDEX
         LH    COUNT,JMAXRL             GET BUGFER SIZE
         BAL   RTN,CONVERT              CONVERT IT
         MVC   D0(L'CSTMT,R1),CSTMT     MOVE NUMBER INTO PRINT LINE
         LA    R1,L'CSTMT(R1)           BUMP PRINT LINE INDEX  @AZ13738
         MVI   D0(R1),JSLASH            MOVE SLASH TO PRINT    @AZ13738
         LA    R1,D1(R1)                BUMP PRINT LINE INDEX  @AZ13738
         LH    COUNT,NRMBUF             GET NR OF MBUF         @AZ13738
         BAL   RTN,CONVERT              CONVERT IT             @AZ13738
         MVC   D0(D2,R1),CSTMT+D3       MOVE OUT NUMBER        @AZ13738
         BAL   RTN,PRINT                PRINT WORKFILE BUFFER SIZE
         MVC   PRTLINE(L'TSYSIN),TSYSIN  TOTAL RCDS FROM SYSTEM INPUT
         L     COUNT,JRECIN             GET NUMBER OF RECORDS READ FROM
         BAL   RTN,CONVERT                  SYSTEM INPUT AND CONVERT IT
         MVC   PRTLINE+L'TSYSIN(L'DBLWD2),DBLWD2  MOVE IT TO PRINT LINE
         BAL   RTN,PRINT                GO PRINT IT
         MVC   PRTLINE(L'TSYSLIB),TSYSLIB  TOTAL RCDS FROM SYSTEM LIB
         L     COUNT,JRECLIB            GET NUMBER OF RECORDS READ FROM
         BAL   RTN,CONVERT                  SYSTEM LIBRARY & CONVERT IT
         MVC   PRTLINE+L'TSYSLIB(L'DBLWD2),DBLWD2  MOVE IT TO PRT LINE
         BAL   RTN,PRINT                GO PRINT IT
         MVC   PRTLINE(L'TSYSPCH),TSYSPCH   TOTAL RECORDS PUNCHED
         L     COUNT,JRECPCH            GET NUMBER OF RECORDS PUNCHED
         BAL   RTN,CONVERT                  AND CONVERT IT
         MVC   PRTLINE+L'TSYSPCH(L'DBLWD2),DBLWD2  MOVE IT TO PRINT LN
         BAL   RTN,PRINT                GO PRINT IT
         MVC   PRTLINE(L'TSYSPRT),TSYSPRT  TOTAL LINES PRINTED
         L     COUNT,JRECPRT            GET NUMBER OF LINES PRINTED AND
         LA    COUNT,D1(COUNT)          ADD 1 FOR LINE TO BE PRINTED
         BAL   RTN,CONVERT              AND CONVERT IT
         MVC   PRTLINE+L'TSYSPRT(L'DBLWD2),DBLWD2  MOVE IT TO PRINT LIN
RETURN   EQU   *
         SR    COUNT,COUNT              CLEAR COUNT REGISTER
         IC    COUNT,SEVCDE             GET HIGHEST SEVERITY CODE
         JFRECORE  ADDR=(R7)            FREE X6BCOM COMMON AREA
         LR    R10,COUNT                RETURN HIGHEST SEVERITY CODE
RTRN     JRETURN                        RETURN TO CALLER
         EJECT
MVNO     MVC   D0(L'NO,COUNT),NO        EXECUTED MOVE FOR 'NO'
MVPARM   MVC   D0(R1,COUNT),D0(R2)      EXECUTED MOVE FOR ASM OPTIONS
MSYSPARM MVC   D0(R0,R1),D1(R2)         EXECUTED MOVE FOR SYSPARM MSG
PUNCHEC  EQU   *
***********************************************************************
*              THE PUNCH ROUTINE RECEIVES CONTROL FROM THE MAIN LINE  *
*              ONLY IF THE DECK OR LINK OPTION FLAGS ARE ON.  IT SETS *
*              UP THE 'END' CARD FOR PUNCHING AND RETURNS TO THE MAIN *
*              LINE.                                                  *
***********************************************************************
         ST    PRTBASE,SVPRTBAS         SAVE PRINT BUFFER BASE REGISTER
         JPUNCH
         USING PCHBUF,R11               USING FOR PUNCH BUFFER
         MVI   PCNTRL,X'02'             12-2-9 PUNCH
         MVC   PCEND(L'END),END         MOVE IN END
         MVC   PCCOMP(L'JIDR),JIDR     IDR
         TR    PCLINE(L'PCLINE),JTRTABLE  TRANSLATE TO EXTERNAL FORMAT
         GOIF  JESDCHK,OFF=NOESD        IF ESD SWITCH OFF DONT MOVE ESD
         MVC   PCENTAD(L'JENTRYPT-D1),JENTRYPT+D1  MOVE IN ENTRY PT ADR
         MVC   PCESDID(L'JESDID),JESDID  MOVE IN ESDID
NOESD    L     PRTBASE,SVPRTBAS         RESTORE PRINT BUFFER BASE
         BR    RTN                      RETURN TO CALLER
         EJECT
*
********************************  CONSTANTS AND DATA  *****************
*
BRTABLE  DS    F                        DATA INSERTION BRANCH TABLE
         B     MOVEDATA                 GO TO DATA INSERT ROUTINE
         B     MOVECOL                  GO TO COL POINTER INSERT RTN
TRTABLE  DC    XL51'00'                 TRANSLATE TABLE TO SCAN MSGS
         ORG   TRTABLE+JPOUND               FOR COL PTR INSERT
         DC    X'08'                        OR
         ORG   TRTABLE+JDOLLAR              FOR APPENDED DATA INSERT
         DC    X'04'                        CHARATERS
         ORG   ,                        TO RESUME LOC CTR
ZMASK    DC    X'0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F'
BLANKS   JGENIN '  '
HDNG1    JGENIN 'ASSEMBLER DIAGNOSTICS AND STATISTICS'
HDNG2    JGENIN 'STMT  ERROR CODE   MESSAGE'
PAGE     JGENIN 'PAGE'
NOERMSG  JGENIN 'NO STATEMENTS FLAGGED IN THIS ASSEMBLY'
ASMXF    JGENIN 'ASSEMBLER (XF) DONE'                          @OX12916
ERCTMSG  JGENIN  'NUMBER OF STATEMENTS FLAGGED IN THIS ASSEMBLY = '
OPTM1    JGENIN 'OPTIONS FOR THIS ASSEMBLY'
NO       JGENIN 'NO'
MIN      JGENIN '(MIN),'
STD      JGENIN '(STD),'
MAX      JGENIN '(MAX),'                                       @AZ13738
SHORT    JGENIN '(SHORT)'
PALGN    JGENIN 'ALIGN, '
PALOGIC  JGENIN 'ALOGIC, '
PCALLS   JGENIN 'MCALL, '                                      @OX09734
PDECK    JGENIN 'DECK, '
PESD     JGENIN 'ESD, '
PLOAD    JGENIN 'OBJECT, '
PLIST    JGENIN 'LIST, '
PMLOGIC  JGENIN 'MLOGIC, '
PRENT    JGENIN 'RENT, '
PRLD     JGENIN 'RLD, '
PSYSMAC  JGENIN 'LIBMAC, '
PTEST    JGENIN 'TEST, '
PXREF    JGENIN 'XREF '
PBUF     JGENIN 'BUFSIZE '
PTERM    JGENIN 'TERMINAL, '
PNUM     JGENIN 'NUMBER, '
PSTMT    JGENIN 'STMT, '
PYFLAG   JGENIN 'YFLAG, '                                      @AZ13738
PFLAG    JGENIN 'FLAG('
PLC      JGENIN ', LINECOUNT('
PSIZE    JGENIN 'WORKSIZE('                                    @AZ13738
PBUFSIZE JGENIN 'WORK FILE BUFFER SIZE/NUMBER ='               @AZ13738
PSYSPARM JGENIN 'SYSPARM('
TSYSIN   JGENIN 'TOTAL RECORDS READ FROM SYSTEM INPUT   '
TSYSLIB  JGENIN 'TOTAL RECORDS READ FROM SYSTEM LIBRARY '
TSYSPRT  JGENIN 'TOTAL RECORDS PRINTED                  '
TSYSPCH  JGENIN 'TOTAL RECORDS PUNCHED                  '
COLMSG   JGENIN 'NEAR OPERAND COLUMN '
SEVMSG   JGENIN 'HIGHEST SEVERITY WAS '
S259     JGENIN 'RELOCATABLE Y-TYPE ADDRESS CONSTANT IN THIS ASSEMBLY'
S256     JGENIN 'SYSGO DD CARD MISSING - NOOBJECT OPTION USED'
S257     JGENIN 'SYSPUNCH DD CARD MISSING - NODECK OPTION USED'
S258     JGENIN 'INVALID ASSEMBLER OPTION ON EXEC CARD -- OPTION IGNOREX
               D'
S264     JGENIN 'TOO MANY ESD ENTRIES'
S265     JGENIN 'SYMBOL RESOLUTION DATA AREA HAS BEEN EXHAUSTED'
S267     JGENIN 'SYSPRINT DD CARD MISSING - NOLIST OPTION USED'
S268     JGENIN 'SYSTERM DD CARD MISSING - NOTERMINAL OPTION USED'
S269     JGENIN 'SYSLIB DD CARD MISSING'
END      JGENIN  'END'
         JPATCH X6B00,ED7               5% PATCH AREA
         JEXTRN (X6C01=ERRMSGS)         ADDR OF BEGINNING OF ERR MSGS
         JEXTRN (X6C02=MTABLE)          ADDR OF ERR MSG INDEX TABLE
         EJECT
         JCSECT (X6B20)                 DEFINE CSECT
PRINTEXT JSAVE BASE=YES                 SAVE REGISTER
         JENTRY (X6B21=PRINTEXT)        DEFINE ENTRY POINT
*LISTSOURCE
*  THIS ROUTINE RECONSTRUCT THE SOURCE RECORDS IN THE PRINT AREA AND
*  DETERMINE WHETHER SEQUENCE NUMBER NEEDS TO BE ATTACHED OR NOT
*
*
         USING JTEXT,R5                 SET USING FOR TEXT
         USING JTEXTA,R4                SET UP USING FOR JTEXTA
         USING TERMBUF,R11              USING FOR TERMINAL BUFFER
         LR    R5,INBASE                SET R5 FOR TEXT PTR
         BAL   R6,INITBUF               GO TO INITIALIZE BUFFER
         GOIF  JSTMT,OFF=LST100         DO WE PRINT STMT NUM?
         TM    D16(R5),BIT2             TEST SAVED FLAGB FOR JNOCNT
         BO    LST100                   IF SO DO NOT ASSIGN STMTNR
         LH    R1,JTFLGA                GET STMT NUMBER
         BAL   R6,PRN800                CONVERT TO DECIMAL
         MVC   STMTNO,DWORD2            MOVE TO PRINT LINE
LST100   EQU   *                        BRANCH LABEL
         CLI   D5(R5),JM                IS THIS AN MNOTE MESSAGE
         BE    LSTMNOTE                 THAN HANDLE IT SEPARATELY
         SET   COLOVLP,OFF              TURN OVERLAP CHECK BIT OFF
         XC    COLSAV,COLSAV            CLEAR SAVEAREA
*  MOVE NAME FIELD
         LH    R4,JTNMP                 GET NAME POINTER
         BAL   R6,FLDMOVE               GO MOVE NAME FIELD
*  MOVE OPCODE FIELD
         LH    R4,JTOCP                 GET OPCODE POINTER
         BAL   R6,FLDMOVE               MOVE OPCODE
*  MOVE OPERAND FIELD
         LH    R4,JTOPP                 GET OPERAND POINTER
         BAL   R6,FLDMOVE               MOVE OPERAND
*  MOVE COMMENT FIELD
         LH    R4,JTCPR                 GET COMMENT POINTER
         BAL   R6,FLDMOVE               MOVE COMMENT
*  MOVE PRE-BEGIN POST-END FIELDS
LST200   BAL   R6,STRING                INSERT STRING
         GOIF  JNUM,OFF=LIST6           DO WE PRINT SEQ NUM?
         MVC   SEQNO(8),SEQNUM          YES MOVE IN SEQ NUM
         MVI   SEQNUM,JBLANK            SET BLANK CHARACTER
         MVC   SEQNUM+1(7),SEQNUM       BLANK OUT SEQNUM
         BAL   R6,ZEROSUP               SUPRESS LEADING ZEROS
LIST6    EQU   *                        BRANCH LABEL
         JTPRINT                        CALL TERMINAL PRINT
         BAL   R6,INITBUF               CLEAR BUFFER
RTPOINT  JRETURN                        EXIT
* LSTMNOTE HANDELS MNOTE PROCESSING FOR CORRECT MNOTES TO SYSTERM
LSTMNOTE EQU   *
         LH    R4,JTOPP            GET OPERAND POINTER
         AR    R4,R5               MAKE IT AN ADDRESS
         LA    R3,SOURCE           GET OUTPUT POINTER
         SR    R14,R14             CLEAR REGISTER
         IC    R14,LENGTH          GET OPERAND LENGTH
         GOIF  (R14),NOTZERO=LSTMN10 SCAN OPERAND
         B     LST200              FINISH MNOTE
LSTMN10  BCTR  R14,0               MAKE IT MOVE LENGTH
         AR    R14,R4              GET END OF OPERAND
         L     R1,JCTCHR           GET END COL -1
         AR    R1,R3               POINT TO END OF BUFFER
LSTMN15  CLI   FIELD,JASTER        COMMENT MNOTE
         BE    LSTMN20             YES, HANDEL IT
         CLI   FIELD,JCOMMA        SEV CODE OMITTED
         BE    LSTMN30             YES, HANDEL
         CLI   FIELD,JBLANK        BLANK SEV CODE
         BNE   LSTMN40             NO, TAKE CARE
         LA    R4,D1(R4)           STEP UP INPUT
         B     LSTMN15             CONTINUE SCAN FOR SEV CODE
LSTMN20  MVC   D0(D2,R3),FIELD     MOVE *,
         LA    R4,D2(R4)           STEP UP INPUT
         LA    R3,D2(R3)           STEP UP OUTPUT
         B     LSTMN50             HANDEL MESSAGE
LSTMN30  MVC   D5(D1,R3),FIELD     MOVE ,
         LA    R3,D6(R3)           STEP UP OUTPUT
         LA    R4,D1(R4)           STEP UP INPUT
         B     LSTMN50             HANDEL MESSAGE
LSTMN40  LR    R6,R4               SAVE INPUT POINTER
LSTMN42  LA    R4,D1(R4)           STEP UP ONE CHAR
         CLI   FIELD,JCOMMA        COUNT CHAR BEFORE COMMA
         BNE   LSTMN42             CONT NOT COMMA
         SR    R4,R6               NO OF CHAR PAST
         LA    R3,D5(R3)           5 MAX NO
         SR    R3,R4               MINUS NO OF CHAR =NO BLANKS
         LR    R4,R6               BACK UP INPUT POINTER
LSTMN46  MVC   D0(D1,R3),FIELD     MOVE SEV CODE 1 CHAR AT A TIME
         LA    R4,D1(R4)           STEP UP INPUT
         LA    R3,D1(R3)           STEP UP OUTPUT
         CLI   FIELD,JCOMMA        NEXT CHAR A COMMA?
         BNE   LSTMN46             CONT IF NOT
         MVC   D0(D1,R3),FIELD     MOVE THE COMMA
         LA    R3,D1(R3)           STEP UP OUTPUT
         LA    R4,D1(R4)           STEP PAST COMMA
LSTMN50  LA    R4,D1(R4)           STEP PAST FIRST QOUTE
LSTMN55  CLI   FIELD,JQUOTE        TERMINATING QUOTE?
         BE    LSTMN70             ELIMINATE DOUBLE QUOTE
         CLI   FIELD,JAMPER        ELIMINATE DOUBLE AMPERSANDS
         BE    LSTMN80             CHECK IF TWO
         CR    R4,R14              END OF OPERAND
         BNL   LST200              FINISH MNOTE PROC IF YES
LSTMN60  MVC   D0(D1,R3),FIELD     MOVE CHAR TO OUTPUT
         LA    R3,D1(R3)           STEP UP OUTPUT
         LA    R4,D1(R4)           STEP UP INPUT
         CR    R3,R1               END OF BUFFER
         BNL   LSTMN90             YES, HANDEL IT
         B     LSTMN55             NO CONT SCAN
LSTMN70  CLI   FIELD+D1,JQUOTE     DOUBLE QUOTE
         BNE   LST200              NO- TERMINATE STRING
LSTMN75  LA    R4,D1(R4)           STEP PAST 1 QUOTE
         B     LSTMN60             OUPUT 1 QUOTE
LSTMN80  CLI   FIELD+D1,JAMPER     A 2ND AMPERSAND
         BNE   LSTMN60             OUTPUT THE SINGLE AMPER
         B     LSTMN75             STEP BY 1 OF 2
LSTMN90  CLI   FIELD,JQUOTE        NEXT CHAR A QUOTE
         BE    LSTMN95             YES - END OF STRING?
LSTMN92  MVI   D0(R3),JX           INSERT CONT CHAR
         BAL   R6,STRING           GET STRINGS
         GOIF  JNUM,OFF=LSTMN94    NUM OPTION ON
         MVC   SEQNO(D8),SEQNUM    MOVE SEQNO TO PROPER PLACE
         MVI   SEQNUM,JBLANK       INSERT BLANK
         MVC   SEQNUM+D1(D7),SEQNUM BLANK SEQNUM FIELD
         BAL   R6,ZEROSUP          SUPRESS LEADING ZEROS
LSTMN94  JTPRINT
         BAL   R6,INITBUF          INITIALIZE TERM BUFFER
         LA    R3,SOURCE           GET OUTPUT POINTER
         L     R1,JCTCHR           GET END COL - 1
         AR    R1,R3               POINT TO END OF BUFFER
         B     LSTMN55             CONTINUE SCAN
LSTMN95  CLI   FIELD+D1,JQUOTE     A 2ND QUOTE
         BNE   LST200              NO STRING TERMINATED
         B     LSTMN92             YES  PRINT THE LINE
*FLDMOVE   THIS ROUTINE MOVE THE NAME,OPERATION,OPERAND OR COMMENTS TO
*        THE PRINT LINE.IT TAKES CARE OF PRINTING TO CONTINUATION LINES
*        THE ROUTINE IS CALLED BY BAL FLDMOVE WITH REG R4 POINTING TO
*        THE FIELD TO BE MOVED.
*
*
FLDMOVE  ST    R6,FLDSAVE               SAVE LINK REGISTER
         AR    R4,R5                    TURN POINTER INTO ADDRESS
         GOIF  CDPTR,OFF=FLD1           CARD PTR?
*   HANDLE CARD POINTER
         MVC   CARDP,OPTR               SAVE CARD POINTER
         SET   CDPTR1,OFF               TURN OFF FLAG BIT
FLD01    SR    R1,R1                    CLEAR REGISTER
         IC    R1,CARDP                 GET CARD PTR
         SH    R1,CDSTMT                SUBTRACT CURR-CARD-WITHIN STMT
         BNH   FLD02                    NOT IN NEW CARD
         BAL   R6,STRING                GO INSERT STRING
         GOIF  JNUM,OFF=FLD03           DO WE PRINT SEQ NUMBER?
         MVC   SEQNO(8),SEQNUM          YES,MOVE SEQNUM TO PROPER PLACE
         MVI   SEQNUM,JBLANK            SET BLANK CHARACTER
         MVC   SEQNUM+1(7),SEQNUM       BLANK OUT SEQNUM
         BAL   R6,ZEROSUP               SUPRESS LEADING ZEROS
FLD03    EQU   *                        BRANCH LABEL
         JTPRINT                        CALL TERMINAL PRINT
         BAL   R6,INITBUF               INITIALIZE BUFFER
         XC    COLSAV,COLSAV            CLEAR SAVE AREA FOR COL PTR
         SET   COLOVLP,OFF              TURN OVERLAP CHECK BIT OFF
         B     FLD01                    GO TEST NEXT CARD
FLD02    LA    R4,L'OPTR(,R4)           POINT TO COLUMN POINTER
FLD1     SR    R3,R3                    CLEAR REGISTER
         IC    R3,OCPTR                 GET OUTPUT COL PTR
         SR    R14,R14                  CLEAR REGISTER
         IC    R14,LENGTH               GET FIELD LENGTH
         GOIF  (R14),NOTZERO=FLD10      CHECK IF OPERAND LENGTH ZERO
         L     R6,FLDSAVE               RESTORE LINKAGE REGISTER
         BR    R6
*   R14 NOW CONTAINS TRUE LENGTH,R3 CONTAINS OUTPUT COLUMN POINTER
FLD10    BCTR  R14,0                    DECREASE TO MOVE LENGTH
         GOIF  COLOVLP,OFF=FLD20        BRANCH IF OVERLAP BIT OFF
         CH    R3,COLSAV                DID FIELDS OVERLAPPED?
         BNL   FLD20                    NO,BRANCH AROUND
         LH    R3,COLSAV                GET ADJUSTED COLUMN PTR
FLD20    EQU   *                        BRANCH LABEL
         SET   COLOVLP,ON               TURN OVERLAP CHECK BIT ON
         L     R1,JCTCHR                GET END COLUMN - 1
         SR    R1,R3                    GET MAXIMUM MOVE LENGTH
         LA    R15,D2(R3,R14)           COMPUTE NEXT FIELD PTR
         STH   R15,COLSAV               SAVE COLUMN PTR FOR NXT FIELD
         CR    R14,R1                   WILL FIELD FIT INTO THIS LINE
         LA    R3,SOURCE-D1(R3)         GET PRINT POSITION
         BH    FLD100                   BRANCH IF LINE WONT FIT
         EX    R14,MOVE                 MOVE IT
         L     R6,FLDSAVE               RESTORE LINK REGISTER
         BR    R6                       RETURN
*  MOVE PART OF FIELD
FLD100   EX    R1,MOVE                  MOVE PART OF FIELD
         SR    R14,R1                   GET LENGTH OF REMAINDER
         STH   R14,HWD                  SAVE LENGTH
         LA    R4,D1(R1,R4)             GET ADDR OF REMAINING PART
         BAL   R6,STRING                INSERT STRINGS INTO PRINT LINE
             GOIF  JNUM,OFF=FLD30           DO WE PRINT SEQ NUMBER?
         MVC   SEQNO(8),SEQNUM          YES,MOVE SEQNUM TO PROPER PLACE
         MVI   SEQNUM,JBLANK            SET BLANK CHARACTER
         MVC   SEQNUM+1(7),SEQNUM       BLANK OUT SEQNUM
         BAL   R6,ZEROSUP               SUPRESS LEADING ZEROS
FLD30    EQU   *                        BRANCH LABEL
         JTPRINT                        CALL TERMINAL PRINT
         BAL   R6,INITBUF               INITIALIZE BUFFER
*
         LH    R14,HWD                  GET LENGTH AGAIN
         L     R3,JCTBGN                SET OUTPUT COLUMN POINTER
         LA    R3,D1(,R3)                 TO CONTINUE COLUMN
         XC    COLSAV,COLSAV            ZEROED OUT SAVEAREA
         SET   COLOVLP,OFF              TURN OFF OVERLAP CHECK BIT
         B     FLD10                    GO MOVE REMAINING PART
*STRING
*   EXTRACT STRINGS FROM TEXT RECORD AND INSERT THEM INTO THE CURRENT
*   PRINT LINE. STRADR(ADDRESS OF STRING GROUP) AND CDSTMT(CARD WITHIN
*   START COUNTER) ARE UPDATED
STRING   EQU   *                        BRANCH LABEL
         LH    R1,CDSTMT                GET CARD WITHIN STMT COUNTER
         LA    R1,D1(R1)                INCREMENT 1
         STH   R1,CDSTMT                UPDATE IT
         TM    JTSYMCNT,JGEN            IS STMT GENERATED?
         BZ    STR050                   NO,BRANCH AROUND
         MVI   GENFLG,JPLUS             YES,PUT IN + SIGN
STR050   EQU   *                        BRANCH LABEL
         L     R15,STRADR               GET STRING GROUP POINTER
         DROP  R4                       DROP USING FOR JTEXTA
         USING JTEXTA,R15               SET NEW USING FOR JTEXTA
         SR    R1,R1                    CLEAR REGISTER
         IC    R1,JTSTC                 GET STRING COUNT
         LTR   R1,R1                    IS IT ZERO?
         BCR   8,R6                     YES,RETURN
         LA    R15,JTSTO                POINT TO OUTPUT COL PTR
STR100   SR    R14,R14                  CLEAR REGISTER
         IC    R14,JTSTL2               GET STRING LENGTH
         BCTR  R14,0                    DECREASE MOVE
         SR    R3,R3                    CLEAR REGISTER
         IC    R3,JTSTO2                GET OUTPUT COLUMN POINTER
         LA    R3,SOURCE-D1(R3)         POINT TO PRINT POSITION
         EX    R14,STRMOVE              MOVE STRING TO OUTPUT
         LA    R15,JTSTR2+D1(R14)       POINT TO NEXT STRING
         BCT   R1,STR100                GO BACK IF MORE
         ST    R15,STRADR
         BR    R6
STRMOVE  MVC   D0(0,R3),JTSTR2          EXECUTED STRING MOVE
         DROP  R15                      DROP USING FOR JTEXTA
         USING JTEXTA,R4                BACK TO OLD USING
MOVE     MVC   D0(0,R3),FIELD           EXECUTED MOVE TO PRINT
INITBUF  EQU   *        F               BRANCH LABEL
         LA    R11,BUFTERM              GET BUFFER ADDRESS
         MVI   BUFC,SPACE1              DO SINGLE SPACE
         MVI   PRTIMG,JBLANK            BLANK FIRST BYTE
         MVC   PRTIMG+D1(L'PRTIMG-D1),PRTIMG  BLANK THE REST
         BR    R6                       RETURN TO CALLER
*  CONVERT TO DECIMAL
*
PRN800   CVD   R1,DWORD1                CONVERT NUMBER TO DECIMAL
         UNPK  DWORD2(5),DWORD1         UNPACK NUMBER
         NC    DWORD2(5),MASK1          MASKED OUT ZONE BITS
         LA    R1,D4                    GET MAXIMUM BLANKS TO ADD
         LA    R15,DWORD2               POINT TO NUMBER
PRN810   CLI   D0(R15),J0               IS LEADING DIGIT ZERO
         BNE   PRN820                   NO
         MVI   D0(R15),JBLANK           YES,BLANK OUT
         LA    R15,D1(R15)              BUMP POINTER
         BCT   R1,PRN810                GO BACK IF MORE
PRN820   BR    R6                       RETURN
*       SUPRESS LEADING ZEROS IN SEQUENCE NUMBER
ZEROSUP  LA    R3,D8                    GET LENGTH OF NUM FIELD
         LA    R2,SEQNO                 GET ADDRESS
ZEROS    CLI   D0(R2),J0                LEADING ZERO ?
         BNE   ZERORET                  NO
         MVI   D0(R2),JBLANK            SUPRESS LEADING ZERO
         LA    R2,D1(R2)                POINT TO NEXT DIGIT
         BCT   R3,ZEROS                 DECREMENT COUNT
ZERORET  BR    R6                       RETURN TO CALLER
MASK1    DC    5X'0F'                   MASK TO REMOVE ZONE BITS
         JPATCH X6B20,256               5% PATCH AREA
         END   BEGIN
