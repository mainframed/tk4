* /* START OF SPECIFICATIONS ****
*02* PROCESSOR = ASSEMBLER
**** END OF SPECIFICATIONS ***/
         GBLC  &COMPNM,&ASMID
         SPACE 2
         JHEAD 'ASSEMBLY PHASE - DC EVALUATION',                       X
               PHASEID=X5D,                                            X
               LEVEL=10
*                                                                     *
*FUNCTION                                                             *
*   1. SCAN DC/DS/DXD OPERAND FIELDS ENCODED IN TEXT-BUCKET FORMAT.   *
*   NOTE- LITERAL-POOL GENERATED CONSTANTS ARE PROCESSED IN THE SAME  *
*   MANNER AS DC OPERANDS.                                            *
*   2. CONVERT ALL CONSTANTS TO HEXADECIMAL AND OUTPUT THE REQUIRED   *
*   OBJECT CODE, EXCEPT ON DS/DXD CALLS, FOR PRINTING AND/OR PUNCHING.*
*   3. LIST THE CORRESPONDING SOURCE OR GENERATED STATEMENTS.         *
*   4. ALIGN AND INCREMENT THE LOCATION-COUNTER FOR EACH CONSTANT     *
*   THAT DOES NOT HAVE A SYNTACTIC ERROR.  PRINTING AND/OR PUNCHING   *
*   ALIGNMENT BYTES WHERE REQUIRED.                                   *
*   5. OUTPUT RLD RECORDS FOR A-, Y-, V- AND Q-TYPE CONSTANTS.        *
*   7. LOG THOSE ERRORS THAT ARE DETECTED.                            *
*                                                                     *
*ENTRY POINT                                                          *
*        DCEVAL                                                       *
*                                                                     *
*INPUT                                                                *
*   R10 POINTS TO THE 1ST TEXT-BUCKET OF THE OPERAND FIELD.           *
*   R7 POINTS TO THE ASSEMBLY PHASE WORK AREA, X5COM.                 *
*   THE HALF-WORD AT LCTRSAV+D8 IS A COUNT OF THE NUMBER OF VALID     *
*   OPERANDS.                                                         *
*   FLAGS IN THE COMMON REGION ARE SET TO INDICATE THE TYPE           *
*   OF CALL-                                                          *
*   DSSW  - DS STATEMENT                                              *
*   DXDSW - DXD STATEMENT                                             *
*                                                                     *
*OUTPUT                                                               *
*   NO INFORMATION IS RETURNED TO THE CALLING ROUTINE.  IN DC AND     *
*   LITERAL-POOL CONSTANTS, OBJECT CODE IS PASSED TO THE PRINT/PUNCH  *
*   ROUTINE FOR OPTION-CONTROLLED OUTPUT. SIMILARLY, PRINT/PUNCH IS   *
*   CALLED FOR STATEMENT LISTING.  RLD RECORDS ARE OUTPUT FOR THOSE   *
*   RELOCATABLE A- AND Y-TYPE CONSTANTS AND VALID V- AND Q-TYPE       *
*   CONSTANTS WHICH OCCUR IN A DC OR LITERAL-POOL IN A REAL CONTROL-  *
*   SECTION, WITHOUT A ZERO DUP-FACTOR.                               *
*   THE LOCATION-COUNTER WILL BE ALIGNED AND INCREMENTED AS REQUIRED. *
*   SEMANTIC ERRORS ARE LOGGED BUT DO NOT AFFECT THE LOCATION-COUNTER *
*   ADJUSTMENTS.                                                      *
*                                                                     *
*EXTERNAL REFERENCES                                                  *
*        IFNX5A21 - FOR LOCATION-COUNTER ALIGNMENT                    *
*        IFNX5A31 - FOR LOCATION-COUNTER INCREMENTING                 *
*        IFNX5A41 - FOR RLD OUTPUT                                    *
*        IFNX5A51 - FOR XREF OUTPUT                                   *
*        IFNX5F01 - FOR FIXED- AND FLOATING-POINT CONVERSION          *
*        IFNX5L01 - FOR ERROR LOGGING                                 *
*        IFNX5P01 - FOR PRINT/PUNCH                                   *
*        IFNX5V01 - FOR EXPRESSION EVALUATION                         *
*                                                                     *
*EXITS, NORMAL                                                        *
*   THIS ROUTINE ALWAYS EXITS NORMALLY, VIA THE JRETURN MACRO.        *
*                                                                     *
*EXITS, ERROR                                                         *
*   NONE                                                              *
*                                                                     *
*TABLES/WORK AREAS                                                    *
*   ONLY ONE INTERNAL TABLE IS USED -                                 *
*   DCTABLE CONTAINS THE INFORMATION NECESSARY TO PROCESS EACH        *
*   CONSTANT TYPE.                                                    *
*   EXTERNAL TABLES ACCESSED ARE -                                    *
*   JTRTABLE - INTERNAL-TO-EXTERNAL CHARACTER-SET TRANSLATE TABLE,    *
*   USED FOR C-TYPE CONSTANT.                                         *
*   USINGT - USED FOR ADDRESS DECOMPOSITION IS S-TYPE CONSTANTS.      *
*   WORK SPACE IS CURRENTLY 106 BYTES, FULL-WORD ALIGNED, AT LOCATION *
*   WORKAREA IN THE X5COM  AREA.                                      *
*                                                                     *
*ATTRIBUTES                                                           *
*   REENTRANT, READ-ONLY, REUSABLE                                    *
*                                                                     *
*NOTES                                                                *
*   THE STATUS OF PRINTSW IS SAVED ON ENTRY AND RESTORED ON EXIT.     *
*                                                                     *
   TITLE '&COMPNM&ASMID - ASSEMBLY PHASE - DC EVALUATION - COPY CODE'
         PRINT OFF                      DON'T PRINT JCOMMON COPY CODE
         COPY  JCOMMON                  COPY ASSEMBLER COMMON MODULE
         PRINT OFF                      DON'T PRINT JTEXT COPY CODE
         COPY  JTEXT                    GET TEXT DEFINITION
         PRINT OFF                      DON'T PRINT X5COM COPY CODE
         COPY  X5COM                    GET COMMON WORK AREA DSECT
         PRINT OFF                      DON'T PRINT JERMSGCD COPY CODE
         COPY  JERMSGCD                 DEFINE ERROR CODES AND SEVERITY
         PRINT ON                       WE'RE PAST THE COPY CODE
         SPACE 2
BASE     EQU   X'01'                    BASE MASK - XREF DEFN
REF      EQU   X'02'                    REFERENCE MASK - XREF
DUP      EQU   X'03'                    DUPLICATE MASK - XREF
         USING X5COM,R7                 ESTABLISH COMMON USING
   TITLE '&COMPNM&ASMID - ASSEMBLY PHASE - DC EVALUATION - INITIALIZATIO
               ON'
         JCSECT (X5D00)                 START MODULE CSECT
* VS1 RELEASE 2 CHANGES
*A027700-027920,075700                                          OX00221
* VS1 RELEASE 2.6 CHANGES
*A718900-719120                                                 OX00223
*A027800-027980,045300,075720                                   OX00107
*C075700                                                        OX00107
* VS1 RELEASE 3.1 CHANGES
*C527200,5278800                                                OX02675
*A027700                                                        OY02614
* VS2 RELEASE 3.0 CHANGES
*C359200                                                        OY02610
*A025100                                                       @OX08862
*A593500,593520                                                @OY06592
*C593600                                                       @OY06592
*A480100,481500                                                @OX09734
*C736800,737000                                                @OX09734
*C614400,615200                                                @OZ04407
*C603200,604000                                                @OX08876
*C623200                                                       @OY11250
*C475600-480100                                            D78 @AX21436
         JMODID ,                       CREATE MODULE  ID
DCEVAL   JSAVE BASE=YES                 SAVE ENTRY REGISTERS
         JENTRY (X5D01=DCEVAL)          DEFINE ENTRY POINT
         XC    CLEAR2(CLEAR1-CLEAR2),CLEAR2       CLEAR BIG WORK
         XC    X5ATEMP,X5ATEMP          CLEAR ERROR LOGGING AREA
         XC    DCLNG,DCLNG              CLEAR ACC LENGTH AREA
         XC    ZDUPSW,ZDUPSW            CLEAR ZERO DUPFACTOR SWITCH
         LR    R6,R10                   SET TEXT POINTER
         ST    R10,JFWORD2              SAVE OPER ADDR         @OX08862
LITSKIP  MVC   DCPRSW,PRINTSW           SAVE PRINT SWITCH
         NI    EVALMODE,BITFF-(SUBLIST) JUST IN CASE            OY02614
         LR    R4,R10                   SAVE REG                OX00107
         BCTR  R4,0                     POINT TO LENGTH         OX00107
         CLI   0(R4),X'00'              LENGTH EQ ZERO          OX00107
         BNE   LITSKIP1                 BRANCH IF NOT ZERO      OX00107
         SET   NOOP,ON                  SET FLAG FOR NO OPERAND OX00107
LITSKIP1 EQU   *                                                OX00107
         GOIF  DSSW,ON=SETPDUM          IS ENTRY A DS
         GOIF  DXDSW,OFF=PNODUM         NO, IS THIS DXD
SETPDUM  OI    PRINTSW,BIT5             TURN ON PRINT DUMMY-BIT
         MVI   DUMSW,TESTER             AND LOCAL DUMMY FLAG
PNODUM   LA    R5,LEFTHF                SET PRINT-AREA BASE
         USING LEFTHF,R5                ESTABLISH LEFT HALF USING
         L     R1,ELCTR                 GET CURRENT LC
         LA    R1,D0(,R1)               CLEAR WRAP BITS
         ST    R1,LOCATN                TO PRINT
         SLL   R1,D3                    CHANGE TO BITS
         ST    R1,BITLC                 SET BIT LC
         XC    DCDATA,DCDATA            CLEAR PRINT DATA
   TITLE '&COMPNM&ASMID - ASSEMBLY PHASE - DC EVALUATION - NEXT OPERAND*
                INIT && DUP FACTOR CHECK'
NEXTOP   XC    WORKAREA(CLEAR2-WORKAREA),WORKAREA      SMALL CLEAR
         MVI   TUBEOP,TESTER-TESTER     TURN OFF DUP FACTOR ERROR IND
         LH    R1,OPNDCT                STEP
         LA    R1,D1(,R1)                   OPERAND
         STH   R1,OPNDCT                       COUNT
         SET   XRFNO,ON                 SET XREF SWITCH ON
         MVC   LCTRSAV+D12,ELCTR        SAVE LOCATION COUNTER
         MVC   LCTRSAV+D10(D2),OBITS    SAVE OUTPUT BIT COUNT
         SPACE 5
         GOIF  NOOP,ON=NOOPRND          TEST IF NO OPERAND      OX00107
         LA    R11,D1                   PRE-SET VALUE TO 1.
         BAL   R9,EVAL1                 GO SET UP EVAL CALL
         B     DFZCHEK0                 GO CHECK FOR ZERO DUPLICATION
         GOIF  D0(R6),JLPARN,NE=DFVSET  IS THERE AN EXPRESSION
         SET   (SUBLIST,PRDEFREQ),ON    INIT SWITCHES ON
         LR    R10,R6                   POINT AT LEFT PAREN
         JCALL EVAL                     CALL THE EVALUATION ROUTINE
         JEXTRN (X5V01=EVAL)            DEFINE EVAL AS EXTERNAL
         LR    R6,R14                   RESTORE POINTER
         BC    D1,DUPERR                FATAL DUP FACTOR ERROR BRANCH
         BZ    DFZCHEK                  LOG ERROR IF NOT ABSOLUTE
DSCAN2   MVI   TUBEOP,TESTER            INDICATE DUP FACTOR ERROR
         LA    R11,D1                   DUMMY UP DUP FACTOR
         B     DFZCHEK                  GO SAVE DUP FACTOR
DFZCHEK0 LTR   R11,R11                  SELF DEFINING ZERO
         BNZ   DFVSET                   SET VALUE
         OI    ZDUPSW,BITFF             INDICATE SELFDEF ZERO
DFZCHEK  LTR   R11,R11                  TEST FOR ZERO DUP FACTOR
         BP    DFVSET                   NO - POSITIVE - OK
         BM    DSCAN2                   NO - NEGATIVE - NOT OK
         OI    ZDUPSW,TESTER            SET ZERO DUP-FACTOR FLAG
DFVSET   ST    R11,DUPF                 SAVE DUP FACTOR
   TITLE '&COMPNM&ASMID - ASSEMBLY PHASE - DC EVALUATION - TYPE RANGE CH
               HECK'
         GOIF  D0(R6),JALFAMIN,LT=TYPERR CHECK TYPE FOR LEGAL
         GOIF  D0(R6),JALFAMAX,GT=TYPERR RANGE OF ALLOWABLE TYPES
         MVC   TYPE(D1),D0(R6)           SAVE TYPE
         TR    TYPE(D1),DCTRBL-JALFAMIN  TRANSLATE TYPE
         SR    R3,R3                    ZERO REGISTER
         IC    R3,TYPE                  GET TYPE
         LTR   R3,R3                    IS TYPE VALID
         BZ    TYPERR                   BRANCH IF ILLEGAL TYPE
         BCTR  R3,0                     DECREMEN FOR LOOKUP
         MH    R3,TABLENG               TIMES LENGTH OF TABLE
         LA    R3,DCTABLE(R3)           PLUS TABLE ORIGIN
         LH    R1,IMPLINC(,R3)          IMPLIED LENGTH
         ST    R1,LMOD                  TO L-MODIFIER
         SLL   R1,D3                    BYTES TO BITS
         ST    R1,BITMOD                IN BIT-LENGTH MODIFIER
         LA    R6,D1(,R6)               STEP TEXT PNTR
         B     LTEST                    GO TEST FOR LENGTH MODIFIER
TYPERR   ST    R6,ERRPTR                SAVE ERROR COLUMN PTR
         X5ERRL 198,CLMPTR              INVALID DC,DS, OR DXD TYPE
         TM    TUBEOP,TESTER            DUP FACTOR ERROR
         BZ    STMEND                   NO
DUPERR   X5ERRL 206,0,STMEND            INVALID DUPFACTOR
NOOPRND  SET   NOOP,OFF                 RESET FLAG              OX00107
         X5ERRL 62,0,STMEND             OMITTED OPERAND OX00221,OX00107
   TITLE '&COMPNM&ASMID - ASSEMBLY PHASE - DC EVALUATION - CHECK AND ALI
               IGNMENT IF NONE'
LTEST    GOIF  D0(R6),JL,NE=LNOBIT      IS THERE A LENGTH MODIFIER
         LA    R6,D1(,R6)               STEP OVER L BUCKET
         MVI   LMODSW,TESTER            TURN ON EXPLICIT-LENGTH FLAG
         GOIF  D0(R6),JPERIOD,NE=LNOBIT IS LENGTH MODIFIER BIT LENGTH
         TM    FLAGINC(R3),BIT1         IS BIT LENGTH LEGAL
         BO    LTEST1                   YES,BRANCH AROUND
         ST    R6,ERRPTR                SAVE COLUMN PTR FOR LOGGING
         B     LIMITH                   GO LOG LENGTH ERROR
LTEST1   MVI   BITLSW,TESTER            YES, TURN ON BIT-LENGTH FLAG
         LA    R6,D1(,R6)               STEP OVER POINT BUCKET
         B     TUBECHK                  TO CHECK INTERLUDE ERROR
LNOBIT   LH    R2,OBITS                 GET OUTPUT-BIT COUNT
         LA    R2,D7(,R2)               PAD PARTIAL BYTE
         N     R2,BYTEMSK
         STH   R2,OBITS
         CLI   OBITS+D1,D8*D8           CHECK FULL OUTPUT
         BL    SETEMP                   NO
         LA    R1,ENTDC                 SET FOR DC PRINT
         L     R12,=A(DCPRINT)          SET FOR DCPRINT
         BALR  R9,R12                   BRANCH TO ROUTINE
SETEMP   L     R1,BITLC                 PAD BIT LOCATION COUNTER
         AH    R1,SEVEN                 TO BYTES AND
         SRL   R1,D3                    STORE IN TEMPORARY LC
         LA    R1,D0(,R1)               CLEAR WRAP BIT
         ST    R1,TEMPLC
         L     R2,ELCTR                 GET NON-WRAP
         LA    R2,0(,R2)                CURRENT LC
         SR    R1,R2                    CHECK FOR PADDING INCREMENT
         BZ    NOLCINC                  NO
         ST    R1,LOCLEN                YES, SET 1 BYTE INCREMENT
         JCALL LOCUPD                   CALL LOCATION COUNTER UPDATE
         JEXTRN (X5A31=LOCUPD)          DEFINE EXTERNAL SYMBOL
NOLCINC  L     R1,TEMPLC                UPDATE BIT LC
         SLL   R1,3
         ST    R1,BITLC
         TM    LMODSW,TESTER            WAS THERE AN L-MODIFIER
         BNZ   TUBECHK                  YES
         LH    R2,ALININC(,R3)          NO, GET ALIGNMENT
         EX    R2,ALNTEST               IS ALIGNMENT REQUIRED
         BZ    NOLIGN                   NO
         TM    ZDUPSW,BITFF             ZERO SELF DEF DUP FACTOR
         BO    ALIGN0                   YES DO ALWAYS ALIGN IF NEEDED
         GOIF  JALGN,OFF=NOLIGN         DON'T ALIGN IF NOALIGN OPTION
ALIGN0   SET   VLIT,ON                  TURN ON SWITCH FOR ALIGN
         JCALL ALIGN                    CALL ALIGNMENT ROUTINE
         SET   VLIT,OFF                 TURN OFF SWITCH USED IN ALIGN
         JEXTRN (X5A21=ALIGN)           DEFINE EXTERNAL SYMBOL
         MVC   LCTRSAV+D12,ELCTR        SAVE LOC CTR
         L     R4,ELCTR                 GET ALIGNED LC
         LA    R4,D0(,R4)               CLEAR WRAP BITS
         SLL   R4,D3                    UPDATE BIT LC
         ST    R4,BITLC                 STORE BIT LOCATION CAONTER
         TM    DUMSW,TESTER             ARE WE IN DS OR DXD
         BZ    LNODUM                   NO
         MVC   LOCATN,ELCTR             UPDATE PRINT LC
         XC    DCDATA,DCDATA            CLEAR PRINT DATA
         MVI   OBITS+D1,D0              CLEAR OUTPUT-BIT COUNT
         B     NOLIGN                   TO CHECK PASS 1 ERROR
* TO PRINT INTER-OPERAND ALIGNMENT ON SEPARATE LINES, REPLACE THE
* FOLLOWING SEGMENT OF CODE WITH THE COMMENT CODE.
LNODUM   CLI   OPNDCT+D1,D1             IS THIS 1ST OPERAND
         BE    ALINOUT                  YES, PRINT SEPARATE ALIGNMENT
         LA    R10,ALINMT               POINT TO ALIGN BYTES
         SR    R2,R2                    CLEAR BIT REMAINDER
         L     R11,FULLWD               GET BYTE COUNT
         SLL   R11,D3                   CONVERT TO BIT COUNT
         L     R12,=A(KOUTPUT)          CALL OUTPUT
         BALR  R9,R12                   BRANCH TO ROUTINE
         B     NOLIGN
*LNODUM  CLI   OBITS+D1,D0              CHECK ANY OUTPUT LEFT
*        BE    ALINOUT                  NO
*        LH    R2,OBITS                 YES, PRINT THEM
*        LA    R1,X'40'
*        LA    R12,DCPRINT
*        BALR  R5,R12
ALINOUT  L     R2,FULLWD                GET BYTES SKIPPED
         LA    R1,ENTALN                SET FOR ALIGNMENT PRINT
         L     R12,=A(DCPRINT)          SET FOR DCPRINT
         BALR  R9,R12                   CALL ROUTINE
TUBECHK  EQU   *                        BRANCH LABEL
NOLIGN   TM    TUBEOP,TESTER            INVALID DUP FACTOR
         BZ    NOLIGN2                  OK
         X5ERRL 206,0,STMEND3           INVALID DUP FACTOR
NOLIGN2  MVC   STRTLC(D4),BITLC         SAVE OPERAND START
         TM    LMODSW,TESTER            CHECK EXPLICIT LENGTH
         BZ    STEST                    NO, TO S-MOD TEST
   TITLE '&COMPNM&ASMID - ASSEMBLY PHASE - DC EVALUATION - EVALUATE LENG
               GTH MODIFIER'
         BAL   R9,EVAL1                 GO SET UP EVAL CALL
         B     SETLMOD                  TO STORE
         CLI   D0(R6),JLPARN            IS IT LEFT PAREN?
         BNE   LDELIM3                  GO LOG ERROR IF NOT
         SET   (SUBLIST,PRDEFREQ),ON    SET SUBLIST AND PRDEFREQ BITS
         LR    R10,R6                   POINT AT LEFT PAREN
         JCALL EVAL                     CALL THE EVALUATION ROUTINE
         LR    R6,R14                   RESTORE POINTER
         BC    D1,STMEND3               SYNTAX ERROR, EXIT
         BZ    SETLMOD                  LOG ERROR IF NOT ABSOLUTE
         X5ERRL 179,CLMPTR,STMEND3      INVALID LENGTH - NOT ABSOLUTE
         SPACE
SETLMOD  LR    R1,R11                   SAVE VALUE
         ST    R1,LMOD                  STORE L-MOD VALUE
         TM    BITLSW,TESTER            CHECK BIT-LENGTH
         BNZ   LBITM                    YES
         SLL   R1,D3                    NO, CHANGE TO BITS
LBITM    ST    R1,BITMOD                SET BIT-LENGTH
         LH    R15,HILMINC(,R3)         GET L-MOD HIGH LIMIT
         TM    DUMSW,TESTER             IS IT DS OR DXD
         BZ    LIMITL                   NO
         CLI   TYPE,XBKT                YES,IS IT C OR X TYPE?
         BH    LIMITL                   NO
         L     R15,BIGLIM               GET SPECIAL UPPER LIMIT
LIMITL   CH    R1,LOLMINC(,R3)          IS IT TOO SHORT?
         BL    LIMITH                   YES, GO LOG ERROR
         CR    R1,R15                   IS IT TOO LONG ?
         BNH   STEST                    NO, CONTINUE
LIMITH   X5ERRL 199,CLMPTR,STMEND       LENGTH ERROR
   TITLE '&COMPNM&ASMID - ASSEMBLY PHASE - DC EVALUATION - SCALE MODIFIE
               ER SCAN && EVALUATION'
STEST    SET   PRDEFREQ,OFF             TURN PRIOR DEF REQ BIT OFF
         GOIF  D0(R6),JS,NE=ETEST       IS THERE A SCALE FACTOR
         TM    FLAGINC(R3),BIT2         IS SCALE ALLOWED?
         BNO   SMBAD                    LOG ERROR IF NOT ALLOWED
         LA    R6,D1(,R6)               STEP OVER S
         MVI   SIGNSW,D0                SET SIGN FLAG PLUS
         GOIF  D0(R6),JMINUS,EQ=SNEG    IS IT NEGATIVE
         GOIF  D0(R6),JPLUS,EQ=SPOS     IS IT POSITIVE
         B     SNOSIGN                  NO, TO GET VALUE
SNEG     MVI   SIGNSW,TESTER            SET SIGN FLAG MINUS
SPOS     LA    R6,D1(,R6)               STEP OVER SIGN
SNOSIGN  BAL   R9,EVAL1                 GO SET UP EVAL CALL
         B     SLIMCHK                  TO VALIDITY CHECK
         CLI   D0(R6),JLPARN            IS IT LEFT PAREN?
         BNE   LDELIM3                  GO LOG ERROR IF NOT
         SET    SUBLIST,ON              TURN SUBLIST BIT ON
         LR    R10,R6                   POINT AT LEFT PAREN
         JCALL EVAL                     CALL THE EVALUATION ROUTINE
         LR    R6,R14                   RESTORE POINTER
         BC    1,STMEND3                SYNTAX ERROR, EXIT
         BNZ   SMBAD                    TO BAD VALUE
SLIMCHK  TM    SIGNSW,TESTER            CHECK MINUS
         LR    R1,R11                   GET VALUE
         BZ    CHKSBIT                  YES
         LCR   R1,R1                    NO, COMPLEMENT VALUE
CHKSBIT  LH    R14,LOSMINC(,R3)         GET VALUE LIMITS
         LH    R15,HISMINC(,R3)
         CR    R1,R14                   CHECK LO LIMIT
         BL    SMBAD                    TOO LOW
         CR    R1,R15                   CHECK HI LIMIT
         BH    SMBAD                    TOO HIGH
ST0SCAL  ST    R1,SMOD                  STORE GOOD S-MOD
         B     ETEST                    TO E-MOD TEST
SMBAD    BAL  R9,ERLOG                  GO LOG ERROR
         DC    AL1(SEV200,ERR200,CLMPTR,0)  INVALID SCALE MODIFIER
         SR    R1,R1                    SET SCALE TO ZERO
         B     ST0SCAL                  GO DO IT
   TITLE '&COMPNM&ASMID - ASSEMBLY PHASE - DC EVALUATION - EXPONENT MODI
               IFIER SCAN && EVALUATION'
ETEST    GOIF  D0(R6),JE,NE=KSCAN       IS THERE AN EXPONENT
         TM    FLAGINC(R3),BIT3         IS EXPONENT ALLOWED?
         BNO   EMBAD                    ERROR IF NOT ALLOWED
         LA    R6,D1(,R6)               STEP OVER E
         MVI   SIGNSW,D0                SET SIGN FLAG PLUS
         GOIF  D0(R6),JMINUS,EQ=ENEG    IS IT NEGATIVE
         GOIF  D0(R6),JPLUS,EQ=EPOS     IS IT POSITIVE
         B     ENOSIGN                  NO, TO GET VALUE
ENEG     MVI   SIGNSW,TESTER            SET SIGN FLAG MINUS
EPOS     LA    R6,D1(,R6)               STEP OVER SIGN
ENOSIGN  BAL   R9,EVAL1                 GO SET UP EVAL CALL
         B     ELIMCHK                  TO VALIDITY CHECK
         CLI   D0(R6),JLPARN            IS IT LEFT PAREN?
         BNE   LDELIM3                  GO LOG ERROR IF NOT
         SET    SUBLIST,ON              TURN SUBLIST BIT ON
         LR    R10,R6                   POINT AT LEFT PAREN
         JCALL EVAL                     CALL THE EVALUATION ROUTINE
         LR    R6,R14                   RESTORE POINTER
         BC    D1,STMEND3               SYNTAX ERROR, EXIT
         BNZ   EMBAD                    TO BAD VALUE
ELIMCHK  TM    SIGNSW,TESTER            CHECK MINUS
         LR    R1,R11                   GET VALUE
         BZ    CHKEBIT                  YES
         LCR   R1,R1                    NO, COMPLEMENT VALUE
CHKEBIT  TM    FLAGINC(R3),EBIT         IS E-MOD LEGAL FOR TYPE
         BZ    EMBAD                    NO
         LH    R14,LOEMINC(,R3)         YES, GET VALUE LIMITS
         LH    R15,HIEMINC(,R3)
         CR    R1,R14                   CHECK LO LIMIT
         BL    EMBAD                    TOO LOW
         CR    R1,R15                   CHECK HI LIMIT
         BH    EMBAD                    TOO HIGH
ST0EXP   ST    R1,EMOD                  STORE GOOD E-MOD
         B     KSCAN                    TO CONSTANT PRE-SCAN
EMBAD    BAL   R9,ERLOG                 GO LOG ERROR
         DC    AL1(SEV201,ERR201,CLMPTR,0)  INVALID EXPONENT MODIFIER
         SR    R1,R1                    SET EXPONENT TO ZERO
         B     ST0EXP                   GO DO IT
EVAL1    CLI   D0(R6),JNUMMAX           IS IT NUMERIC?
         BC    D2,D4(R9)                NO, RETURN
         MVI   SELFDEFN,D0              SET SELF DEFN FLAG OFF
         LR    R10,R6                   POINT TO NUMBER FOR EVAL
         L     R12,=A(EVAL)             GET EVAL ADDRESS
         LR    R2,R9                    SAVE R9
         BALR  R9,R12                   CALL EVAL
         LR    R9,R2                    RESTORE R9
         MVI   SELFDEFN,BITFF           RESET SELFDEFN FLAG
         LR    R6,R14                   SET TEXT POINTER
         BR    R9                       RETURN
 TITLE '&COMPNM&ASMID - ASSEMBLY PHASE - DC EVALUATION - CONSTANT SCAN'
KSCAN    ST    R6,ERRPTR                SAVE COL PTR FOR LOGGING
         TM    DUMSW,TESTER             IS THIS DS OR DXD
         BZ    LDELIM                   NO
         TM    FSTPSW,TESTER            YES, HAVE WE PRINTED YET
         BNZ   MTCHK                    YES
         SR    R1,R1                    FORCE STATEMENT PRINT
         L     R12,=A(DCPRINT)          SET FOR DCPRINT
         BALR  R9,R12                   CALL ROUTINE
MTCHK    GOIF  D0(R6),JBLANK,EQ=KEMPTY
         GOIF  D0(R6),JCOMMA,NE=LDELIM  IS DS VARIABLE LENGTH
KEMPTY   L     R2,BITMOD                YES, FORM TOTAL LENGTH
         L     R1,DUPF                  IN BITS
         MR    R0,R2
DUPDS    ST    R1,BITMOD
         SLDL  R0,D5                    CHECK ADDRESS OVERFLOW
         MVI   MTSW,TESTER              TURN ON EMPTY FLAG
         LTR   R0,R0
         BZ    KDELIM                   TO OK
         ST    R2,BITMOD                TOO BIG, TREAT LIKE NO DUP-F
         B     LENER2                   GO LOG ERROR
LENER    XC    BITMOD,BITMOD            ZERO OUTPUT LENGTH
LENER2   BAL   R9,ERLOG2                GO LOG LENGTH ERROR
         DC    AL1(SEV224,ERR224,CLMPTR,0)  LENGTH ERROR
         B     KDELIM                   PLOW ON
         SPACE
LDELIM   GOIF  D0(R6),JLPARN,NE=LDELIM2 IS IT LEFT PAREN?
         TM    FLAGINC(R3),BIT0         IS IT ADDRESS TYPE?
         BO    LDELIM1                  YES,BRANCH AROUND
LDELIM3  ST    R6,ERRPTR                SAVE COL PTR FOR LOGGING
         SPACE
         B     SYN178                   GO LOG SYNTAX ERROR
         SPACE
LDELIM2  GOIF  D0(R6),JQUOTE,NE=LDELIM3 IS IT A QUOTE?
         TM    FLAGINC(R3),BIT0         IS IT ADDRESS TYPE?
         BO    LDELIM3                  ERROR IF ADDRESS TYPE
         SPACE
LDELIM1  LA    R6,D1(,R6)               STEP OVER QUOTE OR LEFT PAREN
         ST    R6,KONSTRT               SAVE CONSTANT START PNTR
         CLC   DUPF,=F'1'               IS DUP FACTOR GREATER THAN 1
         BNH   DUPLOOP                  NO, DON'T WORRY ABOUT POINT
         CLI   TYPE,ABKT                IS DC AN ADDRES CONSTANT
         BL    DUPLOOP                  NO, WILL NOT HAVE TO POINT
         SET   NOTEWL,ON                SET ON SWITCH TO NOTE IF NECESS
DUPLOOP  XC    KCOUNT(D2),KCOUNT        CLEAR CONSTANT COUNT
MLTLOOP  L     R4,ALPTR                 SET EVAL WORK FOR BUILD
         ST    R4,OUTSTART              SAVE BUILD START ADDRESS
         L     R15,ADDRINC(,R3)         GET PROCESS LOC FOR TYPE
         MVI   KLENGTH+D3,D32           SET TRUNCATION INSURANCE
         BR    R15
ALNTEST  TM    TEMPLC+D3,D0             DUMMY ALIGNMENT TESTER
   TITLE '&COMPNM&ASMID - ASSEMBLY PHASE - DC EVALUATION - PROCESS C-TYP
               PE CONSTANT'
CKON     LH    R12,ONE                  SET STEPPER
         LR    R15,R4                   SAVE OUTPUT START
         MVI   D0(R4),EXBLANK           PRE-SET OUTPUT
         MVC   D1(D17*D15,R4),D0(R4)    TO EXTERNAL BLANKS
CNEXTCH  GOIF  D0(R6),JQUOTE,NE=CAMPR   IS IT A QUOTE
         GOIF  D1(R6),JQUOTE,EQ=CDOUBL  ARE THEY PAIRED?
         GOIF  D1(R6),JBLANK,EQ=CENDS   OK IF BLANK
         GOIF  D1(R6),JCOMMA,EQ=CENDS   OK IF COMMA
         B     LDELIM3                  GO LOG ERROR
CAMPR    GOIF  D0(R6),JAMPER,NE=CNOTDBL IS IT AN AMPERSAND
         GOIF  D1(R6),JAMPER,NE=CERR    ARE THEY PAIRED
CDOUBL   AR    R6,R12                   SKIP OVER DOUBLE
CNOTDBL  MVC   D0(D1,R4),D0(R6)         NEXT CHARACTER TO OUTPUT
         AR    R6,R12                   STEP POINTER TO NEXT CHARACTER
         AR    R4,R12                   STEP OUTPUT POINTER
         C     R6,OPNEND                CHECK FOR END OF OPERAND
         BL    CNEXTCH                  NO, CONTINUE SCAN
         X5ERRL 35,0,STMEND3            NO ENDING QUOTE
CENDS    SR    R4,R15                   GET DATA LENGTH
         LTR   R4,R4                    IS IT ZERO?
         BZ    LDELIM3                  ERROR IF YES
         LR    R1,R4                    SAVE VALUE
         BCTR  R4,0                     FORM MACHINE LENGTH
         EX    R4,CTRANS                TRANSLATE TO EXTERNAL CODE
         SLL   R1,D3                    CHANGE IMPL-LENGTH TO BITS
         TM    LMODSW,TESTER            CHECK EXPLICIT LENGTH
         BNZ   CSPECL                   YES, TO ERROR CHECK
         ST    R1,BITMOD                NO SET IMPLICIT LENGTH
CSPECL   L     R0,BITMOD                GET MOD BIT-LENGTH
         ST    R0,KLENGTH               SET FOR RIGHT-PADDING
         B     LJUST                    TO OUTPUT
CERR     ST    R6,ERRPTR                SAVE COLUMN PTR FOR LOGGING
         X5ERRL 176,CLMPTR,STMEND3      UNPAIRED AMPERSAND
CTRANS   TR   D0(0,R15),JTRTABLE        DUMMY TRANSLATE
   TITLE '&COMPNM&ASMID - ASSEMBLY PHASE - DC EVALUATION - PROCESS X-TYP
               PE CONSTANTS'
XKON     SR    R2,R2                    CLEAR CHARACTER REGISTER
         LR    R1,R2                    ZERO TO INDEX
         LA    R14,D4                   SET SHIFT CONTROL
         LR    R15,R14                  SET SHIFT SWITCHER
         STH   R2,D0(R4)                CLEAR WORKAREA
         MVC   D2(D16*D16,R4),D0(R4)    CLEAR WORKAREA
         LA    R0,UNBKT                 SET TEXT-BUCKET START TESTER
XNEXTCH  IC    R2,D0(R1,R6)             GET NEXT TEXT BYTE
         CR    R2,R0                    IS IT HEX DIGIT
         BL    XDIGIT                   YES
         B     XCHECK                   GO CHECK FURTHER
XDIGIT   SLL   R2,D0(R14)               SHIFT FOUR OR ZERO
         EX    R2,BSTORE                DIGIT TO OBJECT BYTE
         LA    R1,D1(,R1)               STEP INDEX
         XR    R14,R15                  SWITCH SHIFT CONTROL
         BZ    XNEXTCH                  CONTINUE IF NEW SHIFT 15 ZERO
         LA    R4,D1(,R4)               STEP OBJECT POINTER
         B     XNEXTCH                  CONTINUE
XFINISH  AR    R6,R1                    UPDATE TEXT POINTER
         SLL   R1,2                     HEX COUNT TO BITS
BFINISH  ST    R1,KLENGTH               STORE IMPLICIT BIT-LENGTH
         LTR   R1,R1                    IS IT ZERO?
         BZ    LDELIM3                  ERROR IF YES=
         LA    R4,D1(,R4)               POINT TO PAD BYTES
         TM    LMODSW,TESTER            CHECK EXPLICIT LENGTH
         BNZ   LJUST                    YES, TO OUTPUT
         AH    R1,SEVEN                 NO, PAD BITS TO BYTES
         N     R1,BYTEMSK
         ST    R1,BITMOD                SET IMPLICIT LENGTH
         B     LJUST                    TO LEFT PAD TEST
BSTORE   OI    D0(R4),D0                DUMMY BIT-STORE
         SPACE
XCHECK   LA    R0,JQUOTE                PUT JQUOTE IN REG
         CR    R2,R0                    IS IT A QUOTE?
         BE    XFINISH                  FINISH IF EQUAL
         LA    R0,JCOMMA                GET COMMA TEXT
         CR    R2,R0                    IS IT COMMA?
         BE    XFINISH                  GO TO FINISH SCAN
XBERR1   ST    R6,ERRPTR                SAVE COL PTR FOR LOGGING
         X5ERRL 236,CLMPTR,STMEND3      ILLEGAL CHARACTER
   TITLE '&COMPNM&ASMID - ASSEMBLY PHASE - DC EVALUATION - PROCESS B-TYP
               PE CONSTANTS'
BKON     SR    R1,R1                    CLEAR BIT-LENGTH
         STH   R1,D0(,R4)               CLEAR WORK AREA
         MVC   D2(D16*D16,R4),D0(R4)    CLEAR WORKAREA
         BCTR  R4,0                    COMPENSATE FOR 1ST INCREMENT
BBITMSK  LA    R15,X'80'                POSITION OBJECT BIT
         LA    R2,D8                    SET SHIFT COUNTER
         LA    R4,D1(,R4)               STEP OBJECT POINTER
BNEXTCH  CLI   D0(R6),D1                IS TEXT BYTE 1
         BL    BZERO                    NO, IT IS ZERO
         BE    BONE                     YES
         CLI   D0(R6),JQUOTE            IS IT A QUOTE?
         BE    BFINISH                  FINISH IF EQUAL
         CLI   D0(R6),JCOMMA            IS IT COMMA?
         BE    BFINISH                  YES, GO TO FINISH
         B     XBERR1                   GO LOG ERROR
BONE     EX    R15,BSTORE               BIT TO OBJECT BYTE
BZERO    SRL   R15,D1                   SHIFT OBJECT BIT
         LA    R1,D1(,R1)               STEP BIT-LENGTH
         LA    R6,D1(,R6)               STEP TEXT POINTER
         BCT   R2,BNEXTCH               REDUCE SHIFT COUNTER AND LOOP
         B     BBITMSK                  GO RE-SET FOR NEW BYTE
   TITLE '&COMPNM&ASMID - ASSEMBLY PHASE - DC EVALUATION - PROCESS P-TYP
               PE CONSTANTS'
PKON     SR    R2,R2                    CLEAR CHARACTER REGISTER
         LR    R1,R2                    ZERO TO INDEX
         LA    R14,D4                   SET SHIFT CONTROL
         LR    R15,R14                  SET SHIFT SWITCHER
         LA    R0,JQUOTE                SET QUOTE TESTER
         LA    R10,JCOMMA               SET COMMA TESTER
         XC    D0(D18,R4),D0(R4)        CLEAR 1ST 17 BYTES      OY02610
         LA    R9,X'0C'                 SET PLUS-ZONE CODE
         CLI   D0(R6),JPLUS             CHECK PLUS SIGN
         BE    PTSTEP                   YES
         CLI   D0(R6),JMINUS            NO, CHECK MINUS SIGN
         BNE   PNEXTCH                  NO
         LA    R9,X'0D'                 YES, SET MINUS-ZONE CODE
PTSTEP   LA    R6,D1(,R6)               STEP TEXT POINTER
PNEXTCH  IC    R2,D0(R1,R6)             GET NEXT TEXT BYTE
         LA    R12,D0(R1,R6)            GET OPERAND POINTER
         CLI   D0(R12),J9               IS IT NUMERIC?
         BNH   PDIGIT                   BRANCH IF YES
         CLI   D0(R12),JPERIOD          IS IT A PERIOD?
         BE    PCHECK                   BRANCH IF EQUAL
         CR    R2,R10                   IS IT A COMMA?
         BE    PKON1                    BRANCH IF EQUAL
         CR    R2,R0                    IS IT A QUOTE?
         BNE   XBERR1                   LOG ILLEGAL CHARACTER ERROR
         SPACE
PKON1    LTR   R1,R1                    NULL OPERAND?
         BZ    LDELIM3                  ERROR IF YES
         AR    R6,R1                    DONE, UPDATE TEXT POINTER
         SLL   R9,D0(R14)               SHIFT ZONE CODE FOUR OR ZERO
         EX    R9,BSTORE                ZONE TO LAST OBJECT BYTE
         CH    R1,HISMINC(,R3)          IS IT GREATER THAN 31
         BH    LENER                    ERROR IF YES
         LA    R1,D1(,R1)               INCLUDE ZONE IN COUNT
         SLL   R1,D2                    DIGIT COUNT TO BITS
         B     BFINISH                  TO CHECK L-MOD
PDIGIT   SLL   R2,D0(R14)               SHIFT FOUR OR ZERO
         EX    R2,BSTORE                DIGIT TO OBJECT BYTE
         LA    R1,D1(,R1)               STEP INDEX
         XR    R14,R15                  SWITCH SHIFT CONTROL
         BZ    PNEXTCH                  CONTINUE IF NEW SHIFT IS ZERO
         LA    R4,D1(,R4)               STEP OBJECT POINTER
         B     PNEXTCH                  CONTINUE
PCHECK   GOIF  VLIT,ON=ZCHECK1          GO IF PERIOD SWITCH IS ON
         SET   VLIT,ON                  SET PERIOD SWITCH ON
         B     PTSTEP                   GO SKIP PERIOD
   TITLE '&COMPNM&ASMID - ASSEMBLY PHASE - DC EVALUATION - PROCESS Z-TYP
               PE CONSTANTS'
ZKON     SR    R2,R2                    CLEAR CHARACTER REGISTER
         LR    R1,R2                    ZERO TO INDEX
         LA    R0,JQUOTE                SET QUOTE TESTER
         LA    R10,JCOMMA               SET COMMA TESTER
         LA    R15,X'F0'                SET NUMERIC ZONE CODE
         STC   R15,D0(,R4)              PRE-SET 15 PAD BYTES
         MVC   D1(D14,R4),D0(R4)
         LA    R4,D15(,R4)              STEP OUTPUT OVER PAD
         LA    R9,X'CF'                 SET PLUS ZONE MASK
         CLI   D0(R6),JPLUS             CHECK PLUS SIGN
         BE    ZTSTEP                   YES
         CLI   D0(R6),JMINUS            CHECK MINUS SIGN
         BNE   ZNEXTCH                  NO
         LA    R9,X'DF'                 YES, SET MINUS ZONE MASK
ZTSTEP   LA    R6,D1(,R6)               STEP TEXT POINTER
ZNEXTCH  IC    R2,D0(R1,R6)             GET NEXT TEXT BYTE
         LA    R12,D0(R1,R6)            GET OPERAND POINTER
         CLI   D0(R12),J9               IS IT NUMERIC?
         BNH   ZDIGIT                   BRANCH IF YES
         CLI   D0(R12),JPERIOD          IS IT A PERIOD?
         BE    ZCHECK                   BRANCH IF EQUAL
         CR    R2,R10                   IS IT A COMMA?
         BE    ZKON1                    BRANCH IF EQUAL
         CR    R2,R0                    IS IT A QUOTE?
         BNE   XBERR1                   LOG ILLEGAL CHARACTER ERROR
         SPACE
ZKON1    LTR   R1,R1                    IS IT ZERO?
         BZ    LDELIM3                  ERROR IF YES
         AR    R6,R1                    DONE, UPDATE TEXT POINTER
         BCTR  R4,0                     BACK UP OUTPUT POINTER
         AR    R4,R1                    POINT TO LAST OUTPUT BYTE
         EX    R9,ZSIGN                 CHANGE LAST BYTE ZONE TO SIG
         CH    R1,HISMINC(,R3)          IS IT GREATER THAN 16
         BH    LENER                    ERROR IF YES
         SLL   R1,D3                    DIGIT COUNT TO BITS
         TM    LMODSW,TESTER            CHECK EXPLICIT LENGTH
         BNZ   ZINC                     YES
         ST    R1,BITMOD                NO, SET IMPLICIT LENGTH
ZINC     LA    R1,D8*D15(,R1)           INSURE NEEDED PADDING
         ST    R1,KLENGTH               STORE IMPLICIT BIT-LENGTH
         B     LJUST                    TO LEFT PAD TEST
ZDIGIT   OR    R2,R15                   SET NUMERIC ZONE
         STC   R2,D0(R1,R4)             STORE OBJECT BYTE
         LA    R1,D1(,R1)               STEP INDEX
         B     ZNEXTCH                  CONTINUE
ZCHECK   GOIF  VLIT,ON=ZCHECK1          GO IF PERIOD SWITCH IS ON
         SET   VLIT,ON                  SET PERIOD SWITCH ON
         B     ZTSTEP                   GO SKIP PERIOD
ZCHECK1  SET   VLIT,OFF                 SET PERIOD SWITCH OFF
         ST    R6,ERRPTR                STORE PTR FOR ERROR LOGGING
SYN178   X5ERRL 178,CLMPTR,STMEND3      ILLEGAL FORMAT
ZSIGN    NI    D0(R4),D0                DUMMY ZONE CHANGER
   TITLE '&COMPNM&ASMID - ASSEMBLY PHASE - DC EVALUATION - PROCESS L-, D
               D-, E-, F-, H-TYPE CONSTANTS'
DKON     LA    R11,WORKAREA             SET PARAMETER POINTER
         LA    R2,D16*D8                SET TRUNCATION INSURANCE
         ST    R2,KLENGTH
         LR    R10,R6                   SET TEXT POINTER
         JCALL DKVERT                   CALL DECIMAL CONVERSION
         JEXTRN (X5F01=DKVERT)          DEFINE EXTERNAL SYMBOL
         TM    EBYTE,X'FF'              WERE ANY ERRORS FLAGGED
         BZ    DKFINISH                 NO, GO TO OUTPUT
         ST    R10,ERRPTR               SAVE ERROR POINTER
         LA    R6,ERLOG2                PT TO ERROR LOGGING ROUTINE
         SPACE 1
         TM    EBYTE,BIT0               SCALE INVALID ERROR
         BZ    DK10                     BR NO ERROR
         BALR  R9,R6                    GO LOG ERROR
         DC    AL1(SEV200,ERR200,CLMPTR,0) SCALE INVALID
         SPACE 1
DK10     TM    EBYTE,BIT1               EXPONENT INVALID ERROR
         BZ    DK20                     BR NO ERROR
         BALR  R9,R6                    GO LOG ERROR
         DC    AL1(SEV201,ERR201,CLMPTR,0) EXPONENT INVALID
         SPACE 1
DK20     TM    EBYTE,BIT2               TRUNCATION ERROR
         BZ    DK30                     BR NO ERROR
         BALR  R9,R6                    GO LOG ERROR
         DC    AL1(SEV203,ERR203,CLMPTR,0) TRUNCATION
         SPACE 1
DK30     TM    EBYTE,BIT4               FLOATING POINT CHAR ERROR
         BZ    DK40                     BR NO ERROR
         BALR  R9,R6                    GO LOG ERROR
         DC    AL1(SEV239,ERR239,CLMPTR,0) FLOATING POINT CHAR
         SPACE 1
DK40     TM    EBYTE,BIT5               PRECISION LOST ERROR
         BZ    DK50                     BR NO ERROR
         BALR  R9,R6                    GO LOG ERROR
         DC    AL1(SEV202,ERR202,CLMPTR,0) PRECISION LOST ERROR
         SPACE 1
DK50     TM    EBYTE,BIT3+BIT6+BIT7     INVALID DELIMITER ERROR
         BZ    DKFINISH                 BR NO ERROR
         BALR  R9,R6                    GO LOG ERROR
         DC    AL1(SEV255,ERR255,CLMPTR,0) INVALID DELIMITER ERROR
         LR    R6,R10                   RESTORE TEXT POINTER
         B     NOTINC                   SYNTAX ERROR, FLUSH STATEMENT
DKFINISH LR    R6,R10                   UPDATE TEXT PTR
         LA    R11,D16(,R11)            POINT TO OUTPUT
         ST    R11,OUTSTART             ''
         B     LJUST                    TO LEFT PAD TEST
         SPACE
         SPACE
         TITLE '&COMPNM&ASMID - ASSEMBLY PHASE - DC EVALUATION '
AYKON    LR    R10,R6                   SET TEXT POINTER
         L     R2,ELCTR                 SAVE CURRENT LOCTR
         JCALL EVAL                     CALL THE EVALUATION ROUTINE
         LR    R6,R14                   UPDATE TEXT PTR
         ST    R2,ELCTR                 RESTORE CURRENT LOCATION CTR
         BZ    MAGCHK                   ABSOLUTE, TO SIZE CHECK
         BH    AYREL                    TO RELOCATABLE
         BC    ERRX,STMEND3             SYNTAX ERROR,EXIT
         GOIF  COMPLEX,EQ=AYREL         IS EXPRESSION COMPLEXLY RELOC
         SR    R1,R1                    ZERO VALUE
         B     NOTY                     TO STORE VALUE
AYREL    CLI   D0(R6),JRPARN            IS IT RIGHT PAREN?
         BE    AYREL1                   BRANCH IF YES
         CLI   D0(R6),JCOMMA            IS IT COMMA?
         BE    AYREL1                   BRANCH IF YES
         B     LDELIM3                  IF NOT GO LOG ERROR
AYREL1   EQU   *                        BRANCH LABEL
         TM    BITLSW,TESTER            CHECK BIT-LENGTH-MOD
         BZ    YCHK                     NO, OK
RELOERR  BAL   R9,ERLOG2                GO LOG ERROR           @AX21436
         DC    AL1(SEV204,ERR204,0,0)   RELOCATION ERROR       @AX21436
         SR    R11,R11                  ZERO EXPRESSION VALUE  @AX21436
         B     MAGCHK                   CHECK FURTHER          @AX21436
YCHK     L     R1,LMOD                  GET L-MODIFIER         @AX21436
         LA    R2,2                     SET A L-TESTER         @AX21436
         CLI   TYPE,YBKT                CHECK Y-TYPE           @AX21436
         BNE   ALCHK                    NO                     @AX21436
         BCTR  R2,0                     SET Y L-TESTER         @AX21436
ALCHK    CLR   R1,R2                    CHECK RELOC LGTH LIMIT @AX21436
         BNH   RELOERR                  LOG ERROR IF NEEDED    @AX21436
         CLI   TYPE,YBKT                CHECK Y-TYPE           @AX21436
         BNE   AYZCHK                   NO                     @AX21436
         GOIF  JYFLAG,OFF=AYZCHK        SUPR ERR MSG YFLAG OFF @AX21436
         BAL   R9,ERLOG2                GO LOG ERROR
         DC    AL1(SEV205,ERR205,0,0)   RELOCATABLE Y-CON
AYZCHK   TM    ZDUPSW,TESTER            CHECK ZERO DUP-F
         BNZ   MAGCHK                   YES, BYPASS RLD
         MVC   DWORD1+D1(D3),ELCTR+D1   GET LOCATION OF A OR Y CON
         ST    R11,EMOD                 SAVE SYMBOL VALUE
         MVI   DWORD1,D0                SET RLD FLAGS
         MVC   DWORD2(D2),LMOD+D2       MOVE LENGTH FOR RLD
         JCALL RLDOUT                   CALL RLD OUTPUT ROUTINE
         JEXTRN (X5A41=RLDOUT)          DEFINE EXTERNAL SYMBOL
         L     R11,EMOD                 RESTORE VALUE
MAGCHK   LR    R1,R11                   GET VALUE
         CLI   D0(R6),JRPARN            IS IT RIGHT PAREN?
         BE    MAGCHK1                  BRANCH AROUND IF YES
         CLI   D0(R6),JCOMMA            IS IT COMMA?
         BE    MAGCHK1                  BRANCH AROUND IF YES
         B     LDELIM3                  LOG ERROR
MAGCHK1  EQU   *                        BRANCH LABEL
         CLI   TYPE,YBKT                IS IT A Y-CON
         BNE   NOTY                     NO
         C     R1,YMASK                 YES, IS IT TOO BIG
         BH    YDATA                    YES
         C     R1,YNMASK                TOO SMALL
         BNL   NOTY                     NO
YDATA    LR    R10,R1                   SAVE REGISTER CONTENT
         BAL   R9,ERLOG2                GO LOG ERROR
         DC    AL1(SEV203,ERR203,CLMPTR,0)  TRUNCATION
         LR    R1,R10                   RESTORE REGISTER CONTENT
*
NOTY     ST    R1,0(,R4)                SET OUTPUT
         B     LJUST                    TO OUTPUT
         EJECT
VKON     LR    R10,R6                   SET TEXT POINTER
         LR    R1,R6                    GET OPERAND POINTER
         GOIF  D0(R6),JALFAMIN,LT=LDELIM3 ERROR IF NOT ALPHABTIC
VESCAN   GOIF  D0(R1),JALFAMAX,GT=VSCN10  IS SYMBOL CONTINUING
         LA    R1,D1(,R1)               YES, CHECK NEXT CHARACTER
         B     VESCAN                   CONTINUE SCAN
VSCN10   GOIF  D0(R1),JCOMMA,EQ=VSCN20  V-CON IS DELIMITED BY A COMMA
         GOIF  D0(R1),JRPARN,EQ=VSCN20   OR A RIGHT PARN
         ST    R1,ERRPTR                SAVE OPERAND PTR FOR ERROR LOG
         B     SYN178                   GO LOG SYNTAX ERROR
VSCN20   SR    R1,R6                    DETERMINE LENGTH OF SYMBOL
         AR    R6,R1                    STEP OPERAND POINTER
         CH    R1,=H'8'                 IS SYMBOL LENGTH LEGAL
         BNH   VSCN30                   YES,GO MAKE RLD
VSCN25   EQU   *                        BRANCH LABEL
         ST    R6,ERRPTR                SAVE OPERAND PTR FOR ERROR LOG
         X5ERRL 187,CLMPTR,STMEND3      INVALID SYMBOL
VSCN30   LTR   R1,R1                    WAS FIELD NULL
         BZ    LDELIM3                  GO LOG ERROR
         LH    R10,JINFILE              POINT TO REFERENCE FILE
         JGETL FILE=(R10)               GET REFERENCE RECORD
         GOIF  NOTEWL,OFF=VSCN15        IS NOTE NECESSARY?
         SET   NOTEHS,ON                TURN ON FILE NOTED SWITCH
         SET   NOTEWL,OFF               TURN OFF NOTE REQUIRED SWITCH
         LR    R2,R11                   SAVE RECORD POINTER
         LH    R10,JINFILE              GET INPUT FILE NUMBER
         JNOTE FILE=(R10)               NOTE INPUT FILE
         MVC   NOTEVAL,JNOTEVAL         SAVE NOTED VALUE
         LR    R11,R2                   RESTORE RECORD POINTER
VSCN15   EQU   *
         L     R14,SYMXRF               INCREMENT               OX02675
         LA    R14,D1(R14)                 SYMBOL COUNT
         ST    R14,SYMXRF               RESTORE SYMBOL XREFED   OX02675
         SPACE
         TM    ZDUPSW,TESTER            IS DUP FACTOR ZERO
         BNZ   LJUST                    YES, NO RLD
         GOIF  DSSW,ON=LJUST            NO RLD IF DS
         MVI   RELOCTR,D1               SET UP RLD DATA
         MVC   RLIST,D6(R11)            SAVE ESD
         MVC   DWORD1+D1(D3),ELCTR+D1   SAVE LOCATION OF V-CON
         MVI   DWORD1,BIT3              SET RLD FLAG
         MVC   DWORD2(D2),LMOD+D2       MOVE LENGTH FOR RLD
         JCALL RLDOUT                   GO CREATE RLD
         XC    D0(D4,R4),D0(R4)         ZERO OUTPUT AREA
         B     LJUST                    CONTINUE OUTPUT
         EJECT
QKON     LR    R10,R6                   SET TEXT POINTER
         GOIF  D0(R10),JALFAMIN,LT=LDELIM3  ERROR IF NOT ALPHABETIC
QESCAN   GOIF  D0(R10),JALFAMAX,GT=QEND SCAN SYMBOL
         LA    R10,D1(,R10)             STEP SCAN POINTER
         B     QESCAN                   CONTINUE SCAN
QEND     GOIF  D0(R10),JCOMMA,EQ=QSCN10 DELIMITER MUST BE A COMMA
         GOIF  D0(R10),JRPARN,EQ=QSCN10 OR A RIGHT PAREN
         ST    R10,ERRPTR               SAVE OPERAND PTR FOR ERROR LOG
         B     SYN178                   GO LOG SYNTAX ERROR
QSCN10   SR    R10,R6                   DETERMINT SYMBOL LENGTH
         BZ    LDELIM3                  BRANCH TO LOG ERROR
         CH    R10,=H'8'                8 CHARACTERS OR LESS
         BH    VSCN25                   BRANCH TO LOG INVALID SYMBOL
         AR    R6,R10                   POINT TO DELIMITER
         LH    R10,JINFILE              POINT TO INPUT FILE
         JGETL FILE=(R10)               GET NEXT RECORD
         TM    D5(R11),BIT1+BIT2        IS IT PREVIOUSLY DEFINED?
         BO    QSCN15                   BRANCH IF YES
         ST    R11,ERRPTR               SAVE RECORD PTR FOR LOGGING
         BAL   R9,ERLOG2                GO LOG ERROR
         DC    AL1(SEV231,ERR231,DTAPTR,0)  SYMBOL NOT PREVIOUSLY DEF'D
QSCN15   EQU   *                        BRANCH LABEL
         GOIF  NOTEWL,OFF=QSCN20        IS NOTE NECESSARY?
         SET   NOTEHS,ON                TURN ON FILE NOTED SWITCH
         SET   NOTEWL,OFF               TURN OFF NOTE REQUIRED SWITCH
         LH    R10,JINFILE              GET INPUT FILE NUMBER
         LR    R2,R11                   SAVE SYMBOL RECORD PTR
         JNOTE FILE=(R10)               NOTE INPUT FILE
         MVC   NOTEVAL,JNOTEVAL         SAVE NOTED VALUE
         LR    R11,R2                   RESTOR RECORD PTR
QSCN20  EQU    *
         GOIF  XRFNO,OFF=QSCN30         DO WE MAKE XREF?
         LA    R2,REF                   INDICATE XREF REF
         JCALL XREF                     GO MAKE XREF ENTRY
QSCN30   EQU   *
         TM    ZDUPSW,TESTER            IS DUP FACTRO ZERO?
         BNZ   LJUST                    BRANCH IF YES
         TM    D3(R11),BIT4+BIT6+BIT7   IS IT DSECT OR DXD?
         BNO   QER4
         MVI   RELOCTR,D1               SET UP RLD DATA
         MVC   RLIST,D6(R11)            SAVE ESD
         NI    RLIST,X'0F'              CLEAR FLAG
         MVC   DWORD1+D1(D3),ELCTR+D1   SAVE LOCATION FOR RLD
         MVC   DWORD2(D2),LMOD+D2       SAVE LENGTH FOR RLD
         MVI   DWORD1,BIT2              SET Q-CON RLD FLAG
         JCALL RLDOUT                   GO CREATE RLD
QRLD1    EQU   *                        BRANCH LABEL
         XC    D0(D4,R4),D0(R4)         ZERO WORK AREA
         B     LJUST                    GO OUTPUT Q-CON
         SPACE
QER4     BAL   R9,ERLOG2                GO LOG ERROR
         DC    AL1(SEV207,ERR207,CLMPTR,0) NOT A DXD OR DSECT NAME
         B     QRLD1                    PLOW ON
         JEXTRN (X5A51=XREF)            DEFINE EXTERNAL SYMBOL
         EJECT
SKON     MVI   SIGNSW,0                 TURN OFF SUB-FIELD FLAG
         XC    DECKON(4),DECKON         CLEAR ESD POINTER
SVLOOP   LR    R10,R6                   SET TEXT POINTER
         JCALL EVAL                     CALL THE EVALUATION ROUTINE
         LR    R6,R14                   UPDATE TEXT PTR
         ST    R11,EMOD                 SET EXPRESSION VALUE
         BZ    SDELIM                   ABSOLUTE, TO CHECK DELIMITER
         BO    SDELIM                   GO CHECK SUB FIELD
         BM    SPLEX                    TO NON-SYNTAX ERROR CHECK
         ST    R10,DECKON               SET EXPRESSION ESD
         B     SDELIM                   TO CHECK DELIMITER
SPLEX    XC    EMOD(4),EMOD             ZERO TO VALUE
         GOIF  COMPLEX,NE=SDELIM        IS EXPRESSION COMPLEXLY RELOC
         BAL   R9,ERLOG2                GO LOG ERROR
         DC    AL1(SEV213,ERR213,CLMPTR,0)  COMPLEXLY RELOCATABLE
SDELIM   TM    EVALSW1,FATALER          HAS AN ERROR OCCURED   @OY06592
         BO    STMEND3                  GO TO NEXT             @OY06592
         CLI   D0(R6),JLPARN            CHECK SUB-FIELD        @OY06592
         BNE   SDCHK                    NO, CHECK DECOMPOSE
         MVI   SIGNSW,TESTER            TURN ON SUB-FIELD FLAG
         MVC   SMOD(4),EMOD             SET DISPLACEMENT VALUE
         LA    R6,D1(,R6)               STEP TEXT POINTER
         B     SVLOOP                   TO SCAN SUB-FIELD
SDCHK    TM    SIGNSW,TESTER            CHECK IF SUB-FIELD
         BNZ   SUBF                     YES
         L     R9,DECKON                GET POF POINTE
         L     R12,EMOD                 GET VALUE
         LA    R14,USINGT               POINT TO USING TABLE
         USING UESD,R14                 ESTABLISH USING
SCOMPB   TM    UREG,X'0F'               THE END OF TABLE?      @OX08876
         BO    SCOMPF                   YES, GO CHECK ABSOLUTE @OX08876
         CH    R9,UESD                  NO, DO ESD'S COMPARE
         BH    SADLOG                   NO, GO LOG ADDRESSING ERROR
         BE    SCOMPD                   YES, GO CHECK DISPLACEMENT
SCOMPC   LA    R14,USNXT                STEP TO NEXT USING ENTRY
         B     SCOMPB                   GO CONTINUE SEARCH
SCOMPD   LR    R1,R12                   GET EXPRESSION VALUE
         S     R1,UVAL                  SUBTRACT USING VALUE
         BM    SCOMPC                   USING VALUE TOO LARGE
         CH    R1,=H'4096'              IS DISPLACEMENT 4096 OR GREATER
         BNL   SCOMPC                   YES, GO CONTINUE SEARCH
         LTR   R12,R12                  IS DISPLACEMENT POSITIVE
         BL    SCOMPE                   NO, GO ALLOW NEG DISPLACEMENT
         TM    UVAL,BITFF               IS USING OUT OF RANGE   OZ04407
         BM    SCOMPC                   YES, DON'T ALLOW IT     OZ04407
SCOMPE   LH    R0,UREG                  GET USING REGISTER
         SLL   R0,D12                   FORM VALUE
         OR    R1,R0
         B     SKONOUT                  TO SET OUTPUT
SCOMPF   LTR   R9,R9                    IS USING ABSOLUTE
         BNZ   SADLOG                   NO, GO LOG ERROR
         LR    R1,R12                   GET VALUE
         CH    R1,=H'4096'              IS DISPLACEMENT TOO LARGE
         BNL   SADLOG                   YES, GO LOG ERROR
         LTR    R1,R1                   IS NEG DISP TO BIG     @OY11250
         BL    SADLOG                   YES, GO LOG ERROR
         N     R1,=A(X'FFF')            CLEAR ANY NEGATIVE BITS
         B     SKONOUT                  GO COMPLETE OUTPUT
SADLOG   BAL   R9,ERLOG2                GO LOG ERROR
         DC    AL1(SEV209,ERR209,CLMPTR,0)  ADDRESSABILITY ERROR
SZVAL    SR    R1,R1                    ZERO TO VALUE
         B     SKONOUT                  TO OUTPUT
SUBF     L     R0,DECKON                CHECK ESD PTR
         LA    R6,D1(R6)                STEP OVER RIGHT PAREN OF SUBFLD
         LTR   R0,R0
         BZ    SDISP                    OK
         BAL   R9,ERLOG2                GO LOG ERROR
         DC    AL1(SEV159,ERR159,0,0)   RELOCATION ERROR
         B     SZVAL                    PLOW ON
SDISP    L     R1,SMOD                  GET DISPLACEMENT
         CL    R1,DISPLIM               CHECK TOO BIG
         BL    SREG                     OK
         BAL   R9,ERLOG2                GO LOG ERROR
         DC    AL1(SEV208,ERR208,0,0)  BAD DISPLACEMENT
         B     SZVAL                    PLOW ON
SREG     L     R2,EMOD                  GET REGISTER
         CL    R2,REGLIM                CHECK TOO BIG
         BNH   SFVAL                    OK
         BAL   R9,ERLOG2                GO LOG ERROR
         DC    AL1(SEV230,ERR230,CLMPTR,0) INVALID REGISTER
         B     SZVAL                    PLOW ON
SFVAL    SLL   R2,12                    FORM VALUE
         CH    R1,=H'-4096'             IS NEGATIVE DISPLACEMENT TO BIG
         BL    SADLOG                   YES, GO LOG ERROR
         N     R1,=A(X'FFF')             CLEAR ANY NEGATIVE BITS
         OR    R1,R2
SKONOUT  ST    R1,0(,R4)                SET OUTPUT
         EJECT
LJUST    GOIF  LITRSW,ON=LITEV          OPERAND OF LITERAL ?
         CLC   OPNDCT(D2),LCTRSAV+D8    OVER OPERAND COUNT
         BH    NOTINC                   YES FORGET OUTPUT
LITEV    TM    ZDUPSW,TESTER            CHECK ZERO DUP FACTOR
         BZ    NOZDP2                   NO
         XC    BITMOD(4),BITMOD         YES, CLEAR BIT-LENGTH
         B     KDELIM                   SKIP OUTPUT
NOZDP2   TM    DUMSW,TESTER             IS THIS A DXD OR DS
         BNZ   KDELIM                   YES, SKIP OUTPUT
         L     R10,BITMOD               GET EXPLICIT BIT-LENGTH
         S     R10,KLENGTH              SUBTRACT IMPLICIT LENGTH
         BZ    KNORMAL                  TO NO PAD OR TRUNCATION
         BP    KPAD                     TO OUTPUT PADDING
         LCR   R10,R10                  GET POSITIVE DIFFERENCE
         SRDL  R10,3                    CHANGE TO BYTES
         A     R10,OUTSTART             TRUNCATED START ADDRESS
         LR    R2,R11                   SET BIT REMAINDER
         SRL   R2,29
         L     R11,BITMOD               SET TRUNCATED COUNT
         B     KALLOUT                  TO OUTPUT
KPAD     LR    R11,R10                  SET PAD OUTPUT COUNT
         SR    R2,R2                    CLEAR BIT REMAINDER
         LA    R10,1(,R4)               SET PAD OUTPUT POINTER
         L     R12,=A(KOUTPUT)          CALL OUTPUT
         BALR  R9,R12                   BRANCH TO ROUTINE
KNORMAL  L     R10,OUTSTART             SET CONSTANT START
         SR    R2,R2                    CLEAR BIT REMAINDER
         L     R11,KLENGTH              SET CONSTANT BIT LENGTH
KALLOUT  L     R12,=A(KOUTPUT)          CALL OUTPUT
         BALR  R9,R12                   BRANCH TO ROUTINE
         EJECT
KDELIM   L     R1,BITLC                 INCREMENT BIT LOCATION COUNTER
         A     R1,BITMOD
         LR    R0,R1                    SAVE IT
         L     R2,ELCTR                 GET CURRENT LC
         LA    R2,0(,R2)                CLEAR WRAP BITS
         SRL   R0,3                     TRUNCATE BIT LC TO BYTES
         N     R1,WRAPMSK               CLEAR BIT LC WRAP
         ST    R1,BITLC                 SET UPDATED BIT LC
         SR    R0,R2                    FORM LC INCREMENT
         BZ    NOTINC                   TO NO INCREMENT
         ST    R0,LOCLEN                STORE INCREMENT
         JCALL LOCUPD                   CALL LOCATION COUNTER UPDATE
NOTINC   SET   VLIT,OFF                 TURN OFF PERIOD SWITCH
         L     R1,LMOD                  ACCUMULATE LENGTH OF DC
         A     R1,DCLNG
         ST    R1,DCLNG                 SAVE ACCUMULATED LENGTH
         TM    MTSW,TESTER              IS EMPTY DS SWITCH ON?
         BNZ   OPEND                    YES, TO FINISH OPERAND
         CLI   0(R6),JCOMMA             CHECK MULTIPLE CONSTANT
         LA    R6,1(,R6)                STEP OVER DELIMITER
         BE    MLTKON                   YES
         L     R1,DUPF                  REDUCE DUP-FACTOR
         SH    R1,ONE
         ST    R1,DUPF
         BNP   OPEND                    TO NO DUPLICATE SCAN
         GOIF  LTDECV,ON=STMEND         IS THIS A LITERAL REFERENCE
         GOIF  DSSW,OFF=NOTDS           IS ENTRY A DS
         L     R2,BITLC                 FORM BIT INCREMENT
         S     R2,STRTLC
         MR    R0,R2                    TIMES DUP FACTOR LESS 1
         SR    R2,R2
         B     DUPDS                    TO OVERFLOW CHECK
NOTDS    BCTR  R6,0                     BACK-UP TEXT POINTER
         SET   XRFNO,OFF                TURN OFF XREF
         MVI   SKLOG,TESTER             TURN OFF ERLOG
         TM    FLAGINC(R3),ABIT         CHECK ADDRESS-TYPE
         BO    REPSCAN                  YES, TO SCAN AGAIN
         LH    R0,KCOUNT                TEST MULTIPLE CONSTANTS
         LTR   R0,R0
         BZ    LJUST                    NO, TO REPEAT OUTPUT
REPSCAN  L     R6,KONSTRT               RE-SET TEXT POINTER
         SET   DUPEVAL,ON               INDICATE DUPLICATE EVALUATION
         GOIF  NOTEHS,OFF=DUPLOOP       IS POINT NECESSARY
         LH    R10,JINFILE              POINT TO INPUT FILE
         JPOINT FILE=(R10),NEXT=GET,ADDR=NOTEVAL POINT BACK FOR SYMBOLS
         SET   XRFNO,OFF                TURN XREF OFF
*                                                TO BE RESCANNED
         B     DUPLOOP
MLTKON   LH    R1,KCOUNT                STEP CONSTANT COUNT
         LA    R1,1(,R1)
         STH   R1,KCOUNT
         B     MLTLOOP                  TO SCAN NEXT CONSTANT
         EJECT
OPEND    SET   (NOTEWL,NOTEHS),OFF      TURN OFF NOTE POINT SWITCHES
         SET   DUPEVAL,OFF              RESET DUP EVALUATION
         GOIF  LTDECV,ON=OPEND1         IF LITERAL,EXIT
         GOIF  LITRSW,ON=STMEND         IF LITERAL DC THEN EXIT
         CLI   D0(R6),JCOMMA            IS COMMA NEXT
         BNE   STMEND1                  GO CHECK FOR BLANK
         LA    R6,1(,R6)                YES, STEP OVER COMMA
         B     NEXTOP                   TO NEXT OPERAND
OPEND1   LR    R10,R6                   RESTORE OPERAND POINTER
         B     KLEANUP                  GO CLEAN UP AND EXIT
STMEND3  EQU   *                        BRANCH LABEL
         MVC   ELCTR,LCTRSAV+D12        RESTORE LOCTR
         MVC   OBITS(2),LCTRSAV+D10     RESTORE OUTPUT BIT COUNT
         SET   (NOTEWL,NOTEHS),OFF      TURN OFF NOTE SWITCHES
         TM    DUMSW,TESTER             IS IT A DS              OX00223
         BZ    NOFNINC                  NO, GO TO EXIT          OX00223
         GOIF  PGEN,ON=NOFNINC          YES, IF PRT GEN ON EXIT OX00223
         MVI   FSTPSW,D0                NO, CLEAR FIRST PRNT SW OX00223
         B     NOFNINC                  GO TO EXIT
STMEND1  GOIF  D0(R6),JBLANK,EQ=OPEND2  IS IT BLANK?
         BAL   R9,ERLOG                 GO LOG ERROR
         DC    AL1(SEV178,ERR178,CLMPTR,0)  BLANK EXPECTED
OPEND2   CLC   OPNDCT(2),LCTRSAV+D8     OVER OPERAND COUNT?
         BNH   STMEND                   BRANCH AROUND IF NO
         MVC   ELCTR,LCTRSAV+D12        RESTORE LOCTR
         MVC   OBITS(2),LCTRSAV+D10     RESTORE OUTPUT BIT COUNT
         B     NOFNINC                  EXIT
         EJECT
STMEND   L     R1,BITLC                 PADDED BIT LOCATION COUNTER
         AH    R1,SEVEN                 TO BYTES
         SRL   R1,3
         L     R2,ELCTR                 GET CURRENT LC
         LA    R2,0(,R2)                CLEAR WRAP BITS
         SR    R1,R2                    IS INCREMENT NEEDED
         BZ    NOFNINC                  NO
         ST    R1,LOCLEN                YES, SET INCREMENT = 1
         LR    R10,R6                   SAVE TEXT POINTER
         SET   (NOTEWL,NOTEHS),OFF      BE SURE NOTE-POINT SWITCHES OFF
         JCALL LOCUPD                   CALL LOCATION COUNTER UPDATE
NOFNINC  CLI   DCLNG,X'00'              IS DC TOO LONG         @OX09734
         BE    OKLNG                                           @OX09734
         X5ERRL 157,0                   LENGTH ERROR
OKLNG    SR    R1,R1
         TM    DUMSW,TESTER             IS THIS DS OR DXD
         BNZ   CHEK1ST                  YES
         LH    R2,OBITS                 NO, SET OUTPUT BIT COUNT
         LA    R1,ENTDC                 SET FOR DC PRINT
         LTR   R2,R2                    CHECK UNPRINTED DATA
         BNZ   FPRCALL                  YES
CHEK1ST  TM    FSTPSW,TESTER            HAVE WE PRINTED YET
         BNZ   KLEANUP                  YES
FPRCALL  L     R12,=A(DCPRINT)          SET FOR DCPRINT
         BALR  R9,R12                   BRANCH TO ROUTINE
KLEANUP  SET   XRFNO,ON                 TURN ON XREF
         MVC   PRINTSW,DCPRSW           RESTORE PRINT SWITCH
         SET   PRDEFREQ,OFF             TURN PRIOR DEF REQUIRED OFF
GETOT    JRETURN ,                      EXIT
         JEXTRN (X5L01=LOGERR)          DEFINE EXTRNAL SYMBOL
DISPLIM  DC    F'4096'                  DISPLACEMENT UPPER LIMIT
REGLIM   DC    F'15'                    REGISTER UPPER LIMIT
BIGLIM   DC    F'524280'                L-MOD BIT LIMIT FOR C/X IN DS
YMASK    DC    X'00007FFF'              Y-CON OVERFLOW CHECKER
YNMASK   DC    X'FFFF8000'              Y-CON LOWER LIMIT
WRAPMSK  DC    X'07FFFFFF'              BIT LOCTR WRAP MASK
BYTEMSK  DC    X'FFFFFFF8'              PARTIAL-BYTE PAD MASK
ALINMT   DC    4F'0'                    ALIGNMENT BYTES FOR PRINT
TABLENG  DC    H'20'                    TYPE-TABLE ITEM LENGTH
ONE      DC    H'1'
SEVEN    DC    H'7'
         EJECT
*
*  SUBROUTINE LINKAGE TO CHECK FOR DUPLICATE ERROR MESSAGES AND TO
*  CALL THE ERROR LOGGING ROUTINE IF IT IS NOT
*
*  NOTE - R0 AND R1 ARE DESTROYED
*
ERLOG    ST    R6,ERRPTR                SAVE COLUMN POINTER
ERLOG2   SR    R0,R0                    ZERO FOR INSERT
         IC    R0,D1(,R9)               PICK UP THE ERROR CODE
         SLL   R0,D24                   POSITON IT
         SRA   R0,D16                      WITH A SIGN
         IC    R0,KCOUNT+D1                  AND COUNT
         L     R1,X5ATEMP               GET INDEX
         LTR   R1,R1                    ARE ANY LOGGED YET THIS OPERAND
         BZ    LOGIT                    NO, DO IT
LOGLOOP  CH    R0,X5ATEMP+D2(R1)        YES, IS IT A DUPLICATE
         BE    D4(R9)                   YES, BYPASS ERROR LOGGING
         BCTR  R1,0                     BACK UP THE INDEX
         BCT   R1,LOGLOOP               TO NEXT COMPARE
LOGIT    CLI   X5ATEMP+D3,ELIM          ANY ROOM LEFT
         BE    NOTABE                   NO, SKIP ENTRY
         L     R1,X5ATEMP               YES, REFRESH INDEX
         STH   R0,X5ATEMP+D4(R1)        PLUG CODE & CONSTANT ID
         LA    R1,D2(,R1)               BUMP INDEX
         ST    R1,X5ATEMP               AND SAVE IT
NOTABE   L     R12,=A(LOGERR)           POINT AT ERROR ROUTINE
         BR    R12                      GO THERE
ELIM     EQU   L'X5ATEMP-D4             MAXIMUM ERROR ENTRY DISP
         LTORG
DCTRBL   DC    26X'00'                  DC TYPE TRANSLATE TABLE
DCTABLE  DC    0F'0'
         DC    H'1,0,1,2048,0,0,0,0',B'01000000',AL3(CKON)            C
         DC    H'1,0,1,2048,0,0,0,0',B'01000000',AL3(XKON)            X
         DC    H'1,0,1,2048,0,0,0,0',B'01000000',AL3(BKON)            B
         DC    H'1,0,1,128,0,31,0,0',B'01000000',AL3(PKON)            P
         DC    H'1,0,1,128,0,16,0,0',B'01000000',AL3(ZKON)            Z
         DC    H'16,7,1,128,0,28,-85,75',B'01110000',AL3(DKON)        L
         DC    H'8,7,1,64,0,14,-85,75',B'01110000',AL3(DKON)          D
         DC    H'4,3,1,64,0,14,-85,75',B'01110000',AL3(DKON)          E
         DC    H'4,3,1,64,-187,346,-85,75',B'01110000',AL3(DKON)      F
         DC    H'2,1,1,64,-187,346,-85,75',B'01110000',AL3(DKON)      H
         DC    H'4,3,1,32,0,0,0,0',B'11000000',AL3(AYKON)             A
         DC    H'2,1,1,16,0,0,0,0',B'11000000',AL3(AYKON)             Y
         DC    H'4,3,24,32,0,0,0,0',B'10000000',AL3(VKON)             V
         DC    H'4,3,8,32,0,0,0,0',B'10000000',AL3(QKON)              Q
         DC    H'2,1,16,16,0,0,0,0',B'10000000',AL3(SKON)             S
         EJECT
KOUTPUT  JSAVE BASE=YES                 SAVE REGISTERS
         MVC   FULLWD(4),0(R10)         GET 1ST 4 BYTES
         LR    R4,R7                    SAVE REGISTER
         L     R7,FULLWD                GET FIRST 4 BYTES
         LA    R10,4(,R10)              SET FOR NEXT PICKUP
         LA    R3,32                    SET INPUT BIT COUNT
         SLL   R7,D0(R2)                TRUNCATE 1ST BYTE
         SR    R3,R2                    ADJUST IN-BIT COUNT
         B     KOBCHEK                  TO CHECK OUT-BIT LIMIT
KOUTSET  LH    R14,OBITS                GET PRINT BIT COUNT
         SRDL  R14,3                    DIVIDE BY 8
         LA    R9,DCDATA(R14)           POINT TO CURRENT PRINT BYTE
         SR    R14,R14
         SLDL  R14,3                    8 - REMAINDER
         LA    R2,8                     INTO SHIFT CONTROL
         SR    R2,R14
         SR    R3,R2                    ADJUST INBIT COUNT BY SHIFT
         BM    KNEGCT                   TO NOT ENOUGH IN-BITS
         SR    R6,R6                    CLEAR OUTPUT REGISTER
         SLDL  R6,0(R2)                 SHIFT IN BITS
         EX    R6,KBITOR                OR BITS TO PRINT
         AH    R2,OBITS                 INCREMENT OUT-BIT COUNT
         STH   R2,OBITS
         SRA   R2,6                     IS PRINT FULL
         BZ    KOUTSET                  NO, KEEP SHIFTING
* PRINT 8 BYTES HERE
         LA    R2,64                    CALL PRINT FOR
         LA    R1,ENTDC                 SET FOR DC PRINT
         STM   R10,R11,PREGSV           SAVE IN-BIT CONTROLS
         XR    R7,R4                    EXCHANGE
         XR    R4,R7                      REGISTERS
         XR    R7,R4                        FOR NEXT ROUTINE
         LA    R12,DCPRINT
         BALR  R9,R12                   BRANCH TO ROUTINE
         XR    R7,R4                    RESTORE
         XR    R4,R7                      BY EXCHANGING
         XR    R7,R4                        THEM
         LM    R10,R11,PREGSV           RESTORE IN-BIT CONTROLS
         B     KOUTSET                  TO NEXT OUTPUT
KNEGCT   LCR   R1,R3                    SET ZERO-FILL SHIFT
         AR    R2,R3                    REDUCE INITIAL SHIFT
         SR    R6,R6                    CLEAR OUTPUT REGISTER
         SLDL  R6,0(R2)                 SHIFT IN REMAINING BITS
         SLL   R6,0(R1)                 POSITION FOR OUTPUT
         EX    R6,KBITOR                OR BITS TO PRINT
         AH    R2,OBITS                 INCREMENT OUT-BIT COUNT
         STH   R2,OBITS                 FULL PRINT IS IMPOSSIBLE
         MVC   FULLWD(4),0(R10)         GET NEXT 4 BYTES
         L     R7,FULLWD                GET NEXT 4 BYTES
         LA    R10,4(,R10)              SET FOR NEXT PICKUP
         LA    R3,32                    RE-SET INPUT BIT COUNT
KOBCHEK  SR    R11,R3                   REDUCE TOTAL IN-BIT COUNT
         BNM   KOUTSET                  TO OUTPUT UNLESS NEGATIVE
         AR    R3,R11                   FORM REMAINING IN-BIT COUNT
         BP    MORPRNT                  EXIT IF ZERO
KXIT     JRETURN ,                      EXIT
MORPRNT  SR    R11,R11                  ZERO TO TOTAL REMAINDER
         B     KOUTSET                  TO OUTPUT THE REST
KBITOR   OI    D0(R9),D0                EXECUTED OR FOR PRINT
         DROP  R5                       RETURN TO COMMON USING REGISTER
         EJECT
         PRINT DATA
* SUBROUTINE TO CALL PRINT
* TO CALL -  LA R12,DCPRINT  -  BALR R5,R12
* SAVES R3 THRU R13
* CLEARS PRINT DATA, CONTROL BYTE, AND OBITS AFTER PRINT
* TURNS OFF 1ST TIME SWITCH IF NOT ALIGN CALL
* PRINT LOCATION COUNTER IS UPDATED AFTER PRINT
* PARAMETERS -
*        R1 = 0 FORCES ENTIRE STATEMENT PRINT, NO DATA (FOR DS, DXD)
*        R1 = X'80' FORCES ALIGNMENT PRINT
*           R2 = ALIGNMENT BYTE COUNT
*        R1 = X'40' FORCES DATA PRINT
*           R2 = OUTPUT BIT COUNT (PARTIAL BYTE GETS PADDED)
DCPRINT  JSAVE BASE=YES                 SAVE REGISTERS
         STM   R10,R12,PRNTSV           SAVE REGISTERS
         LTR   R1,R1                    CHECK STATEMENT PRINT
         BNZ   DCPACT                   NO
         SR    R2,R2                    ZERO DATA BYTES
         MVI   LHFLGS,D0                YES, ZERO CONTROL BYTE
         MVI   FSTPSW,TESTER            TURN OFF 1ST TIME SWITCH
         GOIF  DXDSW,OFF=DCPCALL        IS THIS DXD
         MVI   LHFLGS,DNTPLH            SET NO LEFT-HALF
         B     DCPCALL                  TO PRINT
DCPACT   LA    R0,ENTALN                CHECK ALIGN CALL
         CLR   R1,R0
         BNE   POBITS                   NO
         XC    DCDATA,DCDATA            CLEAR PRINT DATA
         B     PCTROL                   TO SET CONTROL
POBITS   LA    R2,7(,R2)                PAD PARTIAL BYTE
         SRL   R2,3                     FORM BYTE COUNT
         MVI   FSTPSW,TESTER            TURN OFF 1ST TIME SWITCH
PCTROL   LA    R1,0(R1,R2)              SET CONTROL BYTE
         STC   R1,LHFLGS                SET LEFT HALF FLAGS
DCPCALL  LA    R10,DC0OUT               SET PRINT INDEX
         LR    R3,R2                    SAVE DATA BYTES
         L     R5,TXTPTR                GET TEXT POINTER
         JCALL OUTPUT                   CALL PRINT PUNCH ROUTINE
         LA    R5,LEFTHF                POINT TO WORK AREA
         JEXTRN (X5P01=OUTPUT)          DEFINE EXTERNAL SYMBOL
         XC    DCDATA,DCDATA            CLEAR DATA
         MVI   OBITS+1,0                CLEAR OUTPUT-BIT COUNT
         L     R1,LOCATN                INCREMENT PRINT LOCATION
         ALR   R1,R3                    OR ALIGNMENT BYTES
         ST    R1,LOCATN                STORE NEW LOCATION COUNTER
         LM    R10,R12,PRNTSV           RESTORE REGISTERS
DCXIT    JRETURN ,                      EXIT
         EJECT
* DC CHARACTERISTICS AND GO-TO TABLE
* EACH TABLE ITEM IS 20 BYTES LONG
*       BYTES 0-1 - IMPLIED LENGTH
*       BYTES 2-3 - ALIGNMENT FACTOR
*       BYTES 4-5 - LENGTH-MOD LOWER LIMIT
*       BYTES 6-7 - LENGTH-MOD UPPER LIMIT
*       BYTES 8-9 - SCALE-MOD LOWER LIMIT
*       BYTES 10-11 - SCALE-MOD UPPER LIMIT
*       BYTES 12-13 - EXPONENT-MOD LOWER LIMIT
*       BYTES 14-15 - EXPONENT-MOD UPPER LIMIT
*       BYTE 16 - FLAG BYTE
*          BIT 0 = 1 IF ADDRESS TYPE
*          BIT 1 = 1 IF BIT-LENGTH LEGAL
*          BIT 2 = 1 IF SCALE-MOD LEGAL
*          BIT 3 = 1 IF EXPONENT-MOD LEGAL
*          BITS 4 - 7 CURRENTLY UNUSED
*       BYTES 17-19 - BRANCH ADDRESS FOR CONSTANT SCAN
IMPLINC  EQU   0                        IMPLICIT LENGTH ACCESS
ALININC  EQU   2                        ALIGNMENT ACCESS
LOLMINC  EQU   4                        LO L-MOD ACCESS
HILMINC  EQU   6                        HI L-MOD ACCESS
LOSMINC  EQU   8                        LO S-MOD ACCESS
HISMINC  EQU   10                       HI S-MOD ACCESS
LOEMINC  EQU   12                       LO E-MOD ACCESS
HIEMINC  EQU   14                       HI E-MOD ACCESS
FLAGINC  EQU   16                       FLAG BYTE ACCESS
ADDRINC  EQU   16                       ADDRESS WORD ACCESS
ABIT     EQU   X'80'                    ADDRESS TYPE TESTER
EBIT     EQU   X'10'                    E-MOD VALIDITY TESTER
CBKT     EQU   1                        C  TYPE FLAG  (DC)
XBKT     EQU   CBKT+1                   X  TYPE FLAG  (DC)
BBKT     EQU   XBKT+1                   B  TYPE FLAG  (DC)
PBKT     EQU   BBKT+1                   P  TYPE FLAG  (DC)
ZBKT     EQU   PBKT+1                   Z  TYPE FLAG  (DC)
LBKT     EQU   ZBKT+1                   L  TYPE FLAG  (DC)
DBKT     EQU   LBKT+1                   D  TYPE FLAG  (DC)
EBKT     EQU   DBKT+1                   E  TYPE FLAG  (DC)
FBKT     EQU   EBKT+1                   F  TYPE FLAG  (DC)
HBKT     EQU   FBKT+1                   H  TYPE FLAG  (DC)
ABKT     EQU   HBKT+1                   A  TYPE FLAG  (DC)
YBKT     EQU   ABKT+1                   Y  TYPE FLAG  (DC)
VBKT     EQU   YBKT+1                   V  TYPE FLAG  (DC)
QBKT     EQU   VBKT+1                   Q  TYPE FLAG  (DC)
SBKT     EQU   QBKT+1                   S  TYPE FLAG  (DC)
         ORG   DCTRBL+JC-JALFAMIN       ORG TO CORRECT PLACE FOR C
         DC    AL1(CBKT)                C ENTRY IN TABLE
         ORG   DCTRBL+JX-JALFAMIN       ORG TO CORRECT PLACE FOR X
         DC    AL1(XBKT)                X ENTRY IN TABLE
         ORG   DCTRBL+JB-JALFAMIN       ORG TO CORRECT PLACE FOR B
         DC    AL1(BBKT)                B ENTRY IN TABLE
         ORG   DCTRBL+JP-JALFAMIN       ORG TO CORRECT PLACE FOR P
         DC    AL1(PBKT)                P ENTRY IN TABLE
         ORG   DCTRBL+JZ-JALFAMIN       ORG TO CORRECT PLACE FOR Z
         DC    AL1(ZBKT)                Z ENTRY IN TABLE
         ORG   DCTRBL+JL-JALFAMIN       ORG TO CORRECT PLACE FOR L
         DC    AL1(LBKT)                L ENTRY IN TABLE
         ORG   DCTRBL+JD-JALFAMIN       ORG TO CORRECT PLACE FOR D
         DC    AL1(DBKT)                D ENTRY IN TABLE
         ORG   DCTRBL+JE-JALFAMIN       ORG TO CORRECT PLACE FOR E
         DC    AL1(EBKT)                E ENTRY IN TABLE
         ORG   DCTRBL+JF-JALFAMIN       ORG TO CORRECT PLACE FOR F
         DC    AL1(FBKT)                F ENTRY IN TABLE
         ORG   DCTRBL+JH-JALFAMIN       ORG TO CORRECT PLACE FOR H
         DC    AL1(HBKT)                H ENTRY IN TABLE
         ORG   DCTRBL+JA-JALFAMIN       ORG TO CORRECT PLACE FOR A
         DC    AL1(ABKT)                A ENTRY IN TABLE
         ORG   DCTRBL+JY-JALFAMIN       ORG TO CORRECT PLACE FOR Y
         DC    AL1(YBKT)                Y ENTRY IN TABLE
         ORG   DCTRBL+JV-JALFAMIN       ORG TO CORRECT PLACE FOR V
         DC    AL1(VBKT)                V ENTRY IN TABLE
         ORG   DCTRBL+JQ-JALFAMIN       ORG TO CORRECT PLACE FOR Q
         DC    AL1(QBKT)                Q ENTRY IN TABLE
         ORG   DCTRBL+JS-JALFAMIN       ORG TO CORRECT PLACE FOR S
         DC    AL1(SBKT)                S ENTRY IN TABLE
         ORG   , GET LOCATION COUNTER IN STEP
         EJECT
TESTER   EQU   X'F0'                    FLAG TEST MASK
EXBLANK  EQU   X'40'                    EXTERNAL BLANK CODE
UNBKT    EQU   X'10'                    UNCLASSIFIED TEXT BKT TYPE
         JPATCH X5D00,122C              5% PATCH AREA
         END
