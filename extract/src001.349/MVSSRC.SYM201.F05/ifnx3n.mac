         JHEAD 'GENERATE PHASE DICTIONARY ROUTINES',                   X
               PHASEID=X3N,                                            X
               LEVEL=10
*FUNCTION/OPERATION-                                                  *
*   THE GENERATE PHASE DICTIONARY ROUTINES ARE A SET OF SUBROUTINES.  *
*   THESE SUBROUTINES PROVIDE ALL THE FUNCTIONS REQUIRED BY THE       *
*   GENERATE PHASE RELATIVE TO THE GENERATION TIME DICTIONARIES. THE  *
*   FUNCTIONS PROVIDED ARE- INITIALIZATION, SETTING, AND REFERENCING. *
*   THESE FUNCTIONS ARE REQUESTED DURING THE EXPANSION OF MACRO       *
*   INSTRUCTIONS AND IN CONDITIONAL ASSEMBLY FOR THE GENERATION OF    *
*   THE TEXT TO BE PROCESSED BY THE ASSEMBLY PHASE. THE PERTINENT     *
*   DICTIONARIES ARE- GLOBAL DICTIONARY, ORDINARY SYMBOL REFERENCE    *
*   DICTIONARY, AND THE DICTIONARY FOR THE TEXT SEGMENT CURRENTLY     *
*   BEING USED BY THE GENERATE PHASE. THE DICTIONARY FOR A TEXT       *
*   SEGMENT INCLUDES THE SKELETON DICTIONARY BUILT BY THE DICTIONARY  *
*   INTERLUDE PHASE FOR THAT TEXT SEGMENT (CONSISTING OF THE          *
*   DICTIONARY HEADER, THE GLOBAL VECTOR, AND THE SEQUENCE SYMBOL     *
*   REFERENCE DICTIONARY), THE LOCAL DICTIONARY, AND, IN THE CASE     *
*   OF A MACRO DEFINITION, THE MACRO PARAMETER WORK AREA.             *
*                                                                     *
*ENTRY POINT-                                                         *
*        DICTENTR                                                     *
*              THE CALLING SEQUENCE IS-                               *
*                  DICTCALL ENTRY                                     *
*              WHICH GENERATES-                                       *
*                  L     LINK,POINTER                                 *
*                  BAL   RETURN,ENTRY(,LINK)                          *
*              WHERE LINK IS THE STANDARD REGISTER FOR THE ADDRESS    *
*                             OF THE CALLED ROUTINE                   *
*                    POINTER CONTAINS THE ADDRESS OF THE DICTIONARY   *
*                            ENTRY ROUTINE                            *
*                    ENTRY IS THE NAME OF THE DICTIONARY FUNCTION     *
*                             REQUIRED (ENTRY NAMES ARE EQUATED TO    *
*                             ABSOLUTE VALUES USED AS DISPLACEMENTS   *
*                             INTO A BRANCH TABLE                     *
*                    RETURN IS THE STANDARD REGISTER FOR THE RETURN   *
*                             ADDRESS                                 *
*                                                                     *
*INPUT-                                                               *
*   FILE 1 - SKELETON DICTIONARY FOR EACH TEXT SEGMENT                *
*   FILE 1 - OVERFLOW DICTIONARIES                                    *
*   FILE 2 - MACRO DEFINITION VECTOR                                  *
*          - ORDINARY SYMBOL REFERENCE DICTIONARY                     *
*          - OPSYN TABLE                                              *
*                                                                     *
*OUTPUT-                                                              *
*   FILE 1 - OVERFLOW DICTIONARIES                                    *
*                                                                     *
*EXTERNAL ROUTINES-                                                   *
*                                                                     *
*                                                                     *
*                                                                     *
*EXITS,NORMAL-                                                        *
*   EXIT TO THE CONTROLLER WITH THE COMPLETION CODE SET TO A ZERO     *
*   VALUE.                                                            *
*                                                                     *
*EXITS,ERROR-                                                         *
*   EXIT TO THE CONTROLLER WITH THE COMPLETION CODE SET TO A NON-ZERO *
*   VALUE, THE SPECIFIC VALUE INDICATING THE ACTION TO BE TAKEN BY    *
*   THE CONTROLLER.                                                   *
*                                                                     *
*TABLES/WORK AREAS-                                                   *
*   MACRO DEFINITION VECTOR - A SEQUENTIAL TABLE. THERE IS ONE ENTRY  *
*        IN THE TABLE FOR EACH TEXT SEGMENT. EACH ENTRY CONSISTS      *
*        OF THE NOTE/POINT ADDRESS OF THE EDITED TEXT (NOT PRESENT    *
*        IN THE ENTRY FOR OPEN CODE), THE NOTE/POINT ADDRESS OF THE   *
*        SKELETON DICTIONARY, AND THE SIZE OF SKELETON DICTIONARY.    *
*   GLOBAL DICTIONARY - THE AREA IN WHICH THE VALUES OF THE VARIABLE  *
*        SYMBOLS ASSIGNED AS GLOBAL VARIABLES IN THE EDIT PHASE ARE   *
*        SET AND REFERENCED IN THE GENERATE PHASE DURING THE          *
*        EXPANSION OF MACRO INSTRUCTIONS AND IN CONDITIONAL ASSEMBLY. *
*   ORDINARY SYMBOL REFERENCE DICTIONARY - A SEQUENTIAL TABLE. THERE  *
*        IS ONE ENTRY IN THE TABLE FOR EACH ORDINARY SYMBOL           *
*        REFERENCED IN ATTRIBUTE REFERENCES OR IN MACRO INSTRUCTION   *
*        OPERANDS (LESS THOSE RESOLVED AS DUPLICATES). EACH ENTRY     *
*        CONSISTS OF THE TYPE, LENGTH, AND SCALE ATTRIBUTES OF THE    *
*        CORRESPONDING ORDINARY SYMBOL.                               *
*   DICTIONARY FOR A TEXT SEGMENT - THE SKELETON DICTIONARY (CONSIS-  *
*        TING OF THE DICTIONARY HEADER, THE GLOBAL VECTOR, AND THE    *
*        SEQUENCE SYMBOL REFERENCE DICTIONARY) PLUS THE LOCAL DIC-    *
*        TIONARY PLUS, IN THE CASE OF A MACRO DEFINITION, THE MACRO   *
*        PARAMETER WORK AREA.                                         *
*      --DICTIONARY HEADER - WORK AREA CONTAINING ALL THE OVERHEAD    *
*              PECULIAR TO THE DICTIONARY FOR A TEXT SEGMENT.         *
*      --GLOBAL VECTOR - A SEQUENTIAL TABLE OF POINTERS, ONE FOR      *
*              EACH SYSTEM GLOBAL VARIABLE AND ONE FOR EACH OF THE    *
*              VARIABLE SYMBOLS IN THE TEXT SEGMENT ASSIGNED          *
*              AS GLOBAL VARIABLES IN THE EDIT PHASE, EACH POINTING   *
*              TO THE CORRESPONDING ENTRY IN THE GLOBAL DICTIONARY.   *
*      --SEQUENCE SYMBOL REFERENCE DICTIONARY - A SEQUENTIAL TABLE    *
*              OF NOTE/POINT ADDRESSES, ONE FOR EACH SEQUENCE SYMBOL  *
*              REFERENCE IN THE TEXT SEGMENT (LESS THOSE RESOLVED     *
*              AS DUPLICATES), EACH POINTING TO THE POSITION IN THE   *
*              EDITED TEXT WHERE THE CORRESPONDING SEQUENCE SYMBOL    *
*              IS DEFINED.                                            *
*      --LOCAL DICTIONARY - THE AREA IN WHICH THE VALUES OF THE       *
*              VARIABLE SYMBOLS ASSIGNED AS LOCAL VARIABLES FOR THE   *
*              TEXT SEGMENT IN THE EDIT PHASE ARE SET AND REFERENCED  *
*              IN THE GENERATE PHASE DURING THE EXPANSION OF MACRO    *
*              INSTRUCTIONS AND IN CONDITIONAL ASSEMBLY.              *
*      --MACRO PARAMETER WORK AREA - THE KEYWORD PARAMETER VECTOR     *
*              PLUS THE POSITIONAL PARAMETER VECTOR PLUS THE          *
*              PARAMETER TABLE, CONSISTING OF THE VALUES OF ALL       *
*              THE MACRO INSTRUCTION OPERANDS.                        *
*                                                                     *
*ATTRIBUTES-                                                          *
*   REFRESHABLE                                                       *
*                                                                     *
*NOTES-                                                               *
*                                                                     *
*                                                                     *
*                                                                     *
         EJECT
         COPY  JCOMMON
         EJECT
         COPY  JTMTXT
         EJECT
         COPY  GENCOM
         EJECT
*
* THIS DSECT MAPS THE MACRO DEFINITION VECTOR ENTRY.
*
MDVNTRY  DSECT
MNPTXT   DS    XL8                      TEXT FILE N/P     8 BYTES
MNPSD    DS    XL8                      SKEL DICTION N/P  8 BYTES
MSDL     DS    XL3                      SKEL DICT LENGTH  3 BYTES
MDVEND   EQU   *
*
* THIS DSECT MAPS THE HEADER FOR THE SKELETON DICTIONARY.
*
SKDCTHDR DSECT
SKSRDPT  DS    XL3                      DISPL SEQ SYM DIC 3 BYTES
SKLDADR  DS    XL3                      LCL DICT PTR      3 BYTES
SKLDLNG  DS    XL3                      LCL DICT LENGTH   3 BYTES
SKMPADR  DS    XL3                      MACRO PARAM PTR   3 BYTES
SKKVADR  DS    XL3                      KEYWD VECTR PTR   3 BYTES
SKADNLD  DS    XL4                      DICT ADR NXT LVL  4 BYTES
SKNPNLT  DS    XL8                      TEXT N/P NXT LVL  8 BYTES
SKACTRV  DS    XL4                      ACTR VALUE        4 BYTES
SKNOFSLS DS    XL2                      N'&SYSLIST        2 BYTES
SKHDREND EQU   *
*
* THIS DSECT MAPS THE MACRO CALL META-TEXT.
*
MCRCAL   DSECT
MDVPNT   DS    XL3                      PTR TO MDV ENTRY FOR MACRO
*
*
* THIS DSECT MAPS THE GLOBAL AND LOCAL REFERENCE META-TEXT.
*
VREF     DSECT
VFLAG    DS    X                        META-TEXT FLAG/OPERATOR
VPNT     DS    XL3                      PTR TO DICT/VECTOR ENTRY
VSUBS    DS    XL2                      VARIABLE SUBSCRIPT/DIMENSION
*
* THIS DSECT MAPS THE SEQUENCE SYMBOL REFERENCE META-TEXT.
*
SEQREF   DSECT
SFLAG    DS    X                        META-TEXT FLAG/OPERATOR
SEQPNT   DS    XL3                      PTR TO DICTIONARY ENTRY
SEQPAD   DS    XL2                      PADDING
*
* THIS DSECT MAPS THE ORDINARY SYMBOL REFERENCE META-TEXT.
*
ORDREF   DSECT
OFLAG    DS    X                        META-TEXT FLAG/OPERATOR
ORDPNT   DS    XL3                      PTR TO DICTIONARY ENTRY
ORDPAD   DS    XL2                      PADDING
*
* THIS DSECT MAPS THE PARAMETER REFERENCE META-TEXT.
*
PARMREF  DSECT
PARMFLG  DS    X                        META-TEXT FLAG/OPERATOR
PARMPNT  DS    XL3                      PTR TO PARAM VECTOR ENTRY
PARMPAD  DS    XL2                      PADDING
         ORG   PARMPAD                  ORIGIN FOUR
PARMSUB  DS    XL2                      SUBOPERAND NUMBER
*
* THIS DSECT MAPS THE ENTRY IN THE GLOBAL OR LOCAL DICTIONARY FOR A
*        SETA VARIABLE.
*
SETANTRY DSECT
SETAVAL  DS    XL4                      DICT ENTRY, SETA VARIABLE
*
* THIS DSECT MAPS THE ENTRY IN THE GLOBAL OR LOCAL DICTIONARY FOR A
*        SETB VARIABLE.
*
SETBNTRY DSECT
SETBVAL  DS    X
*
* THIS DSECT MAPS THE ENTRY IN THE GLOBAL OR LOCAL DICTIONARY FOR A
*        SETC VARIABLE.
*
SETCNTRY DSECT
SETCLEN  DS    C                        LENGTH BYTE, SETC VARIABLE
SETCVAL  DS    CL8                      DICT ENTRY, SETC VARIABLE
         ORG   SETCVAL+D5               ORIGIN SIX
SETCPTR  DS    XL3                      PTR TO VALUE, EXTENDED SETC
*
* THIS DSECT MAPS THE ENTRIES FOR THE SYSTEM GLOBAL VARIABLES
*        AT THE HEAD OF THE GLOBAL DICTIONARY.
GSYSVALS DSECT
PARMLEN  DS    C                        LENGTH SYSPARM VALUE
PARMVAL  DS    CL8                      SYSPARM VALUE
TIMELEN  DS    C                        LENGTH, SYSTIME VALUE
TIMEVAL  DS    CL8                      SYSTIME VALUE
DATELEN  DS    C                        LENGTH, SYSDATE VALUE
DATEVAL  DS    CL8                      SYSDATE VALUE
*
* THIS DSECT MAPS THE ENTRIES FOR THE SYSTEM LOCAL VARIABLES
*        AT THE HEAD OF EACH LOCAL DICTIONARY
*
LSYSVALS DSECT
INDXVAL  DS    XL4                      SYSNDX VALUE
SECTLEN  DS    CL1                      LENGTH, SYSECT VALUE
SECTVAL  DS    CL8                      SYSECT VALUE
*
* THIS DSECT MAPS THE LOGICAL RECORD FOR A MACRO INSTRUCTION
*        OR MACRO PROTOTYPE OPERAND.
*
         COPY  JTEXT
*
* THIS DSECT MAPS THE ERROR STACK ENTRY
*
ERRMESS  DSECT
EMSGSVTY DS    C                        ERROR SEVERITY CODE
EMSGCODE DS    C                        ERROR NUMBER
EMSGHL   EQU   *-EMSGSVTY
ENTRYLNG DS    C                        LENGTH, SNAPSHOT DATA
EMSGNTRY DS    CL8                      SNAPSHOT DATA
*
*        MORE DISPLACEMENT EQUATES
*
D36      EQU   36                       DISPLACEMENT
D44      EQU   44                       DISPLACEMENT
D48      EQU   48                       DISPLACEMENT
D256     EQU   256                      MAXIMUM MOVE LENGTH
         EJECT
         COPY JERMSGCD
         EJECT
SAVMDVNP EQU   JDPASS                   SAVE AREA, MDV ADDRESS
SAVMDVLN EQU   JDPASS+D8                SAVE AREA, MDV LENGTH
SAVGDLNT EQU   JDPASS+D12               SAVE AREA GLOBAL DICT ALLOC
SAVOSDNP EQU   JDPASS+D16               SAVE AREA, OSRD ADDRESS
SAVOSDLN EQU   JDPASS+D24               SAVE AREA, OSRD LENGTH
SAVOVFPT EQU   JDPASS+D28               SAVE AREA, END OF FILE 1 ADDR
SAVOPTNP EQU   JDPASS+D36               SAVE AREA, OPSYN TABLE ADDRESS
SAVOPTLN EQU   JDPASS+D44               SAVE AREA, OPSYN TABLE LENGTH
SAVERRNP EQU   JDPASS+D48               SAVE AREA, ERROR BLOCK ADDRESS
GBLVCTEL EQU   3                        GLOBAL VECTOR ENTRY LENGTH
OPNDSTR  EQU   BIT7                     CHARACTER STRING PARAM FLAG
OPNDTRM  EQU   BIT6                     SELF-DEF TERM PARAM FLAG
OPNDORD  EQU   BIT5                     ORDINARY SYMBOL PARAM FLAG
OPNDOMT  EQU   BIT4                     OMITTED OPERAND PARAM FLAG
OPNDPRM  EQU   BIT3                     PASSED PARAMETER PARAM FLAG
OPNDSUB  EQU   BIT0                     SUBOPERAND PARAM FLAG
OPNDSUBF EQU   BIT2                     FIRST SUBOPERAND PARAM FLAG
OPNDSUBL EQU   BIT1                     LAST SUBOPERAND PARAM FLAG
MINRECSZ EQU   18                       MINIMUM I/O LENGTH
WORK1    EQU   R1                       SCRATCH REGISTER
WORKX    EQU   R1                       SCRATCH REGISTER
LOCTR    EQU   R2                       PTR TO NEXT BYTE FOR ALLOCAT
MDVPTR   EQU   R2                       PTR TO MDV ENTRY
PTPTR    EQU   R2                       PTR TO NEXT PARAM TBL SLOT
KEYPTR   EQU   R2                       PTR TO KEYWORD IN PARAM RECORD
KCPTR    EQU   R2                       PTR TO KEYWORD CHAIN ENTRY
SKDCTPTR EQU   R2                       PTR TO START OF SKEL DICT
PARAMPTR EQU   R2                       PTR TO PARAM TBL ENTRY
EPTR     EQU   R3                       PTR TO ERROR RCD IN ERROR BLOCK
PVEPTR   EQU   R3                       PTR TO NEXT PARAM VECTOR SLOT
KEYLEN   EQU   R3                       KEYWORD LENGTH REGISTER
SETPTR   EQU   R3                       PTR TO GBL/LCL DICT ENTRY, LIMB
OVLPTR   EQU   R4                       PTR TO ALLOC ADJUSTED FOR OVRLP
KEYCHAIN EQU   R4                       PTR TO KEYWORD CHAIN ENTRY
DICTPTR  EQU   R4                       PTR TO GBL/LCL DICT ENTRY, ROOT
VALLEN   EQU   R5                       PARAM VALUE LENGTH REGISTER
SETLEN   EQU   R5                       SETC VALUE LENGTH REGISTER
TXTPTR   EQU   R6                       PTR TO PARAM RECORD HDR DATA
RETURN   EQU   R9                       LINKAGE REGISTER
RTNLNK   EQU   R9                       LINKAGE REGISTER
PARMA    EQU   R10                      PARAMETER PASSAGE REGISTER
PARMB    EQU   R11                      PARAMETER PASSAGE REGISTER
WORKA    EQU   R14                      SCRATCH REGISTER
WORK2    EQU   R14                      SCRATCH REGISTER
WORKY    EQU   R14                      SCRATCH REGISTER
PAIRE    EQU   R14                      EVEN REGISTER OF PAIR
WORKB    EQU   R15                      SCRATCH REGISTER
WORK3    EQU   R15                      SCRATCH REGISTER
WORKZ    EQU   R15                      SCRATCH REGISTER
PAIRO    EQU   R15                      ODD REGISTER OF PAIR
         EJECT
         JCSECT (X3N00)
* VS1 RELEASE 2 CHANGES
*C374400,378200                                                 OX00049
*A377900-378000                                                 OX00049
*A751700-751700                                                 OX00218
*A754700-754784                                                 OX00218
* VS1 RELEASE 4 CHANGES
*A568000                                                        OY01298
         JMODID
*DICTIONARY ENTRY ROUTINE - ALL CALLS TO THE GENERATE PHASE           *
*   DICTIONARY ROUTINES ENTER THROUGH THE FOLLOWING BRANCH TABLE      *
*   WHICH PROVIDES THE LINK TO THE REQUIRED ROUTINE.                  *
*                                                                     *
         USING DICTENTR,R12
DICTENTR B     DICTSAVE                 LINK TO ENTRY/SAVE ROUTINE
         DC    AL2(PHASENTR-DICTENTR)   DISPL TO PHASENTR ROUTINE
         DC    AL2(MACRCALL-DICTENTR)   DISPL TO MACRCALL ROUTINE
         DC    AL2(CALLEND-DICTENTR)    DISPL TO CALLEND  ROUTINE
         DC    AL2(MACRKWRD-DICTENTR)   DISPL TO MACRKWRD ROUTINE
         DC    AL2(MACRPOST-DICTENTR)   DISPL TO MACRPOST ROUTINE
         DC    AL2(PROTOKWD-DICTENTR)   DISPL TO PROTOKWD ROUTINE
         DC    AL2(PROTOEND-DICTENTR)   DISPL TO PROTOEND ROUTINE
         DC    AL2(GBLDICTR-DICTENTR)   DISPL TO GBLDICTR ROUTINE
         DC    AL2(GBLDICTS-DICTENTR)   DISPL TO GBLDICTS ROUTINE
         DC    AL2(LCLDICTR-DICTENTR)   DISPL TO LCLDICTR ROUTINE
         DC    AL2(LCLDICTS-DICTENTR)   DISPL TO LCLDICTS ROUTINE
         DC    AL2(PARMTBLR-DICTENTR)   DISPL TO PARMTBLR ROUTINE
         DC    AL2(SEQSYMBR-DICTENTR)   DISPL TO SEQSYMBR ROUTINE
         DC    AL2(ORDSYMBR-DICTENTR)   DISPL TO ORDSYMBR ROUTINE
         DC    AL2(MACRFINI-DICTENTR)   DISPL TO MACRFINI ROUTINE
         SPACE 5
         JENTRY (X3N01=DICTENTR)
         EJECT
*
* THIS SUBROUTINE IS USED BY ALL THE DICTIONARY ROUTINES TO SAVE
*        REGISTERS AND ESTABLISH ADDRESSABILITY.
*
DICTSAVE STM   R2,R9,REGSTACK           PRESERVE CALLERS REGISTERS
         LR    R8,R12                   SET UP DICT RTN BASE ADDR
         USING DICTENTR,R8
         DROP  R12
         LH    R9,ENTRYNDX              PICK UP ENTRY PT FLAG
         LH    R9,DICTENTR+D4(R9)       GET DISPL TO REQ'D RTN
         B     DICTENTR(R9)             ENTER DICTIONARY SUBRTN
         SPACE 10
*
* THIS ROUTINE IS THE COMMON EXIT POINT FOR THE DICTIONARY ROUTINES.
*
DICTEXIT LM    R2,R9,REGSTACK           RESTORE CALLERS REGISTERS
         BR    R9                       RETURN TO CALLER
         EJECT
*PHASENTR - THIS ROUTINE IS CALLED AT THE START OF THE GENERATE       *
*   PHASE. ITS FUNCTION IS TO FETCH THE MACRO DEFINITION VECTOR,      *
*   GET THE SPACE FOR AND INITIALIZE THE GLOBAL DICTIONARY, FETCH     *
*   THE ORDINARY SYMBOL REFERENCE DICTIONARY, FETCH THE SKELETON      *
*   DICTIONARY FOR OPEN CODE, AND GET THE SPACE FOR AND INITIALIZE    *
*   THE LOCAL DICTIONARY FOR OPEN CODE.                               *
*        INPUT - NONE.                                                *
*        OUTPUT - NONE.                                               *
*                                                                     *
PHASENTR EQU   *
         XC    DICTCOMS(DICTCOME-DICTCOMS),DICTCOMS CLEAR COMMON AREA
         L     R11,=A(X'1FFFF0')        MAX CORE REQUEST IN DW
         JGETCORE MINDBL=750,MAXDBL=(R11) GET FREE SPACE
         ST    R10,FREESTRT             SAVE START PTR
         AR    R11,R10                  DETERMINE END PTR
         ST    R11,FREEEND              SAVE END PTR
         ST    R11,SPACEAH              SET UP FREE AREA END FIRST
         LR    LOCTR,R10                SET UP MAIN ALLOCATION PTR
         MVC   PIOPARMB,SAVMDVLN        GET LENGTH OF MDV
         ST    LOCTR,PIOPARMA           SET UP TO READ IN MDV
         L     WORK1,PIOPARMB           PICK UP MOV LENGTH
         MVC   JFWORD1,SAVGDLNT         GET GLOBAL DICT SIZE
         A     WORK1,JFWORD1            ADD IN FOR CALCULATION
         MVC   JFWORD1,SAVOSDLN         GET ORD SYMB REF DICT SIZE
         A     WORK1,JFWORD1            ADD IN FOR CALCULATION
         MVC   JFWORD1,SAVOPTLN         PICK UP OPSYN TABLE LENGTH
         A     WORK1,JFWORD1            ADD IN FOR CALCULATION
         AR    WORK1,LOCTR              DEVELOP OVERLAP POINTER
         CL    WORK1,FREEEND            LOOK FOR OVERLAP
         BNL   OVERLP4A                 BRANCH IF NO ROOM FOR GBL DICTS
         ST    LOCTR,MDVSTRT            SAVE AS MDV PTR
         JPOINT FILE=FILE2,ADDR=SAVMDVNP,NEXT=READ POINT TO MDV
         LH    R5,JMAXRL2               SET UP MAXIMUM RECORD THIS FILE
         LA    R6,FILE2                 SET UP FILE POINTER
         BAL   RTNLNK,BUFREAD           GO GET MDV FROM FILE 2
         A     LOCTR,PIOPARMB           BUMP PTR PAST MDV
         CLC   SAVOPTLN(D4),=D'0'       SEE IF OPSYN TABLE REQ'D
         BZ    SKPOPSYN                 BRANCH IF NOT
         ST    LOCTR,PIOPARMA           SET UP I/O AREA POINTER
         ST    LOCTR,OPSNSTRT           SET UP OPSYN TABLE POINTER
         MVC   PIOPARMB,SAVOPTLN        SET UP OPSYN TABLE LENGTH
         JPOINT FILE=FILE2,ADDR=SAVOPTNP,NEXT=READ POINT TO OPSYN TBL
         LH    R5,JMAXRL2               GET MAX RECD LNGT FOR FILE
         LA    R6,FILE2                 GET FILE INDICATOR
         BAL   RTNLNK,BUFREAD           GO FETCH OPSYN TABLE
         A     LOCTR,PIOPARMB           BUMP PTR PAST OPSYN TABLE
SKPOPSYN EQU   *
         ST    LOCTR,GDSTRT             SAVE AS GBL DICT PTR
         MVC   JFWORD1,SAVGDLNT         GET LENGTH OF GBL DICT
         L     WORK1,JFWORD1            PICK IT UP FOR CLEARING DICT
         LR    WORKA,LOCTR              SET UP PTR TO AREA TO CLEAR
         LA    WORKB,D1(,WORKA)         SET UP DESTINATION POINTER
         MVI   D0(WORKA),J0             INSERT CHARACTER TO PROPAGATE
         BAL   RETURN,MOVLOP            GO CLEAR OUT AREA
         USING GSYSVALS,LOCTR
         L     WORK2,JSYSPARM           PICK UP SYSPARM PTR IN COMMON
         LTR   WORK2,WORK2              SEE IF SYSPARM SPECIFIED
         BZ    SKIPPARM                 BRANCH IF NOT
         IC    WORK3,D0(,WORK2)         PICK UP SYSPARM LENGTH
         STC   WORK3,PARMLEN            INSERT IN SYSPARM ENTRY
         CLI   PARMLEN,L'PARMVAL        SEE IF LENGTH OVER 8
         BH    SKIPPARM                 IF YES, LEAVE POINTER ZERO
         BCTR  WORK3,D0                 OTHERWISE, GET MOVE LENGTH
         EX    WORK3,SYSPMOVE           MOVE SYSPARM VALUE INTO ENTRY
SKIPPARM EQU   *
         LA    WORK3,L'JSYSTIME         GET LENGTH FOR SYSTIME ENTRY
         STC   WORK3,TIMELEN            INSERT IN DICTIONARY
         MVC   TIMEVAL(L'JSYSTIME),JSYSTIME INSERT SYSTIME VALUE
         LA    WORK3,L'JSYSDATE         GET LENGTH FOR SYSDATE ENTRY
         STC   WORK3,DATELEN            INSERT IN DICTIONARY
         MVC   DATEVAL(L'JSYSDATE),JSYSDATE  INSERT SYSDATE VALUE
         A     LOCTR,JFWORD1            BUMP PTR PAST GLOBAL DICT
         CLC   SAVOSDLN(D4),=D'0'       SEE IF OSRD LENGTH FOR READ
         BZ    SKPOSRD                  BRANCH IF YES
         MVC   PIOPARMB,SAVOSDLN        PICK UP OSRD LENGTH FOR READ
         ST    LOCTR,PIOPARMA           SET UP TO READ IN OSRD
         ST    LOCTR,OSRDSTRT           SAVE AS OSRD PTR
         JPOINT FILE=FILE2,ADDR=SAVOSDNP,NEXT=READ POINT TO OSRD
         LH    R5,JMAXRL2               SET UP MAXIMUM RECORD THIS FILE
         LA    R6,FILE2                 SET UP FILE POINTER
         BAL   RTNLNK,BUFREAD           GO GET OSRD FROM FILE 2
         A     LOCTR,PIOPARMB           BUMP PTR PAST OSRD
SKPOSRD  EQU   *
         ST    LOCTR,OVLYSTRT           SAVE AS DICT AREA START PTR
         BAL   RETURN,OVERLP4B          GO DUMP INTERLUDE ERRORS
         ST    LOCTR,SPACEAL            SET UP FREE SPACE LOW ADDR
         LCR   WORK1,LOCTR              GET COMPLEMENT FOR CALCULATE
         A     WORK1,SPACEAH            COMPUTE LENGTH OF FREE SPACE
         ST    WORK1,SPACEAE            SAVE FREE SPACE LENGTH
         ST    LOCTR,PIOPARMA           SET UP TO READ O.C. SKEL DICT
         L     PARMA,MDVSTRT            GET PTR TO OPEN CODE ENTRY
         USING MDVNTRY,PARMA
         CLC   MNPSD,=D'0'              SEE IF OPEN CODE OVERFLOWED
         BZ    OVERLP4F                 BRANCH IF IT DID
         MVC   PIOPARMB+(L'PIOPARMB-L'MSDL)(L'MSDL),MSDL               X
               SET UP LENGTH OF O.C. SKELETON DICTIONARY
         L     R0,PIOPARMB              LENGTH OF SKEL DICTIONARY
         C     R0,SPACEAE               CHECK FOR SPACE OVERLAP
         BNL   OVERLP4C                 BRANCH IF OVERLAP FOUND
         LCR   R0,R0                    SUBTRACT LENGTH FROM
         A     R0,SPACEAE               FREE SPACE
         ST    R0,SPACEAE
         ST    LOCTR,CURRDICT           SAVE AS CURRENT DICT PTR
         BAL   RETURN,DCTFETCH          GO TO BRING IN SKEL DICT
         USING SKDCTHDR,LOCTR
         MVC   HIBYTE0+(L'HIBYTE0-L'SKLDLNG)(L'SKLDLNG),SKLDLNG        X
               GET LOCAL DICTIONARY SIZE
         L     R0,HIBYTE0               AND PICK IT UP
         CL    R0,SPACEAE               CHECK FOR SPACE OVERLAP
         BNL   OVERLP4C                 BRANCH IF OVERLAP FOUND
         BAL   RETURN,PTRINIT           GO TO SET UP DICT POINTERS
         CLC   CURRLOCL,SPACEAL         SEE IF ANY LOCAL DICT ALLOCTD
         BNL   NOLCLOC                  BRANCH IF NOT
         LR    WORK1,R0                 GET LCL DICT LENGTH FOR MOVLOP
         BAL   RETURN,LOCLINIT           INITIALIZE LOCAL DICTIONARY
NOLCLOC  EQU   *
NOLOCAL  EQU   *
         MVC   ACTRCNT,=F'4096'         INITIATE ACTR COUNT
         B     OVERLP4E                 BRANCH TO REPOSITION TEXT
OVERLP4A LA    RETURN,OVERLP4C          SET UP FOR FULSH EXIT,SEQUENCE
OVERLP4B ST    RETURN,REGSAVEB          PRESERVE LINK REGISTER
         JPOINT FILE=FILE2,NEXT=START   REPOSITION TEXT OUTPUT FILE
         MVC   D0(L'JNOTEVAL,LOCTR),SAVERRNP SET UP N/P CHAIN
         ST    LOCTR,PIOPARMA           SET UP I/O AREA POINTER
         MVC   PIOPARMB,=F'190'         SET UP ERROR BLOCK LENGTH
INLP     CLC   D0(L'JNOTEVAL,LOCTR),=D'0'   SEE IF ANY ERROR BLOCKS
         L     RETURN,REGSAVEB          RESTORE LINK REGISTER
         BZR   RETURN                   BRANCH IF NOT
         JPOINT FILE=FILE1,ADDR=(LOCTR),NEXT=READ POINT TO ERROR BLOCK
         LH    R5,JMAXRL1               SET UP MAX RCD LENGTH FOR FILE
         LA    R6,FILE1                 SET UP FILE INDICATOR
         BAL   RTNLNK,BUFREAD           GO FETCH ERROR BLOCK
         LA    EPTR,L'JNOTEVAL(,LOCTR)  GET PTR TO ERROR RECORD
         USING JTEXT,EPTR
OUTLP    CLC   JTRLI,=H'0'              LOOK FOR END OF BLOCK FLAG
         BE    INLP                     BRANCH IF FOUND
         JPUTM FILE=FILE2,ADDR=(EPTR)   PUT ERROR,RCD TO TXT FILE
         LA    EPTR,D36(,EPTR)          BUMP TO NEXT ERROR RECORD
         B     OUTLP                    GO BACK TO HANDLE NEXT ONE
OVERLP4C JPUTM FILE=FILE2,ADDR==AL1(D0,D12,JPSOP,JNOCNT,JTERROR,D0,D0,DX
               0,D0,SEV89,ERR89,D0) PUT ERROR RECORD INTO TEXT FILE
         SET   INMACRO,OFF              INDICATE NOT IN MACRO NEST
OVERLP4D SET   FLUSH2,ON                INDICATE TEXT TO BE FLUSHED
OVERLP4E JPOINT FILE=FILE1,ADDR=SAVOVFPT,NEXT=WRITE                    X
               POINT TO END OF FILE PRIOR TO REWIND
         JPOINT FILE=FILE1,NEXT=START   REWIND TEXT FILE FOR GENERATOR
         B     DICTEXIT                 RETURN TO GENERATOR
OVERLP4F JPUTM FILE=FILE2,ADDR==AL1(D0,D12,JPSOP,JNOCNT,JTERROR,D0,D0,DX
               0,D0,SEV133,ERR133,D0) PUT ERROR RECORD INTO TEXT FILE
         B     OVERLP4D                 GO SET FLUSH SWITCH,ETC.
         USING GSYSVALS,LOCTR
SYSPMOVE MVC   PARMVAL(D0),D1(WORK2)    EXECUTED SYSPARM MOVE
         DROP  LOCTR
         DROP  EPTR
         DROP  PARMA
         EJECT
*MACRCALL - THIS ROUTINE IS CALLED WHEN A MACRO INSTRUCTION IS        *
*   ENCOUNTERED. ITS FUNCTION IS TO PERFORM THE INITIALIZATION        *
*   REQUIRED TO BEGIN PARAMETER PROCESSING AND TO SUBSEQUENTLY        *
*   FETCH THE SKELETON DICTIONARY FOR THE MACRO DEFINITION.           *
*        INPUT - A POINTER IN R10 TO THE MACRO DEFINITION VECTOR      *
*                POINTER IN THE MACRO INSTRUCTION.                    *
*        OUTPUT - ON VALID MACRO CALL, R11 SET TO ZERO.               *
*                 ON UNDEFINED OP CODE, R11,SET TO VALUE INDICATING   *
*                 REASON FOR NON-DEFINITION.                          *
*                                                                     *
MACRCALL EQU   *
         USING MCRCAL,PARMA
         MVC   HIBYTE0+(L'HIBYTE0-L'MDVPNT)(L'MDVPNT),MDVPNT           X
               SAVE MDV PTR FROM TEXT FOR CURRENT AND LATER USE
         L     MDVPTR,MDVSTRT           GET BASE PTR TO MDV
         A     MDVPTR,HIBYTE0           DEVELOP PTR TO PROPER MDV SLOT
         ST    MDVPTR,MDVPTRSV          SAVE THIS POINTER FOR LATER
         USING MDVNTRY,MDVPTR
         SR    PARMB,PARMB              CLEAR RTN REG. CALL ASSUMED OK
         CLC   MNPTXT,=D'0'             CHECK FOR INVALID OP CODE
         BZ    BADCALL                  IF INVALID, BRANCH
         MVC   PPARMCNT,=F'-1'          INITIALIZE POSITIONAL COUNT
         XC    PRMTBLDS(L'PRMTBLDS+L'PVECTDIS+L'KVECTDIS+L'KCHANPTR),PRX
               MTBLDS INITIALIZE OTHER CRUCIAL PARAMETER PROCESS VALUES
         MVI   PRMSWTCH,J0              INITIALIZE PARAMETER SWITCHES
         B     DICTEXIT                 RETURN
BADCALL  IC    PARMB,MSDL+(L'MSDL-D1)   PICK UP FLAG FOR INVALID TYPE
         B     DICTEXIT                 RETURN
         DROP  PARMA
         DROP  MDVPTR
         EJECT
*CALLEND - THIS ROUTINE IS CALLED WHEN THE END-OF-PARAMETERS RECORD   *
*   IS ENCOUNTERED FOLLOWING A MACRO INSTRUCTION. ITS FUNCTION IS     *
*   TO NOTE AND SAVE THE TEXT RESUMPTION POINT FOR THE CURRENT TEXT   *
*   SEGMENT AND TO POSITION THE TEXT FILE TO THE START OF THE MACRO   *
*   DEFINITION TEXT SEGMENT.                                          *
*        INPUT - NONE.                                                *
*        OUTPUT - NONE.                                               *
*                                                                     *
CALLEND  EQU   *
         JNOTE FILE=FILE1               NOTE TEXT FILE AT END OF CALL
         MVC   NOTESAVE,JNOTEVAL        SAVE N/P  TEMPORARILY
         L     MDVPTR,MDVPTRSV          GET PTR TO MDV ENTRY CALLED
         USING MDVNTRY,MDVPTR
         JPOINT FILE=FILE1,ADDR=MNPTXT,NEXT=GET POINT TO START OF TEXT
         B     DICTEXIT                 RETURN
         DROP  MDVPTR
         EJECT
*MACRKWRD - THIS ROUTINE IS CALLED WHEN A KEYWORD PARAMETER RECORD    *
*   IS ENCOUNTERED FOLLOWING A MACRO INSTRUCTION. ITS FUNCTION IS     *
*   TO ADD THE PARAMETER VALUE TO THE KEYWORD PARAMETER CHAIN IN      *
*   PARAMETER TABLE.                                                  *
*        INPUT - A POINTER IN R10 TO THE PARAMETER RECORD.            *
*              - A POINTER IN R11 TO THE PARAMETER VALUE LENGTH       *
*                ( 1 BYTE) FOLLOWED BY THE PARAMETER VALUE CHARACTER  *
*                STRING (1-255 BYTES).
*        OUTPUT - NONE.                                               *
*                                                                     *
MACRKWRD EQU   *
         SET   KEYFLG,ON                INDICATE KEYWORD PARAMETER
         L     PTPTR,PRMTBLAD           GET PTR TO BASE OF PARAM TABLE
         A     PTPTR,PRMTBLDS           GET PTR TO NEXT PARAM SLOT
         L     PVEPTR,PVECTPTR          GET PTR TO BASE OF POSIT VECTR
         S     PVEPTR,PVECTDIS          GET PTR TO END OF VECTOR
         S     PVEPTR,KVECTDIS          ALLOW FOR KEYWORDS UP TO HERE
         LR    OVLPTR,PTPTR             SET UP PTR FOR OVERLAP CHECK
         SR    VALLEN,VALLEN            CLEAR KEYWORD/VALUE LENGTH
         USING JTEXT,PARMA
         LH    TXTPTR,JTOPP             GET DISPL TO OPERAND FIELD
         AR    TXTPTR,PARMA             GET PTR TO OPERAND FIELD
         SH    TXTPTR,=H'5'              BACK UP TO START OF HEADER
         TM    D0(TXTPTR),OPNDSUB+OPNDSUBF BYPASS KEYWORD ENTRY IF NOT
         BM    MP0                      OPERAND OR FIRST SUBOPERAND
MK1      LA    WORKA,D5(,TXTPTR)        GET PTR TO OPERAND FIELD
         IC    VALLEN,D1(,WORKA)        GET KEYWORD LENGTH
         LA    OVLPTR,D5(VALLEN,OVLPTR) MAKE OVERLAP CALCULATION
         CLR   OVLPTR,PVEPTR            AND CHECK FOR OVERLAP
         BH    OVERLAP1                 BRANCH IF PARAM WON'T FIT
         MVC   D0(D4,PTPTR),KCHANPTR    PUT KEYWORD CHAIN PTR IN TBL
         LA    PTPTR,D0(,PTPTR)         MAKE FIRST BYTE ZERO
         ST    PTPTR,KCHANPTR           UPDATE KEYWORD CHAIN PTR
         EX    VALLEN,KEYMOVE           PUT KEYWORD LEN,KEYWORD IN TBL
         LA    PTPTR,D5(VALLEN,PTPTR)   UPDATE PARAMETER TABLE PTR
         SR    VALLEN,VALLEN            INSURE ZERO LENGTH REG
         B     MP0                      CONTINUE AS POSITIONAL PARAM
KEYMOVE  MVC   D4(D0,PTPTR),D1(WORKA)   EXECUTED KEYWORD MOVE
         DROP  PARMA
         EJECT
*MACRPOST - THIS ROUTINE IS CALLED WHEN A POSITIONAL PARAMETER        *
*   RECORD IS ENCOUNTERED FOLLOWING A MACRO INSTRUCTION. ITS FUNCTION *
*   IS TO ADD THE PARAMETER VALUE TO THE PARAMETER TABLE AND TO       *
*   MAKE AN ENTRY IN THE POSITIONAL VECTOR.                           *
*        INPUT - A POINTER IN R10 TO THE PARAMETER RECORD.            *
*              - A POINTER IN R11 TO THE PARAMETER VALUE LENGTH       *
*                ( 1 BYTE) FOLLOWED BY THE PARAMETER VALUE CHARACTER  *
*                STRING (1-255 BYTES).                                *
*        OUTPUT - NONE.                                               *
*                                                                     *
MACRPOST EQU   *
         SET   KEYFLG,OFF               INDICATE POSITIONAL PARAM
         L     PTPTR,PRMTBLAD           GET PTR TO BASE OF PARAM TABLE
         A     PTPTR,PRMTBLDS           GET PTR TO NEXT PARAM SLOT
         L     PVEPTR,PVECTPTR          GET PTR TO BASE OF POSIT VECTR
         S     PVEPTR,PVECTDIS          GET PTR TO END OF VECTOR
         LR    OVLPTR,PTPTR             SET UP PTR FOR OVERLAP CHECK
         SR    VALLEN,VALLEN            CLEAR VALUE LENGTH
         USING JTEXT,PARMA
         LH    TXTPTR,JTOPP             GET DISPL TO OPERAND FIELD
         AR    TXTPTR,PARMA             GET PTR TO OPERAND FIELD
         SH    TXTPTR,=H'5'             BACK UP TO START OF HDR DATA
MP0      TM    D0(TXTPTR),OPNDSUB+OPNDSUBF LOOK FOR SUBOPERAND FLAGS
         BZ    MP2                      BRANCH IF NOT SUBOPERAND
         BM    MP3                      BRANCH IF NOT FIRST SUBOPER
         XC    SUBCNT(L'SUBCNT+L'SUBLEN+L'SUBVCTDS),SUBCNT             X
               INITIALIZE SUBOPERAND PROCESSING VALUES
MP2      ST    PTPTR,PRMPTRSV           SAVE POINTER TO STRT OF PARAM
MP3      TM    D0(TXTPTR),OPNDPRM       SEE IF PARAM PASSED FROM OUTER
         BO    MP3B                     BRANCH IF THE CASE
         TM    D0(TXTPTR),OPNDOMT       SEE IF OMITTED OPERAND. IF SO,
         BO    MP3A                     SKIP PICK UP OF VALUE LENGTH
         IC    VALLEN,D0(,PARMB)        PICK UP LENGTH OF PARAM VALUE
MP3A     LA    OVLPTR,D7(VALLEN,OVLPTR) MAKE OVERLAP CALCULATION
         CLR   OVLPTR,PVEPTR            SEE IF PARAMETER WILL FIT
         BH    OVERLAP2                 BRANCH IF NOT
MP3B     TM    D0(TXTPTR),OPNDSUB+OPNDSUBF LOOK FOR SUBOPERAND FLAGS
         BZ    MP5                      BRANCH IF NOT SUBOPERAND
         BM    MP4                      BRANCH IF NOT FIRST SUBOPERAND
         LA    OVLPTR,D13(,OVLPTR)      DEVELOP POSSIBLE OVERLAP PTR
         CLR   OVLPTR,PVEPTR            CHECK IF OVERLAP MAY OCCUR
         BH    OVERLAP2                 BRANCH IF YES
         MVC   D0(D13,PTPTR),=X'80000000000000000000000000'            X
               PUT SUBLIST HEADER IN TO PARAM TABLE
         LA    PTPTR,D13(,PTPTR)        ALLOW FOR SUBLIST HEADER
MP4      LR    WORKA,PVEPTR             GET POSIT VECTOR PTR FOR CALC
         S     WORKA,SUBVCTDS           DISPL TO END OF SUBLIST VECTOR
         SH    WORKA,=H'3'              ADJUST FOR ENTRY TO BE MADE
         LR    WORKB,PTPTR              GET PARAM TBL POINTER
         S     WORKB,PRMPTRSV           GET REL PTR TO SUBOPERAND
         ST    WORKB,HIBYTE0            SAVE COMPUTED DISPL
         MVC   D0(D3,WORKA),HIBYTE0+D1  INSERT IN SUBLIST VECTOR ENTRY
         LR    WORKB,PVEPTR             GET PTR TO PARAM VCTR END
         SR    WORKB,WORKA              GET NEW DISPL FOR SUBLST VCTR
         ST    WORKB,SUBVCTDS           SAVE DISPL FOR NEXT TIME
MP5      TM    D0(TXTPTR),OPNDPRM       SEE IF PARAM PASSED FROM OUTER
         BO    MP12                     BRANCH IF THE CASE
         TM    D0(TXTPTR),OPNDOMT       SEE IF OMITTED OPERAND
         BZ    MP6                      BRANCH IF NOT THE CASE
MPOMIT   MVC   D0(D8,PTPTR),=AL1(OPNDOMT,JO,J0,J1,J0,J0,X'60',J0)      X
               SET ENTRY TYPE FLAG, ATTRIBUTES, AND LENGTH      OX00049
         LA    PTPTR,D8(,PTPTR)         ADJUST PARAM TBL POINTER
         B     MP9                      GO FINISH UP WITH THIS PARAM
MP6      TM    D0(TXTPTR),OPNDSTR       SEE IF CHARACTER STRING
         BZ    MP7                      BRANCH IF NOT THE CASE
         TM    D0(TXTPTR),OPNDORD       CHECK FOR COMPOS OPERAND
         BZ    MP6B                     BRANCH IF SIMPLE STRING
         MVI   D0(PTPTR),OPNDSTR        PUT IN STRING FLAG
         B     MP8A                     GO HANDLE AS ORD SYMBOL REFER
MP6B     LTR   VALLEN,VALLEN            IF NULL STRING          OX00049
         BZ    MPOMIT                   OMITTED OPERAND         OX00049
         MVC   D0(D7,PTPTR),=AL1(OPNDSTR,JU,J0,J1,J0,J0,X'60')  OX00049X
               SET ENTRY TYPE FLAG AND ATTRIBUTES               OX00049
         LA    PTPTR,D7(,PTPTR)         ADJUST PARAM TBL POINTER
MP6A     EQU   *
         EX    VALLEN,STRINGMV          INSERT VALUE LENGTH, VALUE
         LA    PTPTR,D1(VALLEN,PTPTR)   ADJUST PARAM TBL POINTER
         B     MP9                      GO FINISH UP WITH THIS PARAM
MP7      TM    D0(TXTPTR),OPNDTRM       SEE IF SELF-DEFINING TERM
         BZ    MP8                      BRANCH IF NOT THE CASE
         MVC   D0(D2,PTPTR),=AL1(OPNDTRM,JN) SET ENTRY TYPE FLAG,ATTRS
         MVC   D2(D4,PTPTR),D1(TXTPTR)  INSERT BINARY VALUE
         LA    PTPTR,D7(,PTPTR)         ADJUST PARAM TBL POINTER
         B     MP6A                     GO HANDLE VALUE
MP8      MVI   D0(PTPTR),OPNDORD        INSERT TYPE FLAG (ORDINARY SYM)
         USING ORDREF,TXTPTR
MP8A     EQU   *
         MVC   HIBYTE0+(L'HIBYTE0-L'ORDPNT)(L'ORDPNT),ORDPNT           X
               PICK UP DICTIONARY POINTER FROM META TEXT
         L     WORKA,HIBYTE0            GET IT FOR POINTER CALCULATION
         CLC   OSRDSTRT,=D'0'           SEE IF ANY OSRD PRESENT
         BZ    MP8NG                    BRANCH IF NOT
         A     WORKA,OSRDSTRT           DEVELOP PTR TO DICT ENTRY
         MVC   D1(D6,PTPTR),D0(WORKA)   PULL ACROSS ORDINARY SYMB ATTR
         LA    PTPTR,D7(,PTPTR)         ADJUST PARAM TBL POINTER
         B     MP6A                     GO HANDLE VALUE
MP8NG    MVC   D1(D6,PTPTR),=AL1(JU,J0,J1,J0,J0,X'E0')   DEFAULT
         LA    PTPTR,D6(,PTPTR)         ADJUST PARAM TBL POINTER
         B     MP6A                     GO ON WITH PROCESS
MP9      TM    D0(TXTPTR),OPNDSUB       LOOK FOR SUBOPERAND FLAG
         BZ    MP10                     BRANCH IF NOT SUBOPERAND
         LH    WORKA,SUBCNT             GET CURRENT SUBOPERAND COUNT
         LA    WORKA,D1(,WORKA)         INCREMENT BY ONE
         STH   WORKA,SUBCNT             SAVE NEW COUNT
         LH    WORKA,SUBLEN             GET CURRENT SUBLIST LENGTH
         AR    WORKA,VALLEN             INCREMENT BY SUBOPERAND LENGTH
         STH   WORKA,SUBLEN             SAVE NEW LENGTH
         TM    D0(TXTPTR),OPNDSUBL      LOOK FOR LAST SUBOPER FLAG
         BZ    MP11                     BRANCH IF NOT LAST SUBOPER
         L     WORKA,PRMPTRSV           GET PTR TO SUBLIST HEADER
         MVC   D6(L'SUBCNT+L'SUBLEN,WORKA),SUBCNT INSERT SUBOPERAND    X
               COUNT AND SUBLIST LENGTH IN HEADER DATA
         MVC   D1(D5,WORKA),D14(WORKA)  INSERT ATTRIBUTES OF FIRST     X
               SUBOPERAND AS ATTRIBUTES OF SUBLIST
         LR    WORKB,PTPTR              GET PTR TO PARAM TABLE
         SR    WORKB,WORKA              GET LENGTH OF SUBLIST ENTRY
         A     WORKB,SUBVCTDS           GET DISPL TO SUBLIST VCTR STRT
         ST    WORKB,JFWORD1            SAVE DISPL TO SUBLIST VECTOR
         MVC   D10(D3,WORKA),JFWORD1+D1 INSERT INTO SUBLIST HEADER
         L     WORK1,SUBVCTDS           GET LENGTH OF SUBLIST VECTOR
         LR    WORKA,PVEPTR             GET PTR TO END OF SUBLST VCTR
         SR    WORKA,WORK1              GET PTR TO STRT OF SUBLST VCTR
         LR    WORKB,PTPTR              GET PTR TO PARAM TABLE
         BAL   RETURN,MOVLOP            GO MERGE VECTOR WITH SUBLIST
         A     PTPTR,SUBVCTDS           ADJUST PTR FOR SUBLIST VECTOR
MP10     GOIF  KEYFLG,ON=MP11           BRANCH IF KEYWORD OPERAND
         L     WORKA,PRMPTRSV           GET PTR TO PARAMETER START
         S     WORKA,PRMTBLAD           GET DISPL TO PARAM IN TABLE
         SH    PVEPTR,=H'3'             GET PTR TO NEXT VECTOR ENTRY
         ST    WORKA,HIBYTE0            SAVE DISPL TO PARAM ENTRY
         MVC   D0(D3,PVEPTR),HIBYTE0+D1 AND PUT INTO VECTOR ENTRY
         L     WORKA,PVECTPTR           PICK UP PARAM VECTOR BASE
         SR    WORKA,PVEPTR             GET DISPL TO NEW END OF VECTOR
         ST    WORKA,PVECTDIS           SAVE DISPLACEMENT
         L     WORKA,PPARMCNT           GET CURRENT POSIT PARAM COUNT
         LA    WORKA,D1(,WORKA)         INCREMENT BY ONE
         ST    WORKA,PPARMCNT           SAVE NEW COUNT
MP11     S     PTPTR,PRMTBLAD           GET NEW PARAM TBL LENGTH
         ST    PTPTR,PRMTBLDS           SAVE DISPL
         B     DICTEXIT                 RETURN
MP12     GOIF  PASSPARM,ON=MP12A        GO TO HANDLE PARAM AS PARAM
         IC    VALLEN,D0(,PARMB)        PICK UP LENGTH OF PARAM STRING
         LA    OVLPTR,D7(VALLEN,OVLPTR) CALCULATE OVERLAP POINTER
         CLR   OVLPTR,PVEPTR            SEE IF OVERLAP OCCURRED
         BH    OVERLAP2                 BRANCH IF SO. OTHERWISE,
         B     MP6B                     HANDLE PARAM AS STRING
MP12A    EQU   *
         TM    D0(PARMB),OPNDSUB        SEE IF PASSING A SUBLIST
         BZ    MP13                     BRANCH IF NOT SUBLIST
         MVC   HIBYTE0+D1(D3),D10(PARMB) PICK UP PTR TO SUBLIST VCTR
         L     WORK1,HIBYTE0            GET IT AS SUBLIST LENGTH
         B     MP13A                    GO CHECK FOR OVERLAP CONDITION
MP13     IC    VALLEN,D7(,PARMB)        PICK UP VALUE LENGTH
         LA    WORK1,D8(,VALLEN)        GET WHOLE PARAMETER LENGTH
MP13A    LA    OVLPTR,D3(WORK1,OVLPTR)  DEVELOP OVERLAP PTR
         CLR   OVLPTR,PVEPTR            CHECK FOR POSSIBLE OVERLAP
         BH    OVERLAP2                 BRANCH IF YES
         LR    R0,WORK1                 PRESERVE PARAMETER LENGTH
         LR    WORKA,PARMB              GET PTR TO PARAMETER VALUE
         LR    WORKB,PTPTR              GET PTR TO PARAMETER TABLE
         BAL   RETURN,MOVLOP            GO TO PUT PARAM VALUE IN TABLE
         AR    PTPTR,R0                 ADJUST PTR FOR PARAM VALUE
         SET   PASSPARM,OFF             CLEAN UP PASSED PARAM SWITCH
         B     MP9                      GO FINISH UP WITH THIS PARAM
STRINGMV MVC   D0(D0,PTPTR),D0(PARMB)   EXECUTE PARM VALUE MOVE
OVERLAP1 EQU   *
OVERLAP2 EQU   *
         SET   (CALLING,NOCALL),FLIP    RESET SWITCHES FOR REST OF CALL
         SET   DEFLG,OFF                SET FLAG FOR DEFAULT OVERLAP
         BAL   R2,ERRRTN                GO TO LOG ERROR AND FIX COUNT
         B     DICTEXIT                 RETURN TO GENERATOR
         DROP  PARMA
         DROP  TXTPTR
         EJECT
* PROTOKWD - THIS ROUTINE IS CALLED WHEN A KEYWORD PARAMETER RECORD   *
*   IS ENCOUNTERED FOLLOWING A PROTOTYPE STATEMENT. ITS FUNCTION IS   *
*   TO ADD THE DEFAULT PARAMETER VALUE TO THE KEYWORD PARAMETER       *
*   CHAIN IN THE PARAMETER TABLE IF THE KEYWORD PARAMETER WAS NOT     *
*   SPECIFIED ON THE MACRO INSTRUCTION. IT ALSO MAKES AN ENTRY IN     *
*   THE KEYWORD VECTOR.                                               *
*        INPUT - A POINTER IN R10 TO THE PARAMETER RECORD.            *
*              - A POINTER IN R11 TO THE PARAMETER VALUE LENGTH       *
*                ( 1 BYTE) FOLLOWED BY THE PARAMETER VALUE CHARACTER  *
*                STRING (1-255 BYTES).                                *
*        OUTPUT - NONE.                                               *
*                                                                     *
PROTOKWD EQU   *
         USING JTEXT,PARMA
         LH    KEYPTR,JTOPP             GET DISPL TO OPERAND FIELD
         AR    KEYPTR,PARMA             GET PTR TO STRT OF OPRND FIELD
         GOIF  BYFLG,ON=PK8             BRANCH IF BYPASS FLAG ON
         GOIF  ENFLG,ON=PK7             BRANCH IF ENTRY FLAG ON
         SET   PREVDEF,OFF              INITIALIZE DUPLICATION SWITCH
         SR    KEYLEN,KEYLEN            CLEAR REG FOR KEYWORD LENGTH
         IC    KEYLEN,D1(,KEYPTR)       PICK UP KEYWORD LENGTH
         BCTR  KEYLEN,D0                DROP AMPERSAND
         STC   KEYLEN,KEYLENSV          SAVE FOR LENGTH COMPARISON
         BCTR  KEYLEN,D0                GET MOVE LENGTH OF KEYWORD
         L     KEYCHAIN,KCHANPTR        PICK UP KEYWORD CHAIN POINTER
PK1      LTR   KEYCHAIN,KEYCHAIN        SEE IF CHAIN PTR ZERO (END)
         BZ    PK5                      BRANCH IF END TO ENTER DEFAULT
         TM    D0(KEYCHAIN),BIT0        LOOK FOR PROCESSED INDICATOR
         BO    PK2                      BRANCH IF ON TO GET NEXT ENTRY
         CLC   KEYLENSV,D4(KEYCHAIN)    COMPARE KEYWORD LENGTHS
         BNE   PK2                      BRANCH IF UNALIKE TO GET NEXT
         EX    KEYLEN,KEYCOMP           COMPARE KEYWORDS
         BE    PK3                      BRANCH IF IDENTICAL
PK2      MVC   HIBYTE0(D4),D0(KEYCHAIN) GET CHAIN PTR FROM ENTRY
         NI    HIBYTE0,BITFF-BIT0       STRIP OUT HIGH BIT IF THERE
         L     KEYCHAIN,HIBYTE0         MAKE IT THE NEW CHAIN POINTER
         B     PK1                      GO BACK TO CONTINUE SEARCH
PK3      GOIF  PREVDEF,ON=KDUPLERR      BRANCH IF MATCH ALREADY FOUND
         SET   PREVDEF,ON               INDICATE INITIAL MATCH
         LR    WORKX,KEYPTR             SET UP OPERAND FIELD PTR
         SH    WORKX,=H'5'              GET PTR TO START OF HEADER
         TM    D0(WORKX),OPNDSUB+OPNDSUBF+OPNDSUBL                     X
               CHECK SUBOPERAND FLAGS
         BNM   PK4                      BRANCH IF NOT SUBOPERAND (NTH)
         SET   BYFLG,ON                 SET BYPASS FLAG ON
PK4      EQU   *
         BAL   R9,KWDEND                GO TO FINISH KEYWORD ENTRY
         B     PK2                      GO BACK TO COMPLETE SCAN
PK5      GOIF  PREVDEF,ON=DICTEXIT      DONT ENTER DEFALT OF DUPLICATE
         LR    WORKX,KEYPTR             SET UP OPERAND FIELD PTR
         SH    WORKX,=H'5'              GET PTR TO START OF HEADER
         TM    D0(WORKX),OPNDSUB+OPNDSUBF+OPNDSUBL                     X
               CHECK SUBOPERAND FLAGS
         BNM   PK6                      BRANCH IF NOT SUBOPERAND (NTH)
         SET   ENFLG,ON                 SET ENTRY FLAG ON
PK6      SET   DEFLG,ON                 INDICATE DEFAULT VALUE ASSGNMT
         LR    R12,R8                   SET UP DUMMY BASE ADDR
         MVC   RECURSTK(D32),REGSTACK   PRESERVE OUTER LEVEL REGISTERS
         LA    R11,D5(KEYLEN,KEYPTR)    GET PTR TO PARAM STRING
         MVI   NDXVAL,D6                SET UP FOR MACRKWRD ENTRY
         BALR  R9,R12                   MAKE RECURRSIVE ENTRY
         MVC   REGSTACK(D32),RECURSTK   RESTORE OUTER LEVEL REGISTERS
         GOIF  DEFLG,OFF=OVERLAP3       BRANCH IF OVERLAP OCCURRED
         GOIF  ENFLG,ON=DICTEXIT        FINISHED WITH SUBOPERAND
         B     PK7A                     GO TO MAKE VECTOR ENTRY
PK7      MVC   RECURSTK(D32),REGSTACK   PRESERVE OUTER LEVEL REGISTERS
         LR    R12,R8                   SET UP DUMMY BASE ADDR
         LA    R11,D1(,KEYPTR)          GET PTR TO PARAM STRING
         MVI   NDXVAL,D6                SET UP FOR MACRKWRD ENTRY
         BALR  R9,R12                   MAKE RECURRSIVE ENTRY
         MVC   REGSTACK(D32),RECURSTK   RESTORE OUTER LEVEL REGISTERS
PK71     EQU   *
         GOIF  DEFLG,OFF=OVERLAP3       BRANCH IF OVERLAP OCCURRED
         LR    WORKX,KEYPTR             SET UP OPERAND FIELD PTR
         SH    WORKX,=H'5'              GET PTR TO START OF HEADER
         TM    D0(WORKX),OPNDSUBL       LOOK FOR LAST SUBOPERAND FLAG
         BZ    DICTEXIT                 BRANCH IF NOT FOUND
         SET   ENFLG,OFF                TURN OFF ENTRY FLAG
PK7A     L     KEYCHAIN,KCHANPTR        PICK UP PTR TO KEYWORD ENTERED
         SR    KEYLEN,KEYLEN            CLEAR REG FOR KEYWORD LENGTH
         IC    KEYLEN,KEYLENSV          PICK UP SAVED KEYWORD LENGTH
         BAL   R9,KWDEND                GO TO FINISH KEYWORD ENTRY
         B     DICTEXIT                 DONE WITH THIS ENTRY
PK8      LR    WORKX,KEYPTR             SET UP OPERAND FIELD PTR
         SH    WORKX,=H'5'              GET PTR TO START OF HEADER
         TM    D0(WORKX),OPNDSUBL       LOOK FOR LAST SUBOPERAND FLAG
         BZ    DICTEXIT                 BRANCH IF NOT FOUND
         SET   BYFLG,OFF                TURN OFF BYPASS FLAG
         B     DICTEXIT                 RETURN
KWDEND   L     WORKZ,PVECTPTR           GET PTR TO END OF PARAM VCTRS
         S     WORKZ,PVECTDIS           GET PTR TO START OF POSIT VCTR
         SH    WORKZ,=H'3'              GET PTR TO FIRST KEYWORD SLOT
         S     WORKZ,KVECTDIS           DISPLACE TO NEXT KEYWORD SLOT
         LA    WORKY,D6(KEYLEN,KEYCHAIN) GET PTR TO PARAM TBL ENTRY
         S     WORKY,PRMTBLAD           GET DISPL TO PARAM TBL ENTRY
         ST    WORKY,JFWORD1            SAVE DISPLACEMENT AND
         MVC   D0(D3,WORKZ),JFWORD1+D1  INSERT INTO KEYWORD VECTOR SLOT
         L     WORKY,KVECTDIS           PICK UP CURRENT KEYWORD VECTOR
         AH    WORKY,=H'3'              LENGTH, ADJUST FOR NEW PARAM,
         ST    WORKY,KVECTDIS           AND SAVE ADJUSTED LENGTH
         OI    D0(KEYCHAIN),BIT0        INDICATE KEYWORD ENTRY PROCESSD
         BR    R9                       RETURN TO CALLER
KEYCOMP  CLC   D5(D0,KEYCHAIN),D3(KEYPTR) EXECUTED KEYWORD COMPARE
KDUPLERR L     R12,=A(LOGERR01)         GET PTR TO ERROR LOGGING RTN
         JEXTRN (X3A02=LOGERR01)
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV91,ERR91)         ERROR PARAMETERS
         L     WORKX,ESTKNDX            PICK UP ERROR STACK POINTER
         MVC   D0(D8,WORKX),=8AL1(JBLANK) INSERT NAME PADDING
         IC    WORKY,D4(,KEYCHAIN)      PICK UP KEYWORD LENGTH
         BCTR  WORKX,D0                 BACK UP TO LAST ENTRY
         EX    WORKY,KEYDUPMV          INSERT KEYWORD IN MESSAGE
         LA    WORKX,D9(,WORKX)         ADJUST ERROR STACK POINTER
         ST    WORKX,ESTKNDX            SAVE ERROR STACK POINTER
         L     R15,TXTOUT               PICK UP PTR TO LAST TEXT RCD
         USING JTEXT,R15
         SET   JERR,ON                  INDICATE AN ERROR FOLLOWS
         OI    D0(KEYCHAIN),BIT0        INDICATE KEYWORD ENTRY PROCESSD
         B     PK2                      GO BACK FOR FURTHER SCAN
KEYDUPMV MVC   D0(D0,WORKX),D4(KEYCHAIN) EXECUTED MOVE OF DUPL KEYWRD
         DROP  PARMA
         DROP  R15
         EJECT
*PROTOEND - THIS ROUTINE IS CALLED WHEN THE END-OF-PARAMETERS RECORD  *
*   IS ENCOUNTERED FOLLOWING A PROTOTYPE STATEMENT. ITS FUNCTION IS   *
*   TO CHECK FOR AND FLAG UNDECLARED KEYWORD PARAMETERS, TO COMPLETE  *
*   THE PARAMETER PROCESSING AND TO MERGE THE PARAMETER VECTORS       *
*   AND THE PARAMETER TABLE INTO THE MACRO PARAMETER WORK AREA, TO    *
*   ALLOCATE THE SPACE FOR AND FETCH THE SKELETON DICTIONARY FOR      *
*   THE MACRO DEFINITION, AND TO ALLOCATE THE SPACE FOR AND           *
*   INITIALIZE THE LOCAL DICTIONARY FOR THE MACRO DEFINITION. IF      *
*   NECESSARY TO GET THE SPACE FOR THE DICTIONARY BEING BUILT, THE    *
*   DICTIONARY(S) FOR THE HIGHER LEVEL TEXT SEGMENT(S) ARE SAVED      *
*   ON A WORKFILE.                                                    *
*        INPUT - NONE.                                                *
*        OUTPUT - NONE.                                               *
*                                                                     *
PROTOEND EQU   *
         L     KCPTR,KCHANPTR           PICK UP KEYWORD CHAIN PTR
PE0      LTR   KCPTR,KCPTR              SEE IF END OF CHAIN INDICATED
         BZ    PE2                      BRANCH IF YES
         TM    D0(KCPTR),BIT0           SEE IF KEYWORD DEFINED
         BO    PE1                      BRANCH IF YES AND MATCH FOUND
         L     R12,=A(LOGERR01)         GET PTR TO ERROR LOGGING RTN
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV92,ERR92)         ERROR PARAMETERS
         L     WORKX,ESTKNDX            PICK UP ERROR STACK POINTER
         MVC   D0(D8,WORKX),=8AL1(JBLANK) INSERT NAME PADDING
         IC    WORKY,D4(,KCPTR)         PICK UP KEYWORD LENGTH
         BCTR  WORKX,D0                 BACK UP TO LAST ENTRY
         EX    WORKY,KEYUNDMV           INSERT KEYWORD IN MESSAGE
         LA    WORKX,D9(,WORKX)         ADJUST ERROR STACK POINTER
         ST    WORKX,ESTKNDX            SAVE ERROR STACK POINTER
         L     R15,TXTOUT               PICK UP PTR TO LAST TEXT RCD
         USING JTEXT,R15
         SET   JERR,ON                  INDICATE AN ERROR FOLLOWS
PE1      NI    D0(KCPTR),BITFF-BIT0     STRIP OFF FLAG BIT
         MVC   HIBYTE0(D4),D0(KCPTR)    GET CHAIN POINTER FROM ENTRY
         L     KCPTR,HIBYTE0            PICK UP PTR FOR NEXT ENTRY
         B     PE0                      GO BACK TO REPEAT PROCESS
PE2      EQU   *
         L     WORK1,PVECTDIS           GET LENGTH OF POSITIONAL VCTR
         A     WORK1,KVECTDIS           GET LENGTH OF BOTH VECTORS
         LTR   WORK1,WORK1              SEE IF ANY VECTORS TO MOVE
         BZ    PE3                      IF NOT, SKIP MOVE
         ST    WORK1,KVECTDIS           PRESERVE LENGTH OF VECTORS
         L     WORKB,PRMTBLAD           GET PTR TO START OF PARAM TBL
         A     WORKB,PRMTBLDS           GET PTR TO END OF PARAM TBL
         L     WORKA,PVECTPTR           GET PTR TO END OF VECTORS
         SR    WORKA,WORK1              GET PTR TO START OF VECTORS
         BAL   RETURN,MOVLOP            GO MOVE PARAM VECTORS TO TABLE
PE3      EQU   *
         JNOTE FILE=FILE1               KEEP PTR TO TEXT FILE
         MVC   SAVENOTE,JNOTEVAL        SAVE NOTE/POINT ADDR
         L     SKDCTPTR,CURRDICT        GET PTR TO CALLING LEVEL DICT
         USING SKDCTHDR,SKDCTPTR
         MVC   SKACTRV,ACTRCNT          SAVE CURRENT ACTR VALUE
         MVC   SKNOFSLS,NOFSYSLS        SAVE POSITIONAL PARAM COUNT
         ST    SKDCTPTR,ALTPTRSV        SAVE DICT PTR TEMPORARILY
         L     SKDCTPTR,SPACEAL         GET PTR TO STRT OF FREE AREA
         A     SKDCTPTR,PRMTBLDS        ALLOW FOR PARAMETER TABLE
         A     SKDCTPTR,KVECTDIS        ALLOW FOR PARAMETER VECTORS
         ST    SKDCTPTR,PIOPARMA        SET UP PTR FOR DICT SKEL FETCH
         L     PARMA,MDVPTRSV           GET PTR TO MDV ENTRY
         USING MDVNTRY,PARMA
         MVC   PIOPARMB+(L'PIOPARMB-L'MSDL)(L'MSDL),MSDL               X
               SET UP SKEL DICT LENGTH
         L     R0,PRMTBLDS              LENGTH OF PARAMETERS TABLE
         A     R0,KVECTDIS              LENGTH OF PARAMETER VECTORS
         A     R0,PIOPARMB              LENGTH OF SKEL DICTIONARY
         C     R0,SPACEAE               CHECK FOR SPACE OVERLAP
         BNL   OVERLAP5                 BRANCH IF INSUFF SPACE
         LCR   R0,R0                    SUBTRACT LENGTH FROM
         A     R0,SPACEAE               FREE SPACE
         ST    R0,SPACEAE
         BAL   RETURN,DCTFETCH          GO TO FETCH SKELETON DICT
         MVC   SKNPNLT,NOTESAVE         PUT TXT N/P IN SKEL DICT HDR
         MVC   SKKVADR,PVECTDIS+(L'PVECTDIS-L'SKKVADR) GET POSITIONAL  X
               VECTOR LENGTH FOR HEADER
         MVC   SKADNLD,ALTPTRSV         SAVE PTR TO NEXT LEVEL DICT
         MVC   HIBYTE0+(L'HIBYTE0-L'SKLDLNG)(L'SKLDLNG),SKLDLNG        X
               GET LOCAL DICT LENGTH FROM DICT HEADER
         L     R0,HIBYTE0               PICK UP LENGTH FOR INITIAL
         CL    R0,SPACEAE               SEE IF SPACE OVERLAP OCCURS
         BNL   OVERLAP5                 BRANCH ON OVERLAP
         ST    SKDCTPTR,CURRDICT        SET UP NEW CURRENT DICT PTR
         LR    WORK1,SKDCTPTR           GET PTR TO DICT AREA BASE
         S     WORK1,SPACEAL            COMPUTE PARAM TBL LENGTH
         ST    WORK1,HIBYTE0            SAVE TEMPORARILY AND INSERT
         MVC   SKMPADR,HIBYTE0+(L'HIBYTE0-L'SKMPADR) IN DICT HDR
         BAL   RETURN,PTRINIT           GO INITIALIZE DICT POINTERS
         CLC   CURRLOCL,SPACEAL         SEE IF LOCAL DICT LENGTH ZERO
         BE    NOLCLMD                  SKIP INITIALIZATION IF SO
         LR    WORK1,R0                 GET LOCAL LENGTH FOR MOVLOP
         BAL   RETURN,LOCLINIT           GO INITIZE LOCAL DICTIONARY
         L     WORK1,CURRLOCL           GET PTR TO LOCAL DICT BASE
         USING LSYSVALS,WORK1
         MVC   INDXVAL,SYSNDX           PUT SYSNDX VALUE IN LCL DICT
         IC    WORK3,SYSECTL            GET LENGTH OF SYSECT VALUE
         EX    WORK3,SECTMOVE           PUT SYSECT VALUE,LEN IN LCL DT
NOLCLMD  EQU   *
         MVC   ACTRCNT,=F'4096'         INITIALIZE ACTR VALUE
         L     WORK2,PPARMCNT           PICK UP FINAL POSITIONAL COUNT
         LTR   WORK2,WORK2              SEE IF ANY WERE PRESENT
         BNM   GOODCNT                  BRANCH IF ONE OR MORE
         SR    WORK2,WORK2              SET COUNT TO ZERO
GOODCNT  STH   WORK2,NOFSYSLS           SAVE POSITIONAL COUNT FOR DICT
         JPOINT FILE=FILE1,ADDR=SAVENOTE,NEXT=GET REPOSITION TEXT
         JGETL FILE=FILE1               DUMMY GET ON TEXT FILE
         B     DICTEXIT                 RETURN
SECTMOVE MVC   SECTLEN(D0),SYSECTL      EXECUTED SYSECT MOVE
KEYUNDMV MVC   D0(D0,WORKX),D4(KCPTR)   EXECUTED MOVE OF UNDEF KEYWORD
OVERLAP5 SET   CALLING,OFF              EFFECTIVELY ABORT CALL
         BAL   R2,ERRRTN                GO TO LOG OVERLAP ERROR
OVERLAP3 EQU   *
         NI    EVALSW01,BITFF-(CALLING+NOCALL)                  OY01298
         JPOINT FILE=FILE1,ADDR=NOTESAVE,NEXT=GET REPOSITION TEXT FILE
         B     DICTEXIT                 EXIT
         DROP  PARMA
         DROP  SKDCTPTR
         DROP  R15
         EJECT
*GBLDICTR/GBLDICTS - THIS ROUTINE IS CALLED WHEN THE VALUE OF A       *
*   GLOBAL VARIABLE IS TO BE SET OR IS REFERENCED. ITS FUNCTION       *
*   IS TO LOCATE THE APPROPRIATE ENTRY IN THE GLOBAL DICTIONARY       *
*   THROUGH THE GLOBAL VECTOR AND TO EITHER SET THE GLOBAL DICTIONARY *
*   ENTRY TO A SPECIFIED VALUE (ENTRY AT 'GBLDICTS') OR GET THE       *
*   VALUE OF THE GLOBAL DICTIONARY ENTRY FOR THE GENERATOR (ENTRY     *
*   AT 'GBLDICTR').                                                   *
*                           * ENTRY AT GBLDICTS *                     *
*        INPUT - A POINTER IN R10 TO THE TEXT FLAG (1 BYTE)           *
*                FOLLOWED BY THE DICTIONARY POINTER (3 BYTES)         *
*                FOLLOWED BY THE EFFECTIVE SUBSCRIPT (2 BYTES)        *
*              - SETA VARIABLE, VALUE TO BE ASSIGNED IN R11           *
*                SETB VARIABLE, ZERO VALUE IN R11 TO SET VARIABLE OFF *
*                               NON-ZERO VALUE IN R11 TO SET VARIABLE *
*                                       ON                            *
*                SETC VARIABLE, POINTER TO CHARACTER STRING TO BE     *
*                                       ASSIGNED IN R11               *
*        OUTPUT - NONE.                                               *
*                           * ENTRY AT GBLDICTR *                     *
*        INPUT - A POINTER IN R10 TO THE TEXT FLAG (1 BYTE)           *
*                FOLLOWED BY THE DICTIONARY POINTER (3 BYTES)         *
*                FOLLOWED BY THE EFFECTIVE SUBSCRIPT (2 BYTES)        *
*        OUTPUT - SETA VARIABLE, VALUE OF VARIABLE IN R11             *
*                 SETB VARIABLE, ZERO VALUE IN R11 IF VARIABLE OFF    *
*                                NON-ZERO VALUE IN R11 IF VARIABLE ON *
*                 SETC VARIABLE, POINTER TO CHARACTER STRING IN R11   *
*                                                                     *
GBLDICTR EQU   *
         SET   REFFLAG,ON               INDICATE REFERENCE ENTRY
         B     GCOM                     CONTINUE AT GLOBAL COMMON
GBLDICTS EQU   *
         SET   REFFLAG,OFF              INDICATE SET ENTRY
GCOM     EQU   *
         SET   GBLCALL,ON               INDICATE GLOBAL ENTRY
         L     SETPTR,CURRGLBL          PICK UP CURRENT GBL VCTR PTR
         USING VREF,PARMA
         MVC   HIBYTE0+(L'HIBYTE0-L'VPNT)(L'VPNT),VPNT                 X
               PICK UP PTR TO GBL VECTOR ENTRY FROM TEXT
         A     SETPTR,HIBYTE0           DEVELOP PTR TO GBL VECTOR ENTRY
         CLC   D0(GBLVCTEL,SETPTR),=X'FFFFFE' LOOK FOR GBL ERROR FLAG
         BE    GBLERR                   BRANCH IF FOUND
         MVC   HIBYTE0+(L'HIBYTE0-GBLVCTEL)(GBLVCTEL),D0(SETPTR)       X
               PICK UP PTR TO GBL DICT FROM GBL VECTR ENTRY
         L     SETPTR,HIBYTE0           SET IT UP AND ADD TO GBL
         A     SETPTR,GDSTRT            DICT BASE ADDR
         B     ALLCOM                   GO TO COMMON HANDLING
GBLERR   GOIF  REFFLAG,ON=REFERR         DIVERGE ON REFERENCE OR SET
SETERR   EQU   *
         L     R12,=A(LOGERR01)         GET PTR TO ERROR LOGGING RTN
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV131,ERR131)       ERROR PARAMETERS
         B     DICTEXIT                 RETURN
REFERR   EQU   *
         L     R12,=A(LOGERR01)         GET PTR TO ERROR LOGGING RTN
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV132,ERR132)       ERROR PARAMETERS
DEADEXIT EQU   *
         SR    R11,R11                  SET UP SETA/SETB DEFAULT
         CLI   VFLAG,JTMSVC             SET IF SETA OR SETB REFERENCE
         BL    DICTEXIT                 RETURN DIRECTLY IF SO
         LA    R11,=9X'00'              SET UP DEFAULT FOR SETC REFER
         B     DICTEXIT                 RETURN
         DROP  PARMA
         EJECT
*LCLDICTR/LCLDICTS - THIS ROUTINE IS CALLED WHEN THE VALUE OF A       *
*   LOCAL VARIABLE IS TO BE SET OR IS REFERENCED. ITS FUNCTION        *
*   IS TO LOCATE THE APPROPRIATE ENTRY IN THE LOCAL DICTIONARY        *
*   AND TO EITHER SET THE LOCAL DICTIONARY ENTRY TO A SPECIFIED       *
*   VALUE (ENTRY A 'LCLDICTS') OR GET THE VALUE OF THE LOCAL          *
*   DICTIONARY ENTRY FOR THE GENERATOR (ENTRY AT 'LCLDICTR').         *
*                           * ENTRY AT LCLDICTS *                     *
*        INPUT - A POINTER IN R10 TO THE TEXT FLAG (1 BYTE)           *
*                FOLLOWED BY THE DICTIONARY POINTER (3 BYTES)         *
*                FOLLOWED BY THE EFFECTIVE SUBSCRIPT (2 BYTES)        *
*              - SETA VARIABLE, VALUE TO BE ASSIGNED IN R11           *
*                SETB VARIABLE, ZERO VALUE IN R11 TO SET VARIABLE OFF *
*                               NON-ZERO VALUE IN R11 TO SET VARIABLE *
*                                       ON                            *
*                SETC VARIABLE, POINTER TO CHARACTER STRING TO BE     *
*                                       ASSIGNED IN R11               *
*        OUTPUT - NONE.                                               *
*                           * ENTRY AT LCLDICTR *                     *
*        INPUT - A POINTER IN R10 TO THE TEXT FLAG (1 BYTE)           *
*                FOLLOWED BY THE DICTIONARY POINTER (3 BYTES)         *
*                FOLLOWED BY THE EFFECTIVE SUBSCRIPT (2 BYTES)        *
*        OUTPUT - SETA VARIABLE, VALUE OF VARIABLE IN R11             *
*                 SETB VARIABLE, ZERO VALUE IN R11 IF VARIABLE OFF    *
*                                NON-ZERO VALUE IN R11 IF VARIABLE ON *
*                 SETC VARIABLE, POINTER TO CHARACTER STRING IN R11   *
*                                                                     *
LCLDICTR EQU   *
         SET   REFFLAG,ON               INDICATE REFERENCE ENTRY
         B     LCOM                     CONTINUE AT LOCAL COMMON
LCLDICTS EQU   *
         SET   REFFLAG,OFF              INDICATE SET ENTRY
LCOM     EQU   *
         SET   GBLCALL,OFF              INDICATE LOCAL ENTRY
         L     SETPTR,CURRLOCL          PICK UP CURRENT LCL DICT PTR
         USING VREF,PARMA
         MVC   HIBYTE0+(L'HIBYTE0-L'VPNT)(L'VPNT),VPNT                 X
               PICK UP PTR TO LCL DICT ENTRY FROM TEXT
         A     SETPTR,HIBYTE0           ADD TO DICT BASE
ALLCOM   EQU   *
         TM    VSUBS,BIT0               SEE IF DEAD TERM
         BNZ   DEADTERM                 BRANCH IF SO
         MVC   JHWORD1,VSUBS            GET SUBSCRIPT FIELD FROM TEXT
         LH    PAIRE,JHWORD1            PICK IT UP FOR CALCULATION
         LTR   PAIRE,PAIRE              TEST FOR ZERO SUBSCRIPT
         BZ    TYPETEST                 BRANCH IF ZERO
         BCTR  PAIRE,D0                 ADJUST THE SUBSCRIPT
TYPETEST CLI   VFLAG,JTMSVB             TEST FOR SET VARIABLE TYPE
         BL    TYPEA                    BRANCH IF FLAG FOR A-TYPE
         CLI   VFLAG,JTMSVC             TEST FOR TYPE AGAIN
         BNL   TYPEC                    BRA CH IF FLAG FOR C-TYPE
         SRDL  PAIRE,D3                 DIVIDE SETB SUBSCRIPT BY 8
         SRL   PAIRO,D29                GET THE REMAINDER
         LA    WORK1,BIT0               INSERT A BIT FOR MASK GENERAT
         SRL   WORK1,D0(PAIRO)          SHIFT BY REMAINDER FOR MASK
         ALR   SETPTR,PAIRE             PUT PTR TO REQUIRED ENTRY
         USING SETBNTRY,SETPTR
         GOIF  REFFLAG,ON=REFSETB       BRANCH IF VARB REFERENCE
         LTR   PARMB,PARMB              TEST FOR CONDITION TO BE SET
         BZ    SETBOFF                  BRANCH IF SET TO ZERO
         EX    WORK1,SETONE             SET IT ON USING OR MASK
         B     DICTEXIT                 GO TO COMMON EXIT
SETBOFF  LA    WORK1,D1(,WORK1)         INCREMENT OR MASK BY ONE AND
         LCR   WORK1,WORK1              DEVELOP AND MASK
         EX    WORK1,SETZERO            SET IT OFF USING AND MASK
         B     DICTEXIT                 GO TO COMMON EXIT
REFSETB  EX    WORK1,TESTINST           TEST IF SETB ON
         BO    SETBON                   BRANCH IF ON
         SR    PARMB,PARMB              INDICATE SETB OFF TO GENERATOR
         B     DICTEXIT                 GO TO COMMON EXIT
SETBON   LA    PARMB,D1                 INDICATE SETB ON TO GENERATOR
         B     DICTEXIT                 GO TO COMMON EXIT
TESTINST TM    SETBVAL,D0               EXECUTED SETB VARB TEST
SETONE   OI    SETBVAL,D0               EXECUTED TURN-ON FOR SETB VARB
SETZERO  NI    SETBVAL,D0               EXECUTED TURN-OFF FOR SETB VARB
DEADTERM GOIF  REFFLAG,OFF=DICTEXIT,    IGNORE ATTEMPT TO SET VARIABLE X
               ELSE=DEADEXIT            GET DEFAULT (NULL) ON REFERENCE
TYPEA    EQU   *
         SLL   PAIRE,D2                 MULTIPLY SUBSCRIPT BY 4
         ALR   SETPTR,PAIRE             DEVELOP PTR TO ARRAY ENTRY
         USING SETANTRY,SETPTR
         GOIF  REFFLAG,ON=REFSETA       BRANCH IF VARB NOT TO BE SET
         ST    PARMB,JFWORD1            STORE VALUE FROM GENERATOR
         MVC   SETAVAL,JFWORD1          INSERT INTO DICT ENTRY
         B     DICTEXIT                 GO TO COMMON EXIT
REFSETA  MVC   JFWORD1,SETAVAL          GET DICT ENTRY
         L     PARMB,JFWORD1            PICK IT UP FOR GENERATOR
         B     DICTEXIT                 GO TO COMMON EXIT
TYPEC    EQU   *
         MH    PAIRE,=H'9'              MULTIPLY SUBSCRIPT BY 9
         ALR   SETPTR,PAIRE             DEVELOP PTR TO ARRAY ENTRY
         LR    DICTPTR,SETPTR           PRESERVE ORIGINAL DICT PTR
         CLI   D0(DICTPTR),J8           SEE IF SETC EXTENDED
         BNH   REFCHEK                  BRANCH IF NOT
         MVC   HIBYTE0+D1(D3),D6(SETPTR) PICK UP PTR TO EXTENSION ENTRY
         GOIF  GBLCALL,ON=GETGBLEX      BRANCH IF GLOBAL EXTENSION
         L     SETPTR,HIBYTE0           PICK UP DISPLACEMENT
         A     SETPTR,CURRLOCL          COMPUTE PTR TO LOCAL EXTENSION
REFCHEK  GOIF  REFFLAG,ON=REFSETC       BRANCH IF SETC REFERENCE ONLY
         SR    PAIRO,PAIRO              CLEAR REG FOR EXTENSION CALCS
         IC    PAIRO,D0(,PARMB)         PICK UP STRING LENGTH
         L     PAIRE,=F'-16'            SET UP INITIAL MASK
         AR    PAIRO,PAIRO              SHIFT LENGTH LEFT ONE
         NR    PAIRO,PAIRE              DROP OFF LOW ORDER FOUR BITS
HSHLP    LR    SETLEN,PAIRO             PRESERVE CURRENT LENGTH
         AR    PAIRE,PAIRE              SHIFT MASK LEFT ONE
         NR    PAIRO,PAIRE              AND TO GET NEXT EXTENSION LNGT
         BNZ   HSHLP                    RETRY IF NOT LARGER THAN STRING
         CLI   D0(DICTPTR),J8           SEEIF ENTRY EXTENDED
         BH    EXTEST                   IF YES, LOOK AT EXTENSION
         CLI   D0(PARMB),J8             SEE IF SET VALUE WILL FIT
         BNH   PUTSET                   BRANCH IF IT WILL FIT
         B     TPCHEK                   GO TO EXTEND DICTIONARY ENTRY
EXTEST   CLC   D0(D1,DICTPTR),D0(PARMB) SEE IF SET VALUE WILL FIT
         BNL   PUTSET                   BRANCH IF IT WILL FIT
TPCHEK   EQU   *
         GOIF  GBLCALL,ON=GBLEXTND      BRANCH IF GLOBAL EXTENSION REQD
         CL    SETLEN,SPACEAE           SEE IF ROOM IS AVAILABLE
         BNL   OVERLAP9                 BRANCH IF NOT
         L     SETPTR,SPACEAL           SET UP PTR TO EXTENSION ENTRY
         LR    WORK1,SETPTR             SET UP EXTENSION BASE ADDR
         S     WORK1,CURRLOCL           COMPUTE DISPL TO LCL ENTRY
         ST    WORK1,JFWORD1            SAVE TEMPORARILY
         MVC   D6(D3,DICTPTR),JFWORD1+D1 INSERT IN ORIGINAL DICT ENTRY
         L     SKDCTPTR,CURRDICT        SET UP PTR TO DICT HDR
         USING SKDCTHDR,SKDCTPTR
         MVC   HIBYTE0+(L'HIBYTE0-L'SKLDLNG)(L'SKLDLNG),SKLDLNG        X
               PICK UP CURRENT LOCAL DICTIONARY LENGTH
         L     WORK1,HIBYTE0            SET UP TO ADD EXTENSION ENTRY
         AR    WORK1,SETLEN             ADJUST FOR EXTENSION
         ST    WORK1,JFWORD1            SAVE TEMPORARILY AND REPLACE
         MVC   SKLDLNG,JFWORD1+(L'JFWORD1-L'SKLDLNG) IN DICT HEADER
         LA    WORK1,D0(SETLEN,SETPTR)  DEVELOP NEW LOW SPACE ADDR
         ST    WORK1,SPACEAL            SAVE NEW LOW SPACE ADDR
         L     WORK2,SPACEAH            PICK UP HIGH SPACE ADDR
         SR    WORK2,WORK1              SUBTRACT LOW SPACE ADDR
         ST    WORK2,SPACEAE            SAVE NEW SPACE EXTENT
SETMAX   BCTR  SETLEN,D0                GET EXTENSION LENGTH -1
         STC   SETLEN,D0(,DICTPTR)      PUT IN PRIMARY DICT ENTRY
         USING SETCNTRY,SETPTR
PUTSET   IC    SETLEN,D0(,PARMB)        PICK UP STRING LENGTH
         EX    SETLEN,MOVEINST          MOVE STRING INTO SETC ENTRY
         B     DICTEXIT                 RETURN
GETGBLEX CLC   HIBYTE0,=D'0'            SEE IF EXTENDED SYSPARM
         BZ    GGX1                     BRANCH IF IT IS
         L     SETPTR,FREEEND           PICK UP EXTENSION AREA BASE
         S     SETPTR,HIBYTE0           COMPUTE PTR TO GLOBAL EXTENSION
         B     REFCHEK                  RETURN TO MAIN FLOW
REFSETC  LR    PARMB,SETPTR             GET PTR FOR GENERATOR TO SETC
         B     DICTEXIT                 RETURN
GGX1     L     PARMB,JSYSPARM           PICK UP SYSPARM POINTER
         B     DICTEXIT                 RETURN
OVERLAP8 EQU   *
OVERLAP9 EQU   *
         BAL   R2,ERRRTN                 GO TO LOG ERROR AND FIX COUNT
         GOIF  FLUSH2,OFF=MACRPOP,      BRANCH IF NO OVERLAP FOUND     X
               ELSE=DICTEXIT            IN OPEN CODE
GBLEXTND CL    SETLEN,SPACEAE           SEE IF ENOUGH ROOM IN AREA
         BNL   OVERLAP8                 BRANCH IF NOT
         L     SETPTR,SPACEAH           PICK UP AREA HIGH ADDRESS
         SR    SETPTR,SETLEN            ADJUST FOR STRING BYTES
         ST    SETPTR,SPACEAH           SAVE NEW AREA HIGH ADDRESS
         LR    WORK1,SETPTR             GET NEW AREA HIGH ADDRESS
         S     WORK1,SPACEAL            SUBTRACT AREA LOW ADDRESS
         ST    WORK1,SPACEAE            SAVE NEW AREA LENGTH
         L     WORK1,FREEEND            GET EXTENSION BASE PTR
         SR    WORK1,SETPTR             COMPUTE DISPLACEMENT
         ST    WORK1,JFWORD1            SAVE TEMPORARILY AND INSERT
         MVC   D6(D3,DICTPTR),JFWORD1+D1 IN ORIGINAL DICTIONARY ENTRY
         B     SETMAX                   GO TO COMPLETE SET
MOVEINST MVC   SETCLEN(D0),D0(PARMB)    EXECUTED ASSIGN FOR SETC VARB
         DROP  PARMA
         DROP  SKDCTPTR
         DROP  SETPTR
         EJECT
*PARMTBLR - THIS ROUTINE IS CALLED WHEN THE VALUE OF A PARAMETER IS   *
*   REFERENCED. ITS FUNCTION IS TO LOCATE THE APPROPRIATE ENTRY IN    *
*   THE PARAMETER TABLE THROUGH THE APPROPRIATE VECTOR, KEYWORD OR    *
*   POSITIONAL, AND TO GET THE VALUE OF THE PARAMETER TABLE ENTRY     *
*   FOR THE GENERATOR.                                                *
*        INPUT - A POINTER IN R10 TO THE TEXT FLAG (1 BYTE)           *
*                FOLLOWED BY THE VECTOR POINTER (3 BYTES)             *
*                FOLLOWED BY PADDING (2 BYTES) IF NOT A SUBOPERAND    *
*                REFERENCE OR BY SUBOPERAND NUMBER (2 BYTES) IF A     *
*                SUBOPERAND REFERENCE                                 *
*        OUTPUT - A POINTER IN R11 TO THE PARAMETER TABLE ENTRY       *
*                                                                     *
PARMTBLR EQU   *
         USING PARMREF,PARMA
         TM    PARMSUB,BIT0             LOOK FOR DEAD TERM FLAG
         BO    PTR1X                    BRANCH IF FOUND
         CLI   PARMFLG,JTMKPAR          SEE IF KEYWORD REFERENCE
         BNE   PTR1                     BRANCH IF NOT
         L     PARAMPTR,CURRKEYD        GET POINTER TO KEYWORD VECTOR
         B     PTR2                     GO JOIN MAIN FLOW
PTR1     LH    WORK1,NOFSYSLS           PICK UP POSITIONAL COUNT
         MH    WORK1,=H'3'              GET MAXIMUM VECTOR DISPL
         ST    WORK1,JFWORD1            SET ASIDE FOR PTR COMPARE
         CLC   PARMPNT,JFWORD1+(L'JFWORD1-L'PARMPNT) COMPARE DISPLS
         BNH   PTR0                     BRANCH IF PARAM IN RANGE
PTR1X    LA    PARMB,=AL1(OPNDOMT,JO,J0,J1,J0,J0,X'60',J0)  OMITTED
         B     DICTEXIT                 RETURN TO GENERATOR
PTR0     L     PARAMPTR,CURRPOST        GET POINTER TO POSITIONAL VCTR
PTR2     EQU   *
         MVC   HIBYTE0+(L'HIBYTE0-L'PARMPNT)(L'PARMPNT),PARMPNT        X
               PICK UP PTR TO PARAM VECTOR SLOT
         S     PARAMPTR,HIBYTE0         DEVELOP PTR TO VECTOR ENTRY
         MVC   HIBYTE0+D1(D3),D0(PARAMPTR) PICK UP VECTOR ENTRY
         L     PARMB,HIBYTE0            GET FOR PARAM TBL REFERENCE
         A     PARMB,CURRPARM           DEVELOP PTR TO PARAM ENTRY
         CLC   PARMPAD,=D'0'            SEE IF SUBOPERAND REFERENCE
         BZ    DICTEXIT                 IF NOT, RETURN
         MVC   JHWORD1,PARMSUB          PICK UP SUBOPERAND NUMBER
         TM    D0(PARMB),OPNDSUB        SEE IF SUBLIST BEING REFER'D
         BO    PTR4                     IF SO, PROCEED
         CLC   JHWORD1,=H'1'            SEE IF SUBOPERAND 1 REFER'D
         BE    DICTEXIT                 IF SO, RETURN WHOLE PARAM PTR
         B     PTR1X                    GO RETURN DEFAULT
PTR4     CLC   JHWORD1,D6(PARMB)        SEE IF SUBOPERAND IN RANGE
         BH    PTR1X                    GO RETURN DEFAULT
         LH    WORK1,JHWORD1            GET SUBOPERAND NUMBER
         MH    WORK1,=H'3'              CONVERT TO VECTOR INDEX
         LR    WORK2,PARMB              GET PARAM ENTRY PTR FOR CALC
         MVC   HIBYTE0+D1(D3),D10(PARMB) PICK UP SUBLIST VECTOR PTR
         A     WORK2,HIBYTE0            GET PTR TO STRT OF SUBL VCTR
         SR    WORK2,WORK1              GET PTR TO SUBLIST VECTR ENTRY
         MVC   HIBYTE0+D1(D3),D0(WORK2) PICK UP SUBLIST VECTOR ENTRY
         A     PARMB,HIBYTE0            DEVELOP PTR TO SUBOPERAND
         B     DICTEXIT                 RETURN
         DROP  PARMA
         EJECT
*SEQSYMBR - THIS ROUTINE IS CALLED WHEN A REFERENCE TO A SEQUENCE     *
*   SYMBOL IS ENCOUNTERED. ITS FUNCTION IS TO LOCATE THE APPROPRIATE  *
*   ENTRY IN THE SEQUENCE SYMBOL REFERENCE DICTIONARY AND TO GET      *
*   THE NOTE/POINT ADDRESS IN THE SEQUENCE SYMBOL REFERENCE           *
*   DICTIONARY ENTRY FOR THE GENERATOR.                               *
*        INPUT - A POINTER IN R10 TO THE TEXT FLAG (1 BYTE)           *
*                FOLLOWED BY THE DICTIONARY POINTER (3 BYTES)         *
*        OUTPUT - A POINTER IN R11 TO THE NOTE/POINT ADDRESS          *
*                                                                     *
SEQSYMBR EQU   *
         L     SKDCTPTR,CURRSEQS        GET PTR TO SEQ SYMB REF DICT
         USING SEQREF,PARMA
         USING JTEXT,R5                                         OX00218
         MVC   HIBYTE0+(L'HIBYTE0-L'SEQPNT)(L'SEQPNT),SEQPNT           X
               GET DISPL TO SEQ SYMB REF DICT ENTRY
         A     SKDCTPTR,HIBYTE0         DEVELOP PTR TO DICT ENTRY
         CLC   D0(D8,SKDCTPTR),=D'0'    LOOK FOR UNDEFINED SEQ SYM
         BZ    DICTEXIT                 RETURN DIRECTLY IF THE CASE
         GOIF  JERR,OFF=NOERREC         ANY ERROR IN REC        OX00218
ERREC    JGETL FILE=FILE1               YES, GET ERROR REC      OX00218
         LR    R5,R11                   LOAD BASE FOR TEXT      OX00218
         GOIF  JTERROR,NE=NOERREC       IS THE REC ERROR REC    OX00218
         JPUTM FILE=FILE2,ADDR=(R5)     YES,PUT IT OUT          OX00218
         B     ERREC                    SEE IF MORE ERROR REC   OX00218
NOERREC  EQU   *                        NO MORE OR NO ERROR REC OX00218
         JPOINT FILE=FILE1,ADDR=(SKDCTPTR),NEXT=GET POSITION TEXT FILE
         CLI   *,BITFF                  SET COND CODE FOR DEF SEQ SYM
         B     DICTEXIT                 RETURN TO GENERATOR
         DROP  PARMA
         EJECT
*ORDSYMBR - THIS ROUTINE IS CALLED WHEN A REFERENCE TO AN ORDINARY    *
*   SYMBOL IS ENCOUNTERED. ITS FUNCTION IS TO LOCATE THE APPROPRIATE  *
*   ENTRY IN THE ORDINARY SYMBOL REFERENCE DICTIONARY AND TO GET      *
*   THE TYPE, LENGTH, AND SCALE ATTRIBUTES OF THE ORDINARY SYMBOL     *
*   IN THE ORDINARY SYMBOL REFERENCE DICTIONARY ENTRY FOR THE         *
*   GENERATOR.                                                        *
*        INPUT - A POINTER IN R10 TO THE TEXT FLAG (1 BYTE)           *
*                FOLLOWED BY THE DICTIONARY POINTER (3 BYTES)         *
*                FOLLOWED BY 2 BYTES OF PADDING                       *
*        OUTPUT - A POINTER IN R11 TO THE TYPE ATTRIBUTE (1 BYTE)     *
*                 FOLLOWED BY THE LENGTH ATTRIBUTE (2 BYTES)          *
*                 FOLLOWED BY THE SCALE ATTRIBUTE (2 BYTES)           *
*                 ATTRIBUTES                                          *
*                                                                     *
ORDSYMBR EQU   *
         CLC   OSRDSTRT,=D'0'           SEE IF ANY OSRD PRESENT
         BZ    OSRDBAD                  BRANCH IF NONE (OVERFLOWED)
         USING ORDREF,PARMA
         MVC   HIBYTE0+(L'HIBYTE0-L'ORDPNT)(L'ORDPNT),ORDPNT           X
               PICK UP DICTIONARY POINTER FROM META-TEXT
         L     PARMB,HIBYTE0            GET IT FOR POINTER CALCULATION
         A     PARMB,OSRDSTRT           DEVELOP PTR TO DICT ENTRY
         BCTR  PARMB,D0                 BACK UP PTR FOR GEN USEAGE
         B     DICTEXIT                 RETURN TO GENERATOR
OSRDBAD  LA    PARMB,=AL1(OPNDSTR,JU,J0,J0,J0,J0) RETURN DEFAULT ATTRS
         B     DICTEXIT                 RETURN
         DROP  PARMA
         EJECT
*MACRFINI - THIS ROUTINE IS CALLED WHEN THE EXPANSION OF A MACRO      *
*   INSTRUCTION IS COMPLETED. ITS FUNCTION IS TO RESTORE THE          *
*   DICTIONARY FOR THE NEXT HIGHER LEVEL TEXT SEGMENT AS THE CURRENT  *
*   DICTIONARY AND TO REPOSITION THE TEXT FILE TO THE RESUMPTION      *
*   POINT IN THE NEXT HIGHER LEVEL TEXT SEGMENT.                      *
*        INPUT - NONE.                                                *
*        OUTPUT - NONE.                                               *
*                                                                     *
MACRFINI EQU   *
MACRPOP  EQU   *
         L     SKDCTPTR,CURRDICT        GET CURRENT DICT PTR
         USING SKDCTHDR,SKDCTPTR
MACRPOS  EQU   *
         JPOINT FILE=FILE1,ADDR=SKNPNLT,NEXT=GET REPOSITION TEXT FILE
         MVC   CURRDICT,SKADNLD         SET UP NEW CURRENT DICT PTR
         L     SKDCTPTR,CURRDICT        POINT TO SKEL DICT HDR
         MVC   ACTRCNT,SKACTRV          RESTORE ACTR COUNT
         MVC   NOFSYSLS,SKNOFSLS        RESTORE POSITIONAL PARAM COUNT
         BAL   RETURN,PTRINIT           REESTABLISH DICTIONARY POINTERS
         B     DICTEXIT                 RETURN TO GENERATOR
         DROP  SKDCTPTR
         EJECT
*
* THIS SUBROUTINE PERFORMS A BUFFERED READ FROM ANY FILE.
*        IT IS CALLED FROM THE FOLLOWING ROUTINES
*                   PHASENTR
*                   PROTOEND
*
BUFREAD  EQU   *
         ST    RTNLNK,REGSAVEA          PRESERVE LINK REGISTER
         LM    R3,R4,PIOPARMB           PICK UP I/O PARAMETERS
BRD1     CLR   R3,R5                    SEE IF RECORD LESS THAN MAX
         BH    BRD4                     BRANCH IF NOT
         CH    R3,=AL2(MINRECSZ)        SEE IF BLOCK OVER MINIMUM
         BNL   BRD11                    BRANCH IF MORE OR JUST ENUF
         LA    R3,MINRECSZ              IF NOT, USE MINIMUM SIZE
BRD11    STH   R3,PIOPARMC              SET UP RECORD LENGTH
         SR    R3,R3                    INDICATE LAST READ
BRD2     JREAD FILE=(R6),PARM=PIOPARMA  READ RECORD FROM PROPER FILE
         JCHECK FILE=(R6)               CHECK THE READ
         LTR   R3,R3                    SEE IF READ COMPLETE
         BNZ   BRD3                     DKIP AHEAD IF NOT
         L     RTNLNK,REGSAVEA          RESTORE LINK REGISTER
         BR    RTNLNK                   RETURN TO CALLING ROUTINE
BRD3     EQU   *
         AR    R4,R5                    DEVELOP PTR TO NEXT I/O AREA
         ST    R4,PIOPARMA              PUT PTR IN I/O CONTROL AREA
         B     BRD1                     GO SET UP NEW READ LENGTH
BRD4     STH   R5,PIOPARMC              SET UP MAXIMUM RECORD LENGTH
         SR    R3,R5                    ADJUST READ LENGTH
         B     BRD2                     GO READ NEXT RECORD
*
* THIS SUBROUTINE MOVES DATA TO AN AREA POINTED TO BY WORKB FROM
*        AN AREA POINTED TO BY WORKA USING THE LENGTH IN WORK1.
*        IT IS CALLED FROM THE FOLLOWING ROUTINES -
*        PHASENTR, PROTOEND, MACRPOST
*
MOVLOP1  MVC   D0(D256,WORKB),D0(WORKA) MOVE BLOCK OF 256 BYTES
         LA    WORKA,D256(,WORKA)       ADJUST SOURCE POINTER
         LA    WORKB,D256(,WORKB)       ADJUST DESTINATION POINTER
MOVLOP   SH    WORK1,=H'256'            SEE IF ONE MOVE WILL DO IT
         BP    MOVLOP1                  BRANCH IF NOT
         AH    WORK1,=H'255'            GET MOVE LENGTH REMAINING
         EX    WORK1,MOVLOP2            MOVE REMAINING SEGMENT
         BR    RETURN                   RETURN
MOVLOP2  MVC   D0(D0,WORKB),D0(WORKA)   EXECUTED MOVE - 256 OR LESS
*
* THIS SUBROUTINE LOGS THE OVERLAP ERROR MESSAGE AND DECREMENTS THE
*        MACRO NEST COUNT. IT ADJUSTS THE 'INMACRO' SWITCH IF
*        NECESSARY.
*
ERRRTN   EQU   *
         L     R12,=A(LOGERR01)         GET PTR TO ERROR LOGGING RTN
         BALR  R9,R12                   GO MAKE ERROR STACK ENTRY
         DC    AL1(SEV89,ERR89)         ERROR PARAMETERS
         L     R9,MACROLVL              GET CURRENT MACRO NEST COUNT
         GOIF  (R9),NOTZERO=ERRRTN0     BRANCH IF NOT OPEN CODE
         SET   FLUSH2,ON                INDICATE TEXT TO BE FLUSHED
         BR    R2                       EXIT DIRECTLY
ERRRTN0  EQU   *
         BCT   R9,ERRRTN1               DECREMENT BY ONE. IF ZERO,
         SET   INMACRO,OFF              INDICATE POPPED TO OPEN CODE
ERRRTN1  ST    R9,MACROLVL              SAVE ADJUSTED MACRO NEST COUNT
         BR    R2                       RETURN
*
* THIS SUBROUTINE SETS UP IN THE COMMON AREA THE POINTERS TO THE
*        VARIOUS GENERATION-TIME DICTIONARY ELEMENTS. THE POINTERS
*        ARE COMPUTED FROM VALUES IN THE DICTIONARY HEADER.
*        IT IS CALLED BY THE FOLLOWING ROUTINES -
*        MACRFINI,PHASENTR,PROTOEND
*
PTRINIT  EQU   *
         L     SKDCTPTR,CURRDICT        GET PTR TO DICT FOR INIT'ATION
         LR    WORK1,SKDCTPTR           GET COPY FOR CALCULATION
         USING SKDCTHDR,SKDCTPTR
         LA    WORK1,SKHDREND-SKDCTHDR(,WORK1) GET PTR TO GBL VECTOR
         ST    WORK1,CURRGLBL           SET ASIDE FOR GLBL REFERENCES
         MVC   HIBYTE0+(L'HIBYTE0-L'SKSRDPT)(L'SKSRDPT),SKSRDPT        X
               GET LENGTH OF GLOBAL VECTOR FROM DICT HEADER
         A     WORK1,HIBYTE0            CALCULATE PTR TO SEQ SYMB DICT
         ST    WORK1,CURRSEQS           SET ADIDE FOR SEQ SYMB REFERS
         MVC   HIBYTE0+(L'HIBYTE0-L'SKLDADR)(L'SKLDADR),SKLDADR        X
               GET LENGTH OF SEQ SYMB REFERENCE DICT FROM DICT HDR
         A     WORK1,HIBYTE0            CALCULATE PTR TO LOCAL DICT
         ST    WORK1,CURRLOCL           SET ASIDE FOR LOCAL REFERS
         MVC   HIBYTE0+(L'HIBYTE0-L'SKLDLNG)(L'SKLDLNG),SKLDLNG        X
               GET LENGTH OF LOCAL DICT FROM DICT HEADER
         A     WORK1,HIBYTE0            CALCULATE PTR TO END OF SPACE
         ST    WORK1,SPACEAL            SET ASIDE FOR FREE SPACE LOW
         LCR   WORK1,WORK1              COMPLEMENT FOR CALCULATION
         A     WORK1,SPACEAH            ADD FREE SPACE HIGH
         ST    WORK1,SPACEAE            SAVE FREE SPACE EXTENT
         LR    WORK1,SKDCTPTR           RE-GET CALCULATION BASE
         SH    WORK1,=H'3'              GET PTR TO POSITIONAL VECTOR
         ST    WORK1,CURRPOST           SAVE FOR POSIT PARAM REFERS
         MVC   HIBYTE0+(L'HIBYTE0-L'SKKVADR)(L'SKKVADR),SKKVADR        X
               GET LENGTH OF POSITIONAL VECTOR FROM DICT HEADER
         S     WORK1,HIBYTE0            GET PTR TO KEYWORD VECTOR
         ST    WORK1,CURRKEYD           SET ASIDE FOR KEYWORD REFERS
         MVC   HIBYTE0+(L'HIBYTE0-L'SKMPADR)(L'SKMPADR),SKMPADR        X
               PICK UP PARAM TBL LENGTH FROM DICT HEADER
         S     SKDCTPTR,HIBYTE0         CALCULATE PTR TO PARAM TABLE
         ST    SKDCTPTR,CURRPARM        SET ASIDE FOR PARAM REFERS
         BR    RETURN                   RETURN
         DROP  SKDCTPTR
*
* THIS SUBROUTINE INITIALIZES THE LOCAL DICTIONARY SPACE TO ZEROES.
*        IT IS CALLED FROM THE FOLLOWING ROUTINES -
*        PHASENTR,PROTOEND
*
LOCLINIT EQU   *
         LR    R12,RETURN               PRESERVE RETURN REGISTER
         L     WORKA,CURRLOCL           GET PTR TO START OF LOCAL DICT
         LA    WORKB,D1(,WORKA)         GET PTR TO SINK LOCATION
         MVI   D0(WORKA),J0             INSERT ZERO TO BE PROPAGATED
         BAL   RETURN,MOVLOP            GO TO CLEAR LOCAL DICT SPACE
         BR    R12                      RETURN
*
* THIS SUBROUTINE FETCHES A SKELETON DICTIONARY INTO THE FREE
*        SPACE. THE I/O PARAMETERS ARE SET UP IN PIOPARMA AND
*        PIOPARMB, AND R10 POINTS TO THE MDV ENTRY.
*        IT IS CALLED FROM THE FOLLOWING ROUTINES-
*        PHASENTR,PROTOEND
*
DCTFETCH EQU   *
         ST    RETURN,REGSAVEB          SAVE LINK REGISTER
         USING MDVNTRY,PARMA
         LA    R11,MNPSD                GET PTR TO N/P ADDRESS
         JPOINT FILE=FILE1,ADDR=(R11),NEXT=READ POSITION TO DICTIONARY
         LH    R5,JMAXRL1               SET UP FILES BLOCK SIZE
         LA    R6,FILE1                 SET UP FILE INDICATOR
         BAL   RTNLNK,BUFREAD           LINK TO BUFFERED READ RTN
         L     RETURN,REGSAVEB          RESTORE LINK REGISTER
         BR    RETURN                   RETURN
         DROP  PARMA
         EJECT
         LTORG
         SPACE 3
         JPATCH X3N00,E40               X3N PATCH AREA
         END
