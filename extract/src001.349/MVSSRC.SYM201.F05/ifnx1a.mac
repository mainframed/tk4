         JHEAD 'EDIT PHASE',                                           X
               PHASEID=X1A,                                            X
               LEVEL=10
*
*FUNCTION/OPERATION-
*   THIS PHASE TRANSLATES, SCANS AND EDITS SOURCE STATEMENTS, COPY
*   CODE, AND SYSTEM MACROS INTO EDITED TEXT.
*
*   IT CALLS DIRECTORY ROUTINES, 'DRUTENT', TO BUILD MACRO NAME
*   DIRECTORY, VARIABLE SYMBOL DIRECTORIES, SEQUENCE SYMBOL DIRECTORIES
*   AND OPEN CODE ORDINARY SYMBOL DIRECTORY. ON ABNORMAL RETURN
*   FROM DIRECTORY ROUTINES, 'CONCODE' IS SET TO A NON-ZERO VALUE
*   SIGNIFYING THE TYPE OF ERROR DETECTED. THE VALUE IS THEN USED
*   TO BRANCH TO THE APPROPRIATE ERROR ROUTINE TO LOG THE ERROR.
*   (SEE DIRECTORY ROUTINE PROLOG FOR FURTHER EXPLANATION.)
*
*   INPUT CONTROL ROUTINE, 'RDSRC', IS CALLED AT APPROPRIATE TIME TO
*   BRING IN SOURCE RECORDS FROM SYSTEM INPUT, OR FROM MACRO LIBRARY
*   IF IN COPY CODE OR SYSTEM MACRO EDITING.
*
*   'PROCNXT' ROUTINE EDITS NAME FIELD AND OPERATION FIELD, CLASSIFIES
*   THE TYPE OF THE INPUT RECORD, PREPARING TO PASS CONTROL TO THE
*   APPROPRIATE ROUTINES FOR FURTHER PROCESSING OF THE RECORD BASED
*   ON THE OPERATION CODE.
*
*   WHEN A MACRO PROTOTYPE RECORD IS ENCOUNTERED,  CONTROL IS
*   PASSED TO PROTOTYPE SCANNER, 'PROSCN', WHICH MAKES SYNTAX CHECKS
*   ON ALL SYMBOLIC PARAMETERS.
*
*   AS END OF OPERAND OR STATEMENT IS DETECTED,  'WRAPFLD' ROUTINE
*   IS CALLED TO WRAP UP THE BUILDING OF THE EDITED TEXT RECORD.
*   CONTROL IS THEN PASSED BACK TO THE CALLER IF END OF OPERAND,
*   OR IT EXITS TO 'READNEXT' IF END OF STATEMENT.
*
*
*ENTRY POINT-
*        EDITENT
*
*
*INPUT-
*   SYSTEM INPUT - SOURCE STATEMENTS.
*
*   MACRO LIBRARY - COPY CODE AND SYSTEM MACRO DEFINITIONS.
*
*   INPUT RECORDS ARE OBTAINED THROUGH INPUT CONTROL ROUTINE IN
*   80-BYTE CARD FORMAT WITH REGISTER 'RETADR' POINTS TO THE FIRST
*   BYTE OF THE RECORD OBTAINED. THE RECORD IS THEN MOVED TO WORK
*   BUFFER FOR PROCESSING. THE ADDRESS OF THE WORK BUFFER IS SAVED
*   IN 'INPUT'.
*
*
*OUTPUT-
*   FILE 1 - SOURCE STATEMENT EDITED TEXT AND ASSOCIATED ERROR RECORDS,
*   AND MACRO DEFINITION EDITED TEXT AND ASSOCIATED ERROR RECORDS.
*
*   FILE 2 - TEXT SEGMENT DICTIONARY FILE FOR EACH MACRO DEFINITION.
*            TEXT SEGMENT DICTIONARY FILE FOR OPEN CODE
*
*   FILE 3 - DEFINITION FILE AND MACRO DEFINITION DIRECTORY
*   (SEE DIRECTORY ROUTINE PROLOG FOR FURTHER DETAILS.)
*
*
*EXTERNAL ROUTINES-
*   DRUTENT - CALLED TO BUILD VARIOUS DIRECTORIES.
*             AT ENTRY. 'DINDEX' (R9) HAS DIRECTORY ROUTINE INDEX.
*             IN THE CASE OF SYMBOL ENTRY.
*                       'PARM' (R10) POINTS TO THE SYMBOL TO BE ENTERED
*                       OR SEARCHED, AND
*                       'PARAM2' (R11) CONTAINS THE MOVE LENGTH OF THE
*                       SYMBOL TO BE ENTERED OR SEARCHED.
*
*              LINKAGE IS...
*              LA    DINDEX,XXX  WHERE XXX IS DIRECTORY ROUTINE INDEX
*              .     .     .     .
*              L     LINK,DENTRY
*              BAL   RETURN,D0(DINDEX,LINK)
*
*   PFIXRI -  CALLED TO INITIALIZE POSTFIXER ROUTINE.
*
*              LINKAGE IS...
*              L     PARAM2,ADPINIT
*              BALR  RETURN,PARAM2
*
*
*   PFIXRN -  CALLED TO PLACE ALL OPERATORS IN AN EXPRESSION INTO
*             APPROPRIATE ARRANGEMENT IN A META TEXT FIELD
*             AT ENTRY, 'PARM' (R10) CONTAINS THE OPERATOR TO BE
*                       ENTERED.
*
*              LINKAGE IS...
*              L     PARAM2,ADPSTR
*              BALR  RETURN,PARAM2
*
*
*EXITS, NORMAL-
*   EXIT TO CONTROLLER WITH ZERO VALUE IN REGISTER 10.
*
*EXITS, ERROR-
*   EXIT TO CONTROLLER WITH NON-ZERO VALUE IN REGISTER 10.
*
*
*TABLE/WORK AREAS-
*   INPUT/OUTPUT BUFFERS ARE DYNAMICALLY LOCATED ABOVE THE EXECUTABLE
*   CODE OF THE EDIT PHASE WITH REGISTER 'RETADR' POINTS TO THE NEXT
*   INPUT RECORD TO BE PROCESSED, OR TO THE NEXT AVAILABLE OUTPUT
*   BUFFER LOCATION AT RETURN FROM INPUT/OUTPUT CONTROL ROUTINE.
*
*   A 264-BYTE INPUT WORK BUFFER, POINTED TO BY ADDRESS CONSTANT
*   'INPUT', CONTAINS THE RECORD TO BE EDITED. THE WORK BUFFER MAY
*   CONTAIN UP TO TWO CONTINUATION CARDS WITH THEIR PRE-BEGIN(POST-END
*   STRINGS STRIPPED AND COLLECTED AT THE TAILEND PORTION OF THE WORK
*   BUFFER. ADDRESS CONSTANT 'DSTGBGN' POINTS TO THE BEGINNING OF THE
*   STRING COLLECTION AREA.
*
*
*ATTRIBUTES-
*   REFRESHABLE
*
*
*NOTES- N/A
*
         SPACE 5
         PRINT OFF                      DON'T PRINT JCOMMON COPY CODE
         COPY JCOMMON
         PRINT OFF                      DON'T PRINT JERMSGCD COPY CODE
         COPY  JERMSGCD
         PRINT ON                       WE'LL PRINT THE REST
         EJECT
         COPY  EDSECT
         EJECT
*************************
*   INPUT WORK BUFFER   *
*************************
INPFMT   DSECT                          ADDRESSED BY REG. 'INPTR'
         USING INPFMT,INPTR
INPNAME  EQU   *                        NAME FIELD
         ORG   INPNAME
INPOP    EQU   *                        OPERATION FIELD
         ORG   INPNAME
INPOPR   EQU   *                        OPERAND FIELD
         ORG   INPNAME
INPCOMM  EQU   *                        COMMENTS FIELD
         ORG   INPNAME
INPCTFLG EQU   *                        CONTINUATION FLAG
POSTEND  EQU   INPCTFLG                 POST-END STRING
         ORG   INPNAME
PREBGN   EQU   *                        PRE-BEGIN STRING
         ORG   INPNAME
INPCNT   EQU   *                        CONTINUATION FIELD
ENDIPT   EQU   PREBGN+79
******************************
*   STRING COLLECTION AREA   *
******************************
STGAREA  DSECT ,                        STRING COLLECTION AREA
         USING STGAREA,DSTGPTR
SCCNT    EQU   *                        STRING COUNT
         ORG   SCCNT
SOPTR    EQU   *                        STRING OUTPUT LOCATION
SOLEN    EQU   SOPTR+1                  STRING LENGTH
SDATA    EQU   SOLEN+1                  STRING
***********************************************
*   RSTACK-RECURSIVE STACK USED BY SCANNERS   *
***********************************************
DRSTK    DSECT
         USING DRSTK,R14
BDRSTK   EQU   *                        RSTACK BEGIN
RSTKRTN  DS    CL2                      RETURN ADDRESS
RSTKATR  DS    X                        ATTRSV SAVED
RSTKFLG  DS    X                        MCALL SAVED
RSTKSTP  DS    CL4                      MTBLNDX SAVED
RSTKVST  EQU   RSTKSTP                  FLGBYT SAVED
EDRSTK   EQU   *
***********************************************
*   CSTK-RECURSIVE STACK USED BY INNER COPY   *
***********************************************
DCSTK    DSECT
         USING DCSTK,PARM
CSTKNOTE DS    CL(L'JNOTEVAL)           NOTED ADDRESS
CSTKSW   DS    C                        SWITCH1 SAVE AREA
CSTKMEM  DS    CL8                      NOTED MEMBER
EDCSTK   EQU   *
***********************************
*   EDITED TEXT RECORD FORMAT 1   *
***********************************
         USING JTEXT,INDEXO
         USING JTEXTA,INDEXP
         PRINT OFF                      DON'T PRINT JTEXT COPY CODE
         COPY JTEXT
         PRINT ON                       DON'T PRINT JTEXT COPY CODE
         SPACE 3
******************************************
*        PARAMETER RECORD FORMATS        *
******************************************
MPROTO   DSECT
         USING MPROTO,INDEXP
HDF      DSW   MPSB,                    SUBOPERAND                     H
               MPSBL,                   LAST SUBOPERAND                H
               MPSBF,                   FIRST SUBOPERAND               H
               OPNDPRM,                 PASSED PARAMETER               H
               OPNDOMT,                 OMITTED OPERAND                H
               OPNDORD,                 ORDINARY SYMBOL                H
               OPNDTRM,                 SELF-DEFINING TERM             H
               OPNDSTR                  CHARCTER STRING
*   HEADER DATA AREA FORMAT
         ORG   HDF                      .
MPHFLG   DS    C                        HEADER DATA FLAG
MPHP     DS    CL4                      VALUE/POINTER AREA
         ORG   MPHP                     .
MPOSRP   DS    CL3                      ORDINARY SYMBOL REF POINTER
         ORG   MPHP                     .
MPSDTV   DS    CL4                      SDT BINARY VALUE
         ORG
MPHDL    EQU   *-MPHFLG                 *****
         SPACE 3
*   META TEXT FORMAT
MPMT     DSECT
         USING MPMT,R14
MPMCFLG  DS    C                        CHAR STG FLAG (SEE JTMFLG)
MPMCLNG  DS    C                        CHAR STG LENGTH
MPMCSTG  EQU   *                        CHAR STRING
         ORG   MPMCFLG                  .
MPVSRP   DS    CL6                      VARIABLE SYM REF PTR ETC
         ORG   MPMCFLG                  .
MPKEYF   DS    C                        KEYWORD PARAM OPERATOR (=)
         ORG   MPMCFLG                  .
MPEMT    DS    C                        STATEMENT TERMINATOR FLAG
         DROP  INDEXP,R14
         SPACE 3
*******************************
*   META TEXT FIELD FORMATS   *
*******************************
         COPY  JTMTXT
         EJECT
         COPY  JERRCD
JERRHL   EQU   JEDATA-JERECL
STACKREC DSECT
LAST     DS    0H                       LAST STACK ENTRY
LASTOP   DS    C                        OPERATOR
LASTBIND DS    C                        BINDING FACTOR
         EJECT
**********************
*   SYMBOL EQUATES   *
**********************
*
BASE1    EQU   8                        PRIMARY BASE REGISTER
BASE2    EQU   7                        SECONDARY BASE REGISTER
BASE3    EQU   7                        THIRD BASE REGISTER
BASE4    EQU   7
COMR     EQU   13                       COMMON AREA BASE REGISTER
MODCOMM  EQU   2                        MODULE COMMON AREA BASE
TRTN     EQU   0                        SCRATCH REGISTER
RCNT     EQU   0
STGLOC   EQU   TRTN                     STRING LOCATION CONVEYER
TLINK    EQU   1                        LOCAL LINKAGE
CGOTO    EQU   1                        GO-TO REGISTER
WORK2    EQU   3
GSPTR    EQU   3
SLNREG   EQU   3                        SOURCE LENGTH REGISTER
BEGREG   EQU   4                        BEGIN COLUMN REGISTER
INDEXP   EQU   4                        VARIABLE PORTION O/P BUF INDEX
INDEXO   EQU   5                        FIXED PORTION O/P BUF INDEX
CNTREG   EQU   5                        CONTINUATION CHAR. COLUMN REG.
INPTR    EQU   6                        INPUT WORK BUFFER POINTER
RETURN   EQU   9                        RETURN LINKAGE REGISTER
DSTGPTR  EQU   9                        DESTINATION POINTER
SEQREG   EQU   9                        SEQ FIELD BEGIN REGISTER
DINDEX   EQU   9                        INDEX REG FOR D ENTRY ROUTINE
PARAM1   EQU   10                       PARAMETER REGISTER
PARM     EQU   PARAM1                   INDEX TO DIRECOTY ROUTINES
SQLREG   EQU   10                       SEQ FIELD LENGTH REGISTER
SRCPTR   EQU   10                       SOURCE RECORD POINTER
PARAM2   EQU   11                       PARAMETER REGISTER
RETADR   EQU   PARAM2                   TEMPORARY RETURN LINKAGE
LINK     EQU   12                       TARGET LINKAGE REGISTER
CBGREG   EQU   12                       CONT FIELD BEGIN REGISTER
SRCEND   EQU   12                       SOURCE RECORD END POS. CONVEYER
TWKREG1  EQU   14
TWKREG2  EQU   15
MTBLNDX  EQU   5                        MTABLE INDEX REGISTER
MTBLENT  EQU   12                       ABSOLUTE ROUTINE ADDRESS PTR
*
ALLOFF   EQU   X'00'
LBITS    EQU   JF                       LENGTH BITS MASK
BNE      EQU   7
BHI      EQU   2
BLO      EQU   4
BZ       EQU   8
BEQ      EQU   8
BMX      EQU   4
BONE     EQU   1
LICTL    EQU   66
SEVENTY  EQU   70
CRDLN    EQU   80                       SOURCE RECORD LENGTH
SLTLEN   EQU   3
INVALV   EQU   31
SPECHAR  EQU   JTBLTRT+JALFAMAX+1       SPECIAL CHARACTER START
JTBLALFA EQU   JTBLTRT+JA
HICHR    EQU   JPERIOD                  HIGHEST ASSEMBLER CHARACTER
XSDT     EQU   JTMSDT+0                 X TYPE SDT TYPE NUMBER
BSDT     EQU   JTMSDT+1                 B TYPE SDT TYPE NUMBER
CSDT     EQU   JTMSDT+2                 C TYPE SDT TYPE NUMBER
DSDT     EQU   JTMSDT+3                 D TYPE SDT TYPE NUMBER
DENTLNG  EQU   6                        MT TERM/POINTER LENGTH
STMASK   EQU   X'C0'                    MCALL STAUS MASK
DMCHIN   EQU   X'40'                    IOCID MASK FOR V.S.OP OCDE
XDMSLS   EQU   VTYP2+VSLS+VSNS          MASK FOR UNSUBSCRIPTED SYSLIST
RFLGLOC  EQU   (EDRSTK-BDRSTK)*2        INDEX TO 2ND LEVEL IN RSTACK
MISTGL   EQU   30                       MI STRING LENGTH  (STANDARD)
STSTGL   EQU   71                       ST STRING LENGTH  (STANDARD)
MISTGP   EQU   5+1                      MI STG POINTER LENGTH
STSTGP   EQU   5*3+1                    ST STG POINTER LENGTH
MAXCNTL  EQU   79                       1ST CARD MAX DATA AREA W/ CONT.
MAXCNT   EQU   255
PRMLEN   EQU   3                        PARAMETER POINTER LENGTH
MTHDLEN  EQU   9                        MT HEADER DATA LENGTH
SZMI     EQU   562                      MI/PROTO SIZE **TEMP**
SZCNT    EQU   784                      STATEMENT W/ CONTIN    @AY11229
SZNORM   EQU   296                      STATEMENT W/O CONTINUATIONS
SZCMT    EQU   116                      COMMENTS STATEMENT SIZE
TSRCLN2  EQU   TSRCLN+2                 TRUE SSOURCE DATA LENGTH
TCNTLN2  EQU   TCNTLN+2                 TRUE CONTINUATION DATA LENGTH
RTNSV1   EQU   OCPTRSV                  RETURN POINTER SAVE AREA
RLAST    EQU   R15
HIBIND   EQU   13                       UNLUCKY 13
         EJECT
*******************************
*   DIRECTORY ROUTINE INDEX   *
*******************************
PHASENT  EQU   0
MACRENT  EQU   2
MACREND  EQU   4
OPENENT  EQU   6
OPENEND  EQU   8
VARBSYMR EQU   10
SEQSYMBR EQU   12
SEQSYMBD EQU   14
ORDSYMBR EQU   16
ORDSYMBD EQU   18
VARBSYMD EQU   20
OPERCODE EQU   22
OPSYNBLD EQU   24
         USING JTEXTA,INDEXP
         USING DRSTK,R14
         EJECT
         JCSECT (X1A00=CS0)
* VS1 RELEASE 2 CHANGES
*A883100-883120                                                 OX00217
* VS1 RELEASE 2.6 CHANGES
*C173100                                                        OX00224
*A457500                                                        OX00224
*A843900-843920                                                 OX00225
*C891200                                                        OX00225
*A301970-301994                                                 OX00403
*C302000                                                        OX00403
*C333400                                                        OX00404
*A674500                                                        OX00405
*A345900-345920,500100                                          OX00406
*D521600                                                        OX00406
*A847300                                                        OX00409
*C274800                                                        OX00410
*A457520-457540,459700-459740                                   OX00411
*D737600                                                        OX00081
*A741900                                                        OX00081
* VS1 RELEASE 3 CHANGES
*A169700                                                        OX00095
*D170600                                                        OX00095
*C978500                                                        OX00095
*A978700-978760,979920                                          OX00095
* VS1 RELEASE 3.1 CHANGES
*D872600                                                        OX01771
*A835100,868900,872500-872700,875700-875760                     OX01771
*A644924                                                        OY01713
*D644960                                                        OY01713
*A131500-131560                                                 OX02266
*D847300                                                        OX02973
*A848300                                                        OX02973
*A334700-334740                                                 OX02957
*A142220-142260                                                 OX02976
*A128900-128980                                                 OX04102
*D131500-131560                                                 OX04102
*A866300,868500,868820,868920,876260-876796                     OX04106
*C876800                                                        OX04106
*D875800-876600                                                 OX04106
*C458400,558400,558600                                          OX05801
*A459620,558500,558520                                          OX05801
*A335100-335180                                                 OY04852
*C453800                                                        OY06129
*D335100-335180                                                 OY06129
*A453700,453720                                                 OY06129
* VS1 RELEASE 040 CHANGES
*A993620                                                       @XA04142
*A676925,676926                                                @XA05837
*A843300-843340,843820                                         @OZ01697
*A461920-461980,173150,173820-173996                           @OX06626
*C458800,460200,558400,558600                                  @OX06626
*D558500-558520                                                @OX06626
*A093700,174900                                                @OX07247
*A075700,076300,076900,077300,263900,266700,646100-646160      @OX07230
*A423100-423188                                                @OY04864
*A423700                                                       @OX07300
*C423800                                                       @OX07300
*A088500-088540                                                @OY08021
*A301954-301968                                                @OX08858
*D301970                                                       @OX08858
*A098500,299540                                                @OY08060
*A806500-806560                                                @OX07290
*A093620,093640,093720                                         @OX01364
*A829700,831900,826600,827300-827360,975685,975687             @OZ06551
*C827400,976586                                                @OZ06551
*A335100                                                       @OX10953
*D142000                                                       @AX11012
*A141820                                                       @AX11012
*C827300,975686,826050,827340,827360                           @AX12896
*A827220                                                       @AX12896
*D826700                                                       @AX12896
*C063000                                                       @AY11229
*A911620-911755,903900-903980                                  @AY11215
*C674600                                                       @AX12923
*A093660,093680                                                @AZ10910
*A071700                                                       @AY14007
*A122900                                                       @AX16038
*A559100-559140,558900,129220,879900                           @AZ13722
*C558400,558600                                                @AZ13722
*A826070,826104,826108,827240,827260                           @AY14037
*C827200,827220                                                @AY14037
*A421700,421720                                                @AX16943
*D088500-088520                                                @AY16252
*A173200                                                       @AY16256
*C173500                                                       @AY16256
*C826104                                                       @AZ19665
*A826110,826113                                                @AZ19665
*A301910                                                       @AY19080
*D838660,838720                                                @AZ24557
*C911620,911705                                                @AZ24557
*A911900-911930                                                @AZ24557
*C173820,173900,173960,173984                                  @AZ26008
*A173981                                                       @AZ26008
*C828600                                                       @AX19887
*A828700-828740                                                @AX19887
         JMODID
         SPACE 3
****************************
*   PHASE INITIALIZATION   *
****************************
EDITENT  JSAVE  BASE=NO
         JENTRY (X1A01=EDITENT)
         BALR  BASE2,D0                 SET BASE VALUE
         USING *,BASE2
         LA    PARAM1,(ENDEDSCT-EDSCTGO+7)/8 GET EDSECT SIZE
         JGETCORE DBL=(R10)             GET CORE FOR MOD COMMON AREA
         LR    MODCOMM,PARAM1           SET UP MOD COMMON AREA BASE
         XC    VSFLG(SEQSVT+40-VSFLG),VSFLG  CLEAR EDSECT CONSTANTS
         XC    EDSCTGO(BITFF),EDSCTGO
         MVC   TBGLN(L'TBGLN*6),STDPARM
         XC    PARML,PARML              INITT AREA WITH ZEROS  @AY14007
         LA    TWKREG1,RSTACK-(EDRSTK-BDRSTK)
         ST    TWKREG1,RAVSP            POINTER
         LA    TWKREG1,CSTK             CSTK POINTERS INITIALIZATION
         ST    TWKREG1,NRSTK
         ST    TWKREG1,BCSTK
         ST    TWKREG1,CSTKADR
         LA    TWKREG1,CSTKX
         ST    TWKREG1,NCSTK
         XC    ERRCNT(D5),ERRCNT
         LA    TWKREG1,ERRSTK           INITIALIZE ERROR MSG
         ST    TWKREG1,AERRSTK          STACK ADDRESS AND
         ST    TWKREG1,ESTKNDX          INDEX
         MVC   DNTERR(ENDDNTL),SEVERR   INIT DSECT TO LOG ERRORS
         MVI   DERRCD,D0                INITIALIZE ERROR CODE TO ZERO
*
         JGETCORE DBL=63
         ST    PARAM1,DSTGBGN           SET STRING AREA POINTER
         LA    TWKREG1,MISTGL(,PARAM1)  GET STRING AREA LENGTH
         ST    TWKREG1,MINPUT           COMPUTEMI DATA POINTER
         ST    TWKREG1,MINPSTD          AND SAVE
         ST    TWKREG1,MINPADJ          SAVE FOR ICTL          @OX07230
         LA    TWKREG2,STSTGL(,PARAM1)  COMPUTE OTHER DATA POINTER
         ST    TWKREG2,INPUT            AND
         ST    TWKREG2,STNPSTD              SAVE
         ST    TWKREG2,STNPADJ          SAVE FOR ICTL          @OX07230
         SR    TWKREG2,TWKREG1          COMPUTE DIFFERENCE
         STH   TWKREG2,MINDIF           BETWEEN MINPUT AND INPUT
         STH   TWKREG2,SVMINDIF         SAVE STANDARD BUFF DIF
         STH   TWKREG2,MINDFADJ         SAVE FOR ICTL          @OX07230
         LA    PARAM2,D0(PARAM1,PARAM2)
         ST    PARAM2,SVENDWKA          SAVE STANDARD WORK AREA END
         ST    PARAM2,ENDWKADJ          SAVE FOR ICTL          @OX07230
         ST    PARAM2,ENDWKA            END OF DATA AREA PLUS 1
         XC    JTBLTRT(L'JTBLTRT),JTBLTRT ZERO OUT TRT TABLE
         LM    BASE2,BASE1,USEBAS
         USING SETBAS,BASE1
SETBAS   EQU   *
         JEXTRN (X1J01=DRUTENT)
         LA    RLAST,STACK              GET ADDR OF OPERATOR STACK
         ST    RLAST,SVLAST             AND SAVE IN MOVEABLE POINTER
         ST    RLAST,ALAST              AND ALSO AS STOPPER
         USING STACKREC,RLAST
         MVI   LASTOP,JTMSTRM           PUT EXPRESSION TERMINATOR WITH
         MVI   LASTBIND,HIBIND          BINDING FACTOR INTO STACK
         DROP  RLAST
         SET   SFSTCD,ON                INDICATE FIRST CARD
         SET   SPGRMD,ON                INDICATE PROC'G PRG'R MACRO
         B     READNEXT                 GO TO READ NEXT STATEMENT
         USING IFNX1A30,BASE4
SEVERR   EQU   *                        MOVED TO COMMON FOR X1J ERRORS
         BAL   TLINK,NSNAPERR           LOG ERROR WITH SNAP SHOT
         DC    AL2(2)                   PADDING TO CALCULATE RETURN
         DC    AL1(SEV0)                SEVERITY CODE
         DC    AL1(ERR0)                ERROR CODE
         BR    RETURN                   RETURN TO CALLER
         USING CS2,BASE2
USEBAS   DC    A(CS2,SETBAS)
STDPARM  DC    A(0,71,56,0-1,8)         STANDARD ICTL PARAMS
F70      DC    A(70)                    COLUMN 71 DISPLACEMENT
         EJECT
***********************************************************************
*   READNEXT ROUTINE IS ENTERED EACH TIME A NEW STATEMENT IS TO BE
*   READ. ITS FUNCTION IS TO PROVIDE A LINKAGE TO INPUT CONTROL
*   ROUTINE.
***********************************************************************
READNEXT L     LINK,ARDSRC              POINT TO RDSRC
         BALR  RETURN,LINK              LINK TO READ SOURCE ROUTINE
         DC    AL2(RFSTCRD-RFSTCRD)     READ FIRST CARD OF STATEMENT
         SET  SMISCN,OFF     RESET NO V.T. OUTPUT SWITCH
         GOIF  SINEOF,OFF=PROCIN        PROCEED IF NOT END OF FILE
         GOIF  SFSTCD,OFF=EOFRTN
NODATA   EQU   *
         MVI   DDNDX1,PHASENT           SET UP INDEX FOR BR TO DIR RTN
         BAL   R3,DIR10                 ISSUE MESSAGES
         L     BASE4,CS4ADDR            CHANGE BASE FOR CSECT 4
         L     LINK,APGRMAC             GET ADDR OF PGRMAC
         BR    LINK                     BR TO CLOSE FILES
PROCIN0  XC    JTRLI,JTRLI              CANCEL REC W/NO V.T.
PROCIN   EQU   *
         BAL   RETURN,PUTLSIZ           GET O/P BUFFER
         BAL   RETURN,HDINIT            INITIALIZE HEADER
         GOIF SMISCN,ON=PNXT12         GO PUT OUT PR ONLY RECORD
         EJECT
***********************************************************************
*   PROCNXT ROUTINE IS ENTERED EACH TIME A NEW STATEMENT IN THE
*   INPUT WORK BUFFER IS TO BE EDITED. IT CALLS GSCAN TO EDIT NAME
*   AND OPERATION FIELDS INTO OUTPUT BUFFER. IT THEN FANS OUT TO
*   OPERAND PROCESSORS BASED ON THE TYPES OF OPERATION CODE.
*   (THERE ARE THREE DISTINCTIVE GROUPINGS OF OPERATION CODES. THEY
*   ARE PROTOTYPE, MACRO INSTRUCTIONS, AND MACHINE/ASSEMBLER OPERATION
*   CODES.) COMMENTS STATEMENTS ARE EDITED AS COMMENTS FIELD IN
*   ASSEMBLER OP STATEMENTS.
***********************************************************************
         SPACE 3
PROCNXT  EQU   *
PROCN01  EQU   *                                               @OY08021
         CLI   INPNAME,JBLANK           TEST IF THERE IS NAME FIELD
         BNE   PROCN10                  YES, THERE IS A NAME
PROCN02  EQU   *
         BAL   TLINK,SKPBLK             GO FIND OP CODE
         GOIF  SFSTCD,OFF=PNXT299       BR IF NOT FIRST CARD
PROCN05  EQU   *
         GOIF  SNOFND,ON=NOICTL         BR IF OP CODE NOT FOUND
         CLC   D0(L'ICTLX,INPTR),ICTLX  TEST IF ICTL STATEMENT
         BNE   NOICTL                   BRANCH IF NOT ICTL
         GOIF  SNMFND,OFF=PROCN07       PROC ICTL IF NO NAME
         BAL   RETURN,NAMERR            NAME DISALLOWED ON ICTL
         B     PROCN07                  CONT TO PROCESS ICTL OPERAND
NOICTL   GOIF  SNMFND,ON=PNXT299        BR IF OP CODE NOT ICTL ON 1ST
         B     PNXT29                   NO NAME ON FIRST CARD, NON-ICTL
PROCN07  EQU   *
         LA    INPTR,L'ICTLX(,INPTR)    BUMP OVER ICTL
         ST    INPTR,FPTRSV             DUMMY UP SCAN RESULTS
         ST    INDEXP,OFPTRSV
         MVI   IOCID,IOCTYP+BIT1
         MVI   OCSAVE,JTICTL
         SET   JPSOP,ON
         SET   SICTL,ON                 INDICATE ICTL STATEMENT
         B     TBLOPS                   GO PROCESS OPERAND
ICTLX    DS    0CL5
         DC    AL1(JI,JC,JT,JL,JBLANK)  INTERNAL ICTL OP
         DS    0H
PROCN10  EQU   *
         CLI   INPNAME,JASTER           COMMENTS QUERY         @OX10364
         BE    PROCN15                  BR IF COMMENT CARD     @OX10364
         CLC   DOTSTAR,INPNAME          HIDENT COMMENT QUERY   @AZ10910
         BE    PROCN15                  BR IF SO               @AZ10910
         GOIF  SXMCRO,ON=SSEQ46         BR IF ERR IFO085       @OX07247
PROCN15  EQU   *                                               @OX10364
         GOIF  SFSTCD,OFF=PROCN20
         MVI   DDNDX1,PHASENT           SET UP INDEX FOR BR TO DIR RTN
         BAL   R3,DIR10                 INITIALIZE DIRECTORIES
PROCN20  EQU   *
         CLI   INPNAME,JASTER           COULD IT BE COMMENTS STMT
         BE    PNXT11                   BRANCH IF YES
         CLC   INPNAME(L'DOTSTAR),DOTSTAR
         BNE   PNXT20                   BRANCH IF NOT COMMENTS AT ALL
         EJECT
*****************************************
*        EDIT COMMENTS STATEMENT        *
*****************************************
PNXT10   EQU   *
         MVI   OCSAVE,JTHCMNT           VIRTUAL TEXT SUPPRESSION CTRL
         SET   SDTCMT,ON                INDICATE '.*' TYPE COMMENTS
         B     PNXT13                   BYPASS NEXT
PNXT12   SET   SMISCN,OFF               RESET NO V.T. OUTPUT SWITCH
PNXT11   SET   STRCMT,ON                INDICATE '*' TYPE COMMENTS
         MVI   OCSAVE,JTCMNT            VIRTUAL TEXT SUPPRESSION CTRL
PNXT13   EQU   *
         L     INPTR,ENDATA
         L     LINK,ARDSRC05            POINT TO RDSRC05
         BALR  RETURN,LINK              READ ALL CONTINUATIONS
         DC    AL2(RALLCNT-RFSTCRD)     READ ALL VALID CONTINUATIONS
         L     INPTR,INPUT
PNXT15   EQU   *                                               @OY08060
         MVC   JTFLGA(D4),PUTFLG        INSERT COMMENTS FLAGS AND IOC
         GOIF  SXPRTO,ON=BADPRTO        LOG ERROR IF EXPECTING PROTO
         CLI   OCSAVE,JTHCMNT           TEST IF .* TYPE COMMENT
         BNE   WRAPFLD                  BRANCH IF NOT
         MVI   JTIOP1,JTHCMNT           INDICATE HIDDEN COMMENTS
         SET   JPRONLY,OFF              .* TYPE CMNT, RESET PRINT ONLY
         GOIF  SMDEF,ON=WRAPFLD         .* TYPE MUST BE IN MACRO DEF
         BAL   TLINK,ABSERR             '.*'-TYPE COMMENTS ARE
         DC    AL1(6*16+SEV17)          DISALLOWED IN OPEN CODE
         DC    AL1(ERR17)               LOG ERR AND STOP EDIT ON STMT
         EJECT
PNXT20   EQU   *
         SET   SNMFND,ON                INDICATE NAME FOUND
         SET   SENAME,ON
         SET   SKPNAME,ON               INDICATE SKIPPING NAME FIELD
         BAL   RETURN,GSCAN             SKIP NAME FIELD
         SET   SKPNAME,OFF
         SET   SENAME,OFF
         B     PROCN02                  1ST CD HAS NAME, CK IF ICTL
         SPACE 3
PNXT29   EQU   *
         MVI   DDNDX1,PHASENT           SET UP INDEX FOR BR TO DIR RTN
         BAL   R3,DIR10                 INITIALIZE DIRECTORIES
         SPACE 3
PNXT299  EQU   *
         CLI   INPOP,JAMPER             IS OP CODE FIELD A V. S.
         BNE   PNXT30                   BR IF NOT VARIABLE SYMBOL
         GOIF  SPGRMD,OFF=PNXT30        BR IF NOT IN PRGR MACS
         GOIF  SMDEF,ON=PNXT30          BR IF IN MACRO DEF
         MVI   DDNDX1,OPENENT           SET TO INITIALIZE OPEN CODE
         BAL   R3,DIR10                 GO DO IT
         SET   (SPGRMD,SOPNCD),FLIP     OUT OF PRGMR MACS, NOW OPEN CD
         EJECT
*****************************************
*        PROCESS OPERATION FIELD        *
*****************************************
PNXT30   EQU   *
         SET   SEOPCD,ON                INDICATE EDITING OP CODE
         GOIF  SNOFND,ON=NOPCD          OP FIELD NOT FOUND, LOG ERROR
         BAL   RETURN,GSCAN             SCAN OPERATION FIELD
         LCR   TWKREG1,INDEXO           GET OUTPUT ABSOLUTE ADDRESS
         A     TWKREG1,OFPTRSV          COMPUTE RELATIVE ADDRESS
         STH   TWKREG1,JTOCP            INSERT OP CODE FIELD REL ADDR
         ST    INPTR,OPNDPTR            REMEMBER WHERE TO COME BACK
         C     R1,ENDATA                OP CODE MUST BE FOLLOWED BY BLK
         BNL   INVOP                    BR FOR ERROR IF NOT
         GOIF  (ROSYM,RVSYM),NONE=INVOP LOG ERROR IF INVALID
         GOIF  RVSYM,ON=PUTOC10         BRANCH IF OP CODE A V.S.
         TM    DERRCD,BITFF             TEST IF ERROR FOUND IN D RTN
         BZ    PUTOC20                  BRANCH IF NOT
         MVI   OCSAVE,INVALV            ELSE, DUMMY UP INTERNAL OP
         SET   JPRONLY,ON               AND INDICATE PRINTONLY
         B     PUTOC40                  EDIT AS MACHINE OP
PUTOC10  EQU   *
         MVI   IOCID,DMCHIN             DUMMY UP OP CODE ID AND
         B     PUTOC40                  EDIT AS MACHINE OP
PUTOC20  EQU   *
         TM    IOCID,BIT0+BIT1          TEST IF MACRO CALL/PROTO
         BNZ   PUTOC25                  BRANCH IF NOT
         SET   PROTOCAL,ON              ELSE, SO INDICATE
         B     PUTOC40                  AND BRANCH
PUTOC25  EQU   *
         L     PARAM2,OCPTRSV           RESTORE IOC POINTER
         MVC   JTFLGA,D0(PARAM2)        INSERT FLAGA BYTE FOR OP CODE
         IC    PARM,D1(,PARAM2)         PICK UP OP CODE BYTE ONE
         SLL   PARM,D8                  SHIFT TO 3RD BYTE IN PARM
         BM    PUTOC30                  BRANCH IF 1 BYTE OPCODE
         IC    PARM,D2(,PARAM2)         PICK UP OP CODE BYTE TWO
PUTOC30  EQU   *
PUTOC35  EQU   *
         STH   PARM,JTIOP               INSERT INTO E.T.
         GOIF  SXPRTO,OFF=PUTOC40       CAN'T BE PROTOTYPE IF HERE
         L     INPTR,INPUT              BACK UP TO BEGINNING OF FIELD
         BAL   RETURN,RESETPTR          RESET TEXT POINTERS
         B     BDPTO                    NOW, GO LOG ERROR
PUTOC40  EQU   *
         SET   SEOPCD,OFF
         GOIF  SNMFND,ON=PNAME          EDIT NAME IF FOUND ONE
         MVI   GSUMRY,D0                ZERO OUT OP CODE FLAGS
         B     TBLOPS                   ELSE, EDIT OPERAND
         EJECT
************************************
*        PROCESS NAME FIELD        *
************************************
PNAME    EQU   *
         L     INPTR,INPUT              BACK TO EDIT NAME FIELD
         GOIF  (SKPMND,SKPEND),ANY=PNAME1    BYPASS NAME PROC ON ABORT
         SET   SENAME,ON                INDICATE EDITING NAME FIELD
         BAL   RETURN,GSCAN             YES, SCAN NAME FIELD
         ST    R15,NAML1                SAVE NAME FIELD LENGTH
         MVC   VSTAT(L'FLGBYT),FLGBYT   SAVE NAME FIELD V.S. STATUS
         LCR   TWKREG1,INDEXO           COMPUTE NAME FIELD POINTER
         A     TWKREG1,OFPTRSV
         STH   TWKREG1,JTNMP            AND ENTER IT
         MVC   NAMBYT,GSUMRY            SAVE NAME STATUS IN CASE SS
         L     INPTR,OPNDPTR            RESTORE OPERAND POINTER
PNAME1   EQU   *
         ST    INPTR,FPTRSV             AND SAVE
         SET   SENAME,OFF
         B     TBLOPS                   GO EDIT OPERAND FIELD
         EJECT
***********************************************************************
*   MACINST ROUTINE IS ENTERED WHEN A 'MACRO INSTRUCTION' OR A PROTO-
*   TYPE STATEMENT IS ENCOUNTERED. (ANY OP CODE THAT CAN NOT BE FOUND
*   IN THE OP CODE TABLE IS ASSUMED A 'MACRO INSTRUCTION'.) THIS
*   ROUTINE IS ALSO CALLED BY THE PROTOTYPE SCANNER TO PROCESS KEYWORD
*   PARAMETER WITH A NORMAL VALUE. IT MAKES SYNTACTICAL SCANNING OF
*   OPERAND FIELDS, BUILDS EDITED TEXT RECORDS, OBTAINS THE NOTE/POINT
*   DATA OF THE ASSOCIATED MACRO DEFINITION EDITED TEXT, MAKES MACRO
*   NAME ENTRIES INTO MACRO NAME TABLE IS NOT PREVIOUSLY ENTERED,
*   AND MAKES OPERAND ENTRIES INTO ORDINARY SYMBOL REFERENCE DIRECTORY.
***********************************************************************
         SPACE 3
MACINST  EQU   *
         SET   SEOPCD,OFF
         SET   SEOPND,ON
         MVI   GSUMRY,D0                ZERO OUT OP CODE FLAGS
         BAL   RETURN,STMTDSQ           STATEMENT SEQUENCING
         SET   JPSOP,ON                 INDICATE ASSEMBLER OP
         LA    R0,D1                    SET COLCTR AND CRDCTR
         ST    R0,COLCTR                TO 0 AND 1 RESPECTIVELY
         MVC   DTLENG(L'DTLENG),TSRCLN2 SET DATA LENGTH
         XC    PRNLVL,PRNLVL            RESET PAREN LEVEL COUNT TO ZERO
         MVI   SWITCH6,D0               RESET SWITCHES
         L     LINK,AMIPRTO             GET LINKAGE
         BALR  RETURN,LINK              EDIT PROTO/M CALL
         SET   SMI,OFF                  SET OFF MI SWITCH
         SET   SEOPND,OFF
         SET   SMISCN,OFF               RESET NO V.T. SW.      @AX16038
         NI    JHWORD2+1,BITFF-(DMIENT) RESET SECOND DMIENT SW @AZ13722
         B     WRAPCNT                  THEN EXIT
AMIPRTO  DC    A(MIPRTOIN)              ADDRESS OF MIPRTOIN
H1       DC    H'1'                     .
H2       DC    H'2'                     .
H3       DC    H'3'                     .
H6       DC    H'6'                     .
         DS    0F
F7       DC    H'0'                     .
H7       DC    H'7'                     .
H63      DC    H'63'                    STD DBLE-WORD SIZE OF WORK AREA
H8       DC    H'8'                     .
H10      DC    H'10'                    .
H255     DC    H'255'                   .
         EJECT
***********************************************************************
*   WRAPFLD ROUTINE IS ENTERED TO WRAP UP THE EDITING OF A STATEMENT
*   OR OPERAND WHEN END OF STATEMENT OR OPERAND IS REACHED. IT EDITS
*   COMMENTS FIELD, COMPUTES EDITED TEXT RECORD LENGTH, AND, IF NOT
*   SUPPRESSED, MAKES THE REMAINING DIRECTORY ENTRIES.
*   CARDS, WITHIN A STATEMENT THAT ARE TO BE FLUSHED ARE FLUSHED, AND
*   ERROR RECORD BUILT FOR THE STATEMENT IS OUTPUT.
***********************************************************************
         SPACE 3
WPOPND   EQU   *
         MVI   D0(INDEXP),JBLANK        INSERT A BLANK FOR ASS SCANNER
         LA    INDEXP,D1(,INDEXP)       WHICH IS NOT INCLUDED IN THE   X
                                        LENGTH COUNT IN JTOCP
WRAPFLD  EQU   *
         L     RCNT,INPUT               BEGIN OF FIELD
WRAPF1   EQU   *
         TM    SWITCH4,(SPGRMD+SOPNCD)  IF PGMMAC OR OPEN CODE  OX04102
         BZ    EDTSTG1                  IF NOT- BRANCH          OX04102
         GOIF  SINCPY,ON=EDTSTG1        FLAG IS OFF THEN CHK    OX04102
         SET   JPRGICTL,ON              FOR COPY. USE PGM ICTL  OX04102
EDTSTG1  EQU   *                                                OX04102
         BAL   TLINK,SKPBLK             GO FIND COMMENTS FIELD
         GOIF  SNOFND,ON=EDTSTG         NO COMMENTS
         ST    INPTR,FPTRSV             SAVE INPTR
EDTCMT   EQU   *                        COMMENTS FIELD FOUND
         L     TWKREG2,ENDATA           UPPER LIMIT OF SCAN
EDTCMT1  EQU   *
         BCTR  TWKREG2,0                ELIMINATE BLANKS FROM LAST COL.
         CLI   D0(TWKREG2),JBLANK       TO FIND END OF COMMENTS FIELD
         BE    EDTCMT1                  LOOP TO END OF COMMENTS
         LA    INPTR,D1(,TWKREG2)       SIMULATE SCAN RESULTS
         LCR   TWKREG1,INDEXO           COMPUTE RELATIVE ADDRESS OF
         AR    TWKREG1,INDEXP           COMMENTS FIELD IN TEXT
         STH   TWKREG1,JTCPR            STORE IN COMMENTS POINTER
         ST    BASE2,JFWORD2            SAVE CS3 BASE
         L     BASE2,USEBAS             LOAD CS2 BASE
         BAL   R12,VTPUT                EDIT COMMENTS FIELD
         L     BASE2,JFWORD2            RESTORE PREVIOUS BASE
EDTSTG   EQU   *
         L     GSPTR,DSTGBGN            POINT TO BEGIN OF STRING AREA
         CLI   D0(GSPTR),D0             TEST IF NO STRING
         BE    EDTLEN                   BRANCH IF NO STRING
         LCR   TWKREG1,INDEXO           COMPUTE RELATIVE ADDRESS OF
         AR    TWKREG1,INDEXP           STRING FIELD
         STH   TWKREG1,JTSPR            AND ENTER IT IN E.T.
         L     DSTGPTR,DSTGNDX          POINT TO END OF STRING AREA
         MVI   SCCNT,D0                 INDICATE END OF STRING
         SR    DSTGPTR,GSPTR            COMPUTE STRING AREA MOVE LENGTH
         BCTR  INDEXP,0                 BACK UP JTEXTA PTR
         EX    DSTGPTR,ETMOV            MOVE STRING TO TEXT
         LA    INDEXP,D2(DSTGPTR,INDEXP) BUMP POINTER
*
EDTLEN   EQU   *
         LR    TWKREG1,INDEXP           COMPUTE O/P TEXT LENGTH
         SR    TWKREG1,INDEXO
         STH   TWKREG1,JTRLI            STORE TRUE LENGTH IN TEXT
*        TO MAKE DEFINITION DIRECTORY ENTRY
         CLI   SDENTR,D0                TEST IF TO MAKE DIR ENTRY
         BE    EDTLEN3                  NO
         GOIF SMISCN,OFF=EDTLEN2        GO PUT OUT DIR ENTRY
         CLI   ERRCNT1,D0               NO V.T. TO BE OUTPUTTED SO
         BNE   WRRTN                     IF ERRORS, THEN NO DIR ENTRY
EDTLEN2  EQU   *
         MVC   DDNDX1(D1),SDENTR        EST INDEX FOR BR INTO DIR RTN
         LM    PARM,PARAM2,NAMP         GET POINTERS
         BAL   R3,DIRENT                MAKE D ENTRY
         MVI   SDENTR,D0                SET OFF DEFINITION D-ENTRY SW
EDTLEN3  CLI   SDENTR1,D0               CHECK IF WXTRN/EXTRN OPERAND
         BE    WRRTN                    NO, THEN NO DIR ENTRY REQ
         MVC   DDNDX1(D1),SDENTR1       GET DIR ENTRY INDEX
         L     PARM,NAMP1               GET PTR TO OPERAND
         BAL   R3,DIRENT                GO MAKE O/SYMBOL DEFINITION
         MVI   SDENTR1,D0               CLEAR DIR INDEX BYTE
*
WRRTN    EQU   *
         GOIF  SCTLRTN,ON=WRETURN       RETURN IF SO INDICATED
*
*
WRAPCNT  EQU   *
         BAL   RETURN,WRAPERR           WRITE ERROR RECORD
         GOIF  SPRVCT,OFF=WREXIT        EXIT IF NO MORE CONT'N CARDS
         GOIF  SINEOF,ON=UNXPEOF        LOG ERROR IF END OF FILE
         LA    R11,SZCMT                GET BUFFER SIZE
         BAL   RETURN,OPUTL             GET O/P BUFFER
         L     LINK,ARDSRC              POINT TO RDSRC
         BALR  RETURN,LINK              BYPASS ALL CONTINUATION CARDS
         DC    AL2(RBYPCNT-RFSTCRD)     BYPASS ONE CONTINUATION CARD
         GOIF  SINEOF,ON=UNXPEOF        LOG ERROR IF END OF FILE
         MVC   JTRLI(L'FXDHD),FXDHD     MOVE IN FIXED HEAD
         LA    INDEXP,D2(,INDEXP)       AND POINT OVER DUMMY FIELD
         SET   JNOCNT,ON                DO NOT ASSIGN STATEMENT NUMBER
         B     WRAPFLD                  GO PROCESS CONTINUED STATEMENT
*
WRAPERR  EQU   *
         CLI   ERRCNT1,D0               TEST IF THERE ARE ERRORS
         BCR   BEQ,RETURN               RETURN IF NO
         L     INDEXO,OUTADR            SET BASE               @AX11012
         GOIF SMISCN,ON=PROCIN0         PR ONLY RECORD TO BE FORCED
         SET   JERR,ON                  ELSE, INDIACTE MSG FOLLOWS
         CLI   JTIOP,JTEND              CHECK FOR GEN END       OX02976
         BNE   WRAPERR1                                         OX02976
         SET   (JDEF,JREF),ON                                   OX02976
WRAPERR1 EQU   *
         ST    RETURN,EDTSVZ
         L     R4,AERRSTK               SET ADDRESSABILITY
         ST    R4,ESTKNDX               RESET INDEX
         USING ERRMESS,R4
         LH    R3,ERRCNT
WERRLP   SR    R5,R5
         IC    R5,ENTRYLNG              PICK UP ENTRY LENGTH
         LA    R11,JERRHL(R5)           COMPUTE LENGTH
         JPUTL FILE=FILE1,BUFREQ=(R11)  GET O/P BUFFER
         USING JERRCD,R11
         MVC   JEFLGA(L'ERRHDR),ERRHDR  MOVE HEADER
         LA    R10,JERRHL(,R5)          COMPUTE RECORD LENGTH
         STH   R10,JERECL
         LA    R5,EMSGHL(,R5)
         EX    R5,MVERR                 MOVE MSG ENTRIES
         LA    R4,ERMEND(,R4)           BUMP DSECT BASE TO NEXT ERR MSG
         BCT   R3,WERRLP                DUMP NEXT ERROR MSG
         STH   R3,ERRCNT                CLEAR ERROR COUNT
         MVI   ERRSTK+2,D0
         L     RETURN,EDTSVZ
         BR    RETURN                   RETURN TO CALLER
MVERR    MVC   JESEV(0),EMSGSVTY        OFF-THE-LINE MOVE
         DROP  R4,R11
         USING JTEXTA,INDEXP
ERRHDR   DS    0CL6                     ERROR RECORD HEADER
         DC    AL1(JPSOP)               ASSEMBLER OP
         DC    AL1(JNOCNT)              DON'T COUNT STMT NUMBER
         DC    AL1(JTERROR)             INTERNAL OP
         DC    AL1(0,0,0)               .
EERRHDR  EQU   *
         DS    0H
         SPACE
WREXIT   SET   (SFSTCD,SUPDNT),OFF      RESET SWITCHES
         SET   (SNMFND,SNOFND,SDTCMT,STRCMT),OFF
         SET   (SBYCNT,SBYONE),OFF      RESET SWITCHES
         GOIF  SNOPND,OFF=READNEXT      BRANCH IF NO RETURN
         SPACE
WRETURN  SET   (SNOPND,SCTLRTN),OFF
         L     RETURN,RTNSV             RESTORE RETURN POINT
         BR    RETURN                   RETURN TO CALLER
         EJECT
         USING DCSTK,PARM
NOPCD    EQU   *
         GOIF  SXMCRO,ON=SSEQ46         CLOSE M DEF IF EXP MAC  OX00095
         L     INPTR,INPUT              BACK UP TO BEGIN OF FIELD
         BAL   TLINK,ABSERR             OP CODE NOT FOUND IN 1ST CARD
         DC    AL1(SEV53)               .
         DC    AL1(ERR53)               OP CODE NOT FOUND IN 1ST CARD
         B     WRAPFLD                  WRAP UP STMT
RENTFULL EQU   *
         BAL   TLINK,ABSERR             RSTACK FULL
         DC    AL1(5*16+SEV46)          CLEANUP
         DC    AL1(ERR46)               STMT COMPLEXITY EXCEEDED
ILGVS    EQU   *
         L     INPTR,TPSAVE             BACK TO BEGIN OF FIELD FOR SNAP
         LA    R15,D1(,R15)             INCREASE LENGTH FOR &
         LR    R0,R1                    SAVE LENGTH
         BAL   TLINK,SNAPERR            TAKE A SNAP SHOT
         DC    AL2(2)                   .
         DC    AL1(4*16+SEV39)          CLN0
         DC    AL1(ERR39)               TRY TO CONTINUE EDITING
INVSUBS  EQU   *
         L     INPTR,TPSAVE1            BACK TO BEG OF SNAPFIEL OX00224
         BCTR  INPTR,D0                 BEGIN SNAP WITH LEFT PAREN
         GOIF  DMIENT,ON=INVSUBS1       ERROR FROM MI          @OX06626
         LR    R0,R1                    SAVE R1                @OY16256
         BAL   TLINK,SNAPERRL           TAKE A SNAP SHOT
         DC    AL2(2)                   .
         DC    AL1(4*16+SEV37)                                 @OY16256
         DC    AL1(ERR37)               SUBSCRIPT ERROR
INVSUBS1 GOIF  SUBLST,ON=INVSUBS2       BR IF ERROR IN SUBLIST @OZ26008
         LR    R0,R1                    SAVE R1                @OZ26008
         BAL   TLINK,SNAPERRL           TAKE A SNAPSHOT...     @OX06626
         DC    AL2(2)                   AND RETURN TO CLN0...  @OX06626
         DC    AL1(4*16+SEV37)          AFTER LOGGING...       @OZ26008
         DC    AL1(ERR37)               SUBSCRIPT ERROR        @OX06626
INVSUBS2 L     BASE3,AMIPRTO            RESTORE BASE REG       @OZ26008
         BAL   TLINK,SNAPERRL             SUBSCRIPT ERROR      @OZ26008
         DC    AL2(2)                                          @OX06626
         DC    AL1(10*16+SEV37)                                @OX06626
         DC    AL1(ERR37)                                      @OX06626
BADPRTO  EQU   *
         BAL   TLINK,ABSERR             COMMENTS STMT FOUND
         DC    AL1(6*16+SEV87)          WHILE
         DC    AL1(ERR87)               EXPECTING PROTOTYPE
INVOP    EQU    *
         GOIF  SXMCRO,ON=SSEQ46         BR IF ERR IFO085       @OX07247
         L     INPTR,INPUT              GET END OF SCAN POINT
         BAL   RETURN,RESETPTR          RESET POINTERS
         GOIF  SXPRTO,ON=BDPTO          BRANCH IF EXPECTING PROTO
         BAL   TLINK,ABSERR             LOG HARD ERROR
         DC    AL1(6*16+SEV54)          WRAPFLD
         DC    AL1(ERR54)               OP OCDE NOT O-SYM OR V-SYM
CSTKFULL EQU   *
         BAL   TLINK,ABSERR             MORE THAN 5 LEVELS OF COPY CODE
         DC    AL1(2*16+SEV61)          AOPPTR
         DC    AL1(ERR61)               CURRENT LIMIT IS 5 LEVELS
GLXERRZ  ST    INPTR,OPNDPTR
GLXE1    LA    INPTR,D1(,INPTR)
GLXERR   CLI   D0(INPTR),JCOMMA
         BE    GLXE2                    LOG ERROR WHEN FIND A COMMA
         CLI   D0(INPTR),JBLANK         OR A BLANK
         BNE   GLXE1                    ELSE, KEEP LOOKING
GLXE2    LR    R15,INPTR
         LR    R0,INPTR
         L     INPTR,OPNDPTR
         SR    R15,INPTR
         BNP   GLXE3                    MAKE SURE YOU GET A POS. VALUE
         BCTR  R15,0                    BACK UP 1
GLXE3    BAL   TLINK,SNAPERR            LOG ERROR NOW
         DC    AL2(1)                   .
         DC    AL1(SEV29)               BAD DECLARATION
         DC    AL1(ERR29)               BAD DECLARATION
         LR    INPTR,R0
         B     GLX10                    CHECK NEXT SYMBOL
NOPNDER  BAL   TLINK,ABSERR             THIS STMT SHOULD HAVE OPERAND
         DC    AL1(7*16+SEV62)          BUT -
         DC    AL1(ERR62)               MISSING
BDPTO    BAL   TLINK,ABSERR             THIS PROTOTYPE STMT
         DC    AL1(6*16+SEV43)          HAS AN ILLEGAL OP CODE
         DC    AL1(ERR43)               FORMAT
ILDIM    ST    INPTR,OPNDPTR            SAVE THE BEGIN POINT
ILDIM1   LA    INPTR,D1(,INPTR)         BUMP UP TO THE NEXT CHARACTER
         CLI   D0(INPTR),JCOMMA         IS IT A COMMA
         BE    ILDIM2                   YES, GO LOG ERR FOR THIS OPND
         CLI   D0(INPTR),JBLANK         WHAT ABOUT A BLANK
         BNE   ILDIM1                   NO, LOOP UNTIL FIND TERMINATOR
ILDIM2   LR    R15,INPTR                GET THE END POINT
         LR    INPTR,TRTN               GET THE BEGIN POINT
         LR    TRTN,R15                 SAVE FOR CLEANUP ROUTINE
         SR    R15,INPTR                CALCULATE LENGTH OF THIS OPND
         BCTR  INPTR,D0                 BEGIN SNAP WITH LEFT PAREN
         BAL   TLINK,SNAPERR            TAKE A SNAP SHOT
         DC    AL2(2)                   .
         DC    AL1(4*16+SEV30)          (CLN0)  OR
         DC    AL1(ERR30)               EXCEEDS 10 DSDT DIGITS
HIDIM    XR    INPTR,TRTN               SAVE INPTR AND BACK UP
         XR    TRTN,INPTR               TO THE LOCATION AT TRTN
         XR    INPTR,TRTN
         LR    R3,PARM                  SAVE WHERE SYMBOL STARTS
         STH   PARAM2,JHWORD1           SAVE SYMBOL LENGTH
         BCTR  TWKREG2,D0               ADJUST MOVE LENGTH OF DIMENSION
         BAL   TLINK,SNAPERR            TAKE A SNAP OF DIMENSION
         DC    AL2(2)                   ERROR--
         DC    AL1(SEV30)               DIMENSION
         DC    AL1(ERR30)               TOO LARGE
         LR    PARM,R3                  RESTORE -WHERE IT'S AT-
         LH    PARAM2,JHWORD1           RESTORE SYMBOL LENGTH
         MVC   JHWORD1(L'H32K),H32K
         LR    INPTR,TRTN
         B     VSDNDX                   CONTINUE EDITING
ILGLXP   EQU   *
         BAL   TLINK,SNAPERR            TAKE A SNAP SHOT
         DC    AL2(1)                   .
         DC    AL1(5*16+SEV33)          CLEANUP
         DC    AL1(ERR33)               IN SET STATEMENT
ILSETA   BAL   TLINK,ABSERR             BOOLEAN EXPRESSION
         DC    AL1(5*16+SEV59)          NOT ALLOWED IN
         DC    AL1(ERR59)               SETA EXPRESSION
ILUNARY  EQU   *
         BAL   TLINK,ABSERR             INVALID UNARY OPERATOR
         DC    AL1(5*16+SEV52)          CLEANUP
         DC    AL1(ERR52)               UNARY OPERATOR NOT + OR -
INVDUP   EQU   *
         BAL   TLINK,SNAPERRL           GO PUT OUT SNAP SHOT
         DC    AL2(1)                   PADDING TO CALCULATE RETURN
         DC    AL1(5*16+SEV57)          NOT TERMINATED BY
         DC    AL1(ERR57)               RIGHT PAREN
INVSUB   BAL   TLINK,ABSERR             INVALID SUBSTRING NOTATION
         DC    AL1(5*16+SEV70)          CLEANUP
         DC    AL1(ERR70)               NOT TERMINATED BY , AND )
NOQUOTE  BAL   TLINK,ABSERR             SETC EXPRESSION
         DC    AL1(5*16+SEV58)          CLEANUP
         DC    AL1(ERR58)               TERMINATED BY A QUOTE
INVFM    EQU   *
         BAL   TLINK,SNAPERRL           TAKE 8 CHAR SNAP SHOT
         DC    AL2(1)                   .
         DC    AL1(5*16+SEV32)          CLEANUP
         DC    AL1(ERR32)               .
ILATTR   L     INPTR,TPSAVE             BACK TO BEGIN PT FOR SNAP SHOT
         MVI   ATTRSV,D0                RESET ATTRIBUTE INDICATOR
         BAL   TLINK,SNAPERRL           TAKE A SNAP SHOT
         DC    AL2(1)                   TO CALCULATE BR TO ABSOLUTE ERR
         DC    AL1(5*16+SEV36)          CLEANUP
         DC    AL1(ERR36)               .
ILSETX   EQU   INVFM
ILSETNM  BAL   TLINK,ABSERR             ILLEGAL NAME IN SET STMT
         DC    AL1(SEV31)               .
         DC    AL1(ERR31)               NOT V-SYM OR V-SYM WRONG TYPE
         B     AOPXIT                   STOP EDIT ON THIS ERROR
NAMERR   EQU   *
         BAL   TLINK,WRNERR             INVALID NAME DETECTED
         DC    AL1(SEV16)               GO LOG ERROR AND RETURN TO
         DC    AL1(ERR16)               CONTINUE PROC STATEMENT
         SET   JSUBNAME,OFF             SUB NOT REQ'D IF NAME WAS V.S.
         SET   JNMERR,ON                INDICATE NAME ERROR
         MVI   SDENTR,D0                INSURE NO DIR ENTRY ON NAME ERR
         BR    RETURN                   RETURN TO CALLER
ILBXP    BAL   TLINK,ABSERR             INVALID EXPRESSION IN SETB
         DC    AL1(5*16+SEV21)          STATEMENT
         DC    AL1(ERR21)               .
ILSDT    EQU   *
         SR    R15,INPTR                SET LENGTH FOR SNAP
         L     INPTR,TPSAVE             BACK TO BEGIN PT FOR SNAP SHOT
         LR    R15,INPTR                GET TERMINATOR ADDR
         BAL   TLINK,SNAPERR            TAKE A SNAP SHOT
         DC    AL2(1)                   .
         DC    AL1(5*16+SEV38)          CLEANUP
         DC    AL1(ERR38)               .
         EJECT
***********************************************************************
*
* CHANGE BASE REGISTER BEFORE ENTERING THE FOURTH CSECT
*
***********************************************************************
SNAPERRL LA    R15,D7                   SET UP TO DUMP 8 BYTES
SNAPERR  L     LINK,ASNAPERR            GET ROUTINE ADDR
         B     SAVOLD                   SAVE OLD FIRST
*
ABSERR   L     LINK,AABSERR             GET ROUTINE ADDR
         B     SAVOLD                   SAVE OLD FIRST
*
WRNERR   L     LINK,AWRNERR             GET ROUTINE ADDR
         B     SAVOLD                   SAVE OLD FIRST
*
UNXPEOF  L     LINK,AUNXPEOF            GET ROUTINE ADDR
         B     GOCSECT4                 GO CHANGE BASE
*
EOFRTN   L     LINK,AEOFRTN             GET ROUTINE ADDR
         B     GOCSECT4                 GO CHANGE BASE
*
DIR10    L     LINK,ADIR10              GET ROUTINE ADDR
         B     SAVOLD                   SAVE OLD FIRST
*
DIRENT   L     LINK,ADIRENT             GET ROUTINE ADDR
*
SAVOLD   ST    BASE2,REGSAVE3           SAVE OLD BASE
GOCSECT4 L     BASE4,CS4ADDR            CHANGE BASE FOR CSECT4
         BR    LINK                     NOW ENTER ROUTINE
         SPACE 3
***************
         DS    0F
CS2ADDR  DC    A(CS2)                   ADDR OF CSECT 2
CS4ADDR  DC    A(CS4)                   ADDR OF CSECT 4
ADIRENT  DC    A(NDIRENT)               ADDR OF DIRENT
ADIR10   DC    A(NDIR10)                ADDR OF DIR10
AUNXPEOF DC    A(NUNXPEOF)              ADDR OF UNXPEOF
AEOFRTN  DC    A(NEOFRTN)               ADDR OF EOFRTN
AESYSMAC DC    A(ESYSMAC)               ADDR OF ESYSMAC
APGRMAC  DC    A(PGRMAC)                ADDR OF PGRMAC
ASVCTLFM DC    A(SVCTLFM)               ADDR OF SVCTLFM
ACSTKEXT DC    A(CSTKEXT)               ADDR OF CSTKEXT
ASNAPERR DC    A(NSNAPERR)              ADDR OF SNAPERR
AABSERR  DC    A(NABSERR)               ADDR OF ABSERR
AWRNERR  DC    A(NWRNERR)               ADDR OF WRNERR
         EJECT
****************************************
*   POSTFIXER ENTRY ROUTINE
*   AT ENTRY REG 10 (PARM) CONTAINS THE OPERATOR TO BE LOGGED
*   LINKAGE IS    BAL   R3,PFXRENT
*                 BAL   R3,PFXRE2
****************************************
         SPACE 3
         JEXTRN (X1S01=PFIXRN)
PFXRENT  EQU   *
         LH    PARM,D0(,R3)             GET OPERATOR
         AH    R3,H2                    ADJUST RETURN ADDRESS
PFXRE2   STM   R15,R3,EDTSVZ            SAVE REGISTERS
         L     LINK,ADPSTR              LOCATE P-FXR ENTRY POINT
         BALR  RETURN,LINK              MAKE ENTRY
         B     RENTFULL                 STACK OVERFLOW IF RETURN HERE
         LA    INPTR,D1(,INPTR)         UPDATE POINTER
         LM    R15,R3,EDTSVZ            RESTORE REGISTERS
         BR    R3                       RETURN TO CALLER
ADPSTR   DC    A(PFIXRN)                POSTFIXER ENTRY POINT
         EJECT
*   SYMSCN EDITS ORDINARY SYMBOLS INTO EDITED TEXT
*   LINKAGE IS     BAL LINK,SYMSCN
*   NORMAL EXIT IS     B    D4(,LINK)
*   ERROR EXIT IS      BR   LINK
         SPACE 3
SYMSCN   EQU   *
         ST    LINK,EDTSVY              SAVE RETURN LINKAGE
         L     LINK,ATRTEST             PT TO TRTEST
         BALR  RETURN,LINK              GO TRT SYMBOL
         L     LINK,EDTSVY
         BCTR  R3,LINK                  ERROR IF NOT O-SYM
SYMSCN1  EQU   *
         ST    LINK,EDTSVY              MAKE SURE RTN LNKAGE IS SAVED
         CH    R15,H7                   AND LENGTH MUST BE LE 8
         BCR   BHI,LINK                 RETURN IF GT 8 - ERROR
         TM    ATTRSV,ATK               N' OR K' FOLLOWED BY O-SYM
         BCR   BONE,LINK                IS ERROR
         MVI   DDNDX1,ORDSYMBR          ORDINARY SYMBOL REF INDEX
         LR    PARM,INPTR               POINT TO SYMBOL
         LR    PARAM2,TWKREG2           GET ITS LENGTH
         BAL   R3,DIRENT                LOG ORDINARY SYMBOL
         L     LINK,EDTSVY              RESTORE RETURN LINKAGE
         LR    INPTR,R1                 BUMP POINTER
         B     D4(,LINK)                RETURN TO CALLER
         EJECT
****************************************
*   PAREN COUNT - INCREMENTAL - MAX HALF WORD
*   LINKAGE IS    BAL   R12,APARCT
****************************************
APARCT   EQU   *
         LH    RCNT,PRNLVL              GET CURRENT COUNT
         AH    RCNT,H1                  ADD ONE
         STH   RCNT,PRNLVL              AND SAVE
         BR    R12                      RETURN TO CALLER
         SPACE 3
****************************************
*   PAREN COUNT - DECREMENTAL -
*   LINKAGE IS    BAL   R12,DPARCT
****************************************
DPARCT   EQU   *
         LH    RCNT,PRNLVL              GET CURRENT COUNT
         SH    RCNT,H1                  SUBTRACT ONE
         STH   RCNT,PRNLVL              AND SAVE
         BR    R12                      RETURN TO CALLER
         EJECT
***********************************************************************
*   TBLOPS  ROUTINE IS ENTERED  WHEN A STATEMENT OTHER THAN MACRO
*   INSTRUCTION OR PROTOTYPE IS READ. THIS ROUTINE FURTHER CLASSIFIES
*   ASSEMBLER OP STATEMENTS FROM MACHINE OP STATEMENTS. ALL MACHINE
*   OP STATEMENTS ARE UNIQUELY EDITED BY ONE SUBROUTINE, WHILE
*   ASSEMBLER OP STATEMENTS ARE FANNED OUT TO THE APPROPRIATE
*   SUBROUTINES BASED ON OP CODES. EDITED TEXT RECORDS ARE PARTIALLY
*   BUILT, AND POSSIBLE DIRECTORY ENTRIES ARE MADE. IN MOST CASES,
*   PROCESS GOES TO 'WRAPFLD' ROUTINE WHERE THE BUILDING OF THE
*   EDITED TEXT RECORD IS COMPLETED. AT END OF EDITING A MACRO
*   DEFINITION, DIRECTORY ROUTINE, 'MACREND', IS CALLED TO CLOSE OUT
*   SOME DIRECTORIES. AT THE END OF EDITING OPEN CODE, DIRECTORY
*   ROUTINE, 'OPENEND', IS  CALLED TO CLOSE OUT SOME DIRECTORIES, AND
*   TO INITIALIZE THE PHASE FOR SYSTEM MACRO EDITING. WHEN ALL
*   SYSTEM MACROS ENCOUNTERED ARE EDITED. DIRECTORY ROUTINE, 'PHASEND',
*   IS CALLED. ALL DIRECTORIES THAT HAVE NOT BEEN CLOSED ARE CLOSED.
*   CONTROL RETURNS TO CONTROLLER.
***********************************************************************
*        PROCESS OPERAND FIELD        *
***************************************
         SPACE 3
TBLOPS   EQU   *                        EDIT OPERAND FIELD
         TM    IOCID,BIT0+BIT1          TEST IF MACRO CALL/PROTO
         BZ    MACINST                  EDIT PARAM IF YES
         SET   SEOPND,ON
         L     INPTR,ENDATA             GET END OF DATA FIELD
         L     LINK,ARDSRC05            PT TO RDSRC05
         BALR  RETURN,LINK              READ ALL CONTINUATIONS
         DC    AL2(RALLCNT-RFSTCRD)     READ ALL VALID CONTINUATIONS
         L     INPTR,FPTRSV             BUMP POINTER
         BAL   TLINK,SKPBLK             GO FIND OPERAND FIELD
         TM    IOCID,IOCTYP             TEST IF ASSEMBLER OP
         BNO   MCHINS                   BRANCH IF MACHINE OP
         SR    TWKREG1,TWKREG1
         IC    TWKREG1,OCSAVE           GET INTERNAL OP BEFORE YOU GO
         BAL   RETURN,STMTSEQ           STATEMENT SEQUENCING
         GOIF  JPRONLY,ON=INVALID       BRANCH IF SEQ'G ERROR FOUND
ASSMOP   EQU   *
         SR    CGOTO,CGOTO
         IC    CGOTO,OCSAVE             GET OP CODE
         AR    CGOTO,CGOTO              DOUBLE THE VALUE
         LH    CGOTO,AOPTBL(CGOTO)      COMPUTE BRANCH ADDRESS
         B     SETBAS(CGOTO)            GO TO PROCESS ASSEMBLER OP
AOPPTRS  ST    RETURN,RTNSV             SAVE RETURN LINKAGE
AOPPTR   LCR   R14,INDEXO               COMPUTE FIELD POINTER
         A     R14,OFPTRSV
         STH   R14,JTOPP                AND SAVE
         SET   SEOPND,OFF
         B     WPOPND                   GO EDIT COMMENTS
SAVPTR   ST    RETURN,RTNSV             SAVE RETURN ADDRESS
AOPXIT   SET   SEOPND,OFF
         B     WRAPFLD                  GO EDIT COMMENTS
         EJECT
*******************************************
*        ASSEMBLER OP BRANCH TABLE        *
*******************************************
         TBLGEN (ICTL,                                                 X
               ISEQ,                                                   X
               COPY,                                                   X
               OPSYN,                                                  X
               ANOP,                                                   X
               GBLA,                                                   X
               GBLB,                                                   X
               GBLC,                                                   X
               LCLA,                                                   X
               LCLB,                                                   X
               LCLC,                                                   X
               MACRO,                                                  X
               ACTR,                                                   X
               AGO,                                                    X
               AIF,                                                    X
               SETA,                                                   X
               SETB,                                                   X
               SETC,                                                   X
               MEXIT,                                                  X
               MEND,                                                   X
               END,                                                    X
               DXD,                                                    X
               EQU,                                                    X
               ORG,                                                    X
               CNOP,                                                   X
               CCW,                                                    X
               DC,                                                     X
               DS,                                                     X
               START,                                                  X
               CSECT,                                                  X
               DSECT,                                                  X
               COM,                                                    X
               ENTRY,                                                  X
               EXTRN,                                                  X
               WXTRN,                                                  X
               CXD,                                                    X
               LTORG,                                                  X
               PUNCH,                                                  X
               REPRO,                                                  X
               PUSH,                                                   X
               POP,                                                    X
               PRINT,                                                  X
               USING,                                                  X
               DROP,                                                   X
               SPACE,                                                  X
               EJECT,                                                  X
               TITLE,                                                  X
               MNOTE,                                                  X
               INVALID),,                                              X
               AOPTBL,,2,SETBAS
         EJECT
ICTL     EQU   *
****                                    OPERAND EDITED AS COMMENTS
         SET   SICTL,OFF
         SET   JPRONLY,ON               INDICATE PRINT ONLY
         ST    INPTR,OPNDPTR
         L     INPTR,INPUT              RESET POINTER
         SET   SCTLRTN,ON               ELSE, INDICATE TO RETURN
         GOIF  SNOFND,ON=BADI           LOG ERROR IF NO OPERAND
         BAL   RETURN,SAVPTR            SAVE RET ADDR AND WRAP UP STMT
         L     INPTR,OPNDPTR            GET OPERAND POINTER
         SET   SFSTCD,OFF               ICTL NO LONGER ALLOWED
*
         BAL   RETURN,DSCAN             SCAN FIRST OPERAND
         B     BADICTL                  INVALID OPERAND FOUND
         LTR   TWKREG1,TWKREG1          TEST IF VALUE BETWEEN 1 AND 40
         BNH   BADICTL                  VALUE EQ 0 - ERROR
         CH    TWKREG1,H40
         BH    BADICTL                  VALUE GT 40 - ERROR
         BCTR  TWKREG1,0                BACK UP 1
         ST    TWKREG1,TBGLN            SAVE NEW STRING LENGTH
         ST    TWKREG1,JBEGCL           SAVE NEW BEGIN COLUMN - 1
         BCTR  TWKREG1,0                BACK UP 1
         ST    TWKREG1,PBGLEN           SAVE PRE-BEGIN LENGTH - 1
         CLI   D0(INPTR),JCOMMA         TEST IF MORE OPERAND
         BE    CTL10                    YES.
         L     TWKREG1,CONTCHR          NO, INSERT STD END COLUMN
         B     CTL15                    CONTINUE
CTL10    EQU   *
         BAL   RETURN,DSCAN1            SCAN SECOND OPERAND
         B     BADICTL                  INVALID OPERAND FOUND
         CH    TWKREG1,H40              TEST VALUE BETEEEN 41 AND 80
         BNH   BADICTL                  VALUE LESS THEN 41. ERROR
         CH    TWKREG1,H80
         BH    BADICTL                  VALUE GREATER THAN 80. ERROR
         BL    CTL15                    BRANCH IF ALLOW CONT'N
         SET   SNOCNT,ON                ELSE, SAY NO CONT'N
CTL15    EQU   *
         ST    TWKREG1,JCTCHR           SAVE CONT. CHR. COLUMN
         LA    WORK2,CRDLN-1            COMPUTE POSTEND STRING LENGTH-1
         SR    WORK2,TWKREG1
         ST    WORK2,PNDLEN
         BCTR  TWKREG1,0                BACK UP 1
         ST    TWKREG1,ENDCOL           SAVE NEW END COLUMN
CTL20    S     TWKREG1,PBGLEN           COMPUTE SOURCE LENGTH WHICH
         CH    TWKREG1,H6               MUST BE GE 5 TO BE ABLE TO
         BL    BADICTL                  HOLD GENERATED ' END  '
         ST    TWKREG1,TSRCLN           STORE NEW SOURCE LENGTH
         LR    WORK2,TWKREG1            SAVE LENGTH
         BCTR  TWKREG1,0                DECR BY 1
         ST    TWKREG1,JSRCLN           STORE NEW SRC LENGTH MINUS 1
         CLI   D0(INPTR),JCOMMA         TEST IF MORE OPERAND
         BNE   CTL40                    BRANCH IF NO MORE OPERAND
         GOIF  SNOCNT,ON=BADICTL        BRANCH IF NO CONT'N ALLOWED
         BAL   RETURN,DSCAN1            SCAN THIRD OPERAND
         B     BADICTL                  INVALID OPERAND FOUND
         CH    TWKREG1,H40
         BH    BADICTL                  VALUE MUST BE
         BCTR  TWKREG1,0                BETWEEN BEGCOL+1 AND 40
         C     TWKREG1,JBEGCL           ELSE ....
         BNH   BADICTL                  ERROR
CTL30    EQU   *
         ST    TWKREG1,JCTBGN           SAVE CONTINUATION BEGIN
         BCTR  TWKREG1,0                BACK UP 1
         LCR   TWKREG1,TWKREG1
         A     TWKREG1,ENDCOL
         ST    TWKREG1,TCNTLN           STORE CONTINUATION LENGTH
         BCTR  TWKREG1,0                DECR BY 1
         ST    TWKREG1,JCTLN            STORE CONT. LENGTH MINUS 1
         CLI   D0(INPTR),JBLANK         BLANK IS GOOD TERMINATOR
          BE    CTLX                    IT IS.
         C     INPTR,ENDATA             ELSE, ENDATA MUST TERMINATE
         BL    BADICTL                  BAD TERMINATOR
CTLX     SR    PARAM1,PARAM1
         LA    PARAM2,MAXCNT
         DR    PARAM1,TWKREG1
         MR    PARAM1,TWKREG1
         LA    PARAM1,D1(WORK2,PARAM2)
         LA    TWKREG2,CRDLN
         SR    TWKREG2,TWKREG1
         LA    PARAM2,D6+D7(TWKREG2,PARAM1)
         SR    PARAM1,PARAM1
         LA    TWKREG1,D8
         DR    PARAM1,TWKREG1
         L     PARAM1,DSTGBGN
         LR    INPTR,PARAM2
         CH    PARAM2,H63               ACTUAL DATA AREA SIZE W/STD
         BNL   FRECORE                  IF GE STD, ASSIGN ACTUAL DW VAL
         LH    INPTR,H63                ASSIGN STANDARD SIZE IF LOWER
FRECORE  EQU   *
         JFRECORE  ADDR=(PARAM1)
GETCORE  EQU   *
         JGETCORE DBL=(INPTR)
         ST    PARAM1,DSTGBGN
         LA    TWKREG1,D0(PARAM1,PARAM2)
         ST    TWKREG1,ENDWKA           SAVE END OF BUFFER POINTER
         ST    TWKREG1,ENDWKADJ         SAVE 'ENDWKA'          @OX07230
         LA    PARAM2,CRDLN             CARD LENGTH MINUS
         S     PARAM2,TCNTLN            CONTINUATION DATA LENGTH
         LA    TWKREG1,MISTGP(PARAM1,PARAM2) ONE CARD STG AREA LENGTH
         ST    TWKREG1,MINPADJ
         ST    TWKREG1,MINPUT
         SLL   PARAM2,D1                COMPUTE NORMAL STRING AREA
         LA    TWKREG2,CRDLN            COMPUTE INPUT POINTER
         S     TWKREG2,TSRCLN
         LA    TWKREG2,STSTGP(TWKREG2,PARAM2)
         LA    TWKREG2,D0(TWKREG2,PARAM1)
         ST    TWKREG2,STNPADJ
         ST    TWKREG2,INPUT
         SR    TWKREG2,TWKREG1          COMPUTE DIF B/
         STH   TWKREG2,MINDIF           MINPUT AND INPUT
         STH   TWKREG2,MINDFADJ         SAVE 'MINDIF'          @OX07230
ICTLOUT  EQU   *
         MVI   DDNDX1,PHASENT           SET UP INDEX FOR BR TO DIR RTN
         BAL   R3,DIR10                 INITIALIZE DIRECTORIES
         B     WRAPCNT                  EDIT COMMENTS
*
BADI     EQU   *
         BAL   RETURN,SAVPTR            OUTPUT PRINT-ONLY RECORD
         BAL   TLINK,ABSERR             LOG ERROR
         DC    AL1(SEV48)               .
         DC    AL1(ERR48)               ICTL OPERAND NOT FOUND
BADIX    EQU   *
         MVI   DDNDX1,PHASENT           SET UP INDEX FOR BR TO DIR RTN
         BAL   R3,DIR10                 INITIALIZE DIRECTORIES
         SET   (SPGRMD,SOPNCD,SKPEND),FLIP
         MVI   DDNDX1,OPENENT           SET UP INDEX FOR BR TO DIR RTN
         BAL   R3,DIR10                 INITIALIZE OPEN CODE
         B     WRAPCNT                  THEN CLOSE
*
CTL40    EQU   *
         L     TWKREG1,F15              STD CONT'N COL
         SET   SNOCNT,ON                CONTINUATION NOT ALLOWED
         B     CTL30                    WRAP UP ICTL STMT
BADICTL  EQU   *
         LR    INPTR,TRTN               BACK UP
         MVC   TBGLN(L'TBGLN*6),STDPARM RESTORE STANDARD ICTL PARAMS
         MVC   JSRCLN(L'JSRCLN*7),SRCLEN
         BAL   TLINK,WRNERR             BAD ICTL STATEMENT
         DC    AL1(1*16+SEV19)          GO TO BADIX RTN THRU WRNERR
         DC    AL1(ERR19)               DEFAULT TO STD ICTL VALUES
         SPACE 3
ISEQ     EQU   *
****                                    OPERAND EDITED AS COMMENTS
         SET   SISEQ,OFF                ASSUME NO SEQUENCE CHECK
* PARAMETER ERROR IN ISEQ STATEMENT IS TREATED AS ISEQ WITHOUT OPERAND,
* WHICH CAUSES SEQUENCE CHECKING TO BE DISCONTINUED.
         SET   JPRONLY,ON               INDICATE PRINT ONLY
         GOIF  SNMFND,OFF=ISEQ05        LOG ERROR IF THERE IS A NAME
         BAL   RETURN,NAMERR             LOG ERROR
ISEQ05   EQU   *
         GOIF  SNOFND,ON=AOPXIT         BRANCH IF NO OPERAND
         CLC   INPOPR(L'CMABLK+1),CMABLK  TEST OMIT OPER FIELD  OX00410
         BE    AOPXIT                   WRAP UP STMT
         ST    INPTR,FPTRSV             SAVE INPTR
         BAL   RETURN,DSCAN             SCAN FIRST OPERAND
         B     ISEQERR                  ERROR FOUND. LOG ERROR
         CLI   D0(INPTR),JCOMMA         TERMINATE MUST BE A COMMA
         BNE   ISEQERR                  NOT A COMMA, LOG ERROR
         LTR   TWKREG1,TWKREG1          VALUE MUST BE GREATER THAN ZERO
         BNH   ISEQERR                  GO LOG ERROR
         BCTR  TWKREG1,0                DECR BY 1
         ST    TWKREG1,JSEQCL           STORE BEGIN COLUMN
         BAL   RETURN,DSCAN1            SCAN SECON OPERAND
         B     ISEQERR                  ERROR FOUND. LOG ERROR
         CLI   D0(INPTR),JBLANK         TEST IF BLANK AS TERMINATOR
         BE    ISEQ10                   BRANCH IF YES
         CR    INPTR,R12                TEST IF END COLUMN TERMINATES
         BL    ISEQERR                  NO, LOG ERROR
ISEQ10   EQU   *
         CH    TWKREG1,H80              VALUE MUST NOT BE GT 80
         BH    ISEQERR                  LOG ERROR
         BCTR  TWKREG1,0                MINUS 1
         CLC   JSEQCL(L'JSEQCL),JCTCHR  SEQUENCE FIELD MUST NOT BE
         BNL   ISEQ20                   BETWEEN BEGIN AND ENDING
         C     TWKREG1,JBEGCL           COLUMN, ELSE
         BNL   ISEQERR                  ERROR
ISEQ20   EQU   *
         S     TWKREG1,JSEQCL           COMPUTE SEQUENCE FIELD LENGTH
         BM    ISEQERR                  RIGHTMOST COLUMN MUST BE EQ OR X
                                        GT LEFTMOST COLUMN, ELSE ERROR
         ST    TWKREG1,JSEQLN           STORE MOVE LENGTH
         SET   SISEQ,ON                 INDICATE SEQUENCE CHECK
         XC    SEQSV(L'SEQSV),SEQSV     CLEAR SEQUENCE VALUE AREA
ISEQXIT  EQU   *
         L     INPTR,FPTRSV             RESET POINTER
         B     AOPXIT                   WRAP UP STATEMENT
ISEQERR  EQU   *
         BAL   TLINK,ABSERR             LOG ERROR
         DC    AL1(SEV19)               .
         DC    AL1(ERR19)               ILLEGAL ISEQ STATEMENT
         B     ISEQXIT                  EXIT
         SPACE 3
*
*        ROUTINE TO SCAN A DECIMAL FIELD.
*        IF FIELD IS VALID RETURN TO D4(,RETURN)
*        OTHERWISE, RETURN TO RETURN
*
DSCAN1   EQU   *
         LA    INPTR,D1(,INPTR)
DSCAN    EQU   *
         LR    TRTN,INPTR               SAVE STARTING POINT
         L     R12,ENDATA
         SR    TWKREG1,TWKREG1
         SR    TWKREG2,TWKREG2
DSC10    EQU   *
         CR    INPTR,R12                TEST IF END OF DATA
         BNL   DSC20                    BRANCH IF YES
         CLI   D0(INPTR),J9             TEST IF A DIGIT
         BH    DSC20                    NO, ASSUME END OF FIELD
         IC    TWKREG2,D0(,INPTR)
         MH    TWKREG1,H10              MULTIPLY PARTIAL SUM BY 10
         AR    TWKREG1,TWKREG2          ADD IN CURRENT DIGIT
         LA    INPTR,D1(,INPTR)         INCREMENT POINTER BY 1
         B     DSC10                    TEST NEXT DIGIT
DSC20    EQU   *
         LR    TWKREG2,INPTR            TEST FIELD LENGTH
         SR    TWKREG2,TRTN             WHICH MUST BE LESS THAN
         CH    TWKREG2,H10              OR EQUAL TO 10 DIGITS
         BCR   BHI,RETURN               IF HI, RETURN
         CH    TWKREG2,H1               BUT NOT LESS THAN 1
         BCR   BLO,RETURN               ELSE, LOG ERROR
         B     D4(,RETURN)              GOOD, WITHIN LIMITS
         SPACE 3
COPY     EQU   *
****                                    OPERAND EDITED AS COMMENTS
         BAL   TLINK,CHKNM              NAME MUST BE BLANK
COPY15   EQU   *
         GOIF  SNOFND,OFF=COPY17        BRANCH IF THERE IS OPERAND
         BAL   TLINK,ABSERR             ELSE LOG ERROR
         DC    AL1(8*16+SEV50)          GO TO INVALID RTN THRU ABSERR
         DC    AL1(ERR50)               COPY STMT NO OPERAND
COPY17   EQU   *
         SET   SCOPY,ON                 EDITING COPY STMT
         BAL   RETURN,GSCAN             SCAN OPERAND FIELD
         GOIF  ROSYM,OFF=BADCPY         BRANCH IF COPY CODE NOT O-SYM
         SET   SCOPY,OFF
         BAL   R3,CSTKENT               RECURSIVE ENTRY
         SET   SNOPND,ON                INDICATE TO RETURN
         BAL   RETURN,AOPPTRS           GO PUT OUT THIS STATEMENT
COPY20   EQU   *
         LA    INPTR,COPYCODE           GET COPY CODE LOC
         JFIND ADDR=(INPTR)             GO FIND IT IN THE LIB.
         BP    COPY25                   GET MEMBER NAME
         BAL   TLINK,SNAPERRL           TAKE A SNAP SHOT
         DC    AL2(1)                   OF COPY CODE NOT FOUND
         DC    AL1(SEV68)               IN MACRO LIBRARY
         DC    AL1(ERR68)               AND PREPARE TO EXIT
         BAL   R3,CSTKEXT               RECURSIVE EXIT
         B     WRAPCNT                  READ NEXT STATEMENT
BADCPY   BAL   TLINK,ABSERR             BAD COPY CODE
         DC    AL1(2*16+SEV49)          GO TO AOPPTR RTN THRU ABSERR
         DC    AL1(ERR49)               COPY CODE NOT O-SYM
COPY25   MVC   LASTFIND(L'LASTFIND),COPYCODE SAVE MEMBER NAME
         BP    READNEXT                 READ NEXT RECORD
         SPACE 3
OPSYN    EQU   *
         GOIF  SNMFND,OFF=ILOPSYN       ERROR IF NO NAME
         GOIF  ROSYM,OFF=ILOPSYN        OR NAME NOT ORDINARY SYMBOL
         MVI   SDENTR,OPSYNBLD          CHANGE ENTRY INDEX
         GOIF  SNOFND,ON=OPSYN1         EXIT IF NO OPERAND
         CLC   INPOPR(L'CMABLK),CMABLK  IS IT ',BLANK' IN OPERAND FIELD
         BE    OPSYN1                   IF YES,PROCESS AS VALID COMMENT
         BAL   RETURN,GSCAN             ELSE, EDIT OPERAND FIELD
         MVI   OCSAVE,D0                CLEAR OPSYN OP CODE
         GOIF  ROSYM,ON=AOPPTR          OK IF OPERAND AN ORD SYM
         LCR   R14,INDEXO               COMPUTE THE OPERAND
         A     R14,OFPTRSV              FIELD POINTER
         STH   R14,JTOPP                AND SAVE
ILOPSYN  EQU   *
         BAL   TLINK,ABSERR             ERROR, SUPPRESS D ENTRY
         DC    AL1(SEV13)               OPSYN NAME NOT ORD SYMBOL
         DC    AL1(ERR13)               OPERAND NOT O-SYM/BLANK
         SET   JNMERR,ON                INDICATE NAME ERROR
         MVI   OCSAVE,D0                CLEAR OPSYN OP CODE
         MVI   SDENTR,D0                INSURE NO DIRECTORY ENTRY
         B     AOPXIT                   STOP EDIT ON THIS ERROR
OPSYN1   MVI   OCSAVE,D0                CLEAR OPSYN OP CODE
         B     AOPXIT                   GO WRAP UP STATEMENT
         SPACE 3
MACRO    EQU   *
         SET   (SMDEF,SXPRTO),ON        INDICATE IN MD, XPCT PROTOTYPE
         MVI   SDENTR,MACRENT           SAVE INDEX
         SET   SDENT,ON                 POINT OF DEFINITION
         BAL   TLINK,CHKNM              NAME MUST BE BLANK
         GOIF  SPGRMD,OFF=AOPXIT        CHECK IF PROGRAMMER MACRO
         SET   JPRGMAC,ON               INDICATE PROGRAMMER MACRO
         GOIF  JNMERR,ON=PNXT15        NAME FIELD PRESENT,ERR  @OY08060
         B     AOPXIT                   WRAP UP STATEMENT
         SPACE 3
MEND     EQU   *
         BAL   TLINK,CHKSSNM            NAME MUST BE SS OR NOT USED
MENDZ    EQU   *
         SET   SNOPND,ON                INDICATE TO RETURN
         BAL   RETURN,SAVPTR            WRAP UP STATEMENT
         B     MEND1                    CLOSE MACRO DEFINITION
MEND0    EQU   *
         GOIF  SINCPY,OFF=MEND1         BRANCH IF NOT IN COPY CODE
         SET   SMAC,OFF                 CORRESPONDING MEND GENERATED
         BAL   R3,CSTKEXT               RECURSIVE EXIT
         GOIF  SOPNCD,OFF=MEND1         BR IF GERERATED MEND IS OK HERE
         BAL   TLINK,ABSERR             LOG ERROR IF NOT
         DC    AL1(SEV23)               MEND CAN'T BE IN OPEN CODE
         DC    AL1(ERR23)
         BAL   RETURN,WRAPERR           WRITE THIS ERROR RECORD
         B     READNEXT                 CONTINUE READING SOURCE
MEND1    EQU   *
         GOIF  SSYSMD,OFF=MEND2         BR IF NOT IN SYSMAC
         GOIF  SINCPY,ON=READNEXT       READ REST OF COPY BOOK
         GOIF  SMDEF,OFF=MEND25         BR IF NO MACRO DEFINIT @AY19080
MEND2    EQU   *
         GOIF  SXPRTO,OFF=MEND3         FOUND MACRO JET        @OX08858
         GOIF  SINEOF,OFF=MEND25        ONLY MACRO FOUND       @OX08858
         BAL   TLINK,WRNERR             LOG ERROR              @OX08858
         DC    AL1(SEV43)               EOF OCCURS BEFORE-     @OX08858
         DC    AL1(ERR43)               PROTOTYPE STMT         @OX08858
MEND25   EQU   *                                               @OX08858
         SET   SNOSMCRO,ON              NO, SET FLG,NOMACRO STM OX00403
         SET   SKPMND,ON                SET FLG FOR SKIPTO MEND OX00403
MEND3    SET   (SMDEF),OFF              CLOSE MACRO DEFINITION  OX00403
         MVI   DDNDX1,MACREND           SET UP INDEX FOR BR TO DIR RTN
         BAL   R3,DIR10                 GO CLOSE MACRO DEFINITION
         SET   SKPMND,OFF               ELSE, RESET SWITCH
         SET   (SNOSMCRO,SBDPROTO),OFF
         GOIF  SPGRMD,ON=READNEXT       RD NEXT STMT IF IN PGR MACRO
         L     BASE4,CS4ADDR            CHANGE BASE FOR CSECT 4
         L     LINK,AESYSMAC            GET ROUTINE ADDR
         BR    LINK                     NOW ENTER ROUTINE
         SPACE 3
REPRO    GOIF  SNMFND,OFF=REPRO10       BRANCH IF THERE IS NO NAME
         GOIF  RSSYM,ON=REPRO10         BRANCH IF NAME A S.S.
         BAL   RETURN,NAMERR            ELSE, LOG ERROR
REPRO10  SET   JPRONLY,ON               INDICATE PRINT ONLY
         SET   SNOPND,ON                INDICATE TO RETURN
         BAL   RETURN,SAVPTR            DON'T FORGET TO COME BACK
         JINPUT  ,                      READ A CARD
         BNP   UNXPEOF                  UNEXPECTED END OF FILE
         LR    INPTR,RETADR             SAVE CARD POINTER
         LA    R11,D10*D10              RECORD LENGTH
         BAL   RETURN,OPUTL             GET BUFFER
         MVC   JTRLI(L'REPRO30),REPRO30 RECORD HEADER
         MVC   JTRLI+L'REPRO30(D10*D8),D0(INPTR)  CARD IMAGE AS COMMENT
         SET   SNOPND,OFF               INSURE NO RETURN TO HERE
         B     WREXIT                   GO RESET SW AND READ NEXT CARD
REPRO30  DC    0CL20' ',H'100'          RECORD HEADER
         DC    AL1(JPSOP+JDEF,0,JTREPRO),3H'16',H'18,16',AL1(0,0,1,80)
         SPACE 3
AGO      EQU   *
         BAL   TLINK,CHKSSNM            NAME MUST BE SS OR NOT USED
         BAL   RETURN,GSCAN             SCAN OPERAND FIELD FOR SS
AGO1     EQU   *
         GOIF  RSSYM,ON=AOPPTR          EDIT COMMENTS IF SS IN OPERAND
         BAL   TLINK,ABSERR             INVALID OPERAND FORMAT
         DC    AL1(2*16+SEV73)          GO TO AOPPTR VIA ABSERR
         DC    AL1(ERR73)               OPERAND NOT SEQUENCE SYMBOL
         SPACE 3
*        NAME = SS OR BLANK
*        OPERAND = NOT USED
*
MEXIT    EQU   *
EJECT    EQU   *
         BAL   TLINK,CHKSSNM            NAME MUST BE SS OR NOT USED
         B     AOPXIT                   WRAP UP STATEMENT
*
*        NAME = SS ONLY
*        OPERAND = NOT USED
*
ANOP     EQU   *
         GOIF  RSSYM,ON=AOPXIT          BRANCH IF NAME A S.S.
         GOIF  SNMFND,OFF=AOPXIT        ALLOW BLANK NAME
         BAL   RETURN,NAMERR            LOG ERROR MESSAGE
         B     AOPXIT                   END PROCESSING OF THIS STMT
*
*        NAME = ANY SYMBOL OR NOT USED
*        OPERAND = NOT USED
*
COM      LA    TLINK,AOPXIT             GET RETURN POINT
         B     CKANYSYM                 CHECK NAME
CSECT    EQU   COM
CXD      EQU   COM
LTORG    EQU   COM
*
*        NAME = SS OR NOT USED
*        OPERAND = REL. EXP., OR BLANK
*
END      EQU   *
         GOIF  SOPNCD,OFF=SPACE         BRANCH IF NOT IN OPEN CODE
         SET   SENDST,ON                ELSE, INDICATE END STMT READ
SPACE    EQU   *
         BAL   TLINK,CHKSSNM            NAME MUST BE SS OR NOT USED
         B     MCHIN15                  EDIT AS MACHINE OP
*
*        NAME = SS OR NOT USED
*        OPERAND = EXP., SYMBOL, CHAR. STRING OR SDT
*
MNOTE    EQU   SPACE
ENTRY    EQU   MNOTE
PUSH     EQU   MNOTE
POP      EQU   MNOTE
PUNCH    EQU   MNOTE
PRINT    EQU   MNOTE
USING    EQU   MNOTE
DROP     EQU   MNOTE
*
*        NAME = SS OR NOT USED
*        OPERAND = RELOCATABLE SYMBOLS SEPARATED BY COMMAS
*
EXTRN    EQU   *
WXTRN    EQU   *
         BAL   TLINK,CHKSSNM            NAME MUST BE SS OR NOT USED
         GOIF  SNOFND,ON=AOPXIT         BRANCH IF NO OPERAND
         BAL   RETURN,GSCAN             ELSE, SCAN IT
         MVI   SDENTR1,ORDSYMBD         EST DIR ENTRY INDEX
         ST    INDEXO,NAMP1             SAVE PTR TO OPND FOR DIR ENTRY
         SET   SDENT,ON                 POINT OF DEFINITION
         B     AOPPTR                   LOG OPERAND POINTER
*
MCHINS   EQU   *
         BAL   RETURN,STMTDSQ           STATEMENT SEQUENCING
MCHIN10  EQU   *
         BAL   TLINK,CKANYSYM           CHECK NAME
MCHIN15  EQU   *
         GOIF  SNOFND,ON=AOPXIT         BRANCH IF NO OPERAND
         BAL   RETURN,GSCAN             ELSE SCAN IT
         B     AOPPTR                   LOG OPERAND POINTER
*
*        NAME = ANY SYMBOL OR NOT USED
*        OPERAND = EXP., STRING, SYMBOL OR SDT
*
START    EQU   MCHIN10                  EDIT AS MACHINE OP
CNOP     EQU   START
ORG      EQU   START
DXD      EQU   START
CCW      EQU   START
DC       EQU   START
DS       EQU   START
TITLE    EQU   MCHIN15
*
*        NAME = OS OR VS
*        OPERAND = NOT USED
*   LET ASSEMBLY PHASE CATCH SS OR BLANK IN NAME FIELD
*
DSECT    EQU   CSECT
         SPACE 3
GBLA     MVI   FLAGBT,GAFLG             INDICATE GBLA
         B     GLX                      CHECK NAME FIELD
GBLB     MVI   FLAGBT,GBFLG             INDICATE GBLB
         B     GLX                      CHECK NAME FIELD
GBLC     MVI   FLAGBT,GCFLG             INDICATE GBLC
         B     GLX                      CHECK NAME FIELD
LCLA     MVI   FLAGBT,LAFLG             INDICATE LCLA
         B     GLX                      CHECK NAME FIELD
LCLB     MVI   FLAGBT,LBFLG             INDICATE LCLB
         B     GLX                      CHECK NAME FIELD
LCLC     MVI   FLAGBT,LCFLG             INDICATE LCLC
GLX      EQU   *
         ST    INDEXP,OFPTRSV
         BAL   TLINK,CHKNM              NAME MUST BE BLANK
         GOIF  SNOFND,ON=NOPNDER        LOG ERROR IF NO OPERAND FOUND
         SET   SGBLCL,ON                INDICATE EDITING DECLARATION
         ST    INPTR,FPTRSV             SAVE BEGIN OF OPERAND
GLX05    ST    INPTR,OPNDPTR            INCASE OF BACK UP
         CLI   D0(INPTR),JAMPER         TEST IF AMPERSAND
         BNE   GLXERR                   COULDN'T BE V-SYM. ERROR
         BAL   RETURN,VARSYM            POSSIBLY.
         LR    INPTR,R1                 RESTORE POINTER
         TM    DERRCD,BITFF             TEST IF ANY ERROR IN DICT RTN
         BZ    GLX10                    CONTINUE IF NO ERROR
         SET   JPRONLY,ON               SET TO PRINT THIS STMT
         CLI   DERRCD,ERR9              SEE IF ERR WAS DICT OVERLAP
         BE    GLX20                    STOP SCANNING STMT IF YES
GLX10    CLI   D0(INPTR),JCOMMA         TERMINATOR MUST BE A COMMA
         BNE   GLX15                    OR A BLANK
         LA    INPTR,D1(,INPTR)         YES, A COMMA
         B     GLX05                    EDIT NEXT DECLARATION
GLX15    CLI   D0(INPTR),JBLANK
         BNE   GLXERRZ                  LOG ERROR IF NEITHER
GLX20    BAL   R12,VTPUT0               A BLANK MEANS END OF STMT
         SET   SGBLCL,OFF
         GOIF  SKPEND,OFF=AOPPTR        BR IF NO DICT OVERLAP (NO ERR9)
         L     INDEXO,OUTADR            RESTORE AFTER ERR9 CLEANUP WORK
         B     AOPPTR                   LOG OPERAND POINTER
         SPACE 3
ACTR     EQU   *
         BAL   TLINK,CHKSSNM            SEQ SYM OR BLANK        OX00404
         MVI   MCALL,MCLA               PROCESS LIKE A SETA STMT
         B     SETX05                   GO PROCESS
SETX     EQU   *
SETA     EQU   SETX
SETB     EQU   SETX
SETC     EQU   SETX
         L     R14,RAVSP               CLEAR                    OX02957
         LA    R14,RFLGLOC(,R14)        EXPRESSION              OX02957
         MVI   RSTKVST,X'00'            STATUS                  OX02957
         CLI   NAMBYT,RVSYM             TEST IF NAME A V. S.
         BNE   ILSETNM                  LOG ERROR IF NOT
         MVI   NAMBYT,J0                RESET FOR NEXT STMT    @OX10953
         SR    R14,R14
         IC    R14,OCSAVE
         SR    R15,15
         IC    R15,NAMABC-JTSETA(R14)   GET CORRESPONDING V.S.FLAG
         NI    VSTAT,X'13'
         CH    R15,VSFLG                TEST SET VAR FOR RIGHT TYPE
         BNE   ILSETNM                  LOG ERROR IF NOT
         IC    R14,SENTVAL-JTSETA(R14)  PICK UP METASCAN ENTRY CODE
         STC   R14,MCALL                AND SAVE IN MCALL
SETX05   EQU   *
         GOIF  SNOFND,ON=NOPNDER        OPERAND IS REQUIRED
         ST    INPTR,FPTRSV
         ST    INDEXP,OFPTRSV
         TM    MCALL,MCLA+MCLC          TEST IF SETB STATEMENT
         BZ    SETB05                   BRANCH IF YES
         BAL   RETURN,METASCAN          GO EDIT SETA/SETC OPERAND
         CLI   D0(INPTR),JBLANK         BLANK IS A GOOD TERMINATOR
         BE    SETX10                   IT IS
         C     INPTR,ENDATA             IF NOT, ENDATA MUST.
         BL    ILSETX                   LOG ERROR IF IT DOESN'T
         BCTR  INPTR,0                  MINUS 1
SETX10   EQU   *
         BAL   R12,VTENT15              WRAP UP OPERAND
         B     AOPPTR                   COMPUTE FIELD POINTER
SETB05   EQU   *
         MVC   D0(L'SBDSDT,INDEXP),SBDSDT TREAT 0,1,(0),(1) AS DSDT
         CLI   D1(INPTR),JBLANK         IF 0 OR 1 DOES NOT STAND ALONE
         BNE   SETB20                   EVALUATE AS EXPR
         CLI   D0(INPTR),D1             TEST IF VALUE 0 OR 1
         BH    SETB20                   BR IF NOT
         BL    SETB16                   ZERO
SETB15   MVI   D4(INDEXP),D1            MAKE DSDT 1
SETB16   LA    INPTR,D1(,INPTR)
         LA    INDEXP,L'SBDSDT(,INDEXP) BUMP POINTER
         BAL   R12,VTPUT0               BUILD V.T.
         B     AOPPTR                   LOG OPERAND POINTER
AIF      EQU   *
         MVI   MCALL,D0                 INDICATE EDITING SETB
         BAL   TLINK,CHKSSNM            NAME MUST BE SS OR BLANK
         ST    INPTR,FPTRSV
         ST    INDEXP,OFPTRSV
         GOIF  SNOFND,ON=NOPNDER        GO LOG ERROR ON MISSING OPERAND
SETB20   EQU   *
         CLI   D0(INPTR),JLPARN         EXPRESSION MUST BE W/N ( )
         BNE   ILGLXP1                  LOG ERR IF NOT
         BAL   R3,PFXRENT               ENTER L-PAREN
         DC    AL2(JTMLPAR)             INTO POSTER
         BAL   RETURN,METASCAN          SCAN IT
         CLI   D0(INPTR),JRPARN         TERMINATOR MUST BE A R-PAREN
         BNE   ILGLXP1                  GO TO LOG EITHER ERR24 OR ERR32
         LR    R0,R3                    SAVE EXIT CODE
         BAL   R3,PFXRENT               ENTER R-PAREN
         DC    AL2(JTMRPAR)             INTO POSTER
         LR    R3,R0                    RESTORE EXIT CODE
         CH    R3,H2                    DO NOT ALLOW SETC STATS OX00406
         BE    SETX30                   ALLOW SETA EXPRESSION   OX00406
         CH    R3,H1                    EXPRESSION MUST BE COMPLEX OR
         BH    ILBXP                    SIMPLE. ELSE, ERROR
         BE    SETX30                   OK IF COMPLEX
         L     R14,RAVSP
         LA    R14,RFLGLOC(,R14)        CHECK EXPRESSION STATUS
         TM    RSTKVST,VSLS             SIMPLE BOOLEAN  ...
         BO    ILBXP                    DOESN'T TOLERATE SYSLIST
SETX30   EQU   *
         CLI   OCSAVE,JTAIF             TEST IF AIF STATEMENT
         BE    AIF1                     BR IF THIS IS AIF
         CLI   D0(INPTR),JBLANK         MUST HAVE BLANK TERMINATOR
         BE    SETX10                   SETB OPERAND TERMINATOR IS OK
         B     INVFM                    LOG ERR32, SNAP INVALID TEXT
         SPACE 3
AIF1     EQU   *
         BAL   R3,PFXRENT               LOG END STMT FLAG
         DC    AL2(JTMSTRM)             FLAG
         BCTR  INPTR,D0                 DON'T GET CARRIED AWAY
         SET   GAIF,ON                  INDICATE AIF STATEMENT
         BAL   RETURN,GSCAN1            GO SCAN SEQ SYMBOL
         SET   GAIF,OFF
         B     AGO1                     WRAP UP LIKE AGO STMT
         SPACE 3
SBDSDT   DS    0CL9                     M.T. FORMAT FOR 0 OR (0) SDT
         DC    AL1(JTMSDT,0,0,0,0,0,JTMSTRM,0,7) M.T. INT'L FORMAT
SENTVAL  DC    AL1(MCLA,0,MCLC)         METASCAN ENTRY CODE FOR SETX
NAMABC   DC    AL1(0,1,3)               SET VARIABLE VALUE IN FLGBYT
         DS    0H
         SPACE 3
*
*        NAME = OS OR VS
*        OPERAND = EXPRESSION
*
*   LET ASSEMBLY PHASE CATCH SS OR BLANK IN NAME FIELD
EQU      EQU   MCHIN10
         SPACE 3
INVALID  EQU   AOPXIT
         EJECT
***********************************************************************
*        SKIP BLANKS BETWEEN FIELDS                                   *
*        AT ENTRY INPTR POINTS TO BEGIN OF FIELD                      *
***********************************************************************
SKPBLK   EQU   *
         L     TWKREG2,ENDATA           GET END OF DATA ADDRESS
SKPBLK0  EQU   *
         SET   SNOFND,OFF
         LA    TWKREG1,1                THE INCREMENT IS ONE BYTE
         BCTR  TWKREG2,0                SET BXLE LOOP UPPER LIMIT
         BCT   INPTR,SKPBLK2            AND BEGIN ADDRESS - 1
SKPBLK1  EQU   *
         CLI   D0(INPTR),JBLANK         TEST IF BLANK
         BCR   7,TLINK                  EXIT IF NOT
SKPBLK2  EQU   *
         BXLE  INPTR,TWKREG1,SKPBLK1    ELSE, LOOK UP NEXT COLUMN
         SET   SNOFND,ON                UNTIL ENDATA
         BR    TLINK                    RETURN TO CALLER
         EJECT
*****************************************
*        SET O/P BUFFER LOCATION        *
*****************************************
OPUTL    EQU   *
         ST    RETURN,EDTSVX
         JPUTL FILE=FILE1,BUFREQ=(R11) GET NEXT OUTPUT BUFFER
         L     RETURN,EDTSVX
         ST    RETADR,OUTADR            SAVE BEGIN ADDRESS
         LR    INDEXO,RETADR            JTEXT BASE
         LA    INDEXP,JTHDRLN(,INDEXO)  JTEXT BASE 2
         BR    RETURN                   RETURN TO CALLER
         SPACE 3
*********************************************
*        EDITED TEXT INITIALIZATION         *
*********************************************
HDINIT   EQU   *
         LCR   TWKREG1,INDEXO           LET ALL FIELD POINTERS
         AR    TWKREG1,INDEXP           POINT TO THE DUMMY FIELD
         XC    JTRLI(JTHDRLN+2),JTRLI   CLEAR HEADER
         STH   TWKREG1,JTNMP
         LA    INDEXP,D2(,INDEXP)       BUMP OVER DUMMY FIELD
RESETPTR EQU   *
         MVC   JTOCP(JTSYMCNT-JTOCP),JTNMP
         BR    RETURN                   RETURN TO CALLER
         EJECT
*******************************
******     CONSTANTS     ******
*******************************
         PRINT DATA
ETMOV    MVC   D1(*-*,INDEXP),D0(GSPTR) OFF-THE-LINE MOVE
ARDSRC   DC    A(RDSRC)                 RDSRC ENTRY POINT
ARDSRC05 DC    A(RDSRC05)               RDSRC05 ENTRY POINT
ATRTEST  DC    A(TRTEST)                TRTEST ENTRY POINT
ATRT01   DC    A(TRT01)                 TRT01 ENTRY POINT
ATRT02   DC    A(TRT02)                 TRT02 ENTRY POINT
SRCLEN   DC    F'70'                    DATA PORTION MOVE LENGTH
BEGCOL   DC    F'0'                     BEGIN COLUMN MINUS 1
CONTCHR  DC    F'71'                    CONT CHR COLUMN MINUS 1
SEQCOL   DC    F'72'                    SEQ FLD BEGIN COL MINUS 1
SEQLEN   DC    F'7'                     SEQ FLD MOVE LENGTH
CONTBGN  DC    F'15'                    CONT COLUMN MINUS 1
CONLEN   DC    F'55'                    CONT FLD MOVE LENGTH
*
F15      DC    F'15'                    MASKING CONSTANTS
F31      DC    F'31'                    .
RSTKLEN  DC    AL2(EDRSTK-BDRSTK)       RSTACK LENGTH
CSTKLEN  DC    AL2(EDCSTK-CSTKNOTE)     CSTACK LENGTH
HATT     DC    AL2(JTMTAT-2)            ATTR FLAG CONV BASE V
H32K     DC    H'32767'                 MAXIMUM DIMENSION ALLOWED
H80      DC    H'80'                    STANDARD CARD LENGTH
H40      DC    H'40'                    STANDARD DATA LENGTH
DOTSTAR  DS    0CL2
         DC    AL1(JPERIOD,JASTER)      GENERATED COMMENT STMT
CMABLK   DC    AL1(JCOMMA,JBLANK)       FIELD TERMINATOR
         DS    0H                       HALF WORD ALIGNMENT
FXDHD    DS    0CL20
         DC    AL2(0)                   RECORD LENGTH
PUTFLG   DC    AL1(JPSOP,JPRONLY)       ASSEMBLER OP / PRINT ONLY
         DC    AL1(JTCMNT,J0)           INTERNAL OP CODE
         DC    5AL2(COMIT-FXDHD)        DUMMY POINTERS
         DC    2X'00'                   TWO FIELDS
COMIT    DC    2X'00'                   DUMMY FIELD
COMDTA   EQU   *                        END OF FXDHD
         DS    0H
***********************************************************************
*  STANDARD CATEGORIES AND TYPES CORRESPONDING TO SPECIAL CHARACTERS  *
*                                                                     *
*  INTERNAL CODE MINUS 39.  0 1 2 3 4 5 6 7 8 9 1011                  *
*  SPECIAL CHARACTER        = ( + - * / ) ,   ' & .                   *
QMDTBL   DC            XL12'000000000000000003050200'  QUOTE MODE ARG *
STDTBL   DC            XL12'030406060606030303050203'  STANDARD CATEG *
*TRTSRC  DC            XL12'00040A0B080905022F000003'  TYPE NUMBER    *
TRTSRC   DS    0CL12                                                  *
         DC    AL1(JEQUAL,JTMLPAR,JTMADD,JTMSUB,JTMMULT,JTMDIV)       *
         DC    AL1(JTMRPAR,JTMCOM,JBLANK,JTMSCM,JAMPER,JTMPER)        *
***********************************************************************
         PRINT NODATA
         SPACE 3
         JPATCH  X1A00,FEE
         EJECT
         JCSECT (X1A10=CS2)
**************************************
*        VIRTUAL TEXT BUILDER        *
**************************************
VTENT    EQU   *
         GOIF  METSW,ON=VTENT10         BRANCH IF GOOD M.T. EXISTS
VTENT05  EQU   *
         L     INDEXP,OFPTRSV           ELSE, WIPE OFF MT SO FAR BUILT
         B     VTPUT0                   BUILD V.T.
VTENT10  EQU   *
         GOIF  GAIF,ON=VTENT20          BRANCH IF AIF STATEMENT
         GOIF  GSUBS,OFF=VTENT20        BRANCH IF NO SUBSTITUTION
         BAL   RETURN,MTENT10          ELSE, WRAP UP MT
         LR    INPTR,R1                 KEEP INPTR CURRENT
         OC    JTFLGB,SWITCH8           AND INDICATE SUBSTITUTION
VTENT15  EQU   *
         LR    R0,R12                   SAVE RETURN POINT
         BAL   R3,PFXRENT               END OF M.T.
         DC    AL2(JTMSTRM)             STATEMENT TERMINATOR
         BCTR  INPTR,D0                 BACK UP
         LR    R12,R0                   RESTORE RETURN POINT
VTENT20  SET   (GSUBS,METSW),OFF
         LR    R14,INDEXP               COMPUTE MT LENGTH
         S     R14,OFPTRSV
         STH   R14,JHWORD1              ENTER MT LENGTH
         MVC   D0(L'JHWORD1,INDEXP),JHWORD1
         LA    INDEXP,D2(,INDEXP)
VTPUT0   EQU   *
         L     RCNT,INPUT
VTPUT    EQU   *
         ST    INDEXP,OFPTRSV           SAVE VT BEGIN LOC FOR PTR CALC
         GOIF  JPSOP,OFF=VTPUT02        SUPPRESS VT ON PSEUDO OPS
         CLI   OCSAVE,JTPEND            LOOK ONLY AT GENERATOR OPS,
         BH    VTPUT02                  THOSE BETWEEN ANOP AND PEND
         CLI   OCSAVE,JTANOP            IF NON-GENERATOR OP, PUT
         BL    VTPUT02                  OUT VIRTUAL TEXT EVERY TIME
         GOIF  SPGRMD,ON=VTPUT02        PUT V.T. FOR PRGMR MACRO DEF
         GOIF  SSYSMD,OFF=VTPUT40       BRANCH IF IN OPEN CODE
         GOIF  SXPRTO,OFF=VTPUT50       BRANCH IF INNER CALL STMT
         GOIF  (JMLOGIC,JSYSMAC),NONE=VTPUT60 PUT VT IF MACRO COND'T'NL
VTPUT02  EQU   *                        ASSEMBLY TO BE PRINTED
         L     GSPTR,FPTRSV             RESTORE INPUT FIELD BEGIN ADDR
VTPUT05  EQU   *
         LM    R9,R11,TBGLN
         LA    R14,D1(,GSPTR)           COMPUTE RELATIVE FIELD LOCATION
         SR    R14,RCNT                 IN INPUT WORK BUFFER
         LH    TRTN,H1                  AND TAKE CARE OF CARD COUNTER
VTPUT10  CR    R14,R10                  ARE WE IN THE RIGHT CARD
         BNH   VTPUT20                  YES
         SR    R14,R11                  NO. SUBTRACT COUNT LENGTH
         AH    TRTN,H1                  INCREMENT CARD COUNT BY 1
         B     VTPUT10                  CHECK NEXT CARD
VTPUT20  AR    R14,R9                   ADD PRE-BEGIN STRING LENGTH
         CH    TRTN,H1                  DID WE STOP IN THE 1ST CARD
         BE    VTPUT30                  DON'T ENTER CARD POINTER IF YES
         STC   TRTN,D0(,INDEXP)         ELSE, A ONE-BYTE CARD POINTER
         OI    D0(INDEXP),BIT0          PRECEDING COLUMN POINTER
         LA    INDEXP,D1(,INDEXP)
VTPUT30  STC   R14,D0(,INDEXP)          ENTER COLUMN POINTER
         LA    INDEXP,D1(,INDEXP)
         LR    R15,INPTR                COMPUTE STRING LENGTH
         SR    R15,GSPTR
         STC   R15,D0(,INDEXP)          AND ENTER IT
         BCTR  R15,0                    DECR LENGTH BY 1
         EX    R15,ETMOV                MOVE VT TO OUTPUT BUFFER
         LA    INDEXP,D2(R15,INDEXP)    BUMP TO NEXT AVAILABLE LOCATION
         BR    R12                      EXIT VT RTN
VTPUT40  CLI   OCSAVE,JTMACRO           LOOK ONLY AT OPEN CODE SUBSET
         BE    VTPUT02                  OF GENERATOR OPS
         CLI   OCSAVE,JTSETC            IF NOT IN THAT RANGE, PUT
         BH    VTPUT02                  OUT VIRTUAL TEXT EVERY TIME
         GOIF  JALOGIC,ON=VTPUT02       ALWAYS PUT V.T. IF ASM LOGIC ON
         GOIF  JSYSMAC,OFF=VTPUT60      NO V.T. IF SYS MACS NOT PRINTED
         B     VTPUT02                  PUT V.T. INCASE GENERATED END
VTPUT50  GOIF  (JCALLS,JMLOGIC,JSYSMAC),ANY=VTPUT02 PUT VT IF INNERS TO
VTPUT60  SET   SMISCN,ON                INDICATE NO V.T. OUTPUT
         BR    R12                      BE PRINTED, ELSE, EXIT
         EJECT
***********************************************************************
*  GSCAN SCANS AND CLASSIFIES ALL INPUT SOURCE STATEMENTS EXCEPT      *
*  OPERANDS ON AIF, AGO, SETX, MACRO INSTRUCTION, AND PROTOTYPE       *
*  STATEMENTS. SCAN RESULTS ARE RETURNED IN LOCATION GSUMRY. THE      *
*  FIELD SCANNED IS EDITED INTO VIRTUAL TEXT AND, IF NECESSARY, META  *
*  TEXT FORMATS IN OUTPUT BUFFER.                                     *
*  AT ENTRY GQST IS SET TO ZERO TO START QUOTE STATUS CHECKING        *
*                0 = EVEN NUMBER OF QUOTE FOUND AT EXIT               *
*                1 = ODD NUMBER OF QUOTE FOUND AT EXIT                *
*  GMET IS SET ON WHEN A META TEXT IS BUILT FOR A FIELD               *
*  RESULTS RETURNED FROM TRT ARE                                      *
*                R1 = TERMINATING CHARACTER ADDRESS                   *
*                R3 = CATEGORY NUMBER OF THE TERMINATING CHARACTER    *
*                R10= TYPE FLAG NUMBER OF THE TERMINATING CHARACTER   *
*                R15= STRING/SYMBOL MOVE LENGTH                       *
*                                                                     *
*  LINKAGE IS  BAL  RETURN,GSCAN                                      *
***********************************************************************
         SPACE 3
GSCAN    EQU   *
         ST    INPTR,FPTRSV             SAVE BEGIN ADDRESS FOR V.T.
         ST    INDEXP,OFPTRSV
GSCAN1   EQU   *
         ST    INPTR,MEZZOPTR           SAVE MEZZO POINTER
         ST    RETURN,EDTSVX            SAVE RETURN POINT
         MVI   GSUMRY,D0                CLEAR SCAN RESULT BYTE
GSCNMOP  EQU   *
         GOIF  GQST,ON=GSCQMD           BRANCH IF IN QUOTE MODE
         L     LINK,ATRTEST             POINT TO TRTEST
         BALR  RETURN,LINK              GO TO TRTEST
GSCFAN   AR    R3,R3                    DOUBLE THE CATEG NUMBER
         LH    R14,GSCTBL(R3)           PICK UP REL ENTRY
         B     GSCTBL(R14)              AND FAN OUT
GSCQMD   MVC   SPECHAR(L'QMDTBL),QMDTBL STOP ON QT, &, BLANK, ENDATA
         LA    PARM,D2                  DON'T DO SYN STG SEARCH
         LA    RETURN,GSCFAN            GET RETURN POINT
         L     LINK,ATRT02              POINT TO TRT02
         BR    LINK                     GO TRT
         EJECT
GSCTBL   EQU   *                        CATEGORIES
         DC    AL2(GSADV-GSCTBL)        0 = DECIMAL
         DC    AL2(GSALFA-GSCTBL)       1 = ALPHAMERIC
         DC    AL2(GSAMPR-GSCTBL)       2 = AMPERSAND
         DC    AL2(GBLK-GSCTBL)         3 = ,=.) OR BLANK
         DC    AL2(GSCIMP-GSCTBL)       4 = (
         DC    AL2(GQOTS-GSCTBL)        5 = QUOTE
         DC    AL2(GSCIMP-GSCTBL)       6 = +-*/
         DC    AL2(LTRLQT-GSCTBL)       7 = L' I' S' K' N'
         DC    AL2(LTRQT-GSCTBL)        8 = X' B' C' SDT
         DC    AL2(LTRQTIN-GSCTBL)      9 = T'
         DC    AL2(GSALFA-GSCTBL)       10 = BOOLEAN OPERATOR
         DC    AL2(GSALFA-GSCTBL)       11 = RELATIONAL OPERATOR
         DC    AL2(GENDT-GSCTBL)        12 = NON-ASSEMBLER
         EJECT
         SPACE 3
GENDT    EQU   *
         C     INPTR,ENDATA             HAVE WE PAST ENDATA
         BNL   GSVTENT                  YES, WRAP UP VT
GSCIMP   OI    GSUMRY,RMPURE            INDICATE IMPURITY
         LA    INPTR,D1(,INPTR)         BUMP POINTER
         B     GSCNMOP                  AND PLOD ONWARD
GSS10    LR    INPTR,R1                 PLOD ONWARD
         B     GSCIMP
*
GBLK     EQU   *
         CLI   D0(INPTR),JBLANK         TEST IF BLANK TERMINATES
         BE    GBLK10                   YES
         CLI   D0(INPTR),JPERIOD        DID PERIOD TERMINATE
         BNE   GSCIMP                   BRANCH IF NOT
*                                       ELSE PRAY FOR A S.S.
GSSSYM   EQU   *
         TM    GSUMRY,BITFF             HAS ANYTHING BEEN DONE
         BNZ   GSCIMP                   BRANCH IF YES
         GOIF  SKPNAME,ON=GSCIMP        BRANCH IF SKIPPING TO OP CODE
         LA    INPTR,D1(,INPTR)         FORGET THE DOT FOR A WHILE
         LA    PARM,D2                  GO TRT THE TRAILING STRING
         L     LINK,ATRT02              POINT TO TRT02
         BALR  RETURN,LINK              W/O SYNTACTIC STRING SEARCH
         BCT   R3,GSS10                 CONTINUE IF NOT AN STRING
         CLI   D0(INPTR),JA             AND DIGIT HEAD IS
         BL    GSS10                    UNDESIRABLE. EDIT AS C STRING
         CLI   D0(R1),JBLANK            AND TERMINATOR MUST BE A BLANK
         BNE   GSS10                    ELSE EDIT AS C STRING
         GOIF  SENAME,ON=GSS20          BRANCH IF EDITING NAME FIELD
         GOIF  SEOPND,OFF=GSS10         BRANCH IF NOT EDITING OPERAND
         CLI   OCSAVE,JTAGO
         BE    GSS20                    BRANCH IF AGO STATEMENT
         CLI   OCSAVE,JTAIF
         BNE   GSS10                    BRANCH IF NOT AIF STMT
GSS20    EQU   *
         BCTR  INPTR,0                  REMEMBER THE FORGOTTEN DOT
         LA    R15,D1(,R15)             AND ITS LENGTH
         CH    R15,H8                   TEST IF LENGTH LE 8
         BNL   GSS10                    EDIT AS C STRING IF GE 8
         MVI   GSUMRY,RSSYM             SET ON SS INDICATOR
         BAL   RETURN,MTENT             GO MAKE D ENTRY
GSADV    AR    INPTR,R15
         B     GSCIMP                   ADVANCE POINTER
GSALFA   EQU   *
         CLI   D0(R1),JBLANK            TEST IF TERMINATOR A BLANK
         BNE   GSADV                    ADVANCE POINTER AND CONT SCAN
         GOIF  SKPNAME,ON=GSA05         BRANCH IF SKIPPING NAME FIELD
* CHARACTER STRING WILL NOT BE BUILT IN MT UNTILL ENCOUNTERED
* A TRAILING BLANK OR AMPERSAND
         TM    GSUMRY,BITFF             ANYTHING DONE YET
         BNE   GSA10                    BRANCH IF YES
         CH    R15,H8                   IT'S AN OS. HOW ABOUT LENGTH
         BNL   GSA10                    LONGER THAN 8 IS EDITED AS STG
         MVI   GSUMRY,ROSYM             A GOOD OS
         BAL   RETURN,MTENT             GO MAKE D ENTRY
GSA05    LR    INPTR,R1                 BUMP TO THE TERMINATOR
         B     GBLK10                   WHICH IS A BLANK
GSA10    GOIF  METSW,OFF=GSA05          BRANCH IF THUS FAR NO MT BUILT
         GOIF  GQST,ON=GSADV            TOO EARLY TO BUILD MT IF IN QT
         BAL   RETURN,MTENT10           ELSE FINISH BUILDING MT
         B     GSA05                    GO TO FIELD TERMINATOR
GSAMPR   EQU   *
         CLI   D1(INPTR),JAMPER         TEST IF DOUBLE AMPERSAND
         BNE   GSM10                    BRANCH IF NOT
         LA    INPTR,D1(,INPTR)         ELSE, EDIT AS C STRING
         B     GSCIMP                   '&&' EDITED AS CHARACTER STRING
GSM10    EQU   *
         GOIF  (SKPNAME,PROTOCAL),ANY=GSCIMP BR IF SKIPPING TO OP CODE
         CLI   OCSAVE,JTOPSYN           VAR SYM IN NAME/OPND OF OPSYN
         BNE   GSM15                    NO, GO TO DIR ROUTINE
         GOIF  SNMFND,OFF=ILOPSYN       VAR SYM IN OPND FIELD OF OPSYN
* VAR SYMBOL IN NAME FIELD OF OPSYN IS DISALLOWED--IT'S SCANNED AND
*  ENTERED INTO THE TEXT, BUT THE DIRECTORY ROUTINE IS BYPASSED--
*  THE ERROR ITSELF WILL BE DETECTED IN THE OPSYN ROUTINE
         SET   RVSYM,ON                 ERR-VAR SYM IN OPSYN NAME FIELD
         LA    INPTR,D1(,INPTR)         BUMP OVER '&' AND SCAN TO END
         LA    R10,D2                   OF VAR SYM, NO SYNTACTIC SCAN
         L     LINK,ATRT01              POINT TO TRT01
         BALR  RETURN,LINK              SCAN THRU END OF SYM, ISOLATE
         B     GSA05                    NOW, GO PUT OUT THE ISOLATED SY
GSM15    EQU   *
         BAL   RETURN,MTENT10           GO OUTPUT PRIOR MT
         LR    INPTR,R1                 UPDATE INPTR
         BAL   RETURN,VARSYM            SCAN V.S. AND BUILD MT
* VARSYM ROUTINE SHOULD INDICATE RVSYM AND SET ON METSW, MAKE D ENTRY
* AND BUILD MT. AFTER RETURN, UPDATE INPTR TO NEXT SCAN LOCATION.     *
         LR    INPTR,R1                 POINT TO NEXT SCAN LOCATION
GSM20    EQU   *
         MVI   ATTRSV,D0                RESET SYSLIST FLAGS
         CLI   D0(INPTR),JPERIOD        TEST IF TERMINATOR A DOT
         BNE   GSCNMOP                  BRANCH IF NOT
         LA    INPTR,D1(,INPTR)         YES, IT IS A CONCATENATION
         ST    INPTR,MEZZOPTR           UPDATE POINTERS AND
         B     GSCNMOP                  CONTINUE SCANNING
GBLK10   EQU   *
         GOIF  GQST,OFF=GSQXT           THAT'S END OF FLD IF NOT QT MD
         B     GQOTLP                   ELSE KEEP SCANNING
         SPACE
LTRLQT   CLI   D0(INPTR),JL             TEST IF L' TYPE
         BNE   LTRQTIN                  NOT WANTED IF NOT
         CLI   D2(INPTR),JA             LOOK AHEAD FOR ....
         BL    LTRQT                    POSSIBLE LONG FORM
         CLI   D2(INPTR),JAT            IF FOLLOWED BY ALPHA
         BNH   GSS10                    FORGET IT
         CLI   D2(INPTR),JASTER
         BE    GSS10                    INCLUDING L'*
         CLI   D2(INPTR),JAMPER         IF FOLLOWED BY AMPER   @AX16943
         BE    GSS10                    PROCEED CHECKING       @AX16943
LTRQTIN  GOIF  (SKPNAME,PROTOCAL),ANY=GSS10
         SPACE
LTRQT    OI    GSUMRY,RMPURE            IMPURITY
         LA    INPTR,D1(,INPTR)         BUMP POINTER
         SPACE
GQOTS    SET   GQST,FLIP                FLIP THE ODD QUOTE CHECKER
         OI    GSUMRY,RQTSTG            INDICATE IN QUOTE MODE
         GOIF  SEOPCD,OFF=GQOTLP        BR IF NOT OPCODE       @OY04864
         GOIF  GQST,OFF=GQOTLP          BR IF NOT ODD QOUTE MD @OY04864
         CLI   D1(INPTR),JAMPER         ONLY '& VALID FOR-     @OY04864
         BE    GQOTLP                   QOUTE IN OPCODE        @OY04864
         SET   GQST,OFF                 RESET ODD QOUTE CHK    @OY04864
         GOIF  SKPNAME,ON=GQOTERR       BR IF NO NAME FIELD    @OY04864
         BAL   R12,VTENT                ELSE, LOG VT           @OY04864
GQOTERR  B     INVOP                    LOG HARD ERROR         @OY04864
GQOTLP   LA    INPTR,D1(,INPTR)         BUMP POINTER
         B     GSCNMOP                  KEEP SCANNING
         SPACE
GSVTENT  L     INPTR,ENDATA             BE SURE PNT TO END     @OX07300
         GOIF  GQST,ON=ODDQT            ERR IF NO ENDING QUOTE @OX07300
         SPACE
GSQXT    GOIF  SKPNAME,ON=GSQXT1        BRANCH IF SKIPPING NAME FIELD
         BAL   R12,VTENT                ELSE, LOG VT
         SPACE
GSQXT1   ST    INPTR,FPTRSV             SAVE NEXT LOC TO BE EDITED
         L     RETURN,EDTSVX            RESTORE RETURN POINT
         BR    RETURN                   RETURN
         SPACE
ODDQT    LR    R0,R1
         BAL   TLINK,ABSERR             LOG ERROR
         DC    AL1(SEV35)               .
         DC    AL1(ERR35)               NO TERMINATING QUOTE
         LR    R1,R0
         SET   GQST,OFF
         B     GSQXT                    GO LOG VT
         EJECT
***********************************************************************
* MTENT ROUTINE ONLY ENTERS ORDINARY SYMBOLS, SEQUENCE SYMBOLS AND
* CHARACTER STRINGS. VARIABLE SYMBOLS ARE ENTERED IN VARSYM ROUTINE.
* ORDINARY SYMBOL DEFINITION AND SEQUENCE SYMBOL DEFINITION ARE ENTERED
* INTO DIRECTORY AFTER THE EDITED TEXT FOR THE STATEMENT HAS BEEN
* COMPLETELY BUILT. SWITCH SDENT IS DESIGNED FOR SUCH PURPOSE.
* THE REST OF THE SYMBOLS ARE ENTERED INTO DIRECTORY AS SOON AS A
* SYMBOL IS RECOGNIZED AND FOUND TO BE A VALID ONE.
***********************************************************************
         SPACE 3
MTENT    ST    RETURN,EDTSVY
         TM    GSUMRY,ROSYM             TEST IF O.S.
         BO    MTTOS                    BRANCH IF YES
         TM    GSUMRY,RSSYM             TEST IF S.S.
         BNO   MTCSTG                   ASSUME C STRING IF NOT S.S.
         SPACE
MTTSS    GOIF  SENAME,OFF=SSRTEMP  ******** T ********
         MVI   SDENTR,SEQSYMBD          SAVE SS DEFINITION INDEX
         ST    R15,NAML                 SAVE NAME FIELD MOVE LENGTH
         ST    INPTR,NAMP               AND POINTER FOR
MTSVPTR  SET   SDENT,ON                 POINT OF DEFINITION
         SPACE
MTSVRTN  L     RETURN,EDTSVY            RESTORE POINTER
         BR    RETURN                   THEN RETURN
***********************************************************************
         SPACE
SSRTEMP  GOIF  SEOPND,OFF=MTCSTG        BRANCH IF NOT IN OPERAND
         MVI   DDNDX1,SEQSYMBR          SET UP INDEX FOR BR TO DIR RTN
         LR    PARM,INPTR               POINT TO THE SYMBOL
         LR    PARAM2,TWKREG2           AND THE LENGTH
         BAL   R3,DIRENT                LOG SS REFERENCE
         MVC   D0(D4,INDEXP),D0(R11)    BUILD MT
         LA    INDEXP,DENTLNG(,INDEXP)  BUMP 2 EXTRA BYTES FOR GEN'TOR
         B     METON                    GO SET METSW ON
***********************************************************************
MTTOS    GOIF  SENAME,OFF=MTTOS10       BRANCH IF NOT NAME FIELD
         GOIF  SMDEF,ON=GSA05           NO D ENTRY IF IN MACRO DEF.
         MVI   SDENTR,ORDSYMBD          SAVE OS DEF INDEX
         ST    INDEXO,NAMP              AND BEGIN POINT OF ET
         B     MTSVPTR                  GO TO RETURN
         SPACE
MTTOS10  GOIF  SEOPCD,OFF=MTCPY         BRANCH IF IN OPERAND
* MAKE IOC AND FLAGA ENTRY AFTER RETURN TO MAINLINE LOGIC
         LR    PARM,INPTR               GET OP CODE FIELD ADDRESS
         LR    PARAM2,TWKREG2           AND ITS MOVE LENGTH
         MVI   DDNDX1,OPERCODE          INDICATE OP CODE SEARCH
         BAL   R3,DIR10                 GO
         ST    PARAM2,OCPTRSV           SAVE IOC POINTER
         MVI   OCSAVE,D0                ZERO IN CASE OF MACRO CALL
         TM    IOCID,BIT0+BIT1          TEST IF MACRO CALL
         BZ    MTTOS11                  BRANCH IF MACRO CALL/NAME
         BO    MTSVRTN                  BRANCH IF TWO BYTE OP CODE
         MVC   OCSAVE,D1(PARAM2)        PRESERVE ASSEMBLER OP CODE
         B     MTSVRTN                  GO TO EXIT
         SPACE
MTTOS11  GOIF  SXPRTO,ON=MTSVRTN        PROTOTYPE IS NOT WANTED
         MVC   D0(D3,INDEXP),D0(PARAM2) MAKE MT ENTRY IF MACRO CALL
         LA    INDEXP,D3(,INDEXP)       AND ADVANCE POINTER
METON    SET   METSW,ON                 INDICATE META TEXT BUILT
         B     MTSVRTN                  GO TO RETURN
         SPACE
MTCPY    GOIF  SCOPY,OFF=MTCSTG         BRANCH IF NOT EDITING COPY STMT
         MVI   COPYCODE,JBLANK          YES. CLEAR COPY CODE SAVE AREA
         MVC   COPYCODE+1(L'COPYCODE-1),COPYCODE
         EX    TWKREG2,MVCOPY           AND SAVE COPY CODE
         BR    RETURN                   DO NOT BUILD MT
MTCSTG   EQU   *                        BUILD C STRING IN MT
MTENT10  L     INPTR,MEZZOPTR
         LR    R14,R1
         SR    R14,INPTR                TEST IF ANYTHING TO BE PUT
         BCR   BZ,RETURN                BRANCH IF NO
         MVI   D0(INDEXP),JTMCS         ENTER FLAG
         STC   R14,D1(,INDEXP)          AND ENTER IT
         LA    INDEXP,D2(,INDEXP)       BUMP POINTER
         BCTR  R14,0                    MAKE IT MOVE LENGTH
         EX    R14,MTXTMV               MOVE STRING TO MT
MTEXIT   LA    INDEXP,D1(R14,INDEXP)    BUMP TO NEXT AVAILABLE LOCATION
         ST    R1,MEZZOPTR              UPDATE MEZZOPTR
         BR    RETURN                   RETURN
MTXTMV   MVC   D0(1,INDEXP),D0(INPTR)   OFF-THE-LINE MOVE
MVCOPY   MVC   COPYCODE(0),INPOPR       OFF-THE-LINE MOVE
         EJECT
***********************************************************************
*  RECURSIVE ROUTINE TO SCAN VARIABLE SYMBOLS
*  THE LINKAGE IS BAL RETURN,VARSYM
***********************************************************************
         SPACE 3
VARSYM   BAL   R12,RENTSTK              MAKE RECURSION STACK ENTRY
*BUMP THE POINTER PAST THE '&' FOR THE DIRECTORY ROUTINE
         ST    INPTR,TPSAVE             SAVE BEGIN PT FOR SNAP
         LA    INPTR,D1(,INPTR)         BUMP POINTER
         LA    R10,D2                   NO SYNTACTIC STRING SEARCH
         L     LINK,ATRT01              POINT TO TRT01
         BALR  RETURN,LINK              GO ISOLATE V.S. TRAILER WHICH
         CH    R3,H1                    MUST BE A/N STRING
         BNE   ILGVS                    ELSE, LOG ERROR
         CH    R15,H6                   AND LENGTH MUST BE LE 8
         BH    ILGVS                    ELSE, LOG ERROR
* MAKE DIRECTORY ENTRY FOR VS - DISTINGUISH DEF FROM REF FIRST
* AT ENTRY R11 CONTAINS THE MOVE LENGTH (INCL. &) OF THE SYMBOL
*          R10 POINTS TO THE SYMBOL  /&NAME/(/D/)/ WHERE DIMENSION
*              IS OPTIONAL
* ON RETURN  XIJ TELLS X1A THROUGH FLGBYT WHETHER THE SYMBOL IS A
* SYSTEM VARIABL, DIMENSIONED AND WHETHER IT IS SYSLIST
*          R11 POINTS TO A 6-BYTE LOCATION CONTAINING /F/PTR/DM/
* IF ERROR FOUND IN D ROUTINE ON THE V.S. ENTERED  CONCODE WILL TELL.
*
*          SYSECT/SYSNDX/SYSLIST IN OPEN CODE IS RETURNED WITH ERROR
*          CODE IN CONCODE (ERROR #6- VS NOT PREVIOUSLY DEFINED.)
         LR    PARAM2,TWKREG2           GET SYMBOL LENGTH
         LR    PARM,INPTR               POINT TO THE SYMBOL
         MVI   DDNDX1,VARBSYMR          SET UP INDEX FOR BR TO DIR RTN
         GOIF  SGBLCL,OFF=VSDENT        BRANCH IF YES
         MVC   FLGBYT(L'FLGBYT),FLAGBT  REDEFINE FLGBYT
         LR    INPTR,R1                 SKIP OVER V.S.
         CLI   D0(INPTR),JLPARN         TEST IF LEFT PAREN FOLLOWS
         BNE   VSDNDX                   NO, UNDIMENSIONED
         BAL   RETURN,DSCAN1            YES, GO SCAN DSDT
         B     ILDIM                    ILLEGAL DIMENSION
         LTR   TWKREG1,TWKREG1          DIMENSION OF 0 IS NOT ALLOWED
         BNP   ILDIM                    ILLEGAL DIMENSION
         CLI   D0(INPTR),JRPARN         TEST DELIMITER FOR RIGHT PAREN
         BNE   ILDIM                    ERROR IF NOT
         SET   VDIM,ON                  INDICATE DIMENSIONED
         LA    INPTR,D1(,INPTR)         BUMP OVER R-PAREN
         CH    TWKREG1,H32K             NOR CAN IT BE GT 32K
         BH    HIDIM                    ERROR, MAX DIMENSION EXCEEDED
         STH   TWKREG1,JHWORD1          TELL IT TO DIRECTORY ROUTINE
VSDNDX   EQU   *
         LR    R1,INPTR                 UPDATE POINTER
         L     INPTR,OPNDPTR            IN CASE OF BACK UP
         MVI   DDNDX1,VARBSYMD          INDICATE DEFINITION
VSDENT   BAL   R3,DIRENT                WHATEVER IT IS GO MAKE D ENTRY
         TM    DERRCD,BITFF             TEST IF ERROR FOUND
         BNZ   CLEANUP                  WRAP UP STATEMENT
         GOIF  SENAME,ON=VS10           BR IF EDIT NAME FIELD   OY06129
         MVI   GSUMRY,RVSYM             INDICATE V.S.           OY06129
VS10     OI    GSUMRY,RVSYM             INDICATE V.S.           OY06129
         GOIF  SGBLCL,ON=REXSTK         EXIT IF IT WAS DEFINITION
         L     R14,RAVSP
         MVC   RSTKVST(L'FLGBYT),FLGBYT SAVE FLGBYT
         NI    ATTRSV,D0                CLEAN UP ATTRSV
         MVC   D0(D6,INDEXP),D0(R11)    ENTER VS REF MT
         CLI   FLGBYT,XDMSLS            TEST IF UNSUBSCRIPTED SYSLIST
         BNE   VS20                     BRANCH IF NOT
         XC    D4(D2,INDEXP),D4(INDEXP) DUMMY UP DIMENSION BYTES
VS20     EQU   *
         LA    INDEXP,DENTLNG(,INDEXP)  BUMP POINTER
         GOIF  VDIM,OFF=VSXIT           EXIT IF NOT DIMENSIONED
         LA    INPTR,D0(R15,INPTR)      BUMP POINTER
         BAL   R3,PFXRENT               TELL POSTFIXER
         DC    AL2(JTMDIM)              IT IS DIMENSIONED
         BAL   R3,PFXRENT               LOG L-PAREN
         DC    AL2(JTMLPAR)             LEFT PAREN
         BAL   R12,APARCT               UP PAREN COUNT
         MVI   MCALL,MCLA               INDICATE SCAN AS SETA
         ST    INPTR,TPSAVE1            SAVE FOR SNAP           OX00224
         MVC   JHWORD2(L'PARMSTAT),PARMSTAT SAVE DMIENT         OX00411
         SET   DMIENT,OFF               CLEAR DMIENT            OX00411
         BAL   RETURN,METASCAN          SCAN FIRST SUBSCRIPT
         L     R14,RAVSP
         OI    RSTKATR,AT1              ASSUME SINGLE SUBSCRIPT
         CLI   D0(INPTR),JCOMMA         IS TERMINATOR A COMMA
         BNE   VS25                     BRANCH IF NOT           OX05801
         TM    RSTKVST,VSLS             ONLY SYSLIST MAY HAVE DOUBLE
         BZ    VS32                     SUBSCRIPT, ELSE ERROR  @OX06626
         OI    RSTKATR,ATSUBS           OK, GOOD DOUBLE SUBSCRIPT
         BAL   R3,PFXRENT               PUT COMMA IN POSTFIXER STACK
         DC    AL2(JTMCOM)              COMMA
         BAL   RETURN,METASCAN          SCAN SECOND SUBSCRIPT
VS25     EQU   *                                                OX05801
         TM    JHWORD2,DMIENT           ENTRY FROM MIPROTO      OX00411
         BZ    VS30                     BR IF NOT               OX00411
         SET   DMIENT,ON                SET DMIENT              OX00411
VS30     EQU   *
         CLI   D0(INPTR),JRPARN         TEST IF RIGHT PAREN TERMINATES
         BNE   VS32                     LOG ERROR IF NOT       @0X06626
         BAL   R3,PFXRENT               LOG R-PAREN
         DC    AL2(JTMRPAR)             RIGHT PAREN
         BAL   R12,DPARCT               AND DECREMENT PAREN COUNT
         LR    R1,INPTR                 UPDATE POINTER
VSXIT    EQU   *
         SET   (METSW,GSUBS),ON         INDICATE SUBSTITUTION/MT BUILT
         ST    R1,MEZZOPTR              UPDATE MEZZO POINTER
         B     REXSTK                   GO TO RECURSIVE EXIT
VS32     EQU   *
         TM    JHWORD2,DMIENT           ENTRY FROM MIPROTO     @OX06626
         BZ    INVSUBS                  SUBSCRIPT ERROR        @OX06626
         SET   DMIENT,ON                                       @OX06626
         B     INVSUBS                  ERROR FROM MI          @OX06626
         EJECT
*   METASCAN DOES SYNTACTIC SCAN FOR SETA, SETB, SETC, AIF AND ACTR
*   OPERANDS.  ACTR OPERAND IS SCANNED AS SETA OPERAND, AND
*   AIF OPERAND IS SCANNED AS SETB OPERAND.
*   AT ENTRY, REGISTERS 5,9,11,12,14 ARE AVAILABLE.
*   REGISTER  5 IS USED AS MTABLE INDEX. TRANPARENT THROUGH ALL
*               RECURSIVE CALLS.
*   REGISTER 9 IS USED FOR RETURN LINKAGE ON EACH RECURSIVE CALL.
*   REGISTER 12 POINTS TO CURRENT ENTRY IN MTABLE.
*   REGISTERS 11 AND 14 ARE SCRATCH REGISTERS.
*   ENTRY CODE MCALL INDICATES THE TYPE OF SCAN TO BE MADE: SETA,
*               SECT, OR OTHERS.
*   EXIT CODE IN REG 3 AS FOLLOWS
*                0 = SIMPLE STATE
*                1 = COMPLEX STATE
*                2 = SETA EXPRESSION
*                3 = SETC EXPRESSION
*
*   LINKAGE IS BAL  RETURN,METASCAN
         SPACE 3
METASCAN EQU   *
         BAL   R12,RENTSTK              ENTER VIA RECURSIVE ENTRY
         SET   METSW,ON                 ASSUME THERE WILL BE M.T.
         SR    MTBLNDX,MTBLNDX          INIT. INDEX OF ZERO
         B     MSCVRT                   GO TEST FLAG
*        TRANSITION TO NEW STATE
*        ***********************
MSADV    LA    MTBLNDX,D1(MTBLNDX)      ADVANCE INDEX
MSCVRT   LA    MTBLENT,MTABLE(MTBLNDX)  CONVERT TO ABSOLUTE ADDRESS
         TM    D0(MTBLENT),EXNXNT       TEST TYPE OF FLAG IN MTABLE
         BO    MEXFR                    EXECUTE THE LIST THAT FOLLOWS
         BM    MCATEG                   MATCH TRT CATEG W/ THAT IN TBL
         L     LINK,ATRTEST             POINT TO TRTEST
         BALR  RETURN,LINK              TRT STRING AT INPTR
         B     MSADV                    GO FIND OUT WHAT TO DO NEXT
*   MATCH TRT CATEG AGAINST CATEG IN MTABLE FOR RIGHT PATH
*   ******************************************************
MCATEG   IC    TWKREG1,D0(,MTBLENT)     OBTAIN CURRENT LIST CATEG ENTRY
         N     TWKREG1,F15              MASK OUT UNWANTED BITS
         CR    TWKREG1,R3               COMPARE AGAINST TRT CATEGORY
         BE    MEXFR                    TRANSFER INTO ACTION IF MATCH
         IC    TWKREG1,D0(,MTBLENT)     ELSE, TRY NEXT LIST
         SRL   TWKREG1,D4               ISOLATE LENGTH OF CURRENT LIST
         LA    MTBLNDX,D0(TWKREG1,MTBLNDX) COMPUTE NEXT LIST ADDRESS
         B     MSCVRT                   GO CONVERT INTO ABSOLUTE ADDR
*        EXECUTE CURRENT LIST AT MTBLNDX
*        *******************************
MEXFR    LA    MTBLNDX,D1(MTBLNDX)      ADVANCE POINTER
MEXFR1   IC    TWKREG1,MTABLE(MTBLNDX)  PICK UP ROUTINE NUMBER FOR
         N     TWKREG1,F31              COMPUTED GO TO BY MASK OUT
         AR    TWKREG1,TWKREG1          UNWANTED BITS THEN DOUBLE IT
         LH    TWKREG1,MBRTBL-D2(TWKREG1) PICK UP REL ADDRESS
         B     MBRTBL(TWKREG1)          FAN OUT TO ABSOLUTE ROUTINE ADR
         EJECT
*   METASCAN BRANCH TABLE
         SPACE 3
MBRTBL   EQU   *
MBTA     DC    AL2(ESETA-MBRTBL)        .
MBTC     DC    AL2(ESETC-MBRTBL)        .
MBTBLK   DC    AL2(EBLANK-MBRTBL)       .
MBTBOP   DC    AL2(DBLOP-MBRTBL)        .
MBTARE   DC    AL2(ARENT-MBRTBL)        .
MBTARE1  DC    AL2(ARENT10-MBRTBL)      .
MBTSTC   DC    AL2(DSETC-MBRTBL)        .
MBTVBOP  DC    AL2(DVBLOP-MBRTBL)       .
MBTAOP   DC    AL2(DAROP-MBRTBL)        .
MBTROP   DC    AL2(DRELOP-MBRTBL)       .
MBTATM   DC    AL2(ARTERM-MBRTBL)       .
MBTDUP   DC    AL2(DUPC-MBRTBL)         .
MBTATR   DC    AL2(DATTR-MBRTBL)        .
MBTVSM   DC    AL2(EVSYM-MBRTBL)        .
MBTXSA   DC    AL2(XSA-MBRTBL)          .
MBTXSB   DC    AL2(XSB-MBRTBL)          .
MBTXSC   DC    AL2(XSC-MBRTBL)          .
MBTXSX   DC    AL2(XSX-MBRTBL)          .
MBTINV   DC    AL2(ILGLXP1-MBRTBL)      .
MBTILG   DC    AL2(ILGLXPBR-MBRTBL)       .
MBTCPR   DC    AL2(DCPR-MBRTBL)         .
MBTDSDT  DC    AL2(BDSDT-MBRTBL)        .
DCPR     EQU   MSADV
         SPACE 3
*   BRANCH TABLE ENTRY SEQUENCE EQUATED
ETSETA   EQU   (MBTA-MBRTBL)/2+1        TEST SETA ENTRY
ETSETC   EQU   (MBTC-MBRTBL)/2+1        TEST SETC ENTRY
ETBLANK  EQU   (MBTBLK-MBRTBL)/2+1      TEST IF BLANK
ETBOOL   EQU   (MBTBOP-MBRTBL)/2+1      TEST IF BOOLEAN OPERATOR
EPSETA   EQU   (MBTARE-MBRTBL)/2+1      L-PAREN RECURSIVE CALL
EPSETBE  EQU   (MBTARE1-MBRTBL)/2+1     L-PAREN RECURSIVE CALL
EPSETC   EQU   (MBTSTC-MBRTBL)/2+1      PROCESS SETC EXPR
EPMBOOL  EQU   (MBTVBOP-MBRTBL)/2+1     PROCESS BOOLEAN OPERATOR
EPAROP   EQU   (MBTAOP-MBRTBL)/2+1      PROCESS ARITHMETIC OPERATOR
EPRELOP  EQU   (MBTROP-MBRTBL)/2+1      PROCESS RELATIONAL OPE-ATOR
EPTRMA   EQU   (MBTATM-MBRTBL)/2+1      PROCESS ARITHMETIC TERM
EPDUPE   EQU   (MBTDUP-MBRTBL)/2+1      PROCESS DUPLICATION FACTOR-SETC
EPATTR   EQU   (MBTATR-MBRTBL)/2+1      PROCESS ATTRIBUTE NOTATION
EPVSYM   EQU   (MBTVSM-MBRTBL)/2+1      PROCESS VARIABLE SYMBOL
EXITA    EQU   (MBTXSA-MBRTBL)/2+1      ARITHMETIC EXIT
EXITB    EQU   (MBTXSB-MBRTBL)/2+1      BOOLEAN(COMPLEX) EXIT
EXITC    EQU   (MBTXSC-MBRTBL)/2+1      SETC EXIT
EXITX    EQU   (MBTXSX-MBRTBL)/2+1      UNCATEGORIZED EXIT
EPDSDT   EQU   (MBTDSDT-MBRTBL)/2+1     DSDT IN SETB OPND PAREN'D
EPINVLD  EQU   (MBTINV-MBRTBL)/2+1      INVALID OPERAND FORMAT
EPILXP   EQU   (MBTILG-MBRTBL)/2+1      ILEGAL LOGICAL OPERATOR
EXCPR    EQU   (MBTCPR-MBRTBL)/2+1      EXECUTE COMPARISON
*
EXTRT    EQU   0                        EXECUTE TRANSLATE&TEST
EXNXNT   EQU   255                      EXECUTE NEXT ENTRY
         EJECT
*        TRANSITION TABLE WHICH DRIVES METASCAN
         SPACE 3
MTABLE   EQU   *
STATE0   EQU   *
         DC    AL1(EXTRT)               TRANSLATE&TEST
         DC    AL1(EXNXNT)              EXECUTE NEXT ENTRY
         DC    AL1(ETSETA)            1 TEST IF SETA ENTRY
         DC    AL1(SSTXA)               BRANCH IF YES
         DC    AL1(ETSETC)            2 TEST IF SETC ENTRY
         DC    AL1(SSTXC)               BRANCH IF YES
         DC    AL1(ETBLANK)           3 TEST IF BLANK-SCAVENGE IF YES
         DC    AL1(SSTATE0)             THEN START ALL OVER
*             ... ELSE, ASSUME SETB ENTRY ...
         DC    AL1(EXCPR)             4 CPR NEXT ENTRY VS TRT'D CATEG
         DC    AL1(3*16+10)             TEST IF BOOLEAN OPERATOR
         DC    AL1(128+ETBOOL)          YES-BUT HAS TO BE 'NOT'
         DC    AL1(SSTATE0)             YES. GO TRT NEXT TERM
         DC    AL1(5*16+0)              IS IT PAREN'D DSDT
         DC    AL1(EPDSDT)              POSSIBLY, LOOK INTO IT
         DC    AL1(SSTBOPY)             SURE IT IS
         DC    AL1(SSTMOP)              NO, TRY ARITH EXPR
*   IF NOT 'NOT', LOG ERROR, NO RETURN, GIVE UP SCANNING.
STATE1   DC    AL1(EXTRT)               TRANSLATE&TEST
*
STXA     EQU   *                        SETA EXPRESSION
         DC    AL1(7*16+4)              TEST IF L-PAREN
         DC    AL1(EPSETBE)             EDIT IF YES, THEN...
         DC    AL1(SSTOP)               RETURN HERE IF SIMPLE (V.S.)
         DC    AL1(SSTBOP)              RETURN HERE IF COMPLEX (BOOL)
         DC    AL1(SSTMOP)              RETURN HERE IF SETA EXPR
         DC    AL1(SSTERR1)             RETURN HERE IF SETC EXPR(ERROR)
         DC    AL1(SSTDUP)              RETURN HERE IF DUP FACTOR      X
                                        FOUND IN COMPLEX EXPRESSION
*
         DC    AL1(EXNXNT)              EXEC NEXT ENTRY
         DC    AL1(ETSETA)              TEST IF SETA ENTRY
         DC    AL1(SSTMA)               BRANCH IF SETA ENTRY
         DC    AL1(EXCPR)               ELSE, COMPARE NEXT ENTRY
         DC    AL1(3*16+2)              TEST IF AMPERSAND
         DC    AL1(EPVSYM)              BRANCH IF YES...
         DC    AL1(SSTOP)               THEN TRT NEXT OPERATOR
************************************************************
STXC     EQU   *                        SETC EXPRESSION
         DC    AL1(3*16+9)              TEST IF T' NOTATION
         DC    AL1(EPATTR)              EDIT IT YES
         DC    AL1(SSTIF)               THEN TRY TO GET OUT
*
         DC    AL1(4*16+4)              TEST IF L-PAREN (DUP FACTOR)
         DC    AL1(EPDUPE)              EDIT IF YES (LINK TO EPSETC)
         DC    AL1(SSTIF)               THEN TRY TO EXIT
*
STDUP    EQU   *
         DC    AL1(EXTRT)               TRANSLATE&TEST
         DC    AL1(3*16+5)              TEST IF QUOTE (C-EXPR)
         DC    AL1(EPSETC)              EDIT IF YES
         DC    AL1(SSTIF)               THEN TRY TO EXIT
*
         DC    AL1(EXNXNT)              IF NONE OF THE ABOVE...
         DC    AL1(ETSETC)              TEST IF SETC ENTRY
         DC    AL1(SSTERR1)             LOG ERROR IF YES
         DC    AL1(EPTRMA)              NO. PROCESS AS ARITH TERM
         DC    AL1(SSTMOP)              THEN GET NEXT OPERATOR
*********************************************
STOP     EQU   *                        OPERATOR EVALUATION
         DC    AL1(EXTRT)               TRANSLATE&TEST
         DC    AL1(3*16+11)             TEST IF RELATIONAL OPERATOR
         DC    AL1(EPRELOP)             EDIT IF YES
         DC    AL1(SSTMOP1)             THEN GO LOOK FOR NEXT TERM
*
         DC    AL1(3*16+10)             TEST IF BOOLEAN OPERATOR
         DC    AL1(64+EPMBOOL)          YES-BUT HAS TO BE AND/OR
         DC    AL1(SSTATE0)             CHECK. GO PROCESS NEXT TERM
*
         DC    AL1(3*16+6)              COULD IT BE ARITH OPERATOR
         DC    AL1(EPAROP)              EDIT IF YES
         DC    AL1(SSTMA1)              THEN CHECK NEXT TERM
*
         DC    AL1(4*16+3)              TEST IF TERMINATING CHARACTER
         DC    AL1(ETBLANK)             YES, SCAVENGE IF BLANK(S)
         DC    AL1(SSTOPX)              NOW ONLY REL OP & BOOL OP      X
                                        ALLOWED FOLLOWING BLANKS
         DC    AL1(EXITX)               NOT BLANK. CHECK CURRENT STATUS
*
STBOPY   EQU   *                                                OX00406
         DC    AL1(EXNXNT)              IF NONE OF THE ABOVE ...
         DC    AL1(EXITX)               GO CHECK CURRENT STATUS
*
STOPX    EQU   *                        WRAP UP THE MESS LEFT BY SST7
         DC    AL1(EXTRT)               TRANSLATE&TEST
         DC    AL1(3*16+11)             TEST IF RELATIONAL OPERATOR
         DC    AL1(EPRELOP)             EDIT IF YES
         DC    AL1(SSTMOP1)             THEN GO TO NEXT TERM
*
         DC    AL1(3*16+10)             TEST IF BOOLEAN OPERATOR
         DC    AL1(64+EPMBOOL)          YES, BUT HAS TO BE 'AND'/'OR'
         DC    AL1(SSTATE0)             CHECK. PROCESS NEXT TERM
*
         DC    AL1(EXNXNT)              IF NEITHER ...
         DC    AL1(EXITX)               CHECK CURRENT STATUS
**********************************************
STMA     EQU   *                        ARITH TERM SCAN
         DC    AL1(EXNXNT)              EXEC NEXT ENTRY
         DC    AL1(EPTRMA)              GO CLASSIFY ARITH TERM
         DC    AL1(SSTMOP)              THEN GO CHECK FOR ARITH OP
STUNE    EQU   *-1                      POST-UNARY RE-ENTRY BECAUSE OF
         DC    AL1(SSTMA1)              L-PAREN
STMA1    EQU   *                   CHECK THE TERM FOLLOWING ARITH OP
         DC    AL1(EXTRT)               TRANSLATE&TEST
         DC    AL1(7*16+4)              TEST IF L-PAREN
         DC    AL1(EPSETA)              EDIT IF YES (ARITH EXPR),THEN..
         DC    AL1(SSTMOP)              RETURN HERE IF SIMPLE
         DC    AL1(SSTERR2)             RETURN HERE IF COMPLEX (ERROR)
         DC    AL1(SSTMOP)              RETURN HERE IF SETA EXPR
         DC    AL1(SSTERR2)             RETURN HERE IF SETC EXPR(ERROR)
         DC    AL1(SSTERR2)             AND HERE IF DUP'D SETC (ERROR)
*
         DC    AL1(EXNXNT)              EXEC NEXT ENTRY
         DC    AL1(EPTRMA)              MUST BE ARITMETIC TERM. PROCESS
         DC    AL1(SSTMOP)              THEN GO TO NEXT OPERATOR
*
STMOP    EQU   *                   CHK NEXT TERM/OP FOLLOWING ARITH TRM
         DC    AL1(EXTRT)               TRANSLATE&TEST
         DC    AL1(3*16+6)              TEST IF ARITH OPERATOR
         DC    AL1(EPAROP)              EDIT IF YES
         DC    AL1(SSTMA1)              THEN CHECK NEXT TERM
*
         DC    AL1(EXNXNT)              EXEC NEXT ENTRY
         DC    AL1(ETSETA)              TEST IF SETA ENTRY
         DC    AL1(SSTXITA)             EXIT IF YES
*
         DC    AL1(EXCPR)               ELSE, MAKE COMPARISON
         DC    AL1(3*16+11)             TEST IF RELATIONAL OPERATOR
         DC    AL1(EPRELOP)             EDIT IF YES, THEN
         DC    AL1(SSTMOP1)             LOOK FOR NEXT TERM
*
         DC    AL1(4*16+3)              TEST FOR TERMINATING CHAR
         DC    AL1(ETBLANK)             YES, SCAVENGE IF BLANK(S), THEN
         DC    AL1(SSTRO)               PRAY FOR REL OP TO FOLLOW.
         DC    AL1(EXITA)               NOT BLANK. LET'S GET OUT
*
STXITA   DC    AL1(EXNXNT)              NONE OF THE ABOVE...
         DC    AL1(EXITA)               LET'S GET OUT
STRO     EQU   *                        EXPECTING REL OP TO FOLLOW
         DC    AL1(EXTRT)               TRANSLATE&TEST
         DC    AL1(3*16+11)             IS IT RELATIONAL OPERATOR
         DC    AL1(EPRELOP)             EDIT IF YES
         DC    AL1(SSTMOP1)             THEN GO ONE MORE STEP FURTHER
         DC    AL1(3*16+10)             TEST IF BOOLEAN OPERATOR
         DC    AL1(64+EPMBOOL)          YES-BUT HAS TO BE AND/OR
         DC    AL1(SSTATE0)             CHECK. GO PROCESS NEXT TERM
*
STERR1   DC    AL1(EXNXNT)              ELSE, EXEC NEXT ENTRY
         DC    AL1(EPINVLD)             INVALID OPERAND FIELD FORMAT
*
STMOP1   EQU   *                        TERM/OP FOLLOWING REL/ARITH OP
         DC    AL1(EXTRT)               TRANSLATE&TEST
         DC    AL1(7*16+4)              TEST IF L-PAREN
         DC    AL1(EPSETA)              EDIT IF YES (ARITH EXPR) THEN
         DC    AL1(SSTAOP)              RETURN HERE IF SUMPLE
         DC    AL1(SSTERR2)             RETURN HERE IF COMPLEX (ERROR)
         DC    AL1(SSTAOP)              RETURN HERE IF SETA EXPR
         DC    AL1(SSTERR2)             RETURN HERE IF SETC EXPR(ERROR)
         DC    AL1(SSTERR2)             AND HERE IF DUP'D SETC (ERROR)
*
         DC    AL1(EXNXNT)              ELSE, EXEC NEXT ENTRY..
         DC    AL1(EPTRMA)              HAS TO BE ARITH TERM. PROCESS
         DC    AL1(SSTAOP)              THEN LOOK FOR NEXT ARITH OP
*
STAOP    EQU   *                        ARITH OP FOLLOWING ARITH TERM
         DC    AL1(EXTRT)               TRANSLATE&TEST
         DC    AL1(4*16+6)              TEST IF ARITH OP
         DC    AL1(EPAROP)              EDIT IF YES
         DC    AL1(SSTMOP1)             CHECK NEXT TERM/OP
*        LINK TO STBOP
STBOP    EQU   *                        BOOLEAN 'AND' OR 'OR'
         DC    AL1(EXTRT)               TRANSLATE&TEST
         DC    AL1(3*16+10)             TEST IF BOOLEAN OPERATOR
         DC    AL1(64+ETBOOL)           YES, BUT HAS TO BE AND/OR
         DC    AL1(SSTATE0)             CHECK. PROCESS NEXT TERM
*
         DC    AL1(4*16+3)              TEST IF TERMINATING CHAR
         DC    AL1(ETBLANK)             YES, SCAVENGE IF BLANKS, THEN
         DC    AL1(SSTBOPX)             GO TEST BOOLEAN OPERATOR AGAIN
         DC    AL1(EXITB)               GET OUT IF NOT BLANK
*
         DC    AL1(EXNXNT)              IF NEITHER ABOVE...
         DC    AL1(EXITB)               GET OUT OF HERE
*
STBOPX   EQU   *                        WRAP UP THE MESS LEFT BY STBOP
         DC    AL1(EXTRT)               TRANSLATE&TEST
         DC    AL1(3*16+10)             TEST IF BOOLEAN OPERATOR
         DC    AL1(64+ETBOOL)           YES, BUT HAS TO BE AND/OR
         DC    AL1(SSTATE0)             CHECK. NEXT
*
         DC    AL1(EXNXNT)              IF NOT BOOLEAN OP...
         DC    AL1(EXITB)               GET OUT OF HERE
**********************************************
STIF     EQU   *
         DC    AL1(EXNXNT)              EXECUTE NEXT ENTRY
         DC    AL1(ETSETC)              TEST IF SETC ENTRY
         DC    AL1(SSTXITC)             TRY TO EXIT IF YES
         DC    AL1(EXCPR)               ELSE, MAKE COMPARISON
         DC    AL1(EXTRT)               BUT TRANSLATE&TEST FIRST
         DC    AL1(3*16+11)             TEST IF REL OP
         DC    AL1(EPRELOP)             EDIT IF YES
         DC    AL1(SSTMIF)              THEN CHECK NEXT TERM
*
         DC    AL1(4*16+3)              IF NOT REL OP, CHECK IF BLANKS
         DC    AL1(ETBLANK)             SCAVENGE IF YES
         DC    AL1(SSTIFX)              THEN TEST IF REL OP AGAIN.
         DC    AL1(EXITC)               EXIT IF NOT BLANK
*
STXITC   DC    AL1(EXNXNT)              IF NEITHER ABOVE
         DC    AL1(EXITC)               CHECK CURRENT STATUS
*
STIFX    EQU   *                        WRAP UP THE MESS LEFT BY STIF
         DC    AL1(EXTRT)               TRANSLATE&TEST
         DC    AL1(3*16+11)             TEST IF REL OP
         DC    AL1(EPRELOP)             EDIT IF YES-THEN
         DC    AL1(SSTMIF)              CHECK NEXT TERM
*
         DC    AL1(EXNXNT)              ELSE, LOG INVALID OPERAND FMT
         DC    AL1(EPINVLD)             (EXPECTING REL OP.)
*
STMIF    EQU   *                        TERM FOLLOWS REL OP IN AIF
         DC    AL1(EXTRT)               TRANSLATE&TEST
         DC    AL1(3*16+9)              TEST IF TYPE ATTR NOTATION
         DC    AL1(EPATTR)              EDIT IF YES
         DC    AL1(SSTBOP)              GO CHECK NEXT OP (BOOLEAN OP)
*
         DC    AL1(3*16+4)              TEST IF L-PAREN (DUP FACTOR)
         DC    AL1(EPDUPE)              EDIT IF YES (LINK TO EPSETC)
         DC    AL1(SSTBOP)              THEN CHECK NEXT OP (BOOL OP)
*
         DC    AL1(3*16+5)              TEST IF QUOTE (C-EXPR)
         DC    AL1(EPSETC)              EDIT IF YES
         DC    AL1(SSTBOP)              THEN CHECK NEXT OP (BOOL OP)
*
         DC    AL1(EXNXNT)              EXEC NEXT ENTRY
         DC    AL1(EPINVLD)             GO LOG ERR32
*
STERR2   EQU   *                        LOG ILGL OPERAND FIELD FORMAT
         DC    AL1(EXNXNT)              EXEC NEXT ENTRY
         DC    AL1(EPILXP)
         DS    0H
         SPACE 3
*   TRANSITION TABLE ROUTINE ENTRY RELATIVE ADDRESS EQUATED
         SPACE 3
*
SSTATE0  EQU   STATE0-STATE0
SSTUNE   EQU   STUNE-STATE0
SSTATE1  EQU   STATE1-STATE0
SSTXA    EQU   STXA-STATE0
SSTXC    EQU   STXC-STATE0
SSTDUP   EQU   STDUP-STATE0
SSTMA    EQU   STMA-STATE0
SSTOP    EQU   STOP-STATE0
SSTOPX   EQU   STOPX-STATE0
SSTMA1   EQU   STMA1-STATE0
SSTMOP   EQU   STMOP-STATE0
SSTRO    EQU   STRO-STATE0
SSTERR1  EQU   STERR1-STATE0
SSTMOP1  EQU   STMOP1-STATE0
SSTAOP   EQU   STAOP-STATE0
SSTBOP   EQU   STBOP-STATE0
SSTBOPX  EQU   STBOPX-STATE0
SSTIF    EQU   STIF-STATE0
SSTXITA  EQU   STXITA-STATE0
SSTXITC  EQU   STXITC-STATE0
SSTIFX   EQU   STIFX-STATE0
SSTMIF   EQU   STMIF-STATE0
SSTBOPY  EQU   STBOPY-STATE0            .
SSTERR2  EQU   STERR2-STATE0
         EJECT
*   ENTRIES TO RESPECTIVE DETAIL PROCESSING ROUTINES
         SPACE 3
ILGLXPBR B     ILGLXP                   GO TO ILGLXP IN CS0
         SPACE 3
ESETA    EQU   *
         L     R14,RAVSP
         TM    D3(R14),MCLA             TEST IF SETA ENTRY
         B     BRIDGE1                  .....
ESETC    EQU   *
         L     R14,RAVSP
         TM    D3(R14),MCLC             TEST IF SETC ENTRY
BRIDGE1  BO    TRNSFER                  ..DO CURRENT STATE ENTRY IF YES
BRIDGE2  LA    MTBLNDX,D2(MTBLNDX)      ELSE, STEP ACROSS CURRENT ENTRY
         B     MEXFR1                   TO EXECUTE NEXT STATE ENTRY
EBLANK   EQU   *                        TEST IF BLANK AT INPTR
         CLI   D0(INPTR),JBLANK
         BNE   BRIDGE2                  BRANCH IF NOT BLANK
DBLANK   EQU   *                        ELSE GOBBLE UP BLANKS
         L     R14,RAVSP
         OI    RSTKFLG,MCMPLX           INDICATE COMPLEX STATE
         BAL   TLINK,SKPBLK             BUMP OVER BLANKS
         GOIF  SNOFND,ON=ILGLXP2        INVALID FORMAT
TRNSFER  EQU   *                        TRANSITION TO NEW STATE
         IC    MTBLNDX,STATE0+D1(MTBLNDX) PICK UP NEW STATE REL ADDRESS
         B     MSCVRT                   BACK TO THE OLD GRINDER
         SPACE 3
*   RECURSIVE CALL TO METASCAN FORCED BY LEFT PARENTHESIS WHILE
*   PROCESSING ARITHMETIC EXPRESSION OR BOOLEAN EXPRESSION
ARENT    EQU   *
         MVI   MCALL,MCLA               RESET TO ARITHMETIC ENTRY CODE
         B     ARENT20                  UP PAREN COUNT AND PUT IN STACK
ARENT10  L     R14,RAVSP                SET ENTRY CODE SAME AS CURRENT
         MVC   MCALL(D1),RSTKFLG        STATE
         NI    MCALL,STMASK             MASK OUT UNWANTED STATUS
ARENT20  BAL   R12,APARCT               INCREMENT PAREN COUNT
         BAL   R3,PFXRENT               LOG L-PAREN IN REGISTER PARM
         DC    AL2(JTMLPAR)             LOG L-PAREN
         BAL   RETURN,METASCAN          SCAN
         CLI   D0(INPTR),JRPARN         TERMINATOR MUST BE R-PAREN
         BNE   ILGLXP1                  ELSE, LOG ERROR
         BAL   R12,DPARCT               DECREMENT PAREN COUNT
         LR    R0,R3                    SAVE EXIT CODE
         BAL   R3,PFXRENT               LOG R-PAREN IN REGISTER PARM
         DC    AL2(JTMRPAR)             LOG R-PAREN
         LR    R3,R0                    RESTORE EXIT CODE
         CLI   D0(INPTR),JQUOTE         TEST IF DUP FACTOR
         BNE   ARENT30                  BRANCH IF NOT
         BAL   R3,PFXRENT               ASSUME DUP FACTOR
         DC    AL2(JTMDUP)              AND SO INDICATE
         BCTR  INPTR,0                  BUT DON'T GET CARRIED AWAY
         LA    R3,D4                    EXIT CODE IS 4
ARENT30  EQU   *
         AR    MTBLNDX,R3               TRANSITION TO ANY OF THE FOUR
         B     TRNSFER                  STATES DEPENDING ON EXIT CODE
ILGLXP0  L     INPTR,TPSAVE             BACK UP FOR SNAP
ILGLXP1  C     INPTR,ENDATA             DID END DATA TERMINATE
         BNL   ILGLXP2                  IF SO LOG ERR24
         CLI   D0(INPTR),JBLANK         IS THE TERMINATOR A BLANK
         BNE   INVFM                    FLAG ERR32, SNAP INVALID TEXT
ILGLXP2  BAL   TLINK,ABSERR             EITHER UNPAIRED PARENS
         DC    AL1(5*16+SEV24)          OR
         DC    AL1(ERR24)               BLANK APPEARED INSIDE
         SPACE 3
*   EXITS FROM RESPECTIVE DETAIL PROCESSING ROUTINES
XSX      EQU   *                        CHECK CURRENT STATUS
         SR    R3,R3                    LET'S ASSUME SIMPLE STATE
         L     R14,RAVSP                WE'LL SOON FIND OUT
         TM    RSTKFLG,MCMPLX           TEST IF COMPLEX STATE
         BZ    XSB1                     EXIT IF SIMPLE STATE
XSB      EQU   *
         LA    R3,1                     SET BOOLEAN COMPLEX EXIT CODE
XSB1     L     INDEXO,OUTADR            RESTORE OUTPUT BUFFER POINTER
         B     REXSTK                   GO TO RECURSIVE EXIT
XSA      EQU   *
         LA    R3,2                     SET SETA TYPE EXIT CODE
         B     REXSTKL                  GO GET STACK BASE
XSC      EQU   *
         LA    R3,3                     SET SETC TYPE EXIT CODE
REXSTKL  EQU   *
         L     R14,RAVSP                GET STACK-BASE
         TM    RSTKFLG,MCMPLX           TEST IF COMPLEX STATE
         BO    ILSETA                   LOG ERROR
         L     INDEXO,OUTADR            RESTORE OUTPUT BUFFER POINTER
         B     REXSTK1                  GO TO RECURSIVE EXIT
         SPACE 3
*   CLEANUP ROUTINE CLEAN UP THE STATEMENT OR THE OPERAND WHERE ERROR
*   IS FOUND. IT THEN RETURN TO CALLER IF PROCESSING MULTI-OPERAND
*   STATEMENTS. ELSE, GO TO READ NEXT STATEMENT.
*   STATEMENTS THAT HAVE MULTI-OPERAND ARE:
*        MACRO CALL,
*        PROTOTYPE WITH KEYWORD PARAMETER,
*        GBLX/LCLX, AND
*        EQU
*
CLN0     LR    R1,R0
CLEANUP  EQU   *
         LA    TWKREG1,STACK            CLEAN UP WHAT'S LEFT IN
         ST    TWKREG1,SVLAST           POSTFIXER STACK
         L     INPTR,FPTRSV             BACK UP TO BEGIN OF FIELD
         L     INDEXP,OFPTRSV           ON BOTH I/O BUFFERS
         L     INDEXO,OUTADR            RESTORE POINTER
         GOIF  SEOPCD,ON=REXSTK         RETURN IF EDITING OP CODE
         GOIF  SENAME,OFF=CLN1
         BAL   RETURN,RESETPTR          INSURE NO OVERLAP
CLN1     MVI   SWITCH8,D0               RESET SWITCH
         SET   (METSW,GSUBS),OFF
         LA    TWKREG1,RSTACK-(EDRSTK-BDRSTK)
         ST    TWKREG1,RAVSP            AND RSTACK
         L     INDEXO,OUTADR            RESTORE POINTER
         SET   JPRONLY,ON
         GOIF  SGBLCL,ON=CLN2
         SET GQST,OFF
         GOIF  DMIENT,OFF=CLN3                                 @AZ13722
         SET   DMIENT,OFF                                      @AZ13722
CLN2     LA    R14,EDRSTK-BDRSTK(,R14)
         NI    JHWORD2+1,BITFF-(DMIENT) RESET SECOND DMIENT SW @AZ13722
         B     REXSTK1                  WRAP UP STATEMENT
CLN3     TM    JHWORD2+1,DMIENT         TEST FOR PREV PROC-    @AZ13722
         BZ    WRAPFLD                  ESS IN MIPROTO         @AZ13722
         B     CLN2                     RETURN OVER REX        @AZ13722
         EJECT
*   PROCESS ARITHMETIC OPERATOR
DAROP    EQU   *
         BAL   R3,PFXRE2                MAKE POSTER ENTRY
         B     TRNSFER                  GO FOR TRANSITION
         SPACE 3
*   PROCESS VARIABLE SYMBOL
EVSYM    EQU   *
         BAL   RETURN,VARSYM            SCAN V.S. AND BUILD MT
         LR    INPTR,R1                 BUMP TO NEXT SCAN LOCATION
         B     TRNSFER                  NEXT TERM/OPERATOR
         SPACE 3
*   PROCESS BOOLEAN (LOGICAL) OPERATOR
DVBLOP   EQU   *                        SCREEN SYSLIST
         L     R14,RAVSP
         TM    FLGBYT,VSLS              TEST IF SYSLIST PROCESSED
         BO    ILBXP                    LOG ERROR IF YES
         OI    RSTKFLG,MCMPLX           ELSE INDICATE IN COMPLEX STATE
DBLOP    EQU   *
         IC    TWKREG1,BOP10-JTMNOT(R10) PICK UP ACCEPTANCE MASKS
         LA    R1,MTABLE(MTBLNDX)       AND TEST IF CORRESPOND TO
         EX    TWKREG1,BOPTM            CALLING SEQUENCE
         BNO   ILGLXP                   ILLEGAL EXPRESSION
*   ENTER RELATIONAL OPERATOR
DRELOP   EQU   *
         BAL   R3,PFXRE2                MAKE POSTER ENTRY
         LA    INPTR,D0(R15,INPTR)      BUMP INPTR
         B     DBLANK                   GO TAKE CARE OF BLANKS
BOPTM    TM    D0(R1),0
BOP10    DC    X'804040'                NOT/AND/OR ACCEPTANCE MASKS
         DS    0H
         SPACE 3
DATTR    EQU   *
         ST    INPTR,TPSAVE
         LA    INPTR,D1(R15,INPTR)      UPDATE POINTER
         LR    TWKREG1,PARM             CONVERT ATTR FLAG
         SH    TWKREG1,HATT
         STC   TWKREG1,ATTRSV           AND SAVE
         BAL   R3,PFXRE2                LOG ATTR FLAG
         CLI   D0(INPTR),JAMPER         TEST IF FOLLOWED BY A V.S.
         BNE   ATTROS                   BRANCH IF NOT
         BAL   RETURN,VARSYM            GO PROCESS VS
         LR    INPTR,R1                 UPDATE POINTER
         GOIF  RMPURE,ON=ILATTR         EXIT IF BAD V.S.
         TM    FLGBYT,VTYP1+VSLS        TEST IF A PARAM OR A SYSLIST
         BM    ATTRSYP                  BRANCH IF EITHER
         TM    ATTRSV,ATT               ELSE, MUST BE SET SYM PRECEDED
         BNO   ILATTR                   BY ...
         TM    ATTRSV,AT7               K' OR T'
         BO    ILATTR                   ELSE, ERROR
         B     ATTX1                    EXIT IF ALL'S WELL
ATTRSYP  EQU   *
         GOIF  SMDEF,OFF=ILATTR         LOG ERROR IF NOT IN MACRO
         TM    ATTRSV,ATN               TEST IF N'
         BNO   ATTX1                    EXIT IF NOT N'
         TM    ATTRSV,ATSUBS
         BO    ILATTR                   ERROR IF DOUBLY SUBS'D SYSLIST
         BZ    ATTX1                    OK IF NON-SUBSCRIPTED V.S.
          TM    FLGBYT,VSLS             ELSE, TEST IF SYSLIST AT ALL
         BO    ATTX1                    OK IF YES
         B     ILATTR                   ELSE, ERROR
ATTROS   EQU   *
         BAL   LINK,SYMSCN              TEST IF ORDINARY SYMBOL
         B     ILATTR                   ERROR IF RETURN TO HERE
         MVC   D0(D4,INDEXP),D0(R11)    ENTER O-SYM POINTER
         LA    INDEXP,DENTLNG(,INDEXP)  BUMP 2 EXTRA BYTES FOR GEN'R
ATTX1    EQU   *
         MVI   ATTRSV,D0                RESET ATTRIBUTE FLAGS
         B     TRNSFER                  MAKE TRANSITION
ATTX2    EQU   *
         MVI   ATTRSV,D0                RESET ATTRIBUTE FLAGS
         B     REXSTK                   POP UP
         SPACE 3
*   PROCESS SETC CHARACTER EXPRESSION
*   STARTING WITH A QUOTE (DUPLICATION FACTOR IS CHECKED BY TRANSE
*   OR AN EXTRA TABLE ENTRY PRECEEDING CSETC ENTRY
*
DUPC     EQU   *
         ST    INPTR,TPSAVE             SAVE FOR POSSIBLE ERROR SNAP
         BAL   R3,PFXRENT               TELL POSTER
         DC    AL2(JTMLPAR)             IT IS A LEFT PAREN
         BAL   R12,APARCT               UP PAREN COUNT
         MVI   MCALL,MCLA               SCAN DUP FACTOR AS SETA EXPR.
         BAL   RETURN,METASCAN          SCAN
         CLI   D0(INPTR),JRPARN         TERMINATOR MUST BE R-PAREN
         BNE   INVDUP                   ELSE LOG ERROR
         BAL   R3,PFXRENT               LOG RIGHT PAREN
         DC    AL2(JTMRPAR)             RIGHT PAREN
         BAL   R12,DPARCT               DECR PAREN COUNT
         CLI   D0(INPTR),JQUOTE         QUOTE MUST FOLLOW DUP FACTOR
         BNE   ILGLXP0                  GO FLAG ERROR 32
         BAL   R3,PFXRENT               MAKE DUP FACTOR ENTRY
         DC    AL2(JTMDUP)              DUPLICATION OPERATOR
         BCTR  INPTR,0                  DON'T GET CARRIED AWAY
         L     R14,RAVSP
         MVC   MCALL(L'MCALL),RSTKFLG   BACK TO CURRENT STATE
DSETC    EQU   *
         BAL   R3,PFXRENT               INDICATE START CHAR MODE
         DC    AL2(JTMSCM)              START CHARACTER MODE
CSC05    L     TWKREG2,ENDATA           SET END OF DATA AREA
         BCTR  TWKREG2,D0               SET END OF DATA AREA
         LA    TWKREG1,D1               SET INCREMENT FACTOR
         LR    R1,INDEXP                REMEMBER WHERE M.T. STARTS
         SR    R0,R0                    CLEAR STRING COUNT
         LA    INDEXP,D2(,INDEXP)       BUMP POINTER
CSC10    LA    R3,D2
         CLI   D0(INPTR),JQUOTE         TEST IF QUOTE
         BNE   CSC20                    BRANCH IF NOT
         CLI   D1(INPTR),JQUOTE
         BNE   CSC50                    SINGLE - END OF C-STRING
         BCT   R3,CSC30                 DOUBLE QT - SQUASH TO SINGLE
CSC20    CLI   D0(INPTR),JAMPER         TEST IF AMPERSAND
         BNE   CSC40                    NO. C-STRING
         CLI   D1(INPTR),JAMPER
         BNE   CSCVSYM                  SINGLE & - ASSUME V.S.
CSC30    EQU   *
         AR    INPTR,TWKREG1            ADVANCE POINTER
CSC35    EQU   *
         MVC   D0(D1,INDEXP),D0(INPTR)  MOVE 1 CHAR TO O/P
         AR    INDEXP,TWKREG1           BUMP O/P POINTER
         AR    R0,TWKREG1               INCREMENT STRING COUNT BY 1
CSC40    BCT   R3,CSC35                 ITERATE ON COUNT
         BXLE  INPTR,TWKREG1,CSC10      PROCESS NEXT CHAR
         B     NOQUOTE                  ERR, UNBALANCED QUOTES IN SETC
CSCVSYM  EQU   *
         BAL   R3,CSTGCHK               CHECK IF STRING COLLECTED
         BAL   RETURN,VARSYM            EDIT VS INTO MT
         LR    INPTR,R1                 UPDATE POINTER
         CLI   D0(INPTR),JPERIOD        IGNORE THE DOT
         BNE   CSC05                    (BRANCH IF NOT A DOT)
         LA    INPTR,D1(,INPTR)         IF THERE IS ONE
         B     CSC05                    THEN CONTINUE C-EXPR PROCESSING
CSC50    EQU   *
         BAL   R3,CSTGCHK               CHECK IF STRING COLLECTED
         BAL   R3,PFXRENT               INDICATE END CHARACTER MODE
         DC    AL2(JTMECM)
         CLI   D0(INPTR),JLPARN         ANY SUBSTRING NOTATION
         BNE   CSC60                    BRANCH IF NOT
         BAL   R12,APARCT               ADVANCE PAREN COUNT
         BAL   R3,PFXRENT               ENTER SUBSTRING OPERATOR
         DC    AL2(JTMSTR)              STRING OPERATOR
         BCTR  INPTR,0                  DON'T GET CARRIED AWAY
         BAL   R3,PFXRENT               LOG L-PAREN
         DC    AL2(JTMLPAR)             LEFT PAREN
         MVI   MCALL,MCLA               INDICATE TO SCAN AS SETA EXPR.
         BAL   RETURN,METASCAN          SCAN SUBSCRIPT 1
         CLI   D0(INPTR),JCOMMA         TERMINATOR MUST BE A COMMA
         BNE   INVSUB                   ELSE, LOG ERROR
         BAL   R3,PFXRENT               A COMMA
         DC    AL2(JTMCOM)              STACK IT IN
         BAL   RETURN,METASCAN          SCAN SUBSCRIPT 2
         CLI   D0(INPTR),JRPARN         TERMINATOR MUST BE R-PAREN
         BNE   INVSUB                   ELSE, LOG ERROR
         BAL   R3,PFXRENT               LOG R-PAREN
         DC    AL2(JTMRPAR)             RIGHT PAREN
         BAL   R12,DPARCT               DECREMENT PAREN COUNT
         L     R14,RAVSP
         MVC   MCALL(L'MCALL),RSTKFLG   BACK TO CURRENT STATE
         CLI   D0(INPTR),JLPARN         TEST IF IMPLIED CONCATENATION
         BNE   CSC55                    BRANCH IF NOT FOLLOWED BY (
         BAL   R3,PFXRENT               YES, DUP FACTOR FOLLOWS
         DC    AL2(JTMPER)              INDICATE CONCATENATION FIRST
         BCT   INPTR,DUPC               THEN RE-ENTER DUPC
CSC55    EQU   *
         CLI   D0(INPTR),JQUOTE         TEST IF IMPLIED CONCATENATION
         BNE   CSC60                    BRANCH IF NOT
         BAL   R3,PFXRENT               ENTER CONCATENATION OPERATOR
         DC    AL2(JTMPER)              PERIOD
         BCT   INPTR,DSETC              RE-ENTER CSETC
CSC60    CLI   D0(INPTR),JPERIOD        TEST IF EXPLICIT CONCATENATION
         BNE   TRNSFER                  NO - END OF C-EXPRESSION
         BAL   R3,PFXRENT               TELL IT TO POSTER
         DC    AL2(JTMPER)              PERIOD
         CLI   D0(INPTR),JLPARN         TEST IF DUPLICATION FACTOR
         BE    DUPC                     YES, RE-ENTER DSECT
         CLI   D0(INPTR),JQUOTE         TEST IF DOT FOLLOWED BY QUOTE
         BE    DSETC                    RE-ENTER DSETC
         B     TRNSFER                  GO TO NEXT TABLE ENTRY
CSTGCHK  EQU   *
         LTR   R0,R0                    TEST IF ANY STRING COLLECTED
         BNZ   CSTGC10                  BRANCH IF YES
         SH    INDEXP,H2                ELSE, BACK UP
         BR    R3                       AND RETURN
CSTGC10  EQU   *
         MVI   D0(R1),JTMCS             ELSE, FILL IN FLAG
         STC   R0,D1(,R1)               AND STRING LENGTH
         BR    R3                       RETURN
         EJECT
*   PROCESS UNARY OPERATOR - LINK TO ARITHMETIC TERM PROCESSOR OR
*   MAKE RECURSIVE ENTRY BECAUSE OF LEFT PAREN
*
*   UNARY OPERATOR FOLLOWS
*                  L-PAREN,
*                  ARITH OPERATOR,
*                  UNARY OPERATOR,
*                  OR BLANK.
*
CUNARY   EQU   *
         IC    PARM,UNARYOP-JTMMULT(PARM) PICK UP UNARY OPERATOR
         LTR   PARM,PARM                TEST IF PLUS OR MINUS
         BZ    ILUNARY                  UNARY OPERATOR ERROR
         BAL   R3,PFXRE2                LOG UNARY OPERATOR
         CLI   D0(INPTR),JLPARN         TEST IF L-PAREN FOLLOWS
         BNE   ARTERMX                  CLASSIFY ARITH TERM IF NOT
         LA    MTBLNDX,SSTUNE           ELSE, MAKE RECURSIVE ENTRY
         B     TRNSFER                  TO METASCAN
UNARYOP  DC    AL1(0,0,JTMPLUS,JTMMIN)  UNARY OP INTERNAL VALUE
         SPACE 3
*   PROCESS ARITHMETIC TERM WHICH MAY BE IN THE FOLLOWING FORMATS.
*   1) V.S.
*   2) ATTRIBUTE NOTATION
*   3) SELF DEFINING TERM (B, C, D, X)
*
ARTERMX  L     LINK,ATRTEST             POINT TO TRTEST
         BALR  RETURN,LINK              FIND OUT NEXT TERM/OPERATOR
ARTERM   EQU   *
         ST    INPTR,TPSAVE             SAVE BEGIN PT FOR SNAP
         BAL   RETURN,AEXPR             GO PROCESS THE TERM
         B     ILSDT                    RETURN HERE IF ERROR FOUND
         B     TRNSFER                  NORMAL RETURN
         SPACE 3
*   ENTRY TO APPROPRIATE ROUTINES
AEXPR    EQU   *                        TEST TRT RESULT
         CH    R3,H2
         BE    EVSYM                    BRANCH IF VARIABLE SYMBOL
         CH    R3,H6                    TEST POSSIBLE UNARY OPERATOR
         BE    CUNARY                   BRANCH IF ARITH OPERATOR
         CH    R3,H7
         BE    DATTR                    ATTRIBUTE NOTATION
         CH    R3,H8
         BE    XBCSDT                   X-, B-, C-TYPE SDT
         CH    R3,H3                    OPERAND TERMINATOR
         BE    ILGLXP2                  LOG ERROR IF NOTHING FOUND
         LTR   R3,R3
         BNZ   ILSDT                    LOG ERROR IF NOT DSDT
         SPACE 3
*   SELF DEFINING TERM PROCESSING ROUTINES.
*   CALLED BY METASCAN ARITHMETIC TERM PROCESSING ROUTINE, BY
*   PROTOTYPE PARAMETER PROCESSING ROUTINE, AND BY MACRO INSTRUCTION
*   KEYWORD PROCESSING ROUTINE.
*
DSDTIN   EQU   *
         ST    INPTR,TPSAVE
         LR    SCNLREG,R1               SCAN UP TO TRT TERMINATING CHAR
         LA    PARM,DSDT                GWT DSDT TYPE NUMBER
         BCT   SCNLREG,SDTLMT           AND GO
*
XBCSDT   EQU   *                        X-, B-, C-TYPE SDT ENTRY
         ST    INPTR,TPSAVE
         LA    INPTR,D2(,INPTR)         BUMP OVER SDT HEAD
         L     SCNLREG,ENDATA           SET SCAN LIMIT
*
SDTLMT   EQU   *
         IC    R3,SDTMAXC-JTMSDT(PARM) SET SDT CHAR MAX COUNT
         STH   R3,HICCNT
         IC    R3,SDTCVAL-JTMSDT(PARM) SET SDT HIGH CHAR VALUE
         STH   R3,HICVAL
         IC    R1,SDTSHFT-JTMSDT(PARM)  SET CONVERSION SHIFT VALUE
*
         LA    INCREG,D1                BXLE INCREMENT IS 1
         SR    KNTREG,KNTREG            SET COUNT REG = 0
         LR    MAXVREG,KNTREG           SET RESULT REGISTER
*
SDTPR    EQU   *
         SR    R14,R14
         IC    R14,D0(,INPTR)           SET ONE BYTE AT INPTR
         CLI   D0(INPTR),JQUOTE         TEST IF QUOTE
         BNE   SDTPR05                  GO TEST CHAR VALUE
         LA    INPTR,D1(,INPTR)         BUMP POINTER
         CLI   HICVAL1,CHARV            TEST IF CHARACTER SDT
         BNE   SDTEND                   TERMINATE IF NOT
         CLI   D0(INPTR),JQUOTE         IS IT DOUBLE QUOTE
         BNE   SDTEND                   NO. TERMINATE
SDTPR05  CH    R14,HICVAL               TEST IF CHAR VALUE IN RANGE
         BCR   BHI,RETURN               ERROR IF HIGH
         CLI   D0(INPTR),JAMPER         IS THE CHAR AN AMPERSAND
         BNE   SDTPR15                  BRANCH IF NOT
         LA    INPTR,D1(,INPTR)         BUMP POINTER
         CLI   D0(INPTR),JAMPER         IT BETTER BE DOUBLE
         BCR   BNE,RETURN               ELSE, LOG ERROR
SDTPR15  CLI   HICVAL1,J9               TEST IF DSDT
         BNE   SDTPR25                  BRANCH IF NOT
         ALR   R14,MAXVREG              INITIALIZE CONVERSION TO BINARY
         ALR   R14,MAXVREG
SDTPR25  EQU   *
         SLL   MAXVREG,D0(R1)           SHIFT PARTIAL RESULT
         ALR   MAXVREG,R14              ADD IN THE ADJUSTED BYTE
         AR    KNTREG,INCREG            ADD 1 TO CHARACTER COUNT
         BXLE  INPTR,INCREG,SDTPR       GET NEXT BYTE
         CLI   HICVAL1,J9               WOOPS, FALL THRU
         BE    SDTPR35                  BETTER BE DSDT,  YES, GREAT
         BR    RETURN                   ELSE, ERROR - RETURN
*
SDTPR35  EQU   *
         CL    MAXVREG,SDTMAXV          HAS DSDT HIT MAX VALUE
         BCR   BHI,RETURN               TOO HIGH. LOG ERROR
SDTEND   LTR   KNTREG,KNTREG            CHAR COUNT MUST WITHIN RANGE
         BCR   BZ,RETURN                TOO LOW
         CH    KNTREG,HICCNT
         BCR   BHI,RETURN               TOO HIGH
         ST    MAXVREG,JFWORD2          OK. SAVE IT
         CLI   HICVAL1,CHARV            TEST IF CSDT
         BNE   SDTOUT                   BRANCH IF NOT
         LCR   R14,KNTREG               NEGATE CHAR COUNT
         LA    TRBASE,JFWORD2+D4(R14)   ADJUST OFF-THE-LINE TR BASE REG
         LR    TRLENG,KNTREG
         BCTR  TRLENG,0                 ADJUST TR LENGTH
         EX    TRLENG,CSDTTR            TR TO EXTERNAL CHAR VALUE
SDTOUT   EQU   *
         MVC   D1(L'JFWORD2,INDEXP),JFWORD2 ENTER VALUE INTO TEXT
         LA    R12,D1                   VALID SDT EXIT CODE FOR DMIENT
         GOIF  DMIENT,OFF=SDTOUT1       DID WE ENTER FROM MIPROTIN
         GOIF  VDIM,OFF=D4(,RETURN)     RETURN IF DIMENSIONED
SDTOUT1  EQU   *
         MVI   D0(INDEXP),JTMSDT        NO
         LA    INDEXP,SDTLENG(,INDEXP)  BUMP OVER ONE EXTRA BYTE       X
                                        FOR GENERATOR'S CONVENIENCE
         B     D4(,RETURN)              AND RETURN
CSDTTR   TR    D0(0,TRBASE),JTRTABLE    OFF-THE-LINE TRANSLATE
         SPACE 3
         DS    0F
* SDT TYPE ----> X B C D
SDTMAXC  DC    X'0820040A'              MAX CHAR COUNT ALLOWED IN SDT
SDTCVAL  DC    X'0F01FF09'              MAX CHAR VALUE ALLOWED IN SDT
SDTSHFT  DC    X'04010803'              SHIFT VALUE IN BITS
*
SDTMAXV  DC    X'7FFFFFFF'              MAX DSDT VALUE (2**32)-1
*
KNTREG   EQU   0                        CHAR COUNT REG
MAXVREG  EQU   3                        MAX VALUE REG
INCREG   EQU   10                       BXLE INCREMENT REG
SCNLREG  EQU   11                       SDT SCAN LIMIT REG
TRLENG   EQU   12                       OFF-THE-LINE TR LENGTH REG
TRBASE   EQU   14                       OFF-THE-LINE TR BASE REG
CHARV    EQU   255                      CHAR VALUE
SDTLENG  EQU   L'JFWORD2+2              SDT ENTRY LENGTH (ONE EXTRA    X
                                        BYTE FOR GEN'TOR'S CONVENIENCE
         DS    0H
         SPACE 3
BDSDT    BAL   RETURN,DSDTIN            EDIT AS DSDT
         B     ILSDT                    INV SDT IF RETURN TO HERE
         CLI   D0(INPTR),JRPARN         DSDT MUST BE PARENTHESIZED
         BE    TRNSFER                  YES
         AR    MTBLNDX,R12              NOT DSDT
         B     TRNSFER                  TRY ARITH EXPR
         EJECT
***********************************************************************
* RECURSIVE ENTRY FOR SCANNERS
* FORMAT = VMMMRRAF      WHERE
*          V  = FLGBYT SAVED
*          MMM = MTABLE INDEX (MTBLNDX)
*          RR = RETURN ADDRESS (RELATIVE TO BASE1)
*          A  = ATTRSV SAVED
*          F  = MCALL SAVED
* RAVSP MUST BE INITIALIZED TO A(RSTACK) AT PHASE ENTRY
* LINKAGE      BAL  R12,RENTSTK
***********************************************************************
         SPACE 3
RENTSTK  EQU   *
         ST    INDEXP,INTERMET          SAVE INTERMEDIATE MT POINTER
         L     R14,RAVSP                GET AVAILABLE LOCATION IN RSTAC
         LA    R14,EDRSTK-BDRSTK(,R14)  COMPUTE NEXT AVAILABLE LOCATION
         C     R14,NRSTK                TEST IF END OF STACK
         BNL   RENTFULL                 LOG ERROR IF END OF STACK
         ST    MTBLNDX,RSTKSTP          SAVE
         LA    RETURN,D0(,RETURN)       CLEAN UP BAL MESS
         SR    RETURN,BASE1             MAKE RETURN ADDRESS RELATIVE
         STH   RETURN,RSTKRTN           AND SAVE
         MVC   RSTKATR(L'ATTRSV+L'MCALL+L'FLGBYT),ATTRSV SAVE FLAGS
         ST    R14,RAVSP                AND SAVE IT
         BR    R12                      RETURN TO CALLER
         SPACE 3
***********************************************************************
* RECURSIVE EXIT FOR SCANNERS
* LINKAGE      B    REXSTK
***********************************************************************
         SPACE 3
REXSTKP  EQU   *                        ERROR-CONDITION EXIT
         L     INDEXP,INTERMET          WIPE OFF BAD META TEXT ENTRY
REXSTK   EQU   *                        NORMAL EXIT
         L     R14,RAVSP
REXSTK1  EQU   *
         LH    RETURN,RSTKRTN           RESTORE RETURN ADDRESS
         AR    RETURN,BASE1             AND MAKE IT ABSOLUTE
         MVC   ATTRSV(L'ATTRSV+L'MCALL+L'FLGBYT),RSTKATR RESTORE FLAGS
         L     MTBLNDX,RSTKSTP          RESTORE
         SH    R14,RSTKLEN              BACK UP ENTRY POINT
         ST    R14,RAVSP                RESET AVAILABLE LOCATION POINTR
         BR    RETURN                   RETURN
         EJECT
***********************************************************************
*   CSTK IS A RECURSIVE STACK FOR NESTED COPY CODE. A COPY CODE MAY   *
*   BE IMBEDDED IN A COPY CODE UP TO MAXIMUM OF FIVE LEVELS INCLUSIVE.*
*   A COPY CODE MAY COPY ITSELF. IT MAY COPY A MACRO DEFINITION AS A  *
*   PROGRAMMER MACRO. THUS, A COPY STATEMENT IS ALLOWED TO BE BETWEEN *
*   PROGRAMMER MACROS.                                                *
*                                                                     *
*   FORMAT OF CSTK IS NNNNS     WHERE                                 *
*                     NNNN = NOTED VALUE OF THE DISCONTINUED          *
*                            SOURCE STREAM.                           *
*                     S = SWITCH1 SAVED FOR CURRENT LEVEL OF COPY     *
*                           STREAM.                                   *
*                                                                     *
*   LINKAGE IS  BAL   R3,CSTKENT - FOR ENTRY                          *
*               BAL   R3,CSTKEXT - FOR EXIT                           *
*                                                                     *
***********************************************************************
CSTKENT  EQU   *
         L     PARM,CSTKADR             GET NEXT AVAILABLE LOCATION
         C     PARM,NCSTK               TEST IF THE STACK FULL
         BNL   CSTKFULL                 BRANCH IF YES
         XC    CSTKMEM(L'CSTKMEM),CSTKMEM CLEAR MEMBER NAME
         GOIF  JINLIB,OFF=CSTK20        BRANCH IF NOT IN LIBRARY MODE
         JNOTELB
         L     PARM,CSTKADR             RESTORE NEXT AVAILABLE LOCATION
         MVC   CSTKNOTE(L'CSTKNOTE),JNOTEVAL AND SAVE NOTED ADDRESS
         MVC   CSTKMEM(L'CSTKMEM),LASTFIND SAVE MEMBER NAME IN STACK
CSTK10   EQU   *
         MVC   CSTKSW(L'SWITCH9),SWITCH9 SAVE SWITCH9 STATUS
         MVI   SWITCH9,J0               CLEAR SWITCH AT OLD LEVEL
         SET   SINCPY,ON                INDICATE IN COPY CODE
         LA    PARM,EDCSTK-CSTKNOTE(,PARM) COMPUTE NEXT SLOT ADDRESS
         ST    PARM,CSTKADR             AND SAVE
         BR    R3                       RETURN
         SPACE
CSTK20   L     LINK,ASVCTLFM            GET ROUTINE ADDR
         BALR  TLINK,LINK               GO RESTORE STD I/P CTL FORMATS
         L     BASE2,CS2ADDR            RESTORE BASE FOR SECOND CSECT
         B     CSTK10
*
CSTKEXT  EQU   *
         L     PARM,CSTKADR             POP UP TO NEXT HIGHER LEVEL
         SH    PARM,CSTKLEN
         ST    PARM,CSTKADR
         MVC   SWITCH9(L'SWITCH9),CSTKSW RESTORE SWITCH9 STATUS
         C     PARM,BCSTK               TEST IF UP ON HIGHEST LEVEL
         BNH   CSTKEX2                  BRANCH IF YES
CSTKEX1  EQU   *
         LA    PARM,CSTKMEM             GET MEMBER NAME ADDRESS
         JFIND ADDR=(PARM)              FIND DISCONTINUED MEMBER
         L     PARM,CSTKADR             GET STACK ADDRESS       OY01713
         MVC   LASTFIND(L'LASTFIND),CSTKMEM MOVE MEMBER NAME
         JPOINTLB ADDR=(PARM)           POINT TO DISCONTINUED STREAM
         BR    R3                       RETURN
CSTKEX2  EQU   *
         GOIF  SSYSMD,ON=CSTKEX1        BRANCH IF EDITING SYS MACRO
         MVC   JSRCLN(L'JSRCLN*7),COPYSV3 RESTORE I/P CTL FORMATS
         MVC   TBGLN(L'TBGLN*6),COPYSV4
         MVC   INPUT,STNPADJ            RESTORE OLD STD-       @OX07230
         MVC   MINPUT,MINPADJ           OR ICTL I/P-CTL FORMS- @OX07230
         MVC   MINDIF,MINDFADJ          WHEN NOT IN-           @OX07230
         MVC   ENDWKA,ENDWKADJ          COPY ANYMORE.          @OX07230
         SET   JINLIB,OFF               INDICATE OUT OF LIBRARY MODE
         BR    R3                       RETURN
         EJECT
***********************************************************************
*   STMTSEQ ROUTINE IS CALLED EACH TIME A NEW STATEMENT IS BEING
*   EDITED. ITS FUNCTION IS TO CHECK THE SEQUENCE OF A STATEMENT
*   RELATIVE TO ITS ENVIRONMENT IN THE INPUT SOURCE STREAM.
*   (IT HAS NO CONCERN WITH THE SEQUENCE CHECK ACTIVATED BY A
*   'ISEQ' STATEMENT PROCESSED.)
*        LINKAGES ARE
*        BAL   RETURN,STMTDSQ
*        BAL   RETURN,STMTSEQ
***********************************************************************
         SPACE 3
STMTDSQ  EQU   *
         LA    TWKREG1,DMMY-AOTSEQ      DUMMY UP SWITCH BYTE
STMTSEQ  EQU   *
         IC    TRTN,AOTSEQ(TWKREG1)     INIT. SEQUENCING SWITCH
         STC   TRTN,AOTSW
         GOIF  (SKPMND,SKPEND),NONE=SSEQ20 IF NOT SKIP TO MEND/END
         L     INPTR,INPUT              RESET POINTER
         GOIF  SKPMND,ON=SSEQ10         BRANCH IF SKIP TO MEND
         TM    AOTSW,AOEND              TEST IF END STATEMENT
         BNO   ABTRTN                   CONTINUE TO FLUSH TO END
         L     INPTR,FPTRSV             RESET POINTER
         B     END                      GO PROCESS THE END STMT
SSEQ10   EQU   *
         TM    AOTSW,AOMEND             TEST IF MEND STATEMENT
         BNO   ABTRTN                   CONTINUE FLUSH TO MEND STMT
         BAL   RETURN,RESETPTR          REINIT E/T REC FOR PRNT OX00405
         L     INPTR,INPUT              RESET POINTER          @AX12923
         SET   SMAC,OFF                 CORRESPONDING MEND FOUND
         B     MENDZ                    GO PROCESS MEND STATEMENT
SSEQ20   EQU   *
         GOIF  AOPSYN,OFF=SSEQ22        BRANCH IF NOT OPSYN STATEMENT
         GOIF  SNOPSYN,OFF=(RETURN)     RETURN IF OPSYN ALLOWED
         MVI   OCSAVE,D0                CLEAR OPSYN OP CODE
         BAL   TLINK,ABSERR             ELSE, LOG ERROR
         DC    AL1(8*16+SEV12)          GO TO INVALID RTN THRU ABSERR
         DC    AL1(ERR12)               SUPPRESS D ENTRY
SSEQ22   EQU   *
         CLI   OCSAVE,JTCOPY            DOES THIS STMT INHIBIT OPSYS
         BNH   SSEQ25                   BR IF ICTL/ISEQ/OPSYN/COPY STMT
         CLI   OCSAVE,JTPRINT           CHECK IF PRINT STMT    @XA05837
         BE    SSEQ25                   OPSYN STILL OK         @XA05837
         CLI   OCSAVE,JTSPACE           CHECK IF IN COPY-SPACE RANGE
         BL    SSEQ24                   THESE INHIBIT FURTHER OPSYN
         CLI   OCSAVE,JTTITLE           CHECK IF IN RANGE ABOVE TITLE
         BNH   SSEQ25                   OPSYN STILL OK,SPACE/EJECT/TITL
SSEQ24   SET   SNOPSYN,ON               OPSYN NO LONGER ALLOWED
SSEQ25   EQU   *
         GOIF  SINCPY,OFF=SSEQ30        BRANCH IF NOT IN COPY CODE
         TM    AOTSW,AOMEND             TEST IF MEND STMT
         BO    SSEQ29                   GO TO SET SMAC OFF
         CLI   OCSAVE,JTMACRO           CHECK IF MACRO STMT
         BNE   SSEQ27                   BRANCH IF NOT
         SET   SMAC,ON                  MACRO STMT COPIED AT THIS LEVEL
SSEQ27   EQU   *
         GOIF  AOCOPYX,OFF=SSEQ30       BRANCH IF LEGAL IN COPY CODE
         BAL   TLINK,ABSERR             THIS STMT ILLEGAL IN COPY CODE
         DC    AL1(8*16+SEV22)          GO TO INVALID RTN THRU ABSERR
         DC    AL1(ERR22)               SUBROUTINE
SSEQ29   EQU   *
         SET   SMAC,OFF                 CORRESPONDING MEND FOUND
SSEQ30   EQU   *
         GOIF  SMDEF,OFF=SSEQ40         BRANCH IF NOT IN MACRO DEF.
         GOIF  SXPRTO,OFF=SSEQ35        BRANCH IF NOT EXPECTING PROTO
         TM    IOCID,BIT0+BIT1
         BNZ   BDPTO                    BRANCH IF ILLEGAL PROTO OP CODE
SSEQ35   EQU   *
         TM    AOTSW,AOMACROX           TEST IF LEGAL IN MACRO DEF
         BCR   BZ,RETURN                BRANCH IF LEGAL
         BAL   TLINK,ABSERR             ELSE, LOG ERROR
         DC    AL1(8*16+SEV27)          GO TO INVALID RTN THRU ABSERR
         DC    AL1(ERR27)               THIS STMT ILLEGAL IN MACRO
SSEQ40   EQU   *
         GOIF  SPGRMD,OFF=SSEQ45        BRANCH IF NOT EDIT'G PRG'R MAC
         GOIF  AOKBTNPM,OFF=SSEQ50      BRANCH IF ILLEGAL B/ PGR M DEF
         BR    RETURN                   RETURN
SSEQ45   EQU   *
         GOIF  SXMCRO,OFF=SSEQ47        BR IF NOT EXP'G MACRO STMT
         SET   SXMCRO,OFF
         CLI   OCSAVE,JTMACRO           YES, MUST BE SYSTEM MACRO DEF
         BCR   BEQ,RETURN               BRANCH IF THIS IS MACRO DEF
*        FIRST CARD IN THIS SYSTEM MACRO DEFINITION IS NOT A 'MACRO'.
*        LET GENERATOR LOG THE ERROR IN LINE. DEFINITION DISCARRED.
SSEQ46   EQU   *
         SET   SKPMND,ON               DUMMY SKIP
         SET   SNOSMCRO,ON              1ST STMT IN SYS M DEF NOT MACRO
         B     MEND1                    GET NEXT SYSTEM MACRO DEF
SSEQ47   EQU   *                        WE ARE IN OPEN CODE
         TM    AOTSW,AOPENCDX           TEST IF ALLOWED IN OPEN CODE
         BCR   BZ,RETURN                BRANCH IF YES
         TM    AOTSW,AICOPY             IS THIS AN ICTL STMT
         BZ    SSEQ48                   BR IF MACRO,MEXIT,MEND
         BAL   TLINK,ABSERR             LOG ERROR FOR ICTL
         DC    AL1(8*16+SEV12)          GO TO INVALID RTN VIA ABSERR
         DC    AL1(ERR12)               ICTL OCCURS AFTER FIRST STMT
SSEQ48   BAL   TLINK,ABSERR             LOG ERR FOR MACRO,MEXIT,MEND
         DC    AL1(8*16+SEV23)          GO TO INVALID RTN THRU ABSERR
         DC    AL1(ERR23)               STMT ILLEGAL IN OPEN CODE
*        OPEN CODE INITIALIZATION
SSEQ50   EQU   *
         GOIF  SICTL,ON=(RETURN)        OK IF VALID ICTL
         SET   (SPGRMD,SOPNCD),FLIP     OUT OF PRGMR MACS, NOW OPEN CD
         ST    RETURN,EDTSVX            SAVE RETURN POINT
         MVI   DDNDX1,OPENENT           SET UP INDEX FOR BR TO DIR RTN
         BAL   R3,DIR10                 INITIALIZE OPEN CODE
         L     RETURN,EDTSVX            RESTORE RETURN POINT
         B     SSEQ45                   CHECK SEQ OF FIRST CARD
         EJECT
********************************************
*        STATEMENT SEQUENCING TABLE        *
********************************************
         TBLGEN (ICTL,                                                 X
               ISEQ,                                                   X
               OPSYN,                                                  X
               COPY,                                                   X
               ANOP,                                                   X
               GBLA,                                                   X
               GBLB,                                                   X
               GBLC,                                                   X
               LCLA,                                                   X
               LCLB,                                                   X
               LCLC,                                                   X
               MACRO,                                                  X
               ACTR,                                                   X
               AGO,                                                    X
               AIF,                                                    X
               SETA,                                                   X
               SETB,                                                   X
               SETC,                                                   X
               MEXIT,                                                  X
               MEND,                                                   X
               END,                                                    X
               DXD,                                                    X
               EQU,                                                    X
               ORG,                                                    X
               CNOP,                                                   X
               CCW,                                                    X
               DC,                                                     X
               DS,                                                     X
               START,                                                  X
               CSECT,                                                  X
               DSECT,                                                  X
               COM,                                                    X
               ENTRY,                                                  X
               EXTRN,                                                  X
               WXTRN,                                                  X
               CXD,                                                    X
               LTORG,                                                  X
               PUNCH,                                                  X
               REPRO,                                                  X
               PUSH,                                                   X
               POP,                                                    X
               PRINT,                                                  X
               USING,                                                  X
               DROP,                                                   X
               SPACE,                                                  X
               EJECT,                                                  X
               TITLE,                                                  X
               MNOTE,                                                  X
               INVALID),                                               X
               (46,                     ICTL                           X
               5,                       ISEQ                           X
               22,                      OPSYN                          X
               33,                      COPY                           X
               0,                       ANOP                           X
               0,                       GBLA                           X
               0,                       GBLB                           X
               0,                       GBLC                           X
               0,                       LCLA                           X
               0,                       LCLB                           X
               0,                       LCLC                           X
               7,                       MACRO                          X
               0,                       ACTR                           X
               0,                       AGO                            X
               0,                       AIF                            X
               0,                       SETA                           X
               0,                       SETB                           X
               0,                       SETC                           X
               2,                       MEXIT                          X
               66,                      MEND                           X
               128,                     END                            X
               0,                       DXD                            X
               0,                       EQU                            X
               0,                       ORG                            X
               0,                       CNOP                           X
               0,                       CCW                            X
               0,                       DC                             X
               0,                       DS                             X
               0,                       START                          X
               0,                       CSECT                          X
               0,                       DSECT                          X
               0,                       COM                            X
               0,                       ENTRY                          X
               0,                       EXTRN                          X
               0,                       WXTRN                          X
               0,                       CXD                            X
               0,                       LTORG                          X
               0,                       PUNCH                          X
               0,                       REPRO                          X
               0,                       PUSH                           X
               0,                       POP                            X
               1,                       PRINT                          X
               0,                       USING                          X
               0,                       DROP                           X
               1,                       SPACE                          X
               1,                       EJECT                          X
               1,                       TITLE                          X
               0,                       MNOTE                          X
               0),                      INVALID                        X
               AOTSEQ,SEQT,1
         EJECT
***********************************************************************
*   PUTLSIZ ROUTINE IS CALLED EACH TIME BEFORE JPUTL IS ISSUED TO
*   DETERMINE THE LOGICAL OUTPUT BUFFER SIZE NEEDED FOR A PARTICULAR
*   STATEMENT.
*   (AN EDITED TEXT RECORD IS BUILT DIRECTLY INTO BUFFER, SO AS TO
*   SAVE A MOVE OF THE EDITED TEXT RECORD FROM A WORK AREA TO OUTPUT
*   BUFFER, AND TO SAVE 1/2K CORE THAT, OTHERWISE, WOULD HAVE TO BE
*   PROVIDED TO THE WORK BUFFER.) THE RESULT FROM THE CALCULATION IS
*   RETURNED IN REGISTER R11.
*        BAL   TLINK,PUTLSIZ
***********************************************************************
         SPACE 3
*****************************************
*        COMPUTE O/P BUFFER SIZE        *
*****************************************
PUTLSIZ  EQU   *
         GOIF  (SDTCMT,STRCMT),MIX=CMTSIZ COMMENTS STATEMENT SIZE
*        GOIF  SMIPRTO,ON=MISIZ         MACRO INSTR. OR PROTOTYPE
         GOIF  SPRVCT,ON=CNTSIZ         WITH CONTINUATION CARDS
         LA    R11,SZNORM               ELSE, MUST BE NORMAL SIZE
         B     OPUTL                    GO GET BUFFER ADDRESS
CMTSIZ   EQU   *
         LA    R11,SZCMT                GET BUFFER SIZE
         B     OPUTL                    GO GET BUFFER ADDRESS
MISIZ    EQU   *
         LA    R11,SZMI                 LOAD MI/PROTO SIZE
         B     OPUTL                    GO GET BUFFER ADDRESS
CNTSIZ   EQU   *
         LA    R11,SZCNT                LOAD CONTINUATION SIZE
         B     OPUTL                    GO GET BUFFER ADDRESS
         EJECT
***********************************************************************
*   ABTRTN IS CALLED WHEN A MACRO DEFINITION IS TO BE FLUSHED.
***********************************************************************
ABTRTN   EQU   *
         BAL   RETURN,RESETPTR          REINIT E/T REC FOR PRINT ONLY
         LA    INDEXP,JTHDRLN+2(,INDEXO)  RESET TEXT POINTER
         SET   SNOPND,ON                INDICATE TO RETURN
         SET JPRONLY,ON
         BAL   RETURN,SAVPTR            EDIT AS COMMENTS FIELD
         L     LINK,ARDSRC              POINT TO RDSRC
         BALR  RETURN,LINK              READ ONE CARD
         DC    AL2(RBYPONE-RFSTCRD)     BYPASS ONE CARD
         GOIF  SINEOF,ON=EOFRTN         BRANCH IF END OF FILE
         LA    R11,SZCNT                NO, SO....
         BAL   RETURN,OPUTL             GET O/P BUFFER
         BAL   RETURN,HDINIT            INITIALIZE HEADER
         SET   SUPDNT,ON                SUPPRESS DIRECTORY ENTRY
         B     PROCNXT                  GO PROCESS AS NORMAL
         EJECT
***********************************************************************
*        CHECK NAME FOR SEQUENCE SYMBOL OR BLANK                      *
CKANYSYM EQU   *
         GOIF  (ROSYM,RVSYM)            RETURN IF NAME A
         BCR   7,TLINK                  VS OR OS
CHKSSNM  EQU   *
         GOIF  RSSYM,ON=(TLINK)         RETURN IF NAME A S.S.
CHKNM    EQU   *
         GOIF  SNMFND,OFF=(TLINK)       RETURN IF NO NAME
         ST    TLINK,EDTSVX             SAVE RETURN POINT
         BAL   RETURN,NAMERR            ELSE, LOG ERROR
         L     TLINK,EDTSVX             RESTORE RETURN POINT
         BR    TLINK                    RETURN TO CALLER
         SPACE 3
         JPATCH  X1A10,E70
         EJECT
         JCSECT (X1A20=CS3)
***********************************************************************
*                                                                     *
* RDSRC - THIS ROUTINE IS CALLED WHEN A NEW STATEMENT OR A CONTINUATION
*   RECORD IS TO BE READ. IT CALLS 'JINPUT' MACRO TO READ A RECORD
*   FROM SYSTEM INPUT, OR FROM MACRO LIBRARY IF 'JINLIB' BIT IN
*   'JINFLAG' BYTE IS ON.  IT SEQUENCE CHECKS THE RECORD WHEN ISEQ
*   SWITCH (SWITCH1 BIT 0) IS ON. FINALLY, IT MOVES THE RECORD TO
*   INPUT WORK BUFFER.
*        BAL   RETURN,RDSRC
*        BAL   RETURN,RDSRC05
*
***********************************************************************
*                                                                     *
*   RFSTCRD = READ FIRST CARD OF A STATEMENT - ALWAYS FROM READNEXT   *
*   RALLCNT = READ ALL CONTINUATIONS - FOR MACHINE/ASSEMBLER OPS      *
*   RONECNT = READ ONE CONTINUATION - FOR MACRO CALLS/PROTOTYPE STMTS *
*   RBYPCNT = BYPASS ALL CONTINUATIONS - FOR STMTS WITH HARD ERRORS   *
*   RONECRD = READ ONE CARD - FOR REPRO STATEMENT                     *
*   RBYPONE = BYPASS ONE CARD IN EDITED FORMAT - FOR DATA FLUSHING    *
*                                                                     *
***********************************************************************
RDSRC    EQU   *
         L     INPTR,INPUT              UPDATE INPTR
RDSRC05  EQU   *
         STM   R12,R9,SAVMALL           SAVE REGISTERS
         BALR  BASE3,0                  REDEFINE BASE REGISTER
         USING *,BASE3
         LH    TWKREG1,D0(,RETURN)      GET BRANCH POINT
         B     RFSTCRD(TWKREG1)         AND FAN OUT
RFSTCRD  EQU   *                        READ FIRST CARD
         SET   (SNXTCT,SPRVCT),OFF      RESET SWITCHES
RDSRC10  EQU   *
         NI    CNTCTR,ALLOFF
RDSRC20  EQU   *
         L     TWKREG1,DSTGBGN          INITIALIZE STRING AREA POINTER
         ST    TWKREG1,DSTGADJ          TO ORIGINAL POINT
         ST    TWKREG1,DSTGNDX
         MVI   D0(TWKREG1),D0           RESET STRING COUNT
         B     RCONT                    READ CONTINUATIONS IF ANY
RONECRD  EQU   *                        READ ONE CARD
         SET   SONECD,ON
         B     RFSTCRD                  GO
RBYPONE  EQU   *                        BYPASS ONE CARD IN EDITED FORM
         SET   SBYONE,ON                INDICATE READ ONE CARD
         B     RFSTCRD                  GO
RBYPCNT  EQU   *                        BYPASS ALL CONTINUATIONS
         SET   SBYCNT,ON
         B     RDSRC10                  FLUSH THROUGH CONTINUATION
RONECNT  EQU   *                        READ ONE CONTINUATION CARD
         SET   SONECT,ON
         B     RDSRC20                  GO GET ONE CARD
RALLCNT  EQU   *
         SET   SALLCT,ON
RCONT    EQU   *
         GOIF  (SBYCNT,SONECT,SALLCT),NONE=RINPT BR IF NO CONTINUATION
RCNTLP   EQU   *
         GOIF  SPRVCT,OFF=REXIT         RETURN IF NOT TO BE CONT'D
RINPT    EQU   *
         JINPUT                         GET INPUT BUFFER POINTER
         BNP   REOFX                    GO TO END OF FILE ROUTINE
         ST    RETADR,IPTRSV            SAVE INPUT POINTER
RINIT    EQU   *
         LM    R3,R5,JSRCLN             REGISTER INITIALIZATION
         IC    TWKREG1,CNTCTR           INCREMENT CARD COUNT
         LA    TWKREG1,D1(,TWKREG1)
         STC   TWKREG1,CNTCTR
         BAL   RETURN,MVSRC             MOVE RECORD TO INPUT WK BUF
*                                       SEPARATE STRINGS FROM DATA
         ST    INPTR,ENDATA
         MVI   D0(INPTR),JBLANK         PATCH A BLANK FOR SCANNER
         GOIF  SONECD,ON=REXIT          RETURN TO CALLER IF RONECD
         LM    SEQREG,SQLREG,JSEQCL
*
         GOIF  SNOCNT,ON=RSEQCHK        BRANCH IF CONT'N NOT ALLOWED
         LA    TWKREG1,D0(CNTREG,RETADR)
         CLI   D0(TWKREG1),JBLANK       TEST IF ANY CONTINUATION
         BE    RSEQCHK                  NO, GO CHECK SEQUENCE
         SET   SNXTCT,ON                INDICATE TO BE CONTINUED
RSEQCHK  EQU   *
         GOIF  SISEQ,OFF=RFCCHK         BRANCH IF NOT TO SEQ CHK
         LA    TWKREG1,D0(SEQREG,RETADR)
         EX    SQLREG,SEQMV             MOVE SEQ FIELD TO TR AREA
         EX    SQLREG,SEQTR             TRANSLATE
         EX    SQLREG,SEQCPR            SEQUENCE CHECK
         EX    SQLREG,SEQSAVE           SAVE NEW SEQ VALUE
         BH    RFCCHK                   SEQUENCE OK
         BAL   TLINK,WRNERR             GO LOG SEQUENCE ERROR
         DC    AL1(SEV25)               .
         DC    AL1(ERR25)               INPUT SEQUENCE ERROR
*
RFCCHK   EQU   *
         GOIF  (SONECD,SBYCNT,SONECT,SALLCT),NONE=RMORCNT IF RFSTCRD
         GOIF  SPRVCT,OFF=REXCS         IF THIS CD NOT CONT OF PREV CD
         L     CBGREG,JCTBGN                                    OX00081
         LA    INPTR,D0(BEGREG,RETADR)  PREPARE TO GO CHECK BLANKS
         LA    TWKREG2,D0(CBGREG,RETADR)
         BAL   TLINK,SKPBLK0            SKIP BLANKS
         L     INPTR,ENDATA             RESTORE INPTR
         GOIF  SNOFND,ON=REXCS          O.K. IF BLANK
         BAL   TLINK,WRNERR             GO LOG CONTINUATION ERROR
         DC    AL1(SEV26)               CONTINUATION CARD STARTS
         DC    AL1(ERR26)               BEFORE CONTINUATION COLUMN
*
REXCS    EQU   *
         GOIF  SALLCT,OFF=RMORCNT       BRANCH IF NOT RALLCNT
         CLI   CNTCTR,J3                CHECK CARD COUNT
         BL    RMORCNT                  GO GET CONTINUATIONS
         BH    REXCS10                  TOO MANY CONTINUATIONS, ERROR
         GOIF  SNXTCT,ON=REXCS10        MORE CONT'NS IS ERROR
         SET   SPRVCT,OFF               RESET CONTINUATION BIT
         B     RAXIT                    EXIT
REXCS10  EQU   *
         BAL   TLINK,WRNERR             GO LOG CONTINUATION ERROR
         DC    AL1(SEV69)               MORE THAN 2 CONTINUATION
         DC    AL1(ERR69)               CARDS IN THIS STMT
         SET   SBYCNT,ON                BYPASS ALL CONTINUATIONS
         SET   SALLCT,OFF
*
RMORCNT  EQU   *
         SET   SPRVCT,OFF               RESET CONTINUATION SWITCH
         GOIF  SNXTCT,OFF=RAXIT         BRANCH IF NO MORE CONT'NS
         SET   SPRVCT,ON                INDICATE TO BE CONTINUED
         SET   SNXTCT,OFF               PREPARE FOR NEXT CARD
*
RAXIT    EQU   *
         GOIF  SALLCT,ON=RCNTLP         READ NEXT CARD IF RALLCNT
REXIT    EQU   *                        RETURN TO CALLER
         SET   (SONECD,SONECT,SALLCT),OFF
*        RBYPCNT BIT WILL BE SET OFF AT WRAPFLD WHEN ALL CARDS TO BE
*        BYPASSED ARE READ.
*
         LM    R12,R9,SAVMALL           RESTORE REGISTERS
         B     D2(,RETURN)              RETURN TO CALLER
REOFX    EQU   *
         SET   SINEOF,ON                INDICATE END OF FILE
         B     REXIT                    RETURN TO CALLER
*
MVSRC    EQU   *
         ST    RETURN,EDTSVX            SAVE RETURN POINTER
         LR    SRCPTR,RETADR            SET SOURCE RECORD POINTER
         LA    SRCEND,CRDLN(,SRCPTR)    END RECORD POSITION PLUS 1
         L     DSTGPTR,DSTGNDX          RESERVE SPACE FOR STRING COUNT
         LA    DSTGPTR,D1(,DSTGPTR)
         ST    DSTGPTR,DSTGNDX
         NI    STGCNT,ALLOFF            ZERO OUT STRING COUNT
         LA    STGLOC,D1                GET STRING LOCATION
         GOIF  SBYCNT,ON=MVSRC1         EDIT AS NON-CONT'N IF TO BYPASS
         GOIF  SPRVCT,ON=MVPBSTG        BRANCH IF A CONT'N CARD
MVSRC1   EQU   *
         LTR   BEGREG,BEGREG            IF NO PRE-BEGIN STRING
         BZ    MVDATA                   GO MOVE DATA
         L     TWKREG2,PBGLEN           GET PRE-BEGIN STRING LENGTH -1
MVSTRING EQU   *
         LA    R1,D1(TWKREG2,SRCPTR)    GET UPPER LIMIT OF SCAN
         LR    TWKREG1,SRCPTR           GET BEGIN ADDRESS TO BE SCANNED
         B     MVSTR20                  GO TEST FOR END OF STRING
MVSTR10  EQU   *
         LA    TWKREG1,D1(,TWKREG1)     STEP TO NEXT COLUMN
MVSTR20  EQU   *
         CR    TWKREG1,R1               TEST IF END OF STRING
         BE    MVNONE                   YES, BLANK STRING
         CLI   D0(TWKREG1),JBLANK       IS IT A BLANK
         BE    MVSTR10                  YES, GO CHECK NEXT COLUMN
         STC   STGLOC,SOPTR             MOVE IN STRING OUTPUT POINTER
         EX    TWKREG2,MVSTRG           MOVE STRING
         LA    TWKREG2,D1(,TWKREG2)     MAKE IT TRUE LENGTH
         STC   TWKREG2,SOLEN            MOVE IN STRING TRUE LENGTH
         LA    SRCPTR,D0(TWKREG2,SRCPTR) POINT TO NEXT FIELD
         IC    TWKREG1,STGCNT           UPDATE STRING COUNT
         LA    TWKREG1,D1(,TWKREG1)     BY ONE
         STC   TWKREG1,STGCNT
         LA    TWKREG1,D2(TWKREG2,DSTGPTR) UPDATE STRING INDEX
         ST    TWKREG1,DSTGNDX
MVSTR30  EQU   *
         CR    SRCPTR,SRCEND            TEST IF END OF RECORD
         BL    MVDATA                   NO, GO MOVE DATA
MVRTN    EQU   *
         L     DSTGPTR,DSTGADJ          BACK UP TO STRING POINTER TO
         IC    TLINK,STGCNT             INSERT STRING COUNT INTO
         STC   TLINK,SCCNT              EDITED TEXT
         L     TLINK,DSTGNDX            UPDATE ADJUSTED POINTER
         ST    TLINK,DSTGADJ
         L     RETURN,EDTSVX            YES, RETURN TO CALLER
         BR    RETURN                   RETURN
MVNONE   EQU   *
         LR    SRCPTR,TWKREG1           POINT TO NEXT FIELD
         B     MVSTR30                  GO TEST FOR END OF RECORD
MVPBSTG  EQU   *
         L     TWKREG2,JCTBGN           PREPARE TO SCAN TO CONT'N BEG.
         BCTR  TWKREG2,0                BACK UP 1
         B     MVSTRING                 GO SCAN TO END OF STRING
*
MVDATA   EQU   *
         LR    TWKREG2,SLNREG           GET SOURCE LENGTH
         GOIF  SPRVCT,OFF=MVDEX         BRANCH IF NOT CONT'D
         GOIF  SBYCNT,ON=MVDEX          BRANCH IF TO BYPASS ONE CARD
         L     TWKREG2,JCTLN            ELSE, GET CONT'N LENGTH
MVDEX    EQU   *
         LR    DSTGPTR,INPTR            SET UP DESTINATION  POINTER
         EX    TWKREG2,MVSEGT
         LA    INPTR,D1(TWKREG2,INPTR)  BUMP WORK AREA POINTER
         LA    SRCPTR,D1(TWKREG2,SRCPTR) POINT TO NEXT FIELD
         CR    SRCPTR,SRCEND            TEST IF END OF DATA
         BNL   MVRTN                    YES, EXIT
         L     TWKREG2,PNDLEN           LOAD POST-END STRING LENGTH
         LA    STGLOC,D1(,CNTREG)       SET UP POST-END STRING LOCATION
         L     DSTGPTR,DSTGNDX          SET UP DESTINATION POINTER
         B     MVSTRING                 GO SCAN TO END OF STRING
MVSEGT   MVC   D0(0,DSTGPTR),D0(SRCPTR) OFF-THE-LINE MOVE
MVSTRG   MVC   SDATA(0),D0(SRCPTR)      OFF-THE-LINE MOVE
SEQMV    MVC   SEQSVT(0),D0(TWKREG1)    MOVE SEQ FIELD TO TR AREA
SEQTR    TR    SEQSVT(0),JTRTABLE       TRANSLATE
SEQCPR   CLC   SEQSVT(0),SEQSV          COMPARE SEQ FIELD
SEQSAVE  MVC   SEQSV(0),SEQSVT          SAVE NEW SEQ VALUE
         DROP  INDEXP,R14
         EJECT
*********************************************************
*        PROTOTYPE STATEMENT PARAMETER PROCESSOR        *
*********************************************************
         USING MPROTO,INDEXP
         USING MPMT,R14
MIPRTOIN JSAVE BASE=NO
         LR    BASE3,LINK               REDEFINE BASE REGISTER
         USING MIPRTOIN,BASE3
         GOIF  SXPRTO,OFF=MCALLIN       BRANCH IF MCARO CALL
PROTOIN  EQU   *                        PROTOTYPE PROCESSOR
         SET   SDENT,OFF                INSURE SS DEF IS NOT ENTERED
         SET   JTPROTO                  INDICATE PROTO
         BAL   RETURN,DTADJ             MAKE DATA ADJUSTMENT
         B     STEND                    END STATEMENT IF RETURN HERE
         GOIF  SNMFND,ON=PRTX           BRANCH IF THERE IS A NAME
* IF NO NAME, INDICATE THAT A NULL PARAMETER EXISTS FOR MACRO EXPANSION
         L     R3,GTPVALOC              GET POS PARM COUNTER INDICATOR
         LA    R3,D3(,R3)               BUMP POS PARM CTR BY 3 BYTES
         ST    R3,GTPVALOC              SAVE FOR MACRO GENERATOR
PRTX     EQU   *
         LA    R11,SZMI
         BAL   RETURN,OPUTL             GET O/P BUFFER
         BAL   RETURN,HDINIT            INITIALIZE HEADER
         ST    INPTR,FPTRSV             SAVE POINTERS
         ST    INDEXP,OFPTRSV
         SET   JTPPKEY                  ASSUME KEYWORD PARAMETER
         SET   JPSOP,ON
PRTX10   EQU   *
         CLI   D0(INPTR),JAMPER         TEST IF AMPERSAND
         BNE   PRTCMA                   BRANCH IF NOT
*BUMP THE POINTER PAST THE '&' FOR THE DIRECTORY ROUTINE
         LA    INPTR,D1(,INPTR)         BUMP OVER V SYM HEAD
         BAL   RETURN,TRT01             TRT V SYMBOL
         BCT   R3,BADPARM               ERROR IF NOT A/N STRING
         MVI   FLGBYT,PARMFLG           ASSUME POSITIONAL PARAMETER
         GOIF  SNMFND,OFF=PRTX40        MUST BE OPERAND IF NOT NAME
         CLI   D0(R1),JBLANK            TERMINATOR MUST BE A BLANK
         BNE   BADPARM                  ELSE,ERROR
PRTX15   CH    R15,H7                   LENGTH MUST BE RIGHT
         BNL   BADPARM                  ELSE, LOG ERROR
         LR    PARAM2,TWKREG2           GET MOVE LENGTH OF SYMBOL
         LR    PARM,INPTR               GET THE POINTER
         MVI   DDNDX1,VARBSYMD          INDICATE VAR SYM DEFINITION
         BAL   R3,DIRENT                MAKE DIRECTORY ENTRY
         GOIF  SNMFND,OFF=PRTX20        GO FIND NEXT OPERAND
PRTX16   BAL   RETURN,ADJ20             MAKE DATA ADJUSTMENT
         B     STEND                    END STATEMENT IF RETURN HERE
         B     PRTX                     EDIT OPERAND
PRTX20   EQU   *
         TM    DERRCD,BITFF             SEE IF ERROR RETURNED FROM DIR
         BNZ   SKMNDST                  FLUSH MACRO IF ERROR FOUND
         LR    INPTR,R1                 UPDATE POINTER
         CLI   D0(INPTR),JEQUAL         TEST IF KWD PARAM
         BNE   PRTX30                   BRANCH IF NOT
         MVC   VECPTR,D1(R11)           SAVE VECTOR POINTER
         LA    R14,MPHDL(,INDEXP)       GET HDR RECORD LENGTH
PRTX25   ST    R14,MTXTP                SAVE MT POINTER
         LR    R15,R14                  SAVE HDF BASE REGISTER
         SR    R15,INDEXO               COMPUTE OPERAND POINTER
         STH   R15,JTOPP
         BAL   RETURN,BLDPMT            BUILD PARAM MT
         BAL   RETURN,NEXTPM            EDIT KWD OPERAND
         SET   (DSDTX,DECMA,DEEQL,DLPRN),OFF RESET INDICATORS
         BAL   RETURN,WRAPOPND          WRAP UP OPERAND
PRTX30   EQU   *
         CLI   D0(INPTR),JRPARN         TEST IF END OF SUBLIST
         BNE   PRTX35                   BRANCH IF NOT
         LA    INPTR,D1(,INPTR)         YES, BUMP OVER R PAREN
         BAL   R12,DPARCT               DECREMENT PAREN COUNT
         BL    UNBAL                    LOG ERROR IF UNBAL PARENS
PRTX35   EQU   *
         CLI   D0(INPTR),JCOMMA         OR IS IT A COMMA
         BE    PRTX50                   BRANCH IF YES
         CLI   D0(INPTR),JBLANK         OR IS IT A BLANK
         BE    STEND                    END STATEMENT
         B     BADPARM1                 BAD PARAMETER
PRTX40   EQU   *
         CLI   D0(R1),JEQUAL            IS IT KEYWORD
         BNE   PRTX15                   BRANCH IF NOT
         MVI   FLGBYT,PARMFLG+VPTYP     ELSE, SO INDICATE
         SET   SKWPRM,ON                INDICATE PROCESSING KWD
         B     PRTX15                   CONTINUE CHECKING
PRTX50   EQU   *
         LA    INPTR,D1(,INPTR)
         L     PARAM1,MINPUT
         BAL   TLINK,SHFTDTA            SHUFFLE DATA A LITTLE
         CLI   D0(INPTR),JBLANK         IS COMMA FOLLOWED BY A BLANK
         BNE   PRTX                     EDIT NEXT PARAMETER
         GOIF  SNOCNT,ON=STEND          END STMT IF NO CONT'N ALLOWED
         BAL   RETURN,BUMPD             BUMP OVER COMMENTS
*
PRTX70   EQU   *
         L     PARAM1,MINPUT
         BAL   TLINK,SHFTDTA            SHUFFLE, SHUFFLE
         B     PRTX                     EDIT NEXT PARAMETER
PRTCMA   EQU   *
         CLI   D0(INPTR),JCOMMA         TEST IF AN OMITTED PARAMETER
         BNE   PRTBLK                   BRANCH IF NOT
         GOIF  SNMFND,ON=BADPARM        BAD PARAMETER
*NOW WE KNOW IT'S A NULL PARAMETER, UP THE PARM COUNTER FOR GENERATOR
         L     R3,GTPVALOC              GET POS PARM COUNTER INDICATOR
         LA    R3,D3(,R3)               BUMP POS PARM CTR BY 3 BYTES
         ST    R3,GTPVALOC              SAVE FOR MACRO GENERATOR
         B     PRTX50                   SHIFT DATA IF YES
PRTBLK   CLI   D0(INPTR),JBLANK         TEST IF END OF STATEMENT
         BNE   BADPARM                  LOG ERROR IF NOT
         B     STEND                    ELSE, WRAP UP STATEMENT
         SPACE 3
*        LINKAGES ARE
*              BAL   RETURN,DTADJ
*              BAL   RETURN,ADJ20
DTADJ    EQU   *
         ST    RETURN,ADJSV             SAVE RETURN POINT
         L     RCNT,INPUT               BEGIN OF FIELD
         BAL   RETURN,PRESUB1           OUTPUT PRE-SUBSTITUTION RECORD
         GOIF  SNMFND,OFF=ADJ25         BRANCH IF NO NAME
         L     INPTR,INPUT              POINT TO NAME
         GOIF  SXPRTO,ON=ADJOUT         LET GO IF PROTO
         GOIF  NSSYM,ON=ADJ25           IGNORE NAME IF SS
ADJOUT   EQU   *
         L     RETURN,ADJSV             RESTORE POINTER
         B     D4(,RETURN)              RETURN
ADJ20    EQU   *
         ST    RETURN,ADJSV             SAVE RETURN POINTER
ADJ25    EQU   *
         SET   SNMFND,OFF               INDICATE IN OPERAND
         L     INPTR,OPNDPTR            BUMP TO OPERAND FIELD
ADJ30    BAL   TLINK,SKPBLK             GO FIND NEXT PARAMETER
         GOIF  SNOFND,ON=ADJ40          BRANCH IF NOT FOUND YET
         L     TWKREG1,ENDATA           MAKE ENDATA ADJUSTMENT
         SH    TWKREG1,MINDIF           FOR 1ST CARD IN STATEMENT
         ST    TWKREG1,ENDATA           BEFORE SHIFTING
         L     PARAM1,INPUT
         BAL   TLINK,SHFTDTA            SHIFT DATA
         B     ADJOUT                   RETURN
ADJ40    EQU   *
         MVC   DTLENG(L'DTLENG),TCNTLN2
ADJ45    EQU   *
         GOIF  SPRVCT,OFF=ADJOUT2       ELSE,CHECK IF TO BE CONTINUED
         L     INPTR,MINPUT
         BAL   RETURN,READATA           READ NEXT CARD
         L     INPTR,MINPUT
         BAL   TLINK,SKPBLK             CHECK IF PARAM STARTS HERE
         GOIF  SNOFND,ON=ADJ45          IF NOT, NEXT CARD
         L     INPTR,ENDATA
         BAL   TLINK,GETDNT            YES, READ IN BUFFER FULL
         B     ADJOUT                   GO EDIT THEM
ADJOUT2  EQU   *
         L     RETURN,ADJSV             RESTORE POINTER
         BR    RETURN                   RETURN TO CALLER
BUMPD    EQU   *
         LH    RCNT,DTLENG              GET DATA LENGTH
         SH    RCNT,COLCTR              MINUS CURRENT LENGTH
         AR    INPTR,RCNT               ADD INTO INPTR
         BR    RETURN                   RETURN TO CALLER
SHFTDTA  EQU   *
         L     TWKREG1,MINPUT           GET BEGIN OF BUFFER
         L     TWKREG2,ENDWKA           COMPUTE DATA MOVE LENGTH
         SR    TWKREG2,INPTR
         LR    PARAM2,INPTR
         CH    TWKREG2,H255             DO WE SHIFT MORE THAN 255
         BNH   SHIFT                    MOVE IF NOT OVER 255 CHAR
         MVC   D0(MAXCNT,TWKREG1),D0(PARAM2) ELSE, MOVE 255 FIRST
         SH    TWKREG2,H255             MAKE ADJUSTMENT
         AH    TWKREG1,H255             TO MOVE THE REMAINING
         AH    PARAM2,H255              NUMBER OF BYTES
         BCTR  TWKREG2,0                REDUCE MOVE LENGTH BY 1
SHIFT    EX    TWKREG2,SHMOVE           GO SHIFT DATA INTO WORK AREA
         SR    INPTR,PARAM1             NUMBER OF BYTES SHIFTED
         LH    RCNT,CRDCTR              GET CARD NUMBER
         LH    TWKREG2,COLCTR           GET ACCUMULATED NUM OF COL
         AR    TWKREG2,INPTR            ADD ADDITIONAL NUM OF COLUMNS
COUNT    CH    TWKREG2,DTLENG           STILL IN THE SAME CARD OR NOT
         BL    COUNTX                   YES.
         SH    TWKREG2,DTLENG
         AH    RCNT,H1
         MVC   DTLENG(L'DTLENG),TCNTLN2 SET DATA LENGTH
         B     COUNT                    LOOP UNTIL END OF FIELD
COUNTX   EQU   *
         STH   TWKREG2,COLCTR           SAVE COUNTERS
         STH   RCNT,CRDCTR
         L     TWKREG1,ENDATA
         SR    TWKREG1,INPTR            FIND OUT ENDATA AFTER SHIFTING
         ST    TWKREG1,ENDATA           WHICH IS NEXT AVAILABLE LOC
         LR    INPTR,TWKREG1            FOR NEXT CARD
GETDNT   ST    TLINK,RTNSV1             SAVE RETURN POINT
GETDTA   EQU   *
         GOIF  SPRVCT,OFF=GETDX         EXIT IF NOT CONTINUED
GETD10   L     TWKREG2,ENDWKA           ELSE, CHECK IF STILL HAVE ROOM
         SR    TWKREG2,INPTR            FOR ONE MORE CARD
         CH    TWKREG2,DTLENG
         BNH   GETDX                    NO MORE ROOM, EXIT.
         BAL   RETURN,READATA           GET ONE CARD
         L     INPTR,ENDATA
         B     GETDTA                   GET NEXT CARD
         SPACE
R9SAVE   EQU   OPCDPTR
READATA  ST    RETURN,R9SAVE
         L     RETURN,ARDSRC05          GET BRANCH ADDRESS
         BALR  RETURN,RETURN            READ IT IN
         DC    AL2(RONECNT-RFSTCRD)     .
         GOIF  SINEOF,OFF=READATA5      EOF NOT ALLOWED        @OX07290
         LA    R10,ERR263               LOAD ERR MSG NR        @OX07290
         B     JABORT                   GEN ERR MSG, TERMINATE @OX07290
READATA5 EQU   *                                               @OX07290
         LA    R11,SZCMT
         BAL   RETURN,OPUTL             GET O/P BUFFER
         BAL   RETURN,HDINIT            INITIALIZE HEADER
         SET   JPSOP,ON                 INDICATE ASSEMBLER OP
         SET   JNOCNT,ON                PRINT-ONLY, NO STMT NUMBER
         SET   JTPROTO                  INDICATE PROTO
         GOIF  SMI,OFF=GETD20           BRANCH IF NOT MI
         SET   JTCALL                   ELSE, RESET IOC
GETD20   EQU   *
         BAL   RETURN,PRESUB            OUTPUT PRE-SUB RECORD
         L     RETURN,R9SAVE
         BR    RETURN                   RETURN
GETDX    EQU   *
         L     INPTR,MINPUT             RESTORE INPTR
         L     TLINK,RTNSV1             RESTORE RETURN POINT
         BR    TLINK                    RETURN TO CALLER
SHMOVE   MVC   D0(0,TWKREG1),D0(PARAM2) OFF-THE-LINE MOVE
PRESUB   EQU   *
         L     TWKREG1,JCTBGN           COMPUTE DIF B/ BEGIN COL AND
         S     TWKREG1,JBEGCL           CONT'N COL TO DETERMINE PRE-SUB
         LR    RCNT,INPTR               RECORD BEGIN LOCATION
         SR    RCNT,TWKREG1
PRESUB1  EQU   *
         ST    RETURN,RTNSV
         SET   SCTLRTN,ON
         B     WRAPF1                   OUTPUT PRE-SUB RECORD
RECLN    EQU   *
         LR    TWKREG1,INDEXP
         SR    TWKREG1,INDEXO           CALCULATE AND
         STH   TWKREG1,JTRLI            SAVE RECORD LENGTH
         BR    RETURN                   RETURN TO CALLER
*
SKMNDST  SET   SKPMND,ON                FLUSH MACRO DEFINITION
         SET   SBDPROTO,ON              BAD PROTO
STEND    EQU   *
         SET   SXPRTO,OFF
         MVI  PARMSTAT,D0
CNTFLSH  L     INPTR,INPUT
         BAL   TLINK,GETDNT             FLUSH A BUFFER FULL OF CONS
         GOIF  SPRVCT,ON=CNTFLSH        BRANCH IF STILL MORE TO FLUSH
         LA    R11,D8                   LESE, ...
         BAL   RETURN,OPUTL             GET O/P BUFFER FOR
         MVC   JTRLI(L'PPHD),PPHD       END-OF-PARAM RECORD
PROTOUT  JRETURN                        RETURN TO CALLER
*
PPHD     DS    0CL8                     PARAM END RECORD
         DC    AL2(D8)                  RECORD LENGTH
         DC    AL1(JPSOP,D0)            FLAGS
         DC    AL1(JTPEND,D0)           OP CODE
         DC    AL1(D0,D0)               NOT USED
         DS    0F
BLDPMT   EQU   *
         BAL   R12,MTENTRY1             BUILD MT
         LA    INPTR,D1(,INPTR)
         ST    INPTR,FPTRSV             UPDATE POINTER
         SET   (DECMA,DEEQL),ON
         BR    RETURN                   RETURN TO CALLER
         SPACE 3
         EJECT
MCALLIN  EQU   *
         SET   JTCALL                   INDICATE MACRO CALL
         SET   SMI,ON
MACPRM   BAL   RETURN,DTADJ             MAKE DATA ADJUSTMENT
         B     PRESTEND                 END STMT IF RETURN HERE
         GOIF  SNMFND,OFF=MACPRM0       BRANCH IF NO NAME
         BAL   RETURN,MPOPND            EDIT THE NAME PARAMETER
         GOIF  JSUBOPND,ON=MACPRM2      NAME WAS VARIABLE SYMBOL
         GOIF  NMPURE,ON=BADNAME        BR IF NAME SCAN HAD IMPURITY
         B     MACPRM2                  GO ON TO DO OPERAND
MACPRM0  EQU   *
         LA    R11,SZMI                 PREPARE TO OUTPUT
         BAL   RETURN,OPUTL             OMITTED OPERAND
         MVC   D0(L'OMTNM,INDEXO),OMTNM FOR MACRO CALL NAME
MACPRM1  BAL   RETURN,MPOPND            EDIT NEXT OPERAND
MACPRM2  GOIF  SUBLST,ON=MACPRM1        NEXT PARAM IF IN SUBL
         GOIF  SNMFND,OFF=MACPRM1       OR IN OPERAND FIELD
         BAL   RETURN,ADJ20             ELSE ONE MORE DATA ADJUSTMENT
         B     STEND                    END STATEMENT IF RETURN TO HERE
         B     MACPRM1                  NEXT OPERAND IF RETURN TO HERE
PRESTEND LA    R11,SZMI                 PREPARE TO OUTPUT
         BAL   RETURN,OPUTL             OMMITTED OPERAND
         MVC   D0(L'OMTNM,INDEXO),OMTNM FOR MACRO CALL NAME
         B     STEND                    NOW FLUSH
         SPACE 3
MPOPND   EQU   *
         ST    RETURN,MPOPSV            SAVE RETURN LINKAGE
MIX      LA    R11,SZMI
         BAL   RETURN,OPUTL             GET O/P BUFFER
         BAL   RETURN,HDINIT            INITIALIZE HEADER
         ST    INPTR,FPTRSV             SAVE INPTR
         ST    INDEXP,OFPTRSV           SAVE HEADER DATA POINTER
         LA    R14,MPHDL(,INDEXP)       GET HDR RECORD LENGTH
         ST    R14,MTXTP                SAVE META TEXT POINTER
         SR    R14,INDEXO               COMPUTE OPERAND POINTER
         STH   R14,JTOPP                AND SAVE
         SET   POSSUBL,OFF              INIT SUBLIST 1ST SCAN SWITCH
         SET   JTCPPOS                  ASSUME POSITIONAL CALL
         SET   JPSOP,ON
*
         BAL   RETURN,NEXTPARM          EDIT ONE PARAMETER
MIX5     EQU   *
         CLI   MSERR,D0                 TEST FOR ERRORS
         BE    MIX7                     KEEP GOING IF NONE
         GOIF  MXRPRN,ON=UNBAL1         BR IF PAREN NOT PAIRED @AX12896
         CLI   JTIOP,JTCPKEY            KEYWORD CALL PARM?     @AY14037
         MVC   D0(L'OMTNM,INDEXO),OMTNM OMITTED PARM RECORD
         BNE   MIX6                     NOT KW DONT CH OPCODE  @AZ19665
         MVI   JTIOP,JTCPKEY            THIS WAS A KW OPERAND  @AY14037
MIX6     GOIF  SUBLST,OFF=MIX8          IN SUBLIST ?           @AZ19665
         SET   MPSB,ON                  YES MARK IT            @AZ19665
         B     MIX8                     THE RECORD IS PERFECT AS IS
MIX7     EQU   *
         BAL   RETURN,WRAPOPND          ELSE WRAP UP OPERAND
MIX8     CLI   D0(INPTR),JRPARN         BRANCH IF ....
         BNE   MPX10                    BRANCH IF NOT
         BAL   R12,DPARCT               END OF SUBLIST
         LA    INPTR,D1(,INPTR)         BUMP POINTER
         BH    MPX10                    GO ON IF HIGH          @AY14037
         BL    UNBAL                    GO TEST DELIM          @AY14037
         SET   (MPSB,MPSBL),ON          MARK LAST SUBL REC     @AY14037
         B     MPX10                    GO ON MAY BEE MORE     @AY14037
UNBAL1   GOIF  (ALTERN),OFF=UNBAL       BR: NOT ALTERNATE      @OX12896
         SET   SUBLERR,ON               IND ERR IN SUBL        @OZ06551
         SET   (ALTERN),OFF             RESET SW               @AX12896
UNBAL    EQU   *                                               @AX12896
         BAL   TLINK,ABSERR             LOG ERROR ON UNP PARENS@OZ06551
         DC    AL1(10*16+SEV24)         GO TO SKMNDST RTN VIA ABSERR
         DC    AL1(ERR24)               UNBALANCED PAREN
MPX10    CLI   D0(INPTR),JCOMMA
         BE    MPCMA                    COMMA
         CLI   D0(INPTR),JBLANK         OR BLANK
         BE    MPBLK                    BLANK MEANS END OF STMT@OX19887
         LA    R11,SZCMT                ROOM FOR NEXT RECORD   @OX19887
         BAL   RETURN,OPUTL             PUT OUT PREVIOUS REC   @OX19887
         BAL   TLINK,ABSERR             LOG THE ERROR AND...   @OX19887
         DC    AL1(9*16+SEV24)          RETURN TO STEND AFTER..@OX19887
         DC    AL1(ERR24)               PARENTHESIS ERROR      @OX19887
MPBLK    EQU   *
         GOIF  SNMFND,ON=MPOPOUT        EXIT IF EDITING NAME FIELD
         B     STEND                    ELSE, WRAP UP STATEMENT
         SPACE 3
MPCMA    EQU   *
         SET   (ALTERN,ENDSUBL),OFF     RESET SW               @OZ06551
         SET   DECMA,ON                 INDICATE END OPND COMMA PASSED
         LA    INPTR,D1(,INPTR)         BUMP OVER COMMA
         GOIF  SNMFND,OFF=MPCMA1        GO ON IF NOT NAME FIELD
         GOIF  SUBLST,ON=MPOPOUT        OK IF IN SUBLIST
         BCT   INPTR,BADNAME            OR GO TO LOG ERROR
MPCMA1   EQU   *
         L     PARAM1,MINPUT
         BAL   TLINK,SHFTDTA            SHIFT DATA
         CLI   D0(INPTR),JBLANK         IS IT AN ALTERNATE FORMAT
         BNE   MPOPOUT                  BRANCH IF NOT
         GOIF  SNOCNT,ON=MPOPOUT        OMITTED  IF NO CONT'N ALLOWED
         SET   ALTERN,ON                IND ALTENATE FORM      @OZ06551
         BAL   RETURN,BUMPD             BUMP OVER COMMENTS
         L     PARAM1,MINPUT
         BAL   TLINK,SHFTDTA            SHIFT DATA
         SPACE 3
MPOPOUT  EQU   *
         SET   (DSDTX,DECMA,DEEQL,DLPRN),OFF RESET INDICATORS
         L     RETURN,MPOPSV
         BR    RETURN                   RETURN TO CALLER
         SPACE 3
NEXTPARM EQU   *                        EDIT NEXT OPERAND
         MVI   FLGBYT,PARMFLG           ASSUME POSITIONAL PARAM
         SET   SKWPRM,OFF          RESET KWD INDICATOR
NEXTPM   EQU   *
         ST    RETURN,NEXPSV            SAVE RETURN LINKAGE
         ST    INPTR,FSTGL              SAVE BEGIN OF STRING
NEXTPM1  EQU   *                                                OX01771
         MVI   HDF,D0                   INIT. FLAG BYTE
NEXTT    EQU   *
         SET   SCNCAT,OFF               RESET INDICATOR
         MVI   MSERR,D0
         GOIF  SUBLST,ON=PTSUBL5        BRANCH IF EDITING SUBLIST
         CLI   D0(INPTR),JLPARN         TEST IF SUBLIST
         BNE   NEXTP                    BRANCH IF NOT
         LA    INPTR,D1(,INPTR)         BUMP POINTER
         GOIF  POSSUBL,ON=PTSUBL        GO EDIT IF GOOD SUBLIST
         SET   POSSUBL,ON               INIDCATE POSS SUBL CANDIDATE
         BAL   R12,APARCT               UP PAREN COUNT FOR L-PAREN
         B     PCSTGIN                  PROC FIRST PASS AS C-STRING
NEXTP1   EQU   *
         LA    INPTR,D1(,INPTR)         BUMP POINTER
NEXTP    L     LINK,ATRTEST             POINT TO TRTEST
         BALR  RETURN,LINK              TRT STRING
         AR    R3,R3
         LH    R14,PRMTBL(R3)           PREPARE TO BRANCH TO ITS
         B     D0(R14,BASE3)            CORRESPONDING ROUTINE
*
NEXRTN   L     RETURN,NEXPSV            RESTORE RETURN POINT
         BR    RETURN                   RETURN TO CALLER
         SPACE 3
PRMTBL   EQU   *                        CATEGORIES
         DC    AL2(PDSDT-MIPRTOIN)      0 = DECIMAL
         DC    AL2(POSYM-MIPRTOIN)      1 = ALPHAMERIC
         DC    AL2(PAMPR-MIPRTOIN)      2 = &
         DC    AL2(PTERM-MIPRTOIN)      3 = ,=.) OR BLANK
         DC    AL2(PLPAR-MIPRTOIN)      4 = (
         DC    AL2(PQTMD-MIPRTOIN)      5 = '
         DC    AL2(PCSTG-MIPRTOIN)      6 = +-*/
         DC    AL2(PLATR-MIPRTOIN)      7 = L' I' S' K' N'
         DC    AL2(PXBCT-MIPRTOIN)      8 = C' B' X'
         DC    AL2(PTATR-MIPRTOIN)      9 = T'
         DC    AL2(PDSYM-MIPRTOIN)      10= AND OR NOT
         DC    AL2(PDSYM-MIPRTOIN)      11= EQ NE LT LE GT GE
         DC    AL2(PEDTA-MIPRTOIN)      12= NON ASSEMBLER
DQTMD    LA    INPTR,D1(,INPTR)
PQTMD    EQU   *
         GOIF  POSSUBL,OFF=PQTMD3       ENDING ' ?             @OZ01697
         GOIF  DQUOT,ON=PQTMD7          BEEN HERE BEFORE       @OZ01697
PQTMD3   EQU   *                                               @OZ01697
         SET   DQUOT,ON                 ENTER QUOTE MODE
         SET   OPNDSTR,ON               SET C STG FLAG
PQTMD5   LA    INPTR,D1(,INPTR)
PQTMD7   EQU   *                                               @OZ01697
         C     INPTR,ENDATA             SEE IF PAST END OF DATA OX00225
         BNL   PEDTA1                   BRANCH IF YES           OX00225
         CLI   D0(INPTR),JQUOTE         TEST IF ENDING QUOTE
         BNE   PQTMD15                  BRANCH IF NOT
         CLI   D1(INPTR),JQUOTE         POSSIBLY, IF NOT DOUBLE QUOTE
         LA    INPTR,D1(,INPTR)
         BE    PQTMD5                   TOO BAD, DOUBLE QUOTE
         BCTR  INPTR,0                  BACK UP
PQTMDEX  EQU   *
         SET   DQUOT,OFF                PAIRED QUOTE
PQTMD10  EQU   *
         LA    INPTR,D1(,INPTR)         UPDATE POINTER
         SET   DSDTX,ON                 INDICATE DISALLOW SDT
         BAL   RETURN,TENDOP            TEST END OF OPERAND
         B     NEXTP                    CONTINUE EDITING
         B     PXBCOUT                  WRAP UP OPERAND
PQTMD15  EQU   *
         CLI   D0(INPTR),JAMPER         LOOK FOR NEXT AMPERSAND
         BNE   PQTMD5                   BRANCH IF NOT
         CLI   D1(INPTR),JAMPER         TEST IF DOUBLE AMPERSAND
         BNE   VSRTENT                  SINGLE AMPERSAND - ASSUME V SYM
         LA    INPTR,D1(,INPTR)         BUMP POINTER
         B     PQTMD5                   EDIT AS C STG
VSRTENT  EQU   *                        ASSUME VARIABLE SYMBOL
         GOIF  POSSUBL,ON=PCSTG         OMIT ON 1ST SUBL SCAN   OX02973
         ST    INPTR,MEZZOPTR           SAVE ENDING POINTER
         BAL   R12,MTENTRY              PUT OUT PREVIOUS TEXT
         BAL   RETURN,VSRTN             EDIT V SYM
         BCT   INPTR,PQTMD5             CONTINUE CODE MODE
*
PXBCT    EQU   *
         GOIF  DSDTX,ON=DQTMD           EDIT AS QT MODE IF DISALLOW SDT
         L     LINK,AXBCIN              GET LINK ADDRESS
PESDT    EQU   *
         SET   DMIENT,ON
         BAL   RETURN,RTNXFR            BRANCH OUT
         L     BASE3,AMIPRTO            NEED TWO FOR SAFTY
         L     BASE3,AMIPRTO            RESTORE BASE3
         BCT   R12,INVSDTP              OR GO LOG ERROR
PXBCT1   EQU   *
         SET   OPNDTRM,ON               SDT FLAG
         BAL   RETURN,TENDOP            TEST END OPERAND
         B     PXBCT2                   ON RETURN HERE, KEEP SCANNING
PXBCOUT  EQU   *
         BAL   R12,MTENTRY              BUILD M.T.
         B     NEXRTN                   RETURN TO POINT OF ORIGIN
PXBCT2   SET   OPNDSTR,ON
         SET   DSDTX,ON                 DISALLOW SDT
         B     NEXTP                    CONTINUE TO SCAN FIELD
         SPACE 3
MTENTRY  EQU   *
         C     INPTR,FPTRSV
         BCR   BEQ,R12                  RETURN IF NOTHING TO PUT OUT
         SET   SCNCAT,ON                ELSE, MEANING CONCATENATION
MTENTRY1 EQU   *
         L     R14,MTXTP                GET BUFFER LOCATION
         MVI   MPMCFLG,JTMCS            ENTER C STG FLAG
         L     GSPTR,FPTRSV
         LR    R15,INPTR                COMPUTE STRING LENGTH
         SR    R15,GSPTR
         STC   R15,MPMCLNG              AND SAVE
         BCTR  R15,0                    MAKE IT MOVE LENGTH
         EX    R15,STGMV                MOVE STG TO BUFFER
         LA    R14,D3(R15,R14)          UPDATE POINTER AND
         ST    R14,MTXTP                SAVE
         BR    R12                      RETURN TO CALLER
*
STGMV    MVC   MPMCSTG(0),D0(GSPTR)     OFF-THE-LINE MOVE
         SPACE 3
TENDOP   EQU   *
         GOIF  (SUBLST,POSSUBL),NONE=TENDOP0 BYPASS ON NO POSS SUBLIST
         CLI   D0(INPTR),JEQUAL         TERMINATOR EQUAL SIGN
         BNE   TENDOP0                  NO, GO CHECK FOR COMMA
         BR    RETURN                   PROC '=' IN ()'S AS CHAR STRING
TENDOP0  EQU   *
         CLI   D0(INPTR),JCOMMA         RETURN TO HERE IF GOOD SDT BUT
         BE    TENDOP2                  TERMINATOR MUST BE A COMMA
         CLI   D0(INPTR),JBLANK         OR --
         BE    TENDOP1                  A BLANK,
         CLI   D0(INPTR),JRPARN         R PAREN IS GOOD TERMINATOR TOO
         BCR   BNE,RETURN               RETURN IF NOT
TENDOP3  EQU   *
         GOIF  POSSUBL,ON=VALSUBL       CHECK VALID SUBLIST TERMINATOR
         GOIF  SUBLST,OFF=(RETURN)      RETURN IF NOT EDITING SUBLIST
         CLI   PRNLVL1,D1               TEST IF END OF SUBOPERAND
         BCR   BHI,RETURN               NO, PART OF C STG
         BE    TENDOPZ                  BRANCH IF EQUAL
         SET   MXRPRN,ON                ELSE, EXCESS RIGHT PARENS
TENDOPZ  EQU   *
         MVC   MPOPSV(L'MPOPSV+L'NEXPSV),SUBSAVE RESTORE RTN LINKAGES
         SET   MPSBL,ON                 INDICATE LAST SUBOPND
         SET   SUBLST,OFF
         B     D4(,RETURN)              AND RETURN
TENDOP1  CLI   PRNLVL1,D0               TEST IF BLANK AT ZERO LEVEL
         BE    D4(,RETURN)              YES, A TERMINATOR
         GOIF  POSSUBL,ON=GOODSUBL      ALTR FORMAT, ASSUME VALID SUBL
         B     BLKERR                   NO BLANK AT ANY PAREN LEVEL
TENDOP2  CLI   PRNLVL1,D1               AND COMMA MUST BE QUALIFIED
         BCR   BHI,RETURN               PART OF C-STG
         BL    D4(,RETURN)              A TERMINATOR AT ZERO-PAREN LVL
         GOIF  SUBLST,OFF=(RETURN)      IN SUBLST IF AT ONE-PRN LVL
         B     D4(,RETURN)              IT IS
         SPACE 3
VALSUBL  CLI   PRNLVL1,D1               END OF LAST SUBOPERAND
         BCR   BHI,RETURN               NO, CONTINUE IN C-STRING MODE
         BE    VALSUBL1                 YES, TEST IF VALID SUBLIST
         SET   AMPER1,OFF               RESET FOR NEXT CHAR     OX04106
         B     UNBAL                    OTHERWISE, ERR ON UNBAL PARENS
VALSUBL1 CLI   D1(INPTR),JCOMMA         R-PAREN FOLL'D BY COMMA
         BE    GOODSUBL                 YES, PROC AS GOOD SUBL
         CLI   D1(INPTR),JBLANK         R-PAREN FOLL'D BY BLANK
         BNE   BADSUBL                  NO, PUT OUT BAD SUBL AS C-STG
GOODSUBL L     INPTR,FSTGL              BACK UP TO BEGIN POINT OF SUBL
         GOIF  SKWPRM,OFF=GOODSUB       CONTINUE ON NO KEYWORD
         L     INPTR,FPTRSV             BACK TO L-PAREN AFTER '=' SIGN
GOODSUB  SET   OPNDSTR,OFF              NO LONGER C-STRING
         SET   DSDTX,OFF                PREPARE TO START OVER
         MVI   PRNLVL1,D0               RESET PAREN COUNT TO ZERO
         SET   AMPER1,OFF               RESET FOR NEXT CHAR     OX04106
         B     NEXTT                    NOW, PROCESS GOOD SUBLIST
BADSUBL  SET   POSSUBL,OFF              RESET SUBLIST SCAN SWITCH
         GOIF  AMPER1,OFF=BADSUBL1      DO NOT USE AMPER SW     OX04106
         SET   AMPER,ON                 INDICATE VARSYM         OX01771
BADSUBL1 SET   AMPER1,OFF               RESET FOR NEXT CHAR     OX04106
         BR    RETURN                   PUT INVALID SUBL OUT AS C-STG
         SPACE 3
PLPAR    EQU   *
         BAL   R12,APARCT               UP PAREN COUNT
         SET   DLPRN,ON
         B     PCSTG                    PART OF C STG
         SPACE 3
PTERM    EQU   *
         CLI   D0(INPTR),JCOMMA         TEST IF A COMMA
         BE    PTERMC                   YES - TEST IF OMITTED OPERAND
         CLI   D0(INPTR),JBLANK         TEST IF A BLANK
         BE    PTERMB                   YES - TEST IF OMITTED OPERAND
         CLI   D0(INPTR),JRPARN         TEST IF R PAREN
         BNE   PCSTG                    EDIT AS C STG IF NONE ABOVE
         BAL   RETURN,TENDOP3           TEST IF END OF OPERAND
         B     PTERMP                   BRANCH IF NOT
         B     OMITOP                   LOG OMITTED OPERAND
PTERMP   BAL   R12,DPARCT               TAKE CARE OF PAREN COUNT
         GOIF  AMPER,OFF=PCSTG          NO VARSYM               OX01771
         L     INPTR,FSTGL              POINT TO BEG OF STRING  OX01771
         B     NEXTPM1                  IT IS PART OF C STG     OX01771
PTERMC   EQU   *
         CLI   PRNLVL1,D1               TEST PAREN STATUS
         BH    PCSTG                    PART OF C STG
         BL    OMITOP                   OMITTED OPERAND
         GOIF  SUBLST,OFF=PCSTG         PART OF C STG IF NOT IN SUBLIST
OMITOP   EQU   *
         SET   OPNDOMT,ON               INDICATE OMITTED PARAM
         B     NEXRTN                   EXIT
*
PTERMB   EQU   *
         CLI   PRNLVL1,D0               BLANK MAY NOT APPEAR IN PAIRED
         BE    OMITOP                   MUST BE OMITTED OPERAND
         B     BLKERR                   BLANK DISALLOWED IN ()'S
         SPACE 3
PAMPR    EQU   *
         GOIF  AMPER,OFF=PAMPR05        NO BAD SUBL W VARSYM    OX01771
         SET   AMPER,OFF                RESET VARSYM FLAG       OX01771
         SET   POSSUBL,OFF              NO SUBL                 OX01771
PAMPR05  EQU   *                                                OX01771
         CLI   D1(INPTR),JAMPER         TEST FOR DOUBLE AMPERS  OX04106
         BE    PAMPR07                  GO BUMP POINTER         OX04106
         GOIF  POSSUBL,OFF=PAMPR08      CHAR STG ON 1 SUBL SCAN OX04106
         SET   AMPER1,ON                IND VARSYM IN POSSUBLST OXO4106
         B     PCSTG                    TREAT AS CHAR STG       OX04106
PAMPR07  LA    INPTR,D1(,INPTR)         BUMP POINTER            OX04106
         B     PCSTG                    TREAT AS CHAR STG       OX04106
PAMPR08  BAL   R12,MTENTRY              ELSE, PUT OUT C STG     OX04106
         ST    R1,FPTRSV                UPDATE STRING POINTER
         BAL   RETURN,VSRTN             EDIT VARIABLE SYMBOL
         BAL   RETURN,TENDOP            TRY TO WRAP UP OPND
         B     PAMPR1                   CANCEL PP FLAG
         B     NEXRTN                   EXIT IF RETURN TO HERE
PAMPR1   SET   OPNDPRM,OFF              BAD PASSED PARAMETER
         B     NEXTP                    EDIT AS C STG
*
VSRTN    EQU   *
         ST    RETURN,VSRSV             SAVE REUTRN LINKAGE
         GOIF  SXPRTO,ON=ILPRTKY        PROTO KWD OPND MAY NOT BE V SYM
         SET   OPNDSTR,ON               ASSUME NOT PASSED PARAM
         ST    INDEXP,VSRSV1            SAVE HEADER DATA POINTER
         L     INDEXP,MTXTP             GET MT POINTER
         SET   DMIENT,ON
         OI    JHWORD2+1,DMIENT         SET SECOND DMIENT SW   @AZ13722
         L     LINK,AVARSYM             GET VARSYM RTN ADDRESS
         BAL   RETURN,RTNXFR            TRANSFER
         L     BASE3,AMIPRTO            RESTORE BASE REG
         GOIF  RMPURE,OFF=VSRTN3        CONTINUE IF NO ERROR
         SET   MXVS,ON                  FLAG TO OUTPUT OMITTED PARM
VSRTN3   EQU   *
         BAL   R3,PFXRENT               FORCE OUT ALL OPERATORS STILL
         DC    AL2(JTMSTRM)             IN POSTER STACK
         LR    INPTR,R1                 UPDATE POINTER
         MVI   GSUMRY,D0                MASK OFF SWITCHES SET BY
         SET   (METSW,GSUBS),OFF        VARSYM ROUTINE BUT NOT WANTED
         SET   JSUBOPND,ON              OPERAND NEED SUBSTITUTION
         BCTR  INDEXP,0                 WIPE OFF END-STMT OPERATOR
         ST    INDEXP,MTXTP             SAVE MT POINTER
         L     INDEXP,VSRSV1            RESET HEADER DATA POINTER
         L     RETURN,VSRSV             RESET RETURN LINKAGE
         GOIF  SCNCAT,ON=VSRTN5         BRANCH IF CONCATENATION
         SET   SCNCAT,ON
         TM    FLGBYT,VSLS                                      OX00217X
               CONSIDER SYSLIST PASSED PARAM                    OX00217
         BO    VSRTN4                   BRANCH IF SYSLIST       OX00217
         TM    FLGBYT,PARMFLG           PASSED PARAM MAY NOT BE
         BNO   VSRTN5                   CONCATENATED. ANYTHING OTHER
VSRTN4   SET   (OPNDSTR,OPNDPRM),FLIP   GOOD PASSED PARAM
VSRTN5   EQU   *
         CLI   D0(INPTR),JPERIOD        TEST IF CONCATENATED
         BNE   VSRTN20                  BRANCH IF NOT
VSRTN10  EQU   *
         SET   DSDTX,ON                 DISALLOW SDT
         LA    INPTR,D1(,INPTR)         WITH C STG FLAG
VSRTN20  EQU   *
         ST    INPTR,FPTRSV             RESET POINTER, PREPARE TO
         BR    RETURN                   EDIT NEXT TERM
*
PTATR    EQU   DQTMD
*
PLATR    EQU   *
         CLI   D0(INPTR),JL             TEST IF L'
         LR    INPTR,R1
         BNE   PQTMD                    BRANCH IF NOT
         CLI   D1(INPTR),JA             TEST IF FOLLOWED BY ALPHA
         BL    PQTMD                    NO - EDIT AS QUOTED STG
         CLI   D1(INPTR),JAT
         BH    PQTMD                    EDIT AS QUOTED STG
*
         SPACE 3
DCSTG    LR    INPTR,R1                 UPDATE POINTER
PCSTG    EQU   *
         LA    INPTR,D1(,INPTR)         BUMP OVER TERMINATOR
PCSTGIN  EQU   *
         SET   OPNDSTR,ON               SET C STG FLAG
         SET   DSDTX,ON                 DISALLOW SDT
         BAL   RETURN,TENDOP            TEST IF END OF OPERAND
         B     NEXTP                    BRANCH IF NOT
         B     PXBCOUT                  ELSE, BUILD MT THEN EXIT
         SPACE 3
PEDTA    EQU   *
         CLI   D0(INPTR),JBLANK         IF IT IS A BLANK, IT IS AN
         BE    PTERMB                   OMITTED OPERAND ENDING THE STMT
         C     INPTR,ENDATA             ELSE, TEST IF END DATA
         BL    PCSTG                    NO, IS A PART OF C STG
PEDTA1   BAL   TLINK,ABSERR             QUOTE MODE AND NO END   OX00225
         DC    AL1(9*16+SEV35)          QUOTE FOUND FOR AN ATTRIBUTE
         DC    AL1(ERR35)               END STMT VIA STEND RTN
*        LOG ERROR - OPERAND EXCEEDS 255 CHAR
CSTGLERR BAL   TLINK,WRNERR             GO TO
         DC    AL1(SEV42)               LOG WARNING MSG
         DC    AL1(ERR42)               EXCEEDS 255 CHARACTERS
         AH    INPTR,H255               CHOP OFF FIRST 255 CHARACTERS
         ST    INPTR,FPTRSV             RESET STRING POINTER
         B     NEXTP                    CONTINUE WITH THIS MUCH
         SPACE 3
SYMSDTCK EQU   *
         GOIF  SCNCAT,ON=D4(,RETURN)    DSDT/SYM MUST STAND ALONE
         GOIF  DSDTX,OFF=(RETURN)       IF SDT ALLOWED O-SYM ALLOWED
         GOIF  DLPRN,ON=(RETURN)        DISALLOW SDT COULD STILL ALLOW
         C     INPTR,FPTRSV             O-SYM PROVIDED IT IS
         BR    RETURN                   FIRST ACTION
         SPACE 3
PDSDT    EQU   *
         BAL   RETURN,SYMSDTCK          SYM/SDT MUST BE LEGITIMATE
         BE    PDSDT1                   YES, IT IS
PDSDTX   LR    INPTR,R1
         B     PCSTGIN                  EDIT AS C STG
PDSDT1   CLI   D0(R1),JLPARN            ELIMINATE INVALID TERMINATORS
         BL    PDSDTX                   ZERO THRU EQUAL SIGN TERMINATE
         BE    PDSDTC1                  L-PAREN TERMINATES
         CLI   D0(R1),JRPARN            R-PAREN THRU SLASH
         BL    PDSDTC1                  PUT OUT SYM REF FOR + - * OR /
         BE    PDSDTC                   R-PAREN TERMINATES
         CLI   D0(R1),JBLANK            WHAT ABOUT COMMA OR BLANK
         BL    PDSDTC                   COMMA, CHECK PAREN LEVEL
         BE    PDSDTB                   BLANK, DELIMITS DSDT OR SYMBOL
         B     PDSDTX                   ANY OTHER TERMINATOR, C-STRING
PDSDTC   EQU   *
         CLI   PRNLVL1,D1               COMMA IS INSIGNIFICANT IF
         BH    PQTMD10                  PAREN DON'T BALANCE
PDSDTC1  EQU   *
         CH    R3,H2                    TEST IF O-SYM
         BE    POSOSYM                  YES, POSITIONAL O-SYM
         L     LINK,ADSDTIN             GET DSDTIN ADDRESS
         B     PESDT                    GO EDIT DSDT
         SPACE 3
PDSDTB   EQU   *                        DSDT FOLLOWED BY BLANK
         CLI   PRNLVL1,D0               BLANK TERMINATOR MUST
         BE    PDSDTC1                  NOT APPEAR INSIDE PAIRED PAREN
         B     BLKERR                   ELSE ERROR, BLANK DISALLOWED
         SPACE 3
POSOSYM  EQU   *
         BAL   LINK,SYMSCN1             EDIT O-SYM
         B     PCSTG                    BAD O-SYM EDIT AS C STG
         SET   OPNDORD,ON               ORDINARY SYM FLAG
         MVC   MPOSRP,D1(R11)           AND POINTER
         BAL   RETURN,TENDOP            TRY TO WRAP UP OPERAND
         B     PCSTGIN                  CONTINUE EDIT IF NOT END OPND
         B     PXBCOUT                  ELSE, EXIT
         SPACE 3
PDSYM    LA    R3,D2                    DUMMY UP CATEGORY NUMBER
POSYM    EQU   *
         CLI   D0(R1),JEQUAL            TEST IF MI KWD PARAM
         BNE   PDSDT                    EDIT AS DSDT IF NOT
         GOIF  (SUBLST,POSSUBL),ANY=DCSTG NO KWD PARM ALLOWED IN SUBL
         GOIF  OPNDSTR,ON=DCSTG         MUST BE O/SYM PRIOR TO '=' SIGN
         GOIF  SKWPRM,ON=DCSTG          BRANCH IF NOT KWD SIGN
         SET   VPTYP,ON                 INDICATE KEYWORD
         SET   JTCPKEY                  INDICATE KWD CALL
         SET   SKWPRM,ON
         LR    R12,R1                   DO NOT USE REG 1       @AY11215
         S     R12,FSTGL                COMPUTE KEW LEN        @AY11215
         LA    R12,D1(R12)              ADD 1 FOR EQUAL SIGN   @AY11215
         LNR   R12,R12                  MAKE IT NEGATIVE       @AY11215
         STH   R12,PARML                SAVE TOTAL LEN         @AY11215
         LR    INPTR,R1                 UPDATE POINTER
         BAL   R12,MTENTRY1             BUILD MT
         SET   (DECMA,DEEQL),ON
         LA    INPTR,D1(,INPTR)         BUMP OVER EQUAL SIGN
         ST    INPTR,FPTRSV             UPDATE POINTER
         B     NEXTT                    EDIT KWD OPERAND
         SPACE 3
PTSUBL   EQU   *
         SET   POSSUBL,OFF              NOW IN SUBL,RESET SCAN SWITCH
         GOIF  SUBLST,ON=NEXTP          BEEN HERE BEFORE- PART OF C STG
         ST    INPTR,FPTRSV             THROW AWAY SUBLIST HEAD
         BAL   R12,APARCT               UP PAREN COUNT
         SET   SUBLST,ON                INDICATE SUBLIST
         MVC   SUBSAVE(L'MPOPSV+L'NEXPSV),MPOPSV SAVE RETURN LINKAGES
         MVC   MPOPSV(L'MPOPSV+L'NEXPSV),AMIX5 ALTER RETURN LINKAGES
         MVC   OCSAVE(D1),JTIOP1        SAVE OP OCDE STATUS
         GOIF  SMI,OFF=PTSUBL1          BRANCH IF NOT FROM MI
         GOIF  SKWPRM,OFF=PTSUBL1       BRANCH IF M CALL POS SUBOPND
         MVC   JTIOP1(D1),OCSAVE        RESET OPCODE FOR SUBOPND
PTSUBL1  SET   (MPSB,MPSBF),ON          INDICATE FIRST SUBOPND
         B     NEXTP                    CONTINUE PROCESSING
PTSUBL5  EQU   *
         GOIF  SXPRTO,OFF=PTSUBL6       BRANCH IF NOT PROTOTYPE
         LA    R14,MPHDL(,INDEXP)       GET HDR RECORD LENGTH
         ST    R14,MTXTP                AND SAVE
         SR    R14,INDEXO               RESET OPERAND POINTER
         STH   R14,JTOPP
         MVI   HDF,D0                   INIT. FLAG BYTE
PTSUBL6  EQU   *
         MVC   JTIOP1(D1),OCSAVE        RESET OP CODE FOR SUBOPERAND
         SET   MPSB,ON                  INDICATE SUBLIST
         B     NEXTP                    EDIT SUBOPERAND
         SPACE 3
WRAPOPND EQU   *
         L     R14,MTXTP                GET BASE
         MVI   MPEMT,JTMSTRM            INSERT END STATEMENT FLAG
         LA    R14,D1(,R14)
         SR    R14,INDEXO               COMPUTE RECORD LENGTH
         STH   R14,JTRLI                ENTER TEXT LENGTH
         GOIF  (MPSBF,MPSB,MPSBL),OFF=TST255A B IF NOT SUB PARA@AZ24557
ADD255   LR    R14,INPTR                DO NOT USE REG 6       @AY11215
         S     R14,FSTGL                COMPUTE PARM LEN       @AY11215
         LA    R14,D1(R14)              ADD 1 FOR DELIMITER    @AY11215
         AH    R14,PARML                ADD TO PREV LEN        @AY11215
         STH   R14,PARML                SAVE TOTAL RESULT      @AY11215
         GOIF  MPSBL,OFF=END255         BR IFNOT LAST SUB PARM @AY11215
TST255   SH    R14,=H'255'              0 = 255 CHAR IN PARAM  @AZ24557
         BNP   END255A                  BR IF NOT EXEEDS 255 CH@AY11215
         BAL   TLINK,WRNERR             GEN ERR MSG 42: OPERA- @AY11215
         DC    AL1(SEV42)               ND EXEEDS 255 CHAR.    @AY11215
         DC    AL1(ERR42)                                      @AY11215
END255A  XC    PARML,PARML              CLEAR FOR MORE TESTS   @AY11215
END255   EQU   *                        END OF TEST            @AY11215
         BR    RETURN                   RETURN TO CALLER
TST255A  LR    R14,INPTR                DO NOT USE REG 6       @AZ24557
         S     R14,FSTGL                COMPUTE PARM LENGTH    @AZ24557
         AH    R14,PARML                ADD TO PREV LENGTH     @AZ24557
         B     TST255                   BR AND TEST FOR 255 CH @AZ24557
         SPACE 3
         SPACE 3
RTNXFR   EQU   *
         L     BASE2,USEBAS             RESET BASE2 VALUE
         BR    LINK                     MAKE TRANSFER
*
AVARSYM  DC    A(VARSYM)                VARSYM ADDRESS
AXBCIN   DC    A(XBCSDT)                XBCSDT ADDRESS
ADSDTIN  DC    A(DSDTIN)                DSDTIN ADDRESS
AMIX5    DC    A(MACPRM2,MIX5)          ALTERNATE RETURN LINKAGES
         EJECT
BADPARM  L     INPTR,FPTRSV             POINT BACK TO FIELD BEGIN
BADPARM1 BAL   TLINK,SNAPERRL           GO LOG ERROR- MOVE 8 CHARS
         DC    AL2(1)                   ABSOLUTE ERROR
         DC    AL1(9*16+SEV39)          BAD PARAMETER
         DC    AL1(ERR39)               GIVE UP STMT, NO RETURN
*
         SPACE 3
BLKERR   EQU   *
         GOIF  SUBLST,OFF=BLKERR1       BR IF NOT IN SUBLIST
         SET   (MPSB,MPSBL,OPNDOMT),ON  FLAG AS LAST SUBOP/OMITTED PARM
         BAL   RETURN,WRAPOPND          WRAP UP THIS PARM RECORD
         LA    R11,D8                   SIZE OF END-OF -PARM
         BAL   RETURN,OPUTL             FORCE LAST PARM RECORD
BLKERR1  EQU   *
         BAL   TLINK,ABSERR             BLANK DELIMITS BUT PARENS UNBAL
         DC    AL1(9*16+SEV24)          OR BLANK DETECTED WITHIN PARENS
         DC    AL1(ERR24)               NO RETURN, TO STEND RTN
BADNAME  MVC   D0(L'OMTNM,INDEXO),OMTNM OMITTED PARM RECORD
         BAL   TLINK,WRNERR             GO LOG THE ERROR
         DC    AL1(SEV16)               INVALID CHARACTER DETECTED IN
         DC    AL1(ERR16)               THE NAME FIELD OF A MACRO INST
         B     MACPRM2                  CONTINUE WITH OPERAND
         SPACE 3
ILPRTKY  EQU   *
         BAL   TLINK,ABSERR             KW PARAMETER ERROR
         DC    AL1(9*16+SEV28)          NO RETURN, GO TO STEND RTN
         DC    AL1(ERR28)               VIA ABSERR
INVSDTP  CLI   HICVAL1,J9               NOT A VALID SDT, SO ....
         BE    PCSTGIN                  C STG IF DSDT
         L     INPTR,TPSAVE             ELSE, .....
         B     DQTMD                    QUOTE MODE
MPTCHA   DS    20C                      TEMPORARY PATCH AREA
         SPACE 3
OMTNM    DS    0CL26                    MACRO CALL OMITTED NAME RECORD
         DC    AL2(L'OMTNM)             LENGTH
         DC    AL1(X'80',0)             FLAG
         DC    AL1(JTCPPOS,0)           IOC
         DC    AL2(18,18,25,18,18)      POINTERS
         DC    AL1(0,0,0,0,8)           HEADER DATA FLAG
         DC    AL1(0,0,0,0)             PADDING
OMTMT    DC    AL1(JTMSTRM)             M.T. END STMT FLAG
         EJECT
***********************************************************************
*  TRANSLATE AND TEST RESULTS                                         *
*  R1 = TERMINATING CHARACTER ADDRESS                                 *
*  R3 = CATEGORY NUMBER                                               *
*       VALUE 0 = DECIMAL (1ST CHARACTER NUMERIC)                     *
*             1 = ALPH-NUMERIC (1ST CHARACTER ALPHA)                  *
*             2 = &                                                   *
*             3 = , = . ) BLANK (OPERAND TERMINATOR)                  *
*             4 = (                                                   *
*             5 = '                                                   *
*             6 = + - * /                                             *
*             7 = L' S' I' N' K'                                      *
*             8 = C' X' B'                                            *
*             9 = T'                                                  *
*            10 = AND OR NOT                                          *
*            11 = EQ NE LT LE GT GE                                   *
*            12 = NON-ASSEMBLER (1ST CHARACTER NON-ASSEMBLER)         *
*  R10 = TYPE NUMBER                                                  *
*  R15 = STRING LENGTH (MOVE LENGTH)                                  *
***********************************************************************
*  AT ENTRY R10 HAS INDEX OF 1 OR 2                                   *
*        1 = DO SYNTACTIC STRING SEARCH                               *
*        2 = NO SYNTACTIC STRING SEARCH                               *
*                                                                     *
*  REGISTERS 1,2,3,10,11,12,14,15 MUST BE MADE AVAILABLE              *
*                                                                     *
*        LINKAGE IS ANY OF THE FOLLOWINGS                             *
*        BAL   RETURN,TRTEST                                          *
*        BAL   RETURN,TRT01                                           *
*        BAL   RETURN,TRT02                                           *
*                                                                     *
* STRING TO BE TRT'ED IS LIMITED TO 255 CHARACTERS  *******************
***********************************************************************
TRTEST   LA    PARM,1                   DO SYNTACTIC STRING SEARCH
TRT01    MVC   SPECHAR(L'STDTBL),STDTBL LOAD STANDARD TRT TABLE
TRT02    ST    BASE3,JFWORD2            SAVE BASE 3
         BALR  BASE3,0                  REDEFINE BASE
         USING *,BASE3                      REGISTER
         SR    TWKREG2,TWKREG2          IN CASE PAST END
         L     TWKREG1,ENDATA           COMPUTE STRING LENGTH
         SR    TWKREG1,INPTR
         BNP   TRTOUT1                  EXIT IF PASSED END COLUMN
         BCTR  TWKREG1,0                MAKE IT MOVE LENGTH
         CH    TWKREG1,H255             ALLOW MAXIMUM OF 256 BYTES
         BNH   TRT10                    LENGTH OK
         LH    TWKREG1,H255
         SPACE
TRT10    ST    R2,JFWORD1               SAVE EDSECT BASE REG
         SR    R1,R1                    CLEAR REGISTERS FOR TRT RESULT
         LR    R2,R1
         EX    TWKREG1,TRT00            TRT STRING INDICATED IN INPTR
         LR    R3,R2                    TRANSFER RESULT TO R3 SINCE
         L     R2,JFWORD1               R2 IS EDSECT BASE REGISTER
         BNE   MATCH                    BRANCH IF AN ENTRY MATCHES
*  NO HIT - SIMULATE ONE
         L     R1,ENDATA
         CLI   D0(INPTR),JA             SEPARATE AN STRING FROM N STG.
         BL    MATCH                    BRANCH IF NUMERIC
         LA    R3,1                     ELSE INDICATE AN STRING
*
MATCH    LR    TWKREG2,R1               COMPUTE STRING TRUE LENGTH
         SR    TWKREG2,INPTR
         BZ    TRTOUT                   EXIT IF 1ST CHAR TERMINATES
         BCT   TWKREG2,TRT20            BRANCH IF LENGTH GT ONE
         CLI   D1(INPTR),JQUOTE         ELSE, TEST IF ATTR. NOTATION
         BNE   TRTSTG                   BRANCH IF NOT
*
TRT20    CH    TWKREG2,H2               BRANCH IF LENGTH GT 3
         BH    TRTSTG
*  LENGTH LE 3 - COULD BE BOOLEAN, RELATIONAL OPS OR ATTR. NOTATION
         BCT   PARM,TRTSTG              BRANCH IF NOT TRTEST ENTRY
*  DO SYNTACTIC STRING SEARCH - PARM CONTAINS BXLE INCREMENT FACTOR
         LA    PARM,D3(,TWKREG2)
         SR    PARAM2,PARAM2
*  R12 POINTS TO TRTTYPE,TRTREL OR TRTOPTR FOR L OF 1, 2, OR 3
         IC    PARAM2,TRTNDX1(TWKREG2)
         LA    R12,TRTTYPE(PARAM2)      GET TO THE RIGHT TABLE
* PARAM2 POINTS TO UPPER LIMIT OF BXLE LOOP
         IC    PARAM2,TRTNDX2(TWKREG2)
         AR    PARAM2,R12
         SPACE
* NOW LOOK FOR A MATCH IN THE TABLE POINTED TO IN R12
TRTLKUP  EX    TWKREG2,TRTCPR           COMPARE SYMBOL VS TABLE
         BE    TRTFND                   BRANCH IF FOUND IN TABLE
         BXLE  R12,PARM,TRTLKUP         ELSE KEEP LOOKING
         SPACE
* STRING IS NOT IN THE TABLE POINTED TO IN R12 - ASSUME AN STRING
TRTSTG   LA    R3,D1                    INDICATE AN STRING
         CLI   D0(INPTR),J9
         BH    TRTRTN                   EXIT IF AN STRING
         BCTR  R3,0                     ELSE, INDICATE NUMERIC STRING
         B     TRTRTN                   THEN EXIT
         SPACE
* SYMBOL FOUND IN TABLE - PICK UP TYPE NUMBER AND RETURN
TRTFND   IC    PARM,D2(TWKREG2,R12)     GET TYPE NUMBER AND
         IC    R3,D1(TWKREG2,R12)       CATEGORY NUMBER FROM TABLE
         B     TRTRTN                   RETURN TO CALLER
         SPACE
TRTOUT   CLI   D0(INPTR),HICHR          TEST 1ST CHARACTER
         BNH   TRTXIT                   BRANCH IF NOT NON-ASSEMBLER CHR
TRTOUT1  LA    R3,12                    INDICATE NON-ASSEMBLER
         LR    R1,INPTR                 INSURANCE, INSURANCE.
         B     TRTRTN                   RETURN TO CALLER
         SPACE
TRTXIT   IC    PARM,D0(,INPTR)          GET TERMINATING CHARACTER
         IC    PARM,TRTSRC-(SPECHAR-JTBLTRT)(PARM) PICK UP TYPE NUMBER
TRTRTN   L     BASE3,JFWORD2            RESTORE BASE 3 VALUE
         BR    RETURN                   NOW RETURN TO CALLER
TRT00    TRT   D0(1,INPTR),JTBLTRT      OFF-THE-LINE TRT
TRTCPR   CLC   D0(1,INPTR),D0(R12)      OFF-THE-LINE COMPARE
***********************************************************************
*  SYNTACTIC STRING TABLES                                            *
*        TRTTYPE USED IF TERMINATOR IS ' AND LENGTH = 1. FORMAT = SCT *
*        TRTREL USED IF LENG = 2 (ANY TERMINATOR)   FORMAT = SSCT     *
*        TRTOPTR USED IF LENGTH = 3 (ANY TERMINATOR) FORMAT = SSSCT   *
*        S = CHARACTER STRING (1, 2, OR 3 BYTES)                      *
*        C = CATEGORY NUMBER (1 BYTE)                                 *
*        T = TYPE NUMBER (1 BYTE)                                     *
***********************************************************************
TRTTYPE  EQU   *                        ATTRIBUTE TABLE
         DC    AL1(JT)                  T'
         DC    AL1(09)
         DC    AL1(JTMTAT)
         DC    AL1(JX)                  X'
         DC    AL1(08)
         DC    AL1(XSDT)
         DC    AL1(JB)                  B'
         DC    AL1(08)
         DC    AL1(BSDT)
         DC    AL1(JC)                  C'
         DC    AL1(08)
         DC    AL1(CSDT)
         DC    AL1(JL)                  L'
         DC    AL1(07)
         DC    AL1(JTMLAT)
         DC    AL1(JI)                  I'
         DC    AL1(07)
         DC    AL1(JTMIAT)
         DC    AL1(JS)                  S'
         DC    AL1(07)
         DC    AL1(JTMSAT)
         DC    AL1(JN)                  N'
         DC    AL1(07)
         DC    AL1(JTMNAT)
         DC    AL1(JK)                  K'
         DC    AL1(07)
         DC    AL1(JTMKAT)
*
TRTREL   EQU   *                        RELATIONAL OPERATOR TABLE 2 BYT
         DC    AL1(JE,JQ)               EQ
         DC    AL1(11)
         DC    AL1(JTMEQ)
         DC    AL1(JO,JR)               OR
         DC    AL1(10)
         DC    AL1(JTMOR)
         DC    AL1(JN,JE)               NE
         DC    AL1(11)
         DC    AL1(JTMNE)
         DC    AL1(JL,JT)               LT
         DC    AL1(11)
         DC    AL1(JTMLT)               LT
         DC    AL1(JG,JT)               GT
         DC    AL1(11)
         DC    AL1(JTMGT)
         DC    AL1(JL,JE)               LE
         DC    AL1(11)
         DC    AL1(JTMLE)
         DC    AL1(JG,JE)               GE
         DC    AL1(11)
         DC    AL1(JTMGE)
*
TRTOPTR  EQU   *                        RELATIONAL OPERATOR TABLE 3 BYT
         DC    AL1(JA,JN,JD)            AND
         DC    AL1(10)
         DC    AL1(JTMAND)
         DC    AL1(JN,JO,JT)            NOT
         DC    AL1(10)
         DC    AL1(JTMNOT)
NSYNTBL  EQU   *
*
TRTNDX1  EQU   *
         DC    AL1(TRTTYPE-TRTTYPE)     INDEX FOR LENGTH = 1
         DC    AL1(TRTREL-TRTTYPE)      INDEX FOR LENGTH = 2
         DC    AL1(TRTOPTR-TRTTYPE)     INDEX FOR LENGTH = 3
TRTNDX2  EQU   *
         DC    AL1(TRTREL-TRTTYPE-3)    END INDEX FOR LENGTH = 1
         DC    AL1(TRTOPTR-TRTREL-4)    END INDEX FOR LENGTH = 2
         DC    AL1(NSYNTBL-TRTOPTR-5)   END INDEX FOR LENGTH = 3
TRTNNDX  EQU   *
         DS    0H
*
         EJECT
         JPATCH X1A20,DD4
         EJECT
         JCSECT (X1A30=CS4)
         USING *,BASE4
         USING JTEXTA,INDEXP
*
***********************************************************************
* DIRECTORY ENTRY ROUTINE                                             *
* AT ENTRY R9  CONTAINS D ENTRY INDEX VALUE
*          R10 POINTS TO THE SYMBOL TO BE ENTERED/SEARCHED
*          R11 CONTAINS THE MOVE LENGTH OF THE SYMBOL TO BE ENTERED
*              OR SEARCHED
* ON RETURN R11 POINTS TO A LOCATION CONTAINING THE VECTOR POINTER,
*              THE POINTER TO THE LOCATION IN GENERATION TIME DICT,
*              OR THE FLAGA, OF THE SYMBOL ENTERED.
* LINKAGE IS BAL R3,DIRENT
*         OR BAL R3,DIR10
***********************************************************************
         SPACE 3
NDIRENT  GOIF  SUPDNT,OFF=NDIR10        GO IF ENTRY NOT SUPPRESSED
         SET   SUPDNT,OFF               ELSE SET OFF THE INDICATOR
         B     DIROUT                   AND RETURN
NDIR10   MVI   DERRCD,D0                RESET ERROR CODE TO ZERO
         STM   R15,R1,EDTSVZ            SAVE LENGTH & TERMINATOR
         L     LINK,DENTRY              COMPUTE D ENTRY POINT
         BALR  RETURN,LINK              MAKE D ENTRY
         TM    DERRCD,BITFF             TEST IF ANY ERROR
         BZ    DIR20                    RETURN IF NO
         L     R15,EDTSVZ               GET SYMBOL LENGTH
         CLI   DERRCD,ERR11             TEST IF CALL MISMATCHES DEF
         BE    DIR30                    YES, BUT LET X3 FLAG IT IN LINE
         CLI   DERRCD,ERR10             PREV DEFINED PRGMR MACRO
         BE    DIR18                    LOG ERROR MESSAGE 10
         CLI   DERRCD,ERR7              TEST IF INCONSISTENT USAGE
         BNE   DIR15                    LOG ERROR
         TM    FLGBYT,VDIM              YES, TEST IF DIMENSIONED
         BO    DIR15                    LOG ERROR IF YES
         TM    ATTRSV,ATN               TEST IF PRECEDED BY N'
         BNO   DIR15                    ERROR IF NOT
         MVI   DERRCD,D0                ELSE, NOT ERROR
         B     DIR20                    EXIT
DIR15    LA    R15,1(,R15)              INCR LENGTH TO INCLUDE '&'
         GOIF  SGBLCL,OFF=DIR16         BACK UP IF ---
         L     INPTR,OPNDPTR            FROM DECLARATION
         TM    FLGBYT,VDIM              TEST IF DIMENSIONED
         BNO   DIR18                    BRANCH IF NOT- MOVE LENGTH OK
         AR    R15,TRTN                 ADJUST MOVE LENGTH
         SR    R15,INPTR                FOR NO. OF CHARS IN V. S.
         BCTR  R15,D0                   MAKE INTO MOVE LENGTH
         B     DIR18                    GO LOG ERROR
DIR16    EQU   *                        ELSE, DON'T
         BCTR  INPTR,0                  BACK UP TO '&' FOR SNAP
DIR18    EQU   *
         BAL   RETURN,DNTERR            LOG ERROR
         L     BASE4,CS4ADDR            GET BACK TO THIS CSECT
         SET   RMPURE,ON               INDICATE IMPURITY
         L     R1,OUTADR
         OI    D3(R1),JPRONLY           PRINT ONLY
DIR20    EQU   *
         LM    R15,R1,EDTSVZ            RESTORE LENGTH AND TERMINATOR
         CLI   DERRCD,ERR14
         BE    DIROUT                   RETURN IF ERROR 14
         CLI   DERRCD,ERR9              TEST IF PREVIOUSLY DEFINED
         BL    DIROUT                   RETURN IF BELOW ERROR 9
         BH    DIR31                    BR IF ABOVE ERROR 9
         GOIF  SMDEF,ON=DIR31           BR- DICTIONARY OVERLAP IN MACRO
         SET   SKPEND,ON                FLUSH WHOLE SOURCE STREAM
DIROUT   L     BASE2,REGSAVE3           RESTORE OLD BASE
         BR    R3                       AND RETURN
DIR30    EQU   *
         L     R15,EDTSVZ               GET THE LENGTH
DIR31    SET   SKPMND,ON                FLUSH MACRO
         SET   SXPRTO,OFF
         L     INDEXP,OFPTRSV           RESTORE JTEXTA POINTER
         L     INPTR,FPTRSV             RESTORE FIELD POINTER
         L     BASE2,REGSAVE3           RESTORE OLD BASE
         B     WRAPFLD                  THROW AWAY THIS STATEMENT
         SPACE 3
***************
         DS    0F
DENTRY   DC    A(DRUTENT)               DIRECTORY ROUTINE ENTRY POINT
*
SVCTLFM  EQU   *
         MVC   COPYSV3(L'JSRCLN*7),JSRCLN SAVE CURRENT CTL FORMATS
         MVC   JSRCLN(L'JSRCLN*7),SRCLEN
         MVC   COPYSV4(L'TBGLN*6),TBGLN
         MVC   TBGLN(L'TBGLN*6),STDPARM
         SET   JINLIB,ON                INDICATE IN LIBRARY MODE
         MVC   INPUT,STNPSTD            GET STD ICTL INPUT WORK BUF PTR
         MVC   MINPUT,MINPSTD           GET STD ICTL MINPUT WORK BUF PT
         MVC   MINDIF,SVMINDIF          RESTORE STD BUFF DIFFERENCE
         MVC   ENDWKA,SVENDWKA          RESTORE STD WORK BUFF END
         BR    TLINK                    RETURN TO CALLER
         EJECT
****************************************
*   SNAPERR - LINKAGE TO THIS ROUTINE IS
*        DC    AL2(BR CODE)             IF BR CD=1, FINISH WITH ABSERR-
*        DC    AL1(X*16+SEVERITY CODE)  ELSE FINISH WITH WRNERR
*        DC    AL1(ERROR CODE)
****************************************
         SPACE 3
NSNAPERR EQU   *
         LH    R11,D0(,TLINK)           SET UP BRANCH CODE
         LA    TLINK,D2(,TLINK)         ADJ RETURN POINT
         USING ERRMESS,R10
         L     R10,ESTKNDX              SET ADDRESSABILITY
         MVI   EMSGNTRY,JBLANK
         MVC   EMSGNTRY+1(L'EMSGNTRY-1),EMSGNTRY
         CH    R15,H7                   DON'T DUMP MORE THAN 8 CHARS
         BNH   SNAPMOV                  SEVEN OR LESS IS OK
         LH    R15,H7                   DEFAULT TO 8 CHARS
SNAPMOV  EX    R15,MVSYM                MOVE DATA ITEM
         LA    R14,D8
         STC   R14,ENTRYLNG
         BCT   R11,NWRNERR              LOG ERROR CODE
*
***********************************************************************
*   ABSERR
*   WRNERR -
*   IT IS CALLER'S RESPONSIBILITY TO PLACE THE LENGTH AND ITS
*   ASSOCIATED DATA ITEM(S) IN THE ERROR MESSAGE STACK AT ESTKNDX
*   BEFORE ENTER INTO THIS ROUTINE.
*
*   CALLING SEQUENCE IS
*        BAL   TLINK,ABSERR             LOG ERROR
*        DC    AL1(X*16 + SEVERITY CODE)
*        DC    AL1(ERROR CODE)
*        (RETURN TO HERE IF X=0, ELSE EXIT VIA ERTNTBL AT ENTRY X)
***********************************************************************
         SPACE 3
NABSERR  EQU   *
         L     INDEXO,OUTADR            INSURE OUTPUT POINTER
         GOIF  SXPRTO,OFF=ABSE10        BRANCH IF NOT EXPECTING PROTO
         SET   SKPMND,ON
         SET   SBDPROTO,ON
         SET   SUBLST,OFF
         SET   SXPRTO,OFF
ABSE10   GOIF  SUBLERR,ON=ABSE11        NO PRONLY BIT IN REC   @OZ06551
         SET   JPRONLY,ON               PRINT ONLY STATEMENT   @OX12896
ABSE11   SET   SUBLERR,OFF              RESET SW               @OZ06551
         SET   SUPDNT,ON                AND SUPPRESS DIRECTORY ENTRY
NWRNERR  SET   RMPURE,ON
         L     R10,ESTKNDX              SET ADDRESSABILITY
         USING ERRMESS,R10
         MVC   EMSGSVTY(D2),D0(TLINK)
         NI    EMSGSVTY,X'0F'           MASK OFF RTN CODE
         CLC   EMSGSVTY(D1),JMSGL       TEST SEV CODE
         BL    ERREXIT                  NO ERROR LOGGING SINCE LOW
         CLI   ERRCNT1,D5               TEST IF MSG STACK FULL
         BL    BMPNDX                   OK, REGISTER THIS ERROR
         MVC   EMSGSVTY(L'EROERS),EROERS MSG - MORE THAN 5 ERRORS
         BH    ERREXIT                  LOOP THRU AFTER 6TH ENTRY
         B     BMPCNT                   GO GUMP ERROR COUNT
BMPNDX   LA    R10,ERMEND(,R10)         BUMP INDEX
         ST    R10,ESTKNDX              UP ERROR STACK INDEX
         MVI   ENTRYLNG,D0
BMPCNT   EQU   *
         IC    R14,ERRCNT1
         LA    R14,D1(,R14)             BUMP ERROR COUNT
         STC   R14,ERRCNT1
ERREXIT  SR    R15,R15
         CLC   EMSGSVTY(D1),JSEVER      IS THIS HIGHER
         BNH   ERREXIT1                 BRANCH IF NOT
         MVC   JSEVER(D1),EMSGSVTY      ENTER HIGH
ERREXIT1 IC    R15,D0(,TLINK)           GET RETURN CODE
         SRA   R15,D4                   MASK OFF SEVERITY CODE
         BNZ   ERROUT                   BR IF ERR RETURN SPECIFIED
         L     BASE2,REGSAVE3           RESTORE BASE ADDR
         B     D2(,TLINK)               RETURN TO PLACE OF CALL
ERROUT   SLA   R15,D2                   MULTIPLY BY 4
         L     R1,ERTNTBL-D4(R15)       GET RETURN ADDRESS
         L     BASE2,REGSAVE3           RESTORE BASE ADDR
         BR    R1                       RETURN
MVSYM    MVC   EMSGNTRY(0),D0(INPTR)    OFF-THE-LINE MOVE
         DS    0F                       ALIGNMENT INSURANCE
EROERS   DS    0CL3
         DC    AL1(SEV18)               NO MORE ERROR LOGGING
         DC    AL1(ERR18)               MAX NUMBER OF 5 ERRORS ALLOWED
         DC    AL1(0)                   .
EEROERS  DS    0H
         SPACE 3
ERTNTBL  DS    0CL40                    MAY NOT EXCEED 15 ENTRIES
         DC    A(BADIX)        1 FLUSH SOURCE
         DC    A(AOPPTR)       2 WRAP UP STATEMENT
         DC    A(NAMERR)       3 NAME IN ERROR
         DC    A(CLN0)         4 CLEAN UP STATEMENT
         DC    A(CLEANUP)      5 DITTO
         DC    A(WRAPFLD)      6 END OF OPND 'CAUSE OF ERROR
         DC    A(EDTSTG)       7 WRAP UP STRING FIELD
         DC    A(INVALID)      8 INPUT SEQ ERROR
         DC    A(STEND)        9 PARAMETER ERROR
         DC    A(SKMNDST)      10 SKIP TO MEND STATEMENT
EERTNTBL EQU   *                        END OF TABLE
         EJECT
**************************************
*        END OF FILE ROUTINE         *
**************************************
NUNXPEOF EQU   *
         GOIF  SOPNCD,OFF=NEOFRTN       LOG ERR LATER IF IN PROG MACRO
         BAL   TLINK,NABSERR            ERROR UNEXPECTED EOF
         DC    AL1(SEV47)               SEVERITY CODE
         DC    AL1(ERR47)               ERROR CODE
         L     BASE4,CS4ADDR            GET BACK TO CSECT 4
         SPACE 3
NEOFRTN  SET   SINEOF,OFF               RESTORE EOF SWITCH
         GOIF  JINLIB,ON=EODLIB         BRANCH IF EOD ON SYS LIBRARY
         SET   SLSTCD,ON                INDICATE LAST CARD READ
         GOIF  SOPNCD,OFF=PGRMAC        BRANCH IF IN PROGRAMMER MACRO
         SET   SKPEND,OFF
GENEND   EQU   *
         GOIF  SENDST,OFF=GENEND1       BRANCH IF NO ENDSTMT    OX00095
         CLI   ERRCNT1,D0               IS THERE AN ERROR       OX00095
         BE    EOPNCD                   BRANCH IF NO            OX00095
         B     GENEND2                  GO WRITE OUT ERR REC    OX00095
GENEND1  EQU   *                                                OX00095
         BAL   R3,GENMEND               GO GENERATE RECORD
         MVI   JTIOP,JTEND              INDICATE END STATEMENT
         MVC   JTOPCD(L'GEND),GEND      MOVE IN MNEMONIC
         BAL   TLINK,NWRNERR            LOG ERROR
         DC    AL1(SEV60)               AND THEN GO TO
         DC    AL1(ERR60)               GENERATE AN END STATEMENT
         L     BASE4,CS4ADDR            GET BACK TO CSECT 4
GENEND2  EQU   *                                                OX00095
         L     BASE2,CS2ADDR            TEMPORILY RESTORE BASE 2
         BAL   RETURN,WRAPERR           GO WRITE OUT ERROR RECORD
         L     BASE4,CS4ADDR            GET BACK TO CSECT 4
         SET   (SFSTCD,SUPDNT),OFF      RESET SWITCHES
         SET   (SNMFND,SNOFND,SDTCMT,STRCMT),OFF
         SET   (SBYCNT,SBYONE),OFF      RESET SWITCHES
         SPACE
EOPNCD   LA    R11,D8                   LENGTH
         BAL   RETURN,OPUTL             GET BUFFER
         MVC   JTRLI(L'EOFHD),EOFHD     EOF HEADER
         MVI   JTIOP,JTEEOF             IOC
         MVI   DDNDX1,OPENEND           SET UP INDEX FOR BR TO DIR RTN
         BAL   R3,NDIR10                CLOSE OPEN CODE
         L     BASE4,CS4ADDR            GET BACK TO CSECT 4
         SET   SOPNCD,OFF               INDICATE OUT OF OPEN CODE
         SET   SSYSMD,ON                INDICATE EDITIONG SYSTEM MACRO
         BAL   TLINK,SVCTLFM            RESTORE STANDARD ICTL FORMATS
         SET   (SISEQ,SNOCNT),OFF
         B     ESYSMAC                  GO EDIT SYSTEM MACROS
*
EODLIB   EQU   *
         GOIF  SINCPY,OFF=ELIB05        BRANCH IF NOT IN COPY CODE
         GOIF  SMAC,ON=ELIB05           GENERATE MEND IF MACRO COPIED
         L     BASE2,CS2ADDR            RESTORE BASE FOR SECOND CSECT
         L     LINK,ACSTKEXT            GET ROUTINE ADDR
         BALR  R3,LINK                 RECURSIVE EXIT
         B     WREXIT                   ERROR EXIT
ELIB05   EQU   *
         BAL   TLINK,NWRNERR            GO LOG ERROR ON UNEXPECTED
         DC    AL1(SEV51)               EOD WHEN READING FROM THE
         DC    AL1(ERR51)               SYSTEM LIBRARY
         L     BASE4,CS4ADDR            GET BACK TO CSECT 4
         L     BASE2,CS2ADDR            TEMPORILY RESTORE BASE 2
         BAL   RETURN,WRAPERR1          OUTPUT ERR REC- DON'T SET JERR
         L     BASE4,CS4ADDR            GET BACK TO CSECT 4
         BAL   R3,GENMEND               GENERATE RECORD
         MVI   JTIOP,JTMEND             INDICATE MEND STMT
         MVC   JTOPCD(L'GMEND),GMEND    MOVE IN MNEMONIC
         L     BASE2,CS2ADDR            RESTORE BASE FOR SECOND CSECT
         B     MEND0                    GO CLOSE MACRO DEFINITION
*
PGRMAC   EQU   *
         BAL   TLINK,NWRNERR            LOG ERROR
         DC    AL1(SEV47)               .
         DC    AL1(ERR47)               UNEXPECTED EOD ON SYS INPUT
         L     BASE4,CS4ADDR            GET BACK TO CSECT 4
         GOIF  SMDEF,OFF=OPOPEN         BRANCH IF NOT IN MACRO
         SET   SKPMND,ON                SIMULATE SKIP-TO-MEND CONDITION
         BAL   R3,GENMEND               GENERATE RECORD
         MVI   JTIOP,JTMEND             INDICATE A MEND STATEMENT
         MVC   JTOPCD(L'GMEND),GMEND    MOVE IN MNEMONIC
         SET   (SMDEF),OFF              SIMULATE MEND CONDITION
         MVI   DDNDX1,MACREND           SET UP INDEX FOR BR TO DIR RTN
         BAL   R3,NDIR10                GO TO DIRECTORY ROUTINE
         L     BASE2,CS2ADDR            CHANGE TO CSECT 2
         BAL   RETURN,WRAPERR           GO WRITE OUT ERROR RECORD
         L     BASE4,CS4ADDR            GET BACK TO CSECT 4
         BAL   TLINK,NWRNERR            GO LOG ERROR FOR GEN MEND
         DC    AL1(SEV55)               ERROR PARAMETER
         DC    AL1(ERR55)               ERROR PARAMETER
         L     BASE2,CS2ADDR            CHANGE TO CSECT 2
         BAL   RETURN,WRAPERR           GO WRITE OUT ERROR RECORD
         L     BASE4,CS4ADDR            GET BACK TO CSECT 4
         SET   SKPMND,OFF
         SPACE
OPOPEN   SET   (SPGRMD,SOPNCD),FLIP     OUT OF PRGMR MACS, NOW OPEN CD
         MVI   DDNDX1,OPENENT           SET UP INDEX FOR BR TO DIR RTN
         BAL   R3,NDIR10                OPEN UP OPEN CODE BEFORE
         L     BASE4,CS4ADDR
         B     GENEND                   GENERATE END STATEMENT
         SPACE 3
ESYSMAC  GOIF  LSTSYSMS,ON=PHSEND       BRANCH IF SYS MACROS ALL EDITED
         SET   SNOSYSMD,OFF
* REGISTER 10 POINTER IS SUPPLIED BY DIRECTORY ROUTINE
         ST    R10,JFWORD1              SAVE POINTER TO NAME
         JFIND ADDR=(R10)               GO FIND IT IN LIBRARY
         BP    ESMGO                    BRANCH IF MACRO FOUND
         SET   SKPMND,ON                ELSE, SIMULATE FLUSH CONDITION
         SET   SNOSYSMD,ON              SYSTEM M DEF NOT FOUND
         L     BASE2,CS2ADDR            RESTORE BASE FOR SECOND CSECT
         B     MEND1                    CLOSE MACRO STMT
ESMGO    SET   SXMCRO,ON                EXPECTING MACRO STMT
         SET   SXPRTO,OFF                                      @XA04142
         L     R9,JFWORD1               RESTORE POINTER TO NAME
         MVC   LASTFIND(L'LASTFIND),D0(R9) GET NAME OF MEMBER FOUND
         L     BASE2,CS2ADDR            RESTORE BASE FOR SECOND CSECT
         B     READNEXT
SMNAMOV  MVC   SMACNAM(0),D1(R11)       OFF-THE-LINE MOVE
         SPACE
PHSEND   MVC   JSRCLN(L'JSRCLN*7),COPYSV3 RESTORE ICTL FORMATS
         LA    R11,D8                   EOF RECORD SIZE
         BAL   RETURN,OPUTL             GET O/P BUFFER
         MVC   JTRLI(L'EOFHD),EOFHD     MOVE IN EOF RECORD
*
         JTRUNC FILE=FILE1             TRUNCATE LAST BUFFER
*
         L     PARAM1,DSTGBGN
         JFRECORE ADDR=(R10)            FREE WORK BUFFER
         LR    PARAM1,MODCOMM
         JFRECORE ADDR=(R10)            FREE MODULE COMMON AREA
*
EDITXIT  JRETURN                        RETURN TO CONTROLLER
         SPACE 3
*********************************************
*        GENERATE MEND/END STATEMENT        *
*********************************************
GENMEND  EQU   *
         LA    R11,L'FXDHD+L'GMEND      GET OUTPUT BUFFER
         BAL   RETURN,OPUTL             GET O/P BUFFER
         MVC   JTRLI(L'FXDHD),FXDHD     MOVE IN HEADER
         SET   JPRONLY,OFF              REMOVE PRINT ONLY SWITCH
         LA    TWKREG1,D2(,INDEXP)      COMPUTE FIELD POINTER
         SR    TWKREG1,INDEXO
         STH   TWKREG1,JTOCP            AND SAVE IN ET
         LA    TWKREG1,D8(,INDEXP)      COMPUTE RECORD LENGTH
         SR    TWKREG1,INDEXO
         STH   TWKREG1,JTRLI            AND SAVE IN ET
         BR    R3                       RETURN
         SPACE 3
GEND     DS    0CL5                     GENERATED END STATEMENT
         DC    AL1(JA,D3,JE,JN,JD)      GEN EDITED TEXT FOR END STMT
GMEND    DS    0CL6                     GENERATED MEND STATEMENT
         DC    AL1(JA,D4,JM,JE,JN,JD)   GEN EDITED TEXT FOR MEND STMT
EOFHD    DS    0CL8
         DC    AL2(D8)                  RECORD LENGTH
         DC    AL1(JPSOP,D0)            EOF FLAG
         DC    AL1(JTEOF)               EOF INDICATOR
         DC    AL1(X'EE',X'00',X'FF')   EOF
         SPACE 3
         JPATCH  X1A30,410
         SPACE 3
         END   EDITENT
