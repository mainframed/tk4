         JHEAD 'DICTIONARY INTERLUDE PHASE',                           X
               PHASEID=X2A,                                            X
               LEVEL=10
*FUNCTION/OPERATION-                                                  *
*   GENERALLY, THE DICTIONARY INTERLUDE PHASE BUILDS THE GENERATION   *
*   TIME DICTIONARIES REQUIRED IN THE GENERATE PHASE. SPECIFICALLY,   *
*   THIS PHASE -                                                      *
*        (1) BUILDS THE SEQUENCE SYMBOL REFERENCE DICTIONARY FOR      *
*            EACH MACRO DEFINITION AND FOR OPEN CODE FROM THE         *
*            SEQUENCE SYMBOL REFERENCES AND SEQUENCE SYMBOL DEFIN-    *
*            ITIONS IN THE TEXT SEGMENT DICTIONARY FILE FOR THE       *
*            RESPECTIVE MACRO DEFINITIONS AND OPEN CODE               *
*        (2) BUILDS THE ORDINARY SYMBOL REFERENCE DICTIONARY FROM     *
*            THE ORDINARY SYMBOL REFERENCES IN THE TEXT SEGMENT       *
*            DICTIONARY FILE AND THE ORDINARY SYMBOL DEFINITIONS      *
*            IN THE ORDINARY SYMBOL DEFINITION FILE                   *
*        (3) BUILDS THE GLOBAL VECTOR FOR EACH MACRO DEFINITION AND   *
*            FOR OPEN CODE FROM THE GLOBAL DEFINITIONS IN THE TEXT    *
*            SEGMENT DICTIONARY FILE FOR THE RESPECTIVE MACRO DEFIN-  *
*            ITIONS AND OPEN CODE                                     *
*        (4) BUILDS THE SKELETON DICTIONARY HEADER FOR EACH MACRO     *
*            DEFINITION AND FOR OPEN CODE FROM THE MACRO DEFINITION   *
*            DIRECTORY ENTRIES FOR THE RESPECTIVE MACRO DEFINITIONS   *
*            AND OPEN CODE                                            *
*        (5) BUILDS THE OPSYN TABLE FOR THE GENERATE PHASE FROM THE   *
*            OPSYN TABLE FOR THE EDIT PHASE                           *
*        (6) BUILDS THE MACRO DEFINITION VECTOR FOR THE GENERATE      *
*            PHASE                                                    *
*        (7) DETERMINES THE GLOBAL DICTIONARY ALLOCATION FOR THE      *
*            GENERATE PHASE FROM THE GLOBAL DEFINITIONS IN THE        *
*            TEXT SEGMENT DICTIONARY FILE                             *
*                                                                     *
*ENTRY POINT-                                                         *
*        INTRENTR                                                     *
*                                                                     *
*INPUT-                                                               *
*   FILE 2 - TEXT SEGMENT DICTIONARY FILE FOR EACH MACRO DEFINITION   *
*          - TEXT SEGMENT DICTIONARY FILE FOR OPEN CODE               *
*   FILE 3 - ORDINARY SYMBOL DEFINITION FILE                          *
*          - MACRO DEFINITION DIRECTORY/OPSYN TABLE                   *
*                                                                     *
*OUTPUT-                                                              *
*   FILE 1 - SKELETON DICTIONARY FOR EACH MACRO DEFINITION            *
*          - SKELETON DICTIONARY FOR OPEN CODE                        *
*          - ERROR RECORDS ORIGINATING IN THE INTERLUDE PHASE         *
*   FILE 2 - ORDINARY SYMBOL REFERENCE DICTIONARY                     *
*          - MACRO DEFINITION VECTOR                                  *
*          - OPSYN TABLE                                              *
*                                                                     *
*EXTERNAL ROUTINES-                                                   *
*                                                                     *
*                                                                     *
*                                                                     *
*EXITS,NORMAL-                                                        *
*   RETURN TO THE DRIVER WITH THE COMPLETION CODE SET TO A ZERO       *
*   VALUE.                                                            *
*                                                                     *
*EXITS,ERROR-                                                         *
*   RETURN TO THE DRIVER WITH THE COMPLETION CODE SET TO A NON-ZERO   *
*   VALUE, THE SPECIFIC VALUE INDICATING THE ACTION TO BE TAKEN BY    *
*   THE DRIVER.                                                       *
*                                                                     *
*TABLES/WORK AREAS-                                                   *
*   MACRO DEFINITION DIRECTORY - A CHAINED TABLE CONTAINING AN        *
*        ENTRY FOR EACH UNIQUE MACRO NAME ENCOUNTERED IN THE TEXT     *
*        OF ALL MACRO DEFINITIONS AND OPEN CODE, AND AN ENTRY FOR     *
*        OPEN CODE (MERGED WITH THE OPSYN TABLE).                     *
*   OPSYN TABLE - A CHAINED TABLE CONTAINING AN ENTRY FOR EACH        *
*        UNIQUE MNEMONIC AFFECTED BY AN OPSYN STATEMENT (MERGED       *
*        WITH THE MACRO DEFINITION DIRECTORY).                        *
*   SEQUENCE SYMBOL DEFINITION TABLE - A CHAINED TABLE CONTAINING     *
*        AN ENTRY FOR EACH UNIQUE SEQUENCE SYMBOL DEFINED IN A        *
*        MACRO DEFINITION OR OPEN CODE.                               *
*   ORDINARY SYMBOL REFERENCE TABLE - A CHAINED TABLE CONTAINING AN   *
*        ENTRY FOR EACH REFERENCE TO AN ORDINARY SYMBOL ENCOUNTERED   *
*        IN AN ATTRIBUTE REFERENCE OR IN A MACRO INSTRUCTION          *
*        OPERAND (MERGED WITH THE GLOBAL DIRECTORY).                  *
*   GLOBAL DIRECTORY - A CHAINED TABLE CONTAINING AN ENTRY FOR        *
*        EACH SYSTEM GLOBAL VARIABLE AND EACH UNIQUE VARIABLE SYMBOL  *
*        ENCOUNTERED ON A GBLX STATEMENT IN THE TEXT OF ALL MACRO     *
*        DEFINITIONS AND OPEN CODE (MERGED WITH THE ORDINARY          *
*        SYMBOL REFERENCE TABLE).                                     *
*   MACRO DEFINITION VECTOR - A SEQUENTIAL TABLE CONTAINING AN        *
*        ENTRY FOR EACH UNIQUE MACRO NAME ENCOUNTERED IN THE TEXT     *
*        OF ALL MACRO DEFINITIONS AND OPEN CODE, AND AN ENTRY FOR     *
*        OPEN CODE.                                                   *
*   ORDINARY SYMBOL REFERENCE DICTIONARY - A SEQUENTIAL TABLE         *
*        CONTAINING AN ENTRY FOR EACH ORDINARY SYMBOL ENCOUNTERED     *
*        IN AN ATTRIBUTE REFERENCE OR IN THE OPERAND OF A MACRO       *
*        INSTRUCTION.                                                 *
*   OPSYN TABLE - A SEQUENTIAL TABLE CONTAINING AN ENTRY FOR EACH     *
*        UNIQUE MNEMONIC AFFECTED BY AN OPSYN STATEMENT.              *
*   SKELETON DICTIONARY AREA - THE AREA IN WHICH THE SKELETON DICT-   *
*        IONARY FOR EACH MACRO DEFINITION AND OPEN CODE IS BUILT.     *
*        EACH SKELETON DICTIONARY CONSISTS OF A SKELETON DICTION-     *
*        ARY HEADER, A GLOBAL VECTOR, AND A SEQUENCE SYMBOL REFER-    *
*        ENCE DICTIONARY. THE SIZE OF THE SKELETON DICTIONARY AREA    *
*        VARIES ACCORDING TO THE REQUIREMENTS FOR THE SKELETON        *
*        DICTIONARY FOR EACH TEXT SEGMENT.                            *
*                                                                     *
*ATTRIBUTES-                                                          *
*   REFRESHABLE                                                       *
*                                                                     *
*NOTES-                                                               *
*                                                                     *
*                                                                     *
*                                                                     *
         EJECT
         COPY  JCOMMON
         EJECT
INTRCOM  DSECT
RECADDR  DS    F                        PTR TO LAST RECORD READ
COMSTRT  DS    F                        PTR TO PHASE COMMON AREA
MDDSTRT  DS    F                        PTR TO START OF MACRO DEF DIRCT
FREESTRT DS    F                        PTR TO LOW END OF WORK AREA
FREEEND  DS    F                        PTR TO HIGH END OF WORK AREA
GDSTRT   DS    F                        PTR TO START OF GBL DIRECTORY
OSRTSTRT EQU   GDSTRT                   PTR TO START OF ORD SYMB REF TB
GDEND    DS    F                        PTR TO CURRENT END OF GBL DIR
OSRTEND  EQU   GDEND                    PTR TO CURRENT END OF ORD SYMB
OSRDSTRT EQU   OSRTEND                  PTR TO START OF ORD SYMB REF DI
MDVSTRT  DS    F                        PTR TO START OF MACRO DEF VECTR
MDDND    DS    F                        PTR TO END OF MACRO DEF DIRECT
SSDTSTRT DS    F                        PTR TO START OF SEQ SYMB DEF TB
SSDTEND  DS    F                        PTR TO CURRENT END OF SEQ SYMB
SKDCSTRT DS    F                        PTR TO START OF SKEL DICT
GDALLOC  DS    F                        CURRENT SIZE OF GLOBAL DICTIONY
OREFCNT  DS    F                        COUNT OF ORD SYMB ATTR REFERS
MDVLNTH  DS    F                        LENGTH OF MACRO DEFIN VECTOR
OPSCHAIN DS    F                        MASTER LINK IN OPSYN CHAIN
ENDCOL   DS    F                        PTR TO END OF OPERAND
VECTSAVE EQU   ENDCOL                   TEMP FULLWORD WORK AREA
ERRBLK   DS    F                        PTR TO ERROR RECORD BUFFER
ERBLKPTR DS    F                        PTR TO NEXT SLOT IN ERROR BUF
LNGSK    DS    F                        LENGTH OF SKELETON DICTIONARY
GBLSK    DS    F                        PTR TO START OF GLOBAL VECTOR
SEQSK    DS    F                        PTR TO START OF SEQ,SYM REF DIC
ERRLNKSV DS    F                        SAVE AREA ERROR RTN LINK REG
HIBYTE0  DS    F                        FULL WORD WORK AREA
SHIFTAMT EQU   HIBYTE0+D3               ONE BYTE WORK AREA
*
* THIS IS THE ASCAN WORK AREA.
*
AWORK    DS    0F
AFLAGS   DSW   ADCON1,                  ADDRESS CONSTANT (A,Y,V,S)     X
               ADCON2,                  ADDRESS CONSTANT (Q)           X
               CHCON,                   CHARACTER CONSTANT (C)         X
               BXCON,                   HEX. OR BINARY CONSTANT (X,B)  X
               DCCON,                   DECIMAL CONSTANT (P,Z)         X
               FLCON,                   FLOATING-PT CONSTANT (D,E,L)   X
               FXCON                    FIXED-PT CONSTANT (F,H)
ATYPEAT  DS    XL1                      TYPE ATTRIBUTE
ALENGTH  DS    XL2                      LENGTH ATTRIBUTE
ASCALE   DS    XL2                      SCALE ATTRIBUTE
ALENMAX  DS    XL2                      MAXIMUM LENGTH VALUE
ASCAMAX  DS    XL2                      MAXIMUM SCALE VALUE
ATYPALT  DS    XL1                      ALTERNATE TYPE ATTRIBUTE
         ORG   ATYPALT                  ORIGIN FOR ALTERNATIVE BYTE
ARFACT   DS    XL1                      ROUNDING FACTOR
ASFACT   DS    XL1                      SHIFTING FACTOR
ACHARLMT DS    XL1                      HIGH CHARACTER LIMIT
*
SWITCHA  DSW   ENDSW,                   END OF EXTRN OPERAND HIT       X
               FNDFLG,                  MATHING TABLE ENTRY FOUND      X
               QUOTESW,                 QUOTE MODE ENTERED             X
               TRANSW,                  TRANSLATE SDT VALUE            X
               ,,,
SWITCHB  DSW   DSSW,                    DS (NOT DC) STATEMENT          X
               EXLENFLG,                EXPLICIT LENGTH MODIFIER USED  X
               NSCALSW,                 NEGATIVE SCALE MODIFIER USED   X
               SCALEFLG,                SCALING DECIMAL POINT FOUND    X
               SIGNFLG,                 CONSTANT SIGN PROCESSED        X
               DEFLTL,                  DEFAULT LENGTH MODIFIER USED   X
               ,
DELIMIT  DS    X                        OPERAND DELIMITER SCANNED FOR
PIOPARMB DS    F                        INITIAL I/O LENGTH
PIOPARMA DS    F                        I/O AREA ADDRESS
PIOPARMC DS    H                        I/O AREA LENGTH
SAVE3456 DS    5F                       REGISTER SAVE AREA
FSWITCH  DS    X                        FIRST-WRITE SWITCH
ERRHDR   DS    CL12                     ERROR RECORD HEADER AREA
ERRNAME  DS    CL8                      ERROR RECORD FIRST NAME AREA
ERROTHR  DS    CL16                     ERROR RECORD 2ND, 3RD NAMES
         DS    4F                       PATCH AREA
ENDCOM   DS    0D
         EJECT
*
* THIS DSECT MAPS THE MACRO DEFINITION DIRECTORY ENTRY.
*
MDDNTRY  DSECT
MCHAIN   DS    XL3                      CHAIN PTR         3 BYTES
MFLAGS   DSW   TSEDIT,                  ON-SEGMENT EDITED              X
               OCTS,                    ON-OPEN CODE ENTRY             X
               FLUSH,,,                 ON-MACRO FLUSHED               X
               MNL1,MNL2,MNL3           MACRO NAME LENGTH
MSYMBL   DS    XL8                      SYMBOL (PADDED)   8 BYTES
MVECTR   DS    XL3                      VECTOR POINTER    3 BYTES
MTXTNP   DS    XL8                      TEXT FILE N/P     8 BYTES
MTSDNP   DS    XL8                      DICT FILE N/P     8 BYTES
MGBLSZ   DS    XL3                      GBL VCTR SIZE     3 BYTES
MSEQSZ   DS    XL3                      SEQ SYM DICT SIZE 3 BYTES
MLCLSZ   DS    XL3                      LCL DICT SIZE     3 BYTES
MDDEND   EQU   *
*
* THIS DSECT MAPS THE OPSYN TABLE ENTRY, AS PASSED FROM THE EDIT
*            PHASE.
*
OPSYNTRY DSECT
OPSYNCH  DS    XL3                      CHAIN POINTER     3 BYTES
OPSYNFLG DSW   ,,,,                     SPACE FOR OPCODE FLAGS         X
               OMAC,                    OPSYN MACRO ENTRY              X
               ODEL                     DELETED
OPSYNATT DS    XL3                      ATTRIBUTES
ONAMEL   DS    XL1                      NAME LENGTH
ONAME    DS    XL8                      NAME
OPSYND   EQU   *
*
* THIS DSECT MAPS THE OPSYN TABLE ENTRY, AS PASSED TO THE GENERATE
*            PHASE.
*
OPSTBL   DSECT
OPSFLGS  DS    XL1                      FLAGS
OPSTATTS DS    XL3                      ATTRIBUTES
OPSTNL   DS    XL1                      NAME LENGTH
OPSTNAM  DS    XL8                      NAME
OPSTND   EQU   *
*
* THIS DSECT MAPS THE MACRO DEFINITION VECTOR ENTRY.
*
MDVNTRY  DSECT
MNPTXT   DS    XL8                      TEXT FILE N/P     8 BYTES
MNPSD    DS    XL8                      SKEL DICTION N/P  8 BYTES
MSDL     DS    XL3                      SKEL DICT LENGTH  3 BYTES
MDVEND   EQU   *
*
* THIS DSECT MAPS THE HEADER FOR THE SKELETON DICTIONARY.
*
SKDCTHDR DSECT
SKSRDPT  DS    XL3                      DISPL SEQ SYM DIC 3 BYTES
SKLDADR  DS    XL3                      LCL DICT PTR      3 BYTES
SKLDLNG  DS    XL3                      LCL DICT LENGTH   3 BYTES
SKMPADR  DS    XL3                      MACRO PARAM PTR   3 BYTES
SKKVADR  DS    XL3                      KEYWD VECTR PTR   3 BYTES
SKADNLD  DS    XL4                      DICT ADR NXT LVL  4 BYTES
SKNPNLT  DS    XL8                      TEXT N/P NXT LVL  8 BYTES
SKACTRV  DS    XL4                      ACTR VALUE        4 BYTES
SKNOFSLS DS    XL2                      N'&SYSLIST        2 BYTES
SKHDREND EQU   *
*
* THIS DSECT MAPS THE LOGICAL RECORD READ FROM THE TEXT SEGMENT
*            DICTIONARY FILE FOR A SEQUENCE SYMBOL DEFINITION.
*
SSDEF    DSECT
SDEFRL   DS    XL2                      RECORD LENGTH     2 BYTES
SDEFRT   DS    X'04'                    RECORD TYPE       1 BYTE
SDEFNP   DS    XL8                      NOTE/POINT ADDR   8 BYTES
SDEFSL   DS    XL1                      SYMBOL LENGTH     1 BYTE
SDEFSS   EQU   *                        SEQUENCE SYMBOL 2-8 BYTES
*
* THIS DSECT MAPS THE SEQUENCE SYMBOL DEFINITION TABLE ENTRY.
*
SSDTNTRY DSECT
SSDTCP   DS    XL3                      CHAIN POINTER     3 BYTES
SSDTNP   DS    XL8                      NOTE/POINT ADDR   8 BYTES
SSDTSL   DS    XL1                      SYMBOL LENGTH     1 BYTE
SSDTSY   EQU   *                        SEQUENCE SYMBOL 2-8 BYTES
*
* THIS DSECT MAPS THE LOGICAL RECORD READ FROM THE TEXT SEGMENT
*            DICTIONARY FILE FOR A SEQUENCE SYMBOL REFERENCE.
*
SSREF    DSECT
SREFRL   DS    XL2                      RECORD LENGTH     2 BYTES
SREFRT   DS    X'08'                    RECORD TYPE       1 BYTE
SREFDP   DS    XL3                      DICTIONARY PTR    3 BYTES
SREFSL   DS    XL1                      SYMBOL LENGTH     1 BYTE
SREFSS   EQU   *                        SEQUENCE SYMBOL 2-8 BYTES
*
* THIS DSECT MAPS THE LOGICAL RECORD READ FROM THE TEXT SEGMENT
*            DICTIONARY FILE FOR A GLOBAL DEFINITION.
*
GBLDEFN  DSECT
GDEFRL   DS    XL2                      RECORD LENGTH     2 BYTES
GDEFRT   DS    X'00'                    RECORD TYPE       1 BYTE
GDEFF    DS    X                        FLAGS             1 BYTE
GDEFSL   DS    X                        SYMBOL LENGTH     1 BYTE
GDEFVS   EQU   *                        VARIABLE SYMBOL 2-8 BYTES
         ORG   GBLDEFN                  ORIGIN ZERO
GDEFTF   DS    X                        TEXT FLAG VALUE   1 BYTE
GDEFVP   DS    XL3                      VECTOR POINTER    3 BYTES
GDEFD    DS    XL2                      DIMENSION         2 BYTES
*
* THIS DSECT MAPS THE LOGICAL RECORD READ FROM THE TEXT SEGMENT
*            DICTIONARY FILE FOR AN ORDINARY SYMBOL REFERENCE.
*
OSREF    DSECT
OREFRL   DS    XL2                      RECORD LENGTH     2 BYTES
OREFRT   DS    X'0C'                    RECORD TYPE       1 BYTE
OREFDP   DS    XL3                      DICTIONARY PTR    3 BYTES
OREFSL   DS    XL1                      SYMBOL LENGTH     1 BYTE
OREFOS   EQU   *                        ORDINARY SYMBOL 1-8 BYTES
*
* THIS DSECT MAPS THE END-OF-SEGMENT RECORD READ FROM THE TEXT
*            SEGMENT DICTIONARY FILE.
*
ENDSEG   DSECT
ESEGRL   DS    XL2                      RECORD LENGTH     2 BYTES
ESEGRT   DS    X'10'                    RECORD TYPE       1 BYTE
*
* THIS DSECT MAPS THE END-OF-FILE RECORD READ FROM THE TEXT SEGMENT
*            DICTIONARY FILE AND THE ORDINARY SYMBOL DEFINITION FILE.
*
ENDFIL   DSECT
EFILRL   DS    XL2                      RECORD LENGTH     2 BYTES
EFILRT   DS    X'FF'                    RECORD TYPE       1 BYTE
*
* THIS DSECT MAPS THE ORDINARY SYMBOL REFERENCE DICTIONARY ENTRY.
*
OSRDNTRY DSECT
TATTRIB  DS    X                        TYPE ATTRIBUTE    1 BYTE
LATTRIB  DS    XL2                      LENGTH ATTRIBUTE  2 BYTES
SATTRIB  DS    XL2                      SCALE ATTRIBUTE   2 BYTES
ATTRIB   DSW   TDEFALT,                 TYPE ATTRIB IS DEFAULT VALUE   X
               LDEFALT,                 LENGTH ATTRIB IS DEFAULT VALUE X
               SDEFALT,                 SCALE ATTRIB IS DEFAULT VALUE  X
               UDEFALT                  UNDEFINED SYMBOL ATTRIB REFED
*
* THIS DSECT MAPS THE GLOBAL DIRECTORY ENTRY.
*
GDNTRY   DSECT
GDCP     DS    XL3                      CHAIN POINTER     3 BYTES
GDFL     DSW   GTYP1,GTYP2,GPTYP,GSNS,GSLS,GDIM,GSTP1,GSTP2
GDSL     DS    X                        SYMBOL LENGTH     1 BYTE
GDSYM    EQU   *                        VARIABLE SYMBOL 2-8 BYTES
         ORG   GDNTRY                   ORIGIN ZERO
GDTFV    DS    X                        TEXT FLAG VALUE   1 BYTE
GDDP     DS    XL3                      G.T. DICT. PTR    3 BYTES
GDDM     DS    XL2                      DIMENSION         2 BYTES
*
* THIS DSECT MAPS THE ORDINARY SYMBOL REFERENCE TABLE ENTRY.
*
OSRTNTRY DSECT
OSRTCP   DS    XL3                      CHAIN POINTER     3 BYTES
OSRTDP   DS    XL3                      DICTIONARY PTR    3 BYTES
OSRTSL   DS    XL1                      SYMBOL LENGTH     1 BYTE
OSRTOS   EQU   *                        ORDINARY SYMBOL 1-8 BYTES
*
* THIS DSECT MAPS THE LOGICAL RECORD READ FROM THE ORDINARY SYMBOL
*            DEFINITION FILE.
*
         COPY  JTEXT
         COPY JERRCD
         COPY  JERMSGCD
         EJECT
SAVMDDPT EQU   JDPASS                   SAVE AREA, MDD ADDRESS
SAVMDDLN EQU   JDPASS+D8                SAVE AREA, MDD LENGTH
SAVMDDCN EQU   JDPASS+D12               SAVE AREA, MDD ENTRY CHAIN
SAVMDDCT EQU   JDPASS+D16               SAVE AREA, MDD ENTRY COUNT
SAVOPSCN EQU   JDPASS+D20               SAVE AREA, OPSYN ENTRY CHAIN
LNGTHREG EQU   R12                      SYMBOL LENGTH REGISTER
WORK2    EQU   R15                      SCRATCH REGISTER
WORK3    EQU   R10                      SCRATCH REGISTER
MDDPTR   EQU   R3                       PTR TO MDD ENTRY BEING PROCD
SKDCTPTR EQU   R4                       PTR TO START OF SKELETON DICT
BRTBLPTR EQU   R5                       PTR TO BRANCH TABLE IN USE
SSDTBASE EQU   R6                       PTR TO START OF SEQ SYM DEF TBL
GDBASE   EQU   R6                       PTR TO START OF GBL DEF DIRECT
SSDTPTR  EQU   R7                       PTR TO SEQ SYM DEF TBL ENTRY
RTNLNK   EQU   R9                       RETURN LINKAGE REGISTER
PTR      EQU   R10                      PTR TO START OF SYMBOL FOR HASH
RCDPTR   EQU   R11                      PTR REGISTER, INPUT RCD BASE
WORK1    EQU   R14                      SCRATCH REGISTER
PAIRE    EQU   R0                       EVEN REGISTER OF PAIR
PAIRO    EQU   R1                       ODD REGISTER OF PAIR
EO1      EQU   R0                       EVEN REGISTER OF PAIR
EO2      EQU   R1                       ODD REGISTER OF PAIR
HASHSS   EQU   R1                       HASH VALUE FOR SEQ SYMBOL
HASHGS   EQU   R1                       HASH VALUE FOR GBL VARIABLE
D36      EQU   36                       LENGTH OF INTERLUDE ERROR RCD
D44      EQU   44                       DISPLACEMENT
D48      EQU   48                       DISPLACEMENT
SAVMDVNP EQU   JDPASS                   SAVE AREA, MDV ADDRESS
SAVMDVLN EQU   JDPASS+D8                SAVE AREA, MDV LENGTH
SAVGDLNT EQU   JDPASS+D12               SAVE AREA, GLOBAL DICT ALLOC
SAVOSDNP EQU   JDPASS+D16               SAVE AREA, OSRD ADDRESS
SAVOSDLN EQU   JDPASS+D24               SAVE AREA, OSRD LENGTH
SAVOVFPT EQU   JDPASS+D28               SAVE AREA, END OF FILE 1 ADDR
SAVOPTNP EQU   JDPASS+D36               SAVE AREA, OPSYN TABLE ADDRESS
SAVOPTLN EQU   JDPASS+D44               SAVE AREA, OPSYN TABLE LENGTH
SAVERRNP EQU   JDPASS+D48               SAVE AREA, ERROR BLOCK ADDRESS
GDEL     EQU   19                       MAX LENGTH,GBL DIRECT ENTRY
OSRTBASE EQU   R6                       PTR TO START OF ORD SYMB REF TB
HASHOS   EQU   R1                       HASH VALUE FOR ORD SYMBOL
OSRDPTR  EQU   R4                       PTR TO ORD SYM REF TBL ENTRY
REFCNT   EQU   R5                       COUNT OR ORD SYM REF TBL ENTRYS
ENDPTR   EQU   R0                       PTR TO END OF OPERAND
PARENCT  EQU   R0                       PARENTHESIS LEVEL COUNT
INPTR    EQU   R7                       PTR TO OPERAND BEING SCANNED
RX       EQU   R1                       SCRATCH REGISTER
RY       EQU   R5                       SCRATCH REGISTER
WORK5    EQU   R12                      SCRATCH REGISTER
RZ       EQU   R12                      SCRATCH REGISTER
ATYPE    EQU   JA                       TYPE ATTRIBUTE, A-CON
BTYPE    EQU   JB                       TYPE ATTRIBUTE, B-CON
CTYPE    EQU   JC                       TYPE ATTRIBUTE, C-CON
DTYPE    EQU   JD                       TYPE ATTRIBUTE, D-CON
WORK4    EQU   R1                       SCRATCH REGISTER
ETYPE    EQU   JE                       TYPE ATTRIBUTE, E-CON
FTYPE    EQU   JF                       TYPE ATTRIBUTE, F-CON
GTYPE    EQU   JG                       TYPE ATTRIBUTE, G-CON
HTYPE    EQU   JH                       TYPE ATTRIBUTE, H-CON
KTYPE    EQU   JK                       TYPE ATTRIBUTE, K-CON
LTYPE    EQU   JL                       TYPE ATTRIBUTE, L-CON
PTYPE    EQU   JP                       TYPE ATTRIBUTE, P-CON
QTYPE    EQU   JQ                       TYPE ATTRIBUTE, Q-CON
RTYPE    EQU   JR                       TYPE ATTRIBUTE, R-CON
STYPE    EQU   JS                       TYPE ATTRIBUTE, S-CON
VTYPE    EQU   JV                       TYPE ATTRIBUTE, V-CON
XTYPE    EQU   JX                       TYPE ATTRIBUTE, X-CON
YTYPE    EQU   JY                       TYPE ATTRIBUTE, Y-CON
ZTYPE    EQU   JZ                       TYPE ATTRIBUTE, Z-CON
OPSTLNT  EQU   OPSTND-OPSTBL            OPSYN ENTRY LENGTH
MINRECSZ EQU   18                       MINIMUM I/O LENGTH
VALUE    EQU   R0                       SDT VALUE REGISTER
TYPE     EQU   R15                      SDT TYPE REGISTER
COUNT    EQU   R14                      SDT CHARACTER COUNT REGISTER
D384     EQU   384                      LENGTH OF GBL DIRECT HASH TABLE
D256     EQU   256                      MOVE LIMIT
D192     EQU   192                      LENGTH OF SSDT HASH TABLE
D255     EQU   255                      MOVE LIMIT LESS ONE
         EJECT
         JCSECT (X2A00)
* VS1 RELEASE 3 CHANGES
*C886000,890500,912500,927500,935500                            OX00408
*C593000                                                       @AX14177
*A599100-599160                                                @AX14177
*C214500                                                       @AZ26254
*A779100-779170                                                @AY19671
         JMODID
*INTERLUDE INITIALIZATION ROUTINE - THIS ROUTINE PERFORMS ALL THE     *
*   ONE-TIME INITIALIZATION FUNCTIONS FOR THE PHASE. ITS FUNCTION     *
*   IS-  (1) TO GET AND ALLOCATE THE SPACE REQUIRED FOR THE VARIOUS   *
*            COMMON, TABLE, AND WORK AREAS USED BY THE PHASE          *
*        (2) TO INITIALIZE COMMON FOR THE PHASE                       *
*        (3) TO FETCH THE MACRO DEFINITION DIRECTORY                  *
*        (4) TO INITIALIZE THE PERMANENT DICTIONARIES WITHIN THE      *
*            WORK AREA.                                               *
*                                                                     *
INTRENTR JSAVE BASE=YES
         JENTRY (X2A01=INTRENTR)
         L     R11,=F'1310720'          SET MAX SPACE TO 10M   @AZ26254
         JGETCORE MINDBL=1625,MAXDBL=(R11) GET FREE SPACE
         AR    R11,R10                  DEVELOP END-OF-SPACE PTR
         LA    WORK1,(((ENDCOM-INTRCOM+D7)/D8)*D8) COMPUTE COMMON LEN
         SR    R11,WORK1                DEVELOP COMMON ADDRESS
         LR    R2,R11                   SET UP AS COMMON PTR
         USING INTRCOM,R2
         XC    INTRCOM(ENDCOM-INTRCOM),INTRCOM INITIALIZE ALL COMMON
         ST    R11,COMSTRT              SAVE IN COMMON ITSELF
         S     R11,=F'190'              ALLOW FOR ERROR RECORD BUFFER
         ST    R11,ERRBLK               SAVE PTR TO STRT OF BUFFER
         XC    D0(L'JNOTEVAL,R11),D0(R11) SET FIRST CHAIN LINK TO 0
         LA    WORK1,D8(,R11)           DEVELOP PTR WITHIN ERROR BUFF
         ST    WORK1,ERBLKPTR           AND SAVE FOR ERLOGER
         ST    R11,MDDND                MAKE IT END-OF-MDD ADDR ALSO
         ST    R10,FREESTRT             SAVE START-OF-SPACE PTR
         ST    R10,GDSTRT               MAKE IT GBL DIRECTORY BASE
         MVI   D0(R10),BITFF-BITFF      INSERT ZERO IN HASH TABLE
         MVC   D1(D256,R10),D0(R10)     PROPAGATE FIRST 256 BYTES
         LA    R10,D256(,R10)           BUMP THE POINTER AND
         MVC   D1(D384-D256,R10),D0(R10) PROPAGATE THRU REST OF TABLE
         LA    R10,D384-D256(,R10)      BUMP THE POINTER PAST HASH TBL
         ST    R10,GDEND                SAVE PTR TO GBL ENTRY SPACE
         MVC   PIOPARMB,SAVMDDLN        PICK UP MDD LENGTH FROM COMMON
         S     R11,PIOPARMB             DEVELOP MDD ADDRESS
         ST    R11,MDDSTRT              SAVE MDD PTR IN COMMON
         ST    R11,PIOPARMA             SET IT UP ALSO FOR MDD READ
         MVC   JFWORD1,SAVMDDCT         PICK UP MDD ENTRY COUNT
         L     EO2,JFWORD1              GET IT FOR MDV LENGTH CALC
         MH    EO2,=Y(MDVEND-MDVNTRY)   MULTIPLY BY MDV ENTRY LENGTH
         ST    EO2,MDVLNTH              SAVE LENGTH OF MDV FOR WRITE
         SR    R11,EO2                  DEVELOP MDV ADDRESS
         ST    R11,MDVSTRT              SAVE MDV PTR IN COMMON
         BCTR  R11,D0                   GET END-OF-FREE-SPACE PTR
         ST    R11,FREEEND              AND SAVE IT IN COMMON
         JPOINT FILE=FILE3,ADDR=SAVMDDPT,NEXT=READ POINT TO MDD
         LH    R5,JMAXRL3               SET UP MAXIMUM RECORD THIS FILE
         LA    R6,FILE3                 SET UP FILE POINTER
         BAL   R7,BUFREAD               GO GET MDD FROM FILE 3
         JPOINT FILE=FILE3,NEXT=START        REWIND THE FILE
         MVC   HIBYTE0,SAVMDDCN         PICK UP CHAIN PTR FOR FIRST
         MVC   OPSCHAIN,SAVOPSCN        PRESERVE OPSYN PTR FOR LATER
         MVC   ERRHDR+D1(D5),=AL1(D36,JEPSOP,JNOCNT,JEOPCOD)           X
               SET UP STANDARD STUFF IN ERROR HEADER
         EJECT
*DRIVER FOR CONCURRENT RESOLUTION - THIS ROUTINE ATTEMPTS TO BUILD    *
*   THE SKELETON DICTIONARY FOR A TEXT SEGMENT IN THE MINIMUM         *
*   NUMBER OF PASSES (2) OVER THE TEXT SEGMENT DICTIONARY FILE        *
*   FOR THAT TEXT SEGMENT. THIS MEANS THAT, WHILE BUILDING            *
*   SKELETON DICTIONARIES, THE ENTIRE SKELETON DICTIONARY FOR         *
*   THE TEXT SEGMENT IS IN CORE, ALL UNIQUE GLOBAL DEFINITIONS        *
*   FROM ALL TEXT SEGMENTS UP TO THAT POINT ARE IN THE GLOBAL         *
*   DIRECTORY IN CORE, ALL ORDINARY SYMBOL REFERENCES                 *
*   FROM ALL TEXT SEGMENTS UP TO THAT POINT ARE IN THE ORDINARY       *
*   SYMBOL REFERENCE TABLE IN CORE, AND ALL THE SEQUENCE SYMBOL       *
*   DEFINITIONS FOR THE TEXT SEGMENT ARE IN THE SEQUENCE SYMBOL       *
*   DEFINITION TABLE IN CORE.                                         *
*                                                                     *
INITTSD  L     MDDPTR,MDDND             PICK UP TABLE BASE
         S     MDDPTR,HIBYTE0           DISPLACE TO NEXT ENTRY IN CHAIN
         C     MDDPTR,MDDND             SEE IF END OF CHAIN REACHED
         BE    INITOSR                  BRANCH IF YES
         USING MDDNTRY,MDDPTR
         GOIF  FLUSH,ON=ENDSEGBX        BRANCH IF BYPASS FLAG ON
         GOIF  TSEDIT,OFF=OERR          OVERLAP IN X1A-DUMMY UP MDV REC
         MVC   HIBYTE0+(L'HIBYTE0-L'MSEQSZ)(L'MSEQSZ),MSEQSZ           X
               PICK UP LENGTH OF SEQUENCE SYMBOL REFERENCE DIRECTORY
         L     WORK1,HIBYTE0            ACCUM FOR SKEL DICT SIZE
         MVC   HIBYTE0+(L'HIBYTE0-L'MGBLSZ)(L'MGBLSZ),MGBLSZ           X
               PICK UP LENGTH OF GLOBAL VECTOR
         A     WORK1,HIBYTE0            ADD TO SEQ SYMB REF DIR SIZE
         LA    WORK1,SKHDREND-SKDCTHDR(,WORK1) ADD IN HEADER LENGTH
         ST    WORK1,LNGSK              PRESERVE SKELETON LENGTH
         L     WORK2,FREEEND            GET PTR TO HI END OF WORKAREA
         SR    WORK2,WORK1              ALLOW FOR SKELETON DICT
         C     WORK2,GDEND              CHECK FOR OVERLAP
         BL    OERR                     GO FLAG THE CONDITION
         ST    WORK2,SKDCSTRT           SAVE SKEL DICT START ADDR
         LR    SKDCTPTR,WORK2           GET PTR TO SKEL DICT HEADER
         USING SKDCTHDR,SKDCTPTR
         BCTR  WORK2,D0                 BUMP PAST SKEL DICTIONARY
         ST    WORK2,SSDTSTRT           SET UP PTR TO SEQ SYMB DEF TBL
         SH    WORK2,=H'192'            ALLOW FOR HASH TABLE
         CL    WORK2,GDEND              CHECK FOR OVERLAP
         BL    OERR                     GO FLAG THE CONDITION
         ST    WORK2,SSDTEND            SAVE AS END OF SSDT PTR
         MVI   D1(WORK2),BITFF-BITFF    INSERT ZERO FOR PROPAGATION
         MVC   D2(D192-D1,WORK2),D1(WORK2) CLEAR HSH TBL BY PROPAGATION
         XC    SKDCTHDR(SKHDREND-SKDCTHDR),SKDCTHDR CLEAR IT FIRST
         MVC   SKSRDPT(L'MGBLSZ+L'MSEQSZ+L'MLCLSZ),MGBLSZ              X
               FILL IN GBL, SEQ, AND LCL DICT SIZES
         LA    WORK2,SKHDREND-SKDCTHDR(,SKDCTPTR) GET PTR TO GBL VECTR
         ST    WORK2,GBLSK              SAVE IT FOR LATER USE
         A     WORK2,HIBYTE0            DEVELOP PTR TO SEQ SYMB VECTOR
         ST    WORK2,SEQSK              SAVE IT FOR LATER USE
         LA    BRTBLPTR,BRTBLA          SET UP TO USE BRANCH TABLE A
RESCAN   JPOINT FILE=FILE2,ADDR=MTSDNP,NEXT=GET  POINT TO START OF
GETNXT   JGETL FILE=FILE2               TXT SEG DICT FILE AND READ
         ST    R11,RECADDR              PRESERVE RECORD PTR ONCE
         SR    WORK1,WORK1              CLEAR A REGISTER
         IC    WORK1,D2(,R11)           GET RECORD TYPE
         L     WORK1,D0(WORK1,BRTBLPTR) BRANCH ON IT VIA
         BR    WORK1                    BRANCH TABLE
*
*BRANCH TABLE A - USED IN THE FIRST PASS OVER THE TEXT SEGMENT
*                 DICTIONARY FILE FOR A TEXT SEGMENT
*
BRTBLA   DC    A(GBLDEF)                RECORD TYPE 00
         DC    A(SEQDEF)                RECORD TYPE 04
         DC    A(GETNXT)                RECORD TYPE 08
         DC    A(ORDREF)                RECORD TYPE 0C
         DC    A(ENDSEGA)               RECORD TYPE 10
*
*BRANCH TABLE B - USED IN THE SECOND PASS OVER THE TEXT SEGMENT
*                 DICTIONARY FILE FOR A TEXT SEGMENT
*
BRTBLB   DC    A(GETNXT)                RECORD TYPE 00
         DC    A(GETNXT)                RECORD TYPE 04
         DC    A(SEQREF)                RECORD TYPE 08
         DC    A(GETNXT)                RECORD TYPE 0C
         DC    A(ENDSEGB)               RECORD TYPE 10
         EJECT
*GBLDEF - THIS ROUTINE PROCESSES GLOBAL DEFINITIONS DURING THE        *
*   FIRST PASS OVER THE TEXT SEGMENT DICTIONARY FILE FOR A TEXT       *
*   SEGMENT. ITS FUNCTION IS TO MAKE AN ENTRY FOR THE GLOBAL          *
*   VARIABLE IN THE GLOBAL DIRECTORY, IF IT HAS NOT ALREADY BEEN      *
*   ENTERED, TO INCREASE THE GENERATION TIME GLOBAL DICTIONARY        *
*   ALLOCATION AS NECESSARY, AND TO BUILD THE GLOBAL VECTOR IN        *
*   THE SKELETON DICTIONARY FOR EACH TEXT SEGMENT.                    *
*                                                                     *
GBLDEF   EQU   *
         USING GBLDEFN,RCDPTR
         LA    PTR,GDEFSL               GET PTR TO LEN, NAME FOR SUBR
         BAL   RTNLNK,GSHASHER          GO LOOK FOR GBL VARB IN DIRECT
         GOIF  FNDFLG,ON=SYNCHEK        BRANCH IF SYNONYM FOUND
         L     WORK1,GDEND              GET PTR TO NEW ENTRY
         USING GDNTRY,WORK1
         LA    WORK2,GDEL(,WORK1)       ASSUME LONGEST GBL DIR ENTRY
         C     WORK2,SSDTEND            CHECK FOR OVERLAP
         BNL   OERR                     IF OVERLAP, BRANCH
         MVC   GDFL(L'GDEFF+L'GDEFSL),GDEFF PUT FLAGS AND LENGTH IN
         MVI   GDSYM,JAMPER             SUPPLY AMPERSAND LITERALLY
         SR    WORK2,WORK2              CLEAR WORK REGISTER
         IC    WORK2,GDEFSL             GET LENGTH OF GBL VARB SYMBOL
         LA    WORK3,L'GDEFTF+L'GDEFVP+L'GDEFD(,WORK2)                 X
                   GET MOVE LENGTH FOR GLOBAL DEFINITION
         EX    WORK3,GNTRYMV            MOVE GBL DEFN INTO GBL DIRECT
         LA    WORK3,D7(WORK1,WORK3)    ALLOW FOR ADDED ENTRY IN DIRCT
         ST    WORK3,GDEND              PUT PTR BACK UPDATED
         A     HASHGS,GDSTRT            GET PTR TO HASH TBL ENTRY
         MVC   GDCP,D0(HASHGS)          PUT CHAIN LINK IN NEW ENTRY
         LR    WORK3,WORK1              SET UP NEW ENTRY ADDR
         S     WORK3,GDSTRT             GET DISPL FOR HSH TBL ENTRY
         ST    WORK3,JFWORD1            SAVE TEMPORARILY AND PUT IN
         MVC   D0(L'GDCP,HASHGS),JFWORD1+(L'JFWORD1-L'GDCP) HASH TABLE
         LA    WORK1,L'GDCP+L'GDFL+L'GDSL+D2(WORK2,WORK1) BUMP POINTER
         MVC   GDDP,GDALLOC+(L'GDALLOC-L'GDDP) INSERT GT PTR IN ENTRY
         SR    PAIRO,PAIRO              INITIALIZE FOR ALLOCATION
         LA    PAIRO,D1(,PAIRO)         ALLOC 1 BYTE FOR B TYPE
         TM    GDEFF,GSTP1+GSTP2        CHECK IF B-TYPE VARIABLE
         BM    DIMENCK                  BRANCH IF B-TYPE
         LA    PAIRO,D3(,PAIRO)         ALLOC 4 BYTES FOR A TYPE
         BZ    DIMENCK                  BRANCH IF A-TYPE
         LA    PAIRO,D5(,PAIRO)         ALLOC 9 BYTES FOR C TYPE
DIMENCK  TM    GDEFF,GDIM               CHECK IF VARIABLE DIMENSIONED
         BZ    ALLOC                    BRANCH IF NOT
         MVC   JHWORD1,GDDM             PICK UP VARIABLE DIMENSION
         MH    PAIRO,JHWORD1           MULTIPLY BY SINGLE ELEMENT SIZE
         TM    GDEFF,GSTP1+GSTP2        CHECK IF B-TYPE VARIABLE
         BNM   ALLOC                    BRANCH IF NOT
         LA    PAIRO,D7(,PAIRO)         ROUND VALUE TO NEXT BYTE
         SR    PAIRE,PAIRE              CLEAR EVEN REG FOR DIVIDE
         D     PAIRE,=F'8'              GET NUMBER OF BYTES FO B TYPE
ALLOC    A     PAIRO,GDALLOC            ADD ALLOCATION FOR NEW ENTRY
         ST    PAIRO,GDALLOC              TO CURRENT GT GBL DICT ALLOC
         LR    GDBASE,WORK1             PREPARE FOR BASE CHANGE
         LA    RCDPTR,L'GDEFRL+L'GDEFRT+L'GDEFF+L'GDEFSL+D1(LNGTHREG,RCX
               DPTR) BUMP PTR TO GBL DEFN RCD PAST VARB SYMB
         B     ENTRSKEL                 GO TO FILL GBL VCTR SLOT
GNTRYMV  MVC   GDSYM+D1(D0),GDEFVS      EXECUTED GBL DEFN MOVE
         DROP  WORK1
         USING GDNTRY,GDBASE
SYNCHEK  CLC   GDEFF,GDFL               COMPARE THE FLAG BYTES
         BNE   IERR1                    IF UNALIKE, AN ERROR
         SR    WORK3,WORK3              CLEAR WORK REGISTER
         IC    WORK3,GDSL               PICK UP SYMBOL LENGTH
         LA    GDBASE,L'GDCP+L'GDFL+L'GDSL+D2(WORK3,GDBASE)            X
               BUMP GBL DIR ENTRY PTR PAST VARB SYMBOL
         LA    WORK2,GDEFSL             GET PTR TO VARB SYM, IN CASE
         LA    RCDPTR,L'GDEFRL+L'GDEFRT+L'GDEFF+L'GDEFSL+D1(LNGTHREG,RCX
               DPTR) BUMP PTR TO GBL DEFN RCD PAST VARB SYMB
         CLC   GDEFD,GDDM               COMPARE DIMENSIONING
         BNE   IERR2                    IF UNALIKE, AN ERROR
ENTRSKEL L     SKDCTPTR,GBLSK           GET PTR TO GLOBAL VECTOR
         MVC   HIBYTE0+(L'HIBYTE0-L'GDEFVP)(L'GDEFVP),GDEFVP           X
               GET DISPL TO GBL VECTR SLOT FROM GBL DEFN RECORD
         A     SKDCTPTR,HIBYTE0         DEVELOP PTR TO GBL VCTR SLOT
         MVC   D0(L'GDDP,SKDCTPTR),GDDP INSERT POINTER TO GBL DICT
         B     GETNXT                   RETURN
IERR     EQU   *
IERR1    EQU   *
         LA    WORK2,GDEFSL             GET PTR TO VARB SYMB
         LA    RCDPTR,L'GDEFRL+L'GDEFRT+L'GDEFF+L'GDEFSL+D1(LNGTHREG,RCX
               DPTR) BUMP PTR TO GBL DEFN RCD PAST VARB SYMB
         MVC   VECTSAVE+D1(L'GDEFVP),GDEFVP                            X
               PRESERVE VECTOR POINTER ACROSS ERROR PROCESS
         BAL   RTNLNK,ERLOGER           CALL ERROR LOGGING RTN
         DC    AL1(SEV67,ERR67)         ERROR PARAMETERS
IERR1A   LA    GDBASE,=X'00FFFFFE'       SET UP DEFAULT FLAGS
         LA    RCDPTR,VECTSAVE          DUMMY UP PTR TO VECTOR POINTER
         B     ENTRSKEL                 GO BUILD VECOTR ENTRY W/DEFAULT
IERR2    EQU   *
         MVC   VECTSAVE+D1(L'GDEFVP),GDEFVP                            X
               PRESERVE VECTOR POINTER ACROSS ERROR PROCESS
         BAL   RTNLNK,ERLOGER           CALL ERROR LOGGING RTN
         DC    AL1(SEV81,ERR81)         ERROR PARAMETERS
         B     IERR1A                   GO TO DEFAULT PROCESS
         DROP  GDBASE
         DROP  RCDPTR
         EJECT
*SEQDEF - THIS ROUTINE PROCESSES SEQUENCE SYMBOL DEFINITIONS          *
*   DURING THE FIRST PASS OVER THE TEXT SEGMENT DICTIONARY FILE       *
*   FOR A TEXT SEGMENT. ITS FUNCTION IS TO MAKE AN ENTRY FOR THE      *
*   SEQUENCE SYMBOL DEFINITION IN THE SEQUENCE SYMBOL DEFINITION      *
*   TABLE.                                                            *
*                                                                     *
SEQDEF   EQU   *
         USING SSDEF,RCDPTR
         LA    PTR,SDEFSL               GET PTR TO LEN, NAME FOR SUBR
         BAL   RTNLNK,SSHASHER          GO SEE IF SEQ SYMB ALREADY IN
         GOIF  FNDFLG,ON=DUPERR         IF YES, DUPLICATE DEFINITION
         L     WORK1,SSDTEND            GET PTR TO SPACE FOR ENTRY
         LA    WORK2,L'SSDTCP+L'SSDTNP+L'SSDTSL(,LNGTHREG) GET LENGTH
         SR    WORK1,WORK2              BUMP PTR FOR NRXT ENTRY
         C     WORK1,GDEND              CHECK FOR TABLE OVERLAP
         BNH   OERR                     BRANCH IF IT OCCURS
         ST    WORK1,SSDTEND            UPDATE POINTER
         LA    WORK1,D1(,WORK1)         SET UP PTR TO THIS ENTRY
         USING SSDTNTRY,WORK1
         SR    WORK2,WORK2              CLEAR REGISTER
         IC    WORK2,SDEFSL             GET SEQUENCE SYMBOL LENGTH
         LA    WORK2,L'SDEFNP+D1(,WORK2) GET ENTRY LENGTH - CHAIN PTR
         EX    WORK2,SSDTMOVE           PUT N/P, LEN, SYMBOL IN ENTRY
         LR    SSDTPTR,SSDTBASE         PICK UP HASH TABLE PTR
         SH    SSDTPTR,=H'2'            ADJUST IT
         SR    SSDTPTR,HASHSS           GET PTR TO PROPER HSH TBL SLOT
         MVC   SSDTCP,D0(SSDTPTR)       PUT CHAIN PTR IN ENTRY
         SR    SSDTBASE,WORK1           GET DISPL TO NEW ENTRY
         ST    SSDTBASE,JFWORD1         PUT IT IN PROPER HASH TABLE
         MVC   D0(L'SSDTCP,SSDTPTR),JFWORD1+(L'JFWORD1-L'SSDTCP) SLOT
         B     GETNXT                   RETURN FOR NEXT RECORD
DUPERR   EQU   *
         LA    R0,JPERIOD               INSERT PERIOD FOR SEQ SYNB
         LA    WORK2,SDEFSL             GET PTR TO SEQ SYMB
         BAL   RTNLNK,ERLOGERZ          CALL ERROR LOGGING RTN
         DC    AL1(SEV74,ERR74)         ERROR PARAMETERS
         B     GETNXT                   RETURN
SSDTMOVE MVC   SSDTNP(D0),SDEFNP        EXECUTED SSDT ENTRY MOVE
         DROP  RCDPTR
         DROP  WORK1
         EJECT
*SEQREF - THIS ROUTINE PROCESSES SEQUENCE SYMBOL REFERENCES           *
*   DURING THE SECOND PASS OVER THE TEXT SEGMENT DICTIONARY FILE      *
*   FOR A TEXT SEGMENT. ITS FUNCTION IS TO BUILD THE SEQUENCE         *
*   SYMBOL REFERENCE DICTIONARY IN THE SKELETON DICTIONARY FOR        *
*   EACH TEXT SEGMENT USING THE SEQUENCE SYMBOL DEFINITIONS IN        *
*   THE SEQUENCE SYMBOL DEFINITION TABLE.                             *
*                                                                     *
SEQREF   EQU   *
         USING SSREF,RCDPTR
         LA    PTR,SREFSL               GET PTR TO LEN, NAME FOR SUBR
         BAL   RTNLNK,SSHASHER          GO SEE IF SEQ SYM ALREADY IN
         GOIF  FNDFLG,OFF=UNDERR        IF NO, UNDEFINED SEQ SYMB
SEQREFA  EQU   *
         USING SSDTNTRY,SSDTPTR
         L     SKDCTPTR,SEQSK           GET PTR TO SEQ SYMB VECTOR
         MVC   HIBYTE0+(L'HIBYTE0-L'SREFDP)(L'SREFDP),SREFDP           X
               GET DISPL TO SSRD SLOT FROM SEQ SYMB REF RECORD
         A     SKDCTPTR,HIBYTE0         DEVELOP PTR TO SSRD SLOT
         MVC   D0(L'SSDTNP,SKDCTPTR),SSDTNP  INSERT N/P ADDR IN SLOT
         B     GETNXT                   RETURN FOR NEXT RECORD
UNDERR   EQU   *
         LA    R0,JPERIOD               INSERT PERIOD FOR SEQ SYMB
         LA    WORK2,SREFSL             GET PTR TO SEQ SYMB
         BAL   RTNLNK,ERLOGERZ          CALL ERROR LOGGING RTN
         DC    AL1(SEV76,ERR76)         ERROR PARAMETERS
         L     R11,RECADDR              RESTORE RECORD PTR
         LA    SSDTPTR,=XL11'00'        GIVE DUMMY TO CLEAR SSRD ENTRY
         B     SEQREFA                  GO BACK TO PROCESS AS NORMAL
         DROP  SSDTPTR
         DROP  RCDPTR
         EJECT
*ORDREF - THIS ROUTINE PROCESSES ORDINARY SYMBOL REFERENCES           *
*   DURING THE FIRST PASS OVER THE TEXT SEGMENT DICTIONARY FILE       *
*   FOR A TEXT SEGMENT. ITS FUNCTION IS TO MAKE AN ENTRY FOR THE      *
*   ORDINARY SYMBOL REFERENCE IN THE ORDINARY SYMBOL REFERENCE        *
*   TABLE.                                                            *
*                                                                     *
ORDREF   EQU   *
         USING OSREF,RCDPTR
         LH    WORK1,OREFRL             PICK UP LENGTH OF OS REF
         BCTR  WORK1,D0                 MAKE IT MOVE LENGTH FOR MOVE
         L     WORK3,OSRTEND            GET PTR TO NEXT SLOT IN OSRT
         LA    WORK2,D1(WORK1,WORK3)    DEVELOP PTR PAST POTENTIAL NTRY
         C     WORK2,SSDTEND            CHECK FOR TABLE OVERLAP
         BNL   OERR                     BRANCH IF IT OCCURS
         USING OSRTNTRY,WORK3
         EX    WORK1,OSREFMV            MOVE OS REF RCD INTO OSRT
         ST    WORK2,OSRTEND            SAVE NEXT SLOT POINTER
         L     WORK1,OREFCNT            GET CURRENT OS REF COUNT
         LA    WORK1,D1(,WORK1)         ADD 1
         ST    WORK1,OREFCNT            SAVE NEW COUNT
         XC    JDWORD,JDWORD            CLEAR WORK AREA FOR ORD SYMB
         SR    LNGTHREG,LNGTHREG        CLEAR REGISTER FOR ORD SYM LEN
         IC    LNGTHREG,OREFSL          GET LENGTH OF ORDINARY SYMBOL
         EX    LNGTHREG,OSMOVE          MOVE SYMBOL INTO WORK AREA
         LA    WORK1,OSPRIME            GET PTR TO HASH PARAMETERS
         BAL   WORK2,HASH               LINK TO HASHING RTN
         A     HASHOS,OSRTSTRT          DEVELOP HASH TABLE POINTER
         MVC   OSRTCP,D0(HASHOS)        MOVE CHAIN PTR TO NEW ENTRY
         S     WORK3,OSRTSTRT           DEVELOP CHAIN PTR FOR HSH TBL
         ST    WORK3,JFWORD1            STOE TEMPORARILY AND
         MVC   D0(L'OSRTCP,HASHOS),JFWORD1+(L'JFWORD1-L'OSRTCP)        X
               INSERT INTO HASH TABLE SLOT
         B     GETNXT                   RETURN
OSMOVE   MVC   JDWORD(D0),OREFOS        EXECUTED ORD SYMB MOVE
OSREFMV  MVC   OSRTCP(D0),OREFRL        EXECUTED OS REF RCD MOVE
         DROP  RCDPTR
         DROP  WORK3
         EJECT
*ENDSEGA - THIS ROUTINE HANDLES THE END-OF-SEGMENT CONDITION          *
*   THAT INDICATES THE END OF THE FIRST PASS OVER THE TEXT            *
*   SEGMENT DICTIONARY FILE FOR A TEXT SEGMENT. ITS FUNCTION          *
*   IS TO SET UP THE BRANCH TABLE FOR THE SECOND PASS AND TO          *
*   INITIATE THE SECOND PASS.                                         *
*                                                                     *
ENDSEGA  EQU   *
         LA    BRTBLPTR,BRTBLB          SET UP PTR TO BRANCH TABLE B
         B     RESCAN                   GO START SECOND PASS
         EJECT
*ENDSEGB - THIS ROUTINE HANDLES THE END-OF-SEGMENT CONDITION          *
*   THAT INDICATES THE END OF THE SECOND PASS OVER THE TEXT           *
*   SEGMENT DICTIONARY FILE FOR A TEXT SEGMENT. ITS FUNCTION          *
*   IS TO OUTPUT THE SKELETON DICTIONARY FOR THE TEXT SEGMENT,        *
*   TO BUILD THE MACRO DEFINITION VECTOR ENTRY FOR THE TEXT           *
*   SEGMENT, AND TO INITIATE THE FIRST PASS OVER THE TEXT SEGMENT     *
*   DICTIONARY FILE FOR THE NEXT TEXT SEGMENT.                        *
*                                                                     *
ENDSEGB  EQU   *
         MVC   PIOPARMA,SKDCSTRT        SET UP PTR TO START OF DICT
         MVC   PIOPARMB,LNGSK           SET UP LNGTH OF DICT           X
               SET UP LENGTH OF SKELETON DICTIONARY FOR WRITE
         STM   R3,R5,SAVE3456           SAVE REGISTERS USED BY SUBRTN
         LH    R5,JMAXRL1               SET UP MAXIMUM RECORD THIS FILE
         LA    R6,FILE1                 SET UP FILE POINTER
         BAL   R7,BUFRITE               GO PUT SKEL DICT TO FILE 1
         LM    R3,R5,SAVE3456           RESTORE NECESSARY REGISTERS
         L     WORK2,MDVSTRT            GET PTR TO START OF MDV
         MVC   HIBYTE0+(L'HIBYTE0-L'MVECTR)(L'MVECTR),MVECTR           X
               GET DISPL INTO MDV FROM MOD ENTRY
         A     WORK2,HIBYTE0            DEVELOP PTR TO MDV SLOT
         USING MDVNTRY,WORK2
         MVC   MNPSD,JNOTEVAL           INSERT SKEL DICT N/P ADDR
         MVC   MNPTXT,MTXTNP            INSERT TEXT START N/P ADDR
         MVC   MSDL,LNGSK+(L'LNGSK-L'MSDL) INSERT SKEL DICT LENGTH
ENDSEGXT MVC   HIBYTE0+(L'HIBYTE0-L'MCHAIN)(L'MCHAIN),MCHAIN           X
               PICK UP PTR TO NEXT ENTRY IN CHAIN
         B     INITTSD                  RETURN TO BUILD NEXT SKEL DICT
ENDSEGBX EQU   *
         L     WORK2,MDVSTRT            GET PTR TO START OF MDV
         MVC   HIBYTE0+(L'HIBYTE0-L'MVECTR)(L'MVECTR),MVECTR           X
               GET DISPL INTO MDV FROM MDD ENTRY
         A     WORK2,HIBYTE0            DEVELOP PTR TO MDV SLOT
         USING MDVNTRY,WORK2
         XC    MNPTXT(MDVEND-MDVNTRY),MNPTXT    SET MDV SLOT ALL ZEROES
         MVC   MSDL+(L'MSDL-D1)(D1),MTSDNP+(L'MTSDNP-D1) SET ERROR FLAG
         B     ENDSEGXT                 GO TO RETURN
OERR     EQU   *
         L     WORK2,MDVSTRT            GET PTR TO START OF MDV
         MVC   HIBYTE0+(L'HIBYTE0-L'MVECTR)(L'MVECTR),MVECTR           X
               GET DISPL INTO MDV FROM MDD ENTRY
         A     WORK2,HIBYTE0            DEVELOP PTR TO MDV SLOT
         USING MDVNTRY,WORK2
         XC    MNPTXT(MDVEND-MDVNTRY),MNPTXT SET MDV ENTRY TO ZEROES
         MVI   MSDL+D2,D20              INSERT ERROR FLAG
         B     ENDSEGXT                 GO TO RETURN
         DROP  WORK2
         EJECT
*
* THIS SUBROUTINE SCANS OFF A DECIMAL SELF-DEFINING TERM AND
*        CONVERTS IT TO BINARY. IT IS CALLED BY THE FOLLOWING
*        ROUTINES- EQUSCAN
*
DECBIN   EQU   *
         SR    RX,RX                    CLEAR ACCUMULATED LENGTH REG
         LR    RY,RX                    CLEAR NEXT DIGIT REGISTER
DB1      CLI   D0(INPTR),J9             LOOK FOR NUMERIC CHARACTER
         BHR   RTNLNK                   EXIT IF NOT FOUND
         IC    RY,D0(INPTR)             PICK UP DIGIT
         MH    RX,=H'10'                MULTIPLY ACCUMULATED LENGTH
         AR    RX,RY                    AND ADD IN NEXT DIGIT
         LA    INPTR,D1(,INPTR)         BUMP COLUMN POINTER TO NEXT
         B     DB1                      GO BACK TO GET MORE DIGITS
*
* THIS SUBROUTINE GETS A NAME FROM THE OPERAND OF AN EXTRN OR
*        WXTRN STATEMENT. IT IS CALLED BY THE FOLLOWING ROUTINES-
*        ESCAN
*
GETXNAM  EQU   *
         GOIF  ENDSW,OFF=GX1            GO ON IF END NOT REACHED
GX0      SET   ENDSW,ON                 INDICATE NO MORE NAMES
         B     D0(,RTNLNK)              RETURN ON NO NAME OR ERROR
GX1      CLI   D0(INPTR),JAT            LOOK FOR ALPHANUMERIC CHAR
         BH    GX5                      BRANCH IF NOT
         CLI   D0(INPTR),JA             LOOK FOR ALPHA ONLY
         BL    GX0                      BRANCH IF NOT
GX1A     EQU   *
         LR    RX,INPTR                 SAVE PTR TO START OF NAME
GX2      LA    INPTR,D1(,INPTR)         BUMP TO NEXT CHARACTER
         CLI   D0(INPTR),JAT            LOOK FOR ALPHANUMERIC CHAR
         BNH   GX2                      BRANCH IF FOUND
GX3      CLI   D0(INPTR),JCOMMA         LOOK FOR COMMA DELIMITER
         BE    GX4                      BRANCH IF FOUND
         CLI   D0(INPTR),JBLANK         LOOK FOR BLANK DELIMITER
         BNE   GX0                      BRANCH IF NOT FOUND
         SET   ENDSW,ON                 INDICATE LAST OPERAND PROCESSED
GX4      LR    WORK3,INPTR              GET PTR TO END OF NAME +1
         SR    WORK3,RX                 GET LENGTH OF NAME
         BCTR  WORK3,D0                 GET MOVE LENGTH OF NAME
         C     WORK3,=F'7'              CHECK FOR VALID LENGTH
         BH    GX0                      BRANCH IF TOO LONG
         LA    INPTR,D1(,INPTR)         BUMP TO NEXT NAME
         B     D4(,RTNLNK)              RETURN WITH GOOD NAME
GX5      CLI   D0(INPTR),JAMPER         TEST FOR POSSIBLE VARIABLE SYM
         BNE   GX0                      BRANCH IF NOT FOUND
         B     GX1A                     ACCEPT IF FOUND
*
* THIS SUBROUTINE SCANS PAST EXPRESSIONS IN THE OPERANDS OF EQU,
*        DC, AND DS STATEMENTS. IT IS CALLED BY THE FOLLOWING
*        ROUTINES- EQUSCAN, DCSCAN
*
OPNDSCAN EQU   *
         SR    PARENCT,PARENCT          INITIALIZE PAREN COUNT TO 0
         SET   QUOTESW,OFF              INITIALIZE QUOTE MODE INDICATOR
OPS1     CLI   D0(INPTR),JBLANK         LOOK FOR BLANK DELIMITER
         BNE   OPS2                     BRANCH IF NOT FOUND
         GOIF  QUOTESW,ON=OPS6          IGNORE IF BLANK INSIDE QUOTES
OPS1A    B     D0(,RTNLNK)              RETURN ON ANY ERROR
OPS2     CLI   D0(INPTR),JCOMMA         LOOK FOR COMMA DELIMITER
         BNE   OPS3                     BRANCH IF NOT FOUND
         GOIF  QUOTESW,ON=OPS6          IGNORE IF COMMA INSIDE QUOTES
         CLI   DELIMIT,JCOMMA           SEE IF LOOKING FOR COMMA
         BNE   OPS1A                    ERROR IF NOT
         LTR   PARENCT,PARENCT          CHECK PAREN COUNT FOR ZERO
         BNZ   OPS1A                    ERROR IF NOT ZERO
OPS2A    LA    INPTR,D1(,INPTR)         BUMP PTR PAST DELIMITER
         B     D4(,RTNLNK)              RETURN ON VALID SYNTAX
OPS3     CLI   D0(INPTR),JLPARN         LOOK FOR LEFT PAREN CHARACTER
         BNE   OPS4                     BRANCH IF NOT FOUND
         GOIF  QUOTESW,ON=OPS6          IGNORE IF PAREN INSIDE QUOTES
         LA    PARENCT,D1(,PARENCT)     INCREMENT PAREN COUNT BY 1
         B     OPS6                     GO ON TO NEXT CHARACTER
OPS4     CLI   D0(INPTR),JQUOTE         LOOK FOR QUOTE CHARACTER
         BNE   OPS5                     BRANCH IF NOT FOUND
         BCTR  INPTR,D0                 BACK UP TO PREVIOUS CHARACTER
         CLI   D0(INPTR),JL             LOOK FOR L ATTRIB NOTATION
         BNE   OPS41                    BRANCH IF NOT FOUND
         GOIF  QUOTESW,ON=OPS42,ELSE=OPS421 IGNORE QUOTE IF L ATTRIB
OPS41    CLI   D0(INPTR),JB             LOOK FOR BINARY SDT
         BE    OPS42                    BRANCH IF FOUND
         CLI   D0(INPTR),JC             LOOK FOR CHARACTER SDT
         BE    OPS42                    BRANCH IF FOUND
         CLI   D0(INPTR),JX             LOOK FOR HEX SDT
         BE    OPS42                    BRANCH IF FOUND
         CLI   D0(INPTR),JQUOTE         LOOK FOR PAIRED QUOTES
         BE    OPS42                    BRANCH IF FOUND
         GOIF  QUOTESW,ON=OPS42,ELSE=OPS1A END ON SPURIOUS QUOTE
OPS42    SET   QUOTESW,FLIP             START OR END QUOTE MODE
OPS421   LA    INPTR,D1(,INPTR)         REPOSITION POINTER
         B     OPS6                     GO ON TO NEXT CHARACTER
OPS5     CLI   D0(INPTR),JRPARN         LOOK FOR RIGHT PAREN DELIMITER
         BNE   OPS6                     BRANCH IF NOT FOUND
         GOIF  QUOTESW,ON=OPS6          IGNORE IF PAREN INSIDE QUOTES
         CLI   DELIMIT,JRPARN           SEE IF LOOKING FOR RIGHT PAREN
         BNE   OPS5A                    GO ON IF NOT
         LTR   PARENCT,PARENCT          CHECK PAREN COUNT FOR ZERO
         BZ    OPS2A                    BRANCH IF ZERO
         B     OPS1A                    ERROR IF NOT
OPS5A    BCTR  PARENCT,D0               DECREMENT PAREN COUNT BY 1
OPS6     LA    INPTR,D1(,INPTR)         BUMP PTR TO NEXT CHARACTER
         CL    INPTR,ENDCOL             CHECK FOR OPERAND EXCEEDED
         BH    OPS1A                    BRANCH IF EXCEEDED
         B     OPS1                     GO HANDLE NEXT CHARACTER
*
* THIS SUBROUTINE PERFORMS A BUFFERED WRITE TO ANY FILE.
*        IT IS CALLED FROM THE FOLLOWING ROUTINES
*                   ENDSEGB
*                   INITOSR
*                   OSRDFINI
*
BUFRITE  EQU   *
         MVI   FSWITCH,J0               CLEAR FIRST WRITE/NOTE SWITCH
         LM    R3,R4,PIOPARMB           PICK UP I/O PARAMETERS
BRT1     CLR   R3,R5                    SEE IF RECORD LESS THAN MAX
         BH    BRT4                     BRANCH IF NOT
         CH    R3,=AL2(MINRECSZ)        SEE IF BLOCK OVER MINIMUM
         BNL   BRT11                    BRANCH IF MORE OR JUST ENUF
         LA    R3,MINRECSZ              IF NOT, USE MINIMUM SIZE
BRT11    STH   R3,PIOPARMC              SET UP RECORD LENGTH
         SR    R3,R3                    INDICATE LAST WRITE
BRT2     JWRITE FILE=(R6),PARM=PIOPARMA WRITE RECORD TO PROPER FILE
         JCHECK FILE=(R6)               CHECK THE WRITE
         TS    FSWITCH                  TEST AND SET FIRST WRITE SW
         BNZ   BRT3                     BRANCH IF NOT FIRST WRITE
         JNOTE FILE=(R6)                NOTE FIRST BLOCK WRITTEN
BRT3     LTR   R3,R3                    SEE IF WRITE COMPLETE
         BZR   R7                       RETURN IF YES
         AR    R4,R5                    DEVELOP PTR TO NEXT I/O AREA
         ST    R4,PIOPARMA              PUT PTR IN I/O CONTROL AREA
         B     BRT1                     GO SET UP NEW WRITE LENGTH
BRT4     STH   R5,PIOPARMC              SET UP MAXIMUM RECORD LENGTH
         SR    R3,R5                    ADJUST WRITE LENGTH
         B     BRT2                     GO WRITE NEXT RECORD
*
* THIS SUBROUTINE PERFORMS A BUFFERED READ FROM ANY FILE.
*        IT IS CALLED FROM THE FOLLOWING ROUTINES
*                   INTRENTR
*
BUFREAD  EQU   *
         LM    R3,R4,PIOPARMB           PICK UP I/O PARAMETERS
BRD1     CLR   R3,R5                    SEE IF RECORD LESS THAN MAX
         BH    BRD4                     BRANCH IF NOT
         CH    R3,=AL2(MINRECSZ)        SEE IF BLOCK OVER MINIMUM
         BNL   BRD11                    BRANCH IF MORE OR JUST ENUF
         LA    R3,MINRECSZ              IF NOT, USE MINIMUM SIZE
BRD11    STH   R3,PIOPARMC              SET UP RECORD LENGTH
         SR    R3,R3                    INDICATE LAST READ
BRD2     JREAD FILE=(R6),PARM=PIOPARMA  READ RECORD FROM PROPER FILE
         JCHECK FILE=(R6)               CHECK THE READ
         LTR   R3,R3                    SEE IF READ COMPLETE
         BZR   R7                       RETURN IF YES
         AR    R4,R5                    DEVELOP PTR TO NEXT I/O AREA
         ST    R4,PIOPARMA              PUT PTR IN I/O CONTROL AREA
         B     BRD1                     GO SET UP NEW READ LENGTH
BRD4     STH   R5,PIOPARMC              SET UP MAXIMUM RECORD LENGTH
         SR    R3,R5                    ADJUST READ LENGTH
         B     BRD2                     GO READ NEXT RECORD
*
* THIS SUBROUTINE SEARCHES THE SEQUENCE SYMBOL DEFINITION TABLE
*        FOR A SPECIFIED SEQUENCE SYMBOL.
*        IT IS CALLED FROM THE FOLLOWING ROUTINES
*                   SEQDEF
*                   SEQREF
*
         USING SSDEF,RCDPTR
SSHASHER XC    JDWORD,JDWORD            CLEAR WORK AREA FOR SEQ SYMB
         SR    LNGTHREG,LNGTHREG        CLEAR REGISTER FOR SEQ SYM LEN
         IC    LNGTHREG,D0(,PTR)        GET LENGTH OF SEQ SYMB
         EX    LNGTHREG,SSDEFMOV        MOVE SYMBOL INTO WORK AREA
         LA    LNGTHREG,D1(,LNGTHREG)   GET SYMBOL TRUE LENGTH
         LA    WORK1,SSPRIME            SET UP PTR TO HASH PARAMETERS
         BAL   WORK2,HASH               LINK TO HASHING RTN
         L     SSDTBASE,SSDTSTRT        SET UP SSDT POINTER CONSTANT
         LR    SSDTPTR,SSDTBASE         SET UP SAME POINTER SCRATCH
         SH    SSDTPTR,=H'2'            ADJUST IT
         SR    SSDTPTR,HASHSS           DEVELOP HASH TABLE POINTER
         USING SSDTNTRY,SSDTPTR
CHNLOOP  CLC   SSDTCP,=FL3'0'           CHECK FOR END OF CHAIN
         BZ    NTFND                    IF FOUND, BRANCH OUT
         MVC   HIBYTE0+(L'HIBYTE0-L'SSDTCP)(L'SSDTCP),SSDTCP           X
               GET CHAIN POINTER FROM ENTRY
         LR    SSDTPTR,SSDTBASE         RESTORE SSDT BASE ADDR
         S     SSDTPTR,HIBYTE0          GET CHAINED ENTRY ADDRESS
         EX    LNGTHREG,SSDEFCMP        COMPARE SEQUENCE SYMBOLS
         BNE   CHNLOOP                  BRANCH IF NOT IDENTICAL
         SET   FNDFLG,ON                INDICATE MATCH FOUND
         BR    RTNLNK                   RETURN
NTFND    SET   FNDFLG,OFF               INDICATE NO MATCH FOUND
         BR    RTNLNK                   RETURN
SSDEFMOV MVC   JDWORD(D0),D1(PTR)       EXECUTED SEQ SYMB MOVE
SSDEFCMP CLC   D0(D0,PTR),SSDTSL        EXECUTED SEQ SYMB COMPARE
         DROP  RCDPTR
         DROP  SSDTPTR
*
* THIS SUBROUTINE SEARCHES THE GLOBAL DIRECTORY FOR A SPECIFIED
*        VARIABLE SYMBOL.
*        IT IS CALLED FROM THE FOLLOWING ROUTINES
*                   GBLDEF
*
         USING GBLDEFN,RCDPTR
GSHASHER XC    JDWORD,JDWORD            CLEAR WORK AREA FOR VARB NAME
         SR    LNGTHREG,LNGTHREG        CLEAR REGISTER FOR VAR SYM LEN
         IC    LNGTHREG,D0(,PTR)        GET LENGTH OF VARIABLE SYMBOL
         EX    LNGTHREG,GSMOVE          MOVE NAME INTO WORK AREA
         LA    WORK1,GSPRIME            SET UP PTR TO HASH PARAMETERS
         BAL   WORK2,HASH               LINK TO HASHING RTN
         L     GDBASE,GDSTRT            GET GBL DIRECTORY BASEADDR
         AR    GDBASE,HASHGS            DEVELOP HASH TABLE POINTER
         USING GDNTRY,GDBASE
CHAINON  CLC   GDCP,=FL3'0'             CHECK FOR END OF CHAIN
         BZ    NTFOUND                  IF FOUND, BRANCH OUT
         MVC   HIBYTE0+(L'HIBYTE0-L'GDCP)(L'GDCP),GDCP                 X
               GET CHAIN POINTER FROM ENTRY
         L     GDBASE,HIBYTE0           PICK UP CHAIN PTR
         A     GDBASE,GDSTRT            ADD BASE ADDR OF TABLE
         SR    WORK2,WORK2              CLEAR LENGTH REGISTER
         IC    WORK2,GDSL               PICK UP ENTRY LENGTH
         CR    WORK2,LNGTHREG           CHECK FOR EQUAL LENGTHS
         BNE   CHAINON                  IF NOT, DONT BOTHER MORE
         EX    LNGTHREG,GSCMP           COMPARE GLOBAL VARIABLES
         BNE   CHAINON                  BRANCH IF NOT IDENTICAL
         SET   FNDFLG,ON                INDICATE MATCH FOUND
         BR    RTNLNK                   RETURN
NTFOUND  SET   FNDFLG,OFF               INDICATE NO MATCH FOUND
         BR    RTNLNK                   RETURN
GSMOVE   MVC   JDWORD(D0),D1(PTR)       EXECUTED VARB SYMB MOVE
GSCMP    CLC   JDWORD(D0),GDSYM+D1      EXECUTED VARB SYMB COMPARE
         DROP  RCDPTR
         DROP  GDBASE
*
* THIS SUBROUTINE CONVERTS A SYMBOL PASSED IN JDWORD TO A HASH
*            TABLE INDEX USING THE PARAMETERS POINTED TO BY WORK1.
*   IT IS CALLED BY THE FOLLOWING ROUTINES -                          *
*              ORDREF,ORDSYMBR,SSHASHER,GSHASHER                      *
*
HASH     EQU   *
         L     PAIRO,JDWORD             PICK UP FIRST HALF OF NAME
         AL    PAIRO,JDWORD+D4          FOLD SECOND HALF OVER FIRST
         SR    PAIRE,PAIRE              SET UP REGISTER PAIR
         D     PAIRE,D0(,WORK1)         DIVIDE BY HASH VALUE
         N     PAIRE,D4(,WORK1)         APPLY MASK FOR HASH TABLE RANGE
         LR    PAIRO,PAIRE              SHIFT VALUE FOR MULTIPLY
         M     PAIRE,=F'3'              DEVELOP TABLE INDEX
         BR    WORK2                    RETURN
*                                                                     *
* THIS SUBROUTINE GENERATES THE ERROR RECORDS ORIGINATING IN THE      *
*              INTERLUDE PHASE. IT IS CALLED FROM THE FOLLOWING       *
*              ROUTINES - GBLDEF, SEQDEF, SEQREF, INITOSR,            *
*              ORDSYMBR, OPSYNBLD                                     *
*                                                                     *
ERLOGER  EQU   *
         LA    R0,JAMPER                INSERT AMPERSAND FOR VARB SYMB
ERLOGERZ SR    WORK1,WORK1              CLEAR LENGTH REGISTER
         IC    WORK1,D0(,WORK2)         PICK UP SYMBOL LENGTH
         STC   R0,D0(,WORK2)            INSERT AMPERSAND OR PERIOD
         LA    WORK1,D1(,WORK1)         IN SYMBOL AND ADJUST FOR IT
         GOIF  OCTS,OFF=MACROMSG        GO TO HANDLE SEPARATE MSGS
         MVC   ERROTHR,=AL1(JO,JP,JE,JN,JBLANK,JBLANK,JBLANK,JBLANK,JC,X
               JO,JD,JE,JBLANK,JBLANK,JBLANK,JBLANK)                   X
               PUT IN EXTRA STUFF FOR OPEN CODE ERROR
         B     ERLOGERA                 PROCEED TO NAME INSERTION
MACROMSG MVC   ERROTHR,=AL1(JM,JA,JC,JR,JO,JBLANK,JBLANK,JBLANK,JBLANK,X
               JBLANK,JBLANK,JBLANK,JBLANK,JBLANK,JBLANK,JBLANK)       X
               PUT IN EXTRA STUFF AND PAD FOR MACRO DEFINITION ERROR
         IC    WORK5,MFLAGS             PICK UP MDD ENTRY FLAGS
         N     WORK5,=F'7'              GET MACRO NAME LENGTH
         EX    WORK5,MACRNMOV           PUT MACRO NAME IN MESSAGE
ERLOGERA EQU   *
         MVC   ERRNAME,=8AL1(JBLANK)    FILL SYMBOL SLOT WITH PAD
         EX    WORK1,NAMEMVE            PUT ERROR SYMBOL IN BUFFER
ERLOGERB CLC   JMSGL,D0(RTNLNK)         SEE IF ERROR SHOULD BE LOGGED
         BH    D2(,RTNLNK)              RETURN DIRECTLY IF NOT
         CLC   D0(D1,RTNLNK),JSEVER     IS THIS HIGHER
         BNH   ERLOGERD                 BRANCH IF NOT
         MVC   JSEVER(D1),D0(RTNLNK)    ENTER HIGH
ERLOGERD MVC   ERRHDR+D9(D2),D0(RTNLNK) PUT IN ERROR CODE
         L     WORK1,ERBLKPTR           GET PTR TO NEXT RCD SLOT
         LA    WORK2,D36(,WORK1)        ADJUST PTR FOR NEW ERROR
         C     WORK2,COMSTRT            CHECK FOR OVERLAP OF BUFFER
         BL    ERLOGERC                 BRANCH IF NO OVERLAP
         MVC   D0(D2,WORK1),=H'0'       PUT END OF BUFFER FLAG IN
         MVC   PIOPARMA,ERRBLK          SET UP WRITE PARAMETER- ADDRESS
         MVC   PIOPARMB,=F'190'         SET UP WRITE PARAMETER- LENGTH
         ST    RTNLNK,ERRLNKSV          PRESERVE RETURN ADDRESS
         STM   R3,R7,SAVE3456           SAVE CRUCIAL REGISTERS
         LH    R5,JMAXRL1               SET UP MAXIMUM RECORD LENGTH
         LA    R6,FILE1                 SET UP FILE POINTER
         BAL   R7,BUFRITE               LINK TO BUFFERED WRITE RTN
         LM    R3,R7,SAVE3456           RESTORE REGISTERS
         L     WORK1,ERRBLK             GET PTR TO ERROR BUFFER
         MVC   D0(L'JNOTEVAL,WORK1),JNOTEVAL SAVE N/P FOR LINK TO LAST
         LA    WORK1,D8(,WORK1)         GET OFFSET IN NEW ERROR BUFFER
         L     RTNLNK,ERRLNKSV          RESTORE RETURN REGISTER
ERLOGERC MVC   D0(D36,WORK1),ERRHDR     PUT ERROR MSG BUILT INTO BUF
         LA    WORK1,D36(,WORK1)        ADJUST BUFFER PTR FOR NEW MSG
         ST    WORK1,ERBLKPTR           SAVE NEW ERROR SLOT PTR
         B     D2(,RTNLNK)              RETURN TO CALLING RTN
NAMEMVE  MVC   ERRNAME(D0),D0(WORK2)    EXECUTED ERROR SYMBOL MOVE
MACRNMOV MVC   ERROTHR+D8(D0),MSYMBL    EXECUTED MACRO NAME MOVE
*
* THIS SUBROUTINE CONVERTS ANY SELF-DEFINING TERM TO A BINARY VALUE.
*
SDTCONV  SR    COUNT,COUNT              CLEAR REG FOR CHAR COUNT
         LR    RX,COUNT                 CLEAR REG FOR CHAR VALUE
         STC   TYPE,SHIFTAMT            SAVE SDT TYPE INDICATOR
SDT01    LA    RY,SDTAB1-D1(TYPE)       GET TTR TO SDT HI CHARACTER
         CLC   D0(D1,INPTR),D0(RY)      CHECK FOR NEXT CHAR IN RANGE
         BH    SDT08                    BRANCH IF NOT
         IC    RX,D0(,INPTR)            PICK UP NEXT VALID CHAR
         LR    RY,VALUE                 PRESERVE CURRENT ACCUM VALUE
         CLI   SHIFTAMT,D8              CHECK FOR CHAR (C) TYPE SDT
         BNE   SDT04                    BRANCH IF NOT C TYPE
         CLI   D0(INPTR),JQUOTE         SEE IF CHARACTER A QUOTE
         BNE   SDT04                    PROCEED IF NOT
         CLI   D1(INPTR),JQUOTE         LOOK AHEAD FOR PAIRED QUOTE
         BNE   SDT08A                   GO TO CHECK LENGTH AND EXIT
SDT03    LA    INPTR,D1(,INPTR)         BUMP PAST PARING QUOTE
SDT04    SLL   VALUE,D0(TYPE)           SHIFT ACCUM VALUE 1 PLACE
         CLI   SHIFTAMT,D3              CHECK FOR DECIMAL SDT
         BNE   SDT05                    BRANCH IF NOT DECIMAL
         ALR   VALUE,RY                 DO ADDITIONAL ADJUSTMENT
         ALR   VALUE,RY                 NECESSARY FOR DECIMAL SDT
SDT05    ALR   VALUE,RX                 ADD IN NEXT CHARACTER VALUE
         LA    COUNT,D1(,COUNT)         INCREMENT CHARACTER COUNT
         LA    INPTR,D1(,INPTR)         BUMP INPUT PTR TO NEXT CHAR
         CL    INPTR,ENDCOL             SEE IF OPERAND EXCEEDED
         BNH   SDT01                    GO ON IF STILL OK
SDT06    SR    COUNT,COUNT              SET COUNT TO NONE
SDT07    BR    RTNLNK                   RETURN TO CALLING RTN
SDT08    CLI   SHIFTAMT,D3              CHECK FOR DECIMAL SDT
         BE    SDT09                    GO TO CHECK LENGTH AND EXIT
         CLI   D0(INPTR),JQUOTE         LOOK FOR ENDING QUOTE
         BNE   SDT06                    TREAT AS ERROR IF NONE
SDT08A   LA    INPTR,D1(,INPTR)         BUMP PAST ENDING QUOTE
SDT09    IC    RX,SDTAB2-D1(TYPE)       PICK UP LENGTH LIMIT
         CR    COUNT,RX                 SEE IF SDT LENGTH IN RANGE
         BH    SDT06                    TREAT AS ERROR IF NOT
         CLI   SHIFTAMT,D8              CHECK FOR CHARACTER SDT
         BNER  RTNLNK                   BRANCH OUT IF NOT
         GOIF  TRANSW,OFF=(RTNLNK)      EXIT IF NO TRANSLATION
         ST    VALUE,JFWORD1            SET UP VALUE FOR TRANSLATE
         TR    JFWORD1,JTRTABLE         TRANSLATE IT
         L     VALUE,JFWORD1            PICK IT UP FOR CALLER
         BR    RTNLNK                   RETURN WITH TRANSLATED VALUE
SDTAB1   DC    X'0100090F000000FF'      SELF-DEFINING TERM
SDTAB2   DC    X'20000A0800000004'      CONVERSION TABLES
         EJECT
SSPRIME  DC    F'71'                    PRIME FOR HASHING SEQ SYMBOLS
SSHSHMSK DC    XL4'3F'                  MASK FOR HASHING SEQ SYMBOLS
GSPRIME  DC    F'201'                   PRIME FOR HASHING GBL VARIABLES
OSPRIME  EQU   GSPRIME                  PRIME FOR HASHING ORD SYMBOLS
GSHSHMSK DC    XL4'7F'                  MASK FOR HASHING GBL VARIABLES
OSHSHMSK EQU   GSHSHMSK                 MASK FOR HASHING ORD SYMBOLS
         EJECT
*INITOSR - THIS ROUTINE OUTPUTS THE MACRO DEFINITION VECTOR AND       *
*   INITIALIZES FOR THE ORDINARY SYMBOL RESOLUTION.                   *
*                                                                     *
         DS    0H
INITOSR  EQU   *
         L     R3,=A(ORDSYMBR)          SET UP BASE FOR SECOND HALF
         USING ORDSYMBR,R3
         JPOINT FILE=FILE2,NEXT=START   REWIND BEFORE PUTTING MDV
         MVC   PIOPARMB,MDVLNTH         SET UP MDV LENGTH
         MVC   PIOPARMA,MDVSTRT         SET UP MDV ADDRESS
         ST    R3,SAVE3456              SAVE CRUCIAL REGISTER
         LH    R5,JMAXRL2               SET UP MAXIMUM RECORD THIS FILE
         LA    R6,FILE2                 SET UP FILE POINTER
         BAL   R7,BUFRITE               GO PUT MDV TO FILE2
         L     R3,SAVE3456              RESTORE CRUCIAL REGISTER
         MVC   SAVMDVNP(L'JNOTEVAL),JNOTEVAL SAVE N/P ADDR FOR GENER
         MVC   SAVMDVLN(L'MDVLNTH),MDVLNTH   SAVE LENGTH FOR GENERATOR
         MVC   SAVGDLNT(L'GDALLOC),GDALLOC   SAVE GLOBAL DICT SIZE
         L     REFCNT,OREFCNT           GET NUMBER OF REFERENCES
         LTR   REFCNT,REFCNT            TEST FOR ZERO
         BNZ   OSRDALOC                 IF NOT ZERO, ENTER RESOLUTION
OSRDXT   XC    SAVOSDLN(D4),SAVOSDLN    INDICATE NO OSRD TO X3N
         B     OPSYNBLD                 AND SKIP TO OPSYN PROCESSING
OSRDALOC MH    REFCNT,=H'6'             GET SIZE OF OSRD
         ST    REFCNT,JFWORD1           SAVE TEMPORARILY AND PUT OSRD
         MVC   SAVOSDLN(L'JFWORD1),JFWORD1 LENGTH IN COMMON
         L     WORK2,OSRDSTRT           GET PTR TO DICT AREA
         LA    WORK3,D0(REFCNT,WORK2)   GET PTR PAST OSRD
         C     WORK3,MDDSTRT            CHECK FOR TABLE OVERLAP
         BNH   OSRDGO                   BRANCH IF NOT THE CASE
         BAL   RTNLNK,ERLOGERB          CALL ERROR LOGGING RTN
         DC    AL1(SEV64,ERR64)         ERROR PARAMETERS
         B     WTOMSG                   GO THRU BYPASS OF OSRD @AX14177
OSRDGO   EQU   *
CLERLP1  CH    REFCNT,=H'256'           SEE IF ONE MOVE WILL CLEAR IT
         BH    CLERLP2                  BRANCH IF NOT
         SH    REFCNT,=H'2'             ADJUST LENGTH FOR EXECUTED MOVE
         MVI   D0(WORK2),BITFF          INSERT F'S TO PROPAGATE
         EX    REFCNT,OSRDCLER          PROPAGATE THRU REST OF DICT
         B     ORDSYMBR                 GO ON TO RESOLUTION
CLERLP2  MVI   D0(WORK2),BITFF          INSERT F'S TO PROPAGATE
         MVC   D1(D255,WORK2),D0(WORK2) PROPAGATE THRU 256 BYTES
         SH    REFCNT,=H'256'           ADJUST REMAINING DICT LENGTH
         LA    WORK2,D256(,WORK2)       ADJUST PTR ALSO
         B     CLERLP1                  GO BACK THRU TO CLEAR REST
WTOMSG   WTO   MF=(E,MSG064)                                   @AX14177
         B     OSRDXT                                          @AX14177
MSG064   WTO   'IFO064 INTERLUDE DICTIONARY SPACE EXHAUSTED',  @AX14177*
               ROUTCDE=11,MF=L                                 @AX14177
         EJECT
         JPATCH X2A00,A20               PATCH AREA
         EJECT
         JCSECT (X2A02)
ORDSYMBR EQU   *
         JGETL FILE=FILE3               OTHERWISE, READ NEXT DEF RECD
         USING ENDFIL,RCDPTR
         CLI   EFILRT,BITFF             CHECK FOR END-OF-FILE
         BE    OSRDFINI                 IF SO, FINISH UP
         USING JTEXT,RCDPTR
         GOIF  JPSOP,OFF=GETNAME        BRANCH IF NOT A PSEUDO-OP
         CLI   JTIOP1,JTEXTRN           SEE IF PSEUDO-OP IS EXTRN
         BE    ESCAN                    BRANCH IF IT IS, TO GET NAME
         CLI   JTIOP1,JTWXTRN           SEE IF PSEUDO-OP IS WXTRN
         BE    ESCAN                    BRANCH IF IT IS, TO GET NAME
GETNAME  LR    WORK1,RCDPTR             GET START OF TEXT ADDR
         AH    WORK1,JTNMP              GET START OF NAME FIELD ADDR
         SR    WORK3,WORK3              CLEAR REGISTER FOR LENGTH
         IC    WORK3,D1(,WORK1)         PICK UP NAME TRUE LENGTH
         BCTR  WORK3,D0                 MAKE IT MOVE LENGTH
         STH   WORK3,JHWORD2            SAVE LENGTH OF NAME
         XC    JDWORD,JDWORD            CLEAR NAME WORK AREA
         EX    WORK3,NAMEMV             MOVE NAME FOR HASHING
HASHNAME LA    WORK1,OSPRIME            GET PTR TO HASHING PARAMETERS
         BAL   WORK2,HASH               LINK TO SYMBOL HASHING RTN
         L     OSRTBASE,OSRTSTRT        GET OSRT BASE ADDRESS
         AR    OSRTBASE,HASHOS          DEVELOP HASH TABLE POINTER
         USING OSRTNTRY,OSRTBASE
OSLUKUP  CLC   OSRTCP,=FL3'0'           CHECK FOR END OF CHAIN
         BZ    NGNAME                   IF FOUND, NO MATCH
         MVC   HIBYTE0+(L'HIBYTE0-L'OSRTCP)(L'OSRTCP),OSRTCP           X
               GET CHAIN POINTER FROM ENTRY
         L     OSRTBASE,HIBYTE0         PICK UP CHAIN POINTER
         A     OSRTBASE,OSRTSTRT        DEVELOP PTR TO NEXT ENTRY
         SR    WORK1,WORK1              CLEAR REGISTER FOR LENGTH
         IC    WORK1,OSRTSL             PICK UP ENTRY SYMBOL LENGTH
         CLR   WORK1,WORK3              COMPARE MOVE LENGTHS
         BNE   OSLUKUP                  NO MATCH IF UNALIKE
         EX    WORK1,NAMECM             COMPARE NAMES
         BNE   OSLUKUP                  SEARCH ON IF UNALIKE
         L     OSRDPTR,OSRDSTRT         PICK UP BASE ADDR OF OSRD
         MVC   HIBYTE0+(L'HIBYTE0-L'OSRTDP)(L'OSRTDP),OSRTDP           X
               GET DICTIONARY POINTER
         A     OSRDPTR,HIBYTE0          DEVELOP PTR TO OSRD ENTRY
         USING OSRDNTRY,OSRDPTR
         CLC   TATTRIB(L'TATTRIB+L'LATTRIB+L'SATTRIB),=5X'FF'          X
               SEE THAT ATTRIBUTES HAVE NOT ALREADY BEEN ASSIGNED
         BE    BRONTYP                  BRANCH IF NOT YET SET
         CLI   TATTRIB,JM               WAS OLD TYPE ATTRIBUTE M
         BNE   OLDNOTM                  BR IF ANYTHING ELSE
         GOIF  JTCALL,EQ=ORDSYMBR       ALLOW DUPLICATE NAME ON MI
CHNGU    MVI   TATTRIB,JU               DUPLICATE NAMES-- MAKE ATTRB U
         B     ORDSYMBR                 BACK TO CONTINUE
OLDNOTM  GOIF  JTCALL,EQ=CHNGU          MAKE ATTRB U IF THIS IS MI
CHKCST   GOIF  JTCSECT,LO=ERRORA        ERROR IF DUPLICATE NAME NOT ON
         GOIF  JTCOM,HI=ERRORA,ELSE=NGNAME CSECT, DSECT, OR COM STMT
BRONTYP  EQU   *
         MVI   ATTRIB,J0                CLEAR ATTRIBUTE DEFAULT FLAGS
         GOIF  JSUBOPCD,ON=TYPEU1       HANDLE SUBSTITUTED OP CODE
         GOIF  JPSOP,OFF=TYPEI1         BRANCH IF MACHINE INSTRUCTION
         GOIF  JTDC,EQ=DCSCAN           BRANCH IF DC STATEMENT
         GOIF  JTEQU,EQ=EQUSCAN         BRANCH IF EQU STATEMENT
         GOIF  JTDS,EQ=DSSCAN           BRANCH IF DS STATEMENT
         GOIF  JTCALL,EQ=TYPEM          BRANCH IF MACRO INSTRUCTION
         GOIF  JTORG,EQ=TYPEU1          BRANCH IF ORG STATEMENT
         GOIF  JTEXTRN,EQ=TYPET         BRANCH IF EXTRN STATEMENT
         GOIF  JTWXTRN,EQ=TYPE$         BRANCH IF WXTRN STATEMENT
         GOIF  JTSTART,EQ=TYPEJ         BRANCH IF START STATEMENT
         GOIF  JTLTORG,EQ=TYPEU1        BRANCH IF LTORG STATEMENT
         GOIF  JTDSECT,EQ=TYPEJ         BRANCH IF DSECT STATEMENT
         GOIF  JTCSECT,EQ=TYPEJ         BRANCH IF CSECT STATEMENT
         GOIF  JTCNOP,EQ=TYPEI2         BRANCH IF CNOP STATEMENT
         GOIF  JTCCW,EQ=TYPEW           BRANCH IF CCW STATEMENT
         GOIF  JTCOM,EQ=TYPEJ           BRANCH IF COM STATEMENT
         GOIF  JTCXD,EQ=TYPEU2          BRANCH IF CXD STATEMENT
         GOIF  JTDXD,EQ=TYPEJ           BRANCH IF DXD STATEMENT
         B     TYPEU1                   OTHERWISE ASSIGN DEFAULT ATTRS
ERRORA   EQU   *
         MVI   TATTRIB,JU               DUPLICATE NAMES-- MAKE ATTRB U
NGNAME   EQU   *
         GOIF  JTEXTRN,EQ=ESCANA        GO GET NEXT EXTRN/WXTRN NAME
         GOIF  JTWXTRN,EQ=ESCANA,ELSE=ORDSYMBR OR NEXT STATEMENT
CHASER     EQU   *
ENDCHK   NC    OSRTCP,OSRTCP            SEE IF END OF CHAIN REACHED
         BZ    NGNAME                   BRANCH IF YES
         MVC   HIBYTE0+(L'HIBYTE0-L'OSRTCP)(L'OSRTCP),OSRTCP           X
               GET CHAIN PTR FROM ENTRY
         L     OSRTBASE,HIBYTE0         PICK UP CHAIN POINTER
         A     OSRTBASE,OSRTSTRT        DEVELOP PTR TO NEXT ENTRY
         SR    WORK1,WORK1              CLEAR REGISTER FOR LENGTH
         IC    WORK1,OSRTSL             PICK UP ENTRY SYMBOL LENGTH
         CLR   WORK1,WORK3              COMPARE MOVE LENGTHS
         BNE   ENDCHK                   BRANCH IF UNALIKE
         EX    WORK1,NAMECM             COMPARE NAMES
         BNE   ENDCHK                   BRANCH IF UNALIKE
         L     PAIRO,OSRDSTRT           PICK UP,OSRD BASE ADDRESS
         MVC   HIBYTE0+(L'HIBYTE0-L'OSRTDP)(L'OSRTDP),OSRTDP           X
                   GET PTR TO OSRD ENTRY FOR DUPLICATE
         A     PAIRO,HIBYTE0            DEVELOP DICTIONARY POINTER
         MVC  D0(L'TATTRIB+L'LATTRIB+L'SATTRIB+L'ATTRIB,PAIRO),TATTRIB X
               PUT SAME ATTRIBUTES IN DUPLICATE ENTRY
         B     CHASER                   LOOP BACK FOR MORE
         EJECT
TYPEI1   EQU   *
         MVI   TATTRIB,JI               SET TYPE TO I IN DICT ENTRY
         SR    PAIRO,PAIRO              CLEAR WORK REGISTER
         IC    PAIRO,JTFLGA             PICK UP FLAGA BYTE FROM TEXT
         N     PAIRO,=F'3'              ISOLATE LENGTH BITS
         LA    PAIRO,D1(,PAIRO)         ADD 1 AND
         SLL   PAIRO,D1                 MULTIPLY BY 2 FOR LENGTH
         STH   PAIRO,JHWORD1            TEMPORARILY SAVE LENGTH AND
         MVC   LATTRIB,JHWORD1          INSERT INTO DICTIONARY ENTRY
         B     DEFALTC                  GO ASSIGN SCALE
TYPEI2   EQU   *
         MVI   TATTRIB,JI               SET TYPE TO I IN DICT ENTRY
DLENGTH  MVC   LATTRIB,=H'1'            PUT DEFAULT LENGTH IN ENTRY
         SET   LDEFALT,ON               INDICATE DEFAULTED LENGTH
DEFALTC  MVC   SATTRIB,=H'0'            INSERT DEFAULT SCALE ATTRIB
         SET   SDEFALT,ON               INDICATE DEFAULTED SCALE
         B     CHASER                   RETURN FOR ADDITNL REFERENCES
ESCAN    EQU   *
         SET   ENDSW,OFF                &NITIALIZE FOR NEW STATEMENT
ESCANB   LR    INPTR,RCDPTR             PICK UP PTR TO STATEMENT
         AH    INPTR,JTOPP              DEVELOP PTR TO OPERAND
         CLI   D0(INPTR),J0             LOOK FOR NULL OPERAND
         BE    ORDSYMBR                 BRANCH IF NO OPERAND
         TM    D0(INPTR),BIT0           LOOK FOR CARD POINTER
         BNO   ESCANC                   BRANCH IF NONE PRESENT
         LA    INPTR,D1(,INPTR)         BUMP PAST CARD POINTER
ESCANC   LA    INPTR,D2(,INPTR)         GET PTR TO NAME ITSELF
ESCANA   BAL   RTNLNK,GETXNAM           GO GET A NAME
         B     ORDSYMBR                 BRANCH ON NO NAME OR ERROR
         XC    JDWORD,JDWORD            CLEAR NAME WORK AREA
         EX    WORK3,MVNAME             PICK UP NAME FOR HASHING
         B     HASHNAME                 GO HASH NAME
DSSCAN   EQU   *
         MVI   SWITCHB,J0               CLEAR OUT ALL SWITCHES
         SET   DSSW,ON                  INDICATE DS OPERAND
         B     DC0                      CONTINUE AS DC
DCSCAN   EQU   *
         MVI   SWITCHB,J0               CLEAR OUT ALL SWITCHES
         SET   DSSW,OFF                 INDICATE DC OPERAND
DC0      LH    INPTR,JTOPP              GET DISPL TO OPERAND IN TEXT
         AR    INPTR,RCDPTR             DEVELOP PTR TO OPERAND
         CLI   D0(INPTR),J0             CHECK FOR NO OPERAND
         BE    DEFALTD1                 BRANCH IF NONE
         TM    D0(INPTR),BIT0           LOOK FOR CARD POINTER
         BNO   DC1                      BRANCH IF NONE
         LA    INPTR,D1(,INPTR)         BUMP PAST CARD POINTER
DC1      LA    INPTR,D1(,INPTR)         BUMP PAST COLUMN POINTER
         SR    ENDPTR,ENDPTR            CLEAR REGISTER FOR END PTR
         IC    ENDPTR,D0(INPTR)         PICK UP OPERAND LENGTH
         AR    ENDPTR,INPTR             DEVELOP PTR TO END OF OPERAND
         AH    ENDPTR,=H'1'             ADJUST FOR BLANK DELIMITER
         ST    ENDPTR,ENDCOL            SAVE FOR USE IN SCAN LATER
         LA    INPTR,D1(,INPTR)         BUMP PAST OPERAND LENGTH
         SR    RZ,RZ                    INITIALIZE WORK REGISTER
         CLI   D0(INPTR),J9             LOOK FOR DECIMAL DUP FACTOR
         BH    DC2                      BRANCH IF EXPRESSION
         BAL   RTNLNK,DECBIN            COLLECT DUP FACTOR
         B     DC3                      BRANCH,IGNORING DUP FACTOR
DC2      CLI   D0(INPTR),JLPARN         LOOK FOR LEADING PARENTHESIS
         BNE   DC3                      BRANCH IF NOT FOUND
         LA    INPTR,D1(,INPTR)         BUMP PAST LEFT PAREN
         MVI   DELIMIT,JRPARN           INDICATE LOOKING FOR RIGHT PAR
         BAL   RTNLNK,OPNDSCAN          GO SCAN OVER EXPRESSION
         B     DEFALTD1                 BRANCH ON ERROR RETURN
DC3      CLI   D0(INPTR),JZ             LOOK FOR TYPE CHARACTER HIGH
         BH    DEFALTD1                 BRANCH IF INVALID TYPE
         CLI   D0(INPTR),JA             LOOK FOR TYPE CHARACTER LOW
         BL    DEFALTD1                 BRANCH IF INVALID TYPE
         IC    RZ,D0(,INPTR)            PICK UP TYPE AS INDEX TO CONTAB
         IC    RZ,CONTAB-JA(RZ)         PICK UP DISPL IN CONTAB
         LTR   RZ,RZ                    CHECK FOR ZERO DISPLACEMENT
         BZ    DEFALTD1                 BRANCH ON INVALID TYPE
         LA    RZ,CONTAB(RZ)            DEVELOP PTR TO CONSTANT DATA
         MVC   AWORK(ACHARLMT-AFLAGS+D1),D0(RZ) PUT IN WORK AREA
         LA    INPTR,D1(,INPTR)         BUMP PTR TO NEXT CHARACTER
         CLI   D0(INPTR),JL             LOOK FOR LENGTH MODIFIER CHAR
         BNE   DC7                      BRANCH IF IMPLICIT LENGTH
         LA    INPTR,D1(,INPTR)         BUMP PTR TO NEXT CHARACTER
         SET   EXLENFLG,ON              SET EXPLICIT LENGTH FLAG ON
         CLI   D0(INPTR),JPERIOD        LOOK FOR BIT LENGTH INDICATOR
         BNE   DC4                      BRANCH IF NOT BIT LENGTH
         CLI   ATYPEAT,STYPE            LOOK FOR STYPE WITH BIT LENGTH
         BE    DEFALTD2                 BRANCH IF FOUND
         LA    INPTR,D1(,INPTR)         BUMP PTR TO NEXT CHARACTER
         BAL   RTNLNK,DECBIN            COLLECT BIT LENGTH
         LTR   RX,RX                    CHECK FOR ZERO BIT LENGTH
         BZ    DEFALTD2                 BRANCH IF FOUND
         LA    RX,D7(,RX)               ROUND BIT LENGTH UP
         SRL   RX,D3                    DIVIDE BY 8 FOR BYTE LENGTH
         B     DC6                      BRANCH TO SET LENGTH ATTR
DC4      CLI   D0(INPTR),J9             LOOK FOR DECIMAL LENGTH MODIF
         BH    DC8                      BRANCH IF EXPRESSION
         BAL   RTNLNK,DECBIN            COLLECT LENGTH MODIFIER
         LTR   RX,RX                    CHECK FOR ZERO LENGTH
         BZ    DEFALTD2                 BRANCH IF FOUND
         CLI   ATYPEAT,STYPE            LOOK FOR S TYPE CONSTANT
         BNE   DC5                      BRANCH IF NOT FOUND
         CH    RX,=H'2'                 LOOK FOR EXACT LENGTH OF 2
         BNE   DEFALTD2                 BRANCH IF NOT FOUND
DC5      CL    RX,=F'65535'             CHECK FOR HIGH LENGTH LIMIT
         BH    DEFALTD2                 BRANCH IF EXCEEDED
         CH    RX,ALENMAX               CHECK IF CONSTANT LENGTH LESS
         BNH   DC6                      BRANCH ON LENGTH OK
         GOIF  DSSW,OFF=DEFALTD2        BRANCH IF NOT DS OPERAND
         GOIF  (CHCON,BXCON),OFF=DEFALTD2 BRANCH IF NOT C,X,B TYPE
         CLI   ATYPEAT,BTYPE            LOOK FOR B TYPE
         BE    DEFALTD2                 BRANCH IF FOUND
DC6      STH   RX,ALENGTH               STORE LENGTH
         GOIF  (ADCON1,ADCON2,FLCON,FXCON),OFF=DC7                     X
               BRANCH IF NOT A,Y,V,S,Q,D,E,L,F,H TYPE
         MVC   ATYPEAT,ATYPALT          INSERT TYPE WITH EXPLICIT LENG
         GOIF  FLCON,OFF=DC7            BRANCH IF NOT D,E,L TYPE
         AR    RX,RX                    GET SCALE LIMIT WITH EXPL LENG
         SH    RX,=H'2'                 ALLOW FOR FIRST CHARACTERISTIC
         CL    RX,=F'16'                LOOK FOR L-CON, LENGTH OVER 8
         BNH   DC6A                     BRANCH IF NOT THE CASE
         SH    RX,=H'2'                 ALLOW FOR SECOND CHARACTERISTIC
DC6A     EQU   *
         GOIF  DEFLTL,ON=DC7            KEEP STD SCALE MAX ON DEFAULT
         STH   RX,ASCAMAX               SET SCALE, (LENGTH-1)*2
DC7      CLI   D0(INPTR),JS             LOOK FOR SCALE MODIFIER CHAR
         BNE   DC11                     BRANCH IF NOT FOUND
         GOIF  (FLCON,FXCON),NONE=DEFALTD3 EXIT IF SCALE NOT ALLOWED
         LA    INPTR,D1(,INPTR)         BUMP PTR TO NEXT CHARACTER
         CLI   D0(INPTR),JPLUS          LOOK FOR SCALE SIGN PLUS
         BE    DC7A                     SIMPLY IGNORE IF FOUND
         CLI   D0(INPTR),JMINUS         LOOK FOR SCALE SIGN MINUS
         BNE   DC9                      GO ON IF NO SIGN FOUND
         GOIF  FXCON,OFF=DEFALTD3       BR IF NEG SCALE ON FLCON
         SET   NSCALSW,ON               INDICATE SCALE NEGATIVE
DC7A     LA    INPTR,D1(,INPTR)         BUMP PTR PAST SCALE SIGN
DC9      CLI   D0(INPTR),J9             LOOK FOR DECIMAL SCALE
         BH    DEFALTD3                 BR IF NOT DECIMAL
         BAL   RTNLNK,DECBIN            GO COLLECT SCALE VALUE
         GOIF  NSCALSW,OFF=DC10         BRANCH IF SCALE POSITIVE
         LCR   RX,RX                    MAKE SCALE VALUE NEGATIVE
         CH    RX,=H'-187'              CHECK FOR NEGATIVE LIMIT
         BL    DEFALTD3                 BR IF EXCEEDED
DC10     CH    RX,ASCAMAX               CHECK FOR POSITIVE LIMIT
         BH    DEFALTD3                 BR IF EXCEEDED
         STH   RX,ASCALE                INSERT SCALE ATTRIBUTE
DC11     CLI   D0(INPTR),JE             LOOK FOR EXPONENT MODIFIER
         BNE   DC11A                    BRANCH IF NOT FOUND
         GOIF  (FXCON,FLCON),ANY=DCEXIT, TERMINATE FIXED AND FLOATING  X
               ELSE=DEFALTD2            ERROR FOR ALL OTHER TYPES
DC11A    CLI   D0(INPTR),JQUOTE         LOOK FOR LEADING QUOTE
         BNE   DC19                     IF NOT FOUND, MAKE MORE CHECKS
         GOIF  (FXCON,FLCON),ANY=DCEXIT THRU WITH TYPES F,H,D,E,L
         GOIF  (ADCON1,ADCON2),ANY=DEFALTD2  ERROR IF TYPES A,S,V,Y,Q
         GOIF  DCCON,ON=DC13            CONTINUE ON ALL TYPES P,Z
         GOIF  EXLENFLG,ON=DCEXIT       THRU ON TYPES C,X,B - EXPL LEN
DC13     SR    RX,RX                    CLEAR LENGTH ACCUMULATOR
         LR    RY,RX                    CLEAR SCALE ACCUMULATOR
         LA    INPTR,D1(,INPTR)         BUMP TO FIRST CHARACTER
DC13A    CLI   D0(INPTR),JQUOTE         LOOK FOR ENDING QUOTE
         BNE   DC12                     BRANCH IF NOT IT
         GOIF  CHCON,OFF=DC14           THRU FOR ALL BUT TYPE C
         LA    INPTR,D1(,INPTR)         BUMP PTR TO NEXT CHARACTER
         CLI   D0(INPTR),JQUOTE         LOOK FOR PAIRED QUOTE
         BNE   DC14                     THRU WITH TYPE C IF NOT FOUND
DC12     CLC   D0(D1,INPTR),ACHARLMT    CHECK FOR CHARACTER IN RANGE
         BNH   DC15                     BRANCH IF WITHIN RANGE
         GOIF  BXCON,ON=DEFALTD2        ERROR IF TYPES B,X
         CLI   D0(INPTR),JPLUS          LOOK FOR INTERNAL PLUS SIGN
         BE    DC17                     BRANCH IF FOUND
         CLI   D0(INPTR),JMINUS         LOOK FOR INTERNAL MINUS SIGN
         BE    DC17                     BRANCH IF FOUND
         CLI   D0(INPTR),JPERIOD        LOOK FOR INTERNAL DECIMAL PT
         BE    DC18                     BRANCH IF FOUND
         CLI   D0(INPTR),JCOMMA         LOOK FOR MULTIPLE CONSTANT DEL
         BNE   DEFALTD2                 BRANCH IF NOT FOUND
DC14     STH   RY,ASCALE                INSERT ACCUMULATED SCALE
         GOIF  EXLENFLG,ON=DCEXIT       THRU IF EXPLICIT LENGTH
         SR    RY,RY                    CLEAR REGISTER
         IC    RY,ARFACT                PICK UP ROUNDING FACTOR
         AR    RX,RY                    ADD TO ACCUMULATED LENGTH
         IC    RY,ASFACT                PICK UP SHIFTING FACTOR
         SRL   RX,D0(RY)                SHIFT TO GET CONSTANT LENGTH
         LTR   RX,RX                    CHECK FOR LENGTH OF ZERO
         BNP   DEFALTD2                 BRANCH IF LENGTH ZERO OR NEG
         CH    RX,ALENMAX               CHECK IF MAXIMUM LEN EXCEEDED
         BH    DEFALTD2                 BRANCH IF EXCEEDED
         STH   RX,ALENGTH               INSERT IMPLIED LENGTH
         B     DCEXIT                   GO COMPLETE ATTRIBUTE INSERTION
DC15     CLI   D0(INPTR),JAMPER         LOOK FOR AMPERSAND CHARACTER
         BNE   DC16                     BRANCH IF NOT FOUND
         CLI   D1(INPTR),JAMPER         LOOK FOR PAIRED AMPERSAND
         BNE   DEFALTD2                 BRANCH IF NOT FOUND
         LA    INPTR,D1(,INPTR)         IGNORE FIRST AMPERSAND
DC16     LA    RX,D1(,RX)               ADD 1 TO ACCUMULATED LENGTH
         GOIF  DCCON,OFF=DC16A          BRANCH ON ALL BUT TYPES P,Z
         GOIF  SCALEFLG,OFF=DC16A       BRANCH IF DEC PT NOT YET FOUND
         LA    RY,D1(,RY)               ADD 1 TO ACCUMULATED SCALE
DC16A    SET   SIGNFLG,ON               DISALLOW ANY FURTHER SIGNS
         LA    INPTR,D1(,INPTR)         BUMP PTR TO NEXT CHARACTER
         B     DC13A                    LOOP BACK FOR NEXT CHARACTER
DC17     GOIF  SIGNFLG,ON=DEFALTD2      BRANCH IF SIGN ALREADY FOUND
         B     DC16A                    CONTINUE OTHERWISE
DC18     GOIF  SCALEFLG,ON=DEFALTD2     BRANCH IF DEC PT ALREADY FOUND
         SET   SCALEFLG,ON              INDICATE DEC PT FOUND
         B     DC16A                    CONTINUE
DC19     CLI   D0(INPTR),JLPARN         LOOK FOR LEF PAREN CHARACTER
         BNE   DC20                     BRANCH IF NOT FOUND
         GOIF  (ADCON1,ADCON2),ANY=DCEXIT THRU WITH TYPES A,S,V,Y,Q
         B     DEFALTD2                 ERROR ON ALL OTHER TYPES
DC20     CLI   D0(INPTR),JBLANK         LOOK FOR BLANK DELIMITER
         BE    DC21                     BRANCH IF FOUND
         CLI   D0(INPTR),JCOMMA         LOOK FOR COMMA DELIMITER
         BNE   DEFALTD2                 BRANCH IF NOT FOUND
DC21     GOIF  DSSW,ON=DCEXIT,ELSE=DEFALTD2 ERROR EXCEPT ON DS STMT
DC8      CLI   D0(INPTR),JLPARN         LOOK FOR LEADING PARENTHESIS
         BNE   DEFALTD2                 BRANCH IF NOT FOUND
         LA    INPTR,D1(,INPTR)         BUMP PAST LEFT PAREN
         MVI   DELIMIT,JRPARN           INDICATE LOOKING FOR RIGHT PAR
         BAL   RTNLNK,OPNDSCAN          GO SCAN OVER EXPRESSION
         B     DEFALTD2                 BRANCH ON ERROR RETURN
         LH    RX,=H'1'                 SET UP DEFAULT LENGTH OF 1
         SET   LDEFALT,ON               INDICATE DEFAULTED LENGTH
         SET   DEFLTL,ON                INDICATE LENGTH DEFAULTED
         B     DC6                      GO ON WITH DEFAULT LENGTH
DEFALTD1 MVI   ATYPEAT,JU               SET TYPE TO U
DEFALTD2 MVC   ALENGTH,=H'1'            SET LENGTH ATTRIB TO 1
         SET   LDEFALT,ON               INDICATE DEFAULTED LENGTH
DEFALTD3 MVC   ASCALE,=H'0'             SET SCALE ATTR TO 0
         SET   SDEFALT,ON               INDICATE DEFAULTED SCALE
DCEXIT   MVC   TATTRIB(L'TATTRIB+L'LATTRIB+L'SATTRIB),ATYPEAT          X
               PUT ATTRIBUTES INTO OSRD ENTRY
         GOIF  (DCCON,FLCON,FXCON),ANY=CHASER BR IF SCALE ALLOWED
         SET   SDEFALT,ON               INDICATE DEFAULTED SCALE
         B     CHASER                   GO SCAN FOR DUPLICATES
EQUSCAN  EQU   *
         LH    INPTR,JTOPP              GET START OF RECORD ADDR
         AR    INPTR,RCDPTR             GET START OF OPERAND ADDR
         CLI   D0(INPTR),J0             SEE IF OPERAND PRESENT
         BE    DEFALTA                  BRANCH IF NOT
         TM    D0(INPTR),BIT0           LOOK FOR CARD POINTER
         BNO   ES1                      BRANCH IF NONE FOUND
         LA    INPTR,D1(,INPTR)         BUMP BY CARD POINTER
ES1      LA    INPTR,D1(,INPTR)         BUMP PAST COLUMN POINTER
         SR    ENDPTR,ENDPTR            CLEAR REGISTER FOR END PTR
         IC    ENDPTR,D0(,INPTR)        PICK UP OPERAND LENGTH
         AR    ENDPTR,INPTR             DEVELOP PTR TO END OF OPERAND
         AH    ENDPTR,=H'1'             ADJUST FOR BLANK DELIMITER
         ST    ENDPTR,ENDCOL            SAVE FOR LATER OPERAND SCAN
         LA    INPTR,D1(,INPTR)         POINT TO START OF OPERAND
         MVI   DELIMIT,JCOMMA           INDICATE LOOKING FOR COMMA
         BAL   RTNLNK,OPNDSCAN          GO SCAN OVER FIRST OPERAND
         B     DEFALTA                  BRANCH ON ERROR
         LA    TYPE,D8                  SET UP FOR CHARACTER SDT
         L     VALUE,=C'0000'           INITIALIZE VALUE REG FOR CHAR
         CLI   D0(INPTR),JC             SEE IF IT IS ONE
         BE    ES8                      BRANCH IF SO
         SR    VALUE,VALUE              INITIALIZE VALUE REG FOR X,B,D
         LA    TYPE,D4                  SET UP FOR HEXADEC SDT
         CLI   D0(INPTR),JX             SEE IF IT IS ONE
         BE    ES8                      BRANCH IF SO
         LA    TYPE,D1                  SET UP FOR BINARY SDT
         CLI   D0(INPTR),JB             SEE IF IT IS ONE
         BE    ES8                      BRANCH IF SO
         LA    TYPE,D3                  SET UP FOR DECIMAL SDT
         CLI   D0(INPTR),J9             SEE IF IT IS ONE
         BH    ES9                      BRANCH IF NOT
         B     ES8A                     GO TO CONVERT IT
ES8      CLI   D1(INPTR),JQUOTE         LOOK FOR LEADING QUOTE
         BNE   ES9                      BRANCH IF NOT FOUND
         LA    INPTR,D2(,INPTR)         BUMP TO START OF CONSTANT
ES8A     LR    RZ,INPTR                 PRESERVE INPUT PTR
         L     R9,ENDCOL                POINT TO TERMINATOR    @AY19671
ES8C     BCTR  R9,0                     POINT TO PRECEDING CHAR@AY19671
         CR    R9,INPTR                 END OF TEST            @AY19671
         BNH   ES8E                     BR IF YES              @AY19671
         CLI   D0(R9),J9                TEST FOR DEC SDT       @AY19671
         BH    ES9                      BR IF NOT              @AY19671
         B     ES8C                     LOOP FOR NEXT CHARACTER@AY19671
ES8E     EQU   *                                               @AY19671
         SET   TRANSW,ON                INDICATE TRANSLATED VALUE REQD
         BAL   RTNLNK,SDTCONV           LINK TO CONVERT ROUTINE
         CLI   D0(INPTR),JCOMMA         LOOK FOR COMMA DELIMITER
         BE    ES2                      BRANCH IF FOUND
         CLI   D0(INPTR),JBLANK         LOOK FOR BLANK DELIMITER
         BE    ES2A                     BRANCH IF FOUND
         B     ES3A                     OTHERWISE DEFAULT SITUATION
ES9      MVI   DELIMIT,JCOMMA           INDICATE LOOKING FOR COMMA
         BAL   RTNLNK,OPNDSCAN          GO SCAN OVER SECOND OPERAND
         B     DEFALTA                  BRANCH ON ERROR
         SET   LDEFALT,ON               INDICATE DEFAULTED LENGTH
         B     ES3                      GO SET LENGTH 1
ES2      LA    INPTR,D1(,INPTR)         BUMP PTR TO NEXT OPERAND
ES2A     LTR   COUNT,COUNT              SEE IF VALID VALUE GOTTEN
         BZ    ES3A                     GO WARN OF LENGTH DEFAULT TO 1
         CLI   SHIFTAMT,D3              CHECK FOR DECIMAL SDT
         BNE   ES2B                     BRANCH IF NOT DECIMAL
         CH    COUNT,=H'10'             CHECK FOR MAX LENGTH DEC SDT
         BNE   ES2B                     BRANCH IF NOT MAX LENGTH
         CLC   D0(D10,RZ),=X'00000000000605050305' CHECK FOR UPPER LMT
         BH    ES3A                     BRANCH IF VALUE OUT OF RANGE
ES2B     C     VALUE,=F'65535'          CHECK FOR LEGITIMATE VALUE
         BNH   ES4                      BRANCH IF ACCEPTABLE
ES3A     LA    WORK2,JDWORD             PT TO NAME FIELD OF EQU
         LH    WORK1,JHWORD2            SET NAME MOVE LENGTH
         BAL   RTNLNK,ERLOGERA          LOG ERROR
         DC    AL1(SEV65,ERR65)         2ND OPERAND NOT IN RANGE
         SET   LDEFALT,ON               INDICATE DEFAULTED LENGTH
ES3      LA    VALUE,D1                 ASSIGN DEFAULT LENGTH OF 1
ES4      STH   VALUE,JHWORD1            TEMPORARILY SAVE LENGTH
         MVC   LATTRIB,JHWORD1          INSERT INTO OSRD ENTRY
         CLI   D0(INPTR),JCOMMA         CHECK IF COMMA DELIMITER
         BNE   ES4A                     BR IF NOT
         LA    INPTR,D1(,INPTR)         BUMP OVER COMMA
ES4A     CLI   D0(INPTR),JBLANK         SEE IF THERE IS A THIRD
         BE    DEFALTB                  BR IF NOT
         LA    TYPE,D8                  SET UP FOR CHARACTER SDT
         SR    VALUE,VALUE              INITIALIZE VALUE REG FOR X,B,D
         CLI   D0(INPTR),JC             SEE IF IT IS ONE
         BE    ES5                      BRANCH IF SO
         LA    TYPE,D4                  SET UP FOR HEXADEC SDT
         CLI   D0(INPTR),JX             SEE IF IT IS ONE
         BE    ES5                      BRANCH IF SO
         LA    TYPE,D1                  SET UP FOR BINARY SDT
         CLI   D0(INPTR),JB             SEE IF IT IS ONE
         BE    ES5                      BRANCH IF SO
         LA    TYPE,D3                  SET UP FOR DECIMAL SDT
         B     ES6                      GO TO CONVERT IT
ES5      CLI   D1(INPTR),JQUOTE         LOOK FOR LEADING QUOTE
         BNE   DEFALTT                  BR IF NOT FOUND
         LA    INPTR,D2(,INPTR)         BUMP TO START OF CONSTANT
ES6      LR    RZ,INPTR                 PRESERVE INPUT PTR
         SET   TRANSW,ON                INDICATE TRANSLATION
         BAL   RTNLNK,SDTCONV           LINK TO CONVERT ROUTINE
         ST    VALUE,JFWORD1            SET UP VALUE FOR TRANSLATE
         TR    JFWORD1,JTRTABLE         TRANSLATE IT
         CLI   D0(INPTR),JBLANK         LOOK FOR BLANK DELIMITER
         BNE   DEFALTT                  BR IF NOT FOUND
         LTR   COUNT,COUNT              SEE IF VALID VALUE GOTTEN
         BZ    ES7B                     BR IF NOT
         CLI   SHIFTAMT,D3              CHECK FOR DECIMAL SDT
         BNE   ES7                      BRANCH IF NOT DECIMAL
         CH    COUNT,=H'10'             CHECK FOR MAX LENGTH DEC SDT
         BNE   ES7                      BRANCH IF NOT MAX LENGTH
         CLC   D0(D10,RZ),=X'00000000000000020505' CHECK FOR UPPER LMT
         BH    ES7B                     BRANCH IF VALUE OUT OF RANGE
ES7      CH    VALUE,=H'255'            CHECK FOR LEGITIMATE VALUE
         BH    ES7B                     BR IF OUT OF RANGE
ES7A     L     VALUE,JFWORD1            RESTORE IT TRANSLATED
         STC   VALUE,TATTRIB            ASSIGN TYPE ATTRIBUTE
         B     DEFALTC                  GO TO FINISH UP
ES7B     LA    WORK2,JDWORD             PT TO NAME FIELD OF EQU
         LH    WORK1,JHWORD2            SET NAME MOVE LENGTH
         BAL   RTNLNK,ERLOGERA          LOG ERROR
         DC    AL1(SEV66,ERR66)         3RD OPERAND NOT IN RANGE
DEFALTT  EQU   *
         SET   TDEFALT,ON               INDICATE DEFAULTED TYPE
         B     DEFALTB                  GO SET TYPE TO U
DEFALTA  MVC   LATTRIB,=H'1'            SET DEFAULT LENGTH ATTR
         SET   LDEFALT,ON               INDICATE DEFAULTED LENDTH
DEFALTB  MVI   TATTRIB,JU               SET TYPE   ATTRIBUTE TO U
         B     DEFALTC                  GO ASSIGN SCALE
TYPEM    EQU   *
         MVI   TATTRIB,JM               SET TYPE TO M IN DICT ENTRY
         B     DLENGTH                  GO ASSIGN DEFAULT LENGTH
TYPEU1   EQU   *
         MVI   TATTRIB,JU               SET TYPE TO U IN DICT ENTRY
         MVC   LATTRIB,=H'0'            ASSIGN DEFAULT LENGTH ATTR
         B     DEFALTC                  GO ASSIGN SCALE
TYPEJ    EQU   *
         MVI   TATTRIB,JJ               SET TYPE TO J IN DICT ENTRY
         B     DLENGTH                  GO ASSIGN DEFAULT LENGTH
TYPET    EQU   *
         MVI   TATTRIB,JT               SET TYPE TO T IN DICT ENTRY
         B     DLENGTH                  GO ASSIGN DEFAULT LENGTH
TYPE$    EQU   *
         MVI   TATTRIB,JDOLLAR          SET TYPE TO $ IN DICT ENTRY
         B     DLENGTH                  GO ASSIGN DEFAULT LENGTH
TYPEW    EQU   *
         MVI   TATTRIB,JW               SET TYPE TO W IN DICT ENTRY
         MVC   LATTRIB,=X'0008'         PUT LENGTH ATTR IN ENTRY
         B     DEFALTC                  GO ASSIGN SCALE
TYPEU2   EQU   *
         MVI   TATTRIB,JA               SET TYPE TO A IN DICT ENTRY
         MVC   LATTRIB,=X'0004'         PUT LENGTH ATTR IN ENTRY
         B     DEFALTC                  GO ASSIGN SCALE
         EJECT
OSRDFINI MVC   PIOPARMA,OSRDSTRT        SET UP PTR TO OSRD FOR WRITE
         MVC   PIOPARMB,SAVOSDLN        SET UP OSRD LENGTH FOR WRITE
         L     WORK1,OSRDSTRT           GET PTR TO START OF TABLE
         LR    WORK2,WORK1              USE PTR FOR TABLE END CALCULA
         A     WORK2,PIOPARMB           GET PTR TO END OF TABLE
         SR    WORK3,WORK3              CLEAR TABLE INDEX INITIALLY
OSRDLP1  LA    WORK4,D0(WORK3,WORK1)    GET PTR TO NEXT TABLE ENTRY
         CLR   WORK4,WORK2              SEE IF ENTIRE TABLE SCANNED
         BNL   OSRDLP3                  BRANCH IF IT HAS BEEN
         CLC   D0(D5,WORK4),=5X'FF'     LOOK FOR UNPROCESSED ENTRY
         BNE   OSRDLP2                  BRANCH IF NOT FOUND
         MVC   D0(D6,WORK4),=AL1(JU,J0,J1,J0,J0,X'70') SET DEFALTS
OSRDLP2  LA    WORK3,D6(,WORK3)         BUMP INDEX TO NEXT ENTRY
         B     OSRDLP1                  GO BACK TO START OF LOOP
OSRDLP3  EQU   *
         ST    R3,SAVE3456              SAVE NECESSARY REGISTER
         LH    R5,JMAXRL2               SET UP MAXIMUM RECORD THIS FILE
         LA    R6,FILE2                 SET UP FILE POINTER
         BAL   R7,BUFRITE               GO PUT OSRD TO FILE 2
         L     R3,SAVE3456              RESTORE CRUCIAL REGISTER
         MVC   SAVOSDNP(L'JNOTEVAL),JNOTEVAL SAVE N/P IN COMMON
         B     OPSYNBLD                 GO PROCESS ANY OPSYN ENTRIES
OSRDCLER MVC   D1(D0,WORK2),D0(WORK2)   EXECUTED MOVE TO CLEAR OSRD
NAMEMV   MVC   JDWORD(D0),D2(WORK1)     EXECUTED ORD SYMB MOVE
NAMECM   CLC   JDWORD(D0),OSRTOS        EXECUTED ORD SYMB COMPARE
MVNAME   MVC   JDWORD(D0),D0(RX)        EXECUTED NAME MOVE
         DROP  RCDPTR
         DROP  OSRTBASE
         DROP  OSRDPTR
         EJECT
OPSYNBLD EQU   *
         JPOINT FILE=FILE3,NEXT=START   REWIND FILE 3
         L     WORK1,FREESTRT           GET PTR TO SPACE FOR TABLE BLD
         ST    WORK1,PIOPARMA           SAVE ALSO FOR I/O ROUTINE
         SR    WORK2,WORK2              SET TABLE LENGTH TO ZERO
         MVC   HIBYTE0,OPSCHAIN         PICK UP OPSYN CHAIN POINTER
BLDLOP   L     WORK3,MDDND              GET PTR TO TABLE BASE
         S     WORK3,HIBYTE0            DISPLACE TO FIRST ENTRY
         C     WORK3,MDDND              SEE IF END OF CHAIN REACHED
         BE    PUTOPSYN                 BRANCH IF YES
         USING OPSYNTRY,WORK3
         USING OPSTBL,WORK1
         GOIF  OMAC,ON=BLDOP1           BRANCH IF THIS IS A MACRO
         MVC   OPSFLGS(OPSTLNT),OPSYNFLG MOVE OPSYN DATA TO NEW ENTRY
         LA    WORK2,OPSTLNT(,WORK2)    INCREMENT TABLE LENGTH
         LA    WORK1,OPSTLNT(,WORK1)    INCREMENT TABLE POINTER
BLDOP1   EQU   *
         MVC   HIBYTE0+(L'HIBYTE0-L'OPSYNCH)(L'OPSYNCH),OPSYNCH        X
               PICK UP CHAIN PTR FROM ENTRY
         B     BLDLOP                   GO BACK TO START OF SEARCH
PUTOPSYN LTR   WORK2,WORK2              SEE IF ANY TABLE TO PUT
         BZ    NOOPSYN                  BRANCH IF NOT
         ST    WORK2,PIOPARMB           SET UP TABLE LENGTH FOR I/O
         MVC   SAVOPTLN(L'PIOPARMB),PIOPARMB SAVE ALSO FOR X3N
         ST    R3,SAVE3456              SAVE CRUCIAL REGISTER
         LH    R5,JMAXRL2               SET UP MAXIMUM RECORD LENGTH
         LA    R6,FILE2                 SET UP FILE INDICATOR
         BAL   R7,BUFRITE               GO TO PUT OPSYN TABLE OUT
         L     R3,SAVE3456              RESTORE CRUCIAL REGISTER
         MVC   SAVOPTNP(L'JNOTEVAL),JNOTEVAL SAVE NOTE VALUE FOR X3N
         B     INTREXIT                 GO EXIT THE PHASE
NOOPSYN  XC    SAVOPTLN(D4),SAVOPTLN    SET OPSYN TABLE LENGTH TO 0
         B     INTREXIT                 GO EXIT THE PHASE
         DROP  WORK3
         DROP  WORK1
         EJECT
*INTREXIT - THIS ROUTINE RELEASES THE WORK SPACE USED BY THE          *
*   DICTIONARY INTERLUDE PHASE AND TERMINATES THE PHASE.              *
*                                                                     *
INTREXIT EQU   *
         L     WORK3,ERRBLK             GET PTR TO ERROR BUFFER
         ST    WORK3,PIOPARMA           SET UP I/O AREA START PTR
         MVC   SAVERRNP(L'JNOTEVAL),D0(WORK3) SAVE LAST ERROR LINK
         LA    WORK3,D8(,WORK3)         GET PTR TO NEXT ERROR SLOT
         CL    WORK3,ERBLKPTR           SEE IF ANY ERRORS IN BUFFER
         BE    IEXIT1                   BRANCH IF NOT
         L     WORK3,ERBLKPTR           PICK UP PTR TO NEXT ERROR SLOT
         MVC   D0(D2,WORK3),=H'0'       INSERT END OF ERRORS FLAG
         MVC   PIOPARMB,=F'190'         SET UP I/O AREA LENGTH
         LH    R5,JMAXRL1               SET UP RECORD LENGTH
         LA    R6,FILE1                 SET UP FILE INDICATOR
         BAL   R7,BUFRITE               GO TO WRITE BLOCK OF ERRORS
         MVC   SAVERRNP(L'JNOTEVAL),JNOTEVAL SAVE NEW LAST ERROR LINK
IEXIT1   EQU   *
         JNOTE FILE=FILE1               NOTE END OF DICT FILE
         MVC   SAVOVFPT(L'JNOTEVAL),JNOTEVAL SAVE AS OVERFLOW PTR
         JFRECORE ADDR=FREESTRT         FREE UP ALL DICT WORK AREA
INTROUT  JRETURN                        RETURN TO THE DRIVER
         EJECT
*
* THIS TABLE IS INDEXED INTO USING THE DC/DS TYPE CHARACTER. IF
*        THE BYTE INDEXED TO IS ZERO, THE TYPE IS INVALID. IF THE
*        BYTE INDEXED TO IS NON-ZERO, THE BYTE CONTAINS THE DISPLACE-
*        MENT TO THE TABLE INFORMATION FOR THAT TYPE.
*
CONTAB   DC    AL1(ACON-CONTAB)         A
         DC    AL1(BCON-CONTAB)         B
         DC    AL1(CCON-CONTAB)         C
         DC    AL1(DCON-CONTAB)         D
         DC    AL1(ECON-CONTAB)         E
         DC    AL1(FCON-CONTAB)         F
         DC    AL1(0)                   G
         DC    AL1(HCON-CONTAB)         H
         DC    AL1(0)                   I
         DC    AL1(0)                   J
         DC    AL1(0)                   K
         DC    AL1(LCON-CONTAB)         L
         DC    AL1(0)                   M
         DC    AL1(0)                   N
         DC    AL1(0)                   O
         DC    AL1(PCON-CONTAB)         P
         DC    AL1(QCON-CONTAB)         Q
         DC    AL1(0)                   R
         DC    AL1(SCON-CONTAB)         S
         DC    AL1(0)                   T
         DC    AL1(0)                   U
         DC    AL1(VCON-CONTAB)         V
         DC    AL1(0)                   W
         DC    AL1(XCON-CONTAB)         X
         DC    AL1(YCON-CONTAB)         Y
         DC    AL1(ZCON-CONTAB)         Z
*
* THIS TABLE CONTAINS THE DATA FOR EACH DC/DS TYPE NECESSARY TO
*        COLLECT AND VERIFY THE TYPE, LENGTH, AND SCALE ATTRIBUTES.
*
ACON     DC    AL1(128)                 TYPE A  FLAGS
         DC    AL1(ATYPE)                       TYPE ATTR
         DC    AL2(4)                           LENGTH ATTR
         DC    AL2(0)                           SCALE ATTR
         DC    AL2(4)                           LENGTH MAXIMUM
         DC    AL2(0)                           SCALE MAXIMUM
         DC    AL1(RTYPE)                       ALTERNATE TYPE ATTR
BCON     DC    AL1(16)                  TYPE B  FLAGS
         DC    AL1(BTYPE)                       TYPE ATTR
         DC    AL2(1)                           LENGTH ATTR     OX00408
         DC    AL2(0)                           SCALE ATTR
         DC    AL2(256)                         LENGTH MAXIMUM
         DC    AL2(0)                           SCALE MAXIMUM
         DC    AL1(7)                           ROUNDING FACTOR
         DC    AL1(3)                           SHIFTING FACTOR
         DC    AL1(1)                           CHARACTER HIGH LIMIT
CCON     DC    AL1(32)                  TYPE C  FLAGS
         DC    AL1(CTYPE)                       TYPE ATTR
         DC    AL2(1)                           LENGTH ATTR     OX00408
         DC    AL2(0)                           SCALE ATTR
         DC    AL2(256)                         LENGTH MAXIMUM
         DC    AL2(0)                           SCALE MAXIMUM
         DC    AL1(0)                           ROUNDING FACTOR
         DC    AL1(0)                           SHIFTING FACTOR
         DC    AL1(255)                         CHARACTER HIGH LIMIT
DCON     DC    AL1(4)                   TYPE D  FLAGS
         DC    AL1(DTYPE)                       TYPE ATTR
         DC    AL2(8)                           LENGTH ATTR
         DC    AL2(0)                           SCALE ATTR
         DC    AL2(8)                           LENGTH MAXIMUM
         DC    AL2(14)                          SCALE MAXIMUM
         DC    AL1(KTYPE)                       ALTERNATE TYPE ATTR
ECON     DC    AL1(4)                   TYPE E  FLAGS
         DC    AL1(ETYPE)                       TYPE ATTR
         DC    AL2(4)                           LENGTH ATTR
         DC    AL2(0)                           SCALE ATTR
         DC    AL2(8)                           LENGTH MAXIMUM
         DC    AL2(14)                          SCALE MAXIMUM
         DC    AL1(KTYPE)                       ALTERNATE TYPE ATTR
FCON     DC    AL1(2)                   TYPE F  FLAGS
         DC    AL1(FTYPE)                       TYPE ATTR
         DC    AL2(4)                           LENGTH ATTR
         DC    AL2(0)                           SCALE ATTR
         DC    AL2(8)                           LENGTH MAXIMUM
         DC    AL2(346)                         SCALE MAXIMUM
         DC    AL1(GTYPE)                       ALTERNATE TYPE ATTR
HCON     DC    AL1(2)                   TYPE H  FLAGS
         DC    AL1(HTYPE)                       TYPE ATTR
         DC    AL2(2)                           LENGTH ATTR
         DC    AL2(0)                           SCALE ATTR
         DC    AL2(8)                           LENGTH MAXIMUM
         DC    AL2(346)                         SCALE MAXIMUM
         DC    AL1(GTYPE)                       ALTERNATE TYPE ATTR
LCON     DC    AL1(4)                   TYPE L  FLAGS
         DC    AL1(LTYPE)                       TYPE ATTR
         DC    AL2(16)                          LENGTH ATTR
         DC    AL2(0)                           SCALE ATTR
         DC    AL2(16)                          LENGTH MAXIMUM
         DC    AL2(28)                          SCALE MAXIMUM
         DC    AL1(KTYPE)                       ALTERNATE TYPE ATTR
PCON     DC    AL1(8)                   TYPE P FLAGS
         DC    AL1(PTYPE)                       TYPE ATTR
         DC    AL2(1)                           LENGTH ATTR     OX00408
         DC    AL2(0)                           SCALE ATTR
         DC    AL2(16)                          LENGTH MAXIMUM
         DC    AL2(31)                          SCALE MAXIMUM
         DC    AL1(2)                           ROUNDING FACTOR
         DC    AL1(1)                           SHIFTING FACTOR
         DC    AL1(9)                           CHARACTER HIGH LIMIT
QCON     DC    AL1(64)                  TYPE Q FLAGS
         DC    AL1(QTYPE)                       TYPE ATTR
         DC    AL2(4)                           LENGTH ATTR
         DC    AL2(0)                           SCALE ATTR
         DC    AL2(4)                           LENGTH MAXIMUM
         DC    AL2(0)                           SCALE MAXIMUM
         DC    AL1(RTYPE)                       ALTERNATE TYPE ATTR
SCON     DC    AL1(128)                 TYPE S  FLAGS
         DC    AL1(STYPE)                       TYPE ATTR
         DC    AL2(2)                           LENGTH ATTR
         DC    AL2(0)                           SCALE ATTR
         DC    AL2(2)                           LENGTH MAXIMUM
         DC    AL2(0)                           SCALE MAXIMUM
         DC    AL1(RTYPE)                       ALTERNATE TYPE ATTR
VCON     DC    AL1(128)                 TYPE V  FLAGS
         DC    AL1(VTYPE)                       TYPE ATTR
         DC    AL2(4)                           LENGTH ATTR
         DC    AL2(0)                           SCALE ATTR
         DC    AL2(4)                           LENGTH MAXIMUM
         DC    AL2(0)                           SCALE MAXIMUM
         DC    AL1(RTYPE)                       ALTERNATE TYPE ATTR
XCON     DC    AL1(16)                  TYPE X  FLAGS
         DC    AL1(XTYPE)                       TYPE ATTR
         DC    AL2(1)                           LENGTH ATTR     OX00408
         DC    AL2(0)                           SCALE ATTR
         DC    AL2(256)                         LENGTH MAXIMUM
         DC    AL2(0)                           SCALE MAXIMUM
         DC    AL1(1)                           ROUNDING FACTOR
         DC    AL1(1)                           SHIFTING FACTOR
         DC    AL1(15)                          CHARACTER HIGH LIMIT
YCON     DC    AL1(128)                 TYPE Y  FLAGS
         DC    AL1(YTYPE)                       TYPE ATTR
         DC    AL2(2)                           LENGTH ATTR
         DC    AL2(0)                           SCALE ATTR
         DC    AL2(2)                           LENGTH MAXIMUM
         DC    AL2(0)                           SCALE MAXIMUM
         DC    AL1(RTYPE)                       ALTERNATE TYPE ATTR
ZCON     DC    AL1(8)                   TYPE Z  FLAGS
         DC    AL1(ZTYPE)                       TYPE ATTR
         DC    AL2(1)                           LENGTH ATTR     OX00408
         DC    AL2(0)                           SCALE ATTR
         DC    AL2(16)                          LENGTH MAXIMUM
         DC    AL2(16)                          SCALE MAXIMUM
         DC    AL1(0)                           ROUNDING FACTOR
         DC    AL1(0)                           SHIFTING FACTOR
         DC    AL1(9)                           CHARACTER HIGH LIMIT
         EJECT
         JPATCH X2A02,A20
         END   INTRENTR
