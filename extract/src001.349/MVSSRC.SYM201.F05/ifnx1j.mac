         JHEAD 'EDIT PHASE DICTIONARY ROUTINES',                       X
               PHASEID=X1J,                                            X
               LEVEL=10
         EJECT
*   THE EDIT PHASE DICTIONARY ROUTINES ARE A SET OF SUBROUTINES.      *
*   THESE SUBROUTINES PROVIDE ALL THE FUNCTIONS REQUIRED BY THE EDIT  *
*   PHASE RELATIVE TO THE COLLECTION TIME DICTIONARIES, CALLED        *
*   DIRECTORIES. THE FUNCTIONS PROVIDED ARE- INITIALIZATION,          *
*   BUILDING, REFERENCING, AND OUTPUTTING. THESE FUNCTIONS ARE        *
*   REQUESTED DURING THE CONVERSION OF SOURCE INPUT TEXT FOR BOTH     *
*   MACRO DEFINITIONS AND OPEN CODE INTO EDITED TEXT TO BE PROCESSED  *
*   BY THE GENERATE PHASE. THE PERTINENT DICTIONARIES ARE- OP CODE    *
*   TABLE, MACRO DEFINITION DIRECTORY, VARIABLE SYMBOL DIRECTORY,     *
*   SEQUENCE SYMBOL REFERENCE DIRECTORY, ORDINARY SYMBOL REFERENCE    *
*   DIRECTORY, AND OPSYN TABLE.                                       *
*                                                                     *
*ENTRY POINT-                                                         *
*        DICTENTR                                                     *
*              THE CALLING SEQUENCE IS-                               *
*                  LA    RETURN,ENTRY                                 *
*                  L     LINK,POINTER                                 *
*                  BAL   RETURN,0(RETURN,LINK)                        *
*              WHERE LINK IS THE STANDARD REGISTER FOR THE ADDRESS    *
*                             OF THE CALLED ROUTINE                   *
*                    POINTER CONTAINS THE ADDRESS OF THE DICTIONARY   *
*                             ENTRY ROUTINE                           *
*                    ENTRY IS THE NAME OF THE DICTIONARY FUNCTION     *
*                             REQUIRED (ENTRY NAMES ARE EQUATED TO    *
*                             ABSOLUTE VALUES USED AS DISPLACEMENTS   *
*                             INTO A BRANCH TABLE)                    *
*                    RETURN IS THE STANDARD REGISTER FOR THE RETURN   *
*                             ADDRESS                                 *
*                                                                     *
*INPUT-                                                               *
*   ITEMS EXTRACTED FROM THE SOURCE TEXT BY THE EDITOR, TO BE         *
*   EXCHANGED FOR POINTERS TO GENERATION TIME DICTIONARIES (IN THE    *
*   CASES OF MACRO NAMES, MACRO PARAMETERS, GLOBAL VARIABLES, LOCAL   *
*   VARIABLES, SEQUENCE SYMBOLS, AND OPEN CODE ORDINARY SYMBOLS       *
*   USED IN ATTRIBUTE REFERENCES OR IN MACRO INSTRUCTION OPERANDS)    *
*   OR POINTERS TO OP CODE TABLE ENTRIES (IN THE CASE OF OP CODES).   *
*                                                                     *
*OUTPUT-                                                              *
*   FILE 2 - TEXT SEGMENT DICTIONARY FILE FOR EACH MACRO DEFINITION   *
*          - TEXT SEGMENT DICTIONARY FILE FOR OPEN CODE               *
*   FILE 3 - ORDINARY SYMBOL DEFINITION FILE                          *
*          - MACRO DEFINITION DIRECTORY/OPSYN TABLE                   *
*                                                                     *
*EXTERNAL ROUTINES-                                                   *
*   NONE                                                              *
*                                                                     *
*                                                                     *
*EXITS,NORMAL-                                                        *
*   RETURN TO THE EDITOR WITH THE BYTE 'CONCODE' SET TO A ZERO        *
*   VALUE.                                                            *
*                                                                     *
*EXITS,ERROR-                                                         *
*   RETURN TO THE EDITOR WITH THE BYTE 'CONCODE' SET TO A NON-ZERO    *
*   VALUE, THE SPECIFIC VALUE INDICATING THE ERROR DETECTED.          *
*                                                                     *
*TABLES/WORK AREAS-                                                   *
*   MACRO DEFINITION DIRECTORY - A CHAINED TABLE CONTAINING AN        *
*        ENTRY FOR EACH UNIQUE MACRO NAME ENCOUNTERED IN THE TEXT     *
*        OF ALL MACRO DEFINITIONS AND OPEN CODE, AND AN ENTRY FOR     *
*        OPEN CODE (MERGED WITH THE OPSYN TABLE).                     *
*   VARIABLE SYMBOL DIRECTORY - A CHAINED TABLE CONTAINING AN         *
*        ENTRY FOR EACH VARIABLE SYMBOL (SYSTEM VARIABLE, GLOBAL      *
*        VARIABLE, LOCAL VARIABLE, OR SYMBOLIC PARAMETER)             *
*        ENCOUNTERED IN THE TEXT OF THE MACRO DEFINITION CURRENTLY    *
*        BEING EDITED OR IN THE TEXT OF OPEN CODE.                    *
*   SEQUENCE SYMBOL REFERENCE DIRECTORY - A REVOLVING TABLE           *
*        CONTAINING AN ENTRY FOR THE 10 MOST RECENTLY REFERENCED      *
*        SEQUENCE SYMBOLS ENCOUNTERED IN THE TEXT OF A MACRO          *
*        DEFINITION OR OF OPEN CODE.                                  *
*   ORDINARY SYMBOL REFERENCE DIRECTORY - A REVOLVING TABLE CONTAIN-  *
*        ING AN ENTRY FOR THE 10 MOST RECENTLY REFERENCED ORDINARY    *
*        SYMBOLS ENCOUNTERED IN ATTRIBUTE REFERENCES OR IN MACRO      *
*        INSTRUCTION OPERANDS.                                        *
*   OP CODE TABLE - A CHAINED TABLE CONTAINING AN ENTRY FOR EACH      *
*        OF THE DEFINED ASSEMBLER AND MACHINE OPERATION CODES.        *
*   OPSYN TABLE - A CHAINED TABLE CONTAINING AN ENTRY FOR EACH        *
*        UNIQUE MNEMONIC AFFECTED BY AN OPSYN STATEMENT (MERGED       *
*        WITH THE MACRO DEFINITION DIRECTORY).                        *
*                                                                     *
*ATTRIBUTES-                                                          *
*   REFRESHABLE                                                       *
*                                                                     *
*NOTES-                                                               *
*                                                                     *
*                                                                     *
*                                                                     *
         EJECT
         COPY JCOMMON
         EJECT
         COPY  EDSECT
         EJECT
*
* THIS DSECT MAPS ALL ENTRIES IN THE VARIABLE SYMBOL DIRECTORY.
*
VSDENTRY DSECT
VCHAIN   DS    XL3                      CHAIN POINTER     3 BYTES
VFLAGS   DS    X                        ENTRY FLAGS       1 BYTE
VLNGTH   DS    X                        SYMBOL LENGTH     1 BYTE
VSYMBL   EQU   *                        VARIABLE SYMBOL 1-7 BYTES
         ORG   VSDENTRY                 ORIGIN 0
VTFVAL   DS    X                        META TEXT FLAG    1 BYTE
VGVECTR  DS    XL3                      GBL VECTOR PTR    3 BYTES
         ORG   VGVECTR                  ORIGIN 1
VLDICTR  DS    XL3                      LCL DICTNRY PTR   3 BYTES
         ORG   VGVECTR                  ORIGIN 1
VPVECTR  DS    XL3                      PARAM VCTR PTR    3 BYTES
VGDIMEN  DS    XL2                      GBL DIMEN/SUBSC   2 BYTES
         ORG   VGDIMEN                  ORIGIN 4
VLDIMEN  DS    XL2                      LCL DIMEN/SUBSC   2 BYTES
         ORG   VGDIMEN                  ORIGIN 4
VPPAD    DS    XL2                      PARAM TERM PAD    2 BYTES
*
* THIS DSECT MAPS THE GLOBAL VARIABLE ENTRY IN THE VARIABLE SYMBOL
*            DIRECTORY.
*
GBLNTRY  DSECT
GCHAIN   DS    XL3                      CHAIN POINTER     3 BYTES
GFLAGS   DS    X                        FLAGS             1 BYTE
GLNGTH   DS    X                        SYMBOL LENGTH     1 BYTE
GSYMBL   EQU   *                        VARIABLE SYMBOL 2-8 BYTES
         ORG   GBLNTRY                  ORIGIN 0
GTFVAL   DS    X                        TEXT FLAG VALUE   1 BYTE
GVECTR   DS    XL3                      VECTOR POINTER    3 BYTES
GDIMEN   DS    XL2                      DIMENSION         2 BYTES
*
* THIS DSECT MAPS THE LOCAL VARIABLE ENTRY IN THE VARIABLE SYMBOL
*            DIRECTORY.
*
LCLNTRY  DSECT
LCHAIN   DS    XL3                      CHAIN POINTER     3 BYTES
LFLAGS   DS    X                        FLAGS             1 BYTE
LLNGTH   DS    X                        SYMBOL LENGTH     1 BYTE
LSYMBL   EQU   *                        VARIABLE SYMBOL 2-8 BYTES
         ORG   LCLNTRY                  ORIGIN 0
LTFVAL   DS    X                        TEXT FLAG VALUE   1 BYTE
LDICTR   DS    XL3                      DICTIONARY PTR    3 BYTES
LDIMEN   DS    XL2                      DIMENSION         2 BYTES
*
* THIS DSECT MAPS THE MACRO PARAMETER ENTRY IN THE VARIABLE SYMBOL
*            DIRECTORY.
*
PRMNTRY  DSECT
PCHAIN   DS    XL3                      CHAIN POINTER     3 BYTES
PFLAGS   DS    X                        FLAGS             1 BYTE
PLNGTH   DS    X                        SYMBOL LENGTH     1 BYTE
PSYMBL   EQU   *                        VARIABLE SYMBOL 2-8 BYTES
         ORG   PRMNTRY                  ORIGIN 0
PTFVAL   DS    X                        TEXT FLAG VALUE   1 BYTE
PVECTR   DS    XL3                      VECTOR POINTER    3 BYTES
PPAD     DS    XL2                      PADDING           2 BYTES
*
* THIS DSECT MAPS THE OP CODE TABLE ENTRY.
*
OPNTRY   DSECT
OCHAIN   DS    XL2                      CHAIN POINTER     2 BYTES
OFLAGS   DS    X                        FLAGS             1 BYTE
OMNEM    EQU   *                        MNEMONIC        1-8 BYTES
         ORG   OPNTRY                   ORIGIN 0
OFLAGA   DS    X                        SWITCH CODES      1 BYTE
OINTCD   DS    X                        INTERNAL OP COD   1 BYTE
OMASK    DS    X                        MASK, EXT MNEMS   1 BYTE
OINTCD2  EQU   OMASK                    OP (2ND BYTE)     1 BYTE
*
* THIS DSECT MAPS THE MACRO DEFINITION DIRECTORY ENTRY.
*
MDDNTRY  DSECT
MCHAIN   DS    XL3                      CHAIN PTR         3 BYTES
MFLAGS   DSW   TSEDIT,                  ON-SEGMENT EDITED              X
               OCTS,                    ON-OPEN CODE ENTRY             X
               FLUSH,                   ON-MACRO FLUSHED               X
               DELETE,,                 ON-MACRO DELETED VIA OPSYN     X
               MNL1,MNL2,MNL3           MACRO NAME LENGTH
MSYMBL   DS    XL8                      SYMBOL (PADDED)   8 BYTES
MVECTR   DS    XL3                      VECTOR POINTER    3 BYTES
MTXTNP   DS    XL8                      TEXT FILE N/P     8 BYTES
MTSDNP   DS    XL8                      DICT FILE N/P     8 BYTES
MGBLSZ   DS    XL3                      GBL VCTR SIZE     3 BYTES
MSEQSZ   DS    XL3                      SEQ SYM DICT SIZE 3 BYTES
MLCLSZ   DS    XL3                      LCL DICT SIZE     3 BYTES
MDDEND   EQU   *
*
* THIS DSECT MAPS THE OPSYN TABLE ENTRY.
*
OPSYNTRY DSECT
OPSYNCH  DS    XL3                      CHAIN POINTER  3 BYTES
OPSYNFLG DSW   ,,,,                     ROOM FOR OP CODE FLAGS         X
               OMAC,                    MACRO OPSYN ENTRY              X
               ODEL,                    DELETED OPSYN ENTRY            X
               OPREV                    PREVIOUS OPSYN ENTRY USED
OPSYNATT DS    XL3                      ATTRIBUTES
         ORG   OPSYNATT                 OVERLAY WITH ALTERNATE
OPSYNCHN DS    XL3                      MACRO CHAIN POINTER
ONAMEL   DS    XL1                      NAME LENGTH
ONAME    DS    XL8                      NAME
OPSYND   EQU   *                        END OF DSECT
OPSYNLN  EQU   OPSYND-OPSYNTRY          OPSYN ENTRY LENGTH
*
* THIS DSECT MAPS THE SEQUENCE SYMBOL REFERENCE DIRECTORY ENTRY.
*
SSDIR    DSECT
SSSYM    DS    XL8                      SEQ SYMB (PADDED) 8 BYTES
STFVAL   DS    X                        TEXT FLAG VALUE   1 BYTE
SSRDP    DS    XL3                      DICT POINTER      3 BYTES
SSPAD    DS    XL2                      PADDING           2 BYTES
SSDIRND  EQU   *
*
* THIS DSECT MAPS THE ORDINARY SYMBOL REFERENCE DIRECTORY ENTRY.
*
OSDIR    DSECT
OSSYM    DS    XL8                      ORD SYMB (PADDED) 8 BYTES
OTFVAL   DS    X                        TEXT FLAG VALUE   1 BYTE
OSRDP    DS    XL3                      DICT POINTER      3 BYTES
OSPAD    DS    XL2                      PADDING           2 BYTES
OSDIRND  EQU   *
*
* THIS DSECT MAPS THE LOGICAL RECORD PUT TO THE TEXT SEGMENT          *
*            DICTIONARY FILE FOR A GLOBAL DEFINITION.                 *
*
GBLDEF   DSECT
GDEFRL   DS    XL2                      RECORD LENGTH     2 BYTES
GDEFRT   DS    X'00'                    RECORD TYPE       1 BYTE
GDEFF    DS    X                        FLAGS             1 BYTE
GDEFSL   DS    X                        SYMBOL LENGTH     1 BYTE
GDEFVS   EQU   *                        VARIABLE SYMBOL 2-8 BYTES
         ORG   GBLDEF                   ORIGIN 0
GDEFTF   DS    X                        TEXT FLAG VALUE   1 BYTE
GDEFVP   DS    XL3                      VECTOR POINTER    3 BYTES
GDEFD    DS    XL2                      DIMENSION         2 BYTES
*
* THIS DSECT MAPS THE LOGICAL RECORD PUT TO THE TEXT SEGMENT          *
*            DICTIONARY FILE FOR A SEQUENCE SYMBOL DEFINITION.        *
*
SSDEF    DSECT
SDEFRL   DS    XL2                      RECORD LENGTH     2 BYTES
SDEFRT   DS    X'04'                    RECORD TYPE       1 BYTE
SDEFNP   DS    XL8                      NOTE/POINT ADDR   8 BYTES
SDEFSL   DS    XL1                      SYMBOL LENGTH     1 BYTE
SDEFSS   EQU   *                        SEQUENCE SYMBOL 2-8 BYTES
*
* THIS DSECT MAPS THE LOGICAL RECORD PUT TO THE TEXT SEGMENT          *
*            DICTIONARY FILE FOR A SEQUENCE SYMBOL REFERENCE.         *
*
SSREF    DSECT
SREFRL   DS    XL2                      RECORD LENGTH     2 BYTES
SREFRT   DS    X'08'                    RECORD TYPE       1 BYTE
SREFDP   DS    XL3                      DICTIONARY PTR    3 BYTES
SREFSL   DS    XL1                      SYMBOL LENGTH     1 BYTE
SREFSS   EQU   *                        SEQUENCE SYMBOL 2-8 BYTES
*
* THIS DSECT MAPS THE LOGICAL RECORD PUT TO THE TEXT SEGMENT          *
*            DICTIONARY FILE FOR AN ORDINARY SYMBOL REFERENCE.        *
*
OSREF    DSECT
OREFRL   DS    XL2                      RECORD LENGTH     2 BYTES
OREFRT   DS    X'0C'                    RECORD TYPE       1 BYTE
OREFDP   DS    XL3                      DICTIONARY PTR    3 BYTES
OREFSL   DS    XL1                      SYMBOL LENGTH     1 BYTE
OREFOS   EQU   *                        ORDINARY SYMBOL 1-8 BYTES
*
* THIS DSECT MAPS THE LOGICAL RECORD PUT TO THE ORDINARY SYMBOL
*            DEFINITION FILE.
*
         COPY  JTEXT
*
* THIS DSECT MAPS THE END-OF-SEGMENT RECORD PUT TO THE TEXT SEGMENT
*            DICTIONARY FILE.
*
ENDSEG   DSECT
ESEGRL   DS    XL2                      RECORD LENGTH     2 BYTES
ESEGRT   DS    X'10'                    RECORD TYPE       1 BYTE
*
* THIS DSECT MAPS THE END-OF-FILE RECORD PUT TO THE TEXT SEGMENT
*            DICTIONARY FILE AND THE ORDINARY SYMBOL DEFINITION FILE.
*
ENDFIL   DSECT
EFILRL   DS    XL2                      RECORD LENGTH     2 BYTES
EFILRT   DS    X'FF'                    RECORD TYPE       1 BYTE
*
         COPY  JTMTXT
         EJECT
         COPY  JERMSGCD
         EJECT
WORK4    EQU   R6                       SCRATCH REGISTER
MODCOMM  EQU   R2                       PTR REGISTER, EDSECT BASE
LNGTHREG EQU   R3                       SYMBOL LENGTH REGISTER
PARMREG  EQU   R4                       SYMBOL POINTER REGISTER
VSDPTR   EQU   R5                       PTR TO ENTRY IN VSD
SSRDPTR  EQU   R5                       PTR TO ENTRY IN SSRD
OCHNPTR  EQU   R5                       PTR TO ENTRY IN OP CODE TABLE
WORK3    EQU   R5                       SCRATCH REGISTER
WORK2    EQU   R6                       SCRATCH REGISTER
WORK1    EQU   R7                       SCRATCH REGISTER
RTNLNK   EQU   R9                       LINKAGE REGISTER
BUFPTR   EQU   R11                      PTR TO RECORD IN BUFFER
EOPAIR1  EQU   R14                      EVEN REGISTER OF PAIR
HASHO    EQU   R14                      OP CODE TABLE HASH VALUE REG
HASHV    EQU   R15                      VSD HASH VALUE REGISTER
EOPAIR2  EQU   R15                      ODD REGISTER OF PAIR
SSRDNE   EQU   10                       NO. OF SSRD ENTRIES
SSRDEL   EQU   SSDIRND-SSDIR            LENGTH OF AN SSRD ENTRY
SSRDLNGT EQU   SSRDNE*SSRDEL            LENGTH OF WHOLE SSRD
OSRDPTR  EQU   SSRDPTR                  PTR TO ENTRY IN OSRD
OSRDNE   EQU   SSRDNE                   NO. OF OSRD ENTRIES
OSRDEL   EQU   SSRDEL                   LENGTH OF AN OSRDENTRY
OSRDLNGT EQU   SSRDLNGT                 LENGTH OF WHOLE OSRD
OSALNGT  EQU   6                        LENGTH OF ORD SYMB ATTRIBUTES
GDEFTYPE EQU   0                        TYPE FOR GBL DEFIN RCD
SDEFTYPE EQU   4                        TYPE FOR SEQ SYMB DEFIN RCD
SSREFTYP EQU   8                        TYPE FOR SEQ SYMB REFER RCD
OSREFTYP EQU   12                       TYPE FOR ORD SYMB REFER RCD
ESEGTYPE EQU   16                       TYPE FOR END-OF-SEGMENT RCD
EFILTYPE EQU   255                      TYPE FOR END-OF-FILE RCD
MINSPACE EQU   512                      MINIMUM WORK SPACE IN DBL WDS
PVPTRLNG EQU   3                        LENGTH OF ENTRY IN PARAM VCTRS
GVPTRLNG EQU   3                        LENGTH OF ENTRY IN GBL VECTOR
VSDHTLNT EQU   128*3                    LENGTH OF VAR SYMB DIR HSH TBL
MDVEL    EQU   19                       LENGTH OF ENTRY IN MDV
SAVMDDPT EQU   JDPASS                   SAVE AREA, MDD ADDRESS
SAVMDDLN EQU   JDPASS+D8                SAVE AREA, MDD LENGTH
SAVMDDCN EQU   JDPASS+D12               SAVE AREA, MDD ENTRY CHAIN
SAVMDDCT EQU   JDPASS+D16               SAVE AREA, MDD ENTRY COUNT
SAVOPSCN EQU   JDPASS+D20               SAVE AREA, OPSYN ENTRY CHAIN
PAIR1E   EQU   R4                       EVEN REGISTER OF PAIR
PAIR1O   EQU   R5                       ODD REGISTER OF PAIR
PAIR2E   EQU   R6                       EVEN REGISTER OF PAIR
PAIR2O   EQU   R7                       ODD REGISTER OF PAIR
VSDEL    EQU   19                       MAX, LENGTH OF VSD ENTRY
MINRECSZ EQU   18                       MINIMUM I/O LENGTH
WORK5    EQU   R1                       SCRATCH REGISTER
NAMEPTR  EQU   R5                       OPSYN SYNONYM PTR REGISTER
ENTRYPTR EQU   R6                       PTR TO ENTRY IN OPSYN TABLE
SCANPTR  EQU   R7                       PTR TO SYNONYM ENTRY REGISTER
D256     EQU   256                      SYMBOLIC SDT (256)
         EJECT
         JCSECT (X1J00)
         JMODID
*DICTIONARY ENTRY ROUTINE - ALL CALLS TO THE EDIT PHASE DICTIONARY    *
*   ROUTINES ENTER THROUGH THE FOLLOWING BRANCH TABLE WHICH PROVIDES  *
*   THE LINK TO THE REQUIRED ROUTINE.                                 *
*                                                                     *
         USING DICTENTR,R12
DICTENTR B     DICTSAVE                 GO DIRECTLY TO COMMON ENTRY
         DC    AL2(PHASENT-DICTENTR)    DISPL TO PHASENT ROUTINE
         DC    AL2(MACRENT-DICTENTR)    DISPL TO MACRENT ROUTINE
         DC    AL2(MACREND-DICTENTR)    DISPL TO MACRENT  ROUTINE
         DC    AL2(OPENENT-DICTENTR)    DISPL TO OPENENT  ROUTINE
         DC    AL2(OPENEND-DICTENTR)    DISPL TO OPENEND  ROUTINE
         DC    AL2(VARBSYMR-DICTENTR)   DISPL TO VARBSYMR ROUTINE
         DC    AL2(SEQSYMBR-DICTENTR)   DISPL TO SEQSYMBR ROUTINE
         DC    AL2(SEQSYMBD-DICTENTR)   DISPL TO SEQSYMBD ROUTINE
         DC    AL2(ORDSYMBR-DICTENTR)   DISPL TO ORDSYMBR ROUTINE
         DC    AL2(ORDSYMBD-DICTENTR)   DISPL TO ORDSYMBD ROUTINE
         DC    AL2(VARBSYMD-DICTENTR)   DISPL TO VARBSYMD ROUTINE
         DC    AL2(OPERCODE-DICTENTR)   DISPL TO OPERCODE ROUTINE
         DC    AL2(OPSYNBLD-DICTENTR)   DISPL TO OPSYNBLD ROUTINE
         SPACE 5
         JENTRY (X1J01=DICTENTR)
         EJECT
*
* THIS SUBROUTINE IS USED BY ALL THE DICTIONARY ROUTINES TO SAVE
*        REGISTERS AND ESTABLISH ADDRESSABILITY.
*
DICTSAVE STM   R2,R9,REGSTACK           SAVE REGISTER FOR EDITOR
         LR    R8,R12                   SET UP BASE REGISTER
         USING DICTENTR,R8
         DROP  R12
         LH    R9,DDNDX                 PICK UP ENTRY INDICATOR
         LH    R9,DICTENTR+D4(R9)       GET DISPL TO REQ'D ROUTINE
         B     DICTENTR(R9)             LINK TO DICTIONARY ROUTINE
         SPACE 10
*
* THIS ROUTINE IS THE COMMON EXIT POINT FOR THE DICTIONARY ROUTINES.
*
DICTEXIT LM    R2,R9,REGSTACK           RESTORE EDITOR'S REGISTERS
         BR    R9                       RETURN TO EDITOR
         EJECT
*PHASENT - THIS ROUTINE IS CALLED AT THE START OF THE EDIT PHASE.     *
*   ITS FUNCTION IS TO GET AND ALLOCATE THE SPACE REQUIRED FOR THE    *
*   VARIOUS COLLECTION TIME DICTIONARIES, TO PERFORM THE GENERAL      *
*   INITIALIZATION FOR THOSE DICTIONARIES, AND TO INITIALIZE THE      *
*   MODULE COMMON SPACE USED BY ALL THE EDIT PHASE DICTIONARY         *
*   ROUTINES.                                                         *
*        INPUT - NONE.                                                *
*        OUTPUT - NONE.                                               *
*                                                                     *
PHASENT  EQU   *
         XC    DICTCOMS(DICTCOME-DICTCOMS),DICTCOMS INITIALIZE COMMON
         LH    R11,=H'32000'            SET UP MAX SPACE VALUE
         JGETCORE MINDBL=MINSPACE,MAXDBL=(R11) GET FREE SPACE
         ST    R10,FREESTRT             KEEP ADDR FOR LATER RELEASE
         AR    R11,R10                  GET HIGH BYTE ADDR AND SAVE AS
         ST    R11,MDDSTRT              MACRO DEF DIR BASE ADDR
         ST    R11,MDDSLOT              SAVE MDD PTR FOR FIRST MACRO
         ST    R10,SSRDSTRT             SAVE SEQ SYMB REF DIR PTR
         LA    R10,SSRDLNGT(,R10)       DISPLACE BY SEQ SYMB REF DIR
         ST    R10,OSRDSTRT             SAVE ORD SYMB REF DIR PTR
         MVI   D0(R10),JBLANK           INSERT CHARACTER TO CLEAR
         MVC   D1(OSRDLNGT-D1,R10),D0(R10) ORDINARY SYMBOL REFER DIRECT
         LA    R10,OSRDLNGT(,R10)       DISPLACE BY ORD SYMB REF DIR
         ST    R10,VSDSTRT              SAVE VAR SYMB DIR BASE ADDR
         XC    D0(VSDHTLNT-256,R10),D0(R10)  CLEAR VSD HASH TABLE,
         XC    VSDHTLNT-256(256,R10),VSDHTLNT-256(R10) PARTS 1 AND 2
         MVC   GTMVALOC,=F'19'          INITIALIZE MDV POINTER
         MVC   SSDLNGTH(D12),=AL1(0,L'JNOTEVAL,JTMSEQ,SSREFTYP,0,0,0,0,X
               0,OSALNGT,JTMOSA,OSREFTYP) SET UP TABLE DATA FOR SYMBOL X
               REFERENCES - SEQUENCE AND ORDINARY
         B     DICTEXIT                 RETURN
         EJECT
*MACRENT - THIS ROUTINE IS CALLED AT THE START OF EDITING A MACRO     *
*   DEFINITION. ITS FUNCTION IS TO INITIALIZE THAT PART OF MODULE     *
*   COMMON USED IN EDITING MACRO DEFINITIONS, TO INITIALIZE THE       *
*   VARIABLE SYMBOL DIRECTORY, TO INITIALIZE THE SEQUENCE SYMBOL      *
*   REFERENCE DIRECTORY, TO INITIALIZE THE TEXT SEGMENT DICTIONARY    *
*   FILE, AND TO NOTE THE START OF THE MACRO DEFINITION TEXT FOR      *
*   THE ENTRY IN THE MACRO DEFINITION DIRECTORY.                      *
*        INPUT - THE 'MACRO' STATEMENT HAS BEEN PUT TO THE TEXT       *
*                FILE PRIOR TO ENTRY.                                 *
*        OUTPUT - NONE.                                               *
*                                                                     *
MACRENT  EQU   *
         XC    MDINITS(TSINITE-MDINITS),MDINITS REINITIALIZE COMMON
         BAL   WORK3,COMNINIT           GO TO COMMON INITIALIZATION
         JNOTE FILE=FILE1               NOTE THE TEXT FILE
         MVC   NOTESAVE,JNOTEVAL        SAVE N/P ADDR FOR MDD ENTRY
         LA    WORK5,SYSNDX             POINT TO SYST LCL, GBL LIST
         B     VSDINIT                  GO TO ENTER THEN IN VSD
         EJECT
*MACREND - THIS ROUTINE IS CALLED AT THE END OF EDITING A MACRO       *
*   DEFINITION. FOR A MACRO SUCCESSFULLY EDITED, ITS FUNCTION IS TO   *
*   CLOSE OUT THE TEXT SEGMENT DICTIONARY FILE, TO INSERT THE LOCAL   *
*   DICTIONARY, GLOBAL VECTOR, AND SEQUENCE SYMBOL REFERENCE DICTION- *
*   ARY ALLOCATIONS IN THE ENTRY FOR THE MACRO DEFINITION IN THE      *
*   MACRO DEFINITION DIRECTORY, TO INSERT THE POINTER TO THE MACRO    *
*   DEFINITION EDITED TEXT AND THE POINTER TO THE TEXT SEGMENT        *
*   DICTIONARY FILE SEGMENT FOR THE MACRO DEFINITION IN THE ENTRY     *
*   FOR THE MACRO DEFINITION IN THE MACRO DEFINITION DIRECTORY AND    *
*   TO FLAG THE MACRO AS EDITED. FOR A MACRO NOT SUCCESSFULLY EDITED, *
*   ITS FUNCTION IS TO FLAG THE MACRO AS AN UNDEFINED OP CODE AND     *
*   TO FLAG THE MACRO AS EDITED. IF LIBRARY MACROS ARE BEING EDITED,  *
*   THE NEXT NAME IS RETURNED TO THE EDITOR.                          *
*        INPUT - IF 'SKPMND' IS ON, 'SNOSMCRO', 'SBDPROTO', OR        *
*                'SNOSYSMD' INDICATE THE CAUSE FOR ABORTING THE       *
*                MACRO DEFINITION.                                    *
*        OUTPUT - NONE.                                               *
*                                                                     *
MACREND  EQU   *
         GOIF  SKPMND,OFF=MRSKPA        BRANCH IF NORMAL END OF EDIT
         GOIF  SSYSMD,ON=MRSKP          SKIP IF EDITING SYS MACS
         GOIF  SMDDENTR,OFF=DICTEXIT    EXIT IF NO MDD ENTRY WAS MADE
MRSKP    L     WORK1,CURMDDPT           GET MDD ENTRY POINTER
         USING MDDNTRY,WORK1
         SET   FLUSH,ON                 INDICATE EDIT ABORTED
         MVI   MTSDNP+(L'MTSDNP-D1),D4  INDICATE NO SUCH MACRO
         GOIF  SNOSYSMD,ON=MRSKPB       SKIP IF THATS THE ERROR
         GOIF  SSYSMD,OFF=MRSKPB        BR IF PRGMR MACRO
         MVI   MTSDNP+(L'MTSDNP-D1),D8  INDICATE BOGUS PROTOTYPE
         GOIF  SBDPROTO,ON=MRSKPB       SKIP IF THATS THE ERROR
         MVI   MTSDNP+(L'MTSDNP-D1),D12 INDICATE NO MACRO STMT
         GOIF  SNOSMCRO,ON=MRSKPB       SKIP IF THATS THE ERROR
         MVI   MTSDNP+(L'MTSDNP-D1),D16 INDICATE MEMBER, MACRO UNALIKE
         GOIF  LSTSYSMS,OFF=MRSKPB      SKIP IF THATS THE ERROR
         MVI   MTSDNP+(L'MTSDNP-D1),D20 DICT OVERFLOW ON THIS SYS MAC
         B     MRSKPB                   GO TO FINISH MDD ENTRY
MRSKPA   EQU   *
         BAL   WORK3,COMNEND            GO TO COMMON TERMINATION
         MVC   MTXTNP(L'MTXTNP+L'MTSDNP),NOTESAVE                      X
               INSERT TEXT AND TSDF N/P ADDRS IN MDD ENTRY
MRSKPB   EQU   *
         SET   SMDDENTR,OFF             RESET MDD ENTRY MADE SWITCH
         SET   TSEDIT,ON                INDICATE MACRO EDITED
         GOIF  SSYSMD,ON=EDITSYSM,      CONTINUE LIBRARY MACRO EDIT    X
               ELSE=DICTEXIT            RETURN OTHERWISE
         DROP  WORK1
         EJECT
*OPENENT - THIS ROUTINE IS CALLED AT THE START OF EDITING OPEN CODE.  *
*   ITS FUNCTION IS TO INITIALIZE THAT PART OF MODULE COMMON USED IN  *
*   EDITING OPEN CODE, TO INITIALIZE THE VARIABLE SYMBOL DIRECTORY,   *
*   TO INITIALIZE THE TEXT SEGMENT DICTIONARY FILE, TO INITIALIZE     *
*   THE SEQUENCE SYMBOL REFERENCE DIRECTORY, AND TO INITIALIZE THE    *
*   ENTRY FOR OPEN CODE IN THE MACRO DEFINITION DIRECTORY.            *
*        INPUT - NONE.                                                *
*        OUTPUT - APPROPRIATE FLAGS IN 'CONCODE' IF INSUFFICIENT      *
*                 SPACE REMAINS FOR THE MACRO DEFINITION DIRECTORY    *
*                 ENTRY.                                              *
*                                                                     *
OPENENT  EQU   *
         XC    OCINITS(TSINITE-OCINITS),OCINITS REINITIALIZE COMMON
         BAL   WORK3,COMNINIT           GO TO COMMON INITIALIZATION
         L     WORK1,MDDSLOT            GET PRESENT END OF MDD PTR
         SH    WORK1,=AL2(MDDEND-MDDNTRY) ADJUST FOR OPEN CODE ENTRY
         C     WORK1,VSDSLOT            LOOK FOR OVERLAP WITH VSD
         BL    OERR                     IF OVERLAP, GO FLAG THE ERROR
         ST    WORK1,MDDSLOT            PUT END OF MDD PTR BACK
         ST    WORK1,CURMDDPT           SET CURRENT ENTRY PTR ALSO
         USING MDDNTRY,WORK1
         MVC   MCHAIN,MDDCHN+(L'MDDCHN-L'MCHAIN) INSERT CHAIN PTR
         XC    MFLAGS(L'MFLAGS+L'MSYMBL+L'MVECTR),MFLAGS               X
               CLEAR LENGTH,NAME, GT MDV POINTER
         L     WORK2,MDDSTRT            PICK UP TABLE BASE
         SR    WORK2,WORK1              GET DISPL TO LATEST ENTRY
         ST    WORK2,MDDCHN             SAVE AS NEW FIRST CHAIN PTR
         L     WORK2,MDDCNT             PICK UP NUMBER OF MDD ENTRIES
         LA    WORK2,D1(,WORK2)         INCREMENT FOR NEW ENTRY
         ST    WORK2,MDDCNT             SAVE NEW MDD ENTRY COUNT
         SET   OCTS,ON                  INDICATE OPEN CODE ENTRY
         LA    WORK5,SYSPRM             POINT TO SYST GBL LIST
         B     VSDINIT                  GO TO ENTER THEM IN VSD
         DROP  WORK1
         EJECT
*OPENEND - THIS ROUTINE IS CALLED AT THE END OF EDITING OPEN CODE.    *
*   ITS FUNCTION IS TO CLOSE OUT THE TEXT SEGMENT DICTIONARY FILE,    *
*   INSERT THE LOCAL DICTIONARY, GLOBAL VECTOR, AND SEQUENCE SYMBOL   *
*   REFERENCE DICTIONARY ALLOCATIONS IN THE ENTRY FOR OPEN CODE IN    *
*   THE MACRO DEFINITION DIRECTORY. IF THERE ARE LIBRARY MACROS       *
*   TO BE EDITED, THE FIRST NAME IS RETURNED,TO THE EDITOR. WHEN      *
*   ALL LIBRARY MACROS ARE EDITED, 'LSTSYSMS' IS SET ON, AND THE      *
*   PHASE TERMINATION IS PERFORMED.                                   *
*        INPUT - NONE.                                                *
*        OUTPUT - A POINTER IN R11 TO THE LENGTH OF THE NAME (1       *
*                 BYTE) IMMEDIATELY FOLLOWED BY THE NAME ITSELF       *
*                 (PADDED WITH ZEROS TO 8 BYTES) OF A LIBRARY MACRO   *
*                 TO BE EDITED.                                       *
*                                                                     *
OPENEND  EQU   *
         BAL   WORK3,COMNEND            GO TO COMMON TERMINATION
         USING MDDNTRY,WORK1
         MVC   MTSDNP,SAVENOTE          INSERT TSDF N/P ADDR IN MDD
         XC    MTXTNP,MTXTNP            CLEAR TEXT N/P ADDR FOR O.C.
         SET   TSEDIT,ON                INDICATE OPEN CODE EDITED
EDITSYSM GOIF  LSTSYSMS,ON=PHASEND      SKIP IT ALL IF OVERLAP OCCURRED
         MVC   HIBYTE0,MDDCHN           SET UP PTR FOR FULL CHAIN SCAN
SYSEDTLP L     WORK1,MDDSTRT            PICK UP TABLE BASE
         S     WORK1,HIBYTE0            DISPLACE TO NEXT CHAIN ENTRY
         C     WORK1,MDDSTRT            SEE IF END OF CHAIN REACHED
         BE    ENDSYSM                  BRANCH IF YES
         GOIF  TSEDIT,OFF=EDITIT        GO TO EDIT IF NOT ALREADY
         MVC   HIBYTE0+(L'HIBYTE0-L'MCHAIN)(L'MCHAIN),MCHAIN           X
               PICK UP PTR TO NEXT ENTRY IN CHAIN
         B     SYSEDTLP                 GO BACK TO START OF SEARCH
EDITIT   ST    WORK1,CURMDDPT           SAVE PTR TO ENTRY BEING EDITED
         LA    R10,MSYMBL               GET NAME PTR FOR EDITOR
         B     DICTEXIT                 RETURN
ENDSYSM  SET   LSTSYSMS,ON              ALL LIBRARY MACROS EDITED
         DROP  WORK1
         EJECT
*PHASEND - THIS ROUTINE IS CALLED AT THE END OF EDITING ALL LIBRARY   *
*   MACROS. ITS FUNCTION IS TO CLOSE OUT THE ORDINARY SYMBOL          *
*   DEFINITION FILE, OUTPUT THE MACRO DEFINITION DIRECTORY, CLOSE     *
*   OUT THE TEXT SEGMENT DICTIONARY FILE, TO PUT IN COMMON THE DATA   *
*   REQUIRED BY THE DICTIONARY INTERLUDE PHASE, AND TO RELEASE THE    *
*   DICTIONARY SPACE.                                                 *
*        INPUT - NONE.                                                *
*        OUTPUT - NONE.                                               *
*                                                                     *
PHASEND  EQU   *
         JPUTL FILE=FILE3,BUFREQ=L'EFILRL+L'EFILRT GET RECORD LENGTH
         USING ENDFIL,BUFPTR
         MVC   EFILRL(L'EFILRL+L'EFILRT),=AL1(0,L'EFILRL+L'EFILRT,EFILTX
               YPE) INSERT RECORD LENGTH AND TYPE
         JTRUNC FILE=FILE2              COMPLETE OUTPUT, FILE 2
         JTRUNC FILE=FILE3              COMPLETE OUTPUT, FILE 3
         JPOINT FILE=FILE2,NEXT=START   REWIND FOR INTERLUDE
         MVC   PIOPARMA,MDDSLOT         SET UP BUFFER ADDRESS
         L     WORK1,MDDSTRT            GET PTR TO MDD HIGH END
         S     WORK1,MDDSLOT            GET LENGTH OF MDD
         ST    WORK1,PIOPARMB           SET UP WRITE LENGTH
         MVC   SAVMDDLN(L'PIOPARMB),PIOPARMB LENGTH IN COMMON
         LH    R5,JMAXRL3               SET UP MAXIMUM RECORD THIS FILE
         LA    R6,FILE3                 SET UP FILE POINTER
         BAL   R7,BUFRITE               GO PUT MDD TO FILE 3
         MVC   SAVMDDPT(L'JNOTEVAL),JNOTEVAL  SAVE NOTE/POINT AND MDD
         MVC   SAVMDDCN(L'MDDCHN),MDDCHN PASS MDD CHAIN LINK TO INTERL
         MVC   SAVMDDCT(L'MDDCNT),MDDCNT PASS MACRO NAME COUNT ALSO
         MVC   SAVOPSCN(L'OPSCHN),OPSCHN PASS OPSYN CHN PTR TO X2A
         JFRECORE ADDR=FREESTRT         RELEASE DIRECTORY SPACE
         B     DICTEXIT                 RETURN TO EDITOR
         DROP  BUFPTR
         EJECT
*MACRNAME - THIS ROUTINE IS CALLED DURING THE EDITING OF A MACRO      *
*   DEFINITION WHEN THE MACRO NAME IS ENCOUNTERED ON THE PROTOTYPE    *
*   STATEMENT. ITS FUNCTION IS TO ENTER THE MACRO NAME IN THE MACRO   *
*   DEFINITION DIRECTORY, IF IT HAS NOT BEEN PREVIOUSLY ENTERED, AND  *
*   TO RETURN TO THE EDITOR A POINTER TO THE APPROPRIATE ENTRY IN THE *
*   GENERATION TIME MACRO DEFINITION VECTOR.                          *
*        INPUT - THE LENGTH OF THE MNEMONIC IN R11.                   *
*              - A POINTER TO THE MNEMONIC (1-8 BYTES) IN R10.        *
*                THE MNEMONIC HAS BEEN VERIFIED AS A VALID SYMBOL.    *
*                THE MNEMONIC HAS NOT BEEN FOUND IN THE OP CODE TABLE.*
*        OUTPUT - A POINTER IN R11 TO THE APPROPRIATE ENTRY IN THE    *
*                 MACRO DEFINITION DIRECTORY AND APPROPRIATE FLAGS    *
*                 SET IN THE BYTE 'IOCID'.                            *
*               - APPROPRIATE FLAGS IN 'CONCODE' IF THE NAME OF A     *
*                 PROGRAMMER MACRO DUPLICATES A PREVIOUS ONE OR IF    *
*                 INSUFFICIENT SPACE REMAINS FOR THE MACRO DEFINI-    *
*                 TION ENTRY OF IF THE NAME ON THE PROTOTYPE IN A     *
*                 LIBRARY MACRO IS DIFFERENT FROM THE NAME THE        *
*                 MACRO IS CATALOGED UNDER.                           *
*                                                                     *
MACRNAME EQU   *
         MVC   JDWORD,=8AL1(JBLANK)     SET UP PAD FOR MACRO NAME
         EX    LNGTHREG,MACRNMOV        SET UP MACRO NAME WITH PAD
         MVC   HIBYTE0,MDDCHN           SET UP PTR TO START CHAIN SERCH
MDDSCAN  L     WORK1,MDDSTRT            PICK UP TABLE BASE
         S     WORK1,HIBYTE0            DISPLACE TO NEXT ENTRY IN CHAIN
         C     WORK1,MDDSTRT            SEE IF END OF CHAIN REACHED
         BER   R4                       BRANCH IF YES
         USING MDDNTRY,WORK1
         GOIF  DELETE,ON=MSCANB         DELETED, IGNORE
         CLC   JDWORD,MSYMBL            COMPARE MACRO NAMES
         BE    MSCANA                   BRANCH IF NAMES MATCH
MSCANB   EQU   *
         MVC   HIBYTE0+(L'HIBYTE0-L'MCHAIN)(L'MCHAIN),MCHAIN           X
               PICK UP PTR IN ENTRY TO NEXT ENTRY IN CHAIN
         B     MDDSCAN                  GO BACK TO START OF SEARCH
MSCANA   GOIF  SXPRTO,OFF=MACDONE       SEE IF PRGMR MACRO PROTOTYPE
         GOIF  TSEDIT,ON=MACERR         IF ENTRY ALREADY EDITED, ERROR
         ST    WORK1,CURMDDPT           SET CURRENT PTR TO THIS ENTRY
         SET   SMDDENTR,ON              SHOW THAT MDD ENTRY WAS MADE
MACDONE  LA    R11,MVECTR               GET PTR FOR EDITOR TO MDV SLOT
         MVI   IOCID,J0                 SET OP CODE FLAGS PROPERLY
         B     D4(R4)                   RETURN
MACERR   MVC   DSEVCD(D2),=AL1(SEV10,ERR10) INDICATE DUPL PRGMR MACROS
         B     D4(R4)                   RETURN
MACENTRY EQU   *
         GOIF  SSYSMD,OFF=MAKENTRY      MAKE CHECK ONLY IN SYST MACROS
         GOIF  SXPRTO,OFF=MAKENTRY      SEE IF BOOK NAME AND MACRO NAME
         MVC   DSEVCD(D2),=AL1(SEV11,ERR11) DO NOT AGREE, FLAG IF NOT
         B     DICTEXIT                 EXIT
MAKENTRY EQU   *
         L     WORK1,MDDSLOT            GET END OF DICT PTR
         SH    WORK1,=AL2(MDDEND-MDDNTRY) ALLOW ROOM FOR THIS ENTRY
         C     WORK1,VSDSLOT            LOOK FOR OVERLAP WITH VSD
         BL    OERR                     IF OVERLAP, GO FLAG THE ERROR
         ST    WORK1,MDDSLOT            IF NOT, UPDATE NEXT SLOT PTR
         MVC   MCHAIN,MDDCHN+(L'MDDCHN-L'MCHAIN) INSERT CHAIN PTR
         STC   LNGTHREG,MFLAGS          INSERT FLAGS IN MDD ENTRY
         MVC   MSYMBL,JDWORD            INSERT NAME IN MDD ENTRY
         MVC   MVECTR,GTMVALOC+(L'GTMVALOC-L'MVECTR)   INSERT MACRO    X
               DEFINITION VECTOR PTR IN MDD ENTRY
         XC    MTXTNP(L'MTXTNP+L'MTSDNP),MTXTNP  CLEAR N/P ADDRS
         L     R14,GTMVALOC             PICK UP CURRENT MDV PTR
         LA    R14,MDVEL(,R14)          BUMP IT FOR NEXT ENTRY
         ST    R14,GTMVALOC             PUT IT BACK UPDATED
         L     R14,MDDSTRT              PICK UP TABLE BASE
         SR    R14,WORK1                GET DISPL TO LATEST ENTRY
         ST    R14,MDDCHN               STORE IT
         L     R14,MDDCNT               NUMBER OF MOD ENTRIES
         LA    R14,D1(R14)              BUMP
         ST    R14,MDDCNT               STORE
         B     MSCANA                   GO SEE IF EDITING THE ENTRY
MACRNMOV MVC   JDWORD(D0),JFWORD1       MOVE MACRO NAME
         DROP  WORK1
         EJECT
*VARBSYMD - THIS ROUTINE IS CALLED DURING THE EDITING OF A MACRO      *
*   DEFINITION OR OF OPEN CODE WHEN THE DEFINITION OF A VARIABLE      *
*   SYMBOL IS ENCOUNTERED (IN THE OPERAND OF A GLOBAL OR LOCAL        *
*   DECLARATION OR IN THE OPERAND OF THE MACRO PROTOTYPE STATEMENT).  *
*   ITS FUNCTION IS TO ENTER THE VARIABLE SYMBOL IN THE VARIABLE      *
*   SYMBOL DIRECTORY. FOR GLOBALS, THIS ROUTINE ALSO MAKES AN ENTRY   *
*   IN THE TEXT SEGMENT DICTIONARY FILE FOR THE GLOBAL DEFINITION.    *
*        INPUT - THE LENGTH OF THE VARIABLE SYMBOL IN R11.            *
*              - A POINTER IN R10 TO THE VARIABLE SYMBOL (1-8 BYTES). *
*                THE VARIABLE SYMBOL HAS BEEN VERIFIED AS VALID.      *
*                IF THE VARIABLE SYMBOL IS DIMENSIONED, THE           *
*                DIMENSION VALUE IS IN 'JHWORD1'. THE DIMENSION       *
*                HAS BEEN VERIFIED AS VALID.                          *
*              - APPROPRIATE FLAGS SET IN THE BYTE 'FLGBYT'.          *
*        OUTPUT - APPROPRIATE FLAGS IN 'CONCODE' IF THE VARIABLE      *
*                 SYMBOL DUPLICATES A PREVIOUS ONE OR IF INSUFFIC-    *
*                 IENT SPACE REMAINS FOR THE VARIABLE SYMBOL          *
*                 DIRECTORY ENTRY.                                    *
*                                                                     *
VSDINIT  EQU   *
         SET   ITERSW,ON                INDICATE VSD INITIALIZATION
VSDINITA SR    R11,R11                  CLEAR PARAMETER REGISTER
         IC    R11,D1(,WORK5)           PICK UP VARB SYMB LENGTH
         LA    R10,D2(,WORK5)           GET PTR TO SYST VARB SYMBOL
         MVC   FLGBYT,D0(WORK5)         SET UP APPROPRIATE FLAGS
VARBSYMD EQU   *
         BAL   RTNLNK,VSLOOKUP          SEE IF VAR SYM DEFINED PREV
         GOIF  FNDFLG,ON=VERR           IF YES, THIS DECLR AN ERROR
         L     WORK2,VSDSLOT            GET PTR TO NEW ENTRY
         LA    WORK1,VSDEL(,WORK2)      ASSUME LONGEST VSD ENTRY
         C     WORK1,MDDSLOT            CHECK FOR OVERLAP
         BNL   OERR                     IF OVERLAP, BRANCH
         L     WORK1,VSDSTRT            GET VSD HASH TBL PTR
         AR    WORK1,HASHV              GET PTR TO HSH TBL ENTRY
         USING VSDENTRY,WORK2
         MVC   VCHAIN,D0(WORK1)         PUT CHN LINK IN NEW ENTRY
         LR    WORK3,WORK2              SET UP NEW ENTRY ADDR
         S     WORK3,VSDSTRT            GET DISPL FOR HASH TBL ENTRY
         ST    WORK3,JFWORD1            SAVE TEMPORARILY AND PUT IN
         MVC   D0(L'VCHAIN,WORK1),JFWORD1+(L'JFWORD1-L'VCHAIN) HSH TBL
         STC   LNGTHREG,VLNGTH          INSERT VARB SYMB LENGTH
         EX    LNGTHREG,SYMBMOVE        PUT VAR SYMB IN ENTRY
         LA    WORK2,L'VCHAIN+L'VFLAGS+L'VLNGTH+D1(LNGTHREG,WORK2)     X
               UPDATE ENTRY (DSECT) PTR
         GOIF  (VTYP1,VTYP2),NOTALL=LGVARB GO AHEAD IF LOCAL, GLOBAL
PENTRY   GOIF  VPTYP,ON=KENTRY
         MVI   VTFVAL,JTMPPAR           FLAG POS PARAM FOR TEXT
         MVC   VPVECTR,GTPVALOC+(L'GTPVALOC-L'VPVECTR) PUT IN POSITNL  X
               PARAMETER VECTOR DISPLACEMENT
         L     WORK3,GTPVALOC           GET CURRENT POSIT PARM DISPL
         LA    WORK3,PVPTRLNG(,WORK3)   INCR FOR NEXT POS ENTRY
         ST    WORK3,GTPVALOC           PUT IT BACK UPDATED
         B     COMPNTRY                 CONTINUE AT COMMON PARAM PT
KENTRY   MVI   VTFVAL,JTMKPAR           FLAG KWD PARAM FOR TEXT
         MVC   VPVECTR,GTKVALOC+(L'GTKVALOC-L'VPVECTR) PUT IN KEYWORD  X
               PARAMETER VECTOR DISPLACEMENT
         L     WORK3,GTKVALOC           GET CURRENT KEYWRD PARM DISPL
         LA    WORK3,PVPTRLNG(,WORK3)   INCR FOR NEXT KWD ENTRY
         ST    WORK3,GTKVALOC           PUT IT BACK UPDATED
COMPNTRY EQU   *
         XC    VPPAD,VPPAD              INSERT PAD OF ZEROES IN ENTRY
         B     COMALL                   CONTINUE AT COMMON PT FOR ALL
SYMBMOVE MVC   VSYMBL(D0),D0(PARMREG)   EXECUTED VARB SYMB MOVE
LGVARB   GOIF  (VSTP1,VSTP2),NONE=ATYP,MIX=BTYP BRANCH ON VARB TYPE
         MVI   VTFVAL,JTMSVC            FLAG C-TYPE FOR TEXT
         B     FANOUT                   GO ON
ATYP     MVI   VTFVAL,JTMSVA            FLAG A-TYPE FOR TEXT
         B     FANOUT                   GO ON
BTYP     MVI   VTFVAL,JTMSVB            FLAG B-TYPE FOR TEXT
FANOUT   GOIF  (VTYP1,VTYP2),NONE=GENTRY SEPARATE GLOBALS AND LOCALS
LENTRY   EQU   *
         GOIF  VSLS,OFF=SLSKIP          HANDLE SYSLIST SPECIALLY
         MVI   VTFVAL,JTMLSTO           SET SPECIAL SYSLIST FLAG
         XC    VLDICTR,VLDICTR          CLEAR DICTIONARY PTR
         MVC   VLDIMEN,=H'1'            PRE-SET SYSLIST DIMENSION FLAG
         B     COMALL                   SKIP ALLOCATION FOR SYSLIBT
SLSKIP   MVC   VLDICTR,GTLDALOC+(L'GTLDALOC-L'VLDICTR) PUT IN DICT PTR
         LA    EOPAIR2,D1               ALLOCATE 1 BYTE FOR B-TYPE
         GOIF  (VSTP1,VSTP2),MIX=DIMENCK  BRANCH IF B-TYPE
         LA    EOPAIR2,D4               ALLOCATE 4 BYTES FOR A-TYPE
         GOIF  (VSTP1,VSTP2),NONE=DIMENCK BRANCH IF A-TYPE
         LA    EOPAIR2,D9               ALLOCATE 9 BYTES FOR C-TYPE
DIMENCK  GOIF  VDIM,ON=LSKIP            BRANCH IF VARB DIMENSIONED
         XC    VLDIMEN,VLDIMEN          SET DIMEN TO ZERO
         B     COMLNTRY                 SKIP DIMEN CALCULATION
LSKIP    MVC   VLDIMEN,JHWORD1          PUT DIMEN VALUE IN ENTRY
         MH    EOPAIR2,JHWORD1          COMPUTE DIMEN'D ALLOCATION
         GOIF  (VSTP1,VSTP2),NOTMIX=COMLNTRY   BRANCH IF NOT B-TYPE
         LA    EOPAIR2,D7(,EOPAIR2)     ADJUST TO GET ROUNDED RESULT
         SR    EOPAIR1,EOPAIR1          INITIALIZE AND DIVIDE TO ALLOC
         D     EOPAIR1,=F'8'            FORM
COMLNTRY A     EOPAIR2,GTLDALOC         ADJUST DICTIONARY ALLOCATION
         ST    EOPAIR2,GTLDALOC         PUT BACK UPDATED
         B     COMALL                   CONTINUE AT COMMON PT FOR ALL
GENTRY   OI    VTFVAL,JTMGBL            INSERT GLOBAL FLAG
         MVC   VGVECTR,GTGVALOC+(L'GTGVALOC-L'VGVECTR) PUT IN GLOBAL   X
               VECTOR DISPLACEMENT
         L     WORK3,GTGVALOC           GET CURRENT GBL VECTR DISPL
         LA    WORK3,GVPTRLNG(,WORK3)   INCR FOR NEXT GBL ENTRY
         ST    WORK3,GTGVALOC           PUT IT BACK UPDATED
         GOIF  VDIM,ON=GSKIP            BRANCH IF VARB DIMENSIONED
LSKIPA   EQU   *
         XC    VGDIMEN,VGDIMEN          SET DIMEN TO ZERO
         B     COMALL                   SKIP DIMEN HANDLING
GSKIP    MVC   VGDIMEN,JHWORD1          PUT DIMEN VALUE IN ENTRY
COMALL   EQU   *
         LA    WORK2,L'VTFVAL+L'VGVECTR+L'VGDIMEN(,WORK2) UPDATE PTR
         L     WORK3,VSDSLOT            GET PTR TO START OF ENTRY
         DROP  WORK2
         USING VSDENTRY,WORK3
         MVC   VFLAGS,FLGBYT            INSERT FLAGS IN ENTRY
         ST    WORK2,VSDSLOT            UPDATE NEXT ENTRY ADDRESS
         GOIF  (VTYP1,VTYP2),ANY=VSDINITX FINSIHED EXCEPT FOR GLOBALS
         SR    WORK2,WORK3              GET ENTRY LENGTH
         LR    R11,WORK2                SET UP LENGTH FOR JPUTL
         ST    WORK5,REGSAVE2           PRESERVE VSDINIT POINTER
         JPUTL FILE=FILE2,BUFREQ=(R11)  GET BUFFER PTR AND SPACE
         USING GBLDEF,BUFPTR
         BCTR  WORK2,D0                 GET RECORD MOVE LENGTH
         EX    WORK2,GDEFMOVE           MOVE DIR ENTRY TO DEF RECORD
         LA    WORK2,D1(,WORK2)         RESTORE TRUE LENGTH
         STH   WORK2,GDEFRL             PUT AT HEAD OF DEF RCRD
         MVI   GDEFRT,GDEFTYPE          INSERT RECORD TYPE
         BAL   RTNLNK,GETNPF2           NOTE TEXT SEG DICT, IF NECESS
         L     WORK5,REGSAVE2           RESTORE VSDINIT POINTER
VSDINITX GOIF  ITERSW,OFF=DICTEXIT      EXIT FI NOT VSD INITIALIZATION
         LA    WORK5,D9(,WORK5)        BUMP TO NEXT SYST VARB DEFIN
         CLI   D0(WORK5),BITFF          SEE IF END OF LIST REACHED
         BNE   VSDINITA                 BRANCH IF NOT
         SET   ITERSW,OFF               INDICATE VSD INITIALIZE DONE
         B     DICTEXIT                 AND EXIT
GDEFMOVE MVC   GDEFRL(D0),VCHAIN        EXECUTED GBL DEFINITION MOVE
         DROP  BUFPTR
         DROP  WORK3
         USING VSDENTRY,VSDPTR
OERR     MVC   DSEVCD(D2),=AL1(SEV9,ERR9) FLAG DICTIONARY OVERLAP
         SET   LSTSYSMS,ON              PREVENT SYSTEM MACRO EDITING
         B     DICTEXIT                 RETURN TO EDITOR
VERR     GOIF  (VTYP1,VTYP2),ON=PERR    BRANCH IF PARAM IN ERROR
         TM    VFLAGS,VSNS              SEE IF DUP ENTRY FOR SYS VARB
         BO    VERRA                    BRANCH IF YES
         TM    VFLAGS,VTYP1+VTYP2       SEE IF DUP ENTRY FOR PARAM
         BO    VERRB                    BRANCH IF YES
         MVC   DSEVCD(D2),=AL1(SEV5,ERR5) FLAG VAR SYMB DUPL OF VAR SYM
         B     DICTEXIT                 EXIT
VERRA    MVC   DSEVCD(D2),=AL1(SEV3,ERR3) FLAG VAR SYMB DUPL OF SYS VAR
         B     DICTEXIT                 EXIT
VERRB    MVC   DSEVCD(D2),=AL1(SEV4,ERR4) FLAG VAR SYMB DUPL OF PARAM
         B     DICTEXIT                 EXIT
PERR     TM    VFLAGS,VTYP1+VTYP2       SEE IF DUPL ENTRY FOR PARAM
         BO    PERRA                    BRANCH IF YES
         MVC   DSEVCD(D2),=AL1(SEV1,ERR1) FLAG PARAM DUPL OF SYST VAR
         B     DICTEXIT                 EXIT
PERRA    MVC   DSEVCD(D2),=AL1(SEV2,ERR2) FLAG PARAM DUPL OF PARAM
         B     DICTEXIT                 RETURN TO EDITOR
         DROP  VSDPTR
         EJECT
*VARBSYMR - THIS ROUTINE IS CALLED DURING THE EDITING OF A MACRO      *
*   DEFINITION OR OF OPEN CODE WHEN A REFERENCE TO A VARIABLE SYMBOL  *
*   IS ENCOUNTERED. ITS FUNCTION IS TO DETERMINE THE TYPE OF          *
*   REFERENCE (SYMBOLIC PARAMETER, LOCAL VARIABLE, OR GLOBAL VARI-    *
*   ABLE), AND TO RETURN TO THE EDITOR A POINTER TO THE APPROPRIATE   *
*   ENTRY IN THE APPROPRIATE GENERATION TIME DICTIONARY (THE KEYWORD  *
*   OR POSITIONAL PARAMETER VECTOR IN THE CASE OF A SYMBOLIC PARAM-   *
*   ETER, THE LOCAL DICTIONARY IN THE CASE OF A LOCAL VARIABLE, THE   *
*   GLOBAL VECTOR IN THE CASE OF A GLOBAL VARIABLE).                  *
*        INPUT - THE LENGTH OF THE VARIABLE SYMBOL IN R11.            *
*              - A POINTER IN R10 TO THE VARIABLE SYMBOL (1-8 BYTES). *
*                IF SUBSCRIPTED, THE VARIABLE SYMBOL IS FOLLOWED BY   *
*                A LEFT PARENTHESIS (1 BYTE).                         *
*                THE VARIABLE SYMBOL HAS BEEN VERIFIED AS VALID.      *
*        OUTPUT - A POINTER IN R11 TO THE TEXT FLAG BYTE IN THE       *
*                 VARIABLE SYMBOL DIRECTORY ENTRY FOR THE VARIABLE    *
*                 SYMBOL.                                             *
*               - APPROPRIATE FLAGS SET IN THE BYTE 'FLGBYT'.         *
*               - APPROPRIATE FLAGS IN 'CONCODE' IF THE VARIABLE      *
*                 SYMBOL WAS NOT PREVIOUSLY DEFINED OR IF ITS         *
*                 USEAGE IS INCONSISTENT WITH ITS DECLARATION.        *
*                                                                     *
VARBSYMR EQU   *
         MVI   FLGBYT,J0                CLEAN UP BEFORE GOING ON
         BAL   RTNLNK,VSLOOKUP          SEE IF VARB SYMB DECLARED PREV
         GOIF  FNDFLG,OFF=VERRC         IF NOT, THIS REFER AN ERROR
         GOIF  SPGRMD,OFF=RSKIP         BR IF NOT PRGR MACS
         GOIF  SMDEF,OFF=VERRC          ERROR IF BETWEEN MACRO DEFS
RSKIP    EQU   *
         USING VSDENTRY,VSDPTR
         MVC   FLGBYT,VFLAGS            GET FLAGS FOR EDITOR
RSKIPA   LA    WORK1,D1(LNGTHREG,PARMREG) GET PTR PAST VARB SYMB
         CLI   D0(WORK1),JLPARN         LOOK FOR LEFT PAREN (DIMEN)
         BNE   RSKIPB                   IF NOT, DONT SET FLAG
         OI    FLGBYT,VDIM              INDICATE PAREN FOUND
         B     RSKIPB1                  GO CHECK CONSISTENCY
RSKIPB   NI    FLGBYT,BITFF-VDIM        INDICATE NO PAREN FOUND
RSKIPB1  TM    VFLAGS,VTYP1+VTYP2       CONSIDER PARAMS SPECIALLY
         BO    RSKIPD                   SKIP IF THATS THE CASE
         CLC   FLGBYT,VFLAGS            SEE IF USEAGE CONSISTENT
         BNE   VERRD                    BRANCH IF NOT
RSKIPC   EQU   *
         LA    R11,L'VCHAIN+L'VFLAGS+L'VLNGTH+D1(LNGTHREG,VSDPTR)      X
               GET POINTER TO TEXT FLAG BYTE
         B     DICTEXIT                 RETURN
VERRC    MVC   DSEVCD(D2),=AL1(SEV6,ERR6) FLAG UNDECLARED VAR SYMB
         B     DICTEXIT                 RETURN
VERRD    TM    VFLAGS,VSLS              LOOK FOR SYSLIST REFERENCE
         BZ    VERRE                    BRANCH IF GBL OR LCL
         MVC   DSEVCD(D2),=AL1(SEV7,ERR7) FLAG INCONSISTENCY ERROR FOR
         B     RSKIPC                   SYSLIST, BUT STILL GET POINTER
RSKIPD   LA    R11,L'VCHAIN+L'VFLAGS+L'VLNGTH+D1(LNGTHREG,VSDPTR)      X
               GET POINTER TO TEXT FLAG BYTE
         USING PTFVAL,R11
         MVI   PPAD+D1,J0               SET DIMEN TO ZERO INITIALLY
         TM    FLGBYT,VDIM              SEE IF SUBSCRIPT ON PARAM
         BZ    DICTEXIT                 BRANCH IF NOT
         MVI   PPAD+D1,J1               INSERT NON-ZERO IN DIMEN BYTES
         B     DICTEXIT                 RETURN
VERRE    EQU   *
         MVC   DSEVCD(D2),=AL1(SEV7,ERR7) FLAG INCONSISTENCY ERROR
         B     DICTEXIT                 RETURN TO EDITOR
         DROP  VSDPTR
         DROP  R11
         EJECT
*SEQSYMBR - THIS ROUTINE IS CALLED DURING THE EDITING OF A MACRO      *
*   DEFINITION OR OF OPEN CODE WHEN A REFERENCE TO A SEQUENCE SYMBOL  *
*   IS ENCOUNTERED. ITS FUNCTION IS TO ENTER THE SEQUENCE SYMBOL IN   *
*   THE SEQUENCE SYMBOL REFERENCE DIRECTORY, IF IT HAS NOT BEEN       *
*   PREVIOUSLY ENTERED, AND TO RETURN TO THE EDITOR A POINTER TO THE  *
*   APPROPRIATE ENTRY IN THE GENERATION TIME SEQUENCE SYMBOL REFER-   *
*   ENCE DICTIONARY. FOR EACH NEW ENTRY IN THE SEQUENCE SYMBOL        *
*   REFERENCE DIRECTORY, THIS ROUTINE ALSO MAKES AN ENTRY IN THE      *
*   TEXT SEGMENT DICTIONARY FILE FOR THE SEQUENCE SYMBOL REFERENCE.   *
*        INPUT - THE LENGTH OF THE SEQUENCE SYMBOL IN R11.            *
*              - A POINTER TO THE SEQUENCE SYMBOL (2-8 BYTES) IN R10. *
*                THE SEQUENCE SYMBOL HAS BEEN VERIFIED AS VALID.      *
*        OUTPUT - A POINTER IN R11 TO THE TEXT FLAG BYTE IN THE       *
*                 SEQUENCE SYMBOL REFERENCE DIRECTORY ENTRY FOR THE   *
*                 SEQUENCE SYMBOL.                                    *
*                                                                     *
SEQSYMBR EQU   *
         LA    R6,SSPARMS               POINT TO SEQ SYMBOL VALUES
         LA    R10,D1(,R10)             DROP LEADING PERIOD
         BCTR  R11,0                    FROM SEQUENCE SYMBOL
COMNREF  EQU   *
         USING SSPARMS,R6
         LR    LNGTHREG,R11             SAVE LENGTH PARAMETER
         LR    PARMREG,R10              SAVE POINTER PARAMETER
         MVC   JDWORD,=8AL1(JBLANK)     CLEAR NAME BUFFER
         EX    LNGTHREG,SSMVC           MOVE SEQ SYMB INTO BUFFER
         L     SSRDPTR,SSRDSTRT         GET SS REF DIR BASE ADDR
         USING SSDIR,SSRDPTR
         LA    WORK1,SSRDNE             SET UP COMPARE LIMIT
SSLOOP   CLI   SSSYM,J0                 LOOK FOR SS IN DIR ENTRY
         BE    SSENTRY                  IF NO SS, GO MAKE ENTRY
         CLC   JDWORD,SSSYM             COMPARE SEQUENCE SYMBOLS
         BE    SSFOUND                  IF ALIKE, GO GET PTR AND EXIT
         LA    SSRDPTR,SSRDEL(,SSRDPTR) IF NOT, BUMP PTR TO NEXT ENTRY
         BCT   WORK1,SSLOOP             BRANCH 10 TIMES, THEN FALL
         L     SSRDPTR,SSRDSTRT         GET TABLE BASE ADDR
         AH    SSRDPTR,SSRAPDIS         DEVELOP PTR TO NEXT ENTRY SLOT
SSENTRY  MVC   SSSYM,JDWORD             MOVE SS NAME INTO ENTRY
         MVC   STFVAL,SSFLGVAL          INSERT FLAG FOR TEXT REFER
         MVC   SSRDP,GTSDALOC+L'GTSDALOC-L'SSRDP      GET DICT PTR
         XC    SSPAD,SSPAD              INSERT PAD OF ZEROES IN ENTRY
         LA    WORK1,D8(,LNGTHREG)      GET LENGTH OF SS REF RECORD
         LR    R11,WORK1                SET UP FOR JPUTL
         JPUTL FILE=FILE2,BUFREQ=(R11)  GET BUFFER PTR AND SPACE
         USING SSREF,BUFPTR
         STH   WORK1,SREFRL             INSERT RECORD LENGTH
         MVC   SREFDP,SSRDP             INSERT DICTIONARY PTR
         MVC   SREFRT,SREFTYPE          INSERT RECORD TYPE
         STC   LNGTHREG,SREFSL          INSERT SEQ SYMB LENGTH
         EX    LNGTHREG,SREFMOVE        INSERT SEQUENCE SYMBOL
         BAL   RTNLNK,GETNPF2           NOTE TEXT SEG DICT, IF NECESS
         L     WORK1,GTSDALOC           PICK UP CURRENT DICT PTR
         AH    WORK1,SSDLNGTH           INCREMENT BY DICT ENTRY LENGTH
         ST    WORK1,GTSDALOC           PUT IT BACK UPDATED
         LH    WORK1,SSRAPDIS           PICK UP CURRENT DISPL
         LA    WORK1,SSRDEL(,WORK1)     ADD IN NEWEST ENTRY
         CH    WORK1,=AL2(SSRDEL*(SSRDNE-D1)) CHECK IF WRAP POINT HIT
         BNH   SSSKIP                   IF NOT, SKIP
         SR    WORK1,WORK1              IF SO, RESET DISPL TO ZERO
SSSKIP   STH   WORK1,SSRAPDIS           SAVE WRAP-AROUND DISPL
SSFOUND  LA    R11,STFVAL               GET PTR TO STUFF FOR EDITOR
         B     DICTEXIT                 RETURN TO EDITOR
SSMVC    MVC   JDWORD(D0),D0(PARMREG)   EXECUTED SEQ SYMB MOVE
SREFMOVE MVC   SREFSS(D0),D0(PARMREG)   EXECUTED SEQ SYMB MOVE
         DROP  SSRDPTR
         DROP  BUFPTR
         DROP  R6
         EJECT
*SEQSYMBD - THIS ROUTINE IS CALLED DURING THE EDITING OF A MACRO      *
*   DEFINITION OR OF OPEN CODE AFTER THE EDITED TEXT RECORD HAS       *
*   BEEN BUILT FOR A STATEMENT IN WHICH A SEQUENCE SYMBOL WAS         *
*   ENCOUNTERED IN THE NAME FIELD. ITS FUNCTION IS TO MAKE AN         *
*   ENTRY IN THE TEXT SEGMENT DICTIONARY FILE FOR THE SEQUENCE        *
*   SYMBOL DEFINITION.                                                *
*        INPUT - THE LENGTH OF THE SEQUENCE SYMBOL IN R11.            *
*              - A POINTER TO THE SEQUENCE SYMBOL (2-8 BYTES) IN R10. *
*                THE SEQUENCE SYMBOL HAS BEEN VERIFIED AS VALID.      *
*                THE STATEMENT DEFINING THE SEQUENCE SYMBOL HAS       *
*                BEEN PUT TO THE TEXT FILE PRIOR TO ENTRY.            *
*        OUTPUT - NONE.                                               *
*                                                                     *
SEQSYMBD EQU   *
         LR    LNGTHREG,R11             SAVE LENGTH PARAMETER
         LR    PARMREG,R10              SAVE POINTER PARAMETER
         JNOTE FILE=FILE1               GET N/P ADDR AS SS DEF
         LA    WORK1,L'JNOTEVAL+D5(,LNGTHREG) DEVELOP RECORD LENGTH
         LR    R11,WORK1                SET UP FOR JPUTL
         JPUTL FILE=FILE2,BUFREQ=(R11)  GET BUFFER PTR AND SPACE
         USING SSDEF,BUFPTR
         STH   WORK1,SDEFRL             INSERT RECORD LENGTH
         MVC   SDEFNP(L'JNOTEVAL),JNOTEVAL  INSERT N/P ADDR
         BCTR  LNGTHREG,0               DROP LEADING PERIOD
         STC   LNGTHREG,SDEFSL          INSERT SEQ SYMB LENGTH
         EX    LNGTHREG,SSDEFMV         INSERT SEQ SYMB
         MVI   SDEFRT,SDEFTYPE          INSERT RECORD TYPE
         BAL   RTNLNK,GETNPF2           NOTE TEXT SEG DICT, IF NECESS
         B     DICTEXIT                 RETURN TO EDITOR
SSDEFMV  MVC   SDEFSS(D0),D1(PARMREG)   EXECUTED SEQ SYMB MOVE
         DROP  BUFPTR
         EJECT
*OPERCODE - THIS ROUTINE IS CALLED DURING THE EDITING OF A MACRO      *
*   DEFINITION OR OF OPEN CODE WHEN AN OPERATION CODE IS ENCOUNT-     *
*   ERED. ITS FUNCTION IS TO LOCATE THE APPROPRIATE ENTRY IN THE      *
*   OP CODE TABLE AND TO RETURN TO THE EDITOR A POINTER TO THE ENTRY  *
*   LOCATED. ANY OPERATION CODE NOT LOCATED IN THE OP CODE TABLE IS   *
*   ENTERED IN THE MACRO DEFINITION DIRECTORY (SEE THE ROUTINE        *
*   'MACRNAME').                                                      *
*        INPUT - THE LENGTH OF THE MNEMONIC IN R11.                   *
*              - A POINTER TO THE MNEMONIC (1-8 BYTES) IN R10.        *
*                THE MNEMONIC HAS BEEN VERIFIED AS A VALID SYMBOL.    *
*        OUTPUT - A POINTER IN R11 TO THE 'FLAGA' BYTE IN THE OP      *
*                 CODE TABLE ENTRY FOR THE MNEMONIC.                  *
*               - APPROPRIATE FLAGS SET IN THE BYTE 'IOCID'.          *
*                                                                     *
OPERCODE EQU   *
         LR    LNGTHREG,R11             SAVE LENGTH PARAMETER
         XC    JFWORD1(D8),JFWORD1      CLEAR WORK AREA
         EX    R11,MNEMOVE              MOVE MNEMONIC T-6 WORK AREA
         NC    OPSCHN,OPSCHN            SEE IF ANY OPSYN ENTRIES
         BZ    OPERCD1                  BRANCH AROUND IF NONE
         BAL   R4,OPSYNAME              DO OPSYN SCAN
OPERCD1  EQU   *
         BAL   R4,OPERNAME              SEARCH OP CODE TABLE FIRST
         B     OPERCD2                  RETURN--NOT FOUND
         B     DICTEXIT                 RETURN--FOUND
OPERCD2  BAL   R4,MACRNAME              LOOK UP AS A MACRO
         B     MACENTRY                 NOT FOUND
         B     DICTEXIT                 FOUND
OPERNAME EQU   *
         L     EOPAIR2,JFWORD1          GET FIRST HALF OF NAME
         AL    EOPAIR2,JFWORD2          ADD SECOND HALF
         SR    EOPAIR1,EOPAIR1          INITIALIZE AND DIVIDE BY
         D     EOPAIR1,=F'71'           HASHING VALUE
         SLL   EOPAIR1,D1               DEVELOP HASH TABLE INDEX
         L     OCHNPTR,OCTSTRT          GET OP COD TBL BASE ADDR
         AR    OCHNPTR,HASHO            ADD DISPL TO REQ'D CHAIN
         USING OPNTRY,OCHNPTR
NXTCHN   CLC   OCHAIN,=FL3'0'           CHECK FOR END OF CHAIN
         BZR   R4                       IF FOUND, GO HANDLE MACRO CALL
         MVC   JHWORD1,OCHAIN           ALIGN CHAIN POINTER
         LH    OCHNPTR,JHWORD1          PICK UP LINK TO NEXT ENTRY
         A     OCHNPTR,OCTSTRT          GET ADDR OF NEXT CHAIN ENTRY
         SR    WORK1,WORK1              CLEAR WORK REGISTER
         IC    WORK1,OFLAGS             PICK UP ENTRY FLAGS
         N     WORK1,=F'7'              STRIP OUT ALL BUT MNEM LENGTH
         CLR   WORK1,LNGTHREG           SEE IF LENGTHS EQUAL
         BNE   NXTCHN                   BRANCH IF NOT
         EX    LNGTHREG,OPCOMP          COMPARE MNEMONICS
         BNE   NXTCHN                   IF NOT SAME, SEARCH FURTHER
         MVC   IOCID(L'OFLAGS),OFLAGS        GET FLAGS FROM TBL ENTRY
         NI    IOCID,BITFF-BIT5-BIT6-BIT7    STRIP OUT LENGTH BITS
         LA    R11,D4(LNGTHREG,OCHNPTR) GET POINTER TO FLAGA BYTE
         B     D4(R4)                   RETURN--FOUND
MNEMOVE  MVC   JFWORD1(D0),D0(R10)      REMOTE MNEMONIC MOVE
OPCOMP   CLC   JFWORD1(D0),OMNEM        EXECUTED MNEMONIC COMPARE
         DROP  OCHNPTR
OPSYNAME LA    NAMEPTR,JFWORD1-D1       SET UP POINTER FOR OPSYN SCAN
         LA    R1,D1(,LNGTHREG)         GET MNEMONIC TRUE LENGTH
         STC   R1,JFWORD1-D1            STORE FOR COMPARE
OPSYNM1  BAL   RTNLNK,SCANOPSN          GO LOOK FOR OPSYN ENTRY
         B     OPSYNM2                  BRANCH IF FOUND
         BR    R4                       BRANCH IF NOT FOUND
         USING OPSYNTRY,SCANPTR
OPSYNM2  GOIF  ODEL,ON=D4(R4)           SKIP OPCODE LOOKUP IF DELETED
         MVC   IOCID(D1),OPSYNFLG       MOVE FLAGS
         LA    R11,OPSYNATT             POINT TO FLAGA, ETC.
         B     DICTEXIT                 AND EXIT
         DROP  SCANPTR
         EJECT
*ORDSYMBR - THIS ROUTINE IS CALLED DURING THE EDITING OF A MACRO      *
*   DEFINITION OR OF OPEN CODE WHEN AN EXPLICIT REFERENCE TO AN       *
*   ATTRIBUTE OF AN ORDINARY SYMBOL IS ENCOUNTERED IN A CONDITIONAL   *
*   ASSEMBLY STATEMENT OR WHEN AN ORDINARY SYMBOL IS ENCOUNTERED      *
*   IN THE OPERAND OF A MACRO INSTRUCTION.                            *
*   ITS FUNCTION IS TO ENTER THE ORDINARY SYMBOL IN THE ORDINARY      *
*   SYMBOL REFERENCE DIRECTORY, IF IT HAS NOT BEEN PREVIOUSLY         *
*   ENTERED, AND TO RETURN TO THE EDITOR A POINTER TO THE APPRO-      *
*   PRIATE ENTRY IN THE GENERATION TIME ORDINARY SYMBOL REFERENCE     *
*   DICTIONARY. FOR EACH NEW ENTRY IN THE ORDINARY SYMBOL REFERENCE   *
*   DIRECTORY, THIS ROUTINE ALSO MAKES AN ENTRY IN THE TEXT SEGMENT   *
*   DICTIONARY FILE FOR THE ORDINARY SYMBOL REFERENCE.                *
*        INPUT - THE LENGTH OF THE ORDINARY SYMBOL IN R11.            *
*              - A POINTER TO THE ORDINARY SYMBOL (1-8 BYTES) IN R10. *
*                THE ORDINARY SYMBOL HAS BEEN VERIFIED AS VALID.      *
*        OUTPUT - A POINTER IN R11 TO THE TEXT FLAG BYTE IN THE       *
*                 ORDINARY SYMBOL REFERENCE DIRECTORY ENTRY FOR THE   *
*                 ORDINARY SYMBOL.                                    *
*                                                                     *
ORDSYMBR EQU   *
         LA    R6,OSPARMS               POINT TO ORD SYMB VALUES
         B     COMNREF                  HANDLE AS SEQUENCE SYMBOL
         EJECT
*ORDSYMBD - THIS ROUTINE IS CALLED DURING THE EDITING OF OPEN         *
*   CODE AFTER THE EDITED TEXT RECORD HAS BEEN BUILT FOR AN           *
*   'EXTRN' OR 'WXTRN' STATEMENT OR FOR A STATEMENT IN WHICH AN       *
*   ORDINARY SYMBOL WAS ENCOUNTERED IN THE NAME FIELD. ITS FUNCTION   *
*   IS TO MAKE AN ENTRY IN THE ORDINARY SYMBOL DEFINITION FILE.       *
*        INPUT - A POINTER IN R10 TO THE START OF THE EDITED TEXT     *
*                RECORD.                                              *
*        OUTPUT - NONE.                                               *
*                                                                     *
ORDSYMBD EQU   *
         LR    R11,R10                  SET UP PTR FOR PUTL
         JPUTM FILE=FILE3,ADDR=(R11)    PUT RCD TO ORD SYMB DEF FILE
         B     DICTEXIT                 RETURN TO EDITOR
         EJECT
*OPSYNBLD - THIS ROUTINE IS CALLED AFTER THE EDITING OF AN OPSYN      *
*   STATEMENT. ITS FUNCTION IS TO ENTER THE MNEMONIC AND ITS          *
*   SYNONYM IN THE OPSYN TABLE.                                       *
*        INPUT - A POINTER IN R10 TO THE EDITED TEXT RECORD.          *
*        OUTPUT - NONE.                                               *
*                                                                     *
OPSYNBLD EQU   *
         USING JTEXT,R10
         LH    NAMEPTR,JTNMP            GET DISPL TO NAME FIELD
         LA    NAMEPTR,D1(NAMEPTR,R10)  DEVELOP PTR TO OPSYN NAME
         LH    SCANPTR,JTOPP            GET OPERAND FIELD DISPLACEMENT
         AR    R10,SCANPTR              POINT TO OPERAND
         USING JTOPO,R10                  AND DECLARE AS BASE.
         GOIF  JTOPOCD,OFF=OPBLD1       BRANCH IF NO CARD POINTER
         LA    R10,JTOPL                BUMP OVER CARD POINTER
OPBLD1   LA    R10,JTOPL                POINT TO OPERAND LENGTH
         USING JTOPL,R10                  AND RESET BASE.
         SR    R1,R1                    CLEAR REGISTER
         IC    R1,D0(NAMEPTR)           PICK UP NAME FIELD LENGTH
         LR    LNGTHREG,R1              PLACE MNEMONIC IN LENGTH REG
         BCTR  LNGTHREG,0                 AND MAKE MOVE LENGTH
         GOIF  JTOPL,D0,EQ=OPBLD10      EXIT IF NULL OPERAND
         CLC   JTOPL(D2),=AL1(D1,JCOMMA) CHECK FOR COMMA IN OPERAND
         BE    OPBLD10                  BRANCH IF YES--NULL OPERAND
*              NAMEPTR POINTS TO MNEMONIC TO BE SEARCHED
         BAL   RTNLNK,SCANOPSN          SEARCH FOR PREVIOUS ENTRY
         B     OPBLD2                   RETURN HERE IF FOUND
*                                       RETURN HERE IF NOT FOUND
         BAL   RTNLNK,OPENTRY           GO MAKE OPSYN ENTRY
         B     OPBLD3                   SKIP AROUND
OPBLD2   EQU   *
         LR    ENTRYPTR,SCANPTR         POINT TO ENTRY
*              ENTRYPTR IS OPSYN ENTRY BASE
         USING OPSYNTRY,ENTRYPTR        DECLARE BASE
         SET   OPREV,ON
OPBLD3   EQU   *
OPBLD4   EQU   *
         LR    NAMEPTR,R10              POINT TO MNEMONIC
         IC    R1,JTOPL                 PICK UP OPSYN OPERAND LENGTH
         DROP  R10
         LR    LNGTHREG,R1              PUT LENGTH IN LENGTH REG
         BCTR  LNGTHREG,0                 AND MAKE INTO MOVE LENGTH
         BAL   RTNLNK,SCANOPSN          SEE IF THERE IS AN OPSYN
         B     OPBLD6                   RETURN HERE IF FOUND
OPBLD7   XC    JFWORD1(D8),JFWORD1      CLEAR WORK AREA
         EX    R1,NAMEMV                USE TO MOVE OPERAND TO WORK    X
                                          AREA.
OPBLD8   BAL   R4,OPERNAME              GO SEE IF THERE'S AN OP CODE
         B     OPBLD5                   RETURN HERE IF NOT FOUND
*                                       RETURN HERE IF FOUND
         MVC   OPSYNATT,D0(R11)         MOVE ATTRIBUTES TO OPSYN ENTRY
         MVC   OPSYNFLG(D1),IOCID       MOVE FLAGS TO OPSYN ENTRY
         B     DICTEXIT                 EXIT POINT
         SPACE
OPBLD6   EQU   *
*              SCANPTR POINTS TO OLD OPSYN ENTRY
         CLC   HIBYTE0,OPSCHN           IS IT THE LAST OPSYN
         BNE   OPBLD9                   NO
         TM    D3(SCANPTR),OPREV
         BZ    OPBLD7
OPBLD9   TM    D3(SCANPTR),ODEL         DELETED
         BO    OPBLDER1                 OR AN ERRONEOUS OPSYN
         MVC   OPSYNFLG(D4),D3(SCANPTR) MOVE ATTRIBUTES AND FLAGS
         B     DICTEXIT                 EXIT
         SPACE
OPBLD5   EQU   *
         GOIF  OPREV,OFF=OPBLDER1
OPBLDERR SET   ODEL,ON                  MARK AS A DELETE ENTRY
         MVC   DSEVCD(D2),=AL1(SEV8,ERR8)    LOG ERROR--CIRCULAR       X
                                             OPSYN OPERAND
         B     DICTEXIT                 EXIT
         SPACE
*        OPSYN DELETE ROUTINE
         SPACE
OPBLD10  EQU   *                        DELETE AN ENTRY
         SPACE
*        ON ENTRY R1 CONTAINS MNEMONIC LENGTH
*              LNGTHREG CONTAINS LENGTH-1
*                 NAMEPTR CONTAINS POINTER TO MNEMONIC IN TEXT RECORD
         SPACE
         XC    JFWORD1(D8),JFWORD1      CLEAR WORK AREA
         EX    R1,NAMEMV                MOVE NAME TO WORK AREA
         BAL   RTNLNK,SCANOPSN          SEARCH FOR OPSYN ENTRY
         B     OPBLD11                  RETURN HERE IF FOUND
*                                       RETURN HERE IF NOT FOUND
         BAL   R4,OPERNAME              LOOK FOR OP CODE
         B     OPBLDER1                 RETURN HERE IF NOT FOUND
*                                       RETURN HERE IF FOUND
         LA    NAMEPTR,JFWORD1-D1       RESET POINTER TO MNEMONIC
         BAL   RTNLNK,OPENTRY           MAKE OPSYN ENTRY
         SET   ODEL,ON                  MARK AS A DELETE
         B     DICTEXIT                 RETURN
OPBLDER1 SET   ODEL,ON                  MARK AS A DELETE ENTRY
         MVC   DSEVCD(D2),=AL1(SEV14,ERR14)                            X
               LOG ERROR - INVALID OPCODE IN NAME FIELD
         B     DICTEXIT                 RETURN
OPBLD11  EQU   *
         DROP  ENTRYPTR
         USING OPSYNTRY,SCANPTR         BASE
         SET   OPREV,ON
         SET   ODEL,ON                  MARK AS DELETE
         DROP  SCANPTR
         USING OPSYNTRY,ENTRYPTR        BASE FOR OPSYN ENTRY
         B     DICTEXIT                 RETURN
         SPACE
         SPACE
OPENTRY  EQU   *
         L     ENTRYPTR,MDDSLOT         POINTER TO NEXT FREE SLOT
         SH    ENTRYPTR,=AL2(OPSYND-OPSYNTRY)  MAKE ROOM FOR NEW ENTRY
         GOIF  (ENTRYPTR),VSDSLOT,LOW=OERR EXIT IF NO ROOM
         ST    ENTRYPTR,MDDSLOT         UPDATE TABLE BOUNDARY
         XC    OPSYNTRY(OPSYNLN),OPSYNTRY    CLEAR IT OUT
         MVC   OPSYNCH,OPSCHN+(L'OPSCHN-L'OPSYNCH)  LINK THE CHAIN
         LCR   R15,ENTRYPTR             COMPLEMENT AND USE TO CALCULATE
         A     R15,MDDSTRT              NEW CHAIN POINTER
         ST    R15,OPSCHN               SAVE AS MASTER LINK
         EX    R1,NAME1MV               MOVE NAME TO OPSYN ENTRY
         BR    RTNLNK                   RETURN
         SPACE
*        EXECUTED OPERATIONS
         SPACE
NAME1MV  MVC   ONAMEL(D0),D0(NAMEPTR)   MNEMONIC MOVE TO OPSYN ENTRY
NAMEMV   MVC   JFWORD1-D1(D0),D0(NAMEPTR)    ALIGN OPSYN NAME
         DROP  ENTRYPTR
         EJECT
*
* THIS SUBROUTINE SEARCHES THE VARIABLE SYMBOL DIRECTORY FOR A
*        SPECIFIED VARIABLE SYMBOL.
*        IT IS CALLED FROM THE FOLLOWING ROUTINES-
*                   VARBSYMD
*                   VARBSYMR
*
VSLOOKUP EQU   *
         LR    LNGTHREG,R11             SAVE LENGTH PARAMETER
         LR    PARMREG,R10              SAVE POINTER PARAMETER
         XC    JDWORD,JDWORD            CLEAR VARB NAME AREA
         EX    LNGTHREG,VARMOVE         MOVE NAME TO ALIGNED AREA
         L     EOPAIR2,JDWORD           GET FIRST HALF OF NAME
         AL    EOPAIR2,JDWORD+D4        ADD SECOND HALF
         SR    EOPAIR1,EOPAIR1          INITIALIZE AND DIVIDE BY
         D     EOPAIR1,=F'201'          HASHING VALUE
         N     EOPAIR1,=F'127'          INSURE HASH VALUE IN RANGE
         LR    EOPAIR2,EOPAIR1          SET UP TO CALC DISPL
         MH    EOPAIR2,=H'3'            MULTIPLY FOR RANGE 0-381
         L     VSDPTR,VSDSTRT           GET VAR SYMB DIR BASE ADDR
         AR    VSDPTR,HASHV             ADD DISPL TO REQ'D CHAIN
         USING VSDENTRY,VSDPTR
CHNON    CLC   VCHAIN,=FL3'0'           CHECK FOR END OF CHAIN
         BZ    NTFND                    IF YES, GO FLAG IT AND EXIT
         MVC   HIBYTE0+(L'HIBYTE0-L'VCHAIN)(L'VCHAIN),VCHAIN           X
               MOVE CHAIN POINTER
         L     VSDPTR,HIBYTE0           TO ALIGNED AREA, PICK IT UP
         A     VSDPTR,VSDSTRT           GET ADDR OF NEXT CHAIN ENTRY
         SR    WORK1,WORK1              CLEAR WORK REGISTER
         IC    WORK1,VLNGTH             PICK UP LENGTH OF ENTRY
         N     WORK1,=F'7'              STRIP OUT ALL BUT LENGTH BITS
         CLR   WORK1,LNGTHREG           COMPARE VARB SYMB LENGTHS
         BNE   CHNON                    IF UNEQUAL, SEARCH FURTHER
         EX    LNGTHREG,VARCOMP         COMPARE VARIABLE SYMBOLS
         BNE   CHNON                    IF NOT SAME, SEARCH FURTHER
         SET   FNDFLG,ON                IF SAME, FLAG IT
         BR    RTNLNK                        AND EXIT
NTFND    SET   FNDFLG,OFF               INDICATE VARB SYM NOT FOUND
         BR    RTNLNK                   RETURN TO CALLING RTN
VARCOMP  CLC   VSYMBL(D0),D0(PARMREG)   EXECUTED VARB NAME COMPARE
VARMOVE  MVC   JDWORD(D0),D0(PARMREG)   EXECUTED VARB NAME MOVE
         DROP  VSDPTR
*
* THIS SUBROUTINE NOTES THE TEXT SEGMENT DICTIONARY FILE FOLLOWING
*        THE FIRST WRITE TO THAT FILE FOR EACH TEXT SEGMENT.
*        IT IS CALLED FROM THE FOLLOWING ROUTINES-
*                   VARBSYMD
*                   SEQSYMBR
*                   SEQSYMBD
*                   ORDSYMBR
*
GETNPF2  GOIF  NOTEFIL2,OFF=(RTNLNK)    RETURN IF FLAG SET OFF
         SET   NOTEFIL2,OFF             SET FLAG OFF
         ST    RTNLNK,REGSAVE1          TEMPOR SAVE LINK REG
         JNOTE FILE=FILE2               NOTE TEXT SEG DICT FILE
         MVC   SAVENOTE,JNOTEVAL        SAVE N/P ADDR FOR MDD ENTRY
         L     RTNLNK,REGSAVE1          RESTORE LINK REG
         BR    RTNLNK                   RETURN
*
* THIS SUBROUTINE PERFORMS A BUFFERED WRITE TO ANY FILE.
*        IT IS CALLED FROM THE FOLLOWING ROUTINES
*                   PHASEND
*
BUFRITE  EQU   *
         MVI   FSWITCH,J0               CLEAR FIRST WRITE/NOTE SWITCH
         LM    R3,R4,PIOPARMB           PICK UP I/O PARAMETERS
BR1      CLR   R3,R5                    SEE IF RECORD LESS THAN MAX
         BH    BR4                      BRANCH IF NOT
         CH    R3,=AL2(MINRECSZ)        SEE IF BLOCK OVER MINIMUM
         BNL   BR11                     BRANCH IF MORE OR JUST ENUF
         LA    R3,MINRECSZ              IF NOT, USE MINIMUM SIZE
BR11     EQU   *
         STH   R3,PIOPARMC              SET UP I/O LENGTH PARAM
         SR    R3,R3                    INDICATE LAST WRITE
BR2      JWRITE FILE=(R6),PARM=PIOPARMA WRITE RECORD TO PROPER FILE
         JCHECK FILE=(R6)               CHECK THE WRITE
         TS    FSWITCH                  TEST AND SET FIRST WRITE SW
         BNZ   BR3                      BRANCH IF NOT FIRST WRITE
         JNOTE FILE=(R6)                NOTE FIRST BLOCK WRITTEN
BR3      LTR   R3,R3                    SEE IF WRITE COMPLETE
         BZR   R7                       RETURN IF YES
         AR    R4,R5                    DEVELOP PTR TO NEXT I/O AREA
         ST    R4,PIOPARMA              PUT PTR IN I/O CONTROL AREA
         B     BR1                      GO SET UP NEW WRITE LENGTH
BR4      STH   R5,PIOPARMC              USE MAX RCD LENGTH THIS TIME
         SR    R3,R5                    ADJUST RECORD LENGTH
         B     BR2                      GO WRITE NEXT RECORD
*
* THIS SUBROUTINE PERFORMS THE INITIALIZATION COMMON TO A MACRO
*        DEFINITION AND OPEN CODE. IT IS CALLED FROM THE
*        FOLLOWING ROUTINES - OPENENT, MACRENT
*
COMNINIT EQU   *
         SET   NOTEFIL2,ON              SET NOTE FLAG FOR FILE 2
         L     WORK1,SSRDSTRT           GET PTR TO SS REF DIRECTORY
         MVI   D0(WORK1),JBLANK         INSERT CHARACTER TO CLEAR
         MVC   D1(SSRDLNGT-D1,WORK1),D0(WORK1) SEQ SYMB REFER DIRECT
         L     WORK1,VSDSTRT            GET PTR TO VSD HASH TABLE
         XC    D0(VSDHTLNT-D256,WORK1),D0(WORK1) CLEAR VSD HASH TABLE,
         XC    VSDHTLNT-D256(D256,WORK1),VSDHTLNT-D256(WORK1) 2 PARTS
         LA    WORK1,VSDHTLNT(,WORK1)   ADJUST PTR PAST HASH TABLE
         ST    WORK1,VSDSLOT            RESET START OF VSD ENTRY AREA
         BR    WORK3                    RETURN
*
* THIS SUBROUTINE PERFORMS THE TERMINATION COMMON TO A MACRO
*        DEFINITION AND OPEN CODE. IT IS CALLED FROM THE
*        FOLLOWING ROUTINES - OPENEND, MACREND
*
COMNEND  EQU   *
         JPUTL FILE=FILE2,BUFREQ=L'ESEGRL+L'ESEGRT GET RECORD LENGTH
         USING ENDSEG,BUFPTR
         MVC   ESEGRL(L'ESEGRL+L'ESEGRT),=AL1(0,L'ESEGRL+L'ESEGRT,ESEGTX
               YPE) INSERT RECORD LENGTH AND TYPE
         BAL   RTNLNK,GETNPF2           NOTE TEXT SEG DICT, IF NECESS
         L     WORK1,CURMDDPT           PICK UP CURRENT MDD SLOT PTR
         USING MDDNTRY,WORK1
         MVC   MLCLSZ,GTLDALOC+(L'GTLDALOC-L'MLCLSZ) INSERT LCL DICT
         MVC   MSEQSZ,GTSDALOC+(L'GTSDALOC-L'MSEQSZ) INSERT SEQ DICT
         MVC   MGBLSZ,GTGVALOC+(L'GTGVALOC-L'MGBLSZ) INSERT GBL VCT
         BR    WORK3                    RETURN
         DROP  WORK1
*
* THIS SUBROUTINE SCANS THE OPSYN TABLE FOR A GIVEN OP CODE.
*
SCANOPSN MVC   HIBYTE0,OPSCHN           SET UP INITIAL CHAIN PTR
SCOPN1   L     SCANPTR,HIBYTE0          PICK UP PTR TO NEXT CHAIN ENTRY
         LTR   SCANPTR,SCANPTR          SEE IF END OF CHAIN
         BZ    D4(,RTNLNK)              TAKE NOT-FOUND EXIT
         USING OPSYNTRY,SCANPTR
         LCR   SCANPTR,SCANPTR          GET VALUE FOR CALCULATION OF
         A     SCANPTR,MDDSTRT          OPSYN ENTRY LOCATION
         EX    R1,COMPNAME              REMOTE MNEMONIC COMPARE
         BER   RTNLNK                   TAKE FOUND EXIT
         MVC   HIBYTE0+(L'HIBYTE0-L'OPSYNCH)(L'OPSYNCH),OPSYNCH        X
                SET UP LINK TO NEXT ENTRY
         B     SCOPN1                   GO BACK THRU SEARCH LOOP
COMPNAME CLC   ONAMEL,D0(NAMEPTR)       COMPARE MNEMONICS
         DROP  SCANPTR
         EJECT
OCTSTRT  DC    A(OPBASE)                POINTER TO OP CODE TABLE
         JEXTRN (X1K01=OPBASE)
SYSNDX   DC    AL1(VSNS+VTYP2),X'05',AL1(JS,JY,JS,JN,JD,JX,JBLANK)     X
               DEFINITION OF SYSNDX SYSTEM LOCAL
SYSECT   DC    AL1(VSNS+VTYP2+VSTP1+VSTP2),X'05',AL1(JS,JY,JS,JE,JC,JT,X
               JBLANK) DEFINITION OF SYSECT SYSTEM LOCAL
SYSLST   DC    AL1(VSNS+VSLS+VDIM+VTYP2),X'06',AL1(JS,JY,JS,JL,JI,JS,JTX
               ) DEFINITION OF SYSLIST SYSTEM LOCAL
SYSPRM   DC    AL1(VSNS+VSTP1+VSTP2),X'06',AL1(JS,JY,JS,JP,JA,JR,JM)   X
               DEFINITION OF SYSPARM SYSTEM GLOBAL
SYSTME   DC    AL1(VSNS+VSTP1+VSTP2),X'06',AL1(JS,JY,JS,JT,JI,JM,JE)   X
               DEFINITION OF SYSTIME SYSTEM GLOBAL
SYSDTE   DC    AL1(VSNS+VSTP1+VSTP2),X'06',AL1(JS,JY,JS,JD,JA,JT,JE)   X
               DEFINITION OF SYSDATE SYSTEM GLOBAL
         DC    X'FF'                    END OF TABLE FLAG
         SPACE 3
         EJECT
         JPATCH X1J00,B64
         END
