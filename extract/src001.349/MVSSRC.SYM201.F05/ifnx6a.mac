         JHEAD 'POST PROCESSOR PHASE',                                 *
               PHASEID=X6A,                                            *
               LEVEL=10
*FUNCTION/OPERATION-                                                  *
*   THE POST PROCESSOR PHASE SORTS, FORMATS, AND WRITES ON PUNCH/LINK *
*   FILE(S) THE RELOCATION DICTIONARY (RLD) TO THE DESIRED FORMAT     *
*   REQUIRED BY THE LINKAGE EDITOR.  THE PHASE ALSO SORTS, FORMATS,   *
*   AND WRITES OUT ON PRINT FILE THE SYMBOL CROSS REFERENCE, AND THE  *
*   LITERAL CROSS REFERENCE.                                          *
*                                                                     *
*ENTRY POINT-                                                         *
*        PPENT                                                        *
*                                                                     *
*INPUT-                                                               *
*   INPUT FROM 'JINFILE'.                                             *
*   RLD RECORDS FORMAT --                                             *
*   FIELD             BYTES                                           *
*   RECORD LENGTH     2                                               *
*   (NOT USED)        2                                               *
*   RECORD TYPE       2                                               *
*   POSITION ESD/ID   2                                               *
*   RELOCATION ESD/ID 2                                               *
*   SYMBOL ADDRESS    3                                               *
*   FLAG              1                                               *
*   BITS                                                              *
*   0-1  00                                                           *
*   2-3  00  A-, Y-, Q-TYPE ADDRESS CONSTANT                          *
*        01  V TYPE ADDRESS CONSTANT                                  *
*        11 CXD                                                       *
*   4-5      LENGTH OF ADDRESS CONSTANT MINUS ONE                     *
*   6        EXD SIGN 0=PLUS, 1=MINUS                                 *
*   7    1   NEXT ENTRY HAS SAME POSITION AND RELOCATION ID           *
*        0   NEXT ENTRY HAS DIFFERENT POSITION AND/OR RELOCATION ID   *
*                                                                     *
*   XREF RECORDS FORMAT --                                            *
*   FIELD             BYTES                                           *
*   RECORD LENGTH       2                                             *
*   (NOT USED)        2                                               *
*   RECORD TYPE         2                                             *
*   SYMBOL              8                                             *
*   FLAGS               1                                             *
*   STATEMENT NUMBER    2                                             *
*   LENGTH              2                                             *
*   ASSEMBLED ORIGIN    4                                             *
*                                                                     *
*   RECORD FORMAT FOR LITERAL PER SE                                  *
*   FIELD              BYTES                                          *
*   RECORD LENGTH       2                                             *
*   (NOT USED)        2                                               *
*   RECORD TYPE         2                                             *
*   LITERAL             VARIABLE                                      *
*                                                                     *
*   LITERAL CROSS REFERENCE FORMATS                                   *
*   FIELD              BYTES                                          *
*   RECORD LENGTH       2                                             *
*   (NOT USED)          2                                             *
*   RECORD TYPE         2                                             *
*   LITERAL POOL ID     8                                             *
*   FLAGS               1                                             *
*   STATEMENT NUMBER    2                                             *
*   ENTRIES AFTER THIS POINT ARE FOR LITERAL XREF DEFINITION          *
*   RECORD ONLY.                                                      *
*   ASSEMBLED ORIGIN    4                                             *
*   N/P VALUE           L'JNOTEVAL                                    *
*                                                                     *
*OUTPUT-                                                              *
*   RLD RECORDS ARE PUNCHED AND/OR LINKED INTO PUNCH/LINK FILE(S).    *
*   SYMBOL/LITERAL CROSS REFERENCE RECORDS ARE WRITTEN ONTO PRINT FILE.
*                                                                     *
*   JOUTFILE AND FILE 2 ARE USED AS SORT/MERGE FILES AT SORT/MERGE TIME
*                                                                     *
*EXTERNAL ROUTINE-                                                    *
*   N/A                                                               *
*                                                                     *
*EXIT, NORMAL-                                                        *
*        JRETURN                                                      *
*                                                                     *
*EXITS, ERROR-                                                        *
*   N/A                                                               *
*TABLES/WORK AREAS-                                                   *
*   SORT AREA SIZE VARIES FROM 'MINCNT' BYTES TO 'MAXCNT' BYTES WITH  *
*   REGISTER 'SORTPTR' POINTS TO POINTERS AREA AND REGISTER 'DATAPTR' *
*   POINTS TO DATA AREA.                                              *
*   INPUT/OUTPUT BUFFERS ARE DYNAMICALLY LOCATED ABOVE THE EXECUTABLE *
*   CODE OF THIS PHASE WITH REGISTER R5 POINTS TO INPUT RECORD,       *
*   REGISTER 'LOUTNDX' POINTS TO PRINT OUTPUT RECORD, AND REGISTER    *
*   'COUTNDX' POINTS TO CARD OUTPUT RECORD.                           *
*                                                                     *
*ATTRIBUTES-                                                          *
*   REFRESHABLE                                                       *
*                                                                     *
*NOTES-                                                               *
*   N/A                                                               *
         EJECT
         COPY  JCOMMON
         EJECT
******************* COMMON AREA FOR POST PROCESSOR ********************
X6ACOMM  DSECT                          COMMON FOR X6A
         USING X6ACOMM,R7
STRTCOM  EQU   *                        START OF X6A COMMON
PPSW     DSW   RENT,                    RE-ENTRY TO SPILL ROUTINE      X
               DRDCHK,                  CHECK DUMMY READ               X
               FSW,                     FIRST TIME SWTICH              P
               EOFSW,                   EOF                            P
               HEADOUT,                 HEADER HAS JUST BEEN PRINTED   P
               PROCRLD,                 PROCESSING RLD RECORDS         P
               PROCXRF,                 PROCESSING XREF RECORDS        P
               PROCLIT                  PROCESSING LITERAL XREF RECORDS
PPSWI    DSW   JINREAD,                 READ(ON)/WRITE(OFF) ON JINFILE X
               LASTDEF,                 LAST XREF REC A DEF REC        X
               LASTREC,                 LAST REC TO OUTPUT             X
               ENDSTR1,                 END OF STRING ON 1             X
               ENDSTR2,                 END OF STRING ON 2             X
               FIRST,                   FIRST RLD PRINT        @OY06558X
               HEADPEND,                IND XREF HEADER PENDING@AZ28946X
               LINKSW                   ROUTER FOR PRINT RUTINE@AZ18946
CURFLE   DS    3D                       FILE 1
GNBLK1   EQU   CURFLE+2                 JINFILE ID
CFL1CC   EQU   GNBLK1+2                 STRING (GP) COUNT
CFL1VV   EQU   CFL1CC+2                 ARGUMENT
CURFLE2  EQU   CFL1VV+2                 FILE 2
GNBLK2   EQU   CURFLE2+2                JINFILE ID
CFL2CC   EQU   GNBLK2+2                 COUNT
CFL2VV   EQU   CFL2CC+2                 ARGUMENT
CURFLE3  EQU   CFL2VV+2                 FILE 3
GNBLK3   EQU   CURFLE3+2                JINFILE ID
CFL3CC   EQU   GNBLK3+2                 COUNT
CFL3VV   EQU   CFL3CC+2                 ARGUMENT
CHKFILE  DS    H                        FILE YET TO BE CHECKED
RECNUM   DS    H                        NUMBER OF RECORDS
STMTNUM  DS    F                        XREF STATEMENT NUMBER
STMTN2   EQU   STMTNUM+2
RTNSV2   DS    F
NEXTREC  DS    F
RTNSV1   DS    F
MRECSV   DS    F                        MERGE RECORD ADDRESS SAVED
RTNSV    DS    F                        RTN SAVE AREA
RFSAVE   DS    2F                       REG SAVE AREA
R15SAVE  DS    F                        R15 SAVE AREA
SAVEALL  DS    16F
BUFFER   DC    A(0)                     1
         DC    A(0)                     2
BUFEND1  DC    A(0)                     3
BUFFER2  DC    A(0)                     4
         DC    A(0)                     5
BUFEND2  DC    A(0)                     6
BUFFER3  DC    A(0)                     7
         DC    A(0)                     8
BUFEND3  DC    A(0)                     9
BUFFER4  DC    A(0)                     10
         DC    A(0)                     11
BUFEND4  DC    A(0)                     12
BUFFER5  DC    A(0)                     13
         DC    A(0)                     14
BUFEND5  DC    A(0)                     15
BUFFER6  DC    A(0)                     16
         DC    A(0)                     17.
BUFEND6  DC    A(0)                     18
BUFNDX   DS    F                        CURR REC IN CURR O/P BUFFER
JINFLP   DS    F                        JINFILE IN INDEX SAVED
SORTPTR  DS    F                        SORT AREA POINTER
DATAPTR  DS    F                        DATA AREA POINTER
R1SAVE   DS    F                        R1 SAVE
LOUTSV   DS    2F                       LOUTNDX SAVED
XRFPSV   EQU   LOUTSV+4                 XREF REF NEXT AVAIL LOC
LNCTRSV  DS    F                        LINE COUNTER SAVED
RTADDR2  DS    F                        RTN SAVED
PCHSAVE  DS    F                        PUNCH BUFFER POINTER
FWORD    DS    F                        WORK AREAS
SAVSYM   DS    D                        XREF SYMBOL SAVE AREA
UNDFSYM  DS    D                        XREF UNDEFINED SYMBOL SAVE AREA
NOTESV   DS    CL(L'JNOTEVAL)           N/P SAVE AREA
DATAAND  DS    F
LLOCTRSV DS    F                        LITERAL LOCTR SAVED
SAVE2B   DS CL2                         OVERLAP BYTES SAVED
         DS    0D
UNPKAREA DS    CL15                     UNPACK AREA
         ORG   UNPKAREA                 REDEFINE
UPPOS    DS    CL4                      POSITIONAL ID
UPREL    DS    CL4                      RELATIONAL ID
UPVAL    DS    CL6                      ASSEMBLED ORIGIN
UPFLG    DS    CL2                      FLAGS
UPFLGN   EQU   UPFLG+1
         ORG   UNPKAREA                 REDEFINE
CVDCML   DS    D                        CONVERT INTO DECIMAL
UPDCML   EQU   CVDCML+5                 UNPACK 3 BYTES
UPXRL    EQU   *-UPDCML                 LENGTH OF 3
         ORG   UPVAL+2                  REDEFINE
UPX      DS    CL5                      INTO 5-BYTE AREA
         ORG   UNPKAREA                 REDEFINE
UPXVAL   DS    CL9                      XREF VALUE UNPACK AREA
         ORG
RTADDR   DS    3D                       SAVE AREA
RLDHLD   DS    0CL8                     RLD HOLD AREA
RELHLD   DS    CL2                      RELOCATION I.D.
POSHLD   DS    CL2                      POSITION I.D.
FLGHLD   DS    C                        FLAG
ADDRHLD  DS    CL3                      SYMBOL ADDRESS
ESDCOMP  DS    0CL4                     ESDID SAVE AREA
RELTST   DS    CL2                      RELOCATION I.D.
POSTST   DS    CL2                      POSITION I.D.
XLDSV    DS    CL20                     LITERAL SAVE AREA
UPXSV    DS    CL5                      UNDEF SYM STMT NUMBER SAVED
RECSAVE  DS    CL(121)                  SAVE AREA FOR XREF REC @AZ28946
         EJECT
*************************************** EQUATE TABLE ******************
LBASE    EQU   2                        LOWER DATA ITEM REGISTER
SINDEX   EQU   2                        SORT AREA INDEX REG
COUTNDX  EQU   5                        CARD OUTPUT POINTER
XRFPTR   EQU   3                        XREF REF ENTRY POINT
HBASE    EQU   3                        UPPER DATA ITEM REGISTER
DINDEX   EQU   3                        DATA AREA INDEX REG
LOUTNDX  EQU   2                        LIST OUTPUT POINTER
RECCTR   EQU   4                        RECORD COUNTER
SRTNTRY  EQU   4                        SORT AREA ENTRY LENGTH
LINCTR   EQU   RECCTR                   LINE COUNTER
RLREG    EQU   5                        RECORD LENGTH REGISTER
RTN      EQU   6                        RETURN LINKAGE
PARM1    EQU   10                       PARAMETER REG 1
PARM2    EQU   11                       PARAMETER REG 2
LINK     EQU   12                       LINKAGE
RLDCNT   EQU   14                       RLD BYTE COUNT
HPOINT   EQU   14                       ADDRESS OF UPPER DATA ITEM
LPOINT   EQU   15                       ADDRESS OF LOWER DATA ITEM
SAMEID   EQU   1                        XREF DEFINITION ID
MINCNT   EQU   127                      MINIMUM CORE IN DOUBLE WORDS
MAXCNT   EQU   4095                     MAXIMUM CORE IN DOUBLE WORDS
MASKLEN  EQU   4                        MASK LENGTH FOR PAGE COUNT
XBLANK   EQU   X'40'                    EXTERNAL BLANK
JTEOF    EQU   X'FF'                    INTERNAL EOF OP CODE
JPSOP    EQU   X'80'
MRGFLE1  EQU   JOUTFILE                 MERGE FILE 1
MRGFLE2  EQU   FILE2                    MERGE FILE 2
ENDCOMM  DS    0D                       END OF X6A COMMON
         EJECT
*************************************** OUTPUT RECORD FORMATS *********
RPRINT   DSECT                          RLD PRINT RECORD FORMAT
         USING RPRINT,LOUTNDX
RCNTRL   DS    C                        RLD PRINT CONTROL BYTE
         DS    CL1
POSOUT   DS    CL4                      POSITION ESD/ID
         DS    CL5
RELOUT   DS    CL4                      RELOCATION ESD/ID
         DS    CL6
FLGOUT   DS    CL2                      RLD FLAG
         DS    CL5
VALOUT   DS    CL6                      RLD SYMBOL ADDRESS
         DS    CL87
         SPACE
         ORG   RCNTRL                   XREF PRINT RECORD FORMAT
XCNTRL   DS    C                        XREF PRINT CONTROL BYTE
XSYMOUT  DS    CL8                      XREF SYMBOL
         DS    C
XLENOUT  DS    CL5                      LENGTH OF XREF
         DS    C
XVALOUT  DS    CL8                      VALUE OF XREF
         DS    C
XDEFOUT  DS    CL5                      ADDRESS WHERE XREF DEFINED
LITDL    EQU   *-XLENOUT
XDE      DS    CL2
XDEFLN   EQU   *-XCNTRL
XRFREF   DS    CL89                     REFERENCES TO SYMBOL
XPRTND   EQU   *
         ORG   XRFREF
XRFENT   DS    CL5                      XREF REFERENCE ENTRY
         DS    C                        SEPARATOR
XRENTL   EQU   *-XRFENT
         SPACE
         ORG   XCNTRL                   LIT XREF DEF PRINT RECORD FMT
LCNTRL   DS    C                        LIT XREF CONTROL CHAR
LITSYM   EQU   *                        LITERAL XREF DEFINITION
LITSYM5  EQU   LITSYM+5
         ORG
XRL      EQU   *-XCNTRL
         SPACE
         ORG   RCNTRL                   LISTING HEADER FORMATS
CONTROL  DBV   ,                        LIST CONTROL CHARACTER VALUES  X
               EJBYTE(0),               EJECT                          X
               SPACE1(EJBYTE+1),        SINGLE SPACE                   X
               SPACE2(SPACE1+1),        DOUBLE SPACE                   X
               SPACE3(SPACE2+1)         TRIPPLE SPACE
TITLE    DS    CL4                      TITLE
         DS    CL38                     BLANKS
LHDPTR   DS    CL8                      LIT XREF HEADING PTR
HDGPTR   DS    CL21                     RLD OR XREF PAGE IDENTIFIER
         DS    CL25
DTEPTR   DS    CL15                     DATE
PGEPTR   DS    CL4                      PAGE
PGENUM   DS    CL5                      PAGE NUMBER
         SPACE 3
***************
RCARD    DSECT                          RLD PUNCH RECORD FORMAT
         USING RCARD,COUTNDX
CARDID   DS    C                        RLD CARD LAYOUT
RLDNAM   DS    CL3                      RLD NAME
         DS    CL6
RLDBYT   DS    CL2                      NUMBER OF BYTES IN DATA FIELD
         DS    CL4
RLDFLD   DS    CL56                     RLD DATA FIELD (VARIABLE)
DECKID   DS    CL4                      ID AND
SEQNUM   DS    CL4                      SEQUENCE FIELD
RCARDL   EQU   *-CARDID
         SPACE 3
*************************************** INPUT RECORD FORMATS **********
         COPY  RXLFMTS
         EJECT
************************************************************
*   ENTRY TO POST PROCESSOR
************************************************************
         JCSECT (X6A00)
* VS1 RELEASE 2.6 CHANGES
*C381500-382000                                                 OX00413
*C280000                                                        OX00106
*A284700-284800                                                 OX00106
*A722064                                                        OX02645
*C722060                                                        OX02645
*C381500                                                        OX02955
*D382000                                                        OX02955
*D684400                                                       @OY06121
*A803400,803500                                                @OY07206
*A076920,789000,789300                                         @OY06558
*C789400                                                       @OY06558
*A613520-613540                                                @OY08038
*C975800                                                       @OY10363
*C284700                                                       @OY08064
*C722350                                                       @AX14198
*A613504-613516                                                @AX14816
*A613536-613599,613820-613849                                  @AZ11958
*D613520,613540                                                @AZ11958
*A076930,713000-713270,714800-715200,137300,751900             @AZ28946
*A750500-751030,613509-613516,076950,615850-615880             @AZ28946
*C613508                                                       @AZ28946
         JMODID
PPENT    JSAVE
         JENTRY (X6A01=PPENT)
         EJECT
************************************************************
*   PHASE INITIALIZATION
************************************************************
         GOIF  (JRLDCHK,JXREFCHK),OFF=RETURN  RETURN TO CONTROLLER
         LA    R10,(ENDCOMM-STRTCOM+7)/8  SIZE OF X6ACOMM
         JGETCORE DBL=(R10)             GET CORE FOR COMMON AREA
         LR    R7,R10                   BASE FOR X6A COMMON AREA
         BCTR  PARM2,0                  MAKE IT MOVE LENGTH
         XC    STRTCOM(255),STRTCOM          CLEAR COMMON AREA
         S     PARM2,F255
         EX    PARM2,CLRCOM             CLEAR COMMON AREA
         LH    R3,MRGFLE1               INITIALIZE MERGE FILE SWITCHES
         LA    R4,MRGFLE2
         STH   R3,CURFLE
         STH   R4,CURFLE2
         LH    R3,JINFILE
         STH   R3,CURFLE3
         MVI   GNBLK3,X'80'             JINFILE ID
************************************************************
*   BUFFER AND SORT AREA INITIALIZATION
************************************************************
X6AENT   EQU   *
         GOIF  (JDECK,JLINK,JLIST),OFF=RETRN
         LH    R3,JMAXRL                ASSURE MINIMUM CORE AVAILABLE
         LR    R4,R3                      IS JMAXRL*2 PLUS ITS SORTPTR
         AR    R3,R4                      AREA AND MAXIMUM OF 64K BYTES
         SR    R2,R2                      WHICH CAN STILL BE EXTENDED
         LA    R5,RLDND
         DR    R2,R5
         SLL   R3,D2
         AR    R3,R4                    .
         AR    R3,R4                    .
         AR    R3,R4                    .
         AR    R3,R4                    .
         AR    R3,R4                    .
         AR    R3,R4                    .
         SRL   R3,D3                    MAKE IT DOUBLE WORD
         L     R11,K72D
         JGETCORE MINDBL=(R3),MAXDBL=(R11)
         LA    R5,BUFFER
         LA    R6,D6                    LOOP 6 TIMES
INIT     ST    PARM1,D0(,R5)            BUFFER BEGIN
         STH   R4,D4(,R5)               JMAXRL
         SR    PARM2,R4
         AR    PARM1,R4
         ST    PARM1,D8(,R5)            BUFFER END
         LA    R5,D12(,R5)
         BCT   R6,INIT                  ITERATE TILL DONE
         SR    PARM1,R4                 BACK UP
         SR    PARM1,R4                 BACK UP
         AR    PARM2,R4                 BACK UP
         AR    PARM2,R4                 BACK UP
         ST    PARM1,SORTPTR            SET START POINT OF SORT AREA
         LR    R3,PARM2                 GET AVAILABLE CORE SIZE
         SR    R2,R2
         LA    R5,XRFND+SRTNTRY         COMPUTE SORT AREA SIZE
         LH    R14,JLITLNG
         LTR   R14,R14
         BZ    INIT10                   NO LITERALS
         LA    R5,SRTNTRY+LXEND+D3+D1(,R14) COMPUTE DIVISOR
         N     R5,=X'FFFFFFFC'          WITH FULL-WORD ALIGNMENT.
INIT10   EQU   *
         DR    R2,R5                    FIND LENGTH OF
         SLL   R3,D2                    SORT AREA AND
         AR    R3,PARM1                 SET POINTER TO DATA AREA
         ST    R3,DATAPTR               AND SAVE
         ST    R3,XRFPSV                CREATE DUMMY CONDITION
         LA    PARM2,D0(PARM2,PARM1)
         ST    PARM2,DATAAND            END OF SORT AREA
         L     R3,BUFFER3
         LA    R3,D6(,R3)               OVER HEADER
         ST    R3,BUFNDX                AND SAVE IT
         SET   FSW,ON
X6AREAD  EQU   *
         SR    RECCTR,RECCTR            INITIAL RECORD COUNT IS ZERO
         LM    SINDEX,DINDEX,SORTPTR    GET POINTERS
         SPACE
         USING PPIN,PARM2
         BAL   R6,RDPHYREC              READ PHYSICAL RECORD
         EJECT
************************************************************
*   GTRGTR ROUTINE READS DATA FROM JINFILE AND SELECTIVELY MOVES
*   RECORDS INTO SORT AREA.
*   BUFFERS USED ARE BUFFER AND BUFFER2.
************************************************************
GTRGTR   BAL   R12,BUFIN                READ RECORDS
GTRGTR0  L     R9,DATAPTR               SET UP REGISTERS
         L     R10,BUFEND2
GTRGTR1  LH    R15,PPRLI
         CLI   PPIOC,XRFTYPE            SELECT THE FOLLOWING
         BE    GTRGTR15                   THREE TYPES OF RECORDS
         CLI   PPIOC,RLDTYPE              INTO SORT AREA, AND THROW
         BE    GTRGTR02                    AWAY OTHERWISE       OX00106
         CLI   PPIOC,LITTYPE
         BE    GTRGTR5                  LITERAL
         CLI   PPIOC,JTEOF              DON'T LET EOF RECORD
         BNE   GTRGTR4                    SLIP THROUGH
         SET   EOFSW,ON
         B     GTRGTR3                  ITS AS GOOD AS SORT AREA FULL
GTRGTR02 NI    RELID,X'F3'                                     @OY08064
         B     GTRGTR2                                          OX00106
GTRGTR15 EQU   *
*                                       DON'T PICK UP XREF RECORD IF
         GOIF  (JLIST,JXREF),NOTALL=GTRGTR4    NO LIST/XREF OPTIONS
         TR    XRFSYM,JTRTABLE
GTRGTR2  BCTR  R15,0
         EX    R15,MOVREC               MOVE TO SORT AREA
         LA    R15,D1(,R15)               AND
         ST    DINDEX,D0(,SINDEX)         SET UP ITS POINTER,
GTRGTR25 LA    SINDEX,SRTNTRY(,SINDEX)
         LA    RECCTR,D1(,RECCTR)       RECORD COUNT
         AR    DINDEX,R15
         CR    SINDEX,R9                TEST IF SORT AREA FULL
         BL    GTRGTR4                  NO, CONTINUE
         AR    PARM2,R15                YES
         CR    PARM2,R10                TEST IF BUFFER FULL
         BL    GTRGTR3                  NOT YET
         BAL   R12,BUFIN                GET NEXT BUFFER
GTRGTR3  ST    PARM2,JINFLP             SAVE NEXT RECORD LOCATION
         STH   RECCTR,RECNUM
         CLI   PPIOC,JTEOF              END OF FILE
         BNE   X6ARD                    GO TO SORT IF NOT EOF
         SET   EOFSW,ON                 IND END OF FILE
         B     X6ARD                    GO TO SORT
GTRGTR4  AR    PARM2,R15                TEST IF
         CR    PARM2,R10                  BUFFER FULL
         BL    GTRGTR1                  NOT YET
         B     GTRGTR                   YES
GTRGTR5  GOIF  (JLIST,JXREF),NOTALL=GTRGTR4
         C     R15,F255                 LITERAL RECORD MIGHT GO
         BNH   GTRGTR2                    OVER 255 CHARACTERS. SO
         MVC   D0(255,DINDEX),PPRLI       WATCH OUT HOW YOU MOVE IT
         S     R15,F255
         ST    DINDEX,D0(,SINDEX)
         A     DINDEX,F255
         A     PARM2,F255
         EX    R15,MOVREC
         B     GTRGTR25                 CONTINUE
MOVREC   MVC   D0(0,DINDEX),PPRLI       OFF-THE-LINE MOVE
X6ARD    EQU   *
         LTR   RECCTR,RECCTR            MUST BE EOF IF RECCTR = 0
         BP    X6ASRT                   NOT ZERO
*                                              IF NOT 1ST TIME AND
         GOIF  (EOFSW,FSW),NOTALL=X6ARDX         EOF THEN FINISH SORT
         LH    PARM1,JINFILE            GET FILE ID
         JCHECK FILE=(R10)              CHECK THE LAST INPUT READ
         B     RETRN                    NO RECORDS, SO WE'RE DONE
         EJECT
X6ASRT   EQU   *
************************************************************
*   THIS ROUTINE LINKS TO SORT ROUTINE, SELECTS AN OUTPUT FILE FOR
*   THE SORTED DATA ACCORDING TO THE PREDETERMINED NUMBER OF STRINGS
*   TO BE OUTPUT ON THE TWO OUTPUT FILES - CURFLE AND CURFLE2.
*   IT ALSO PADS THE OUTPUT FILES, IF NECESSARY, TO THE NUMBER OF
*   STRINGS THAT WILL SATISFY THE REQUIREMENT OF THE CASCADE MERGE.
************************************************************
         BAL   RTN,SORT                 SORT RECORDS IN BUFFER
         GOIF  EOFSW,ON=X6ARDX          DID WE HIT EOF SO FAR
         SR    RECCTR,RECCTR            NO
         LM    SINDEX,DINDEX,SORTPTR    GO BACK TO READ IN
         L     PARM2,JINFLP               NEXT SORT AREA FULL
         B     GTRGTR0                    OF RECORDS
X6ARDX   EQU   *
*        END OF SORT. PAD BOTH FILES IF NECESSARY.
         CLC   CFL1CC(D2),CFL1VV        HASH OUT HOW MANY STRINGS
         BNE   RDX10                      WE NEED ON EITHER OF
         CLC   CFL2CC(D2),CFL2VV          THE TWO FILES, AND HOW MANY
         BE    RDX40                      HAVE WE GOT ON EACH OF THEM
RDX10    CLC   CFL1CC(D2),CFL2CC        DICHOTOMY
         BH    RDX20                    OK
         XC    CURFLE(D8),CURFLE2       GET HIGHER ONE ON CURFLE
         XC    CURFLE2(D8),CURFLE
         XC    CURFLE(D8),CURFLE2
RDX20    TM    CFL1CC+1,X'01'           TEST ODD/EVEN # OF GPS
         BO    RDX30                    ODD
         BAL   RTN,PADDING1             PAD ONE BLOCK
RDX30    SR    R2,R2
         LH    R3,CFL1CC                TEST IF DIVISIBLE BY 3
         LA    R1,D3
         CR    R3,R1                    NO NEED TO TEST IF
         BL    RDX40                      DIVIDEND IS LESS THAN 3
         DR    R2,R1
         LTR   R2,R2
         BNZ   RDX40                    NOT DIVISIBLE BY 3
         LH    R3,CFL2CC                ELSE, TEST THE OTHER FILE
         CR    R3,R1
         BL    RDX40                    LESS THAN 3 ON THIS ONE TOO
         DR    R2,R1
         LTR   R2,R2
         BNZ   RDX40                    NOT DIVISIBLE BY 3
         BAL   RTN,PADDING              PAD IT
RDX40    SET   EOFSW,OFF
         LH    PARM1,CHKFILE
         JCHECK FILE=(R10)              CHK LAST OUTPUT FOR COMPLETION
         LH    R10,JINFILE
         JNOTE FILE=(R10)               NOTE LAST RECORD READ
         MVC   NOTESV(L'JNOTEVAL),JNOTEVAL  SAVE NOTED VALUE
         LH    R10,CURFLE
         JPOINT FILE=(R10),NEXT=START   REPOSITION ALL FILES
         LH    R10,CURFLE2                TO START EXCEPT
         JPOINT FILE=(R10),NEXT=START     JINFILE
         LH    R0,CFL1CC
         LH    R1,CFL2CC
         B     MERGE                    ENTER MERGE STAGE
         SPACE
PADDING  XC    CURFLE(D8),CURFLE2       THIS IS TO PAD ONE STRING ON
         XC    CURFLE2(D8),CURFLE         EITHER OF THE TWO FILES, BUT
         XC    CURFLE(D8),CURFLE2         CHECK LAST OUTPUT FOR
PADDING1 LH    PARM1,CHKFILE              COMPLETION FIRST
         JCHECK FILE=(R10)
         L     R2,BUFFER3
         MVC   D6(L'EOFREC,R2),EOFREC
         LH    R3,H1
         STH   R3,D2(,R2)               LAST BLK IN GP
         STH   R3,D4(,R2)               ONE RECORD IN BLK
         LA    R3,L'EOFREC+D6
         STH   R3,D0(,R2)               RECORD LENGTH
         LH    PARM1,CURFLE
         LA    PARM2,BUFFER3
         JWRITE FILE=(R10),PARM=(R11)   PADDED BLK
         STH   R10,CHKFILE
         LH    R9,CFL1CC
         LA    R9,D1(,R9)               UP ONE STRING (GP)
         STH   R9,CFL1CC
         BR    RTN                      RETURN
CLRCOM   XC    STRTCOM+255(0),STRTCOM+255 OFF-THE-LINE ZAC
         EJECT
*******************************************************************
*   THIS ROUTINE READS DATA FROM JINFILE.
*   BUFFERS USED ARE BUFFER AND BUFFER2.
*******************************************************************
BUFIN    ST    R12,RTNSV2
         LH    PARM1,JINFILE            CHECK JINFILE I/O
         JCHECK FILE=(R10)                COMPLETION HERE
         L     PARM2,BUFFER
         LH    R12,D0(,PARM2)
         AR    R12,PARM2
         ST    R12,BUFEND1
         XC    BUFFER(D12),BUFFER2      INTERCHANGE BUFFERS
         XC    BUFFER2(D12),BUFFER
         XC    BUFFER(D12),BUFFER2
         SH    R12,H8
         CLC   D2(D3,R12),EOFREC+2      TEST IF LAST INPUT BLOCK
         BE    BUFIN40                  YES.
         BAL   R6,RDPHYREC              NO, READ NEXT BLOCK
         L     PARM2,BUFFER2
BUFIN40  LA    PARM2,D2(,PARM2)         INCREMENT BY 2          OX02955
         L     R12,RTNSV2               PREPARE TO RETURN TO CALLER
         BR    R12                      RETURN TO CALLER
         SPACE 3
RDPHYREC LH    PARM1,JINFILE            READ FROM JINFILE
         LA    PARM2,BUFFER
         JREAD FILE=(R10),PARM=(R11)
         BR    R6                       DON'T WAIT FOR I/O COMPLETION
         DROP  PARM2
         EJECT
************************************************************
*   SORT ROUTINE SORTS RLD'S, SYMBOL XREF'S, AND LITERAL XREF'S.
************************************************************
SORT     EQU   *
         LA    RLREG,XRFLN-1            GET SORT CONTROL FIELD LENGTH-1
         LH    R1,RECNUM                NUMBER OF LOGICAL RECORDS IN
         BCTR  R1,0                          CORE MINUS ONE,
         SLL   R1,J2                              TIMES FOUR, BECAUSE
*                                         EACH RECORD CONTAINS 4 BYTES
         ST    R1,FWORD
         L     R4,SORTPTR               POINTER TO DATA POINTERS
         CH    R1,H4                    TEST IF ONLY 2 ENTRIES
         BE    SORTZ                    YES
SORT1    SRL   R1,J1                    MIDDLE OF DATA POINTERS
         N     R1,ALIGN                 FULL WORD ALIGNMENT
         BZ    SPILLENT                 END OF SORT
SORTZ    EQU   *
         SR    R0,R0                    INITIALIZE SUB SEQUENCE BASE
SORT4    LR    HPOINT,R0
SORT2    LR    LPOINT,HPOINT            STEP TO NEXT SUB SEQUENCE PAIR
SORT3    LA    HPOINT,D0(R1,LPOINT)     UPPER INDEX = LOWER + DELTA
         C     HPOINT,FWORD             UPPER INDEX = LOWER + DELTA
         BH    SORT5                    YES, STEP TO NEXT SUB SEQUENCE
         L     LBASE,D0(LPOINT,R4)      POINTER TO LOWER DATA ITEM
         L     HBASE,D0(HPOINT,R4)      POINTER TO UPPER DATA ITEM
         EX    RLREG,COMPARE            COMPARE DATA ITEMS
         BNH   SORT2                    BRANCH IF IN SEQUENCE
         ST    LBASE,D0(HPOINT,R4)      LET UPPER ITEM SINK
         ST    HBASE,D0(LPOINT,R4)      EXCHANGE DATA RECORDS
         SR    LPOINT,R1
         BNL   SORT3                    POSSIBLY ALL THE WAY
         B     SORT2                       TO THE BOTTOM.
SORT5    AH    R0,H4                    STEP TO NEXT SUB-SEQUENCE
         CR    R0,R1                    TEST FOR END OF PASS
         BL    SORT4                    NO, SORT NEXT SUB SEQUENCE
         B     SORT1                    YES, INITIALIZE NEW PASS
COMPARE  CLC   D4(0,LBASE),D4(HBASE)    COMPARE DATA ITEMS
         DS    0F
ALIGN    DC    XL4'FFFFFFFC'            MASK FOR FULL WORD ALIGNMENT
         EJECT
************************************************************
*   THIS ROUTINE HAS THE CONTROL OF THE OUTPUT OF DATA FROM SORT AREA.
*   IT CONTROLS THE DISTRIBUTION OF STRINGS ONTO THE TWO FILES THAT
*   ARE TO BECOME THE TWO INITIAL INPUT FILES TO THE CASCADE MERGE.
************************************************************
SPILLENT ST    RTN,RTADDR
         SET   RENT,ON                  RE ENTRY TO MERGE ROUTINE
         SR    R3,R3
         L     R5,SORTPTR               GET BEGIN OF SORT AREA AND
*                                         RECORD COUNT
         LH    R4,RECNUM
*                                       BRANCH IF ALL RECORDS ARE
         GOIF  (EOFSW,FSW),ALL=NOMREC     IN THE SORT AREA
         SPACE 3
*        SPILL SORTED RECORDS INTO CURFLE AND CURFLE2
SPILL    EQU   *
         GOIF  FSW,OFF=SPILL10
*        FIRST TIME SPILLING            INITIATE STRING CONTROL NUMBER
         MVI   CFL1VV+1,D3                TO BOTH OUTPUT FILES AND
         MVI   CFL2VV+1,D1                SPILL STRINGS ONTO BOTH FILES
SPILL5   L     R2,BUFFER3                 ACCORDINGLY
         XC    D2(D2,R2),D2(R2)
         LA    R2,D6(,R2)               BUMP PAST BUFFER HEADER
         L     R0,BUFEND3
SPILLING L     R1,D0(,R5)               GET THE NEXT DATA RECORD
         LH    R9,D0(,R1)               GET LENGTH OF DATA RECORD
SPLNG1   LR    R11,R9                   PUT DATA LENGTH IN REG
         AR    R11,R2                   ADD IN BEGINNING ADDR OF BUFFER
         CR    R11,R0                   ARE WE AT THE END OF BUFFER
         BH    SPILTH                   YES, END OF BUFFER
         C     R9,F255                  NO, MOVE IN
         BNH   SPLNG2
         MVC   D0(255,R2),D0(R1)        RCD >255, MOVE IN DEFAULT 255
         S     R9,F255                  ADJUST TO DEFAULT RECORD LENGTH
         A     R1,F255                  BUMP UP POINTERS
         A     R2,F255
SPLNG2   BCTR  R9,0                     NO, MAKE IT MOVE LENGTH
         EX    R9,SPLMV                   AND MOVE
         LR    R2,R11                   UP BUFFER POINTER
         LA    R3,D1(,R3)               UP RECORD COUNT BY 1
         LA    R5,SRTNTRY(,R5)          UP SORT AREA POINTER BY 4
         BCT   R4,SPILLING              GET NEXT RECORD
*        WRITE LAST SHORT BLOCK
         SR    R9,R9                    NO MORE RECORD, SO
         L     R11,BUFFER3              GET START OF BUFF3 FOR WRITE OP
         OI    D3(R11),X'01'            LAST BLK IN THIS GP
         B     SPILTH1                  OUT ON FILE
SPLMV    MVC   D0(0,R2),D0(R1)
SPILTH   L     R11,BUFFER3              GET ADDR OF BUFFER
SPILTH1  STM   R0,R9,SAVEALL            CONSTRUCT THE BLOCK
         SR    R2,R11                   HEADER
         STH   R2,D0(,R11)              POINTER TO FIRST RCD IN BLOCK
         STH   R3,D4(,R11)              NUMBER OF RECORDS IN BLOCK
         TM    PPSW,FSW+RENT
         BO    SPLOUT                   FIRST TIME ENTRY
         TM    PPSW,RENT
         BO    CHKIT                    RE-ENTRY. MUST CHECK LAST
*                                         OUTPUT FILE
         LH    PARM1,CURFLE
         JCHECK FILE=(R10)
         B     SPLOUT
CHKIT    LH    PARM1,CHKFILE
         JCHECK FILE=(R10)              CHECK FOR COMPLETION
SPLOUT   SET   RENT,OFF
         LH    PARM1,CURFLE
         LA    PARM2,BUFFER3
         JWRITE FILE=(R10),PARM=(R11)   WRITE ON CURFLE
         LM    R0,R9,SAVEALL
         XC    BUFFER3(D12),BUFFER4     ALTER BUFFERS
         XC    BUFFER4(D12),BUFFER3
         XC    BUFFER3(D12),BUFFER4
         L     R2,BUFFER3               INITIATE NEXT BUFFER
         XC    D2(D2,R2),D2(R2)           WHILE CURRENT BUFFER IS
         LA    R2,D6(,R2)                 BEING WRITTEN OUT
         L     R0,BUFEND3
         SR    R3,R3
         LTR   R9,R9                    END OF GP TEST
         BP    SPLNG1                   OVERFLOW, NOT END OF STRING
         STH   R10,CHKFILE
         LH    R11,CFL1CC               END OF GP (STRING)
         LA    R11,D1(,R11)             INCREMENT STRING COUNT
         STH   R11,CFL1CC
         L     RTN,RTADDR
         GOIF  FSW,OFF=(RTN)            RETURN IF NOT FIRST ACTION
         SET   FSW,OFF                  ELSE
         XC    CURFLE(D8),CURFLE2       FLIP FIELD
         XC    CURFLE2(D8),CURFLE
         XC    CURFLE(D8),CURFLE2
         BR    RTN                      THEN RETURN
         SPACE
SPILL10  EQU   *
         CLC   CFL1CC(D2),CFL1VV
         BL    SPILL5                   OUTPUT ON SAME FILE
         XC    CURFLE(D8),CURFLE2       OUTPUT ON THE OTHER FILE
         XC    CURFLE2(D8),CURFLE
         XC    CURFLE(D8),CURFLE2
         LH    R11,CFL1VV               COMPUTE NEXT STRING CONTROL
         CH    R11,CFL2VV                 NUMBER ON THIS 'OTHER' FILE
         BL    SPILL20                    .
         SH    R11,CFL2VV                 .
         B     SPILL30                    THEN
SPILL20  AH    R11,CFL2VV                 .
SPILL30  STH   R11,CFL2VV                 .
         B     SPILL5                   GO SPILL RECPRDS
EOFREC   DS    0CL18                    EOF RECORD
         DC    AL2(L'EOFREC)            RL
         DC    AL1(JPSOP,0)             FLAGS
         DC    AL1(JTEOF)               IOC
         DC    AL1(X'EE',X'00',X'FF')   SPECIAL ID
         DC    2AL1(JASTER,X'EE',X'00',X'FF') PADDING
         DC    AL2(0)                   PADDING
EOFL     EQU   *-EOFREC                 LENGTH
         EJECT
************************************************************
*   THIS ROUTINE DOES THE CASCADE MERGE TILL THE NUMBER OF
*   STRINGS ON BOTH INPUT FILES DECREMENT TO ONE.
************************************************************
*        READ FROM CURFLE AND CURFLE2
*        WRITE ON CURFLE3
*        ALL FILES REPOSITIONED TO GO
MERGE    EQU   *
         BAL   RTN,READFL1              READ INTO BFRS 1 & 2 FROM FILE1
         BAL   RTN,READFL2              READ INTO BFRS 3 & 4 FROM FILE2
MERGE1   SR    R11,R11
         L     R12,BUFFER5              WRITE BUFFER
         XC    D2(D2,R12),D2(R12)
         LA    R12,D6(,R12)
MERGE2   SET   FSW,ON
         CH    R0,H1                    DO NOT MERGE LAST PASS
         BH    CPRMRG                   IF
         CH    R1,H1                    BOTH FILES HAVE DATA
         BH    CPRMRG
         CLC   CFL3CC(D2),H1            IF THIRD FILE CONTAINS DATA
         BNL   CPRMRG                   CONTINUE MERGE
         B     OUTPUTS                  MERGE AS THEY PRINT/PUNCH
         SPACE 3
BUMPFL1  LR    R2,R14
CPRMRG   CLC   D4(XRFLN,R2),D4(R3)
         BL    FL1LO                    FILE 1 LOW
         BE    EEREC                    POSSIBLE END OF FILE/GROUP
FL2LO    LR    R14,R3                   RECORD POINTER
         BAL   RTN,PUTREC               PUT ONE RECORD
         BCT   R5,BUMPFL2               KEEP TRACK OF COUNT AND BR
         BCT   R10,CHKFL2               READ IF END OF BLOCK
         LA    R3,EOFREC                LAST BLK ON GROUP
         B     CPRMRG                   NEXT RECORD
BUMPFL2  LR    R3,R14                   NEXT RECORD
         B     CPRMRG                   GO
CHKFL2   BAL   RTN,FL2CHECK             CHECK/READ
         B     CPRMRG                   COMPARE
         SPACE
FL1LO    LR    R14,R2
         BAL   RTN,PUTREC
         BCT   R4,BUMPFL1               COUNT/BRANCH
         BCT   R9,CHKFL1                CHECK/READ
         LA    R2,EOFREC                POINT TO EOFREC
         B     CPRMRG                   NEXT REC
CHKFL1   BAL   RTN,FL1CHECK             CHECK/READ
         B     CPRMRG                   NEXT RECORD
EEREC    CLI   D4(R2),JTEOF             TEST IF END OF GROUP
         BNE   FL1LO                    NO
         BAL   RTN,PUTLBLK              OUTPUT LAST BLOCK
         STM   R0,R1,SAVEALL
         LH    R10,CURFLE3              TO CURFLE3
         JCHECK FILE=(R10)              WAIT FOR COMPLETION
         LM    R0,R1,SAVEALL
         BCTR  R1,0                     MINUS 1 ON CURFLE2 STRING COUNT
         SH    R0,H1                    MINUS 1 ON CURFLE STRING COUNT
         STM   R0,R1,SAVEALL
         BP    GPCNT2                   CURFLE=0 STRING
         STH   R0,CFL1CC
         XC    CURFLE(D8),CURFLE3       FLIP 1 AND 3
         XC    CURFLE3(D8),CURFLE       .
         XC    CURFLE(D8),CURFLE3       .
         LH    R0,CFL1CC
         ST    R0,SAVEALL
         TM    GNBLK1,X'80'             TEST IF JINFILE
         BZ    EEREC2                   NO
         LH    R10,CURFLE               YES, POINT BACK TO NOTED LOC
         LA    R11,NOTESV
         JPOINT FILE=(R10),ADDR=(R11),NEXT=READ
         LH    R10,CURFLE
         BAL   RTN,DUMMYRD              GET BY THE NOTED RECORD
         LH    R10,CURFLE3
         JPOINT FILE=(R10),NEXT=START   REPOSITION CURFLE3
         B     EERECXY                  NEXT STRING
EEREC2   TM    GNBLK3,X'80'
         BZ    EEREC4                   BR IF NOT JINFILE
         LH    R10,CURFLE3              YES, POINT BACK TO NOTED LOC
         LA    R11,NOTESV
         JPOINT FILE=(R10),ADDR=(R11),NEXT=WRITE
EEREC3   LH    R10,CURFLE
         JPOINT FILE=(R10),NEXT=START   REPOSITION CURFLE
EERECXY  LM    R0,R1,SAVEALL
         BAL   RTN,READFL1              READ FIRST BLOCK FROM CURFLE
EERECXZ  BAL   RTN,FL2CHECK             CONTINUE READING CURFLE2
         B     MERGE1                   CONTINUE PROCESSING
EEREC4   LH    R10,CURFLE3
         JPOINT FILE=(R10),NEXT=START   REPOSITION CURFLE3
         B     EEREC3                   .
GPCNT2   CH    R1,H1
         BL    GPCNT3                   CURFLE2=0 STRING
         BAL   RTN,FL1CHECK             NOT EXHAUSTED YET, READ
         B     EERECXZ                    NEXT BLOCK AND GO
GPCNT3   EQU   *
         STH   R1,CFL2CC
         XC    CURFLE2(D8),CURFLE3      FLIP 2 AND 3
         XC    CURFLE3(D8),CURFLE2
         XC    CURFLE2(D8),CURFLE3
         LH    R1,CFL2CC
         ST    R1,SAVEALL+4
         TM    GNBLK2,X'80'             TEST IF JINFILE
         BZ    EEREC6                   NO
         LH    R10,CURFLE2              YES, POINT TO THE NOTED LOC
         LA    R11,NOTESV
         JPOINT FILE=(R10),ADDR=(R11),NEXT=READ
         LH    R10,CURFLE2
         BAL   RTN,DUMMYRD              GET BY THE NOTED RECORD
         LH    R10,CURFLE3
         JPOINT FILE=(R10),NEXT=START   REPOSITION CURFLE3
         B     EERECXX                  NEXT STRING (GP)
EEREC6   TM    GNBLK3,X'80'
         BZ    EEREC8                   NOT JINFILE
         LH    R10,CURFLE3              YES, POINT TO THE NOTED LOC
         LA    R11,NOTESV
         JPOINT FILE=(R10),ADDR=(R11),NEXT=WRITE
EEREC7   LH    R10,CURFLE2
         JPOINT FILE=(R10),NEXT=START   REPOSITION CURFLE2
EERECXX  LM    R0,R1,SAVEALL
         BAL   RTN,READFL2              READ FROM BOTH INPUT
         BAL   RTN,FL1CHECK               FILES AND
         B     MERGE1                     CONTINUE MERGE PROCESS
EEREC8   LH    R10,CURFLE3
         JPOINT FILE=(R10),NEXT=START   REPOSITION CURFLE3
         B     EEREC7                   AND GO
         SPACE
DUMBUFR  EQU   BUFFER6
DUMMYRD  LA    PARM2,DUMBUFR
*                                       READ THAT BYPASSES THE NOTED
         JREAD FILE=(R10),PARM=(R11)      RECORD ON JINFILE
         SET   DRDCHK,ON
         STH   R10,CHKFILE
         BR    RTN                      RETURN
         EJECT
************************************************************
*   THIS ROUTINE IS THE DRIVER TO PRINT/PUNCH ROUTINES.
************************************************************
         USING PPIN,PARM2
         USING RPRINT,LOUTNDX
         USING RCARD,COUTNDX
OPENTRY  EQU   *                        ENTRY TO OUTPUTS
*        R2 = CURFLE INDEX
*        R3 = CURFLE2 INDEX
*        R4 = RECORDS IN CURFLE
*        R5 = RECORDS IN CURFLE2
         SPACE
OUTPUTS  CLC   D4(XRFLN,R2),D4(R3)      HI LO COMPARE
         BH    OFL2LO                   FILE 2 LOW
         BE    EOFTEST                  POSSIBLE END OF FILE
         LR    PARM2,R2                 FILE 1 LOW
         LH    R14,D0(,R2)              GET REC LENGTH
         AR    R2,R14
         ST    R2,NEXTREC               SAVE NEXT REC ADDR
         C     R2,BUFEND2               END OF BUFFER
         BL    OUTIN                    NO- NOT LAST REC
         GOIF  ENDSTR1,OFF=OUTIN        NOT IN LAST BLOCK IN STRING
         CLC   EOFREC,D0(R3)            REC LEFT ON OTH FILE
         BNE   OUTIN                    YES - NOT LAST
         SET   LASTREC,ON               NO THIS IS LAST REC
         B     OUTIN                    OUTPUT
OFL2LO   LR    PARM2,R3                 FILE 2 LOW
         LH    R14,D0(,R3)
         AR    R3,R14
         ST    R3,NEXTREC               SAVE NEXT REC ADDR
         C     R3,BUFEND4               END OF BUFFER
         BL    OUTIN                    NO - NOT LAST REC
         GOIF  ENDSTR2,OFF=OUTIN        NOT IN LAST BLOCK IN STRING
         CLC   EOFREC,D0(R2)            REC LEFT ON OTHER FILE
         BNE   OUTIN                    YES
         SET   LASTREC,ON               THIS WAS LAST REC
OUTIN    L     R12,PRT                  GET OUTPUT ROUTINE BASE
         ST    R9,RTNSV1                SAVE STRING COUNT
         BALR  R9,R12                   OUTPUT RECORDS
         L     R9,RTNSV1                RESTORE STRING COUNT
         C     R2,BUFEND2               TEST IF ENDOFBUFFER
         BL    OEX2                     NO
         CLC   EOFREC,D0(R2)            IS IT END OF FILE
         BE    OEX2                     YES
         BCT   R9,OEX1
         LA    R2,EOFREC                END OF STRING HERE
         B     OEX2                     .
OEX1     BAL   RTN,FL1CHECK             GET NEXT BUFFER
OEX2     C     R3,BUFEND4               TEST IF END OF BUFFER
         BL    OUTPUTS                  NEXT
         CLC   EOFREC,D0(R3)            IS IT END OF FILE
         BE    OUTPUTS                  YES
         BCT   R10,OEX3
         LA    R3,EOFREC                END OF STRING HERE
         B     OUTPUTS                  NEXT
OEX3     BAL   RTN,FL2CHECK             GET NEXT BUFFER
         B     OUTPUTS                  CONTINUE
         SPACE 3
NOMREC   SET   EOFSW,OFF
         L     R2,SORTPTR
ONEBFR   L     PARM2,D0(,R2)
         LA    R2,SRTNTRY(,R2)          GET NEXT REC POINTER
         L     R12,D0(,R2)              GET NEXT REC ADDR
         ST    R12,NEXTREC              SAVE IT
         CH    R4,H1                    LAST REC
         BNE   ONEBFR1                  TELL SO
         SET   LASTREC,ON
ONEBFR1  L     R12,PRT                  GET OUTPUT RTN ADDR
         BALR  R9,R12                   GO OUTPUT RECORD
         BCT   R4,ONEBFR                DECREMENT COUNT
         B     EOFOUT                   END OF FILE IF THRU'
         EJECT
****************************************
*   END OF FILE ROUTINE.
****************************************
EOFTEST  CLI   D4(R2),JTEOF             TEST IF EOF RECORD
         BNE   OFL2LO                   NO, ASSUME FILE 2 LOW
EOFOUT   EQU   *
         GOIF  JMINXREF,OFF=EOFOUT5     IF XREF(SHORT)-        @AX14816
         GOIF  LASTDEF,ON=EOFOUT3       BR IF LAST REC = DEF   @AZ28946
         GOIF  HEADPEND,OFF=EOFOUT5     BR IF NO HEADER PEND   @AZ28946
         L     LOUTNDX,LOUTSV           RESTORE BUFFER POINTER @AZ28946
         MVC   RECSAVE,CONTROL          SAVE CURR XREF REC     @AZ28946
         SET   LINKSW,ON                HEADER BUT HEADER ONLY @AZ28946
         L     R12,PRT                  ADDRESS TO-            @AZ28946
         BALR  R9,R12                   PRINT ROUTINE          @AZ28946
         MVC   CONTROL(L'RECSAVE),RECSAVE RESTOR CURR XREF REC @AZ28946
         MVI   XCNTRL,SPACE2            SET SPACE 2            @AZ28946
         B     EOFOUT5                                         @AZ28946
EOFOUT3  EQU   *                                               @AZ28946
         SET   JSUPPRT,ON               LAST DEF PRINT LINE.   @AX14816
EOFOUT5  EQU   *                                               @AX14816
         LH    R10,CURFLE               WAIT FOR OUTSTANDING-  @AZ11958
         BAL   R9,EOFWAIT               I/O ACTIVITY.          @AZ11958
         LH    R10,CURFLE2              WAIT FOR OUTSTANDING-  @AZ11958
         BAL   R9,EOFWAIT               I/O ACTIVITY.          @AZ11958
         LH    R10,CURFLE3              WAIT FOR OUTSTANDING-  @AZ11958
         BAL   R9,EOFWAIT               I/O ACTIVITY.          @AZ11958
         LH    PARM1,JINFILE            REWINE INPUT FILE FOR
         JPOINT FILE=(PARM1),NEXT=START DIAGNOSTICS PHASE
RETRN    JFRECORE ADDR=(R7)             FREE X6A COMMON AREA
RETURN   JRETURN                        RETURN TO SYSTEM
EOFWAIT  LA    R1,D0(R13,R10)           R1 POINTS TO DECB      @AZ11958
         TM    D0(R1),X'40'             TEST IF COMPLETED I/O  @AZ11958
         BOR   R9                       RETURN IF COMPLETED I/O@AZ11958
         WAIT  ECB=(R1)                 WAIT FOR COMPLEATION   @AZ11958
         BR    R9                       RETURN FOR MORE TESTS  @AZ11958
         EJECT
*   READ ROUTINE READS PHYSICAL RECORDS
*   FROM CURFLE INTO BUFFER/BUFFER2
****************************************
READFL1  STM   R0,R15,SAVEALL           FIRST TIME ENTRY POINT
         GOIF  DRDCHK,OFF=READFL17      TEST IF NEED CHECK BEFORE READ
         LH    PARM1,CHKFILE
         JCHECK FILE=(R10)              YES, CHECK IT
         SET   DRDCHK,OFF
READFL17 EQU   *
         LH    PARM1,CURFLE             READ NEXT BLOCK OF RECORDS
         LA    PARM2,BUFFER               FROM CURFLE INTO BUFFER
         JREAD FILE=(R10),PARM=(R11)
         B     RDFL10                   .
FL1CHECK STM   R0,R15,SAVEALL           NON-FIRST-TIME ENTRY POINT
         SET   ENDSTR1,OFF              RESET END OF STRING IND
         LH    PARM1,CURFLE
RDFL10   JCHECK FILE=(R10)              CHECK FOR COMPLETION
         L     PARM2,BUFFER             GET PTR TO BEGIN OF BUFFER
         LH    R12,D0(,PARM2)           EXTRACT LENGTH OF DATA RECORD
         AR    R12,PARM2                CALCULATE END OF BUFFER
         ST    R12,BUFEND1              KEEP PTR TO END OF BUFFER1
RDFL11   XC    BUFFER(D12),BUFFER2      FLIP THE TWO ALTERNATE
         XC    BUFFER2(D12),BUFFER        BUFFERS BY INTERCHANGE
         XC    BUFFER(D12),BUFFER2        POINTERS
         CLI   D3(PARM2),D1             TEST IF END OF STRING
         BNE   RDFL15                   NO, GO TO READ
         SET   ENDSTR1,ON               IND LAST BLOCK IN STRING
         L     R0,SAVEALL               YES, TEST IF LAST STRING
         CH    R0,H1
         BNH   RDFL19                   YES
RDFL15   EQU   *
         LH    PARM1,CURFLE             READ NEXT BLOCK OF RECORDS
         LA    PARM2,BUFFER
         JREAD FILE=(R10),PARM=(R11)
RDFL19   LM    R0,R15,SAVEALL
         L     R2,BUFFER2
         LH    R9,D2(,R2)               # BLKS IN FL 1 GP
         LH    R4,D4(,R2)               # RECS IN FL 1 BLK
         LA    R2,D6(,R2)               BUMP OVER  HEADER
         BR    RTN                      RETURN TO CALLER
         EJECT
*   READ ROUTINE READS PHYSICAL RECORDS
*   FROM CURFLE2 INTO BUFFER3/BUFFER4
****************************************
READFL2  STM   R0,R15,SAVEALL
         GOIF  DRDCHK,OFF=READFL27      TEST IF NEED CHECK BEFORE READ
         LH    PARM1,CHKFILE
         JCHECK FILE=(R10)              YES, CHECK IT
         SET   DRDCHK,OFF
READFL27 EQU   *
         LH    PARM1,CURFLE2            READ NEXT BLOCK OF RECORDS
         LA    PARM2,BUFFER3              FROM CURFLE2 INTO BUFFER3
         JREAD FILE=(R10),PARM=(R11)
         B     RDFL20                   .
FL2CHECK STM   R0,R15,SAVEALL           NON-FIRST-TIME ENTRY POINT
         SET   ENDSTR2,OFF              RESET END OF STRING IND
         LH    PARM1,CURFLE2
RDFL20   JCHECK FILE=(R10)              CHECK BEFORE READ
         L     PARM2,BUFFER3
         LH    R12,D0(,PARM2)
         AR    R12,PARM2
         ST    R12,BUFEND3
RDFL21   XC    BUFFER3(D12),BUFFER4     FLIP THE TWO ALTERNATE BUFFERS
         XC    BUFFER4(D12),BUFFER3
         XC    BUFFER3(D12),BUFFER4
         CLI   D3(PARM2),D1             TEST IF END OF STRING
         BNE   RDFL25                   NO, GO TO READ
         SET   ENDSTR2,ON               IND LAST BLOCK INSTRING
         L     R1,SAVEALL+4
         CH    R1,H1                    YES, TEST IF LAST STRING
         BNH   RDFL29                   YES
RDFL25   EQU   *
         LH    PARM1,CURFLE2            READ NEXT BLOCK OF RECORDS
         LA    PARM2,BUFFER3
         JREAD FILE=(R10),PARM=(R11)
RDFL29   LM    R0,R15,SAVEALL
         L     R3,BUFFER4
         LH    R10,D2(,R3)              # BLKS IN FL 2 GP
         LH    R5,D4(,R3)               # RECS IN FL 2 BLK
         LA    R3,D6(,R3)               BUMP OVER HEADER
         BR    RTN                      RETURN TO CALLER
         EJECT
************************************************************
*   WRITE ROUTINE WRITES PHYSICAL RECORDS
*   FROM BUFFER5/BUFFER6 ONTO CURFLE3
************************************************************
PUTREC   EQU   *
         LH    R15,D0(,R14)             GET RECORD LENGTH
PUTREC1  AR    R12,R15
         C     R12,BUFEND5              TEST IF END OF BUFFER
         BH    OVRFLO                   BR IF OVERFLOW
         SR    R12,R15                  NO, MOVE INTO BUFFER
         C     R15,F255
         BNH   PUTREC2
         MVC   D0(255,R12),D0(R14)      EXTRA MOVE IF RECORD LENGTH
         S     R15,F255                   EXCEEDS 255
         A     R12,F255
         A     R14,F255
PUTREC2  BCTR  R15,0                    MAKE MOVE LENGTH
         EX    R15,MVMV                 MOVE RECORD TO BUFFER
         LA    R15,D1(R15)              MAKE IT LOGICAL LENGTH AGAIN
         AR    R12,R15
         AR    R14,R15
         LA    R11,D1(,R11)
         BR    RTN                      RETURN
MVMV     MVC   D0(0,R12),D0(R14)        OFF-THE-LINE MOVE
         SPACE
OVRFLO   SR    R12,R15                  WRAP UP THE BUFFER
OVRFLO1  STM   R0,R15,SAVEALL
         L     R10,BUFFER5
         SR    R12,R10                  TAKE CARE OF ITS HEADER
         STH   R12,D0(,R10)             BLOCK SIZE
         STH   R11,D4(,R10)             # RECORDS
         LH    PARM1,CURFLE3            BRANCH IF FIRST TIME
OVRFLO5  GOIF  FSW,ON=WRITE             ELSE, CHECK LAST OUTPUT
         JCHECK FILE=(R10)              COMPLETION BEFORE
****************************************
WRITE    LA    PARM2,BUFFER5            WRITE CURRENT BLOCK
         SET   FSW,OFF
         JWRITE FILE=(R10),PARM=(R11)
         LM    R0,R15,SAVEALL
         XC    BUFFER5(D12),BUFFER6     FLIP THE TWO
         XC    BUFFER6(D12),BUFFER5       ALTERNATIVE
         XC    BUFFER5(D12),BUFFER6       BUFFERS
         L     R12,BUFFER5                AND
         XC    D2(D2,R12),D2(R12)         INITIATE HEADER
         LA    R12,D6(,R12)
         SR    R11,R11
         LTR   R15,R15                  END OF GP IF R15 = 0
         BP    PUTREC1                  BR IF NOT
         LH    R10,CFL3CC               INCREMENT STRING COUNT
         LA    R10,D1(,R10)
         STH   R10,CFL3CC
         BR    RTN                      RETURN
         SPACE
LBSW     EQU   X'01'                    LAST-BLOCK-IN-GP
PUTLBLK  SR    R15,R15
         L     R10,BUFFER5
         OI    D3(R10),LBSW             INDICATE LAST BLOCK IN GP
         B     OVRFLO1                  PUT
         EJECT
*
*   CONSTANTS
*
F255     DC    F'255'                   CONSTANT 255
PRT      DC    A(PRTPCH)                ADDRESS OF OUTPUT ROUTINE
K72D     DC    X'00007FFF'
H1       DC    H'1'                     CONSTANT 1
H4       DC    H'4'                     CONSTANT 4
H8       DC    H'8'                     CONSTANT 8
         JPATCH X6A00,AF0                     5% PATCH AREA
         EJECT
         JCSECT (X6A20)
         JMODID
PRTPCH   JSAVE
         JENTRY (X6A21=PRTPCH)
         STM   R1,R10,SAVEALL
         L     LINCTR,LNCTRSV           RESTORE LINE COUNTER
         GOIF  LINKSW,OFF=VJGARAM       BR IF NOTHING SPECIAL  @AZ28946
         BAL   RTN,XRFHDNG              NOW LAST XREF HEADER   @AZ28946
         B     OUTEXIT                  RETURN TO EOF ROUTINE  @AZ28946
VJGARAM  EQU   *                                               @AZ28946
         CLI   PPIOC,RLDTYPE            TEST IF RLD RECORD
         BE    RLDOUT                   YES
         CLI   PPIOC,XRFTYPE            TEST IF XREF RECORD
         BE    XRFOUT                   YES
         CLI   PPIOC,LITTYPE            TEST IF LETERAL XREF RECORD
         BE    LITOUT                   BRANCH IF YES
         B     RET                      RETURN TO CALLER
         SPACE
OUTEXIT  ST    LINCTR,LNCTRSV           SAVE LINE COUNTER
         LM    R1,R10,SAVEALL
RET      JRETURN                        NEXT RECORD
         EJECT
************************************************************
*   RELOCATION LIST DICTIONARY PRINT ROUTINE.
************************************************************
RLDOUT   EQU   *
         GOIF  PROCRLD,ON=RLDGO         BRANCH IF NOT FIRST ENTRY
         LA    LINCTR,D1                DUMMY UP LINE COUNTER
         SET   PROCRLD,ON               INDICATE INVOLVED IN RLD NOW
         GOIF  (JDECK,JLINK),OFF=RLDGO   BRANCH IF NO RLD PUNCH OUTPUT
         BAL   RTN,PCHREC               LOCATE NEXT PUNCH BUFFER
RLDGO    EQU   *
         GOIF  (JLIST,JRLD),NOTALL=RLDDL BRANCH IF NO LIST OUTPUT
         L     LOUTNDX,LOUTSV           SAVE LIST BUFFER POINTER
         BCT   LINCTR,RLDLST            BRANCH IF LIST HDG NOT NEEDED
         BAL   RTN,RLDHDNG              ELSE, BUILD ONE
         LH    LINCTR,JLNCT             GET LINE COUNT PER PAGE
         ST    LINCTR,LNCTRSV
         MVI   RCNTRL,SPACE2            DOUBLE SPACE
RLDLST   EQU   *
         UNPK  UNPKAREA(L'UNPKAREA),POSID(L'POSID+L'RELID+L'RLDVAL+L'RLX
               DFLG)                    UNPACK
         MVN   UPFLGN(D1),RLDFLG        COMPLETE UNPACKING
         NC    UNPKAREA(L'UNPKAREA+1),MASK1 MASK OUT ZONE PORTION
         MVC   POSOUT,UPPOS             POSITIONAL ID
         MVC   RELOUT,UPREL             RELATIONAL ID
         MVC   VALOUT,UPVAL             ADDRESSE
         MVC   FLGOUT,UPFLG             FLAGS
         BAL   RTN,PRTREC               PRINT ONE LINE
RLDDL    EQU   *
         GOIF  (JDECK,JLINK),OFF=OUTEXIT  NEXT RECORD
RLDBLD   EQU   *
         LM    RLDCNT,R15,RFSAVE        RESTORE
         CH    RLDCNT,H56               TEST IF BUFFER FULL
         BL    RLDBLD1                  BRANCH IF NOT
         BAL   RTN,PCHREC               ELSE, PUNCH OUT RECORD
RLDBLD1  EQU   *
         MVC   RELHLD,RELID             RELOCATION ID
         MVC   POSHLD,POSID             POSITIONAL ID
         MVC   FLGHLD,RLDFLG            RLD FLAGS
         MVC   ADDRHLD,RLDVAL           RLD ASSEMBLED ORIGIN
         CLC   ESDCOMP,RLDHLD           TEST IF POS/REL ID CHANGED
         BNE   RLDB                     YES.
         SH    R15,H4I                  BACK UP TO FLAG IN PREV ENTRY
         OI    D0(R15),SAMEID           INDICATE NEXT ENTRY HAS SAME ID
         AH    R15,H4I
         LA    PARM2,FLGHLD             LOCATION OF ITEM TO BE MOVED
         LA    PARM1,D3                 AND ITS MOVE LENGTH
         B     RLDB1                    GO MOVE IT TO BUFFER
RLDBZ    EQU   *
         BAL   RTN,PCHREC               LOCATE NEXT PUNCH BUFFER
RLDB     LA    PARM1,D7                 MOVE LENGTH FOR SAME-ID ENTRY
         LA    PARM2,RLDHLD             AND ITS LOCATION
         MVC   ESDCOMP,RLDHLD           UPDATE ESDCOMP
RLDB1    LA    RLDCNT,D1(PARM1,RLDCNT)  UPDATE RLD DATA BYTE COUNT
         CH    RLDCNT,H56               IF IT ACCUMULATES
         BH    RLDBZ                    MORE THAN 56 BYTES MUST SPLIT
         EX    PARM1,MVCRLD             ELSE, MOVE INTO BUFFER
         STH   RLDCNT,JHWORD1           ENTER NUMBER OF BYTES ACCUM'D
         L     COUTNDX,PCHSAVE
         MVC   RLDBYT(L'RLDBYT),JHWORD1
         LA    R15,D1(PARM1,R15)        MIGHT HAVE ROOM FOR NEXT ENTRY
         STM   RLDCNT,R15,RFSAVE        SAVE
         B     OUTEXIT                  READ NEXT CARD
         DROP  COUTNDX
*
MVCRLD   MVC   D0(0,R15),D0(PARM2)      OFF-THE-LINE MOVE
         EJECT
************************************************************
*   SYMBOL CROSS-REFERENCE LISTING ROUTINE.
************************************************************
         DROP  PARM2
         USING PPIN,R5
XRFOUT   EQU   *
         LR    R5,PARM2                 SET BASE FOR XREF'S
         GOIF  PROCXRF,ON=XRFLST        BRANCH IF NOT FIRST ENTRY
         LA    LINCTR,D1                ELSE, FORCE OUT PREVIOUS LINE
         XC    SAVSYM(L'SAVSYM+L'UNDFSYM),SAVSYM ZERO OUT SAVE AREAS
         SET   PROCXRF,ON
         B     XRFLST                   GO PROCESS
XRFOUT0  CLI   XRFFLG,BASE              DEF REC
         BNE   XRFOUT2                  NO PROCESSING STARTS
         GOIF  LASTREC,ON=OUTEXIT       LAST REC NOTHING TO PRINT
         L     R1,NEXTREC               GET NEXT REC ADDR
         CLI   XRFFLG-XRFIN(R1),BASE    A DEF REC TOO
         BE    OUTEXIT                  YES DO NOT PROCESS YET
XRFOUT2  SET   PROCXRF,ON               NOT DEF PROCESSING STARTS
XRFLST   EQU   *
         MVC   STMTN2(D2),XRFSTM        ALIGN STMT # TO HWD BNDRY
         CLI   XRFFLG,REF               IS IT A REFERENCE RECORD
         BE    XREFIN                   BRANCH IF YES
         BAL   RTN,XRFDEFS              ELSE, PROCESS DEFINITION
XRFEXIT  STM   LOUTNDX,XRFPTR,LOUTSV
         B     OUTEXIT                  READ NEXT CARD
         SPACE 3
XREFIN   EQU   *
         SET   LASTREC,OFF              REF NO WORRIES
         LM    LOUTNDX,XRFPTR,LOUTSV
         LA    PARM2,XPRTND             GET END PRINT BUFFER ADDRESS
         CR    XRFPTR,PARM2             TEST IF REFERENCE LINE FULL
         BL    XRFR0                    BRANCH IF STILL ROOM
         BAL   R1,HDLINE1               ELSE, PRINT THE LINE
XRFR0    EQU   *
         L     R15,STMTNUM              XREF STATEMENT NUMBER
         BAL   RTN,CVTXRF               NUMBER FOR PRINTING.
         GOIF  PROCLIT,ON=XRFR2         SKIP IF PROCESSING LIT XREF
         CLC   SAVSYM,XRFSYM            SYMBOL = PREVIOUS SYMBOL
         BE    XRFR2                    YES, BYPASS UNDEFINED SYM CODE
         CLC   UNDFSYM,XRFSYM           UNDEFINED SYMBOL = TO LAST
         BE    XRFR2                    YES, GO PUT OUT REFERENCE NUM.
         GOIF  HEADOUT,ON=XRFR15        BRANCH IF BUFFER EMPTY
         GOIF  LASTDEF,ON=XRFR15        SKIP LAST BUF IF IT WAS DEF
         MVC   UPXSV(L'XRFENT),UPX      SAVE STMT NUMBER
         BAL   R1,HDLINE                ELSE, PRINT A LINE
         MVC   UPX(L'XRFENT),UPXSV      RESTORE STMT NUMBER
XRFR15   EQU   *
         MVC   UNDFSYM,XRFSYM           SAVE UNDEFINED SYMBOL
         TR    XRFSYM,JTRTABLE          CONVERT SYMBOL TO INTERNAL CODE
         MVC   XSYMOUT,XRFSYM           XREF SYMBOL
         MVC   XLENOUT(L'UNDFMSG),UNDFMSG    UNDEFINED MESSAGE
XRFR2    EQU   *
         MVC   D0(L'XRFENT,XRFPTR),UPX  REFERENCE NUMBER
         LA    XRFPTR,XRENTL(,XRFPTR)   BUMP REF PRINT POINTER
         SET   HEADOUT,OFF
         SET   LASTDEF,OFF              REFERENCE RESETS DEF REC IND
         B     XRFEXIT                  GET OUT
         SPACE 3
HDLINE1  SET   HEADOUT,ON
HDLINE   EQU   *
         ST    R1,R1SAVE
         L     LOUTNDX,LOUTSV           RESTORE BUFFER POINTER
         GOIF  LASTDEF,ON=HDLINE2       WAS LAST XREF A DEF
         GOIF  HEADPEND,OFF=HDLINE11    BR IF NOT XREF HEADER  @AZ28946
         MVC   RECSAVE,CONTROL          SAVE XREF RECORD       @AZ28946
         BAL   RTN,XRFHDNG              PRINT HEADER           @AZ28946
         LH    LINCTR,JLNCT             GET LINE COUNT         @AZ28946
         ST    LINCTR,LNCTRSV                                  @AZ28946
         MVC   CONTROL(L'RECSAVE),RECSAVE BACK SAVED XREF REC  @AZ28946
         MVI   XCNTRL,SPACE2            DOUBLE SPACE           @AZ28946
         SET   HEADPEND,OFF             RESET SW               @AZ28946
HDLINE11 EQU   *                                               @AZ28946
         BAL   RTN,PRTREC               PRINT ONE LINE
HDLINE2  EQU   *
         MVI   XCNTRL,SPACE1            SINGLE SPACE
         BCT   LINCTR,HDLNX             EXIT IF PAGE NOT FULL
         GOIF  PROCXRF,OFF=HDLINE3      BR IF NOT XREF         @AZ28946
         GOIF  JMINXREF,OFF=HDLINE3     BR IF NOT XREF(SHORT)  @AZ28946
         SET   HEADPEND,ON              IND XREF HEADER PEND   @AZ28946
         B     HDLNX                    TRY NEXT XREF RECORD   @AZ28946
HDLINE3  EQU   *                                               @AZ28946
         BAL   RTN,XRFHDNG              ELSE, PRINT HEADING
         LH    LINCTR,JLNCT             GET LINE COUNT PER PAGE
         ST    LINCTR,LNCTRSV
         MVI   XCNTRL,SPACE2            DOUBLE SPACE
HDLNX    LA    XRFPTR,XRFREF            GET REFERENCE POINTER
         L     R1,R1SAVE
         SET   LASTDEF,OFF              RESET DEF REC IND
         BR    R1                       BEFORE YOU GO
         SPACE 3
XRFDEFS  EQU   *
         ST    RTN,RTNSV                SAVE RETURN LINKAGE
         GOIF  JMINXREF,ON=XRFDEF0      WORRIE ONLY IF SHORT XREF
         SET   LASTREC,OFF              SO CLEAR LAST REC IND
XRFDEF0  GOIF  LASTDEF,OFF=XRFDEFS0     WAS ALST REC ALSO A DEF REC
         L     LOUTNDX,LOUTSV           RESTORE BUFFER OPOINTER
         LA    XRFPTR,XRFREF            GET REFERENCE POINTER
         CLI   XRFFLG,DUPL              DUPL DEF
         BE    XRFDEFS1                 YES CONT PROC
         CLI   XOPCDE,X'FF'             FINISHED IF LAST REC ON OX02645
         BNE   XRFDEFS1                 FINIS                   OX02645
         MVI   D1(LOUTNDX),JBLANK       MAKE SURE NO INF PRINTED
         MVC   D2(D30,LOUTNDX),D1(LOUTNDX)
         BR    RTN                      BYPASS OUTPUT
XRFDEFS0 EQU   *
         CLI   XRFFLG,DUPL              DUPL DEF REC
         BE    XRFDEFSA                 YES PRINT IT
         GOIF  LASTREC,ON=XRFDEFSA      FINISHED IF LST REC ON @AX14198
XRFDEFSA BAL   R1,HDLINE                UNLOAD PREVIOUS BUFFER
XRFDEFS1 MVC   SAVSYM,XRFSYM            SAVE XREF SYMBOL FOR FUTURE TST
         TR    XRFSYM,JTRTABLE          CONVERT SYMBOL TO INTERNAL CODE
         MVC   XSYMOUT,XRFSYM           XREF SYMBOL
         B     XLREF1                   CONTINUE PROCESSING
XLREF    EQU   *
         ST    RTN,RTNSV
XLREF1   EQU   *
         XC    JFWORD1,JFWORD1          ALIGN LENGTH ATTRIBUTE VALUE
         MVC   JFWORD1+D2(D2),XRFLEN    IN A FULL WORD AREA
         L     R15,JFWORD1              CONVERT LENGTH ATTRIBUTE
         BAL   RTN,CVTXRF               AND MOVE IT TO
         MVC   XLENOUT,UPX              PRINT BUFFER.
         GOIF  PROCLIT,ON=LITVAL        BRANCH IF PROCESSING LITERAL
         UNPK  UPXVAL(L'UPXVAL),XRFVAL(L'XRFVAL+1) CONVERT LOC CTR
XLREF2   EQU   *
         NC    UPXVAL(L'UPXVAL),MASK1   ZERO OUT ZONES
         MVC   XVALOUT,UPXVAL           AND MOVE IT TO PRINT
         L     R15,STMTNUM              XREF DEF STATEMENT NUMBER
         BAL   RTN,CVTXRF               DEFINED AT AND MOVE IT TO
         MVC   XDEFOUT,UPX              PRINT BUFFER.
         L     RTN,RTNSV
         CLI   XRFFLG,BASE              IS RECORD A DEFINITION ONE
         BC    12,XLREF3                YES BYPASS DUPLICATION CODE
         MVC   XRFREF(L'DUPMSG),DUPMSG  DUPLICATE SYMBOL MESSAGE
         SET   LASTDEF,OFF              DUPLICATE SHOULD BE PRINTED
         BR    RTN                      RETURN TO CALLER
XLREF3   GOIF  JMINXREF,OFF=(RTN)       IS SHORT XREF REQUESTED
         SET   LASTDEF,ON               YES INDICATE THIS WAS DEF REC
         BR    RTN                      RETURN TO CALLER
LITVAL   UNPK  UPXVAL(L'UPXVAL),LITLOCTR(L'LITLOCTR+1) GET LOCATION CTR
         B     XLREF2                   RESUME PROCESSING
         SPACE
CVTXRF   CVD   R15,CVDCML                         CONVERT XREF DEF, OR
         UNPK  UPX(L'UPX),UPDCML(D3)    UNPACK
         NC    UPX(L'UPX),MASK1         ZERO OUT ZONES
         BR    RTN                      RETURN TO CALLER
         EJECT
************************************************************
*   LITERAL CROSS-REFERENCE LISTING ROUTINE.
*   THERE ARE NO SUCH RECORD TYPES AS DUPLICATE OR UNDEFINED ON LITERAL
*   CROSS REFERENCE RECORDS. IF FOUND, GIVE X4 A DUMP.
************************************************************
LITOUT   EQU   *
         LR    R5,PARM2
         GOIF  PROCLIT,ON=LITLST        BRANCH IF NOT FIRST ENTRY
         GOIF  HEADPEND,OFF=LITOUT4     BR IF NO HEADER PEND   @AZ28946
         GOIF  LASTDEF,ON=LITOUT2       BR IF LAST REC = DEF   @AZ28946
         L     LOUTNDX,LOUTSV           RESTORE BUFFER POINTER @AZ28946
         MVC   RECSAVE,CONTROL          SAVE CURR XREF REC     @AZ28946
         BAL   RTN,XRFHDNG              PRINT XREF HEADER      @AZ28946
         MVC   CONTROL(L'RECSAVE),RECSAVE RESTOR XREF REC      @AZ28946
         MVI   XCNTRL,SPACE2            SET CONTR CHAR FOR SP2 @AZ28943
LITOUT2  EQU   *                                               @AZ28946
         SET   HEADPEND,OFF             RESET SW               @AZ28946
LITOUT4  EQU   *                                               @AZ28946
         LA    LINCTR,D1                DUMMY UP LINE COUNTER
         SET   PROCLIT,ON
         SET   PROCXRF,OFF              RESET SW               @AZ28946
LITLST   EQU   *
         MVC   STMTN2(D2),XRFSTM        ALIGN STMT # TO HWD BNDRY
         CLI   XRFFLG,REF               TEST IF REFERENCE RECORD
         BE    XREFIN                   MAKE REFERENCE ENTRY IF YES
         SPACE 3
LITDEFS  EQU   *
         BAL   R1,HDLINE                PRINT HEADING IF NECESSARY
         LH    R15,LITPOLID
         CH    R15,LLOCTRSV
         BNH   LITD0                    BRANCH IF SAME POOL
         STH   R15,LLOCTRSV
LITD0    EQU   *
         ST    R5,RFSAVE                SAVE RECORD POINTER
         SR    R15,R15
         IC    R15,LITDTL               GET DATA LENGTH
         CH    R15,H8I                  TEST IF LONGER THAN 8 CHAR.
         BH    LITD1                    YES, SPLIT INTO 2 LINES OR MORE
         BCTR  R15,0                    MAKE IT MOVE LENGTH
         EX    R15,LITMOVH              MOVE ALL INFORMATION INTO
         B     LITD5                    ONE LINE
LITD1    EQU   *
LITMOVH  MVC   LITSYM(D5),LITDTA        MOVE IN 5 BYTES
         LA    R5,LITDTA+5              ADJUST POINTER
         SH    R15,H5
         CH    R15,H115                 TEST IF RECORD GT 115 CHAR
         BNH   LITD4                    BRANCH IF NOT
LITD2    MVC   LITSYM5(XRL-5),D0(R5)    COMPLETE ONE LINE
         ST    R15,R15SAVE              SAVE LENGTH
         BAL   R1,HDLINE                PRINT HEADING IF NECESSARY
         L     R15,R15SAVE              RESTORE LENGTH
LITD3    SH    R15,H115                 DECREMENT BYTE COUNT
         AH    R5,H115                  BUMP POINTER
         CH    R15,H115                 TEST IF STILL GT 115 CHAR
         BH    LITD2                    BRANCH IF YES
LITD4    BCTR  R15,0                    MAKE IT MOVE LENGTH
         EX    R15,LITMOV               MOVE THE REST
         CH    R15,H2                   TEST IF LAST LINE
         BNH   LITD5                    NOT MORE THAN 3 CHARACTERS
         BAL   R1,HDLINE                PRINT HEADING IF NECESSARY
LITD5    EQU   *
         L     R5,RFSAVE                POINT BACK
         BAL   RTN,XLREF                BUILD RECORD
         B     XRFEXIT                  NEXT RECORD
*
LITMOV   MVC   LITSYM5(0),D0(R5)        OFF-THE-LINE MOVE
         EJECT
************************************************************
*   RLD HEADING ROUTINE
************************************************************
RLDHDNG  STM   R1,R6,RTADDR             SAVE REGISTERS 1 - 6
         BAL   RTN,PGECNT               BUMP PAGE COUNT
         GOIF  FIRST,ON=SECPRT          BRANCH IF SECOND PRINT @OY06558
         BAL   RTN,PRTREC
         SET   FIRST,ON                 SET FIRST PRINT ON     @OY08558
SECPRT   L     LOUTNDX,LOUTSV           RESTORE BUFFER POINTER @OY06558
         MVI   CONTROL,EJBYTE           EJECT TO NEW PAGE
         MVC   TITLE(L'JDECKID),JDECKID TITLE ID
         MVC   HDGPTR(L'RLDH1),RLDH1    'RELOCATION DICTIONARY'
         MVC   PGEPTR(L'PAGE),PAGE      'PAGE'
         MVC   PGENUM(L'PGENUM),UPX     RLD PAGE COUNT
         BAL   RTN,PRTREC               PRINT ONE LINE
         MVI   CONTROL,SPACE3           TRIPLE SPACE
         MVC   TITLE(L'RLDH2),RLDH2     RLD HEADING 2
         MVC   DTEPTR(L'JLVTMDT),JLVTMDT COMPNT-LEVEL-MONTH-DAY-YR
         B     HDNGX                    PRINT ONE LINE AND EXIT
         EJECT
************************************************************
*   SYMBOL/LITERAL XREF HEADING ROUTINE
************************************************************
XRFHDNG  STM   R1,R6,RTADDR             SAVE ADDRESS OF CALLER
         BAL   RTN,PGECNT               CONVERT PAGE COUNT FOR PRINTING
         GOIF  LASTDEF,OFF=XRFHD0       DONT PRINT IF IT WAS DEF
         L     LOUTNDX,LOUTSV           RESTORE BUFFER POINTER
         B     XRFHD05                  BYPASS PRINT
XRFHD0   EQU   *
         L     LOUTNDX,LOUTSV           RESTORE BUFFER POINTER @OY06558
XRFHD05  EQU   *
         MVI   CONTROL,EJBYTE           EJECT TO NEW PAGE
         MVC   TITLE(L'JDECKID),JDECKID TITLE ID
         MVI   TITLE+D8,JBLANK         CLEAN HEADER LINE       @OX07206
         MVC   TITLE+D9(PGEPTR-TITLE-D9),TITLE+D8 CLN HDRLINE  @OX07206
         MVC   HDGPTR(L'XRFH1),XRFH1    'CROSS-REFERENCE'
         GOIF  PROCLIT,OFF=XRFHD1       BRANCH IF PROC'G LIT XREF
         MVC   HDGPTR(L'LITH1+L'XRFH1),LITH1 MOVE IN HEADING
XRFHD1   EQU   *
         MVC   PGEPTR(L'PAGE),PAGE      'PAGE'
         MVC   PGENUM(L'PGENUM),UPX     XREF PAGE COUNT
         BAL   RTN,PRTREC               PRINT ONE LINE
         MVI   CONTROL,SPACE3           TRIPLE SPACE
         MVC   TITLE(L'XRFH2),XRFH2     XREF HEADING 2
         MVC   DTEPTR(L'JLVTMDT),JLVTMDT COMPNT-LEVEL-MONTH-DAY-YEAR
HDNGX    EQU   *
         BAL   RTN,PRTREC               PRINT ONE LINE
         ST    LOUTNDX,RTADDR+4         OUTPUT POINTER
         LM    R1,R6,RTADDR             ADDRESS OF CALLER
         BR    RTN                      RETURN TO CALLER
         EJECT
************************************************************
*   PAGE COUNT SUBROUTINE
************************************************************
PGECNT   EQU   *
         LH    R2,JPAGENO               XREF PAGE COUNT
         LA    R2,D1(,R2)               INCREASE PAGE COUNT
         STH   R2,JPAGENO               SAVE PAGE NUMBER
         CVD   R2,CVDCML                CONVERT INTO DECIMAL
         UNPK  UPX(L'UPX),UPDCML(D3)    UNPACK
         NC    UPX(L'UPX),MASK1         ZERO OUT ZONES
         LA    R2,MASKLEN               COUNT FOR MASKING OUT LEADING 0
         LA    R3,UPX                   POINTER TO LEAD CHARACTER
LOOP     CLI   D0(R3),J0                TEST FOR LEADING ZEROS
         BCR   7,RTN                    BRANCH IF NOT ZERO
         MVI   D0(R3),JBLANK            MASK OUT ZERO WITH A BLANK
         LA    R3,D1(,R3)               STEP TO NEXT CHARACTER
         BCT   R2,LOOP                  LOOP BACK UP TO 3 TIMES
         BR    RTN                      RETURN TO CALLER
         EJECT
************************************************************
*   THIS ROUTINE PRINTS ONE LINE ONTO PRINT FILE.
************************************************************
PRTREC   EQU   *
         ST    PARM2,FWORD
         JPRINT                         PRINT ONE LINE
         LR    LOUTNDX,PARM2            GET BASE
         ST    LOUTNDX,LOUTSV           SAVE POINTER
         L     PARM2,FWORD
         BR    RTN                      RETURN TO CALLER
         SPACE 5
************************************************************
*   THIS ROUTINE PUNCHES ONE LINE ONTO PUNCH FILE.
************************************************************
         USING RCARD,COUTNDX
PCHREC   EQU   *
         ST    PARM2,FWORD
         JPUNCH SEQ=YES
         LR    COUTNDX,PARM2            AND SAVE ADDRESS
         MVI   CARDID,XBLANK            FILL BUFFER WITH EXTERNAL
         MVC   RLDNAM(RCARDL-1),CARDID  BLANKS
         MVI   CARDID,J2                12-2-9 COMBINATION IN COLUMN 1
         MVC   RLDNAM,RLDC              RLD NAME EXTERNAL FORMAT
         LA    R15,RLDFLD               POINT TO DATA FIELD
         SR    RLDCNT,RLDCNT            INITIAL RLD COUNT
         ST    COUTNDX,PCHSAVE
         STM   RLDCNT,R15,RFSAVE        SAVE
         XC    ESDCOMP,ESDCOMP
         L     PARM2,FWORD
         BR    RTN                      RETURN TO CALLER
         EJECT
************************************************************
*   CONSTANTS, CONSTANTS, CONSTANTS
************************************************************
         DS    0F
H1I      DC    H'1'
H2       DC    H'2'
H4I      DC    H'4'
H5       DC    H'5'
H7       DC    H'7'
H8I      DC    H'8'
H56      DC    H'56'
H115     DC    H'115'
RLDC     DC    CL3'RLD'                 EXTERNAL RLD NAME
RLDH1    JGENIN 'RELOCATION DICTIONARY'
RLDH2    JGENIN 'POS.ID   REL.ID   FLAGS   ADDRESS'
PAGE     JGENIN 'PAGE'
LITH1    JGENIN 'LITERAL '
XRFH1    JGENIN 'CROSS-REFERENCE'
XRFH2    JGENIN 'SYMBOL    LEN   VALUE   DEFN    REFERENCES'
DUPMSG   JGENIN '****DUPLICATE****'
UNDFMSG  JGENIN '****UNDEFINED****   '                         @OX10363
MASK1    DC    16X'0F'                  ZONE DELETOR
         JPATCH X6A20,5E0             5% PATCH AREA
         END   PPENT
