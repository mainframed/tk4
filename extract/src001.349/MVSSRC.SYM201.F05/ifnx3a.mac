         MACRO
&NAME    DICTCALL &ENTRY,&POINTER=DICTBASE
&NAME    L     R12,&POINTER             SET UP DICT RTN ENTRY ADDR
         MVI   NDXVAL,&ENTRY            INDICATE ENTRY BEING MADE
         BALR  R9,R12                   LINK TO DICTIONARY ROUTINE
         MEND
         SPACE 3
         MACRO
         GENOPS &OP
         ORG   MOPTABLE+2*JT&OP         ORIGIN TO OP CODES SLOT IN TBL
         AIF   (K'&SYSLIST(2) EQ 0).STEP2
         DC    Y(&SYSLIST(2)-MOPRTNS)   DUMMY ENTRY
         MEXIT
.STEP2   AIF   ('&OP'(1,1) EQ 'M').M
         DC    Y(M&OP-MOPRTNS)          OP CODES ENTRY IN BRANCH TABLE
         MEXIT
.M       DC    Y(&OP-MOPRTNS)           OP CODE'S ENTRY IN BRANCH TABLE
         MEND
         SPACE 3
         MACRO
         OPS   &OP
         ORG   OPTAB+2*JTM&OP           ORIGIN TO OPERATOR SLOT IN TBL
         DC    Y(EVAL&OP-EVALOPS)        OPERATOR ENTRY IN BRANCH TABLE
         SPACE
         MEND
         EJECT
         JHEAD 'XKE MACRO GENERATOR',                                  X
               PHASEID=X3A,                                            X
               LEVEL=10
*                                                                     *
*FUNCTION/OPERATION-                                                  *
*   READS EDITED TEXT FOR MAINLINE CODE AND MACRO DEFINITIONS, WITH   *
*   THEIR DICTIONARIES, INTERPRETIVELY EXECUTES MACRO LANGUAGE PSEUDO-*
*   OPS TO PRODUCE LOGICAL SOURCE LANGUAGE FOR INPUT TO THE ASSEMBLY  *
*   PROCESS.  PERFORMS MACRO EXPANSION AND VARIABLE SYMBOL SUBSTITU-  *
*   TION.  MAPS TEXT INTO INTERNAL EVALUATION NOTATION FOR ASSEMBLY   *
*   PROCESS.  OUTPUTS TEXT AND SYMBOL RESOLUTION INFORMATION FOR ASSEM*
*   BLY PROCESSING.                                                   *
*                                                                     *
*ENTRY POINTS-                                                        *
*        MENTRY--ONLY ENTRY POINT                                     *
*                                                                     *
*INPUT-                                                               *
*        FILE1--EDITED TEXT FOR MAINLINE AND MACRO DEFINITIONS, WITH  *
*   CORRESPONDING DICTIONARIES.                                       *
*                                                                     *
*OUTPUT-                                                              *
*        FILE2--TEXT POST GENERATION                                  *
*        FILE3--SYMBOL DEFINITION AND SYMBOL REFERENCE INFORMATION    *
*                                                                     *
*EXTERNAL ROUTINES-                                                   *
*   USES ASSEMBLER SERVICES IN ROOT MODULE.                           *
*                                                                     *
*EXITS-                                                               *
*   NORMAL--JRETURN TO CONTROLLER WITH COMPLETION CODE OF X'00' IN    *
*   PARAMETER REGISTER R10.                                           *
*   ERROR--JRETURN TO CONTROLLER WITH COMPLETION CODE OF X'04' IN     *
*   PARAMETER REGISTER R10.                                           *
***********ALSO PROVIDE FOR NO TEXT AND NO SYMBOL CONDITIONS***********
*                                                                     *
*TABLES/WORK AREAS-                                                   *
*        *********************** TO BE DOCUMENTED WHEN DEFINED*********
*                                                                     *
*        MOPTABLE--BRANCH TABLE FOR GENERATOR OPERATIONS              *
         EJECT
         COPY  JCOMMON                  INCLUDES USING FOR COMMON
         EJECT
         COPY  JTEXT
         EJECT
MTEXT    DSECT ,                        COPY OF JTEXT FOR OUTPUT
         SPACE
MTRLI    DS    H                        RECORD LENGTH
MTFLGA   DSW   MPSOP                    FLAGA PSEUDO-OP FLAG
MTFLGB   DSW   MPRONLY,                 FLAGB PRINT ONLY SWITCH        X
               MERR,                    DEAD STATEMENT                 X
               MNOCNT,                  DON'T COUNT                    X
               MGEN,                    GENERATED                      X
               MNMERR                   INVALID NAME FIELD
MTIOP    DS    0H                       OP CODE
MTIOP1   DS    1X                       1ST BYTE
MTIOP2   DS    X                        2ND BYTE
MTNMP    DS    H                        NAME POINTER
MTOCP    DS    H                        MNEMONIC POINTER
MTOPP    DS    H                        OPERAND POINTER
MTCPR    DS    H                        COMMENTS POINTER
MTSPR    DS    H                        STRING POINTER
MTFLGC   DS    C                        FLAG C                  OX00407
MTSYMCNT DS    C                        NUMBER OF OPERAND SYMBOLS
MTHDREND EQU   *                        END OF HEADER
MTHDRLN  EQU   MTHDREND-MTEXT           LENGTH OF HEADER
         SPACE
MTEXTA   DSECT ,                        VARIABLE PORTION--OUTPUT
         SPACE
MTNMO    DSW   ,                        NAME CARD POINTER
MTNML    DS    C                        NAME LENGTH
MTNAME   EQU   *                        NAME
         ORG   MTNMO                    BACK TO START FOR RE-MAP
MTOCO    DSW   ,                        MNEMONIC CARD POINTER
MTOCL    DS    C                        MNEMONIC LENGTH
MTOPCD   EQU   *                        MNEMONIC
         ORG   MTNMO                    BACK AGAIN FOR RE-MAP
MTOPO    DSW   ,                        OPERAND CARD POINTER
MTOPL    DS    C                        OPERAND LENGTH
MTOPND   EQU   *                        OPERAND
         ORG   MTNMO                    BACK FOR RE-MAP
MTCOP    DS    C                        COMMENT OUTPUT POINTER
MTCML    DS    C                        COMMENT LENGTH
MTCMM    EQU   *                        COMMENT
         ORG   MTNMO                    BACK AGAIN
MTSTC    DS    C                        STRING COUNT
MTSTO    DS    C                        STRING1 POINTER
MTSTL    DS    C                        STRING1 LENGTH
MTSTR    EQU   *                        STRING1
         ORG   MTNMO                    ORG BACK FOR NEXT STRING
MTSTO2   DS    C                        STRING2 POINTER
MTSTL2   DS    C                        STRING2 LENGTH
MTSTR2   EQU   *                        STRING2
         SPACE 3
PARMTAB  DSECT ,                        MAP OF PARAMETER TABLE ENTRIES
         SPACE
PFLAG    DSW   PSUB,                    SUB-OPERAND (ALL)              X
               PSUBL,                   SUB-OPERAND (LAST)             X
               PSUBF,                   SUB-OPERAND (FIRST)            X
               PPASS,                   PASSED PARAMETER               X
               POMIT,                   OMITTED OPERAND                X
               POS,                     ORDINARY SYMBOL                X
               PSDT,                    SELF-DEFINING TERM             X
               PCHAR                    CHARACTER STRING
         SPACE
PCS      EQU   *                        PARAMETER--CHARACTER STRING
PTAT     DS    C                        TYPE ATTRIBUTE
PPAD     DS    4C                       PAD
         DS    C                        DEFAULT BITS
PKAT     DS    C                        COUNT ATTRIBUTE (LENGTH)
PSTRING  EQU   *                        STRING START
         ORG   PCS                      RE-SET FOR NEXT MAP
*PSDT    EQU   *                        SELF DEFINING TERM
         DS    C                        TYPE ATTRIBUTE
PVAL     DS    4C                       VALUE
         ORG   PCS                      NEXT MAP
*POS     EQU   *                        ORDINARY SYMBOL REFERENCE
         DS    C                        TYPE
PLAT     DS    2C                       LENGTH ATTRIBUTE
PSAT     DS    2C                       SCALE ATTRIBUTE
ATTRIB   DSW   TDEFALT,                 TYPE ATTRIBUTE IS DEFAULT VALUEX
               LDEFALT,                 SAME FOR LENGTH                X
               SDEFALT,                 SAME FOR SCALE                 X
               UDEFALT                  UNDEFINED SYMBOL
         ORG   PCS                      NEXT MAP
*POM     EQU   *                        OMITTED--SAME AS PCS
*PSUB    EQU   *                        SUBLIST HEADER
         DS    C                        TYPE
PLATSUB  DS    2C                       LENGTH ATTRIBUTE
PSATSUB  DS    2C                       SCALE ATTRIBUTE
         ORG   PLATSUB                  ORIGIN TWO
PVALSUB  DS    4C                       VALUE
PNAT     DS    2C                       NUMBER ATTRIBUTE--COUNT OF     X
                                          SUBOPERANDS
PKATSUB  DS    2C                       TOTAL COUNT OF ALL CHARACTERS  X
                                          LESS DELIMITING COMMAS AND   X
                                          PARENS.
PLIST    DS    3C                       VECTOR LIST POINTER.
         EJECT
RSYMRCD  DSECT
         COPY  RSYMRCD                  SYMBOL PHASE RECORD DSECT HERE
         EJECT
         COPY  GENCOM
GENCOMLN EQU   (GENCOM99-GENCOM+7)/8    MODULE COMMON LENGTH IN        X
                                                       DOUBLE WORDS
         EJECT
         COPY  JTMTXT
*
*        OP CODE TABLE ENTRY MAP
*
         SPACE
OPNTRY   DSECT
OCHAIN   DS    XL2                      CHAIN POINTER
OFLAGS   DS    X                        FLAGS
OMNEM    EQU   *                        MNEMONIC
         ORG   OPNTRY                   DUMMY FOR POST VARIABLE FIELD
OFLAGA   DS    X                        FLAGA
OINTCD   DS    X                        INTERNAL OP CODE
OINTCD2  DS    X                        OP CODE BYTE 2
OMASK    EQU   OINTCD2                  ESTENDED MNEMONIC MASK
         COPY  JERRCD
ERRMESS  DSECT
EMSGSVTY DS    C                        ERROR SEVERITY CODE
EMSGCODE DS    C                        ERROR NUMBER
EMSGHL   EQU   *-EMSGSVTY               LENGTH FOR SEVERITY NUMBER
ENTRYLNG DS    C                        SNAPSHOT/DATA LENGTH
EMSGNTRY DS    CL8                      SNAPSHOT/DATA
*
* THIS DSECT MAPS THE OPSYN TABLE ENTRY
*
OPSYNTRY DSECT
OPSYNFLG DSW   ,,,,                     SPACE FOR OPCODE FLAGS         X
               OMAC,                    OPSYN MACRO (NOT USED HERE)    X
               ODEL                     DELETED
OPSYNATT DS    XL3                      ATTRIBUTES
ONAMEL   DS    XL1                      NAME LENGTH
ONAME    DS    XL8                      NAME
OPSYND   EQU   *
         EJECT
X3000    DSECT
         SPACE 3
*EQUATES TO BE USED IN SHIFT-MULTIPLY OPERATIONS
         SPACE
TIMES1   EQU   0
TIMES2   EQU   1
TIMES4   EQU   2
TIMES8   EQU   3
TIMES16  EQU   4
TIMES32  EQU   5
TIMES64  EQU   6
TIMES128 EQU   7
TIMES256 EQU   8
         SPACE 3
*        REGISTERS
         SPACE
INDEX1   EQU   R14                      SCRATCH USED AS TEMPORARY INDEX
INDEX2   EQU   R15
RETURN   EQU   R9                       RETURN REGISTER AFTER LINK
SYMPTR   EQU   R11                      FIXED SYMBOL RECORD BASE
SYMPTR2  EQU   R4                       VARIABLE SYMBOL RECORD BASE
FLDPTR   EQU   R2                       MOVEABLE TEXT POINTER--LOCTR
FLDLN    EQU   R2                       LENGTH REGISTER--EVAL
RMOVE    EQU   R3                       EXECUTED MOVE REGISTER--KEEP   X
                                          CLEAR.
EVEN     EQU   R2                         EVEN--
ODD      EQU   R3                             ODD PAIR
RCOMP0   EQU   R0                       SCRATCH AS NEEDED
RCOMPX   EQU   R2                       NON-VOLATILE COMP REG
STACKPTR EQU   R5                       CURRENT EVAL STACK LEVEL
INPTR    EQU   R5                       JTEXT INPUT POINTER
RCOMP1   EQU   R1                       SCRATCH COMPUTATION REGISTER
RLOCTR   EQU   R6                       LOCATION COUNTER SEGMENT
VTXTPTR  EQU   R6                       VARIABLE PORTION OF TEXT
FTXTPTR  EQU   INPTR                    FIXED PORTION OF TEXT
SYMLEN   EQU   R4                       SYMBOL LENGTH
FTXTIN   EQU   R5
VTXTIN   EQU   R6
FTXTOUT  EQU   R11
VTXTOUT  EQU   R4
HEDRPTR  EQU   FLDPTR                   PARAMETER HEADER
METAPTR  EQU   VTXTIN                   PARAMETER META TEXT
         SPACE
*        LANGUAGE DEPENDENT VALUES
         SPACE
MAXDEC   EQU   10                       MAXIMUM DIGITS CONVERTIBLE     X
                                          CHARACTER TO BINARY.
MAXNAME  EQU   8                        MAXIMUM SYMBOL LENGTH
HIALPHA  EQU   JAT                      LAST ALPHABETIC CHARACTER
LOALPHA  EQU   JA                       FIRST ALPHABETIC CHARACTER
HINUM    EQU   J9
LONUM    EQU   J0
HIALNUM  EQU   HIALPHA
LOALNUM  EQU   LONUM
         SPACE
*        SYSTEM TO GENERATOR TEXT FILE EQUATES
         SPACE
GTFILE   EQU   FILE2                    GENERATED TEXT FILE
PMTFILE  EQU   FILE1                    PROGRAMMER MACRO TEXT
SMTFILE  EQU   FILE1                    SYSTEM MACRO TEXT FILE
DFILE    EQU   FILE1                    DICTIONARY FILE
SDFILE   EQU   FILE3                    SYMBOL DEFINITION FILE
SRFILE   EQU   FILE3                    SYMBOL REFERENCE FILE
         SPACE
*        GENERATOR LIMITING EQUATES--MAY BE CHANGED TO INCREASE NON    X
                                        LANGUAGE DEPENDENT LIMITS.
         SPACE
MAXREC   EQU   256                      MAXIMUM RECORD SIZE
MAXSTRNG EQU   17                       MAXIMUM PRE-BEGIN POST-END SIZE
MAXSYM   EQU   MAXNAME                  MAXIMUM SYMBOL LENGTH
MAXCHAR  EQU   255                      MAXIMUM CHARACTER STRING
MAXGENLN EQU   298
D256     EQU   256                      MAXIMUM MOVE LENGTH
         SPACE
*        DICTIONARY ROUTINE ENTRY PARAMETERS
         SPACE
PHASENTR EQU   0
MACRCALL EQU   2
CALLEND  EQU   4
MACRKWRD EQU   6
MACRPOST EQU   8
PROTOKWD EQU   10
PROTOEND EQU   12
GBLDICTR EQU   14
GBLDICTS EQU   16
LCLDICTR EQU   18
LCLDICTS EQU   20
PARMTBLR EQU   22
SEQSYMBR EQU   24
ORDSYMBR EQU   26
MACRFINI EQU   28
         EJECT
         COPY  JERMSGCD
         EJECT
         JCSECT (X3A00)
* VS1 RELEASE 3 CHANGES
*A026200,192400-192867                                         @OX00407
*D192600                                                       @OX00407
* VS1 RELEASE 3.1 CHANGES
*A532600                                                       @YA03863
*A531100-531280                                                @OY06599
*D532600                                                       @OY06599
*D531100-531280                                                @OX09721
*A710500                                                       @OX09721
*A640000-640140                                                @AZ10934
         JMODID
         SPACE 3
MENTRY   JSAVE BASE=YES
         SPACE
         JENTRY (X3A01=MENTRY)          ENTRY POINT AS EXTERNAL NAME
         SPACE 3
*        INITIALIZE THE GENERATOR
         SPACE
MINIT    EQU   *
         SPACE
         SPACE
*        GET CORE FOR MODULE COMMON
         SPACE
         JGETCORE DBL=GENCOMLN
         SPACE
         LR    R7,R10                   BASE FOR MODULE COMMON SET UP
         XC    GENCOM(GENSPEND-GENCOM),GENCOM CLEAR TO ZEROS
         SPACE
*        PASS CONTROL TO DICTIONARY INITIALIZATION
         SPACE
         DICTCALL   PHASENTR
         SPACE
*        PERMANENTLY CLEAR A REGISTER
         SPACE
         SR    RMOVE,RMOVE              LOW BYTE ONLY TO BE USED
         SPM   RMOVE                    NO INTERRUPTS, PLEASE
         SPACE
*        PREPARE EVAL WORK SPACE
         SPACE
         LA    RCOMP1,ENDSTACK          LOCATE END OF STACK
         ST    RCOMP1,STACKEND          AND SAVE IT
         LA    RCOMP1,STRING1           STRING BUFFER 1
         ST    RCOMP1,STRPTR1             AND SAVE IT
         LA    RCOMP0,STRING2           MASK FOR
         XR    RCOMP0,RCOMP1              FLIPPING TO
         ST    RCOMP0,STRPTR2           STRING BUFFER 2 AND BACK.
         LA    RCOMP0,ERRSTK            GET PTR TO START OF ERROR STK
         ST    RCOMP0,ESTKNDX           INITIALIZE MOVEABLE STACK PTR
         SPACE 3
MINPUT   EQU   *                        INPUT SOURCE
         SPACE
         JGETL FILE=FILE1               GET NEXT INPUT TEXT RECORD
         SPACE
         SPACE
         LR    INPTR,R11                SET UP A BASE FOR
         USING JTEXT,INPTR                INPUT RECORD AND
         ST    INPTR,TXTIN              ALSO SAVE IT FOR LATER USE
         SR    RMOVE,RMOVE              CLEAR A REGISTER FOR LATER
         SPACE
         GOIF  INMACRO,OFF=MINPUT12     NOT IN A MACRO, CONTINUE.
         SET   JGEN,ON                    ELSE INDICATE THAT THIS IS A X
                                          GENERATED STATEMENT.
         SPACE
MINPUT12 EQU   *
         SPACE
         GOIF  JPRONLY,ON=FLUSH90       ALREADY PRINT ONLY
         GOIF  INMACDEF,ON=MINPUT35     GO IF WITHIN MACRO DEFINITIONS
         GOIF  JPSOP,ON=MINPUT20        SEPARATE PSEUDO OPS
         GOIF  (FLUSH1,FLUSH2,FLUSH3),NONE=MFEVAL
         GOIF  FLUSH3,ON=FLUSH05
         GOIF  FLUSH2,ON=FLUSH20
         GOIF  JSYSMAC,ON=FLUSH20       CONTINUE TO PRINT IF SYSMAC
         B     FLUSH25                  EXIT
MINPUT20 GOIF  JTERROR,EQ=FLUSH84       ERROR RECORD
         GOIF  JTEOF,EQ=MEXIT10         END OF FILE
         GOIF  (FLUSH1,FLUSH2,FLUSH3),NONE=MINPUT22
         GOIF  FLUSH1,ON=MINPUT25       BRANCH IF END FOUND
         GOIF  FLUSH3,ON=FLUSH05        BRANCH IF END TO BE GENERATED
         GOIF  JTEEOF,NE=FLUSH10
         GOIF  JSYSMAC,OFF=FLUSH25
         B     FLUSH30
MINPUT22 GOIF  JTEEOF,NE=MINPUT50       BR IF NOT END OF SOURCE INPUT
FLUSH05  SET   FLUSH3,OFF               RESET
         SET   FLUSH1,ON                INDICATE END CARD
         BAL   R3,DMYENDRT              GENERATE END CARD
         B     MINPUT12                 PROCESS AGAIN
MINPUT25 GOIF  JSYSMAC,OFF=FLUSH25      EXIT IF NOSYSMAC
         GOIF  JTEEOF,EQ=FLUSH30        PRINT SYSTEM MACROS
         B     FLUSH10                  PRINT FROM SYSIN
MINPUT35 GOIF  JPSOP,OFF=FLUSH20        TEST IF PSEUDO OPS
         GOIF  JTERROR,EQ=FLUSH84       ERROR RECORD
         GOIF  JTMEND,NE=FLUSH10        BRANCH IF NOT MEND
         SET   INMACDEF,OFF             INDICATE END OF DEFINITION
         B     FLUSH20                  PRINT MEND
FLUSH10  GOIF  JTCPKEY,LO=FLUSH20       SIFT OUT THE PARAMETER
         GOIF  JTPEND,HI=FLUSH20,LO=FLUSH15   RECORDS
         GOIF  JERR,OFF=MINPUT          CHECK PARAMETERS END RECORDS
         L     R1,TXTOUT                FOR ERROR FLAG TRANSFER
         USING MTEXT,R1
         SET   MERR,ON                  ERROR FLAG TO LAST RECORD PUT
         DROP  R1
         B     MINPUT                   NEXT RECORD
FLUSH15  GOIF  JTPROTO,NE=MINPUT        DO NOT PASS THEM
FLUSH20  SET   JPRONLY,ON               SET PRINT ONLY
         BAL   RETURN,PRINT90           PRINT THE RECORD
         SET   JPRONLY,OFF              CLEAN UP THE PRINT FLAGS
         B     MINPUT                   NEXT RECORD
FLUSH25  LA    INPTR,=AL1(D0,D8,JPSOP,D0,JTEOF,D0) SET UP END OF FILE
         B     MEXIT10                  EXIT
FLUSH30  JPUTM FILE=FILE2,ADDR==AL1(D0,D8,JPSOP,D0,JTSICTL,D0)         X
               PUT OUT SPECIAL RCD FOR ICTL SWITCH FOR X51
         B     MINPUT                   READ NEXT RECORD
FLUSH84  EQU   *
         L     R1,TXTOUT                PICK UP PTR TO LAST RCD PUT
         USING MTEXT,R1
         GOIF  MTIOP,JTERROR,EQ=FLUSH85 CONT TOUCH AN ERROR RECORD
         SET   MERR,ON                  INDICATE ERROR TO BE FLAGGED
         GOIF  MPSOP,OFF=FLUSH85        BRANCH IF NOT PSEUDO-OP
         GOIF  MTIOP1,JTANOP,LO=FLUSH85 BRANCH IF NOT A GENERATOR-
         GOIF  MTIOP1,JTMEND,HI=FLUSH85 PROCESSED PSEUDO-OP
         L     R1,ACTRCNT               PICK UP CURRENT ACTR VALUE
         SRL   R1,D1                    HALVE IT ON EDITOR ERROR
         ST    R1,ACTRCNT               SAVE NEW ACTR VALUE
         DROP  R1
FLUSH85  EQU   *                        PASS UNCHANGED
         SPACE
         BAL   RETURN,PRINT90           PRINT A COPY, PLEASE
         B     MINPUT                   GO BACK FOR ANOTHER ONE
FLUSH90  GOIF  FLUSH3,ON=FLUSH05        BRANCH IF END TO BE GENERATED
         GOIF  FLUSH1,OFF=FLUSH85       CHECK IF END STATEMENT FOUND
         GOIF  JSYSMAC,ON=FLUSH85       CHECK IF SYSMAC OPTION IS ON
         B     FLUSH25
MEXIT10  LR    R2,INPTR                 PRESERVE EOF RCD POINTER
         JFRECORE ADDR=FREESTRT         FREE UP DICTIONARY SPACE
         JFRECORE ADDR=(R7)             RETURN MODULE COMMON TO SYSTEM
         SPACE
         LA    R10,GTFILE               ELSE INDICATE GENERATED TEXT
         JPUTM FILE=(R10),ADDR=(R2)     AND MOVE EOF RECORD
         LA    R10,SDFILE               LIKEWISE SYMBOL FILE
         LA    R11,EOFSD                SYMBOL DEFINITION END-OF-FILE
         JPUTM FILE=(R10),ADDR=(R11)
         JPOINT FILE=FILE1,NEXT=START   REWIND FILE1
         JPOINT FILE=FILE3,NEXT=START   REWIND FILE3
         JTRUNC FILE=FILE2              TRUNCATE FILE2  TEXT FILE.  DO X
                                        NOT REPOSITION BECAUSE NEXT    X
                                        PHASE NEEDS END OF FILE.
MGET99   JRETURN ,                      AND EXIT FROM PHASE
         SPACE
EOFSD    DC    H'8',AL1(0,0,JTEOFII,0)  SYMBOL DEFINITION END OF FILE
DMYENDRT JPUTM FILE=FILE2,ADDR=DUMYEND  PUT OUT DUMMY END STATEMENT
         ST    R3,GENREGS               PRESERVE RETURN REGISTER
         ST    R11,TXTOUT               PRESERVE TEXT RECORD POINTER
         L     R12,=A(X3B01)            SET UP TO CALL S.I. PREPROC.
         BALR  R9,R12                   CALL SYMBOL INTERLUDE PREPROC.
         L     INPTR,TXTIN              RESTORE PTR TO LAST TEXT RCD
         CLI   JMSGL,SEV60              CHECK MSGLEVEL
         BH    DONTPUT                  DONT FLAG IF HIGH
         L     R3,TXTOUT                PUTPUT POINTER
         USING MTEXT,R3
         SET   MERR,ON                  FLAG ERROR
         DROP  R3
         JPUTM FILE=FILE2,ADDR==AL1(D0,D12,JPSOP,JNOCNT,JTERROR,D0,D0,DX
               0,D0,SEV60,ERR60,D0) GENERATE GENERATED END DIAGNOSTIC
DONTPUT  L     R3,GENREGS               RESTORE RETURN REGISTER
         BR    R3                       RETURN TO CALLER
         SPACE
         SPACE
MINPUT50 EQU   *
         SPACE
         GOIF  HIGENOP,NOTLO=MFEVAL     TOO HIGH FOR GENERATOR OP, GO  X
                                          PERFORM SUBSTITUTION.
         GOIF  LOGENOP,NOTLO=MLKUP      OK, LOOKUP GENERATOR OP AND    X
                                          PROCESS IT.
         GOIF  JTCOPY,LT=MFEVAL         LET ICTL,ISEQ,OPSYN GO THRU
*              ALL THAT REMAIN ARE ANOP,GBLX,LCLX,COPY
         BAL   RETURN,PRINT10           PRINT IF OPTIONS ALLOW
         B     MINPUT                   GO BACK FOR NEXT RECORD
         SPACE
         DROP  INPTR
         SPACE 3
MFEVAL   EQU   *                        SEND ALL MACHINE AND ASSEMBLER X
                                        OPS OUT FOR FIELD EVALUATION.
         L     FTXTIN,TXTIN             GET INPUT TEXT POINTER
         USING JTEXT,FTXTIN               AND DECLARE AS BASE
         GOIF  JPSOP,OFF=FEVAL10        LOOK ONLY AT PSEUDO-OPS
         GOIF  JTHCMNT,NE=FEVAL10       ONLY LOOK AT HIDDEN COMMENTS
         BAL   RETURN,PRINT30           GO TO PRINT THEM IF REQ'D
         B     MINPUT                   GO BACK FOR NEXT STATEMENT
*        GET A WORK BUFFER AND SAVE THE POINTER TO IT
         SPACE
FEVAL10  EQU   *
         SPACE
         LA    R10,GTFILE               GENERATED TEXT FILE IS OUTPUT
         GOIF  (JSUBNAME,               ANY SUBSTITUTION,              X
               JSUBOPCD,                                               X
               JSUBOPND),                                              X
               ANY=FEVAL22                GO PREPARE FOR FIELD EVAL.
         SPACE
         BAL   RETURN,PRINT25           PUT OUT PRINT IMAGEIF REQD
         B     MLOCTR                   RETURN TO DRIVER
         SPACE
MOVEOP   MVC   JFWORD1(D0),D0(R12)      EXECUTED MNEMONIC MOVE
         USING OPNTRY,R14               BASE FOR COMPARE
OPCOMP   CLC   JFWORD1(D0),OMNEM        REMOTE MNEMONIC COMPARE
         DROP  R14
         SPACE 3
         SPACE 3
FEVAL22  EQU   *                        GET READY FOR SUBSTITUTION
         SPACE
         SET   JPRONLY,ON               PUT PRINT ONLY COPY OF MODEL
         GOIF  JERR,OFF=NOERR           TEST IF ERROR STATEMENT
         SET   JERR,OFF                 DO NOT FLAG PRESUBST
         BAL   RETURN,PRINT10           PRINT IF OPTIONS ALLOW
         SET JERR,ON                    RESET MASTER COPY
         B     PRINTOFF                 GO ON
NOERR    BAL   RETURN,PRINT10           PRINT PRE-SUBSTITUTION COPY
PRINTOFF SET   JPRONLY,OFF              CLEAN UP STMT MASTER COPY
         SPACE
         SR    R11,R11                  SET UP BASE FOR CALC
         GOIF  JTCPR,HHDRLN,EQ=FEVAL23 BRANCH IF NO COMMENTS
         SH    R11,JTCPR                GET DISPL TO COMMENTS START
         B     FEVAL24                  GO CALC COMMENTS,STRNG LEN
FEVAL23  GOIF  JTSPR,HHDRLN,EQ=FEVAL25  BRANCH IF NO STRINGS
         SH    R11,JTSPR                GET DISPL TO STRINGS START
FEVAL24  AH    R11,JTRLI                CALC LENGTH OF COMMENTS,STRS
FEVAL25  LA    R11,MAXGENLN(,R11)       CALC LENGTH OF BUFFER NEEDED
         JPUTL FILE=(R10),BUFREQ=(R11)  REQUEST A BUFFER
         ST    R11,TXTOUT               AND SAVE ITS ADDRESS
         USING MTEXT,FTXTOUT              AND SET A BASE FOR IT.
         SPACE
         MVC   MTEXT(MTHDRLN),JTEXT     MOVE RECORD HEADER TO OUTPUT
         SET   MGEN,ON                  INDICATE GENERATED STATEMENT
         SPACE
*                             NAME FIELD
         SPACE
FEVAL30  EQU   *
         LA    VTXTOUT,MTHDRLN          START OF VARIABLE OUTPUT FIELD
         STH   VTXTOUT,MTNMP            STORE NAME FIELD POINTER
         LH    VTXTIN,JTNMP             PICK UP NAME POINTER
         SPACE
         GOIF  JSUBNAME                 SET CONDITION CODE
         SPACE
         SPACE
FEVAL32  BAL   RETURN,MOVEFLD           MOVE THE FIELD TO OUTPUT
         GOIF  JSUBNAME,OFF=FEVAL40     NO NAME SUBSTITUTION, SKIP
         L     R15,GENRTRN              PICK UP POINTER TO NAME LENGTH
         USING JTOPL,R15                DECLARE AS BASE
         IC    RMOVE,JTOPL              PICK UP FIELD LENGTH
         GOIF  (RMOVE),ZERO=FEVAL40     ZERO LENGTH, SKIP AHEAD
FEVAL33  EQU   *
         LR    R14,RMOVE                SET UP LOOP COUNT REGISTER
FEVAL34  LA    R1,D0(R14,R15)           GET PTR TO NEXT TRAILING CHAR
         CLI   D0(R1),JBLANK            LOOK FOR TRAILING BLANK
         BNE   FEVAL35                  BRANCH ON NON-BLANK
         BCT   R14,FEVAL34              LOOP THRU TRAILING BLANKS
FEVAL35  STC   R14,JTOPL                SAVE FINAL FIELD LENGTH
         GOIF  JTOPL,D8,LE=FEVAL40      SEE IF FIELD LENGTH ALRIGHT
         LA    R12,LOGERR01             GET BASE FOR ERROR LOGGING RTN
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV129,ERR129)       ERROR PARAMETERS
         SET   MNMERR,ON                INDICATE BOGUS NAME
         MVI   JTOPL,D8                 GIVE BACK ONLY FIRST 8 CHARS
         SR    VTXTOUT,RMOVE            ADJUST TEXT OUTPUT PTR TO
         LA    VTXTOUT,D8(,VTXTOUT)     REFLECT TRUNCATED NAME
         DROP  R15
         SPACE
*                             OP CODE FIELD
         SPACE
FEVAL40  EQU   *
         SPACE
         LH    VTXTIN,JTOCP             PICK UP INPUT DISPLACEMENT
         STH   VTXTOUT,MTOCP            STORE OUTPUT DISPLACEMENT
         SPACE
         GOIF  JSUBOPCD                 SET CONDITION CODE
         SPACE
         SPACE
FEVAL42  BAL   RETURN,MOVEFLD           MOVE THE FIELD TO OUTPUT
         GOIF  JSUBOPCD,OFF=FEVAL50     NO OP CODE SUBSTITUTION, SKIP.
         L     R15,GENRTRN              POINT TO MNEMONIC LENGTH AND
         USING JTOPL,R15                DECLARE AS BASE.
         IC    RMOVE,JTOPL              PICK UP OP CODE LENGTH
         CH    RMOVE,=H'8'              CHECK FOR VALID FIELD LENGTH
         BH    LOGER128                 BRANCH IF TOO MANY CHARACTERS
         GOIF  (RMOVE),ZERO=LOGER102    BRANCH IF NULL SUBSTITUTION
         XC    JFWORD1(L'JFWORD1+L'JFWORD2),JFWORD1 CLEAR NAME BUFFER
         LA    R1,JTOPND                SET UP STRING START PTR
         AR    R15,RMOVE                SET UP STRING END PTR
         LA    R14,D1                   SET UP BXLE INCREMENT
FEVAL43  CLI   D0(R1),JBLANK            LOOK FOR LEADING BLANK
         LR    R12,R1                   SAVE PTR IN CASE NON-BLANK
         BNE   FEVAL45                  BRANCH IF NON-BLANK
         BXLE  R1,R14,FEVAL43           LOOP THRU LEADING BLANKS
LOGER102 LA    R12,LOGERR01             GET BASE FOR ERROR LOGGING RTN
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV102,ERR102)       ERROR PARAMETERS
         B     FEVAL49                  GO FLAG STMT AS BAD
LOGER128 EQU   *
         LA    R12,LOGERR01             GET BASE FOR ERROR LOGGING RTN
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV128,ERR128)       ERROR PARAMETERS
         SET   MPRONLY,ON               INDICATE NO HOPE FOR THIS STMT
         L     R15,GENRTRN              RESTORE STARTING POINTER
         MVI   JTOPL,D8                 GIVE BACK ONLY FIRST 8 CHARS
         SR    VTXTOUT,RMOVE            ADJUST TEXT OUTPUT PTR TO
         LA    VTXTOUT,D8(,VTXTOUT)     REFLECT TRUNCATED OP CODE
         B     FEVAL50                  CONTINUE WITH OPERAND
         DROP  R15
FEVAL46A CLI   D0(R1),JBLANK            LOOK FOR MORE TRAILING BLANKS
         BNE   LOGER101                 BRANCH IF NON-BLANK FOUND
FEVAL46B BXLE  R1,R14,FEVAL46A          LOOP THRU BLANK CHARACTERS
         LR    R1,R0                    RESTORE END POINTER
         B     FEVAL46                  GO HANDLE GOOD OP CODE
FEVAL44  CLI   D0(R1),JBLANK            LOOK FOR FIRST TRAILING BLANK
         LR    R0,R1                    PRESERVE END POINTER
         BE    FEVAL46B                 BRANCH IF FOUND
FEVAL45  BXLE  R1,R14,FEVAL44           LOOP THRU NON-BLANK CHARS
FEVAL46  SR    R1,R12                   GET LENGTH OF NON-BLANK STRING
         STC   R1,JFWORD1-D1            SET UP LENGTH FOR OPSYN SCAN
         BCTR  R1,D0                    GET MOVE LENGTH OF OP CODE
         EX    R1,MOVEOP                INSERT OP CODE IN WORK AREA
         CLC   OPSNSTRT,=F'0'           SEE IF ANY OPSYN TABLE
         BZ    OPSC5                    BYPASS OPSYN LOOK UP IF NOT
OPSC1    L     R14,OPSNSTRT             POINT TO START OF TABLE
OPSC3    C     R14,GDSTRT               CHECK FOR END OF TABLE POINT
         BNL   OPSC5                    BRANCH IF ALL ENTRIES SCANNED
         USING OPSYNTRY,R14
         CLC   ONAMEL(L'ONAMEL+L'ONAME),JFWORD1-D1 LOOK FOR THE NAME
         BE    OPSC4                    BRANCH IF OPSYN FOUND
         LA    R14,OPSYND-OPSYNTRY(,R14) ADJUST PTR TO NEXT ENTRY
         B     OPSC3                    GO BACK FOR MORE SEARCHING
OPSC4    GOIF  ODEL,ON=LOGER102         DELETED OP CODE
         LA    R14,OPSYNATT             POINT TO FLAGA AND INTERNAL OPS
         B     FEVAL46C                 SKIP AHEAD
OPSC5    EQU   *
         L     R15,JFWORD1              ADD TWO HALVES OF MNEMONIC
         AL    R15,JFWORD2              TO DEVELOP HASH VALUE
         SR    R14,R14
         D     R14,=F'71'                 POINTER BY DIVIDING RESULT.
         AR    R14,R14                  DOUBLE REMAINDER AND
         A     R14,=A(OPBASE)             ADD IN OP CODE TABLE BASE.
         JEXTRN (X3K01=OPBASE)          DECLARE EXTERNAL
         USING OPNTRY,R14               R14 NOW IS BASE FOR OPTAB ENTRY
OPLOOP   CLC   OCHAIN,=F'0'             SEE IF SUBSTITUTED OP LEGAL
         BZ    LOGER101                 BRANCH IF NOT EVEN FOUND
         MVC   JHWORD1,OCHAIN           ALIGN CHAIN POINTER AND
         LH    R14,JHWORD1
         A     R14,=A(OPBASE)           ADD IN TABLE BASE (NEXT ENTRY)
         IC    RMOVE,OFLAGS             GET LENGTH OF MNEMONIC FROM
         N     RMOVE,=A(D7)             OP CODE TABLE ENTRY FLAGS
         GOIF  (R1),(RMOVE),NE=OPLOOP   NOT EQUAL TO INPUT, LOOP.
         EX    RMOVE,OPCOMP             ELSE COMPARE MNEMONIC ITSELF.
         BNE   OPLOOP                   NOT EQUAL, LOOP.
         LA    R14,D4(RMOVE,R14)        POINT TO FLAGA ENTRY
FEVAL46C EQU   *
         MVC   MTFLGA,OFLAGA            FOUND IT--MOVE FLAGA
         MVC   MTIOP,OINTCD               AND INTERNAL OP TO TEXT.
         GOIF  MPSOP,ON=FEVAL47         BRANCH IF PSEUDO-OP
         TM    MTFLGA,BIT0+BIT1         CHECK TYPE OF MACHINE OP
         BNZ   FEVAL48                  BRANCH IF TWO BYTE OP CODE
FEVAL47  MVI   MTIOP2,J0                CLEAR 2ND BYTE FOR ALL OTHERS
FEVAL48  EQU   *
         B     FEVAL50                  CONTINUE AT OPERAND
         DROP  R14
         SPACE
LOGER101 LA    R12,LOGERR01             GET BASE FOR ERROR LOGGING RTN
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV101,ERR101)       ERROR PARAMETERS
FEVAL49  SET   MPRONLY,ON               FLAG STMT AS BAD AND CONTINUE
         SPACE
*                             OPERAND FIELD
         SPACE
FEVAL50  EQU   *
         SPACE
         LH    VTXTIN,JTOPP             OPERAND DISPLACEMENT INPUT
         STH   VTXTOUT,MTOPP            STORE OUTPUT
         GOIF  JSUBOPND                 SET CONDITION CODE
         SPACE
         SPACE
FEVAL52  BAL   RETURN,MOVEFLD           MOVE THE FIELD TO OUTPUT
         L     R15,GENRTRN              POINT TO MNEM LENGTH    OX00407
         USING JTOPL,R15                AND DECLARE AS BASE     OX00407
         IC    RMOVE,JTOPL              PICK UP OPERAND LENGTH  OX00407
         LA    R1,JTOPND                SET UP START POINTER    OX00407
         AR    R15,RMOVE                SET UP END POINTER      OX00407
         SR    R3,R3                    CLEAR COUNTER           OX00407
         LA    R14,D1                   SET UP BXLE INCREMENT   OX00407
FEVAL53  CLI   D0(R1),JBLANK            LOOK FOR LEADING BLANK  OX00407
         BNE   FEVAL55                  BRANCH IF NON-BLANK     OX00407
         LA    R3,D1(R3)                COUNT BLANKS            OX00407
         BXLE  R1,R14,FEVAL53           LOOP THRU LEADING BLNKS OX00407
         B     FEVAL56                  ONLY BLANKS IN OPERAND  OX00407
FEVAL55  L     R15,GENRTRN              POINT TO CARD POINTER   OX00407
         BCTR  R15,R0                   FOR OPERAND             OX00407
         USING MTOCO,R15                AND USE AS BASE         OX00407
         IC    R1,MTOPO                 UPDATE OPERAND CARD     OX00407
         AR    R1,R3                    POINTER BY LEAVING OUT  OX00407
         STC   R1,MTOPO                 LEADING BLANKS          OX00407
         IC    R1,MTOPL                 UPDATE OPERAND LENGTH   OX00407
         SR    R1,R3                    BY DELETING             OX00407
         STC   R1,MTOPL                 LEADING BLANKS          OX00407
         L     R15,GENRTRN              POINT TO MNEMONIC AGAIN OX00407
         USING JTOPL,R15                AND DECLARE AS BASE     OX00407
         LA    R1,JTOPND                SET UP STRING POINTER   OX00407
         SR    R14,R14                  CLEAR REG FOR LENGTH    OX00407
         IC    R14,JTOPL                INSERT OPERAND LENGTH   OX00407
         SR    R14,R3                   CALC NEW OPERAND LENGTH OX00407
         SR    VTXTOUT,R3               STEP BACK IF BLANKS     OX00407
         LA    R3,D0(R1,R3)             SET UP STRING POINTER   OX00407
         EX    R14,MOVEOPND             GET RID OF BLANKS       OX00407
         SR    RMOVE,RMOVE              CLEAR FOR MOVEFLD       OX00407
         B     FEVAL56                  BRANCH OVER MOVE        OX00407
         DROP  R15                                              OX00407
MOVEOPND MVC   D0(D0,R1),D0(R3)         GET RID OF BLANKS       OX00407
         SPACE 2                                                OX00407
FEVAL56  AR    VTXTOUT,FTXTOUT          GET PTR TO OPERAND END  OX00407
         MVI   D0(VTXTOUT),JBLANK       SUPPLY TRAILING BLANK
         LA    VTXTOUT,D1(,VTXTOUT)     ADJUST OUTPUT POINTER
         SR    VTXTOUT,FTXTOUT          RE-CALC NEXT FIELD DISPLACEM'T
         SPACE
*                             COMMENTS AND STRINGS
         SPACE
FEVAL60  EQU   *
         SPACE
         STH   VTXTOUT,MTCPR            COMMENT OUTPUT POINTER TO TEXT
         LH    VTXTIN,JTCPR             PICK UP COMMENT DISPLACEMENT
         BAL   RETURN,MOVEFLD           MVOE THE FIELD
         SPACE
*        STRINGS
         SPACE
         STH   VTXTOUT,MTSPR            STORE STRING POINTER--OUTPUT
         LH    VTXTIN,JTSPR             PICK UP POINTER--INPUT
         GOIF  JTSPR,HHDRLN,NE=FEVAL63  STRING POINTER POINTS TO END OFX
                                          TEXT HEADER (NULL), BRANCH.
         LA    RCOMP1,L'JTSTC           JUST MOVE STRING COUNT
         B     FEVAL64                  AND SKIP AHEAD
         SPACE
FEVAL63  EQU   *
         SPACE
         LH    RCOMP1,JTRLI             LENGTH OF REMAINDER OF RECORD
         SR    RCOMP1,VTXTIN              IS LENGTH MINUS DISPLACEMENT
         BCTR  RCOMP1,D0                  OF STRINGS MINUS ONE
FEVAL64  AR    VTXTIN,FTXTIN            ABSOLUTE INPUT ADDRESS
         AR    VTXTOUT,FTXTOUT          ACTUAL OUTPUT ADDRESS
         EX    RCOMP1,MVCFLD10          MOVE THE REST OF THE RECORD
         SPACE
FEVAL90  EQU   *
         SPACE
         LA    VTXTOUT,D1(RCOMP1,VTXTOUT) COMPUTE TOTAL RECORD LENGTH
         SR    VTXTOUT,FTXTOUT            AND STORE IN OUTPUT
         STH   VTXTOUT,MTRLI
         SPACE 3
*        SYMBOL PROCESSING FOR ASSEMBLY PHASES
         DROP  FTXTIN
         SPACE
MLOCTR   EQU   *
         USING JTEXT,FTXTOUT
         GOIF  JPRONLY,ON=ERRDUMP       IGNORE ALL PRINT-ONLY STMTS
         GOIF  JPSOP,OFF=MLOCTR10       SKIP IF NOT PSEUDO-OP
         GOIF  JTIOP,JTCALL,EQ=MINPUT   GO NO FURTHER ON MACRO CALL
         GOIF  JTIOP,JTEND,NE=MLOCTR05  IF NOT SUBSTITUTED END, SKIP
         L     RCOMPX,MACROLVL          GET MACRO NEST COUNT
         GOIF  (RCOMPX),NOTPOS=MLOCTR02 BRANCH IF NO POP NECESSARY
         ST    FTXTOUT,GENREGS          PRESERVE OUTPUT TEXT POINTER
         SET   GENEND,ON                INDICATE END FROM INSIDE MACRO
MLOCTR01 EQU   *
         DICTCALL MACRFINI              POP ONE LEVEL OF MACRO NEST
         BCT   RCOMPX,MLOCTR01          DECREMENT NEST COUNT
         L     FTXTOUT,GENREGS          RESTORE TEXT POINTER
MLOCTR02 EQU   *
         SET   INMACRO,OFF              INDICATE OUT OF MACRO NEST
         SET   FLUSH1,ON                INDICATE TEXT TO BE FLUSHED
         B     MLOCTR10                 PROCEED
MLOCTR05 EQU   *
         GOIF  JTIOP,JTTITLE,NE=MLOCTR10 SEE IF PSEUDO-OP IS TITLE
         LH    EVEN,JTNMP               IF SO, GET NAME FIELD DISPL
         AR    EVEN,FTXTOUT             DEVELOP PTR TO NAME FIELD
         USING JTNMO,EVEN
         SR    ODD,ODD                  CLEAR LENGTH REGISTER
         IC    ODD,JTNML                PICK UP NAME LENGTH
         GOIF  (ODD),ZERO=ERRDUMP       SEE IF NAME IS PRESENT
         GOIF  JTNML,D8,HI=LOGER125     BRANCH IF NAME TOO LONG
         LA    R1,JTNAME(ODD)           GET PTR PAST END OF NAME FIELD
         BCTR  R1,D0                    POINT TO LAST CHARACTER
         BCT   ODD,TITLE200             CHECK IF LENGTH IS ONE
         B     TITLE300                 STRING IS ONE CHARACTER
TITLE100 BCTR  R1,D0                    NEXT CHARACTER
TITLE200 CLI   D0(R1),JAT               CHECK IF ALPHANUMERIC
         BH    LOGER125                 ERROR IF NOT
         BCT   ODD,TITLE100             CHECK NEXT
         BCTR  R1,D0                    R1 NOW POINTS TO FIRST CHAR
         CLI   D0(R1),JPERIOD           CHECK IF SEQUENCE SYMBOL
         BE    TITLE400                 MAY BE SEQUENCE SYMBOL
TITLE300 CLI   D0(R1),JAT               MUST BE ALPHANUMERIC
         BH    LOGER125                 ERROR IF NOT
         GOIF  FRSTTITL,ON=LOGER104     BRANCH IF NAMED TITLE NOT FIRST
         IC    ODD,JTNML                LENGTH OF NAME FIELD
         EX    ODD,TITLEMOV             MOVE DECK ID
         SET   FRSTTITL,ON              INDICATE TITLE FOUND
         B     ERRDUMP                  GET NEXT RECORD
TITLE400 CLI   D1(R1),JA                CHECK IF 2ND CHAR ALPHA
         BL    LOGER125                 ERROR IF NOT
         B     MLOCTR11                 NAME FIELD IS SEQUENCE SYMBOL
LOGER104 LA    R12,LOGERR01             GET PTR TO ERROR ROUTINE
         BALR  R9,R12                   GO TO LOG THE ERROR
         DC    AL1(SEV104,ERR104)       ERROR PARAMETERS
         B     ERRDUMP                  GO TO FINISH UP STATEMENT
MLOCTR10 GOIF  JNMERR,ON=MLOCTR40       SKIP IF NAME ALREADY BAD
         LH    EVEN,JTNMP               IF NOT, GET NAME FIELD DISPL
         AR    EVEN,FTXTOUT             DEVELOP PTR TO NAME FIELD
         GOIF  JTNML,D0,EQ=MLOCTR30     BRANCH IF NAME NOT PRESENT
         GOIF  JTNAME,JPERIOD,NE=MLOCTR20 SEE IF NAME IS SEQ SYMBOL
MLOCTR11 EQU   *
         GOIF  GENEND,ON=MLOCTR12       BRANCH IF END FROM MACRO
         GOIF  INMACRO,OFF=MLOCTR15     BRANCH IF IN OPEN CODE
MLOCTR12 EQU   *
         GOIF  JMLOGIC,ON=MLOCTR40,     BRANCH IF SEQ SYMB NOT         X
               ELSE=MLOCTR16            TO BE SUPPRESSED
MLOCTR15 GOIF  JALOGIC,ON=MLOCTR40      BRANCH IF SEQ SYMB NOT SUPRESD
MLOCTR16 EQU   *
         MVI   JTNML,D0                 INDICATE NO NAME
         B     MLOCTR40                 PROCEED AS IF NO NAME
MLOCTR20 GOIF  JDEF,ON=MLOCTR25         CHECK IF NAME ALLOWED
         GOIF  JTIOP,JTOPSYN,EQ=MLOCTR25
         LA    R12,LOGERR01             ILLEGAL NAME FIELD
         BALR  R9,R12                   LOG ERROR
         DC    AL1(SEV16,ERR16)
         SET   JNMERR,ON                INDICATE INVALID NAME FIELD
MLOCTR25 GOIF  JTNML,D8,HI=LOGER125     BRANCH IF NAME TOO LONG
         SR    ODD,ODD                  CLEAR LENGTH REGISTER
         IC    ODD,JTNML                PICK UP NAME LENGTH
         LA    R1,JTNAME(ODD)           GET POINTER PAST NAME FIELD
MLOCTR27 BCTR  R1,D0                    BACK UP TO NEXT CHARACTER
         CLI   D0(R1),JAT               CHECK FOR NAME VALIDITY
         BH    LOGER125                 BRANCH IF OUT OF RANGE
         BCT   ODD,MLOCTR27             BRANCH UNTIL ALL CHARS CHECKED
         CLI   D0(R1),J9                CHECK FIRST CHAR FOR ALPHA ONLY
         BH    MLOCTR30                 BRANCH IF ALL CRITERIA MET
LOGER125 EQU   *
         LA    R12,LOGERR01             GET BASE FOR ERROR LOGGING RTN
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV125,ERR125)       ERROR PARAMETERS
         SET   JNMERR,ON                INDICATE BAD NAME
         B     MLOCTR40                 GO ON
TITLEMOV MVC   JDECKIDL(D0),JTNML       EXECUTED DECK ID MOVE
SYSMOVE  MVC   SYSECT(D0),JTNML         EXECUTED SYSECT MOVE
MLOCTR30 GOIF  JPSOP,OFF=MLOCTR40       LOOK AT PSEUDO-OPS ONLY
         GOIF  JTIOP,JTCOM,GT=MLOCTR40  LOOK FOR PSEUDO-OPS CSECT,
         GOIF  JTIOP,JTSTART,LT=MLOCTR40 DSECT, START, AND COM
         IC    ODD,JTNML                PICK UP NAME LENGTH
         EX    ODD,SYSMOVE              ASSIGN NAME TO SYSECT
MLOCTR40 EQU   *
         DROP  EVEN
MLOCTR60 L     R12,=A(X3B01)            GET PTR TO SYMBOL PROCESSOR
         JEXTRN (X3B01=X3B01)
         BALR  R9,R12                   LINK TO SYMBOL INTER PREPROCESS
         DROP  R11
         SPACE
* PUT OUT ANY ERROR MESSAGES LOGGED AGAINST THE RECORD JUST
*        PROCESSED
         SPACE
ERRDUMP  EQU   *
         LH    R3,ERRCNT                PICK UP ERROR COUNT
         LTR   R3,R3                    SEE IF ANY MESSAGES LOGGED
         BZ    MINPUT                   GO GET NEXT RECORD IF NOT
         L     R2,TXTOUT                GET PTR TO OUTPUT RECORD
         USING JTEXT,R2
         SET   JERR,ON                  INDICATE ERROR FLAG FOR THIS
         DROP  R2
         LCR   R6,R3                    GET NUMBER OF ERRORS - NEG
         AH    R6,=H'5'                 ADD MAX LOGGED ERRORS
         LTR   R6,R6                    SEE IF NUMBER LT OR EQ MAX
         BNM   ERRDUMP1                 BRANCH IF SO
         MVC   ERRCNT,=H'2'             INSURE OK ERROR COUNT
         LA    R12,LOGERR01             GET BASE FOR ERROR LOGGING RTN
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV126,ERR126)       ERROR PARAMETERS
         LA    R3,D6                    SET NUMBER OF ERROR LOGGED
ERRDUMP1 LA    R4,ERRSTK                GET PTR TO START OF ERROR STK
         ST    R4,ESTKNDX               REINPTIALIZE MOVEABLE STK PTR
ERRDUMP2 SR    R5,R5                    CLEAR LENGTH REGISTER
         USING ERRMESS,R4
         JPUTL FILE=FILE2,BUFREQ=D20   GET BUFFER FOR ERROR RECORD
         USING JERRCD,R11
         MVC   JERECL(D9),=AL1(D0,D20,JPSOP,JNOCNT,JTERROR,D0,D0,D0,D0)X
                INSERT RECORD LENGTH, FLAGS, ETC. IN RECORD
         MVC   JESEV(D11),EMSGSVTY      INSERT SEVERITY, ERROR, DATA
         GOIF  ENTRYLNG,D0,EQ=ERRDUMP3  SKIP IF DATA LENGTH OF ZERO
         LA    R5,D8                    ALLOW FOR DATA ITEM
ERRDUMP3 LA    R4,D3(R5,R4)             BUMP TO NEXT ERROR STACK ITEM
         BCT   R3,ERRDUMP2              DECREMENT COUNT, BRANCH NON-0
         STH   R3,ERRCNT                REINITIALIZE ERROR COUNTER
         B     MINPUT                   READ NEXT STATEMENT
         DROP  R4
         DROP  R11
         EJECT
*
* MOVERTN - THIS SUBROUTINE MOVES RECORDS BUFFER-TO-BUFFER.
*           IT ACCOMPLISHES THE FUNCTION OF A JPUTM, WHICH CANT
*           BE USED SINCE A POINTER TO THE OUTPUT RECORD MUST BE
*           GOTTEN AND SAVED.
*
MOVERTN1 MVC   D0(D256,INDEX1),D0(INDEX2) MOVE BLOCK OF 256 BYTES
         LA    INDEX1,D256(,INDEX1)     ADJUST DESTINATION POINTER
         LA    INDEX2,D256(,INDEX2)     ADJUST SOURCE POINTER
MOVERTN  SH    RCOMP1,=H'256'            SEE IF ONE MOVE WILL DO IT
         BP    MOVERTN1                  BRANCH IF NOT
         AH    RCOMP1,=H'255'            GET MOVE LENGTH REMAINING
         EX    RCOMP1,MOVERTN2           MOVE REMAINING SEGMENT
         BR    RETURN                    RETURN
MOVERTN2 MVC   D0(D0,INDEX1),D0(INDEX2) EXECUTED MOVE, 256 OR LESS
         EJECT
MLKUP    EQU   *                        COMPUTE BRANCH ADDRESS FROM    X
                                        TABLE
*        BRANCH TABLE CONSISTS OF TWO BYTE ADDRESSES TO BE USED AS
*        INDICES FOR BRANCHES TO THE NAMED ROUTINES.  INTERNAL OP CODE
*        FROM TEXT IS MULTIPLIED BY TWO AND USED AS AN INDEX TO THE
*        TABLE.
         SPACE 3
         USING JTEXT,INPTR              BASE FOR INPUT TEXT
         SR    INDEX1,INDEX1            CLEAR A REGISTER
         IC    INDEX1,JTIOP             PICK UP INTERNAL OP CODE
         SLL   INDEX1,TIMES2            MULTIPLY BY 2
         LH    INDEX1,MOPTABLE(INDEX1)  USE IT AS INDEX TO PICK UP     X
                                        BRANCH DISPLACEMENT.
         B     MOPRTNS(INDEX1)          USE DISPLACEMENT AS INDEX
         DROP  INPTR
         EJECT
*TITLE-                                                               *
*   PRINT/PRINT LOGIC SELECTOR ROUTINE                                *
*                                                                     *
*FUNTION/OPERATION-                                                   *
*   DETERMINE IF OPTIONS REQUIRE A PRINTABLE RECORD OF A GENERATOR    *
*   LOGICAL STATEMENT TO BE PASSED FOR LISTING PURPOSES, AND PASS THE *
*   RECORD IF SO.                                                     *
*                                                                     *
*   AGO, AIF, MEXIT, ACTR, SETA, SETB, SETC, PROTO, PPARMS,MACRO, MEND*
*   ARE THE OPS HANDLED BY THIS ROUTINE.                              *
*                                                                     *
         SPACE
PRINT10  EQU   *                        ENTRY FOR ALL BUT PROTO        X
                                          MACRO, MEND.
         SPACE
         USING JTEXT,INPTR              INPUT TEXT BASE
         GOIF  CALLING,OFF=PRINT20      PROCEED IF NOT MACRO CALL
PRINT15  GOIF  INMACRO,OFF=PRINT90      PRINT ALL OUTER MACRO CALLS
         GOIF  (JMLOGIC,JCALLS),NONE=MINPUT, PRINT INNER MACRO CALLS   X
               ELSE=PRINT90             ONLY ON USERS OPTION
PRINT20  EQU   *
         GOIF  INMACRO,ON=PRINT30       BRANCH IF EXPANDING A MACRO
         GOIF  JALOGIC,ON=PRINT90,      PRINT IF ALOGIC OPTION IS ON   X
               ELSE=(RETURN)              OTHERWISE RETURN
PRINT25  EQU   *
         GOIF  CALLING,OFF=PRINT90,ELSE=PRINT15 PRINT IF NOT CALL
PRINT30  EQU   *                        ENTRY FOR PROTO, MACRO, MEND
         GOIF  JERR,ON=PRINT90          PRINT ERRONEOUS STATEMENTS
         SPACE
         GOIF  JMLOGIC,OFF=(RETURN)     EXIT IF MLOGIC OPTION IS NOT ON
         SPACE
PRINT90  EQU   *                        ENTRY FOR UNCONDITIONAL PRINT
         SPACE
         LR    FLDLN,RETURN             SAVE THE RETURN REGISTER
         LA    R10,GTFILE               OUTPUT TO GENERATED TEXT FILE
         LH    R11,JTRLI                PICK UP LENGTH OF INPUT RCD
         JPUTL FILE=(R10),BUFREQ=(R11)  GET OUTPUT BUFFER SPACE
         ST    R11,TXTOUT               SAVE PTR TO OUTPUT RECORD
         LH    RCOMP1,JTRLI             GET RCD LENGTH FOR MOVE
         LR    INDEX2,INPTR             SET UP SOURCE POINTER
         LR    INDEX1,FTXTOUT           SET UP DESTINATION PTR
         BAL   RETURN,MOVERTN           GO TO MOVE RCD BUF-TO-BUF
         BR    FLDLN                    RETURN VIA DUMMY RETURN
         DROP  INPTR
         EJECT
*
*        MOPTABLE
*
*        THIS IS A BRANCH TABLE TO THE ROUTINES TO HANDLE GENERATOR
*        OP CODES.  EACH ENTRY IS A TWO BYTE INDEX TO THE ROUTINES
*        RELATIVE TO MOPRTNS, AND IS USED IN AN INDEXED BRANCH TO THAT
*        ROUTINE AFTER THE TABLE ENTRY IS SELECTED BY A COMPUTATION ON
*        THE INTERNAL OP CODE.
*
         SPACE 3
         ORG   *-2*LOGENOP              SET TABLE START
MOPTABLE EQU   *                        GIVE IT A NAME
         ORG   ,                        AND RESET LOCATION COUNTER
         GENOPS MACRO,MACRO             MACRO HEADER
         GENOPS ACTR .                  ACTR
         GENOPS AGO,MBRANCH1 .          AGO
         GENOPS AIF                     AIF
         GENOPS SETA .                  SETA
         GENOPS SETB .                  SETB
         GENOPS SETC .                  SETC
         GENOPS MEXIT,MEND1 .           MEXIT
         GENOPS MEND,MEND1 .            MEND
         GENOPS CALL                    MACRO CALL
         GENOPS CPKEY                   CALL PARAMETER--KEYWORD
         GENOPS CPPOS                   CALL PARAMETER--POSITIONAL
         GENOPS PROTO
         GENOPS PPKEY                   PROTOTYPE PARM--KEYWORD
         GENOPS PPPOS                   PROTOTYPE PARM--POSITIONAL
         GENOPS PEND                    PARAMETER LIST END--ALL
         ORG   ,                             END OF TABLE
         EJECT
*TITLE-                                                               *
*        MOPRTNS/GENERATOR OPCODE ROUTINE BASE                        *
*                                                                     *
*FUNCTION/OPERATION-                                                  *
*        PROVIDE BASE FOR ALL GENERATOR OPCODE HANDLING ROUTINES.     *
*   THIS VALUE IS USED FOR COMPUTING INDEX FOR TABLE LOOKUP BY        *
*   STATEMENT TYPE TO SELECT THE APPROPRIATE ROUTINE.  ALSO INCLUDES  *
*   MERROR, WHICH IS THE EXIT FOR INVALID OPCODE TYPES (PROGRAM LOGIC *
*   ERROR).                                                           *
*                                                                     *
         SPACE 3
MOPRTNS  EQU   *                        BASE ONLY--NOT AN ENTRY POINT
         EJECT
*TITLE--                                                              *
*   MACRO/MACRO STATEMENT UTILITY ROUTINE                             *
*                                                                     *
*FUNCTION/OPERATION--                                                 *
*   A MACRO STATEMENT CAN OCCUR UNEXPECTEDLY, DENOTING THE BEGINNING  *
*   OF TEXT OF A PROGRAMMER MACRO DEFINITION, OR EXPECTED, DENOTING   *
*   THE FIRST TEXT RECORD OF A CALLED MACRO. THIS ROUTINE CONTROLS THE*
*   SWITCHES THAT KEEP THE TWO MODES STRAIGHT.                        *
*                                                                     *
*   IF OPEN CODE, THE ROUTINE TURNS ON SWITCH 'INMACDEF', WHICH STAYS *
*   ON UNTIL A MEND STATEMENT IS FOUND.  WHILE THIS SWITCH IS ON, ALL *
*   RECORDS ARE PASSED THROUGH AS PRINT ONLY, FOR LISTING PURPOSES    *
*   ONLY.                                                             *
*                                                                     *
*   WHEN A MACRO IS CALLED, MCALL TURNS ON SWITCH 'CALLING' INDICATING*
*   THAT A CALL IS IN PROGRESS.  IF THIS SWITCH IS ON, MACRO JUST     *
*   TURNS IT OFF, BYPASSING REFERENCE TO 'INMACDEF' SWITCH.           *
*                                                                     *
*INPUT--NONE                                                          *
*OUTPUT--NONE                                                         *
*ENTRY POINTS--MACRO                                                  *
*EXTERNAL ROUTINES--NONE                                              *
*EXITS--BR RETURN                                                     *
*TABLES/WORK AREAS--                                                  *
*   SWITCHES INMACDEF AND CALLING, LOCATED IN GENCOM.                 *
*                                                                     *
*ATTRIBUTES--REFRESHABLE                                              *
*NOTES--
*   IF NESTED DEFINITIONS ARE EVER ALLOWED, SWITCH 'INMACDEF' WILL BE *
*   REPLACED WITH A COUNTER WHICH WILL BE DECREMENTED BY MEND STATE-  *
*   MENTS.                                                            *
         SPACE
MACRO    EQU   *
         SPACE
         GOIF  CALLING,ON=MACRO20       IF ON, THIS IS PART OF A CALL
         SET   INMACDEF,ON              ELSE IT MUST BE LISTING ONLY
         USING JTEXT,INPTR
         DROP  INPTR
         BAL   RETURN,PRINT90           PRINT A COPY
         B     MINPUT                   GO BACK FOR NEXT STATEMENT
         SPACE 3
MACRO20  EQU   *
         SPACE
         BAL   RETURN,PRINT30           PRINT IF MLOGIC OPTION IS ON
         SET   CALLING,OFF
         B     MINPUT                   GO BACK FOR NEXT STATEMENT
         EJECT
*TITLE--                                                              *
*   MPROTO/MACRO PROTOTYPE HANDLER                                    *
*                                                                     *
*FUNCTION/OPERATION--                                                 *
*   UNDEFINED--MAY BE DICTIONARY                                      *
         SPACE
MPROTO   EQU   *
         BAL   RETURN,PRINT30           PRINT IF MLOGIC OPTION IS ON
         B     MINPUT                   GO BACK FOR NEXT STATEMENT
         EJECT
*TITLE--                                                              *
*   MPARM/MACRO CALL AND PARAMETER ROUTINE                            *
         SPACE
*FUNCTION/OPERATION--                                                 *
*   POINTS REG10 TO THE LENGTH PORTION OF THE OPERAND OF A PARAMETER  *
*   RECORD, AND CALLS THE APPROPRIATE DICTIONARY ROUTINE TO PLACE THE *
*   PARAMETER IN THE PARAMETER TABLE.                                 *
         SPACE
*ENTRY POINTS--                                                       *
*   MCPKEY     CALL KEYWORD PARAMETER                                 *
*   MCPPOS     CALL POSITIONAL PARAMETER                              *
*   MPPKEY     PROTOTYPE KEYWORD PARAMETER                            *
*   MPEND      END OF PARAMETER LIST                                  *
*   MCALL      BEGIN MACRO CALLING SEQUENCE                           *
         SPACE
*INPUT--                                                              *
*   TEXT RECORD POINTED TO BY INPTR                                   *
         SPACE
*OUTPUT--NONE                                                         *
         SPACE
*EXTERNAL ROUTINES--                                                  *
*        MACRKWRD   CALL KEYWORD        DICTIONARY ACCESS INTERFACE   *
*        MACRPOST   CALL POSITIONAL        ''        ''      ''       *
*        PROTOKWD   PROTOTYPE KEYWORD      ''        ''      ''       *
*        MACRCALL   INITIATE CALL          ''         ''       ''     *
*        CALLEND    CALL END               ''         ''       ''     *
*        PROTOEND   PROTOTYPE END          ''         ''       ''     *
         SPACE
*EXITS--                                                              *
*   NORMAL--BRANCH TO MINPUT                                          *
         SPACE
*TABLES/WORK AREAS--N/A                                               *
         SPACE 3
MPPKEY   LA    RMOVE,PROTOKWD           PROTOTYPE KEYWORD
         B     MPARM                    GO TO PIVOT
MCPKEY   LA    RMOVE,MACRKWRD           CALL KEYWORD
         B     MPARM                      AND TAKE PIVOT
MCPPOS   LA    RMOVE,MACRPOST           CALL POSITIONAL
MPARM    EQU   *                        COMMON PARAMETER PIVOT
         USING JTEXT,INPTR              TEXT BASE
         GOIF  NOCALL,ON=MINPUT         ABORTED CALL, DON'T PROCESS.
         LR    METAPTR,INPTR            PICK UP TEXT BASE AND
         AH    METAPTR,JTOPP            DEVELOP OPERAND POINTER AND
         USING JTMFLG,METAPTR             DECLARE AS META TEXT BASE.
         LR    R10,METAPTR              TEMPORARY
         SH    R10,=H'5'                BACK UP TO HDR DATA START
         ST    R10,GENRTRN              PRESERVE PTR TO HDR FLAGS
         USING PFLAG,R10
         SPACE
         GOIF  JTCPKEY,EQ=MPARM9        CALL KEYWORD, BRANCH
         GOIF  JTPPKEY,NE=MPARM10       NOT PROTOTYPE KEYWORD, BRANCH
         SPACE
*        KEYWORD PROCESSING--SKIP KEYWORD ON FIRST SUBELEMENT ONLY
         SPACE
MPARM9   EQU   *                        KEYWORD HANDLING
         GOIF  (PSUB,PSUBF),MIX=MPARM10                                X
               BRANCH IF NOT A SUBLIST OR IF NOT FIRST SUB-OPERAND
         SR    R1,R1                    ZERO LENGTH REGISTER
         IC    R1,JTMLNG                PICK UP KEYWORD LENGTH
         LA    METAPTR,JTMSTRNG(R1)     AND BUMP STRING POINTER OVER   X
                                          FLAG, LENGTH, AND KEYWORD.
MPARM10  EQU   *                        METAPTR NOW POINTS TO FIRST FLAG
                                          IN META TEXT DESCRIBING      X
                                          THE PARAMETER.
         GOIF  JSUBOPND,ON=MPARM11      SKIP AHEAD IF WE HAVE SUBSTITU-
         LA    METAPTR,JTMLNG             TION, ELSE JUST POINT TO
         LR    R11,METAPTR
         B     MPARM30                    LENGTH AND PUT IN DICTIONARY.
         DROP  METAPTR
         SPACE
MPARM11  EQU   *                        PARAMETER IS TO BE DEVELOPED   X
                                          FROM META TEXT.
         SPACE
         GOIF  PPASS,OFF=MPARM20        NOT PASSED PARM, SUBSTITUTE
         SPACE
MPARM12  BAL   RETURN,EVALINIT          EVALUATE THE PARM REFERENCE
*        REFERENCE IS NOW AT BOTTOM OF EVAL STACK.
         LA    R10,STACK                POINT TO TERM IN STACK
         SET   CHARMODE,ON              INDICATE CHAR STRINGS WANTED
         JCALL RESOLVE                  AND RESOLVE IT.
         SET   CHARMODE,OFF             CLEAN UP CHAR STRING FLAG
*        NOW R14 POINTS TO REFERENCED PARAMETER, R11 POINTS TO STRING.
         USING PFLAG,R14                TEMPORARY BASE FOR PARM ENTRY
         GOIF  PSUB,OFF=MPARM15         BRANCH IF PARAM NOT SUBLIST
         L     R10,GENRTRN              RESTORE PTR TO HDR FLAGS
         TM    D0(R10),BIT0             SEE IF SUBLIST A SUBOPERAND
         BO    MPARM20                  MAKE STRING OF IT IF SO
         DROP  R14
MPARM15  EQU   *
         LR    R11,R14                  ELSE PUT PARM POINTER IN R11
         SET   PASSPARM,ON              INDICATE PARM PASSED AS PRM
*        DICTIONARY ENTRY
MPARM30  L     R12,DICTBASE             DICTIONARY BASE
         LR    R10,INPTR                TEXT BASE FOR DICTIONARY ENTRY
         STC   RMOVE,NDXVAL             SET UP PROPER ENTRY INDEX
         BALR  R9,R12                   LINK TO DICTIONARY ROUTINE
         B     ERRDUMP                  RETURN FOR NEXT RECORD
         SPACE
MPARM20  LA    VTXTOUT,STRING1          POINT TO A BUFFER
         LA    RCOMP1,STACK-STKENTRY    INITIALIZE
         ST    RCOMP1,STACKLVL            EVAL STACK.
         MVI   STRING1,D0               SET TO NULL STRING
         JCALL GENSTRNG                 AND GENERATE THE STRING.
         LR    R11,VTXTOUT              STRING POINTER FOR DICTIONARY
         B     MPARM30                  GO ENTER IN THE DICTIONARY
         SPACE
MPEND    EQU   *
         GOIF  JERR,OFF=MPEND05         BRANCH IF NO PARAM ERRORS
         L     R1,TXTOUT                GET PTR TO PROTOTYPE OR CALL
         USING MTEXT,R1
         SET   MERR,ON                  TRANSFER ERROR FLAG TO TEXT
         DROP  R1
         L     R1,ACTRCNT               PICK UP CURRENT ACTR VALUE
         SRL   R1,D1                    HALVE IT ON EDITOR ERROR
         ST    R1,ACTRCNT               SAVE NEW ACTR VALUE
MPEND05  EQU   *
         SPACE
         GOIF  NOCALL,OFF=MPEND10       NOT ABORTED CALL, PROCEED.
         SET   NOCALL,OFF               ELSE TURN OFF SWITCH,
         B     ERRDUMP                  AND EXIT
MPEND10  GOIF  CALLING,ON=MCALLEND      BRANCH IF MACRO CALL SEQUENCE
         DICTCALL PROTOEND                ELSE ASSUME PROTOTYPE END
         SPACE
         B     ERRDUMP                  RETURN FOR NEXT RECORD
         SPACE
MCALLEND EQU   *
         JGETL FILE=FILE1               FETCH NEXT TEXT RECORD
         USING JTEXT,R11
         GOIF  JTERROR,NE=MPEND15       PROCEED IF NOT ERROR RECORD
         JPUTM FILE=FILE2,ADDR=(R11)    FLUSH PAST ERROR RECORD(S)
         B     MCALLEND                 GO BACK FOR NEXT TEXT RECORD
         DROP  R11
MPEND15  EQU   *
         SPACE
         SET   INMACRO,ON               INDICATE WE ARE NOW IN A MACRO
         DICTCALL CALLEND
         B     MINPUT                   RETURN FOR NEXT RECORD
         SPACE 3
MCALL    EQU   *                        MACRO CALL
         GOIF  (CALLING,NOCALL),ANY=MFEVAL RE-DIRECT CALL CONTINUATIONS
         SET   NOCALL,ON                ASSUME BAD INITIALLY
         SPACE
         LA    R11,MACRCALL             SET ENTRY DISPLACEMENT
         LH    VTXTIN,JTOCP             GET OP CODE DISPLACEMENT
         AR    VTXTIN,INPTR             GET OP CODE POINTER
         BAL   RETURN,METAINIT          INITIALIZE META TEXT POINTER
         LR    R10,VTXTIN               SET UP FOR DICT ROUTINE
         SPACE
         DICTCALL MACRCALL
         SPACE
*        ON RETURN, R11 CONTAINS--
*              0    OK                                                *
*              4    MACRO NOT FOUND                    ERROR
*              8    INVALID PROTOTYPE                  ERROR          *
*              12   NO MACRO STATEMENT                 ERROR          *
*              16   BOOKNAME DOES NOT MATCH PROTOTYPE  ERROR          *
         SPACE
*        SO WE'LL DO AN INDEXED BRANCH
         B     CALLTABL(R11)            DO INDEXED BRANCH
         SPACE
CALLTABL EQU   *                        BRANCH TABLE ORIGIN
         SPACE
         B     MCALL10                  WE MADE IT OK.
         B     LOGERR78                 THAT'S
         B     LOGERR87                   NOT
         B     LOGERR85                    A
         B     LOGERR88                    MACRO.
         B     LOGER100                 NO DICTIONARY
         SPACE
MCALL10  SET   (CALLING,NOCALL),FLIP    CALLING ON, NOCALL OFF
         L     R1,MACROLVL              INCREMENT
         LA    R1,D1(,R1)                    MACRO NEST DEPTH
         ST    R1,MACROLVL                        BY ONE
         L     RCOMP1,SYSNDX           PICK UP CURRENT SYSNDX
         LA    RCOMP1,D1(,RCOMP1)       INCREMENT IT BY 1 FOR CALL
         ST    RCOMP1,SYSNDX            PUT IT BACK, UPDATED
         B     MFEVAL                   LET FEVAL GENERATE IMAGES
         SPACE 10
* DUMMY ROUTINE TO HANDLE PROTOTYPE PARAMETERS, POSITIONAL -
* SIMPLE RETURN FOR NEXT RECORD
MPPPOS   B     MINPUT                   RETURN FOR NEXT RECORD
         SPACE
         EJECT
LOGERR78 LA    R12,LOGERR01             GET BASE FOR ERROR LOGGING RTN
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV78,ERR78)         ERROR PARAMETERS
LOGCOMN  EQU   *
         BAL   RETURN,PRINT90           PUT OUT COPY OF BOGUS MACRO
         B     ERRDUMP                  GO TERMINATE STATEMENT
LOGERR85 LA    R12,LOGERR01             GET BASE FOR ERROR LOGGING RTN
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV85,ERR85)         ERROR PARAMETERS
         B     LOGCOMN                  GO MAKE REAL ERROR ENTRY
LOGERR87 LA    R12,LOGERR01             GET BASE FOR ERROR LOGGING RTN
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV87,ERR87)         ERROR PARAMETERS
         B     LOGCOMN                  GO MAKE REAL ERROR ENTRY
LOGERR88 LA    R12,LOGERR01             GET BASE FOR ERROR LOGGING RTN
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV88,ERR88)         ERROR PARAMETERS
         B     LOGCOMN                  GO MAKE REAL ERROR ENTRY
LOGERR90 LA    R12,LOGERR01             GET BASE FOR ERROR LOGGING RTN
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV90,ERR90)         ERROR PARAMETERS
         B     ERRDUMP                  GO TERMINATE STATEMENT
LOGER100 LA    R12,LOGERR01             GET BASE FOR ERROR LOGGING RTN
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV100,ERR100)       ERROR PARAMETERS
         B     LOGCOMN                  GO MAKE REAL ERROR ENTRY
LOGER118 LA    R12,LOGERR01             GET BASE FOR ERROR LOGGING RTN
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV118,ERR118)       ERROR PARAMETERS
         B     MEND11                   PROCEED ON ACTR OVERRUN
         EJECT
*TITLE-                                                               *
*        MBRANCH/GENERATOR TEXT BRANCH ROUTINE                        *
*                                                                     *
*FUNCTION/OPERATION-                                                  *
*        HANDLES CONDITIONAL ASSEMBLY BRANCHING.  FOR AIF STATEMENTS, *
*    CALLS BEVAL TO DETERMINE IF BRANCH IS TO BE TAKEN.  FOR AGO      *
*    STATEMENTS, AND AIF STATEMENTS IF CONDITION IS YES, CALLS MPOINTR*
*    TO EFFECT THE BRANCH.                                            *
*                                                                     *
         SPACE 3
MBRANCH1 EQU   *                        AGO ENTRY POINT
         SPACE
         BAL   RETURN,PRINT10           PRINT IF OPTIONS ARE ON
         USING JTEXT,INPTR              BASE FOR TEXT
         LH    VTXTIN,JTOPP             GET OPERAND POINYER
         AR    VTXTIN,INPTR             MAKE ABSOLUTE
         BAL   RETURN,METAINIT          GET PTP TO META TEXT START
         SPACE
MBRANCH2 EQU   *
         SPACE
         L     RCOMP1,ACTRCNT           PICK UP ACTR COUNT
         GOIF  (RCOMP1),NOTPOS=LOGER118 ACTR RAN OUT, LOG THE MESSAGE
         BCTR  RCOMP1,D0                ELSE DECREMENT ACTR
         ST    RCOMP1,ACTRCNT           AND REPLACE
         LR    R10,VTXTIN               SET UP META TEXT PTR FOR DICT
         SPACE
         DICTCALL SEQSYMBR              BRANCH TO THE SEQUENCE SYMBOL
         SPACE
         SPACE
         BNZ   ERRDUMP                  GO GET NEXT RCD IF ALL OK
         B     LOGERR90                 GO DIAGNOSE SITUATION
         DROP  INPTR
         EJECT
*TITLE-                                                               *
*        MEND/GENERATOR MEND MEXIT END ROUTINE                        *
*                                                                     *
*FUNCTION/OPERATION-                                                  *
*        HANDLES END OF FILE PROCESSING FOR EACH TEXT SEGMENT.  RE-   *
*    CEIVES CONTROL EITHER UPON ENCOUNTERING AN END, MEND, OR MEXIT   *
*    STATEMENT IN THE TEXT STREAM.  END CAUSES TERMINATION OF PHASE.  *
*    MEND OR MEXIT CAUSE TERMINATION OF THE CURRENT MACRO, CALLS FOR  *
*    RESETTING TEXT TO POINT AT WHICH THE MACRO WAS CALLED, AND RE-   *
*    SETS DICTIONARY POINTERS TO THE LOCAL DICTIONARY OF THE CALLING  *
*    TEXT SEGMENT.                                                    *
*                                                                     *
*ENTRY POINTS-                                                        *
*        MEND1--MEND/MEXIT PROCESSING                                 *
*        MEND2--END PROCESSING                                        *
*                                                                     *
         SPACE 3
MEND1    EQU   *
         SPACE
         BAL   RETURN,PRINT30           PRINT IF OPTIONS ARE ON
MEND11   EQU   *
         L     RCOMP1,MACROLVL          PICK UP CURRENT MACRO NEST LVL
         GOIF  (RCOMP1),POS=MEND12      CHEK IF ACTR OVFLO IN OPEN CD
         SET   FLUSH3,ON                GENERATE END CARD
         B     ERRDUMP                  GO TO DIAGNOSE AND EXIT
MEND12   EQU   *
         BCT   RCOMP1,MEND1A            ADJUST BY ONE. IF ZERO,
         SET   INMACRO,OFF                THEN TURN OFF SWITCH INMACRO.
MEND1A   ST    RCOMP1,MACROLVL          IN EITHER CASE, SAVE THE COUNT.
         DICTCALL MACRFINI              POP THE DICTIONARY LEVEL ALSO
         B     ERRDUMP                  RETURN TO GET NEXT RECORD
         SPACE 3
         EJECT
*TITLE-                                                               *
*   MSET/MACRO GENERATOR SET STATEMENT PROCESSOR                      *
         SPACE
*FUNCTION/OPERATION-                                                  *
*   CALLS EVAL TO CONVERT OPERAND META TEXT TO CHARACTER OR ARITHMETIC*
*   FORM, THEN PASSES VALUE THROUGH DICTIONARY LINKAGE FOR ENTRY.    *
         SPACE
MSETA    EQU   *                        SETA ENTRY
MSETB    EQU   *                        SETB ENTRY
MSETC    EQU   *                        SETC ENTRY
MAIF     EQU   *                        AIF ENTRY
MACTR    EQU   *                        ACTR ENTRY
         SPACE
*                                       MERCY--THEY'RE ALL THE SAME.
         SPACE
         BAL   RETURN,PRINT10           PRINT IF OPTIONS ARE ON
         USING JTEXT,FTXTIN             FIXED INPUT BASE
         LH    VTXTIN,JTOPP               OPERAND DISPLACEMENT
         AR    VTXTIN,FTXTIN              MAKE ABSOLUTE
         LA    VTXTOUT,STRING1          OUTPUT POINTER--A BUFFER
         SPACE
         BAL   RETURN,METAINIT          GO INITIALIZE META TEXT
         BAL   RETURN,EVALINIT          GO INITIALIZE EVAL STACKS
         SPACE
         GOIF  JTSETB,GT=MSETC10        IF SETC, GO DO IT
         SPACE
         LR    VTXTIN,R10               RESTORE THE REAL TEXT POINTER
*        LAST ELEMENT IN STACK MAY NOT BE SELF DEFINING TERM.
         LA    R10,STACK                SO POINT TO IT,
         JCALL RESOLVE                      AND RESOLVE IT.
*        NOW R11 CONTAINS THE VALUE.
         SPACE
         GOIF  JTACTR,EQ=ACTR           IF ACTR, GO DO IT
         GOIF  JTAIFB,LE=AIF,ELSE=MSET20                               X
                                        GO DO AIF, ELSE SKIP TO SETAB
         SPACE
MSETC10  EQU   *                        SETC--CHARACTER STRING
         SPACE
         LA    R11,STRING1              GET POINTER TO STRING
         SPACE
MSET20   EQU   *                        NOW GET READY FOR DICTIONARY DO
         SPACE
SET20    LH    VTXTIN,JTNMP             GET NAME FIELD POINTER
         AR    VTXTIN,FTXTIN            MAKE ABSOLUTE
         DROP  FTXTIN
         ST    R11,STRRTRN              STORE VALUE IN R11
         BAL   RETURN,METAINIT          INITIALIZE NAME FIELD META
         LA    RCOMP1,STACK-STKENTRY    POINT TO START OF EVAL STACK
         ST    RCOMP1,STACKLVL            AND SAVE AS STACK POINTER
         L     R12,=A(EVAL)             GO EVALUATE THE
         BALR  RETURN,R12                 SET TARGET
         L     R11,STRRTRN              RESTORE R11 TO SET VALUE
         LA    R10,STACK                POINT TO TERM--NOW IN STACK
         SPACE
         USING JTMFLG,R10               BASE FOR SET SYMBOL
         GOIF  JTMGBL,ON=SET32          GLOBAL, GO DO GLOBAL SET
         DROP  R10
         SPACE
SET30    DICTCALL LCLDICTS              LOCAL SET
         B     ERRDUMP                  RETURN TO GET NEXT RECORD
         SPACE
SET32    DICTCALL GBLDICTS              GLOBAL SET
         B     ERRDUMP                  RETURN TO GET NEXT RECORD
         SPACE 3
AIF      EQU   *                        AIF ENTRY
         SPACE
         LR    R10,VTXTIN               TEXT POINTER IN R10 AS A PARAM-X
                                          ETER--POINTS TO SEQUENCE SYM.
         GOIF  (R11),ZERO=ERRDUMP,ELSE=MBRANCH2                        X
                                        RETURN IF ZERO ELSE POINT TEXT
         SPACE 3
ACTR     EQU   *
         SPACE
*        NEW ACTR VALUE IS IN REG R11
         SPACE
         ST    R11,ACTRCNT              STORE AS NEW ACTR
         B     ERRDUMP                  RETURN TO GET NEXT RECORD
         EJECT
EVALINIT EQU   *                        INITIALIZE EVAL ROUTINE
         SPACE
         SET   CCOMP,OFF                ASSUME ARITHMETIC COMPARES
         LA    RCOMP1,STACK-STKENTRY    NOTHING IN THE STACK
         ST    RCOMP1,STACKLVL          POINT TO START OF EVAL STACK
         LA    RCOMP1,STRING1           FIRST STRING BUFFER
         ST    RCOMP1,STRPTR1             AND SAVE IT
         MVI   STRING1,D0               NULL STRING
         MVI   STRING2,D0               NULL STRING
         L     R12,=A(EVAL)             POINT TO EVAL ROUTINE
         BR    R12                        AND GO.  RETURN VIA R9.
         EJECT
METAINIT EQU   *                        POINT TO START OF META TEXT
         SPACE
         SH    VTXTIN,=H'2'             GET PTR TO META TEXT LENGTH
         MVC   JHWORD1,D0(VTXTIN)       ALIGN 2-BYTE META TEXT LENGTH
        SH    VTXTIN,JHWORD1            DEVELOP PTR TO META TEXT START
         BR    RETURN                   RETURN TO CALLER
         EJECT
         DS    0H
MOVEFLD  EQU   *
         SPACE
         USING JTEXT,FTXTIN
         USING MTEXT,FTXTOUT
         USING MTOCO,VTXTOUT            VARIABLE TEXT OUTPUT
         USING JTOCO,VTXTIN               AND INPUT BASES.
         SPACE
         AR    VTXTIN,FTXTIN            VTXTIN CONTAINS DISPLACEMENT-- X
                                          ADD TEXT POINTER TO GET FIELDX
                                          POINTER FOR INPUT.
         LR    R0,VTXTIN                SAVE INPUT POINTER
         AR    VTXTOUT,FTXTOUT          ADD RECORD BASE FOR OUTPUT
         SPACE
MOVFLD5  GOIF  JTOCOCD,OFF=MOVFLD10     NO CARD POINTER, SKIP.
         MVC   MTOCO,JTOCO                ELSE MOVE IT
         LA    VTXTIN,JTOCL               AND ADJUST INPUT POINTER
         LA    VTXTOUT,MTOCL              AND OUTPUT POINTER.
         SPACE
MOVFLD10 EQU   *                        MOVE THE COLUMN POINTER
         SPACE
         MVC   MTOCO,JTOCO              MOVE 1 BYTE
         LA    VTXTIN,JTOCL             ADJUST INPUT
         LA    VTXTOUT,MTOCL              AND OUTPUT POINTERS
         ST    VTXTOUT,GENRTRN          SAVE POINTER TO LENGTH.
         SPACE
         USING JTOCL,VTXTIN             NEW BASE IN
         USING MTOCL,VTXTOUT            NEW BASE OUT
         SPACE
         MVI   MTOCL,D0                 INITIALLY A ZERO LENGTH STRING
         SPM   RETURN                   RECOVER ENTRY CONDITION CODE
         BO    GENFLD                     GO TO GENFLD IF SUBSTITUTION
         SPACE
         IC    RMOVE,JTOCL              PICK UP LENGTH
MOVFLD20 EX    RMOVE,MVCFLD10             AND EXECUTE FIELD MOVE OF    X
                                          FIELD PLUS LENGTH.
         LA    VTXTOUT,D1(RMOVE,VTXTOUT)     ADJUST OUTPUT POINTER
         SR    VTXTOUT,FTXTOUT            AND REDUCE TO DISPLACEMENT.
         BR    RETURN                   RETURN TO CALLER
         SPACE
MVCFLD10 MVC   MTOCL(D0),JTOCL          REMOTE FIELD MOVE
         SPACE
         DROP  VTXTIN,VTXTOUT,FTXTIN,FTXTOUT
         EJECT
*TITLE--
*   GENFLD/GENERATE A FIELD
         SPACE
         DS    0H
GENFLD   EQU   *
         SPACE
*        ON ENTRY, VTXTIN POINTS TO REAL START OF VIRTUAL TEXT
         SPACE
         LR    VTXTIN,R0                RECOVER INPUT POINTER
         LR    FLDLN,RETURN             SAVE THE RETURN ADDRESS
         BAL   RETURN,METAINIT          GET PTR TO META TEXT START
         SPACE
*        NOW VTXTIN POINTS TO START OF META TEXT.
         SPACE
         ST    FTXTOUT,OUTPTR           SAVE THE REAL OUTPUT POINTER
         LA    RCOMP1,STACK-STKENTRY    START OF STACK BECOMES
         ST    RCOMP1,STACKLVL            INTIAL STACK POINTER
         JCALL GENSTRNG                 GENERATE A CHARACTER STRING
         SPACE
GENFLD90 EQU   *                        GENFLD EXIT ROUTINE
         SPACE
         LR    VTXTOUT,R10              PICK UP NEW FIELD POINTER
         L     FTXTOUT,OUTPTR           RESTORE THE OUTPUT POINTER
         SR    VTXTOUT,FTXTOUT          REDUCE OUTPUT POINTER TO       X
                                        DISPLACEMENT.
         BR    FLDLN                    RETURN ON THE SAVED RETURN REG
         EJECT
*        CONSTANTS FOR X3A
         SPACE
DICTBASE DC    A(DICTENTR)              DICTIONARY INTERFACE BASE
DUMYEND  DC    AL2(24),AL1(JPSOP+JDEF+JREF,0,JTEND,0),AL2(17,19,17,17,1X
               7),AL1(0),AL2(0),AL1(10,3,JE,JN,JD)
         JEXTRN (X3N01=DICTENTR)          DECLARE IT EXTERNAL
CHKSYMLN DC    Y(MAXSYM)                HALFWORD CONSTANT TO CHECK SYM-X
                                          BOL LENGTH OVERFLOW
HHDRLN   DC    Y(JTHDRLN)               TEXT RECORD HEADER LENGTH
         SPACE
         DS    0H
         SPACE 3
* LOGERR - THIS SUBROUTINE MAKES AN ENTRY FOR A SINGLE ERROR IN THE
*          ERROR STACK AND INCREMENTS THE ERROR COUNT BY 1.
*
LOGERR01 EQU   *
         JENTRY (X3A02=LOGERR01)
         USING LOGERR01,R12
         STM   R14,R15,GENREGS          SAVE WORK REGISTERS
         CLI   D0(R9),D4                LOOK FOR SEVERITY 4 MESSAGE
         BNH   LOGERR03                 BRANCH IF NOT GT 4
         L     R14,ACTRCNT              PICK UP CURRENT ACTR VALUE
         SRL   R14,D1                   HALVE IT ON GENERATE ERROR
         ST    R14,ACTRCNT              SAVE NEW ACTR VALUE
LOGERR03 CLC   JMSGL,D0(R9)             SEE IF MESSAGE SHOULD BE PUT
         BH    LOGERR02                 RETURN IF NOT
         CLC   D0(D1,R9),JSEVER         IS THIS HIGHER
         BNH   LOGERR04                 BRANCH IF NOT
         MVC   JSEVER(D1),D0(R9)        ENTER HIGH
LOGERR04 LH    R14,ERRCNT               PICK UP CURRENT ERROR COUNT
         LA    R14,D1(,R14)             ADJUST FOR ERROR JUST ADDED
         STH   R14,ERRCNT               SAVE NEW ERROR COUNT
         L     R15,ESTKNDX               GET PTR TO NEXT ERROR SLOT
         MVC   D0(D2,R15),D0(R9)         INSERT SEV CODE ERR NUMBER
         MVI   D2(R15),J0                INSERT DATA LENGTH
         CH    R14,=H'6'                 SEE IF 7TH OR MORE MESSAGE
         BNL   LOGERR02                 BRANCH IF SO
         LA    R15,D3(,R15)             ADJUST STACK PTR FOR NEW ENTRY
         ST    R15,ESTKNDX              SAVE FOR NEXT ERROR ENTRY
LOGERR02 EQU   *
         LM    R14,R15,GENREGS          RESTORE SAVED REGIS0ERS
         B     D2(,R9)                  RETURN TO CALLING RTN
         DROP  R12
         SPACE 3
         JPATCH  X3A00,E44              PATCH AREA
         EJECT
         JCSECT (X3A03)
         SPACE
*TITLE--                                                              *
*                                                                     *
*   RESOLVE/RESOLVE TERMS ROUTINE                                     *
*                                                                     *
*FUNCTION/OPERATION--                                                 *
*                                                                     *
*   PROCESSES ALL TERMS, LOOKING UP THOSE THAT ARE VARIABLE.  ON ENTRY*
*   R10 POINTS TO TERM.  ON OUTPUT, R11 CONTAINS VALUE OF THE TERM IF *
*   ARITHMETIC MODE, OR A POINTER TO L FIELD OF STRING IF CHARACTER.  *
*                                                                     *
         SPACE
RESOLVE  EQU   *
         SPACE
RESOLV00 STM   R2,R9,RESOLVST           SAVE CALLERS REGISTERS
         LR    R8,R12                   ESTABLISH BASE FOR RTN
         USING RESOLV00,R8
         SPACE
         USING JTMFLG,R10               DUMMY BASE
         SET   CTYPE,OFF                INITIALLY ASSUME ARITHMETIC IN
         GOIF  JTMGBL,ON=RESOLV08       IF GLOBAL, GO SET SWITCH,
         SET   GLOBAL,OFF               ELSE MAKE SURE IT IS OFF
         B     RESOLV09                 AND CONTINUE AT COMMON POINT
RESOLV08 SET   GLOBAL,ON                MUST DO GLOBAL LOOKUP
RESOLV09 SET   JTMCSW,OFF               MAKE SURE FLAG IS CLEAN
         SPACE
         GOIF  JTMSDT,EQ=RESOLV30       SELF DEFINING TERM
         GOIF  JTMSVC,EQ=RESOLV10,LT=RESOLV12     SET SYMBOL
         GOIF  JTMOSA,LT=RESOLV10,      GLOBAL SETC                    X
               EQ=RESOLV80,             ORDINARY SYMBOL                X
               ELSE=RESOLV70            PARAMETER OR SYSLIST
         DROP  R10
         SPACE
RESOLV10 EQU   *                        SET SYMBOL--SETC
         SET   CTYPE,ON                 INDICATE CHARACTER TYPE
RESOLV12 EQU   *                        SETA, SETB ENTRY
         GOIF  GLOBAL,OFF=RESOLV14      NOT GLOBAL, DO LOCAL LOOKUP
RESOLV13 DICTCALL GBLDICTR,POINTER==A(DICTENTR)   GLOBAL REFERENCE
         B     RESOLV15                 GO TO EXIT SEQUENCE
RESOLV14 DICTCALL LCLDICTR,POINTER==A(DICTENTR)   LOCAL REFERENCE
RESOLV15 GOIF  CTYPE,OFF=RESOLV17       NOT CHARACTER TYPE IN, BRANCH
RESOLV16 GOIF  CHARMODE,ON=RESOLV90,    CHARACTER IN, SAME OUT, EXIT   X
               ELSE=ARTHCONV              ELSE CONVERT TO ARITHMETIC
RESOLV17 GOIF  CHARMODE,OFF=RESOLV90,   ARITH IN, ARITH OUT, EXIT      X
               ELSE=CHARCONV              ELSE CONVERT TO CHARACTER
         SPACE 3
RESOLV30 EQU   *                        SELF DEFINING TERM
         SPACE
         USING STACK,R10                BASE FOR TERM
         L     R11,STACKVAL             PICK UP VALUE
         DROP  R10
         B     RESOLV90                   AND RETURN
         SPACE 3
         SPACE
RESOLV70 EQU   *                        SYSLIST OR PARAMETER
         SPACE
         DICTCALL PARMTBLR,POINTER==A(DICTENTR)  DICTIONARY CALL
*        R11 NOW POINTS TO PARAMETER ENTRY HEADER.
         SPACE
         LR    R14,R11                  SAVE PARAMETER POINTER
         USING PARMTAB,R14              BASE FOR PARAMETER
         GOIF  PSUB,ON=RESOLV71         SUBLIST, SKIP AHEAD
         LA    R11,PKAT                 ELSE POINT TO CHARACTER STRING
         SET   SUBLIST,OFF              TURN SUBLIST FLAG OFF
         B     RESOLV72                 LENGTH AND EXIT.
RESOLV71 MVC   JHWORD1,PNAT             SUBLIST, ALIGN N ATTRIBUTE
         SET   SUBLIST,ON               AND TURN ON SUBLIST FLAG
         XC    JFWORD1,JFWORD1          CLEAR HOLDING AREA
         MVC   JFWORD1+D1(D3),PLIST     ALIGN SUBLIST VECTOR POINTER.
         SPACE
RESOLV72 EQU   *                       GET PARAMETER BINARY VALUE.
         SPACE
         GOIF  CHARMODE,YES=RESOLV90    CHARACTERS, RETURN.
         GOIF  PSUB,ON=LOGER113         ILLEGAL SUBLIST REFERENCE
         GOIF  PSDT,OFF=ARTHCONV        NOT SDT, GO CONVERT TO BINARY
         MVC   JFWORD1,PVAL             ALIGN THE VALUE
         DROP  R14
         L     R11,JFWORD1              AND PICK IT UP.
         B     RESOLV90                 EXIT.
         SPACE 3
RESOLV80 EQU   *                        ORDINARY SYMBOL REFERENCE
         SPACE
         DICTCALL ORDSYMBR,POINTER==A(DICTENTR) ORDINARY SYMBOL REF
         LR    R14,R11                  SAVE THE POINTER.
         B     RESOLV90                   AND RETURN.
         SPACE 3
LOGER113 L     R12,=A(LOGERR01)         GET PTR TO ERROR LOGGING RTN
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV113,ERR113)       ERROR PARAMETERS
         SET   SUBLIST,OFF              CLEAN UP SUBLIST SWITCH
         SR    R11,R11                  SET UP DEFAULT VALUE TO RETURN
         B     RESOLV99                 PROCEED AS NORMAL
LOGER107 L     R12,=A(LOGERR01)         GET PTR TO ERROR LOGGING RTN
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV107,ERR107)       ERROR PARAMETERS
         B     RESOLV98                 CONTINUE AT COMMON POINT
LOGER108 L     R12,=A(LOGERR01)         GET PTR TO ERROR LOGGING RTN
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV108,ERR108)       ERROR PARAMETERS
         B     RESOLV98                 CONTINUE AT COMMON POINT
LOGER109 L     R12,=A(LOGERR01)         GET PTR TO ERROR LOGGING RTN
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV109,ERR109)       ERROR PARAMETERS
         B     RESOLV98                 CONTINUE AT COMMON POINT
LOGER127 L     R12,=A(LOGERR01)         GET PTR TO ERROR LOGGING RTN
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV127,ERR127)       ERROR PARAMETERS
RESOLV98 EQU   *
         SR    R11,R11                  SET UP DEFAULT VALUE TO RETURN
RESOLV90 EQU   *                        EXIT FROM ROUTINE
         SPACE
RESOLV99 LM    R2,R9,RESOLVST           RESTORE CALLERS REGISTERS
         BR    R9                       RETURN TO CALLER
         EJECT
*TITLE--                                                              *
*   ARTHCONV/CONVERT CHARACTER STRING TO ARITHMETIC VALUE             *
*                                                                     *
         SPACE
*        ON ENTRY R11 POINTS TO L FIELD OF CHARACTER STRING
         SPACE
ARTHCONV EQU   *
         SPACE
         USING JTMLNG,R11               BASE
         GOIF  JTMLNG,MAXDEC,GT=LOGER107 TOO LONG TO CONVERT, ERROR
         SR    R1,R1                    CLEAR
         IC    R1,JTMLNG                PICK UP STRING LENGTH
         DROP  R11
         SPACE
*        MAKE SURE WE HAVE ALL NUMERICS
         SPACE
         GOIF  (R1),ZERO=LOGER109       NULL STRING, ERROR
         AR    R1,R11                   POINT PAST END OF STRING
ACONV10  EQU   *
         USING JTMSTRNG,R1              NEW BASE
         GOIF  JTMSTRNG,JNUMMAX,GT=LOGER108 NOT NUMERIC, ERROR
         BCTR  R1,D0                    COUNT BACK DOWN TO START
         GOIF  (R1),(R11),HI=ACONV10    MORE, ITERATE
         SPACE
*        NOW WE CAN CONVERT
         SPACE
         USING JTMLNG,R1
         IC    R11,JTMLNG               PICK UP LENGTH OF CONVERT STRNG
         BCTR  R11,D0                   MAKE LENGTH L-1 FOR EXECUTE
         EX    R11,STRNGTRL             TRANSLATE STRING TO ZONED
         EX    R11,STRNGPCK             PACK ZONED TO PACKED
         EX    R11,STRNGTRL             TRANSLATE ZONED TO STRING
         OI    JDWORD+L'JDWORD-D1,JC    OR IN A PLUS FOR SIGN
         CLC   JDWORD,=PL8'2147483647'  CHECK FOR MAXIMUM ARITH VALUE
         BH    LOGER127                 TOO HIGH, ERROR
         CVB   R11,JDWORD               AND CONVERT TO BINARY
         SPACE
*        R11 CONTAINS RESULTANT VALUE
         SPACE
         B     RESOLV90                 RETURN TO CALLER
STRNGTRL TR    JTMSTRNG(D0),JTRTABLE    EXECUTED STRING TRANSLATE
STRNGPCK PACK  JDWORD,JTMSTRNG          EXECUTED STRING PACK
         DROP  R1
         EJECT
*TITLE                                                                *
*   CHARCONV/CONVERT ARITHMETIC TO CHARACTER STRING                   *
*                                                                     *
         SPACE
*        ON ENTRY R11 CONTAINS VALUE
         SPACE
CHARCONV EQU   *
         SPACE
         CVD   R11,JDWORD               CONVERT TO P&CKED DECIMAL
         UNPK  UNPKBUF,JDWORD             AND UNPACK
         NC    UNPKBUF,ZONEMASK         TRANSLATE TO INTERNAL
         GOIF  INMACRO,OFF=CCONV05      SYSNDX NOT IN OPEN CODE
         USING JTMFLG,R10
         GOIF  JTMSVA,GT=CCONV05        BRANCH IF NOT LOCAL SETA
         LA    R1,UNPKBUF+D12           SET UP PTR TO LEFT OF SYSNDX
         CLC   JTMPTR,=F'0'             SEE BY PTR IF SYSNDX
         BZ    CCONV10                  LEAVE ZEROS IF SYSNDX VALUE
         DROP  R10
CCONV05  EQU   *
         TRT   UNPKBUF,ZONEMASK         FIND FIRST SIGNIFICANT DIGIT
         BNZ   CCONV10                  EXIT POINTING
         LA    R1,UNPKLAST              FAKE ONE IF NONE
         SPACE
CCONV10  EQU   *
         SPACE
*        R1 CONTAINS ADDRESS OF FIRST NON-ZERO CHARACTER
         SPACE
         LA    RCOMP0,UNPKEND           POINT TO ONE PAST END OF STRING
         SR    RCOMP0,R1                  AND COMPUTE STRING LENGTH
         BCTR  R1,D0                    BACK UP TO SPACE BEFORE THE
         LR    R11,R1                     STRING, USE R11 TO POINT TO
         USING JTMLNG,R11                 IT, AND STORE THE STRING
         STC   RCOMP0,JTMLNG              LENGTH IN IT.
         DROP  R11
         SPACE
*        ON RETURN, R11 MUST POINT TO THE LENGTH FIELD OF THE STRING
         SPACE
         B     RESOLV90                 EXIT
         EJECT
*TITLE--                                                              *
*   EVAL/GENERAL EVALUATION OF ALL META TEXT                          *
*                                                                     *
*FUNCTION/OPERATION--                                                 *
*   CONVERTS META TEXT FROM THE EDITOR INTO APPROPRIATE CHARACTER     *
*   STRINGS OR ARITHMETIC VALUES.  META TEXT IS AN ORDERED SEQUENCE   *
*   OF META TERMS AND OPERATORS.  TERMS ARE ENTERED IMMEDIATELY INTO  *
*   A PUSH DOWN STACK.  OPERATORS REMOVE TERMS FROM THE TOP OF THE    *
*   STACK AND RETURN VALUES TO THE STACK.  CHARACTER STRINGS ARE NOT  *
*   KEPT IN THE STACK, BUT ARE BUILT IN BUFFERS OR DIRECTLY IN TEXT.  *
*   THE FINAL RESULT OF EVALUATION IS A SINGLE TERM IN THE STACK,     *
*   WHOSE LOCATION IS KNOWN TO ALL CALLING ROUTINES.                  *
         SPACE 3
EVAL     EQU   *
         SPACE
EVAL00   STM   R2,R9,EVALST             SAVE CALLERS REGISTERS
         LR    R8,R12                   ESTABLISH BASE FOR RTN
         USING EVAL00,R8
         SPACE
         USING JTMOP,VTXTIN
         SPACE
         L     STACKPTR,STACKLVL        GET STACK POINTER
EVAL10   GOIF  JTMHIOP,GT=EVAL80        TERMS GET PROCESSED OVER THERE
         SPACE
*        BRANCH TABLE FOR OPERATORS
         SPACE
         SR    INDEX1,INDEX1            CLEAR A REGISTER
         IC    INDEX1,JTMOP             PICK UP AN OPERATOR
         AR    INDEX1,INDEX1            DOUBLE IT
         LH    INDEX1,OPTAB(INDEX1)     GET BRANCH DISPLACEMENT
         LA    VTXTIN,JTMPTR            BUMP PAST FLAG
         B     EVALOPS(INDEX1)          BRANCH TO OP ROUTINE
         DROP  VTXTIN
         SPACE
OPTAB    DS    0H                       OPERATOR BRANCH TABLE
         SPACE
         OPS   SCM                      START CHARACTER MODE
         OPS   PER                      PERIOD--CONCATENATION OPERATOR
         OPS   PLUS                     UNARY PLUS
         OPS   MIN                      UNARY MINUS
         OPS   MULT                     BINARY MULTIPLY
         OPS   DIV                      BINARY DIVIDE
         OPS   ADD                      BINARY ADD
         OPS   SUB                      BINARY SUBTRACT
         OPS   GT                       GREATER THAN
         OPS   GE                       GREATER/EQUAL
         OPS   LT                       LESS THAN
         OPS   LE                       LESS/EQUAL
         OPS   EQ                       EQUAL
         OPS   NE                       NOT EQUAL
         OPS   NOT                      NOT
         OPS   AND                      AND
         OPS   OR                       OR
         OPS   STR                      SUB STRING OPERATION
         OPS   DUP                      DUPLICATION OPERATION
         OPS   DIM                      DIMENSION
         OPS   DIM2                     SYSLIST(N,M) FIRST DIMENSION
         OPS   DIM3                     SYSLIST(N,M) SECOND DIMENSION
         OPS   STRM                     STATEMENT TERMINATOR
         OPS   TAT                      TYPE ATTRIBUTE
         OPS   LAT                      LENGTH ATTRIBUTE
         OPS   SAT                      SCALE ATTRIBUTE
         OPS   IAT                      INTERGER ATTRIBUTE
         OPS   KAT                      COUNT ATTRIBUTE
         OPS   NAT                      NUMBER ATTRIBUTE
         SPACE
EVALOPS  EQU   *                        ROOT FOR EVALUATION OPERATORS
         EJECT
EVALDIM3 EQU   *                        APPLY SYSLIST(N,M) M TERM
         SPACE
         USING JTMFLG,STACKPTR          BASE FOR TERM IN STACK
         SET   SUBSCR2,ON               INDICATE SECOND SUBSCRIPT
         SPACE
EVALDIM  EQU   *                        DIMENSION OPERATOR
         SPACE
*        DIMENSION IS THE LAST OPERATOR IN EVAL STACK, AND NEEDS TO BE
*        INSERTED INTO THE PRECEEDING ENTRY IF WITHIN RANGE.
         SPACE
         BAL   RETURN,PREFXRES          RESOLVE LAST TERM
*        VALUE IS RETURNED IN EVEN REG.  STACKPTR IS NOT DECREMENTED.
         SH    STACKPTR,=Y(STKENTRY)    SO DECREMENT IT.
         GOIF  (EVEN),NEG=LOGER111      BRANCH IF SUBSCRIPT INVALID
         GOIF  JTMLSTO,EQ=DIM09         ACCEPT ZERO SUBSCRIPT IN BOTH
         CLI   JTMFLG,JTMLSTO+JTMCSW    SYSLIST CASES --
         BNE   DIM10                    SYSLIST(N) AND SYSLIST(N,M)
DIM09    GOIF  SUBSCR2,OFF=DIM11        BUT NOT IN M TERM OF (N,M)
DIM10    EQU   *
         GOIF  (EVEN),POS=DIM11         ACCEPT ONLY POSITIVE OTHERWISE
LOGER111 EQU   *
         L     R12,=A(LOGERR01)         GET PTR TO ERROR LOGGING RTN
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV111,ERR111)       ERROR PARAMETERS
         OI    JTMD,BIT0                INDICATE DEAD TERM
         SR    EVEN,EVEN                MAKE SURE DIMEN IS LOW VALUE
DIM11    EQU   *
         STH   EVEN,JHWORD1             PUT IN STORAGE FOR SS USAGE
         GOIF  JTMCSW,OFF=DIM15         SKIP AHEAD IF NOT CHARACTER
         SET   JTMCSW,OFF               ELSE TURN OFF SWITCH IN TERM
         SET   CHARMODE,ON                AND ON FOR CHARACTER MODE.
DIM15    EQU   *
         GOIF  SUBSCR2,ON=DIM19         BRANCH IF M OF SYSLIST(N,M)
         GOIF  JTMLSTO,EQ=DIM40,        BRANCH IF N OF SYSLIST(N)      X
               GT=DIM20                 OR N OF PARAMETER(N)
         GOIF  JHWORD1,JTMD,LE=DIM20    GO ON WITH VALID DIMENSION
         L     R12,=A(LOGERR01)         GET PTR TO ERROR LOGGING RTN
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV112,ERR112)       ERROR PARAMETERS
         OI    JTMD,BIT0                INDICATE DEAD TERM
         B     DIM22                    CONTINUE WITH MAXIMUM DIMEN
DIM19    SET   SUBSCR2,OFF              CLEAN UP SECOND SUBSCRIPT FLAG
         MVI   JTMFLG,JTMPPAR           CONVERT SYSLIST TO PARAM REFER
DIM20    TM    JTMD,BIT0                SEE IF DEAD TERM FLAG ALREADY
         BO    DIM22                    BRANCH IF ON. OTHERWISE,
         MVC   JTMD,JHWORD1             APPLY THE DIMENSION
DIM22    GOIF  CHARMODE,OFF=EVAL10      EXIT IF NOT CHARACTER MODE
         L     FLDLN,RESRTRN            RESTORE LENGTH COUNTER
         LR    R10,STACKPTR             RESOLVE WANTS POINTER IN R10
         JCALL RESOLVE                  GET A CHARACTER STRING
         DROP  STACKPTR
         L     R8,=A(GENSTRNG)          BASE FOR GENSTRNG ROUTINE
         USING GENSTRNG,R8                DECLARE--
         B     GENSTR1X                 PASS RESULT TO GENSTRNG
         USING EVAL,R8                  RECOVER ROUTINE BASE
DIM40    EQU   *
         USING JTMFLG,STACKPTR
         TM    JTMD,BIT0                SEE IF DEAD TERM FLAG ALREADY
         BO    DIM22                    BRANCH IF ON. OTHERWISE,
         MH    EVEN,=H'3'               CALCULATE SYSLIST VECTOR PTR
         ST    EVEN,JFWORD1             TEMPORARILY SAVE AND
         MVI   JTMFLG,JTMPPAR           CONVERT SYSLIST TO PARAM REFER
         MVC   JTMLSTN,JFWORD1+D1       INSERT INTO PTR FIELD OF TERM
         MVC   JTMLSTM,=H'0'            RESET DIMEN FLAG IN TERM
         B     DIM22                    GO BACK TO RESOLVE TERM
         DROP STACKPTR
EVALDIM2 EQU   *                        APPLY SPECIAL SYSLIST DIMENSION
         SPACE
         USING JTMFLG,STACKPTR          BASE FOR TERM IN STACK
         BAL   RETURN,PREFXRES          RESOLVE THE DIMENSION
         SH    STACKPTR,=Y(STKENTRY)      AND UPDATE THE STACK POINTER
         GOIF  (EVEN),NOTNEG=EDIM2A     OK FOR SYSLIST IF ZERO OR POS
         L     R12,=A(LOGERR01)         GET PTR TO ERROR LOGGING RTN
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV130,ERR130)       ERROR PARAMETERS
         OI    JTMD,BIT0                INDICATE DEAD TERM
         B     EVAL10                   AND CONTINUE
EDIM2A   EQU   *
         MH    EVEN,=H'3'               MAKE INTO A POINTER,
         ST    EVEN,JFWORD1             ALIGN,
         MVC   JTMLSTN,JFWORD1+D1       AND MOVE INTO PTR IN TERM
         B     EVAL10                     AND CONTINUE.
         DROP  STACKPTR
         SPACE 3
EVALSTR  EQU   *
         SPACE
*        LAST TWO STACK ENTRIES REPRESENT VALUES OF EXPRESSION 1 AND 2
*              OF SUBSTRING EXPRESSION.
         SPACE
         BAL   RETURN,INFIXRES          RESOLVE TWO TERMS
*        NOW EXPRESSION 1 VALUE IS IN EVEN REG AND EXPRESSION 2 IN
*              ODD REG.
         SH    STACKPTR,=Y(STKENTRY)    DELETE XTRA TERM FROM STACK
         LA    R15,STRING2               POINT TO 2ND STRING
         GOIF  (R15),NEWSTRNG,LE=STR20  SKIP IF IN BUFFER 2
         LA    R15,STRING1              ELSE RESET TO FIRST STRING
         SPACE
STR20    EQU   *
         SPACE
         USING JTMLNG,R15               BASE FOR STRING
*        COMPUTE LENGTH OF CURRENT STRING--INITIAL STRING LENGTH MINUS
*              PREVIOUS STRING LENGTH.
         SPACE
         SR    RCOMP1,RCOMP1            CLEAR A REGISTER
         IC    RCOMP1,JTMLNG            GET THE CURRENT LENGTH
         SH    RCOMP1,STRNGLN            SUBTRACT PREVIOUS LENGTH
         GOIF  (EVEN),POS=STR21         GO ON IF EXPRESSION 1 OK
         L     R12,=A(LOGERR01)         GET PTR TO ERROR LOGGING RTN
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV115,ERR115)       ERROR PARAMETERS
         SR    RCOMP1,RCOMP1            GIVE NULLSTRING
         B     STR35                    FINISHED
STR21    GOIF  (ODD),NOTNEG=STR22       GO ON IF EXPRESSION 2 OK
         L     R12,=A(LOGERR01)         GET PTR TO ERROR LOGGING RTN
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV116,ERR116)       ERROR PARAMETERS
         SR    RCOMP1,RCOMP1            GIVE NULLSTRING
         B     STR35                    FINISHED
STR22    GOIF  (RCOMP1),(EVEN),NOTLO=STR23 GO ON IF EXPR 1 OK WITH STR
         L     R12,=A(LOGERR01)         GET PTR TO ERROR LOGGING RTN
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV117,ERR117)       ERROR PARAMETERS
         SR    RCOMP1,RCOMP1            GIVE NULLSTRING
         B     STR35                    FINISHED
STR23    EQU   *
         BCTR  EVEN,D0                  REDUCE TO ZERO ORIGIN
         SR    RCOMP1,EVEN              COMPUTE BALANCE OF STRING
         L     VTXTOUT,NEWSTRNG         START OF 'TO' FIELD
         A     EVEN,NEWSTRNG            START OF 'FROM' FIELD
         GOIF  (ODD),(RCOMP1),HIGH=STR30 ERROR IF EXPR 2 HIGH
         LR    RCOMP1,ODD               ELSE MOVE REQUESTED LENGTH
         B     STR32                    GO MOVE STRING
         SPACE
STR30    EQU   *
         SPACE
STR32    EX    RCOMP1,MOVESTR           REMOTE MOVE
STR35    AH    RCOMP1,STRNGLN           ADD LENGTH OF REST OF TOTAL
         USING JTMLNG,R15               BASE FOR TOTAL STRING
         STC   RCOMP1,JTMLNG             STORE NEW LENGTH
         DROP  R15
         B     EVAL10                   ITERATE
MOVESTR  MVC   D0(D0,VTXTOUT),D0(EVEN)  REMOTE MOVE FOR STRING OPERATOR
         SPACE 3
EVALDUP  EQU   *                        DUPLICATION FACTOR
         SPACE
*        DUPLICATION FACTOR IS REPRESENTED BY LAST STACK ENTRY.
         SPACE
         BAL   RETURN,PREFXRES          RESOLVE DUP FACTOR
         SPACE
*        VALUE IS NOW IN EVEN REGISTER.
         SPACE
         SH    STACKPTR,=Y(STKENTRY)    DELETE XTRA TERM FROM STACK
*        COMPUTE LENGTH OF CURRENT STRING AND GET POINTER TO STRING.
         SPACE
         LA    R15,STRING2              POINT TO SECOND STRING
         GOIF  (R15),NEWSTRNG,LE=DUP20  SKIP IF IN BUFFER 2
         LA    R15,STRING1              ELSE POINT TO BUFFER 1
         SPACE
DUP20    EQU   *
         SPACE
         LR    R0,R15                   SAVE STRING BUFFER POINTER
         USING JTMLNG,R15               BASE FOR STRING BUFFER
         SR    RCOMP1,RCOMP1            CLEAR A REGISTER
         IC    RCOMP1,JTMLNG            PICK UP THE STRING LENGTH
         DROP  R15
         SH    RCOMP1,STRNGLN           SUBTRACT PRIOR STRING LENGTH
         LR    R14,RCOMP1               LENGTH OF STRING
         BCTR  R14,R0                   MACHINE LENGTH
         USING STRING1,R15              DUMMY TEMPORARY BASE
         LA    R15,STRING2              COMPUTE A STOPPER
         SR    R15,RCOMP1
         DROP  R15
         L     ODD,NEWSTRNG              START OF 'FROM' FIELD
         LR    VTXTOUT,ODD              START OF 'TO' FIELD
         SPACE
*        START OF STRING IS IN 'ODD' AND LENGTH IS IN 'RCOMP1'
         SPACE
         GOIF  (EVEN),ZERO=DUP90,POS=DUP30 PROCEED IF DUP FACTOR OK
         L     R12,=A(LOGERR01)         GET PTR TO ERROR LOGGING RTN
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV114,ERR114)       ERROR PARAMETERS
         B     DUP90                    GET OUT NOW WITH NULL
DUP30    EQU   *                        DUP LOOP (DOOP LUP)
         GOIF  (VTXTOUT),(R15),HIGH=DUP80    NOT ENOUGH ROOM, FAKE IT
DUP32    EX  R14,DUPMOVE                MOVE THE STRING
DUP34    AR    VTXTOUT,RCOMP1           ADD LENGTH OF MOVED STRING
         BCT   EVEN,DUP30               LOOP CONTROL
         SPACE
*        DONE--BE SURE LENGTH IS UPDATED
         SPACE
DUP90    LR    R15,R0                   RESTORE STRING BUFFER BASE
         SR    VTXTOUT,R15              NEW LENGTH OF TOTAL STRING
         BCTR  VTXTOUT,D0               DONT COUNT LENGTH BYTE
         USING JTMSTRNG,R15
         STC   VTXTOUT,JTMSTRNG         STORE STRING LENGTH
         DROP  R15
         B     EVAL10                   EXIT TO EVAL ITERATION POINT
DUPMOVE  MVC   D0(D0,VTXTOUT),D0(ODD)   REMOTE MOVE FOR DUP FACTOR
         SPACE 3
DUP80    EQU   *                        MOVE A PARTIAL STRING
         SPACE
         GOIF  ERR105SW,ON=DUP85        BYPASS IF ERROR ALREADY LOGGED
         L     R12,=A(LOGERR01)         GET PTR TO ERROR LOGGING RTN
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV105,ERR105)       ERROR PARAMETER
         SET   ERR105SW,ON              INDICATE ERROR LOGGED ONCE
DUP85    AR    RCOMP1,R15               END OF BUFFER
         SR    RCOMP1,VTXTOUT           REMAINING LENGTH
         LTR   R14,RCOMP1
         BZ    DUP90                    DONE IF NOTHING TO MOVE
         LA    EVEN,D1                  TO GET OUT OF LOOP
         B     DUP32                    GO MOVE
         SPACE 3
EVALSCM  EQU   *                        START CHARACTER MODE
         SPACE
         SET   CCOMP,ON                 DO CHARACTER RELATIONALS
         L     VTXTOUT,STRPTR1            GET CURRENT CHARACTER BUFFER X
                                          POINTER.
         SPACE
         ST    STACKPTR,STACKLVL        SAVE THE STACK POIN0ER
         L     R12,=A(GENSTRNG)         GENSTRING BASE
         BALR  RETURN,R12                 AND LINK TO GENERATE A STRING
         LR    VTXTIN,R11               RECOVER META TEXT POINTER
EVALPER  EQU   *
         SPACE
         XC    STRPTR1,STRPTR2          FLIP BUFFERS
         B     EVAL10                   DO SOME MORE.
         SPACE 3
         SPACE 3
EVALSTRM EQU   *                        EXIT
         SPACE
         ST    STACKPTR,STACKLVL        SAVE THE STACK POINTER
         LR    R10,VTXTIN               META TEXT POINTER AS PARAMETER
EVAL99   LM    R2,R9,EVALST             RESTORE CALLERS REGISTERS
         BR    R9                       RETURN TO CALLER
         EJECT
         USING STACK,STACKPTR           BASE FOR STACK OPERATIONS
         SPACE
EVALADD  EQU   *                        ADD
         SPACE
         BAL   RETURN,INFIXRES          RESOLVE TWO TERMS
         SPACE
         AR    EVEN,ODD                 ADD
         BNO   ADD80                    GO ON IF NO OVERFLOW
LOGER110 L     R12,=A(LOGERR01)         GET PTR TO ERROR LOGGING RTN
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV110,ERR110)       ERROR PARAMETERS
         SR    EVEN,EVEN                SET UP DEFAULT VALUE
ADD80    ST    EVEN,STACKVAL            STORE THE VALUE
         B     ARTHEXIT                   AND GO CLEAN UP
         SPACE 3
EVALSUB  EQU   *                        SUBTRACT
         SPACE
         BAL   RETURN,INFIXRES          RESOLVE TWO TERMS
         SPACE
         SR    EVEN,ODD                 SUBTRACT
         BO    LOGER110                 DIAGNOSE THE OVERFLOW
         B     ADD80                    OTHERWISE, FINISH UP NORMALLY
         SPACE 3
EVALDIV  EQU   *                        DIVIDE
         SPACE
         BAL   RETURN,INFIXRES          RESOLVE TWO TERMS
         GOIF  (ODD),ZERO=DIV80         SKIP DIVIDE ON ZERO DIVISOR
         LR    R0,ODD                   DIVISOR
         SRDA  EVEN,D32                 SET UP DIVIDEND
         DR    EVEN,R0                  DIVIDE
DIV80    ST    ODD,STACKVAL             STORE DIVIDEND
         B     ARTHEXIT                   AND GO CLEAN UP
         SPACE 3
EVALMULT EQU   *                        MULTIPLY
         SPACE
         BAL   RETURN,INFIXRES          RESOLVE TWO TERMS
         SPACE
         MR    EVEN,EVEN                MULTIPLY
         LTR   EVEN,EVEN                CHECK FOR OVERFLOW
         BNM   MULT79                   BRANCH IF NOT NEGATIVE SIGN
         LCR   EVEN,EVEN                CONVERT NEGATIVE TO POSITIVE
         BCTR  EVEN,D0                  DECREMENT. IF 1, WILL BE ZERO
         LTR   EVEN,EVEN                TEST FOR ZERO. IF NOT,
MULT79   EQU   *
         BNZ   LOGER110                 GO TO PUT ERROR, SET DEFAULT
         ST    ODD,STACKVAL             RESULT GOES TO THE STACK
         B     ARTHEXIT                 AND GO CLEAN UP
         DROP  STACKPTR
         SPACE 3
INFIXRES EQU   *                        RESOLVE FOR INFIX OPERATIONS
         SPACE
         ST    RETURN,INFIXRTN          SAVE THE RETURN REGISTER
         LR    R10,STACKPTR             REGISTER FOR RESOLVE
         JCALL RESOLVE                  RESOLVE TO ARITHMETIC
         LR    ODD,R11                  PLACE VALUE IN COMP REGISTER
         SH    STACKPTR,=Y(STKENTRY)    BACK UP ONE TERM IN STACK
         SPACE
INFIX50  EQU   *                        ENTRY FOR SINGLE TERM RESOLVE
         SPACE
         LR    R10,STACKPTR             RESOLVE NEEDS IT IN R10
         JCALL RESOLVE                  RESOLVE TO ARITHMETIC
         LR    EVEN,R11                 PLACE VALUE IN OTHER COMP REG
         L     RETURN,INFIXRTN          RESTORE RETURN REGISTER
         BR    RETURN                     AND RETURN TO CALLER
         SPACE 3
PREFXRES EQU   *                        RESOLVE FOR PREFIX OPERATIONS
         SPACE
         ST    RETURN,INFIXRTN          SAVE THE RETURN REGISTER
         B     INFIX50                  AND RESOLVE ONE TERM
         SPACE 3
RELATE   EQU   *                        ENTER IN THE STACK
         SPACE
         USING JTMOP,VTXTIN             BASE FOR OPERATOR
         LA    VTXTIN,JTMPTR            SKIP UP TO NEXT OPERATOR/TERM
         DROP  VTXTIN
         SPACE
         USING STACK,STACKPTR           BASE FOR STACK ENTRY
         ST    EVEN,STACKVAL            STACK THE RESULT
         DROP  STACKPTR
         B     RELTEXIT                 GO TO FINISH UP RELATIONALLY
         SPACE 3
EVAL80   EQU   *                        ENTER ALL TERMS IN STACK
         SPACE
         USING STACK,STACKPTR           BASE FOR STACK ENTRY
         USING JTMFLG,VTXTIN            BASE FOR TERM INPUT
         MVC   STACKNXT(TERMLNTH),JTMFLG  MOVE TERM TO STACK
         SET   JTMCSW,OFF               BE SURE TEXT SWITCHES ARE CLEAN
         LA    VTXTIN,JTMFLG+TERMLNTH   BUMP TEXT OVER TERM
         LA    STACKPTR,STACKNXT          AND OVER TERM IN STACK
         B     EVAL10                   GO BACK FOR MORE
         DROP  STACKPTR,VTXTIN
         SPACE 3
EVALGT   EQU   *                        GENERAL
EVALGE   EQU   *                          ENTRY
EVALLT   EQU   *                            FOR
EVALLE   EQU   *                              RELATIONAL
EVALEQ   EQU   *                                OPERATIONS
EVALNE   EQU   *                                  IS HERE.
         SPACE
         BCTR  VTXTIN,D0                BACK UP TO RELATIONAL OPERATOR
         GOIF  CCOMP,ON=CHARREL         SWITCH ON, DO CHARACTER COMPARE
         SPACE
ARTHREL  EQU   *                        ARITHMETIC RELATIONAL
         SPACE
         BAL   RETURN,INFIXRES          RESOLVE TWO TERMS
         GOIF  (EVEN),(ODD),MODE=A,HI=EVALHI,LO=EVALLO                 X
                                        COMPARE AND BRANCH
         SPACE
EVALEQU  EQU   *                        WE HAVE AN EQUAL COMPARE
         SPACE
         USING JTMFLG,VTXTIN            BASE TO CHECK OPERATOR
         GOIF  JTMGE,LO=EVALNO          BRANCH IF OPERATOR IS GT
         GOIF  JTMLE,HI=EVALNO,         BRANCH IF OPERATOR IS LT, NE   X
               ELSE=EVALYES             ELSE IT MUST BE GE, LE, EQ
         SPACE
EVALHI   EQU   *                        HIGH COMPARE
         SPACE
         GOIF  JTMGE,LE=EVALYES         OPERATOR IS GE, GT
         GOIF  JTMNE,EQ=EVALYES,        OPERATOR IS NE                 X
               ELSE=EVALNO              OPERATOR IS EQ, LE, LT
         SPACE
EVALLO   EQU   *                        LOW COMPARE
         SPACE
         GOIF  JTMLE,GE=EVALYES,        OPERATOR IS LE, LT, NE         X
               ELSE=EVALNO              OPERATOR IS GT, GE, EQ
         SPACE
EVALYES  EQU   *                        YESS
         SPACE
         LA    EVEN,D1                  GIVE YES RESPONSE
         B     RELATE                     AND GO STORE IT
         SPACE
EVALNO   EQU   *                        NO--
         SPACE
         SR    EVEN,EVEN                ZERO THE RESULT (NO)
         B     RELATE                     AND GO STORE IT
         DROP  VTXTIN
         SPACE 3
CHARREL  EQU   *                        CHARACTER RELATIONAL
         SPACE
         SET   CCOMP,OFF                TURN OFF CHARACTER RELATIONAL  X
                                          SWITCH.
         USING STACK,STACKPTR           BASE FOR TERM STACK
         LA    STACKPTR,STACKNXT        A CHARACTER RELATIONAL CAUSES AX
                                          NEW TERM TO BE ENTERED IN THEX
                                          STACK--MAKE ROOM FOR IT.
         DROP  STACKPTR
         CLC   STRING1(D1),STRING2      COMPARE STRING LENGTHS
         BH    EVALHI                   LONG
         BL    EVALLO                   SHORT
         IC    RMOVE,STRING1            ELSE COMPARE CHARACTERS--
         EX    RMOVE,TR1                BUFFER 1 TO EXTERNAL
         EX    RMOVE,TR2                BUFFER 2 TO EXTERNAL
         EX    RMOVE,COMP12             EXECUTED COMPARE
         EX    RMOVE,TR1                BUFFER 1 BACK AGAIN
         EX    RMOVE,TR2                BUFFER 2 BACK AGAIN
         BL    EVALLO                   LOW
         BH    EVALHI                   HIGH
         B     EVALEQU                  EQUAL
         SPACE
COMP12   CLC   STRING1(D0),STRING2      REMOTE COMPARE
TR1      TR    STRING1(D0),JTRTABLE     REMOTE TRANSLATE STRING1
TR2      TR    STRING2(D0),JTRTABLE     LIKEWISE STRING2
         SPACE 3
         USING STACK,STACKPTR           BASE FOR STACK OPERATIONS
         SPACE
EVALOR   EQU   *                        OR
         SPACE
         BAL   RETURN,INFIXRES          RESOLVE TWO TERMS
         OR    EVEN,ODD                 DO THE OR
         ST    EVEN,STACKVAL            STORE THE RESULT
         B     ARTHEXIT                   AND EXIT.
         SPACE
EVALAND  EQU   *                        AND
         SPACE
         BAL   RETURN,INFIXRES          RESOLVE TWO TERMS
         NR    EVEN,ODD                 DO THE AND
         ST    EVEN,STACKVAL            STORE THE RESULT
         B     ARTHEXIT                   AND EXIT
         SPACE
EVALNOT  EQU   *                        NOT
         SPACE
         BAL RETURN,PREFXRES            RESOLVE ONE TERM
         X     EVEN,=F'1'               REVERSE THE BIT
         CL    EVEN,=F'1'               GT THAN ONE ?          @AZ10934
         BNH   EVALNOT5                 BR IF NOT, ELSE SET-   @AZ10934
         SR    EVEN,EVEN                TO ZERO                @AZ10934
EVALNOT5 EQU   *                                               @AZ10934
         ST    EVEN,STACKVAL            STORE THE RESULT
         B     ARTHEXIT                   AND EXIT
         SPACE
EVALMIN  EQU   *                        MINUS--UNARY
         SPACE
         BAL   RETURN,PREFXRES          RESOLVE ONE TERM
         LCR   EVEN,EVEN                COMPLEMENT
         ST    EVEN,STACKVAL            STORE THE RESULT
         B     ARTHEXIT                   AND EXIT
         DROP  STACKPTR
         SPACE
EVALPLUS EQU   *                        PLUS--UNARY
         SPACE
         B     EVAL10                   A NO-OP, EFFECTIVELY
RELTEXIT EQU   *
         MVI   STRING1,D0               DROP STRING IF ANY
         MVI   STRING2,D0               DROP STRING IF ANY
ARTHEXIT EQU   *                        EXIT ROUTINE TO FOLLOW ARITH-  X
                                          METIC OPERATIONS.
         USING STACK,STACKPTR
         MVI   STACKFLG,JTMSDT          NOW IT'S A SELF DEFINING TERM
         B     EVAL10                   AND RETURN TO EVAL MAINLINE
         DROP  STACKPTR
         SPACE 3
EVALTAT  EQU   *                        TYPE ATTRIBUTE
         L     VTXTOUT,STRPTR1          SET UP PTR TO STRING BUFFER
         SPACE
         SET   CCOMP,ON                 INDICATE CHARACTER COMPARES
         USING JTMFLG,STACKPTR          BASE FOR TERM
         GOIF  JTMSVC,LT=TAT22          A OR B TYPE VARIABLE
         GOIF  JTMOSA,LT=TAT24          C TYPE VARIABLE
         DROP  STACKPTR
         LR    R10,STACKPTR             POINT TO TERM
         SET   CHARMODE,ON              NO ARITHMETIC CONVERSION
         JCALL RESOLVE                  RESOLVE IT
         SET   CHARMODE,OFF
*        R14 POINTS TO HEADER
         USING PARMTAB,R14              BASE FOR ENTRY
         GOIF  PTAT,JU,NE=TAT15         PICK UP TYPE IF NOT U
         GOIF  TDEFALT,ON=TAT23         DIAGNOSE IF U DEFAULTED
TAT15    IC    RMOVE,PTAT               PICK UP TYPE
         DROP  R14
         USING JTMLNG,VTXTOUT           BASE FOR OUTPUT
TAT20    STC   RMOVE,JTMSTRNG           STORE TYPE
         MVI   JTMLNG,D1                LENGTH OF 1
         DROP  VTXTOUT
         SH    STACKPTR,=Y(STKENTRY)    DELETE TERM FROM STACK
         XC    STRPTR1,STRPTR2          SWITCH BUFFERS.
         B     EVAL10                   AND EXIT TO MAINLINE EVAL.
         SPACE
TAT22    LA    RMOVE,JN                 TYPE N FOR A AND B VARIABLES
         B     TAT20                    CONTINUE
TAT23    L     R12,=A(LOGERR01)         LOG ERROR 119
         BALR  R9,R12
         DC    AL1(SEV119,ERR119)
TAT24    LA    RMOVE,JU                 TYPE U FOR C VARIABLES
         B     TAT20                    CONTINUE
         SPACE 3
EVALSAT  EQU   *                        SCALE ATTRIBUTE
         SPACE
         USING JTMFLG,STACKPTR          BASE FOR TERM
         GOIF  JTMLSTO,GT=SAT10         GO ON IF SCALE ATTR VALID
         GOIF  JTMOSA,EQ=SAT10          I.E., ORD SYMB OR PARAM
SAT05    L     R12,=A(LOGERR01)         ERROR ROUTINE
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV123,ERR123)       ERROR PARAMETERS
         B     SAT07                    GET DEFAULT VALUE
SAT06    L     R12,=A(LOGERR01)         ERROR ROUTINE
         BALR  R9,R12
         DC    AL1(SEV80,ERR80)         UNDEFINED SYMBOL
SAT07    SR    EVEN,EVEN                SET UP DEFAULT VALUE
         B     SAT20                    GO TO ASSIGN IT NORMALLY
SAT10    EQU   *
         LR    R10,STACKPTR             POINTER FOR DICTIONARY CALL
         SET   CHARMODE,ON              NO ARITHMETIC CONVERSION
         JCALL RESOLVE                  RESOLVE THE TERM
         SET   CHARMODE,OFF
         USING PARMTAB,R14              BASE FOR ATTRIBUTE REFERENCE
         GOIF  PTAT,JN,EQ=SAT05         LOOK FOR SELFDEFINING TERM
         GOIF  UDEFALT,ON=SAT06         REFERENCE TO UNDEFINED SYMBOL
         GOIF  SDEFALT,ON=SAT05         GOIF DEFAULTED VALUE
SAT15    EQU   *
         XC    JFWORD1,JFWORD1          CLEAR
         MVC   JFWORD1+D2(D2),PSAT      ALIGN
         L     EVEN,JFWORD1             PICK UP
         USING STACK,STACKPTR           BASE FOR NEW STACK ENTRY
SAT20    EQU   *
         ST    EVEN,STACKVAL            AND STORE.
         MVI   STACKFLG,JTMSDT          MAKE A SELF DEFINING TERM
         B     EVAL10                   BACK TO MAINLINE EVAL
         DROP  STACKPTR,R14
         SPACE 3
EVALLAT  EQU   *                        LENGTH ATTRIBUTE
         SPACE
         USING JTMFLG,STACKPTR          BASE FOR TERM
         GOIF  JTMLSTO,GT=LAT10         GO ON IF LENGTH ATTR VALID
         GOIF  JTMOSA,EQ=LAT10          OR IF DIRECT ORD SYMB REFER
LAT05    L     R12,=A(LOGERR01)         ERROR ROUTINE
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV120,ERR120)       ERROR PARAMETERS
         B     LAT07                    GET DEFAULT VALUE
LAT06    L     R12,=A(LOGERR01)         ERROR ROUTINE
         BALR  R9,R12
         DC    AL1(SEV80,ERR80)         UNDEFINED SYMBOL
LAT07    L     EVEN,=F'1'               SET UP DEFAULT VALUE
         B     LAT20                    GO TO ASSIGN IT NORMALLY
LAT10    EQU   *
         LR    R10,STACKPTR             POINTER FOR RESOLVE CALL
         SET   CHARMODE,ON              NO ARITHMETIC CONVERSION
         JCALL RESOLVE                  RESOLVE THE TERM
         SET   CHARMODE,OFF
         USING PARMTAB,R14              BASE FOR REFERENCED ITEM
         GOIF  PTAT,JN,EQ=LAT05         CHECK IF SELFDEFINED TERM
         GOIF  UDEFALT,ON=LAT06         CHECK IF UNDEFINED SYMBOL
         GOIF  LDEFALT,ON=LAT05         CHECK IF DEFAULTED VALUE
         XC    JFWORD1,JFWORD1          CLEAR
         MVC   JFWORD1+D2(D2),PLAT      ALIGN
         L     EVEN,JFWORD1             PICK UP
         USING STACK,STACKPTR           BASE FOR NEW STACK ENTRY
LAT20    EQU   *
         ST    EVEN,STACKVAL            AND STORE.
         MVI   STACKFLG,JTMSDT          MAKE INTO SELF DEFINING TERM
         B     EVAL10                   RETURN TO EVAL MAINLINE
         DROP  R14,STACKPTR
         SPACE 3
EVALIAT  EQU   *                        INTEGER ATTRIBUTE
         SPACE
         USING JTMFLG,STACKPTR          BASE FOR TERM
         GOIF  JTMLSTO,GT=IAT10         GO ON IF INTEGER ATTR VALID
         GOIF  JTMOSA,NE=IAT15          I.E., ORD SYMB OR PARAM
IAT10    EQU   *
         DROP  STACKPTR
         LR    R10,STACKPTR             POINTER FOR RESOLVE
         SET   CHARMODE,ON              NO ARITHMETIC CONVERSION
         JCALL RESOLVE                  RESOLVE THE TERM
         SET   CHARMODE,OFF
         USING PARMTAB,R14              BASE FOR REFERENCED ITEM
         GOIF  PTAT,JN,EQ=IAT15         CHECK IF SELFDEFINED TERM
         GOIF  UDEFALT,ON=IAT16         CHECK IF UNDEFINED SYMBOL
         GOIF  LDEFALT,ON=IAT17         CHECK IF LENGTH DEFAULTED
         XC    JFWORD1,JFWORD1          CLEAR
         MVC   JFWORD1+D2(D2),PLAT      ALIGN
         L     EVEN,JFWORD1             PICK UP
IAT12    GOIF  SDEFALT,ON=IAT18         CHECK IF SCALE DEFAULTED
         XC    JFWORD1,JFWORD1          CLEAR
         MVC   JFWORD1+D2(D2),PSAT      ALIGN
         L     ODD,JFWORD1              PICK UP
IAT13    LA    RCOMP1,PTAT              POINT TO TYPE ATTRIBUTE
         USING PTAT,RCOMP1              BASE FOR TYPE ATTRIBUTE
         GOIF  PTAT,JD,EQ=FLPIN         D IS FLOATING POINT
         GOIF  PTAT,JE,EQ=FLPIN         E IS TOO
         GOIF  PTAT,JL,EQ=FLPIN         L IS ALSO
         GOIF  PTAT,JK,EQ=FLPIN         K IS FLOATING PT, EXPLICIT LEN
         GOIF  PTAT,JP,EQ=PDECIN        P IS PACKED DECIMAL
         GOIF  PTAT,JZ,EQ=ZDECIN        Z IS ZONED DECIMAL
         GOIF  PTAT,JG,EQ=FXPIN         G IS FIXED PT, EXPLICIT LENGTH
         GOIF  PTAT,JF,EQ=FXPIN         F IS FIXED POINT
         GOIF  PTAT,JH,EQ=FXPIN         H LIKEWISE
IAT15    L     R12,=A(LOGERR01)         ERROR ROUTINE
         BALR  R9,R12
         DC    AL1(SEV124,ERR124)
         SR    EVEN,EVEN                DEFAULT VALUE
         B     IAT20                    GO TO BUILD RESULTANT TERM
IAT16    L     R12,=A(LOGERR01)         ERROR ROUTINE
         BALR  R9,R12
         DC    AL1(SEV80,ERR80)         UNDEFINED SYMBOL
         SR    EVEN,EVEN                SET UP DEFAULT VALUE
         B     IAT20                    STORE VALUE
IAT17    L     R12,=A(LOGERR01)         ERROR ROUTINE
         BALR  R9,R12
         DC    AL1(SEV120,ERR120)
         L     EVEN,=F'1'               DEFAULT VALUE
         B     IAT12                    GET SCALE ATTRIBUTE
IAT18    L     R12,=A(LOGERR01)         ERROR ROUTINE
         BALR  R9,R12
         DC    AL1(SEV123,ERR123)
         SR    ODD,ODD                  DEFAULT SCALE ATTRIBUTE
         B     IAT13                    CALCULATE INTEGER ATTRIBUTE
         SPACE
*INTEGER ATTRIBUTE IS COMPUTED AS FOLLOWS--
*        FIXED POINT     I'=(L'*8)-1-S'
*        FLOATING POINT  I'=(L'-1)*2-S'      SHORT
*                        I'=(L'-2)*2-S'      LONG
*        PACKED DECIMAL  I'=(L'-2)-1-S'
*        ZONED DECIMAL   I'=L'-S'
         SPACE
FXPIN    EQU   *                        FIXED POINT ENTRY
         SLL   EVEN,TIMES8              L' * 8
         BCTR  EVEN,D0                  MINUS ONE
         B     ZDECIN                   FIXED POINT CONTINUE
FLPIN    EQU   *                        FLOATING POINT ENTRY
         BCTR  EVEN,D0                  LENGTH ATTR MINUS ONE
         CH    EVEN,=H'7'               IF LENGTH IS M OR LESS,
         BNH   FLP2                     SKIP AROUND.
         BCTR  EVEN,D0                  ELSE, MINUS ONE AGAIN
FLP2     AR    EVEN,EVEN                TIMES 2
         B     ZDECIN                   FLOATING POINT CONTINUE
PDECIN   EQU   *                        PACKED DECIMAL ENTRY
         AR    EVEN,EVEN                L' * 2
         BCTR  EVEN,D0                  MINUS ONE
ZDECIN   EQU   *                        ZONED DECIMAL ENTRY
         SR    EVEN,ODD                 - S'
         USING STACK,STACKPTR           STACK BASE
IAT20    EQU   *
         ST    EVEN,STACKVAL            STORE THE RESULT
         MVI   STACK,JTMSDT             AND MAKE IT A SELF DEFINING    X
                                          TERM.
         B     EVAL10                   BACK TO EVAL MAINLINE.
         DROP  STACKPTR,R14
         DROP  RCOMP1
         SPACE 3
EVALKAT  EQU   *                        COUNT ATTRIBUTE
         SPACE
         USING JTMFLG,STACKPTR          BASE FOR TERM
         GOIF  JTMOSA,LT=KATT50         SET VARIABLE
         GOIF  JTMLSTO,GT=KATT30        GO ON IF COUNT ATTR VALID
         L     R12,=A(LOGERR01)         GET PTR TO ERROR LOGGING RTN
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV121,ERR121)       ERROR PARAMETERS
         SR    EVEN,EVEN                SET UP DEFAULT VALUE
         B     KATT90                   GO TO ASSIGN IT NORMALLY
         SPACE
KATT30   EQU   *                        PARAMETER COUNT ATTRIBUTE
         LR    R10,STACKPTR             TERM POINTER PASSED
         SET   CHARMODE,ON              NO ARITHMETIC CONVERSION
         JCALL RESOLVE                  AND RESOLVE THE TERM.
         SET   CHARMODE,OFF
         USING PARMTAB,R14
         GOIF  PSUB,ON=KATT34           SUBLIST REFERENCE
         SR    EVEN,EVEN                CLEAR A REGISTER
         IC    EVEN,PKAT                AND PICK UP K ATTRIBUTE
         USING STACK,STACKPTR           BASE FOR NEW STACK ENTRY
KATT90   ST    EVEN,STACKVAL            STORE IN THE STACK
         MVI   STACKFLG,JTMSDT            AND MAKE IT AN SDT.
         B     EVAL10                   RETURN
         SPACE
KATT34   MVC   JHWORD1,PKATSUB          ALIGN SUBOPERAND K ATTRIBUTE
KATT35   LH    EVEN,JHWORD1             PICK UP VALUE
         MVC   JHWORD1,PNAT             ALIGN AND
         AH    EVEN,JHWORD1             ADD N ATTRIBUTE
         LA    EVEN,D1(EVEN)            ADD 1--ACCOUNTS FOR COMMAS AND X
                                          PARENS ADDED ON OUTPUT.
         B     KATT90                     AND CONTINUE
         SPACE
KATT50   EQU   *                        SET VARIABLE K ATTRIBUTE
         LR    R10,STACKPTR             TERM POINTER
         SET   CHARMODE,ON                WE WANT CHARACTERS BACK
         JCALL RESOLVE                  RESOLVE THE TERM TO A STRING
         SET   CHARMODE,OFF             (SWITCH BACK OFF)
         USING JTMLNG,R11               BASE FOR STRING
         SR    EVEN,EVEN                CLEAR A REGISTER
         IC    EVEN,JTMLNG              PICK UP LENGTH AS K ATTRIBUTE
         DROP  R11
         B     KATT90                   CONTINUE
         DROP  R14,STACKPTR
         SPACE 3
EVALNAT  EQU   *                        NUMBER ATTRIBUTE
         SPACE
         USING JTMFLG,STACKPTR          BASE FOR TERM
         GOIF  JTMLSTO,EQ=NAT40,        BRANCH IF SYSLIST REFERENCE    X
               GT=NAT10                 BRANCH IF PARAMETER REFER
         L     R12,=A(LOGERR01)         GET PTR TO ERROR LOGGING RTN
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV122,ERR122)       ERROR PARAMETERS
         SR    EVEN,EVEN                SET UP DEFAULT VALUE
         B     KATT90                   GO TO ASSIGN IT NORMALLY
NAT10    LR    R10,STACKPTR             TERM POINTER
         SET   CHARMODE,ON              NO ARITHMETIC CONVERSION
         JCALL RESOLVE                  RESOLVE THE TERM
         SET   CHARMODE,OFF
         USING PARMTAB,R14              BASE FOR PARAMETER
         GOIF  PSUB,ON=NAT20            SUBLIST, SKIP AHEAD
         GOIF  POMIT,ON=NAT50           CHECK FOR OMITTED OPERAND
         LA    EVEN,D1                  ELSE N ATTRIBUTE IS 1
         B     KATT90                   EVIT
NAT20    MVC   JHWORD1,PNAT             ALIGN
         LH    EVEN,JHWORD1             PICK UP VALUE
         SET   SUBLIST,OFF              CLEAR SUBLIST SWITCH   @OX09721
         B     KATT90                   AND EXIT
         SPACE
NAT40    EQU   *                        SYSLIST
         TM    JTMLSTM,BIT0             LOOK FOR DEAD TERM
         BO    NAT50                    GIVE DEFAULT IF FOUND
         SPACE
         LH    EVEN,NOFSYSLS            ELSE LOAD N'SYSLIST
         B     KATT90                   AND EXIT.
NAT50    SR    EVEN,EVEN                SET N ATTRIBUTE TO ZERO
         B     KATT90                   AND EXIT
         DROP  STACKPTR,R14
         EJECT
*TITLE                                                                *
*   GENSTRING/GENERATE A CHARACTER STRING                             *
         SPACE
*NOTES-                                                               *
*   REGISTERS--                                                       *
*                                                                     *
*   ENTRY--                                                           *
*                                                                     *
*   VTXTOUT    LENGTH FIELD OF CURRENT STRING                         *
*   VTXTIN     META TEXT                                              *
*                                                                     *
*   EXIT--                                                            *
*                                                                     *
*   R10        NEXT AVAILABLE OUTPUT POSITION                         *
*   R11        NEXT META FLAG                                         *
*        STACKPTR   CURRENT EVALUATION STACK ENTRY
         SPACE
GENSTRNG EQU   *
GENSTR00 STM   R2,R9,GENSTRST           SAVE CALLERS REGISTERS
         LR    R8,R12                   ESTABLISH BASE FOR RTN
         USING GENSTR00,R8
         SPACE
         USING JTOPL,VTXTOUT            DUMMY OUTPUT BASE
         ST    VTXTOUT,GENPTR           SAVE POINTER TO LENGTH
         SR    FLDLN,FLDLN              CLEAR A REGISTER
         IC    FLDLN,JTOPL              PICK UP CURRENT STRING LENGTH
         LA    VTXTOUT,JTOPND(FLDLN)      AND STEP TO END OF STRING.
         ST    VTXTOUT,NEWSTRNG         SAVE THIS STRING START
         STH   FLDLN,STRNGLN            AND PREVIOUS LENGTH
         USING JTOPND,VTXTOUT           RESET BASE
         SET   CHARMODE,ON              WE WANT CHARACTERS BACK
         SET   ERR105SW,OFF             CLEAR ERROR LOGGED SWITCH
         SET   SUBLIST,OFF              CLEAR SUBLIST SWITCH
         SPACE
GENSTR10 EQU   *                        ITERATION POINT
         SPACE
         USING JTMOP,VTXTIN             VTXTIN POINTS TO META OPERATOR
         GOIF  SUBLIST,ON=GENSTR32      IF SUBLIST SWITCH IS ON, MUST  X
                                          MOVE ENTIRE SUBLIST.  REENTERX
                                          AT GENSTR14 AFTER PREPARATION
         GOIF  JTMSTRM,EQ=GENSTR90      EXIT IF STATEMENT TERMINATOR
         GOIF  JTMECM,EQ=GENSTR80         OR END CHARACTER MODE.
         SPACE
         GOIF  JTMCS,NE=GENSTR12        NOT CHARACTER STRING, SKIP
         SR    RMOVE,RMOVE              HAS GARBAGE ON RECURSION
         IC    RMOVE,JTMLNG               BEFORE PROCEEDING,
         LA    R11,JTMLNG               POINT R11 TO L FIELD OF STRING
         LA    VTXTIN,JTMSTRNG(RMOVE)   AND UPDATE THE META TEXT PTR
         B     GENSTR16                 SKIP AHEAD
         SPACE
GENSTR12 EQU   *                        PREPARE TO RESOLVE TERM
         SPACE
         GOIF  JTMLSTO,EQ=GENSTR15      SYSLIST, GO GET DIMENSION
         GOIF  JTMD,FZERO,EQ=GENSTR13   NO DIMENSION, PROCEED
GENSTR15 SET   JTMCSW,ON                ELSE SET TEMPORARY CHARACTER   X
                                          FLAG.
         SET   CHARMODE,OFF             NO LONGER IN CHARACTER MODE
         ST    FLDLN,RESRTRN            SAVE STRING LENGTH COUNTER
         L     STACKPTR,STACKLVL        PICK UP CURRENT STACK POINTER
         L     R8,=A(EVAL)              BASE FOR EVAL ROUTINE
         USING EVAL,R8                    DECLARED--
         B     EVAL80                   GO EVALUATE DIMENSION
         USING GENSTRNG,R8              RE-DECLARE ROUTINE BASE
         SPACE
GENSTR13 EQU   *
         SPACE
         LR    R10,VTXTIN               R10 WANTS TERM POINTER
         LA    VTXTIN,JTMNEXT             AND VTXTIN NEEDS UPDATE
         JCALL RESOLVE                  RESOLVE PRODUCES A STRING
         DROP  VTXTIN
         USING JTMLNG,R11               BASE
GENSTR1X EQU   *
         GOIF  SUBLIST,ON=GENSTR30      SUBLIST SWITCH ON, BRANCH
GENSTR14 SR    RMOVE,RMOVE              CLEAR A REGISTER
         IC    RMOVE,JTMLNG             PICK UP STRING LENGTH
GENSTR16 EQU   *
         GOIF  (RMOVE),ZERO=GENSTR10    NULL STRING IF L=0
         DROP  R11
         AR    FLDLN,RMOVE              INCREMENT LENGTH COUNTER
         GOIF  (FLDLN),HMAXCHAR,GT=LOGER105  GENERATED STRING TOO LONG
GENSTR18 EQU   *
         BCTR  RMOVE,D0                 DECREMENT TO MOVE LENGTH
         EX    RMOVE,GENMOVE            EXECUTED MOVE
         LA    VTXTOUT,D1(RMOVE,VTXTOUT)     INCREMENT OUTPUT POINTER  X
                                               TO END OF STRING
         B     GENSTR10                 ITERATE
         SPACE
         USING JTMLNG,R11
GENMOVE  MVC   JTOPND,JTMSTRNG          REMOTE MOVE CHARACTER STRING TOX
                                          OUTPUT.
         DROP  R11,VTXTOUT
GENSTR80 EQU   *                        END CHARACTER MODE
GENSTR90 EQU   *                        END OF STATEMENT
         SPACE
         L     INDEX1,GENPTR            PICK UP LENGTH POINTER
         USING JTMLNG,INDEX1              AND USE AS BASE
         STC   FLDLN,JTMLNG             STORE FIELD LENGTH
         DROP  INDEX1
         LR    R10,VTXTOUT              SAVE THE OUTPUT POINTER
         SET   CHARMODE,OFF             INACTIVATE CHARACTER MODE SW
         USING JTMFLG,VTXTIN            BASE FOR INPUT
         LA    R11,JTMPTR               BUMP TO NEXT POTENTIAL FLAG
         DROP  VTXTIN
GENSTR99 LM    R2,R9,GENSTRST           RESTORE CALLERS REGISTERS
         BR    R9                       RETURN TO CALLER
         SPACE
GENSTR30 EQU   *                        STRING IS ENTIRE SUBLIST
         SPACE
         LR    R10,R14                  COMPUTE SUBLIST
         A     R10,JFWORD1              VECTOR POINTER.
         LA    FLDLN,D1(,FLDLN)         INCREMENT STRING COUNT
         GOIF  (FLDLN),HMAXCHAR,GT=LOG105X   GENERATED STRING TOO LONG
         USING JTOPND,VTXTOUT           BASE FOR OUTPUT
         MVI   JTOPND,JLPARN            OUTPUT A LEFT PAREN
         DROP  VTXTOUT
         LA    VTXTOUT,D1(VTXTOUT)      UPDATE THE OUTPUT POINTER
         B     GENSTR35                 AND SKIP AHEAD
         SPACE
GENSTR32 LH    R15,JHWORD1              DECREMENT
         GOIF  (R15),ZERO=GENSTR33      EXIT ON SUBOPERANDS EXHAUSTED
         BCT   R15,GENSTR34               PARAMETER COUNT AND CONTINUE.
         STH   R15,JHWORD1              PRESERVE SUBOPERAND COUNT (0)
         LA    FLDLN,D1(,FLDLN)         BUMP OUTPUT COUNT
         GOIF  (FLDLN),HMAXCHAR,GT=LOG105X GENERATED STRING TOO LONG
         USING JTOPND,VTXTOUT
         MVI   JTOPND,JRPARN            OUTPUT TERMINATING RIGHT PAREN
         DROP  VTXTOUT
         LA    VTXTOUT,D1(,VTXTOUT)     UPDATE THE OUTPUT PTR
GENSTR33 EQU   *
         SET   SUBLIST,OFF              TURN OFF THE SUBLIST FLAG AND
         B     GENSTR10                 GO BACK FOR MORE STRINGING
         SPACE
GENSTR34 STH   R15,JHWORD1              ELSE SAVE THE COUNT.
         LA    FLDLN,D1(FLDLN)          BUMPT OUTPUT COUNT.
         GOIF  (FLDLN),HMAXCHAR,GT=LOG105X   GENERATED STRING TOO LONG
         USING JTOPND,VTXTOUT           BASE FOR OUTPUT TEXT
         MVI   JTOPND,JCOMMA            MOVE COMMA TO TEXT
         DROP  VTXTOUT
         LA    VTXTOUT,D1(VTXTOUT)        AND UPDATE OUTPUT POINTER.
GENSTR35 SH    R10,=H'3'                BACK UP TO NEXT SUBLIST VECTOR
         MVC   JFWORD1+D1(D3),D0(R10)   ALIGN THE VECTOR
         L     R11,JFWORD1              PICK UP THE VECTOR
         USING PFLAG,R14                BASE FOR SUBOPERAND FETCH
         LA    R11,PKAT(R11)            POINT TO SUBOPERAND.
         B     GENSTR14                 AND CONCATENATE IT TO STRING
         SPACE
LOG105X  LA    RMOVE,D1                 SET UP COUNT ON OVERFLO CHAR
LOGER105 GOIF  ERR105SW,ON=GENSTR50     BYPASS IF ERROR ALREADY LOGGED
         L     R12,=A(LOGERR01)         GET PTR TO ERROR LOGGING RTN
         BALR  R9,R12                   MAKE ERROR STACK ENTRY
         DC    AL1(SEV105,ERR105)       ERROR PARAMETERS
         SET   ERR105SW,ON              INDICATE ERROR LOGGED ONCE
GENSTR50 EQU   *
         SR    FLDLN,RMOVE              GET BASE STRING LENGTH
         LH    RMOVE,HMAXCHAR           SET UP MAXIMUM STRING LENGTH
         SR    RMOVE,FLDLN              COMPUTE ALLOWABLE INCREMENT
         LTR   RMOVE,RMOVE              SEE IF INCREMENT ZERO
         BZ    GENSTR10                 IF SO, DON'T BOTHER, ELSE
         AR    FLDLN,RMOVE              ADJUST LENGTH FOR FRAGMENT
         B     GENSTR18                 GO BACK TO ADD MAXIMUM POSSIB
         EJECT
ZONEMASK DC    X'00',15X'0F'            MASK TO DROP LEADING ZEROS OR  X
                                          MASK OUT ZONES AFTER UNPACK
HMAXCHAR DC    Y(MAXCHAR)               MAXIMUM STRING LENGTH
FZERO    DC    F'0'                     ZEROS FOR COMPARES
         SPACE 3
         SPACE 3
         JPATCH  X3A03,B4A              PATCH AREA
         END   MENTRY
