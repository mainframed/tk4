***********************************************************************
*  TITLE: IEBCREAT  DATA GENERATOR CREATE MODULE.                     *
*                                                                     *
*  STATUS: CHANGE LEVEL 0                                             *
*                                                                     *
*  FUNCTION - GENERATES OUTPUT RECORDS AND READS INPUT RECORDS FROM   *
*              INPUT DATA SETS.  AFTER EACH RECORD IS WRITTEN, ALL    *
*              FD TABLES THAT ARE ACCESSED ARE PROCESSED TO PERFORM   *
*              ACTIONS, INDEXING, RANGE, AND CYCLE FUNCTIONS.         *
*             THIS MODULE IS ALWAYS ENTERED FROM MODULE IEBCRANL AND  *
*              RETURNS CONTROL TO IEBCRANL.  IF ENTERED WITH THE      *
*              'NOGO' SWITCH ON ALL OUTPUT GENERATION IS SUPPRESSED   *
*              AND ANY EXISTING CREATE, FD ADDRESS, OR PICTURE TABLES *
*              ARE FREED.                                             *
*             IF AN ERROR IS FOUND CONTROL IS RETURNED TO PRINT A     *
*              MESSAGE, SET THE NOGO SWITCH, AND READ THE NEXT CONTROL*
*              CARD TO CONTINUE SYNTAX CHECKING.                      *
*                                                                     *
*  ENTRY POINT: IEBCREAT THE CSECT NAME OF THIS MODULE.               *
*             LINKED TO BY MODULE IEBCRANL.       -                   *
*                                                                     *
*  INPUT    -  'COMMON' - WORK AREA.                                  *
*              R5       - POINTS TO 'COMMON'.                         *
*             'NOGO'   - IF ON, SUPPRESSES ALL OUTPUT GENERATION.     *
*              CREATE TABLES.                                         *
*              PICTURE TABLES.                                        *
*              FD ADDRESS TABLES.                                     *
*                                                                     *
*  OUTPUT   - RECORDS WRITTEN ON THE OUTPUT DEVICE DEFINED BY THE     *
*              DD NAME SPECIFIED ON THE DSD CARD.                     *
*                                                                     *
*  EXTERNAL ROUTINES - GETMAIN MACRO.                                 *
*                      GET MACRO.                                     *
*                      PUT MACRO.                                     *
*                                                                     *
*  EXITS -    NORMAL - RETURN TO MODULE IEBCRANL.                     *
*             ERROR  - RETURN TO MODULE IEBCRANL.                     *
*                                                                     *
*                                                                     *
*  TABLES/WORKAREAS                                                   *
*                                                                     *
*    CREATE TABLES - FIRST GETMAIN IS POINTED TO BY 'CRTABPT'.        *
*                                                                     *
*     BYTE 1 BYTE 2 BYTE 3 BYTE 4 BYTE 5 BYTE 6 BYTE 7 BYTE 8         *
*    *****************************                                    *
*    * ADDRESS OF NEXT GETMAIN   *---FIRST 4 BYTES OF EACH 512 BYTE   *
*    *****************************    GETMAIN.                        *
*    *********************************************************        *
*  0 *  ADDRESS OF NEXT CREATE   *       QUANTITY            *        *
*    *********************************************************        *
*  8 *   INPUT DCB ADDRESS       *   USER EXIT ADDRESS       *        *
*    *********************************************************        *
* 16 *   PICTURE ADDRESS         * FILL *     NOT USED       *        *
*    *********************************************************        *
* 24 *   FD ADDRESS TABLE        *                                    *
*    *****************************                                    *
*       ANY POINTER OF 0 MEANS NO TABLE OR LAST TABLE.                *
*                                                                     *
*                                                                     *
*                                                                     *
*    PICTURE TABLE - POINTED TO BY 'PICPTR IN CREATE ENTRY.           *
*                    GETMAIN FOR PICTURE LENGTH +6.                   *
*                                                                     *
*     BYTE 1 BYTE 2 BYTE 3 BYTE 4 BYTE 5 BYTE 6 BYTE 7 BYTE 8         *
*    *********************************************************        *
*    *  START LOCATION OFFSET    *  LENGTH     *  PICTURE    *        *
*    *********************************************************        *
*    *         STRING                                        *        *
*    *********************************************************        *
*                                                                     *
*                                                                     *
*                                                                     *
*    FD ADDRESS TABLE - POINTED TO BY 'FDADTAB' IN CREATE ENTRY.      *
*                       GETMAIN OF 88 BYTES.                          *
*                                                                     *
*    *****************************                                    *
*  O * ADDRESS OF NEXT GETMAIN   *                                    *
*    *****************************                                    *
*  4 *   FD TABLE ADDRESS        *                                    *
*    *****************************                                    *
*  8 *   FD TABLE ADDRESS        *                                    *
*    *****************************                                    *
*       LAST FD TABLE ADDRESS IN GETMAIN IS FOLLOWED BY 4 BYTES OF 0'S*
*                                                                     *
*                                                                     *
*                                                                     *
*    EXIT NAME TABLE - FIRST GETMAIN IS POINTED TO BY 'EXITTAB'.      *
*                      GETMAIN OF 72 BYTES. FREED BY MODULE IEBDG     *
*                      WHEN AN END CARD IS READ.                      *
*                                                                     *
*     BYTE 1 BYTE 2 BYTE 3 BYTE 4 BYTE 5 BYTE 6 BYTE 7 BYTE 8         *
*    *****************************                                    *
*  0 * ADDRESS OF NEXT GETMAIN   *                                    *
*    *********************************************************        *
*  4 *      USER EXIT ROUTINE NAME                           *        *
*    *********************************************************        *
* 12 *      USER EXIT ROUTINE NAME                           *        *
*    *********************************************************        *
*       LAST EXIT NAME IN GETMAIN IS FOLLOWED BY 4 BYTES OF 0'S.      *
*                                                                     *
*                                                                     *
*                                                                     *
*    DCB TABLES- KEPT FOR DSD GROUP  GETMAIN 272 BYTES FOR EACH UNIQUE*
*                 DDNAME ON CREATE CARD. INPUT DCB'S ARE CHAINED      *
*                 TOGETHER AND POINTED TO BY 'IDCBPT'. OUTPUT DCB IS  *
*                 POINTED TO BY 'ODCBPT'.                             *
*                                                                     *
*     BYTE 1 BYTE 2 BYTE 3 BYTE 4 BYTE 5 BYTE 6 BYTE 7 BYTE 8         *
*    *********************************************************        *
*    *         DCB FOR INPUT OR OUTPUT DATA SET              *        *
*    *                   256 BYTES                           *        *
*    *********************************************************        *
*    * ADDRESS OF NEXT DCB       *     DDNAME---             *        *
*    *********************************************************        *
*    * ---DDNAME                 *EODSW *                    *        *
*    *********************************************************        *
*                                                                     *
*  ATTRIBUTES: REENTRANT,REUSEABLE                                    *
*                                                                     *
*    NEW MODULE, RELEASE 17.                                       DG0H
*                                                                A30011
*A507700-508000.C506400                                          A45152
*C187800-188300.A280100-280188                                   A45169
*C667000-673400                                                  A45200
*A804300,811500,812000                                          YA01453
*A360010-360380,361210                                          YA01716
*D804600-808600,814200-816600                                   YA01453
*A507710-507750                                                 YA02528
*C508800                                                        YA02528
*A518700,523840-524320                                         @ZA03396
*C289200                                                       @ZA03396
*C237000                                                       @ZA04231
*C237000                                                       @ZA07345
*A246700,262300-262600,381700,382110    (ORG)@XA16970,@YA18072,@ZA24201
*A905500-905700                         (ORG)@XA16970,@YA18072,@ZA24201
*381920                                                        @ZA26202
         LCLA  &T,&SPN                                            0003
.@001    ANOP                                                     0003
IEBCREAT CSECT ,                                                  0003
         ST    @E,12(0,@D)                                        0003
         STM   @0,@8,20(@D)                                       0003
         STM   @A,@C,60(@D)                                       0003
         BALR  @B,0                                               0003
@PSTART  DS    0H                                                 0003
         USING @PSTART+00000,@B                                   0003
         L     @0,@SIZ001                                         0003
         GETMAIN  R,LV=(0)                                        0003
         LR    @C,@1                                              0003
         USING @DATD+00000,@C                                     0003
         LM    @0,@1,20(@D)                                       0003
         XC    @TEMPS(@L),@TEMPS                                  0003
         ST    @D,@SAV001+4                                       0003
         LA    @F,@SAV001                                         0003
         ST    @F,8(0,@D)                                         0003
         LR    @D,@F                                              0003
*            SYSINEOD = OFF;
         MVC   579(1,@5),OFF                                      0048
*                                   /*CLEAR SYSISW SWITCH. */
*            SYSISW = OFF;
         MVC   569(1,@5),OFF                                      0049
*                                   /*TEST IF NOGO SWITCH IS ON.*/
*         IF NOGOSW = ON THEN GO TO A7A6;
         CLC   551(1,@5),ON                                       0050
         BC    08,A7A6                                            0051
*                                   /*PUT ADR. OF SYSI DCB IN BASE PTR.
*            DCBPTR = ADDR(SYSI);
         LA    @F,116(0,@5)                                       0052
         ST    @F,300(0,@5)                                       0052
*                                   /*SAVE SYNAD OF SYSIN DCB FOR
*                                   /* IEBDG.  MUST BE RESTORED BEFORE
*                                   /* EXITING.
*                                   /*SAVE SYNAD ADR. IN 'PARM'. */
*            PARM = SYNAD;
         L     @1,300(0,@5)        
         MVC   12(4,@5),56(@1)                                    0053
*                                   /*CHANGE SYSIN EODAD FOR   @ZA24201
*                                   /*READING DATA RECORDS     @ZA24201
*           SAVEEOD = EODAD;                                 /*@ZA24201
         L     @1,300(0,@5)        
         MVC   SAVEEOD(3),33(@1)                                  0054
*           EODAD   = ADDR(A7EOD);                           /*@ZA24201
         LA    @F,A7EOD                                           0055
         ST    @F,@TEMP4                                          0055
         MVC   33(3,@1),@TEMP4+1                                  0055
*                                   /*INITIALIZE OUTPUT DCB SYNAD. */
*                                   /*PUT SYNAD ADR. IN 'Q'. */
*            Q(1:4) = ADDR(A7SYNAD);
         LA    @F,A7SYNAD                                         0056
         ST    @F,216(0,@5)                                       0056
*                                   /*MOVE SYNAD TO OUTPUT DCB. */
*            FIRSTGMO -> SYNAD(2:4) = Q(2:4);
         L     @1,380(0,@5)        
         MVC   57(3,@1),217(@5)                                   0057
*  A7A1:;
*                                   /*INITIALIZE CREATE TABLE POINTERS.
*                                   /*CURRENT CREATE GM = 1ST CREATE GM
*            CURCRGM = CRTABPT;
A7A1     MVC   320(4,@5),312(@5)                                  0059
*                                   /*CURRENT CREATE = 1ST CREATE ENTRY
*            CURCRTE = CRTABPT + 4;
         LA    @F,4                                               0060
         A     @F,312(0,@5)                                       0060
         ST    @F,316(0,@5)                                       0060
* /********************************************************************
* /**  DO INITIALIZATION FOR EACH CREATE ENTRY.                       *
* /**     R4 IS BASE REG. FOR CREATE TABLE AND MUST BE PRESERVED      *
* /**       ACROSS MOST OF MODULE.                                    *
* /********************************************************************
*  A7A11:;
*                                   /*BASE REG FOR CREATE ENTRY.*/
*            R4 = CURCRTE;
A7A11    L     @4,316(0,@5)                                       0062
*                                   /*CLEAR EODSTOP SWITCH. */
*            EODSTOP = OFF;
         MVC   556(1,@5),OFF                                      0063
*                                   /*PUT OUTPUT DCB RECFM BITS 0,1 */
*                                   /* ONLY IN OUTRECFM.            */
*            OUTRECFM = FIRSTGMO -> RECFM & 'C0'X;
         MVI   662(@5),X'C0'                                      0064
         L     @1,380(0,@5)        
         NC    662(1,@5),36(@1)                                   0064
*                                   /*IF OUTPUT RECFM IS U RECORD SIZE
*                                   /* IS BLKSIZE.
*         IF OUTRECFM = 'C0'X THEN OUTRECSZ = FIRSTGMO -> BLKSI;
         CLI   662(@5),X'C0'                                      0065
         BC    07,@9FF                                            0065
         L     @1,380(0,@5)        
         MVC   658(2,@5),62(@1)                                   0066
         BC    15,@9FE                                            0067
*                                   /*ELSE, RECORD SIZE IS LRECL. */
*         ELSE OUTRECSZ = FIRSTGMO -> LRECL;
@9FF     L     @1,380(0,@5)        
         MVC   658(2,@5),82(@1)                                   0067
*          IF FIRSTGMO -> DSORG(1) = '1'B THEN DO ;    /* I.SEQ.A45169*
@9FE     L     @1,380(0,@5)        
         TM    26(@1),B'10000000'                                 0068
         BC    12,@9FD                                            0068
*               IF FIRSTGMO -> CIND = '0000'X THEN DO; /* RKP=0 A45169*
         CLC   60(2,@1),@X3                                       0070
         BC    07,@9FC                                            0070
*                  IF FIRSTGMO -> RECFM = '80'X THEN DO; /* F   A45169*
         CLI   36(@1),X'80'                                       0072
         BC    07,@9FB                                            0072
*                           /* LRECL ONLY DATA SO ADD KEYLEN    A45169*
*                    OUTRECSZ = OUTRECSZ + FIRSTGMO -> KEYLEN ;
         SR    @F,@F                                              0074
         IC    @F,16(0,@1)                                        0074
         AH    @F,658(0,@5)                                       0074
         STH   @F,658(0,@5)                                       0074
*                  END;             /* END OF CHECK F UNBLK     A45169*
*               END;                   /* END OF CHECK RKP      A45169*
@9FB     EQU   *                                                  0076
*          END;                     /* END OF CHECK INDEX SEQ   A45169*
@9FC     EQU   *                                                  0077
*                                   /*TEST IF OUTPUT RECFM IS V. */
*         IF OUTRECFM = '40'X THEN RECOFFST = 4;
@9FD     CLI   662(@5),X'40'                                      0078
         BC    07,@9FA                                            0078
         MVI   661(@5),4                                          0079
         BC    15,@9F9                                            0080
*                                   /*ELSE, RECORD OFFSET = 0. */
*         ELSE RECOFFST = 0;
@9FA     MVI   661(@5),0                                          0080
*                    /*************************************************
*                    /** DO INITIALIZATION FOR AN INPUT DATA SET.     *
*                    /**  THIS SECTION INITIALIZES SWITCHES AND INPUT *
*                    /**   DCB ADRS.  IT ALSO TESTS IF THE INPUT      *
*                    /**   RECORD SIZE EXCEEDS THE OUTPUT RECORD      *
*                    /**   SIZE.                                      *
*                    /*************************************************
*                                   /*TEST IF INPUT DCB PRESENT.*/
*        IF IDCBPTR ^= 0 THEN DO;
@9F9     SR    @F,@F                                              0081
         C     @F,8(0,@4)                                         0081
         BC    08,@9F8                                            0081
*                                   /*INITIALIZE INPUT DCB SYNAD. */
*                                   /*PUT SYNAD ADR. IN 'Q'. */
*            Q(1:4) = ADDR(A7SYNAD1);                       /*@ZA03396*
         LA    @F,A7SYNAD1                                        0083
         ST    @F,216(0,@5)                                       0083
*                                   /*MOVE SYNAD TO INPUT DCB. */
*            IDCBPTR -> SYNAD(2:4) = Q(2:4);
         L     @1,8(0,@4)          
         MVC   57(3,@1),217(@5)                                   0084
*                                   /*PUT INPUT DCB RECFM BITS 0,1 */
*                                   /* ONLY IN INRECFM.            */
*            INRECFM = IDCBPTR -> RECFM & 'C0'X;
         MVI   660(@5),X'C0'                                      0085
         NC    660(1,@5),36(@1)                                   0085
*                                   /*IF INPUT RECFM IS U RECORD SIZE *
*                                   /* BLKSIZE.                       *
*         IF INRECFM = 'C0'X THEN INRECSZ = IDCBPTR -> BLKSI;
         CLI   660(@5),X'C0'                                      0086
         BC    07,@9F7                                            0086
         MVC   656(2,@5),62(@1)                                   0087
         BC    15,@9F6                                            0088
*                                   /*ELSE, RECORD SIZE IS LRECL. */
*         ELSE INRECSZ = IDCBPTR -> LRECL;
@9F7     MVC   656(2,@5),82(@1)                                   0088
*                              /***************************************
*                              /**IF QUANTITY IS 0, THEN AN INPUT DATA*
*                              /** SET WAS SPECIFIED.  'EODSTOP' SW.  *
*                              /** IS USED TO STOP RECORD GENERATION  *
*                              /** WHEN AN INPUT END-OF-DATA OCCURS.  *
*                              /***************************************
*                                   /*TEST IF QUANTITY = 0. */
*         IF QUAN = 0 THEN DO;
@9F6     CLC   4(4,@4),@D1                                        0089
         BC    07,@9F5                                            0089
*                                   /*SET EODSTOP SWITCH TO STOP GENER-
*                                   /* ATION ON INPUT EOD.
*            EODSTOP = ON;
         MVC   556(1,@5),ON                                       0091
*         END;
*                                   /*TEST IF INPUT DCB IS SYSIN. */
*         IF IDCBPTR ^= ADDR(SYSI) THEN DO;
@9F5     LA    @F,116(0,@5)                                       0093
         C     @F,8(0,@4)                                         0093
         BC    08,@9F4                                            0093
*                                  /*PUT EODAD ADR IN INPUT DCB.*/
*           IDCBPTR -> EODAD = ADDR(A7EODAD);
         LA    @F,A7EODAD                                         0095
         L     @1,8(0,@4)          
         ST    @F,@TEMP4                                          0095
         MVC   33(3,@1),@TEMP4+1                                  0095
         BC    15,@9F3                                            0097
*         END;
*                              /***************************************
*                              /**IF THE INPUT DDNAME IS 'SYSIN',     *
*                              /** 'SYSISW' SW. IS USED TO INDICATE   *
*                              /** THERE ARE SYSIN DATA RECORDS AFTER *
*                              /** A SINGLE CREATE OR REPEAT GROUP.   *
*                              /***************************************
*                                   /*TURN ON 'SYSISW' SW. */
*         ELSE SYSISW = ON;
@9F4     MVC   569(1,@5),ON                                       0097
*                                   /*TEST IF INPUT RECORD EXCEEDS */
*                                   /* OUTPUT RECORD.              */
*         IF INRECSZ > OUTRECSZ THEN DO;
@9F3     LH    @F,658(0,@5)                                       0098
         CH    @F,656(0,@5)                                       0098
         BC    10,@9F2                                            0098
*         IF SYSISW = ON THEN DO  /** DO BELOW IF SYSIN **/;
         CLC   569(1,@5),ON                                       0100
         BC    07,@9F1                                            0100
*         IF SYSINSEL = ON THEN GO TO A7A111  /** BR NO MSG REQUIRED**/
         CLC   636(1,@5),ON                                       0102
         BC    08,A7A111                                          0103
*         END;
*         IF IDCBPTR -> FIELDSEL = ON THEN GO TO A7A111 /**BR NO MSG**/
@9F1     L     @1,8(0,@4)          
         CLC   278(1,@1),ON                                       0105
         BC    08,A7A111                                          0106
*                                  /*INPUT LRECL IS TOO LARGE.*/
*           MS = 17                /*SET MSG 17               */;
         LA    @F,17                                              0107
         STH   @F,406(0,@5)                                       0107
*         SYSISW = OFF;
         MVC   569(1,@5),OFF                                      0108
*         FLUSHSW = ON;
         MVC   572(1,@5),ON                                       0109
*         GO TO ERROR1;
         BC    15,ERROR1                                          0110
*        END;
*        END;
@9F2     EQU   *                                                  0112
* A7A111:;
@9F8     EQU   *                                                  0113
*                                   /*INIT. NO. OF RECORDS COUNTER.*/
*            RECREM = QUAN;
A7A111   MVC   348(4,@5),4(@4)                                    0114
* /********************************************************************
* /**  START CONSTRUCTION OF OUTPUT RECORD.                           *
* /**     CONTROL IS RETURNED TO THIS POINT AFTER THE PREVIOUS RECORD *
* /**      IS WRITTEN AND ANY FD TABLES PROCESSED AND THERE ARE MORE  *
* /**      RECORDS TO BE WRITTEN.  ALL FD FIELDS, CREATE PICTURE AND  *
* /**      INPUT RECORD, IF PRESENT, ARE CONSTRUCTED IN THE OUTPUT    *
* /**      BUFFER.                                                    *
* /********************************************************************
*                    /*************************************************
*                    /**  FILL OUTPUT BUFFER WITH FILL CHAR.          *
*                    /*************************************************
*  A7A12:    OUTREC -> AREA(1) = FILLCH;
A7A12    L     @1,308(0,@5)        
         MVC   0(1,@1),20(@4)                                     0115
*                                   /*CALL MOVEROUT TO FILL OUTPUT REC.
*                                   /*SETUP PARAMETERS FOR MOVEROUT.*/
*            R6 = OUTREC            /*FROM FIELD.*/;
         L     @6,308(0,@5)                                       0116
*            R7 = OUTREC + 1        /*TO FIELD.*/;
         LA    @7,1                                               0117
         A     @7,308(0,@5)                                       0117
*            R8 = OUTRECSZ - 1      /*LENGTH - 1. */;
         LH    @8,@D2                                             0118
         AH    @8,658(0,@5)                                       0118
*         CALL MOVEROUT;
         BAL   @E,MOVEROUT                                        0119
*                                   /*INITIALIZE FD FIELD LOCATION    *
*                                   /* TO 1ST BYTE OF DATA IN RECORD. *
*            CUROUT = RECOFFST;
         MVC   357(1,@5),661(@5)                                  0120
         MVI   356(@5),X'00'                                      0120
*                                   /*INITIALIZE PICTURE LOCATION     *
*                                   /* TO 1ST BYTE OF DATA IN RECORD. *
*            PICEND = RECOFFST;
         MVC   629(1,@5),661(@5)                                  0121
         MVI   628(@5),X'00'                                      0121
*                                   /*IF V RECFM INIT. LENGTH DESCRIP-
*                                   /* TOR FIELD TO 4.
*         IF OUTRECFM = '40'X THEN LLFLD = 4;
         CLI   662(@5),X'40'                                      0122
         BC    07,@9F0                                            0122
         LA    @F,4                                               0123
         L     @1,308(0,@5)        
         STH   @F,0(0,@1)                                         0123
*                    /*************************************************
*                    /**  READ A RECORD FROM THE INPUT DATA SET.      *
*                    /**    'SYSINEOD' SW. IS TURNED ON WHEN THE SYSIN*
*                    /**      DELIMITER IS READ.                      *
*                    /**    'EODSW' SW. IN THE INPUT DCB TABLE IS     *
*                    /**      TURNED ON WHEN AN END-OF-DATA OCCURS ON *
*                    /**      A NON-SYSIN DATA SET.                   *
*                    /*************************************************
*                                   /*TEST IF INPUT DCB IS PRESENT.*/
*         IF IDCBPTR = 0 THEN GO TO A7A18;
@9F0     SR    @F,@F                                              0124
         C     @F,8(0,@4)                                         0124
         BC    08,A7A18                                           0125
*                                   /*TEST IF INPUT DCB IS SYSIN. */
*         IF IDCBPTR = ADDR(SYSI) THEN DO;
         LA    @F,116(0,@5)                                       0126
         C     @F,8(0,@4)                                         0126
         BC    07,@9EF                                            0126
*                                   /*TEST IF EOD ON SYSIN DCB. */
*         IF SYSINEOD = ON THEN GO TO A7A15;
         CLC   579(1,@5),ON                                       0128
         BC    08,A7A15                                           0129
*                                   /*GO TO ISSUE GET MACRO. */
*         GO TO A7A13;
         BC    15,A7A13                                           0130
*         END;
*                                   /*TEST IF EOD ON INPUT DCB. */
*         IF IDCBPTR -> EODSW = ON THEN GO TO A7A15;
@9EF     L     @1,8(0,@4)          
         CLC   268(1,@1),ON                                       0132
         BC    08,A7A15                                           0133
*                                   /*INPUT DCB FOR GET MACRO.*/
*  A7A13:    R1 = IDCBPTR;
A7A13    L     @1,8(0,@4)                                         0134
*                                   /** TEST IF INPUT DCB IS SYSIN **/
*         IF IDCBPTR = ADDR(SYSI) THEN DO;
         LA    @F,116(0,@5)                                       0135
         C     @F,8(0,@4)                                         0135
         BC    07,@9EE                                            0135
*                              /** TEST IF FIELD SELECTION ON SYSIN**/
*         IF SYSINSEL = ON THEN DO;
         CLC   636(1,@5),ON                                       0137
         BC    07,@9ED                                            0137
*                              /** READ SYSIN INTO INBUFA**/
*         R0 = ADDR(INBUFA);
         LA    @0,418(0,@5)                                       0139
*         GO TO GETINP;
         BC    15,GETINP                                          0140
*         END;
*                              /**INPUT IS SYSIN WITHOUT FIELD SELECT**
*                              /** READ SYSIN INTO OUTREC**/
*         GO TO GETIN;
*         END;
*                              /**TEST IF FIELD SELECT ON INPUT**/
*         IF IDCBPTR -> FIELDSEL = ON THEN DO ;
@9EE     L     @1,8(0,@4)          
         CLC   278(1,@1),ON                                       0144
         BC    07,@9EC                                            0144
*                              /**READ INPUT RECORD INTO INREC**/
*         R0 = IDCBPTR -> INREC;
         L     @0,272(0,@1)                                       0146
*         GO TO GETINP;
         BC    15,GETINP                                          0147
*         END;
* /********************************************************************
* /** INPUT IS WITHOUT FIELD SELECT AND THE INPUT RECORD CAN   YA01716*
* /** BE READ INTO OUTREC, BUT IF THE INPUT WORKAREA           YA01716*
* /** PREVIOUSLY HAS BEEN EXTENDED WITH A KEYFIELD THEN THE    YA01716*
* /** OUTPUT WORKAREA MUST HAVE THE SAME SIZE AS THE INPUT     YA01716*
* /** WORKAREA, IN THIS CASE A FREEMAIN ON THE OUTPUT WORKAREA YA01716*
* /** AND A NEW GETMAIN WITH THE SAME SIZE AS THE INPUT        YA01716*
* /** WORKAREA WILL BE DONE                                    YA01716*
* /********************************************************************
*              DCBPTR = IDCBPTR; /* REINITILIZE DCB POINTER     YA01716
@9EC     MVC   300(4,@5),8(@4)                                    0149
*              R15 = GMLGTH; /* PICK UP INPUT WORKAREA LENGTH   YA01716
         L     @1,300(0,@5)        
         LH    @F,276(0,@1)                                       0150
*              DCBPTR = FIRSTGMO; /* REINITILIZE DCB POINTER    YA01716
         MVC   300(4,@5),380(@5)                                  0151
*                        /* TEST IF INPUT WORKAREA EXEEDS       YA01716
*                        /* OUTPUT WORKAREA                     YA01716
*              IF R15 > GMLGTH THEN DO;                       /*YA01716
         L     @1,300(0,@5)        
         CH    @F,276(0,@1)                                       0152
         BC    12,@9EB                                            0152
*              R7 = GMLGTH; /* PICK UP OUTPUT WORKAREA LENGHT   YA01716
         LH    @7,276(0,@1)                                       0154
*              R6 = ADDR(OUTREC); /* GET OUTPUT WORKAREA PTR    YA01716
         LA    @6,308(0,@5)                                       0155
*              R1 = ADDR(GETMLIST);                           /*YA01716
         LA    @1,364(0,@5)                                       0156
*                        /* FREEMAIN THE 'OLD' OUTPUT           YA01716
*                        /* WORKAREA                            YA01716
* GEN ( FREEMAIN E,LV=(R7),A=(R6),SP=0,MF=(E,(R1)));          /*YA01716
          FREEMAIN E,LV=(R7),A=(R6),SP=0,MF=(E,(R1))
         DS    0H
*              DCBPTR = IDCBPTR; /* REINITILIZE DCB POINTER     YA01716
         MVC   300(4,@5),8(@4)                                    0158
*              R6 = GMLGTH; /* PICK UP INPUT WORKAREA LENGHT    YA01716
         L     @1,300(0,@5)        
         LH    @6,276(0,@1)                                       0159
*              R8 = ADDR(GCADDR); /* GET GC ADDRESS             YA01716
         LA    @8,376(0,@5)                                       0160
*              R1 = ADDR(GETMLIST);                           /*YA01716
         LA    @1,364(0,@5)                                       0161
*                        /* GETMAIN FOR THE 'NEW'               YA01716
*                        /* OUTPUT WORKAREA                     YA01716
* GEN ( GETMAIN EC,LV=(R6),A=(R8),SP=0,MF=(E,(R1)));          /*YA01716
          GETMAIN EC,LV=(R6),A=(R8),SP=0,MF=(E,(R1))
         DS    0H
*        IF R15 > 0 THEN DO; /* IS GETMAIN NOT SUCCESSESFUL     YA01716
         LTR   @F,@F                                              0163
         BC    12,@9EA                                            0163
*        MS = 10; /*INDICATE MESSAGE                            YA01716
         LA    @F,10                                              0165
         STH   @F,406(0,@5)                                       0165
*        SYSISW = OFF;                                        /*YA01716
         MVC   569(1,@5),OFF                                      0166
*        FLUSHSW = ON;                                        /*YA01716
         MVC   572(1,@5),ON                                       0167
*        GO TO ERROR1;                                        /*YA01716
         BC    15,ERROR1                                          0168
*        END;                                                 /*YA01716
*        DCBPTR = FIRSTGMO; /* REINITILIZE DCB POINTER          YA01716
@9EA     MVC   300(4,@5),380(@5)                                  0170
*        GMLGTH = R6; /* SAVE LENGHT                            YA01716
         L     @1,300(0,@5)        
         STH   @6,276(0,@1)                                       0171
*        OUTREC = GCADDR; /* INIT ADDR FOR OUTPUT WORKAREA      YA01716
         MVC   308(4,@5),376(@5)                                  0172
*        END;                                                 /*YA01716
*                              /** SET READIN ADDRESS TO OUTREC**/
*  GETIN:;
@9EB     EQU   *                                                  0174
*         R1 = IDCBPTR;                                       /*YA01716
GETIN    L     @1,8(0,@4)                                         0175
*         R0 = OUTREC;
         L     @0,308(0,@5)                                       0176
*  GETINP:;
*                              /** GET INPUT RECORD **/
*            GEN( GET  (R1),(R0));
GETINP    GET  (R1),(R0)
         DS    0H
*                                   /*TEST IF INPUT DCB IS SYSIN. */
*         IF IDCBPTR = ADDR(SYSI) THEN DO;
         LA    @F,116(0,@5)                                       0179
         C     @F,8(0,@4)                                         0179
         BC    07,@9E9                                            0179
*                              /** TEST IF FIELD SEL ON SYSIN**/
*         IF SYSINSEL = ON THEN DO;
         CLC   636(1,@5),ON                                       0181
         BC    07,@9E8                                            0181
*                              /**TEST FOR DELIMITER IN INBUFA**/
*         IF INBUFA(1:4) ^= DELIM THEN GO TO A7A18;
         CLC   418(4,@5),344(@5)                                  0183
         BC    07,A7A18                                           0184
*         INBUFA(1:4) = '    ' /**BLANK DELIM IN INBUFA **/;
         MVC   418(4,@5),@C6                                      0185
*                              /**GO TO SET SYSIN EOD SW**/
*         GO TO A7A135;
         BC    15,A7A135                                          0186
*       END;
*                                   /*TEST IF DELIMITER CARD WAS READ.
*         IF OUTREC -> AREA(1:4) ^= DELIM THEN GO TO A7A18;
@9E8     L     @1,308(0,@5)        
         CLC   0(4,@1),344(@5)                                    0188
         BC    07,A7A18                                           0189
*  A7A135:;
*                                   /*TURN ON SYSIN EOD SWITCH. */
*            SYSINEOD = ON;
A7A135   MVC   579(1,@5),ON                                       0191
*                              /***************************************
*                              /**REFILL OUTPUT BUFFER WITH FILL CHAR.*
*                              /**  BECAUSE DELIMITER WAS READ INTO   *
*                              /**  BUFFER.                           *
*                              /***************************************
*            OUTREC -> AREA(1) = FILLCH;
         L     @1,308(0,@5)        
         MVC   0(1,@1),20(@4)                                     0192
*                                   /*SETUP PARAMETERS FOR MOVEROUT. */
*            R6 = OUTREC            /*FROM FIELD. */;
         L     @6,308(0,@5)                                       0193
*            R7 = OUTREC + 1        /*TO FIELD. */;
         LA    @7,1                                               0194
         A     @7,308(0,@5)                                       0194
*            R8 = OUTRECSZ - 1      /*LENGTH - 1. */;
         LH    @8,@D2                                             0195
         AH    @8,658(0,@5)                                       0195
*         CALL MOVEROUT             /*LINK TO MOVEROUT. */;
         BAL   @E,MOVEROUT                                        0196
*         GO TO A7A15;
         BC    15,A7A15                                           0197
*         END;
*         GO TO A7A18;
*                              /***************************************
*                              /**EODAD ENRTY FOR SYSIN DCB           *
*                              /***************************************
*  A7EOD:;                                                   /*@ZA24201
*         DCBPTR -> EODSW = ON;                              /*@ZA26202
A7EOD    L     @1,300(0,@5)        
         MVC   268(1,@1),ON                                       0201
*         GO TO A7A135;                                      /*@ZA24201
         BC    15,A7A135                                          0202
*                              /***************************************
*                              /**EODAD ENTRY FOR INPUT DCB (EXCEPT   *
*                              /**  SYSIN).                           *
*                              /***************************************
*  A7EODAD:;
*                                   /*TURN ON EODSW IN INPUT DCB TABLE.
*            IDCBPTR -> EODSW = ON;
A7EODAD  L     @1,8(0,@4)          
         MVC   268(1,@1),ON                                       0204
*                                   /*TEST IF EODSTOP SWITCH IS ON, IF
*                                   /* SO TERMINATE GENERATION FOR THIS
*                                   /* CREATE ENTRY.
*  A7A15: IF EODSTOP = ON THEN GO TO A7A56;
A7A15    CLC   556(1,@5),ON                                       0205
         BC    08,A7A56                                           0206
*                    /*************************************************
*                    /**  PROCESS FD NAMES.                           *
*                    /**    R9 IS USED AS A BASE REG. FOR THE FD TABLE*
*                    /**     AND MUST BE PRESERVED ACROSS MOST OF     *
*                    /**     THIS SECTION.                            *
*                    /**    'CUROUT' POINTS TO THE OFFSET             *
*                    /**     IN THE RECORD WHERE THE NEXT FD FIELD    *
*                    /**     BEGINS UNLESS START LOC. WAS SPECIFIED   *
*                    /**     ON THE FD CARD.                          *
*                    /**    'FDOBUF' IN THE FD TABLE SPECIFIES THE    *
*                    /**     OFFSET IN THE RECORD FOR FD START LOC.   *
*                    /**     (EXCLUDING THE LENGTH DESCRIPTOR IF      *
*                    /**     V RECFM).                                *
*                    /*************************************************
*                                   /*TEST IF ANY FD ADRS. FOR THIS */
*                                   /* CREATE ENTRY.                */
*  A7A18: IF FDADTAB = 0 THEN GO TO A7A14;
A7A18    SR    @F,@F                                              0207
         C     @F,24(0,@4)                                        0207
         BC    08,A7A14                                           0208
*                                   /*POINT TO 1ST FD ADR. TABLE GM. */
*            CURFDGM = FDADTAB;
         MVC   632(4,@5),24(@4)                                   0209
*                                   /*POINT TO 1ST FD ADR. IN GM. */
*  A7B1:     CURFD = CURFDGM + 4;
A7B1     LA    @F,4                                               0210
         A     @F,632(0,@5)                                       0210
         ST    @F,352(0,@5)                                       0210
*                                   /*PUT FD ADR. IN BASE PTR. */
*  A7B2:     R9 = CURFD -> FDADR;
A7B2     L     @1,352(0,@5)        
         L     @9,0(0,@1)                                         0211
*                                   /*TEST IF FD STARTLOC SPECIFIED. */
*         IF STRTLOC1 = '1'B THEN DO;
         TM    62(@9),B'10000000'                                 0212
         BC    12,@9E7                                            0212
*                                   /*UPDATE CURRENT OUTPUT LOCATION */
*                                   /* WITH FD STARTLOC.             */
*            CUROUT = FDOBUF + RECOFFST;
         SR    @F,@F                                              0214
         IC    @F,661(0,@5)                                       0214
         AH    @F,40(0,@9)                                        0214
         STH   @F,356(0,@5)                                       0214
*         END;
*                                   /*TEST IF FD FIELD OVERFLOWS OUTPUT
*                                   /* RECORD.
*         IF CUROUT + FDLGTH > OUTRECSZ THEN DO;
@9E7     LH    @F,24(0,@9)                                        0216
         AH    @F,356(0,@5)                                       0216
         CH    @F,658(0,@5)                                       0216
         BC    12,@9E6                                            0216
*                                   /*FD FIELD OVERFLOWS. */
*                                   /*GO TO ISSUE MSG 16. */
*         GO TO A7A16;
         BC    15,A7A16                                           0218
*         END;
*                              /***************************************
*                              /**FILL FD FIELD WITH BLANKS.          *
*                              /** IN CASE OF SHIFT OR TRUNCATE ACT-  *
*                              /** IONS, ONLY A PROTION OF THE FIELD  *
*                              /** MAY BE MOVED IN.                   *
*                              /***************************************
*                                   /*SETUP PARAMETERS FOR MOVEROUT
*                                   /*PUT FD LENGTH - 1 IN R8. */
*            R8 = FDLGTH - 1;
@9E6     LH    @8,@D2                                             0220
         AH    @8,24(0,@9)                                        0220
*                                   /*FROM ADR. IN R6. */
*            R6 = CUROUT + OUTREC;
         L     @6,308(0,@5)                                       0221
         AH    @6,356(0,@5)                                       0221
*                                   /*TO ADR. IN R7. */
*            R7 = CUROUT + OUTREC + 1;
         LA    @7,1                                               0222
         A     @7,308(0,@5)                                       0222
         AH    @7,356(0,@5)                                       0222
*                                   /*MOVE A BLANK INTO 1ST CHAR. OF */
*                                   /* FD FIELD.                     */
*            R6 -> AREA(1) = ' ';
         MVI   0(@6),C' '                                         0223
*                                   /*CALL MOVEROUT TO BLANK FD FIELD.
*         CALL MOVEROUT;
         BAL   @E,MOVEROUT                                        0224
*                              /***************************************
*                              /**MOVE FD FIELD TO OUTPUT RECORD.     *
*                              /***************************************
*                                   /*GET LENGTH OF PATTERN TO MOVE. */
*            R8 = FDMLGTH;
         LH    @8,48(0,@9)                                        0225
*                                   /*RESOLVE FROM ADR. */
*            R6 = FDFROMAD + FDFRINC;
         LH    @6,42(0,@9)                                        0226
         AL    @6,44(0,@9)                                        0226
*                                   /*RESOLVE TO ADR. IN OUTPUT RECORD.
*            R7 = CUROUT + OUTREC + FDTOINC;
         LH    @7,50(0,@9)                                        0227
         A     @7,308(0,@5)                                       0227
         AH    @7,356(0,@5)                                       0227
*                                   /*CALL MOVEROUT TO MOVE FD PATTERN
*                                   /* TO OUTPUT RECORD.
*         CALL MOVEROUT;
         BAL   @E,MOVEROUT                                        0228
*                              /***************************************
*                              /** 'PASS' BIT IN FD TABLE IS USED IN  *
*                              /**  PROCESS FD TABLES SECTION         *
*                              /***************************************
*                                   /*CLEAR PASS BIT IN FD TABLE. */
*            PASS = '0'B;
         NI    32(@9),B'10111111'                                 0229
*                                   /*UPDATE CURRENT OUTPUT LOCATION. *
*            CUROUT = CUROUT + FDLGTH;
         LH    @F,24(0,@9)                                        0230
         AH    @F,356(0,@5)                                       0230
         STH   @F,356(0,@5)                                       0230
*                                   /*UPDATE PTR. TO NEXT FD ADR. */
*            CURFD = CURFD + 4;
         LA    @F,4                                               0231
         A     @F,352(0,@5)                                       0231
         ST    @F,352(0,@5)                                       0231
*                                   /*TEST IF LAST FD ADR. IN GM. */
*         IF CURFD -> AREA(1:4) ^= 0 THEN GO TO A7B2;
         L     @1,352(0,@5)        
         CLC   0(4,@1),@D1                                        0232
         BC    07,A7B2                                            0233
*                                   /*TEST IF ANOTHER FD ADR. GM. */
*         IF CURFDGM -> NXTFDGM = 0 THEN GO TO A7A14;
         SR    @F,@F                                              0234
         L     @2,632(0,@5)        
         C     @F,0(0,@2)                                         0234
         BC    08,A7A14                                           0235
*                                   /*GET ADR. OF NEXT FD ADR. GM. */
*            CURFDGM = CURFDGM -> NXTFDGM;
         MVC   632(4,@5),0(@2)                                    0236
*                                   /*LOOP BACK TO PROCESS MORE FD ADRS
*         GO TO A7B1;
         BC    15,A7B1                                            0237
*                    /*************************************************
*                    /**  PROCESS CREATE PICTURE.                     *
*                    /**    'PICSTLOC' POINTS TO THE OFFSET IN THE    *
*                    /**     RECORD WHERE THE PICTURE BEGINS (EXCLUD- *
*                    /**     ING THE LENGTH DESCRIPTOR IF V RECFM).   *
*                    /*************************************************
*  A7A14:;
*                                   /*TEST IF PICTURE IS PRESENT.*/
*         IF PICPTR = 0 THEN GO TO A7A2;
A7A14    SR    @F,@F                                              0239
         C     @F,16(0,@4)                                        0239
         BC    08,A7A2                                            0240
*                                   /*CALCULATE END LOC. OF PICTURE. */
*            PICEND = PICPTR -> PICSTLOC + PICPTR -> PICLGTH + RECOFFST
         IC    @F,661(0,@5)                                       0241
         L     @1,16(0,@4)         
         AH    @F,4(0,@1)                                         0241
         A     @F,0(0,@1)                                         0241
         STH   @F,628(0,@5)                                       0241
*                                   /*TEST IF PICTURE OVERFLOWS OUTPUT
*                                   /* RECORD.
*         IF PICEND > OUTRECSZ THEN DO;
         LH    @F,658(0,@5)                                       0242
         CH    @F,628(0,@5)                                       0242
         BC    10,@9E5                                            0242
*                                   /*PICTURE OVERFLOWS. */
*  A7A16:    MS = 16;
A7A16    LA    @F,16                                              0244
         STH   @F,406(0,@5)                                       0244
*         GO TO ERROR1;
         BC    15,ERROR1                                          0245
*         END;
*                              /***************************************
*                              /**MOVE PICTURE STRING INTO OUTPUT     *
*                              /**  RECORD STARTING AT PICTURE START  *
*                              /**  LOCATION.                         *
*                              /***************************************
*                                   /*SETUP PARAMETERS FOR MOVEROUT TO
*                                   /* MOVE PICTURE.
*            R6 = PICPTR + 6        /*FROM ADDRESS.*/;
@9E5     LA    @6,6                                               0247
         A     @6,16(0,@4)                                        0247
*                                   /*TO ADDRESS. */
*            R7 = OUTREC + PICPTR -> PICSTLOC + RECOFFST;
         SR    @F,@F                                              0248
         IC    @F,661(0,@5)                                       0248
         L     @1,16(0,@4)         
         A     @F,0(0,@1)                                         0248
         A     @F,308(0,@5)                                       0248
         LR    @7,@F                                              0248
*            R8 = PICPTR -> PICLGTH         /*LENGTH.      */;
         LH    @8,4(0,@1)                                         0249
*                                   /*CALL MOVEROUT.*/
*         CALL MOVEROUT;
         BAL   @E,MOVEROUT                                        0250
*                    /*************************************************
*                    /** SETUP LENGTH DESCRIPTOR FIELD IF V RECFM .   *
*                    /**   DESCRIPTOR FIELD CONTAINS 4 UNLESS AN      *
*                    /**    INPUT RECORD WAS READ.                    *
*                    /*************************************************
*  A7A2:;
*                                   /*TEST IF V TYPE RECORDS. */
*         IF OUTRECFM = '40'X THEN DO;
A7A2     CLI   662(@5),X'40'                                      0252
         BC    07,@9E4                                            0252
*                                   /*TEST IF END LOCATION OF FD IS GT
*                                   /* LL FIELD.
*         IF CUROUT > LLFLD THEN LLFLD = CUROUT;
         L     @1,308(0,@5)        
         LH    @F,0(0,@1)                                         0254
         CH    @F,356(0,@5)                                       0254
         BC    10,@9E3                                            0254
         MVC   0(2,@1),356(@5)                                    0255
*                                   /*TEST IF END LOCATION OF PICTURE *
*                                   /* IS GT LL FIELD.
*         IF PICEND > LLFLD THEN LLFLD = PICEND;
@9E3     LH    @F,0(0,@1)                                         0256
         CH    @F,628(0,@5)                                       0256
         BC    10,@9E2                                            0256
         MVC   0(2,@1),628(@5)                                    0257
*                              /***************************************
*                              /**IF LL FIELD IS 4, THEN NO INPUT     *
*                              /** RECORD, FD FIELD, OR PICTURE IS    *
*                              /** PRESENT.  MAKE LL FIELD EQUAL TO   *
*                              /** OUTPUT LRECL.                      *
*                              /***************************************
*         IF LLFLD = 4 THEN DO;
@9E2     LA    @F,4                                               0258
         CH    @F,0(0,@1)                                         0258
         BC    07,@9E1                                            0258
*                                   /*PUT LRECL IN LL FIELD. */
*            LLFLD = FIRSTGMO -> LRECL;
         L     @2,380(0,@5)        
         MVC   0(2,@1),82(@2)                                     0260
*         END;
*                                   /*CLEAR LAST 2 BYTES OF DESCRIPTOR
*                                   /* FIELD.
*            OUTREC -> AREA(3:4) = '0000'X;
@9E1     L     @1,308(0,@5)        
         MVC   2(2,@1),@X3                                        0262
*         END;
* /********************************************************************
* /**  GO TO USER EXIT ROUTINE IF PRESENT.                            *
* /**    REG. 1 CONTAINS ADR. OF OUTPUT RECORD.                       *
* /**    USER'S ROUTINE MUST PASS BACK A RETURN CODE IN REG. 15.      *
* /********************************************************************
*                                   /*TEST IF USER EXIT PRESENT.*/
*         IF EXITADR = 0 THEN GO TO A7A4;
@9E4     SR    @F,@F                                              0264
         C     @F,12(0,@4)                                        0264
         BC    08,A7A4                                            0265
*                                   /*PASS OUTPUT RECORD TO USER IN R1.
*            R1 = OUTREC;
         L     @1,308(0,@5)                                       0266
*                                   /*SET R15 TO ADR OF EXIT ROUTINE.*/
*            R15 = EXITADR;
         L     @F,12(0,@4)                                        0267
*                                   /*GO TO USER ROUTINE.*/
*            GEN( BALR  14,15);
          BALR  14,15
         DS    0H
*                    /*************************************************
*                    /** USER PASSES A RETURN CODE IN REG. 15 AS      *
*                    /**   FOLLOWS-                                   *
*                    /**    0  WRITE THE RECORD.                      *
*                    /**    4  SKIP THE RECORD (COUNTS AS 1 RECORD    *
*                    /**       IN THE QUANTITY OF RECORDS TO BE       *
*                    /**       WRITTEN).                              *
*                    /**   12  END GENERATION FOR THIS DSD GROUP.     *
*                    /**   16  END GENERATION FOR ENTIRE JOB STEP.    *
*                    /*************************************************
*                                   /*TEST RETURN CODE FROM USER IN
*                                   /* REG. 15.
*            R6 = R15;
         LR    @6,@F                                              0269
*         IF R6 = 0 THEN GO TO A7A4;
         LTR   @6,@6                                              0270
         BC    08,A7A4                                            0271
*         IF R6 = 4 THEN GO TO A7C1;
         CH    @6,@D3                                             0272
         BC    08,A7C1                                            0273
*         IF R6 = 12 THEN DO;
         CH    @6,@D4                                             0274
         BC    07,@9E0                                            0274
*                                   /*SET CONDITION CODE TO 8. */
*            CONCODE = 8;
         LA    @F,8                                               0276
         STH   @F,306(0,@5)                                       0276
*                                   /*TURN ON FLUSHSW. */
*            FLUSHSW = ON;
         MVC   572(1,@5),ON                                       0277
*                                   /*GO TO CREATE CLEAN UP. */
*         GO TO A7A6;
         BC    15,A7A6                                            0278
*         END;
*         IF R6 = 16 THEN DO;
@9E0     CH    @6,@D5                                             0280
         BC    07,@9DF                                            0280
*                                   /*SET CONDITION CODE TO 4. */
*            CONCODE = 4;
         LA    @F,4                                               0282
         STH   @F,306(0,@5)                                       0282
*                                   /*TURN ON FLUSHSW1. */
*            FLUSHSW1 = ON;
         MVC   573(1,@5),ON                                       0283
*                                   /*GO TO CREATE CLEAN UP. */
*         GO TO A7A6;
         BC    15,A7A6                                            0284
*         END;
*                                   /*USER DIDN'T RETURN A VALID RETURN
*                                   /* CODE.
*            MS = 9;
@9DF     LA    @F,9                                               0286
         STH   @F,406(0,@5)                                       0286
*         GO TO ERROR1;
         BC    15,ERROR1                                          0287
* /********************************************************************
* /**  WRITE THE OUTPUT RECORD.                                       *
* /********************************************************************
*  A7A4:;
*                                   /*OUTPUT DCB FOR PUT MACRO.*/
*            R1 = FIRSTGMO;
A7A4     L     @1,380(0,@5)                                       0289
*      IF OUTRECFM='C0'X THEN DO ;          /* RECFM=U          A45152*
         CLI   662(@5),X'C0'                                      0290
         BC    07,@9DE                                            0290
*     R1->LRECL = CUROUT;
         MVC   82(2,@1),356(@5)                                   0292
*     IF  PICEND>CUROUT  THEN  R1->LRECL  = PICEND;
         LH    @F,356(0,@5)                                       0293
         CH    @F,628(0,@5)                                       0293
         BC    10,@9DD                                            0293
         MVC   82(2,@1),628(@5)                                   0294
*        IF R1 -> LRECL = 0 THEN DO ;   /* NO FD CARD NOR PICT  A45152*
@9DD     SR    @F,@F                                              0295
         CH    @F,82(0,@1)                                        0295
         BC    07,@9DC                                            0295
*          IF IDCBPTR = 0 THEN DO; /*  NO INPUT DCB           @YA02528*
         C     @F,8(0,@4)                                         0297
         BC    07,@9DB                                            0297
*             R1 -> LRECL = R1 -> BLKSI; /* MAKE LRECL SAME   @YA02528*
         MVC   82(2,@1),62(@1)                                    0299
*                                       /* AS BLKSIZE         @YA02528*
*         GO TO PUTOUT;                                     /*@YA02528*
         BC    15,PUTOUT                                          0300
*          END;                                             /*@YA02528*
*             R14 = IDCBPTR ;           /* INIT INPUT DCB       A45152*
@9DB     L     @E,8(0,@4)                                         0302
*             R1 -> LRECL = R14 -> LRECL ; /* STRAIGT COPY      A45152*
         MVC   82(2,@1),82(@E)                                    0303
*        END ;                          /* OUTPUT REC. EQU INPUTA45152*
*     END;
@9DC     EQU   *                                                  0305
* PUTOUT:;                        /*OUTPUT AREA FOR PUT MACRO @YA02528*
@9DE     EQU   *                                                  0306
*            R0 = OUTREC;
PUTOUT   L     @0,308(0,@5)                                       0307
*                                   /*WRITE OUTPUT RECORD.*/
*            GEN( PUT  (R1),(R0));
          PUT  (R1),(R0)
         DS    0H
*                                   /*GO TO PROCESS FD TABLES. */
*         GO TO A7C1;
         BC    15,A7C1                                            0309
* /********************************************************************
* /**    SYNAD ENTRY FOR INPUT OR OUTPUT DCB.                         *
* /**       THIS SECTION IS ENTERED BY THE ACCESS METHOD WHEN A       *
* /**        PERMANENT I/O ERROR OCCURS.  SYNADAF MACRO IS ISSUED     *
* /**        TO GET INFORMATION ABOUT THE ERROR.  THIS INFORMATION IS *
* /**        PRINTED IN MESSAGE 29.                                   *
* /********************************************************************
*  A7SYNAD:;
*                                   /*MOVE FIRST PORTION OF MSG 29 */
*                                   /* INTO BUFFER.                */
*            INBUFA1 = ' IEB729I PERMANENT I/O ERROR';
A7SYNAD  MVC   408(28,@5),@C8                                     0311
         MVI   436(@5),C' '                                       0311
         MVC   437(92,@5),436(@5)                                 0311
*              R1 = FIRSTGMO;      /*GET OUTPUT DCB ADDRESS   @ZA03396*
         L     @1,380(0,@5)                                       0312
*         IF R1 -> DSORG = '80'X THEN DO /**IF ISAM USE ISAM SYNADAF **
         CLI   26(@1),X'80'                                       0313
         BC    07,@9DA                                            0313
*         GEN ( SYNADAF ACSMETH=QISAM);
          SYNADAF ACSMETH=QISAM
         DS    0H
*               GO TO A7SYNAD5           /**BR TO MOVE INFO AND RLSE**/
         BC    15,A7SYNAD5                                        0316
*         END;
*                                   /*ISSUE SYNADAF MACRO. */
*                                   /*SYNADAF RETURNS AN ADDRESS OF THE
*                                   /* DATA IN REG. 1.  THE DATA TO BE
*                                   /* PRINTED IS AT AN OFFSET OF 49.
*            GEN( SYNADAF  ACSMETH=QSAM );
@9DA     EQU   *                                                  0318
          SYNADAF  ACSMETH=QSAM
         DS    0H
*              GO TO A7SYNAD5; /*BR TO MOVE INFO AND RLSE     @ZA03396*
         BC    15,A7SYNAD5                                        0319
*  A7SYNAD1:;                                               /*@ZA03396*
*  /*MOVE FIRST PORTION OF MSG 29 INTO BUFFER                 @ZA03396*
*            INBUFA1 = ' IEB729I PERMANENT I/O ERROR';      /*@ZA03396*
A7SYNAD1 MVC   408(28,@5),@C8                                     0321
         MVI   436(@5),C' '                                       0321
         MVC   437(92,@5),436(@5)                                 0321
*              R1 = IDCBPTR;       /*GET INPUT DCB ADDRESS    @ZA03396*
         L     @1,8(0,@4)                                         0322
*  /*IF ISAM USE ISAM SYNADAF                                 @ZA03396*
*         IF R1 -> DSORG = '80'X  THEN DO;                  /*@ZA03396*
         CLI   26(@1),X'80'                                       0323
         BC    07,@9D9                                            0323
*         GEN ( SYNADAF ACSMETH=QISAM);                     /*@ZA03396*
          SYNADAF ACSMETH=QISAM
         DS    0H
*              GO TO A7SYNAD5; /*BR TO MOVE INFO AND RLSE     @ZA03396*
         BC    15,A7SYNAD5                                        0326
*          END;                                             /*@ZA03396*
*  /*ISSUE SYNADAF MACRO. SYNADAF RETURNS AN ADDRESS OF THE   @ZA03396*
*  /*DATA IN REG1. THE DATA TO BE PRINTED IS AT OFFSET 49     @ZA03396*
*           GEN ( SYNADAF ACSMETH=QSAM);                    /*@ZA03396*
@9D9     EQU   *                                                  0328
          SYNADAF ACSMETH=QSAM
         DS    0H
*  A7SYNAD5:;
*                                   /*MOVE SYNAD INFORMATION TO BUFFER.
*            GEN( MVC  INBUFA1+28(79,5),49(1));
A7SYNAD5  MVC  INBUFA1+28(79,5),49(1)
         DS    0H
*         GEN ( SYNADRLS);
          SYNADRLS
         DS    0H
*                                   /*SET CONDITION CODE TO 12. */
*            CONCODE = 12;
         LA    @F,12                                              0332
         STH   @F,306(0,@5)                                       0332
*                                   /*SET 'FLUSHSW1' TO TERMINATE STEP.
*            FLUSHSW1 = ON;
         MVC   573(1,@5),ON                                       0333
*                                   /*SET MS=30 TO CAUSE IEBMSG TO  */
*                                   /* PRINT MESSAGE IN 'INBUFA1'.  */
*            MS = 30;
         LA    @F,30                                              0334
         STH   @F,406(0,@5)                                       0334
*                                   /*GO TO SET AN ERROR RETURN AND */
*                                   /* CREATE CLEANUP.              */
*         GO TO ERROR;
         BC    15,ERROR                                           0335
* /********************************************************************
* /**  PROCESS FD TABLES.                                             *
* /**    ANY FD TABLES REFERENCED BY THE CREATE ENTRY MUST BE PRO-    *
* /**     CESSED FOR ACTION, INDEX, REANGE, AND CYCLE.  IF A TABLE    *
* /**     IS REFERENCED MORE THAN ONCE, IT IS ONLY PROCESSED ONCE.    *
* /**     THE 'PASS' BIT IN THE FD TABLE INDICATES THIS.              *
* /**    REG. 9 IS USED AS A BASE REG. FOR THE FD TABLE AND MUST BE   *
* /**     PRESERVED ACROSS MOST OF THIS SECTION.                      *
* /********************************************************************
*                                   /*TEST IF ANY FD ADRS. FOR THIS */
*                                   /* CREATE ENTRY.                */
*  A7C1:  IF FDADTAB = 0 THEN GO TO A7A5;
A7C1     SR    @F,@F                                              0336
         C     @F,24(0,@4)                                        0336
         BC    08,A7A5                                            0337
*                                   /*POINT TO 1ST FD ADR. TABLE GM. */
*            CURFDGM = FDADTAB;
         MVC   632(4,@5),24(@4)                                   0338
*                                   /*POINT TO 1ST FD ADR. IN GM. */
*  A7J1:     CURFD = CURFDGM + 4;
A7J1     LA    @F,4                                               0339
         A     @F,632(0,@5)                                       0339
         ST    @F,352(0,@5)                                       0339
*                                   /*PUT FD ADR. IN BASE PTR. */
*  A7J2:     R9 = CURFD -> FDADR;
A7J2     L     @1,352(0,@5)        
         L     @9,0(0,@1)                                         0340
*                                   /*TEST IF FD TABLE ALREADY */
*                                   /* PROCESSED.              */
*         IF PASS = '1'B THEN GO TO A7J3;
         TM    32(@9),B'01000000'                                 0341
         BC    01,A7J3                                            0342
*                                   /*TURN ON PASS BIT IN FD TABLE. */
*            PASS = '1'B;
         OI    32(@9),B'01000000'                                 0343
*                                   /*SAVE R4 TEMPORARILY. */
*            GCADDR = R4;
         ST    @4,376(0,@5)                                       0344
*                                   /*TEST IF NUACTION BIT ON. */
*         IF NUACTION = '0'B THEN GO TO A7R8;
         TM    32(@9),B'00000001'                                 0345
         BC    08,A7R8                                            0346
*                                   /*TEST IF RANDOM FORMAT. */
*         IF FDFORMAT = 'RA' THEN GO TO A7R6;
         CLC   30(2,@9),@C9                                       0347
         BC    08,A7R6                                            0348
*                    /*************************************************
*                    /** PROCESS INDEX, CYCLE, AND RANGE FUNCTIONS.   *
*                    /*************************************************
*                                   /*TEST IF INDEX NO. IS 0. */
*         IF FDINDNUM = 0 THEN GO TO ABCD;
         SR    @F,@F                                              0349
         C     @F,20(0,@9)                                        0349
         BC    08,ABCD                                            0350
*                                   /*TEST IF CYCLE IS 0. */
*         IF FDCYCLE = 0 THEN GO TO A7R1;
         CH    @F,26(0,@9)                                        0351
         BC    08,A7R1                                            0352
*                                   /*INCREMENT CYCLE CTR. */
*            FDCYCCNT = FDCYCCNT + 1;
         LA    @F,1                                               0353
         AH    @F,52(0,@9)                                        0353
         STH   @F,52(0,@9)                                        0353
*                                   /*TEST IF CYCLE CTR = CYCLE VALUE.
*         IF FDCYCCNT < FDCYCLE THEN GO TO ABCD;
         LH    @F,26(0,@9)                                        0354
         CH    @F,52(0,@9)                                        0354
         BC    02,ABCD                                            0355
*                                   /*SET CYCLE CTR TO 0. */
*  A7R1:     FDCYCCNT = 0;
A7R1     SR    @F,@F                                              0356
         STH   @F,52(0,@9)                                        0356
*                                   /*CLEAR 'Q' TO ZEROS. */
*            Q = Q && Q;
         XC    216(16,@5),216(@5)                                 0357
*                              /***************************************
*                              /**CONVERT ZONED DECIMAL NO.           *
*                              /** NO. IS PACKED INTO 'Q'.            *
*                              /***************************************
*                                   /*TEST IF ZD FORMAT. */
*         IF FDFORMAT = 'ZD' THEN DO;
         CLC   30(2,@9),@C10                                      0358
         BC    07,@9D8                                            0358
*                                   /*TEST IF FD LENGTH GT 15. */
*         IF FDLGTH > 15 THEN R6 = 15;
         LA    @F,15                                              0360
         CH    @F,24(0,@9)                                        0360
         BC    10,@9D7                                            0360
         LR    @6,@F                                              0361
         BC    15,@9D6                                            0362
*                                   /*ELSE, SET R6 TO FD LENGTH. */
*            ELSE R6 = FDLGTH;
@9D7     LH    @6,24(0,@9)                                        0362
*                                   /*CALCULATE FROM ADR. */
*            R7 = FDFROMAD + FDLGTH - R6;
@9D6     LCR   @7,@6                                              0363
         LH    @0,24(0,@9)                                        0363
         ALR   @7,@0                                              0363
         AL    @7,44(0,@9)                                        0363
*                                   /*PACK ZD NO. INTO 'Q'. */
*                                   /*DECREMENT LENGTH BY 1. */
*            R6 = R6 - 1;
         BCTR  @6,0                                               0364
*            GEN( EX  R6,PACK );
          EX  R6,PACK
         DS    0H
*         GO TO A7R2;
         BC    15,A7R2                                            0366
*         END;
*                              /***************************************
*                              /**CONVERT PACKED DECIMAL NO.          *
*                              /** NO. IS MOVED INTO 'Q'.             *
*                              /***************************************
*                                   /*TEST IF PD FORMAT. */
*         IF FDFORMAT = 'PD' THEN DO;
@9D8     CLC   30(2,@9),@C11                                      0368
         BC    07,@9D5                                            0368
*                                   /*TEST IF FD LENGTH GT 8. */
*         IF FDLGTH > 8 THEN R6 = 8;
         LA    @F,8                                               0370
         CH    @F,24(0,@9)                                        0370
         BC    10,@9D4                                            0370
         LR    @6,@F                                              0371
         BC    15,@9D3                                            0372
*                                   /*ELSE, SET R6 TO FD LENGTH. */
*            ELSE R6 = FDLGTH;
@9D4     LH    @6,24(0,@9)                                        0372
*                                   /*CALCULATE FROM ADR. */
*            R7 = FDFROMAD + FDLGTH - R6;
@9D3     LCR   @7,@6                                              0373
         LH    @0,24(0,@9)                                        0373
         ALR   @7,@0                                              0373
         AL    @7,44(0,@9)                                        0373
*                                   /*CALCULATE TO ADR. */
*            R8 = ADDR(Q) + 8 - R6;
         LCR   @F,@6                                              0374
         AH    @F,@D6                                             0374
         LA    @0,216(0,@5)                                       0374
         AR    @F,@0                                              0374
         LR    @8,@F                                              0374
*                                   /*MOVE PD NO. INTO 'Q'. */
*            R8 -> AREA(1:R6) = R7 -> AREA(1:R6);
         LR    @E,@7                                              0375
         LR    @1,@6                                              0375
         BCTR  @1,0                                               0375
         LR    @A,@8                                              0375
         EX    @1,@MVC                                            0375
*         GO TO A7R2;
         BC    15,A7R2                                            0376
*         END;
*                              /***************************************
*                              /**PROCESS BINARY NO.                  *
*                              /** NO. IS MOVED INTO REG 4.           *
*                              /***************************************
*                                   /*FORMAT MUST BE BI. */
*                                   /*TEST IF FD LENGTH GT 4. */
*         IF FDLGTH > 4 THEN R6 = 4;
@9D5     LA    @F,4                                               0378
         CH    @F,24(0,@9)                                        0378
         BC    10,@9D2                                            0378
         LR    @6,@F                                              0379
         BC    15,@9D1                                            0380
*                                   /*ELSE, SET R6 TO FD LENGTH. */
*            ELSE R6 = FDLGTH;
@9D2     LH    @6,24(0,@9)                                        0380
*                                   /*CALCULATE FROM ADR. */
*            R7 = FDFROMAD + FDLGTH - R6;
@9D1     LCR   @7,@6                                              0381
         LH    @0,24(0,@9)                                        0381
         ALR   @7,@0                                              0381
         AL    @7,44(0,@9)                                        0381
*                                   /*CALCULATE TO ADR. */
*            R8 = ADDR(Q) + 4 - R6;
         LCR   @F,@6                                              0382
         AH    @F,@D3                                             0382
         LA    @0,216(0,@5)                                       0382
         AR    @F,@0                                              0382
         LR    @8,@F                                              0382
*                                   /*MOVE BINARY NO. INTO 'Q'. */
*            R8 -> AREA(1:R6) = R7 -> AREA(1:R6);
         LR    @E,@7                                              0383
         LR    @1,@6                                              0383
         BCTR  @1,0                                               0383
         LR    @A,@8                                              0383
         EX    @1,@MVC                                            0383
*            R4 = Q(1:4);
         L     @4,216(0,@5)                                       0384
*         GO TO A7R3;
         BC    15,A7R3                                            0385
*                              /***************************************
*                              /**IF PD OR ZD FORMAT, CONVERT PACKED  *
*                              /** DECIMAL NO. TO BINARY.             *
*                              /***************************************
*                                   /*CONVERT PACKED NO. IN 'Q' TO */
*                                   /*BINARY.                      */
* A7R2:
*         IF Q(1:8) >= '000002147483647C'X THEN
A7R2     CLC   216(8,@5),@X12                                     0386
         BC    04,@9D0                                            0386
*         DO;
* MESS6:
*         MS = 6;
MESS6    LA    @F,6                                               0388
         STH   @F,406(0,@5)                                       0388
*         GOTO ERROR1;
         BC    15,ERROR1                                          0389
*         END;
*         GEN (CVB  R4,Q(R5));
@9D0     EQU   *                                                  0391
         CVB  R4,Q(R5)
         DS    0H
* A7R3:
*         R0 = FDINDNUM;
A7R3     L     @0,20(0,@9)                                        0392
* INDEXIT:
*         R0 = R0 - 1;
INDEXIT  LR    @F,@0                                              0393
         BCTR  @F,0                                               0393
         LR    @0,@F                                              0393
*         R4 = R4 + 1;
         AH    @4,@D7                                             0394
*         IF R4 = BINARYMX THEN DO;
         C     @4,BINARYMX                                        0395
         BC    07,@9CF                                            0395
*         IF R0 = 0 THEN
         LTR   @0,@0                                              0397
*         GOTO A7R33;
         BC    08,A7R33                                           0398
*         GOTO MESS6;
         BC    15,MESS6                                           0399
*         END;
*         IF R0 = 0 THEN
@9CF     LTR   @0,@0                                              0401
*         GOTO A7R33;
         BC    08,A7R33                                           0402
*         GOTO INDEXIT;
         BC    15,INDEXIT                                         0403
*                                   /*ADD INDEX NO. TO R4. */
*                              /***************************************
*                              /**AT THIS POINT REG. 4 CONTAINS THE   *
*                              /** INDEXED BINARY NO.  IT MUST NOW BE *
*                              /** CONVERTED BACK TO ITS ORIGINAL     *
*                              /** FORMAT.                            *
*                              /***************************************
*                                   /*TEST IF RANGE VALUE IS 0. */
* A7R33:
*         IF FDRANGE = 0 THEN GO TO A7R4;
A7R33    CLC   36(4,@9),@D1                                       0404
         BC    08,A7R4                                            0405
*                                   /*TEST IF VALUE EXCEEDS RANGE. */
*                                   /*IF YES, DONT CHANGE VALUE IN FD *
*                                   /* TABLE.                         *
*         IF R4 > FDRANC  THEN GO TO ABCD;
         C     @4,36(0,@9)                                        0406
         BC    02,ABCD                                            0407
*                                   /*TEST IF BI FORMAT. */
*  A7R4:  IF FDFORMAT = 'BI' THEN DO;
A7R4     CLC   30(2,@9),@C13                                      0408
         BC    07,@9CE                                            0408
*                                   /*PUT NO. IN 'Q'. */
*            Q(1:4) = R4;
         ST    @4,@TEMP4                                          0410
         MVC   216(4,@5),@TEMP4                                   0410
*         GO TO A7R5;
         BC    15,A7R5                                            0411
*         END;
*                                   /*CONVERT BINARY NO. TO PACKED */
*                                   /* DECIMAL.                    */
*            GEN( CVD  R4,Q(R5));
@9CE     EQU   *                                                  0413
          CVD  R4,Q(R5)
         DS    0H
*                                   /*TEST IF PD FORMAT. */
*         IF FDFORMAT = 'PD' THEN DO;
         CLC   30(2,@9),@C11                                      0414
         BC    07,@9CD                                            0414
*                                   /*MOVE PACKED NO. OR BINARY NO. */
*                                   /* INTO FD FIELD.               */
*  A7R5:     R7 -> AREA(1:R6) = R8 -> AREA(1:R6);
A7R5     LR    @E,@8                                              0416
         LR    @1,@6                                              0416
         BCTR  @1,0                                               0416
         LR    @A,@7                                              0416
         EX    @1,@MVC                                            0416
*         GO TO ABCD;
         BC    15,ABCD                                            0417
*         END;
*                                   /*TEST IF ZD FORMAT. */
*         IF FDFORMAT = 'ZD' THEN DO;
@9CD     CLC   30(2,@9),@C10                                      0419
         BC    07,@9CC                                            0419
*                                   /*SHIFT R6 LEFT 4 BITS FOR UNPACK *
*                                   /* INSTRUCTION.                   *
*            R6 = R6 * 16;
         SLA   @6,4                                               0421
*                                   /*UNPACK NO. INTO FD FIELD. */
*            GEN( EX  R6,UNPACK);
          EX  R6,UNPACK
         DS    0H
*                                   /*CALCULATE ADR. OF LO-ORDER BYTE *
*                                   /* OF FD FIELD.                   *
*            R4 = FDFROMAD + FDLGTH - 1;
         L     @4,@D8                                             0423
         LH    @0,24(0,@9)                                        0423
         ALR   @4,@0                                              0423
         AL    @4,44(0,@9)                                        0423
*                                   /*OR A 'F0' INTO LO-ORDER BYTE TO *
*                                   /* MAKE CHAR. A VALID EBCDIC NO.  *
*            R4 -> AREA(1) = R4 -> AREA(1)  'F0'X;
         OI    0(@4),X'F0'                                        0424
*         GO TO ABCD;
         BC    15,ABCD                                            0425
*         END;
*  PACK:     GEN( PACK  Q(8,R5),0(1,R7));
@9CC     EQU   *                                                  0427
PACK      PACK  Q(8,R5),0(1,R7)
         DS    0H
*  UNPACK:   GEN( UNPK  0(1,R7),Q(8,R5));
UNPACK    UNPK  0(1,R7),Q(8,R5)
         DS    0H
*                    /*************************************************
*                    /** PROCESS RANDOM FORMAT NO.                    *
*                    /**   'U' CONTAINS LAST RANDOM NO.               *
*                    /*************************************************
*  A7R6:;
*         R6 = U ;                     /* PICK UP LAST RANDOM # A45200*
A7R6     L     @6,624(0,@5)                                       0430
*         GENERATE ;
         LA    R7,1                    SET ALL FF IN R7          A45200
         LCR   R7,R7                   FOR SUBTRACTING           A45200
         SRDL  R6,8                    SHIFT TO RETAIN           A45200
         SLL   R6,8                    CLEAN NUMBER              A45200
         SLR   R7,R6                   SUBTRACT TO NUMBER        A45200
         SRL   R6,8                    SHIFT TO GET BYTE         A45200
         SLDL  R6,8                    PLACE IN                  A45200
         DS    0H
*         R7 = 524293 ;                /* INIT MULTIPLIER       A45200*
         L     @7,@D9                                             0432
*         GENERATE ;
         MR    R6,R6                   MULTIPLY FOR NEW RANDOM   A45200
         LA    R6,3201                 LOAD NUMBER FOR ADD       A45200
         ALR   R7,R6                   ADD VALUE RANDOMIZING     A45200
         LR    R6,R7                   SAVE NEW VALUE            A45200
         SLL   R7,24                   SHIFT TO ADD RANDOM #     A45200
         ALR   R7,R6                   ADD TO NEW # TO AVOID     A45200
         SRL   R6,8                    PAIR/UNPAIR SEQUENCE      A45200
         SLDL  R6,8                    RESULT RANDOM             A45200
         DS    0H
         DS    0H
*         U = R6 ;                     /* NEW RANDOM #          A45200*
         ST    @6,624(0,@5)                                       0434
*                                   /*TEST IF FD LENGTH IS GT 4. */
*                                   /*IF YES, SET R6 = 4.        */
*         IF FDLGTH > 4 THEN R6 = 4;
         LA    @F,4                                               0435
         CH    @F,24(0,@9)                                        0435
         BC    10,@9CB                                            0435
         LR    @6,@F                                              0436
         BC    15,@9CA                                            0437
*                                   /*ELSE, R6 = FD LENGTH. */
*            ELSE R6 = FDLGTH;
@9CB     LH    @6,24(0,@9)                                        0437
*                                   /*CALCULATE FROM ADDRESS. */
*            R7 = ADDR(U) + 4 - R6;
@9CA     LCR   @F,@6                                              0438
         AH    @F,@D3                                             0438
         LA    @0,624(0,@5)                                       0438
         AR    @F,@0                                              0438
         LR    @7,@F                                              0438
*                                   /*CALCULATE TO ADDRESS. */
*            R8 = FDFROMAD + FDLGTH - R6;
         LCR   @8,@6                                              0439
         LH    @0,24(0,@9)                                        0439
         ALR   @8,@0                                              0439
         AL    @8,44(0,@9)                                        0439
*                                   /*MOVE NEW RANDOM NO. INTO FD TABLE
*            R8 -> AREA(1:R6) = R7 -> AREA(1:R6);
         LR    @E,@7                                              0440
         LR    @1,@6                                              0440
         BCTR  @1,0                                               0440
         LR    @A,@8                                              0440
         EX    @1,@MVC                                            0440
*                                   /*RANDOM NO. IS PROCESSED. */
*         GO TO ABCD;
         BC    15,ABCD                                            0441
*                    /*************************************************
*                    /** PROCESS SHIFT OR TRUNCATE ACTIONS.           *
*                    /*************************************************
*  A7R8:;
*         IF FXACTION = '1'B THEN GO TO ABCD /**BR NO ACTION TO DO**/;
A7R8     TM    32(@9),B'00100000'                                 0443
         BC    01,ABCD                                            0444
*         IF STACTION ^= '1'B THEN GO TO ABCD1 /**BR NOT S OR T **/;
         TM    32(@9),B'00000010'                                 0445
         BC    12,ABCD1                                           0446
*         IF FDMLGTH > 1 THEN DO;
         LA    @F,1                                               0447
         CH    @F,48(0,@9)                                        0447
         BC    10,@9C9                                            0447
*               FDMLGTH = FDMLGTH- 1 /**COUNT DOWN ON MOVE LGTH**/;
         LH    @F,@D2                                             0449
         AH    @F,48(0,@9)                                        0449
         STH   @F,48(0,@9)                                        0449
*               FDFRINC = FDFRINC + FDFRINCR /**INCREASE FROM INC**/;
         SR    @F,@F                                              0450
         IC    @F,58(0,@9)                                        0450
         AH    @F,42(0,@9)                                        0450
         STH   @F,42(0,@9)                                        0450
*               FDTOINC = FDTOINC + FDTOINCR /**INCREASE TO INC**/;
         SR    @F,@F                                              0451
         IC    @F,59(0,@9)                                        0451
         AH    @F,50(0,@9)                                        0451
         STH   @F,50(0,@9)                                        0451
*               GO TO ABCD     /** BR WE ARE DONE**/;
         BC    15,ABCD                                            0452
*         END;
*               FDMLGTH = FDLGTH /**RESTORE MOVE LENGTH**/;
@9C9     MVC   48(2,@9),24(@9)                                    0454
*               FDFRINC = 0    /**RESTORE FROM INCREMENT**/;
         SR    @F,@F                                              0455
         STH   @F,42(0,@9)                                        0455
*               FDTOINC = 0    /**RESTORE TO INCREMENT**/;
         STH   @F,50(0,@9)                                        0456
*               GO TO ABCD     /**BR TO PROCESS**/;
         BC    15,ABCD                                            0457
*                    /*************************************************
*                    /** PROCESS RIPPLE ACTION.                       *
*                    /*************************************************
*  ABCD1:;
*         IF RPACTION ^= '1'B THEN GO TO ABCD5 /**BR NOT RIPPLE**/;
ABCD1    TM    32(@9),B'00010000'                                 0459
         BC    12,ABCD5                                           0460
*         IF FDSLGTH > 1 THEN DO /**DO BELOW IF ANY COUNT LEFT**/;
         LA    @F,1                                               0461
         CH    @F,54(0,@9)                                        0461
         BC    10,@9C8                                            0461
*               FDSLGTH = FDSLGTH - 1 /**COUNT DOWN ON SEQUENCE**/;
         LH    @F,@D2                                             0463
         AH    @F,54(0,@9)                                        0463
         STH   @F,54(0,@9)                                        0463
*               FDFRINC = FDFRINC + 1 /**INCREASE FROM INC**/;
         LA    @F,1                                               0464
         AH    @F,42(0,@9)                                        0464
         STH   @F,42(0,@9)                                        0464
*               GO TO ABCD     /** BRANCH TO PROCESS**/;
         BC    15,ABCD                                            0465
*         END;
*               FDSLGTH = FDSLGTHR /**RESTORE SEQ LGTH COUNTER**/;
@9C8     MVC   54(2,@9),56(@9)                                    0467
*               FDFRINC = 0    /**RESTORE FROM INCREMENT**/;
         SR    @F,@F                                              0468
         STH   @F,42(0,@9)                                        0468
*         GO TO ABCD           /** BRANCH TO PROCESS*/;
         BC    15,ABCD                                            0469
*  ABCD5:;
*            R6 = FDFROMAD + FDFRINC  /*PICKUP FROM ADDRESS. */;
ABCD5    LH    @6,42(0,@9)                                        0471
         AL    @6,44(0,@9)                                        0471
*         IF WVACTION ^= '1'B THEN GO TO ABCD2 /**DO BELOW IF WAVE**/;
         TM    32(@9),B'00000100'                                 0472
         BC    12,ABCD2                                           0473
*                    /*************************************************
*                    /** PROCESS WAVE ACTION.                         *
*                    /*************************************************
*                                   /*DO BELOW IF FROMAD NOT BLANK. */
*         IF R6 -> AREA(1) = ' ' THEN DO;
         CLI   0(@6),C' '                                         0474
         BC    07,@9C7                                            0474
*               FDFRINC = FDFRINC + 1 /**RESOLVE NEW FROM INCREMENT**/;
         LA    @F,1                                               0476
         AH    @F,42(0,@9)                                        0476
         STH   @F,42(0,@9)                                        0476
*               GO TO ABCD     /** BRANCH TO PROCESS**/;
         BC    15,ABCD                                            0477
*         END;
*               FDFRINC = 0    /**RESTORE FROM INCREMENT**/;
@9C7     SR    @F,@F                                              0479
         STH   @F,42(0,@9)                                        0479
*               FDMLGTH = FDLGTH /**RESTORE MOVE LENGTH**/;
         MVC   48(2,@9),24(@9)                                    0480
*               GO TO ABCD /**BRANCH FINISHED WAVEING**/;
         BC    15,ABCD                                            0481
*  ABCD2:;
*         IF ROACTION ^= '1'B THEN GO TO ABCD /**BRANCH IF NOT ROLL**/;
ABCD2    TM    32(@9),B'00001000'                                 0483
         BC    12,ABCD                                            0484
*  /**IF USER PATTERN IS ALLOWED IN THE FUTURE THIS BRANCH**/
*  /**SHOULD GO TO TEST A USER SWITCH SET WHEN THE ACTION IS TAKEN**/
*  /** FROM CONTROL CARD DURING INITIAL SCAN**/
*                    /*************************************************
*                    /** PROCESS ROLL ACTION.                         *
*                    /*************************************************
*         IF FDFRINCR = '01'X THEN GO TO ABCD3 /**BR TO TEST LEFT BL**/
         CLI   58(@9),X'01'                                       0485
         BC    08,ABCD3                                           0486
*         R6 = R6 + FDLGTH - 1 /**POINT AT END OF FIELD**/;
         LH    @F,@D2                                             0487
         AH    @F,24(0,@9)                                        0487
         AR    @6,@F                                              0487
*         IF R6 -> AREA(1) ^= ' ' THEN DO;
         CLI   0(@6),C' '                                         0488
         BC    08,@9C6                                            0488
*               FDFRINCR = '01'X /**INDICATE ROLL TO LEFT**/;
         MVI   58(@9),X'01'                                       0490
*         FDFRINC = FDFRINC + 1 /**RESOLVE FROM IINCREMENT**/;
         LA    @F,1                                               0491
         AH    @F,42(0,@9)                                        0491
         STH   @F,42(0,@9)                                        0491
*               GO TO ABCD     /** BRANCH TO PROCESS**/;
         BC    15,ABCD                                            0492
*         END;
*         FDFRINC = FDFRINC - 1 /**RESOLVE FROM INC-ROLL TO RIGHT**/;
@9C6     LH    @F,@D2                                             0494
         AH    @F,42(0,@9)                                        0494
         STH   @F,42(0,@9)                                        0494
*               GO TO ABCD     /**BRANCH TO PROCESS**/;
         BC    15,ABCD                                            0495
*  ABCD3:;
*                                   /*BRANCH NEED TO RESTORE. */
*         IF R6 -> AREA(1) ^= ' ' THEN GO TO ABCD4;
ABCD3    CLI   0(@6),C' '                                         0497
         BC    07,ABCD4                                           0498
*         FDFRINC = FDFRINC + 1 /**RESOLVE NEW FROM INCREMENT**/;
         LA    @F,1                                               0499
         AH    @F,42(0,@9)                                        0499
         STH   @F,42(0,@9)                                        0499
*               GO TO ABCD     /**BRANCH TO PROCESS**/;
         BC    15,ABCD                                            0500
*  ABCD4:;
*               FDFRINCR = '02'X /** CHANGE INDICATOR**/;
ABCD4    MVI   58(@9),X'02'                                       0502
*         FDFRINC = FDFRINC - 1 /**RESOLVE NEW FROM INCREMENT**/;
         LH    @F,@D2                                             0503
         AH    @F,42(0,@9)                                        0503
         STH   @F,42(0,@9)                                        0503
*         GO TO ABCD           /** BRANCH TO PROCESS**/;
*                    /*************************************************
*                    /**  FD TABLE HAS BEEN PROCESSED.  THIS SECTION  *
*                    /**    TESTS IF ANY MORE TABLES ARE TO BE PRO-   *
*                    /**    CESSED.                                   *
*                    /*************************************************
*  ABCD:;
*                                   /*RESTORE REG 4. */
*            R4 = GCADDR;
ABCD     L     @4,376(0,@5)                                       0506
*                                   /*UPDATE PTR TO NEXT FD ADR. */
*  A7J3:     CURFD = CURFD + 4;
A7J3     LA    @F,4                                               0507
         A     @F,352(0,@5)                                       0507
         ST    @F,352(0,@5)                                       0507
*                                   /*TEST IF LAST FD ADR. IN GM. */
*         IF CURFD -> AREA(1:4) ^= 0 THEN GO TO A7J2;
         L     @1,352(0,@5)        
         CLC   0(4,@1),@D1                                        0508
         BC    07,A7J2                                            0509
*                                   /*TEST IF ANOTHER FD ADR. GM. */
*         IF CURFDGM -> NXTFDGM = 0 THEN GO TO A7A5;
         SR    @F,@F                                              0510
         L     @2,632(0,@5)        
         C     @F,0(0,@2)                                         0510
         BC    08,A7A5                                            0511
*                                   /*GET ADR. OF NEXT FD ADR. GM. */
*            CURFDGM = CURFDGM -> NXTFDGM;
         MVC   632(4,@5),0(@2)                                    0512
*                                   /*LOOP BACK TO PROCESS NORE FD TABS
*         GO TO A7J1;
         BC    15,A7J1                                            0513
* /********************************************************************
* /**  CHECK NO. OF RECORDS TO GENERATE.                              *
* /**    IF 'EODSTOP' SW. IS ON, RECORDS ARE WRITTEN UNTIL AN         *
* /**      END-OF DATA OCCURS.                                        *
* /********************************************************************
*                                   /*TEST IF EODSTOP SWITCH IS ON. */
*  A7A5:  IF EODSTOP = ON THEN GO TO A7A12;
A7A5     CLC   556(1,@5),ON                                       0514
         BC    08,A7A12                                           0515
*                                   /*DECREMENT RECORD COUNTER.*/
*            RECREM = RECREM - 1;
         LH    @F,@D2                                             0516
         A     @F,348(0,@5)                                       0516
         ST    @F,348(0,@5)                                       0516
*                                   /*TEST IF ALL RECORDS WRITTEN FOR *
*                                   /* THIS CREATE ENTRY.             *
*         IF RECREM ^= 0 THEN GO TO A7A12;
         SR    @F,@F                                              0517
         C     @F,348(0,@5)                                       0517
         BC    07,A7A12                                           0518
* /********************************************************************
* /**  CHECK FOR ANY MORE CREATE ENTRIES.                             *
* /**    IF THE CREATE CARD WASN'T IN A REPEAT GROUP, THEN THERE ARE  *
* /**     NO MORE CREATE ENTRIES.                                     *
* /********************************************************************
*                                   /*TEST IF NEXT CREATE POINTER IS 0.
*  A7A56: IF NXTCRTE ^= 0 THEN DO;
A7A56    SR    @F,@F                                              0519
         C     @F,0(0,@4)                                         0519
         BC    08,@9C5                                            0519
*                                   /*IT'S NOT 0.  POINT TO NEXT */
*                                   /* CREATE ENTRY.             */
*            CURCRTE = NXTCRTE;
         MVC   316(4,@5),0(@4)                                    0521
*                                   /*GO TO PROCESS NEW CREATE ENTRY.*/
*         GO TO A7A11;
         BC    15,A7A11                                           0522
*         END;
*                                   /*TEST IF NEXT CREATE GM POINTER*/
*                                   /* IS 0.                        */
*         IF CURCRGM -> NXTCRGM ^= 0 THEN DO;
@9C5     SR    @F,@F                                              0524
         L     @1,320(0,@5)        
         C     @F,0(0,@1)                                         0524
         BC    08,@9C4                                            0524
*                                   /*IT'S NOT 0. UPDATE CURRENT CREATE
*                                   /* GM POINTER.
*            CURCRGM = CURCRGM -> NXTCRGM;
         MVC   320(4,@5),0(@1)                                    0526
*                                   /*UPDATE CURRENT CREATE POINTER.*/
*            CURCRTE = CURCRGM + 4;
         LA    @F,4                                               0527
         A     @F,320(0,@5)                                       0527
         ST    @F,316(0,@5)                                       0527
*                                   /*GO TO PROCESS NEW CREATE ENTRY.*/
*         GO TO A7A11;
         BC    15,A7A11                                           0528
*         END;
*                                   /*DECREMENT REPEATNO.*/
*            REPEATNO = REPEATNO - 1;
@9C4     LH    @F,@D2                                             0530
         AH    @F,16(0,@5)                                        0530
         STH   @F,16(0,@5)                                        0530
*                                   /*TEST IF REPEATNO = 0. IF NOT,   *
*                                   /* LOOP BACK TO PROCESS ALL       *
*                                   /* CREATE ENTRIES AGAIN.          *
*         IF REPEATNO ^= 0 THEN GO TO A7A1;   /* REPEATNO NOT 0OY01163*
         SR    @F,@F                                              0531
         CH    @F,16(0,@5)                                        0531
         BC    07,A7A1                                            0532
* /********************************************************************
* /** CREATE CLEAN UP - ALL CREATE ENTRIES HAVE BEEN PROCESSED.       *
* /**           CREATE TABLES, PICTURE TABLES, & NAME TABLES MUST BE  *
* /**           FREED. ALSO, ANY USER EXIT ROUTINES MUST BE DELETED.  *
* /********************************************************************
*  A7A6:;
*                    /*************************************************
*                    /** FLUSH SYSIN DATA RECORDS.                    *
*                    /**   IF INPUT=SYSIN WAS SPECIFIED AND THE DELIM-*
*                    /**    WASN'T READ, SYSIN MUST BE FLUSHED TO THE *
*                    /**    NEXT CONTROL CARD.                        *
*                    /*************************************************
*                                   /*TEST IF THERE WERE ANY CREATE  */
*                                   /* ENTRIES WITH SYSIN INPUT DCB. */
*         IF SYSISW = OFF THEN GO TO A7A62;
A7A6     CLC   569(1,@5),OFF                                      0534
         BC    08,A7A62                                           0535
*                                   /*TEST IF WE HAD AN EOD ON SYSIN. *
*  A7A61:
*         IF SYSINEOD = ON THEN GO TO A7A62;
A7A61    CLC   579(1,@5),ON                                       0536
         BC    08,A7A62                                           0537
*                                   /*FLUSH AN INPUT RECORD. */
*                                   /*PUT SYSIN DCB ADR IN REG 1. */
*         R1 = ADDR(SYSI);
         LA    @1,116(0,@5)                                       0538
*         R0 = ADDR(MESSAGE);      /**ADDRESS OF FLUSH BUFFER YA01453**
         LA    @0,668(0,@5)                                       0539
*  A7FLUSH:;
*                                   /*ISSUE GET MACRO. */
*            GEN( GET  (R1),(R0));
A7FLUSH   GET  (R1),(R0)
         DS    0H
*                          /*TEST IF A DELIMITER CARD WAS READ YA01453*
*         IF MESSAGE(1:4)=DELIM THEN GO TO A7A62;            /*YA01453*
         CLC   668(4,@5),344(@5)                                  0542
*               GO TO A7A61    /**BR NOT AT DELIM YET**/;
         BC    07,A7A61                                           0544
*                    /*************************************************
*                    /**  THIS SECTION WILL FREE TABLE SPACE.         *
*                    /*************************************************
*                                   /*IF 'CRTABPT' IS 0, THERE ARE NO *
*                                   /* TABLES TO FREE.                *
*  A7A62: IF CRTABPT = 0 THEN GO TO A7A9;
A7A62    SR    @F,@F                                              0545
         C     @F,312(0,@5)                                       0545
         BC    08,A7A9                                            0546
*                                   /*INITIALIZE POINTERS TO 1ST */
*                                   /* CREATE ENTRY.             */
*            CURCRGM = CRTABPT;
         MVC   320(4,@5),312(@5)                                  0547
*            CURCRTE = CURCRGM + 4;
         LA    @F,4                                               0548
         A     @F,320(0,@5)                                       0548
         ST    @F,316(0,@5)                                       0548
*  A7A7:;
*                                   /*BASE REG FOR CREATE ENTRY.*/
*            R4 = CURCRTE;
A7A7     L     @4,316(0,@5)                                       0550
*                              /***************************************
*                              /**FREE PICTURE TABLE.                 *
*                              /***************************************
*                                   /*TEST IF PICTURE POINTER IS 0.*/
*         IF PICPTR ^= 0 THEN DO;
         SR    @F,@F                                              0551
         C     @F,16(0,@4)                                        0551
         BC    08,@9C3                                            0551
*                                   /*PUT ADR OF AREA TO FREE IN*/
*                                   /* FREEMAIN PARAMETER.       */
*            GCADDR = PICPTR;
         MVC   376(4,@5),16(@4)                                   0553
*                                   /*PUT LENGTH TO FREE IN REG 3.*/
*            R3 = PICPTR -> PICLGTH + 6;
         LA    @F,6                                               0554
         L     @1,16(0,@4)         
         AH    @F,4(0,@1)                                         0554
         LR    @3,@F                                              0554
*                                   /*POINT TO ADDRESS PARAMETER.*/
*            R2 = ADDR(GCADDR);
         LA    @2,376(0,@5)                                       0555
*                                   /*POINT TO PARAMETER LIST.*/
*            R1 = ADDR(GETMLIST);
         LA    @1,364(0,@5)                                       0556
*                                   /*FREE SPACE FOR PICTURE.*/
*            GEN( FREEMAIN  E,LV=(R3),A=(R2),SP=0,MF=(E,(1)));
          FREEMAIN  E,LV=(R3),A=(R2),SP=0,MF=(E,(1))
         DS    0H
*         END;
*                              /***************************************
*                              /**FREE FD ADDRESS TABLES.             *
*                              /***************************************
*                                   /*TEST IF ANY FD'S FOR THIS */
*                                   /* CREATE ENTRY.            */
*         IF FDADTAB = 0 THEN GO TO A7A75;
@9C3     SR    @F,@F                                              0559
         C     @F,24(0,@4)                                        0559
         BC    08,A7A75                                           0560
*                                   /*POINT TO 1ST FD ADR. GM. */
*            R6 = FDADTAB;
         L     @6,24(0,@4)                                        0561
*                                   /*SAVE PTR TO NEXT FD ADR. GM. */
*  A7A73:    CURFDGM = R6 -> NXTFDGM;
A7A73    MVC   632(4,@5),0(@6)                                    0562
*                                   /*FREE 88 BYTE FD ADR. TABLE. */
*            R0 = 88;
         LA    @0,88                                              0563
*                                   /*ISSUE FREEMAIN MACRO. */
*            GEN( FREEMAIN  R,LV=(0),A=(6));
          FREEMAIN  R,LV=(0),A=(6)
         DS    0H
*                                   /*PUT PTR TO NEXT GM IN R6. */
*            R6 = CURFDGM;
         L     @6,632(0,@5)                                       0565
*                                   /*TEST IF PTR TO NEXT GM IS 0. */
*         IF R6 ^= 0 THEN GO TO A7A73;
         LTR   @6,@6                                              0566
         BC    07,A7A73                                           0567
*                                   /*TEST IF NEXT CREATE PTR IS 0.*/
*  A7A75: IF NXTCRTE ^= 0 THEN DO;
A7A75    SR    @F,@F                                              0568
         C     @F,0(0,@4)                                         0568
         BC    08,@9C2                                            0568
*                                   /*POINT TO NEXT CREATE ENTRY.*/
*            CURCRTE = NXTCRTE;
         MVC   316(4,@5),0(@4)                                    0570
*                                   /*LOOP BACK TO PROCESS NEW CREATE *
*                                   /* ENTRY.                         *
*         GO TO A7A7;
         BC    15,A7A7                                            0571
*         END;
*                                   /*TEST IF NEXT CREATE GETMAIN */
*                                   /* POINTER IS 0.              */
*         IF CURCRGM -> NXTCRGM ^= 0 THEN DO;
@9C2     SR    @F,@F                                              0573
         L     @1,320(0,@5)        
         C     @F,0(0,@1)                                         0573
         BC    08,@9C1                                            0573
*                                   /*UPDATE CURRENT CREATE GM PTR.*/
*            CURCRGM = CURCRGM -> NXTCRGM;
         MVC   320(4,@5),0(@1)                                    0575
*                                   /*UPDATE CURRENT CREATE ENTRY PTR.*
*            CURCRTE = CURCRGM + 4;
         LA    @F,4                                               0576
         A     @F,320(0,@5)                                       0576
         ST    @F,316(0,@5)                                       0576
*                                   /*LOOP BACK TO PROCESS NEW CREATE *
*                                   /* ENTRY.                         *
*         GO TO A7A7;
         BC    15,A7A7                                            0577
*         END;
*                              /***************************************
*                              /**FREE CREATE TABLES.                 *
*                              /***************************************
*                                   /*INITIALIZE CURRENT CREATE GM PTR.
*            CURCRGM = CRTABPT;
@9C1     MVC   320(4,@5),312(@5)                                  0579
*  A7A8:;
*                                   /*PUT ADR OF CREATE TABLE IN */
*                                   /* FREEMAIN PARAMETER LIST.  */
*            GCADDR = CURCRGM;
A7A8     MVC   376(4,@5),320(@5)                                  0581
*                                   /*GET ADR OF NEXT CREATE GETMAIN.*/
*            CURCRGM = CURCRGM -> NXTCRGM;
         L     @1,320(0,@5)        
         MVC   320(4,@5),0(@1)                                    0582
*                                   /*POINT TO ADDRESS PARAMETER.*/
*            R2 = ADDR(GCADDR);
         LA    @2,376(0,@5)                                       0583
*                                   /*POINT TO PARAMETER LIST.*/
*            R1 = ADDR(GETMLIST);
         LA    @1,364(0,@5)                                       0584
*                                   /*FREE CREATE TABLE SPACE.*/
*            GEN( FREEMAIN  E,LV=512,A=(R2),SP=0,MF=(E,(1)));
          FREEMAIN  E,LV=512,A=(R2),SP=0,MF=(E,(1))
         DS    0H
*                                   /*TEST IF NEXT GM PTR IS 0. IF NOT*
*                                   /* LOOP BACK TO FREE NEXT GM.     *
*         IF CURCRGM ^= 0 THEN GO TO A7A8;
         SR    @F,@F                                              0586
         C     @F,320(0,@5)                                       0586
         BC    07,A7A8                                            0587
*                    /*************************************************
*                    /**  THIS SECTION INITIALIZES POINTERS AND SW-   *
*                    /**    ITCHES FOR INITIAL ENTRY TO MODULE        *
*                    /**    IEBCRANL.                                 *
*                    /*************************************************
*                                   /*CLEAR NAME CONTINUATION SW. */
*  A7A9:     NAMCSW = '0'X;
A7A9     MVI   561(@5),X'00'                                      0588
*                                   /*CLEAR PICTURE CONTINUATION SW. */
*            PICCSW = '0'X;
         MVI   562(@5),X'00'                                      0589
*                                   /*CLEAR CREATE SW. */
*            CREATESW = '0'X;
         MVI   552(@5),X'00'                                      0590
*                                   /*CLEAR REPEAT SW. */
*            REPEATSW = '0'X;
         MVI   578(@5),X'00'                                      0591
*                                   /*SET 'CREATENO' TO 1. */
*            CREATENO = 1;
         LA    @F,1                                               0592
         STH   @F,18(0,@5)                                        0592
*                                   /*SET 'REPEATNO' TO 1. */
*            REPEATNO = 1;
         STH   @F,16(0,@5)                                        0593
*                                   /*SET POINTER TO 1ST CREATE TABLE *
*                                   /* TO 0.                          *
*            CRTABPT = 0;
         SR    @F,@F                                              0594
         ST    @F,312(0,@5)                                       0594
*                                   /*PUT ADR. OF SYSI DCB IN BASE PTR.
*            DCBPTR = ADDR(SYSI);
         LA    @F,116(0,@5)                                       0595
         ST    @F,300(0,@5)                                       0595
*                                   /*RESTORE SYSIN DCB SYNAD FOR IEBDG
*            SYNAD = PARM;
         L     @1,300(0,@5)        
         MVC   56(4,@1),12(@5)                                    0596
*                                   /*RESTORE SYSIN EODAD FOR  @ZA24201
*                                   /*READING CONTROL STMT'S   @ZA24201
*            EODAD = SAVEEOD;                                /*@ZA24201
         MVC   33(3,@1),SAVEEOD                                   0597
* /********************************************************************
* /**    NORMAL RETURN.                                               *
* /**      CONTROL IS PASSED TO IEBCRANL WHICH RETURNS TO IEBDG TO    *
* /**       READ THE NEXT CONTROL CARD.                               *
* /********************************************************************
*                                   /*GO TO IEBDG TO READ NEXT CONTROL*
*                                   /* STATEMENT.                     *
*         RETURN;
         BC    15,@EL01                                           0598
* /********************************************************************
* /**    ERROR RETURN.                                                *
* /**      CONTROL IS PASSED TO IEBCRANL WHICH RETURNS TO IEBDG TO    *
* /**       PRINT A MESSAGE, SET THE 'NOGO' SW., AND READ THE NEXT    *
* /**       CONTROL CARD.                                             *
* /********************************************************************
*                                   /*SET CONDITION CODE TO 8. */
*  ERROR1:   CONCODE = 8;
ERROR1   LA    @F,8                                               0599
         STH   @F,306(0,@5)                                       0599
*                                   /*SET EPSW = 1 TO PRINT A MSG, SET*
*                                   /* NOGO, & READ NEXT CARD.
*  ERROR:    EPSW = 1;
ERROR    MVI   568(@5),1                                          0600
*                                   /*GO TO CREATE CLEANUP. */
*         GO TO A7A6;
         BC    15,A7A6                                            0601
* /********************************************************************
* /** MOVEROUT - THIS SUBROUTINE WILL MOVE ONE AREA TO ANOTHER        *
* /**             REGARDLESS OF LENGTH.                               *
* /**      ENTRY - R14 IS LINKAGE REGISTER.                           *
* /**              R6 POINTS TO START OF FROM FIELD.                  *
* /**              R7 POINTS TO START OF TO FIELD.                    *
* /**              R8 CONTAINS NO. OF BYTES TO BE MOVED.              *
* /**      EXIT  - R6 POINTS TO START OF FROM FIELD ON LAST MOVE.     *
* /**              R7 POINTS TO START OF TO FIELD ON LAST MOVE.       *
* /**              R8 DESTROYED.                                      *
* /********************************************************************
*  MOVEROUT:;
*                                   /*SAVE REG 14 IN COMMON AREA. */
*            SAVE14 = R14;
MOVEROUT ST    @E,360(0,@5)                                       0603
*                                   /*TEST IF LENGTH IS 0 IN CASE */
*                                   /* NOTHING SHOULD BE MOVED.   */
*         IF R8 =< 0 THEN GO TO A7P2;
         LTR   @8,@8                                              0604
         BC    12,A7P2                                            0605
*                                   /*TEST IF LENGTH IS GT 256. IF YES,
*                                   /* PEFORM A MOVE OF 256 BYTES.
*  A7P1:  IF R8 > 256 THEN DO;
A7P1     CH    @8,@D10                                            0606
         BC    12,@9C0                                            0606
*                                   /*MOVE 256 BYTES.*/
*            GEN( MVC  0(256,R7),0(R6));
          MVC  0(256,R7),0(R6)
         DS    0H
*                                   /*DECREMENT LENGTH 256.*/
*            R8 = R8 - 256;
         SH    @8,@D10                                            0609
*                                   /*INCREMENT FROM POINTER BY 256.*/
*            R6 = R6 + 256;
         AH    @6,@D10                                            0610
*                                   /*INCREMENT TO POINTER BY 256.*/
*            R7 = R7 + 256;
         AH    @7,@D10                                            0611
*                                   /*LOOP TO DO ANOTHER MOVE.*/
*         GO TO A7P1;
         BC    15,A7P1                                            0612
*         END;
*                                   /*DECREMENT LENGTH BY 1.*/
*            R8 = R8 - 1;
@9C0     BCTR  @8,0                                               0614
*                                   /*EXECUTE MOVE INSTRUCTION.*/
*            GEN( EX  R8,MOVE);
          EX  R8,MOVE
         DS    0H
*                                   /*RESTORE REG 14 FROM COMMON AREA.
*  A7P2:     R14 = SAVE14;
A7P2     L     @E,360(0,@5)                                       0616
*                                   /*RETURN TO CALLER.*/
*         GO TO R14;
         BCR   15,@E                                              0617
*  MOVE:     GEN( MVC  0(1,R7),0(R6));
MOVE      MVC  0(1,R7),0(R6)
         DS    0H
*  END IEBCREAT;
@EL01    L     @D,4(0,@D)                                         0619
         LR    @1,@C                                              0619
         L     @0,@SIZ001                                         0619
         FREEMAIN R,LV=(0),A=(1)                                  0619
         L     @E,12(0,@D)                                        0619
         LM    @0,@8,20(@D)                                       0619
         LM    @A,@C,60(@D)                                       0619
         BCR   15,@E                                              0619
@DATA1   EQU   *
@0       EQU   00                  EQUATES FOR REGISTERS 0-15
@1       EQU   01
@2       EQU   02
@3       EQU   03
@4       EQU   04
@5       EQU   05
@6       EQU   06
@7       EQU   07
@8       EQU   08
@9       EQU   09
@A       EQU   10
@B       EQU   11
@C       EQU   12
@D       EQU   13
@E       EQU   14
@F       EQU   15
@D1      DC    F'0'
@D8      DC    F'-1'
@D9      DC    F'524293'
@D2      DC    H'-1'
@D3      DC    H'4'
@D4      DC    H'12'
@D5      DC    H'16'
@D6      DC    H'8'
@D7      DC    H'1'
@D10     DC    H'256'
@MVC     MVC   0(1,@A),0(@E)
         DS    0F
@SIZ001  DC    AL1(&SPN)
         DC    AL3(@DATEND-@DATD)
         DS    0F
@C6      DC    C'    '
@C8      DC    C' IEB729I PERMANENT I/O ERROR'
@X12     DC    X'000002147483647C'
@X3      DC    X'0000'
@C9      DC    C'RA'
@C10     DC    C'ZD'
@C11     DC    C'PD'
@C13     DC    C'BI'
         DS    0D
@DATA    EQU   *
R2       EQU   00000002            FULLWORD POINTER REGISTER
R3       EQU   00000003            FULLWORD POINTER REGISTER
R4       EQU   00000004            FULLWORD POINTER REGISTER
R5       EQU   00000005            FULLWORD POINTER REGISTER
R6       EQU   00000006            FULLWORD POINTER REGISTER
R7       EQU   00000007            FULLWORD POINTER REGISTER
R8       EQU   00000008            FULLWORD POINTER REGISTER
R9       EQU   00000009            FULLWORD POINTER REGISTER
R0       EQU   00000000            FULLWORD INTEGER REGISTER
R1       EQU   00000001            FULLWORD POINTER REGISTER
R14      EQU   00000014            FULLWORD POINTER REGISTER
R15      EQU   00000015            FULLWORD INTEGER REGISTER
COMMON   EQU   00000000            308 BYTE(S) ON DWORD
PAGENO   EQU   COMMON+00000000     4 BYTE(S)
LINECT   EQU   COMMON+00000004     FULLWORD INTEGER
LINECTR  EQU   COMMON+00000008     FULLWORD INTEGER
PARM     EQU   COMMON+00000012     FULLWORD POINTER
REPEATNO EQU   COMMON+00000016     HALFWORD INTEGER
CREATENO EQU   COMMON+00000018     HALFWORD INTEGER
SYSP     EQU   COMMON+00000020     96 BYTE(S)
SYSI     EQU   COMMON+00000116     96 BYTE(S)
Q        EQU   COMMON+00000216     16 BYTE(S) ON DWORD
QFILL    EQU   COMMON+00000216     7 BYTE(S)
QSIGN    EQU   COMMON+00000223     8 BIT(S)
QFILL1   EQU   COMMON+00000224     7 BYTE(S)
QSIGN1   EQU   COMMON+00000231     8 BIT(S)
COUNTER  EQU   COMMON+00000232     FULLWORD POINTER
OPENLIST EQU   COMMON+00000236     8 BYTE(S)
OPTBYTE1 EQU   COMMON+00000236     4 BYTE(S)
OPTBYTE2 EQU   COMMON+00000240     4 BYTE(S)
EXLST    EQU   COMMON+00000244     24 BYTE(S) ON WORD
INHDR    EQU   COMMON+00000244     1 BYTE(S)
INHDR1   EQU   COMMON+00000245     3  BYTE  POINTER ON WORD+1
OUTHDR   EQU   COMMON+00000248     1 BYTE(S)
OUTHDR1  EQU   COMMON+00000249     3  BYTE  POINTER ON WORD+1
INTRL    EQU   COMMON+00000252     1 BYTE(S)
INTRL1   EQU   COMMON+00000253     3  BYTE  POINTER ON WORD+1
OUTTRL   EQU   COMMON+00000256     1 BYTE(S)
OUTTRL1  EQU   COMMON+00000257     3  BYTE  POINTER ON WORD+1
EXITDCB  EQU   COMMON+00000260     1 BYTE(S)
EXITDCB1 EQU   COMMON+00000261     3  BYTE  POINTER ON WORD+1
TOTAL    EQU   COMMON+00000264     1 BYTE(S)
TOTAL1   EQU   COMMON+00000265     3  BYTE  POINTER ON WORD+1
EXLST1   EQU   COMMON+00000268     4 BYTE(S) ON WORD
EDCB1    EQU   COMMON+00000268     1 BYTE(S)
EDCB2    EQU   COMMON+00000269     3  BYTE  POINTER ON WORD+1
EXLST2   EQU   COMMON+00000272     4 BYTE(S) ON WORD
EDCB3    EQU   COMMON+00000272     1 BYTE(S)
EDCB4    EQU   COMMON+00000273     3  BYTE  POINTER ON WORD+1
EXLST3   EQU   COMMON+00000276     4 BYTE(S) ON WORD
EDCB5    EQU   COMMON+00000276     1 BYTE(S)
EDCB6    EQU   COMMON+00000277     3  BYTE  POINTER ON WORD+1
DLRECL   EQU   COMMON+00000280     HALFWORD INTEGER
DBLKSI   EQU   COMMON+00000282     HALFWORD INTEGER
DRECFM   EQU   COMMON+00000284     8 BIT(S)
LEFTOVER EQU   COMMON+00000288     FULLWORD INTEGER
OFFSET   EQU   COMMON+00000292     FULLWORD POINTER
LPTR     EQU   COMMON+00000296     FULLWORD POINTER
DCBPTR   EQU   COMMON+00000300     FULLWORD POINTER
DUMMY    EQU   COMMON+00000304     FULLWORD POINTER
COMMON1  EQU   00000304            236 BYTE(S) ON WORD
SAVEMS   EQU   COMMON1+00000000    HALFWORD INTEGER
CONCODE  EQU   COMMON1+00000002    HALFWORD INTEGER
OUTREC   EQU   COMMON1+00000004    FULLWORD POINTER
CRTABPT  EQU   COMMON1+00000008    FULLWORD POINTER
CURCRTE  EQU   COMMON1+00000012    FULLWORD POINTER
CURCRGM  EQU   COMMON1+00000016    FULLWORD POINTER
CURPIC   EQU   COMMON1+00000020    FULLWORD POINTER
PICCTR   EQU   COMMON1+00000024    FULLWORD INTEGER
EXITTAB  EQU   COMMON1+00000028    FULLWORD POINTER
EXITGM   EQU   COMMON1+00000032    FULLWORD POINTER
CUREXIT  EQU   COMMON1+00000036    FULLWORD POINTER
DELIM    EQU   COMMON1+00000040    4 BYTE(S)
RECREM   EQU   COMMON1+00000044    FULLWORD INTEGER
CURFD    EQU   COMMON1+00000048    FULLWORD POINTER
CUROUT   EQU   COMMON1+00000052    HALFWORD POINTER
SAVE14   EQU   COMMON1+00000056    FULLWORD POINTER
GETMLIST EQU   COMMON1+00000060    16 BYTE(S) ON WORD
GLENGTH  EQU   COMMON1+00000060    FULLWORD INTEGER
ADRLIST  EQU   COMMON1+00000064    FULLWORD POINTER
IND      EQU   COMMON1+00000068    4 BYTE(S)
GCODE    EQU   COMMON1+00000068    1 BYTE(S)
SPOOL    EQU   COMMON1+00000069    1 BYTE(S)
CCODE    EQU   COMMON1+00000070    2 BYTE(S)
GCADDR   EQU   COMMON1+00000072    FULLWORD POINTER
FIRSTGMO EQU   COMMON1+00000076    FULLWORD POINTER
CURRGMO  EQU   COMMON1+00000080    FULLWORD POINTER
LASTGMO  EQU   COMMON1+00000084    FULLWORD POINTER
FIRSTGMI EQU   COMMON1+00000088    FULLWORD POINTER
CURRGMI  EQU   COMMON1+00000092    FULLWORD POINTER
LASTGMI  EQU   COMMON1+00000096    FULLWORD POINTER
CONDCODE EQU   COMMON1+00000100    HALFWORD INTEGER
MS       EQU   COMMON1+00000102    HALFWORD INTEGER
INBUFA1  EQU   COMMON1+00000104    121 BYTE(S)
INFILL   EQU   COMMON1+00000104    10 BYTE(S)
INBUFA   EQU   COMMON1+00000114    111 BYTE(S)
DDPTR    EQU   COMMON1+00000228    FULLWORD POINTER
DUMMY1   EQU   COMMON1+00000232    FULLWORD POINTER
COMMON2  EQU   00000536            76 BYTE(S) ON WORD
SWITCH   EQU   COMMON2+00000000    52 BYTE(S)
FDCSW    EQU   COMMON2+00000000    1 BYTE(S)
FDNAMESW EQU   COMMON2+00000001    1 BYTE(S)
FDPCSW   EQU   COMMON2+00000002    1 BYTE(S)
FDFMTSW  EQU   COMMON2+00000003    1 BYTE(S)
FDPLSW   EQU   COMMON2+00000004    1 BYTE(S)
RANGESW  EQU   COMMON2+00000005    1 BYTE(S)
FILLSW   EQU   COMMON2+00000006    1 BYTE(S)
REPSW    EQU   COMMON2+00000007    1 BYTE(S)
INDEXSW  EQU   COMMON2+00000008    1 BYTE(S)
INDNMSW  EQU   COMMON2+00000009    1 BYTE(S)
BQUOTESW EQU   COMMON2+00000010    1 BYTE(S)
PQUOTESW EQU   COMMON2+00000011    1 BYTE(S)
EQUOTESW EQU   COMMON2+00000012    1 BYTE(S)
FDSW     EQU   COMMON2+00000013    1 BYTE(S)
DSDSW    EQU   COMMON2+00000014    1 BYTE(S)
NOGOSW   EQU   COMMON2+00000015    1 BYTE(S)
CREATESW EQU   COMMON2+00000016    1 BYTE(S)
DSDCSW   EQU   COMMON2+00000017    1 BYTE(S)
CRCSW    EQU   COMMON2+00000018    1 BYTE(S)
EXITSW   EQU   COMMON2+00000019    1 BYTE(S)
EODSTOP  EQU   COMMON2+00000020    1 BYTE(S)
DSDNULSW EQU   COMMON2+00000021    1 BYTE(S)
DSDORGSW EQU   COMMON2+00000022    1 BYTE(S)
DSDDDSW  EQU   COMMON2+00000023    1 BYTE(S)
CRTBLK   EQU   COMMON2+00000024    1 BYTE(S)
NAMCSW   EQU   COMMON2+00000025    8 BIT(S)
PICCSW   EQU   COMMON2+00000026    8 BIT(S)
BUFPSW   EQU   COMMON2+00000027    1 BYTE(S)
ENDSW    EQU   COMMON2+00000028    1 BYTE(S)
COMCSW   EQU   COMMON2+00000029    1 BYTE(S)
FLAGSW   EQU   COMMON2+00000030    8 BIT(S)
PAGESW   EQU   COMMON2+00000031    1 BYTE(S)
EPSW     EQU   COMMON2+00000032    1  BYTE  POINTER
SYSISW   EQU   COMMON2+00000033    1 BYTE(S)
SYSPSW   EQU   COMMON2+00000034    1 BYTE(S)
OLDNEWSW EQU   COMMON2+00000035    1 BYTE(S)
FLUSHSW  EQU   COMMON2+00000036    1 BYTE(S)
FLUSHSW1 EQU   COMMON2+00000037    1 BYTE(S)
DSDOSW   EQU   COMMON2+00000038    1 BYTE(S)
DSDISW   EQU   COMMON2+00000039    1 BYTE(S)
QUANSW   EQU   COMMON2+00000040    1 BYTE(S)
PARENSW  EQU   COMMON2+00000041    1 BYTE(S)
REPEATSW EQU   COMMON2+00000042    1 BYTE(S)
SYSINEOD EQU   COMMON2+00000043    1 BYTE(S)
FDPLGTH  EQU   COMMON2+00000052    HALFWORD INTEGER
SGCADDR  EQU   COMMON2+00000056    FULLWORD POINTER
FDPTR    EQU   COMMON2+00000060    FULLWORD POINTER
FDPTR1   EQU   COMMON2+00000064    FULLWORD POINTER
FDPTR2   EQU   COMMON2+00000068    FULLWORD POINTER
DUMMY2   EQU   COMMON2+00000072    FULLWORD POINTER
COMMON3  EQU   00000608            188 BYTE(S) ON WORD
FDCTR    EQU   COMMON3+00000000    HALFWORD POINTER
LREMAIN  EQU   COMMON3+00000004    FULLWORD POINTER
COMPCTR  EQU   COMMON3+00000008    FULLWORD POINTER
LMOVED   EQU   COMMON3+00000012    HALFWORD POINTER
U        EQU   COMMON3+00000016    FULLWORD POINTER
PICEND   EQU   COMMON3+00000020    HALFWORD POINTER
CURFDGM  EQU   COMMON3+00000024    FULLWORD POINTER
SWTCH    EQU   COMMON3+00000028    4 BYTE(S) ON WORD
SYSINSEL EQU   COMMON3+00000028    1 BYTE(S)
FIRSTSW  EQU   COMMON3+00000029    1 BYTE(S)
FRSTSW   EQU   COMMON3+00000030    1 BYTE(S)
STOPSW   EQU   COMMON3+00000031    1 BYTE(S)
COPYVAL  EQU   COMMON3+00000032    HALFWORD INTEGER
COPYFD   EQU   COMMON3+00000036    FULLWORD POINTER
COPYFDGM EQU   COMMON3+00000040    FULLWORD POINTER
NAMCTR   EQU   COMMON3+00000044    HALFWORD INTEGER
NAMCTR1  EQU   COMMON3+00000046    HALFWORD INTEGER
INRECSZ  EQU   COMMON3+00000048    HALFWORD POINTER
OUTRECSZ EQU   COMMON3+00000050    HALFWORD POINTER
INRECFM  EQU   COMMON3+00000052    1 BYTE(S)
RECOFFST EQU   COMMON3+00000053    1  BYTE  POINTER
OUTRECFM EQU   COMMON3+00000054    1 BYTE(S)
PICBASE  EQU   COMMON3+00000056    FULLWORD POINTER
MESSAGE  EQU   COMMON3+00000060    121 BYTE(S)
DUMMY3   EQU   COMMON3+00000184    FULLWORD POINTER
DCBD     EQU   00000000            280 BYTE(S) ON DWORD
FILL     EQU   DCBD+00000000       16 BYTE(S)
KEYLEN   EQU   DCBD+00000016       1 BYTE(S)
DEVT     EQU   DCBD+00000017       8 BIT(S)
FILL1    EQU   DCBD+00000018       8 BYTE(S)
DSORG1   EQU   DCBD+00000026       2 BYTE(S)
DSORG    EQU   DCBD+00000026       8 BIT(S)
FILLER   EQU   DCBD+00000028       8 BYTE(S)
IOBAD    EQU   DCBD+00000028       4 BYTE(S)
BFTEK    EQU   DCBD+00000032       8 BIT(S)
EODAD    EQU   DCBD+00000033       3 BYTE(S)
RECFM    EQU   DCBD+00000036       8 BIT(S)
EXLIST   EQU   DCBD+00000037       3  BYTE  POINTER ON WORD+1
DDNAME   EQU   DCBD+00000040       8 BYTE(S)
DEBAD    EQU   DCBD+00000040       4 BYTE(S)
IFLGS    EQU   DCBD+00000040       8 BIT(S)
GETAD    EQU   DCBD+00000048       4 BYTE(S)
OFLGS    EQU   DCBD+00000048       8 BIT(S)
OFLGS1   EQU   DCBD+00000049       1 BYTE(S)
MACRF    EQU   DCBD+00000050       2 BYTE(S)
FILL2    EQU   DCBD+00000052       4 BYTE(S)
SYNAD    EQU   DCBD+00000056       4 BYTE(S)
CIND     EQU   DCBD+00000060       2 BYTE(S)
BLKSI    EQU   DCBD+00000062       HALFWORD INTEGER
FILL3    EQU   DCBD+00000064       18 BYTE(S)
LRECL    EQU   DCBD+00000082       HALFWORD INTEGER
FILL4    EQU   DCBD+00000084       172 BYTE(S)
NEXTDCB  EQU   DCBD+00000256       FULLWORD POINTER
DDNAME1  EQU   DCBD+00000260       8 BYTE(S)
EODSW    EQU   DCBD+00000268       1 BYTE(S)
DCBSW1   EQU   DCBD+00000269       1 BYTE(S)
DCBSW2   EQU   DCBD+00000270       1 BYTE(S)
DCBSW3   EQU   DCBD+00000271       8 BIT(S)
INREC    EQU   DCBD+00000272       FULLWORD POINTER
GMLGTH   EQU   DCBD+00000276       HALFWORD INTEGER
FIELDSEL EQU   DCBD+00000278       1 BYTE(S)
SPARE    EQU   DCBD+00000279       1 BYTE(S)
CRPICT   EQU   00000000            7 BYTE(S) ON WORD
PICSTLOC EQU   CRPICT+00000000     FULLWORD POINTER
PICLGTH  EQU   CRPICT+00000004     HALFWORD INTEGER
PICSTRNG EQU   CRPICT+00000006     1 BYTE(S)
CRTAB    EQU   00000000            28 BYTE(S) ON WORD
NXTCRTE  EQU   CRTAB+00000000      FULLWORD POINTER
QUAN     EQU   CRTAB+00000004      4 BYTE(S)
IDCBPTR  EQU   CRTAB+00000008      FULLWORD POINTER
EXITADR  EQU   CRTAB+00000012      FULLWORD POINTER
PICPTR   EQU   CRTAB+00000016      FULLWORD POINTER
FILLCH   EQU   CRTAB+00000020      1  BYTE  POINTER
EMP1     EQU   CRTAB+00000021      3 BYTE(S)
FDADTAB  EQU   CRTAB+00000024      FULLWORD POINTER
ENDFD    EQU   CRTAB+00000024      1 BYTE(S)
FDTBL    EQU   00000000            520 BYTE(S) ON WORD
FDNAME   EQU   FDTBL+00000000      8 BYTE(S)
FDREPNM  EQU   FDTBL+00000008      8 BYTE(S)
FDINDNM  EQU   FDTBL+00000016      8 BYTE(S) ON WORD
FDUMMY   EQU   FDTBL+00000016      4 BYTE(S)
FDINDNUM EQU   FDTBL+00000020      FULLWORD POINTER
FDLGTH   EQU   FDTBL+00000024      HALFWORD POINTER
FDCYCLE  EQU   FDTBL+00000026      HALFWORD POINTER
FDACTION EQU   FDTBL+00000028      2 BYTE(S)
FDFORMAT EQU   FDTBL+00000030      2 BYTE(S)
FDSWITCH EQU   FDTBL+00000032      8 BIT(S)
INDBYNAM EQU   FDTBL+00000032      1 BIT(S)
PASS     EQU   FDTBL+00000032      1 BIT(S)
FXACTION EQU   FDTBL+00000032      1 BIT(S)
RPACTION EQU   FDTBL+00000032      1 BIT(S)
ROACTION EQU   FDTBL+00000032      1 BIT(S)
WVACTION EQU   FDTBL+00000032      1 BIT(S)
STACTION EQU   FDTBL+00000032      1 BIT(S)
NUACTION EQU   FDTBL+00000032      1 BIT(S)
FDFILL   EQU   FDTBL+00000033      1 BYTE(S)
FDSIGN   EQU   FDTBL+00000034      1 BYTE(S)
FDCHAR   EQU   FDTBL+00000035      1 BYTE(S)
FDRANGE  EQU   FDTBL+00000036      4 BYTE(S)
FDRANC   EQU   FDTBL+00000036      4  BYTE  INTEGER
FDOBUF   EQU   FDTBL+00000040      HALFWORD POINTER
FDFRINC  EQU   FDTBL+00000042      HALFWORD POINTER
FDFROMAD EQU   FDTBL+00000044      4 BYTE(S)
FDMLGTH  EQU   FDTBL+00000048      HALFWORD POINTER
FDTOINC  EQU   FDTBL+00000050      HALFWORD POINTER
FDCYCCNT EQU   FDTBL+00000052      HALFWORD POINTER
FDSLGTH  EQU   FDTBL+00000054      HALFWORD POINTER
FDSLGTHR EQU   FDTBL+00000056      HALFWORD POINTER
FDFRINCR EQU   FDTBL+00000058      1 BYTE(S)
FDTOINCR EQU   FDTBL+00000059      1 BYTE(S)
LTOFREE  EQU   FDTBL+00000060      HALFWORD POINTER
FDSW1    EQU   FDTBL+00000062      8 BIT(S)
STRTLOC1 EQU   FDTBL+00000062      1 BIT(S)
NXTFDTAB EQU   00000516            FULLWORD POINTER
INBUF    EQU   00000000            80 BYTE(S)
PARAM    EQU   00000000            1 BYTE(S)
AREA     EQU   00000000            512 BYTE(S)
NXTCRGM  EQU   00000000            FULLWORD POINTER
BINARYMX EQU   *                   FULLWORD INTEGER
         DC    BL4'1111111111111111111111111111110'
NXTFDGM  EQU   00000000            FULLWORD POINTER
FDADR    EQU   00000000            FULLWORD POINTER
LLFLD    EQU   00000000            HALFWORD INTEGER
ONE      EQU   *                   FULLWORD INTEGER
         DC    FL4'0'
YES      EQU   *                   1 BYTE(S)
         DC    X'FF'
NO       EQU   *                   1 BYTE(S)
         DC    X'00'
ON       EQU   *                   1 BYTE(S)
         DC    X'FF'
OFF      EQU   *                   1 BYTE(S)
         DC    X'00'
         ORG   @DATA
         DS    00000012C
@L       EQU   1
@DATD    DSECT
@SAV001  EQU   @DATD+00000000      72 BYTE(S) ON WORD
SAVEEOD  EQU   @DATD+00000072      3 BYTE(S)
         DS    00000084C
@TEMPS   DS    0F
@TEMP4   DC    F'0'
@DATEND  EQU   *
IEBCREAT CSECT ,
@9ED     EQU   GETIN
@9E9     EQU   A7A18
         END   IEBCREAT
