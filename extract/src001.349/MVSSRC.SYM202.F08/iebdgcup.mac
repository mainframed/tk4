*    NEW MODULE, RELEASE 17.                                       DG0H
*                                                                A32655
*A474000                                                         A48747
*D474000,486000                                                  A48747
*C39300.D394000                                                  A48773
*A499200-499498                                                  A50950
*C292000                                                       @ZA04231
*A499400-499410                                                @ZA07345
*C292000                                                       @ZA07345
*D499400                                                       @ZA07345
         LCLA  &T,&SPN                                            0002
.@001    ANOP                                                     0002
IEBDGCUP CSECT ,                                                  0002
         ST    @E,12(0,@D)                                        0002
         STM   @0,@8,20(@D)                                       0002
         STM   @A,@C,60(@D)                                       0002
         BALR  @B,0                                               0002
@PSTART  DS    0H                                                 0002
         USING @PSTART+00000,@B                                   0002
         L     @0,@SIZ001                                         0002
         GETMAIN  R,LV=(0)                                        0002
         LR    @C,@1                                              0002
         USING @DATD+00000,@C                                     0002
         LM    @0,@1,20(@D)                                       0002
         XC    @TEMPS(@L),@TEMPS                                  0002
         ST    @D,@SAV001+4                                       0002
         LA    @F,@SAV001                                         0002
         ST    @F,8(0,@D)                                         0002
         LR    @D,@F                                              0002
*  GEN ( EJECT);
          EJECT
         DS    0H
*  DCL  R14 REG(14);
*  DCL  R15 REG(15);
*  DCL R0 REG(0);
*  DCL R1 REG(1);
*  DCL R2 REG(2);
*  DCL R3 REG(3);
*  DCL R5 REG(5) PTR(31);
*         RESTRICT(5);
*  DCL R6 REG(6) PTR(31);
*  RESTRICT(6);
*  DCL R7 REG(7) PTR(31);
*  RESTRICT(7);
*  DCL R8 REG(8) PTR(31);
*  RESTRICT (8);
*  DCL R9 REG(9) PTR(31);
*   RESTRICT (9);
*  DCL    1     COMMON BDY(DWORD) BASED(R5),
*               2  PAGENO CHAR(4),
*                   2  LINECT FIXED(31),
*                   2  LINECTR FIXED(31),
*         2     PARM PTR(31),
*               2 REPEATNO FIXED(15),
*               2 CREATENO FIXED(15),
*         2     SYSP CHAR(96),
*         2     SYSI CHAR(96),
*               2  Q  CHAR(16) BDY(DWORD),
*         3  QFILL CHAR(7),
*         3  QSIGN BIT(8),
*                    3 QFILL1 CHAR(7),
*                    3 QSIGN1 BIT(8),
*         2 COUNTER  PTR(31),
*         2 OPENLIST CHAR(8),
*                                   3 OPTBYTE1 CHAR(4),
*                                   3 OPTBYTE2 CHAR(4),
*               2  EXLST,
*                                        3  INHDR CHAR(1),
*                                        3 INHDR1 PTR(24),
*                                        3 OUTHDR CHAR(1),
*                                        3 OUTHDR1 PTR(24),
*                                        3 INTRL CHAR(1),
*                                        3 INTRL1 PTR(24),
*                                        3 OUTTRL CHAR(1),
*                                        3 OUTTRL1 PTR(24),
*                                        3 EXITDCB CHAR(1),
*                                        3 EXITDCB1 PTR(24),
*                                        3 TOTAL CHAR(1),
*                                        3 TOTAL1 PTR(24),
*               2 EXLST1,
*                                       3 EDCB1 CHAR(1),
*                                       3 EDCB2 PTR(24),
*              2 EXLST2,
*                                       3 EDCB3 CHAR(1),
*                                       3 EDCB4 PTR(24),
*         2  EXLST3,
*               3  EDCB5 CHAR(1),
*               3 EDCB6  PTR(24),
*               2 DLRECL FIXED(15),
*               2 DBLKSI FIXED(15),
*               2 DRECFM BIT(8),
*               2 LEFTOVER FIXED(31),
*         2     OFFSET PTR(31),
*         2     LPTR PTR(31),
*         2     DCBPTR PTR(31),
*         2 DUMMY PTR(31);
*  DCL 1 COMMON1 BASED(ADDR(DUMMY)) BDY(WORD),
*               2   SAVEMS  FIXED(15),
*               2   CONCODE FIXED(15),
*         2 OUTREC   PTR(31),
*         2 CRTABPT  PTR(31),
*         2 CURCRTE  PTR(31),
*         2 CURCRGM  PTR(31),
*         2 CURPIC PTR(31),
*         2 PICCTR FIXED(31),
*         2 EXITTAB PTR(31),
*         2 EXITGM PTR(31),
*         2 CUREXIT PTR(31),
*               2  DELIM  CHAR(4),
*         2 RECREM   FIXED(31),
*         2 CURFD    PTR(31),
*         2 CUROUT PTR(31),
*         2  SAVE14  PTR(31),
*         2 GETMLIST CHAR(16) BDY(WORD),
*            3 GLENGTH FIXED(31),
*            3 ADRLIST PTR(31),
*            3 IND CHAR(4),
*               4 GCODE CHAR(1),
*               4 SPOOL CHAR(1),
*               4 CCODE CHAR(2),
*            3 GCADDR PTR(31),
*         2     FIRSTGMO  PTR(31),
*         2     CURRGMO   PTR(31),
*         2     LASTGMO   PTR(31),
*         2     FIRSTGMI  PTR(31),
*         2     CURRGMI   PTR(31),
*         2     LASTGMI   PTR(31),
*         2     CONDCODE FIXED(15),
*               2       MS     FIXED(15),
*               2 INBUFA1 CHAR(121),
*                   3   INFILL CHAR(10),
*                      3  INBUFA  CHAR(111),
*         2     DDPTR PTR(31),
*               2   DUMMY1 PTR(31);
*  DCL 1 COMMON2 BASED (ADDR(DUMMY1)) BDY(WORD),
*         2  SWITCH   CHAR(52),
*               3  FDCSW      CHAR(1),
*               3  FDNAMESW   CHAR(1),
*               3  FDPCSW     CHAR(1),
*               3  FDFMTSW    CHAR(1),
*               3  FDPLSW     CHAR(1),
*               3  RANGESW    CHAR(1),
*               3  FILLSW     CHAR(1),
*               3  REPSW      CHAR(1),
*               3  INDEXSW    CHAR(1),
*               3  INDNMSW    CHAR(1),
*               3  BQUOTESW   CHAR(1),
*               3  PQUOTESW   CHAR(1),
*               3  EQUOTESW   CHAR(1),
*               3  FDSW       CHAR(1),
*               3  DSDSW      CHAR(1),
*               3  NOGOSW     CHAR(1),
*               3  CREATESW   CHAR(1),
*               3  DSDCSW     CHAR(1),
*               3  CRCSW      CHAR(1),
*               3  EXITSW     CHAR(1),
*               3  EODSTOP    CHAR(1),
*               3  DSDNULSW   CHAR(1),
*               3  DSDORGSW   CHAR(1),
*               3  DSDDDSW    CHAR(1),
*               3  CRTBLK     CHAR(1),
*               3  NAMCSW     BIT(8),
*               3  PICCSW     BIT(8),
*               3  BUFPSW     CHAR(1),
*               3  ENDSW      CHAR(1),
*               3  COMCSW     CHAR(1),
*               3  FLAGSW     BIT(8),
*               3  PAGESW     CHAR(1),
*               3  EPSW       PTR(8),
*               3  SYSISW     CHAR(1),
*               3  SYSPSW     CHAR(1),
*               3  OLDNEWSW   CHAR(1),
*               3  FLUSHSW    CHAR(1),
*               3  FLUSHSW1   CHAR(1),
*               3  DSDOSW     CHAR(1),
*               3  DSDISW     CHAR(1),
*               3  QUANSW     CHAR(1),
*               3  PARENSW    CHAR(1),
*               3  REPEATSW   CHAR(1),
*         2 FDPLGTH FIXED(15),
*         2 SGCADDR PTR(31),
*         2 FDPTR   PTR(31),
*         2 FDPTR1  PTR(31),
*         2 FDPTR2  PTR(31),
*         2  DUMMY2  PTR(31);
*  DCL 1 COMMON3 BASED(ADDR(DUMMY2)) BDY(WORD),
*               2    FDCTR     PTR(15),
*         2  LREMAIN PTR(31),
*               2     COMPCTR    PTR(31),
*               2  LMOVED    PTR(15),
*               2    U    PTR(31),
*               2 PICEND  PTR(15),
*         2 CURFDGM  PTR(31),
*         2  SWTCH,
*               3    SYSINSEL CHAR(1),
*               3  FIRSTSW     CHAR(1),
*               3  FRSTSW     CHAR(1),
*               3  STOPSW     CHAR(1),
*         2  COPYVAL      FIXED(15),
*         2  COPYFD       PTR(31),
*         2  COPYFDGM     PTR(31),
*         2  NAMCTR       FIXED(15),
*         2  NAMCTR1      FIXED(15),
*               2    INRECSZ   PTR(15),
*               2    OUTRECSZ  PTR(15),
*               2    INRECFM   CHAR(1),
*               2    RECOFFST  PTR(8),
*               2    OUTRECFM  CHAR(1),
*         2     PICBASE PTR(31),
*         2     MESSAGE CHAR(121),
*         2     DUMMY3  PTR(31);
*  DCL 1 DCBD BASED(DCBPTR) BDY(DWORD),
*               2  FILL CHAR(26),
*               2  DSORG1 CHAR(2),
*                                        3  DSORG  BIT(8),
*               2  FILLER CHAR(8),
*                   3  IOBAD CHAR(4),
*                   3  BFTEK BIT(8),
*                   3  EODAD CHAR(3),
*         2  RECFM  BIT(8),
*         2  EXLIST  PTR(24),
*         2 DDNAME CHAR(8),
*          3 DEBAD CHAR(4),
*              4 IFLGS BIT(8),
*         2     GETAD CHAR(4),
*                                   3 OFLGS BIT(8),
*                    3  OFLGS1  CHAR(1),
*                    3  MACRF    CHAR(2),
*         2     FILL2 CHAR(10),
*         2     BLKSI FIXED(15),
*         2     FILL3 CHAR(18),
*         2     LRECL FIXED(15),
*         2 FILL4 CHAR(172),
*         2 NEXTDCB PTR(31),
*               2  DDNAME1 CHAR(8),
*               2  EODSW   CHAR(1),
*               2 DCBSW1   CHAR(1),
*               2 DCBSW2   CHAR(1),
*         2     DCBSW3 BIT(8),
*         2     INREC  PTR(31),
*         2     GMLGTH FIXED(15),
*         2     FIELDSEL CHAR(1),
*         2     SPARE    CHAR(1);
*  DCL 1 FDTBL CHAR(520) BASED(FDPTR) BDY(WORD),
*               2    FDNAME    CHAR(8),
*               2    FDREPNM   CHAR(8),
*               2    FDINDNM   CHAR(8) BDY(WORD),
*                   3    FDUMMY CHAR(4),
*                    3    FDINDNUM  PTR(31),
*               2    FDLGTH    PTR(15),
*               2    FDCYCLE   PTR(15),
*               2    FDACTION  CHAR(2),
*               2    FDFORMAT  CHAR(2),
*               2    FDSWITCH  BIT(8),
*                  3      INDBYNAM  BIT(1),
*                   3  PASS     BIT(1),
*                   3  FXACTION BIT(1),
*                   3  RPACTION BIT(1),
*                   3  ROACTION BIT(1),
*                   3  WVACTION BIT(1),
*                   3  STACTION BIT(1),
*               3  NUACTION  BIT(1),
*               2    FDFILL    CHAR(1),
*               2    FDSIGN    CHAR(1),
*               2    FDCHAR    CHAR(1),
*               2    FDRANGE   CHAR(4),
*               2    FDOBUF    PTR(15),
*               2    FDFRINC   PTR(15),
*               2    FDFROMAD  CHAR(4),
*               2    FDMLGTH   PTR(15),
*               2    FDTOINC   PTR(15),
*               2    FDCYCCNT  PTR(15),
*               2    FDSLGTH   PTR(15),
*               2    FDSLGTHR  PTR(15),
*               2    FDFRINCR  CHAR(1),
*               2    FDTOINCR  CHAR(1),
*               2    LTOFREE  PTR(15),                      /*@ZA07345*
*               2    FDSW1  BIT(8),
*                   3    STRTLOC1  BIT(1);
*  DCL FOXZEROS  CHAR(16) INIT('F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0'X);
*   DCL BUFPTR      PTR(31);
*  DCL INBUF CHAR(80) BASED(R9);
*  DCL  BUFFER CHAR(32767) BASED(BUFPTR);
*  DCL RCODE FIXED(31) BDY(WORD) ;
*         DCL ON CHAR(1) INIT('FF'X);
*         DCL OFF CHAR(1) INIT('00'X);
*  DCL WKADDR CHAR(32767) BASED(GCADDR);
*  DCL COPAT CHAR(27) INIT(' Ö.<(+×&!$*);^-/,%_>?:#@''="');
*  DCL ALPAT CHAR(36) INIT('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789');
*  DCL OPTPTR PTR(31);
*  DCL PGPTR PTR(31);
*  DCL OPTIONS CHAR(256) BASED(OPTPTR);
*  DCL PAGE CHAR(256) BASED(PGPTR);
*  DCL DDLST CHAR(256) BASED(DDPTR);
*  /*******************************************************************
*  /**                                                                *
*  /** THIS SECTION WILL CLOSE THE OUTPUT DCB DEFINED ON THE DSD CARD *
*  /** ITS ADDRESS IS CONTAINED IN FIRSTGMO.AFTER THE CLOSE THE BUFFER*
*  /** POOL IS FREED AND CORE IS FREED THAT HELD THE DCB.CODE IS      *
*  /** PRESENT FOR MORE THAN ONE OUTPUT DCB ALTHOUGH ONE OUTPUT       *
*  /** IS ALLOWED AT THE PRESENT TIME                                 *
*  /**                                                                *
*  /**    THIS SECTION CHECKS FOR MORE OUTPUT DCBS TO CLOSE.IF NONE A *
*  /** BRANCH IS TAKEN TO TEST FOR INPUT DCBS                         *
*  /**                                                                *
*  /*******************************************************************
*  A2J3:;
*         IF FIRSTGMO = 0 THEN GO TO A2J4;
A2J3     SR    @F,@F                                              0042
         C     @F,380(0,@5)                                       0042
         BC    08,A2J4                                            0043
*               DCBPTR = FIRSTGMO /**REINITILIZE DCB POINTER**/;
         MVC   300(4,@5),380(@5)                                  0044
*  /*******************************************************************
*  /**                                                                *
*  /**    THIS SECTION WILL INITILIZE THE DCB POINTER AND TEST FOR THE*
*  /** DCB BEING OPEN.IF NOT OPEN A BRANCH IS TAKEN AROUND THE CLOSE  *
*  /** AND FREEPOOL.IF OPEN THE LIST IS INITILIZED FOR CLOSE WITH     *
*  /** DISPOSITION FROM THE DD CARD AND THE CLOSE MACRO IS ISSUED.    *
*  /**                                                                *
*  /*******************************************************************
*         IF OFLGS(4) = '1'B THEN DO /** CLOSE DCB IF OPEN**/;
         L     @1,300(0,@5)        
         TM    48(@1),B'00010000'                                 0045
         BC    12,@9FF                                            0045
*               OPTBYTE1 = FIRSTGMO /* OUTPUT DCB ADDR TO CLOSE */;
         MVC   236(4,@5),380(@5)                                  0047
*         OPTBYTE1(1) = '8F'X;
         MVI   236(@5),X'8F'                                      0048
*  /** IF DCB IS OPEN OUTREC CONTAINS ADDRESS OF OUTPUT WORKAREA.    **
*  /** ITS LENGTH IS IN GMLGTH FIELD OF DCB                           *
*               R7 = GMLGTH    /**PICK UP WORKAREA LENGTH**/;
         L     @1,300(0,@5)        
         LH    @7,276(0,@1)                                       0049
*         R6 = ADDR(OUTREC);
         LA    @6,308(0,@5)                                       0050
*         R1 = ADDR(GETMLIST)  /**  ADDRESS  THE GET MAIN LIST**/;
         LA    @1,364(0,@5)                                       0051
*     IF   OUTREC=0  THEN GO TO L1;                          /*A32655*/
         SR    @F,@F                                              0052
         C     @F,308(0,@5)                                       0052
         BC    08,L1                                              0053
*                        /**   FREEMAIN FOR WORKAREA    **/;
*         GEN ( FREEMAIN E,LV=(R7),A=(R6),SP=0,MF=(E,(R1)));
          FREEMAIN E,LV=(R7),A=(R6),SP=0,MF=(E,(R1))
         DS    0H
*   L1:;                                                     /*A32655*/
*         R1 = ADDR(OPENLIST);
L1       LA    @1,236(0,@5)                                       0057
*         GEN (CLOSE MF=(E,(1)));
         CLOSE MF=(E,(1))
         DS    0H
*  GEN ( EJECT);
          EJECT
         DS    0H
*  /*******************************************************************
*  /**                                                                *
*  /**    THIS SECTION ISSUES A FREEPOOL MACRO FOR THE DCB JUST CLOSED*
*  /** DATA MANAGENENT DOES NOT FREE ANY BUFFERS IT GETS FOR US.      *
*  /**                                                                *
*  /*******************************************************************
*               R1 = FIRSTGMO            /*OUTPUT DCBAD TO REGISTER*/;
         L     @1,380(0,@5)                                       0060
*                                        /* FREE THE BUFFER POOL*/
*         GEN ( FREEPOOL (R1));
          FREEPOOL (R1)
         DS    0H
*         END;
*  /*******************************************************************
*  /**                                                                *
*  /**    THIS SECTION PLACES ADDRESS OF NEXTDCB IN FIRSTGMO POINTER  *
*  /** IF NO NEXTDCB BINARY ZEROS ARE PLACED IN FIRSTGMO AS  THE AREA *
*  /** FOR THE DCB WAS CLEARED TO BINARY ZEROS AFTER THE GETMAIN      *
*  /**                                                                *
*  /*******************************************************************
*               DCBPTR = FIRSTGMO        /* FILL DCBPTR WITH DCBADDR*/;
@9FF     MVC   300(4,@5),380(@5)                                  0063
*               FIRSTGMO = NEXTDCB       /*NEXT DCB ADDR TO FIRSTGMO*/;
         L     @1,300(0,@5)        
         MVC   380(4,@5),256(@1)                                  0064
*  /*******************************************************************
*  /**    THIS SECTION SETS UP REGISTERS AND ISSUES A FREEMAIN FOR 280*
*  /** BYTES.A FREEMAIN IS NEEDED EVEN IF A DCB WAS NOT OPEN.         *
*  /**                                                                *
*  /*******************************************************************
*               R6 = ADDR(DCBPTR)        /* CORE LIST ADDRESS*/;
         LA    @6,300(0,@5)                                       0065
*               R1 = ADDR(GETMLIST) /**ADDRESS THE GET MAIN LIST**/;
         LA    @1,364(0,@5)                                       0066
*                                        /*FREEMAIN FOR DCB*/
*         GEN ( FREEMAIN E,LV=280,A=(R6),SP=0,MF=(E,(R1)));
          FREEMAIN E,LV=280,A=(R6),SP=0,MF=(E,(R1))
         DS    0H
*  GEN ( EJECT);
          EJECT
         DS    0H
*         IF FIRSTGMO ^= 0 THEN GO TO A2J3 /* BR MORE TO FREE*/;
         SR    @F,@F                                              0069
         C     @F,380(0,@5)                                       0069
         BC    07,A2J3                                            0070
*  /*******************************************************************
*  /**                                                                *
*  /** THIS SECTION WILL CLOSE ALL INPUT DCBS OPENED FOR THIS DSD     *
*  /** GROUP.EACH BUFFER POOL IS FREED AND DYNAMIC CORE RETURNED TO   *
*  /** THE SYSTEM.LINKAGE IS THROUGH FIRSTGMI AND NEXTDCB.LAST DCB    *
*  /** WILL HAVE BINARY ZEROS PRESENT IN NEXTDCB FIELD.CONTROL IS     *
*  /** RETURNED TO THE BASE MODULE WHEN FIRSTGMI IS ZERO.             *
*  /**                                                                *
*  /*******************************************************************
*  A2J4:;
*  /*******************************************************************
*  /**                                                                *
*  /**    THIS SECTION WILL BRANCH TO A2J6 TO TEST FOR END OF DSD     *
*  /** GROUP IF THERE ARE NO INPUT DCBS TO CLOSE.                     *
*  /**                                                                *
*  /*******************************************************************
*         IF FIRSTGMI = 0 THEN GO TO A2J6 /**BRANCH NO MORE INPUT DCB**
A2J4     SR    @F,@F                                              0072
         C     @F,392(0,@5)                                       0072
         BC    08,A2J6                                            0073
*  A2J5:           DCBPTR = FIRSTGMI; /*REINITILIZE DCBPTR COR  A48773*
A2J5     MVC   300(4,@5),392(@5)                                  0074
*  /*******************************************************************
*  /**                                                                *
*  /**    IF INPUT DCB IS NOT OPEN A BRANCH IS TAKEN TO FREEMAIN      *
*  /**                                                                *
*  /*******************************************************************
*         IF OFLGS(4) = '1'B THEN DO /** CLOSE DCB IF OPEN**/;
         L     @1,300(0,@5)        
         TM    48(@1),B'00010000'                                 0075
         BC    12,@9FE                                            0075
*  /*******************************************************************
*  /**                                                                *
*  /**    THIS SECTION INITILIZES THE LIST FOR CLOSEING OF THE INPUT  *
*  /** DCB.DISPOSITION IS TAKEN FROM THE DD CARD.                     *
*  /**                                                                *
*  /*******************************************************************
*               OPTBYTE1 = FIRSTGMI      /* INPUT DCBAD TO LIST*/;
         MVC   236(4,@5),392(@5)                                  0077
*                                        /*  DECLARE OPTION FOR CLOSE*/
*                                        /* TAKE DISP FROM DD CARD*/
*               OPTBYTE1(1) = '80'X      /*  OPTION = LAST,DISP*/;
         MVI   236(@5),X'80'                                      0078
*  /** IF INPUT DCB IS OPEN INREC CONTAINS ADDRESS OF INPUT WORKAREA  *
*  /** LENGTH IS TAKEN FROM GMLGTH OF DCB FOR FREEING                 *
*               R7 = GMLGTH    /**PICK UP WORKAREA LENGTH**/;
         L     @1,300(0,@5)        
         LH    @7,276(0,@1)                                       0079
*         R6 = ADDR(INREC) /**GET INPUT WORKAREA PTR**/;
         LA    @6,272(0,@1)                                       0080
*         R1 = ADDR(GETMLIST)  /**  ADDRESS  THE GET MAIN LIST**/;
         LA    @1,364(0,@5)                                       0081
*                        /**   FREEMAIN FOR WORKAREA    **/;
*         GEN ( FREEMAIN E,LV=(R7),A=(R6),SP=0,MF=(E,(R1)));
          FREEMAIN E,LV=(R7),A=(R6),SP=0,MF=(E,(R1))
         DS    0H
*               R1 = ADDR(OPENLIST)      /*LIST ADDR FOR CLOSE*/;
         LA    @1,236(0,@5)                                       0084
*         GEN ( CLOSE MF=(E,(1)));
          CLOSE MF=(E,(1))
         DS    0H
*                   /* DCB NOW CLOSED */
*  GEN ( EJECT);
          EJECT
         DS    0H
*  /*******************************************************************
*  /**    THIS SECTION FREES THE BUFFERS GOTTEN BY DATA MANAGEMENT.   *
*  /*******************************************************************
*               R1 = FIRSTGMI /*INPUT DCB TO REGISTER*/;
         L     @1,392(0,@5)                                       0087
*                                        /* FREE THE BUFFER POOL*/
*         GEN ( FREEPOOL (R1));
          FREEPOOL (R1)
         DS    0H
*         END;
*  /*******************************************************************
*  /**    THIS SECTION INITILIZES THE POINTER TO THE NEXT DCB AND SETS*
*  /** UP REGISTERS FOR A FREEMAIN OF 280 BYTES USED FOR THE DCB.     *
*  /*******************************************************************
*               DCBPTR = FIRSTGMI        /* ADDRESS THE DCB */;
@9FE     MVC   300(4,@5),392(@5)                                  0090
*               FIRSTGMI = NEXTDCB       /*NEXT DCB ADDR TO FIRSTGMI*/;
         L     @1,300(0,@5)        
         MVC   392(4,@5),256(@1)                                  0091
*               R6 = ADDR(DCBPTR)        /* CORE LIST ADDRESS*/;
         LA    @6,300(0,@5)                                       0092
*               R1 = ADDR(GETMLIST) /**ADDRESS THE GET MAIN LIST**/;
         LA    @1,364(0,@5)                                       0093
*         GEN ( FREEMAIN E,LV=280,A=(R6),SP=0,MF=(E,(R1)));
          FREEMAIN E,LV=280,A=(R6),SP=0,MF=(E,(R1))
         DS    0H
*         IF FIRSTGMI ^= 0 THEN GO TO A2J5 /*BR IF MORE TO FREE*/;
         SR    @F,@F                                              0095
         C     @F,392(0,@5)                                       0095
         BC    07,A2J5                                            0096
*  GEN ( EJECT);
          EJECT
         DS    0H
*  /*******************************************************************
*  /**                                                                *
*  /**    THIS SECTION WILL TEST FOR ENTRY AS A RESULT OF FINDING AN  *
*  /** END CARD IN THE INPUT STREAM.IF END IS PRESENT WE DO NOT CLOSE *
*  /** THE DATA GENERATOR INPUT AND OUTPUT DCBS AS THEY MAY BE NEEDED *
*  /** FOR MORE DSD GROUPS.CONTROL RETURNS TO THE BASE MODULE IN THIS *
*  /** CASE.WHEN ENTRY IS A RESULT OF FINDING THE SYSIN DELIMITER CARD*
*  /** FIRSTGMO AND FIRSTGMI SHOULD BE ZERO.WE ARE  DEFINED IN THE SRL*
*  /** AS REQUIREING AN END CARD FOR EACH GROUP,HOWEVER IF ONE IS NOT *
*  /** PRESENT FOR THE LAST GROUP,THE USER DCBS GET CLOSED ANYWAY     *
*  /**                                                                *
*  /*******************************************************************
*  A2J6:;
*  /** THIS SECTION WILL PLACE FOXES IN NAME FIELDS OF FDTBLS THAT    *
*  /** WERE USED FOR FIELD SELECTION.SELECTION IS INDICATED BY A NAME *
*  /** IN THE FDREPNM FIELD.THIS MUST BE DONE SO THAT THE USER MAY    *
*  /** NEVER ACCESS THE NAME IN ANOTHER DSD GROUP.THE FROMAD IS       *
*  /** DYNAMIC AS INREC WAS GOTTEN WHEN THE DCB WAS OPENED.THE RECORD *
*  /** IS READ INTO INREC BY THE 'GET' OF THE CREATE MODULE.INREC HAS *
*  /** BEEN FREED SO IT CAN BE SEEN THAT IF THE NAME WAS ACCESSED IN  *
*  /** ANOTHER DSD GROUP THAT INCORRECT INFORMATION WOULD BE OBTAINED *
*  /** THE DATA SETS MUST BE REDEFINED FOR EACH DSD GROUP AS THEY ARE *
*  /** FREED BY THIS MODULE.SYSIN DOESNT NEED REDEFINING BUT ANY      *
*  /** RECORD SELECTION ASSOCIATED WITH INPUT MUST BE REDEFINED       *
*  /**  FD NAMES THAT ARE BE BLANKED OUT MUST BE REDEFINED IF USED    *
*  /** AGAIN.                                                         *
*  /**                                                                *
*      IF FDPTR1 ^= 0 THEN DO /* DO IF FDPTR IS NOT ZERO    A36081 */;
A2J6     SR    @F,@F                                              0099
         C     @F,600(0,@5)                                       0099
         BC    08,@9FD                                            0099
*               R7 = FDPTR1    /** PICK UP FIRST TABLE ADDRESS **/;
         L     @7,600(0,@5)                                       0101
*  A2J64:;
*               R6 = R7        /** COPY TABLE ADDRESS **/;
A2J64    LR    @6,@7                                              0103
*  /**LMOVED IS USED AS COUNTER,IT IS INIT TO ZERO WHEN USED ELSEWHERE*
*               LMOVED = 0     /** INIT COUNTER FOR SCAN**/;
         SR    @F,@F                                              0104
         STH   @F,620(0,@5)                                       0104
*  A2J65:;
*   /**  IF NAME IS PRESENT DO BELOW**/
*               LMOVED = LMOVED + 1 ; /* ADD ONE TO COUNTER A48747 */
A2J65    LA    @F,1                                               0106
         AH    @F,620(0,@5)                                       0106
         STH   @F,620(0,@5)                                       0106
*       IF R6 -> FDREPNM(1) ^= '00'X THEN DO; /* IF INPUT DO BELOW */
         CLI   8(@6),X'00'                                        0107
         BC    08,@9FC                                            0107
*         R6 -> FDNAME = 'FFFFFFFFFFFFFFFF'X /** FOXES TO NAME FIELD**/
         MVC   0(8,@6),@X5                                        0109
*         END;
*         IF LMOVED ^= 8 THEN DO /** BR IF NOT AT END OF TABLE**/;
@9FC     LA    @F,8                                               0111
         CH    @F,620(0,@5)                                       0111
         BC    08,@9FB                                            0111
*               R6 = R6 + 64   /** POINTER TO NEXT SECTION **/;
         AH    @6,@D1                                             0113
*               GO TO A2J65    /** BRANCH TO KEEP LOOKING**/;
         BC    15,A2J65                                           0114
*         END;
*    /**  BRANCH IF DONE**/
*         IF R7 -> FDTBL(517:520) = '00000000'X THEN GO TO A2J66 ;
@9FB     CLC   516(4,@7),@X6                                      0116
         BC    08,A2J66                                           0117
*         R7 = R7 -> FDTBL(517:520) /**PICK UP NEXT TABLE ADDRESS**/;
         L     @7,516(0,@7)                                       0118
*               GO TO A2J64         /**BR TO START LOOKING AGAIN**/;
         BC    15,A2J64                                           0119
*       END;
*  A2J66:;
@9FD     EQU   *                                                  0121
*         IF ENDSW = ON THEN GO TO A2J7 /** BR NOT END OF JOB**/;
A2J66    CLC   564(1,@5),ON                                       0122
         BC    08,A2J7                                            0123
*  /*******************************************************************
*  /**    THIS SECTION FREES CORE OBTAINED FOR THE FD TABLES.AT ENTRY *
*  /** FDPTR1 CONTAINS ADDRESS OF FIRST FD TABLE.LINK ADDRESS TO THE  *
*  /** NEXT FD TABLE IS MAINTAINED AT BYTE LOCATION 517-520 OF CURRENT*
*  /** TABLE.THIS LOCATION WILL BE ZERO WHEN WE ARE ADDRESSING THE    *
*  /** LAST TABLE                                                     *
*  /*******************************************************************
*  A2J67:;
*         IF FDPTR1 ^= 0 THEN DO /** DO BELOW IF FDPTR NOT ZERO**/;
A2J67    SR    @F,@F                                              0125
         C     @F,600(0,@5)                                       0125
         BC    08,@9FA                                            0125
*         R6 = ADDR(FDPTR1) /** PICK UP FDPTR**/;
         LA    @6,600(0,@5)                                       0127
*         FDPTR = FDPTR1  /** PICKUP ADDRESS NEXT FDTABEL**/ ;
         MVC   596(4,@5),600(@5)                                  0128
*  LMOVED = 0 ;                   /** SET COUNTER TO ZERO       A50950
         SR    @F,@F                                              0129
         STH   @F,620(0,@5)                                       0129
*  A2J67A:;
*              IF FDACTION = 'RO' THEN DO;   /* ROLL ACTION     A50950*
A2J67A   L     @1,596(0,@5)        
         CLC   28(2,@1),@C7                                       0131
         BC    07,@9F9                                            0131
*                 FDFROMAD = FDFROMAD - FDLGTH ; /* RESET POINT A50950*
         LH    @F,24(0,@1)                                        0133
         LCR   @F,@F                                              0133
         AL    @F,44(0,@1)                                        0133
         ST    @F,44(0,@1)                                        0133
*              END;                        /*TO START OF FIELD  A50950*
*          R7 = ADDR(FDFROMAD) ;  /** R7 WITH THE FD FLD ADDR.  A50950
@9F9     L     @1,596(0,@5)        
         LA    @7,44(0,@1)                                        0135
* GENERATE(  SR  8,8);                  /* CLEAR REG 8        @ZA07345*
           SR  8,8
         DS    0H
* GENERATE(  ICM 8,3,60(1));       /* GET LENGTH OF FD FIELD  @ZA07345*
           ICM 8,3,60(1)
         DS    0H
*             IF R8 ^= 0 THEN DO ;   /** IS A FD FLD PRESENT ?  A50950
         LTR   @8,@8                                              0138
         BC    08,@9F8                                            0138
*                R1 = ADDR(GETMLIST) ;   /** THEN DO            A50950
         LA    @1,364(0,@5)                                       0140
*                GEN ( FREEMAIN E,LV=(R8),A=(R7),SP=0,MF=(E,(R1))) ;
          FREEMAIN E,LV=(R8),A=(R7),SP=0,MF=(E,(R1))
         DS    0H
*                                                            /* A50950
*             END ;                                          /* A50950
*             FDPTR = FDPTR+64 ;     /** GET NEXT FD FLD ADDR.  A50950
@9F8     LA    @F,64                                              0143
         A     @F,596(0,@5)                                       0143
         ST    @F,596(0,@5)                                       0143
*             LMOVED = LMOVED + 1 ;        /** UPDATE COUNTER   A50950
         LA    @F,1                                               0144
         AH    @F,620(0,@5)                                       0144
         STH   @F,620(0,@5)                                       0144
*                IF LMOVED ^= 8 THEN DO ;  /** 8 FD FLDS HAD ?  A50950
         LA    @F,8                                               0145
         CH    @F,620(0,@5)                                       0145
*                   GO TO A2J67A ;   /** NO, FREEM. NEXT FD FLD A50950
         BC    07,A2J67A                                          0147
*                END ;               /** YES, CONTINUE          A50950
*         FDPTR = FDPTR1 ;   /** PICKUP ADDRESS NEXT FDTABEL    A50950
@9F7     MVC   596(4,@5),600(@5)                                  0149
*         FDPTR = FDTBL(517:520) ;
         L     @1,596(0,@5)        
         L     @F,516(0,@1)                                       0150
         ST    @F,596(0,@5)                                       0150
*        R1 = ADDR(GETMLIST)  /** ADDRESS THE GET MAIN LIST **/ ;
         LA    @1,364(0,@5)                                       0151
*         GEN ( FREEMAIN E,LV=520,A=(R6),SP=0,MF=(E,(R1)));
          FREEMAIN E,LV=520,A=(R6),SP=0,MF=(E,(R1))
         DS    0H
*         FDPTR1 = FDPTR ;
         MVC   600(4,@5),596(@5)                                  0153
*         GO TO A2J67 /** FREE NEXT FDTBL AREA **/ ;
         BC    15,A2J67                                           0154
*         END ;
*  /*******************************************************************
*  /**    THIS SECTION WILL CLOSE AND FREEPOOL THE SYSI DCB OF THE    *
*  /** DATA GENERATOR.                                                *
*  /*******************************************************************
*               DCBPTR = ADDR(SYSI) /**PICK UP SYSI DCB ADDRESS**/;
@9FA     LA    @F,116(0,@5)                                       0156
         ST    @F,300(0,@5)                                       0156
*         IF OFLGS(4) = '1'B THEN DO /**BRANCH IF DCB NOT OPENED**/;
         L     @1,300(0,@5)        
         TM    48(@1),B'00010000'                                 0157
         BC    12,@9F6                                            0157
*               OPTBYTE1 = DCBPTR /**DCB ADDRESS TO LIST**/;
         MVC   236(4,@5),300(@5)                                  0159
*               OPTBYTE1(1) = '80'X /** INITILIZE OPTIONS**/;
         MVI   236(@5),X'80'                                      0160
*               R1 = ADDR(OPENLIST) /**ADDRESS THE LIST**/;
         LA    @1,236(0,@5)                                       0161
*         GEN ( CLOSE MF=(E,(R1)));
          CLOSE MF=(E,(R1))
         DS    0H
*               R1 = DCBPTR    /**PICK UP DCB ADDRESS**/;
         L     @1,300(0,@5)                                       0163
*         GEN ( FREEPOOL (R1));
          FREEPOOL (R1)
         DS    0H
*         END;
*  GEN ( EJECT);
@9F6     EQU   *                                                  0166
          EJECT
         DS    0H
*  /*******************************************************************
*  /**    THIS SECTION WILL CLOSE AND FREEPOOL THE SYSP DCB OF THE    *
*  /** DATA GENERATOR.                                                *
*  /*******************************************************************
*               DCBPTR = ADDR(SYSP) /**PICK UP SYSP DCB ADDRESS**/;
         LA    @F,20(0,@5)                                        0167
         ST    @F,300(0,@5)                                       0167
*         IF OFLGS(4) = '1'B THEN DO /**BRANCH IF DCB NOT OPEN**/;
         L     @1,300(0,@5)        
         TM    48(@1),B'00010000'                                 0168
         BC    12,@9F5                                            0168
*               OPTBYTE1 = DCBPTR /**DCB ADDRESS TO LIST**/;
         MVC   236(4,@5),300(@5)                                  0170
*               OPTBYTE1(1) = '8F'X /**INITILIZE OPTIONS**/;
         MVI   236(@5),X'8F'                                      0171
*               R1 = ADDR(OPENLIST) /**ADDRESS THE LIST**/;
         LA    @1,236(0,@5)                                       0172
*         GEN ( CLOSE MF=(E,(R1)));
          CLOSE MF=(E,(R1))
         DS    0H
*               R1 = DCBPTR /**PICK UP DCB ADDRESS**/;
         L     @1,300(0,@5)                                       0174
*         GEN (FREEPOOL (R1));
         FREEPOOL (R1)
         DS    0H
*         END;
*  GEN ( EJECT);
@9F5     EQU   *                                                  0177
          EJECT
         DS    0H
*  /*******************************************************************
*  /*******************************************************************
*  /** ***** NOTICE THERE IS NO FREEMAIN FOR THE SYSI AND SYSP DCBS.  *
*  /** ***** THEY EXIST IN THE COMMON AREA WHICH IS FREED WHEN A      *
*  /** ***** RETURN IS GIVEN FROM THE BASE MODULE.                    *
*  /*******************************************************************
*  /*******************************************************************
*  A2J7:;
*         RETURN;
*         END IEBDGCUP;
@EL01    L     @D,4(0,@D)                                         0180
         LR    @1,@C                                              0180
         L     @0,@SIZ001                                         0180
         FREEMAIN R,LV=(0),A=(1)                                  0180
         L     @E,12(0,@D)                                        0180
         LM    @0,@8,20(@D)                                       0180
         LM    @A,@C,60(@D)                                       0180
         BCR   15,@E                                              0180
@DATA1   EQU   *
@0       EQU   00                  EQUATES FOR REGISTERS 0-15
@1       EQU   01
@2       EQU   02
@3       EQU   03
@4       EQU   04
@5       EQU   05
@6       EQU   06
@7       EQU   07
@8       EQU   08
@9       EQU   09
@A       EQU   10
@B       EQU   11
@C       EQU   12
@D       EQU   13
@E       EQU   14
@F       EQU   15
@D1      DC    H'64'
         DS    0F
@SIZ001  DC    AL1(&SPN)
         DC    AL3(@DATEND-@DATD)
         DS    0F
@X5      DC    X'FFFFFFFFFFFFFFFF'
@X6      DC    X'00000000'
@C7      DC    C'RO'
         DS    0D
@DATA    EQU   *
R14      EQU   00000014            FULLWORD INTEGER REGISTER
R15      EQU   00000015            FULLWORD INTEGER REGISTER
R0       EQU   00000000            FULLWORD INTEGER REGISTER
R1       EQU   00000001            FULLWORD INTEGER REGISTER
R2       EQU   00000002            FULLWORD INTEGER REGISTER
R3       EQU   00000003            FULLWORD INTEGER REGISTER
R5       EQU   00000005            FULLWORD POINTER REGISTER
R6       EQU   00000006            FULLWORD POINTER REGISTER
R7       EQU   00000007            FULLWORD POINTER REGISTER
R8       EQU   00000008            FULLWORD POINTER REGISTER
R9       EQU   00000009            FULLWORD POINTER REGISTER
COMMON   EQU   00000000            308 BYTE(S) ON DWORD
PAGENO   EQU   COMMON+00000000     4 BYTE(S)
LINECT   EQU   COMMON+00000004     FULLWORD INTEGER
LINECTR  EQU   COMMON+00000008     FULLWORD INTEGER
PARM     EQU   COMMON+00000012     FULLWORD POINTER
REPEATNO EQU   COMMON+00000016     HALFWORD INTEGER
CREATENO EQU   COMMON+00000018     HALFWORD INTEGER
SYSP     EQU   COMMON+00000020     96 BYTE(S)
SYSI     EQU   COMMON+00000116     96 BYTE(S)
Q        EQU   COMMON+00000216     16 BYTE(S) ON DWORD
QFILL    EQU   COMMON+00000216     7 BYTE(S)
QSIGN    EQU   COMMON+00000223     8 BIT(S)
QFILL1   EQU   COMMON+00000224     7 BYTE(S)
QSIGN1   EQU   COMMON+00000231     8 BIT(S)
COUNTER  EQU   COMMON+00000232     FULLWORD POINTER
OPENLIST EQU   COMMON+00000236     8 BYTE(S)
OPTBYTE1 EQU   COMMON+00000236     4 BYTE(S)
OPTBYTE2 EQU   COMMON+00000240     4 BYTE(S)
EXLST    EQU   COMMON+00000244     24 BYTE(S) ON WORD
INHDR    EQU   COMMON+00000244     1 BYTE(S)
INHDR1   EQU   COMMON+00000245     3  BYTE  POINTER ON WORD+1
OUTHDR   EQU   COMMON+00000248     1 BYTE(S)
OUTHDR1  EQU   COMMON+00000249     3  BYTE  POINTER ON WORD+1
INTRL    EQU   COMMON+00000252     1 BYTE(S)
INTRL1   EQU   COMMON+00000253     3  BYTE  POINTER ON WORD+1
OUTTRL   EQU   COMMON+00000256     1 BYTE(S)
OUTTRL1  EQU   COMMON+00000257     3  BYTE  POINTER ON WORD+1
EXITDCB  EQU   COMMON+00000260     1 BYTE(S)
EXITDCB1 EQU   COMMON+00000261     3  BYTE  POINTER ON WORD+1
TOTAL    EQU   COMMON+00000264     1 BYTE(S)
TOTAL1   EQU   COMMON+00000265     3  BYTE  POINTER ON WORD+1
EXLST1   EQU   COMMON+00000268     4 BYTE(S) ON WORD
EDCB1    EQU   COMMON+00000268     1 BYTE(S)
EDCB2    EQU   COMMON+00000269     3  BYTE  POINTER ON WORD+1
EXLST2   EQU   COMMON+00000272     4 BYTE(S) ON WORD
EDCB3    EQU   COMMON+00000272     1 BYTE(S)
EDCB4    EQU   COMMON+00000273     3  BYTE  POINTER ON WORD+1
EXLST3   EQU   COMMON+00000276     4 BYTE(S) ON WORD
EDCB5    EQU   COMMON+00000276     1 BYTE(S)
EDCB6    EQU   COMMON+00000277     3  BYTE  POINTER ON WORD+1
DLRECL   EQU   COMMON+00000280     HALFWORD INTEGER
DBLKSI   EQU   COMMON+00000282     HALFWORD INTEGER
DRECFM   EQU   COMMON+00000284     8 BIT(S)
LEFTOVER EQU   COMMON+00000288     FULLWORD INTEGER
OFFSET   EQU   COMMON+00000292     FULLWORD POINTER
LPTR     EQU   COMMON+00000296     FULLWORD POINTER
DCBPTR   EQU   COMMON+00000300     FULLWORD POINTER
DUMMY    EQU   COMMON+00000304     FULLWORD POINTER
COMMON1  EQU   00000304            236 BYTE(S) ON WORD
SAVEMS   EQU   COMMON1+00000000    HALFWORD INTEGER
CONCODE  EQU   COMMON1+00000002    HALFWORD INTEGER
OUTREC   EQU   COMMON1+00000004    FULLWORD POINTER
CRTABPT  EQU   COMMON1+00000008    FULLWORD POINTER
CURCRTE  EQU   COMMON1+00000012    FULLWORD POINTER
CURCRGM  EQU   COMMON1+00000016    FULLWORD POINTER
CURPIC   EQU   COMMON1+00000020    FULLWORD POINTER
PICCTR   EQU   COMMON1+00000024    FULLWORD INTEGER
EXITTAB  EQU   COMMON1+00000028    FULLWORD POINTER
EXITGM   EQU   COMMON1+00000032    FULLWORD POINTER
CUREXIT  EQU   COMMON1+00000036    FULLWORD POINTER
DELIM    EQU   COMMON1+00000040    4 BYTE(S)
RECREM   EQU   COMMON1+00000044    FULLWORD INTEGER
CURFD    EQU   COMMON1+00000048    FULLWORD POINTER
CUROUT   EQU   COMMON1+00000052    FULLWORD POINTER
SAVE14   EQU   COMMON1+00000056    FULLWORD POINTER
GETMLIST EQU   COMMON1+00000060    16 BYTE(S) ON WORD
GLENGTH  EQU   COMMON1+00000060    FULLWORD INTEGER
ADRLIST  EQU   COMMON1+00000064    FULLWORD POINTER
IND      EQU   COMMON1+00000068    4 BYTE(S)
GCODE    EQU   COMMON1+00000068    1 BYTE(S)
SPOOL    EQU   COMMON1+00000069    1 BYTE(S)
CCODE    EQU   COMMON1+00000070    2 BYTE(S)
GCADDR   EQU   COMMON1+00000072    FULLWORD POINTER
FIRSTGMO EQU   COMMON1+00000076    FULLWORD POINTER
CURRGMO  EQU   COMMON1+00000080    FULLWORD POINTER
LASTGMO  EQU   COMMON1+00000084    FULLWORD POINTER
FIRSTGMI EQU   COMMON1+00000088    FULLWORD POINTER
CURRGMI  EQU   COMMON1+00000092    FULLWORD POINTER
LASTGMI  EQU   COMMON1+00000096    FULLWORD POINTER
CONDCODE EQU   COMMON1+00000100    HALFWORD INTEGER
MS       EQU   COMMON1+00000102    HALFWORD INTEGER
INBUFA1  EQU   COMMON1+00000104    121 BYTE(S)
INFILL   EQU   COMMON1+00000104    10 BYTE(S)
INBUFA   EQU   COMMON1+00000114    111 BYTE(S)
DDPTR    EQU   COMMON1+00000228    FULLWORD POINTER
DUMMY1   EQU   COMMON1+00000232    FULLWORD POINTER
COMMON2  EQU   00000536            76 BYTE(S) ON WORD
SWITCH   EQU   COMMON2+00000000    52 BYTE(S)
FDCSW    EQU   COMMON2+00000000    1 BYTE(S)
FDNAMESW EQU   COMMON2+00000001    1 BYTE(S)
FDPCSW   EQU   COMMON2+00000002    1 BYTE(S)
FDFMTSW  EQU   COMMON2+00000003    1 BYTE(S)
FDPLSW   EQU   COMMON2+00000004    1 BYTE(S)
RANGESW  EQU   COMMON2+00000005    1 BYTE(S)
FILLSW   EQU   COMMON2+00000006    1 BYTE(S)
REPSW    EQU   COMMON2+00000007    1 BYTE(S)
INDEXSW  EQU   COMMON2+00000008    1 BYTE(S)
INDNMSW  EQU   COMMON2+00000009    1 BYTE(S)
BQUOTESW EQU   COMMON2+00000010    1 BYTE(S)
PQUOTESW EQU   COMMON2+00000011    1 BYTE(S)
EQUOTESW EQU   COMMON2+00000012    1 BYTE(S)
FDSW     EQU   COMMON2+00000013    1 BYTE(S)
DSDSW    EQU   COMMON2+00000014    1 BYTE(S)
NOGOSW   EQU   COMMON2+00000015    1 BYTE(S)
CREATESW EQU   COMMON2+00000016    1 BYTE(S)
DSDCSW   EQU   COMMON2+00000017    1 BYTE(S)
CRCSW    EQU   COMMON2+00000018    1 BYTE(S)
EXITSW   EQU   COMMON2+00000019    1 BYTE(S)
EODSTOP  EQU   COMMON2+00000020    1 BYTE(S)
DSDNULSW EQU   COMMON2+00000021    1 BYTE(S)
DSDORGSW EQU   COMMON2+00000022    1 BYTE(S)
DSDDDSW  EQU   COMMON2+00000023    1 BYTE(S)
CRTBLK   EQU   COMMON2+00000024    1 BYTE(S)
NAMCSW   EQU   COMMON2+00000025    8 BIT(S)
PICCSW   EQU   COMMON2+00000026    8 BIT(S)
BUFPSW   EQU   COMMON2+00000027    1 BYTE(S)
ENDSW    EQU   COMMON2+00000028    1 BYTE(S)
COMCSW   EQU   COMMON2+00000029    1 BYTE(S)
FLAGSW   EQU   COMMON2+00000030    8 BIT(S)
PAGESW   EQU   COMMON2+00000031    1 BYTE(S)
EPSW     EQU   COMMON2+00000032    1  BYTE  POINTER
SYSISW   EQU   COMMON2+00000033    1 BYTE(S)
SYSPSW   EQU   COMMON2+00000034    1 BYTE(S)
OLDNEWSW EQU   COMMON2+00000035    1 BYTE(S)
FLUSHSW  EQU   COMMON2+00000036    1 BYTE(S)
FLUSHSW1 EQU   COMMON2+00000037    1 BYTE(S)
DSDOSW   EQU   COMMON2+00000038    1 BYTE(S)
DSDISW   EQU   COMMON2+00000039    1 BYTE(S)
QUANSW   EQU   COMMON2+00000040    1 BYTE(S)
PARENSW  EQU   COMMON2+00000041    1 BYTE(S)
REPEATSW EQU   COMMON2+00000042    1 BYTE(S)
FDPLGTH  EQU   COMMON2+00000052    HALFWORD INTEGER
SGCADDR  EQU   COMMON2+00000056    FULLWORD POINTER
FDPTR    EQU   COMMON2+00000060    FULLWORD POINTER
FDPTR1   EQU   COMMON2+00000064    FULLWORD POINTER
FDPTR2   EQU   COMMON2+00000068    FULLWORD POINTER
DUMMY2   EQU   COMMON2+00000072    FULLWORD POINTER
COMMON3  EQU   00000608            188 BYTE(S) ON WORD
FDCTR    EQU   COMMON3+00000000    HALFWORD POINTER
LREMAIN  EQU   COMMON3+00000004    FULLWORD POINTER
COMPCTR  EQU   COMMON3+00000008    FULLWORD POINTER
LMOVED   EQU   COMMON3+00000012    HALFWORD POINTER
U        EQU   COMMON3+00000016    FULLWORD POINTER
PICEND   EQU   COMMON3+00000020    HALFWORD POINTER
CURFDGM  EQU   COMMON3+00000024    FULLWORD POINTER
SWTCH    EQU   COMMON3+00000028    4 BYTE(S) ON WORD
SYSINSEL EQU   COMMON3+00000028    1 BYTE(S)
FIRSTSW  EQU   COMMON3+00000029    1 BYTE(S)
FRSTSW   EQU   COMMON3+00000030    1 BYTE(S)
STOPSW   EQU   COMMON3+00000031    1 BYTE(S)
COPYVAL  EQU   COMMON3+00000032    HALFWORD INTEGER
COPYFD   EQU   COMMON3+00000036    FULLWORD POINTER
COPYFDGM EQU   COMMON3+00000040    FULLWORD POINTER
NAMCTR   EQU   COMMON3+00000044    HALFWORD INTEGER
NAMCTR1  EQU   COMMON3+00000046    HALFWORD INTEGER
INRECSZ  EQU   COMMON3+00000048    HALFWORD POINTER
OUTRECSZ EQU   COMMON3+00000050    HALFWORD POINTER
INRECFM  EQU   COMMON3+00000052    1 BYTE(S)
RECOFFST EQU   COMMON3+00000053    1  BYTE  POINTER
OUTRECFM EQU   COMMON3+00000054    1 BYTE(S)
PICBASE  EQU   COMMON3+00000056    FULLWORD POINTER
MESSAGE  EQU   COMMON3+00000060    121 BYTE(S)
DUMMY3   EQU   COMMON3+00000184    FULLWORD POINTER
DCBD     EQU   00000000            280 BYTE(S) ON DWORD
FILL     EQU   DCBD+00000000       26 BYTE(S)
DSORG1   EQU   DCBD+00000026       2 BYTE(S)
DSORG    EQU   DCBD+00000026       8 BIT(S)
FILLER   EQU   DCBD+00000028       8 BYTE(S)
IOBAD    EQU   DCBD+00000028       4 BYTE(S)
BFTEK    EQU   DCBD+00000032       8 BIT(S)
EODAD    EQU   DCBD+00000033       3 BYTE(S)
RECFM    EQU   DCBD+00000036       8 BIT(S)
EXLIST   EQU   DCBD+00000037       3  BYTE  POINTER ON WORD+1
DDNAME   EQU   DCBD+00000040       8 BYTE(S)
DEBAD    EQU   DCBD+00000040       4 BYTE(S)
IFLGS    EQU   DCBD+00000040       8 BIT(S)
GETAD    EQU   DCBD+00000048       4 BYTE(S)
OFLGS    EQU   DCBD+00000048       8 BIT(S)
OFLGS1   EQU   DCBD+00000049       1 BYTE(S)
MACRF    EQU   DCBD+00000050       2 BYTE(S)
FILL2    EQU   DCBD+00000052       10 BYTE(S)
BLKSI    EQU   DCBD+00000062       HALFWORD INTEGER
FILL3    EQU   DCBD+00000064       18 BYTE(S)
LRECL    EQU   DCBD+00000082       HALFWORD INTEGER
FILL4    EQU   DCBD+00000084       172 BYTE(S)
NEXTDCB  EQU   DCBD+00000256       FULLWORD POINTER
DDNAME1  EQU   DCBD+00000260       8 BYTE(S)
EODSW    EQU   DCBD+00000268       1 BYTE(S)
DCBSW1   EQU   DCBD+00000269       1 BYTE(S)
DCBSW2   EQU   DCBD+00000270       1 BYTE(S)
DCBSW3   EQU   DCBD+00000271       8 BIT(S)
INREC    EQU   DCBD+00000272       FULLWORD POINTER
GMLGTH   EQU   DCBD+00000276       HALFWORD INTEGER
FIELDSEL EQU   DCBD+00000278       1 BYTE(S)
SPARE    EQU   DCBD+00000279       1 BYTE(S)
FDTBL    EQU   00000000            520 BYTE(S) ON WORD
FDNAME   EQU   FDTBL+00000000      8 BYTE(S)
FDREPNM  EQU   FDTBL+00000008      8 BYTE(S)
FDINDNM  EQU   FDTBL+00000016      8 BYTE(S) ON WORD
FDUMMY   EQU   FDTBL+00000016      4 BYTE(S)
FDINDNUM EQU   FDTBL+00000020      FULLWORD POINTER
FDLGTH   EQU   FDTBL+00000024      HALFWORD POINTER
FDCYCLE  EQU   FDTBL+00000026      HALFWORD POINTER
FDACTION EQU   FDTBL+00000028      2 BYTE(S)
FDFORMAT EQU   FDTBL+00000030      2 BYTE(S)
FDSWITCH EQU   FDTBL+00000032      8 BIT(S)
INDBYNAM EQU   FDTBL+00000032      1 BIT(S)
PASS     EQU   FDTBL+00000032      1 BIT(S)
FXACTION EQU   FDTBL+00000032      1 BIT(S)
RPACTION EQU   FDTBL+00000032      1 BIT(S)
ROACTION EQU   FDTBL+00000032      1 BIT(S)
WVACTION EQU   FDTBL+00000032      1 BIT(S)
STACTION EQU   FDTBL+00000032      1 BIT(S)
NUACTION EQU   FDTBL+00000032      1 BIT(S)
FDFILL   EQU   FDTBL+00000033      1 BYTE(S)
FDSIGN   EQU   FDTBL+00000034      1 BYTE(S)
FDCHAR   EQU   FDTBL+00000035      1 BYTE(S)
FDRANGE  EQU   FDTBL+00000036      4 BYTE(S)
FDOBUF   EQU   FDTBL+00000040      HALFWORD POINTER
FDFRINC  EQU   FDTBL+00000042      HALFWORD POINTER
FDFROMAD EQU   FDTBL+00000044      4 BYTE(S)
FDMLGTH  EQU   FDTBL+00000048      HALFWORD POINTER
FDTOINC  EQU   FDTBL+00000050      HALFWORD POINTER
FDCYCCNT EQU   FDTBL+00000052      HALFWORD POINTER
FDSLGTH  EQU   FDTBL+00000054      HALFWORD POINTER
FDSLGTHR EQU   FDTBL+00000056      HALFWORD POINTER
FDFRINCR EQU   FDTBL+00000058      1 BYTE(S)
FDTOINCR EQU   FDTBL+00000059      1 BYTE(S)
LTOFREE  EQU   FDTBL+00000060      HALFWORD POINTER
FDSW1    EQU   FDTBL+00000062      8 BIT(S)
STRTLOC1 EQU   FDTBL+00000062      1 BIT(S)
FOXZEROS EQU   *                   16 BYTE(S)
         DC    X'F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0'
INBUF    EQU   00000000            80 BYTE(S)
BUFFER   EQU   00000000            32767 BYTE(S)
ON       EQU   *                   1 BYTE(S)
         DC    X'FF'
OFF      EQU   *                   1 BYTE(S)
         DC    X'00'
WKADDR   EQU   00000000            32767 BYTE(S)
COPAT    EQU   *                   27 BYTE(S)
         DC    C' Ö.<(+×&&!$*);^-/,%_>?:#@''="'
ALPAT    EQU   *                   36 BYTE(S)
         DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
OPTIONS  EQU   00000000            256 BYTE(S)
PAGE     EQU   00000000            256 BYTE(S)
DDLST    EQU   00000000            256 BYTE(S)
         ORG   @DATA
         DS    00000081C
@L       EQU   1
@DATD    DSECT
@SAV001  EQU   @DATD+00000000      72 BYTE(S) ON WORD
BUFPTR   EQU   @DATD+00000072      FULLWORD POINTER
RCODE    EQU   @DATD+00000076      FULLWORD INTEGER
OPTPTR   EQU   @DATD+00000080      FULLWORD POINTER
PGPTR    EQU   @DATD+00000084      FULLWORD POINTER
         DS    00000088C
@TEMPS   DS    0F
         DS    C
@DATEND  EQU   *
IEBDGCUP CSECT ,
A2J7     EQU   @EL01
         END   IEBDGCUP
