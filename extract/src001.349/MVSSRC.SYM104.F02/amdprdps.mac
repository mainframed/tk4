         TITLE 'AMDPRDPS -- STORAGE PRINT SERVICE MODULE               *
                        '
AMDPRDPS CSECT ,                                                01S0001
@MAINENT DS    0H                                               01S0001
         USING *,@15                                            01S0001
         B     @PROLOG                                          01S0001
         DC    AL2(@EP00001-@MAINENT)
         DC    AL1(17)                                          01S0001
         DC    C'AMDPRDPS 12/19/72'                             01S0001
PRNTSTG  DS    0H                                               01S0001
         USING *,@15                                            01S0001
         B     @PROLOG                                          01S0001
         DC    AL2(@EP00032-PRNTSTG)
         ENTRY PRNTSTG
PCBRTN   DS    0H                                               01S0001
         USING *,@15                                            01S0001
         B     @PROLOG                                          01S0001
         DC    AL2(@EP00254-PCBRTN)
         ENTRY PCBRTN
         DROP  @15
@PROLOG  STM   @14,@12,12(@13)                                  01S0001
         BALR  @11,0                                            01S0001
@PSTART  DS    0H                                               01S0001
         USING @PSTART,@11                                      01S0001
         ST    @13,@SA00001+4                                   01S0001
         LA    @14,@SA00001                                     01S0001
         ST    @14,8(,@13)                                      01S0001
         LR    @13,@14                                          01S0001
         AH    @15,4(,@15)                                      01S0001
         BR    @15                                              01S0001
@EP00001 DS    0H                                               01S0002
*/*------------------------------------------------------------------*/
*/* THE FOLLOWING INSTRUCTIONS ONLY GET EXECUTED ONCE WHEN DPS IS    */
*/* CALLED BY AMDPRSEG FOR INITIALIZATION                    @Y02006P*/
*/*------------------------------------------------------------------*/
*  APRTSTG = ADDR(PRNTSTG);        /* SUPPLY ENTRY ADDR IN COMMON    */
         L     @10,@CA00367                                     01S0029
         ST    @10,APRTSTG(,COMBASE)                            01S0029
*  APCBENQ = ADDR(PCBRTN);         /* SUPPLY PCB ENTRY IN COMMON     */
         L     @10,@CA00368                                     01S0030
         ST    @10,APCBENQ(,COMBASE)                            01S0030
*  RETURN;                                                 /*@Y02006P*/
@EL00001 L     @13,4(,@13)                                      01S0031
@EF00001 DS    0H                                               01S0031
@ER00001 LM    @14,@12,12(@13)                                  01S0031
         BR    @14                                              01S0031
*/*------------------------------------------------------------------*/
*/* THE FOLLOWING IS THE MAIN LINE CODE WHICH SERVICES PCB REQUESTS  */
*/*------------------------------------------------------------------*/
*PRNTSTG: ENTRY;                   /* ENTRY POINT FOR FORMAT ROUTINES*/
@EP00032 DS    0H                                               01S0033
*  RESPECIFY R13 RESTRICTED;                               /*@Y02006P*/
*  DPSSAVEA = R13;                 /* SAVE AREA ADDR FOR ASYNC RTNS  */
         ST    R13,DPSSAVEA                                     01S0034
*  RESPECIFY R13 UNRESTRICTED;                             /*@Y02006P*/
*  LSTERRTN = ERRADDR;             /* SAVE PREVIOUS READ ERROR RTN   */
         L     LSTERRTN,ERRADDR(,COMBASE)                       01S0036
*  ERRADDR = ADDR(DPSREAD);        /* ADDR OF MY READ ERROR RTN      */
         LA    @09,DPSREAD                                      01S0037
         ST    @09,ERRADDR(,COMBASE)                            01S0037
*  LSTSTOP = STOPEXIT;             /* SAVE PREVIOUS STOP RTN ADDR    */
         L     LSTSTOP,STOPEXIT(,COMBASE)                       01S0038
*  STOPEXIT = ADDR(DPSSTOP);       /* ADDR OF MY STOP RTN    @Y02006P*/
         LA    @09,DPSSTOP                                      01S0039
         ST    @09,STOPEXIT(,COMBASE)                           01S0039
*  OUTBUFAD = CURBUF;              /* ADDRESS OF OUTPUT BUFFER       */
         L     OUTBUFAD,CURBUF(,COMBASE)                        01S0040
*  LASTASID = 'FFFF'X;                                     /*@Y02006P*/
*                                                               01S0041
         MVC   LASTASID(2),@CB00429                             01S0041
*  IF PCBPTR ^= 0 THEN             /* THERE ARE PCBS TO SERVICE      */
         ICM   @09,15,PCBPTR(COMBASE)                           01S0042
         BZ    @RF00042                                         01S0042
*    DO;                                                   /*@Y02006P*/
*      IF I3800204=ON THEN I3800KEY=ON; /* KEY MSG IN DUMP  @Z40MI3F */
         TM    I3800204(COMBASE),B'00000001'                    01S0044
         BNO   @RF00044                                         01S0044
         OI    I3800KEY(COMBASE),B'00001000'                    01S0045
*                                  /* CONDENSED DUMP ONLY   @Z40MI3F */
*      IF GPRSFND = YES THEN       /* A PRINTOUT OF REGS IS REQUESTED*/
@RF00044 TM    GPRSFND(COMBASE),B'00000010'                     01S0046
         BNO   @RF00046                                         01S0046
*/*------------------------------------------------------------------*/
*/* REGPRINT OBTAINS AND FORMATS THE PSW, GENERAL PURPOSE REGISTERS, */
*/* CONTROL REGISTERS, AND FLOATING POINT REGISTERS          @Y02006P*/
*/*------------------------------------------------------------------*/
*DO;                                                       /*@Y02006P*/
*  RESPECIFY (CPUADDR,R1) RESTRICTED;                      /*@Y02006P*/
*  CPUADDR = IPLCPU;               /* WANT REGS FOR DUMP CPU @Y02006P*/
         SLR   CPUADDR,CPUADDR                                  02S0049
         ICM   CPUADDR,3,IPLCPU(COMBASE)                        02S0049
*  SUBERRTN = ADDR(REGREAD);       /* BRREAD ERROR RTN FOR REGISTERS */
         LA    SUBERRTN,REGREAD                                 02S0050
*  GEN FLOWS(DPSREAD) REFS(CPUADDR,BRRDDATA) (BRREAD (CPUADDR),CPU);
         BRREAD (CPUADDR),CPU
*  CPUSTATP = R1;                  /* ADDRESS OF STATUS RECD @Y02006P*/
         LR    CPUSTATP,R1                                      02S0052
*  RESPECIFY (CPUADDR,R1) UNRESTRICTED;                    /*@Y02006P*/
*  IF CPUGPRS = OFF THEN           /* ALL REGS AND PSW ARE GOOD      */
         TM    CPUGPRS(CPUSTATP),B'00100000'                    02S0054
         BNZ   @RF00054                                         02S0054
*    DO;                           /* FORMAT THE PSW         @Y02006P*/
*      PSWHEADR = PSWMSG;          /* PSW LABEL              @Y02006P*/
         MVC   PSWHEADR(11,OUTBUFAD),PSWMSG                     02S0056
*      AREAPTR = ADDR(PSWWORD1);                           /*@Y02006P*/
         LA    AREAPTR,PSWWORD1(,OUTBUFAD)                      02S0057
*      FROMPTR = ADDR(CPUPSW1);                            /*@Y02006P*/
         LA    FROMPTR,CPUPSW1(,CPUSTATP)                       02S0058
*      DO I = 1 TO 2;              /* TRANSLATE TWO WORDS OF PSW     */
         LA    I,1                                              02S0059
@DL00059 DS    0H                                               02S0060
*        UNPK(TOAREA,FROM);                                /*@Y02006P*/
         UNPK  TOAREA(9,AREAPTR),FROM(5,FROMPTR)                02S0060
*        TOAREA(9) = BLANK;                                /*@Y02006P*/
         MVI   TOAREA+8(AREAPTR),C' '                           02S0061
*        TR(TOAREA(1:8),EBCTABL);                          /*@Y02006P*/
         TR    TOAREA(8,AREAPTR),EBCTABL(COMBASE)               02S0062
*        AREAPTR = ADDR(PSWWORD2); /* SECOND OUTPUT WORD     @Y02006P*/
         LA    AREAPTR,PSWWORD2(,OUTBUFAD)                      02S0063
*        FROMPTR = ADDR(CPUPSW2);  /* SECOND HALF OF PSW     @Y02006P*/
         LA    FROMPTR,CPUPSW2(,CPUSTATP)                       02S0064
*      END;                                                /*@Y02006P*/
         AH    I,@CH00041                                       02S0065
         CH    I,@CH00078                                       02S0065
         BNH   @DL00059                                         02S0065
*      CALL WRITERTN(2);           /* PRINT PSW AND SKIP LINE        */
         LA    @01,@AL00066                                     02S0066
         BAL   @14,WRITERTN                                     02S0066
*      DO I = 1 TO 4;              /* TRANSLATE GENRL AND CONTRL REGS*/
         LA    I,1                                              02S0067
@DL00067 DS    0H                                               02S0068
*        REGHEADR(1:LENGTH(REGMSG(1))) = REGMSG(I);        /*@Y02006P*/
         LR    @09,I                                            02S0068
         SLA   @09,3                                            02S0068
         LA    @07,REGMSG-8(@09)                                02S0068
         MVC   REGHEADR(8,OUTBUFAD),0(@07)                      02S0068
*        AREAPTR = ADDR(REGWORD);  /* OUTPUT AREA FOR REGS   @Y02006P*/
         LA    AREAPTR,REGWORD(,OUTBUFAD)                       02S0069
*        FROMPTR = ADDR(CPUREGS(I)); /* REGISTER DATA        @Y02006P*/
         LR    @09,I                                            02S0070
         SLA   @09,5                                            02S0070
         LA    FROMPTR,CPUREGS-32(@09,CPUSTATP)                 02S0070
*        CALL REGFORMT;            /* FORMAT REGISTERS       @Y02006P*/
         BAL   @14,REGFORMT                                     02S0071
*        IF I = 1 × I = 3 THEN                                  02S0072
         CH    I,@CH00041                                       02S0072
         BE    @RT00072                                         02S0072
         CH    I,@CH00169                                       02S0072
         BNE   @RF00072                                         02S0072
@RT00072 DS    0H                                               02S0073
*          CALL WRITERTN(1);       /* PRINT LINE OF REGS - NO SKIP   */
         LA    @01,@AL00073                                     02S0073
         BAL   @14,WRITERTN                                     02S0073
*        ELSE                                                   02S0074
*          CALL WRITERTN(2);       /* PRINT LINE OF REGS - SKIP 1    */
         B     @RC00072                                         02S0074
@RF00072 LA    @01,@AL00074                                     02S0074
         BAL   @14,WRITERTN                                     02S0074
*      END;                                                /*@Y02006P*/
@RC00072 AH    I,@CH00041                                       02S0075
         CH    I,@CH00047                                       02S0075
         BNH   @DL00067                                         02S0075
*      DO I = 1 TO 2;              /* FORMAT FLOATING POINT REGS     */
         LA    I,1                                              02S0076
@DL00076 DS    0H                                               02S0077
*        REGHEADR(1:LENGTH(FPRMSG(1))) = FPRMSG(I);        /*@Y02006P*/
         LR    @09,I                                            02S0077
         SLA   @09,3                                            02S0077
         LA    @07,FPRMSG-8(@09)                                02S0077
         MVC   REGHEADR(8,OUTBUFAD),0(@07)                      02S0077
*        FROMPTR = ADDR(CPUFLPT(I)); /* REGISTER DATA        @Y02006P*/
         LR    @09,I                                            02S0078
         SLA   @09,4                                            02S0078
         AL    @09,@CF00642                                     02S0078
         LA    FROMPTR,CPUFLPT-4(@09,CPUSTATP)                  02S0078
*        AREAPTR = ADDR(FREG1);    /* OUTPUT AREA FOR FLOATING PT REG*/
         LA    AREAPTR,FREG1(,OUTBUFAD)                         02S0079
*        DO J = 1 TO 2;                                    /*@Y02006P*/
         LA    J,1                                              02S0080
@DL00080 DS    0H                                               02S0081
*          DO K = 1 TO 2;          /* TRANSLATE FLOATING PT REGS     */
         LA    K,1                                              02S0081
@DL00081 DS    0H                                               02S0082
*            UNPK(TOAREA,FROM);                            /*@Y02006P*/
         UNPK  TOAREA(9,AREAPTR),FROM(5,FROMPTR)                02S0082
*            TOAREA(9) = BLANK;                            /*@Y02006P*/
         MVI   TOAREA+8(AREAPTR),C' '                           02S0083
*            TR(TOAREA(1:8),EBCTABL);                      /*@Y02006P*/
         TR    TOAREA(8,AREAPTR),EBCTABL(COMBASE)               02S0084
*            AREAPTR = AREAPTR + LENGTH(TOAREA); /* NEXT OUTPUT AREA */
         AH    AREAPTR,@CH00189                                 02S0085
*            FROMPTR = FROMPTR + 4; /* NEXT REGISTER         @Y02006P*/
         AH    FROMPTR,@CH00047                                 02S0086
*          END;                                            /*@Y02006P*/
         AH    K,@CH00041                                       02S0087
         CH    K,@CH00078                                       02S0087
         BNH   @DL00081                                         02S0087
*          AREAPTR = ADDR(FREG2);  /* AREA FOR NEXT REGISTER @Y02006P*/
         LA    AREAPTR,FREG2(,OUTBUFAD)                         02S0088
*        END;                                              /*@Y02006P*/
         AH    J,@CH00041                                       02S0089
         CH    J,@CH00078                                       02S0089
         BNH   @DL00080                                         02S0089
*        IF I = 1 THEN                                          02S0090
         CH    I,@CH00041                                       02S0090
         BNE   @RF00090                                         02S0090
*          CALL WRITERTN(1);       /* PRINT LINE - NO SKIP   @Y02006P*/
         LA    @01,@AL00091                                     02S0091
         BAL   @14,WRITERTN                                     02S0091
*        ELSE                                                   02S0092
*          CALL WRITERTN(2);       /* PRINT LINE AND SKIP    @Y02006P*/
         B     @RC00090                                         02S0092
@RF00090 LA    @01,@AL00092                                     02S0092
         BAL   @14,WRITERTN                                     02S0092
*      END;                                                /*@Y02006P*/
@RC00090 AH    I,@CH00041                                       02S0093
         CH    I,@CH00078                                       02S0093
         BNH   @DL00076                                         02S0093
*    END;                                                  /*@Y02006P*/
*  ELSE                            /* ONLY GENERAL REGISTERS ARE GOOD*/
*    DO;                                                   /*@Y02006P*/
         B     @RC00054                                         02S0095
@RF00054 DS    0H                                               02S0096
*      DO I = 1 TO 2;              /* FORMAT GENERAL REGS    @Y02006P*/
         LA    I,1                                              02S0096
@DL00096 DS    0H                                               02S0097
*        AREAPTR = ADDR(REGWORD);  /* REGISTER OUTPUT AREA   @Y02006P*/
         LA    AREAPTR,REGWORD(,OUTBUFAD)                       02S0097
*        REGHEADR(1:LENGTH(REGMSG(1))) = REGMSG(I);        /*@Y02006P*/
         LR    @09,I                                            02S0098
         SLA   @09,3                                            02S0098
         LA    @07,REGMSG-8(@09)                                02S0098
         MVC   REGHEADR(8,OUTBUFAD),0(@07)                      02S0098
*        FROMPTR = ADDR(CPUREGS(I)); /* REGISTER DATA        @Y02006P*/
         LR    @09,I                                            02S0099
         SLA   @09,5                                            02S0099
         LA    FROMPTR,CPUREGS-32(@09,CPUSTATP)                 02S0099
*        CALL REGFORMT;            /* TRANSLATE REGS TO PRINTABLE    */
         BAL   @14,REGFORMT                                     02S0100
*        IF I = 1 THEN                                          02S0101
         CH    I,@CH00041                                       02S0101
         BNE   @RF00101                                         02S0101
*          CALL WRITERTN(1);       /* PRINT A LINE AND DONT SKIP     */
         LA    @01,@AL00102                                     02S0102
         BAL   @14,WRITERTN                                     02S0102
*        ELSE                                                   02S0103
*          CALL WRITERTN(2);       /* PRINT A LINE AND SKIP ONE      */
         B     @RC00101                                         02S0103
@RF00101 LA    @01,@AL00103                                     02S0103
         BAL   @14,WRITERTN                                     02S0103
*      END;                                                /*@Y02006P*/
@RC00101 AH    I,@CH00041                                       02S0104
         CH    I,@CH00078                                       02S0104
         BNH   @DL00096                                         02S0104
*      MESSAGE(1:LENGTH(NOSTRMSG)) = NOSTRMSG;             /*@Y02006P*/
         MVC   MESSAGE(40,OUTBUFAD),NOSTRMSG                    02S0105
*      CALL WRITERTN(3);           /* TELL ONLY GENRL REGS AVAILABLE */
         LA    @01,@AL00106                                     02S0106
         BAL   @14,WRITERTN                                     02S0106
*    END;                                                  /*@Y02006P*/
*REGEND: GPRSFND = OFF;            /* REGISTER FORMATTING ALL DONE   */
@RC00054 DS    0H                                               02S0108
REGEND   NI    GPRSFND(COMBASE),B'11111101'                     02S0108
*  END;                                                    /*@Y02006P*/
*      DO WHILE PCBPTR ^= 0;                               /*@Y02006P*/
@RF00046 B     @DE00110                                         01S0110
@DL00110 DS    0H                                               01S0111
*/*------------------------------------------------------------------*/
*/* GETPCB CALLS AMDPRPCB TO GET THE NEXT PCB ON THE QUEUE   @Y02006P*/
*/*------------------------------------------------------------------*/
*DO;                                                       /*@Y02006P*/
*  RESPECIFY PREG RESTRICTED;                              /*@Y02006P*/
*  PREG = ADDR(PCBDATA);           /* AREA FOR COPY OF PCB   @Y02006P*/
         LA    @09,PCBDATA                                      02S0113
         LR    PREG,@09                                         02S0113
*  RESPECIFY PCBPL BASED(ADDR(PCBDATA));                   /*@Y02006P*/
*  PCBPFUNC = PCBPDEQ;             /* INDICATE DEQUEUE FUNCTION      */
         OI    PCBPFUNC(@09),B'10000000'                        02S0115
*  CALL AMDPRPCB;                  /* GET PCB                @Y02006P*/
         BAL   @14,AMDPRPCB                                     02S0116
*  RESPECIFY PREG UNRESTRICTED;                            /*@Y02006P*/
*  DO;                                                     /*@Y02006P*/
*    IF PCBPREAL = YES THEN        /* VIRTUAL REQUEST        @Y02006P*/
         LA    @09,PCBDATA                                      02S0119
         TM    PCBPREAL(@09),B'01000000'                        02S0119
         BNO   @RF00119                                         02S0119
*      PRNTREAL = REAL;            /* INDICATE VIRTUAL READS @Y02006P*/
         OI    PRNTREAL(COMBASE),B'00000100'                    02S0120
*    ELSE                          /* REAL REQUEST           @Y02006P*/
*      PRNTREAL = VIRTUAL;         /* INDICATE REAL READS    @Y02006P*/
         B     @RC00119                                         02S0121
@RF00119 NI    PRNTREAL(COMBASE),B'11111011'                    02S0121
*  END;                                                    /*@Y02006P*/
@RC00119 DS    0H                                               02S0123
*  IF PCBPASID^=LASTASID & PCBPTOPC=ON THEN  /* TOPICHDR FIELD IN
*                                     COMMON NEEDS TO BE UPDATED     */
         LA    @09,PCBDATA                                      02S0123
         CLC   PCBPASID(2,@09),LASTASID                         02S0123
         BE    @RF00123                                         02S0123
         TM    PCBPTOPC(@09),B'00010000'                        02S0123
         BNO   @RF00123                                         02S0123
*    DO;                           /* SET UP HEADER          @Y02006P*/
*      TOPICHDR(1:4) = 'ASID';                             /*@Y02006P*/
         MVC   TOPICHDR(4,COMBASE),@CC00581                     02S0125
*      UNPK(ASIDPLC,INPASIDC);                             /*@Y02006P*/
         UNPK  ASIDPLC(5,COMBASE),INPASIDC(3,@09)               02S0126
*      TR(ASIDPLC,EBCTABL);                                /*@Y02006P*/
         TR    ASIDPLC(5,COMBASE),EBCTABL(COMBASE)              02S0127
*      ASIDPLC(LENGTH(ASIDPLC)) = ' ';                     /*@Y02006P*/
         MVI   ASIDPLC+4(COMBASE),C' '                          02S0128
*      GEN(BRWRITE SKIP);          /* START THIS REQUEST ON NEW PAGE */
         BRWRITE SKIP
*    END;                                                  /*@Y02006P*/
*  LASTASID = PCBPASID;            /* REMEMBER ASID          @Y02006P*/
@RF00123 LA    @09,PCBDATA                                      02S0131
         MVC   LASTASID(2),PCBPASID(@09)                        02S0131
*END;                                                      /*@Y02006P*/
*/*------------------------------------------------------------------*/
*/* FORMSTOR OBTAINS THE DATA REQUESTED IN THE PCB FROM THE DUMP AND */
*/* FORMATS THE PRINTED DUMP OUTPUT                          @Y02006P*/
*/*------------------------------------------------------------------*/
*DO;                                                       /*@Y02006P*/
*  IF I3800204=ON THEN             /* IF CONDENSED DUMP REQUESTED    */
         TM    I3800204(COMBASE),B'00000001'                    02S0134
         BNO   @RF00134                                         02S0134
*    DO;                                                   /*@Z40MI3F*/
*      LINELGT=64;                 /* BYTES PER LINE OF DUMP @Z40MI3F*/
         MVC   LINELGT(4),@CF00180                              02S0136
*      LINEMASK='FFFFFFC0'X;       /* 64-BYTE MASK           @Z40MI3F*/
         MVC   LINEMASK(4),@CF00582                             02S0137
*    END;                                                  /*@Z40MI3F*/
*    ELSE                          /* IF NOT A CONDENSED DUMP        */
*    DO;                                                   /*@Z40MI3F*/
         B     @RC00134                                         02S0139
@RF00134 DS    0H                                               02S0140
*      LINELGT=32;                 /* BYTES PER LINE OF DUMP @Z40MI3F*/
         MVC   LINELGT(4),@CF00362                              02S0140
*      LINEMASK='FFFFFFE0'X;       /* 32-BYTE MASK           @Z40MI3F*/
         MVC   LINEMASK(4),@CF00532                             02S0141
*    END;                                                  /*@Z40MI3F*/
*  PREVREAD = GOOD;                /* TURNED OFF IF READ FAILS       */
@RC00134 DS    0H                                               02S0144
*  FIRSTLIN = YES;                 /* INDICATES FIRST LINE OF OUTPUT */
*  FRSTDUPE = YES;                 /* NO DUPE LINES FOUND YET        */
         OI    FIRSTLIN,B'01100000'                             02S0145
         NI    PREVREAD,B'01111111'                             02S0145
*  CRNTLINE = PCBPBGN & LINEMASK;  /* ROUND TO 32 BYTE MULTIPLE      */
         LA    @09,PCBDATA                                      02S0146
         L     @09,PCBPBGN(,@09)                                02S0146
         N     @09,LINEMASK                                     02S0146
         ST    @09,CRNTLINE                                     02S0146
*  RESPECIFY BLOCKADR RESTRICTED;                          /*@Y02006P*/
*  BLOCKADR = CRNTLINE & BLOCKMSK; /* ROUND TO 4K BOUNDARY   @Y02006P*/
*                                                               02S0148
         N     @09,BLOCKMSK                                     02S0148
         LR    BLOCKADR,@09                                     02S0148
*  DO BLOCKADR = BLOCKADR TO PCBPEND-1 BY BLOCKSIZ;        /*@Y02006P*/
         B     @DE00149                                         02S0149
@DL00149 DS    0H                                               02S0150
*    SUBERRTN = ADDR(BLOCKRD);     /* BRREAD ERROR RTN FOR THIS READ */
         LA    SUBERRTN,BLOCKRD                                 02S0150
*    RESPECIFY (R1,R9) RESTRICTED;                         /*@Y02006P*/
*    R9 = PCBPASID;                                        /*@Y02006P*/
         LA    @03,PCBDATA                                      02S0152
         SLR   R9,R9                                            02S0152
         ICM   R9,3,PCBPASID(@03)                               02S0152
*    GEN REFS(BLOCKADR,BRRDDATA) FLOWS(DPSREAD)                 02S0153
*         (BRREAD (BLOCKADR),DATA,ASID=(9));               /*@Y02006P*/
         BRREAD (BLOCKADR),DATA,ASID=(9)
*    BUFFADDR = R1;                /* ADDRESS RETURNED BY BRREAD     */
         LR    BUFFADDR,R1                                      02S0154
*    RESPECIFY (R1,R9) UNRESTRICTED;                       /*@Y02006P*/
*    IF PREVREAD = FAILED THEN     /* BRREAD(S) BEFORE THIS FAILED   */
         TM    PREVREAD,B'10000000'                             02S0156
         BNO   @RF00156                                         02S0156
*      DO;                                                 /*@Y02006P*/
*        HEXDATA1 = BLOCKADR;      /* ADDRESS OF SUCCESSFUL READ     */
         ST    BLOCKADR,HEXDATA1                                02S0158
*        CALL UNAVAIL;             /* DESCRIBE MISSING RECORDS       */
         BAL   @14,UNAVAIL                                      02S0159
*        CRNTLINE = BLOCKADR;      /* SKIP OVER MISSING RECORDS      */
         ST    BLOCKADR,CRNTLINE                                02S0160
*      END;                                                /*@Y02006P*/
*    IF PCBPVIRT=YES & REALMAP^=0 THEN /* GET REAL ADDR OF BLOCK     */
@RF00156 LA    @09,PCBDATA                                      02S0162
         TM    PCBPVIRT(@09),B'10000000'                        02S0162
         BNO   @RF00162                                         02S0162
         SLR   @09,@09                                          02S0162
         C     @09,REALMAP(,COMBASE)                            02S0162
         BE    @RF00162                                         02S0162
*/*------------------------------------------------------------------*/
*/* REALADDR FOR A VIRTUAL REQUEST WITH REAL INPUT PRINTS OUT THE    */
*/*  REAL ADDRESS OF THE FOUR K BLOCK                        @Y02006P*/
*/*------------------------------------------------------------------*/
*DO;                                                       /*@Y02006P*/
*  IF BUFASID=0 THEN               /* REAL INPUT & VIRTUAL REQUEST   */
         LR    @07,BUFFADDR                                     03S0164
         SH    @07,@CH00064                                     03S0164
         SLR   @05,@05                                          03S0164
         ICM   @05,3,BUFASID(@07)                               03S0164
         CR    @09,@05                                          03S0164
         BNE   @RF00164                                         03S0164
*    DO;                                                   /*@Y02006P*/
*      REALADW = REALAD +(CRNTLINE & OFFSTMSK); /*ADDR OF PRESNT LINE*/
         L     @09,CRNTLINE                                     03S0166
         N     @09,OFFSTMSK                                     03S0166
         AL    @09,REALAD(,@07)                                 03S0166
         ST    @09,REALADW                                      03S0166
*      MESSAGE(8:34) = RELADMSG;   /* REAL ADDR MSG TEXT     @Y02006P*/
         MVC   MESSAGE+7(27,OUTBUFAD),RELADMSG                  03S0167
*      UNPK(MESSAGE(25:31),ADDR1(2:5)); /* VIRTUAL ADDRESS   @Y02006P*/
         UNPK  MESSAGE+24(7,OUTBUFAD),ADDR1+1(4)                03S0168
*      MESSAGE(31) = BLANK;                                /*@Y02006P*/
         MVI   MESSAGE+30(OUTBUFAD),C' '                        03S0169
*      TR(MESSAGE(25:30),EBCTABL);                         /*@Y02006P*/
*                                                               03S0170
         TR    MESSAGE+24(6,OUTBUFAD),EBCTABL(COMBASE)          03S0170
*      UNPK(MESSAGE(35:41),RECADDR1); /* REAL ADDRESS OF BLOCK       */
         UNPK  MESSAGE+34(7,OUTBUFAD),RECADDR1(4)               03S0171
*      MESSAGE(41) = BLANK;                                /*@Y02006P*/
         MVI   MESSAGE+40(OUTBUFAD),C' '                        03S0172
*      TR(MESSAGE(35:40),EBCTABL); /* TRANSLATE TO PRINTABLE @Y02006P*/
         TR    MESSAGE+34(6,OUTBUFAD),EBCTABL(COMBASE)          03S0173
*      CALL WRITERTN(1);           /* ISSUE OUTPUT COMMENT   @Y02006P*/
         LA    @01,@AL00174                                     03S0174
         BAL   @14,WRITERTN                                     03S0174
*    END;                                                  /*@Y02006P*/
*  ELSE ;                                                  /*@Y02006P*/
@RF00164 DS    0H                                               03S0177
*END;                                                      /*@Y02006P*/
*    IF BLOCKADR+BLOCKSIZ < PCBPEND THEN                        02S0178
@RF00162 LR    @09,BLOCKADR                                     02S0178
         AH    @09,@CH00360                                     02S0178
         LA    @07,PCBDATA                                      02S0178
         C     @09,PCBPEND(,@07)                                02S0178
         BNL   @RF00178                                         02S0178
*      BUFFEND = BLOCKADR + BLOCKSIZ; /* PRINT ENTIRE 4K     @Y02006P*/
         LR    BUFFEND,@09                                      02S0179
*    ELSE                                                       02S0180
*      BUFFEND = PCBPEND;          /* PRINT TO END OF REQUEST        */
*                                                               02S0180
         B     @RC00178                                         02S0180
@RF00178 LA    @09,PCBDATA                                      02S0180
         L     BUFFEND,PCBPEND(,@09)                            02S0180
*    DO CRNTLINE = CRNTLINE TO BUFFEND-1 BY LINELGT;       /*@Y02006P*/
@RC00178 L     @09,CRNTLINE                                     02S0181
         B     @DE00181                                         02S0181
@DL00181 DS    0H                                               02S0182
*      CRNTOFF = CRNTLINE & OFFSTMSK; /* OFFSET INTO BUFFER  @Y02006P*/
         N     @09,OFFSTMSK                                     02S0182
         ST    @09,CRNTOFF                                      02S0182
*/*------------------------------------------------------------------*/
*/* KEYPRINT PRINTS THE STORAGE KEY FOR A 2K BLOCK IF IT IS DIFFERENT*/
*/*  FROM THAT OF THE PREVIOUS 2K BLOCK                      @Y02006P*/
*/*------------------------------------------------------------------*/
*DO;                                                       /*@Y02006P*/
*  IF WORK1(1:1) = PROTNRQ THEN     /* PAGE NOT RECLAIMED    @YM08224*/
         SLR   @09,@09                                          03S0184
         IC    @09,WORK1(,COMBASE)                              03S0184
         SLR   @07,@07                                          03S0184
         IC    @07,PROTNRQ                                      03S0184
         CR    @09,@07                                          03S0184
         BE    @RT00184                                         03S0184
*    GO TO NRCLMD;                                         /*@YM08224*/
*  IF WORK1(1:1) = PROTKF THEN      /* GET PROTECT KEY FROM XPTE     */
         SLR   @07,@07                                          03S0186
         IC    @07,PROTKF                                       03S0186
         CR    @09,@07                                          03S0186
         BNE   @RF00186                                         03S0186
*    DO;                                                   /*@YM08224*/
*      THISKEY = WORK1(2:2);        /* STOR PROT KEY FROM XPTE       */
         MVC   THISKEY(1),WORK1+1(COMBASE)                      03S0188
*      GO TO PGERCLMD;              /* BYPASS SADMP HDR      @YM08224*/
         B     PGERCLMD                                         03S0189
*    END;                                                  /*@YM08224*/
*NRCLMD:                                                        03S0191
*  IF CRNTOFF<HALFBLCK THEN        /* FIRST HALF OF 4K BLOCK @Y02006P*/
@RF00186 DS    0H                                               03S0191
NRCLMD   L     @09,CRNTOFF                                      03S0191
         CH    @09,@CH00364                                     03S0191
         BNL   @RF00191                                         03S0191
*    THISKEY = KEY1;                                       /*@Y02006P*/
         LR    @09,BUFFADDR                                     03S0192
         AL    @09,@CF00647                                     03S0192
         MVC   THISKEY(1),KEY1(@09)                             03S0192
*  ELSE                            /* SECOND HALF OF 4K BLOCK        */
*    THISKEY = KEY2;                                       /*@Y02006P*/
         B     @RC00191                                         03S0193
@RF00191 LR    @09,BUFFADDR                                     03S0193
         AL    @09,@CF00648                                     03S0193
         MVC   THISKEY(1),KEY2-1(@09)                           03S0193
*PGERCLMD:                                                      03S0194
*  IF THISKEY ^= LASTKEY × FIRSTLIN=YES ×                       03S0194
*                          (I3800204=ON & CRNTLINE=BLOCKADR) THEN
@RC00191 DS    0H                                               03S0194
PGERCLMD CLC   THISKEY(1),LASTKEY                               03S0194
         BNE   @RT00194                                         03S0194
         TM    FIRSTLIN,B'00100000'                             03S0194
         BO    @RT00194                                         03S0194
         TM    I3800204(COMBASE),B'00000001'                    03S0194
         BNO   @RF00194                                         03S0194
         C     BLOCKADR,CRNTLINE                                03S0194
         BNE   @RF00194                                         03S0194
@RT00194 DS    0H                                               03S0195
*                                  /* FIRST LINE OF PCB OR KEY HAS
*                                     CHANGED OR IS FIRST LINE OF BLOCK
*                                     IN A CONDENSED DUMP   @Z40MI3F */
*    DO;                                                   /*@Y02006P*/
*      UNPK(DATAPART(51:57),ADDR1(2:5)); /* ADDR OF NEXT LINE        */
         UNPK  DATAPART+50(7,OUTBUFAD),ADDR1+1(4)               03S0196
*      MESSAGE(8:49) = STORKMSG;   /* STORAGE KEY MSG TEXT   @Y02006P*/
         MVC   MESSAGE+7(42,OUTBUFAD),STORKMSG                  03S0197
*      MESSAGE(57) = BLANK;                                /*@Y02006P*/
         MVI   MESSAGE+56(OUTBUFAD),C' '                        03S0198
*      TR(DATAPART(51:56),EBCTABL);                        /*@Y02006P*/
         TR    DATAPART+50(6,OUTBUFAD),EBCTABL(COMBASE)         03S0199
*      UNPK(MESSAGE(23:25),THISKEY1); /* STORAGE KEY         @Y02006P*/
         UNPK  MESSAGE+22(3,OUTBUFAD),THISKEY1(2)               03S0200
*      MESSAGE(25) = BLANK;                                /*@Y02006P*/
         MVI   MESSAGE+24(OUTBUFAD),C' '                        03S0201
*      TR(MESSAGE(23:24),EBCTABL);                         /*@Y02006P*/
         TR    MESSAGE+22(2,OUTBUFAD),EBCTABL(COMBASE)          03S0202
*      TITLESTK=MESSAGE(23:24);    /* KEY VALUE IN KEY MSG  @Z40MI3F */
         MVC   TITLESTK(2,COMBASE),MESSAGE+22(OUTBUFAD)         03S0203
*      IF WORK1(1:1) = PROTKF THEN  /* INDICATE RECLAIMABLE PAGE     */
         CLC   WORK1(1,COMBASE),PROTKF                          03S0204
         BNE   @RF00204                                         03S0204
*        MESSAGE(59:74) = RECLMPGE;                        /*@YM08224*/
         MVC   MESSAGE+58(16,OUTBUFAD),RECLMPGE                 03S0205
*      CALL WRITERTN(1);                                   /*@Y02006P*/
@RF00204 LA    @01,@AL00206                                     03S0206
         BAL   @14,WRITERTN                                     03S0206
*      LASTKEY = THISKEY;          /* REMEMBER THIS KEY      @Y02006P*/
         MVC   LASTKEY(1),THISKEY                               03S0207
*    END;                                                  /*@Y02006P*/
*  ELSE ;                          /* KEY HASN'T CHANGED  DON'T PRINT*/
@RF00194 DS    0H                                               03S0210
*END;                                                      /*@Y02006P*/
*      IF  FIRSTLIN = NO           /* NOT THE FIRST LINE     @Y02006P*/
*           & PREVREAD=GOOD        /* BLOCKS WERE NOT SKIPPED        */
*           & PRESLINE(1:LINELGT)=LASTLINE(1:LINELGT) THEN /*@Z40MI3F*/
         TM    FIRSTLIN,B'10100000'                             02S0211
         BNZ   @RF00211                                         02S0211
         LR    @09,BUFFADDR                                     02S0211
         AL    @09,CRNTOFF                                      02S0211
         L     @07,LINELGT                                      02S0211
         LR    @05,@07                                          02S0211
         BCTR  @05,0                                            02S0211
         EX    @05,@SC00649                                     02S0211
         BNE   @RF00211                                         02S0211
*        DO;                                               /*@Y02006P*/
*          IF CRNTLINE + LINELGT ^< PCBPEND THEN /* LAST LINE OF PCB */
         AL    @07,CRNTLINE                                     02S0213
         LA    @09,PCBDATA                                      02S0213
         C     @07,PCBPEND(,@09)                                02S0213
         BL    @RF00213                                         02S0213
*            CALL LFORMAT;         /* PRINT LINE ANYWAY      @Y02006P*/
         BAL   @14,LFORMAT                                      02S0214
*          ELSE                    /* NOT LAST LINE OF PCB   @Y02006P*/
*            IF FRSTDUPE = YES THEN /* FIRST CONSECUTIVE DUPLICATE   */
         B     @RC00213                                         02S0215
@RF00213 TM    FRSTDUPE,B'01000000'                             02S0215
         BNO   @RF00215                                         02S0215
*              DO;                                         /*@Y02006P*/
*/*------------------------------------------------------------------*/
*/* DUPEPRNT ISSUES AN OUTPUT COMMENT DESCRIBING DUPLICATE LINES     */
*/*------------------------------------------------------------------*/
*DO;                                                       /*@Y02006P*/
*  UNPK(DATAPART(1:7),ADDR1(2:5)); /* ADDRESS OF DUPLICATE LINE      */
         UNPK  DATAPART(7,OUTBUFAD),ADDR1+1(4)                  03S0218
*  DATAPART(7) = BLANK;                                    /*@Y02006P*/
         MVI   DATAPART+6(OUTBUFAD),C' '                        03S0219
*  TR(ADDRESS,EBCTABL);            /* TRANSLATE TO PRINTABLE @Y02006P*/
         TR    ADDRESS(6,OUTBUFAD),EBCTABL(COMBASE)             03S0220
*  MESSAGE(8:41) = DUPEMSG;        /* DUPLICATE MESSAGE TEXT @Y02006P*/
         MVC   MESSAGE+7(34,OUTBUFAD),DUPEMSG                   03S0221
*  CALL WRITERTN(1);               /* PRINT MESSAGE - NO SKIP        */
         LA    @01,@AL00222                                     03S0222
         BAL   @14,WRITERTN                                     03S0222
*END;                                                      /*@Y02006P*/
*                FRSTDUPE = NO;    /* INDICATE PREVIOUS LINE WAS DUPE*/
         NI    FRSTDUPE,B'10111111'                             02S0224
*              END;                                        /*@Y02006P*/
*            ELSE ;                /* IS SECONDARY DUPLICATE - IGNORE*/
@RF00215 DS    0H                                               02S0227
*        END;                                              /*@Y02006P*/
*      ELSE                        /* LINE IS NOT A DUPLICATE        */
*        DO;                                               /*@Y02006P*/
         B     @RC00211                                         02S0228
@RF00211 DS    0H                                               02S0229
*          LASTLINE(1:LINELGT)=PRESLINE(1:LINELGT); /*SAVE   @Z40MI3F*/
         L     @09,LINELGT                                      02S0229
         BCTR  @09,0                                            02S0229
         LR    @07,BUFFADDR                                     02S0229
         AL    @07,CRNTOFF                                      02S0229
         EX    @09,@SM00652                                     02S0229
*          FRSTDUPE = YES;         /* INDICATE THIS LINE NOT DUPE    */
         OI    FRSTDUPE,B'01000000'                             02S0230
*          CALL LFORMAT;           /* FORMAT LINE OF OUTPUT  @Y02006P*/
         BAL   @14,LFORMAT                                      02S0231
*        END;                                              /*@Y02006P*/
*      FIRSTLIN = NO;              /* FIRST LINE HAS BEEN PROCESSED  */
@RC00211 DS    0H                                               02S0234
*      PREVREAD = GOOD;                                    /*@Y02006P*/
         NI    FIRSTLIN,B'01011111'                             02S0234
*    END;                          /* END OF CRNTLINE LOOP   @Y02006P*/
         L     @09,CRNTLINE                                     02S0235
         AL    @09,LINELGT                                      02S0235
         ST    @09,CRNTLINE                                     02S0235
@DE00181 LR    @07,BUFFEND                                      02S0235
         BCTR  @07,0                                            02S0235
         CR    @09,@07                                          02S0235
         BNH   @DL00181                                         02S0235
*BLOCKEND:                         /* BRREAD RTN RETURNS HERE        */
*  END;                            /* END OF BLOCKADR LOOP   @Y02006P*/
BLOCKEND AH    BLOCKADR,@CH00360                                02S0236
@DE00149 LA    @09,PCBDATA                                      02S0236
         L     @09,PCBPEND(,@09)                                02S0236
         BCTR  @09,0                                            02S0236
         CR    BLOCKADR,@09                                     02S0236
         BNH   @DL00149                                         02S0236
*  RESPECIFY BLOCKADR UNRESTRICTED;                        /*@Y02006P*/
*  IF PREVREAD = FAILED THEN       /* SOME RECORDS ARE MISSING       */
         TM    PREVREAD,B'10000000'                             02S0238
         BNO   @RF00238                                         02S0238
*    DO;                                                   /*@Y02006P*/
*      HEXDATA1 = PCBPEND;                                 /*@Y02006P*/
         LA    @09,PCBDATA                                      02S0240
         MVC   HEXDATA1(4),PCBPEND(@09)                         02S0240
*      CALL UNAVAIL;               /* DESCRIBE MISSING RECORDS       */
         BAL   @14,UNAVAIL                                      02S0241
*    END;                                                  /*@Y02006P*/
*END;                                                      /*@Y02006P*/
@RF00238 DS    0H                                               02S0244
*        IF PCBPTR^=0 THEN         /* THERE IS MORE TO BE PRINTED    */
         ICM   @09,15,PCBPTR(COMBASE)                           01S0244
         BZ    @RF00244                                         01S0244
*          CALL WRITERTN(2);       /* SKIP 2 LINES AFTER EVERY PCB   */
         LA    @01,@AL00245                                     01S0245
         BAL   @14,WRITERTN                                     01S0245
*      END;                                                /*@Y02006P*/
@RF00244 DS    0H                                               01S0246
@DE00110 ICM   @09,15,PCBPTR(COMBASE)                           01S0246
         BNZ   @DL00110                                         01S0246
*    END;                                                  /*@Y02006P*/
*  I3800KEY=OFF;                   /* STORAGE KEY MSG FOR   @Z40MI3F */
@RF00042 NI    I3800KEY(COMBASE),B'11110111'                    01S0248
*                                  /* STORAGE DUMP ONLY     @Z40MI3F */
*  TITLESTK='  ';                  /* RESET KEY VALUE       @Z40MI3F */
         MVC   TITLESTK(2,COMBASE),@CC00600                     01S0249
*  ERRADDR = LSTERRTN;             /* RESTORE PREVIOUS READ ERR RTN  */
         ST    LSTERRTN,ERRADDR(,COMBASE)                       01S0250
*  STOPEXIT = LSTSTOP;             /* RESTORE PREVIOUS STOP RTN      */
         ST    LSTSTOP,STOPEXIT(,COMBASE)                       01S0251
*  PRNTREAL = VIRTUAL;             /* RESET PRNTREAL SWITCH  @Y02006P*/
         NI    PRNTREAL(COMBASE),B'11111011'                    01S0252
*  RETURN;                                                 /*@Y02006P*/
         B     @EL00001                                         01S0253
*PCBRTN: ENTRY;                                            /*@Y02006P*/
@EP00254 DS    0H                                               01S0255
*  CALL AMDPRPCB;                                          /*@Y02006P*/
         BAL   @14,AMDPRPCB                                     01S0255
*  RETURN CODE(RETCODE);                                   /*@Y02006P*/
         L     @15,RETCODE                                      01S0256
         L     @13,4(,@13)                                      01S0256
         L     @14,12(,@13)                                     01S0256
         LM    @00,@12,20(@13)                                  01S0256
         BR    @14                                              01S0256
*/*------------------------------------------------------------------*/
*/* DPSREAD IS THE BRREAD ERROR ROUTINE. IT GETS CONTROL     @Y02006P*/
*/*     ASYNCHRONOUSLY FROM RDC WHEN AN I/O ERROR OCCURS OR IF THE   */
*/*     DATA IS NOT IN THE DUMP                              @Y02006P*/
*/*------------------------------------------------------------------*/
*DPSREAD:                                                       02S0257
*  GEN REFS(DPSSAVEA);                                     /*@Y02006P*/
DPSREAD  DS    0H                                               02S0257
         USING *,R15               SET UP ADDRESSABILITY       @Y02006P
         L     R13,DPSSAVEA                                    @Y02006P
         LM    R14,R12,12(R13)                                 @Y02006P
         DROP R15                                              @Y02006P
*  GO TO ERRORRTN;                 /* GO TO APPRORIATE ERROR RTN     */
*                                                               02S0258
         BR    SUBERRTN                                         02S0258
*  /*----------------------------------------------------------------*/
*  /* BRREAD ERROR ROUTINE FOR REGISTER READS                @Y02006P*/
*  /*----------------------------------------------------------------*/
*REGREAD:                                                       02S0259
*  MESSAGE(1:LENGTH(NOREGMSG)) = NOREGMSG; /* MSG TEXT FOR MISSING
*                                             REGS           @Y02006P*/
REGREAD  MVC   MESSAGE(30,OUTBUFAD),NOREGMSG                    02S0259
*  CALL WRITERTN(3);               /* PRINT MESSAGE AND SKIP 2 LINES */
         LA    @01,@AL00260                                     02S0260
         BAL   @14,WRITERTN                                     02S0260
*  GO TO REGEND;                   /* RETURN TO MAINLINE     @Y02006P*/
*                                                               02S0261
         B     REGEND                                           02S0261
*  /*----------------------------------------------------------------*/
*  /* BRREAD ERROR ROUTINE FOR STORAGE READS                 @Y02006P*/
*  /*----------------------------------------------------------------*/
*BLOCKRD:                                                       02S0262
*  PREVREAD = FAILED;              /* INDICATE READ FAILLED  @Y02006P*/
BLOCKRD  OI    PREVREAD,B'10000000'                             02S0262
*  IF IOERR = YES THEN             /* I/O ERR ON FIRST FAILURE       */
         TM    IOERR(COMBASE),B'10000000'                       02S0263
         BNO   @RF00263                                         02S0263
*    DO;                                                   /*@Y02006P*/
*      MESSAGE(8:30) = IOERRMSG;   /* I/O ERROR MESSAGE TEXT @Y02006P*/
         MVC   MESSAGE+7(23,OUTBUFAD),IOERRMSG                  02S0265
*      UNPK(MESSAGE(33:39),ADDR1(2:5)); /* ADDR OF FAILING READ      */
         UNPK  MESSAGE+32(7,OUTBUFAD),ADDR1+1(4)                02S0266
*      MESSAGE(39) = BLANK;                                /*@Y02006P*/
         MVI   MESSAGE+38(OUTBUFAD),C' '                        02S0267
*      TR(MESSAGE(33:38),EBCTABL); /* TRANSLATE TO PRINTABLE @Y02006P*/
         TR    MESSAGE+32(6,OUTBUFAD),EBCTABL(COMBASE)          02S0268
*      CALL WRITERTN(1);           /* PRINT MESSAGE AND NO SKIP      */
         LA    @01,@AL00269                                     02S0269
         BAL   @14,WRITERTN                                     02S0269
*    END;                                                  /*@Y02006P*/
*  GO TO BLOCKEND;                 /* END OF FORMSTOR OUTER LOOP     */
         B     BLOCKEND                                         02S0271
*/*------------------------------------------------------------------*/
*/* DPSSTOP IS ENTERED ASYNCHRONOUSLY AFTER A BRWRITE IF THE OPERATOR*/
*/*  REQUESTED THAT PRDMP STOP PROCESSING                    @Y02006P*/
*/*------------------------------------------------------------------*/
*DPSSTOP:                                                       02S0272
*  GEN REFS(DPSSAVEA);                                     /*@Y02006P*/
DPSSTOP  DS    0H                                               02S0272
         USING *,R15               SET UP ADDRESSABILITY       @Y02006P
         L     R13,DPSSAVEA                                    @Y02006P
         LM    R14,R12,12(R13)                                 @Y02006P
         DROP R15                                              @Y02006P
*  DO WHILE PCBPTR ^= 0;           /* PURGE THE PCB QUEUE    @Y02006P*/
         B     @DE00273                                         02S0273
@DL00273 DS    0H                                               02S0274
*    RESPECIFY PREG RESTRICTED;                            /*@Y02006P*/
*    PREG = ADDR(PCBDATA);         /* PARAMETER LIST         @Y02006P*/
         LA    @09,PCBDATA                                      02S0275
         LR    PREG,@09                                         02S0275
*    PCBPFUNC = PCBPDEQ;           /* REQUEST DEQUEUE FUNCTION       */
         OI    PCBPFUNC(@09),B'10000000'                        02S0276
*    CALL AMDPRPCB;                /* DEQUEUE A PCB          @Y02006P*/
         BAL   @14,AMDPRPCB                                     02S0277
*    RESPECIFY PREG UNRESTRICTED;                          /*@Y02006P*/
*  END;                                                    /*@Y02006P*/
@DE00273 ICM   @09,15,PCBPTR(COMBASE)                           02S0279
         BNZ   @DL00273                                         02S0279
*  ERRADDR = LSTERRTN;             /* RESTORE PREVIOUS READ RTN      */
         ST    LSTERRTN,ERRADDR(,COMBASE)                       02S0280
*  STOPEXIT = LSTSTOP;             /* RESTORE PREVIOUS STOP EXIT     */
         ST    LSTSTOP,STOPEXIT(,COMBASE)                       02S0281
*  RESPECIFY R15 RESTRICTED;                               /*@Y02006P*/
*  R15 = LSTSTOP;                                          /*@Y02006P*/
         LR    R15,LSTSTOP                                      02S0283
*  GO TO R15;                      /* PERCOLATE TO NEXT STOP EXIT    */
         BR    R15                                              02S0284
*  RESPECIFY R15 UNRESTRICTED;                             /*@Y02006P*/
*/*------------------------------------------------------------------*/
*/* LFORMAT FORMATS ONE LINE OF DUMP OUTPUT                  @Y02006P*/
*/*------------------------------------------------------------------*/
*LFORMAT: PROCEDURE;                                       /*@Y02006P*/
LFORMAT  STM   @14,@12,@SA00002                                 03S0286
*  IF PCBPLOWC = ON THEN           /* GCD REQUEST OF 0 TO 4K @Y02006P*/
         LA    @09,PCBDATA                                      03S0287
         TM    PCBPLOWC(@09),B'00100000'                        03S0287
         BNO   @RF00287                                         03S0287
*    UNPK(DATAPART(1:7),ADDR2(2:5)); /* CONVERT ADDR TO PRINTABLE HEX*/
         UNPK  DATAPART(7,OUTBUFAD),ADDR2+1(4)                  03S0288
*  ELSE                            /* NORMAL REQUEST         @Y02006P*/
*    UNPK(DATAPART(1:7),ADDR1(2:5)); /* CONVERT ADDR TO PRINTABLE HEX*/
         B     @RC00287                                         03S0289
@RF00287 UNPK  DATAPART(7,OUTBUFAD),ADDR1+1(4)                  03S0289
*  DATAPART(7) = BLANK;                                    /*@Y02006P*/
@RC00287 MVI   DATAPART+6(OUTBUFAD),C' '                        03S0290
*  TR(ADDRESS,EBCTABL);            /* TRANSLATE ADDRESS      @Y02006P*/
         TR    ADDRESS(6,OUTBUFAD),EBCTABL(COMBASE)             03S0291
*  IF I3800204=ON THEN             /* IF CONDENSED DUMP REQUESTED    */
         TM    I3800204(COMBASE),B'00000001'                    03S0292
         BNO   @RF00292                                         03S0292
*    DO;                           /* FORMAT LINE DIFFERENTLY        */
*      AREAPTR=ADDR(AFIELD1);      /* FIRST FIELD OF PRINTABLE HEX   */
         LA    AREAPTR,AFIELD1(,OUTBUFAD)                       03S0294
*      FROMPTR=ADDR(PRESLINE);     /* CURRENT STORAGE TO BE DUMPED   */
         LR    FROMPTR,BUFFADDR                                 03S0295
         AL    FROMPTR,CRNTOFF                                  03S0295
*      DO HALF = 1 TO 4;           /* FOUR FIELDS OF FOUR WORDS      */
         LA    HALF,1                                           03S0296
@DL00296 DS    0H                                               03S0297
*        DO WORD = 1 TO 4;         /* TRANSLATE TO PRINTABLE HEX     */
         LA    WORD,1                                           03S0297
@DL00297 DS    0H                                               03S0298
*           UNPK(TOAREA,FROM);     /* ONE WORD TO ZONED FORMAT       */
         UNPK  TOAREA(9,AREAPTR),FROM(5,FROMPTR)                03S0298
*           TR(TOAREA(1:8),EBCTABL); /* TRANSLATE TO PRINTABLE HEX   */
         TR    TOAREA(8,AREAPTR),EBCTABL(COMBASE)               03S0299
*           TOAREA(1)=TOAREA(1)&'3F'X;       /* UNDERLINE 1ST NIBBLE */
         NI    TOAREA(AREAPTR),X'3F'                            03S0300
*           AREAPTR=AREAPTR+8;     /* ADVANCE 8 BUFFER POSITIONS     */
         AH    AREAPTR,@CH00064                                 03S0301
*           FROMPTR=FROMPTR+4;     /* ADVANCE 4 STORAGE BYTES        */
         AH    FROMPTR,@CH00047                                 03S0302
*        END;                      /* ONE WORD  FORMATTED    @Z40MI3F*/
         AH    WORD,@CH00041                                    03S0303
         CH    WORD,@CH00047                                    03S0303
         BNH   @DL00297                                         03S0303
*        TOAREA(1)=BLANK;          /* BLANK BETWEEN FIELDS   @Z40MI3F*/
         MVI   TOAREA(AREAPTR),C' '                             03S0304
*        AREAPTR=AREAPTR+1;        /* ADVANCE PASSED BLANK   @Z40MI3F*/
         AH    AREAPTR,@CH00041                                 03S0305
*      END;                        /* ONE FIELD FORMATTED    @Z40MI3F*/
*                                                               03S0306
         AH    HALF,@CH00041                                    03S0306
         CH    HALF,@CH00047                                    03S0306
         BNH   @DL00296                                         03S0306
*      AEBCDIC(1:32)=PRESLINE(1:32); /* 1ST 32 BYTES IN EBCDIC BUFFR */
         LR    @09,BUFFADDR                                     03S0307
         AL    @09,CRNTOFF                                      03S0307
         MVC   AEBCDIC(32,OUTBUFAD),PRESLINE(@09)               03S0307
*      AEBCDIC(33)=BLANK;          /* BLANK SEPARATOR COLUMN @Z40MI3F*/
         MVI   AEBCDIC+32(OUTBUFAD),C' '                        03S0308
*      AEBCDIC(34:65)=PRESLINE(33:64); /* LAST 32 BYTES IN BUFFER    */
         MVC   AEBCDIC+33(32,OUTBUFAD),PRESLINE+32(@09)         03S0309
*      TR(AEBCDIC,TABLE);          /* ELIMINATE UNPRINTABLES @Z40MI3F*/
         TR    AEBCDIC(65,OUTBUFAD),TABLE(COMBASE)              03S0310
*    END;                          /* END CONDENSED DUMP SPECIAL ACTS*/
*    ELSE                          /* NOT CONDENSED DUMP,DO FOLLOWING*/
*    DO;                                                   /*@Z40MI3F*/
         B     @RC00292                                         03S0312
@RF00292 DS    0H                                               03S0313
*  UNPK(STOKEY1,THISKEY1);         /* STORAGE KEY            @Y02006P*/
         UNPK  STOKEY1(3,OUTBUFAD),THISKEY1(2)                  03S0313
*  STOKEY1(3) = BLANK;                                     /*@Y02006P*/
         MVI   STOKEY1+2(OUTBUFAD),C' '                         03S0314
*  TR(STOKEY,EBCTABL);             /* TRANSLATE STORAGE KEY  @Y02006P*/
         TR    STOKEY(2,OUTBUFAD),EBCTABL(COMBASE)              03S0315
*  AREAPTR = ADDR(FIELD1);         /* BUFFER LOCATION        @Y02006P*/
         LA    AREAPTR,FIELD1(,OUTBUFAD)                        03S0316
*  FROMPTR = ADDR(DATAHLF1);       /* ADDR OF DATA LINE      @Y02006P*/
         LR    FROMPTR,BUFFADDR                                 03S0317
         AL    FROMPTR,CRNTOFF                                  03S0317
*  DO HALF = 1 TO 2;               /* CONVERT STORAGE TO PRNTABLE HEX*/
         LA    HALF,1                                           03S0318
@DL00318 DS    0H                                               03S0319
*    DO WORD = 1 TO 4;                                     /*@Y02006P*/
         LA    WORD,1                                           03S0319
@DL00319 DS    0H                                               03S0320
*      UNPK(TOAREA,FROM);          /* ONE WORD OF STORAGE    @Y02006P*/
         UNPK  TOAREA(9,AREAPTR),FROM(5,FROMPTR)                03S0320
*      TOAREA(9) = BLANK;                                  /*@Y02006P*/
         MVI   TOAREA+8(AREAPTR),C' '                           03S0321
*      TR(TOAREA(1:8),EBCTABL);    /* TRANSLATE STORAGE      @Y02006P*/
         TR    TOAREA(8,AREAPTR),EBCTABL(COMBASE)               03S0322
*      AREAPTR = AREAPTR + LENGTH(TOAREA);                 /*@Y02006P*/
         AH    AREAPTR,@CH00189                                 03S0323
*      FROMPTR = FROMPTR + 4;      /* GET NEXT WORD OF STORAGE       */
         AH    FROMPTR,@CH00047                                 03S0324
*    END;                                                  /*@Y02006P*/
         AH    WORD,@CH00041                                    03S0325
         CH    WORD,@CH00047                                    03S0325
         BNH   @DL00319                                         03S0325
*    AREAPTR = ADDR(FIELD2);       /* ADDR OF SECOND HALF    @Y02006P*/
         LA    AREAPTR,FIELD2(,OUTBUFAD)                        03S0326
*  END;                                                    /*@Y02006P*/
         AH    HALF,@CH00041                                    03S0327
         CH    HALF,@CH00078                                    03S0327
         BNH   @DL00318                                         03S0327
*  ASTR1 = STAR;                                           /*@Y02006P*/
         MVI   ASTR1(OUTBUFAD),C'*'                             03S0328
*  EBCDIC = PRESLINE(1:LINELGT);   /* EBCDIC OF DATA LINE    @Z40MI3F*/
         MVI   EBCDIC+1(OUTBUFAD),C' '                          03S0329
         MVC   EBCDIC+2(30,OUTBUFAD),EBCDIC+1(OUTBUFAD)         03S0329
         L     @09,LINELGT                                      03S0329
         BCTR  @09,0                                            03S0329
         LR    @07,BUFFADDR                                     03S0329
         AL    @07,CRNTOFF                                      03S0329
         EX    @09,@SM00656                                     03S0329
*  TR(EBCDIC,TABLE);               /* ELIMINATE UNPRINTABLES @Y02006P*/
         TR    EBCDIC(32,OUTBUFAD),TABLE(COMBASE)               03S0330
*  ASTR2 = STAR;                                           /*@Y02006P*/
         MVI   ASTR2(OUTBUFAD),C'*'                             03S0331
*    END;                          /* END NOT-CONDENSED SEPARATE ACTS*/
*  CALL WRITERTN(1);               /* PRINT LINE OF OUTPUT   @Y02006P*/
@RC00292 LA    @01,@AL00333                                     03S0333
         BAL   @14,WRITERTN                                     03S0333
*END LFORMAT;                                              /*@Y02006P*/
@EL00002 DS    0H                                               03S0334
@EF00002 DS    0H                                               03S0334
@ER00002 LM    @14,@12,@SA00002                                 03S0334
         BR    @14                                              03S0334
*/*------------------------------------------------------------------*/
*/* WRITERTN ISSUES BRWRITES                                 @Y02006P*/
*/*------------------------------------------------------------------*/
*WRITERTN: PROCEDURE (LINESKIP);                           /*@Y02006P*/
WRITERTN STM   @14,@12,@SA00003                                 03S0335
         MVC   @PC00003(4),0(@01)                               03S0335
*  DECLARE LINESKIP FIXED(31);                             /*@Y02006P*/
*  IF LINESKIP = 1 THEN                                         03S0337
         L     @09,@PC00003                                     03S0337
         CLC   LINESKIP(4,@09),@CF00041                         03S0337
         BNE   @RF00337                                         03S0337
*    GEN FLOWS(DPSSTOP) REFS(AWRITE) (BRWRITE 1);          /*@Y02006P*/
         BRWRITE 1
*  ELSE                                                         03S0339
*    IF LINESKIP = 2 THEN                                       03S0339
         B     @RC00337                                         03S0339
@RF00337 L     @09,@PC00003                                     03S0339
         CLC   LINESKIP(4,@09),@CF00078                         03S0339
         BNE   @RF00339                                         03S0339
*      GEN FLOWS(DPSSTOP) (BRWRITE 2);                     /*@Y02006P*/
         BRWRITE 2
*    ELSE                                                       03S0341
*      GEN FLOWS(DPSSTOP) (BRWRITE 3);                     /*@Y02006P*/
         B     @RC00339                                         03S0341
@RF00339 DS    0H                                               03S0341
         BRWRITE 3
*END WRITERTN;                                             /*@Y02006P*/
@EL00003 DS    0H                                               03S0342
@EF00003 DS    0H                                               03S0342
@ER00003 LM    @14,@12,@SA00003                                 03S0342
         BR    @14                                              03S0342
*/*------------------------------------------------------------------*/
*/* REGFORMAT CONVERTS GENERAL AND CONTROL REGISTERS TO PRINTABLE HEX*/
*/*------------------------------------------------------------------*/
*REGFORMT: PROCEDURE;                                      /*@Y02006P*/
REGFORMT STM   @14,@12,12(@13)                                  03S0343
*  DO J = 1 TO 2;                                          /*@Y02006P*/
         LA    J,1                                              03S0344
@DL00344 DS    0H                                               03S0345
*    DO M = 1 TO 4;                /* TRANSLATE REGISTER CONTENTS    */
         LA    M,1                                              03S0345
@DL00345 DS    0H                                               03S0346
*      UNPK(TOAREA,FROM);          /* ONE REGISTER           @Y02006P*/
         UNPK  TOAREA(9,AREAPTR),FROM(5,FROMPTR)                03S0346
*      TOAREA(9) = BLANK;                                  /*@Y02006P*/
         MVI   TOAREA+8(AREAPTR),C' '                           03S0347
*      TR(TOAREA(1:8),EBCTABL);    /* TRANSLATE CONTENTS TO PRINTABLE*/
         TR    TOAREA(8,AREAPTR),EBCTABL(COMBASE)               03S0348
*      AREAPTR = AREAPTR + 13;     /* OUTPUT AREA FOR NEXT REGISTER  */
         AH    AREAPTR,@CH00184                                 03S0349
*      FROMPTR = FROMPTR + 4;      /* NEXT REGISTER          @Y02006P*/
         AH    FROMPTR,@CH00047                                 03S0350
*    END;                                                  /*@Y02006P*/
         AH    M,@CH00041                                       03S0351
         CH    M,@CH00047                                       03S0351
         BNH   @DL00345                                         03S0351
*    AREAPTR = ADDR(REGWORD2);     /* SECOND HALF OF LINE FOR REGS   */
         LA    AREAPTR,REGWORD2(,OUTBUFAD)                      03S0352
*  END;                                                    /*@Y02006P*/
         AH    J,@CH00041                                       03S0353
         CH    J,@CH00078                                       03S0353
         BNH   @DL00344                                         03S0353
*END REGFORMT;                                             /*@Y02006P*/
@EL00004 DS    0H                                               03S0354
@EF00004 DS    0H                                               03S0354
@ER00004 LM    @14,@12,12(@13)                                  03S0354
         BR    @14                                              03S0354
*/*------------------------------------------------------------------*/
*/* UNAVAIL ISSUES AN OUTPUT COMMENT SPECIFYING THAT AN ADDRESS RANGE*/
*/*  COULD NOT BE PRINTED                                    @Y02006P*/
*/*------------------------------------------------------------------*/
*UNAVAIL: PROCEDURE;                                       /*@Y02006P*/
UNAVAIL  STM   @14,@12,@SA00005                                 03S0355
*  UNPK(DATAPART(1:7),ADDR1(2:5)); /* FIRST FAILING ADDRESS  @Y02006P*/
         UNPK  DATAPART(7,OUTBUFAD),ADDR1+1(4)                  03S0356
*  MESSAGE(7:14) = THRU;                                   /*@Y02006P*/
         MVC   MESSAGE+6(8,OUTBUFAD),THRU                       03S0357
*  TR(ADDRESS,EBCTABL);                                    /*@Y02006P*/
         TR    ADDRESS(6,OUTBUFAD),EBCTABL(COMBASE)             03S0358
*  UNPK(MESSAGE(16:22),HEXDATA(2:5)); /* END OF FAILING ADDRESS RANGE*/
         UNPK  MESSAGE+15(7,OUTBUFAD),HEXDATA+1(4)              03S0359
*  MESSAGE(22:42) = RESTOMSG;      /* REMAINING MESSAGE TEXT @Y02006P*/
         MVC   MESSAGE+21(21,OUTBUFAD),RESTOMSG                 03S0360
*  TR(MESSAGE(16:21),EBCTABL);                             /*@Y02006P*/
         TR    MESSAGE+15(6,OUTBUFAD),EBCTABL(COMBASE)          03S0361
*  CALL WRITERTN(1);               /* PRINT MESSAGE          @Y02006P*/
         LA    @01,@AL00362                                     03S0362
         BAL   @14,WRITERTN                                     03S0362
*END UNAVAIL;                                              /*@Y02006P*/
@EL00005 DS    0H                                               03S0363
@EF00005 DS    0H                                               03S0363
@ER00005 LM    @14,@12,@SA00005                                 03S0363
         BR    @14                                              03S0363
*/*------------------------------------------------------------------*/
*/* AMDPRPCB MANIPULATES THE PCB QUEUE                       @Y02006P*/
*/*------------------------------------------------------------------*/
*AMDPRPCB: PROCEDURE;                                      /*@Y02006P*/
AMDPRPCB STM   @14,@12,@SA00006                                 03S0364
*  RESPECIFY PCBPL BASED(PCBPLPTR);                        /*@Y02006P*/
*  RESPECIFY R1 RESTRICTED;                                /*@Y02006P*/
*  PCBPLPTR = R1;                  /* ADDRESS OF CALLER SUPPLIED AREA*/
         LR    PCBPLPTR,R1                                      03S0367
*  PCBADDR = ADDR(PCBPTR);         /* ADDRESS OF FIRST PCB LINK FIELD*/
         LA    PCBADDR,PCBPTR(,COMBASE)                         03S0368
*  RESPECIFY R1 UNRESTRICTED;                              /*@Y02006P*/
*  IF PCBPFUNC = PCBPENQ THEN      /* ENQUEUE REQUEST        @Y02006P*/
         TM    PCBPFUNC(PCBPLPTR),B'10000000'                   03S0370
         BNZ   @RF00370                                         03S0370
*    DO;                                                   /*@Y02006P*/
*      MERGE = NOTDONE;            /* INIT LOOP CONTROL SWITCH       */
         OI    MERGE,B'10000000'                                03S0372
*      IF PCBPBGN < PCBPEND THEN   /* VALID RANGE            @Y02006P*/
         CLC   PCBPBGN(4,PCBPLPTR),PCBPEND(PCBPLPTR)            03S0373
         BNL   @RF00373                                         03S0373
*        DO WHILE MERGE=NOTDONE;   /* POSITION THE NEW PCB   @Y02006P*/
         B     @DE00374                                         03S0374
@DL00374 DS    0H                                               03S0375
*          IF PCBLINK = 0 THEN     /* LAST PCB IS REACHED    @Y02006P*/
         ICM   @10,15,PCBLINK(PCBADDR)                          03S0375
         BNZ   @RF00375                                         03S0375
*            DO;                                           /*@Y02006P*/
*DO;                                                       /*@Y02006P*/
*DO;                                                       /*@Y02006P*/
*  RESPECIFY (R0,R1) RESTRICTED;                           /*@Y02006P*/
*  R0 = LENGTH(PCB);               /* SIZE OF GETMAIN        @Y02006P*/
         LA    R0,16                                            05S0380
*  GEN(GETMAIN R,LV=(0));          /* GET SPACE FOR NEW PCB  @Y02006P*/
         GETMAIN R,LV=(0)
*  NEWPCB = R1;                    /* ADDRESS OF NEW SPACE   @Y02006P*/
         LR    NEWPCB,R1                                        05S0382
*  RESPECIFY (R0,R1) UNRESTRICTED;                         /*@Y02006P*/
*  EVAL(NEWPCB+4)->PCBPL = PCBPL;  /* COPY PCB INTO GOTTEN AREA      */
         LA    @10,4                                            05S0384
         ALR   @10,NEWPCB                                       05S0384
         MVC   PCBPL(12,@10),PCBPL(PCBPLPTR)                    05S0384
*END;                                                      /*@Y02006P*/
*  NEWPCB->PCBLINK = 0;            /* INDICATE END OF QUEUE  @Y02006P*/
         SLR   @10,@10                                          04S0386
         ST    @10,PCBLINK(,NEWPCB)                             04S0386
*  PCBLINK = NEWPCB;               /* ADD NEW PCB TO CHAIN   @Y02006P*/
         ST    NEWPCB,PCBLINK(,PCBADDR)                         04S0387
*END;                                                      /*@Y02006P*/
*              MERGE = DONE;       /* ENQUEUE IS COMPLETE    @Y02006P*/
         NI    MERGE,B'01111111'                                03S0389
*            END;                                          /*@Y02006P*/
*          ELSE                    /* THIS PCB IS NOT THE LAST       */
*DO;                                                       /*@Y02006P*/
         B     @RC00375                                         04S0391
@RF00375 DS    0H                                               04S0392
*  LASTPCB = PCBADDR;              /* REMEMBER THIS PCB      @Y02006P*/
         LR    LASTPCB,PCBADDR                                  04S0392
*  PCBADDR = PCBLINK;              /* LOOK AT NEXT PCB       @Y02006P*/
         L     PCBADDR,PCBLINK(,PCBADDR)                        04S0393
*  IF PCBPASID = PCBASID THEN      /* IF STORAGE IS FOR SAME ID      */
         CLC   PCBPASID(2,PCBPLPTR),PCBASID(PCBADDR)            04S0394
         BNE   @RF00394                                         04S0394
*    DO;                                                   /*@Y02006P*/
*      IF PCBPBGN <= PCBSTART THEN /* NEW PCB STARTS BEFORE THIS ONE */
         L     @10,PCBSTART(,PCBADDR)                           04S0396
         C     @10,PCBPBGN(,PCBPLPTR)                           04S0396
         BL    @RF00396                                         04S0396
*        DO;                                               /*@Y02006P*/
*          IF PCBPEND < PCBSTART THEN /* NEW PCB IS ENTIRELY BEFORE
*                                     THIS ONE               @Y02006P*/
         C     @10,PCBPEND(,PCBPLPTR)                           04S0398
         BNH   @RF00398                                         04S0398
*            DO;                                           /*@Y02006P*/
*DO;                                                       /*@Y02006P*/
*DO;                                                       /*@Y02006P*/
*  RESPECIFY (R0,R1) RESTRICTED;                           /*@Y02006P*/
*  R0 = LENGTH(PCB);               /* SIZE OF GETMAIN        @Y02006P*/
         LA    R0,16                                            06S0403
*  GEN(GETMAIN R,LV=(0));          /* GET SPACE FOR NEW PCB  @Y02006P*/
         GETMAIN R,LV=(0)
*  NEWPCB = R1;                    /* ADDRESS OF NEW SPACE   @Y02006P*/
         LR    NEWPCB,R1                                        06S0405
*  RESPECIFY (R0,R1) UNRESTRICTED;                         /*@Y02006P*/
*  EVAL(NEWPCB+4)->PCBPL = PCBPL;  /* COPY PCB INTO GOTTEN AREA      */
         LA    @10,4                                            06S0407
         ALR   @10,NEWPCB                                       06S0407
         MVC   PCBPL(12,@10),PCBPL(PCBPLPTR)                    06S0407
*END;                                                      /*@Y02006P*/
*  NEWPCB->PCBLINK = PCBADDR;      /* LINK TO NEXT PCB       @Y02006P*/
         ST    PCBADDR,PCBLINK(,NEWPCB)                         05S0409
*  LASTPCB->PCBLINK = NEWPCB;      /* ADD NEW PCB TO CHAIN   @Y02006P*/
         ST    NEWPCB,PCBLINK(,LASTPCB)                         05S0410
*END;                                                      /*@Y02006P*/
*              MERGE = DONE;       /* STOP MERGE             @Y02006P*/
         NI    MERGE,B'01111111'                                04S0412
*            END;                                          /*@Y02006P*/
*          ELSE                    /* NEW PCB OVERLAPS THIS PCB      */
*            DO;                                           /*@Y02006P*/
         B     @RC00398                                         04S0414
@RF00398 DS    0H                                               04S0415
*              PCBSTART = PCBPBGN; /* INCLUDE NEW RANGE IN THIS PCB  */
         MVC   PCBSTART(4,PCBADDR),PCBPBGN(PCBPLPTR)            04S0415
*              IF PCBPEND <= PCBSTOP THEN /* RANGE IS ALREADY ENQD   */
         CLC   PCBPEND(4,PCBPLPTR),PCBSTOP(PCBADDR)             04S0416
         BH    @RF00416                                         04S0416
*                MERGE = DONE;     /* STOP SCAN              @Y02006P*/
         NI    MERGE,B'01111111'                                04S0417
*              ELSE                /* THIS PCB IS SPANNED BY NEW PCB */
*                DO;                                       /*@Y02006P*/
         B     @RC00416                                         04S0418
@RF00416 DS    0H                                               04S0419
*                  PCBSTOP = PCBPEND; /* EXPAND PRESENT PCB  @Y02006P*/
         MVC   PCBSTOP(4,PCBADDR),PCBPEND(PCBPLPTR)             04S0419
*                  CALL NEXTCHCK;  /* CHECK FOR OVERLAP WITH NEXT PCB*/
         BAL   @14,NEXTCHCK                                     04S0420
*                END;                                      /*@Y02006P*/
*            END;                                          /*@Y02006P*/
*        END;                                              /*@Y02006P*/
*      ELSE                        /* NEW PCB STARTS AFTER THIS ONE  */
*        IF PCBPBGN <= PCBSTOP THEN /* NEW PCB OVERLAPS THIS ONE     */
         B     @RC00396                                         04S0424
@RF00396 L     @10,PCBSTOP(,PCBADDR)                            04S0424
         C     @10,PCBPBGN(,PCBPLPTR)                           04S0424
         BL    @RF00424                                         04S0424
*          DO;                                             /*@Y02006P*/
*            IF PCBPEND <= PCBSTOP THEN /* RANGE IS ALREADY INCLUDED */
         C     @10,PCBPEND(,PCBPLPTR)                           04S0426
         BL    @RF00426                                         04S0426
*              MERGE = DONE;       /* STOP SCAN              @Y02006P*/
         NI    MERGE,B'01111111'                                04S0427
*            ELSE                  /* NEW PCB OVERFLOWS CURRENT RANGE*/
*              DO;                                         /*@Y02006P*/
         B     @RC00426                                         04S0428
@RF00426 DS    0H                                               04S0429
*                PCBSTOP = PCBPEND; /* EXPAND CURRENT PCB    @Y02006P*/
         MVC   PCBSTOP(4,PCBADDR),PCBPEND(PCBPLPTR)             04S0429
*                CALL NEXTCHCK;    /* CHECK FOR OVERLAP WITH NEXT PCB*/
         BAL   @14,NEXTCHCK                                     04S0430
*              END;                                        /*@Y02006P*/
*          END;                                            /*@Y02006P*/
*        ELSE ;                    /* NEW RANGE EXCEEDS THIS ONE     */
@RF00424 DS    0H                                               04S0434
*    END;                          /* CONTINUE SCAN          @Y02006P*/
*   ELSE                           /* ASIDS NOT THE SAME     @Y02006P*/
*    IF PCBPASID<PCBASID THEN                                   04S0435
         B     @RC00394                                         04S0435
@RF00394 CLC   PCBPASID(2,PCBPLPTR),PCBASID(PCBADDR)            04S0435
         BNL   @RF00435                                         04S0435
*      DO;                                                 /*@Y02006P*/
*DO;                                                       /*@Y02006P*/
*DO;                                                       /*@Y02006P*/
*  RESPECIFY (R0,R1) RESTRICTED;                           /*@Y02006P*/
*  R0 = LENGTH(PCB);               /* SIZE OF GETMAIN        @Y02006P*/
         LA    R0,16                                            06S0440
*  GEN(GETMAIN R,LV=(0));          /* GET SPACE FOR NEW PCB  @Y02006P*/
         GETMAIN R,LV=(0)
*  NEWPCB = R1;                    /* ADDRESS OF NEW SPACE   @Y02006P*/
         LR    NEWPCB,R1                                        06S0442
*  RESPECIFY (R0,R1) UNRESTRICTED;                         /*@Y02006P*/
*  EVAL(NEWPCB+4)->PCBPL = PCBPL;  /* COPY PCB INTO GOTTEN AREA      */
         LA    @10,4                                            06S0444
         ALR   @10,NEWPCB                                       06S0444
         MVC   PCBPL(12,@10),PCBPL(PCBPLPTR)                    06S0444
*END;                                                      /*@Y02006P*/
*  NEWPCB->PCBLINK = PCBADDR;      /* LINK TO NEXT PCB       @Y02006P*/
         ST    PCBADDR,PCBLINK(,NEWPCB)                         05S0446
*  LASTPCB->PCBLINK = NEWPCB;      /* ADD NEW PCB TO CHAIN   @Y02006P*/
         ST    NEWPCB,PCBLINK(,LASTPCB)                         05S0447
*END;                                                      /*@Y02006P*/
*        MERGE = DONE;                                     /*@Y02006P*/
         NI    MERGE,B'01111111'                                04S0449
*      END;                                                /*@Y02006P*/
*END;                                                      /*@Y02006P*/
@RF00435 DS    0H                                               04S0451
@RC00394 DS    0H                                               04S0452
*        END;                                              /*@Y02006P*/
@RC00375 DS    0H                                               03S0452
@DE00374 TM    MERGE,B'10000000'                                03S0452
         BO    @DL00374                                         03S0452
*      ELSE ;                      /* INVALID PCB DO NOTHING @Y02006P*/
@RF00373 DS    0H                                               03S0454
*    END;                                                  /*@Y02006P*/
*  ELSE                            /* DEQUEUE REQUEST        @Y02006P*/
*    DO;                                                   /*@Y02006P*/
         B     @RC00370                                         03S0455
@RF00370 DS    0H                                               03S0456
*      IF PCBPTR = 0 THEN          /* NONE TO BE DEQUEUED    @Y02006P*/
         ICM   @10,15,PCBPTR(COMBASE)                           03S0456
         BNZ   @RF00456                                         03S0456
*        RETCODE = 4;              /* INDICATE NONE RETURNED @Y02006P*/
         MVC   RETCODE(4),@CF00047                              03S0457
*      ELSE                                                     03S0458
*        DO;                                               /*@Y02006P*/
         B     @RC00456                                         03S0458
@RF00456 DS    0H                                               03S0459
*          PCBPL = EVAL(PCBPTR+4)->PCBPL; /* COPY PCB        @Y02006P*/
         L     @10,PCBPTR(,COMBASE)                             03S0459
         LA    @07,4                                            03S0459
         ALR   @07,@10                                          03S0459
         MVC   PCBPL(12,PCBPLPTR),PCBPL(@07)                    03S0459
*          DEQADDR = PCBPTR;                               /*@Y02006P*/
         LR    DEQADDR,@10                                      03S0460
*          PCBPTR = PCBPTR->PCBLINK; /* CHAIN AROUND DEQD PCB        */
         L     @10,PCBLINK(,@10)                                03S0461
         ST    @10,PCBPTR(,COMBASE)                             03S0461
*DO;                                                       /*@Y02006P*/
*  RESPECIFY (R0,R1) RESTRICTED;                           /*@Y02006P*/
*  R0 = LENGTH(PCB);                                       /*@Y02006P*/
         LA    R0,16                                            04S0464
*  R1 = DEQADDR;                                           /*@Y02006P*/
         LR    R1,DEQADDR                                       04S0465
*  GEN(FREEMAIN R,LV=(0),A=(1));                           /*@Y02006P*/
         FREEMAIN R,LV=(0),A=(1)
*END;                                                      /*@Y02006P*/
*          RETCODE = 0;            /* INDICATE PCB RETURNED  @Y02006P*/
         SLR   @10,@10                                          03S0468
         ST    @10,RETCODE                                      03S0468
*        END;                                              /*@Y02006P*/
*    END;                                                  /*@Y02006P*/
*END AMDPRPCB;                                             /*@Y02006P*/
@EL00006 DS    0H                                               03S0471
@EF00006 DS    0H                                               03S0471
@ER00006 LM    @14,@12,@SA00006                                 03S0471
         BR    @14                                              03S0471
*/*------------------------------------------------------------------*/
*/* NEXTCHCK CHECKS FOR OVERLAP OF THE NEW PCB WITH NEXT ONE ON THE  */
*/*   QUEUE                                                  @Y02006P*/
*/*------------------------------------------------------------------*/
*NEXTCHCK: PROCEDURE;                                      /*@Y02006P*/
NEXTCHCK STM   @14,@03,@SA00007                                 03S0472
         STM   @05,@12,@SA00007+24                              03S0472
*  LASTPCB = PCBADDR;              /* REMEMBER PREVIOUS PCB  @Y02006P*/
         LR    LASTPCB,PCBADDR                                  03S0473
*  DO WHILE MERGE=NOTDONE;         /* SCAN PCB QUEUE         @Y02006P*/
         B     @DE00474                                         03S0474
@DL00474 DS    0H                                               03S0475
*    IF PCBLINK = 0 THEN           /* END OF QUEUE - NO OVERLAP      */
         ICM   @10,15,PCBLINK(PCBADDR)                          03S0475
         BNZ   @RF00475                                         03S0475
*      MERGE = DONE;               /* STOP SCAN              @Y02006P*/
         NI    MERGE,B'01111111'                                03S0476
*    ELSE                                                       03S0477
*      DO;                                                 /*@Y02006P*/
         B     @RC00475                                         03S0477
@RF00475 DS    0H                                               03S0478
*        PCBADDR = PCBLINK;        /* GET NEXT PCB           @Y02006P*/
         L     PCBADDR,PCBLINK(,PCBADDR)                        03S0478
*        IF PCBPASID = PCBASID THEN /* IF PCBS ARE FOR SAME MEMORY   */
         CLC   PCBPASID(2,PCBPLPTR),PCBASID(PCBADDR)            03S0479
         BNE   @RF00479                                         03S0479
*          DO;                                             /*@Y02006P*/
*            IF LASTPCB->PCBSTOP < PCBSTART THEN /* NO OVERLAP       */
         CLC   PCBSTOP(4,LASTPCB),PCBSTART(PCBADDR)             03S0481
         BNL   @RF00481                                         03S0481
*              MERGE = DONE;       /* STOP SCAN              @Y02006P*/
         NI    MERGE,B'01111111'                                03S0482
*            ELSE                                               03S0483
*              IF LASTPCB->PCBSTOP = PCBSTART                   03S0483
*                   × LASTPCB->PCBSTOP <= PCBSTOP THEN          03S0483
         B     @RC00481                                         03S0483
@RF00481 L     @10,PCBSTOP(,LASTPCB)                            03S0483
         C     @10,PCBSTART(,PCBADDR)                           03S0483
         BE    @RT00483                                         03S0483
         C     @10,PCBSTOP(,PCBADDR)                            03S0483
         BH    @RF00483                                         03S0483
@RT00483 DS    0H                                               03S0484
*                                  /* THIS IS FINAL OVERLAPPED PCB   */
*                DO;                                       /*@Y02006P*/
*                  LASTPCB->PCBSTOP = PCBSTOP;             /*@Y02006P*/
         MVC   PCBSTOP(4,LASTPCB),PCBSTOP(PCBADDR)              03S0485
*                  LASTPCB->PCBLINK = PCBLINK; /* CHAIN AROUND PCB   */
         MVC   PCBLINK(4,LASTPCB),PCBLINK(PCBADDR)              03S0486
*                  DEQADDR = PCBADDR; /* ADDR OF PCB TO FREE @Y02006P*/
         LR    DEQADDR,PCBADDR                                  03S0487
*DO;                                                       /*@Y02006P*/
*  RESPECIFY (R0,R1) RESTRICTED;                           /*@Y02006P*/
*  R0 = LENGTH(PCB);                                       /*@Y02006P*/
         LA    R0,16                                            04S0490
*  R1 = DEQADDR;                                           /*@Y02006P*/
         LR    R1,DEQADDR                                       04S0491
*  GEN(FREEMAIN R,LV=(0),A=(1));                           /*@Y02006P*/
         FREEMAIN R,LV=(0),A=(1)
*END;                                                      /*@Y02006P*/
*                  MERGE = DONE;   /* STOP SCAN              @Y02006P*/
         NI    MERGE,B'01111111'                                03S0494
*                END;                                      /*@Y02006P*/
*              ELSE                /* MORE OVERLAP TO FOLLOW @Y02006P*/
*                DO;                                       /*@Y02006P*/
         B     @RC00483                                         03S0496
@RF00483 DS    0H                                               03S0497
*                  LASTPCB->PCBLINK = PCBLINK; /* CHAIN AROUND PCB   */
         MVC   PCBLINK(4,LASTPCB),PCBLINK(PCBADDR)              03S0497
*                  DEQADDR = PCBADDR; /* ADDR OF PCB TO BE FREED     */
         LR    DEQADDR,PCBADDR                                  03S0498
*                  PCBADDR = LASTPCB; /* SET UP TO GET LINK FIELD    */
         LR    PCBADDR,LASTPCB                                  03S0499
*DO;                                                       /*@Y02006P*/
*  RESPECIFY (R0,R1) RESTRICTED;                           /*@Y02006P*/
*  R0 = LENGTH(PCB);                                       /*@Y02006P*/
         LA    R0,16                                            04S0502
*  R1 = DEQADDR;                                           /*@Y02006P*/
         LR    R1,DEQADDR                                       04S0503
*  GEN(FREEMAIN R,LV=(0),A=(1));                           /*@Y02006P*/
         FREEMAIN R,LV=(0),A=(1)
*END;                                                      /*@Y02006P*/
*                END;              /* CONTINUE SCAN          @Y02006P*/
*          END;                                            /*@Y02006P*/
@RC00483 DS    0H                                               03S0507
@RC00481 DS    0H                                               03S0508
*      END;                                                /*@Y02006P*/
@RF00479 DS    0H                                               03S0509
*  END;                                                    /*@Y02006P*/
@RC00475 DS    0H                                               03S0509
@DE00474 TM    MERGE,B'10000000'                                03S0509
         BO    @DL00474                                         03S0509
*END NEXTCHCK;                                             /*@Y02006P*/
@EL00007 DS    0H                                               03S0510
@EF00007 DS    0H                                               03S0510
@ER00007 LM    @14,@03,@SA00007                                 03S0510
         LM    @05,@12,@SA00007+24                              03S0510
         BR    @14                                              03S0510
*END AMDPRDPS                                              /*@Y02006P*/
*/* THE FOLLOWING INCLUDE STATEMENTS WERE FOUND IN THIS PROGRAM.      *
*/*%INCLUDE SYSUT5  (DPSPROLG)                                        *
*/*%INCLUDE SYSUT5  (DPSFL1  )                                        *
*/*%INCLUDE SYSUT5  (DPSDCLS )                                        *
*/*%INCLUDE SYSLIB  (AMDPCBPL)                                        *
*/*%INCLUDE SYSLIB  (COMMON  )                                        *
*/*%INCLUDE SYSUT5  (PCBDCLS )                                        *
*/*%INCLUDE SYSUT5  (REGPRINT)                                        *
*/*%INCLUDE SYSUT5  (GETPCB  )                                        *
*/*%INCLUDE SYSUT5  (FORMSTOR)                                        *
*/*%INCLUDE SYSUT5  (REALADDR)                                        *
*/*%INCLUDE SYSUT5  (KEYPRINT)                                        *
*/*%INCLUDE SYSUT5  (DUPEPRNT)                                        *
*/*%INCLUDE SYSUT5  (DPSREAD )                                        *
*/*%INCLUDE SYSUT5  (DPSSTOP )                                        *
*/*%INCLUDE SYSUT5  (INTRTNS )                                        *
*/*%INCLUDE SYSUT5  (LFORMAT )                                        *
*/*%INCLUDE SYSUT5  (WRITERTN)                                        *
*/*%INCLUDE SYSUT5  (REGFORMT)                                        *
*/*%INCLUDE SYSUT5  (UNAVAIL )                                        *
*/*%INCLUDE SYSUT5  (AMDPRPCB)                                        *
*/*%INCLUDE SYSUT5  (ENQAFTER)                                        *
*/*%INCLUDE SYSUT5  (GETAREA )                                        *
*/*%INCLUDE SYSUT5  (GETAREA )                                        *
*/*%INCLUDE SYSUT5  (GETAREA )                                        *
*/*%INCLUDE SYSUT5  (COMPNEXT)                                        *
*/*%INCLUDE SYSUT5  (ENQBEFOR)                                        *
*/*%INCLUDE SYSUT5  (ENQBEFOR)                                        *
*/*%INCLUDE SYSUT5  (FREERTN )                                        *
*/*%INCLUDE SYSUT5  (FREERTN )                                        *
*/*%INCLUDE SYSUT5  (FREERTN )                                        *
*/*%INCLUDE SYSUT5  (NEXTCHCK)                                        *
*;                                                              01S0511
@DATA    DS    0H
@CH00064 DC    H'8'
@CH00189 DC    H'9'
@CH00184 DC    H'13'
@CH00364 DC    H'2048'
@CH00360 DC    H'4096'
@SC00649 CLC   PRESLINE(0,@09),LASTLINE
@SM00652 MVC   LASTLINE(0),PRESLINE(@07)
@SM00656 MVC   EBCDIC(0,OUTBUFAD),PRESLINE(@07)
         DS    0F
@AL00066 EQU   *                       LIST WITH   1 ARGUMENT(S)
@AL00074 EQU   *                       LIST WITH   1 ARGUMENT(S)
@AL00092 EQU   *                       LIST WITH   1 ARGUMENT(S)
@AL00103 EQU   *                       LIST WITH   1 ARGUMENT(S)
@AL00245 DC    A(@CF00078)             LIST WITH   1 ARGUMENT(S)
@AL00073 EQU   *                       LIST WITH   1 ARGUMENT(S)
@AL00091 EQU   *                       LIST WITH   1 ARGUMENT(S)
@AL00102 EQU   *                       LIST WITH   1 ARGUMENT(S)
@AL00174 EQU   *                       LIST WITH   1 ARGUMENT(S)
@AL00206 EQU   *                       LIST WITH   1 ARGUMENT(S)
@AL00222 EQU   *                       LIST WITH   1 ARGUMENT(S)
@AL00269 EQU   *                       LIST WITH   1 ARGUMENT(S)
@AL00333 EQU   *                       LIST WITH   1 ARGUMENT(S)
@AL00362 DC    A(@CF00041)             LIST WITH   1 ARGUMENT(S)
@AL00106 EQU   *                       LIST WITH   1 ARGUMENT(S)
@AL00260 DC    A(@CF00169)             LIST WITH   1 ARGUMENT(S)
         DS    0F
@SA00001 DS    18F
@SA00003 DS    15F
@PC00003 DS    1F
@SA00006 DS    15F
@SA00005 DS    15F
@SA00002 DS    15F
@SA00007 DS    14F
         DS    0F
@CF00041 DC    F'1'
@CH00041 EQU   @CF00041+2
@CF00078 DC    F'2'
@CH00078 EQU   @CF00078+2
@CF00169 DC    F'3'
@CH00169 EQU   @CF00169+2
@CF00047 DC    F'4'
@CH00047 EQU   @CF00047+2
@CF00362 DC    F'32'
@CF00180 DC    F'64'
@CF00642 DC    F'-12'
@CF00647 DC    F'-8'
@CF00648 DC    F'-7'
@CF00532 DC    XL4'FFFFFFE0'
@CF00582 DC    XL4'FFFFFFC0'
@CA00367 DC    A(PRNTSTG)
@CA00368 DC    A(PCBRTN)
         DS    0D
LINELGT  DC    F'32'
DPSSAVEA DS    A
CRNTOFF  DS    F
REALADW  DS    AL4
         ORG   REALADW
@NM00075 DS    CL1
RECADDR  DS    CL3
         ORG   RECADDR
RECADDR1 DS    CL4
         ORG   REALADW+5
         DS    CL3
LINEMASK DC    XL4'FFFFFFE0'
BLOCKMSK DC    XL4'FFFFF000'
OFFSTMSK DC    XL4'00000FFF'
CRNTLINE DS    A
RETCODE  DS    F
PROTNRQ  DC    AL1(0)
PROTKF   DC    AL1(1)
@CC00581 DC    C'ASID'
@CC00600 DC    C'  '
@CB00429 DC    X'FFFF'
PCBDATA  DS    CL12
PSWMSG   DC    CL11'CURRENT PSW'
LASTASID DC    X'FFFF'
         DS    CL1
HEXDATA  DS    CL5
         ORG   HEXDATA
HEXDATA1 DS    AL4
         ORG   HEXDATA+5
DPSSWITC DS    CL1
         ORG   DPSSWITC
PREVREAD DS    BL1
FRSTDUPE EQU   DPSSWITC+0
FIRSTLIN EQU   DPSSWITC+0
@NM00074 EQU   DPSSWITC+0
         ORG   DPSSWITC+1
NOSTRMSG DC    CL40'ONLY GENERAL PURPOSE REGISTERS AVAILABLE'
THRU     DC    CL8' THROUGH'
RESTOMSG DC    CL21' COULD NOT BE PRINTED'
RELADMSG DC    CL27'REAL ADDRESS FOR        IS '
STORKMSG DC    CL42'STORAGE KEY IS    FOR STORAGE BEGINNING AT'
NOREGMSG DC    CL30'REGISTERS COULD NOT BE PRINTED'
IOERRMSG DC    CL23'I/O ERROR READING BLOCK'
RECLMPGE DC    CL16'RECLAIMABLE PAGE'
DUPEMSG  DC    CL34'TO NEXT LINE ADDRESS SAME AS ABOVE'
LASTLINE DS    CL64
THISKEY  DS    CL1
LASTKEY  DS    CL1
PCBSWICH DS    CL1
         ORG   PCBSWICH
MERGE    DS    BL1
         ORG   PCBSWICH+1
REGMSG   DC    CL8'GPRS 0-7'
         DC    CL8'GPRS 8-F'
         DC    CL8'CTRS 0-7'
         DC    CL8'CTRS 8-F'
FPRMSG   DC    CL8'FPRS 0-2'
         DC    CL8'FPRS 4-6'
         DS    CL2
PATCH    DC    80F'0'
AMDPRDPS CSECT
DTAE     EQU   32                  DATA EBCDIC BIT
DTAC     EQU   16                  DATA IN CORE BIT
DTAP     EQU   8                   DATA PTR BIT
DTA      EQU   4                   DATA INCLUDED BIT
LBLP     EQU   2                   LABEL PTR BIT
LBL      EQU   1                   LABEL INCLUDED BIT
AMDPRDPS CSECT
@00      EQU   00                      EQUATES FOR REGISTERS 0-15
@01      EQU   01
@02      EQU   02
@03      EQU   03
@04      EQU   04
@05      EQU   05
@06      EQU   06
@07      EQU   07
@08      EQU   08
@09      EQU   09
@10      EQU   10
@11      EQU   11
@12      EQU   12
@13      EQU   13
@14      EQU   14
@15      EQU   15
DEQADDR  EQU   @06
NEWPCB   EQU   @06
PCBPLPTR EQU   @05
LASTPCB  EQU   @07
PCBADDR  EQU   @04
BUFFEND  EQU   @03
BUFFADDR EQU   @06
WORD     EQU   @07
HALF     EQU   @03
M        EQU   @03
K        EQU   @09
J        EQU   @07
I        EQU   @03
FROMPTR  EQU   @05
AREAPTR  EQU   @02
CPUSTATP EQU   @06
OUTBUFAD EQU   @04
SUBERRTN EQU   @05
LSTSTOP  EQU   @08
LSTERRTN EQU   @10
R0       EQU   @00
R1       EQU   @01
R9       EQU   @09
R13      EQU   @13
R15      EQU   @15
COMBASE  EQU   @12
PREG     EQU   @01
CPUADDR  EQU   @02
BLOCKADR EQU   @02
BASE1    EQU   @11
BASE2    EQU   @10
BASE3    EQU   @09
BEGINADR EQU   @01
BUFREG   EQU   @06
CNTREG   EQU   @03
LINEREG  EQU   @08
R10      EQU   @10
R11      EQU   @11
R12      EQU   @12
R14      EQU   @14
R2       EQU   @02
R3       EQU   @03
R4       EQU   @04
R5       EQU   @05
R6       EQU   @06
R7       EQU   @07
R8       EQU   @08
STOPBASE EQU   @05
PCBPL    EQU   0
PCBPBGN  EQU   PCBPL
PCBPEND  EQU   PCBPL+4
PCBPASID EQU   PCBPL+8
PCBPFLG1 EQU   PCBPL+10
PCBPVIRT EQU   PCBPFLG1
PCBPREAL EQU   PCBPFLG1
PCBPLOWC EQU   PCBPFLG1
PCBPTOPC EQU   PCBPFLG1
PCBPFLG2 EQU   PCBPL+11
PCBPFUNC EQU   PCBPFLG2
COMMON   EQU   0
ERRADDR  EQU   COMMON
WORK1    EQU   COMMON+24
CURBUF   EQU   COMMON+48
PCBPTR   EQU   COMMON+60
SWA      EQU   COMMON+122
SWB      EQU   COMMON+123
IOERR    EQU   SWB
SWC      EQU   COMMON+124
SWD      EQU   COMMON+125
GPRSFND  EQU   SWD
SWE      EQU   COMMON+126
SWF      EQU   COMMON+127
BUFSW    EQU   COMMON+128
PRSW     EQU   COMMON+129
PRNTREAL EQU   PRSW
TABLE    EQU   COMMON+659
HEXTABL  EQU   TABLE+63
EBCTABL  EQU   HEXTABL+10
AWRITE   EQU   COMMON+1500
STOPEXIT EQU   COMMON+1528
APCBENQ  EQU   COMMON+1560
APRTSTG  EQU   COMMON+1572
DCBADDRS EQU   COMMON+1608
@NM00044 EQU   DCBADDRS+16
@NM00045 EQU   @NM00044
REALMAP  EQU   COMMON+1644
IPLCPU   EQU   COMMON+1666
BRRDDATA EQU   COMMON+1984
TOPICHDR EQU   COMMON+2060
I3800SW  EQU   COMMON+2076
I3800KEY EQU   I3800SW
I3800204 EQU   I3800SW
TITLEKEY EQU   COMMON+2077
TITLESTK EQU   TITLEKEY+12
ERRORRTN EQU   0
OUTBUFR  EQU   0
DATAPART EQU   OUTBUFR+1
ADDRESS  EQU   DATAPART
STOKEY   EQU   DATAPART+7
STOKEY1  EQU   STOKEY
FIELD1   EQU   DATAPART+10
FIELD2   EQU   DATAPART+48
ASTR1    EQU   DATAPART+86
EBCDIC   EQU   DATAPART+87
ASTR2    EQU   DATAPART+119
AOUTBUFR EQU   0
ADATAPRT EQU   AOUTBUFR+1
AFIELD1  EQU   ADATAPRT+7
AEBCDIC  EQU   ADATAPRT+139
CPUSTAT  EQU   0
CPUFLAGS EQU   CPUSTAT
CPUGPRS  EQU   CPUFLAGS
CPUFLPT  EQU   CPUSTAT+4
CPUREGS  EQU   CPUSTAT+36
CPUPSW1  EQU   CPUSTAT+164
CPUPSW2  EQU   CPUSTAT+168
TOAREA   EQU   0
FROM     EQU   0
BUFPRFX  EQU   0
KEY1     EQU   BUFPRFX
KEY2     EQU   BUFPRFX+1
BUFASID  EQU   BUFPRFX+2
REALAD   EQU   BUFPRFX+4
PRESLINE EQU   0
DATAHLF1 EQU   PRESLINE
PCB      EQU   0
PCBLINK  EQU   PCB
PCBSTART EQU   PCB+4
PCBSTOP  EQU   PCB+8
PCBASID  EQU   PCB+12
LINESKIP EQU   0
MESSAGE  EQU   DATAPART
PSW      EQU   DATAPART
PSWHEADR EQU   PSW
PSWWORD1 EQU   PSW+13
PSWWORD2 EQU   PSW+23
REGS     EQU   DATAPART
REGHEADR EQU   REGS
@NM00062 EQU   REGS+13
REGWORD  EQU   @NM00062
@NM00065 EQU   REGS+72
REGWORD2 EQU   @NM00065
FLPTREGS EQU   DATAPART
FREG1    EQU   FLPTREGS+13
FREG2    EQU   FLPTREGS+35
ASIDPLC  EQU   TOPICHDR+5
INPASIDC EQU   PCBPASID
ADDR1    EQU   CRNTLINE
ADDR2    EQU   CRNTOFF
THISKEY1 EQU   THISKEY
         AGO   .@UNREFD                START UNREFERENCED COMPONENTS
@NM00067 EQU   FLPTREGS+31
FLHDR    EQU   FLPTREGS
@NM00066 EQU   @NM00065+9
@NM00064 EQU   REGS+65
@NM00063 EQU   @NM00062+9
@NM00061 EQU   PSW+22
@NM00060 EQU   PSW+11
PCBRESV  EQU   PCB+15
PCBFLAG  EQU   PCB+14
DATAHLF2 EQU   PRESLINE+16
@NM00073 EQU   CPUSTAT+172
@NM00072 EQU   CPUREGS
@NM00071 EQU   CPUFLPT
CPUCPU   EQU   CPUSTAT+2
@NM00070 EQU   CPUSTAT+1
@NM00069 EQU   CPUFLAGS
@NM00068 EQU   CPUFLAGS
AFIELD4  EQU   ADATAPRT+106
AFIELD3  EQU   ADATAPRT+73
AFIELD2  EQU   ADATAPRT+40
@NM00059 EQU   ADATAPRT+6
AADDRESS EQU   ADATAPRT
APRCNTRL EQU   AOUTBUFR
@NM00058 EQU   DATAPART+120
@NM00057 EQU   DATAPART+9
@NM00056 EQU   DATAPART+6
PRCONTRL EQU   OUTBUFR
@NM00055 EQU   TITLEKEY
I380080  EQU   I3800SW
I3800ULN EQU   I3800SW
@NM00054 EQU   I3800SW
@NM00053 EQU   I3800SW
@NM00052 EQU   I3800SW
@NM00051 EQU   I3800SW
CSADDR   EQU   COMMON+2072
@NM00050 EQU   COMMON+2070
DFLTCSA  EQU   COMMON+2056
LPAMAX   EQU   COMMON+2052
DNUCTOP  EQU   COMMON+2048
XLMAX    EQU   COMMON+2044
DQEMAX   EQU   COMMON+2042
ASCBMAX  EQU   COMMON+2040
TCBMAX   EQU   COMMON+2038
SRBMAX   EQU   COMMON+2036
DDMAX    EQU   COMMON+2034
DEBMAX   EQU   COMMON+2032
JPQMAX   EQU   COMMON+2030
LLEMAX   EQU   COMMON+2028
PQEMAX   EQU   COMMON+2026
RBMAX    EQU   COMMON+2024
@NM00049 EQU   COMMON+2023
EXITFLAG EQU   COMMON+2022
AUSRASID EQU   COMMON+2020
AUSRTCBA EQU   COMMON+2016
AUSRDEL  EQU   COMMON+2012
AUSREXIT EQU   COMMON+2008
AUSRINIT EQU   COMMON+2004
ASRBFMT  EQU   COMMON+2000
AASCBFMT EQU   COMMON+1996
BRRDADJ  EQU   COMMON+1992
BRRDINIT EQU   COMMON+1988
BUFERMAP EQU   COMMON+1980
ASCBMAP  EQU   COMMON+1976
CPUMAP   EQU   COMMON+1972
ASIDNDX  EQU   COMMON+1968
@NM00048 EQU   COMMON+1964
HDRTITLE EQU   COMMON+1864
HDRREGS  EQU   COMMON+1696
SACSWCAW EQU   COMMON+1684
ASVTADDR EQU   COMMON+1680
PREFXRGV EQU   COMMON+1676
PREFXRGR EQU   COMMON+1672
CURASCB  EQU   COMMON+1668
QASID    EQU   COMMON+1664
QAPFT    EQU   COMMON+1660
@NM00047 EQU   COMMON+1656
REALMAX  EQU   COMMON+1652
SEGTABOR EQU   COMMON+1648
@NM00046 EQU   COMMON+1641
EDITER   EQU   COMMON+1640
AROOT    EQU   COMMON+1636
AEDITCB  EQU   COMMON+1632
TRCCOUNT EQU   COMMON+1628
ASYSUDCB EQU   @NM00044+1
ENDLIST  EQU   @NM00045
AINDCB   EQU   DCBADDRS+12
ARDRDCB  EQU   DCBADDRS+8
APTRDCB  EQU   DCBADDRS+4
AOUTDCB  EQU   DCBADDRS
ATCBSMRY EQU   COMMON+1604
ATCBSMFR EQU   COMMON+1600
ONGOPTR  EQU   COMMON+1596
AEND     EQU   COMMON+1592
AERRMSGA EQU   COMMON+1584
BUFREINT EQU   COMMON+1580
BUFSUM   EQU   COMMON+1576
AFORMAT  EQU   COMMON+1568
ASTPROUT EQU   COMMON+1564
ATCBRTRV EQU   COMMON+1556
ATCBREMV EQU   COMMON+1552
ATCBSAVE EQU   COMMON+1548
QATMERTN EQU   COMMON+1544
ALOADER  EQU   COMMON+1540
AEREXIT  EQU   COMMON+1536
SYNMSGA  EQU   COMMON+1532
ARGNBND  EQU   COMMON+1524
AWRDCNVT EQU   COMMON+1520
AADRCNVT EQU   COMMON+1516
AFMTLINE EQU   COMMON+1512
ASYNTAX  EQU   COMMON+1508
APRTMSG  EQU   COMMON+1504
NONBLNK  EQU   COMMON+1244
BLNK     EQU   COMMON+988
@NM00043 EQU   COMMON+972
@NM00042 EQU   COMMON+915
@NM00041 EQU   HEXTABL
@NM00040 EQU   TABLE
CAPTABL  EQU   COMMON+403
TITLEPGE EQU   COMMON+394
@NM00039 EQU   COMMON+392
TITLETME EQU   COMMON+379
@NM00038 EQU   COMMON+377
TITLEDTE EQU   COMMON+364
@NM00037 EQU   COMMON+362
TITLEMOD EQU   COMMON+347
TITLEMSG EQU   COMMON+283
MSG2     EQU   COMMON+257
MSG1     EQU   COMMON+231
STOP     EQU   COMMON+227
TITLE    EQU   COMMON+222
BLANKS   EQU   COMMON+214
WTORMSG  EQU   COMMON+133
@NM00036 EQU   COMMON+130
@NM00035 EQU   PRSW
@NM00034 EQU   PRSW
PRNTRL   EQU   PRSW
TTLSW    EQU   PRSW
@NM00033 EQU   PRSW
QSEGTBSW EQU   PRSW
@NM00032 EQU   PRSW
@NM00031 EQU   BUFSW
PREFM    EQU   BUFSW
@NM00030 EQU   BUFSW
@NM00029 EQU   BUFSW
@NM00028 EQU   BUFSW
@NM00027 EQU   BUFSW
@NM00026 EQU   BUFSW
@NM00025 EQU   BUFSW
@NM00024 EQU   SWF
QUT1LOD  EQU   SWF
@NM00023 EQU   SWF
PAGEOK   EQU   SWF
DMPIC    EQU   SWF
QSADMP   EQU   SWF
NUCTFRMC EQU   SWF
QPRDINIT EQU   SWF
@NM00022 EQU   SWE
@NM00021 EQU   SWE
@NM00020 EQU   SWE
BUILDMAP EQU   SWE
TITLESW  EQU   SWE
RESPC    EQU   SWE
@NM00019 EQU   SWE
STOPSW   EQU   SWE
@NM00018 EQU   SWD
CONTSW   EQU   SWD
NOLOADSW EQU   SWD
NOSTDMG  EQU   SWD
@NM00017 EQU   SWD
@NM00016 EQU   SWD
FLSHMODE EQU   SWD
@NM00015 EQU   SWC
@NM00014 EQU   SWC
@NM00013 EQU   SWC
EDITSW   EQU   SWC
TREADIN  EQU   SWC
POSITSW  EQU   SWC
SETFLSH  EQU   SWC
MSTRSW   EQU   SWC
@NM00012 EQU   SWB
@NM00011 EQU   SWB
QSYSUT2  EQU   SWB
ENDSW    EQU   SWB
@NM00010 EQU   SWB
@NM00009 EQU   SWB
FMTERR   EQU   SWB
RDRSW    EQU   SWA
SETCVTSW EQU   SWA
@NM00008 EQU   SWA
GOSW     EQU   SWA
@NM00007 EQU   SWA
@NM00006 EQU   SWA
@NM00005 EQU   SWA
@NM00004 EQU   SWA
LINENUM  EQU   COMMON+120
LINENUMB EQU   COMMON+118
SIXTEEN  EQU   COMMON+116
TWELVE   EQU   COMMON+114
ELEVEN   EQU   COMMON+112
HTEN     EQU   COMMON+110
EIGHT    EQU   COMMON+108
SEVEN    EQU   COMMON+106
FIVE     EQU   COMMON+104
FOUR     EQU   COMMON+102
THREE    EQU   COMMON+100
TWO      EQU   COMMON+98
ONEA     EQU   COMMON+96
READTM   EQU   COMMON+92
RDERCNT  EQU   COMMON+88
READNO   EQU   COMMON+84
RDENTRY  EQU   COMMON+80
@NM00003 EQU   COMMON+78
FILESEQ  EQU   COMMON+76
INDD     EQU   COMMON+68
STORSIZE EQU   COMMON+64
CVTADDR  EQU   COMMON+56
TCBLIST  EQU   COMMON+52
PAGENUMB EQU   COMMON+44
LINECNT  EQU   COMMON+40
SIX      EQU   COMMON+36
NUCTOP   EQU   COMMON+32
DELIMCD  EQU   COMMON+20
KYWDEND  EQU   COMMON+16
KYWDBGN  EQU   COMMON+12
VERBEND  EQU   COMMON+8
VERBGN   EQU   COMMON+4
@NM00002 EQU   PCBPFLG2
@NM00001 EQU   PCBPFLG1
.@UNREFD ANOP                          END UNREFERENCED COMPONENTS
@RT00184 EQU   NRCLMD
@RC00213 EQU   @RC00211
@RF00263 EQU   BLOCKEND
@RC00339 EQU   @EL00003
@RC00337 EQU   @EL00003
@RC00424 EQU   @RC00394
@RC00396 EQU   @RC00394
@RC00370 EQU   @EL00006
@RC00456 EQU   @EL00006
@RC00398 EQU   @RC00396
@RC00416 EQU   @RC00396
@RC00426 EQU   @RC00424
@ENDDATA EQU   *
         END   AMDPRDPS,(C'PLS1823',0603,76069)
