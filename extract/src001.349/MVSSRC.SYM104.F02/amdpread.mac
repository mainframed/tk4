         TITLE 'AMDPREAD - AMDPRDMP READ ROUTINE                       *
                        '
AMDPREAD CSECT ,                                                   0001
@PROLOG  STM   @14,@12,12(@13)                                     0001
         BALR  @11,0                                               0001
@PSTART  DS    0H                                                  0001
         USING @PSTART,@11                                         0001
         ST    @13,@SA00001+4                                      0001
         LA    @14,@SA00001                                        0001
         ST    @14,8(,@13)                                         0001
         LR    @13,@14                                             0001
         DCBD  DSORG=BS,DEVD=(DA,TA)
AMDPREAD CSECT
         USING IHADCB,R3
*   PARMPTR=REG1;                   /* SET UP PARM LIST PTR          */
         LR    PARMPTR,REG1                                        0091
*   RESPECIFY                                                      0092
*     REG1 UNRESTRICTED;            /* UNRESTRICT PARM REGISTER    0092
*                                      Y02006                        */
*   SWITCHES=BYTEOFF;               /* TURN OFF ALL SWITCHES         */
         MVI   SWITCHES,X'00'                                      0093
*   IF BUILDMAP=SWTCHOFF THEN       /* IS THIS A MAPBUILD REQUEST    */
         TM    BUILDMAP(COMPTR),B'00001000'                        0094
         BZ    @RT00094                                            0094
*     GO TO TYPEREAD;               /* NO--THEN READ REQUESTED RECORD*/
*                                                                  0096
*/********************************************************************/
*/*                                                                  */
*/*           PERFORM TAPE OR DA INITIALIZATION FOR MAP BUILD.       */
*/*           CHECK FILE SEQUENCE NUMBER                             */
*/*           AND DDNAME SPECIFIED IN COMMON. OPEN                   */
*/*           INPUT DCB.                                             */
*/*                                                                  */
*/********************************************************************/
*                                                                  0096
*TAPEINIT:                                                         0096
*   REG3=ADDR(INDCB);               /* BASE TAPE INPUT DCB           */
TAPEINIT LA    REG3,INDCB                                          0096
*   VOLINDD=VOLNO1;                 /* RESET INDD VOLUME NUMBER      */
         MVI   VOLINDD,X'01'                                       0097
*   IF TREADIN=SWTCHOFF THEN                                       0098
         TM    TREADIN(COMPTR),B'00010000'                         0098
         BNZ   @RF00098                                            0098
*     FIRSTTTR=DATTR;               /* SET FIRST TTR FOR DA Y02006   */
         MVC   FIRSTTTR(4),@CF00061                                0099
*   ELSE                                                           0100
*     FIRSTTTR=TAPETTR;             /* SET FIRST TTR FOR TAPE        */
         B     @RC00098                                            0100
@RF00098 MVC   FIRSTTTR(4),@CF00063                                0100
*   AINDCB=REG3;                    /* STORE INDCB ADDR IN COMMON    */
@RC00098 ST    REG3,AINDCB(,COMPTR)                                0101
*   INDDREC=0;                      /* INIT. INDD REC/TRK VALUE      */
         SLR   @10,@10                                             0102
         STH   @10,INDDREC                                         0102
*   DCBDDNAM=INDD;                  /* MOVE DDNAME FROM COMMON IN  0103
*                                      CASE OF NEWDUMP STATEMENT     */
         MVC   DCBDDNAM(8),INDD(COMPTR)                            0103
*/********************************************************************/
*/*                                                                  */
*/*           READ JFCB TO DETERMINE PROPER POSITIONING              */
*/*           IN CASE OF NEWDUMP STATEMENT WITH                      */
*/*           DIFFERENT FILE SEQUENCE NUMBER.  OVERRIDE              */
*/*           JFCB BUFFER NUMBER BY SETTING TO 0. OPEN               */
*/*           DATA SET AND PERFORM SOME INITIALIZATION.              */
*/*                                                                  */
*/********************************************************************/
*                                                                  0104
*   GEN(RDJFCB MF=(E,DCBLST));      /* READ JFCB FOR FILE POSITIONING*/
         RDJFCB MF=(E,DCBLST)
*   IF FILESEQ^=0 THEN              /* TEST TO INSURE THAT A FILE  0105
*                                      SEQ-NO ON DD IS NOT IGNORED   */
         LH    @10,FILESEQ(,COMPTR)                                0105
         LTR   @10,@10                                             0105
         BZ    @RF00105                                            0105
*     JFCBFLSQ=FILESEQ;             /* MOVE FILE SEQ-NO FROM COMMON  */
         LA    @04,JFCBBUF                                         0106
         STH   @10,JFCBFLSQ+68(,@04)                               0106
*   JFCBUFNO=BYTEOFF;               /* SET BUFFER NO. TO ZERO        */
@RF00105 LA    @10,JFCBBUF                                         0107
         MVI   JFCBUFNO+88(@10),X'00'                              0107
*   JFCBMASK(33)=SWTCHOFF;          /* SUPPRESS WRITING JFCB         */
         NI    JFCBMASK+76(@10),B'01111111'                        0108
*   JFCBTSDM='08'X;                 /* BACK TO JOB QUEUE             */
         MVI   JFCBTSDM+52(@10),X'08'                              0109
*   GEN;                                                           0110
         OPEN  (,(INPUT,REREAD)),MF=(E,DCBLST),TYPE=J
*   OPENJ=SWITCHON;                 /* INDICATE OPEN TYPE=J REQUIRED */
         OI    OPENJ,B'00000100'                                   0111
*                                                                  0112
*/********************************************************************/
*/*                                                                  */
*/*           PERFORM INITIALIZATION FOR MAP BUILD                   */
*/*                                                                  */
*/********************************************************************/
*                                                                  0112
*MAPINIT:                                                          0112
*   CURVOL=0;                       /* SET CURRENT VOLUME TO ZERO    */
MAPINIT  SLR   @08,@08                                             0112
         STH   @08,CURVOL                                          0112
*   CURASID=INITASID;               /* INITIALIZE LAST ASID SO NEW 0113
*                                      MAP ENTRY WILL BE OBTAINED  0113
*                                      Y02006                        */
         MVC   CURASID(2),@CB00067                                 0113
*   CURADDR=INITADDR;               /* INITALIZE LAST ADDRESS SO NEW
*                                      MAP ENTRY WILL BE OBTAINED  0114
*                                      Y02006                        */
         MVC   CURADDR(4),@CB00069                                 0114
*   MAPERROR=0;                     /* ZERO ERROR COUNT              */
         STH   @08,MAPERROR                                        0115
*   POSTIPL=0;                      /* ZERO POST IPL REC COUNT Y02006*/
         STH   @08,POSTIPL                                         0116
*   SVCTTR=0;                       /* INITIALIZE SVC TTR FIELD    0117
*                                      Y02006                        */
         ST    @08,SVCTTR                                          0117
*   RESPECIFY                                                      0118
*    (REG0,                                                        0118
*     REG1) RESTRICTED;             /* RESTRICT REGISTERS Y02006     */
*   REG0=BUFFSIZE;                  /* SET SIZE FOR GETMAIN Y02006   */
         LH    REG0,@CH00038                                       0119
*   GENERATE(GETMAIN R,LV=(0));     /* ISSUE GETMAIN FOR BUFFER TO 0120
*                                      KEEP SVC BUFFER RECORD IN   0120
*                                      Y02006                        */
         GETMAIN R,LV=(0)
*   SVCBUFAD=REG1;                  /* SAVE ADDRESS OF BUFFER Y02006 */
         ST    REG1,SVCBUFAD                                       0121
*   RESPECIFY                                                      0122
*    (REG0,                                                        0122
*     REG1) UNRESTRICTED;           /* UNRESTRICT REGISTERS Y02006   */
*   QPRDINIT=SWITCHON;              /* INDICATE PREAD INITIALIZATION
*                                      HAS BEEN PERFORMED AFTER A  0123
*                                      NEWDUMP/NEWTAPE OPERATION   0123
*                                      Y02006                        */
         OI    QPRDINIT(COMPTR),B'10000000'                        0123
*   LASTMAP=0;                      /* FOR PLS OPTIMIZATION Y02006   */
         SLR   LASTMAP,LASTMAP                                     0124
*   CURMAP=0;                       /* FOR PLS OPTIMIZATION Y02006   */
         SLR   CURMAP,CURMAP                                       0125
*/********************************************************************/
*/*                                                                  */
*/*           PURGE ANY EXISTING DUMP MAPS, AND                      */
*/*           THE ASID INDEX, IF IT EXISTS.                          */
*/*                                                                  */
*/********************************************************************/
*                                                                  0126
*DUMPMAP:                                                          0126
*   MAPSW=SWITCHON;                 /* INDICATE DUMPMAP IN PROCESS 0126
*                                      Y02006                        */
DUMPMAP  OI    MAPSW,B'10000000'                                   0126
*   IF REALMAP^=0 THEN              /* IS THERE A REAL MAP Y02006    */
         L     @08,REALMAP(,COMPTR)                                0127
         LTR   @08,@08                                             0127
         BZ    @RF00127                                            0127
*     DO;                           /* YES                           */
*       MAPPTR=REALMAP;             /* POINT TO REAL MAP             */
         LR    MAPPTR,@08                                          0129
*       CALL MAPPRG;                /* PURGE REAL MAP ENTRIES        */
         BAL   @14,MAPPRG                                          0130
*       REALMAP=0;                  /* SET REALMAP PTR IN COMMON TO 0*/
         SLR   @08,@08                                             0131
         ST    @08,REALMAP(,COMPTR)                                0131
*     END;                                                         0132
*   IF CPUMAP^=0 THEN               /* IS THERE A CPU MAP Y02006     */
@RF00127 L     @08,CPUMAP(,COMPTR)                                 0133
         LTR   @08,@08                                             0133
         BZ    @RF00133                                            0133
*     DO;                           /* YES                           */
*       MAPPTR=CPUMAP;              /* POINT TO CPU MAP Y02006       */
         LR    MAPPTR,@08                                          0135
*       CALL MAPPRG;                /* PURGE CPU MAP ENTRIES         */
         BAL   @14,MAPPRG                                          0136
*       CPUMAP=0;                   /* SET CPUMAP PTR IN COMMON TO 0
*                                      Y02006                        */
         SLR   @08,@08                                             0137
         ST    @08,CPUMAP(,COMPTR)                                 0137
*     END;                                                         0138
*   INDXADDR=ASIDNDX;               /* SET PTR TO FIRST ASID INDEX 0139
*                                      Y02006                        */
@RF00133 MVC   INDXADDR(4),ASIDNDX(COMPTR)                         0139
*   ASIDNDX=0;                      /* SET ASID INDEX PTR IN COMMON
*                                      TO ZERO Y02006                */
         SLR   @08,@08                                             0140
         ST    @08,ASIDNDX(,COMPTR)                                0140
*CHKASID:                                                          0141
*   IF INDXADDR=0 THEN              /* ASID INDEX EXIST Y02006       */
CHKASID  ICM   @08,15,INDXADDR                                     0141
         BZ    @RT00141                                            0141
*     GO TO MAPREAD;                /* NO - BEGIN MAP BUILD PROCESS  */
*   DO I=1 TO ASIDCNT;                                             0143
         LA    I,1                                                 0143
@DL00143 DS    0H                                                  0144
*     MAPPTR=ASDXMAP(I);            /* POINT TO FIRST DUMPMAP ENTRY
*                                      Y02006                        */
         LR    @08,I                                               0144
         SLA   @08,2                                               0144
         L     @06,INDXADDR                                        0144
         L     MAPPTR,ASDXMAP-4(@08,@06)                           0144
*     IF MAPPTR^=0 THEN             /* ANY MAP TO PURGE Y02006       */
         LTR   MAPPTR,MAPPTR                                       0145
         BZ    @RF00145                                            0145
*       CALL MAPPRG;                /* PURGE VIRTUAL DUMP MAP ENTRIES*/
         BAL   @14,MAPPRG                                          0146
*   END;                                                           0147
@RF00145 AH    I,@CH00042                                          0147
         CH    I,@CH00065                                          0147
         BNH   @DL00143                                            0147
*   RESPECIFY                                                      0148
*    (REG0,                                                        0148
*     REG1) RESTRICTED;             /* RESTRICT REGISTERS Y02006     */
*   REG0=LENGTH(ASIDLIST);          /* SIZE OF ASID INDEX Y02006     */
         LA    REG0,112                                            0149
*   REG1=INDXADDR;                  /* ADDRESS OF ASID INDEX Y02006  */
         L     @08,INDXADDR                                        0150
         LR    REG1,@08                                            0150
*   INDXADDR=ASDXLNK;               /* SAVE PTR TO NEXT ASID INDEX 0151
*                                      Y02006                        */
         L     @08,ASDXLNK(,@08)                                   0151
         ST    @08,INDXADDR                                        0151
*   GENERATE(FREEMAIN R,LV=(0),A=(1));/* FREE ASID INDEX Y02006      */
         FREEMAIN R,LV=(0),A=(1)
*   RESPECIFY                                                      0153
*    (REG0,                                                        0153
*     REG1) UNRESTRICTED;           /* UNRESTRICT REGISTERS Y02006   */
*   GO TO CHKASID;                  /* LOOP TO FREE ALL ASID INDESES
*                                      Y02006                        */
         B     CHKASID                                             0154
*                                                                  0155
*/********************************************************************/
*/*                                                                  */
*/*           MAP PURGE ROUTINE -                                    */
*/*                                                                  */
*/*                   PURGE MAP BEGINNING WITH CURRENT               */
*/*                   ENTRY, FOLLOWING LINK FIELD TILL               */
*/*                   END OF MAP. MAPPTR IS INPUT,                   */
*/*                   POINTING TO THE FIRST MAP ENTRY TO             */
*/*                   BE PURGED.                                     */
*/*                                                                  */
*/********************************************************************/
*                                                                  0155
*MAPPRG:                                                           0155
*   PROC OPTIONS(NOSAVEAREA,NOSAVE);                               0155
MAPPRG   DS    0H                                                  0156
*   N1=1;                           /* SET LOOP CONTROL TO NON-ZERO  */
         LA    N1,1                                                0156
*   DO WHILE(N1^=0);                /* LOOP TO FREE EACH ENTRY Y02006*/
         B     @DE00157                                            0157
@DL00157 DS    0H                                                  0158
*     N1=DUMPLINK;                  /* NO - SAVE LINK FIELD          */
         SLR   N1,N1                                               0158
         ICM   N1,7,DUMPLINK(MAPPTR)                               0158
*     RESPECIFY                                                    0159
*      (REG0,                                                      0159
*       REG1) RESTRICTED;           /* RESTRICT REGISTERS Y02006     */
*     REG1=MAPPTR;                                                 0160
         LR    REG1,MAPPTR                                         0160
*     REG0=DUMPFRMS;                /* FREE CURRENT DUMP MAP ENTRY   */
         LA    REG0,16                                             0161
*     GENERATE(FREEMAIN R,LV=(0),A=(1));                           0162
         FREEMAIN R,LV=(0),A=(1)
*     RESPECIFY                                                    0163
*      (REG0,                                                      0163
*       REG1) UNRESTRICTED;         /* UNRESTRICT REGISTERS Y02006   */
*     MAPPTR=N1;                    /* MAKE NEXT ENTRY CURRENT       */
         LR    MAPPTR,N1                                           0164
*   END;                                                           0165
@DE00157 LTR   N1,N1                                               0165
         BNZ   @DL00157                                            0165
*   END MAPPRG;                     /* RETURN TO CALLER              */
@EL00002 DS    0H                                                  0166
@EF00002 DS    0H                                                  0166
@ER00002 BR    @14                                                 0166
*                                                                  0167
*/********************************************************************/
*/*                                                                  */
*/*           SCAN FOR HEADER RECORD, AND WHEN FOUND,                */
*/*           BEGIN BUILDING MAP OF DATA RECORDS.                    */
*/*                                                                  */
*/********************************************************************/
*                                                                  0167
*MAPREAD:                                                          0167
*   IF HDRSW=SWITCHON&BUFFLINK^=0 THEN/* USE NEXT BUFFER ONLY IF A 0167
*                                      HEADER HAS BEEN READ AND THERE
*                                      IS ANOTHER BUFFER       Y02006*/
MAPREAD  TM    HDRSW,B'01000000'                                   0167
         BNO   @RF00167                                            0167
         L     @08,BUFFLINK(,PARMPTR)                              0167
         LTR   @08,@08                                             0167
         BZ    @RF00167                                            0167
*     DO;                                                          0168
*       PARMPTR=BUFFLINK;           /* SET POINTER TO NEXT BUFFER MAP
*                                      ENTRY Y02006                  */
         LR    PARMPTR,@08                                         0169
*       IOERR=SWTCHOFF;             /* RESET I/O ERROR SWITCH ONLY ON
*                                      USE OF A NEW BUFFER (NEEDED 0170
*                                      FOR CPU RECS) Y02006          */
         NI    IOERR(COMPTR),B'01111111'                           0170
*     END;                                                         0171
*   ELSE                                                           0172
*     DO;                                                          0172
         B     @RC00167                                            0172
@RF00167 DS    0H                                                  0173
*       BUFFREAL=ALLFOX;            /* RESET REAL ADDRESS Y02006     */
         SLR   @08,@08                                             0173
         BCTR  @08,0                                               0173
         ST    @08,BUFFREAL(,PARMPTR)                              0173
*       BUFFVIRT=ALLFOX;            /* RESET VIRTUAL ADDRESS Y02006  */
         ST    @08,BUFFVIRT(,PARMPTR)                              0174
*       BUFFASID=ALLFOX2;           /* RESET ASID Y02006             */
         MVC   BUFFASID(2,PARMPTR),@CB00053                        0175
*       BUFFCPU=ALLFOX2;            /* RESET CPU ADDRESS Y02006      */
         MVC   BUFFCPU(2,PARMPTR),@CH00053                         0176
*       BUFFFLAG=BYTEOFF;           /* RESET FLAGS Y02006            */
         MVI   BUFFFLAG(PARMPTR),X'00'                             0177
*       DMPIC=SWTCHOFF;             /* INDICATE DUMP DOES NOT FIT  0178
*                                      INTO ALL THE BUFFERS Y02006   */
         NI    DMPIC(COMPTR),B'11101111'                           0178
*     END;                          /* NOW REUSE THE SAME BUFFER   0179
*                                      Y02006                        */
*   RESPECIFY                                                      0180
*    (REG0,                                                        0180
*     REG1) RESTRICTED;             /* RESTRICT REGISTERS Y02006     */
@RC00167 DS    0H                                                  0181
*MAPREAD1:                                                         0181
*   REG0=BUFFPTR;                   /* SET INPUT BUFFER ADDRESS      */
MAPREAD1 SLR   REG0,REG0                                           0181
         ICM   REG0,7,BUFFPTR(PARMPTR)                             0181
*   GENERATE FLOWS(IOERROR);                                       0182
         READ  MAPDECB,SF,(R3),(REG0),'S' READ RECORD INTO BUFFER
         CHECK MAPDECB
         NOTE  (R3)                    NOTE POSITION OF RECORD READ
*   TTRNO=REG1;                     /* SAVE NOTED POSITION           */
         ST    REG1,TTRNO                                          0183
*   RESPECIFY                                                      0184
*    (REG0,                                                        0184
*     REG1) UNRESTRICTED;           /* UNRESTRICT REGISTERS Y02006   */
*   LASTVOL=CURVOL;                 /* SAVE LAST VOLUME NUMBER TO  0185
*                                      TEST IF IT CHANGED Y02006     */
         LH    @04,CURVOL                                          0185
         LR    LASTVOL,@04                                         0185
*   IF TTRNO=FIRSTTTR THEN          /* DID VOLUME SWITCH OCCUR Y02006*/
         L     @15,TTRNO                                           0186
         C     @15,FIRSTTTR                                        0186
         BNE   @RF00186                                            0186
*     CURVOL=CURVOL+1;              /* YES - INCREMENT CURRENT VOLUME*/
         LA    @04,1(,@04)                                         0187
         STH   @04,CURVOL                                          0187
*   IF SYNADSW=SWTCHOFF THEN        /* I/O ERROR ON LAST READ Y02006 */
@RF00186 TM    SYNADSW,B'00100000'                                 0188
         BZ    @RT00188                                            0188
*     GO TO MAPZERO;                /* NO - CONTINUE PROCESSING      */
*/********************************************************************/
*/*                                                                  */
*/*       I/O ERROR OCCURRED. CHECK IF THE MAXIMUM NUMBER OF         */
*/*       CONSECUTIVE I/O ERRORS DURING THE MAP BUILD HAS OCCURRED.  */
*/*       IF SO, THEN STOP THE MAP BUILD PROCESS. TERMINATE AMDPRDMP */
*/*       PROCESSING IF A HEADER RECORD HAS NOT YET BEEN FOUND.      */
*/*       OTHERWISE PROCEED AS IF END OF FILE HAS BEEN REACHED.      */
*/*                                                                  */
*/********************************************************************/
*                                                                  0190
*   SYNADSW=SWTCHOFF;               /* TURN OFF SYNAD SWITCH Y02006  */
         NI    SYNADSW,B'11011111'                                 0190
*   SVCTTR=0;                       /* INVALIDATE SVC BUFFER TTR   0191
*                                      Y02006                        */
         SLR   @08,@08                                             0191
         ST    @08,SVCTTR                                          0191
*   CURADDR=INITADDR;               /* REINITIALIZE LAST ADDRESS   0192
*                                      Y02006                        */
         MVC   CURADDR(4),@CB00069                                 0192
*   MAPERROR=MAPERROR+1;            /* BUMP CONSECUTIVE I/O ERROR CNT*/
         LA    @08,1                                               0193
         AH    @08,MAPERROR                                        0193
         STH   @08,MAPERROR                                        0193
*   IF MAPERROR<MAXIOERR THEN       /* EXCEEDED MAXIMUM NUMBER       */
         LA    @04,3                                               0194
         CR    @08,@04                                             0194
         BL    @RT00194                                            0194
*     GO TO MAPREAD;                /* NO - CONTINUE READING         */
*   RDERCNT=RDERCNT+MAXIOERR;       /* BUMP I/O ERROR COUNT IN COMMON*/
         AL    @04,RDERCNT(,COMPTR)                                0196
         ST    @04,RDERCNT(,COMPTR)                                0196
*/********************************************************************/
*/*                                                                  */
*/*           END OF FILE ROUTINE -                                  */
*/*                                                                  */
*/*                THIS ROUTINE IS ENTERED AT END                    */
*/*                OF FILE ON THE DUMP DATA SET,                     */
*/*                WHEN THE MAXIMUM NUMBER OF                        */
*/*                CONSECUTIVE I/O ERRORS HAS                        */
*/*                OCCURRED DURING THE MAP BUILD,                    */
*/*                WHEN A SECOND HEADER RECORD IS FOUND,             */
*/*                OR WHEN FIVE RECORDS HAVE BEEN READ               */
*/*                WITHOUT FINDING A HEADER RECORD.                  */
*/*                                                                  */
*/********************************************************************/
*                                                                  0197
*EOF:                                                              0197
*   CALL DSOPEN;                    /* CLOSE AND RE-OPEN INPUT D.S.  */
EOF      BAL   @14,DSOPEN                                          0197
*   CURVOL=0;                       /* RESET CURRENT VOLUME NUMBER   */
         SLR   @10,@10                                             0198
         STH   @10,CURVOL                                          0198
*   IF MAPSW=SWTCHOFF THEN          /* DUMPMAP IN PROCESS Y02006     */
         TM    MAPSW,B'10000000'                                   0199
         BZ    @RT00199                                            0199
*     GO TO ERREXT;                 /* MARK BUFFER INVALID           */
*   RESPECIFY                                                      0201
*    (REG0,                                                        0201
*     REG1) RESTRICTED;             /* RESTRICT REGISTERS Y02006     */
*   REG1=SVCBUFAD;                  /* SET ADDRESS OF STORAGE USED TO
*                                      SAVE SVC BUFFER Y02006        */
         L     REG1,SVCBUFAD                                       0202
*   REG0=BUFFSIZE;                  /* SET SIZE OF STORAGE TO FREE 0203
*                                      Y02006                        */
         LH    REG0,@CH00038                                       0203
*   GEN(FREEMAIN R,LV=(0),A=(1));   /* FREE STORAGE IN WHICH SVC   0204
*                                      BUFFER WAS SAVED Y02006       */
         FREEMAIN R,LV=(0),A=(1)
*   RESPECIFY                                                      0205
*    (REG0,                                                        0205
*     REG1) UNRESTRICTED;           /* UNRESTRICT REGISTERS Y02006   */
*   MAPSW=SWTCHOFF;                 /* INDICATE DUMPMAP COMPLETE   0206
*                                      Y02006                        */
         NI    MAPSW,B'01111111'                                   0206
*   RETURN;                         /* RETURN TO AMDPRRDC            */
@EL00001 L     @13,4(,@13)                                         0207
@EF00001 DS    0H                                                  0207
@ER00001 LM    @14,@12,12(@13)                                     0207
         BR    @14                                                 0207
*                                                                  0208
*/********************************************************************/
*/*                                                                  */
*/*           THIS CODE IS ENTERED IF A SUCCESSFUL READ              */
*/*           HAS BEEN COMPLETED.                                    */
*/*           THE LENGTH OF THE RECORD IS CHECKED TO                 */
*/*           SEE IF IT IS A PREFORMATTED RECORD, IN                 */
*/*           WHICH CASE THE PREFMT ROUTINE IS PASSED                */
*/*           CONTROL.  IF THE RECORD IS NOT A                       */
*/*           PREFORMATTED RECORD, BUT THE PREFMT                    */
*/*           SWITCH IS SET, INDICATING PREVIOUS                     */
*/*           PREFORMATTED RECORDS HAVE BEEN FOUND,                  */
*/*           THEN CONTROL IS PASSED TO THE ERROR                    */
*/*           ROUTINE.                                               */
*/*           IF NONE OF THE ABOVE IS TRUE, THE                      */
*/*           RECORD IS CHECKED TO SEE IF IT IS A                    */
*/*           HEADER RECORD, IN WHICH CASE THE                       */
*/*           CONSTRUCTION OF A MAP BEGINS. IF IT                    */
*/*           IS NOT A HEADER RECORD, IT IS ASSUMED                  */
*/*           TO BE A DATA RECORD OR CPU STATUS RECORD.              */
*/*                                                                  */
*/********************************************************************/
*                                                                  0208
*MAPZERO:                                                          0208
*   MAPERROR=0;                     /* RESET I/O ERROR COUNT Y02006  */
MAPZERO  SLR   @04,@04                                             0208
         STH   @04,MAPERROR                                        0208
*   IF(BUFFSIZE-IOBCSWCT)<=133 THEN /* PREFORMATTED RECORD Y02006    */
         L     @01,DCBIOBA                                         0209
         LH    @15,IOBCSWCT+22(,@01)                               0209
         LH    @14,@CH00038                                        0209
         SLR   @14,@15                                             0209
         CH    @14,@CH00208                                        0209
         BNH   @RT00209                                            0209
*     GO TO PREFMT;                 /* YES - PROCESS IT              */
*   IF PREFMTSW=SWITCHON THEN       /* IS PREFORMAT SWITCH ON Y02006 */
         TM    PREFMTSW,B'00010000'                                0211
         BO    @RT00211                                            0211
*     GO TO ERREXT;                 /* YES - ERROR (MIXED RECORDS)   */
*   IF IOBCSWCT^=0 THEN             /* SHORT BLOCK Y02006            */
         CR    @15,@04                                             0213
         BE    @RF00213                                            0213
*     DO;                           /* YES                           */
*       POSTIPL=POSTIPL+1;          /* INCREMENT POST IPL COUNT    0215
*                                      Y02006                        */
         LH    @08,POSTIPL                                         0215
         LA    @08,1(,@08)                                         0215
         STH   @08,POSTIPL                                         0215
*       SVCTTR=0;                   /* INDICATE INVALID SVC BUFFER 0216
*                                      (JUST IN CASE) Y02006         */
         ST    @04,SVCTTR                                          0216
*       CURADDR=INITADDR;           /* REINITIALIZE LAST ADDRESS   0217
*                                      Y02006                        */
         MVC   CURADDR(4),@CB00069                                 0217
*       GO TO MAPREAD;              /* YES, IGNORE THE RECORD        */
         B     MAPREAD                                             0218
*     END;                                                         0219
*   IF PRDHDRID^=PRDHDR×PRDRECID^=PRDHDREC THEN/* IS THIS A HEADER 0220
*                                      RECORD Y02006                 */
@RF00213 SLR   @04,@04                                             0220
         ICM   @04,7,PRDINPTR(PARMPTR)                             0220
         CLI   PRDHDRID(@04),X'FF'                                 0220
         BNE   @RT00220                                            0220
         CLI   PRDRECID(@04),X'FF'                                 0220
         BNE   @RT00220                                            0220
*     GO TO NOTHEADR;               /* NO - PROCESS DUMP DATA RECORD */
*                                                                  0222
*/********************************************************************/
*/*                                                                  */
*/*           A HEADER RECORD HAS BEEN FOUND. IF THIS IS THE         */
*/*           FIRST HEADER, THE TYPE OF HEADER IS DETERMINED         */
*/*           AND THE CORRESPONDING FIELDS IN COMMON ARE             */
*/*           FILLED IN.  IF A HEADER RECORD HAS PREVIOUSLY BEEN     */
*/*           FOUND, CONTROL IS PASSED TO THE END OF FILE ROUTINE    */
*/*           TO PROCESS THE DUMP UP TO THIS POINT.                  */
*/*                                                                  */
*/********************************************************************/
*                                                                  0222
*HEADER:                                                           0222
*   IF HDRSW=SWITCHON THEN          /* IS THIS A SECOND HEADER Y02006*/
HEADER   TM    HDRSW,B'01000000'                                   0222
         BO    @RT00222                                            0222
*     GO TO EOF;                    /* YES--USE DUMP INFORMATION UP
*                                      TO SECOND HEADER Y02006       */
*   HDRSW=SWITCHON;                 /* TURN ON HEADER FOUND SWITCH 0224
*                                      Y02006                        */
         OI    HDRSW,B'01000000'                                   0224
*   DMPIC=SWITCHON;                 /* INDICATE ALL OF DUMP HAS BEEN
*                                      READ INTO THE BUFFERS (RESET
*                                      WHEN THIS IS NOT TRUE) Y02006 */
         OI    DMPIC(COMPTR),B'00010000'                           0225
*   POSITSW=SWTCHOFF;               /* SET DUMP DATA SET NOT EMPTY SW
*                                      Y02006                        */
         NI    POSITSW(COMPTR),B'11011111'                         0226
*   QASID=PRDASID;                  /* MOVE COMMON HEADER DATA TO  0227
*                                      COMMON Y02006                 */
         ICM   @04,7,PRDINPTR(PARMPTR)                             0227
         MVC   QASID(2,COMPTR),PRDASID(@04)                        0227
*   IF QASID=ALLFOX2 THEN           /* IS ASID FFFF IN HEADER Y02006 */
         CLC   QASID(2,COMPTR),@CB00053                            0228
         BNE   @RF00228                                            0228
*     QASID=0;                      /* YES-THEN CHANGE IT TO ZERO FOR
*                                      USE BY AMDPRRDC Y02006        */
         SLR   @04,@04                                             0229
         STH   @04,QASID(,COMPTR)                                  0229
*   TITLEMOD(8:15)=PRDMODNM;        /* MODULE NAME Y02006            */
@RF00228 SLR   @04,@04                                             0230
         ICM   @04,7,PRDINPTR(PARMPTR)                             0230
         MVC   TITLEMOD+7(8,COMPTR),PRDMODNM(@04)                  0230
*   TITLETME(6:13)=PRDTODVL;        /* TIME OF DAY Y02006            */
         MVC   TITLETME+5(8,COMPTR),PRDTODVL(@04)                  0231
*   HDRTITLE=PRDTITLE;              /* USER TITLE SUPPLIED AT DUMP 0232
*                                      TIME Y02006                   */
         MVC   HDRTITLE(100,COMPTR),PRDTITLE(@04)                  0232
*   IF PRDMODNM=SADMP THEN          /* IS THIS AMDSADMP INPUT Y02006 */
         CLC   PRDMODNM(8,@04),@CC00071                            0233
         BNE   @RF00233                                            0233
*     DO;                           /* YES                           */
*       SACSWCAW(1:8)=PRDCSW;       /* SAVE CSW FROM HEADER Y02006   */
         MVC   SACSWCAW(8,COMPTR),PRDCSW(@04)                      0235
*       SACSWCAW(9:12)=PRDCAW;      /* SAVE CAW FROM HEADER Y02006   */
         MVC   SACSWCAW+8(4,COMPTR),PRDCAW(@04)                    0236
*       QSADMP=SWITCHON;            /* SET SWITCH TO INDICATE      0237
*                                      AMDSADMP Y02006               */
         OI    QSADMP(COMPTR),B'00100000'                          0237
*       GO TO MAPREAD1;             /* GO READ NEXT RECORD Y02006    */
         B     MAPREAD1                                            0238
*     END;                                                         0239
*   ELSE                            /* UZ81700                       */
*     DO;                           /* LOOK FOR SVC DUMP UZ81700     */
@RF00233 DS    0H                                                  0241
*       Z9ERRID(1:10)=PRDERRID;     /* SAVE ERRORID UZ81700          */
         ICM   @04,7,PRDINPTR(PARMPTR)                             0241
         MVC   Z9ERRID(10,COMPTR),PRDERRID(@04)                    0241
*       IF Z9ERRID(1:10)='00000000000000000000'X THEN/* NO ERRID   0242
*                                      UZ81700                       */
         CLC   Z9ERRID(10,COMPTR),@CB00575                         0242
         BNE   @RF00242                                            0242
*         Z9ERRID(1:1)='FE'X;       /* INDICATE SO UZ81700           */
         MVI   Z9ERRID(COMPTR),X'FE'                               0243
*     END;                          /* UZ81700                       */
@RF00242 DS    0H                                                  0245
*   HDRREGS=PRDREGS;                /* MOVE ALL REGS (FL PT, GEN,  0245
*                                      CTL) AND CURRENT PSW Y02006   */
         SLR   @04,@04                                             0245
         ICM   @04,7,PRDINPTR(PARMPTR)                             0245
         MVC   HDRREGS(168,COMPTR),PRDREGS(@04)                    0245
*   IF SETCVTSW=SWTCHOFF THEN       /* HAS A CVT= CARD BEEN READ   0246
*                                      Y02006                        */
         TM    SETCVTSW(COMPTR),B'00000010'                        0246
         BNZ   @RF00246                                            0246
*     CVTADDR=PRDCVT;               /* NO--THEN SET CVT ADDR FROM  0247
*                                      HEADER Y02006                 */
         MVC   CVTADDR(4,COMPTR),PRDCVT(@04)                       0247
*   IF SVCTTR=0 THEN                /* IS THERE AN SVC BUFFER Y02006 */
@RF00246 ICM   @04,15,SVCTTR                                       0248
         BZ    @RT00248                                            0248
*     GO TO MAPREAD1;               /* READ NEXT RECORD Y02006       */
*   DO I=1 TO BUFFSIZE-255 BY 256;  /* MOVE 256 BYTES AT A TIME (PLS
*                                      REST RICTION) Y02006          */
         LA    I,1                                                 0250
@DL00250 DS    0H                                                  0251
*     PRDINPUT(I:I+255)=SVCBUF(I:I+255);/* MOVE DATA INTO BUFFER   0251
*                                      CONTAINING HEADER Y02006      */
         ICM   @06,7,PRDINPTR(PARMPTR)                             0251
         ALR   @06,I                                               0251
         BCTR  @06,0                                               0251
         L     @04,SVCBUFAD                                        0251
         ALR   @04,I                                               0251
         BCTR  @04,0                                               0251
         MVC   PRDINPUT(256,@06),SVCBUF(@04)                       0251
*   END;                                                           0252
         AH    I,@CH00391                                          0252
         CH    I,@CH00665                                          0252
         BNH   @DL00250                                            0252
*   IF BUFFSIZE//256^=0 THEN        /* MOVE REMAINDER IF NOT MULTIPLE
*                                      OF 256 Y02006                 */
*     PRDINPUT(BUFFSIZE+1-BUFFSIZE//256:BUFFSIZE)=SVCBUF(BUFFSIZE+1-
*         BUFFSIZE//256:BUFFSIZE);  /* MOVE DATA Y02006              */
         ICM   @04,7,PRDINPTR(PARMPTR)                             0254
         AL    @04,@CF00040                                        0254
         L     @01,SVCBUFAD                                        0254
         AL    @01,@CF00040                                        0254
         MVC   PRDINPUT(8,@04),SVCBUF(@01)                         0254
*   TTRNO=SVCTTR;                   /* ALSO RESET THE TTR TO THE SVC
*                                      BUFFER TTR Y02006             */
         MVC   TTRNO(4),SVCTTR                                     0255
*   CALL MAPBUILD;                  /* GO BUILD MAP FOR SVC BUFFER 0256
*                                      Y02006                        */
         BAL   @14,MAPBUILD                                        0256
*   IF BADREC=SWITCHON THEN         /* WAS RECORD PLACED INTO MAP  0257
*                                      Y02006                        */
         TM    BADREC,B'00000010'                                  0257
         BO    @RT00257                                            0257
*     GO TO MAPREAD1;               /* NO--READ INTO SAME BUFFER   0258
*                                      Y02006                        */
*   ELSE                                                           0259
*     GO TO MAPREAD;                /* CONTINUE TO BUILD MAP Y02006  */
         B     MAPREAD                                             0259
*                                                                  0260
*/********************************************************************/
*/*                                                                  */
*/*           THIS CODE IS ENTERED WHEN A DATA RECORD IS             */
*/*           FOUND.  IF A HEADER RECORD HAS NOT YET BEEN FOUND,     */
*/*           THE RECORD IS SAVED IN CASE IT IS THE SVC BUFFER       */
*/*           THEN CONTROL IS PASSED BACK TO MAPREAD TO              */
*/*           CONTINUE SCANNING THE INPUT DATA SET. IF A HEADER HAS  */
*/*           BEEN FOUND, THE DATA RECORD IS PLACED IN THE DUMP MAP. */
*/*                                                                  */
*/********************************************************************/
*                                                                  0260
*NOTHEADR:                                                         0260
*   IF HDRSW=SWITCHON THEN          /* HEADER RECORD FOUND YET Y02006*/
NOTHEADR TM    HDRSW,B'01000000'                                   0260
         BNO   @RF00260                                            0260
*     DO;                                                          0261
*       CALL MAPBUILD;              /* YES--GO BUILD MAP FOR THIS  0262
*                                      DATA RECORD OR CPU STATUS   0262
*                                      RECORD Y02006                 */
         BAL   @14,MAPBUILD                                        0262
*       IF BADREC=SWITCHON THEN     /* WAS RECORD PLACED INTO MAP  0263
*                                      Y02006                        */
         TM    BADREC,B'00000010'                                  0263
         BO    @RT00263                                            0263
*         GO TO MAPREAD1;           /* NO--READ INTO SAME BUFFER   0264
*                                      Y02006                        */
*       ELSE                                                       0265
*         GO TO MAPREAD;            /* CONTINUE READING Y02006       */
         B     MAPREAD                                             0265
*     END;                                                         0266
*   IF POSTIPL=5 THEN               /* HAVE 5 RECORDS BEEN READ    0267
*                                      WITHOUT FINDING A HEADER    0267
*                                      Y02006                        */
@RF00260 LH    @08,POSTIPL                                         0267
         CH    @08,@CH00255                                        0267
         BE    @RT00267                                            0267
*     GO TO EOF;                    /* YES--THEN GIVE UP, IT IS NOT A
*                                      NORMAL DUMP DATA SET Y02006   */
*   POSTIPL=POSTIPL+1;              /* INCREMENT POSTIPL COUNT Y02006*/
         LA    @04,1                                               0269
         ALR   @08,@04                                             0269
         STH   @08,POSTIPL                                         0269
*   DO I=1 TO BUFFSIZE-255 BY 256;  /* MOVE 256 BYTES AT A TIME (PLS
*                                      REST RICTION) Y02006          */
         LR    I,@04                                               0270
@DL00270 DS    0H                                                  0271
*     SVCBUF(I:I+255)=PRDINPUT(I:I+255);/* SAVE RECORD IN CASE ITS AN
*                                      SVC BUFFER Y02006             */
         L     @08,SVCBUFAD                                        0271
         ALR   @08,I                                               0271
         BCTR  @08,0                                               0271
         ICM   @06,7,PRDINPTR(PARMPTR)                             0271
         ALR   @06,I                                               0271
         BCTR  @06,0                                               0271
         MVC   SVCBUF(256,@08),PRDINPUT(@06)                       0271
*   END;                                                           0272
         AH    I,@CH00391                                          0272
         CH    I,@CH00665                                          0272
         BNH   @DL00270                                            0272
*   IF BUFFSIZE//256^=0 THEN        /* MOVE REMAINDER IF NOT MULTIPLE
*                                      OF 256 Y0 2006                */
*     SVCBUF(BUFFSIZE+1-BUFFSIZE//256:BUFFSIZE)=PRDINPUT(BUFFSIZE+1-
*         BUFFSIZE//256:BUFFSIZE);  /* MOVE DATA Y02006              */
         L     @08,SVCBUFAD                                        0274
         AL    @08,@CF00040                                        0274
         ICM   @04,7,PRDINPTR(PARMPTR)                             0274
         AL    @04,@CF00040                                        0274
         MVC   SVCBUF(8,@08),PRDINPUT(@04)                         0274
*   SVCTTR=TTRNO;                   /* ALSO SAVE THE TTR FOR THE SVC
*                                      BUFFER Y02006                 */
         MVC   SVCTTR(4),TTRNO                                     0275
*   GO TO MAPREAD;                  /* CONTINUE READING DUMP Y02006  */
         B     MAPREAD                                             0276
*                                                                  0277
*/********************************************************************/
*/*                                                                  */
*/*  MAP BUILD ROUTINE.  THIS ROUTINE PLACES THE ADDRESS AND TTR OF  */
*/* EACH RECORD INTO THE DUMP MAP.  THERE ARE UP TO 3 SETS OF        */
*/* DUMP MAPS.  'REALMAP' POINTS TO DUMP MAP ENTRIES FOR REAL        */
*/* DUMP INPUT, 'CPUMAP' POINTS TO DUMP MAP ENTRIES FOR CPU          */
*/* STATUS RECORDS.  FOR VIRTUAL DUMPS 'ASIDNDX' POINTS TO A         */
*/* TABLE OF ASID'S AND MAP POINTERS.  FOR EACH ASID DUMPED THERE    */
*/* EXISTS A SET OF DUMP MAP ENTRIES.                                */
*/* THIS ROUTINE BUILDS BOTH THE DUMP MAP ENTRIES AND THE ASID       */
*/* TABLES.  WHEN RECORD ADDRESSES ARE IN SEQUENCE THEN THE LAST     */
*/* MAP ENTRY IS JUST UPDATED.                                       */
*/*                                                                  */
*/********************************************************************/
*                                                                  0277
*MAPBUILD:                                                         0277
*   PROC OPTIONS(NOSAVEAREA,NOSAVE);                               0277
MAPBUILD DS    0H                                                  0278
*   RESPECIFY                                                      0278
*     REG14 RESTRICTED;             /* RESTRICT RETURN REG Y02006    */
*   TEMPSAVE=REG14;                 /* SAVE RETURN REG IN CASE     0279
*                                      ASIDSRCH IS CALLED Y02006     */
         ST    REG14,TEMPSAVE                                      0279
*   RESPECIFY                                                      0280
*     REG14 UNRESTRICTED;           /* UNRESTRICT RETURN REG Y02006  */
*   BADREC=SWTCHOFF;                /* RESET BAD RECORD SWITCH Y02006*/
         NI    BADREC,B'11111101'                                  0281
*   IF PRDHDRID=PRDHDR&PRDRECID=PRDCPUID THEN/* IS THS A CPU STATUS
*                                      RECORD Y02006                 */
         SLR   @04,@04                                             0282
         ICM   @04,7,PRDINPTR(PARMPTR)                             0282
         CLI   PRDHDRID(@04),X'FF'                                 0282
         BNE   @RF00282                                            0282
         CLI   PRDRECID(@04),X'0F'                                 0282
         BE    @RT00282                                            0282
*     GO TO CPUREC;                 /* YES--GO TO CPU ROUTINE Y02006 */
*   IF PRDADDR//DUMPBLK^=0 THEN     /* IS THE DATA ADDRESS A MULTIPLE
*                                      OF 4K Y0 2006                 */
@RF00282 ICM   @04,7,PRDINPTR(PARMPTR)                             0284
         L     @04,PRDADDR(,@04)                                   0284
         N     @04,@CF00677                                        0284
         LTR   @04,@04                                             0284
         BZ    @RF00284                                            0284
*     DO;                                                          0285
*       CURADDR=INITADDR;           /* NO--IGNORE THIS RECORD,     0286
*                                      REINITIALIZE LAST ADDRESS   0286
*                                      Y02006                        */
         MVC   CURADDR(4),@CB00069                                 0286
*       BADREC=SWITCHON;            /* INDICATE RECORD NOT PLACED IN
*                                      MAP Y02006                    */
         OI    BADREC,B'00000010'                                  0287
*       GO TO MAPRET;               /* RETURN TO CALLER              */
         B     MAPRET                                              0288
*     END;                                                         0289
*   IF PRDASID=CURASID&PRDADDR=CURADDR+DUMPBLK&(DUMPLINK=0×DUMPLINK->
*       DUMPFADD^=PRDADDR) THEN     /* IS THIS BLOCK IN THE SAME   0290
*                                      MEMORY, THE NEXT PAGE AFTER 0290
*                                      THE LAST BLOCK & NOT DUPLICATE
*                                                             YM00653*/
@RF00284 SLR   @04,@04                                             0290
         ICM   @04,7,PRDINPTR(PARMPTR)                             0290
         CLC   PRDASID(2,@04),CURASID                              0290
         BNE   @RF00290                                            0290
         L     @04,PRDADDR(,@04)                                   0290
         LH    @15,@CH00040                                        0290
         AL    @15,CURADDR                                         0290
         CLR   @04,@15                                             0290
         BNE   @RF00290                                            0290
         SLR   @15,@15                                             0290
         ICM   @15,7,DUMPLINK(MAPPTR)                              0290
         LTR   @15,@15                                             0290
         BZ    @RT00290                                            0290
         CL    @04,DUMPFADD(,@15)                                  0290
         BNE   @RT00290                                            0290
*     GO TO CHKVOLS;                /* YES--THEN GO CHECK IF THE   0291
*                                      VOLUME HAS CHANGED Y02006     */
*   IF PRDASID=CURASID THEN         /* WHILE THE ADDRESS IS NOT NEXT,
*                                      IS THE ASID STILL THE SAME  0292
*                                      Y02006                        */
@RF00290 SLR   @08,@08                                             0292
         ICM   @08,7,PRDINPTR(PARMPTR)                             0292
         CLC   PRDASID(2,@08),CURASID                              0292
         BE    @RT00292                                            0292
*     GO TO SCANMAP;                /* YES--THEN USE THE CURRENT MAP
*                                      AND GO SCAN IT Y02006         */
*   IF PRDASID=0 THEN               /* IS THIS A REAL DUMP RECORD  0294
*                                      Y02006                        */
         ICM   @10,3,PRDASID(@08)                                  0294
         BNZ   @RF00294                                            0294
*     DO;                                                          0295
*       CURMAP=REALMAP;             /* YES--THEN POINT TO THE REAL 0296
*                                      MAP Y02006                    */
         L     CURMAP,REALMAP(,COMPTR)                             0296
*       LASTMAP=ADDR(REALMAP);      /* ALSO SET UP THE LINK POINTER
*                                      (THIS IS USED IF THE NEW MAP
*                                      ENTRY GOES FIRST Y02006       */
         LA    LASTMAP,REALMAP(,COMPTR)                            0297
*       GO TO SCANMAP;              /* NOW GO SCAN THE REAL MAP    0298
*                                      Y02006                        */
         B     SCANMAP                                             0298
*     END;                                                         0299
*   IF ASIDNDX=0 THEN               /* IS THERE AN ASID INDEX YET  0300
*                                      Y02006                        */
@RF00294 ICM   @10,15,ASIDNDX(COMPTR)                              0300
         BNZ   @RF00300                                            0300
*     DO;                                                          0301
*       RESPECIFY                                                  0302
*        (REG0,                                                    0302
*         REG4) RESTRICTED;         /* RESTRICT REGISTERS Y02006     */
*       REG4=ADDR(INDXADDR);        /* NO--SO SET UP TO GET FIRST ONE
*                                      Y02006                        */
         LA    REG4,INDXADDR                                       0303
*       REG0=LENGTH(ASIDLIST);      /* SET LENGTH FOR GETMAIN Y02006 */
         LA    REG0,112                                            0304
*       GEN(GETMAIN EU,LV=(0),A=(R4));/* ISSUE GETMAIN FOR FIRST ASID
*                                      INDEX Y02006                  */
         GETMAIN EU,LV=(0),A=(R4)
*       RESPECIFY                                                  0306
*        (REG0,                                                    0306
*         REG4) UNRESTRICTED;       /* UNRESTRICT REGISTERS Y02006   */
*       ASIDNDX=INDXADDR;           /* SET POINTER IN COMMON TO ASID
*                                      INDEX Y02006                  */
         L     @10,INDXADDR                                        0307
         ST    @10,ASIDNDX(,COMPTR)                                0307
*       ASIDLIST=ASIDLIST&&ASIDLIST;/* SET NEW INDEX TO ZERO Y02006  */
         XC    ASIDLIST(112,@10),ASIDLIST(@10)                     0308
*       INDEX=1;                    /* SET INDEX TO ONE FOR FIRST NEW
*                                      ENTRY Y02006                  */
         LA    INDEX,1                                             0309
*       GO TO INSERT;               /* GO INSERT THE NEW ASID INTO 0310
*                                      THE INDEX Y02006              */
         B     INSERT                                              0310
*     END;                                                         0311
*   REQASID=PRDASID;                /* SET ASID FOR ASIDSRCH       0312
*                                      SUBROUTINE Y02006             */
@RF00300 ICM   @10,7,PRDINPTR(PARMPTR)                             0312
         MVC   REQASID(2),PRDASID(@10)                             0312
*   CALL ASIDSRCH;                  /* SEARCH ASIDLIST FOR NEW ASID
*                                      Y02006                        */
         BAL   @14,ASIDSRCH                                        0313
*   IF INDEX=0 THEN                 /* ARE ALL TABLES FULL AND NEW 0314
*                                      ASID NOT FOUND Y02006         */
         LTR   INDEX,INDEX                                         0314
         BNZ   @RF00314                                            0314
*     DO;                                                          0315
*       RESPECIFY                                                  0316
*        (REG0,                                                    0316
*         REG4) RESTRICTED;         /* RESTRICT REGISTERS Y02006     */
*       REG4=ADDR(ASDXLNK);         /* YES--NEED TO GET STORAGE FOR
*                                      NEW TABLE Y02006              */
         L     REG4,INDXADDR                                       0317
*       REG0=LENGTH(ASIDLIST);      /* GET LENGTH FOR TABLE Y02006   */
         LA    REG0,112                                            0318
*       GENERATE(GETMAIN EU,LV=(0),A=(R4));/* GET STORAGE FOR TABLE
*                                      Y02006                        */
         GETMAIN EU,LV=(0),A=(R4)
*       RESPECIFY                                                  0320
*        (REG0,                                                    0320
*         REG4) UNRESTRICTED;       /* UNRESTRICT REGISTERS Y02006   */
*       INDXADDR=ASDXLNK;           /* SET PTR TO NEW TABLE Y02006   */
         L     @10,INDXADDR                                        0321
         L     @10,ASDXLNK(,@10)                                   0321
         ST    @10,INDXADDR                                        0321
*       ASIDLIST=ASIDLIST&&ASIDLIST;/* ZERO OUT NEW TABLE      Y02006*/
         XC    ASIDLIST(112,@10),ASIDLIST(@10)                     0322
*       INDEX=1;                    /* SET INDEX TO FIRST ENTRY    0323
*                                      Y02006                        */
         LA    INDEX,1                                             0323
*       GO TO INSERT;               /* GO INSERT NEW ASID INTO TABLE
*                                      Y02006                        */
         B     INSERT                                              0324
*     END;                                                         0325
*   IF ASDXASID(INDEX)=PRDASID THEN /* CHECK TO VERIFY ASID WAS FOUND
*                                      IN TABLE Y02006               */
@RF00314 L     @10,INDXADDR                                        0326
         LR    @06,INDEX                                           0326
         ALR   @06,@06                                             0326
         ICM   @04,7,PRDINPTR(PARMPTR)                             0326
         ALR   @06,@10                                             0326
         CLC   ASDXASID-2(2,@06),PRDASID(@04)                      0326
         BNE   @RF00326                                            0326
*     DO;                                                          0327
*       CURMAP=ASDXMAP(INDEX);      /* YES--SET PTR TO MAPS FOR    0328
*                                      EXISTING ASID Y02006          */
         L     @08,INDXADDR                                        0328
         LR    @06,INDEX                                           0328
         SLA   @06,2                                               0328
         L     CURMAP,ASDXMAP-4(@06,@08)                           0328
*       LASTMAP=ADDR(ASDXMAP(INDEX));/* ALSO SET PTR TO LOCATION   0329
*                                      POINTING TO MAP Y02006        */
         LA    LASTMAP,ASDXMAP-4(@06,@08)                          0329
*       GO TO SCANMAP;              /* NOW GO SCAN MAP Y02006        */
         B     SCANMAP                                             0330
*     END;                                                         0331
*INSERT:                                                           0332
*   ASDXASID(INDEX)=PRDASID;        /* INSERT NEW ASID INTO TABLE  0332
*                                      Y02006                        */
@RF00326 DS    0H                                                  0332
INSERT   L     @08,INDXADDR                                        0332
         LR    @06,INDEX                                           0332
         ALR   @06,@06                                             0332
         ALR   @06,@08                                             0332
         ICM   @04,7,PRDINPTR(PARMPTR)                             0332
         MVC   ASDXASID-2(2,@06),PRDASID(@04)                      0332
*   CURMAP=ASDXMAP(INDEX);          /* SET CURRENT MAP POINTER TO NEW
*                                      MAP Y02006                    */
         LR    @06,INDEX                                           0333
         SLA   @06,2                                               0333
         L     CURMAP,ASDXMAP-4(@06,@08)                           0333
*   LASTMAP=ADDR(ASDXMAP(INDEX));   /* ALSO SET POINTER TO ADDRESS OF
*                                      MAP Y02006                    */
         LA    LASTMAP,ASDXMAP-4(@06,@08)                          0334
*/********************************************************************/
*/*                                                                  */
*/* THIS SECTION SCANS THE MAP POINTED TO BY 'CURMAP' FOR THE        */
*/* LOCATION TO PLACE THE NEW MAP ENTRY.                             */
*/*                                                                  */
*/********************************************************************/
*                                                                  0335
*SCANMAP:                                                          0335
*   MAPPTR=CURMAP;                  /* SET POINTER TO CURRENT MAP  0335
*                                      ENTRY Y02006                  */
SCANMAP  LR    MAPPTR,CURMAP                                       0335
*   LASTENTY=LASTMAP;               /* SAVE PTR TO LAST ENTRY IN CASE
*                                      THE NEW ENTRY GOES FIRST    0336
*                                      Y02006                        */
         LR    LASTENTY,LASTMAP                                    0336
*   DO WHILE MAPPTR^=0;             /* LOOP UNTIL PROPER ENTRY IS  0337
*                                      FOUND OR LAST ENTRY IS CHECKED
*                                      Y02006                        */
         B     @DE00337                                            0337
@DL00337 DS    0H                                                  0338
*     IF DUMPLADD<PRDADDR THEN      /* IS ADDRESS IN THIS MAP ENTRY
*                                      Y02006                        */
         ICM   @08,7,PRDINPTR(PARMPTR)                             0338
         CLC   DUMPLADD(4,MAPPTR),PRDADDR(@08)                     0338
         BNL   @RF00338                                            0338
*       DO;                                                        0339
*         LASTENTY=MAPPTR;          /* NO--SAVE PTR TO THIS ENTRY  0340
*                                      Y02006                        */
         LR    LASTENTY,MAPPTR                                     0340
*         MAPPTR=DUMPLINK;          /* AND SET PTR TO NEXT MAP ENTRY
*                                      Y02006                        */
         SLR   @08,@08                                             0341
         ICM   @08,7,DUMPLINK(MAPPTR)                              0341
         LR    MAPPTR,@08                                          0341
*       END;                                                       0342
*     ELSE                                                         0343
*       IF DUMPFADD>PRDADDR THEN    /* ITS BEFORE THIS ENTRY, BE SURE
*                                      ITS NOT IN THIS ENTRY Y02006  */
         B     @RC00338                                            0343
@RF00338 ICM   @08,7,PRDINPTR(PARMPTR)                             0343
         CLC   DUMPFADD(4,MAPPTR),PRDADDR(@08)                     0343
         BH    @RT00343                                            0343
*         GO TO SETDATA;            /* GO PUT DATA IN NEW MAP ENTRY
*                                      Y02006                        */
*       ELSE                                                       0345
*         DO;                       /* THIS RECORD IS A            0345
*                                      DUPLICATE--IGNORE IT Y02006   */
*           CURADDR=INITADDR;       /* REINITIALIZE ADDRESS Y02006   */
         MVC   CURADDR(4),@CB00069                                 0346
*           GO TO MAPRET;           /* RETURN IGNORING DUPLICATE   0347
*                                      Y02006                        */
         B     MAPRET                                              0347
*         END;                                                     0348
*   END;                                                           0349
@RC00338 DS    0H                                                  0349
@DE00337 LTR   MAPPTR,MAPPTR                                       0349
         BNZ   @DL00337                                            0349
*   GO TO SETDATA;                  /* NOW GO SET DATA INTO NEW ENTRY
*                                      Y02006                        */
         B     SETDATA                                             0350
*/********************************************************************/
*/*                                                                  */
*/* THE DATA RECORD OR CPU STATUS RECORD IS IN PROPER SEQUENCE.      */
*/* THIS SECTION CHECKS TO VERIFY THAT A VOLUME SWITCH HAS NOT       */
*/* OCCURED.  IF IT HAS, A NEW ENTRY IS INSERTED AT THE POINT OF THE */
*/* CURRENT MAP.                                                     */
*/*                                                                  */
*/********************************************************************/
*                                                                  0351
*CHKVOLS:                                                          0351
*   IF CURVOL=LASTVOL THEN          /* HAS A VOLUME SWITCH OCCURRED
*                                      Y02006                        */
CHKVOLS  CH    LASTVOL,CURVOL                                      0351
         BE    @RT00351                                            0351
*     GO TO SAVELAST;               /* NO--THEN GO UPDATE LAST     0352
*                                      ADDRESS IN CURRENT ENTRY Y020
*                                      06                            */
*   RESPECIFY                                                      0353
*    (REG0,                                                        0353
*     REG4) RESTRICTED;             /* RESTRICT REGISTERS Y02006     */
*   REG4=ADDR(NEWENTRY);            /* VOLUME SWITCHED SO NEED NEW 0354
*                                      MAP ENTRY Y02006              */
         LA    REG4,NEWENTRY                                       0354
*   REG0=DUMPFRMS;                  /* SET SIZE OF ENTRY Y02006      */
         LA    REG0,16                                             0355
*   GENERATE(GETMAIN EU,LV=(0),A=(R4));/* GET STORAGE FOR NEW ENTRY
*                                      Y02006                        */
         GETMAIN EU,LV=(0),A=(R4)
*   RESPECIFY                                                      0357
*    (REG0,                                                        0357
*     REG4) UNRESTRICTED;           /* UNRESTRICT REGISTERS Y02006   */
*   NEWENTRY->DUMPLINK=DUMPLINK;    /* SET LINK FIELD OF NEWENTRY TO
*                                      LINK OF LAST ENTRY Y02006     */
         L     @08,NEWENTRY                                        0358
         MVC   DUMPLINK(3,@08),DUMPLINK(MAPPTR)                    0358
*   DUMPLINK=NEWENTRY;              /* SET LINK FIELD OF LAST ENTRY
*                                      TO NEW ENTRY Y02006           */
         STCM  @08,7,DUMPLINK(MAPPTR)                              0359
*   GO TO SETDATA1;                 /* PUT DATA IN NEW ENTRY  YM00656*/
         B     SETDATA1                                            0360
*/********************************************************************/
*/*                                                                  */
*/* THIS SECTION INSERTS DATA INTO THE NEW DUMP MAP ENTRIES.         */
*/*                                                                  */
*/********************************************************************/
*                                                                  0361
*SETDATA:                                                          0361
*   RESPECIFY                                                      0361
*    (REG0,                                                        0361
*     REG4) RESTRICTED;             /* RESTRICT REGISTERS     YM00656*/
SETDATA  DS    0H                                                  0362
*   REG4=ADDR(NEWENTRY);            /* SET RETURN FOR ADDRESS OF NEW
*                                      DUMP MAP BLOCK         YM00656*/
         LA    REG4,NEWENTRY                                       0362
*   REG0=DUMPFRMS;                  /* SET SIZE FOR A NEW BLOCK    0363
*                                                             YM00656*/
         LA    REG0,16                                             0363
*   GEN(GETMAIN EU,LV=(0),A=(R4));  /* ISSUE GETMAIN FOR A NEW DUMP
*                                      MAP BLOCK              YM00656*/
         GETMAIN EU,LV=(0),A=(R4)
*   RESPECIFY                                                      0365
*    (REG0,                                                        0365
*     REG4) UNRESTRICTED;           /* UNRESTRICT REGISTERS   YM00656*/
*   LASTENTY->DUMPLINK=NEWENTRY;    /* INSERT NEW MAP ENTRY AT END OF
*                                      CHAIN                  YM00656*/
         L     @08,NEWENTRY                                        0366
         STCM  @08,7,DUMPLINK(LASTENTY)                            0366
*   NEWENTRY->DUMPLINK=MAPPTR;      /* SET LINK FIELD TO NULL YM00656*/
         STCM  MAPPTR,7,DUMPLINK(@08)                              0367
*   IF LASTENTY=LASTMAP THEN        /* IS THIS ALSO THE FIRST (ONLY)
*                                      ENTRY ON CHAIN         YM00656*/
         CR    LASTENTY,LASTMAP                                    0368
         BNE   @RF00368                                            0368
*     CURMAP=NEWENTRY;              /* YES--THEN ALSO UPDATE CURRENT
*                                      PTR ENTRY              YM00656*/
         LR    CURMAP,@08                                          0369
*SETDATA1:                                                         0370
*   MAPPTR=NEWENTRY;                /* SET POINTER TO NEW ENTRY    0370
*                                      Y02006                        */
@RF00368 DS    0H                                                  0370
SETDATA1 L     MAPPTR,NEWENTRY                                     0370
*   DUMPVOLN=CURVOL;                /* SET VOLUME NUMBER INTO ENTRY
*                                      Y02006                        */
         MVC   DUMPVOLN(1,MAPPTR),CURVOL+1                         0371
*   IF TREADIN=SWITCHON THEN        /* SET DUMPDEV TO TREADIN Y02006 */
         TM    TREADIN(COMPTR),B'00010000'                         0372
         BNO   @RF00372                                            0372
*     DUMPDEV=SWITCHON;                                            0373
         OI    DUMPDEV(MAPPTR),B'10000000'                         0373
*   ELSE                                                           0374
*     DUMPDEV=SWTCHOFF;                                            0374
         B     @RC00372                                            0374
@RF00372 NI    DUMPDEV(MAPPTR),B'01111111'                         0374
*   DUMPFADD=PRDADDR;               /* SET BEGINNING ADDRESS INTO  0375
*                                      ENTRY Y02006                  */
@RC00372 ICM   @08,7,PRDINPTR(PARMPTR)                             0375
         MVC   DUMPFADD(4,MAPPTR),PRDADDR(@08)                     0375
*   DUMPTTR=TTRNO;                  /* AND SET TTR (OR BLOCK NUMBER)
*                                      INTO ENTRY Y02006             */
         MVC   DUMPTTR(4,MAPPTR),TTRNO                             0376
*SAVELAST:                                                         0377
*   CURADDR=PRDADDR;                /* SAVE CURRENT ADDRESS Y02006   */
SAVELAST SLR   @08,@08                                             0377
         ICM   @08,7,PRDINPTR(PARMPTR)                             0377
         MVC   CURADDR(4),PRDADDR(@08)                             0377
*   IF PRDHDRID^=PRDHDR THEN        /* IS THIS A CPU STATUS RECORD 0378
*                                      Y02006                        */
         CLI   PRDHDRID(@08),X'FF'                                 0378
         BE    @RF00378                                            0378
*     CURASID=PRDASID;              /* NO--THEN SAVE ASID Y02006     */
         MVC   CURASID(2),PRDASID(@08)                             0379
*   DUMPLADD=CURADDR;               /* SET ENDING ADDRESS INTO ENTRY
*                                      Y02006                        */
@RF00378 L     @08,CURADDR                                         0380
         ST    @08,DUMPLADD(,MAPPTR)                               0380
*   IF PRDHDRID^=PRDHDR THEN        /* AGAIN IS THIS A CPU STATUS  0381
*                                      RECORD Y02006                 */
         ICM   @04,7,PRDINPTR(PARMPTR)                             0381
         CLI   PRDHDRID(@04),X'FF'                                 0381
         BE    @RF00381                                            0381
*     IF CURASID=0 THEN             /* NO--IS IT A REAL DUMP RECORD
*                                      Y02006                        */
         ICM   @04,3,CURASID                                       0382
         BNZ   @RF00382                                            0382
*       BUFFREAL=CURADDR;           /* YES-- UPDATE REAL ADDRESS IN
*                                      BUFFER AMP ENTRY Y020006      */
         ST    @08,BUFFREAL(,PARMPTR)                              0383
*     ELSE                                                         0384
*       DO;                                                        0384
         B     @RC00382                                            0384
@RF00382 DS    0H                                                  0385
*         BUFFVIRT=CURADDR;         /* NO--UPDATE VIRTUAL ADDRESS IN
*                                      BUFFER MAP ENTRY Y02006       */
         MVC   BUFFVIRT(4,PARMPTR),CURADDR                         0385
*         IF CURASID=ALLFOX2 THEN   /* IS ASID FOR COMMON DATA Y02006*/
         CLC   CURASID(2),@CB00053                                 0386
         BNE   @RF00386                                            0386
*           DO;                                                    0387
*             BUFFASID=0;           /* YES--SET ASID TO ZERO FOR   0388
*                                      AMDPRRDC Y02006               */
         SLR   @08,@08                                             0388
         STH   @08,BUFFASID(,PARMPTR)                              0388
*             BUFFCOM=SWITCHON;     /* SET FLAG TO INDICATE DATA FROM
*                                      COMMON Y02006                 */
         OI    BUFFCOM(PARMPTR),B'01000000'                        0389
*           END;                                                   0390
*         ELSE                                                     0391
*           BUFFASID=CURASID;       /* NO--PUT ASID INTO BUFFER AS IS
*                                      Y02006                        */
         B     @RC00386                                            0391
@RF00386 MVC   BUFFASID(2,PARMPTR),CURASID                         0391
*       END;                                                       0392
*   ELSE                                                           0393
*     BUFFCPU=PRDCPUAD;             /* ITS A CPU STATUS RECORD SO  0393
*                                      UPDATE CPU ADDRES S IN BUFFER
*                                      MAP ENTRY Y02006              */
         B     @RC00381                                            0393
@RF00381 ICM   @08,7,PRDINPTR(PARMPTR)                             0393
         MVC   BUFFCPU(2,PARMPTR),PRDCPUAD(@08)                    0393
*MAPRET:                                                           0394
*   RESPECIFY                                                      0394
*     REG14 RESTRICTED;             /* RESTRICT RETURN REG Y02006    */
@RC00381 DS    0H                                                  0394
MAPRET   DS    0H                                                  0395
*   REG14=TEMPSAVE;                 /* RESTORE RETURN REG Y02006     */
         L     REG14,TEMPSAVE                                      0395
*   RESPECIFY                                                      0396
*     REG14 UNRESTRICTED;           /* UNRESTRICT RETURN REG Y02006  */
*   RETURN;                         /* RETURN WITH MAP BUILT Y02006  */
@EL00003 DS    0H                                                  0397
@EF00003 DS    0H                                                  0397
@ER00003 BR    @14                                                 0397
*/********************************************************************/
*/*                                                                  */
*/* THIS SECTION OBTAINS NEW MAP ENTRIES FOR CPU STATUS RECORDS      */
*/* IF THE RECORDS ARE NOT IN CPU ADDRESS SEQUENCE.                  */
*/*                                                                  */
*/********************************************************************/
*                                                                  0398
*CPUREC:                                                           0398
*   IF PRDADDR>MAXCPUAD THEN        /* IS CPU ADDR VALID Y02006      */
CPUREC   ICM   @04,7,PRDINPTR(PARMPTR)                             0398
         CLC   PRDADDR(4,@04),@CB00055                             0398
         BNH   @RF00398                                            0398
*     DO;                                                          0399
*       CURADDR=INITADDR;           /* REINITIALIZE CURRENT ADDRESS
*                                      Y02006                        */
         MVC   CURADDR(4),@CB00069                                 0400
*       BADREC=SWITCHON;            /* INDICATE RECORD NOT PLACED  0401
*                                      INTO MAP Y02006               */
         OI    BADREC,B'00000010'                                  0401
*       GO TO MAPRET;               /* RETURN TO CALLER Y02006       */
         B     MAPRET                                              0402
*     END;                                                         0403
*   IF PRDADDR=CURADDR+1 THEN       /* IS CPU ADDRESS IN SEQUENCE  0404
*                                      Y02006                        */
@RF00398 ICM   @04,7,PRDINPTR(PARMPTR)                             0404
         LA    @15,1                                               0404
         AL    @15,CURADDR                                         0404
         CL    @15,PRDADDR(,@04)                                   0404
         BE    @RT00404                                            0404
*     GO TO CHKVOLS;                /* YES--GO CHECK FOR VOLUME    0405
*                                      SWITCH Y02006                 */
*   RESPECIFY                                                      0406
*    (REG0,                                                        0406
*     REG4) RESTRICTED;             /* RESTRICT REGISTERS Y02006     */
*   REG4=ADDR(NEWENTRY);            /* NOT IN SEQUENCE, GET STORAGE
*                                      FOR NEW ENTRY Y02 0006        */
         LA    REG4,NEWENTRY                                       0407
*   REG0=DUMPFRMS;                  /* SET SIZE OF NEW ENTRY Y02006  */
         LA    REG0,16                                             0408
*   GENERATE(GETMAIN EU,LV=(0),A=(R4));/* GET STORAGE FOR NEW ENTRY
*                                      Y02006                        */
         GETMAIN EU,LV=(0),A=(R4)
*   RESPECIFY                                                      0410
*    (REG0,                                                        0410
*     REG4) UNRESTRICTED;           /* UNRESTRICT REGISTERS Y02006   */
*   IF CPUMAP=0 THEN                /* IS THIS FIRST CPU STATUS    0411
*                                      RECORD Y02006                 */
         ICM   @10,15,CPUMAP(COMPTR)                               0411
         BNZ   @RF00411                                            0411
*     DO;                                                          0412
*       IF IOERR=SWITCHON THEN      /* WAS LAST RECORD IN ERROR    0413
*                                      Y02006                        */
         TM    IOERR(COMPTR),B'10000000'                           0413
         BNO   @RF00413                                            0413
*         IPLCPU=256;               /* INDICATE IPLED CPU STATUS   0414
*                                      UNAVAINLABLE Y02006           */
         MVC   IPLCPU(2,COMPTR),@CH00391                           0414
*       ELSE                                                       0415
*         IPLCPU=PRDCPUAD;          /* SAVE IPLED CPU ADDRESS Y02006 */
         B     @RC00413                                            0415
@RF00413 ICM   @10,7,PRDINPTR(PARMPTR)                             0415
         MVC   IPLCPU(2,COMPTR),PRDCPUAD(@10)                      0415
*     END;                                                         0416
@RC00413 DS    0H                                                  0417
*   CURMAP=CPUMAP;                  /* SET PTR TO CPU STATUS MAPS  0417
*                                      Y02006                        */
@RF00411 L     CURMAP,CPUMAP(,COMPTR)                              0417
*   LASTMAP=ADDR(CPUMAP);           /* ALSO SET PTR TO ADDR OF     0418
*                                      CURRENT MAP Y02006            */
         LA    LASTMAP,CPUMAP(,COMPTR)                             0418
*   GO TO SCANMAP;                  /* NOW GO SCAN MAP Y02006        */
         B     SCANMAP                                             0419
*   END MAPBUILD;                                                  0420
*                                                                  0421
*/********************************************************************/
*/********************************************************************/
*/*                                                                  */
*/*           READ REQUESTS - MAP BUILD COMPLETE                     */
*/*                                                                  */
*/********************************************************************/
*/********************************************************************/
*/*                                                                  */
*/*           DETERMINE TYPE OF READ REQUESTED.                      */
*/*                                                                  */
*/********************************************************************/
*                                                                  0421
*TYPEREAD:                                                         0421
*   IOERR=SWTCHOFF;                 /* RESET IOERR SWITCH Y02006     */
TYPEREAD NI    IOERR(COMPTR),B'01111111'                           0421
*   REQVOL=0;                       /* ZERO REQUESTED VOLUME         */
         MVI   REQVOL,X'00'                                        0422
*   TTRNO=0;                        /* SET TTR VALUE TO 0            */
         SLR   @10,@10                                             0423
         ST    @10,TTRNO                                           0423
*   IF BUFFVIRT^=ALLFOX THEN        /* VIRTUAL STORAGE READ REQUEST  */
         SLR   @10,@10                                             0424
         BCTR  @10,0                                               0424
         C     @10,BUFFVIRT(,PARMPTR)                              0424
         BNE   @RT00424                                            0424
*     GO TO VIRTPROC;               /* YES - FIND TTR FOR POINT      */
*   IF BUFFREAL^=ALLFOX THEN        /* REAL STORAGE READ REQUEST     */
         C     @10,BUFFREAL(,PARMPTR)                              0426
         BNE   @RT00426                                            0426
*     GO TO REALPROC;               /* YES - FIND TTR FOR POINT      */
*   GO TO CPUPROC;                  /* NO - CPU REQUEST TYPE         */
         B     CPUPROC                                             0428
*/********************************************************************/
*/*                                                                  */
*/*           THIS IS ENTERED AFTER FINDING THE REQUESTED            */
*/*           ADDRESS ON THE APPROPRIATE MAP.  THE POSITION          */
*/*           HAS BEEN COMPUTED AND THE RECORD CAN BE POINTED        */
*/*           TO AND READ. ANY VOLUME SWITCHING REQUIRED IS          */
*/*           PERFORMED. THE READ COUNT IS UPDATED.                  */
*/*                                                                  */
*/********************************************************************/
*                                                                  0429
*POINT:                                                            0429
*   IF VOLNO=BYTEOFF THEN           /* CURRENT VOLUME = 0            */
POINT    CLI   VOLNO(VOLADDR),X'00'                                0429
         BE    @RT00429                                            0429
*     GO TO VOLRESET;               /* YES - RESET VOLUMES           */
*   IF VOLNO=REQVOL THEN            /* REQUESTED VOLUME CURRENT      */
         CLC   VOLNO(1,VOLADDR),REQVOL                             0431
         BE    @RT00431                                            0431
*     GO TO POINT2;                 /* YES - CONTINUE PROCESSING     */
*   IF VOLNO>REQVOL THEN            /* REQ. VOL. LESS THAN CURRENT   */
         CLC   VOLNO(1,VOLADDR),REQVOL                             0433
         BNH   @RF00433                                            0433
*     DO;                           /* YES - RESET VOLUMES           */
*VOLRESET:                                                         0435
*       CALL DSOPEN;                /* CLOSE AND RE-OPEN D.S.        */
VOLRESET BAL   @14,DSOPEN                                          0435
*       IF REQVOL=VOLNO1 THEN       /* FIRST VOLUME REQUESTED        */
         CLI   REQVOL,1                                            0436
         BE    @RT00436                                            0436
*         GO TO POINT1;             /* YES - NO VOLUME SWITCHING     */
*       VOLNO=VOLNO1;               /* SET VOLUME TO 1 FOR DIFFERENCE*/
         MVI   VOLNO(VOLADDR),X'01'                                0438
*     END;                                                         0439
*   DO I=1 TO(REQVOL-VOLNO);        /* GET TO REQUESTED VOLUME       */
@RF00433 LA    I,1                                                 0440
         B     @DE00440                                            0440
@DL00440 DS    0H                                                  0441
*     GENERATE(FEOV (R3),REWIND);   /* FORCE EOV UNTIL REQUESTED VOL */
         FEOV (R3),REWIND
*   END;                                                           0442
         AH    I,@CH00042                                          0442
@DE00440 SLR   @10,@10                                             0442
         IC    @10,REQVOL                                          0442
         SLR   @06,@06                                             0442
         IC    @06,VOLNO(,VOLADDR)                                 0442
         SLR   @10,@06                                             0442
         CR    I,@10                                               0442
         BNH   @DL00440                                            0442
*POINT1:                                                           0443
*   VOLNO=REQVOL;                   /* MAKE REQUESTED VOLUME CURRENT */
POINT1   MVC   VOLNO(1,VOLADDR),REQVOL                             0443
*POINT2:                                                           0444
*   SYNADSW=SWTCHOFF;               /* TURN OFF SYNAD SWITCH         */
POINT2   NI    SYNADSW,B'11011111'                                 0444
*   GENERATE(POINT (R3),TTRNO);     /* POINT TO REQ. RECORD          */
         POINT (R3),TTRNO
*   RESPECIFY                                                      0446
*     REG0 RESTRICTED;              /* RESTRICT REGISTERS Y02006     */
*   REG0=BUFFPTR;                   /* ADDR OF INPUT BUFFER          */
         SLR   REG0,REG0                                           0447
         ICM   REG0,7,BUFFPTR(PARMPTR)                             0447
*   GENERATE;                                                      0448
         READ  RDDECB,SF,(R3),(R0),'S' READ REQUESTED RECORD
         CHECK RDDECB
*   RESPECIFY                                                      0449
*     REG0 UNRESTRICTED;            /* UNRESTRICT REGISTERS Y02006   */
*   READNO=READNO+1;                /* INCREMENT READ COUNT          */
         LA    @10,1                                               0450
         L     @08,READNO(,COMPTR)                                 0450
         ALR   @08,@10                                             0450
         ST    @08,READNO(,COMPTR)                                 0450
*   IF SYNADSW=SWTCHOFF THEN        /* SYNAD ENTERED                 */
         TM    SYNADSW,B'00100000'                                 0451
         BZ    @RT00451                                            0451
*     GO TO CHKREQ;                 /* NO - CONTINUE PROCESSING      */
*   RDERCNT=RDERCNT+1;              /* INCREMENT I/O ERROR COUNT     */
         AL    @10,RDERCNT(,COMPTR)                                0453
         ST    @10,RDERCNT(,COMPTR)                                0453
*   GO TO ERREXT;                   /* MARK BUFFER INVALID           */
         B     ERREXT                                              0454
*/********************************************************************/
*/*                                                                  */
*/* THE RECORD READ IS CHECKED TO VERIFY IT IS THE ONE REQUESTED.    */
*/* IF LOCATION 0 WAS READ FOR AMDSADMP INPUT, THE CAW AND CSW       */
*/* ARE UPDATED THEN CONTROL IS RETURNED TO AMDPRRDC.                */
*/*                                                                  */
*/********************************************************************/
*                                                                  0455
*CHKREQ:                                                           0455
*   IF IOBCSWCT^=0 THEN             /* SHORT RECORD READ             */
CHKREQ   SLR   @10,@10                                             0455
         L     @08,DCBIOBA                                         0455
         CH    @10,IOBCSWCT+22(,@08)                               0455
         BNE   @RT00455                                            0455
*     GO TO ERREXT;                 /* YES - MARK BUFFER INVALID     */
*   IF PRDADDR^=REQADDR THEN        /* READ REQUESTED ADDR           */
         SLR   @08,@08                                             0457
         ICM   @08,7,PRDINPTR(PARMPTR)                             0457
         CL    REQADDR,PRDADDR(,@08)                               0457
         BNE   @RT00457                                            0457
*     GO TO ERREXT;                 /* NO - MARK BUFFER INVALID      */
*   IF QSADMP=SWITCHON&BUFFREAL=0 THEN/* READ FOR LOCATION 0 WITH  0459
*                                      SADMP INPUT Y02006            */
         TM    QSADMP(COMPTR),B'00100000'                          0459
         BNO   @RF00459                                            0459
         C     @10,BUFFREAL(,PARMPTR)                              0459
         BNE   @RF00459                                            0459
*     PRDDATA(65:76)=SACSWCAW;      /* YES--THEN RESTORE CAW AND CSW
*                                      Y02006                        */
         MVC   PRDDATA+64(12,@08),SACSWCAW(COMPTR)                 0460
*   RETURN;                         /* RETURN TO AMDPRRDC            */
         B     @EL00001                                            0461
*                                                                  0462
*/********************************************************************/
*/*                                                                  */
*/*           ENTERED WHEN A REAL STORAGE ADDRESS IS REQUESTED.      */
*/*           WHEN THE ADDRESS IS FOUND, THE POSITION OF THE RECORD  */
*/*           WITHIN THE INPUT DATA SET IS COMPUTED AND CONTROL      */
*/*           PASSED TO POINT.                                       */
*/*                                                                  */
*/********************************************************************/
*                                                                  0462
*REALPROC:                                                         0462
*   REQADDR=BUFFREAL;               /* REQUESTED ADDRESS IS REAL     */
REALPROC L     REQADDR,BUFFREAL(,PARMPTR)                          0462
*   MAPPTR=REALMAP;                 /* POINT TO REAL DUMP MAP        */
         L     MAPPTR,REALMAP(,COMPTR)                             0463
*   CALL MAPSCAN;                   /* SEARCH FOR REQUESTED ADDRESS
*                                      Y020 06                       */
         BAL   @14,MAPSCAN                                         0464
*   IF NOTFOUND=SWITCHON THEN       /* WAS REQUESTED ADDRESS FOUND IN
*                                      MAPS Y02006                   */
         TM    NOTFOUND,B'00001000'                                0465
         BO    @RT00465                                            0465
*     GO TO ERREXT;                 /* NO--RETURN ERROR CONDITION  0466
*                                      Y02006                        */
*   GO TO CALCBLK;                  /* YES--GO CALCULATE BLOCK     0467
*                                      POSITION Y02006               */
         B     CALCBLK                                             0467
*/********************************************************************/
*/*                                                                  */
*/*           ENTERED WHEN A VIRTUAL STORAGE ADDRESS IS REQUESTED.   */
*/*           WHEN THE ADDRESS IS FOUND, THE POSITION OF THE RECORD  */
*/*           WITHIN THE INPUT DATA SET IS COMPUTED AND CONTROL      */
*/*           PASSED TO POINT.                                       */
*/*                                                                  */
*/********************************************************************/
*                                                                  0468
*VIRTPROC:                                                         0468
*   REQASID=BUFFASID;               /* SET REQUESTED ASID Y02006     */
VIRTPROC MVC   REQASID(2),BUFFASID(PARMPTR)                        0468
*   REQADDR=BUFFVIRT;               /* REQUESTED ADDRESS IS VIRTUAL  */
         L     REQADDR,BUFFVIRT(,PARMPTR)                          0469
*   IF ASIDNDX=0 THEN               /* ARE THERE ANY VIRTUAL MAPS  0470
*                                      Y02006                        */
         L     @10,ASIDNDX(,COMPTR)                                0470
         LTR   @10,@10                                             0470
         BZ    @RT00470                                            0470
*     GO TO ERREXT;                 /* NO--EXIT NOT FOUND Y02006     */
*   INDXADDR=ASIDNDX;               /* SET PTR TO ASID LIST Y02006   */
         ST    @10,INDXADDR                                        0472
*   CALL ASIDSRCH;                  /* SEARCH FOR REQUESTED ASID   0473
*                                      Y02006                        */
         BAL   @14,ASIDSRCH                                        0473
*   IF INDEX=0×ASDXASID(INDEX)=0 THEN/* WAS AN EMPTY SLOT FOUND    0474
*                                      INSTEAD Y02006                */
         SLR   @10,@10                                             0474
         CR    INDEX,@10                                           0474
         BE    @RT00474                                            0474
         L     @08,INDXADDR                                        0474
         LR    @06,INDEX                                           0474
         ALR   @06,@06                                             0474
         ALR   @06,@08                                             0474
         SLR   @04,@04                                             0474
         ICM   @04,3,ASDXASID-2(@06)                               0474
         CR    @10,@04                                             0474
         BE    @RT00474                                            0474
*     GO TO FFFFCHK;                /* YES--THEN GO CHECK FOR ASID 0475
*                                      FFFF Y02006                   */
*   MAPPTR=ASDXMAP(INDEX);          /* POINT TO VIRTUAL MAP Y02006   */
         LR    @10,INDEX                                           0476
         SLA   @10,2                                               0476
         L     MAPPTR,ASDXMAP-4(@10,@08)                           0476
*   CALL MAPSCAN;                   /* GO SCAN FOR REQUESTED ADDRESS
*                                      Y02006                        */
         BAL   @14,MAPSCAN                                         0477
*   IF NOTFOUND=SWTCHOFF THEN       /* WAS ADDRESS FOUND Y02006      */
         TM    NOTFOUND,B'00001000'                                0478
         BZ    @RT00478                                            0478
*     GO TO CALCBLK;                /* YES--GO CALCULATE BLOCK     0479
*                                      POSITION Y02006               */
*FFFFCHK:                                                          0480
*   REQASID=ALLFOX;                 /* TRY TO FIND COMMON ASID FFFF
*                                      Y02006                        */
FFFFCHK  MVC   REQASID(2),@CB00051                                 0480
*   INDXADDR=ASIDNDX;               /* RESET PTR TO BEGINNING OF   0481
*                                      TABLES Y02006                 */
         MVC   INDXADDR(4),ASIDNDX(COMPTR)                         0481
*   CALL ASIDSRCH;                  /* SEARCH FOR ASID FFFF Y02006   */
         BAL   @14,ASIDSRCH                                        0482
*   IF ASDXASID(INDEX)=0×INDEX=0 THEN/* WAS AN EMPTY SLOT FOUND    0483
*                                      INSTEAD Y02006                */
         SLR   @10,@10                                             0483
         L     @08,INDXADDR                                        0483
         LR    @06,INDEX                                           0483
         ALR   @06,@06                                             0483
         ALR   @06,@08                                             0483
         SLR   @04,@04                                             0483
         ICM   @04,3,ASDXASID-2(@06)                               0483
         CR    @10,@04                                             0483
         BE    @RT00483                                            0483
         CR    INDEX,@10                                           0483
         BE    @RT00483                                            0483
*     GO TO ERREXT;                 /* YES--THEN EXIT ERROR Y02006   */
*   MAPPTR=ASDXMAP(INDEX);          /* POINT TO VIRTUAL MAP Y02006   */
         LR    @10,INDEX                                           0485
         SLA   @10,2                                               0485
         L     MAPPTR,ASDXMAP-4(@10,@08)                           0485
*   CALL MAPSCAN;                   /* GO SCAN FOR REQUESTED ADDRESS
*                                      Y02006                        */
         BAL   @14,MAPSCAN                                         0486
*   IF NOTFOUND=SWITCHON THEN       /* WAS ADDRESS FOUND Y02006      */
         TM    NOTFOUND,B'00001000'                                0487
         BO    @RT00487                                            0487
*     GO TO ERREXT;                 /* NO--EXIT NOT FOUND Y02006     */
*   BUFFCOM=SWITCHON;               /* YES--INDICATE DATE FROM COMMON
*                                      ASID Y02006                   */
         OI    BUFFCOM(PARMPTR),B'01000000'                        0489
*   GO TO CALCBLK;                  /* GO CALCULATE BLOCK POSITION 0490
*                                      Y02006                        */
         B     CALCBLK                                             0490
*/********************************************************************/
*/*                                                                  */
*/* ENTERED WHEN A CPU STATUS RECORD IS REQUESTED.                   */
*/* WHEN THE CPU ADDRESS IS FOUND, THE POSITION OF THE RECORD        */
*/* WITHIN THE INPUT DATA SET IS COMPUTED AND CONTROL                */
*/* PASSED TO POINT.                                                 */
*/*                                                                  */
*/********************************************************************/
*                                                                  0491
*CPUPROC:                                                          0491
*   REQADDR=BUFFCPU;                /* SET REQUESTED CPU ADDRESS   0491
*                                      Y02006                        */
CPUPROC  LH    REQADDR,BUFFCPU(,PARMPTR)                           0491
*   MAPPTR=CPUMAP;                  /* SET PTR TO CPU MAP Y02006     */
         L     MAPPTR,CPUMAP(,COMPTR)                              0492
*   CALL MAPSCAN;                   /* SEARCH FOR REQUESTED ADDRESS
*                                      Y02006                        */
         BAL   @14,MAPSCAN                                         0493
*   IF NOTFOUND=SWITCHON THEN       /* WAS ADDRESS FOUND Y02006      */
         TM    NOTFOUND,B'00001000'                                0494
         BO    @RT00494                                            0494
*     GO TO ERREXT;                 /* NO--EXIT NOT FOUND Y02006     */
*   RELBLK=REQADDR-DUMPFADD;        /* COMPUTE RELATIVE BLOCK Y02006 */
         LR    RELBLK,REQADDR                                      0496
         SL    RELBLK,DUMPFADD(,MAPPTR)                            0496
*   GO TO DCBGET;                   /* GO GET DCB Y02006             */
         B     DCBGET                                              0497
*                                                                  0498
*/********************************************************************/
*/*                                                                  */
*/* THIS SECTION CALCULATES THE RELATIVE BLOCK FOR DATA RECORDS      */
*/* AND SETS UP THE POINTER TO THE PROPER DCB.                       */
*/*                                                                  */
*/********************************************************************/
*                                                                  0498
*CALCBLK:                           /* CALCULATE POSITION OF       0498
*                                      REQUESTED ADDRESS             */
*   RELBLK=(REQADDR-DUMPFADD)/DUMPBLK;/* COMPUTE RELATIVE BLOCK    0498
*                                      Y02006                        */
CALCBLK  LR    @00,REQADDR                                         0498
         SL    @00,DUMPFADD(,MAPPTR)                               0498
         SRDA  @00,32                                              0498
         D     @00,@CF00040                                        0498
         LR    RELBLK,@01                                          0498
*DCBGET:                                                           0499
*   CALL GETDCB;                    /* GET DCB ADDR AND REC/TRK VALUE*/
DCBGET   BAL   @14,GETDCB                                          0499
*   IF RECTRK=0 THEN                /* TAPE INPUT                    */
         ICM   @10,3,RECTRK                                        0500
         BZ    @RT00500                                            0500
*     GO TO TTRTAPE;                /* YES-COMPUTE TAPE BLOCK NUMBER */
*/********************************************************************/
*/*                                                                  */
*/*            COMPUTE TTR OF DESIRED RECORD ON DIRECT ACCESS.       */
*/*                                                                  */
*/********************************************************************/
*                                                                  0502
*TTRDA:                                                            0502
*   RELRECN=RELBLK-1+DUMPR;         /* COMPUTE RELATIVE RECORD NUMBER
*                                      Y02006                        */
TTRDA    LR    RELRECN,RELBLK                                      0502
         BCTR  RELRECN,0                                           0502
         SLR   @10,@10                                             0502
         IC    @10,DUMPR(,MAPPTR)                                  0502
         ALR   RELRECN,@10                                         0502
*   R=RELRECN//RECTRK+1;            /* COMPUTE RECORD R Y02006       */
         LH    @10,RECTRK                                          0503
         LR    @00,RELRECN                                         0503
         SRDA  @00,32                                              0503
         DR    @00,@10                                             0503
         AH    @00,@CH00042                                        0503
         STC   @00,R                                               0503
*   TT=DUMPTT+RELRECN/RECTRK;       /* COMPUTE RECORD TT Y02006      */
         LR    @00,RELRECN                                         0504
         SRDA  @00,32                                              0504
         DR    @00,@10                                             0504
         AH    @01,DUMPTT(,MAPPTR)                                 0504
         STH   @01,TT                                              0504
*   GO TO POINT;                    /* GO TO READ REQUESTED RECORD   */
         B     POINT                                               0505
*/********************************************************************/
*/*                                                                  */
*/*            COMPUTE BLOCK NUMBER OF DESIRED RECORD ON TAPE        */
*/*                                                                  */
*/********************************************************************/
*                                                                  0506
*TTRTAPE:                                                          0506
*   TTRNO=RELBLK+DUMPTTR;           /* COMPUTE BLOCK NUMBER OR RECORD
*                                      Y02006                        */
TTRTAPE  LR    @10,RELBLK                                          0506
         AL    @10,DUMPTTR(,MAPPTR)                                0506
         ST    @10,TTRNO                                           0506
*   GO TO POINT;                    /* GO TO READ REQUESTED RECORD   */
         B     POINT                                               0507
*                                                                  0508
*/********************************************************************/
*/*                                                                  */
*/* THE FOLLOWING ROUTINE SEARCHES THE ASID LISTS FOR THE ASID       */
*/* IN REQASID OR AN ASID OF ZERO.  ZERO INDICATES NO MORE ENTRIES   */
*/* OR TABLES ARE USED.  WHEN FOUND 'INDEX' IS SET TO THAT ASID.     */
*/* AN INDEX RETURNED OF ZERO INDICATES ALL ASID LISTS ARE FULL      */
*/* AND THE REQUESTED ASID COULD NOT BE FOUND.                       */
*/*                                                                  */
*/********************************************************************/
*                                                                  0508
*ASIDSRCH:                                                         0508
*   PROC OPTIONS(NOSAVEAREA,NOSAVE);                               0508
ASIDSRCH DS    0H                                                  0509
*LOOP:                                                             0509
*   DO INDEX=1 TO ASIDCNT;          /* LOOP TO SEARCH ALL ASIDLISTS
*                                      Y02006                        */
LOOP     LA    INDEX,1                                             0509
@DL00509 DS    0H                                                  0510
*     IF ASDXASID(INDEX)=REQASID×ASDXASID(INDEX)=0 THEN/* IS THIS THE
*                                      REQUESTED ASID OR 0 Y02006    */
         L     @10,INDXADDR                                        0510
         LR    @08,INDEX                                           0510
         ALR   @08,@08                                             0510
         ST    @08,@TF00001                                        0510
         ALR   @08,@10                                             0510
         CLC   ASDXASID-2(2,@08),REQASID                           0510
         BE    @RT00510                                            0510
         AL    @10,@TF00001                                        0510
         SLR   @08,@08                                             0510
         ICM   @08,3,ASDXASID-2(@10)                               0510
         LTR   @08,@08                                             0510
         BZ    @RT00510                                            0510
*       RETURN;                     /* YES--THEN RETURN Y02006       */
*   END;                            /* NO--KEEP LOOPING Y02006       */
         AH    INDEX,@CH00042                                      0512
         CH    INDEX,@CH00065                                      0512
         BNH   @DL00509                                            0512
*   IF ASDXLNK^=0 THEN              /* IS THERE ANOTHER TABLE Y02006 */
         L     @10,INDXADDR                                        0513
         L     @10,ASDXLNK(,@10)                                   0513
         LTR   @10,@10                                             0513
         BZ    @RF00513                                            0513
*     DO;                                                          0514
*       INDXADDR=ASDXLNK;           /* YES--SET PTR TO IT Y02006     */
         ST    @10,INDXADDR                                        0515
*       GO TO LOOP;                 /* LOOP THROUGH THIS TABLE Y02006*/
         B     LOOP                                                0516
*     END;                                                         0517
*   INDEX=0;                        /* INDICATE ASID NOT FOUND AND 0518
*                                      ALL TABLES FULL Y02006        */
@RF00513 SLR   INDEX,INDEX                                         0518
*   END ASIDSRCH;                   /* RETURN TO CALLER Y02006       */
@EL00004 DS    0H                                                  0519
@EF00004 DS    0H                                                  0519
@ER00004 BR    @14                                                 0519
*/********************************************************************/
*/*                                                                  */
*/*           THIS ROUTINE SCANS THE INPUT DUMP MAP FOR THE          */
*/*           REQUESTED ADDRESS.  IF THE ADDRESS IS BETWEEN THE      */
*/*           'FIRST' AND 'LAST' ADDRESSES REPRESENTED BY AN ENTRY,  */
*/*           THEN CONTROL IS RETURNED TO THE CALLER.  IF THE        */
*/*           REQUESTED ADDRESS IS NOT ON THE MAP, THE NOTFOUND      */
*/*           SWITCH IS SET. MAPPTR POINTS TO THE FIRST              */
*/*           MAP ENTRY FOR THE SEARCH.                              */
*/*                                                                  */
*/********************************************************************/
*                                                                  0520
*MAPSCAN:                                                          0520
*   PROC OPTIONS(NOSAVEAREA,NOSAVE);                               0520
MAPSCAN  DS    0H                                                  0521
*   NOTFOUND=SWTCHOFF;              /* RESET ERROR SWITCH OFF Y02006 */
         NI    NOTFOUND,B'11110111'                                0521
*   IF MAPPTR=0 THEN                /* IS THERE A MAP TO SEARCH    0522
*                                      Y02006                        */
         LTR   MAPPTR,MAPPTR                                       0522
         BNZ   @RF00522                                            0522
*     DO;                                                          0523
*       NOTFOUND=SWITCHON;          /* NO--RETURN NOT FOUND Y02006   */
         OI    NOTFOUND,B'00001000'                                0524
*       RETURN;                     /* RETURN Y02006                 */
@EL00005 DS    0H                                                  0525
@EF00005 DS    0H                                                  0525
@ER00005 BR    @14                                                 0525
*     END;                                                         0526
*MAPSCN1:                                                          0527
*   IF DUMPLADD<REQADDR THEN        /* ADDR IN THIS MAP ENTRY        */
@RF00522 DS    0H                                                  0527
MAPSCN1  C     REQADDR,DUMPLADD(,MAPPTR)                           0527
         BNH   @RF00527                                            0527
*     DO;                                                          0528
*       MAPPTR=DUMPLINK;            /* NO - POINT TO NEXT ENTRY      */
         SLR   @10,@10                                             0529
         ICM   @10,7,DUMPLINK(MAPPTR)                              0529
         LR    MAPPTR,@10                                          0529
*       IF MAPPTR^=0 THEN           /* END OF MAP LIST Y02006        */
         LTR   MAPPTR,MAPPTR                                       0530
         BNZ   @RT00530                                            0530
*         GO TO MAPSCN1;            /* NO-- CONTINUE SCAN OF MAP   0531
*                                      Y02006                        */
*       ELSE                                                       0532
*         DO;                                                      0532
*           NOTFOUND=SWITCHON;      /* YES--INDICATE ADDRESS NOT   0533
*                                      FOUND Y02006                  */
         OI    NOTFOUND,B'00001000'                                0533
*           RETURN;                 /* RETURN NOT FOUND Y02006       */
         B     @EL00005                                            0534
*         END;                                                     0535
*     END;                                                         0536
*   IF DUMPFADD>REQADDR THEN        /* ADDR IN THIS MAP ENTRY Y02006 */
@RF00527 C     REQADDR,DUMPFADD(,MAPPTR)                           0537
         BNL   @RF00537                                            0537
*     DO;                                                          0538
*       NOTFOUND=SWITCHON;          /* NO--INDICATE ADDRESS NOT FOUND
*                                      Y02006                        */
         OI    NOTFOUND,B'00001000'                                0539
*       RETURN;                     /* RETURN NOT FOUND Y02006       */
         B     @EL00005                                            0540
*     END;                                                         0541
*   REQVOL=DUMPVOLN;                /* REQUEST VOLUME NUMBER IN MAP  */
@RF00537 MVC   REQVOL(1),DUMPVOLN(MAPPTR)                          0542
*   REQVOLD=SWTCHOFF;               /* RESET FLAG BIT IN CASE ITS ON
*                                      Y02006                        */
         NI    REQVOLD,B'01111111'                                 0543
*   END MAPSCAN;                    /* RETURN TO CALLER Y02006       */
         B     @EL00005                                            0544
*                                                                  0545
*/********************************************************************/
*/*                                                                  */
*/*           THIS ROUTINE OBTAINS THE APPROPRIATE DCB ADDRESS       */
*/*           FOR THE CURRENT READ OPERATION.  THE RECORDS           */
*/*           PER TRACK VALUE AND CURRENT VOLUME NUMBER FOR          */
*/*           THAT DATA SET IS OBTAINED.                             */
*/*                                                                  */
*/********************************************************************/
*                                                                  0545
*GETDCB:                                                           0545
*   PROC OPTIONS(NOSAVEAREA,NOSAVE);                               0545
GETDCB   DS    0H                                                  0546
*   RESPECIFY                                                      0546
*     REG14 RESTRICTED;             /* RESTRICT RETURN REG Y02006    */
*   TEMPSAVE=REG14;                 /* SAVE RETURN REG SINCE GETRK IS
*                                      CALLED Y02006                 */
         ST    REG14,TEMPSAVE                                      0547
*   RESPECIFY                                                      0548
*     REG14 UNRESTRICTED;           /* UNRESTRICT RETURN REG Y02006  */
*   OPENJ=SWTCHOFF;                 /* INDICATE NORMAL OPEN REQUIRED */
         NI    OPENJ,B'11111011'                                   0549
*   RECTRK=0;                       /* ZERO REC/TRK VALUE            */
         SLR   @10,@10                                             0550
         STH   @10,RECTRK                                          0550
*   IF QPRDINIT=SWTCHOFF THEN       /* HAS PREAD INITIALIZED Y02006  */
         TM    QPRDINIT(COMPTR),B'10000000'                        0551
         BNZ   @RF00551                                            0551
*     DO;                                                          0552
*       QPRDINIT=SWITCHON;          /* NO--SET SWITCH ON AND       0553
*                                      INITIALIZE Y02006             */
         OI    QPRDINIT(COMPTR),B'10000000'                        0553
*       VOLSYSUT=BYTEOFF;           /* INIT. SYSUT1 VOLUME NUMBER    */
         MVI   VOLSYSUT,X'00'                                      0554
*       VOLINDD=BYTEOFF;            /* INIT. INDD VOLUME NUMBER      */
         MVI   VOLINDD,X'00'                                       0555
*       AINDCB=ADDR(INDCB);         /* SET IN DCB ADDRESS IN COMMON  */
         LA    @10,INDCB                                           0556
         ST    @10,AINDCB(,COMPTR)                                 0556
*       ASYSUDCB=ADDR(SYSUDCB);     /* SET SYSUT1 DCB ADDR IN COMMON */
         LA    @08,SYSUDCB                                         0557
         STCM  @08,7,ASYSUDCB(COMPTR)                              0557
*       REG3=AINDCB;                /* LOAD DCB REGISTER             */
         LR    REG3,@10                                            0558
*       DCBDDNAM=INDD;              /* SET DDNAME INTO DCB Y02006    */
         MVC   DCBDDNAM(8),INDD(COMPTR)                            0559
*       GEN(RDJFCB MF=(E,DCBLST));  /* READ JFCB FOR FILE POSITIONING*/
         RDJFCB MF=(E,DCBLST)
*       IF FILESEQ^=0 THEN          /* TEST TO INSURE THAT A FILE  0561
*                                      SEQ-NO ON DD IS NOT IGNORED   */
         LH    @10,FILESEQ(,COMPTR)                                0561
         LTR   @10,@10                                             0561
         BZ    @RF00561                                            0561
*         JFCBFLSQ=FILESEQ;         /* MOVE FILE SEQ-NO FROM COMMON  */
         LA    @08,JFCBBUF                                         0562
         STH   @10,JFCBFLSQ+68(,@08)                               0562
*       JFCBUFNO=BYTEOFF;           /* SET BUFFER NO. TO ZERO        */
@RF00561 LA    @10,JFCBBUF                                         0563
         MVI   JFCBUFNO+88(@10),X'00'                              0563
*       JFCBMASK(33)=SWTCHOFF;      /* SUPPRESS WRITING JFCB         */
         NI    JFCBMASK+76(@10),B'01111111'                        0564
*       JFCBTSDM='08'X;             /* BACK TO JOB QUEUE             */
         MVI   JFCBTSDM+52(@10),X'08'                              0565
*     END;                                                         0566
*   IF DUMPDEV=SWITCHON THEN        /* IS MAP ENTRY FOR A TAPE DEVICE
*                                      Y02006                        */
@RF00551 TM    DUMPDEV(MAPPTR),B'10000000'                         0567
         BNO   @RF00567                                            0567
*     DO;                                                          0568
*       REG3=AINDCB;                /* YES--SET DCB ADDRESS Y02006   */
         L     REG3,AINDCB(,COMPTR)                                0569
*       VOLADDR=ADDR(VOLINDD);      /* MAKE INDD VOLUME CURRENT    0570
*                                      Y02006                        */
         LA    VOLADDR,VOLINDD                                     0570
*       CURDDNAM=INDD;              /* MAKE INDD DDNAME CURRENT    0571
*                                      Y02006                        */
         MVC   CURDDNAM(8),INDD(COMPTR)                            0571
*       OPENJ=SWITCHON;             /* INDICATE OPEN TYPE=J REQUIRED
*                                      Y02006                        */
         OI    OPENJ,B'00000100'                                   0572
*       GO TO DCBRET;               /* RETURN Y02006                 */
         B     DCBRET                                              0573
*     END;                                                         0574
*   IF QUT1LOD=SWITCHON THEN        /* IS SYSUT1 BEING USED Y02006   */
@RF00567 TM    QUT1LOD(COMPTR),B'00000010'                         0575
         BO    @RT00575                                            0575
*     GO TO RDSYSUT1;               /* YES--GO TO SYSUT1 ROUTINE   0576
*                                      Y02006                        */
*   REG3=AINDCB;                    /* GET INDCB ADDRESS             */
         L     REG3,AINDCB(,COMPTR)                                0577
*   VOLADDR=ADDR(VOLINDD);          /* MAKE INDD VOLUME CURRENT      */
         LA    VOLADDR,VOLINDD                                     0578
*   CURDDNAM=INDD;                  /* MAKE INDD DDNAME CURRENT      */
         MVC   CURDDNAM(8),INDD(COMPTR)                            0579
*   IF INDDREC=0 THEN               /* INITIALIZED INDD REC/TRK      */
         ICM   @10,3,INDDREC                                       0580
         BNZ   @RF00580                                            0580
*     DO;                           /* NO -                          */
*       CALL GETRCTK;               /* COMPUTE REC/TRK VALUE         */
         BAL   @14,GETRCTK                                         0582
*       INDDREC=RECTRK;             /* SAVE INDD REC/TRK VALUE       */
         MVC   INDDREC(2),RECTRK                                   0583
*     END;                                                         0584
*   ELSE                            /* YES -                         */
*     RECTRK=INDDREC;               /* GET INDD REC/TRK VALUE        */
         B     @RC00580                                            0585
@RF00580 MVC   RECTRK(2),INDDREC                                   0585
*   GO TO DCBRET;                   /* RETURN TO CALLER Y02006       */
         B     DCBRET                                              0586
*RDSYSUT1:                                                         0587
*   REG3=ADDR(SYSUDCB);             /* GET SYSUT1 DCB ADDRESS        */
RDSYSUT1 LA    REG3,SYSUDCB                                        0587
*   VOLADDR=ADDR(VOLSYSUT);         /* MAKE SYSUT1 VOLUME CURRENT    */
         LA    VOLADDR,VOLSYSUT                                    0588
*   CURDDNAM=NAMSYSUT;              /* MAKE SYSUT1 DDNAME CURRENT    */
         MVC   CURDDNAM(8),NAMSYSUT                                0589
*   IF SYSUTREC=0 THEN              /* INITIALIZED SYSUT1 REC/TRK    */
         ICM   @10,3,SYSUTREC                                      0590
         BNZ   @RF00590                                            0590
*     DO;                           /* NO -                          */
*       CALL GETRCTK;               /* COMPUTE REC/TRK VALUE         */
         BAL   @14,GETRCTK                                         0592
*       SYSUTREC=RECTRK;            /* SAVE SYSUT1 REC/TRK VALUE     */
         MVC   SYSUTREC(2),RECTRK                                  0593
*     END;                                                         0594
*   ELSE                            /* YES -                         */
*     RECTRK=SYSUTREC;              /* GET SYSUT1 REC/TRK VALUE      */
         B     @RC00590                                            0595
@RF00590 MVC   RECTRK(2),SYSUTREC                                  0595
*DCBRET:                                                           0596
*   RESPECIFY                                                      0596
*     REG14 RESTRICTED;             /* RESTRICT RETURN REG Y02006    */
@RC00590 DS    0H                                                  0596
DCBRET   DS    0H                                                  0597
*   REG14=TEMPSAVE;                 /* RESTORE RETURN REG Y02006     */
         L     REG14,TEMPSAVE                                      0597
*   RESPECIFY                                                      0598
*     REG14 UNRESTRICTED;           /* UNRESTRICT RETURN REG Y02006  */
*   END GETDCB;                     /* RETURN TO CALLER Y02006       */
@EL00006 DS    0H                                                  0599
@EF00006 DS    0H                                                  0599
@ER00006 BR    @14                                                 0599
*/********************************************************************/
*/*                                                                  */
*/*           COMPUTE NUMBER OF BUFFSIZE RECORDS PER TRACK           */
*/*           ON THE DIRECT ACCESS DEVICE ASSOCIATED WITH            */
*/*           THE CURRENT DATA SET.  THE ALGORITHM USED IS           */
*/*           THE SAME AS DESCRIBED IN THE DATA MANAGEMENT FOR SYSTEM*/
*/*           PROGRAMMERS SRL UNDER THE DEVTYPE MACRO                */
*/*           INSTRUCTION, USING THE INFORMATION RETURNED BY         */
*/*           THE DEVTYPE MACRO INSTRUCTION.  REGISTER 3             */
*/*           CONTAINS THE DCB ADDRESS.                              */
*/*                                                                  */
*/********************************************************************/
*                                                                  0600
*GETRCTK:                                                          0600
*   PROC OPTIONS(NOSAVEAREA,NOSAVE);                               0600
GETRCTK  DS    0H                                                  0601
*   GENERATE;                                                      0601
         DEVTYPE CURDDNAM,DEVAREA,DEVTAB ISSUE DEVTYPE FOR DEVICE
*                                      CHARACTERISTICS
*   IF DEVAREA(3)^='20'X THEN       /* TAPE INPUT                    */
         CLI   DEVAREA+2,X'20'                                     0602
         BNE   @RT00602                                            0602
*     RETURN;                       /* RETURN TO CALLER Y02006       */
*   IF DEVTOLRB=SWITCHON THEN       /* DEVICE TOLERANCE REQUIRED     */
         TM    DEVTOLRB,B'00000001'                                0604
         BNO   @RF00604                                            0604
*     DO;                                                          0605
*       N2=BUFFSIZE*DEVTOLR;        /* YES - FIGURE IN TOLERANCE     */
         LH    N2,DEVTOLR                                          0606
         MH    N2,@CH00038                                         0606
*       N2=N2/512;                                                 0607
         SRL   N2,9                                                0607
*     END;                                                         0608
*   ELSE                                                           0609
*     N2=BUFFSIZE;                  /* NO - SET UP DATA RECORD LENGTH*/
         B     @RC00604                                            0609
@RF00604 LH    N2,@CH00038                                         0609
*   IF DEV2BOV=SWTCHOFF THEN        /* TWO BYTE OVERHEAD REQUIRED    */
@RC00604 TM    DEV2BOV,B'00001000'                                 0610
         BNZ   @RF00610                                            0610
*     N2=N2+(DEVADOVH-DEVOVRHD);    /* NO - ADD OVERHEAD     @ZA00400*/
         SLR   @10,@10                                             0611
         IC    @10,DEVADOVH                                        0611
         SLR   @06,@06                                             0611
         IC    @06,DEVOVRHD                                        0611
         SLR   @10,@06                                             0611
         ALR   N2,@10                                              0611
*   ELSE                                                           0612
*     N2=N2+DEVKYOVH;               /* ADD 2 BYTE OVERHEAD           */
         B     @RC00610                                            0612
@RF00610 AH    N2,DEVKYOVH                                         0612
*   RECTRK=1+(DEVMAXTK-N2)/N2;      /* COMPUTE THE NUMBER OF       0613
*                                      RECORDS/TRACK                 */
@RC00610 LH    @00,DEVMAXTK                                        0613
         SLR   @00,N2                                              0613
         SRDA  @00,32                                              0613
         DR    @00,N2                                              0613
         LA    @01,1(,@01)                                         0613
         STH   @01,RECTRK                                          0613
*   END GETRCTK;                    /* RETURN TO GETDCB ROUTINE    0614
*                                      Y02006                        */
@EL00007 DS    0H                                                  0614
@EF00007 DS    0H                                                  0614
@ER00007 BR    @14                                                 0614
*                                                                  0615
*/********************************************************************/
*/*                                                                  */
*/*           THIS ROUTINE CLOSES THE CURRENT DATA SET               */
*/*           AND THEN RE-OPENS IT IN ORDER TO RE-POSITION           */
*/*           IT TO THE BEGINNING.  IT PERFORMS A NORMAL             */
*/*           OPEN FOR SYSUT1, AND AN OPEN TYPE=J FOR                */
*/*           INDD.  REGISTER 3 CONTAINS THE CURRENT DCB ADDRESS.    */
*/*                                                                  */
*/********************************************************************/
*                                                                  0615
*DSOPEN:                                                           0615
*   PROC OPTIONS(NOSAVEAREA,NOSAVE);                               0615
DSOPEN   DS    0H                                                  0616
*   GENERATE;                                                      0616
         CLOSE ((R3),REREAD)           POSITION DATA SET TO BEGINNING
*   IF OPENJ=SWTCHOFF THEN          /* OPEN TYPE=J REQUIRED          */
         TM    OPENJ,B'00000100'                                   0617
         BNZ   @RF00617                                            0617
*     GENERATE;                                                    0618
*                                   /* NO - PERFORM NORMAL OPEN      */
         OPEN  ((R3),(INPUT,REREAD))   RE-OPEN DATA SET
*   ELSE                            /* YES -                         */
*     GENERATE;                                                    0619
         B     @RC00617                                            0619
@RF00617 DS    0H                                                  0619
*                                   /* PERFORM OPEN TYPE=J           */
         OPEN  (,(INPUT,REREAD)),MF=(E,DCBLST),TYPE=J
*     END DSOPEN;                   /* RETURN TO CALLER Y02006       */
@EL00008 DS    0H                                                  0620
@EF00008 DS    0H                                                  0620
@ER00008 BR    @14                                                 0620
*                                                                  0621
*/********************************************************************/
*/*                                                                  */
*/*           ENTERED WHEN A PREFORMATTED RECORD IS                  */
*/*           FOUND IN THE INPUT DATA SET. THE RECORD                */
*/*           IS MOVED TO THE BUFFER POINTED TO BY                   */
*/*           CUFBUF IN COMMON AND WRITTEN TO THE                    */
*/*           PRINTER DATA SET.                                      */
*/*                                                                  */
*/********************************************************************/
*                                                                  0621
*PREFMT:                                                           0621
*   IF PREFMTSW=SWITCHON THEN       /* FIRST TIME THRU Y02006        */
PREFMT   TM    PREFMTSW,B'00010000'                                0621
         BO    @RT00621                                            0621
*     GO TO PRINT;                  /* NO - WRITE RECORD             */
*   PREFMTSW=SWITCHON;              /* SET PREFORMATTED DUMP SW    0623
*                                      Y02006                        */
         OI    PREFMTSW,B'00010000'                                0623
*   PREFM=SWITCHON;                 /* INDICATE PREFORMATTED DUMP  0624
*                                      Y02006                        */
         OI    PREFM(COMPTR),B'00000010'                           0624
*   STOPSAVE=STOPEXIT;              /* SAVE CALLER'S STOP RTN.       */
         MVC   STOPSAVE(4),STOPEXIT(COMPTR)                        0625
*   STOPEXIT=ADDR(TREADSTP);        /* SET UP STOP EXIT CLEAR TITLE
*                                      FIELDS                        */
         LA    @08,TREADSTP                                        0626
         ST    @08,STOPEXIT(,COMPTR)                               0626
*   TITLEMOD(8:15)='PREFORM';                                      0627
         MVI   TITLEMOD+14(COMPTR),C' '                            0627
         MVC   TITLEMOD+7(7,COMPTR),@CC00660                       0627
*   TITLEDTE(6:13)=' ';                                            0628
         MVI   TITLEDTE+6(COMPTR),C' '                             0628
         MVC   TITLEDTE+7(6,COMPTR),TITLEDTE+6(COMPTR)             0628
         MVI   TITLEDTE+5(COMPTR),C' '                             0628
*   TITLETME(6:13)=' ';                                            0629
         MVI   TITLETME+6(COMPTR),C' '                             0629
         MVC   TITLETME+7(6,COMPTR),TITLETME+6(COMPTR)             0629
         MVI   TITLETME+5(COMPTR),C' '                             0629
*   GEN REFS(AWRITE) FLOWS(TREADSTP)(BRWRITE SKIP);/* STA RT ON NEW
*                                      PAGE Y02006                   */
         BRWRITE SKIP
*PRINT:                                                            0631
*   OUTBUF=PRDINPUT(1:BUFFSIZE-IOBCSWCT);/* MOVE RECORD TO BUFFER  0631
*                                      Y02006                        */
PRINT    L     @08,CURBUF(,COMPTR)                                 0631
         MVI   OUTBUF+1(@08),C' '                                  0631
         MVC   OUTBUF+2(131,@08),OUTBUF+1(@08)                     0631
         LH    @04,@CH00038                                        0631
         L     @01,DCBIOBA                                         0631
         SH    @04,IOBCSWCT+22(,@01)                               0631
         BCTR  @04,0                                               0631
         ICM   @01,7,PRDINPTR(PARMPTR)                             0631
         EX    @04,@SM00682                                        0631
*   GEN REFS(AWRITE) FLOWS(TREADSTP)(BRWRITE 1);/* WRITE RECORD    0632
*                                      Y02006                        */
         BRWRITE 1
*   GO TO MAPREAD;                  /* LOOP TO GET NEXT SHORT RECORD */
         B     MAPREAD                                             0633
*/********************************************************************/
*/*                                                                  */
*/*    STOP EXIT - TO GET CONTROL IF STOP IS ENTERED BY OPERATOR     */
*/*                                                                  */
*/********************************************************************/
*                                                                  0634
*TREADSTP:                                                         0634
*   GEN;                                                           0634
TREADSTP DS    0H                                                  0634
         USING *,R15           TEMPORARILY USE REG 15 AS BASE
         LA    R13,@SA00001        POINT TO SAVE AREA          Y02006
         LM    R14,R12,12(R13)     RELOAD REGS
         DROP  R15                 SHIFT BACK TO REGULAR BASE
*   GO TO ERREXT;                   /* PREPARE FOR EXIT TO AMDPRRDC  */
         B     ERREXT                                              0635
*                                                                  0636
*/********************************************************************/
*/*                                                                  */
*/*           ERROR EXIT ENTERED ON VARIOUS ERROR CONDITIONS.        */
*/*           IF A PREFORMATTED DUMP WAS BEING PROCESSED, THE        */
*/*           STOP EXIT ADDRESS IN COMMON IS RESTORED.  THE          */
*/*           BUFFER IS MARKED INVALID AND CONTROL IS RETURNED       */
*/*           TO AMDPRRDC.                                           */
*/*                                                                  */
*/********************************************************************/
*                                                                  0636
*ERREXT:                                                           0636
*   IF PREFMTSW=SWITCHON THEN       /* PREFORMATTED DUMP Y02006      */
ERREXT   TM    PREFMTSW,B'00010000'                                0636
         BNO   @RF00636                                            0636
*     STOPEXIT=STOPSAVE;            /* YES - RESTORE STOP EXIT       */
         MVC   STOPEXIT(4,COMPTR),STOPSAVE                         0637
*   BUFFINVL=SWITCHON;              /* MARK BUFFER INVALID Y02006    */
@RF00636 OI    BUFFINVL(PARMPTR),B'10000000'                       0638
*   RETURN;                         /* RETURN TO AMDPRRDC Y02006     */
         B     @EL00001                                            0639
*/********************************************************************/
*/*                                                                  */
*/*           ENTERED WHEN AN I/O ERROR OCCURS READING THE           */
*/*           INPUT DATA SET.  THE SYNAD SWITCH IS SET AND           */
*/*           CONTROL PASSED TO THE INSTRUCTION FOLLOWING            */
*/*           THE LAST CHECK ISSUED.                                 */
*/*                                                                  */
*/********************************************************************/
*                                                                  0640
*IOERROR:                                                          0640
*   SYNADSW=SWITCHON;               /* SET SYNAD SWITCH Y02006       */
IOERROR  OI    SYNADSW,B'00100000'                                 0640
*   IOERR=SWITCHON;                 /* SIGNAL I/O ERROR Y02006       */
         OI    IOERR(COMPTR),B'10000000'                           0641
*   GEN( BR 14 );                   /* RETURN TO LAST CHECK Y02006   */
          BR 14
*   GEN;                                                           0643
DCBLST   RDJFCB  (INDCB),MF=L
INDCB    DCB   EXLST=EXITLIST,                                         *
               DSORG=PS,                                               *
               RECFM=U,                                                *
               MACRF=(RP),                                             *
               BLKSIZE=4104,                                           *
               LRECL=4104,                                             *
               SYNAD=IOERROR,                                          *
               EODAD=EOF
SYSUDCB  DCB   DSORG=PS,                                               *
               DDNAME=SYSUT1,                                          *
               RECFM=U,                                                *
               MACRF=(RP),                                             *
               BLKSIZE=4104,                                           *
               LRECL=4104,                                             *
               SYNAD=IOERROR,                                          *
               EODAD=EOF
*   END AMDPREAD                                                   0644
*                                                                  0644
*/* THE FOLLOWING INCLUDE STATEMENTS WERE FOUND IN THIS PROGRAM.     */
*/*%INCLUDE SYSLIB  (AMDDATA )                                       */
*/*%INCLUDE SYSLIB  (COMMON  )                                       */
*                                                                  0644
*       ;                                                          0644
         B     @EL00001                                            0644
@DATA    DS    0H
@CH00042 DC    H'1'
@CH00255 DC    H'5'
@CH00065 DC    H'18'
@CH00208 DC    H'133'
@CH00391 DC    H'256'
@CH00665 DC    H'3849'
@CH00038 DC    H'4104'
@CH00053 DC    XL2'FFFF'
@SM00682 MVC   OUTBUF(0,@08),PRDINPUT(@01)
         DS    0F
@SA00001 DS    18F
@TF00001 DS    F
         DS    0F
@CF00677 DC    F'4095'
@CF00040 DC    F'4096'
@CH00040 EQU   @CF00040+2
@CF00061 DC    XL4'00000100'
@CF00063 DC    XL4'00000001'
         DS    0D
INDXADDR DS    A
TEMPSAVE DS    A
STOPSAVE DC    A(0)
TTRNO    DS    FL4
         ORG   TTRNO
TT       DS    FL2
R        DS    CL1
Z        DS    CL1
         ORG   TTRNO+4
NEWENTRY DS    A
FIRSTTTR DC    F'0'
SVCBUFAD DS    A
MAPERROR DS    H
RECTRK   DC    H'0'
INDDREC  DC    H'0'
SYSUTREC DC    H'0'
CURVOL   DC    H'0'
POSTIPL  DS    H
REQVOL   DS    FL1
         ORG   REQVOL
REQVOLD  DS    BL1
@NM00012 EQU   REQVOL+0
         ORG   REQVOL+1
@CC00071 DC    C'AMDSADMP'
@CC00660 DC    C'PREFORM'
@CB00575 DC    X'00000000000000000000'
@CB00051 DC    X'FFFFFFFF'
@CB00055 DC    X'0000003F'
@CB00069 DC    X'0000FFFF'
@CB00053 EQU   @CB00051
@CB00067 DC    X'8000'
REQASID  DS    CL2
         DS    CL6
DEVAREA  DS    CL20
         ORG   DEVAREA
@NM00005 DS    FL4
@NM00006 DS    FL4
@NM00007 DS    FL4
DEVMAXTK DS    FL2
DEVKYOVH DS    FL2
DEVOVRHD DS    CL1
DEVFLAGS DS    BL1
         ORG   DEVFLAGS
@NM00008 DS    BL1
DEV2BOV  EQU   DEVFLAGS+0
@NM00009 EQU   DEVFLAGS+0
DEVTOLRB EQU   DEVFLAGS+0
         ORG   DEVAREA+18
DEVTOLR  DS    FL2
         ORG   DEVAREA+20
EXITLIST DS    CL4
         ORG   EXITLIST
@NM00010 DC    X'87'
JFCBAD   DC    AL3(JFCBBUF)
         ORG   EXITLIST+4
JFCBBUF  DS    CL176
SWITCHES DS    BL1
         ORG   SWITCHES
MAPSW    DS    BL1
HDRSW    EQU   SWITCHES+0
SYNADSW  EQU   SWITCHES+0
PREFMTSW EQU   SWITCHES+0
NOTFOUND EQU   SWITCHES+0
OPENJ    EQU   SWITCHES+0
BADREC   EQU   SWITCHES+0
@NM00011 EQU   SWITCHES+0
         ORG   SWITCHES+1
         DS    CL3
CURADDR  DS    CL4
CURASID  DS    CL2
VOLINDD  DC    X'00'
VOLSYSUT DC    X'00'
NAMSYSUT DC    CL8'SYSUT1'
CURDDNAM DC    CL8' '
SVCTTR   DS    CL4
PATCH    DC    40F'0'
AMDPREAD CSECT
*
DTAE     EQU   32                  DATA EBCDIC BIT
DTAC     EQU   16                  DATA IN CORE BIT
DTAP     EQU   8                   DATA PTR BIT
DTA      EQU   4                   DATA INCLUDED BIT
LBLP     EQU   2                   LABEL PTR BIT
LBL      EQU   1                   LABEL INCLUDED BIT
AMDPREAD CSECT
@00      EQU   00                      EQUATES FOR REGISTERS 0-15
@01      EQU   01
@02      EQU   02
@03      EQU   03
@04      EQU   04
@05      EQU   05
@06      EQU   06
@07      EQU   07
@08      EQU   08
@09      EQU   09
@10      EQU   10
@11      EQU   11
@12      EQU   12
@13      EQU   13
@14      EQU   14
@15      EQU   15
VOLADDR  EQU   @08
RELRECN  EQU   @04
RELBLK   EQU   @07
INDEX    EQU   @07
LASTENTY EQU   @07
LASTMAP  EQU   @09
CURMAP   EQU   @10
LASTVOL  EQU   @08
N2       EQU   @04
N1       EQU   @08
REQADDR  EQU   @09
I        EQU   @07
MAPPTR   EQU   @02
REG0     EQU   @00
REG1     EQU   @01
REG3     EQU   @03
REG4     EQU   @04
REG14    EQU   @14
COMPTR   EQU   @12
PARMPTR  EQU   @05
BASE1    EQU   @11
BASE2    EQU   @10
BASE3    EQU   @09
BUFREG   EQU   @06
CNTREG   EQU   @03
COMBASE  EQU   @12
LINEREG  EQU   @08
PREG     EQU   @01
R0       EQU   @00
R1       EQU   @01
R10      EQU   @10
R11      EQU   @11
R12      EQU   @12
R13      EQU   @13
R14      EQU   @14
R15      EQU   @15
R2       EQU   @02
R3       EQU   @03
R4       EQU   @04
R5       EQU   @05
R6       EQU   @06
R7       EQU   @07
R8       EQU   @08
R9       EQU   @09
STOPBASE EQU   @05
DUMPFORM EQU   0
@NM00001 EQU   DUMPFORM
DUMPVOLN EQU   @NM00001
DUMPDEV  EQU   DUMPVOLN
DUMPLINK EQU   @NM00001+1
DUMPFADD EQU   DUMPFORM+4
DUMPLADD EQU   DUMPFORM+8
DUMPTTR  EQU   DUMPFORM+12
DUMPTT   EQU   DUMPTTR
DUMPR    EQU   DUMPTTR+2
ASIDLIST EQU   0
ASDXLNK  EQU   ASIDLIST
ASDXASID EQU   ASIDLIST+4
ASDXMAP  EQU   ASIDLIST+40
BUFFMAP  EQU   0
BUFFLINK EQU   BUFFMAP
@NM00003 EQU   BUFFMAP+4
BUFFFLAG EQU   @NM00003
BUFFINVL EQU   BUFFFLAG
BUFFCOM  EQU   BUFFFLAG
BUFFPTR  EQU   @NM00003+1
BUFFREAL EQU   BUFFMAP+8
BUFFVIRT EQU   BUFFMAP+12
BUFFASID EQU   BUFFMAP+16
BUFFCPU  EQU   BUFFMAP+18
JFCBTSDM EQU   0
JFCBFLSQ EQU   0
JFCBMASK EQU   0
JFCBUFNO EQU   0
VOLNO    EQU   0
SVCBUF   EQU   0
IOBCSWCT EQU   0
OUTBUF   EQU   0
PRDINPUT EQU   0
PRDHDRID EQU   PRDINPUT
PRDRECID EQU   PRDINPUT+1
PRDASID  EQU   PRDINPUT+2
PRDMODNM EQU   PRDINPUT+4
PRDTODVL EQU   PRDINPUT+12
PRDTITLE EQU   PRDINPUT+20
PRDREGS  EQU   PRDINPUT+120
PRDFPR   EQU   PRDREGS
PRDCVT   EQU   PRDINPUT+288
PRDERRID EQU   PRDINPUT+324
COMMON   EQU   0
CURBUF   EQU   COMMON+48
CVTADDR  EQU   COMMON+56
INDD     EQU   COMMON+68
FILESEQ  EQU   COMMON+76
READNO   EQU   COMMON+84
RDERCNT  EQU   COMMON+88
SWA      EQU   COMMON+122
SETCVTSW EQU   SWA
SWB      EQU   COMMON+123
IOERR    EQU   SWB
SWC      EQU   COMMON+124
POSITSW  EQU   SWC
TREADIN  EQU   SWC
SWD      EQU   COMMON+125
SWE      EQU   COMMON+126
BUILDMAP EQU   SWE
SWF      EQU   COMMON+127
QPRDINIT EQU   SWF
QSADMP   EQU   SWF
DMPIC    EQU   SWF
QUT1LOD  EQU   SWF
BUFSW    EQU   COMMON+128
PREFM    EQU   BUFSW
PRSW     EQU   COMMON+129
TITLEMOD EQU   COMMON+347
TITLEDTE EQU   COMMON+364
TITLETME EQU   COMMON+379
TABLE    EQU   COMMON+659
HEXTABL  EQU   TABLE+63
AWRITE   EQU   COMMON+1500
STOPEXIT EQU   COMMON+1528
DCBADDRS EQU   COMMON+1608
AINDCB   EQU   DCBADDRS+12
@NM00065 EQU   DCBADDRS+16
@NM00066 EQU   @NM00065
ASYSUDCB EQU   @NM00065+1
REALMAP  EQU   COMMON+1644
QASID    EQU   COMMON+1664
IPLCPU   EQU   COMMON+1666
SACSWCAW EQU   COMMON+1684
HDRREGS  EQU   COMMON+1696
HDRTITLE EQU   COMMON+1864
ASIDNDX  EQU   COMMON+1968
CPUMAP   EQU   COMMON+1972
I3800SW  EQU   COMMON+2076
TITLEKEY EQU   COMMON+2077
Z9ERRID  EQU   COMMON+2116
PRDINPTR EQU   BUFFPTR
DEVADOVH EQU   DEVKYOVH+1
PRDFLC   EQU   PRDFPR
PRDCSW   EQU   PRDFLC
PRDCAW   EQU   PRDFLC+8
@NM00016 EQU   PRDHDRID
PRDADDR  EQU   @NM00016+4
PRDDATA  EQU   @NM00016+8
@NM00018 EQU   PRDHDRID
PRDFLAGS EQU   @NM00018+2
PRDCPUAD EQU   @NM00018+6
         AGO   .@UNREFD                START UNREFERENCED COMPONENTS
@NM00024 EQU   @NM00018+8
@NM00023 EQU   @NM00018+4
@NM00022 EQU   @NM00018+3
@NM00021 EQU   PRDFLAGS
PRDGPRVL EQU   PRDFLAGS
PRDSSINV EQU   PRDFLAGS
PRDUNIPR EQU   PRDFLAGS
@NM00020 EQU   @NM00018+1
@NM00019 EQU   @NM00018
@NM00017 EQU   @NM00016+2
PRDKEY2  EQU   @NM00016+1
PRDKEY1  EQU   @NM00016
@NM00015 EQU   PRDFLC+12
Z9SUFLG  EQU   COMMON+2115
Z9SUBITS EQU   COMMON+2100
Z9SVCBUF EQU   COMMON+2096
TITLESTK EQU   TITLEKEY+12
@NM00076 EQU   TITLEKEY
I3800204 EQU   I3800SW
I380080  EQU   I3800SW
I3800ULN EQU   I3800SW
I3800KEY EQU   I3800SW
@NM00075 EQU   I3800SW
@NM00074 EQU   I3800SW
@NM00073 EQU   I3800SW
@NM00072 EQU   I3800SW
CSADDR   EQU   COMMON+2072
@NM00071 EQU   COMMON+2070
TOPICHDR EQU   COMMON+2060
DFLTCSA  EQU   COMMON+2056
LPAMAX   EQU   COMMON+2052
DNUCTOP  EQU   COMMON+2048
XLMAX    EQU   COMMON+2044
DQEMAX   EQU   COMMON+2042
ASCBMAX  EQU   COMMON+2040
TCBMAX   EQU   COMMON+2038
SRBMAX   EQU   COMMON+2036
DDMAX    EQU   COMMON+2034
DEBMAX   EQU   COMMON+2032
JPQMAX   EQU   COMMON+2030
LLEMAX   EQU   COMMON+2028
PQEMAX   EQU   COMMON+2026
RBMAX    EQU   COMMON+2024
@NM00070 EQU   COMMON+2023
EXITFLAG EQU   COMMON+2022
AUSRASID EQU   COMMON+2020
AUSRTCBA EQU   COMMON+2016
AUSRDEL  EQU   COMMON+2012
AUSREXIT EQU   COMMON+2008
AUSRINIT EQU   COMMON+2004
ASRBFMT  EQU   COMMON+2000
AASCBFMT EQU   COMMON+1996
BRRDADJ  EQU   COMMON+1992
BRRDINIT EQU   COMMON+1988
BRRDDATA EQU   COMMON+1984
BUFERMAP EQU   COMMON+1980
ASCBMAP  EQU   COMMON+1976
@NM00069 EQU   COMMON+1964
ASVTADDR EQU   COMMON+1680
PREFXRGV EQU   COMMON+1676
PREFXRGR EQU   COMMON+1672
CURASCB  EQU   COMMON+1668
QAPFT    EQU   COMMON+1660
@NM00068 EQU   COMMON+1656
REALMAX  EQU   COMMON+1652
SEGTABOR EQU   COMMON+1648
@NM00067 EQU   COMMON+1641
EDITER   EQU   COMMON+1640
AROOT    EQU   COMMON+1636
AEDITCB  EQU   COMMON+1632
TRCCOUNT EQU   COMMON+1628
ENDLIST  EQU   @NM00066
ARDRDCB  EQU   DCBADDRS+8
APTRDCB  EQU   DCBADDRS+4
AOUTDCB  EQU   DCBADDRS
ATCBSMRY EQU   COMMON+1604
ATCBSMFR EQU   COMMON+1600
ONGOPTR  EQU   COMMON+1596
AEND     EQU   COMMON+1592
AERRMSGA EQU   COMMON+1584
BUFREINT EQU   COMMON+1580
BUFSUM   EQU   COMMON+1576
APRTSTG  EQU   COMMON+1572
AFORMAT  EQU   COMMON+1568
ASTPROUT EQU   COMMON+1564
APCBENQ  EQU   COMMON+1560
ATCBRTRV EQU   COMMON+1556
ATCBREMV EQU   COMMON+1552
ATCBSAVE EQU   COMMON+1548
QATMERTN EQU   COMMON+1544
ALOADER  EQU   COMMON+1540
AEREXIT  EQU   COMMON+1536
SYNMSGA  EQU   COMMON+1532
ARGNBND  EQU   COMMON+1524
AWRDCNVT EQU   COMMON+1520
AADRCNVT EQU   COMMON+1516
AFMTLINE EQU   COMMON+1512
ASYNTAX  EQU   COMMON+1508
APRTMSG  EQU   COMMON+1504
NONBLNK  EQU   COMMON+1244
BLNK     EQU   COMMON+988
@NM00064 EQU   COMMON+972
@NM00063 EQU   COMMON+915
EBCTABL  EQU   HEXTABL+10
@NM00062 EQU   HEXTABL
@NM00061 EQU   TABLE
CAPTABL  EQU   COMMON+403
TITLEPGE EQU   COMMON+394
@NM00060 EQU   COMMON+392
@NM00059 EQU   COMMON+377
@NM00058 EQU   COMMON+362
TITLEMSG EQU   COMMON+283
MSG2     EQU   COMMON+257
MSG1     EQU   COMMON+231
STOP     EQU   COMMON+227
TITLE    EQU   COMMON+222
BLANKS   EQU   COMMON+214
WTORMSG  EQU   COMMON+133
@NM00057 EQU   COMMON+130
@NM00056 EQU   PRSW
@NM00055 EQU   PRSW
PRNTREAL EQU   PRSW
PRNTRL   EQU   PRSW
TTLSW    EQU   PRSW
@NM00054 EQU   PRSW
QSEGTBSW EQU   PRSW
@NM00053 EQU   PRSW
@NM00052 EQU   BUFSW
@NM00051 EQU   BUFSW
@NM00050 EQU   BUFSW
@NM00049 EQU   BUFSW
@NM00048 EQU   BUFSW
@NM00047 EQU   BUFSW
@NM00046 EQU   BUFSW
@NM00045 EQU   SWF
@NM00044 EQU   SWF
PAGEOK   EQU   SWF
NUCTFRMC EQU   SWF
@NM00043 EQU   SWE
@NM00042 EQU   SWE
@NM00041 EQU   SWE
TITLESW  EQU   SWE
RESPC    EQU   SWE
@NM00040 EQU   SWE
STOPSW   EQU   SWE
@NM00039 EQU   SWD
GPRSFND  EQU   SWD
CONTSW   EQU   SWD
NOLOADSW EQU   SWD
NOSTDMG  EQU   SWD
@NM00038 EQU   SWD
@NM00037 EQU   SWD
FLSHMODE EQU   SWD
@NM00036 EQU   SWC
@NM00035 EQU   SWC
SEGRD    EQU   SWC
EDITSW   EQU   SWC
SETFLSH  EQU   SWC
MSTRSW   EQU   SWC
@NM00034 EQU   SWB
@NM00033 EQU   SWB
QSYSUT2  EQU   SWB
ENDSW    EQU   SWB
@NM00032 EQU   SWB
@NM00031 EQU   SWB
FMTERR   EQU   SWB
RDRSW    EQU   SWA
@NM00030 EQU   SWA
GOSW     EQU   SWA
@NM00029 EQU   SWA
@NM00028 EQU   SWA
@NM00027 EQU   SWA
@NM00026 EQU   SWA
LINENUM  EQU   COMMON+120
LINENUMB EQU   COMMON+118
SIXTEEN  EQU   COMMON+116
TWELVE   EQU   COMMON+114
ELEVEN   EQU   COMMON+112
HTEN     EQU   COMMON+110
EIGHT    EQU   COMMON+108
SEVEN    EQU   COMMON+106
FIVE     EQU   COMMON+104
FOUR     EQU   COMMON+102
THREE    EQU   COMMON+100
TWO      EQU   COMMON+98
ONEA     EQU   COMMON+96
READTM   EQU   COMMON+92
RDENTRY  EQU   COMMON+80
@NM00025 EQU   COMMON+79
RETCODE  EQU   COMMON+78
STORSIZE EQU   COMMON+64
PCBPTR   EQU   COMMON+60
TCBLIST  EQU   COMMON+52
PAGENUMB EQU   COMMON+44
LINECNT  EQU   COMMON+40
SIX      EQU   COMMON+36
NUCTOP   EQU   COMMON+32
WORK1    EQU   COMMON+24
DELIMCD  EQU   COMMON+20
KYWDEND  EQU   COMMON+16
KYWDBGN  EQU   COMMON+12
VERBEND  EQU   COMMON+8
VERBGN   EQU   COMMON+4
ERRADDR  EQU   COMMON
@NM00014 EQU   PRDINPUT+334
@NM00013 EQU   PRDINPUT+292
PRDPSW   EQU   PRDREGS+160
PRDCR    EQU   PRDREGS+96
PRDGPR   EQU   PRDREGS+32
@NM00004 EQU   BUFFFLAG
DUMPZ    EQU   DUMPTTR+3
DUMPVOL  EQU   DUMPVOLN
@NM00002 EQU   DUMPVOLN
.@UNREFD ANOP                          END UNREFERENCED COMPONENTS
@RT00094 EQU   TYPEREAD
@RT00141 EQU   MAPREAD
@RT00188 EQU   MAPZERO
@RT00194 EQU   MAPREAD
@RT00199 EQU   ERREXT
@RT00209 EQU   PREFMT
@RT00211 EQU   ERREXT
@RT00220 EQU   NOTHEADR
@RT00222 EQU   EOF
@RT00248 EQU   MAPREAD1
@RT00257 EQU   MAPREAD1
@RF00257 EQU   MAPREAD
@RT00263 EQU   MAPREAD1
@RF00263 EQU   MAPREAD
@RT00267 EQU   EOF
@RT00282 EQU   CPUREC
@RT00290 EQU   CHKVOLS
@RT00292 EQU   SCANMAP
@RT00343 EQU   SETDATA
@RT00351 EQU   SAVELAST
@RC00382 EQU   @RC00381
@RC00386 EQU   @RC00381
@RT00404 EQU   CHKVOLS
@RT00424 EQU   VIRTPROC
@RT00426 EQU   REALPROC
@RT00429 EQU   VOLRESET
@RT00431 EQU   POINT2
@RT00436 EQU   POINT1
@RT00451 EQU   CHKREQ
@RT00455 EQU   ERREXT
@RT00457 EQU   ERREXT
@RF00459 EQU   @EL00001
@RT00465 EQU   ERREXT
@RT00470 EQU   ERREXT
@RT00474 EQU   FFFFCHK
@RT00478 EQU   CALCBLK
@RT00483 EQU   ERREXT
@RT00487 EQU   ERREXT
@RT00494 EQU   ERREXT
@RT00500 EQU   TTRTAPE
@RT00510 EQU   @EL00004
@RT00530 EQU   MAPSCN1
@RT00575 EQU   RDSYSUT1
@RC00580 EQU   DCBRET
@RT00602 EQU   @EL00007
@RC00617 EQU   @EL00008
@RT00621 EQU   PRINT
@ENDDATA EQU   *
         END   AMDPREAD,(C'PLS1317',0701,77069)
