         TITLE 'AMDPRFMT - LINE FORMAT ROUTINE'
AMDPRFMT CSECT
*A-000000-999999                                                @Y02006
* /* START OF SPECIFICATIONS ****
*
*01*  MODULE-NAME = AMDPRFMT
*
*02*     CSECT-NAME = AMDPRFMT
*
*01*  DESCRIPTIVE-NAME = AMDPRDMP/SNAP EXIT LINE FORMAT ROUTINE
*
*01*  COPYRIGHT = NONE
*
*01*  STATUS = VS2 RELEASE 02.0
*
*01*  FUNCTION = AMDPRFMT FORMATS 120 BYTE OUTPUT LINE WITH LABELS
*     AND/OR DATA FROM THE DUMP DATA SET OR CALLER'S STORAGE AS
*     SPECIFIED BY THE CALLER THROUGH FORMAT PATTERNS.  IT ALSO
*     TRANSLATES DATA TO PRINTABLE HEX IF REQUESTED.
*
*02*     OPERATION = UPON ENTRY, AMDPRFMT IS PASSED THE ADDRESS OF THE
*        ORIGINAL EXIT PARAMETER LIST AND THE ADDRESS OF THE FIRST
*        FORMAT PATTERN.
*        ONE OR MORE FORMAT PATTERNS MAY BE PASSED TO AMDPRFMT ON EACH
*        CALL, SO LONG AS THEY ARE CONTIGUOUS AND DELIMETED BY A WORD
*        OF ZEROS AFTER THE FINAL PATTERN.  BEFORE PROCESSING ANY
*        PATTERN, THE PARAMETER LIST IS CHECKED TO DETERMINE WHETHER
*        AMDPRDMP ISSUED THE LOAD FOR AMDPRFMT, AND IF SO, A GETMAIN IS
*        ISSUED FOR A SAVEAREA/WORKAREA. THIS IS REQUIRED IN THE EVENT
*        THAT AMDPRFMT HAS TO OBTAIN DATA TO BE FORMATTED FROM THE DUMP
*        DATA SET, NECESSITATING LINKAGE TO THE AMDPRDMP EXIT INTERFACE
*        MEMORY ACCESS ROUTINE.  EACH PATTERN IS THEN CHECKED IN TURN,
*        UNTIL THE WORD OF ZEROS IS REACHED.
*        IF A LABEL IS TO BE INCLUDED IN THE OUTPUT LINE, THE FOLLOWING
*        PROCESSING OCCURS:  THE LABEL LENGTH IS ADDED TO THE ADDRESS
*        OF THE OUTPUT LINE BUFFER PLUS THE REQUESTED OFFSET INTO THAT
*        LINE.  IF THE LABEL WILL EXTEND OVER THE END OF THE 120 BYTE
*        BUFFER, IT IS TRUNCATED SUFFICIENTLY TO FIT.  THE LABEL
*        POINTER IS THEN RETRIEVED FROM THE FORMAT PATTERN, UNLESS THIS
*        PATTERN CONTAINS NO LABEL POINTER, IN WHICH CASE THE SAVED
*        POINTER IN THE PARAMETER LIST FROM THE PREVIOUS LABEL, IS
*        USED.  THE NEW LABEL'S LENGTH IS ADDED TO THE LABEL POINTER
*        AND THE RESULT IS SAVED IN THE PARAMETER LIST.  THE CHARACTER
*        STRING BEGINNING AT THE LABEL POINTER IS MOVED TO THE
*        REQUESTED OFFSET INTO THE PRINT LINE FOR THE REQUESTED (OR
*        UPDATED IF TOO LONG) LENGTH.
*        IF DATA IS TO BE INCLUDED IN THE PRINT LINE, THE FOLLOWING
*        PROCESSING OCCURS:  THE DATA LENGTH AND PRINT LINE OFFSET ARE
*        VALIDITY CHECKED IN A MANNER SIMILAR TO THE ONE DESCRIBED
*        ABOVE, WITH THE EXCEPTION THAT, IF THE DATA MUST BE TRANSLATED
*        TO PRINTABLE HEX, THE RESULTANT DATA LENGTH IS EFFECTIVELY
*        DOUBLED.  NEXT, A DETERMINATION IS MADE AS TO WHETHER OR NOT
*        AMDPRFMT MUST INVOKE THE MEMORY ACCESS ROUTINE, ADDRESSED IN
*        THE PARAMETER LIST, TO OBTAIN THE DATA TO BE FORMATTED.  IF
*        THE CALLER WAS INVOKED THROUGH AMDPRDMP, THE PARAMETER LIST IS
*        CHECKED AS TO WHETHER THE DATA IS IN THE CALLER'S STORAGE OR
*        MUST BE READ FROM THE DUMP DATA SET.  IF THE CALLER WAS
*        INVOKED THROUGH SNAP, THEN AMDPRFMT DOES NOT CHECK THE
*        PARAMETER LIST BECAUSE THE DATA WILL BE IN EITHER THE CALLER'S
*        OR SNAP'S STORAGE AND CAN BE READ DIRECTLY.  IN THE EVENT THAT
*        AMDPRDMP'S MEMORY ACCESS ROUTINE IS CALLED, AMDPRFMT USES THE
*        SAVEAREA/WORKAREA FOR STANDARD LINKAGE AND A TEMPORARY READ
*        BUFFER.  THE REQUESTED ADDRESS IS READ FOR THE REQUESTED
*        LENGTH WITH SPECIAL CONSIDERATION OF BOUNDARIES AND LENGTHS
*        RETURNED SO AS NOT TO READ PAST A DUMP DATA SET 4K BLOCK
*        BOUND.  IF AT ANY TIME, THE AMDPRDMP MEMORY ACCESS ROUTINE
*        RETURNS A CODE OF 4 INDICATING AN UNSUCCESSFUL READ, AMDPRFMT
*        DOES THE FOLLOWING:  THE DATA ITEM CURRENTLY BEING PROCESSED
*        IS NOT MOVED TO THE OUTPUT LINE.  THE NEXT FORMAT PATTERN, IF
*        ANY, IS PROCESSED.  A CODE OF 4 IS RETURNED TO THE CALLER ON
*        COMPLETION. ONCE THE DATA HAS BEEN READ INTO THE WORKAREA,
*        PROCESSING BECOMES IDENTICAL TO THE CASE WHERE DATA IS ALREADY
*        IN THE CALLER'S (OR SNAP'S) STORAGE, AS FOLLOWS:
*        IF THE DATA IS ALREADY IN PRINTABLE HEX FORMAT, IT IS MOVED
*        ALL AT ONCE TO THE REQUESTED OFFSET INTO THE PRINT LINE.  IF
*        NOT, IT IS UNPACKED, FOUR BYTES AT A TIME WITH THE LAST UNPACK
*        <= 4 BYTES DEPENDING ON THE REQUESTED LENGTH, DIRECTLY INTO
*        THE PRINT LINE AT THE REQUESTED OFFSET FROM THE DATA POINTER
*        IN THE FORMAT PATTERN, OR FROM THE SAVED DATA POINTER IN THE
*        PARAMETER LIST.  THE UNPACK IS DONE IN SUCH A WAY THAT IT DOES
*        NOT REQUIRE THE USE OF A LOW ORDER PAD CHARACTER IN THE
*        RECEIVING FIELD SO THAT A USER MAY FORMAT SEGMENTS OF AN
*        OUTPUT LINE IN ANY ORDER.  A TRANSLATE IS DONE AFTER THE
*        ENTIRE STRING IS UNPACKED.  THIS COMPLETES PROCESSING FOR AN
*        INDIVIDUAL FORMAT PATTERN AND AMDPRFMT NEXT CHECKS FOR ANOTHER
*        PATTERN OR THE WORD OF ZEROS THE LATTER OF WHICH RESULTS IN
*        FREEING OF THE GETMAINED SAVE/WORK AREA IF ANY, AND RETURN TO
*        THE CALLER.
*
*01*   NOTES =
*
*02*     DEPENDENCIES = NONE THAT CANNOT BE RESOLVED BY RECOMPILATION.
*
*02*     RESTRICTIONS = NONE
*
*02*     REGISTER-CONVENTIONS = REGISTER SYMBOLS ARE DEFINED STARTING
*        AT SYMBOL R0.
*
*02*     PATCH-LABEL = PATCH. RESERVED FOR FUTURE USE.
*
*01*  MODULE-TYPE = PROCEDURE
*
*02*     PROCESSOR = ASSEMBLER
*
*02*     MODULE-SIZE = 0.7K BYTES
*
*02*     ATTRIBUTES = REENTRANT; RESIDES IN LPA.
*
*01*  ENTRY-POINT = AMDPRFMT
*
*02*     PURPOSE = MAIN AND ONLY ENTRY POINT.  ENTERED TO FORMAT ALL OR
*        PART OF AN OUTPUT LINE.
*
*02*     LINKAGE = STANDARD.
*
*02*     INPUT = GENERAL PURPOSE REGISTER 0 CONTAINS ADDRESS OF THE
*        FIRST FORMAT PATTERN.  GENERAL PURPOSE REGISTER 1 CONTAINS THE
*        ADDRESS OF THE ORIGINAL EXIT PARAMETER LIST PASSED TO THE EXIT
*        MODULE BY AMDPRDMP/SNAP.
*        THE FOLLOWING FIELDS IN THE EXIT PARAMETER LIST ARE
*        REFERENCED:
*
*             FIELD         PURPOSE OF REFERENCE
*
*             ADPLASID      ASID FOR READ BY AMDPRDMP
*                           MEMORY ACCESS ROUTINE.
*             ADPLSBPL      SUBPOOL NUMBER TO BE USED IF
*                           GETMAIN NECESSARY.
*             ADPLFLAG      BIT ZERO IS CHECKED TO DETERMINE
*                           IF LOADED BY AMDPRDMP OR SNAP.
*             ADPLBUF       POINTER TO CALLER'S OUTPUT LINE
*                           BUFFER.
*             ADPLMEMA      IF LOADED BY AMDPRDMP, THIS FIELD
*                           IS USED TO ACCESS AMDPRDMP'S
*                           MEMORY ACCESS ROUTINE.
*             ADPLFMT1      SAVE WORD FOR PREVIOUS LABEL POINTER.
*             ADPLFMT2      SAVE WORD FOR PREVIOUS DATA POINTER.
*
*             ALL FIELDS OF EACH FORMAT PATTERN ARE REFERENCED.
*
*02*     REGISTERS-SAVED = ALL
*
*02*     REGISTER-USAGE =
*             R0            ADDRESS FORMAT PATTERN ON ENTRY.
*             R1            ADDRESS PLIST ON ENTRY; MACRO INTERFACE.
*             R2            GENERAL WORK REGISTER.
*             R3            WORK REGISTER; REQUESTED LABEL/DATA LENGTH.
*             R4            GENERAL WORK REGISTER.
*             R5            INDEX INTO OUTPUT BUFFER.
*             R6            OUTPUT BUFFER DSECT BASE.
*             R7            GENERAL WORK REGISTER.
*             R8            FORMAT PATTERN DSECT BASE.
*             R9            LINK REGISTER; GENERAL WORK REGISTER.
*             R10           INDEX INTO FORMAT PATTERNS.
*             R11           AMDPRFMT BASE REGISTER.
*             R12           PLIST DSECT BASE.
*             R13           SAVEAREA POINTER.
*             R14           RETURN ADDRESS.
*             R15           RETURN CODE.
*
*02*     REGISTERS-RESTORED = ALL BUT R15.
*
*01*  EXIT-NORMAL =
*
*02*     CONDITIONS = CONTROL IS RETURNED TO THE CALLER FROM THIS POINT
*        IF AMDPRFMT WAS SUCCESSFUL IN FORMATTING ALL LABEL AND DATA
*        ITEMS INDICATED IN THE FORMAT PATTERNS FOR THIS CALL. I.E. ALL
*        READS FROM THE AMDPRDMP DUMP DATA SET WERE SUCCESSFUL.  THIS
*        EXIT IS TAKEN EVEN IF ANY LABEL OR DATA ITEM MUST BE TRUNCATED
*        DUE TO OUTPUT BUFFER OVERFLOW.
*
*02*     OUTPUT = THE OUTPUT BUFFER ADDRESSED BY THE PARAMETER LIST IS
*        FORMATTED WITH THE REQUESTED LABELS AND DATA.  THE LABEL AND
*        DATA POINTER FIELDS IN THE PARAMETER LIST (ADPLFMT1 AND
*        ADPLFMT2) ARE UPDATED WITH THE DEFAULT POINTERS TO BE USED ON
*        THE NEXT CALL OF AMDPRFMT IN THE EVENT THAT THEY ARE NOT
*        SUPPLIED IN THE NEXT FORMAT PATTERN.
*
*02*     RETURN-CODES = REGISTER 15 = 0.
*
*01*  EXIT-ERROR =
*
*02*     CONDITIONS = CONTROL IS RETURNED TO THE CALLER FROM THIS POINT
*        IF AMDPRFMT WAS NOT COMPLETELY SUCCESSFUL IN FORMATTING ALL
*        DATA ITEMS INDICATED IN THE FORMAT PATTERNS FOR THIS CALL.
*        I.E. AT LEAST ONE READ FROM THE AMDPRDMP DUMP DATA SET
*        RESULTED IN A RETURN CODE OF 4 FROM THE AMDPRDMP MEMORY ACCESS
*        ROUTINE.  THIS EXIT WILL NEVER BE TAKEN WHEN AMDPRFMT IS
*        LOADED BY SNAP.
*
*02*     OUTPUT = THE OUTPUT BUFFER ADDRESSED BY THE PARAMETER LIST
*        WILL BE FORMATTED WITH ALL LABEL ITEMS SPECIFIED IN THE FORMAT
*        PATTERNS, AND ALL DATA ITEMS THAT COULD BE SUCCESSFULLY READ
*        FROM THE AMDPRDMP DUMP DATA SET.
*
*02*     RETURN-CODES = REGISTER 15 = 4.
*
*01*  EXTERNAL-REFERENCES =
*
*02*     ROUTINES =
*             AMDMEMAR      THE AMDPRDMP MEMORY ACCESS ROUTINE IN
*                           AMDPRUIM IS CALLED TO READ DATA FROM
*                           THE DUMP DATA SET.
*
*02*     DATA-AREAS = AMDPRDMP/ABDUMP PARAMETER LIST; FORMAT PATTERNS.
*                           REFERENCE INPUT UNDER ENTRY POINT
*                           SECTION.
*
*02*     CONTROL-BLOCKS = NONE
*
*01*  TABLES =
*             FMTREAD       A 16 BYTE WORK AREA TO CONTAIN DATA READ
*                           FROM THE AMDPRDMP DUMP DATA SET.
*             FMTLN4A       A 16 BYTE TRANSLATE TABLE USED TO TRANSLATE
*                           HEX CHARACTERS A-F TO PRINTABLE HEX.
*01*  MACROS = GETMAIN
*              FREEMAIN
*
*02*     SERIALIZATION = NONE
*
*01*  CHANGE-ACTIVITY = Y02006
*
*01*  MESSAGES = NONE
*
*01*  ABEND-CODES = NONE
*
**** END OF SPECIFICATIONS ***/
*/*AMDPRFMT: CHART (AMODE,SEQ) */
*/*HEADER
*/*AMDPRFMT - AMDPRDMP/ABDUMP LINE FORMAT ROUTINE
*/*                                                      PAGE #    */
*/*AMDPRFMT: E AMDPRDMP/ABDUMP LINE FORMAT ROUTINE */
*/*  N THIS ROUTINE FORMATS A LINE USING A FORMAT PATTERN */
*/*  M SET UP ADDRESSABILITY */
*/* P SET UP BASE FOR PLIST MAPPING (R12) */
*/* P SET RET CODE =0 FOR IMMEDIATE RETURN IF NO PATRNS */
*/*  P PUT PATTERN ADDRESS IN REG 8 FOR BASING & TEST FOR 0 */
*/* D (YES,,NO,FMTLNRT3) IS THERE A PATTERN? */
*/* P SET UP BASE FOR PATTERN MAPPING */
*/*  P GET OUTPUT BUFFER ADDRESS FROM PLIST */
*/* P SET UP BASE FOR OUTPUT BUFFER MAPPING */
*/* D (YES,,NO,FMTLNLP) TEST ADPLFLAG- LOAD BY PRDMP? */
*/* L GETMAIN FOR FMTSAVE AREA & WORK AREA */
*/* N USE SUBPOOL FROM PLIST */
*/* P STD SAVE AREA LINKAGE */
*/* P BASE WORK AREAS ON R13 */
*/* M INITIALIZE AMDPRFMT RETURN CODE SW OFF */
*/*FMTLNLP: P ZERO INDEX REG FOR PATTERN */
*/*  D (YES,FMTLNRT,NO,) IS PATTERN CODE = 0? END OF PTRNS */
*/*  D (YES,FMTLN1,NO,) IS THERE A LABEL? */
*/*FMTLNA: D (YES,FMTLN2,NO,) IS THERE DATA? */
*/*FMTLNB: P (,FMTLNLP) UPDATE PATTERN BASE TO POINT TO NEXT PATTERN */
*/*FMTLN1: N MOVE LABEL TO OUTPUT BUFFER */
*/*  P GET LENGTHS FROM PATTERN */
*/* P AND OFF DATA LENGTH FOR LABEL LEN ONLY */
*/*  D (YES,%L2,NO,) IS THERE A LABEL POINTER? */
*/*FMTLN1A: P (,FMTLN1B) P GET LABEL PTR FROM FMT SAVE WORD IN PLIST */
*/*%L2: P GET LABEL PTR FROM PATTERN */
*/*   P ADD 4 TO INDEX REGISTER */
*/*FMTLN1B: P UPDATE PTR TO THE NEXT LABEL AND STORE IT BACK IN PLIST
*/**/
*/*  P GET LABEL OFFSET INTO OUTPUT BUFFER FROM PATTERN */
*/*  P GET ADDR OF WHERE TO PUT LABEL IN BUFFER */
*/* D (YES,,NO,%ML1) IS THIS ADDR OVER END OF BUFFER? */
*/* N (,FMTLNB) DO NOT FORMAT LABEL */
*/*%ML1: P ADD LEN OF LABEL TO BUFFER ADDR + OFFSET */
*/* D (YES,,NO,%ML2) IS RESULT OVER END OF BUFFER? */
*/* P SUBTRACT AMOUNT OF OVERFLOW FROM ORIGINAL LENGTH */
*/*%ML2:  P (,FMTLNA) EX TO MOVE VAR LEN LABEL TO OUTPUT BUFFER */
*/*FMTLN2: N PUT DATA IN PRINT LINE */
*/*  P GET LENGTHS FROM PATTERN */
*/* P AND OFF LABEL LENGTH FOR DATA LENGTH ONLY */
*/* P INCR BY 1 FOR TRUE LENGTH */
*/*  D (YES,,NO,FMTLN2A) IS THERE A DATA PTR? */
*/*  P GET DATA PTR FROM PATTERN */
*/*  P (,FMTLN2B) ADD 4 TO PATTERN INDEX REGISTER */
*/*FMTLN2A: P GET DATA PTR FROM FMT SAVE WORD IN PLIST */
*/*FMTLN2B: P UPDATE PTR TO NEXT DATA AND STORE IT BACK IN PLIST */
*/*  P GET DATA OFFSET FROM PATTERN */
*/* D (YES,,NO,%ML3) WAS FMT LOADED BY ABDUMP? */
*/* N (,FMTLN3) DATA IS DEFINITELY IN CORE */
*/*%ML3: N LOAD BY PRDMP- DATA MAY NOT BE IN CALLERS STORAGE */
*/*  D (YES,,NO,%ML4) IS DATA IN STORAGE? */
*/* N (,FMTLN3) DATA IS IN CALLERS STORAGE */
*/*%ML4: N MUST CALL MEMORY ACCESS RTN TO READ THE DUMP */
*/* N IF DATA IS NOT ALREADY IN EBCDIC, SET TARGET OF MOVE */
*/* N FROM READ AREA TO 16 BYTE WORK AREA */
*/* N IF DATA IS ALREADY IN EBCDIC, THEN SET TARGET OF MOVE */
*/* N DIRECTLY TO OUTPUT BUFFER */
*/*  P GET ADDRESS OF WORK AREA FOR READ TARGET */
*/*  D (YES,,NO,FMTLN2C) IS DATA ALREADY IN EBCDIC? */
*/*  P GET ADDRESS OF WHERE TO PUT DATA IN BUFFER FOR READ TARGET */
*/* D (YES,,NO,%ML5) THIS ADDR OVER END OF BUFFER? */
*/* N (,FMTLNB) DO NOT FORMAT DATA */
*/*%ML5: P ADD LEN OF DATA TO BUF ADDR + OFFSET */
*/* D (YES,,NO,FMTLN2C) IS RESULT OVER END OF BUFFER? */
*/* P SUBTRACT AMOUNT OF OVERFLOW FROM ORIGINAL LENGTH */
*/*FMTLN2C: P SAVE REGS 2 - 3 */
*/*FMTLN2D:  P PUT ADDR TO BE READ IN REG 0 (FROM R7) */
*/* P RESET PLIST ADDR IN R1 */
*/* L CALL MEMORY ACCESS RTN - READ FOR THE DATA */
*/*  N AT MOST ONLY 4 BYTES OF DATA ARE ASSURED TO BE VALID */
*/* D (YES,FMTLN2D1,NO,) MEMORY ACCESS RTN SUCCESSFUL? */
*/* M (,FMTLNB) INDICATE ONE OF THE READS FAILED & QUIT THIS PTRN */
*/*FMTLN2D1: P POINT R1 TO DATA JUST READ */
*/*  P CALCULATE NUMBER OF BYTES THAT CAN BE MOVED */
*/*  D (YES,FMTLN2E,NO,) IS NUMBER OF BYTES < 4? */
*/*  P PUT 4 IN LENGTH REGISTER */
*/*FMTLN2E: P DECREMENT LENGTH TO BE MOVED FROM REMAINING LENGTH */
*/*  D (YES,,NO,FMTLN2F) RESULT > 0? */
*/*  P INCREMENT 'FROM' ADDRESS */
*/*  P MOVE DATA TO AREA */
*/*  P (,FMTLN2D) INCREMENT 'TOO' ADDRESS */
*/*FMTLN2F: P ADD SUBTRACTED VALUE BACK TO LENGTH */
*/*  D (YES,FMTLN2G,NO,) IS RESULT = 0? */
*/*  P MOVE LAST PART OF DATA */
*/*FMTLN2G: P RESTORE REGISTERS 2 - 3 */
*/*  D (YES,FMTLNB,NO,) IS DATA ALREADY IN EBCDIC? */
*/*FMTLN2H: P GET ADDRESS OF WHERE TO PUT DATA IN BUFFER */
*/* D (YES,,NO,%ML6) THIS ADDR OVER END OF BUFFER? */
*/* N (,FMTLNB) DO NOT FORMAT DATA */
*/*%ML6: P ADD TWICE THE LEN OF DATA TO BUFFER ADDR + OFFSET */
*/* D (YES,,NO,FMTLN2I) IS RESULT OVER END OF BUFFER? */
*/* P DETERMINE HOW MUCH OVER */
*/* N CONVERT TO INPUT BYTES ROUNDED TO BYTE BOUNDARY */
*/* P ADD 1 & DIVIDE BY 2 */
*/* P SUBTRACT CONVERTED EXISS VALUE FROM ORIG INPUT LEN */
*/* D (YES,,NO,FMTLN2I) IS TRUNCATED LENGTH = 0? */
*/* N (,FMTLNB) DO NOT FORMAT DATA */
*/*FMTLN2I: S (,FMTLNB) FMTLN4: TRANSLATE TO PRINTABLE HEX */
*/*FMTLN3: P SET UP DATA 'FROM' ADDRESS FOR HEXCNVT IF NOT IN EBCDIC */
*/*  D (YES,,NO,FMTLN2H) IS DATA ALREADY IN EBCDIC? */
*/*  P MOVE DATA 'FROM' ADDRESS TO PREG */
*/*  P GET ADDR OF WHERE TO PUT DATA IN BUFFER */
*/* D (YES,,NO,%ML8) IS THIS ADDR OVER END OF BUF? */
*/* N (,FMTLNB) DO NOT FORMAT DATA */
*/*%ML8: P ADD LENGTH OF DATA TO BUFFER ADDR + OFFSET */
*/* D (YES,,NO,FMTLN3A) IS RESULT OVER END OF BUFFER? */
*/* P SUBTRACT AMOUNT OF OVERFLOW FROM ORIGINAL LENGTH */
*/*FMTLN3A:  P DECREMENT LENGTH FOR EX MOVE DATA */
*/*  P (,FMTLNB) MOVE EBCDIC DATA TO BUFFER */
*/*FMTLN4: E PRINT HEX CONVERT */
*/* D (YES,,NO,%ML10) IS LENGTH = 0? */
*/* N (,FMTLN4H) DO NOTHING */
*/*%ML10: P SAVE LOW ORDER 2 BITS OF LENGTH */
*/* P DIVIDE LENGTH BY 4 */
*/* D (YES,FMTLN4F,NO,) TOTAL LENGTH LESS THAN 4? */
*/*FMTLN4E: P UNPACK 4 BYTES INTO 7 BYTES OF BUFFER */
*/* P UNPACK LAST BYTE PREVIOUSLY UNPKED INTO 8TH BYTE OF BUF */
*/* P OR LAST 2 BYTES (7TH & 8TH) WITH 'F0F0' */
*/* P INCR BUFFER PTR BY 8 */
*/* P INCR SOURCE PTR BY 4 */
*/* P DECR COUNT OF GROUPS OF 4 BYTES */
*/* D (YES,FMTLN4F,NO,FMTLN4E) PROCESSED LAST GROUP? */
*/*FMTLN4F: D (YES,,NO,%ML11) ARE SAVED BITS = 0? */
*/* N (,FMTLN4G) NO <4 INPUT BYTE GROUP TO FORMAT */
*/*%ML11: N FORMAT LAST (OR ONLY) GROUP OF <4 INPUT BYTES */
*/* P DECR REMAIN LENGTH BY 1 FOR EXEC */
*/* P DOUBLE LEN FOR EX TARGET */
*/* P SHIFT TARGET LENGTH 4 BITS LEFT IN EX REG */
*/* P INSERT SOURCE LEN IN LOW 4 BITS OF EX REG */
*/* P EX UNPACK REMAIN <4 BYTE GROUP */
*/* P INCR BUFFER PTR TO LAST BYTE JUST UNPKED */
*/* P UNPACK LAST BYTE PREVIOUSLY UNPKED INTO NEXT BYTE */
*/* P OR LAST 2 BYTES WITH 'F0F0' */
*/* P ADJUST BUFFER PTR PAST LAST BYTE (ADD 2) */
*/*FMTLN4G: P AGAIN DOUBLE LENGTH FOR TRANSLATE */
*/* P RE ESTABLISH BUFFER PTR TO BEGIN OF FIELD */
*/* P DECR LENGTH FOR EX */
*/* P EX TRANSLATE OF FA - FF */
*/*FMTLN4H: R RETURN ON R9 */
*/*FMTLNRT: D (YES,,NO,FMTLNRT2) LOADED BY PRDMP? */
*/* P INITIALLY INDICATE RETURN CODE 0 REQD */
*/* D (YES,,NO,FMTLNRT1) ANY READ ERRORS THIS CALL? */
*/* P INDICATE RETURN CODE 4 REQD */
*/*FMTLNRT1: M SET UP FOR FREEMAIN */
*/* P RESTORE SAVEAREA LINKAGE */
*/* L FREE GETMAINED SAVE/WORK AREA */
*/* P (,FMTLNRT3) MOVE INDICATED RET CODE TO R15 */
*/*FMTLNRT2: P SET CODE OF 0 IN R15 */
*/*FMTLNRT3: P RESTORE REGS EXCEPT R15 */
*/*  R RETURN */
*/*AMDPRFMT: END */
         EJECT
***********************************************************************
*                                                                     *
*         THIS IS THE GENERAL FORMAT ROUTINE .  INPUT                 *
*         TO THIS ROUTINE IS A LIST OF FORMAT PATTERNS, EACH          *
*         DESCRIBES THE POSITION OF A DATA ITEM IN THE OUTPUT         *
*         LINE AND A LABEL WHICH IDENTIFIES THAT DATA ITEM.  THE      *
*         ENTIRE LIST THUS DESCRIBES THE FORMAT OF A LINE OF          *
*         OUTPUT.  AMDPRFMT FORMATS SUCH A LINE IN THE EXIT           *
*         INTERFACE OUTPUT BUFFER, READY FOR PRINTING.  THE           *
*         FOLLOWING IS THE FORMAT OF A PATTERN ENTRY...               *
*                                                                     *
*            0 ****************************************               *
*              *  CODE  * LBL* DTA*  LABEL  *  DATA   *               *
*              *  BYTE  * LN * LN * OFFSET  * OFFSET  *               *
*            4 ****************************************               *
*              *   POINTER TO LABEL                   *               *
*              *    (IF PRESENT)                      *               *
*            8 ****************************************               *
*              *   POINTER TO DATA                    *               *
*              *    (IF PRESENT)                      *               *
*              ****************************************               *
*                                                                     *
*          CODE BYTE DESCRIPTION...                                   *
*           BIT   MEANING                                             *
*            0    UNUSED                                              *
*            1    UNUSED                                              *
*            2    DATA IS EBCDIC                                      *
*            3    DATA IS IN CORE                                     *
*            4    THERE IS A DATA POINTER                             *
*            5    DATA IS TO BE PLACED ON PRINT LINE                  *
*            6    THERE IS A LABEL POINTER                            *
*            7    A LABEL IS TO BE INCLUDED ON PRINT LINE             *
*                                                                     *
*         IF LABEL AND DATA POINTERS DON'T EXIST THE PATTERN ENTRY    *
*         WILL ONLY BE 4 BYTES LONG.  IF EITHER POINTER IS OMITTED THE*
*         ROUTINE WILL USE THE ADDRESS OF THE LAST LABEL OR DATA      *
*         PLUS IT'S LENGTH FOR THE NEXT LABEL OR DATA ADDRESS.        *
*         THE LAST ENTRY IN A PATTERN WILL BE FOLLOWED BY A BYTE OF   *
*         ZEROS.                                                      *
*                                                                     *
***********************************************************************
         EJECT
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         SPACE
         STM   R14,R12,12(R13)     STORE CALLER'S REGS
         BALR  R11,0               ESTABLISH REG 11 AS BASE
         USING *,R11
         MODID
         SPACE
         LR    R12,R1              REGISTER 12 WILL
         USING ABDPL,R12           ADDRESS EXIT PARAMETER LIST
         SR    R15,R15             SET 0 RET CODE IN CASE NO PATTERNS
         LTR   R8,R0               PATTERN ADDR TO R8 FOR BASE
         BZ    FMTLNRT3            IF NOT PATTERN, EXIT
         USING FMTPTRN,R8          ADDRESS FORMAT PATTERN MAP
         L     R6,ADPLBUF          GET OUTPUT BUFFER ADDR
         USING OUTBUF,R6           ADDRESS OUTPUT BUFFER MAP
         TM    ADPLFLAG,ADPLSNPR   WERE WE LOADED BY PRDMP?
         BZ    FMTLNLP             NO- DONT NEED GETMAINED WORK AREA
         SPACE
***********************************************************************
*                                                                     *
*    LOADED BY AMDPRDMP; NEED GETMAINED SAVE/WORK AREA                *
*                                                                     *
***********************************************************************
         SPACE
         LA    R0,GETMLEN          SET LENGTH OF GETMAIN
         ICM   R0,B'1000',ADPLSBPL SET UP SUBPOOL NUMBER
         GETMAIN R,LV=(0)          GET SAVE/WORK AREA
         ST    R13,4(R1)           SAVE AREA LINKAGE
         ST    R1,8(R13)
         LR    R13,R1
         USING FMTSWMAP,R13        ADDRESS SAVE/WORK AREA MAP
         MVI   FMTSWS,X'00'        INITIALIZE FMT RET CODE SW OFF
         SPACE
***********************************************************************
*                                                                     *
*    PROCESS STRING OF PATTERNS                                       *
*                                                                     *
***********************************************************************
         SPACE
FMTLNLP  SR    R10,R10             ZERO INDEX REG
         TM    PTRNCD,X'FF'        TEST FOR END OF PATTERN
         BZ    FMTLNRT             YES--RETURN TO CALLER
         TM    PTRNCD,LBL          TEST FOR LABEL FOR THIS ENTRY
         BO    FMTLN1              YES--GO MOVE TO LABEL TO OUTPUT BUFF
FMTLNA   TM    PTRNCD,DTA          TEST FOR DATA FOR THIS ENTRY
         BO    FMTLN2              YES--PUT DATA INTO OUTPUT BUFFER
FMTLNB   LA    R8,4(R10,R8)        UPDATE PATTERN BASE TO NEXT ENTRY
         B     FMTLNLP             LOOP FOR ALL PATTERN ENTRIES
         SPACE 2
***********************************************************************
*                                                                     *
*                                                                     *
*   MOVE LABEL TO OUTPUT BUFFER                                       *
*                                                                     *
*                                                                     *
***********************************************************************
         SPACE
FMTLN1   IC    R3,PTRNLN           GET LENGTHS
         N     R3,LN1MSK           AND FOR LABEL LN ONLY
         SRL   R3,4                SHIFT TO LOW DIGIT OF REG
         TM    PTRNCD,LBLP         IS THERE A LABEL POINTER
         BZ    FMTLN1A             NO--BR AROUND
         L     R7,PTRNPTR          YES--LOAD IT INTO R7
         LA    R10,4(R10)          ADD LN OF PTR TO INDEX
         B     FMTLN1B             BR AROUND
FMTLN1A  L     R7,ADPLFMT1         LOAD ADDR OF NEXT LABEL
FMTLN1B  LA    R4,1(R7,R3)         INCR NEXT LABEL ADDR
         ST    R4,ADPLFMT1         STORE IT BACK
         SR    R4,R4               CLEAR FOR IC
         IC    R4,PTRNOFF1         GET OFFSET INTO LINE OF LABEL
         LA    R4,ADDR(R4)         ADDR OF WHERE TO PUT LABEL ON LINE
         LA    R1,OVRFLOW          ADDR OF 1ST CHAR OVER BUFFER END
         CR    R4,R1               IS HE POINTING ME OUTSIDE BUFFER?
         BNL   FMTLNA              YES, DO NOT FORMAT LABEL
         LA    R9,1(R4,R3)         ADD LENGTH TO BUFFER ADDR + OFFSET
         CR    R9,R1               IS RESULT OUTSIDE OF BUFFER?
         BNH   FMTLN1C             NO- GO AHEAD AND MOVE LABEL
         SPACE
***********************************************************************
*                                                                     *
*     PART OF LABEL IS OUTSIDE OF BUFFER- TRUNCATE IT.                *
*                                                                     *
***********************************************************************
         SPACE
         SR    R9,R1               DETERMINE HOW MUCH WENT OVER
         SR    R3,R9               TRUNCATE ORIGINAL LENGTH
FMTLN1C  EX    R3,LBLMOVE          MOVE LABEL TO PRINT LINE
         B     FMTLNA              CONTINUE
         SPACE 2
***********************************************************************
*                                                                     *
*                                                                     *
*   PLACE DATA INTO PRINT LINE                                        *
*                                                                     *
*                                                                     *
***********************************************************************
         SPACE
FMTLN2   IC    R3,PTRNLN           GET LENGTHS
         N     R3,LN2MSK           AND OFF ALL BUT LAST DIGIT
         LA    R3,1(R3)            INCR TO REAL LENGTH
         TM    PTRNCD,DTAP         IS THERE A DATA PTR
         BZ    FMTLN2A             BR IF NOT
         L     R7,PTRNPTR(R10)     YES--LOAD PTR TO DATA
         LA    R10,4(R10)          ADD LN OF PTR TO INDEX REG
         B     FMTLN2B             BR AROUND
FMTLN2A  L     R7,ADPLFMT2         LOAD ADDR OF NEXT DATA
FMTLN2B  LA    R4,0(R7,R3)         UPDATE TO NEXT DATA ADDR
         ST    R4,ADPLFMT2         PUT IT BACK
         SR    R4,R4               CLEAR OFFSET REG
         IC    R4,PTRNOFF2         LOAD OFFSET OF DATA INTO PRINT LINE
         TM    ADPLFLAG,ADPLSNPR   WERE WE LOADED BY ABDUMP?
         BZ    FMTLN3              YES- DATA IS IN CORE- NO READS REQD
         SPACE
***********************************************************************
*                                                                     *
*   LOADED BY AMDPRDMP- DATA MAY OR MAY NOT BE IN CORE- CHECK PATTERN *
*                                                                     *
***********************************************************************
         SPACE
         TM    PTRNCD,DTAC         IS DATA ALREADY IN CORE?
         BO    FMTLN3              YES- MOVE DIRECTLY - NO NEED TO
*                                  CALL MEMORY ACCESS ROUTINE
         SPACE
***********************************************************************
*                                                                     *
*   DATA MUST BE READ FROM DUMP VIA MEMORY ACCESS ROUTINE.            *
*   IF DATA IS ALREADY IN EBCDIC, THEN SET TARGET OF MOVE FROM        *
*   READ AREA DIRECTLY TO OUTPUT BUFFER.  IF DATA IS NOT ALREADY      *
*   IN EBCDIC, SET TARGET OF MOVE TO 16 BYTE GETMAINED WORKAREA.      *
*                                                                     *
***********************************************************************
         SPACE
         TM    PTRNCD,DTAE         IS DATA ALREADY IN EBCDIC?
         LA    R2,FMTREAD          SET MOVE TARGET TO WORK AREA
         BZ    FMTLN2C             NO- NOT ALREADY EBCDIC- KEEP R2
         LA    R2,ADDR(R4)         YES- ALREADY EBCDIC- SET MOVE TARGET
*                                  DIRECTLY TO OUTPUT BUFFER
         SPACE
***********************************************************************
*                                                                     *
*   SINCE MOVING DIRECTLY TO OUTPUT BUFFER- CHECK LENGTHS & INSURE    *
*   DATA DOES NOT FALL OUTSIDE OF BUFFER                              *
*                                                                     *
***********************************************************************
         SPACE
         LA    R1,OVRFLOW          ADDR OF 1ST CHAR OVER BUFFER END
         CR    R2,R1               IS HE POINTING ME OUTSIDE BUFFER?
         BNL   FMTLNB              YES- DO NOT FORMAT DATA
         LA    R9,0(R2,R3)         ADD LENGTH TO BUFFER ADDR + OFFSET
         CR    R9,R1               IS RESULT OUTSIDE OF BUFFER?
         BNH   FMTLN2C             NO- GO AHEAD AND MOVE DATA
         SPACE
***********************************************************************
*                                                                     *
*   PART OF DATA IS OUTSIDE OF BUFFER- TRUNCATE IT.                   *
*                                                                     *
***********************************************************************
         SPACE
         SR    R9,R1               DETERMINE HOW MUCH WENT OVER
         SR    R3,R9               TRUNCATE ORIGINAL LENGTH
         SPACE
***********************************************************************
*                                                                     *
*   PREPARE TO READ DATA FROM THE DUMP VIA MEMORY ACCESS RTN          *
*                                                                     *
***********************************************************************
         SPACE
FMTLN2C  STM   R2,R3,FMTRDSV       SAVE ACROSS THE READ
FMTLN2D  LR    R0,R7               ADDR TO BE READ IN PARM REGISTER
         LR    R1,R12              RESTORE PLIST REG
         L     R15,ADPLMEMA        GET ADDR OF MEMORY ACCESS FROM PLIST
         BALR  R14,R15             CALL MEMORY ACCESS ROUTINE
         LTR   R15,R15             WAS READ SUCCESSFUL?
         BZ    FMTLN2D1            YES- CONTINUE
         SPACE
***********************************************************************
*                                                                     *
*   READ VIA THE MEMORY ACCESS ROUTINE WAS UNSUCCESSFUL.              *
*   INDICATE A RETURN OF 4 IN R15 WILL BE REQUIRED ON EXIT.           *
*   DISCONTINUE PROCESSING OF THIS PATTERN, & CONTINUE WITH THE NEXT  *
*   PATTERN, IF ANY.                                                  *
*                                                                     *
***********************************************************************
         SPACE
         OI    FMTSWS,MEMAERR      INDICATE ONE BAD READ
         B     FMTLNB              CONTINUE WITH NEXT PATTERN, IF ANY
FMTLN2D1 LR    R1,R0               POINT R1 TO DATA JUST READ
         LCR   R5,R7               COMPLIMENT ADDR
         N     R5,LN3MSK           AND OFF ALL BUT LAST 2 BITS
         BNZ   FMTLN2E             BR IF NOT ZERO (LN IN R5)
         LA    R5,4                ZERO--USE A LN OF 4
FMTLN2E  SR    R3,R5               SUBTRACT LN TO BE MOVED FROM
*                                  REMAINING LENGTH
         BNP   FMTLN2F             BR IF REMAINING LN EQ OR LT 0 FOR
*                                  LAST MOVE
         AR    R7,R5               INCR 'FROM' ADDR
         BCTR  R5,0                DECR LN OF MOVE FOR EX
         EX    R5,DTAMOVE1         MOVE DATA
         LA    R2,1(R5,R2)         INCR 'TOO' ADDR
         B     FMTLN2D             LOOP FOR ALL DATA TO BE MOVED
         SPACE
FMTLN2F  AR    R3,R5               ADD BACK SUBTRACTED VAL TO LN
         BZ    FMTLN2G             ALL DONE IF ZERO
         BCTR  R3,0                DECR 1 FOR EX
         EX    R3,DTAMOVE1         DO LAST MOVE
FMTLN2G  LM    R2,R3,FMTRDSV       RESTORE REGS R2 - R3
         TM    PTRNCD,DTAE         IS DATA EBCDIC
         BO    FMTLNB              YES--DONE WITH DATA FOR THIS PATTERN
*                                  ENTRY IF SO
         SPACE
FMTLN2H  LA    R5,ADDR(R4)         ADDR OF WHERE IN BUFFER TO PUT
*                                  DATA
         LA    R1,OVRFLOW          ADDR OF 1ST CHAR OVER BUFFER END
         CR    R5,R1               IS HE POINTING ME OUTSIDE BUFFER?
         BNL   FMTLNB              YES- DO NOT FORMAT DATA
         LA    R9,0(R5,R3)         ADD LENGTH TO BUFFER ADDR + OFFSET
         AR    R9,R3               AGAIN ADD LENGTH FOR PRINTABLE HEX
         CR    R9,R1               IS RESULT OUTSIDE OF BUFFER?
         BNH   FMTLN2I             NO- GO AHEAD AND CONVERT DATA
         SPACE
***********************************************************************
*                                                                     *
*   PART OF CONVERTED DATA IS OUTSIDE OF BUFFER- TRUNCATE THE INPUT   *
*   (I.E. ONE HALF THE CONVERTED) LENGTH.                             *
*                                                                     *
***********************************************************************
         SPACE
         SR    R9,R1               DETERMINE HOW MUCH WENT OVER
         LA    R9,1(R9)            INCREMENT BY ONE AND
         SRL   R9,1                DIVIDE BY 2 TO OBTAIN AMOUNT BY
*                                  WHICH THE INPUT LENGTH SHOULD BE
*                                  TRUNCATED. (BYTE BOUNDARY)
         SR    R3,R9               TRUNCATE ORIGINAL LENGTH
         LTR   R3,R3               INSURE TRUNCATED LENGTH ISNT 0
         BZ    FMTLNB              ZERO- CANT FORMAT THIS DATA
FMTLN2I  BAL   R9,FMTLN4           CONVERT DATA TO PRINTABLE HEX
         B     FMTLNB              DONE WITH DATA FOR THIS PTRN ENTRY
         SPACE
FMTLN3   LR    R2,R7               DATA 'FROM' ADDR TO R2
         TM    PTRNCD,DTAE         IS DATA ALREADY IN EBCDIC?
         BZ    FMTLN2H             NO--GO CONVERT TO HEX
         LA    R2,ADDR(R4)         DATA 'TOO' ADDR TO R2
         LA    R1,OVRFLOW          ADDR OF 1ST CHAR OVER BUFFER END
         CR    R2,R1               IS HE POINTING ME OUTSIDE BUFFER?
         BNL   FMTLNB              YES- DO NOT FORMAT DATA
         LA    R9,0(R2,R3)         ADD LENGTH TO BUFFER ADDR + OFFSET
         CR    R9,R1               IS RESULT OUTSIDE OF BUFFER?
         BNH   FMTLN3A             NO- GO AHEAD AND MOVE DATA
         SPACE
***********************************************************************
*                                                                     *
*   PART OF DATA IS OUTSIDE OF BUFFER- TRUNCATE IT.                   *
*                                                                     *
***********************************************************************
         SPACE
         SR    R9,R1               DETERMINE HOW MUCH OVER
         SR    R3,R9               TRUNCATE ORIGINAL LENGTH
FMTLN3A  BCTR  R3,0                DECR LN FOR EXECUTE
         LR    R1,R7               DATA 'FROM' ADDR TO PREG
         EX    R3,DTAMOVE1         MOVE EBCDIC DATA TO BUFFER
         B     FMTLNB              CONTINUE WITH NEXT ENTRY IN PATTERN
         SPACE
***********************************************************************
*                                                                     *
*   CONVERT DATA TO PRINTABLE HEX                                     *
*                                                                     *
***********************************************************************
         SPACE
FMTLN4   LTR   R1,R3               MAKE SURE LENGTH ISNT ZERO
         BZ    FMTLN4H             ZERO- DO NOTHING
         LA    R0,3                SET UP MASK
         NR    R0,R1               AND SAVE 2 LOW ORDER BITS
         SRL   R1,2                DIVIDE BY 4
         LTR   R1,R1               LENGTH LESS THAN 4?
         BZ    FMTLN4F             IF YES--BRANCH
FMTLN4E  UNPK  0(7,R5),0(4,R2)     UNPACK HEX DIGITS
         UNPK  7(1,R5),6(1,R5)     UNPACK 2ND LAST INTO LAST
         OC    6(2,R5),LN4MSK      FIX THE ZONES
         LA    R5,8(R5)            INCREMENT BUF INDEX REG
         LA    R2,4(R2)            INCREMENT INPUT SOURCE PTR
         BCT   R1,FMTLN4E          LOOP THRU GROUPS OF 4 BYTES
FMTLN4F  LTR   R0,R0               TEST SAVED BITS
         BZ    FMTLN4G             BRANCH IF NO <4 BYTE GROUP
         BCTR  R0,0                DECREMENT FOR EXECUTE
         LR    R1,R0               ADJUST R1
         AR    R1,R0               FOR EXECUTE INSTRUCTION
         SLL   R1,4
         OR    R1,R0
         EX    R1,FMTLN4C          EXECUTE UNPACK
         SRL   R1,4
         AR    R5,R1
         UNPK  1(1,R5),0(1,R5)     UNPK 2ND LAST INTO LAST
         OC    0(2,R5),LN4MSK      FIX THE ZONES
         LA    R5,2(R5)            ADJUST PAST END OF LAST UNPKED BYTE
FMTLN4G  AR    R3,R3               SET UP LENGTH FOR
*                                  TRANSLATE INSTRUCTION
         SR    R5,R3               RE-EXTABLISH BEGINNING OF FIELD
         BCTR  R3,0                DECR LN 1 FOR EXECUTE INSTR
         EX    R3,FMTLN4D          EXECUTE TRANSLATE
FMTLN4H  BR    R9                  RETURN TO CALLER
         SPACE
***********************************************************************
*                                                                     *
*   EXECUTABLE INSTRUCTIONS                                           *
*                                                                     *
***********************************************************************
         SPACE
DTAMOVE1 MVC   0(0,R2),0(R1)      MOVE DATA
LBLMOVE  MVC   0(0,R4),0(R7)      MOVE LABELS
FMTLN4C  UNPK  0(0,R5),0(0,R2)     UNPACK HEX DIGITS
FMTLN4D  TR    0(0,R5),FMTLN4A-X'F0' TRANSLATE FA - FF
         SPACE 2
FMTLNRT  TM    ADPLFLAG,ADPLSNPR   WERE WE LOADED BY PRDMP?
         BZ    FMTLNRT2            NO- SKIP FREEMAIN & RET CODE CHECK
         SPACE
***********************************************************************
*                                                                     *
*   WERE LOADED BY PRDMP- SET PROPER RETURN CODE, RESTORE SAVEAREA    *
*   CHAINING, AND FREE GOTTEN STORAGE.                                *
*                                                                     *
***********************************************************************
         SPACE
         SR    R9,R9               SET A ZERO RETURN CODE
         TM    FMTSWS,MEMAERR      ANY READ ERRORS THIS CALL?
         BZ    FMTLNRT1            NO- KEEP CODE OF ZERO
         SPACE
***********************************************************************
*                                                                     *
*   AT LEAST ONE READ FAILED DURING THIS CALL OF AMDPRFMT.            *
*                                                                     *
***********************************************************************
         SPACE
         LA    R9,4                SET A RETURN CODE OF 4
FMTLNRT1 LA    R0,GETMLEN          SET UP LENGTH FOR FREEMAIN
         ICM   R0,B'1000',ADPLSBPL SET UP SUBPOOL FOR FREEMAIN
         LR    R1,R13              SET UP ADDRESS OF AREA TO BE FREED
         L     R13,4(R13)          RESTORE SAVE AREA LINKAGE BEFORE
*                                  FREEING OUR SAVE/WORK AREA
         FREEMAIN R,LV=(0),A=(1)   FREE FMT SAVE/WORKAREA
         LR    R15,R9              SET RET CODE IN R15
         B     FMTLNRT3            BRANCH AROUND NON-PRDMP LOAD CODE
FMTLNRT2 SR    R15,R15             RETURN CODE IS ALWAYS ZERO WHEN
*                                  LOADED BY ABDUMP- READ ERROR CANNOT
*                                  OCCUR
FMTLNRT3 L     R14,12(R13)         RESTORE R14
         LM    R0,R12,20(R13)      RESTORE R0 - R12
         BR    R14                 RETURN TO CALLER
         SPACE 3
***********************************************************************
*                                                                     *
*                                                                     *
*   CONSTANTS FOR FORMAT LINE ROUTINE                                 *
*                                                                     *
*                                                                     *
***********************************************************************
         SPACE
LN1MSK   DC    F'240'              LENGTH MASK FOR LABEL LENGTH
LN2MSK   DC    F'15'               LENGTH MASK FOR DATA LENGTH
LN3MSK   DC    F'3'                ROUNDING VALUE FOR 4 BYTE BOUND
LN4MSK   DC    X'F0F0'             ZONE MASK FOR UNPACKS
FMTLN4A  DC    C'0123456789ABCDEF' TRANSLATE TABLE
FMTPATCH DC    13F'0'              AMDPRFMT PATCH AREA
         EJECT
         IHAABDPL DSECT=YES
         SPACE 3
FMTPTRN  DSECT                     DSECT FOR LINE FORMAT ROUTINE
PTRNCD   DS    BL1
DTAE     EQU   X'20'               DATA EBCDIC BIT
DTAC     EQU   X'10'               DATA IN CORE BIT
DTAP     EQU   X'08'               DATA POINTER PRESENT BIT
DTA      EQU   X'04'               DATA TO BE INCLUDED BIT
LBLP     EQU   X'02'               LABEL PTR PRESENT BIT
LBL      EQU   X'01'               LABEL TO BE INCLUDED BIT
PTRNLN   DS    XL1                 LABEL/DATA LENGTH (-1)
PTRNOFF1 DS    XL1                 LABEL OFFSET
PTRNOFF2 DS    XL1                 DATA OFFSET
PTRNPTR  DS    F                   POINTER TO LABEL/DATA
         SPACE 3
FMTSWMAP DSECT                     AMDPRFMT SAVE/WORK AREA MAP
FMTSAVE  DS    18F                 AMDPRFMT SAVE AREA
FMTREAD  DS    CL16                AMDPRFMT READ AREA
FMTWORK  DS    0XL16               AMDPRFMT WORK AREA
FMTRDSV  DS    2F                  REGISTER SAVEAREA ACROSS READS
FMTSWS   DS    BL1                 AMDPRFMT SWITCHES
MEMAERR  EQU   X'80'               MEMORY ACCESS RTN READ ERROR
FMTRSVD  DS    XL7                 UNUSED
FMTSWEND EQU   *
GETMLEN  EQU   FMTSWEND-FMTSWMAP   LENGTH OF FMTSWMAP DSECT
         SPACE 3
OUTBUF   DSECT                     DSECT FOR OUTPUT BUFFER
ADDR     DS    CL120
OVRFLOW  DS    CL1
         END AMDPRFMT
