         TITLE 'AMDPRRDC - READ CONTROL MODULE                         *
                        '
AMDPRRDC CSECT ,                                                   0001
@MAINENT DS    0H                                                  0001
         USING *,@15                                               0001
         B     @PROLOG                                             0001
         DC    AL1(16)                                             0001
         DC    C'AMDPRRDC  76.317'                                 0001
         DROP  @15
@PROLOG  STM   @14,@12,12(@13)                                     0001
         BALR  @11,0                                               0001
@PSTART  LA    @10,4095(,@11)                                      0001
         USING @PSTART,@11                                         0001
         USING @PSTART+4095,@10                                    0001
         ST    @13,@SA00001+4                                      0001
         LA    @14,@SA00001                                        0001
         ST    @14,8(,@13)                                         0001
         LR    @13,@14                                             0001
*INISHUL:                                                          0099
*   CURENSAV = R13;                 /* INITIATE ABILITY TO     Y02006*/
INISHUL  ST    R13,CURENSAV                                        0099
*                                   /* REFERENCE OWN REGS      Y02006*/
*                                   /* IF ENTERED IN ASCBMAP   Y02006*/
*                                   /* BUILD RTNS ERROR HANDLR Y02006*/
*                                                                  0100
*   IF FLSHMODE = ON THEN           /* IF IN FLUSHMODE         Y02006*/
         TM    FLSHMODE(COMPTR),B'10000000'                        0100
         BO    @RT00100                                            0100
*     GOTO TERMINIT;                /* DO NOT PERFORM INIT     Y02006*/
*   IF BUILDMAP = OFF THEN          /* IF OFF, NOT A FULL INIT Y02006*/
         TM    BUILDMAP(COMPTR),B'00001000'                        0102
         BNZ   @RF00102                                            0102
*     DO;                           /* MAKE SURE BUFFERS STILL Y02006*/
*                                   /* THERE                   Y02006*/
*       INITSW = OFF;               /* INDICATE PARTIAL INIT   Y02006*/
         NI    INITSW,B'01111111'                                  0104
*       GOTO CHECKBUF;              /* TO CHECK BUFFERS        Y02006*/
         B     CHECKBUF                                            0105
*     END;                                                         0106
*   /*****************************************************************/
*   /*                                                               */
*   /* ENTERED FOR A FULL INIT- IE EITHER FIRST TIME THRU OR         */
*   /* AFTER A NEWDUMP/TAPE CONTROL STATEMENT                        */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0107
*   INITSW = ON;                    /* INDICATE FULL INIT      Y02006*/
*                                                                  0107
@RF00102 OI    INITSW,B'10000000'                                  0107
*   /*****************************************************************/
*   /*                                                               */
*   /* INITIALIZE DUMP READ ROUTINE BASED ON JCL                     */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0108
*   INDD1 = INDD;                   /* SET RDC INDD AREA = INDDY02006*/
         MVC   INDD1(8),INDD(COMPTR)                               0108
*   GEN(DEVTYPE INDD1,DEVAREA);     /* IS INPUT DD DEFINED?    Y02006*/
         DEVTYPE INDD1,DEVAREA
*   IF R15 ^= 0 THEN                /* NOT DEFINED             Y02006*/
         LTR   R15,R15                                             0110
         BZ    @RF00110                                            0110
*     DO;                           /* CHECK FOR PRELOADED     Y02006*/
*                                   /* SYSUT1                  Y02006*/
*       INDD = SYSUT1;              /* CHANGE DDNAME IN COMMON Y02006*/
*                                                                  0112
         MVC   INDD(8,COMPTR),SYSUT1                               0112
*       GP = MGTABPTR + INDX175I;   /* WRITE MSG INDICATING    Y02006*/
         LA    GP,16                                               0113
         AL    GP,MGTABPTR                                         0113
*GEN REFS(APRTMSG) (LM R1,R2,0(GP)); /* NO TAPE DD- SYSUT1     Y02006*/
         LM R1,R2,0(GP)
*GEN(BRPRTMSG (R1),(R2));           /* ASSUMED LOADED          Y02006*/
         BRPRTMSG (R1),(R2)
*GEN(DEVTYPE SYSUT1,DEVAREA);       /* SYSUT1 PROVIDED?        Y02006*/
         DEVTYPE SYSUT1,DEVAREA
*       IF R15 ^= 0 THEN            /* CHECK DEVTYPE           Y02006*/
         LTR   R15,R15                                             0117
         BNZ   @RT00117                                            0117
*         GOTO AMD254;              /* NO- WRITE AMD254I       Y02006*/
*                                   /* AND TERMINATE AMDPRDMP  Y02006*/
*       IF DEVAREA(DEVCLASS) ^= DADEV THEN /* SYSUT1 WAS       Y02006*/
         CLI   DEVAREA+2,X'20'                                     0119
         BNE   @RT00119                                            0119
*                                   /* PROVIDED BUT IS IT ON   Y02006*/
*                                   /* A D.A. DEVICE?          Y02006*/
*         GOTO AMD254;              /* NO, NOT ON D.A.- ISSUE  Y02006*/
*                                   /* AMD254I AND TERMINATE   Y02006*/
*                                                                  0121
*   /* PRELOADED DIRECT ACCESS SYSUT1 WAS PROVIDED                   */
*                                                                  0121
*         TREADIN = OFF;            /* INDICATE D.A. INPUT     Y02006*/
         NI    TREADIN(COMPTR),B'11101111'                         0121
*                                   /* TO PREAD AND LOD        Y02006*/
*         GOTO CHECKBUF;            /* CONTINUE INIT FUNCTION  Y02006*/
         B     CHECKBUF                                            0122
*     END;                                                         0123
*                                                                  0123
*   /*  INPUT DD WAS DEFINED ON EITHER TAPE OR ANYNAME DD            */
*                                                                  0124
*   /*****************************************************************/
*   /*                                                               */
*   /*  DETERMINE WHETHER DUMP SHOULD BE TRANSFERRED TO SYSUT2       */
*   /*  DETERMINE WHETHER DUMP SHOULD BE SPOOLED TO SYSUT1           */
*   /*  OR PROCESSED ON TAPE                                         */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0124
*                                                                  0124
*   /* DETERMINE WHETHER SYSUT2 IS PROVIDED                          */
*                                                                  0124
*   GEN(DEVTYPE SYSUT2,DEVAREA);                            /* Y02006*/
@RF00110 DS    0H                                                  0124
         DEVTYPE SYSUT2,DEVAREA
*   IF R15 = 0 THEN                 /* WAS SYSUT2 PROVIDED?    Y02006*/
         LTR   R15,R15                                             0125
         BNZ   @RF00125                                            0125
*     DO;                           /* YES                     Y02006*/
*       QSYSUT2 = ON;               /* INDICATE TO LOD         Y02006*/
         OI    QSYSUT2(COMPTR),B'00000100'                         0127
*       GOTO CALLLOD;               /* TO INVOKE LOD           Y02006*/
         B     CALLLOD                                             0128
*     END;                                                         0129
*                                                                  0129
*   /* SYSUT2 NOT PRESENT- CHECK FOR SYSUT1 WORKFILE                 */
*                                                                  0130
*   GEN(DEVTYPE SYSUT1,DEVAREA);                            /* Y02006*/
@RF00125 DS    0H                                                  0130
         DEVTYPE SYSUT1,DEVAREA
*   IF R15 ^= 0 THEN                /* WAS SYSUT1 PROVIDED?    Y02006*/
         LTR   R15,R15                                             0131
         BNZ   @RT00131                                            0131
*     GOTO CHECKBUF;                /* NO                      Y02006*/
*                                                                  0132
*   /*****************************************************************/
*   /*                                                               */
*   /* SYSUT1 WORKFILE WAS PROVIDED                                  */
*   /* USE IT ONLY IF IT IS ON DIRECT ACCESS                 @YM08224*/
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0133
*   IF DEVAREA(DEVCLASS) = DADEV THEN /* IS SYSUT1 ON D.A.?    Y02006*/
         CLI   DEVAREA+2,X'20'                                     0133
         BNE   @RF00133                                            0133
*     DO;                           /* YES                     Y02006*/
*       LODSW = ON;                 /* INDICATE LOD SHOULD BE  Y02006*/
         OI    LODSW,B'00010000'                                   0135
*                                   /* INVOKED TO SPOOL TO     Y02006*/
*                                   /* WORKFILE                Y02006*/
*       GOTO CHECKBUF;              /* TO CHECK IF BUFFERS     Y02006*/
         B     CHECKBUF                                            0136
*     END;                          /* EXIST                   Y02006*/
*                                                                  0137
*   /* WORKFILE IS NOT ON D.A.- ISSUE MSG AND DONT SPOOL TO IT       */
*                                                                  0138
*     GP = MGTABPTR + INDX173I;     /* WRITE MSG INDICATING    Y02006*/
@RF00133 LA    GP,8                                                0138
         AL    GP,MGTABPTR                                         0138
*     GEN(LM R1,R2,0(GP));          /* WORKFILE IS NOT D.A.    Y02006*/
         LM R1,R2,0(GP)
*     GEN(BRPRTMSG (R1),(R2));      /* AND DUMP WILL BE PROC-  Y02006*/
         BRPRTMSG (R1),(R2)
*                                   /* ESSED ON TAPE           Y02006*/
*                                                                  0141
*   /*****************************************************************/
*   /*                                                               */
*   /* CHECK WHETHER BUFFERS STILL EXIST FROM BEFORE                 */
*   /* OR WHETHER RDC MUST OBTAIN THEM                               */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0141
*CHECKBUF:                                                         0141
*   IF BUFMAP = 0 THEN              /* DO WE NEED TO ACQUIRE   Y02006*/
CHECKBUF ICM   @14,15,BUFMAP                                       0141
         BNZ   @RF00141                                            0141
*                                   /* BUFFERS?                Y02006*/
*     DO;                           /* YES- NONE EXIST         Y02006*/
*       CALL GETBUFS;               /* OBTAIN STORAGE FOR      Y02006*/
         BAL   @14,GETBUFS                                         0143
*                                   /* DUMP BUFFERS            Y02006*/
*       CALL BUFINIT;               /* INITILIZE NEWLY         Y02006*/
         BAL   @14,BUFINIT                                         0144
*     END;                          /* OBTAINED BUFFERS        Y02006*/
*                                                                  0145
*   /*****************************************************************/
*   /*                                                               */
*   /* DUMP BUFFERS ALREADY EXIST- BUT MUST REINITIALIZE THEM        */
*   /* IF MST RE-INIT IS REQUIRED DUE TO NEWDUMP/NEWTAPE, CVT=,      */
*   /* OR SEGTAB=.                                                   */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0146
*   ELSE                                                           0146
*     IF MSTRSW = OFF THEN          /* MST REINIT REQUIRED?    Y02006*/
         B     @RC00141                                            0146
@RF00141 TM    MSTRSW(COMPTR),B'10000000'                          0146
         BNZ   @RF00146                                            0146
*       CALL BUFINIT;               /* YES- INITIALIZE BUFFERS Y02006*/
*                                                                  0147
         BAL   @14,BUFINIT                                         0147
*   /*****************************************************************/
*   /*                                                               */
*   /* DETERMINE WHETHER RDC, DURING ITS INITIAL PROCESSING,         */
*   /* FOUND IT NECESSARY TO INVOKE LOD FOR THIS PASS OF INIT        */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0148
*CHECKLOD:                                                         0148
*   IF LODSW = ON THEN              /* LOAD RTN REQUIRED?      Y02006*/
@RF00146 DS    0H                                                  0148
@RC00141 DS    0H                                                  0148
CHECKLOD TM    LODSW,B'00010000'                                   0148
         BNO   @RF00148                                            0148
*     DO;                           /* YES                     Y02006*/
*       LODSW = OFF;                /* RESET LOD REQD SWITCH   Y02006*/
         NI    LODSW,B'11101111'                                   0150
*CALLLOD:                                                          0151
*       GEN(LOAD EP=AMDPRLOD);      /* BRING IN WORKFILE LOAD  Y02006*/
CALLLOD  LOAD EP=AMDPRLOD
*                                   /* ROUTINE                 Y02006*/
*       LOADRTN = R0;               /* SET BASE FOR CALLING    Y02006*/
         LR    LOADRTN,R0                                          0152
*                                   /* LOADER                  Y02006*/
*       CALL AMDPRLOD;              /* INVOKE THE LOAD ROUTINE Y02006*/
         LR    @15,LOADRTN                                         0153
         BALR  @14,@15                                             0153
*       GP = R15;                   /* SAVE RETURN CODE FOR    Y02006*/
         LR    GP,R15                                              0154
*                                   /* BRANCHING               Y02006*/
*       GEN(DELETE EP=AMDPRLOD);    /* RELEASE LOAD ROUTINE    Y02006*/
*                                                                  0155
         DELETE EP=AMDPRLOD
*   /*****************************************************************/
*   /*                                                               */
*   /* BRANCH ON RETURN CODE FROM LOAD ROUTINE                       */
*   /*                                                               */
*   /*   CODE    WHERETO                  WHY                        */
*   /*                                                               */
*   /*    0      PREAD        SYSUT1 LOADED MUST NOW PROCESS         */
*   /*    4      FREESAVE     POSITIONING ERROR ENCOUNTERED          */
*   /*    8      FREEXIT      SYSUT2 LOADED PROCESSING COMPLETE      */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0156
*       GP = (GP+4)/4;              /* TRANSLATE RETURN CODE   Y02006*/
         LA    @14,4                                               0156
         LR    @06,GP                                              0156
         ALR   @06,@14                                             0156
         SRDA  @06,32                                              0156
         DR    @06,@14                                             0156
         LR    GP,@07                                              0156
*                                   /* TO A BRANCH TABLE INDX  Y02006*/
*       GOTO LODBRTAB(GP);          /* INDEX TABLE & BRANCH    Y02006*/
         LR    @14,GP                                              0157
         SLA   @14,2                                               0157
         L     @14,LODBRTAB-4(@14)                                 0157
         BR    @14                                                 0157
*     END;                                                         0158
*                                                                  0158
*   /*****************************************************************/
*   /*                                                               */
*   /* CONTINUE INIT PROCESSING BY INVOKING AMDPREAD TO BUILD        */
*   /* DUMP MAPS UNLESS AMDPRLOD WAS INVOKED ABOVE, IN WHICH         */
*   /* CASE, THE DUMP MAPS WILL ALREADY BE BUILT                     */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0159
*PREAD:                                                            0159
*   IF BUILDMAP = ON THEN           /* HAVE THE MAPS BEEN      Y02006*/
@RF00148 DS    0H                                                  0159
PREAD    TM    BUILDMAP(COMPTR),B'00001000'                        0159
         BNO   @RF00159                                            0159
*                                   /* BUILT YET FOR THIS DUMP Y02006*/
*     DO;                           /* NO- HAVE EAD BUILD THEM Y02006*/
*       R1 = BUFERMAP;              /* INITIALIZE TO FIRST     Y02006*/
         L     R1,BUFERMAP(,COMPTR)                                0161
*                                   /* BUFFERMAP ENTRY FOR EAD Y02006*/
*       CALL AMDPREAD;              /* INVOKE AMDPREAD         Y02006*/
*                                                                  0162
         L     @15,@CV01129                                        0162
         BALR  @14,@15                                             0162
*   /*****************************************************************/
*   /*                                                               */
*   /* INSURE THAT PREAD WAS SUCCESSFUL IN BUILDING THE              */
*   /* DUMP MAPS.  IF NOT, TERMINATE INIT PROCESSING AND             */
*   /* GO TO THE MAIN ERROR HANDLER IN CTL VIA FREESAVE.             */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0163
*       IF POSITSW = OFF THEN       /* WAS EAD SUCCESSFUL IN   Y02006*/
         TM    POSITSW(COMPTR),B'00100000'                         0163
         BNZ   @RF00163                                            0163
*                                   /* POSITIONING TO DUMP?    Y02006*/
*         BUILDMAP = OFF;           /* INDICATE MAPS BUILT     Y02006*/
         NI    BUILDMAP(COMPTR),B'11110111'                        0164
*                                   /* SUCCESSFULLY            Y02006*/
*       ELSE                                                       0165
*         GOTO FREESAVE;            /* TO CTL MAIN ERROR       Y02006*/
*     END;                          /* HANDLER                 Y02006*/
*                                                                  0166
*   /*****************************************************************/
*   /*                                                               */
*   /* DETERMINE WHETHER OR NOT AMDPRMST SHOULD BE INVOKED           */
*   /* TO INITIALIZE OR RE-INITIALIZE THE COMMON AREA.               */
*   /* THIS WILL BE THE CASE IF MSTRSW IS OFF.  IT WILL BE OFF       */
*   /* UNDER THE FOLLOWING CONDITIONS:                               */
*   /* 1. FOR 1ST TIME THRU INIT OR NEWDUMP PROCESSING,              */
*   /*    INDICATED TO RDC BY THE BUILDMAP SW = ON.                  */
*   /* 2. FOR SEGTAB= OR CVT= CONTROL STATEMENTS.                    */
*   /* MSTRSW IS RESET ON BY MST AFTER MST COMPLETES PROCESSING .    */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0167
*   IF MSTRSW = OFF THEN            /* MST INITIALIZATION REQD Y02006*/
@RF00159 TM    MSTRSW(COMPTR),B'10000000'                          0167
         BNZ   @RF00167                                            0167
*     DO;                           /* YES-                    Y02006*/
*       ASIDSAVE = 0;               /* INSURE THAT ASID SAVE   Y02006*/
         SLR   @14,@14                                             0169
         STH   @14,ASIDSAVE                                        0169
*       SGTBAPTR = ADDR(SEGTABOR);  /* AREA AND CORRESPONDING  Y02006*/
         LA    @14,SEGTABOR(,COMPTR)                               0170
         ST    @14,SGTBAPTR                                        0170
*                                   /* PTR TO ITS SEGTAB FOR   Y02006*/
*                                   /* QUICK FIND IN DATA ARE  Y02006*/
*                                   /* INITIALIZED TO ASID=0   Y02006*/
*                                   /* AND SEGTABOR IN COMMON  Y02006*/
*                                   /* IN CASE THIS CALL OF    Y02006*/
*                                   /* INIT IS 1ST TIME THRU   Y02006*/
*       GEN(LOAD EP=AMDPRMST);      /* BRING IN MST            Y02006*/
         LOAD EP=AMDPRMST
*       INITRTN = R0;               /* SET BASE FOR CALLING    Y02006*/
         LR    INITRTN,R0                                          0172
*                                   /* PRMST                   Y02006*/
*       CALL AMDPRMST;              /* INVOKE IT               Y02006*/
         LR    @15,INITRTN                                         0173
         BALR  @14,@15                                             0173
*       GEN(DELETE EP=AMDPRMST);    /* RELEASE IT              Y02006*/
         DELETE EP=AMDPRMST
*       CALL BILDASCB;              /* BUILD NEW ASCBMAP       Y02006*/
         BAL   @14,BILDASCB                                        0175
*     END;                                                         0176
*                                                                  0176
*   /*****************************************************************/
*   /*                                                               */
*   /* INIT FUNCTION TERMINAL PROCESSING.                            */
*   /* RESTORE INTERNAL SWITCHES AND RETURN TO CALLER.               */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0177
*   SWITCHES = 0;                   /* RESET RDC INTERNAL      Y02006*/
@RF00167 MVI   SWITCHES,X'00'                                      0177
*                                   /* PROCESS SWITCHES        Y02006*/
*                                                                  0178
*TERMINIT:                                                         0178
*   RETURN;                         /* RETURN TO CALLER        Y02006*/
*                                                                  0178
@EL00001 L     @13,4(,@13)                                         0178
@EF00001 DS    0H                                                  0178
@ER00001 LM    @14,@12,12(@13)                                     0178
         BR    @14                                                 0178
*   /*****************************************************************/
*   /*                                                               */
*   /* AMDPRRDC'S ERROR HANDLERS - RAISE ERROR CONDITION             */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0179
*                                                                  0179
*AMD254:                                                           0179
*   GP = MGTABPTR + INDX254I;       /* INDX TO MSG AMD254I IN CSECT  */
AMD254   LA    GP,24                                               0179
         AL    GP,MGTABPTR                                         0179
*   GENERATE;                                                      0180
         LM    R1,R2,0(GP)             GET MSG ADDR AND MSG LNG  Y02006
         LA R1,4(R1)                   SKIP WTO PREFIX           Y02006
         BRPRTMSG (R1),(R2)            WRITE MESSAGE AMD254I     Y02006
*   IF RDRSW = ON THEN              /* TEST FOR SOURCE OF CNTRL INFO */
         TM    RDRSW(COMPTR),B'00000001'                           0181
         BO    @RT00181                                            0181
*     GOTO FREEXIT;                 /* BRANCH AROUND WTO IF READING
*                                      CARD CONTROL STATEMENTS       */
*   R1 = MSGADDR;                   /* POINT TO WTO PARMLIST         */
         L     R1,MSGADDR(,GP)                                     0183
*   GEN(WTO MF=(E,(1)));            /* ISSUE WTO ON MSG AMD151I      */
         WTO MF=(E,(1))
*   GOTO FREEXIT;                   /* GO TO TERMINATE EXECUTION     */
*                                                                  0185
         B     FREEXIT                                             0185
*AMD151I:                                                          0186
*   GP = MGTABPTR + INDX151I;       /* INDX TO MSG AMD151I IN CSECT  */
AMD151I  L     GP,MGTABPTR                                         0186
*   GENERATE;                                                      0187
         LM R1,R2,0(GP)                GET MSG ADDR AND MSG LNG  Y02006
         LA R1,4(R1)                   SKIP WTO PREFIX           Y02006
         BRPRTMSG (R1),(R2)            WRITE MESSAGE AMD151I     Y02006
*   IF RDRSW = ON THEN              /* TEST FOR SOURCE OF CNTRL INFO */
         TM    RDRSW(COMPTR),B'00000001'                           0188
         BO    @RT00188                                            0188
*     GOTO FREEXIT;                 /* BRANCH ARROUND WTO IF READING
*                                      CARD CONTROL STATEMENTS       */
*   R1 = MSGADDR;                   /* POINT TO WTO PARMLIST         */
         L     R1,MSGADDR(,GP)                                     0190
*   GEN(WTO MF=(E,(1)));            /* ISSUE WTO ON MSG AMD151I      */
*                                                                  0191
         WTO MF=(E,(1))
*   /*****************************************************************/
*   /*                                                               */
*   /*  BRANCH TO PRNTDMP'S EXIT ROUTINE                             */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0192
*                                                                  0192
*FREEXIT:                                                          0192
*   R13 = HIGHSAVE;                 /* POINT TO CALLERS SAVE   Y02006*/
FREEXIT  L     @14,CURENSAV                                        0192
         L     R13,HIGHSAVE(,@14)                                  0192
*   GENERATE REFS(AEREXIT);                                        0193
*                                                                  0193
         L     R15,AEREXIT(,COMPTR) POINT TO EXIT RTN            Y02006
         LA    R1,4                 SET TERMINATION CODE
         BR    R15                  BRANCH TO TERM
*   /*****************************************************************/
*   /*                                                               */
*   /*  EXIT TO ERROR HANDLER                                        */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0194
*                                                                  0194
*FREESAVE:                                                         0194
*   GEN(L R15,ERRADDR(,COMPTR));    /* GET ERROR HANDLER'S EP  Y02006*/
FREESAVE L R15,ERRADDR(,COMPTR)
*   GEN(BR R15);                    /* RAISE ERROR CONDITION         */
*                                                                  0195
         BR R15
*   /*****************************************************************/
*   /*                                                               */
*   /* ADJUST FUNCTION:                                              */
*   /*                                                               */
*   /*       AMDPRRDC WHEN CALLED FOR THIS FUNCTION CHECKS IF DUMP   */
*   /*       PROCESSING BUFFERS EXIST. IF NOT, CONTROL IS RETURNED   */
*   /*       IMMEDIATELY TO THE CALLER. IF BUFFERS DO EXIST THE      */
*   /*       BUFFER MAP AND BUFFERS ARE FREED AND THE POINTER,       */
*   /*       BUFMAP, IS RESET TO ZERO TO INDICATE BUFFERS NO LONGER  */
*   /*       EXIST                                                   */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0196
*AMDPRRDA:                                                         0196
*GENERATE REFS(ADJSAVE);                                           0196
*                                                                  0196
AMDPRRDA DS    0H                                                  0196
         USING *,R15
         STM   R14,R12,12(R13)                                   Y02006
         LM    BASE2,BASE1,ABASREGS                              Y02006
         DROP  R15
         ST    R13,ADJSAVE+4                                     Y02006
         LA    R14,ADJSAVE                                       Y02006
         ST    R14,8(R13)                                        Y02006
         LR    R13,R14                                           Y02006
         B     ADJUST                                            Y02006
ABASREGS DC    A(@PSTART+4095)                                   Y02006
         DC    A(@PSTART)                                        Y02006
*ADJUST:                                                           0197
*   IF BUFMAP ^= 0 THEN             /* CHK IF BUFS EXIST             */
ADJUST   L     @14,BUFMAP                                          0197
         LTR   @14,@14                                             0197
         BZ    @RF00197                                            0197
*     DO;                           /* YES, DO THE FOLLOWING         */
*       R1 = BUFMAP;                /* POINT TO BUF AREA             */
         LR    R1,@14                                              0199
*       BUFSUBPL = 1;               /* SET SUBPOOL TO FREE     Y02006*/
         MVI   BUFSUBPL,X'01'                                      0200
*       R0 = CORE;                  /* GET SIZE OF AREA              */
         L     R0,CORE                                             0201
*       GEN(FREEMAIN R,LV=(0),A=(1)); /* FREE BUFFER AREA            */
         FREEMAIN R,LV=(0),A=(1)
*       BUFMAP = 0;                 /* INDICATE NO BUFFERS EXIST     */
         SLR   @14,@14                                             0203
         ST    @14,BUFMAP                                          0203
*       BUFERMAP = 0;               /* INDICATE TO LOD ALSO    Y02006*/
         ST    @14,BUFERMAP(,COMPTR)                               0204
*       BUFSUM = 0;                 /* RESET NO. OF BUFS IN COMMON   */
         ST    @14,BUFSUM(,COMPTR)                                 0205
*       DMPIC = OFF;                /* RESET ALL OF DUMP IN    Y02006*/
         NI    DMPIC(COMPTR),B'11101111'                           0206
*                                   /* CORE                    Y02006*/
*     END;                                                         0207
*GENERATE;                                                         0208
@RF00197 DS    0H                                                  0208
         L     R13,4(R13)                                        Y02006
         LM    R14,R12,12(R13)                                   Y02006
         BR    R14                                               Y02006
*   GENERATE(EJECT);                                               0209
*                                                                  0209
         EJECT
*   /*****************************************************************/
*   /*                                                               */
*   /* DATA FUNCTION:                                                */
*   /*                                                               */
*   /*       THE BUFFER MAP TABLE IS SEARCHED FOR AN ENTRY REFLECTING*/
*   /*       THE REQUESTED VIRTUAL, REAL, OR TTR ADDRESS. IF AN ENTRY*/
*   /*       IS FOUND THE ADDRESS OF THE DATA IN THE BUFFER POINTED  */
*   /*       TO BY THE ENTRY IS RETURNED TO THE CALLER IN REGISTER   */
*   /*       ONE. IF THE REQUESTED ADDRESS CAN NOT BE FOUND IN A     */
*   /*       BUFFER MAP ENTRY, PREAD WILL BE CALLED TO READ THE DUMP */
*   /*       RECORD CONTAINING THE ADDRESS INTO THE OLDEST BUFFER.   */
*   /*       THE ADDRESS OF THE DATA IN THE BUFFER WILL THEN BE      */
*   /*       RETURNED TO THE CALLER.                                 */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0210
*AMDPRRDD:                                                         0210
*GENERATE REFS(DATASAVE);                                          0210
*                                                                  0210
AMDPRRDD DS    0H                                                  0210
         USING *,R15
         STM   R14,R12,12(R13)                                   Y02006
         LM    BASE2,BASE1,DBASREGS                              Y02006
         DROP  R15
         ST    R13,DATASAVE+4                                    Y02006
         LA    R14,DATASAVE                                      Y02006
         ST    R14,8(R13)                                        Y02006
         LR    R13,R14                                           Y02006
         B     DATA                                              Y02006
DBASREGS DC    A(@PSTART+4095)                                   Y02006
         DC    A(@PSTART)                                        Y02006
*DATA:                                                             0211
*   PLIST = R1;                     /* SAVE PARM LIST PTR      Y02006*/
DATA     ST    R1,PLIST                                            0211
*   RDENTRY = RDENTRY + 1;          /* UPDATE RDC DATA ENTRY CNT     */
         LA    @14,1                                               0212
         AL    @14,RDENTRY(,COMPTR)                                0212
         ST    @14,RDENTRY(,COMPTR)                                0212
*   FMTERR = OFF;                   /* INSURE FORMAT ERROR SW  Y02006*/
         NI    FMTERR(COMPTR),B'10111111'                          0213
*                                   /* IS OFF BEFORE PROCEED   Y02006*/
*                                                                  0214
*   /*****************************************************************/
*   /*                                                               */
*   /* CHECK FOR TYPE OF DATA REQUEST                                */
*   /* EITHER CPUDATA, REAL STORAGE, OR VIRTUAL STORAGE              */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0214
*                                                                  0214
*   IF CPUDAT = ON THEN             /* CHECK DATATYPE FIELD OF Y02006*/
         L     @14,PLIST                                           0214
         TM    CPUDAT(@14),B'10000000'                             0214
         BO    @RT00214                                            0214
*                                   /* PLIST- IS CPU DATA REQ? Y02006*/
*     GOTO CPUREQST;                /* YES- PROCESS CPU DATA   Y02006*/
*   IF PRNTREAL = ON THEN           /* REAL DATA REQUEST?      Y02006*/
         TM    PRNTREAL(COMPTR),B'00000100'                        0216
         BO    @RT00216                                            0216
*     GOTO REALREQ;                 /* YES, GO PROCESS REAL    Y02006*/
*                                                                  0217
*   /*****************************************************************/
*   /*                                                               */
*   /* PROCESS VIRTUAL DATA REQUEST                                  */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0218
*   SRCHAD = DATAAD;                 /* PUT 24 BIT DATA ADDR IN PARM
*                                      WORD FOR COMPADDR AND READREC
*                                      SUBROUTINES.                  */
*                                                                  0218
         SLR   @04,@04                                             0218
         ICM   @04,7,DATAAD(@14)                                   0218
         ST    @04,SRCHAD                                          0218
*GETOFSET:                                                         0219
*   OFFSET = SRCHAD//DATALNG;       /* COMPUTE OFFSET OF DATA IN BUF */
GETOFSET L     @14,SRCHAD                                          0219
         LR    @06,@14                                             0219
         SRDA  @06,32                                              0219
         D     @06,@CF01096                                        0219
         ST    @06,OFFSET                                          0219
*   SRCHAD = (SRCHAD & RNDVALU);    /* ROUND DOWN TO 4K BNDRY        */
*                                                                  0220
         N     @14,@CF01082                                        0220
         ST    @14,SRCHAD                                          0220
*   /*****************************************************************/
*   /*                                                               */
*   /* PERFORM VIRTUAL ADDRESS PREFIXING IF NECESSARY                */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0221
*   IF SRCHAD = 0 THEN              /* IF REQD VIRT BLOCK = 0  Y02006*/
         LTR   @14,@14                                             0221
         BNZ   @RF00221                                            0221
*     SRCHAD = PREFXRGV;            /* USE PREFIX VALUE        Y02006*/
         MVC   SRCHAD(4),PREFXRGV(COMPTR)                          0222
*   ELSE                            /* OR                      Y02006*/
*       DO;                         /* IF THE REQD VIRT        Y02006*/
         B     @RC00221                                            0223
@RF00221 DS    0H                                                  0224
*         IF SRCHAD = PREFXRGV THEN /* BLOCK = THE PREFIX VALU Y02006*/
         CLC   SRCHAD(4),PREFXRGV(COMPTR)                          0224
         BNE   @RF00224                                            0224
*           SRCHAD = 0;             /* USE 0                   Y02006*/
         SLR   @14,@14                                             0225
         ST    @14,SRCHAD                                          0225
*       END;                                                       0226
*                                                                  0226
@RF00224 DS    0H                                                  0227
*   /*****************************************************************/
*   /*                                                               */
*   /* CHECK REQUESTED ASID. IF = 0, (IE FOR VIRTUAL STORAGE         */
*   /* REQUESTS FROM COMMON MEMORY) USE THE CURRENT ASID.            */
*   /* OTHERWISE USE ACTUAL REQUESTED ASID                           */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0227
*   IF REQASID = 0 THEN             /* IS REQD ASID = 0?       Y02006*/
@RC00221 L     @14,PLIST                                           0227
         ICM   @04,3,REQASID(@14)                                  0227
         BNZ   @RF00227                                            0227
*     REQDASID = QASID;             /* YES- USE CURRENT ASID   Y02006*/
         MVC   REQDASID(2),QASID(COMPTR)                           0228
*   ELSE                                                           0229
*     REQDASID = REQASID;           /* NO- USE REQD ASID       Y02006*/
*                                                                  0229
         B     @RC00227                                            0229
@RF00227 L     @14,PLIST                                           0229
         MVC   REQDASID(2),REQASID(@14)                            0229
*   /*****************************************************************/
*   /*                                                               */
*   /* SCAN BUFFERS TO DETERMINE WHETHER REQUESTED VIRTUAL           */
*   /* ADDRESS IS CONTAINED IN A BUFFER                              */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0230
*   CPUIDAD = OFF;                  /* INDICATE REAL OR VIRT   Y02006*/
@RC00227 DS    0H                                                  0231
*   REALADDR = OFF;                 /* INDICATE VIRT. COMPARE        */
         NI    CPUIDAD,B'10011111'                                 0231
*   CALL COMPADDR;                  /* SRCH FOR A BUF CONTAINING THE
*                                      REQ ADDR. SRCHAD CONTAINS ADDR
*                                      AND REALADDR IS OFF           */
         BAL   @14,COMPADDR                                        0232
*   IF R15 = 0 THEN                 /* WAS ADDR IN A BUFFER?         */
         SLR   @14,@14                                             0233
         CR    R15,@14                                             0233
         BE    @RT00233                                            0233
*     GOTO TESTDATA;                /* YES, GO CHK IF BUF DATA VALID */
*                                                                  0234
*   /*****************************************************************/
*   /*                                                               */
*   /* VIRTUAL ADDRESS NOT IN A BUFFER, IF NO REAL INPUT             */
*   /* EXISTS, CALL PREAD TO READ REQUESTED VITRUAL ADDRESS          */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0235
*   IF REALMAP = 0 THEN             /* REAL INPUT EXIST?       Y02006*/
         C     @14,REALMAP(,COMPTR)                                0235
         BNE   @RF00235                                            0235
*     DO;                           /* NO-                     Y02006*/
*READVIRT:                                                         0237
*       CPUIDAD = OFF;              /* INDICATE REAL OR VIRT   Y02006*/
READVIRT DS    0H                                                  0238
*       REALADDR = OFF;             /* INDICATE VIRT COMPARE   Y02006*/
         NI    CPUIDAD,B'10011111'                                 0238
*       IF DMPIC = ON THEN          /* READ VITRUAL ADDR       Y02006*/
         TM    DMPIC(COMPTR),B'00010000'                           0239
         BO    @RT00239                                            0239
*         GOTO CHEKSWAP;            /* UNLESS ALL OF DUMP      Y02006*/
*                                   /* IS IN CORE              Y02006*/
*       CALL READREC;               /* AFTER READ,             Y02006*/
         BAL   @14,READREC                                         0241
*                                   /* VERIFY DATA RETURNED    Y02006*/
*       MAPPTR = CURENTRY;          /* POINT TO BUF MAP NTRY   Y02006*/
         L     MAPPTR,CURENTRY                                     0242
*       IF INVALFLG = OFF THEN      /* IF REQD ADDR READ       Y02006*/
         TM    INVALFLG(MAPPTR),B'10000000'                        0243
         BZ    @RT00243                                            0243
*                                   /* SUCCESSFULLY,           Y02006*/
*         GOTO OFFSETSV;            /* RETURN DATA TO CALLER   Y02006*/
*                                                                  0244
*   /*****************************************************************/
*   /*                                                               */
*   /* AT THIS POINT, IT IS POSSIBLE THAT THE REQUESTED ADDRESS WAS  */
*   /* FROM AN ADDRESS SPACE THAT WAS SWAPPED OUT BUT CONTAINED IN   */
*   /* COMMON MEMORY.  SINCE THE MEMORY WAS SWAPPED OUT, NO SEGMENT  */
*   /* TABLE ADDRESS IS PRESENT IN ASCBMAP.  IF REAL INPUT EXISTS,   */
*   /* AND THE REQUESTED ADDRESS IS WITHIN THE RANGE OF COMMON       */
*   /* MEMORY, AND IT IS NOT A SPECIAL STAND ALONE DUMP RECORD       */
*   /* REQUEST, THEN USE SEGTABOR AS THE SEGMENT TABLE AND TRY TO    */
*   /* TRANSLATE THE REQUESTED ADDRESS TO A REAL ADDRESS.  IF THE    */
*   /* REQUESTED ADDR WAS IN COMMON MEMORY, THIS WILL SATISFY THE    */
*   /* REQUEST.                                                      */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0245
*CHEKSWAP:                                                         0245
*       IF SGTBAPTR ^= ADDR(ZEROSEG) × /* IF NOT POSSIBLY      Y02006*/
*                                   /* SWAPPED OUT,            Y02006*/
*          REALMAP = 0 ×            /* OR NO REAL INPUT        Y02006*/
*          SRCHAD >= NUCTOP &       /* OR NOT IN COMMON        Y02006*/
*          SRCHAD < CSADDR ×        /* MEMORY                  Y02006*/
*          REQDASID(1) = ON THEN    /* OR SADMP RECORD, THEN   Y02006*/
CHEKSWAP LA    @14,ZEROSEG                                         0245
         C     @14,SGTBAPTR                                        0245
         BNE   @RT00245                                            0245
         ICM   @14,15,REALMAP(COMPTR)                              0245
         BZ    @RT00245                                            0245
         L     @14,SRCHAD                                          0245
         C     @14,NUCTOP(,COMPTR)                                 0245
         BL    @GL00001                                            0245
         C     @14,CSADDR(,COMPTR)                                 0245
         BL    @RT00245                                            0245
@GL00001 TM    REQDASID,B'10000000'                                0245
         BO    @RT00245                                            0245
*         GOTO FORMERR;             /* DO NOT RE-TRY           Y02006*/
*                                                                  0246
*   /* POSSIBLE COMMON MEMORY REQUEST.                               */
*   /* DOUBLE BACK AND TRY CURRENT MEMORYS SEGMENT TABLE.            */
*                                                                  0247
*       SGTBAPTR = ADDR(SEGTABOR);  /* USE CURRENT MEMORYS     Y02006*/
         LA    @14,SEGTABOR(,COMPTR)                               0247
         ST    @14,SGTBAPTR                                        0247
*       ASIDSAVE = 0;               /* RESET SAVE WORD FOR     Y02006*/
         SLR   @14,@14                                             0248
         STH   @14,ASIDSAVE                                        0248
*                                   /* ASID FOR NEXT READ      Y02006*/
*       IF DMPIC = OFF THEN         /* IF WE HAD DONE THE      Y02006*/
         TM    DMPIC(COMPTR),B'00010000'                           0249
         BNZ   @RF00249                                            0249
*                                   /* READ AT READVIRT, THEN  Y02006*/
*         DO;                                                      0250
*           BUFFFLAG = FLAGINIT;    /* RE-INIT BUFMAP ENTRY    Y02006*/
         MVI   BUFFFLAG(MAPPTR),X'00'                              0251
*           BUFFIELD = BUFFINIT;    /* THAT HAD BEEN USED FOR  Y02006*/
         MVC   BUFFIELD(12,MAPPTR),BUFFINIT                        0252
*         END;                      /* THE VIRTUAL READ SINCE  Y02006*/
*       GOTO CHEKSEG;               /* WE ARE TRYING AGAIN.    Y02006*/
         B     CHEKSEG                                             0254
*     END;                                                         0255
*                                                                  0255
*   /*****************************************************************/
*   /*                                                               */
*   /* REQUEST WAS VIRTUAL AND REAL INPUT EXISTS                     */
*   /* ATTEMPT TO TRANSLATE TO REAL ADDRESS.                         */
*   /* IF TRANSLATION UNSUCCESSFUL, GOTO READVIRT AND ATTEMPT        */
*   /* TO READ REQUESTED VIRTUAL ADDRESS                             */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0256
*   IF REQDASID = IMPASID THEN      /* IF REQUESTED ASID =     Y02006*/
@RF00235 CLC   REQDASID(2),@CB01105                                0256
         BE    @RT00256                                            0256
*     GOTO FORMERR;                 /* FFFF- ERROR CONDITION   Y02006*/
*                                   /* CANNOT ALLOW ASCBMAP    Y02006*/
*                                   /* SEARCH FOR ASID FFFF    Y02006*/
*   IF REQDASID(1) = ON THEN        /* IF ASID > 7FFF, THERE   Y02006*/
         TM    REQDASID,B'10000000'                                0258
         BNO   @RF00258                                            0258
*     DO;                           /* WILL BE NO VALID SYS    Y02006*/
*       IF SRCHAD = 0 THEN          /* ENTRY IN ASCBMAP TO     Y02006*/
         ICM   @14,15,SRCHAD                                       0260
         BNZ   @RF00260                                            0260
*         SRCHAD = PREFXRGV;        /* MATCH. FIRST UN-PREFIX, Y02006*/
         MVC   SRCHAD(4),PREFXRGV(COMPTR)                          0261
*       ELSE                        /* THEN,  ATTEMPT TO READ  Y02006*/
*           DO;                     /* VIRTUAL RECORD WITH     Y02006*/
         B     @RC00260                                            0262
@RF00260 DS    0H                                                  0263
*             IF SRCHAD = PREFXRGV THEN /* THAT ASID AS IT     Y02006*/
         CLC   SRCHAD(4),PREFXRGV(COMPTR)                          0263
         BNE   @RF00263                                            0263
*               SRCHAD = 0;         /* MAY BE A SPECIAL SADMP  Y02006*/
         SLR   @14,@14                                             0264
         ST    @14,SRCHAD                                          0264
*           END;                                            /* Y02006*/
*       GOTO READVIRT;                                      /* Y02006*/
         B     READVIRT                                            0266
*     END;                                                  /* Y02006*/
*                                                                  0267
*   /*****************************************************************/
*   /*                                                               */
*   /* REQUESTED ASID IS NUMERICALLY VALID. IF IT IS THE SAME        */
*   /* ASID THAT WAS REQUESTED ON LAST BRREAD DATA, USE              */
*   /* QUICK INDEX INTO ASCBMAP OR SEGTABOR RATHER THAN SEARCH.      */
*   /* IF NOT THE SAME AS LAST TIME, GET APPROPRIATE SEGTAB ADDR     */
*   /* FROM EITHER SEGTABOR OR ASCBMAP.  SAVE ASID AND THE           */
*   /* PTR TO THE FIELD CONTAINING ITS CORRESPONDING SEGTAB          */
*   /* ADDRESS FOR QUICK FIND ON NEXT BRREAD.  EVEN IF REQUESTED     */
*   /* ASID FOR THIS READ IS NOT FOUND IN ASCBMAP, OR IF ASCBMAP     */
*   /* DOES NOT EXIST, IT WILL BE SAVED FOR QUICK FIND ON NEXT       */
*   /* READ, BUT THE PTR TO THE FIELD CONTAINING THE CORRESPONDING   */
*   /* SEGTAB ADDRESS WILL BE SET TO POINT TO A WORD OF ZEROS,       */
*   /* THUS CAUSING CHEKSEG CODE TO REJECT IT AND GOTO READVIRT.     */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0268
*   IF REQDASID = ASIDSAVE THEN     /* SAME ASID AS LAST TIME? Y02006*/
@RF00258 CLC   REQDASID(2),ASIDSAVE                                0268
         BE    @RT00268                                            0268
*     GOTO CHEKSEG;                 /* YES- INDEX PTR TO SEG-  Y02006*/
*                                   /* TAB ADDR (SGTBAPTR)     Y02006*/
*                                   /* STILL VALID             Y02006*/
*   IF REQDASID = 0 THEN            /* IF REQUESTED ASID = 0   Y02006*/
         ICM   @14,3,REQDASID                                      0270
         BNZ   @RF00270                                            0270
*                                   /* HERE (MEANING QASID=0)  Y02006*/
*     DO;                           /* SAVE ASID FOR QUICK     Y02006*/
*       ASIDSAVE = REQDASID;        /* FIND NEXT TIME          Y02006*/
         MVC   ASIDSAVE(2),REQDASID                                0272
*       SGTBAPTR = ADDR(SEGTABOR);  /* POINT INDEX POINTER TO  Y02006*/
         LA    @14,SEGTABOR(,COMPTR)                               0273
         ST    @14,SGTBAPTR                                        0273
*                                   /* SEGTABOR FIELD SINCE    Y02006*/
*                                   /* ASID WAS ZERO           Y02006*/
*       GOTO CHEKSEG;               /* GO CHECK SEGMENT TABLE  Y02006*/
         B     CHEKSEG                                             0274
*                                   /* ADDR CONTAINED IN       Y02006*/
*     END;                          /* SEGTABOR                Y02006*/
*                                                                  0275
*   /*****************************************************************/
*   /*                                                               */
*   /* REQUESTED ASID IS NOT SAME AS LAST REQUEST AND IS NOT         */
*   /* ZERO, THEREFORE A SEARCH OF ASCBMAP IS NECESSARY TO           */
*   /* OBTAIN THE CORRESPONDING SEGMENT TABLE ADDRESS.               */
*   /* INSURE THAT ASCBMAP EXISTS.                                   */
*   /* IF NOT, TREAT AS A SWAPPED OUT MEMORY, WHICH WILL             */
*   /* ALLOW USER TO PRINT, AT LEAST, MASTER (COMMON) MEMORY         */
*   /* BY USING SEGTABOR SEGMENT TABLE IF WE WERE UNABLE TO BUILD    */
*   /* ASCBMAP.                                                      */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0276
*   IF ASCBMAP = 0 THEN             /* TABLE EXIST?            Y02006*/
@RF00270 ICM   @14,15,ASCBMAP(COMPTR)                              0276
         BNZ   @RF00276                                            0276
*   DO;                             /* NO-                     Y02006*/
*     ASIDSAVE = REQDASID;          /* TREAT AS SWAPPED OUT    Y02006*/
         MVC   ASIDSAVE(2),REQDASID                                0278
*     SGTBAPTR = ADDR(ZEROSEG);     /* MEMORY BY SETTING TO    Y02006*/
         LA    @14,ZEROSEG                                         0279
         ST    @14,SGTBAPTR                                        0279
*     GOTO CHEKSEG;                 /* ZEROSEG                 Y02006*/
         B     CHEKSEG                                             0280
*   END;                            /*                         Y02006*/
*                                                                  0281
*   /* INITIALIZE FOR SEARCH OF ASCBMAP                              */
*                                                                  0282
*   ASMAPPTR = ASCBMAP + MAPREFLN;  /* INIT MAP INDEX PTR TO   Y02006*/
@RF00276 LA    ASMAPPTR,16                                         0282
         AL    ASMAPPTR,ASCBMAP(,COMPTR)                           0282
*                                   /* FIRST MAP ENTRY         Y02006*/
*   DO NTRYCT=1 TO ASCBNUM WHILE    /* SEARCH ASCBMAP MAP      Y02006*/
*     (ASID^=REQDASID);             /* ENTRIES UNTIL FIND      Y02006*/
         LA    @14,1                                               0283
         B     @DE00283                                            0283
@DL00283 CLC   ASID(2,ASMAPPTR),REQDASID                           0283
         BE    @DC00283                                            0283
*                                   /* REQD ASID OR REACH THE  Y02006*/
*     ASMAPPTR = ASMAPPTR + MAPNTRYL; /* END OF ASCBMAP        Y02006*/
         AH    ASMAPPTR,@CH00164                                   0284
*   END;                                                           0285
*                                                                  0285
         AH    @14,@CH00057                                        0285
@DE00283 STH   @14,NTRYCT                                          0285
         L     @07,ASCBMAP(,COMPTR)                                0285
         CH    @14,ASCBNUM(,@07)                                   0285
         BNH   @DL00283                                            0285
@DC00283 DS    0H                                                  0286
*   IF NTRYCT <= ASCBNUM THEN       /* WAS REQD ASID IN TABLE? Y02006*/
         LH    @14,NTRYCT                                          0286
         L     @04,ASCBMAP(,COMPTR)                                0286
         CH    @14,ASCBNUM(,@04)                                   0286
         BH    @RF00286                                            0286
*     DO;                           /* YES- SAVE REQD ASID FOR Y02006*/
*       ASIDSAVE = REQDASID;        /* QUICK FIND NEXT TIME    Y02006*/
         MVC   ASIDSAVE(2),REQDASID                                0288
*       ASTABPTR = ASCBTAB + (NTRYCT-1) * TABNTRYL; /* & POINT Y02006*/
         L     @09,ASCBMAP(,COMPTR)                                0289
         BCTR  @14,0                                               0289
         SLA   @14,3                                               0289
         AL    @14,ASCBTAB(,@09)                                   0289
         LR    ASTABPTR,@14                                        0289
*       SGTBAPTR = ADDR(SEGTBADR);  /* INDEX PTR TO THE        Y02006*/
         LA    @14,SEGTBADR(,ASTABPTR)                             0290
         ST    @14,SGTBAPTR                                        0290
*     END;                          /* TABLE ENTRY WHICH       Y02006*/
*                                   /* CONTAINS THE CORRES-    Y02006*/
*                                   /* PONDING SEGTAB ADDR     Y02006*/
*   ELSE                                                           0292
*     DO;                           /* NO- SAVE REQD ASID FOR  Y02006*/
         B     @RC00286                                            0292
@RF00286 DS    0H                                                  0293
*       ASIDSAVE = REQDASID;        /* QUICK FIND NEXT TIME    Y02006*/
         MVC   ASIDSAVE(2),REQDASID                                0293
*       SGTBAPTR = ADDR(ZEROSEG);   /* BUT POINT TO A SEGTAB   Y02006*/
         LA    @14,ZEROSEG                                         0294
         ST    @14,SGTBAPTR                                        0294
*     END;                          /* ADDR OF ZERO            Y02006*/
*                                                                  0295
*   /*****************************************************************/
*   /*                                                               */
*   /* THE ADDRESS OF THE SEGMENT TABLE TO BE USED FOR THIS          */
*   /* TRANSLATION IS POINTED TO BY SGTBAPTR.  IF ZERO, EITHER       */
*   /* THE ASCBMAP BUILD RTN WAS UNABLE TO READ IT, OR REQD          */
*   /* ASID FOR THIS READ WAS NOT IN ASCBMAP.  IN THAT CASE,         */
*   /* TRANSLATION IMPOSSIBLE.  READ VIRTUAL.                        */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0296
*CHEKSEG:                           /* IF                      Y02006*/
*   IF SEGTADDR = 0 THEN            /* SEGTAB UNAVAILABLE FOR  Y02006*/
@RC00286 DS    0H                                                  0296
CHEKSEG  L     @14,SGTBAPTR                                        0296
         ICM   @04,7,SEGTADDR(@14)                                 0296
         BZ    @RT00296                                            0296
*     GOTO READVIRT;                /* THIS ASID THEN ATTEMPT  Y02006*/
*                                   /* TO READ REQUEST VIRT AD Y02006*/
*                                                                  0298
*   /*****************************************************************/
*   /*                                                               */
*   /* SEGMENT TABLE ADDR IS NON-ZERO.  TRANSLATION CAN BE           */
*   /* ATTEMPTED.  THE FIELD CONTAINING THE SEGTAB ADDR IS           */
*   /* PASSED TO DAT VIA SGTBAPTR.                                   */
*   /* THE VIRT. ADDR IS PASSED TO DAT IN SRCHAD. WHEN CONTROL IS    */
*   /* RETURNED SRCHAD WILL CONTAIN THE REAL ADDRESS, IF DAT WAS     */
*   /* SUCCESSFUL                                                    */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0298
*   VIRTSAVE = SRCHAD;              /* SAVE VITUAL DATA ADDR         */
         MVC   VIRTSAVE(4),SRCHAD                                  0298
*   CALL DAT;                       /* TRANS. VIRT TO REAL           */
         BAL   @14,DAT                                             0299
*   IF R15 = 0 THEN                 /* DAT SUCCESSFUL?               */
         LTR   R15,R15                                             0300
         BZ    @RT00300                                            0300
*     GOTO REALONLY;                /* YES, GO COMPARE REAL          */
*   SRCHAD = VIRTSAVE;              /* RESTORE REQD VIRT ADDR  Y02006*/
         MVC   SRCHAD(4),VIRTSAVE                                  0302
*   GOTO READVIRT;                  /* ATTEMPT TO READ REQD    Y02006*/
         B     READVIRT                                            0303
*                                   /* VIRTUAL ADDRESS         Y02006*/
*                                                                  0304
*   /*****************************************************************/
*   /*                                                               */
*   /* PROCESS REAL DATA REQUEST                                     */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0304
*                                                                  0304
*REALREQ:                                                          0304
*   IF REALMAP = 0 THEN             /* IS THERE A REAL DMP MAP?      */
REALREQ  ICM   @14,15,REALMAP(COMPTR)                              0304
         BZ    @RT00304                                            0304
*     GOTO FORMERR;                 /* NO, GO RAISE ERROR CONDITION  */
*   IF DATAAD > REALMAX THEN        /* CHK IF DATA ADDR IS WITHIN  0306
*                                      REAL STORAGE HIGH ADDRESS     */
         L     @14,PLIST                                           0306
         SLR   @04,@04                                             0306
         ICM   @04,7,DATAAD(@14)                                   0306
         C     @04,REALMAX(,COMPTR)                                0306
         BH    @RT00306                                            0306
*     GOTO FORMERR;                 /* INVALID ADDR - TAKE ERROR XIT */
*   SRCHAD = DATAAD;                /* PUT 24 BIT DATA ADDR IN PARM
*                                      WORD FOR COMPADDR AND READREC
*                                      SUBROUTINES                   */
*                                                                  0308
         ST    @04,SRCHAD                                          0308
*FIGOFSET:                                                         0309
*   OFFSET = SRCHAD//DATALNG;       /* COMPUTE OFFSET OF DATA IN BUF */
FIGOFSET L     @14,SRCHAD                                          0309
         LR    @06,@14                                             0309
         SRDA  @06,32                                              0309
         D     @06,@CF01096                                        0309
         ST    @06,OFFSET                                          0309
*   SRCHAD = (SRCHAD & RNDVALU);    /* ROUND DOWN TO 4K BNDRY        */
*                                                                  0310
         N     @14,@CF01082                                        0310
         ST    @14,SRCHAD                                          0310
*   /*****************************************************************/
*   /*                                                               */
*   /* PERFORM REAL ADDRESS PREFIXING, IF NECESSARY                  */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0311
*   IF SRCHAD = 0 THEN              /* IF REQD REAL BLOCK = 0  Y02006*/
         LTR   @14,@14                                             0311
         BNZ   @RF00311                                            0311
*     SRCHAD = PREFXRGR;            /* USE PREFIX VALUE        Y02006*/
         MVC   SRCHAD(4),PREFXRGR(COMPTR)                          0312
*   ELSE                            /* OR                      Y02006*/
*       DO;                         /* IF THE REQD REAL        Y02006*/
         B     @RC00311                                            0313
@RF00311 DS    0H                                                  0314
*         IF SRCHAD = PREFXRGR THEN /* BLOCK = THE PREFIX VALU Y02006*/
         CLC   SRCHAD(4),PREFXRGR(COMPTR)                          0314
         BNE   @RF00314                                            0314
*           SRCHAD = 0;             /* USE 0                   Y02006*/
         SLR   @14,@14                                             0315
         ST    @14,SRCHAD                                          0315
*       END;                                                       0316
*                                                                  0316
@RF00314 DS    0H                                                  0317
*   /*****************************************************************/
*   /*                                                               */
*   /* LOCATE BUFFER CONTAINING REAL DATA ADDRESS                    */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0317
*                                                                  0317
*REALONLY:                                                         0317
*   CPUIDAD = OFF;                  /* INDICATE REAL OR VIRT   Y02006*/
@RC00311 DS    0H                                                  0317
REALONLY DS    0H                                                  0318
*                                   /* ADDRESS REQUEST         Y02006*/
*   REALADDR = ON;                  /* INDICATE REAL ADDR REQ        */
         OI    REALADDR,B'00100000'                                0318
         NI    CPUIDAD,B'10111111'                                 0318
*   CALL COMPADDR;                  /* SRCH FOR A BUF CONTAINING ADDR
*                                      IN SRCHAD                     */
         BAL   @14,COMPADDR                                        0319
*   IF R15 ^= 0 THEN                /* ADDR FOUND?                   */
         LTR   R15,R15                                             0320
         BZ    @RF00320                                            0320
*     DO;                           /* NO- ATTEMPT TO READ IT  Y02006*/
*       IF DMPIC = ON THEN          /* UNLESS ALL OF DUMP      Y02006*/
         TM    DMPIC(COMPTR),B'00010000'                           0322
         BO    @RT00322                                            0322
*         GOTO FORMERR;             /* IS IN CORE              Y02006*/
*       ELSE                                                       0324
*     CALL READREC;                 /* NO, READ DMP RCD ASSOCIATED 0324
*                                      WITH SRCHAD                   */
         BAL   @14,READREC                                         0324
*     END;                                                  /* Y02006*/
*                                                                  0325
*   /*****************************************************************/
*   /*                                                               */
*   /* BUFFER CONTAINING REAL ADDR FOUND. IF DATA REQUEST IS A       */
*   /* VIRTUAL DATA REQUEST USING REAL DUMP MAP PUT VIRTUAL ADDR IN  */
*   /* BUF MAP ENTRY.                                                */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0326
*   IF PRNTREAL = ON THEN           /* REAL DATA REQUEST?      Y02006*/
@RF00320 TM    PRNTREAL(COMPTR),B'00000100'                        0326
         BO    @RT00326                                            0326
*     GOTO TESTDATA;                /* YES, GO TEST IF VALID   Y02006*/
*                                                                  0327
*                                   /* NO, SAVE VIRT ADDR IN BUF MAP */
*   MAPPTR = CURENTRY;              /* POINT TO BUF MAP ENTRY        */
         L     MAPPTR,CURENTRY                                     0328
*   BUFFVIRT = VIRTSAVE;            /* GET VIRT. ADDR THAT WAS TRANS.
*                                      TO REAL AND PUT IT IN THE BUF */
         MVC   BUFFVIRT(4,MAPPTR),VIRTSAVE                         0329
*   BUFFASID = REQDASID;            /* PUT ASID IN BUFFER ALSO Y02006*/
*                                                                  0330
         MVC   BUFFASID(2,MAPPTR),REQDASID                         0330
*   /*****************************************************************/
*   /*                                                               */
*   /* BUFFER ASSOCIATED WITH DATA REQUEST HAS BEEN FOUND. CHECK IF  */
*   /* DATA IN BUFFER IS VALID.                                      */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0331
*                                                                  0331
*TESTDATA:                                                         0331
*   MAPPTR = CURENTRY;              /* POINT TO BUF MAP ENTRY        */
TESTDATA L     MAPPTR,CURENTRY                                     0331
*   IF INVALFLG = ON THEN           /* DATA IN BUF INVALID?          */
*                                                                  0332
         TM    INVALFLG(MAPPTR),B'10000000'                        0332
         BNO   @RF00332                                            0332
*FORMERR:                           /* YES, RAISE ERROR CONDITION    */
*     DO;                                                          0333
FORMERR  DS    0H                                                  0334
*       FMTERR = ON;                /* INDICATE FORMAT ERROR   Y02006*/
         OI    FMTERR(COMPTR),B'01000000'                          0334
*       GOTO FREESAVE;              /* GO TO ERROR XIT               */
         B     FREESAVE                                            0335
*     END FORMERR;                                                 0336
*                                                                  0336
*   /*****************************************************************/
*   /*                                                               */
*   /* REQUESTED DATA IN BUFFER IS VALID. GET ADDR OF REQUESTED DATA */
*   /* IN BUFFER AND RETURN TO CALLER                                */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0337
*                                                                  0337
*OFFSETSV:                                                         0337
*   R1 = BUFFPTR + OFFSET + PREFX; /* GET ADDR OF REQ DATA IN BUF*/
@RF00332 DS    0H                                                  0337
OFFSETSV SLR   R1,R1                                               0337
         ICM   R1,7,BUFFPTR(MAPPTR)                                0337
         AL    R1,OFFSET                                           0337
         AH    R1,@CH00043                                         0337
*DATRETRN:                                                  /* Y02006*/
*GENERATE;                                                  /* Y02006*/
*                                                                  0338
DATRETRN DS    0H                                                  0338
         L     R13,4(R13)                                        Y02006
         LM    R14,R0,12(R13)                                    Y02006
         LM    R2,R12,28(R13)                                    Y02006
         BR    R14                                               Y02006
*   /*****************************************************************/
*   /*                                                               */
*   /* PROCESS CPU DATA REQUEST                                      */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0339
*CPUREQST:                                                         0339
*   ZEROCPU = ''B;                  /* ZERO OUT CPU STATUS     Y02006*/
CPUREQST XC    ZEROCPU(192),ZEROCPU                                0339
*                                   /* FIXED AREA              Y02006*/
*   SRCHAD = CPUAD;                 /* MOVE 8 BIT CPU ADDR TO  Y02006*/
         L     @14,PLIST                                           0340
         SLR   @04,@04                                             0340
         IC    @04,CPUAD(,@14)                                     0340
         ST    @04,SRCHAD                                          0340
*                                   /* PARM WORD FOR COMPADDR  Y02006*/
*   IF QSADMP = OFF THEN            /* SADMP INPUT?            Y02006*/
         TM    QSADMP(COMPTR),B'00100000'                          0341
         BNZ   @RF00341                                            0341
*     DO;                           /* NO- SVCDUMP OR DSSDUMP  Y02006*/
*                                   /* INPUT                   Y02006*/
*                                                                  0343
*   /*****************************************************************/
*   /*                                                               */
*   /* CPU STATUS INFO IS CONTAINED IN THE SVC OR DSS DUMP           */
*   /* HEADER RECORD PLACED IN COMMON BY PREAD OR PRLOD.             */
*   /* MOVE REQUESTED CPU INFO TO CPUSTAT FIXED AREA FOR             */
*   /* RETURN TO CALLER IF CORRECT CPU ADDR WAS REQUESTED.           */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0343
*       IF SRCHCPU ^= IPLCPU THEN   /* DID CALLER REQUEST IPL  Y02006*/
         CLC   SRCHCPU(2),IPLCPU(COMPTR)                           0343
         BNE   @RT00343                                            0343
*                                   /* CPU?                    Y02006*/
*         GOTO FORMERR;             /* NO- ERROR RETURN        Y02006*/
*                                                                  0344
*   /*****************************************************************/
*   /*                                                               */
*   /* REQUESTED CPU CORRECT- MOVE CPU DATA TO CPUSTAT               */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0345
*       HDRREGS1 = HDRREGS;         /* MOVE REGS & PSW TO AREA Y02006*/
         MVC   HDRREGS1(168),HDRREGS(COMPTR)                       0345
*       CPUNSADP = ON;              /* INDICATE NON-SADMP      Y02006*/
         OI    CPUNSADP,B'00010000'                                0346
*       R1 = ADDR(CPUSTAT);         /* SET PARM REG TO ADDR    Y02006*/
         LA    R1,CPUSTAT                                          0347
*                                   /* OF REQD DATA            Y02006*/
*       GOTO DATRETRN;              /* RETURN TO CALLER        Y02006*/
         B     DATRETRN                                            0348
*     END;                                                         0349
*                                                                  0349
*   /*****************************************************************/
*   /*                                                               */
*   /* INPUT IS FROM SADMP.  REQUESTED CPU DATA IS CONTAINED         */
*   /* IN A CPU STATUS RECORD DUMPED BY SADMP AND IDENTIFIED         */
*   /* BY THE ADDR OF THE CPU REQUESTED.  SCAN BUFFERS IN CASE       */
*   /* RECORD IS ALREADY IN CORE.  IF NOT, CALL PREAD TO READ        */
*   /* THE REQUESTED RECORD.                                         */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0350
*   CPUIDAD = ON;                   /* INDICATE TO COMPADDR TO Y02006*/
@RF00341 OI    CPUIDAD,B'01000000'                                 0350
*                                   /* SEARCH ON CPU ID        Y02006*/
*   CALL COMPADDR;                  /* CHECK IF REQD RECORD    Y02006*/
         BAL   @14,COMPADDR                                        0351
*                                   /* IN A BUFFER             Y02006*/
*   IF R15 ^= 0 THEN                /* WAS IT?                 Y02006*/
         LTR   R15,R15                                             0352
         BZ    @RF00352                                            0352
*     DO;                           /* NO- ATTEMPT TO READ IT  Y02006*/
*       IF DMPIC = ON THEN          /* UNLESS ALL OF DUMP      Y02006*/
         TM    DMPIC(COMPTR),B'00010000'                           0354
         BO    @RT00354                                            0354
*         GOTO FORMERR;             /* IS IN CORE              Y02006*/
*       ELSE                                                /* Y02006*/
*         CALL READREC;                                     /* Y02006*/
         BAL   @14,READREC                                         0356
*     END;                                                         0357
*   MAPPTR = CURENTRY;              /* POINT TO BUFMAP ENTRY   Y02006*/
@RF00352 L     MAPPTR,CURENTRY                                     0358
*   IF INVALFLG = ON THEN           /* DATA IN BUF VALID?      Y02006*/
         TM    INVALFLG(MAPPTR),B'10000000'                        0359
         BO    @RT00359                                            0359
*     GOTO FORMERR;                 /* NO- ERROR RETURN        Y02006*/
*                                                                  0360
*   /*****************************************************************/
*   /*                                                               */
*   /* REQUESTED CPU STATUS RECORD IN BUFFER AND VALID               */
*   /* MOVE TO FIXED AREA FOR RETURN TO CALLER                       */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0361
*   CPUFLAGS = FLAGS;               /* FLAGS FIELD             Y02006*/
         SLR   @14,@14                                             0361
         ICM   @14,7,BUFFPTR(MAPPTR)                               0361
         MVC   CPUFLAGS(1),FLAGS(@14)                              0361
*   CPUADDR = CPUADDR1;             /* CPU ID ADDR             Y02006*/
         MVC   CPUADDR(2),CPUADDR1(@14)                            0362
*   CPUFLPT = CSRFLPT;              /* FLOATING POINT REGS     Y02006*/
         MVC   CPUFLPT(32),CSRFLPT(@14)                            0363
*   CPUREGS = CSRREGS;              /* GENERAL PURPOSE REGS    Y02006*/
         MVC   CPUREGS(64),CSRREGS(@14)                            0364
*   CPUCTL = CSRCTL;                /* CONTROL REGS            Y02006*/
         MVC   CPUCTL(64),CSRCTL(@14)                              0365
*   CPUPSW = CSRPSW;                /* CURRENT PSW             Y02006*/
         MVC   CPUPSW(8),CSRPSW(@14)                               0366
*   CPUPSA = CSRPSA;                /* PREFIX SAVE AREA        Y02006*/
         MVC   CPUPSA(4),CSRPSA(@14)                               0367
*   CPUTIMER = CSRTIMER;            /* CPU TIMER               Y02006*/
         MVC   CPUTIMER(8),CSRTIMER(@14)                           0368
*   CPUCLKCP = CSRCLKCP;            /* CLOCK COMPARATOR        Y02006*/
*                                                                  0369
         MVC   CPUCLKCP(8),CSRCLKCP(@14)                           0369
*   R1 = ADDR(CPUSTAT);             /* SET PARM REG TO ADDR    Y02006*/
         LA    R1,CPUSTAT                                          0370
*                                   /* OF REQUESTED DATA       Y02006*/
*   GOTO DATRETRN;                  /* RETURN TO CALLER        Y02006*/
         B     DATRETRN                                            0371
*   /*****************************************************************/
*   /*                                                               */
*   /* GETBUFS-                                                      */
*   /* THIS SUBROUTINE ACQUIRES THE DUMP BUFFER AREA FOR AMDPRDMP    */
*   /* PROCESSING. IT IS CALLED ONLY DURING INIT PROCESSING          */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0372
*GETBUFS:                                                          0372
*   PROC;                                                          0372
*                                                                  0372
         B     @EL00001                                            0372
GETBUFS  STM   @14,@12,@SA00002                                    0372
*   DCL                                                            0373
*     SVMLIMIT FIXED(31) CONSTANT(196608); /* 192K- PROVIDES   Y02006*/
*                                   /* EQUIVALENT STORAGE ALGO Y02006*/
*                                   /* RITHM TO THE ONE USED   Y02006*/
*                                   /* IN SVM PRDMP FOR THE    Y02006*/
*                                   /* FIRST 256K OF STORAGE   Y02006*/
*                                   /* ALLOCATED TO PRDMP.     Y02006*/
*   DCL                                                            0374
*     CORE1 FIXED(31);              /* WORK AREAS FOR CALC-    Y02006*/
*   DCL                             /* ULATING AMOUNT OF       Y02006*/
*     CORE2 FIXED(31);              /* STORAGE FOR PRDMP BUFS  Y02006*/
*   DCL                                                            0376
*     ADDSPACE FIXED(31);           /* DITTO                   Y02006*/
*   DCL                                                            0377
*     ASDEFMAX FIXED(31) CONSTANT(200); /* DEFAULT VALUE IN    Y02006*/
*                                   /* ASCBMAX IN COMMON       Y02006*/
*   DCL                                                            0378
*     ASCBWORK FIXED(31) CONSTANT(512); /* AMOUNT OF WORK      Y02006*/
*                                   /* STORAGE REQD FOR EACH   Y02006*/
*                                   /* ASCB OVER DEFAULT OF    Y02006*/
*                                   /* 200 IN ASCBMAX IN COM   Y02006*/
*                                                                  0379
*   GEN(GETMAIN VC,LA=REQSTOR,A=GOTSTOR,SP=1); /* GET ALL STG  Y02006*/
         GETMAIN VC,LA=REQSTOR,A=GOTSTOR,SP=1
*   IF R15 ^= 0 THEN                /* CHK IF GETMAIN FAILED         */
         LTR   R15,R15                                             0380
         BZ    @RF00380                                            0380
*     RETURN TO AMD151I;            /* YES,GO ISSUE ERROR MSG  Y02006*/
*                                                                  0381
         LA    @14,AMD151I                                         0381
         LM    @15,@12,@SA00002+4                                  0381
         BR    @14                                                 0381
*   /*****************************************************************/
*   /*                                                               */
*   /* GETMAIN FOR BUFFER SPACE WAS SUCCESSFUL. CALCULATE SPACE      */
*   /* REQUIRED FOR BUFFER MAP AND BUFFERS                           */
*   /*                                                               */
*   /* IF CORE <= 192K GET 7 BUFFERS FOR THE FIRST 64K OF AVAILABLE  */
*   /* STORAGE AND 9 BUFFERS FOR EACH ADDITIONAL 64K.                */
*   /* IF CORE > 192K USE THE SAME ALGORITHM AS ABOVE FOR THE FIRST  */
*   /* 192K OF CORE.  FOR THE STORAGE IN EXCESS OF 192K, FIRST,      */
*   /* LEAVE 512 BYTES FREE FOR EACH (NUMBER) ASCB IN ASCBMAX > 200. */
*   /* IF THIS AMOUNT IS GREATER THAN OR EQUAL TO THE EXCESS OVER    */
*   /* 192K, THEN FREE IT ALL AND GET NO ADDITIONAL BUFFERS.         */
*   /* OTHERWISE, USE THE REMAINING STORAGE TO GET AS MANY ADDITIONAL*/
*   /* BUFFERS AS POSSIBLE.                                          */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0382
*   IF CORE > SVMLIMIT THEN                                 /* Y02006*/
@RF00380 L     @14,CORE                                            0382
         L     @04,@CF01304                                        0382
         CR    @14,@04                                             0382
         BNH   @RF00382                                            0382
*     DO;                                                   /* Y02006*/
*       CORE1 = SVMLIMIT;                                   /* Y02006*/
         L     @09,@CF01304                                        0384
         LR    CORE1,@09                                           0384
*       CORE2 = CORE - SVMLIMIT;                            /* Y02006*/
         SLR   @14,@09                                             0385
         LR    CORE2,@14                                           0385
*     END;                                                  /* Y02006*/
*   ELSE                                                    /* Y02006*/
*     DO;                                                   /* Y02006*/
         B     @RC00382                                            0387
@RF00382 DS    0H                                                  0388
*       CORE1 = CORE;                                       /* Y02006*/
         L     CORE1,CORE                                          0388
*       CORE2 = 0;                                          /* Y02006*/
         SLR   CORE2,CORE2                                         0389
*     END;                                                  /* Y02006*/
*                                                                  0390
*   BUFSPACE = (7 + (CORE1 / SEGSIZE - 1) * 9) *                   0391
*                                   (RCDLNG + ENTRYLNG);    /* Y02006*/
*                                                                  0391
@RC00382 LR    @06,CORE1                                           0391
         SRDA  @06,32                                              0391
         D     @06,@CF01100                                        0391
         BCTR  @07,0                                               0391
         MH    @07,@CH00171                                        0391
         AH    @07,@CH01163                                        0391
         MH    @07,@CH01455                                        0391
         ST    @07,BUFSPACE                                        0391
*   IF CORE2 > 0 THEN                                       /* Y02006*/
         SLR   @14,@14                                             0392
         CR    CORE2,@14                                           0392
         BNH   @RF00392                                            0392
*     DO;                                                   /* Y02006*/
*       ADDSPACE = (ASCBMAX - ASDEFMAX) * ASCBWORK;         /* Y02006*/
*                                                                  0394
         LH    ADDSPACE,ASCBMAX(,COMPTR)                           0394
         SH    ADDSPACE,@CH01309                                   0394
         SLA   ADDSPACE,9                                          0394
*       IF ADDSPACE > 0 THEN                                /* Y02006*/
         CR    ADDSPACE,@14                                        0395
         BNH   @RF00395                                            0395
*         CORE2 = CORE2 - ADDSPACE;                         /* Y02006*/
*                                                                  0396
         SLR   CORE2,ADDSPACE                                      0396
*       IF CORE2 > 0 THEN                                   /* Y02006*/
@RF00395 LTR   CORE2,CORE2                                         0397
         BNP   @RF00397                                            0397
*         BUFSPACE = BUFSPACE + (CORE2 / (RCDLNG + ENTRYLNG)) *    0398
*                                   (RCDLNG + ENTRYLNG);    /* Y02006*/
         LH    @14,@CH01455                                        0398
         LR    @06,CORE2                                           0398
         SRDA  @06,32                                              0398
         DR    @06,@14                                             0398
         MR    @06,@14                                             0398
         AL    @07,BUFSPACE                                        0398
         ST    @07,BUFSPACE                                        0398
*     END;                                                  /* Y02006*/
*                                                                  0399
@RF00397 DS    0H                                                  0400
*   /*****************************************************************/
*   /*                                                               */
*   /* ROUND BUFFER SPACE TO NEXT HIGHEST DOUBLE WORD MULTIPLE       */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0400
*   BUFSPACE = BUFSPACE + 7;                                       0400
@RF00392 LA    @14,7                                               0400
         AL    @14,BUFSPACE                                        0400
         ST    @14,BUFSPACE                                        0400
*   BUFSPACE = (BUFSPACE & 'FFFFFFF8'X);                           0401
*                                                                  0401
         N     @14,@CF01312                                        0401
         ST    @14,BUFSPACE                                        0401
*   /*****************************************************************/
*   /*                                                               */
*   /* DETERMINE AMOUNT OF EXCESS SPACE GOTTEN AND FREE THIS EXCESS  */
*   /* SPACE FROM TOP OF GOTTEN SPACE                                */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0402
*   R1 = BUFMAP + BUFSPACE;         /* POINT TO EXCESS SPACE         */
         L     R1,BUFMAP                                           0402
         ALR   R1,@14                                              0402
*   BUFSUBPL = 1;                   /* SET SUBPOOL TO FREE     Y02006*/
         MVI   BUFSUBPL,X'01'                                      0403
*   R0 = CORE - BUFSPACE;           /* CALCULATE EXCESS SPACE        */
         LCR   @14,@14                                             0404
         AL    @14,CORE                                            0404
         LR    R0,@14                                              0404
*   GEN(FREEMAIN R,LV=(0),A=(1));   /* FREE EXCESS SPACE             */
*                                                                  0405
         FREEMAIN R,LV=(0),A=(1)
*   /*****************************************************************/
*   /*                                                               */
*   /* SAVE SIZE OF BUFFER SPACE AND CALL BUFINIT TO INITIALIZE THE  */
*   /* BUFFER MAP AND BUFFERS                                        */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0406
*   CORE = BUFSPACE;                /* SAVE SIZE OF BUF AREA         */
         MVC   CORE(4),BUFSPACE                                    0406
*   RETURN;                         /* RETURN TO CALLER        Y02006*/
@EL00002 DS    0H                                                  0407
@EF00002 DS    0H                                                  0407
@ER00002 LM    @14,@12,@SA00002                                    0407
         BR    @14                                                 0407
*   END GETBUFS;                                                   0408
*   /*****************************************************************/
*   /*                                                               */
*   /* BUFINIT -                                                     */
*   /*                                                               */
*   /*       THIS INTERNAL PROCEDURE INITIALIZES THE BUFFER MAP AND  */
*   /*       DUMP BUFFERS. IT IS CALLED ONLY DURING THE INIT FUNCTION*/
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0409
*                                                                  0409
*BUFINIT:                                                          0409
*   PROC;                                                          0409
BUFINIT  STM   @14,@12,12(@13)                                     0409
*   DCL                                                            0410
*         BUFPTR PTR(31);           /* PTR TO DUMP BUFFERS           */
*   DCL                                                            0411
*         BUFNO FIXED(31);          /* NO. OF BUFFERS TO BE INIT.    */
*   DCL                                                            0412
*         MAPSIZE FIXED(31);        /* SIZE OF BUF MAP               */
*                                                                  0412
*   /*****************************************************************/
*   /*                                                               */
*   /* BEGIN BUFINIT PROCESSING                                      */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0413
*   BUFREINT = BUFREINT + 1;        /* UPDATE COUNT OF BUFFER INITS  */
         LA    @14,1                                               0413
         AL    @14,BUFREINT(,COMPTR)                               0413
         ST    @14,BUFREINT(,COMPTR)                               0413
*   BUFNO = CORE/(RCDLNG + ENTRYLNG); /* CACULATE NUMBER OF BUFFS    */
         L     @08,CORE                                            0414
         SRDA  @08,32                                              0414
         D     @08,@CF01455                                        0414
         LR    BUFNO,@09                                           0414
*   BUFSUM = BUFNO;                 /* SAVE NO. OF BUFS IN COMMON    */
         ST    BUFNO,BUFSUM(,COMPTR)                               0415
*   MAPPTR = BUFMAP;                /* POINT TO 1ST MAP ENTRY        */
         L     MAPPTR,BUFMAP                                       0416
*   BUFERMAP = MAPPTR;              /* STORE 1ST MAP ENTRY     Y02006*/
         ST    MAPPTR,BUFERMAP(,COMPTR)                            0417
*                                   /* IN COMMON FOR LOD       Y02006*/
*   CURENTRY = MAPPTR;              /* SET CURRENT BUFMAP ENTRY PTR
*                                      TO FIRST MAP ENTRY            */
         ST    MAPPTR,CURENTRY                                     0418
*   MAPSIZE = BUFNO * ENTRYLNG;     /* CALC SIZE OF BUF MAP          */
         LR    @14,BUFNO                                           0419
         MH    @14,@CH00213                                        0419
         ST    @14,MAPSIZE                                         0419
*   BUFPTR = MAPPTR + MAPSIZE;      /* POINT TO FIRST BUF            */
*                                                                  0420
         ALR   @14,MAPPTR                                          0420
         LR    BUFPTR,@14                                          0420
*   /*****************************************************************/
*   /*                                                               */
*   /* INITIALIZE MAP ENTRY                                          */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0421
*                                                                  0421
*INITMAP:                                                          0421
*   BUFFPTR = BUFPTR;               /* INIT BUFF ADDR IN ENTRY       */
INITMAP  STCM  BUFPTR,7,BUFFPTR(MAPPTR)                            0421
*   BUFFFLAG = FLAGINIT;            /* INIT FLAG BYTE IN ENTRY       */
         MVI   BUFFFLAG(MAPPTR),X'00'                              0422
*   BUFFIELD = BUFFINIT;            /* REINIT BUFFER MAP ENTRY Y02006*/
*                                                                  0423
         MVC   BUFFIELD(12,MAPPTR),BUFFINIT                        0423
*   /*****************************************************************/
*   /*                                                               */
*   /* CHECK IF ALL MAP ENTRIES HAVE BEEN INITIALIZED                */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0424
*   BUFNO = BUFNO - 1;              /* DECREMENT NO. OF BUFS         */
         BCTR  BUFNO,0                                             0424
*   IF BUFNO ^= 0 THEN              /* CHK IF ANYMORE BUFS           */
         LTR   BUFNO,BUFNO                                         0425
         BZ    @RF00425                                            0425
*     DO;                           /* YES DO FOLLOWING              */
*       BUFFLINK = MAPPTR + ENTRYLNG; /* INIT CHAIN PTR IN MAP ENTRY
*                                        WITH ADDR OF NEXT ENTRY     */
         LA    @14,20                                              0427
         LR    @07,MAPPTR                                          0427
         ALR   @07,@14                                             0427
         ST    @07,BUFFLINK(,MAPPTR)                               0427
*       MAPPTR = MAPPTR + ENTRYLNG; /* POINT TO NEXT ENTRY           */
         ALR   MAPPTR,@14                                          0428
*       BUFPTR = BUFPTR + RCDLNG;   /* POINT TO NEXT BUFFER          */
         AH    BUFPTR,@CH01103                                     0429
*       GOTO INITMAP;               /* GO INIT MAP ENTRY             */
         B     INITMAP                                             0430
*     END;                                                         0431
*                                                                  0431
*   /*****************************************************************/
*   /*                                                               */
*   /* NO MORE MAP ENTRIES TO INITIALIZE                             */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0432
*   BUFFLINK = 0;                   /* INDICATE END OF BUF MAP CHAIN */
@RF00425 SLR   @14,@14                                             0432
         ST    @14,BUFFLINK(,MAPPTR)                               0432
*   RETURN;                         /* GO BACK TO CALLER             */
@EL00003 DS    0H                                                  0433
@EF00003 DS    0H                                                  0433
@ER00003 LM    @14,@12,12(@13)                                     0433
         BR    @14                                                 0433
*   END BUFINIT;                                                   0434
*                                                                  0434
*   /*****************************************************************/
*   /*                                                               */
*   /* BILDASCB-                                                     */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0435
*BILDASCB:                                                         0435
*   PROC;                                                          0435
BILDASCB STM   @14,@12,@SA00004                                    0435
*   /*****************************************************************/
*   /*                                                               */
*   /*  CONSTANTS AND VARIABLES USED BY BILDASCB                     */
*   /*                                                               */
*   /*****************************************************************/
*   DCL                                                            0436
*     ASCBFREE INTERNAL ENTRY;      /* ASCBMAP FREE ROUTINE    Y02006*/
*   DCL                                                            0437
*     IBRRDERR LOCAL LABEL;         /* INIT BRREAD ERROR RTN   Y02006*/
*   DCL                                                            0438
*     ERRHANSV PTR(31);             /* SAVE AREA FOR CURRENT   Y02006*/
*                                   /* ERROR HANDLER           Y02006*/
*   DCL                                                            0439
*     QASIDSAV BIT(16);             /* SAVE AREA FOR QASID     Y02006*/
*   DCL                                                            0440
*     ASCBMLEN FIXED(31) INIT(0);   /* AREA TO COMPUTE LENGTHS Y02006*/
*                                   /* FOR MAP AND TABLE       Y02006*/
*   DCL                                                            0441
*     RNDVAL1  FIXED(15) CONSTANT(7);  /* DOUBLEWORD INCREMENT Y02006*/
*   DCL                                                            0442
*     RNDVAL2  BIT(32) CONSTANT('FFFFFFF8'X); /* DOUBLEWORD    Y02006*/
*                                      /* ROUND DOWN MASK      Y02006*/
*   DCL                                                            0443
*     DISPQEND PTR(31);             /* END ADDR OF ASCB DISPAT Y02006*/
*                                   /* QUEUE-NORMALLY = ZERO   Y02006*/
*                                   /* BUT = ADDR OF LAST ASCB Y02006*/
*                                   /* ENTERED INTO ASCBMAP    Y02006*/
*                                   /* ON FORWARD CHAIN SEARCH Y02006*/
*                                   /* WHEN CHAIN BROKEN       Y02006*/
*   DCL                                                            0444
*     CVTREADA PTR(31);             /* ADDR INTO CVT TO EITHER Y02006*/
*                                   /* 1ST OR LAST ASCB ADDR   Y02006*/
*                                   /* ON DISP Q               Y02006*/
*   DCL                                                            0445
*     ASCBERR FIXED(15);            /* ASCB ERROR HANDLER CODE Y02006*/
*   DCL                                                            0446
*     ASCHAIN  FIXED(31);           /* ADDR INTO ASCB TO FORW- Y02006*/
*                                   /* ARD OR BACK CHAIN PTRS  Y02006*/
*   DCL                                                            0447
*     1 ASMPBSW CHAR(1) INIT('00'X), /* ASCBMAP BUILD ROUTINE  Y02006*/
*                                   /* PROCESS SWITCHES        Y02006*/
*       3 ASCBERMG BIT(1),          /* ON MEANS AMD292I REQD   Y02006*/
*       3 ASCBLIMG BIT(1),          /* ON MEANS AMD293I REQD   Y02006*/
*       3 ASMPFREE BIT(1),          /* ON = FREE ENTIRE MAP    Y02006*/
*                                   /* OFF = FREE ONLY PART    Y02006*/
*       3 ASRESVMG BIT(5);          /* FUTURE USE              Y02006*/
*   DCL                                                            0448
*     M293AMAX CHAR(5) BASED(R1+50); /* FIELD OF AMD293I TO    Y02006*/
*                                    /* CONTAIN CONVERTED      Y02006*/
*                                    /* ASCBMAX                Y02006*/
*   DCL                                                            0449
*     DECCNVT CHAR(3);              /* FOR CONVERT TO DECIMAL  Y02006*/
*   DCL                                                            0450
*     (ASERCD00,                    /* ASCBMAP BUILD ERROR     Y02006*/
*      ASERCD04,                    /* HANDLER ROUTINES-       Y02006*/
*      ASERCD08,                    /* GET CONTROL BASED ON    Y02006*/
*      ASERCD10) LABEL;             /* VALUE OF ASCBERR        Y02006*/
*                                                                  0450
*   /*****************************************************************/
*   /*                                                               */
*   /* THE FOLLOWING BRANCH TABLE IS USED ON ENTRY TO                */
*   /* ASCBMAP ERROR HANDLER RTN- IBRRDERR                           */
*   /* TO INITIATE APPROPRIATE PROCESSING BASED ON ASCBERR           */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0451
*   DCL                                                            0451
*     ASERBRTB(6) PTR(31) INIT(ADDR(ASERCD00),ADDR(ASERCD04),      0451
*       ADDR(ASERCD08),ADDR(ASERCD10),ADDR(ASERCD04),              0451
*       ADDR(ASERCD08));                                    /* Y02006*/
*                                                                  0451
*   DCL                                                            0452
*     FASIDVAL BIT(16) INIT('FFFF'X); /* FOR 'ZEROING' ASID IF Y02006*/
*                                   /* BRREAD ERROR WITH FFFF  Y02006*/
*                                                                  0453
*   /*****************************************************************/
*   /*                                                               */
*   /* BILDASCB INITIAL PROCESSING                                   */
*   /* THE FOLLOWING SECTIONS DOWN TO THE CHECK FOR CVTADDR  ARE     */
*   /* EXECUTED WHETHER OR NOT WE ARE ABLE TO BUILD A NEW ASCBMAP    */
*   /* FOR THE NEW DUMP. I.E. THE 'QUICK FIND' VARIABLES ASIDSAVE    */
*   /* AND SGTBAPTR MUST BE RESET AND THE OLD MAP FREED REGARDLESS   */
*   /* OF THE ABILITY OR DISABILITY OF BUILDING A NEW MAP.           */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0453
*   ASIDSAVE = 0;                   /* SINCE NEW ASCBMAP IS    Y02006*/
         SLR   @14,@14                                             0453
         STH   @14,ASIDSAVE                                        0453
*                                   /* BEING BUILT, INIT SAVE  Y02006*/
*                                   /* WORD FOR PREVIOUS REQD  Y02006*/
*                                   /* ASID = 0 AND THE CORRE- Y02006*/
*                                   /* SPONDING PTR TO ITS     Y02006*/
*   SGTBAPTR = ADDR(SEGTABOR);      /* SEGMENT TABLE ADDR TO   Y02006*/
         LA    @04,SEGTABOR(,COMPTR)                               0454
         ST    @04,SGTBAPTR                                        0454
*                                   /* ADDR OF SEGTABOR        Y02006*/
*                                                                  0455
*   /*****************************************************************/
*   /*                                                               */
*   /* FREE UP OLD ASCBMAP IF A PREVIOUS ONE EXISTS                  */
*   /* BEFORE REBUILDING NEW ONE                                     */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0455
*   IF ASCBMAP ^= 0 THEN            /* DOES OLD MAP EXIST?     Y02006*/
         L     @04,ASCBMAP(,COMPTR)                                0455
         CR    @04,@14                                             0455
         BE    @RF00455                                            0455
*     DO;                           /* YES-                    Y02006*/
*       ASCBNUM = 0;                /* THIS WILL CAUSE SUBRTN  Y02006*/
         STH   @14,ASCBNUM(,@04)                                   0457
*                                   /* ASCBFREE TO FREE ENTIRE Y02006*/
*                                   /* OLD ASCBMAP             Y02006*/
*       CALL ASCBFREE;              /* FREE IT                 Y02006*/
         BAL   @14,ASCBFREE                                        0458
*     END;                          /*                         Y02006*/
*   IF CVTADDR = 0 THEN             /* INSURE THAT CVT IS      Y02006*/
@RF00455 SLR   @14,@14                                             0460
         C     @14,CVTADDR(,COMPTR)                                0460
         BE    @RT00460                                            0460
*                                   /* AVAILABLE               Y02006*/
*     RETURN;                       /* OTHERWISE TERMINATE     Y02006*/
*                                                                  0461
*   /*****************************************************************/
*   /*                                                               */
*   /* CVT AVAILABLE. GO AHEAD AND ATTEMPT BUILD OF NEW ASCBMAP.     */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0462
*   ERRHANSV = ERRADDR;             /* SAVE THE CURRENT PRDMP  Y02006*/
         MVC   ERRHANSV(4),ERRADDR(COMPTR)                         0462
*                                   /* ERROR HANDLER           Y02006*/
*   ERRADDR = ADDR(IBRRDERR);       /* STORE THE ADDRESS OF    Y02006*/
         LA    @04,IBRRDERR                                        0463
         ST    @04,ERRADDR(,COMPTR)                                0463
*                                   /* BILDASCBS ERROR HANDLER Y02006*/
*   ASCBERMG = OFF;                 /* INDICATE NEITHER ERROR  Y02006*/
*   ASCBLIMG = OFF;                 /* MESSAGE REQD YET        Y02006*/
         NI    ASCBERMG,B'00111111'                                0465
*   PRNTREAL = OFF;                 /* INDICATE VIRTUAL READ   Y02006*/
*                                                                  0466
         NI    PRNTREAL(COMPTR),B'11111011'                        0466
*   /*****************************************************************/
*   /*                                                               */
*   /* SINCE RDC DATA ON READ REQUESTS FOR ASID 0 USES QASID,        */
*   /* RESET (QASID) CURRENT ASID FIELD IN COMMON TO 0 SUCH THAT     */
*   /* THE DATA FUNCTION WILL BE ABLE TO TRANSLATE VIRTUAL ADDRESSES */
*   /* PRIOR TO THE COMPLETION OF ASCBMAP.  THIS WAY RDC WILL USE    */
*   /* SEGTABOR SEGMENT TABLE FOR ADDRESS TRANSLATION.               */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0467
*   QASIDSAV = QASID;               /*                         Y02006*/
         MVC   QASIDSAV(2),QASID(COMPTR)                           0467
*   IF QSADMP = ON THEN           /* IF STAND-ALONE DUMP     OZ13024 */
         TM    QSADMP(COMPTR),B'00100000'                          0468
         BNO   @RF00468                                            0468
*     QASID = 0;                  /* DEFAULT TO ASID 0       OZ13024 */
*                                                                  0469
         STH   @14,QASID(,COMPTR)                                  0469
*   /*****************************************************************/
*   /*                                                               */
*   /* DETERMINE HOW MUCH SPACE IS REQUIRED FOR THIS ASCBMAPS        */
*   /* MAP AND TABLE SECTIONS AND OBTIAN THE REQD STORAGE            */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0470
*   IF ASCBMAX = 0 THEN             /* MAKE SURE NO ONE SET    Y02006*/
@RF00468 ICM   @14,3,ASCBMAX(COMPTR)                               0470
         BNZ   @RF00470                                            0470
*     DO;                           /* ASCBMAX IN COMMON TO 0- Y02006*/
*       ASCBLIMG = ON;              /* TERMINATE BUILD IF SO   Y02006*/
         OI    ASCBLIMG,B'01000000'                                0472
*       GOTO ASCBTRM1;              /* AFTER ISSUING MSG       Y02006*/
         B     ASCBTRM1                                            0473
*     END;                          /* AMD293I                 Y02006*/
*   ASCBMLEN = ASCBMAX * MAPNTRYL + MAPREFLN;               /* Y02006*/
@RF00470 LH    @14,ASCBMAX(,COMPTR)                                0475
         ALR   @14,@14                                             0475
         AH    @14,@CH00183                                        0475
         ST    @14,ASCBMLEN                                        0475
*                                   /* COMPUTE LEN FOR MAP     Y02006*/
*                                   /* BASED ON DEFAULT        Y02006*/
*                                   /* LIMIT OF ADDR SPACES    Y02006*/
*   ASCBMLEN = ASCBMLEN + RNDVAL1;  /* INCR PAST NEXT HIGH     Y02006*/
         AH    @14,@CH01163                                        0476
         ST    @14,ASCBMLEN                                        0476
*                                   /* DOUBLEWORD BOUNDARY     Y02006*/
*   ASCBMLEN = ASCBMLEN & RNDVAL2;  /* ROUND DOWN TO DOUBLE    Y02006*/
         N     @14,@CF01312                                        0477
         ST    @14,ASCBMLEN                                        0477
*                                   /* WORD BOUNDARY           Y02006*/
*   R0 = ASCBMLEN;                  /* SET LENGTH FOR GETMAIN  Y02006*/
         LR    R0,@14                                              0478
*   GEN(GETMAIN R,LV=(0));          /* GET STORAGE FOR         Y02006*/
         GETMAIN R,LV=(0)
*   ASCBMAP = R1;                   /* MAP SECTION AND PUT     Y02006*/
         ST    R1,ASCBMAP(,COMPTR)                                 0480
*                                   /* ADDR ASCBMAP IN COM     Y02006*/
*   ZEROPREF = ''B;                 /* SET MAP PREFIX = 0      Y02006*/
         L     @14,ASCBMAP(,COMPTR)                                0481
         XC    ZEROPREF(16,@14),ZEROPREF(@14)                      0481
*   ASMAPLEN = ASCBMLEN;            /* SAVE LEN OF MAP IN PREF Y02006*/
*                                                                  0482
         MVC   ASMAPLEN(4,@14),ASCBMLEN                            0482
*   ASCBMLEN = ASCBMAX * TABNTRYL;  /* COMPUTE LEN OF TABLE    Y02006*/
         LH    @14,ASCBMAX(,COMPTR)                                0483
         SLA   @14,3                                               0483
         ST    @14,ASCBMLEN                                        0483
*   ASCBMLEN = ASCBMLEN + RNDVAL1;  /* INCR PAST NEXT HIGH     Y02006*/
         AH    @14,@CH01163                                        0484
         ST    @14,ASCBMLEN                                        0484
*                                   /* DOUBLEWORD BOUNDARY     Y02006*/
*   ASCBMLEN = ASCBMLEN & RNDVAL2;  /* ROUND DOWN TO DOUBLE    Y02006*/
         N     @14,@CF01312                                        0485
         ST    @14,ASCBMLEN                                        0485
*                                   /* WORD BOUNDARY           Y02006*/
*   R0 = ASCBMLEN;                  /* SET LENGTH FOR GETMAIN  Y02006*/
         LR    R0,@14                                              0486
*   GEN(GETMAIN R,LV=(0));          /* GET STORAGE FOR         Y02006*/
         GETMAIN R,LV=(0)
*   ASCBTAB = R1;                   /* TABLE SECTION AND PUT   Y02006*/
         L     @14,ASCBMAP(,COMPTR)                                0488
         ST    R1,ASCBTAB(,@14)                                    0488
*                                   /* ADDR IN MAP PREFIX      Y02006*/
*   ASTABLEN = ASCBMLEN;            /* SAVE LEN OF TAB IN PREF Y02006*/
*                                                                  0489
         MVC   ASTABLEN(4,@14),ASCBMLEN                            0489
*   /*****************************************************************/
*   /*                                                               */
*   /* INITIALIZE FOR SEARCH OF ASCB DISPATCHING QUEUE               */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0490
*   ASMAPPTR = ASCBMAP + MAPREFLN;  /* INIT INDEX TO MAP ORIG  Y02006*/
         AH    @14,@CH00183                                        0490
         LR    ASMAPPTR,@14                                        0490
*   ASTABPTR = ASCBTAB;             /* INIT INDEX TO TABLE ORG Y02006*/
         L     @14,ASCBMAP(,COMPTR)                                0491
         L     @14,ASCBTAB(,@14)                                   0491
         LR    ASTABPTR,@14                                        0491
*   DISPQEND = 0;                   /* INDICATE END OF DISP 1  Y02006*/
         SLR   @14,@14                                             0492
         ST    @14,DISPQEND                                        0492
*                                   /* ON FORWARD SEARCH       Y02006*/
*   CVTREADA = ADDR(CVTASCBH);      /* SET CVT READ ADDR TO    Y02006*/
         L     @14,CVTPTR(,COMPTR)                                 0493
         LA    @14,CVTASCBH(,@14)                                  0493
         ST    @14,CVTREADA                                        0493
*                                   /* ADDR OF PTR TO 1SY ASCB Y02006*/
*   ASCBERR = 1;                    /* SET ERROR HANDLER CODE  Y02006*/
         LA    ASCBERR,1                                           0494
*                                   /* INTO ASCB OF FORWRD PTR Y02006*/
*                                                                  0495
*   RESPECIFY ASCB BASED(ADDRZERO);                         /* Y02006*/
*   ASCHAIN = ADDR(ASCBFWDP) - ADDR(ASCB); /* COMPUTE DISP TO  Y02006*/
         MVC   ASCHAIN(4),@CF00156                                 0496
*   RESPECIFY ASCB BASED(ASCBPTR);    /* FORWARD PTR IN ASCB   Y02006*/
*                                                                  0497
*                                                                  0497
*   /*****************************************************************/
*   /*                                                               */
*   /* BEGIN SEARCH OF ASCB DISPATCH QUEUE.                          */
*   /* SEARCH IS BY FORWARD PTRS DOWN THE CHAIN UNTIL END            */
*   /* OF QUEUE IS REACHED, UNLESS A BREAK IS ENCOUNTERED,           */
*   /* IN WHICH CASE, SEARCH RESUMES BY BACKWARD PTRS UP             */
*   /* THE QUEUE UNTIL POINT BEFORE THE BREAK OR UNTIL ANOTHER       */
*   /* BREAK OCCURS.                                                 */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0498
*QSEARCH:                                                          0498
*   R5 = CVTREADA;                  /* GET ADDR OF THE FIELD   Y02006*/
QSEARCH  L     R5,CVTREADA                                         0498
*                                   /* IN THE CVT THAT POINTS  Y02006*/
*                                   /* TO THE 1ST OR LAST ASCB Y02006*/
*                                   /* ON QUEUE                Y02006*/
*GENERATE REFS(BRRDDATA) FLOWS(IBRRDERR);                          0499
         BRREAD (R5),DATA,ASID=0       READ FOR ADDR OF 1ST OR   Y02006
*                                      LAST ASCB ON DISP Q       Y02006
*   IF R1->ASCBADDR = 0 THEN        /* IS CVTASCB FIELD = 0?   Y02006*/
         ICM   @14,15,ASCBADDR(R1)                                 0500
         BNZ   @RF00500                                            0500
*     GOTO ASERBRTB(ASCBERR);       /* YES- ERROR              Y02006*/
*                                                                  0501
         LR    @14,ASCBERR                                         0501
         SLA   @14,2                                               0501
         L     @14,ASERBRTB-4(@14)                                 0501
         BR    @14                                                 0501
*TABUPDAT:                                                         0502
*   ASCBADDR = R1->ASCBADDR;        /* MOVE ASCB ADDR TO THIS  Y02006*/
@RF00500 DS    0H                                                  0502
TABUPDAT MVC   ASCBADDR(4,ASTABPTR),ASCBADDR(R1)                   0502
*                                   /* TABLE ENTRY             Y02006*/
*   ASCBNUM = ASCBNUM + 1;          /* INCREMENT COUNT OF ASCB Y02006*/
         L     @14,ASCBMAP(,COMPTR)                                0503
         LA    @07,1                                               0503
         LH    @09,ASCBNUM(,@14)                                   0503
         ALR   @09,@07                                             0503
         STH   @09,ASCBNUM(,@14)                                   0503
*                                   /* IN ASCBMAP              Y02006*/
*   ASCBAFLG = OFF;                 /* MAKE SURE FLAG BIT OFF  Y02006*/
         NI    ASCBAFLG(ASTABPTR),B'01111111'                      0504
*   ASCBERR = ASCBERR + 1;          /* INCR ERROR HANDLER CODE Y02006*/
*                                                                  0505
         ALR   ASCBERR,@07                                         0505
*   R5 = ADDR(ASCBSTOR);            /* GET ADDR TO THE FIELD   Y02006*/
         L     R5,ASCBPTR(,ASTABPTR)                               0506
         LA    R5,ASCBSTOR(,R5)                                    0506
*                                   /* IN ASCB THAT CONTAINS   Y02006*/
*                                   /* THE REAL SEGTAB ADDR    Y02006*/
*   GEN(BRREAD (R5),DATA,ASID=0);   /* READ FOR REAL           Y02006*/
         BRREAD (R5),DATA,ASID=0
*                                   /* SEGTAB ADDR             Y02006*/
*SEGUPDAT:                                                         0508
*   SEGTBADR = R1->SGTBAD;          /* THIS TABLE ENTRY        Y02006*/
*                                                                  0508
SEGUPDAT MVC   SEGTBADR(4,ASTABPTR),SGTBAD(R1)                     0508
*   ASCBERR = ASCBERR + 1;          /* INCR ERROR HANDLER CODE Y02006*/
         AH    ASCBERR,@CH00057                                    0509
*   R5 = ADDR(ASCBASID);            /* GET ADDR TO THE FIELD   Y02006*/
         L     R5,ASCBPTR(,ASTABPTR)                               0510
         LA    R5,ASCBASID(,R5)                                    0510
*                                   /* IN ASCB THAT CONTAINS   Y02006*/
*                                   /* THE ASID                Y02006*/
*   GEN(BRREAD (R5),DATA,ASID=0);   /* READ FOR THE ASID       Y02006*/
         BRREAD (R5),DATA,ASID=0
*ASIDUPDT:                                                         0512
*   ASID = R1->ASID;                                               0512
*                                                                  0512
ASIDUPDT MVC   ASID(2,ASMAPPTR),ASID(R1)                           0512
*   ASCBERR = ASCBERR - 2;          /* RESET ERROR HANDLER COD Y02006*/
         BCTR  ASCBERR,0                                           0513
         BCTR  ASCBERR,0                                           0513
*   R5 = ASCBADDR + ASCHAIN;        /* GET ADDR TO THE FIELD   Y02006*/
         L     R5,ASCBADDR(,ASTABPTR)                              0514
         AL    R5,ASCHAIN                                          0514
*                                   /* IN ASCB THAT CONTIANS   Y02006*/
*                                   /* THE FORWARD OR BACKWARD Y02006*/
*                                   /* LINK TO NEXT ASCB ON Q  Y02006*/
*   GEN(BRREAD (R5),DATA,ASID=0);   /* READ FOR NEXT ASCB ADDR Y02006*/
         BRREAD (R5),DATA,ASID=0
*   /*****************************************************************/
*   /*                                                               */
*   /* BEFORE ADDING THIS NEXT ENTY TO ASCBMAP, INSURE THAT          */
*   /* WE HAVE NOT REACHED THE END OF THE DISPATCH QUEUE             */
*   /* OR THAT THE TABLE IS NOT FULL.                                */
*   /* THE TABLE WILL BECOME FULL IF THE DEFAULT LIMIT-              */
*   /* ASCBMAX IS TOO SMALL, OR IF A LOOP CONDITION EXISTS           */
*   /* IN THE ASCB DISPATCH QUEUE                                    */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0516
*   IF R1->ASCBADDR = DISPQEND ×    /* REACHED END OF QUEUE    Y02006*/
*      R1->ASCBADDR = 0 THEN        /* OR LAST ASCB ENTERED    Y02006*/
         L     @14,ASCBADDR(,R1)                                   0516
         C     @14,DISPQEND                                        0516
         BE    @RT00516                                            0516
         LTR   @14,@14                                             0516
         BZ    @RT00516                                            0516
*                                   /* BEFORE BREAK IN FORWARD Y02006*/
*                                   /* CHAIN?                  Y02006*/
*     GOTO ASCBTRM0;                /* YES- TERMINATE BUILD    Y02006*/
*   IF ASCBNUM >= ASCBMAX THEN      /* REACHED MAX NO. ENTRIES Y02006*/
         L     @14,ASCBMAP(,COMPTR)                                0518
         LH    @14,ASCBNUM(,@14)                                   0518
         CH    @14,ASCBMAX(,COMPTR)                                0518
         BL    @RF00518                                            0518
*     DO;                           /* YES-                    Y02006*/
*       ASCBLIMG = ON;              /* INDICATE MSG AMD293I    Y02006*/
         OI    ASCBLIMG,B'01000000'                                0520
*                                   /* REQUIRED                Y02006*/
*       GOTO ASCBTRM0;              /* TERMINATE BUILD         Y02006*/
         B     ASCBTRM0                                            0521
*     END;                          /*                         Y02006*/
*                                                                  0522
*   /* END OF QUEUE OR MAX NO. NOT REACHED, CONTINUE           Y02006*/
*                                                                  0523
*   ASMAPPTR = ASMAPPTR + MAPNTRYL; /* UPDATE MAP INDEX PTR    Y02006*/
@RF00518 AH    ASMAPPTR,@CH00164                                   0523
*   ASTABPTR = ASTABPTR + TABNTRYL; /* UPDATE TABLE INDEX PTR  Y02006*/
         AH    ASTABPTR,@CH00043                                   0524
*   GOTO TABUPDAT;                  /* CONTINUE FILLING ASCBMP Y02006*/
*                                                                  0525
         B     TABUPDAT                                            0525
*   /*****************************************************************/
*   /*                                                               */
*   /* ASCBMAP BUILD TERMINATION PROCESSING                          */
*   /* ISSUE NECESSARY MESSAGES, FREE UNUSED PORTION OF ASCB-        */
*   /* MAP OR ALL OF IT IF NOTHING ENTERED, RESTORE BRREAD           */
*   /* ERROR HANDLER ADDRESS IN COMMON, AND RETURN TO CALLER         */
*   /*                                                               */
*   /*****************************************************************/
*ASCBTRM0:                                                         0526
*   IF ASCBERMG = ON THEN           /* MSG AMD292I REQUIRED:   Y02006*/
ASCBTRM0 TM    ASCBERMG,B'10000000'                                0526
         BNO   @RF00526                                            0526
*     DO;                           /* YES-                    Y02006*/
*       GP = MGTABPTR + INDX292I;   /* WRITE MSG INDICATING    Y02006*/
         LA    GP,40                                               0528
         AL    GP,MGTABPTR                                         0528
*       GEN(LM R1,R2,0(GP));        /* ERROR IN ASCB DISPATCH  Y02006*/
         LM R1,R2,0(GP)
*       GEN(BRPRTMSG (R1),(R2));    /* CHAIN                   Y02006*/
         BRPRTMSG (R1),(R2)
*     END;                          /*                         Y02006*/
*ASCBTRM1:                          /*                         Y02006*/
*   IF ASCBLIMG = ON THEN           /* MST AMD283I REQUIRED:   Y02006*/
@RF00526 DS    0H                                                  0532
ASCBTRM1 TM    ASCBLIMG,B'01000000'                                0532
         BNO   @RF00532                                            0532
*     DO;                           /* YES-                    Y02006*/
*       GP = MGTABPTR + INDX293I;   /* WRITE MSG INDICATING    Y02006*/
         LA    GP,48                                               0534
         AL    GP,MGTABPTR                                         0534
*       GEN(LM R1,R2,0(GP));        /* THE DEFAULT LIMIT OF    Y02006*/
         LM R1,R2,0(GP)
*       CVD(ASCBMAX,DECCNVT);       /* ASCBS PROCESSED BY      Y02006*/
         LH    @14,ASCBMAX(,COMPTR)                                0536
         CVD   @14,@TS00001                                        0536
         MVC   DECCNVT(3),@TS00001+5                               0536
*       UNPK(M293AMAX,DECCNVT);     /* PRDMP WAS EXCEEDED      Y02006*/
         LA    @14,50                                              0537
         ALR   @14,R1                                              0537
         UNPK  M293AMAX(5,@14),DECCNVT(3)                          0537
*       M293AMAX(5) = M293AMAX(5) × 'F0'X; /* PLACE DEFAULT    Y02006*/
         OI    M293AMAX+4(@14),X'F0'                               0538
*                                   /* FROM COM INTO MSG BUF   Y02006*/
*       GEN(BRPRTMSG (R1),(R2));    /* ISSUE MSG AMD293I       Y02006*/
         BRPRTMSG (R1),(R2)
*     END;                          /*                         Y02006*/
*   CALL ASCBFREE;                  /* FREE UNUSED PORTION OF  Y02006*/
@RF00532 BAL   @14,ASCBFREE                                        0541
*                                   /* ASCBMAP                 Y02006*/
*   QASID = QASIDSAV;               /* RESTORE CURRENT ASID    Y02006*/
         MVC   QASID(2,COMPTR),QASIDSAV                            0542
*                                   /* FIELD IN COMMON         Y02006*/
*   ERRADDR = ERRHANSV;             /* RESTORE ERROR HANDLER   Y02006*/
         MVC   ERRADDR(4,COMPTR),ERRHANSV                          0543
*   RETURN;                         /* RETURN TO CALLER        Y02006*/
*                                                                  0544
@EL00004 DS    0H                                                  0544
@EF00004 DS    0H                                                  0544
@ER00004 LM    @14,@12,@SA00004                                    0544
         BR    @14                                                 0544
*   /*****************************************************************/
*   /*                                                               */
*   /* THE FOLLOWING IS THE ASCBMAP BUILD BRREAD ERROR               */
*   /* HANDLER. IT INTERCEPTS READ ERRORS ON THE ASCBMAP             */
*   /* DISPATCH QUEUE. SPECIFIC ACTION IS TAKEN DEPENDING            */
*   /* ON WHERE THE READ ERROR OCCURRED INDICATED BY THE CODE        */
*   /* IN ASCBERR.                                                   */
*   /*                                                               */
*   /*  ASCBERR  ERROR DESCR                 ACTION                  */
*   /*                                                               */
*   /*    1     FORWARD CHAIN   MSG 292I, READ UP BACK CHAIN         */
*   /*    2     SEGMENT TABLE   PUT 0 IN ENTRY, CONTINUE             */
*   /*    3     ASID FIELD      PUT F IN ENTRY, TURN ON HI           */
*   /*                            ORDER BIT IN ASCBADDR FIELD,       */
*   /*                            CONTINUE                           */
*   /*    4      BACKWARD CHAIN  TERMINATE BUILD                     */
*   /*    5      SAME AS 2       SAME AS 2                           */
*   /*    6      SAME AS 3       SAME AS 3                           */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0545
*IBRRDERR:                          /*                         Y02006*/
*   GENERATE REFS(CURENSAV);        /*                         Y02006*/
IBRRDERR DS    0H                                                  0545
         USING *,R15                   RESTORE AMDPRRDC          Y02006
         L     R13,CURENSAV            INIT FUNCTIONS            Y02006
         LM    R14,R12,12(R13)         REGS ON ENTRY TO          Y02006
         DROP  R15                     BRREAD ERROR HANDLER      Y02006
*   GOTO ASERBRTB(ASCBERR);         /* BRANCH TO THE APPROP-   Y02006*/
         LR    @14,ASCBERR                                         0546
         SLA   @14,2                                               0546
         L     @14,ASERBRTB-4(@14)                                 0546
         BR    @14                                                 0546
*                                   /* RIATE ERROR RTN         Y02006*/
*                                                                  0547
*   /*****************************************************************/
*   /*                                                               */
*   /* ERROR OCCURRED READING EITHER THE PTR TO THE 1ST ASCB         */
*   /* ON THE DISPATCH Q FROM THE CVT, OR A FORWARD ASCB PTR         */
*   /* FROM THE ASCB CURRENTLY BEING PROCESSED.                      */
*   /* THIS RTN WILL ATTEMPT TO USE THE PTR IN THE CVT TO THE        */
*   /* LAST ASCB ON THE DISPATCH QUEUE AND SEARCH THE QUEUE          */
*   /* BACKWARDS UNTIL THE LAST ASCB ENTERED ON THE FORWARD          */
*   /* SEARCH IS REACHED                                             */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0547
*ASERCD00:                                                         0547
*   ASCBERMG = ON;                  /* INDICATE MSG AMD292I    Y02006*/
ASERCD00 OI    ASCBERMG,B'10000000'                                0547
*                                   /* IS REQUIRED             Y02006*/
*   IF ASCBNUM ^= 0 THEN            /* WERE ANY ENTRIES ADDED  Y02006*/
         L     @14,ASCBMAP(,COMPTR)                                0548
         ICM   @07,3,ASCBNUM(@14)                                  0548
         BZ    @RF00548                                            0548
*                                   /* ON FORWARD PASS?        Y02006*/
*     DO;                           /* YES-                    Y02006*/
*       DISPQEND = ASCBADDR;        /* STOP BACKWARD PASS WHEN Y02006*/
         MVC   DISPQEND(4),ASCBADDR(ASTABPTR)                      0550
*                                   /* REACH LAST FORWARD NTRY Y02006*/
*       ASMAPPTR = ASMAPPTR + MAPNTRYL; /* UPDATE MAP AND TABLEY02006*/
         AH    ASMAPPTR,@CH00164                                   0551
*       ASTABPTR = ASTABPTR + TABNTRYL; /* INDEX PTRS          Y02006*/
         AH    ASTABPTR,@CH00043                                   0552
*     END;                          /*                         Y02006*/
*   CVTREADA = ADDR(CVTASCBL);      /* SET CVT READ ADDR TO    Y02006*/
@RF00548 L     @14,CVTPTR(,COMPTR)                                 0554
         LA    @14,CVTASCBL(,@14)                                  0554
         ST    @14,CVTREADA                                        0554
*                                   /* ADDR OF PTR TO LAST ASC Y02006*/
*   ASCBERR = 4;                    /* SET ASCB ERROR HANDLER  Y02006*/
         LA    ASCBERR,4                                           0555
*                                   /* CODE TO INDICATE BACK   Y02006*/
*                                   /* CHAINING                Y02006*/
*   RESPECIFY ASCB BASED(ADDRZERO); /* COMPUTE THE DISPLACE-   Y02006*/
*   ASCHAIN = ADDR(ASCBBWDP) - ADDR(ASCB); /* MENT TO THE BACK Y02006*/
         MVC   ASCHAIN(4),@CF00043                                 0557
*   RESPECIFY ASCB BASED(ASCBPTR);    /* CHAIN PTR IN ASCB     Y02006*/
*                                                                  0558
*   GOTO QSEARCH;                   /* CONTINUE SEARCH OF      Y02006*/
         B     QSEARCH                                             0559
*                                   /* ASCB DISPATCH Q         Y02006*/
*                                                                  0560
*   /*****************************************************************/
*   /*                                                               */
*   /* ERROR OCCURRED READING THE FIELD OF THE ASCB CURRENTLY        */
*   /* BEING PROCESSED WHICH CONTAINS THE REAL ADDRESS OF            */
*   /* THE SEGMENT TABLE FOR THIS ADDRESS SPACE.                     */
*   /* THIS ROUTINE WILL CAUSE THE SEGTAB FIELD OF THIS              */
*   /* ASCBMAP ENTRY TO CONTAIN 0                                    */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0560
*ASERCD04:                                                         0560
*   R1 = ADDR(ZEROSEG);             /* POINT TO AREA OF 0      Y02006*/
ASERCD04 LA    R1,ZEROSEG                                          0560
*                                   /* AS IF RETURNED BY DATA  Y02006*/
*                                   /* FUNCTION                Y02006*/
*   GOTO SEGUPDAT;                  /* RETURN TO TABLE UPDATE  Y02006*/
         B     SEGUPDAT                                            0561
*                                   /* RTN & FILL IN SEGTBADR  Y02006*/
*                                   /* FIELD WITH ZERO         Y02006*/
*                                                                  0562
*   /*****************************************************************/
*   /*                                                               */
*   /* ERROR OCCURED READING THE ASID FIELD OF ASCB.                 */
*   /* THIS RTN WILL CAUSE THE ASID FIELD OF THIS ASCBMAP            */
*   /* ENTRY TO BE SET TO FFFF AND WILL SET THE HIORDER BIT          */
*   /* OF ITS CORRESPONDING ASCBADDR FIELD ON. THIS WILL             */
*   /* INDICATE TO PRDMP FORMATTING RTNS THAT ASID WAS 'SET'         */
*   /* TO F'S BY RDC RATHER THAN EXISTING THAT WAY IN THE            */
*   /* DUMPED SYSTEM                                                 */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0562
*ASERCD08:                                                         0562
*   R1 = ADDR(FASIDVAL);            /* POINT TO AREA OF FFFF   Y02006*/
ASERCD08 LA    R1,FASIDVAL                                         0562
*                                   /* AS IF RETURNED BY DATA  Y02006*/
*                                   /* FUNCTION                Y02006*/
*   ASCBAFLG = ON;                  /* TURN ON HIORD BIT OF    Y02006*/
         OI    ASCBAFLG(ASTABPTR),B'10000000'                      0563
*                                   /* ASCBADDR                Y02006*/
*   GOTO ASIDUPDT;                  /* RETURN TO MAP UPDATE    Y02006*/
         B     ASIDUPDT                                            0564
*                                   /* RTN & FILL IN ASID      Y02006*/
*                                   /* FIELD WITH FFFF         Y02006*/
*                                                                  0565
*   /*****************************************************************/
*   /*                                                               */
*   /* ERROR OCCURRED READING EITHER THE PTR TO THE LAST ASCB        */
*   /* ON DISPATCH Q FROM THE CVT, OR A BACKWARD ASCB PTR            */
*   /* FROM THE ASCB CURRENTLY BEING PROCESSED.                      */
*   /* THIS RTN MERELY TERMINATES THE ASCBMAP BUILD AS FURTHER       */
*   /* PROCESSING IS IMPOSSIBLE.                                     */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0565
*ASERCD10:                                                         0565
*   GOTO ASCBTRM0;                  /* TERMINATE BILDASCB      Y02006*/
*                                                                  0565
*   /*****************************************************************/
*   /*                                                               */
*   /*  ASCBFREE-                                                    */
*   /*                                                               */
*   /* THIS SUBROUTINE FREES ANY UNUSED SPACE IN ASCBMAP             */
*   /* BASED ON THE NUMBER OF ENTRIES USED- ASCBNUM.  IF NO          */
*   /* ENTRIES WERE USED (ASCBNUM = 0) THEN THE ENTIRE ASCB          */
*   /* MAP IS FREED AND THE PTR TO IT IN COMMON SET = 0.             */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0566
*ASCBFREE:                                                         0566
*   PROC;                                                          0566
ASCBFREE STM   @14,@12,@SA00005                                    0566
*   IF ASCBMAP = 0 THEN             /* DOES ASCBMAP CURRENTLY  Y02006*/
         SLR   @14,@14                                             0567
         L     @04,ASCBMAP(,COMPTR)                                0567
         CR    @04,@14                                             0567
         BE    @RT00567                                            0567
*                                   /* EXIST?                  Y02006*/
*     RETURN;                       /* NO- RETURN TO CALLER    Y02006*/
*                                                                  0568
*   /*****************************************************************/
*   /*                                                               */
*   /* MAP EXISTS- DETERMINE WHETHER PART OR ALL OF IT SHOULD        */
*   /* BE FREED.  ASMPFREE SW USED ONLY TO DETERMINE WHETHER         */
*   /* ASCBMAP PTR IN COMMON SHOULD BE SET = 0.                      */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0569
*   IF ASCBNUM = 0 THEN             /* ANY ENTRIES USED?       Y02006*/
         CH    @14,ASCBNUM(,@04)                                   0569
         BNE   @RF00569                                            0569
*     ASMPFREE = ON;                /* NO- INDICATE FREE ALL   Y02006*/
         OI    ASMPFREE,B'00100000'                                0570
*   ELSE                            /*                         Y02006*/
*     ASMPFREE = OFF;               /* YES- ONLY FREE UNUSED   Y02006*/
         B     @RC00569                                            0571
@RF00569 NI    ASMPFREE,B'11011111'                                0571
*                                   /* PART                    Y02006*/
*                                                                  0572
*   /* DETERMINE AMOUNT OF TABLE USED                                */
*                                                                  0572
*   ASCBMLEN = ASTABLEN;            /* SAVE CURRENT TAB LENGTH Y02006*/
@RC00569 L     @14,ASCBMAP(,COMPTR)                                0572
         L     @03,ASTABLEN(,@14)                                  0572
         ST    @03,ASCBMLEN                                        0572
*   ASTABLEN = ASCBNUM * TABNTRYL;  /* NO. OF BYTES USED       Y02006*/
         LH    @09,ASCBNUM(,@14)                                   0573
         SLA   @09,3                                               0573
         ST    @09,ASTABLEN(,@14)                                  0573
*   ASTABLEN = (ASTABLEN + RNDVAL1) & RNDVAL2; /* ROUND UP TO  Y02006*/
         AH    @09,@CH01163                                        0574
         N     @09,@CF01312                                        0574
         ST    @09,ASTABLEN(,@14)                                  0574
*                                   /* NEXT DWORD BOUND        Y02006*/
*   ASTABPTR = ASCBTAB + ASTABLEN;  /* POINT TO START OF       Y02006*/
         L     ASTABPTR,ASCBTAB(,@14)                              0575
         ALR   ASTABPTR,@09                                        0575
*                                   /* UNUSED PART OF TABLE    Y02006*/
*   ASCBMLEN = ASCBMLEN - ASTABLEN; /* DETERMINE AMOUNT TO BE  Y02006*/
         SLR   @03,@09                                             0576
         ST    @03,ASCBMLEN                                        0576
*                                   /* FREED                   Y02006*/
*   IF ASCBMLEN ^= 0 THEN           /* IF ALL OF TABLE NOT     Y02006*/
         LTR   @03,@03                                             0577
         BZ    @RF00577                                            0577
*     DO;                           /* USED- THEN              Y02006*/
*       R0 = ASCBMLEN;              /* SET LEN TO BE FREED     Y02006*/
         LR    R0,@03                                              0579
*       R1 = ASTABPTR;              /* SET ADDR TO BE FREED    Y02006*/
         LR    R1,ASTABPTR                                         0580
*       GEN(FREEMAIN R,LV=(0),A=(1)); /* AND FREE              Y02006*/
         FREEMAIN R,LV=(0),A=(1)
*                                   /*  REMAINING PORTION      Y02006*/
*     END;                          /*                         Y02006*/
*                                                                  0582
*   /* DETERMINE AMOUNT OF MAP USED                                  */
*                                                                  0583
*   ASCBMLEN = ASMAPLEN;            /* SAVE CURRENT MAP LENGTH Y02006*/
@RF00577 L     @14,ASCBMAP(,COMPTR)                                0583
         L     @07,ASMAPLEN(,@14)                                  0583
         ST    @07,ASCBMLEN                                        0583
*   ASMAPLEN = ASCBNUM * MAPNTRYL + MAPREFLN; /* AMOUNT USED   Y02006*/
         LH    @04,ASCBNUM(,@14)                                   0584
         ALR   @04,@04                                             0584
         AH    @04,@CH00183                                        0584
         ST    @04,ASMAPLEN(,@14)                                  0584
*   ASMAPLEN = (ASMAPLEN + RNDVAL1) & RNDVAL2; /* ROUND UP TO  Y02006*/
         AH    @04,@CH01163                                        0585
         N     @04,@CF01312                                        0585
         ST    @04,ASMAPLEN(,@14)                                  0585
*                                   /* NEXT DWORD BOUND        Y02006*/
*   ASMAPPTR = ASCBMAP + ASMAPLEN;  /* POINT TO START OF       Y02006*/
         ALR   @14,@04                                             0586
         LR    ASMAPPTR,@14                                        0586
*                                   /* UNUSED PART OF MAP      Y02006*/
*   ASCBMLEN = ASCBMLEN - ASMAPLEN; /* DETERMINE AMOUNT TO BE  Y02006*/
         SLR   @07,@04                                             0587
         ST    @07,ASCBMLEN                                        0587
*                                   /* FREED                   Y02006*/
*   IF ASCBMLEN ^= 0 THEN           /* IF ALL OF MAP NOT USED- Y02006*/
         LTR   @07,@07                                             0588
         BZ    @RF00588                                            0588
*     DO;                           /* THEN                    Y02006*/
*       R0 = ASCBMLEN;              /* SET LEN TO BE FREED     Y02006*/
         LR    R0,@07                                              0590
*       R1 = ASMAPPTR;              /* SET ADDR TO BE FREED    Y02006*/
         LR    R1,ASMAPPTR                                         0591
*       GEN(FREEMAIN R,LV=(0),A=(1)); /* AND FREE              Y02006*/
         FREEMAIN R,LV=(0),A=(1)
*     END;                          /* REMAINING PORTION       Y02006*/
*                                                                  0593
*   /*****************************************************************/
*   /*                                                               */
*   /* IF ASCBNUM WAS = 0, ENTIRE ASCBMAP HAS BEEN FREED-            */
*   /* ZERO PTR IN COMMON.                                           */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0594
*   IF ASMPFREE = ON THEN           /* FREE ENTIRE MAP?        Y02006*/
@RF00588 TM    ASMPFREE,B'00100000'                                0594
         BNO   @RF00594                                            0594
*     ASCBMAP = 0;                  /* YES- ZERO PTR           Y02006*/
*                                                                  0595
         SLR   @14,@14                                             0595
         ST    @14,ASCBMAP(,COMPTR)                                0595
*   RETURN;                         /* RETURN TO CALLER        Y02006*/
@EL00005 DS    0H                                                  0596
@EF00005 DS    0H                                                  0596
@ER00005 LM    @14,@12,@SA00005                                    0596
         BR    @14                                                 0596
*   END ASCBFREE;                   /*                         Y02006*/
         B     @EL00005                                            0597
*   END BILDASCB;                   /*                         Y02006*/
*                                                                  0598
         B     @EL00004                                            0598
*   /*****************************************************************/
*   /*                                                               */
*   /* COMPADDR -                                                    */
*   /*                                                               */
*   /*       THIS SUBROUTINE IS PASSED AN ADDRESS IN SRCHAD AND THE  */
*   /*       REALADDR BIT IN SWITCHES IS SET TO INDICATE WHETHER THE */
*   /*       ADDRESS IS VIRTUAL OR REAL. COMPADDR WILL SEARCH THE    */
*   /*       BUFFER MAP ENTRYS FOR ONE WHICH CONTAINS THE REQUESTED  */
*   /*       ADDRESS. IF AN ENTRY IS FOUND, THEN THE BUFFER POINTED  */
*   /*       TO BY THE MAP ENTRY CONTAINS THE REQUESTED ADDRESS. THE */
*   /*       MAP ENTRY WILL THUS BE MADE THE CURRENT ENTRY IN THE BUF*/
*   /*       MAP CHAIN AND A ZERO RETURN CODE WILL BE PASSED BACK TO */
*   /*       THE CALLER. IF A BUF MAP ENTRY CONTAINING THE ADDRESS   */
*   /*       CANNOT BE FOUND, A RETURN CODE OF 4 WILL BE PASSED BACK */
*   /*       TO THE CALLER.                                          */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0599
*                                                                  0599
*COMPADDR:                                                         0599
*   PROC OPTIONS(NOSAVE(15));                                      0599
COMPADDR ST    @14,12(,@13)                                        0599
         STM   @00,@02,20(@13)                                     0599
         STM   @04,@12,36(@13)                                     0599
*   DCL                                                            0600
*         VIRTNDX FIXED(31) CONSTANT(12); /*                   Y02006*/
*   DCL                                                            0601
*         REALNDX FIXED(31) CONSTANT(8); /*                    Y02006*/
*   DCL                                                            0602
*     STORGEAD PTR(31) BASED(GP);   /* USED TO REF. REAL OR    Y02006*/
*                                   /* VIRT ADDR FIELDS IN     Y02006*/
*                                   /* BUFFER MAP ENTRIES      Y02006*/
*   DCL                                                            0603
*     MAPINDX FIXED(15) INIT(0);    /* INDEX INTO BUF MAP ENTRY TO 0603
*                                      EITHER THE BUFFVIRT OR      0603
*                                      BUFFREAL FIELD          Y02006*/
*                                                                  0603
*   /*****************************************************************/
*   /*                                                               */
*   /* BEGIN COMPADDR PROCESSING                                     */
*   /*                                                               */
*   /* CHK IF ADDR IN SRCHAD IS CPU OR REAL OR VIRTUAL AND SET UP TO */
*   /* SEARCH EITHER THE CPU OR VIRTUAL OR REAL ADDR FIELD IN THE    */
*   /* BUFFER MAP ENTRYS.                                            */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0604
*   MAPPTR = CURENTRY;              /* POINT TO CURRENT ENTRY IN BUF
*                                      MAP CHAIN                     */
         L     MAPPTR,CURENTRY                                     0604
*   IF CPUIDAD = ON THEN            /* INVOKED TO SEARCH FOR   Y02006*/
         TM    CPUIDAD,B'01000000'                                 0605
         BNO   @RF00605                                            0605
*                                   /* CPU STATUS RECORD?      Y02006*/
*COMPCPU:                           /*                         Y02006*/
*     DO;                           /* YES- SCAN FOR IT        Y02006*/
COMPCPU  DS    0H                                                  0607
*       IF BUFFCPU = SRCHCPU THEN   /* CPU RECORD IN BUFFER?   Y02006*/
         CLC   BUFFCPU(2,MAPPTR),SRCHCPU                           0607
         BE    @RT00607                                            0607
*         GOTO INBUF2;              /* YES- RECORD FOUND       Y02006*/
*       ELSE                        /* OTHERWISE CHECK NEXT    Y02006*/
*         GOTO NXTBUFFR;            /* BUFFER IF NOT AT END    Y02006*/
         B     NXTBUFFR                                            0609
*     END;                          /*                         Y02006*/
*                                                                  0610
*   IF REALADDR = ON THEN           /* IS ADDR REAL?                 */
@RF00605 TM    REALADDR,B'00100000'                                0611
         BNO   @RF00611                                            0611
*     MAPINDX = REALNDX;            /* YES, SET MAP ENTRY OFFSET OF
*                                      REAL ADDR FIELD               */
         MVC   MAPINDX(2),@CH00043                                 0612
*   ELSE                                                           0613
*     MAPINDX = VIRTNDX;            /* NO, SET MAP ENTRY OFFSET OF 0613
*                                      VIRT ADDR FIELD               */
*                                                                  0613
         B     @RC00611                                            0613
@RF00611 MVC   MAPINDX(2),@CH00240                                 0613
*   /*****************************************************************/
*   /*                                                               */
*   /* CHK IF BUF MAP ENTRY CONTAINS REQUESTED ADDRESS. STORGEAD IS  */
*   /* BASED ON (GP). STORAGEAD IS EITHER THE REAL ADDR OR           */
*   /* VIRT ADDR FIELD IN THE BUF MAP ENTRY DEPENDING ON THE OFFSET  */
*   /* IN GP.                                                        */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0614
*                                                                  0614
*COMPAD:                                                           0614
*   GP = MAPPTR + MAPINDX;          /* POINT TO ADDR FIELD           */
@RC00611 DS    0H                                                  0614
COMPAD   LR    GP,MAPPTR                                           0614
         AH    GP,MAPINDX                                          0614
*   IF STORGEAD = SRCHAD THEN       /* ADDR IN BUFFER          Y02006*/
         CLC   STORGEAD(4,GP),SRCHAD                               0615
         BNE   @RF00615                                            0615
*INBUF:                                                            0616
*     DO;                           /* YES, ADDR FOUND -       Y10980*/
INBUF    DS    0H                                                  0617
*   IF REALADDR = OFF THEN          /* VIRTUAL SEARCH?         Y02006*/
         TM    REALADDR,B'00100000'                                0617
         BNZ   @RF00617                                            0617
*     DO;                           /* YES-                    Y02006*/
*       IF BUFFASID = REQDASID THEN /* CHECK IF ASIDS MATCH    Y02006*/
*                                                                  0619
         CLC   BUFFASID(2,MAPPTR),REQDASID                         0619
         BNE   @RF00619                                            0619
*   /*****************************************************************/
*   /*                                                               */
*   /* REQ ADDR FOUND IN MAP ENTRY. UPDATE CURRENT ENTRY PTR UNLESS  */
*   /* MAP ENTRY IS ALREADY CURRENT IN THE CHAIN.                    */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0620
*INBUF2:                                                           0620
*         DO;                       /*                         Y02006*/
INBUF2   DS    0H                                                  0621
*           IF MAPPTR ^= CURENTRY THEN  /* ENTRY ALREADY CURRENT?    */
*                                                                  0621
         C     MAPPTR,CURENTRY                                     0621
         BE    @RF00621                                            0621
*UPDATCUR:                                                         0622
*             DO;                       /* NO, UPDATE CURENTRY       */
UPDATCUR DS    0H                                                  0623
*               PRENTRY -> BUFFLINK = BUFFLINK; /* DEQUE ENTRY       */
         L     @14,PRENTRY                                         0623
         MVC   BUFFLINK(4,@14),BUFFLINK(MAPPTR)                    0623
*               BUFFLINK = CURENTRY;  /* CHAIN OLD CURENTRY TO ENTRY */
         MVC   BUFFLINK(4,MAPPTR),CURENTRY                         0624
*               CURENTRY = MAPPTR;      /* MAKE ENTRY NEW CURENTRY   */
         ST    MAPPTR,CURENTRY                                     0625
*             END UPDATCUR;                                        0626
*                                                                  0626
*   /*****************************************************************/
*   /*                                                               */
*   /* RETURN TO CALLER WITH RETURN CODE OF ZERO TO INDICATE BUFFER  */
*   /* WITH REQUESTED ADDR WAS FOUND. CURENTRY POINTS TO THE BUF MAP */
*   /* ENTRY ASSOCIATED WITH THE BUFFER.                             */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0627
*           R15 =0;                 /* INDICATE BUF FOUND            */
@RF00621 SLR   R15,R15                                             0627
*           GOTO COMPXIT;           /* RETURN TO CALLER              */
         B     COMPXIT                                             0628
*         END INBUF2;               /*                         Y02006*/
*       ELSE                        /*                         Y02006*/
*         DO;                       /* ASIDS DO NOT MATCH      Y02006*/
@RF00619 DS    0H                                                  0631
*           IF BUFFCOM = ON THEN    /* CHECK IF THIS BUF       Y02006*/
         TM    BUFFCOM(MAPPTR),B'01000000'                         0631
         BO    @RT00631                                            0631
*                                   /* CONTAINS DATA FROM      Y02006*/
*                                   /* COMMON MEMORY           Y02006*/
*             GOTO INBUF2;          /* YES- USE IT             Y02006*/
*           ELSE                    /*                         Y02006*/
*             GOTO NXTBUFFR;        /* NOT COMMON- TRY NEXT    Y02006*/
         B     NXTBUFFR                                            0633
*         END;                      /*                         Y02006*/
*     END;                          /*                         Y02006*/
*   ELSE                            /* NOT VIRTUAL SEARCH-     Y02006*/
*     GOTO INBUF2;                  /* NO ASID MATCH REQUIRED  Y02006*/
*                                   /* ON REAL- USE IT         Y02006*/
*     END INBUF;                                                   0637
*                                                                  0637
*   /*****************************************************************/
*   /*                                                               */
*   /* MAP ENTRY POINTED TO BY MAPPTR DOESN'T CONTAIN SRCHAD. IF NOT */
*   /* END OF BUF MAP CHAIN, POINT TO NEXT ENTRY IN CHAIN AND GO     */
*   /* CHECK FOR SRCHAD.                                             */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0638
*   ELSE                                                           0638
*                                                                  0638
*NXTBUFFR:                                                         0638
*     IF BUFFLINK ^= 0 THEN         /* END OF CHAIN?                 */
@RF00615 DS    0H                                                  0638
NXTBUFFR L     @14,BUFFLINK(,MAPPTR)                               0638
         LTR   @14,@14                                             0638
         BZ    @RF00638                                            0638
*       DO;                         /* NO, POINT TO NEXT ENTRY       */
*         PRENTRY = MAPPTR;         /* SAVE ADDR OF ENTRY JUST CHKED */
         ST    MAPPTR,PRENTRY                                      0640
*         MAPPTR = BUFFLINK;        /* POINT TO NEXT ENTRY           */
         LR    MAPPTR,@14                                          0641
*         IF CPUIDAD = ON THEN      /* IF SEARCHING FOR CPU    Y02006*/
         TM    CPUIDAD,B'01000000'                                 0642
         BO    @RT00642                                            0642
*           GOTO COMPCPU;           /* RETURN TO THAT SEARCH   Y02006*/
*         ELSE                                                     0644
*         GOTO COMPAD;              /* GO CHK FOR SRCHAD             */
         B     COMPAD                                              0644
*       END;                                                       0645
*                                                                  0645
*   /*****************************************************************/
*   /*                                                               */
*   /* SRCHAD WAS NOT FOUND IN ANY BUFFER                            */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0646
*   R15 = 4;                        /* INDICATE ADDR NOT FOUND       */
*                                                                  0646
@RF00638 LA    R15,4                                               0646
*COMPXIT:                                                          0647
*   RETURN;                         /* GO BACK TO MAIN LINE          */
@EL00006 DS    0H                                                  0647
@EF00006 DS    0H                                                  0647
@ER00006 L     @14,12(,@13)                                        0647
         LM    @00,@02,20(@13)                                     0647
         LM    @04,@12,36(@13)                                     0647
         BR    @14                                                 0647
*   END COMPADDR;                                                  0648
*                                                                  0648
         B     @EL00006                                            0648
*   /*****************************************************************/
*   /*                                                               */
*   /* READREC -                                                     */
*   /*                                                               */
*   /*       THIS SUBROUTINE PROVIDES THE INTERFACE FROM RDC TO PREAD*/
*   /*       TO READ A DMP RECORD ASSOCIATED WITH AN ADDR PASSED TO  */
*   /*       READREC IN SRCHAD. THE BUF MAP ENTRY ASSOCIATED WITH THE*/
*   /*       OLDEST REFERENCED BUFFER IS ALWAYS MADE THE CURRENT     */
*   /*       ENTRY IN THE BUF MAP CHAIN AND THE BUFFER IS THEN USED  */
*   /*       FOR THE READ OPERATION. THE CPUIDAD BIT INDICATES IF THE*/
*   /*       ADDR IN SRCHAD IS A CPU ID, THE REALADDR BIT IN SWITCHES*/
*   /*       INDICATES WHETHER THE ADDR IN SRCHAD IS REAL OR VIRTUAL.*/
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0649
*                                                                  0649
*READREC:                                                          0649
*   PROC;                                                          0649
*                                                                  0649
READREC  STM   @14,@12,@SA00007                                    0649
*   /*****************************************************************/
*   /*                                                               */
*   /* BEGIN READREC PROCESSING                                      */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0650
*   READTM = READTM + 1;            /* UPDATE READ COUNT             */
*                                                                  0650
         LA    @14,1                                               0650
         AL    @14,READTM(,COMPTR)                                 0650
         ST    @14,READTM(,COMPTR)                                 0650
*   /*****************************************************************/
*   /*                                                               */
*   /* POSITION TO OLDEST ENTRY IN BUF MAP CHAIN                     */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0651
*   MAPPTR = CURENTRY;              /* POINT TO TOP OF CHAIN         */
*                                                                  0651
         L     MAPPTR,CURENTRY                                     0651
*CHKEND:                                                           0652
*   IF BUFFLINK ^= 0 THEN           /* END OF CHAIN?                 */
CHKEND   L     @14,BUFFLINK(,MAPPTR)                               0652
         LTR   @14,@14                                             0652
         BZ    @RF00652                                            0652
*     DO;                           /* NO, GET NEXT ENTRY            */
*       PRENTRY = MAPPTR;           /* SAVE ADDR OF ENTRY JUST CHKED */
         ST    MAPPTR,PRENTRY                                      0654
*       MAPPTR = BUFFLINK;          /* POINT TO NEXT ENTRY           */
         LR    MAPPTR,@14                                          0655
*       GOTO CHKEND;                /* GO CHK IF IT IS LAST ENTRY    */
         B     CHKEND                                              0656
*     END;                                                         0657
*                                                                  0657
*   /*****************************************************************/
*   /*                                                               */
*   /* OLDEST ENTRY IN CHAIN FOUND. MAKE IT CURRENT ENTRY UNLESS IT  */
*   /* IS ALREADY THE CURRENT ENTRY                                  */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0658
*   IF MAPPTR ^= CURENTRY THEN      /* ENTRY ALREADY CURRENT?        */
@RF00652 L     @14,CURENTRY                                        0658
         CR    MAPPTR,@14                                          0658
         BE    @RF00658                                            0658
*     DO;                           /* NO, MAKE IT CURRENT           */
*       PRENTRY -> BUFFLINK = BUFFLINK; /* DEQUE ENTRY FROM CHAIN    */
         L     @04,PRENTRY                                         0660
         MVC   BUFFLINK(4,@04),BUFFLINK(MAPPTR)                    0660
*       BUFFLINK = CURENTRY;        /* CHAIN OLD CURENTRY TO ENTRY   */
         ST    @14,BUFFLINK(,MAPPTR)                               0661
*       CURENTRY = MAPPTR;          /* MAKE ENTRY NEW CURENTRY       */
         ST    MAPPTR,CURENTRY                                     0662
*     END;                                                         0663
*                                                                  0663
*   /*****************************************************************/
*   /*                                                               */
*   /* REINITIALIZE THE BUF MAP ENTRY                                */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0664
*   BUFFFLAG = FLAGINIT;            /* INIT FLAG BYTE                */
@RF00658 MVI   BUFFFLAG(MAPPTR),X'00'                              0664
*   BUFFIELD = BUFFINIT;            /* REINIT BUFFER MAP ENTRY Y02006*/
*                                                                  0665
         MVC   BUFFIELD(12,MAPPTR),BUFFINIT                        0665
*   /*****************************************************************/
*   /*                                                               */
*   /* STORE SRCHAD IN THE CPU ADDR FIELD OF THE MAP ENTRY IF ADDR IN*/
*   /* SRCHAD IS A CPU ID.                                           */
*   /* STORE SRCHAD IN THE REAL ADDR FIELD OF THE MAP ENTRY IF ADDR  */
*   /* IN SRCHAD IS REAL. OTHERWISE STORE SRCHAD IN THE VIRT ADDR    */
*   /* FIELD AND THE REQUESTED ASID IN BUFFASID.                     */
*   /* THE ADDRESS WILL BE USED BY PREAD TO DETERMINE THE DUMP       */
*   /* RECORD THAT IS TO BE READ.                                    */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0666
*   IF CPUIDAD = ON THEN            /* INVOKED TO READ CPU REC Y02006*/
         TM    CPUIDAD,B'01000000'                                 0666
         BNO   @RF00666                                            0666
*     BUFFCPU = SRCHCPU;            /* YES- PUT CPU ADR IN BUF Y02006*/
         MVC   BUFFCPU(2,MAPPTR),SRCHCPU                           0667
*   ELSE                                                    /* Y02006*/
*     DO;                                                   /* Y02006*/
         B     @RC00666                                            0668
@RF00666 DS    0H                                                  0669
*   IF REALADDR = ON THEN           /* IS SRCHAD REAL?               */
         TM    REALADDR,B'00100000'                                0669
         BNO   @RF00669                                            0669
*     BUFFREAL = SRCHAD;            /* YES, SAVE IT IN REAL FIELD    */
         MVC   BUFFREAL(4,MAPPTR),SRCHAD                           0670
*   ELSE                                                    /* Y02006*/
*       DO;                         /*                         Y02006*/
         B     @RC00669                                            0671
@RF00669 DS    0H                                                  0672
*         BUFFVIRT = SRCHAD;        /* NO, SAVE IT IN VIRT FIELD     */
         MVC   BUFFVIRT(4,MAPPTR),SRCHAD                           0672
*         BUFFASID = REQDASID;      /* ALSO SAVE ASID          Y02006*/
         MVC   BUFFASID(2,MAPPTR),REQDASID                         0673
*       END;                        /*                         Y02006*/
*     END;                                                         0675
*                                                                  0675
@RC00669 DS    0H                                                  0676
*   /*****************************************************************/
*   /*                                                               */
*   /* INTERFACE WITH PREAD TO READ DUMP RECORD CONTAINING SRCHAD    */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0676
*CALLREAD:                                                         0676
*   R1 = MAPPTR;                    /* PUT ADDR OF CURRENT MAP ENTRY
*                                      IN THE PARM REG               */
@RC00666 DS    0H                                                  0676
CALLREAD LR    R1,MAPPTR                                           0676
*   CALL AMDPREAD;                  /* GO TO PREAD             Y02006*/
*                                                                  0677
         L     @15,@CV01129                                        0677
         BALR  @14,@15                                             0677
*   RETURN;                                                        0678
@EL00007 DS    0H                                                  0678
@EF00007 DS    0H                                                  0678
@ER00007 LM    @14,@12,@SA00007                                    0678
         BR    @14                                                 0678
*   END READREC;                                                   0679
*                                                                  0679
*   /*****************************************************************/
*   /*                                                               */
*   /* DAT -                                                         */
*   /*                                                               */
*   /*       THIS SUBROUTINE TRANSLATES A VIRTUAL ADDRESS TO A REAL  */
*   /*       ADDRESS. THE VIRTUAL ADDRESS IS PASSED TO DAT IN SRCHAD */
*   /*       AND AFTER TRANSLATION THE REAL ADDRESS IS PASSED BACK TO*/
*   /*       THE CALLER IN SRCHAD. A RETURN CODE OF 4 IS PASSED BACK */
*   /*       IF THE SRCHAD IS INVALID. OTHERWISE 0 IS PASSED BACK    */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0680
*                                                                  0680
*DAT:                                                              0680
*   PROC OPTIONS(NOSAVE(15));                                      0680
DAT      ST    @14,@SA00008                                        0680
         STM   @00,@02,@SA00008+4                                  0680
         STM   @04,@12,@SA00008+16                                 0680
*   DCL                                                            0681
*         1 REQADDR FIXED(31),      /* SAVE WORD FOR SRCHAD PARM     */
*             3 HIBYT CHAR(1),                                     0681
*             3 SEGBYTE PTR(8),     /* SEGMENT PORTION OF ADDR       */
*             3 LOW2BYTS PTR(16);   /* FIRST 4 OR 5 BITS CONTAIN PAGE
*                                      PORTION OF ADDRESS           */
*   DCL                                                            0682
*         1 SEGORIGN FIXED(31),     /* CONTAINS SEGTAB ADDR          */
*             3 SEGLNG PTR(8),      /* SEGTAB LENGTH CODE. INDICATES
*                                      TAB LNG IN UNITS OF 64 BYTES  */
*             3 SEGTABAD PTR(24);   /* ADDR OF SEGMENT TABLE         */
*                                                                  0682
*   /*****************************************************************/
*   /*                                                               */
*   /* FORMAT OF SEGMENT TABLE ENTRY                                 */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0683
*   DCL                                                            0683
*         1 SEGENTRY CHAR(4) BDY(WORD),                            0683
*             3 SEGHIBYT CHAR(1),                                  0683
*                 5 PGELNG BIT(4),  /* INDICATES PAGE TABLE LNG IN 0683
*                                      INCREMENTS EQUAL TO SIXTEETHS
*                                      OF MAX. TABLE SIZE            */
*                 5 PGEKEY BIT(4),  /* SEGMENT PROTECTION KEY        */
*             3 PGETABAD PTR(24),                                  0683
*                 5 TABADDR BIT(21), /* PAGE TABLE ADDRESS           */
*                 5 SEGEAC BIT(2),  /* EXTERNAL ACCESS CODE          */
*                 5 SEGIBIT BIT(1); /* SEGMENT INVALID BIT           */
*                                                                  0683
*   /*****************************************************************/
*   /*                                                               */
*   /* PAGE TABLE ENTRY DESCRIPTION                                  */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0684
*   DCL                                                            0684
*         PAGENTRY PTR(16);         /* PAGE TABLE ENTRY              */
*                                   /* ENTRY FMT FOR 4K PAGE SIZE:   */
*                                   /* BITS 0-11 PAGE ADDRESS        */
*                                   /* BIT 12 PAGE INVALID BIT       */
*                                   /* BITS 13-15 NOT USED           */
*   DCL                                                            0685
*         DATINDX FIXED(31);        /* OFFSET TO DATA IN BUFFER      */
*   DCL                                                            0686
*         PAGESIZE FIXED(31) CONSTANT(4096); /* PAGE SIZE      Y02006*/
*   DCL                                                            0687
*         SHIFT FIXED(31);          /* FACTOR FOR SEPARATING THE PAGE
*                                      ADDR AND LOW ORDER BITS IN A
*                                      PAGE TABLE ENTRY              */
*   DCL                                                            0688
*         PFTVBN CHAR(2);           /* VIRTUAL BLOCK NO. IN PAGE FRAME
*                                      TABLE FOR PAGE RECLAIM  Y01980*/
*   DCL                                                            0689
*     PFTASID BIT(16);              /* ASID IN PFT FOR PAGE    Y02006*/
*                                   /* RECLAIM                 Y02006*/
*   DCL                                                            0690
*     COMASID BIT(16) CONSTANT('FFFF'X); /* COMMON ASID FOR    Y02006*/
*                                   /* PAGE RECLAIM            Y02006*/
*   DCL                                                            0691
*         SRCHSAVE PTR(31);         /* SAVE AREA FOR SRCHAD    Y01980*/
*   DCL                                                            0692
*     SRCHSAV1 PTR(31);             /* SAVE AREA FOR SRCHAD    Y02006*/
*   DCL                                                            0693
*     1 PFTFLAGS CHAR(2),           /* MAP OF PAGE FRAME TABLE Y02006*/
*       3 PFTFLAG1 CHAR(1),         /* FLAGS FIELDS- FLAG 1    Y02006*/
*         5 * BIT(4),                                       /* Y02006*/
*         5 PFTPCBSI BIT(1),                                /* Y02006*/
*         5 PFTBADPG BIT(1),                                /* Y02006*/
*         5 * BIT(1),                                       /* Y02006*/
*         5 PFTOFINT BIT(1),                                /* Y02006*/
*       3 PFTFLAG2 CHAR(1),         /* FLAG 2                  Y02006*/
*         5 * BIT(1),                                       /* Y02006*/
*         5 PFTOFFLN BIT(1),                                /* Y02006*/
*         5 * BIT(1),                                       /* Y02006*/
*         5 PFTIRRG BIT(1),                                 /* Y02006*/
*         5 * BIT(4);                                       /* Y02006*/
*   DCL                                                            0694
*     PROTNRQ FIXED(8) INIT(0),    /* RECLAIMABLE PAGE PROTECT     0694
*                                     KEY SWITCHES           @YM08224*/
*     PROTKF FIXED(8) INIT(1),                                     0694
*     PROTNF FIXED(8) INIT(2);                             /*@YM08224*/
*                                                                  0694
*   /*****************************************************************/
*   /*                                                               */
*   /* BEGIN DAT TRANSLATION                                         */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0695
*   REQADDR = SRCHAD;               /* SAVE THE REQUESTED ADDR       */
         MVC   REQADDR(4),SRCHAD                                   0695
*   SEGORIGN = (SGTBAD & 'FFFFFFC0'X); /* GET SEG TABLE ADDR   Y02006*/
         L     @14,SGTBAPTR                                        0696
         L     @14,SGTBAD(,@14)                                    0696
         N     @14,@CF01448                                        0696
         ST    @14,SEGORIGN                                        0696
*   WORK1(1:1) = PROTNRQ;           /* CLEAR PROTECT KEY SW  @YM08224*/
*                                                                  0697
         MVC   WORK1(1,COMPTR),PROTNRQ                             0697
*   /*****************************************************************/
*   /*                                                               */
*   /* CALCULATE ADDR OF SEGMENT TABLE ENTRY FOR REQUESTED ADDR.     */
*   /* MULTIPLY THE SEGMENT PORTION OF THE REQUESTED ADDRESS BY 4 AND*/
*   /* ADD TO THE SEGMENT TABLE ADDR.                                */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0698
*   SRCHAD = SEGTABAD + (SEGBYTE * 4);                             0698
*                                                                  0698
         SLR   @14,@14                                             0698
         IC    @14,SEGBYTE                                         0698
         LR    @04,@14                                             0698
         SLA   @04,2                                               0698
         SLR   @09,@09                                             0698
         ICM   @09,7,SEGTABAD                                      0698
         ALR   @04,@09                                             0698
         ST    @04,SRCHAD                                          0698
*   /*****************************************************************/
*   /*                                                               */
*   /* CHK IF ENTRY IN TABLE. COMPARE HIGH FOUR BITS OF SEGMENT BYTE */
*   /* WITH THE SEGMENT TABLE LENGTH CODE.                           */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0699
*   IF SEGLNG < (SEGBYTE/16) THEN   /* IS SEGMENT ENTRY WITHIN TABLE */
         SRL   @14,4                                               0699
         SLR   @09,@09                                             0699
         IC    @09,SEGLNG                                          0699
         CR    @14,@09                                             0699
         BH    @RT00699                                            0699
*     GOTO DATINVLD;                /* NO, GO TO ERROR EXIT          */
*                                                                  0700
*   /*****************************************************************/
*   /*                                                               */
*   /* SRCH FOR BUFFER CONTAINING SEGMENT TABLE ENTRY                */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0701
*   DATINDX = SRCHAD // DATALNG + 1; /* CALCULATE OFFSET INTO BUFFER */
         L     @14,SRCHAD                                          0701
         LR    @06,@14                                             0701
         SRDA  @06,32                                              0701
         D     @06,@CF01096                                        0701
         AH    @06,@CH00057                                        0701
         LR    DATINDX,@06                                         0701
*   SRCHAD = (SRCHAD & RNDVALU);    /* ROUND ADDR TO 4K BNDRY        */
         N     @14,@CF01082                                        0702
         ST    @14,SRCHAD                                          0702
*   CPUIDAD = OFF;                  /* INDICATE REAL OR VIRT   Y02006*/
*   REALADDR = ON;                  /* INDICATE REAL ADDR PARAMETER  */
         OI    REALADDR,B'00100000'                                0704
         NI    CPUIDAD,B'10111111'                                 0704
*   CALL COMPADDR;                  /* SRCH BUFFS FOR ADDR           */
         BAL   @14,COMPADDR                                        0705
*   IF R15 ^= 0 THEN                /* WAS ADDR ALREADY IN A BUFF?   */
         LTR   R15,R15                                             0706
         BZ    @RF00706                                            0706
*     DO;                           /* NO-                     Y02006*/
*       IF DMPIC = ON THEN          /* IS ALL OF DUMP IN CORE  Y02006*/
         TM    DMPIC(COMPTR),B'00010000'                           0708
         BO    @RT00708                                            0708
*         GOTO DATINVLD;            /* YES- DON'T CALL PREAD   Y02006*/
*       ELSE                        /*                         Y02006*/
*         CALL READREC;             /* NO, INTERFACE WITH PREAD TO 0710
*                                      GET DMP RECORD CONTAINING THE
*                                      ADDR.                         */
         BAL   @14,READREC                                         0710
*     END;                          /*                         Y02006*/
*                                                                  0711
*   /*****************************************************************/
*   /*                                                               */
*   /* BUFFER WITH SEGMENT TABLE ENTRY LOCATED. CHECK IF DATA IN     */
*   /* BUFFER IS VALID.                                              */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0712
*   MAPPTR = CURENTRY;              /* POINT TO BUF MAP ENTRY ASSOC.
*                                      WITH BUFFER.                  */
@RF00706 L     MAPPTR,CURENTRY                                     0712
*   IF INVALFLG = ON THEN           /* IS DATA IN BUF VALID?         */
         TM    INVALFLG(MAPPTR),B'10000000'                        0713
         BO    @RT00713                                            0713
*     GOTO DATINVLD;                /* NO, GO TO ERROR EXIT          */
*   SEGENTRY = BUFDATA(DATINDX:DATINDX+3); /* YES, GET SEG ENTRY     */
*                                                                  0715
         ICM   @14,7,BUFFPTR(MAPPTR)                               0715
         ALR   @14,DATINDX                                         0715
         MVC   SEGENTRY(4),BUFDATA-1(@14)                          0715
*   /*****************************************************************/
*   /*                                                               */
*   /* CHECK IF SEGMENT ENTRY IS VALID                               */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0716
*   IF SEGIBIT = ON THEN            /* IS ENTRY VALID                */
         TM    SEGIBIT,B'00000001'                                 0716
         BO    @RT00716                                            0716
*     GOTO DATINVLD;                /* NO, GO TO ERROR EXIT          */
*                                                                  0717
*   /*****************************************************************/
*   /*                                                               */
*   /* SEGMENT ENTRY IS VALID. GET PAGE ADDR PORTION OF REQUESTED    */
*   /* ADDR AND MULTIPLY BY 2 TO DETERMINE OFFSET OF PAGE ENTRY IN   */
*   /* PAGE TABLE. ADD OFFSET TO PAGE TABLE ADDR TO GET ADDR OF PAGE */
*   /* TABLE ENTRY ASSOCIATED WITH THE REQUESTED ADDR.               */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0718
*   GP = (LOW2BYTS / PAGESIZE) * 2; /* CALC OFFSET INTO PAGE TABLE   */
         SLR   GP,GP                                               0718
         ICM   GP,3,LOW2BYTS                                       0718
         SRL   GP,12                                               0718
         ALR   GP,GP                                               0718
*   SRCHAD = (PGETABAD & 'FFFFF8'X) + GP; /* GET ADDR OF PGTAB ENTRY */
*                                                                  0719
         SLR   @14,@14                                             0719
         ICM   @14,7,PGETABAD                                      0719
         N     @14,@CF01450                                        0719
         ALR   @14,GP                                              0719
         ST    @14,SRCHAD                                          0719
*   /*****************************************************************/
*   /*                                                               */
*   /* GET BUFFER CONTAINING PAGE TABLE ENTRY                        */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0720
*   DATINDX = SRCHAD // DATALNG + 1; /* GET OFFSET OF ENTRY IN BUF   */
         LR    @06,@14                                             0720
         SRDA  @06,32                                              0720
         D     @06,@CF01096                                        0720
         AH    @06,@CH00057                                        0720
         LR    DATINDX,@06                                         0720
*   SRCHAD = (SRCHAD & RNDVALU);    /* ROUND ADDR TO 4K BNDRY        */
         N     @14,@CF01082                                        0721
         ST    @14,SRCHAD                                          0721
*   CPUIDAD = OFF;                  /* INDICATE REAL OR VIRT   Y02006*/
*   REALADDR = ON;                  /* INDICATE A REAL ADDR PARM     */
         OI    REALADDR,B'00100000'                                0723
         NI    CPUIDAD,B'10111111'                                 0723
*   CALL COMPADDR;                  /* SRCH IF ADDR ALREADY IN BUFF  */
         BAL   @14,COMPADDR                                        0724
*   IF R15 ^= 0 THEN                /* WAS ADDR IN A BUFFER?         */
         LTR   R15,R15                                             0725
         BZ    @RF00725                                            0725
*     DO;                           /* NO-                     Y02006*/
*       IF DMPIC = ON THEN          /* IS ALL OF DUMP IN CORE  Y02006*/
         TM    DMPIC(COMPTR),B'00010000'                           0727
         BO    @RT00727                                            0727
*         GOTO DATINVLD;            /* YES- DON'T CALL PREAD   Y02006*/
*       ELSE                        /*                         Y02006*/
*         CALL READREC;             /* NO, INTERFACE TO PREAD TO GET
*                                      DUMP RCD CONTAINING THE ADDR  */
         BAL   @14,READREC                                         0729
*     END;                          /*                         Y02006*/
*                                                                  0730
*   /*****************************************************************/
*   /*                                                               */
*   /* BUFFER WITH PAGE TABLE ENTRY LOCATED. CHECK IF THE DATA IN THE*/
*   /* BUFFER IS VALID.                                              */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0731
*   MAPPTR = CURENTRY;              /* POINT TO BUF MAP ENTRY ASSOC.
*                                      WITH BUFFER                   */
@RF00725 L     MAPPTR,CURENTRY                                     0731
*   IF INVALFLG = ON THEN           /* DATA IN BUFFER VALID?         */
         TM    INVALFLG(MAPPTR),B'10000000'                        0732
         BO    @RT00732                                            0732
*     GOTO DATINVLD;                /* NO, GO TO ERROR EXIT          */
*   PAGENTRY = BUFDATA(DATINDX:DATINDX+1); /* YES, GET PAGE ENTRY    */
*                                                                  0734
         ICM   @14,7,BUFFPTR(MAPPTR)                               0734
         ALR   @14,DATINDX                                         0734
         SLR   PAGENTRY,PAGENTRY                                   0734
         ICM   PAGENTRY,3,BUFDATA-1(@14)                           0734
*   /*****************************************************************/
*   /*                                                               */
*   /* SEPARATE THE REAL PAGE # AND FLAG BITS IN THE PAGE ENTRY THEN */
*   /* CHECK IF THE PAGE TABLE ENTRY IS VALID                        */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0735
*   SHIFT = PAGESIZE / 256;         /* DETERMINE DIVISOR FOR SEPAR-
*                                      ATING REAL PAGE # AND FLGS    */
         LA    SHIFT,16                                            0735
*   SRCHAD = PAGENTRY / SHIFT;      /* PUT REAL PGE NO. IN PARM WORD */
         LR    @09,PAGENTRY                                        0736
         SLR   @08,@08                                             0736
         DR    @08,SHIFT                                           0736
         ST    @09,SRCHAD                                          0736
*   GP = PAGENTRY // SHIFT;         /* GET PAGENTRY FLAGS            */
         LR    @09,PAGENTRY                                        0737
         SLR   @08,@08                                             0737
         DR    @08,SHIFT                                           0737
         LR    GP,@08                                              0737
*   SHIFT = PAGESIZE / 512;         /* GET SHIFT VALUE TO ISOLATE THE
*                                      PAGE ENTRY INVALID BIT        */
         LA    SHIFT,8                                             0738
*   GP = GP / SHIFT;                /* GET INVALID BIT VALUE IN GP   */
*                                                                  0739
         LR    @07,GP                                              0739
         SLR   @06,@06                                             0739
         DR    @06,SHIFT                                           0739
         LR    GP,@07                                              0739
*   /*****************************************************************/
*   /*                                                               */
*   /* CHECK IF PAGE TABLE ENTRY IS VALID                            */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0740
*   IF GP = 1 THEN                  /* IS PAGE ENTRY VALID?          */
         LA    @14,1                                               0740
         CR    GP,@14                                              0740
         BNE   @RF00740                                            0740
*     DO;                           /* NO-CHECK IF RECLAIMABLE Y01980*/
*       IF SRCHAD = 0 ×             /* PAGE TABLE ENTRY = 0    Y01980*/
*          QAPFT = 0 THEN           /* OR ADDR PFT IN COM = 0  Y02006*/
         L     @09,SRCHAD                                          0742
         SLR   @08,@08                                             0742
         CR    @09,@08                                             0742
         BE    @RT00742                                            0742
         L     @07,QAPFT(,COMPTR)                                  0742
         CR    @07,@08                                             0742
         BE    @RT00742                                            0742
*         GO TO DATINVLD;           /* YES - INVALID PAGE      Y01980*/
*       SRCHSAVE = SRCHAD;          /* SAVE PAGE ENTRY         Y01980*/
         LR    SRCHSAVE,@09                                        0744
*       SRCHAD = 2 * SRCHAD * SHIFT + QAPFT; /* COMPUTE OFFSET Y02006
*                                      IN PAGE FRAME TABLE TO  Y02006
*                                      BEGINNING OF APPROP-    Y02006
*                                      RIATE ENTRY             Y02006*/
         ALR   @09,@09                                             0745
         MR    @08,SHIFT                                           0745
         ALR   @09,@07                                             0745
         ST    @09,SRCHAD                                          0745
*       SRCHSAV1 = SRCHAD;          /* SAVE IT FOR NEXT READ   Y02006*/
         ST    @09,SRCHSAV1                                        0746
*       DATINDX = SRCHAD//DATALNG + 1; /* GET OFFSET OF ENTRY IN BUF */
         LR    @08,@09                                             0747
         SRA   @08,31                                              0747
         D     @08,@CF01096                                        0747
         ALR   @08,@14                                             0747
         LR    DATINDX,@08                                         0747
*       SRCHAD = (SRCHAD & RNDVALU); /* ROUND ADDR TO 4K BNDRY Y01980*/
         L     @14,SRCHAD                                          0748
         N     @14,@CF01082                                        0748
         ST    @14,SRCHAD                                          0748
*       CPUIDAD = OFF;              /* INDICATE REAL OR VIRT   Y02006*/
*       REALADDR = ON;              /* INDICATE A REAL ADDR PARM     */
         OI    REALADDR,B'00100000'                                0750
         NI    CPUIDAD,B'10111111'                                 0750
*       CALL COMPADDR;              /* SRCH IF ADDR ALREADY IN BUFF  */
         BAL   @14,COMPADDR                                        0751
*       IF R15 ^= 0 THEN            /* WAS ADDR IN A BUFFER?   Y01980*/
         LTR   R15,R15                                             0752
         BZ    @RF00752                                            0752
*         DO;                       /* NO-                     Y02006*/
*           IF DMPIC = ON THEN      /* IS ALL OF DUMP IN CORE  Y02006*/
         TM    DMPIC(COMPTR),B'00010000'                           0754
         BO    @RT00754                                            0754
*             GOTO DATINVLD;        /* YES- DON'T CALL PREAD   Y02006*/
*           ELSE                    /*                         Y02006*/
*             CALL READREC;         /* NO, INTERFACE TO PREAD TO GET
*                                      DUMP RCD CONTAINING THE ADDR  */
         BAL   @14,READREC                                         0756
*         END;                      /*                         Y02006*/
*                                                                  0757
*   /*****************************************************************/
*   /*                                                               */
*   /* BUFFER WITH PAGE FRAME TABLE ENTRY LOCATED. CHECK IF THE DATA */
*   /* IN THE BUFFER IS VALID.                                       */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0758
*       MAPPTR = CURENTRY;          /* POINT TO BUF MAP ENTRY ASSOC.
*                                      WITH BUFFER                   */
@RF00752 L     MAPPTR,CURENTRY                                     0758
*       IF INVALFLG = ON THEN       /* DATA IN BUFFER VALID?         */
         TM    INVALFLG(MAPPTR),B'10000000'                        0759
         BO    @RT00759                                            0759
*         GOTO DATINVLD;            /* NO, GO TO ERROR EXIT          */
*                                                                  0760
*   /*****************************************************************/
*   /*                                                               */
*   /* THE BUFFER CONTAINING THE APPROPRIATE                         */
*   /* PAGE FRAME TABLE ENTRY IS VALID. CHECK IF VIRTUAL BLOCK       */
*   /* NUMBER IS THE SAME AS THAT REQUESTED. IF SO, THEN THE PAGE    */
*   /* MAY BE RECLAIMABLE. IF NOT, PAGE IS INVALID.                  */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0761
*       SRCHAD = REQADDR & '00FFF000'X; /* GET VIRTUAL BLOCK NO.     */
         L     @14,REQADDR                                         0761
         N     @14,@CF01451                                        0761
         ST    @14,SRCHAD                                          0761
*       PFTVBN = BUFDATA(DATINDX+2:DATINDX+3); /* GET PFT NTRY Y02006*/
         SLR   @14,@14                                             0762
         ICM   @14,7,BUFFPTR(MAPPTR)                               0762
         LR    @07,@14                                             0762
         ALR   @07,DATINDX                                         0762
         MVC   PFTVBN(2),BUFDATA+1(@07)                            0762
*       IF PFTVBN ^= SRCHVBNO THEN  /* PAGE RECLAIMABLE        Y01980*/
         CLC   PFTVBN(2),SRCHVBNO                                  0763
         BNE   @RT00763                                            0763
*         GO TO DATINVLD;           /* NO - PAGE UNAVAILABLE   Y01980*/
*                                                                  0764
*   /*****************************************************************/
*   /*                                                               */
*   /* VIRT BLOCK NUMBER MATCHES.  CHECK IF ASID ALSO MATCHES.       */
*   /* IF NOT, CHECK IF PAGE IN FRAME IS IN COMMON MEMORY- I.E.      */
*   /* ASID = FFFF.  IF SO, PAGE MAY BE RECLAIMABLE.  IF NOT,        */
*   /* PAGE IS INVALID.                                              */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0765
*       PFTASID = BUFDATA(DATINDX:DATINDX+1); /* GET PFT ASID  Y02006*/
         ALR   @14,DATINDX                                         0765
         MVC   PFTASID(2),BUFDATA-1(@14)                           0765
*       IF PFTASID ^= REQDASID &    /* IS PAGE                 Y02006*/
*          PFTASID ^= COMASID THEN  /* RECLAIMABLE?            Y02006*/
         CLC   PFTASID(2),REQDASID                                 0766
         BE    @RF00766                                            0766
         CLC   PFTASID(2),@CB01105                                 0766
         BNE   @RT00766                                            0766
*         GOTO DATINVLD;            /* NO- PAGE UNAVAILABLE    Y02006*/
*                                                                  0767
*   /*****************************************************************/
*   /*                                                               */
*   /* ASID MATCHES, OR PAGE IS IN COMMON MEMORY.  CHECK PFT         */
*   /* FLAGS TO INSURE THAT PAGE IS REALLY RECLAIMABLE.              */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0768
*       SRCHAD = SRCHSAV1 + 12;     /* COMPUTE OFFSET IN PFT   Y02006*/
@RF00766 LA    @14,12                                              0768
         AL    @14,SRCHSAV1                                        0768
         ST    @14,SRCHAD                                          0768
*                                   /* TO THIS ENTRY'S FLAGS   Y02006*/
*       DATINDX = SRCHAD//DATALNG +1; /* GET OFFSET OF FIELD   Y02006*/
         LR    @08,@14                                             0769
         SRDA  @08,32                                              0769
         D     @08,@CF01096                                        0769
         AH    @08,@CH00057                                        0769
         LR    DATINDX,@08                                         0769
*                                   /* IN BUFFER               Y02006*/
*       SRCHAD = SRCHAD & RNDVALU;  /* ROUND ADDR TO 4K BNDRY  Y02006*/
         N     @14,@CF01082                                        0770
         ST    @14,SRCHAD                                          0770
*       CPUIDAD = OFF;              /* INDICATE NOT CPU SRCH   Y02006*/
*       REALADDR = ON;              /* INDICATE REAL ADDR PARM Y02006*/
         OI    REALADDR,B'00100000'                                0772
         NI    CPUIDAD,B'10111111'                                 0772
*       CALL COMPADDR;              /* SRCH IF ADDR ALREADY IN Y02006*/
         BAL   @14,COMPADDR                                        0773
*                                   /* BUFFER                  Y02006*/
*       IF R15 ^= 0 THEN            /* WAS ADDR IN A BUFFER    Y02006*/
         LTR   R15,R15                                             0774
         BZ    @RF00774                                            0774
*         DO;                       /* NO-                     Y02006*/
*           IF DMPIC = ON THEN      /* IS ALL OF DUMP IN CORE? Y02006*/
         TM    DMPIC(COMPTR),B'00010000'                           0776
         BO    @RT00776                                            0776
*             GOTO DATINVLD;        /* YES- DONT CALL PREAD    Y02006*/
*           ELSE                    /*                         Y02006*/
*             CALL READREC;         /* NO, INTERFACE WITH      Y02006*/
         BAL   @14,READREC                                         0778
*         END;                      /* PREAD TO READ DATA      Y02006*/
*                                                                  0779
*   /*****************************************************************/
*   /*                                                               */
*   /* BUFFER WITH FLAGS FIELD OF PFT LOCATED.  CHECK IF THE         */
*   /* DATA IN THE BUFFER IS VALID.                                  */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0780
*       MAPPTR = CURENTRY;          /* POINT TO BUF MAP ENTRY  Y02006*/
@RF00774 L     MAPPTR,CURENTRY                                     0780
*                                   /* ASSOC WITH BUFFER       Y02006*/
*       IF INVALFLG = ON THEN       /* DATA IN BUFFER VALID?   Y02006*/
         TM    INVALFLG(MAPPTR),B'10000000'                        0781
         BO    @RT00781                                            0781
*         GOTO DATINVLD;            /* NO- GOTO ERROR EXIT     Y02006*/
*                                                                  0782
*   /*****************************************************************/
*   /*                                                               */
*   /* BUFFER CONTAINING FLAGS FIELDS OF PFT IS VALID.  CHECK        */
*   /* THE FLAGS.                                                    */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0783
*       PFTFLAGS = BUFDATA(DATINDX:DATINDX+1); /* GET FLAGS    Y02006*/
*                                                                  0783
         ICM   @14,7,BUFFPTR(MAPPTR)                               0783
         ALR   @14,DATINDX                                         0783
         MVC   PFTFLAGS(2),BUFDATA-1(@14)                          0783
*       IF PFTPCBSI = ON ×          /* IF ANY OF THESE         Y02006*/
*          PFTBADPG = ON ×          /* FOUR CONDITIONS         Y02006*/
*          PFTIRRG = ON ×           /* ARE TRUE-               Y02006*/
*         (PFTOFFLN = ON & PFTOFINT = OFF) THEN      /* PAGE   Y02006*/
         TM    PFTPCBSI,B'00001100'                                0784
         BNZ   @RT00784                                            0784
         TM    PFTIRRG,B'00010000'                                 0784
         BO    @RT00784                                            0784
         TM    PFTOFFLN,B'01000000'                                0784
         BNO   @RF00784                                            0784
         TM    PFTOFINT,B'00000001'                                0784
         BZ    @RT00784                                            0784
*         GOTO DATINVLD;            /* IS NOT RECLAIMABLE      Y02006*/
*                                                                  0785
*/********************************************************************/
*/*                                                          @YM08224*/
*/* GET THE CORRECT STORAGE PROTECT KEY FROM THE EXTERNAL PAGE TABLE */
*/* ENTRY, AND STORE IT IN THE SECOND BYTE OF THE COMMON DOUBLE WORD */
*/* WORK AREA, WORK1. THE FIRST BYTE OF WORK1 IS USED AS A   @YM08224*/
*/* RECLAIMABLE PAGE SWITCH. IF THE PAGE TABLE ENTRY IS AVAILABLE    */
*/* THE SWITCH IS SET TO 0. IF THE PAGE IS RECLAIMABLE, AND THE XPTE */
*/* IS AVAILABLE THE SWITCH IS SET TO 1. IF THE PAGE IS RECLAIMABLE  */
*/* AND THE XPTE IS NOT AVAILABLE, THE SWITCH IS SET TO 2.   @YM08224*/
*/*                                                          @YM08224*/
*/********************************************************************/
*       GP = (LOW2BYTS / PAGESIZE) * 12; /* CALCULATE OFFSET IN XPT  */
@RF00784 SLR   GP,GP                                               0786
         ICM   GP,3,LOW2BYTS                                       0786
         SRL   GP,12                                               0786
         MH    GP,@CH00240                                         0786
*        SRCHAD = (PGETABAD & 'FFFFF8'X) + GP + 32; /* ADDR OF XPTE  */
         SLR   @14,@14                                             0787
         ICM   @14,7,PGETABAD                                      0787
         N     @14,@CF01450                                        0787
         ALR   @14,GP                                              0787
         AH    @14,@CH00342                                        0787
         ST    @14,SRCHAD                                          0787
*       DATINDX = SRCHAD // DATALNG +1; /* OFFSET OF ENTRY IN BUF   */
         LR    @08,@14                                             0788
         SRDA  @08,32                                              0788
         D     @08,@CF01096                                        0788
         AH    @08,@CH00057                                        0788
         LR    DATINDX,@08                                         0788
*       SRCHAD = (SRCHAD & RNDVALU); /* RND ADDR TO 4K BNDRY @YM08224*/
         N     @14,@CF01082                                        0789
         ST    @14,SRCHAD                                          0789
*       CPUIDAD = OFF;              /* INDICATE REAL OR VIRT @YM08224*/
*       REALADDR = ON;              /* INDICATE A REAL ADDR PARM     */
         OI    REALADDR,B'00100000'                                0791
         NI    CPUIDAD,B'10111111'                                 0791
*       CALL COMPADDR;              /* SRCH IF ADDR ALREADY IN BUF   */
         BAL   @14,COMPADDR                                        0792
*       IF R15 ^= 0 THEN            /* WAS ADDR IN BUF?      @YM08224*/
         LTR   R15,R15                                             0793
         BZ    @RF00793                                            0793
*         DO;                       /* NO                    @YM08224*/
*           IF DMPIC = ON THEN      /* IS ALL DUMP IN CORE   @YM08224*/
         TM    DMPIC(COMPTR),B'00010000'                           0795
         BNO   @RF00795                                            0795
*             DO;                                          /*@YM08224*/
*               WORK1(1:1) = PROTNF; /* XPTE NOT AVAILABLE   @YM08224*/
         MVC   WORK1(1,COMPTR),PROTNF                              0797
*               GO TO RECLEND;       /* RETURN TO CALLER     @YM08224*/
         B     RECLEND                                             0798
*           END;                                           /*@YM08224*/
*           ELSE                                                   0800
*             CALL READREC;         /* NO, INTERFACE WITH PREAD      */
@RF00795 BAL   @14,READREC                                         0800
*        END;                                              /*@YM08224*/
*/********************************************************************/
*/*                                                          @YM08224*/
*/* CHECK IF DATA IN BUFFER VALID. IF IT IS MOVE THE PROTECT KEY FROM*/
*/* THE XPTE INTO BYTE 2 OF WORK1, AND TURN ON THE PROTECT KEY FOUND */
*/* SWITCH. IF THE XPTE IS NOT AVAILABLE, TURN ON THE PROTECT KEY NOT*/
*/* FOUND SWITCH.                                            @YM08224*/
*/*                                                          @YM08224*/
*/********************************************************************/
*    MAPPTR = CURENTRY;             /* POINT TO BUFMAP ENTRY @YM08224
*                                      ASSOC. WITH BUFFER    @YM08224*/
@RF00793 L     MAPPTR,CURENTRY                                     0802
*    IF INVALFLG = ON THEN          /* DATA IN BUFFER VALID  @YM08224*/
         TM    INVALFLG(MAPPTR),B'10000000'                        0803
         BNO   @RF00803                                            0803
*      DO;                          /* NO                    @YM08224*/
*        WORK1(1:1) = PROTNF;       /* XPTE NOT AVAILABLE    @YM08224*/
         MVC   WORK1(1,COMPTR),PROTNF                              0805
*        GO TO RECLEND;             /* RETURN TO CALLER      @YM08224*/
         B     RECLEND                                             0806
*      END;                                                /*@YM08224*/
*    ELSE                                                          0808
*    WORK1(1:1) = PROTKF;           /* SET PROTECT KEY FOUND SW      */
@RF00803 MVC   WORK1(1,COMPTR),PROTKF                              0808
*    WORK1(2:2) = BUFDATA(DATINDX); /* GET PROTECT KEY FROM XPTE     */
         ICM   @14,7,BUFFPTR(MAPPTR)                               0809
         ALR   @14,DATINDX                                         0809
         MVC   WORK1+1(1,COMPTR),BUFDATA-1(@14)                    0809
*   /*****************************************************************/
*   /*                                                               */
*   /* SINCE ALL OF THE ABOVE CONDITIONS HAVE BEEN MET,              */
*   /* THE REQUESTED PAGE IS RECLAIMABLE AND MAY BE RETURNED         */
*   /* TO THE CALLER.                                                */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0810
*RECLEND: SRCHAD = SRCHSAVE;        /* YES RESTORE PAGE VALUE        */
RECLEND  ST    SRCHSAVE,SRCHAD                                     0810
*     END;                                                         0811
*                                                                  0811
*   /*****************************************************************/
*   /*                                                               */
*   /* PAGE TABLE ENTRY IS VALID. MULTIPLY REAL PAGE NUMBER IN SRCHAD*/
*   /* BY THE PAGE SIZE TO DETERMINE THE REAL ADDRESS OF THE 4K      */
*   /* BLK OF STORAGE WHICH CONTAINS THE REQUESTED ADDR. THEN        */
*   /* CALCULATE THE BYTE ADDRESS.                                   */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0812
*   SRCHAD = SRCHAD * PAGESIZE;     /* GET REAL ADDR OF 4K BLK       */
@RF00740 L     @14,SRCHAD                                          0812
         SLA   @14,12                                              0812
         ST    @14,SRCHAD                                          0812
*   SRCHAD = SRCHAD + (LOW2BYTS // PAGESIZE); /* ADJUST THE REAL ADDR
*                                      TO THE PROPER BYTE BNDRY      */
         SLR   @04,@04                                             0813
         ICM   @04,3,LOW2BYTS                                      0813
         N     @04,@CF01471                                        0813
         ALR   @14,@04                                             0813
         ST    @14,SRCHAD                                          0813
*   R15 = 0;                        /* INDICATE SUCCESSFUL TRANS     */
         SLR   R15,R15                                             0814
*   RETURN;                         /* GO BACK TO MAINLINE           */
*                                                                  0815
@EL00008 DS    0H                                                  0815
@EF00008 DS    0H                                                  0815
@ER00008 L     @14,@SA00008                                        0815
         LM    @00,@02,@SA00008+4                                  0815
         LM    @04,@12,@SA00008+16                                 0815
         BR    @14                                                 0815
*   /*****************************************************************/
*   /*                                                               */
*   /* DAT ERROR EXIT                                                */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0816
*                                                                  0816
*DATINVLD:                                                         0816
*   R15 = 4;                        /* INDICATE INVALID ADDR         */
DATINVLD LA    R15,4                                               0816
*   RETURN;                         /* GO BACK TO MAINLINE           */
         B     @EL00008                                            0817
*   END DAT;                                                       0818
*                                                                  0818
*   END AMDPRRDC                                                   0819
*/* THE FOLLOWING INCLUDE STATEMENTS WERE FOUND IN THIS PROGRAM.      *
*/*%INCLUDE SYSLIB  (COMMON  )                                        *
*/*%INCLUDE SYSLIB  (IHAASCB )                                        *
*/*%INCLUDE SYSLIB  (CVT     )                                        *
*;                                                                 0819
@DATA    DS    0H
@CH00057 DC    H'1'
@CH00164 DC    H'2'
@CH01163 DC    H'7'
@CH00171 DC    H'9'
@CH00240 DC    H'12'
@CH00183 DC    H'16'
@CH00213 DC    H'20'
@CH00342 DC    H'32'
@CH01309 DC    H'200'
@CH01103 DC    H'4104'
         DS    0F
@SA00001 DS    18F
@SA00002 DS    15F
@SA00004 DS    15F
@SA00008 DS    13F
@SA00005 DS    15F
@SA00007 DS    0F
         DS    15F
         DS    0F
@CF00156 DC    F'4'
@CF00043 DC    F'8'
@CH00043 EQU   @CF00043+2
@CF01471 DC    F'4095'
@CF01096 DC    F'4096'
@CF01455 DC    F'4124'
@CH01455 EQU   @CF01455+2
@CF01100 DC    F'65536'
@CF01304 DC    F'196608'
@CF01082 DC    XL4'FFFFF000'
@CF01312 DC    XL4'FFFFFFF8'
@CF01448 DC    XL4'FFFFFFC0'
@CF01451 DC    XL4'00FFF000'
@CF01450 DC    XL4'FFFFF8'
@CV01129 DC    V(AMDPREAD)
         DS    0D
CURENTRY DC    A(0)
VIRTSAVE DC    A(0)
PRENTRY  DC    A(0)
PLIST    DS    A
ZEROSEG  DC    A(0)
SGTBAPTR DC    A(0)
SRCHAD   DC    A(0)
         ORG   SRCHAD
@NM00050 DS    AL1
SRCHVBNO DS    CL2
         ORG   SRCHVBNO
@NM00051 DS    AL1
SRCHCPU  DS    BL2
         ORG   SRCHAD+3
@NM00052 DS    AL1
         ORG   SRCHAD+4
OFFSET   DC    F'0'
BUFSPACE DC    F'0'
CURENSAV DS    A
MGTABPTR DC    AL4(AMDRDCMG)
MAPSIZE  DS    F
ERRHANSV DS    A
ASCBMLEN DC    F'0'
DISPQEND DS    A
CVTREADA DS    A
ASCHAIN  DS    F
REQADDR  DS    FL4
         ORG   REQADDR
HIBYT    DS    CL1
SEGBYTE  DS    AL1
LOW2BYTS DS    AL2
         ORG   REQADDR+4
SEGORIGN DS    FL4
         ORG   SEGORIGN
SEGLNG   DS    AL1
SEGTABAD DS    AL3
         ORG   SEGORIGN+4
SRCHSAV1 DS    A
NTRYCT   DS    H
MAPINDX  DC    H'0'
PROTNRQ  DC    AL1(0)
PROTKF   DC    AL1(1)
PROTNF   DC    AL1(2)
         DS    0D
@TS00001 DS    CL8
@CB01105 DC    X'FFFF'
ASIDSAVE DC    AL2(0)
REQDASID DC    AL2(0)
SWITCHES DC    X'00'
         ORG   SWITCHES
INITSW   DS    BL1
CPUIDAD  EQU   SWITCHES+0
REALADDR EQU   SWITCHES+0
LODSW    EQU   SWITCHES+0
RSVDSWS  EQU   SWITCHES+0
         ORG   SWITCHES+1
         DS    CL1
DEVAREA  DS    CL8
SYSUT1   DC    CL8'SYSUT1'
SYSUT2   DC    CL8'SYSUT2'
INDD1    DS    CL8
GETMNLST DS    CL16
         ORG   GETMNLST
REQSTOR  DS    CL8
         ORG   REQSTOR
MIN      DC    F'65536'
MAX      DC    F'16777215'
         ORG   GETMNLST+8
GOTSTOR  DS    CL8
         ORG   GOTSTOR
BUFMAP   DC    A(0)
CORE     DC    F'0'
         ORG   CORE
BUFSUBPL DS    FL1
         ORG   GETMNLST+16
ADJSAVE  DS    CL72
         ORG   ADJSAVE
@NM00054 DC    72X'00'
         ORG   ADJSAVE+72
DATASAVE DS    CL72
         ORG   DATASAVE
@NM00055 DC    72X'00'
         ORG   DATASAVE+72
BUFFINIT DS    CL12
         ORG   BUFFINIT
@NM00058 DC    12X'FF'
         ORG   BUFFINIT+12
CPUSTAT  DS    CL192
         ORG   CPUSTAT
CPUFLAGS DS    CL1
         ORG   CPUFLAGS
@NM00066 DS    BL1
CPUNSADP EQU   CPUFLAGS+0
@NM00067 EQU   CPUFLAGS+0
         ORG   CPUSTAT+1
CPURESV  DS    CL1
CPUADDR  DS    BL2
HDRREGS1 DS    CL168
         ORG   HDRREGS1
CPUFLPT  DS    CL32
CPUREGS  DS    CL64
CPUCTL   DS    CL64
CPUPSW   DS    CL8
         ORG   CPUSTAT+172
CPUPSA   DS    AL4
CPUTIMER DS    CL8
CPUCLKCP DS    CL8
         ORG   CPUSTAT+192
QASIDSAV DS    BL2
ASMPBSW  DC    X'00'
         ORG   ASMPBSW
ASCBERMG DS    BL1
ASCBLIMG EQU   ASMPBSW+0
ASMPFREE EQU   ASMPBSW+0
ASRESVMG EQU   ASMPBSW+0
         ORG   ASMPBSW+1
DECCNVT  DS    CL3
FASIDVAL DC    X'FFFF'
SEGENTRY DS    CL4
         ORG   SEGENTRY
SEGHIBYT DS    CL1
         ORG   SEGHIBYT
PGELNG   DS    BL1
PGEKEY   EQU   SEGHIBYT+0
         ORG   SEGENTRY+1
PGETABAD DS    AL3
         ORG   PGETABAD
TABADDR  DS    BL3
SEGEAC   EQU   PGETABAD+2
SEGIBIT  EQU   PGETABAD+2
         ORG   SEGENTRY+4
PFTVBN   DS    CL2
PFTASID  DS    BL2
PFTFLAGS DS    CL2
         ORG   PFTFLAGS
PFTFLAG1 DS    CL1
         ORG   PFTFLAG1
@NM00068 DS    BL1
PFTPCBSI EQU   PFTFLAG1+0
PFTBADPG EQU   PFTFLAG1+0
@NM00069 EQU   PFTFLAG1+0
PFTOFINT EQU   PFTFLAG1+0
         ORG   PFTFLAGS+1
PFTFLAG2 DS    CL1
         ORG   PFTFLAG2
@NM00070 DS    BL1
PFTOFFLN EQU   PFTFLAG2+0
@NM00071 EQU   PFTFLAG2+0
PFTIRRG  EQU   PFTFLAG2+0
@NM00072 EQU   PFTFLAG2+0
         ORG   PFTFLAGS+2
         DS    CL2
LODBRTAB DC    AL4(PREAD)
         DC    AL4(FREESAVE)
         DC    AL4(FREEXIT)
PATCH    DC    64F'0'
ASERBRTB DC    AL4(ASERCD00)
         DC    AL4(ASERCD04)
         DC    AL4(ASERCD08)
         DC    AL4(ASERCD10)
         DC    AL4(ASERCD04)
         DC    AL4(ASERCD08)
AMDPRRDC CSECT
DTAE     EQU   32                  DATA EBCDIC BIT
DTAC     EQU   16                  DATA IN CORE BIT
DTAP     EQU   8                   DATA PTR BIT
DTA      EQU   4                   DATA INCLUDED BIT
LBLP     EQU   2                   LABEL PTR BIT
LBL      EQU   1                   LABEL INCLUDED BIT
AMDPRRDC CSECT
AMDRDCMG CSECT
         DC    AL4(WTO151I)
         DC    AL4(51)
         DC    AL4(AMD173I)
         DC    AL4(57)
         DC    AL4(AMD175I)
         DC    AL4(47)
         DC    AL4(WTO254I)
         DC    AL4(59)
         DC    AL4(AMD285I)                                      Y02006
         DC    AL4(53)                                           Y02006
         DC    AL4(AMD292I)                                      Y02006
         DC    AL4(39)                                           Y02006
         DC    AL4(AMD293I)                                      Y02006
         DC    AL4(55)                                           Y02006
WTO151I  WTO   'AMD151I INSUFFICIENT STORAGE - EXECUTION TERMINATED',  C
               ROUTCDE=2,DESC=6,MF=L
WTO254I  WTO   'AMD254I SYSUT1 D.A. FILE NOT DEFINED - EXECUTION TERMINC
               ATED',ROUTCDE=2,DESC=6,MF=L
AMD173I  DC    CL57'AMD173I SYSUT1 IS NOT DA - DUMP WILL BE PROCESSED OC
               N TAPE'
AMD175I  DC    CL47'AMD175I NO TAPE DD CARD - SYSUT1 ASSUMED LOADED'
*                                                                Y02006
AMD285I  DC    CL53'AMD285I DUMP DEFINED ON DIRECT ACCESS- SYSUT1 IGNORC
               ED'
AMD292I  DC    CL39'AMD292I ERROR IN ASCB DISPATCHING CHAIN'     Y02006
*                                                                Y02006
AMD293I  DC    CL55'AMD293I NUMBER OF ASCBS EXCEEDED DEFAULT LIMIT OF  C
                   '
AMDPRRDC CSECT
@00      EQU   00                      EQUATES FOR REGISTERS 0-15
@01      EQU   01
@02      EQU   02
@03      EQU   03
@04      EQU   04
@05      EQU   05
@06      EQU   06
@07      EQU   07
@08      EQU   08
@09      EQU   09
@10      EQU   10
@11      EQU   11
@12      EQU   12
@13      EQU   13
@14      EQU   14
@15      EQU   15
SRCHSAVE EQU   @06
SHIFT    EQU   @04
DATINDX  EQU   @04
PAGENTRY EQU   @06
ASCBERR  EQU   @03
BUFNO    EQU   @04
BUFPTR   EQU   @06
ADDSPACE EQU   @04
CORE2    EQU   @03
CORE1    EQU   @04
ASTABPTR EQU   @04
ASMAPPTR EQU   @06
INITRTN  EQU   @03
LOADRTN  EQU   @03
MAPPTR   EQU   @03
R0       EQU   @00
R1       EQU   @01
R2       EQU   @02
R5       EQU   @05
R13      EQU   @13
R15      EQU   @15
GP       EQU   @05
COMPTR   EQU   @12
BASE1    EQU   @11
BASE2    EQU   @10
BASE3    EQU   @09
BUFREG   EQU   @06
CNTREG   EQU   @03
COMBASE  EQU   @12
LINEREG  EQU   @08
PREG     EQU   @01
R10      EQU   @10
R11      EQU   @11
R12      EQU   @12
R14      EQU   @14
R3       EQU   @03
R4       EQU   @04
R6       EQU   @06
R7       EQU   @07
R8       EQU   @08
R9       EQU   @09
STOPBASE EQU   @05
         ENTRY AMDPRRDA
         ENTRY AMDPRRDD
COMMON   EQU   0
ERRADDR  EQU   COMMON
WORK1    EQU   COMMON+24
NUCTOP   EQU   COMMON+32
CVTADDR  EQU   COMMON+56
INDD     EQU   COMMON+68
RDENTRY  EQU   COMMON+80
READTM   EQU   COMMON+92
SWA      EQU   COMMON+122
RDRSW    EQU   SWA
SWB      EQU   COMMON+123
FMTERR   EQU   SWB
QSYSUT2  EQU   SWB
SWC      EQU   COMMON+124
MSTRSW   EQU   SWC
POSITSW  EQU   SWC
TREADIN  EQU   SWC
SWD      EQU   COMMON+125
FLSHMODE EQU   SWD
SWE      EQU   COMMON+126
BUILDMAP EQU   SWE
SWF      EQU   COMMON+127
QSADMP   EQU   SWF
DMPIC    EQU   SWF
BUFSW    EQU   COMMON+128
PRSW     EQU   COMMON+129
PRNTREAL EQU   PRSW
TABLE    EQU   COMMON+659
HEXTABL  EQU   TABLE+63
APRTMSG  EQU   COMMON+1504
AEREXIT  EQU   COMMON+1536
BUFSUM   EQU   COMMON+1576
BUFREINT EQU   COMMON+1580
DCBADDRS EQU   COMMON+1608
@NM00041 EQU   DCBADDRS+16
@NM00042 EQU   @NM00041
REALMAP  EQU   COMMON+1644
SEGTABOR EQU   COMMON+1648
REALMAX  EQU   COMMON+1652
QAPFT    EQU   COMMON+1660
QASID    EQU   COMMON+1664
IPLCPU   EQU   COMMON+1666
PREFXRGR EQU   COMMON+1672
PREFXRGV EQU   COMMON+1676
HDRREGS  EQU   COMMON+1696
ASCBMAP  EQU   COMMON+1976
BUFERMAP EQU   COMMON+1980
BRRDDATA EQU   COMMON+1984
ASCBMAX  EQU   COMMON+2040
CSADDR   EQU   COMMON+2072
ASCB     EQU   0
ASCBFWDP EQU   ASCB+4
ASCBBWDP EQU   ASCB+8
ASCBASID EQU   ASCB+36
ASCBSTOR EQU   ASCB+44
ASCBFW1  EQU   ASCB+100
ASCBRCTF EQU   ASCBFW1+2
ASCBFLG1 EQU   ASCBFW1+3
ASCBDSP1 EQU   ASCB+114
ASCBFLG2 EQU   ASCB+115
CVTMAP   EQU   0
CVTDAR   EQU   CVTMAP+72
CVTFLGS1 EQU   CVTDAR
CVTDCB   EQU   CVTMAP+116
CVTIERLC EQU   CVTMAP+144
CVTOPTA  EQU   CVTMAP+182
CVTOPTB  EQU   CVTMAP+183
CVTGTF   EQU   CVTMAP+236
CVTGTFST EQU   CVTGTF
CVTGTFS  EQU   CVTGTFST
CVTSTATE EQU   CVTGTFST
CVTTMODE EQU   CVTGTFST
CVTFORM  EQU   CVTGTFST
CVTAQAVT EQU   CVTMAP+240
CVTTCMFG EQU   CVTAQAVT
CVTVOLM2 EQU   CVTMAP+244
CVTTATA  EQU   CVTVOLM2
CVTTSKS  EQU   CVTTATA
CVTVOLF2 EQU   CVTTSKS
CVTTAT   EQU   CVTTATA+1
CVTATER  EQU   CVTMAP+248
CVTEXT1  EQU   CVTMAP+252
CVTPURG  EQU   CVTMAP+260
CVTQMSG  EQU   CVTMAP+268
CVTDMSR  EQU   CVTMAP+272
CVTERPV  EQU   CVTMAP+316
CVTINTLA EQU   CVTMAP+320
CVTAPF   EQU   CVTMAP+324
CVTEXT2  EQU   CVTMAP+328
CVTHJES  EQU   CVTMAP+332
CVTPGSIA EQU   CVTMAP+348
CVTA1F1  EQU   CVTMAP+356
CVTSYSK  EQU   CVTMAP+357
CVTVOLM1 EQU   CVTMAP+380
CVTVOLF1 EQU   CVTVOLM1
CVTATMCT EQU   CVTMAP+388
CVTXTNT1 EQU   0
CVTXTNT2 EQU   0
CVTDSSV  EQU   CVTXTNT2
CVTFLGBT EQU   CVTXTNT2+5
CVTQID   EQU   CVTXTNT2+24
CVTRV400 EQU   CVTXTNT2+52
CVTRV409 EQU   CVTXTNT2+53
CVTATCVT EQU   CVTXTNT2+64
CVTRV429 EQU   CVTXTNT2+84
CVTRV438 EQU   CVTXTNT2+85
CVTRV457 EQU   CVTXTNT2+112
CVTRV466 EQU   CVTXTNT2+113
CVTFIX   EQU   0
CVTRELNO EQU   CVTFIX+252
SGTBAD   EQU   0
SEGTADDR EQU   SGTBAD+1
AMDPRLOD EQU   0
AMDPRMST EQU   0
SAVEMAP  EQU   0
HIGHSAVE EQU   SAVEMAP+4
PLISTMAP EQU   0
DATADDR  EQU   PLISTMAP
DATAAD   EQU   DATADDR+1
CPUAD    EQU   DATAAD+2
DATATYPE EQU   PLISTMAP+4
CPUDAT   EQU   DATATYPE
REQASID  EQU   PLISTMAP+6
BUFFMAP  EQU   0
BUFFLINK EQU   BUFFMAP
BUFFFLAG EQU   BUFFMAP+4
INVALFLG EQU   BUFFFLAG
BUFFCOM  EQU   BUFFFLAG
BUFFPTR  EQU   BUFFMAP+5
BUFFIELD EQU   BUFFMAP+8
BUFFREAL EQU   BUFFIELD
BUFFVIRT EQU   BUFFIELD+4
BUFFASID EQU   BUFFIELD+8
BUFFCPU  EQU   BUFFIELD+10
BUFFER   EQU   0
BUFPREFX EQU   BUFFER
BUFDATA  EQU   BUFFER+8
CPUSADRC EQU   0
FLAGS    EQU   CPUSADRC+2
CPUADDR1 EQU   CPUSADRC+6
CPUSTATS EQU   CPUSADRC+8
CSRTIMER EQU   CPUSTATS+216
CSRCLKCP EQU   CPUSTATS+224
CSRPSW   EQU   CPUSTATS+256
CSRPSA   EQU   CPUSTATS+264
CSRFLPT  EQU   CPUSTATS+352
CSRREGS  EQU   CPUSTATS+384
CSRCTL   EQU   CPUSTATS+448
ASCBPREF EQU   0
ASCBTAB  EQU   ASCBPREF
ASCBNUM  EQU   ASCBPREF+4
ASMAPLEN EQU   ASCBPREF+8
ASTABLEN EQU   ASCBPREF+12
ASMAPENT EQU   0
ASID     EQU   ASMAPENT
ASTABENT EQU   0
ASCBADDR EQU   ASTABENT
ASCBAFLG EQU   ASCBADDR
SEGTBADR EQU   ASTABENT+4
MSGADDR  EQU   0
M293AMAX EQU   0
STORGEAD EQU   0
ASCBPTR  EQU   ASCBADDR
CVTPTR   EQU   CVTADDR
CVTS01   EQU   CVTPGSIA
CVTLPDIA EQU   CVTS01+12
CVTDIRST EQU   CVTLPDIA
CVTSLIDA EQU   CVTS01+24
CVTCTLFG EQU   CVTS01+50
CVTASCBH EQU   CVTS01+216
CVTASCBL EQU   CVTS01+220
CVTRV210 EQU   CVTS01+424
CVTRV219 EQU   CVTS01+425
CVTRV228 EQU   CVTS01+426
CVTRV237 EQU   CVTS01+427
CVTMFRTR EQU   CVTS01+452
CVTRV262 EQU   CVTS01+468
CVTRV271 EQU   CVTS01+469
CVTRV280 EQU   CVTS01+470
CVTRV289 EQU   CVTS01+471
CVTGSDA  EQU   CVTS01+600
ZEROPREF EQU   ASCBPREF
ZEROCPU  EQU   CPUSTAT
         AGO   .@UNREFD                START UNREFERENCED COMPONENTS
CVTRV628 EQU   CVTS01+728
CVTRV627 EQU   CVTS01+724
CVTRV626 EQU   CVTS01+720
CVTRV625 EQU   CVTS01+716
CVTRV624 EQU   CVTS01+712
CVTRV623 EQU   CVTS01+708
CVTRV622 EQU   CVTS01+704
CVTRV621 EQU   CVTS01+700
CVTRV620 EQU   CVTS01+696
CVTRV619 EQU   CVTS01+692
CVTRV618 EQU   CVTS01+688
CVTRV617 EQU   CVTS01+684
CVTRV616 EQU   CVTS01+680
CVTRV615 EQU   CVTS01+676
CVTRV614 EQU   CVTS01+672
CVTRV613 EQU   CVTS01+668
CVTRV612 EQU   CVTS01+664
CVTRV611 EQU   CVTS01+660
CVTRV610 EQU   CVTS01+656
CVTRV609 EQU   CVTS01+652
CVTRV608 EQU   CVTS01+648
CVTRV607 EQU   CVTS01+644
CVTRV606 EQU   CVTS01+640
CVTRV605 EQU   CVTS01+636
CVTRV604 EQU   CVTS01+632
CVTEFF02 EQU   CVTS01+628
CVTCBBR  EQU   CVTS01+624
CVTSSCR  EQU   CVTS01+620
CVTEVENT EQU   CVTS01+616
CVTCRCA  EQU   CVTS01+612
CVTTPIO  EQU   CVTS01+608
CVTADV   EQU   CVTS01+604
CVTGSDAB EQU   CVTGSDA
CVTQV3   EQU   CVTS01+596
CVTQV2   EQU   CVTS01+592
CVTQV1   EQU   CVTS01+588
CVTRPT   EQU   CVTS01+584
CVTSSRB  EQU   CVTS01+580
CVTCSDRL EQU   CVTS01+576
CVTEXP1  EQU   CVTS01+572
CVTRMPMT EQU   CVTS01+568
CVTRMPTT EQU   CVTS01+564
CVTVPSA  EQU   CVTS01+560
CVTVSTOP EQU   CVTS01+556
CVTGTFR8 EQU   CVTS01+552
CVTQUIT  EQU   CVTS01+548
CVTVACR  EQU   CVTS01+544
CVTWTCB  EQU   CVTS01+540
CVTSTPRS EQU   CVTS01+536
CVT0PT02 EQU   CVTS01+532
CVTDARCM EQU   CVTS01+528
CVTIRECM EQU   CVTS01+524
CVTJRECM EQU   CVTS01+520
CVTVEMS0 EQU   CVTS01+516
CVTSPFRR EQU   CVTS01+512
CVTRLSTG EQU   CVTS01+508
CVT0TC0A EQU   CVTS01+504
CVTGMBR  EQU   CVTS01+500
CVTLFRM  EQU   CVTS01+496
CVTRMBR  EQU   CVTS01+492
CVTVIOP  EQU   CVTS01+488
CVTRV307 EQU   CVTS01+486
CVTRV306 EQU   CVTS01+484
CVTRV305 EQU   CVTS01+482
CVTRV304 EQU   CVTS01+480
CVTRV303 EQU   CVTS01+478
CVTRV302 EQU   CVTS01+476
CVTTRCA  EQU   CVTS01+472
CVTRV297 EQU   CVTRV289
CVTRV296 EQU   CVTRV289
CVTRV295 EQU   CVTRV289
CVTRV294 EQU   CVTRV289
CVTRV293 EQU   CVTRV289
CVTRV292 EQU   CVTRV289
CVTRV291 EQU   CVTRV289
CVTRV290 EQU   CVTRV289
CVTRV288 EQU   CVTRV280
CVTRV287 EQU   CVTRV280
CVTRV286 EQU   CVTRV280
CVTRV285 EQU   CVTRV280
CVTRV284 EQU   CVTRV280
CVTRV283 EQU   CVTRV280
CVTRV282 EQU   CVTRV280
CVTRV281 EQU   CVTRV280
CVTRV279 EQU   CVTRV271
CVTRV278 EQU   CVTRV271
CVTRV277 EQU   CVTRV271
CVTRV276 EQU   CVTRV271
CVTRV275 EQU   CVTRV271
CVTRV274 EQU   CVTRV271
CVTRV273 EQU   CVTRV271
CVTRV272 EQU   CVTRV271
CVTRV270 EQU   CVTRV262
CVTRV269 EQU   CVTRV262
CVTRV268 EQU   CVTRV262
CVTRV267 EQU   CVTRV262
CVTRV266 EQU   CVTRV262
CVTRV265 EQU   CVTRV262
CVTRV264 EQU   CVTRV262
CVTRV263 EQU   CVTRV262
CVTVFP   EQU   CVTS01+464
CVTVSI   EQU   CVTS01+460
CVTVPSIB EQU   CVTS01+456
CVTMFACT EQU   CVTMFRTR
CVTMFCTL EQU   CVTS01+448
CVTPVBP  EQU   CVTS01+444
CVTPWI   EQU   CVTS01+440
CVTRV254 EQU   CVTS01+438
CVTRV253 EQU   CVTS01+436
CVTRV252 EQU   CVTS01+434
CVTRV251 EQU   CVTS01+433
CVTRV250 EQU   CVTS01+432
CVTRV249 EQU   CVTS01+431
CVTRV248 EQU   CVTS01+430
CVTRV247 EQU   CVTS01+429
CVTRV246 EQU   CVTS01+428
CVTRV245 EQU   CVTRV237
CVTRV244 EQU   CVTRV237
CVTRV243 EQU   CVTRV237
CVTRV242 EQU   CVTRV237
CVTRV241 EQU   CVTRV237
CVTRV240 EQU   CVTRV237
CVTRV239 EQU   CVTRV237
CVTRV238 EQU   CVTRV237
CVTRV236 EQU   CVTRV228
CVTRV235 EQU   CVTRV228
CVTRV234 EQU   CVTRV228
CVTRV233 EQU   CVTRV228
CVTRV232 EQU   CVTRV228
CVTRV231 EQU   CVTRV228
CVTRV230 EQU   CVTRV228
CVTRV229 EQU   CVTRV228
CVTRV227 EQU   CVTRV219
CVTRV226 EQU   CVTRV219
CVTRV225 EQU   CVTRV219
CVTRV224 EQU   CVTRV219
CVTRV223 EQU   CVTRV219
CVTRV222 EQU   CVTRV219
CVTRV221 EQU   CVTRV219
CVTRV220 EQU   CVTRV219
CVTRV218 EQU   CVTRV210
CVTRV217 EQU   CVTRV210
CVTRV216 EQU   CVTRV210
CVTRV215 EQU   CVTRV210
CVTRV214 EQU   CVTRV210
CVTRV213 EQU   CVTRV210
CVTRV212 EQU   CVTRV210
CVTRV211 EQU   CVTRV210
CVTLCCAT EQU   CVTS01+420
CVTPCCAT EQU   CVTS01+416
CVTIPCRP EQU   CVTS01+412
CVTIPCRI EQU   CVTS01+408
CVTIPCDS EQU   CVTS01+404
CVTAIDVT EQU   CVTS01+400
CVTSSAP  EQU   CVTS01+396
CVTEHCIR EQU   CVTS01+392
CVTEHDEF EQU   CVTS01+388
CVTDAIR  EQU   CVTS01+384
CVTPERFM EQU   CVTS01+380
CVT044R2 EQU   CVTS01+376
CVTFETCH EQU   CVTS01+372
CVTRSTWD EQU   CVTS01+368
CVTSPOST EQU   CVTS01+364
CVTIOBP  EQU   CVTS01+360
CVTASMVT EQU   CVTS01+356
CVTRECRQ EQU   CVTS01+352
CVTWSAC  EQU   CVTS01+348
CVTRV149 EQU   CVTS01+344
CVTWSAL  EQU   CVTS01+340
CVTSPSA  EQU   CVTS01+336
CVTGLMN  EQU   CVTS01+332
CVTVEAC0 EQU   CVTS01+328
CVT062R1 EQU   CVTS01+324
CVTRPOST EQU   CVTS01+320
CVTDQIQE EQU   CVTS01+316
CVTCSD   EQU   CVTS01+312
CVTLKRMA EQU   CVTS01+308
CVTRSPIE EQU   CVTS01+304
CVTRENQ  EQU   CVTS01+300
CVTLQCB  EQU   CVTS01+296
CVTFQCB  EQU   CVTS01+292
CVTQCS01 EQU   CVTS01+288
CVTAPFT  EQU   CVTS01+284
CVTPARRL EQU   CVTS01+280
CVTVWAIT EQU   CVTS01+276
CVTGSPL  EQU   CVTS01+272
CVTLSMQ  EQU   CVTS01+268
CVTGSMQ  EQU   CVTS01+264
CVTEXPRO EQU   CVTS01+260
CVTOPCTP EQU   CVTS01+256
CVTSIC   EQU   CVTS01+252
CVTTPIOS EQU   CVTS01+248
CVTRTMS  EQU   CVTS01+244
CVTSDBF  EQU   CVTS01+240
CVTSCBP  EQU   CVTS01+236
CVTSDMP  EQU   CVTS01+232
CVTSV60  EQU   CVTS01+228
CVTRTMCT EQU   CVTS01+224
CVTGDA   EQU   CVTS01+212
CVTASVT  EQU   CVTS01+208
CVTVVMDI EQU   CVTS01+204
CVTAQTOP EQU   CVTS01+200
CVTIOSCS EQU   CVTS01+196
CVTSDRM  EQU   CVTS01+192
CVTOPTE  EQU   CVTS01+188
CVTSTXU  EQU   CVTS01+184
CVTQUIS  EQU   CVTS01+180
CVTPARS  EQU   CVTS01+176
CVTS1EE  EQU   CVTS01+172
CVTFRAS  EQU   CVTS01+168
CVTQSAS  EQU   CVTS01+164
CVTCRAS  EQU   CVTS01+160
CVTCRMN  EQU   CVTS01+156
CVTDELCP EQU   CVTS01+152
CVTFRECL EQU   CVTS01+148
CVTGETCL EQU   CVTS01+144
CVTBLDCP EQU   CVTS01+140
CVTAUTHL EQU   CVTS01+136
CVTSCAN  EQU   CVTS01+132
CVTRV144 EQU   CVTS01+130
CVTMAXMP EQU   CVTS01+128
CVTSTCK  EQU   CVTS01+124
CVTRV139 EQU   CVTS01+123
CVTDSSAC EQU   CVTS01+122
CVTRV513 EQU   CVTS01+121
CVTIOSPL EQU   CVTS01+120
CVTPTGT  EQU   CVTS01+116
CVTCSPIE EQU   CVTS01+112
CVTSMFEX EQU   CVTS01+108
CVTOLT0A EQU   CVTS01+104
CVTSRBRT EQU   CVTS01+100
CVTPUTL  EQU   CVTS01+96
CVTRV519 EQU   CVTS01+92
CVTRV327 EQU   CVTS01+88
CVTRV326 EQU   CVTS01+84
CVTRV325 EQU   CVTS01+80
CVTRV324 EQU   CVTS01+76
CVT0VL01 EQU   CVTS01+72
CVTSHRVM EQU   CVTS01+68
CVTRV332 EQU   CVTS01+64
CVTTAS   EQU   CVTS01+60
CVTRSCN  EQU   CVTS01+56
CVTTRAC2 EQU   CVTS01+54
CVTTRACE EQU   CVTS01+52
CVTAPG   EQU   CVTS01+51
CVTSDTRC EQU   CVTCTLFG
CVTGTRCE EQU   CVTCTLFG
CVTNOMP  EQU   CVTCTLFG
CVTRSV79 EQU   CVTCTLFG
CVTDSTAT EQU   CVTCTLFG
CVTRSV78 EQU   CVTCTLFG
CVTRV333 EQU   CVTCTLFG
CVTRV323 EQU   CVTCTLFG
CVTSPVLK EQU   CVTS01+49
CVTRSV77 EQU   CVTS01+48
CVTRV331 EQU   CVTS01+44
CVTRV330 EQU   CVTS01+40
CVTRV329 EQU   CVTS01+36
CVTRV328 EQU   CVTS01+32
CVTRV322 EQU   CVTS01+28
CVTSLID  EQU   CVTSLIDA+1
CVTSYLK  EQU   CVTSLIDA
CVTRV321 EQU   CVTS01+20
CVTRV320 EQU   CVTS01+16
CVTLPDIR EQU   CVTLPDIA+1
CVTRSV69 EQU   CVTDIRST
CVTRSV68 EQU   CVTDIRST
CVTRSV67 EQU   CVTDIRST
CVTRSV66 EQU   CVTDIRST
CVTRSV65 EQU   CVTDIRST
CVTRSV64 EQU   CVTDIRST
CVTRSV63 EQU   CVTDIRST
CVTDICOM EQU   CVTDIRST
CVTPVTP  EQU   CVTS01+8
CVTLPDSR EQU   CVTS01+4
CVTGETL  EQU   CVTS01
@NM00065 EQU   ASCBADDR
ASCBRESV EQU   ASCBPREF+6
@NM00064 EQU   CPUSTATS+512
@NM00063 EQU   CPUSTATS+268
@NM00062 EQU   CPUSTATS+232
@NM00061 EQU   CPUSTATS
@NM00060 EQU   CPUSADRC+3
RECID    EQU   CPUSADRC+1
HDRID    EQU   CPUSADRC
BUFFADDR EQU   BUFPREFX+4
@NM00059 EQU   BUFPREFX
RSVFLGS1 EQU   BUFFFLAG
DATRESV  EQU   PLISTMAP+5
@NM00057 EQU   DATATYPE
@NM00056 EQU   DATAAD
DATHIBYT EQU   DATADDR
REGSAVE  EQU   SAVEMAP+12
LOWSAVE  EQU   SAVEMAP+8
UNUSED   EQU   SAVEMAP
@NM00053 EQU   SGTBAD
CVTLEVL  EQU   CVTRELNO+2
CVTNUMB  EQU   CVTRELNO
CVTMDL   EQU   CVTFIX+250
@NM00049 EQU   CVTFIX+248
@NM00048 EQU   CVTFIX
CVTRV482 EQU   CVTXTNT2+128
CVTRV481 EQU   CVTXTNT2+124
CVTRV480 EQU   CVTXTNT2+120
CVTRV479 EQU   CVTXTNT2+118
CVTRV478 EQU   CVTXTNT2+117
CVTRV477 EQU   CVTXTNT2+116
CVTRV476 EQU   CVTXTNT2+115
CVTRV475 EQU   CVTXTNT2+114
CVTRV474 EQU   CVTRV466
CVTRV473 EQU   CVTRV466
CVTRV472 EQU   CVTRV466
CVTRV471 EQU   CVTRV466
CVTRV470 EQU   CVTRV466
CVTRV469 EQU   CVTRV466
CVTRV468 EQU   CVTRV466
CVTRV467 EQU   CVTRV466
CVTRV465 EQU   CVTRV457
CVTRV464 EQU   CVTRV457
CVTRV463 EQU   CVTRV457
CVTRV462 EQU   CVTRV457
CVTRV461 EQU   CVTRV457
CVTRV460 EQU   CVTRV457
CVTRV459 EQU   CVTRV457
CVTRV458 EQU   CVTRV457
CVTRV456 EQU   CVTXTNT2+108
CVTRV455 EQU   CVTXTNT2+104
CVTRV454 EQU   CVTXTNT2+100
CVTRV453 EQU   CVTXTNT2+96
CVTRV452 EQU   CVTXTNT2+94
CVTRV451 EQU   CVTXTNT2+92
CVTRV450 EQU   CVTXTNT2+90
CVTRV449 EQU   CVTXTNT2+88
CVTRV448 EQU   CVTXTNT2+87
CVTRV447 EQU   CVTXTNT2+86
CVTRV446 EQU   CVTRV438
CVTRV445 EQU   CVTRV438
CVTRV444 EQU   CVTRV438
CVTRV443 EQU   CVTRV438
CVTRV442 EQU   CVTRV438
CVTRV441 EQU   CVTRV438
CVTRV440 EQU   CVTRV438
CVTRV439 EQU   CVTRV438
CVTRV437 EQU   CVTRV429
CVTRV436 EQU   CVTRV429
CVTRV435 EQU   CVTRV429
CVTRV434 EQU   CVTRV429
CVTRV433 EQU   CVTRV429
CVTRV432 EQU   CVTRV429
CVTRV431 EQU   CVTRV429
CVTRV430 EQU   CVTRV429
CVTRV428 EQU   CVTXTNT2+80
CVTRV427 EQU   CVTXTNT2+76
CVTRV426 EQU   CVTXTNT2+72
CVTRV425 EQU   CVTXTNT2+68
CVTATACT EQU   CVTATCVT
CVTRV423 EQU   CVTXTNT2+62
CVTRV422 EQU   CVTXTNT2+60
CVTRV421 EQU   CVTXTNT2+58
CVTRV420 EQU   CVTXTNT2+56
CVTRV419 EQU   CVTXTNT2+55
CVTRV418 EQU   CVTXTNT2+54
CVTRV417 EQU   CVTRV409
CVTRV416 EQU   CVTRV409
CVTRV415 EQU   CVTRV409
CVTRV414 EQU   CVTRV409
CVTRV413 EQU   CVTRV409
CVTRV412 EQU   CVTRV409
CVTRV411 EQU   CVTRV409
CVTRV410 EQU   CVTRV409
CVTRV408 EQU   CVTRV400
CVTRV407 EQU   CVTRV400
CVTRV406 EQU   CVTRV400
CVTRV405 EQU   CVTRV400
CVTRV404 EQU   CVTRV400
CVTRV403 EQU   CVTRV400
CVTRV402 EQU   CVTRV400
CVTRV401 EQU   CVTRV400
CVTICB   EQU   CVTXTNT2+48
CVTSKTA  EQU   CVTXTNT2+44
CVTRSV99 EQU   CVTXTNT2+40
CVTRSV98 EQU   CVTXTNT2+36
CVTRSV97 EQU   CVTXTNT2+34
CVTRSV96 EQU   CVTXTNT2+32
CVTOLTEP EQU   CVTXTNT2+28
CVTQIDA  EQU   CVTQID+1
CVTRSV95 EQU   CVTQID
CVTRSV94 EQU   CVTXTNT2+20
CVTRSV93 EQU   CVTXTNT2+16
CVTRSV92 EQU   CVTXTNT2+12
CVTDEBVR EQU   CVTXTNT2+8
CVTRSV91 EQU   CVTXTNT2+6
CVTRSV9H EQU   CVTFLGBT
CVTRSV9G EQU   CVTFLGBT
CVTRSV9F EQU   CVTFLGBT
CVTRSV9E EQU   CVTFLGBT
CVTRSV9D EQU   CVTFLGBT
CVTRSV9C EQU   CVTFLGBT
CVTVME   EQU   CVTFLGBT
CVTNPE   EQU   CVTFLGBT
CVTNUCLS EQU   CVTXTNT2+4
CVTDSSVA EQU   CVTDSSV+1
CVTRSV89 EQU   CVTDSSV
CVTRSV88 EQU   CVTXTNT1+8
CVTRSV87 EQU   CVTXTNT1+4
CVTFACHN EQU   CVTXTNT1
CVTRV488 EQU   CVTMAP+412
CVTRV487 EQU   CVTMAP+408
CVTRV486 EQU   CVTMAP+404
CVTRV485 EQU   CVTMAP+400
CVTACTAP EQU   CVTMAP+396
CVTAUTH  EQU   CVTMAP+392
CVTATMCA EQU   CVTATMCT+1
CVTATMST EQU   CVTATMCT
CVTRSV61 EQU   CVTMAP+384
CVTVOLT1 EQU   CVTVOLM1+1
CVTVOLI1 EQU   CVTVOLF1
CVTSTOA  EQU   CVTMAP+376
CVTRSV58 EQU   CVTMAP+374
CVTRSV57 EQU   CVTMAP+372
CVTDDCE  EQU   CVTMAP+368
CVTPNWFR EQU   CVTMAP+364
CVTSMF   EQU   CVTMAP+360
CVTSULK  EQU   CVTMAP+358
CVTSLKO  EQU   CVTSYSK
CVTSLKP  EQU   CVTSYSK
CVTSLKQ  EQU   CVTSYSK
CVTSLKR  EQU   CVTSYSK
CVTRSV56 EQU   CVTSYSK
CVTRSV55 EQU   CVTSYSK
CVTRSV54 EQU   CVTSYSK
CVTRSV53 EQU   CVTSYSK
CVTRSV52 EQU   CVTA1F1
CVTRSV51 EQU   CVTA1F1
CVTRSV50 EQU   CVTA1F1
CVTRSV49 EQU   CVTA1F1
CVTRSV48 EQU   CVTA1F1
CVTRSV47 EQU   CVTA1F1
CVTSRSW  EQU   CVTA1F1
CVTPFSW  EQU   CVTA1F1
CVTPCVT  EQU   CVTMAP+352
CVTRSV46 EQU   CVTMAP+344
CVTRSV45 EQU   CVTMAP+340
CVTRSV44 EQU   CVTMAP+338
CVTRSV43 EQU   CVTMAP+336
CVTHJESA EQU   CVTHJES+1
CVTRSV42 EQU   CVTHJES
CVTEXT2A EQU   CVTEXT2+1
CVTRSV41 EQU   CVTEXT2
CVTAPFA  EQU   CVTAPF+1
CVTRSV40 EQU   CVTAPF
CVTRV518 EQU   CVTINTLA
CVTRV517 EQU   CVTERPV
CVTEORM  EQU   CVTMAP+312
CVTMCHPR EQU   CVTMAP+308
CVTTZ    EQU   CVTMAP+304
CVTJEPS  EQU   CVTMAP+300
CVTJESCT EQU   CVTMAP+296
CVTMODE  EQU   CVTMAP+292
CVTPTRV  EQU   CVTMAP+288
CVTREAL  EQU   CVTMAP+284
CVTRSV39 EQU   CVTMAP+280
CVTRSV38 EQU   CVTMAP+276
CVTDMSRA EQU   CVTDMSR+1
CVTRSV37 EQU   CVTDMSR
CVTQMSGA EQU   CVTQMSG+1
CVTRSV36 EQU   CVTQMSG
CVTAMFF  EQU   CVTMAP+264
CVTPURGA EQU   CVTPURG+1
CVTRSV35 EQU   CVTPURG
CVTCBSP  EQU   CVTMAP+256
CVTATERA EQU   CVTATER+1
CVTSYST  EQU   CVTATER
CVTVOLT2 EQU   CVTTAT
CVTVOLI2 EQU   CVTVOLF2
CVTAQAVB EQU   CVTAQAVT+1
CVTRSV34 EQU   CVTTCMFG
CVTRSV33 EQU   CVTTCMFG
CVTRSV32 EQU   CVTTCMFG
CVTRSV31 EQU   CVTTCMFG
CVTRSV30 EQU   CVTTCMFG
CVTRSV29 EQU   CVTTCMFG
CVTRSV28 EQU   CVTTCMFG
CVTTCRDY EQU   CVTTCMFG
CVTGTFA  EQU   CVTGTF+1
CVTRSV27 EQU   CVTGTFST
CVTRNIO  EQU   CVTGTFST
CVTUSR   EQU   CVTGTFST
CVTRV318 EQU   CVTFORM
CVTRV317 EQU   CVTTMODE
CVTRV316 EQU   CVTSTATE
CVTRV315 EQU   CVTGTFS
CVTGTFAV EQU   CVTGTFS
CVT0SCR1 EQU   CVTMAP+232
CVTRV515 EQU   CVTMAP+228
CVTRMS   EQU   CVTMAP+224
CVTPATCH EQU   CVTMAP+220
CVTTSCE  EQU   CVTMAP+216
CVTLNKSC EQU   CVTMAP+214
CVTQABST EQU   CVTMAP+212
CVTMDLDS EQU   CVTMAP+208
CVTUSER  EQU   CVTMAP+204
CVTABEND EQU   CVTMAP+200
CVTSMCA  EQU   CVTMAP+196
CVTRSV18 EQU   CVTMAP+192
CVTQLPAQ EQU   CVTMAP+188
CVTQCDSR EQU   CVTMAP+184
CVTRSV17 EQU   CVTOPTB
CVTRSV16 EQU   CVTOPTB
CVTFP    EQU   CVTOPTB
CVTAPTHR EQU   CVTOPTB
CVTNLOG  EQU   CVTOPTB
CVTTOD   EQU   CVTOPTB
CVTCTIMS EQU   CVTOPTB
CVTPROT  EQU   CVTOPTB
CVTXPFP  EQU   CVTOPTA
CVTASCII EQU   CVTOPTA
CVTRSV13 EQU   CVTOPTA
CVTRSV12 EQU   CVTOPTA
CVTNIP   EQU   CVTOPTA
CVTDDR   EQU   CVTOPTA
CVTAPR   EQU   CVTOPTA
CVTCCH   EQU   CVTOPTA
CVTSNCTR EQU   CVTMAP+180
CVTQMWR  EQU   CVTMAP+176
CVTQOCR  EQU   CVTMAP+172
CVT1EF00 EQU   CVTMAP+168
CVTMZ00  EQU   CVTMAP+164
CVTHEAD  EQU   CVTMAP+160
CVTRSV11 EQU   CVTMAP+156
CVT0PT01 EQU   CVTMAP+152
CVTMSER  EQU   CVTMAP+148
CVTRV516 EQU   CVTIERLC
CVTILCH  EQU   CVTMAP+140
CVT0DS   EQU   CVTMAP+136
CVTFBOSV EQU   CVTMAP+132
CVTNUCB  EQU   CVTMAP+128
CVTIXAVL EQU   CVTMAP+124
CVTIOQET EQU   CVTMAP+120
CVTDCBA  EQU   CVTMAP+117
CVTMVS2  EQU   CVTDCB
CVT6DAT  EQU   CVTDCB
CVT4MPS  EQU   CVTDCB
CVTRSV09 EQU   CVTDCB
CVT4MS1  EQU   CVTDCB
CVT2SPS  EQU   CVTDCB
CVT1SSS  EQU   CVTDCB
CVTRSV08 EQU   CVTDCB
CVTSTB   EQU   CVTMAP+112
CVTQTD00 EQU   CVTMAP+108
CVTQTE00 EQU   CVTMAP+104
CVTCUCB  EQU   CVTMAP+100
CVTSJQ   EQU   CVTMAP+96
CVTPBLDL EQU   CVTMAP+92
CVTTPC   EQU   CVTMAP+88
CVTSVDCB EQU   CVTMAP+84
CVTBRET  EQU   CVTMAP+82
CVTEXIT  EQU   CVTMAP+80
CVT0FN00 EQU   CVTMAP+76
CVTDARA  EQU   CVTDAR+1
CVTRSV07 EQU   CVTFLGS1
CVTRSV06 EQU   CVTFLGS1
CVTRSV05 EQU   CVTFLGS1
CVTRSV04 EQU   CVTFLGS1
CVTRSV03 EQU   CVTFLGS1
CVTRSV02 EQU   CVTFLGS1
CVTRSV01 EQU   CVTFLGS1
CVTDMPLK EQU   CVTFLGS1
CVTXITP  EQU   CVTMAP+68
CVTZDTAB EQU   CVTMAP+64
CVTMSLT  EQU   CVTMAP+60
CVTDATE  EQU   CVTMAP+56
CVTBTERM EQU   CVTMAP+52
CVTSYSAD EQU   CVTMAP+48
CVTXTLER EQU   CVTMAP+44
CVTILK2  EQU   CVTMAP+40
CVTILK1  EQU   CVTMAP+36
CVTPRLTV EQU   CVTMAP+32
CVTPCNVT EQU   CVTMAP+28
CVT0VL00 EQU   CVTMAP+24
CVTXAPG  EQU   CVTMAP+20
CVTBUF   EQU   CVTMAP+16
CVTJOB   EQU   CVTMAP+12
CVTLINK  EQU   CVTMAP+8
CVT0EF00 EQU   CVTMAP+4
CVTTCBP  EQU   CVTMAP
CVT      EQU   CVTMAP
ASCBEND  EQU   ASCB+208
ASCBSRBT EQU   ASCB+200
ASCBSWTL EQU   ASCB+196
ASCBRS14 EQU   ASCB+195
ASCBSMCT EQU   ASCB+194
ASCBRS12 EQU   ASCB+192
ASCBPCTT EQU   ASCB+188
ASCBVGTT EQU   ASCB+184
ASCBLGCB EQU   ASCB+180
ASCBJBNS EQU   ASCB+176
ASCBJBNI EQU   ASCB+172
ASCBMCC  EQU   ASCB+168
ASCBRTWA EQU   ASCB+164
ASCBIQEA EQU   ASCB+160
ASCBXMPQ EQU   ASCB+156
ASCBRS01 EQU   ASCB+154
ASCBFMCT EQU   ASCB+152
ASCBOUXB EQU   ASCB+148
ASCBOUCB EQU   ASCB+144
ASCBMECB EQU   ASCB+140
ASCBQECB EQU   ASCB+136
ASCBCMSB EQU   ASCB+132
ASCBCMSF EQU   ASCB+128
ASCBTCBS EQU   ASCB+124
ASCBNVSC EQU   ASCB+122
ASCBVSC  EQU   ASCB+120
ASCBSRBS EQU   ASCB+118
ASCBSSRB EQU   ASCB+116
ASCBRV06 EQU   ASCBFLG2
ASCBRV05 EQU   ASCBFLG2
ASCBRV04 EQU   ASCBFLG2
ASCBSNQS EQU   ASCBFLG2
ASCBS2S  EQU   ASCBFLG2
ASCBCEXT EQU   ASCBFLG2
ASCBPXMT EQU   ASCBFLG2
ASCBXMPT EQU   ASCBFLG2
ASCBRF07 EQU   ASCBDSP1
ASCBRF06 EQU   ASCBDSP1
ASCBRF05 EQU   ASCBDSP1
ASCBRF04 EQU   ASCBDSP1
ASCBRF03 EQU   ASCBDSP1
ASCBRF02 EQU   ASCBDSP1
ASCBFAIL EQU   ASCBDSP1
ASCBNOQ  EQU   ASCBDSP1
ASCBSWCT EQU   ASCB+112
ASCBASXB EQU   ASCB+108
ASCBTMCH EQU   ASCB+104
ASCBNSWP EQU   ASCBFLG1
ASCBTYP1 EQU   ASCBFLG1
ASCBSTND EQU   ASCBFLG1
ASCBABNT EQU   ASCBFLG1
ASCBTERM EQU   ASCBFLG1
ASCBS3S  EQU   ASCBFLG1
ASCBCMSH EQU   ASCBFLG1
ASCBTOFF EQU   ASCBFLG1
ASCBRF01 EQU   ASCBRCTF
ASCBTMLW EQU   ASCBRCTF
ASCBOUT  EQU   ASCBRCTF
ASCBWAIT EQU   ASCBRCTF
ASCBRV08 EQU   ASCBRCTF
ASCBFQU  EQU   ASCBRCTF
ASCBFRS  EQU   ASCBRCTF
ASCBTMNO EQU   ASCBRCTF
ASCBAFFN EQU   ASCBFW1
ASCBDUMP EQU   ASCB+96
ASCBQSVC EQU   ASCB+92
ASCBUBET EQU   ASCB+88
ASCBECB  EQU   ASCB+84
ASCBJSTL EQU   ASCB+80
ASCBEWST EQU   ASCB+72
ASCBEJST EQU   ASCB+64
ASCBTSB  EQU   ASCB+60
ASCBCSCB EQU   ASCB+56
ASCBRSM  EQU   ASCB+52
ASCBLDA  EQU   ASCB+48
ASCBDP   EQU   ASCB+43
ASCBRV07 EQU   ASCB+42
ASCBIOSM EQU   ASCB+40
ASCBSEQN EQU   ASCB+38
ASCBCPUS EQU   ASCB+32
ASCBSPL  EQU   ASCB+28
ASCBLSLQ EQU   ASCB+24
ASCBFSLQ EQU   ASCB+20
ASCBIOSP EQU   ASCB+16
ASCBLOCK EQU   ASCB+12
ASCBASCB EQU   ASCB
ASCBEGIN EQU   ASCB
@NM00047 EQU   COMMON+2070
TOPICHDR EQU   COMMON+2060
DFLTCSA  EQU   COMMON+2056
LPAMAX   EQU   COMMON+2052
DNUCTOP  EQU   COMMON+2048
XLMAX    EQU   COMMON+2044
DQEMAX   EQU   COMMON+2042
TCBMAX   EQU   COMMON+2038
SRBMAX   EQU   COMMON+2036
DDMAX    EQU   COMMON+2034
DEBMAX   EQU   COMMON+2032
JPQMAX   EQU   COMMON+2030
LLEMAX   EQU   COMMON+2028
PQEMAX   EQU   COMMON+2026
RBMAX    EQU   COMMON+2024
@NM00046 EQU   COMMON+2023
EXITFLAG EQU   COMMON+2022
AUSRASID EQU   COMMON+2020
AUSRTCBA EQU   COMMON+2016
AUSRDEL  EQU   COMMON+2012
AUSREXIT EQU   COMMON+2008
AUSRINIT EQU   COMMON+2004
ASRBFMT  EQU   COMMON+2000
AASCBFMT EQU   COMMON+1996
BRRDADJ  EQU   COMMON+1992
BRRDINIT EQU   COMMON+1988
CPUMAP   EQU   COMMON+1972
ASIDNDX  EQU   COMMON+1968
@NM00045 EQU   COMMON+1964
HDRTITLE EQU   COMMON+1864
SACSWCAW EQU   COMMON+1684
ASVTADDR EQU   COMMON+1680
CURASCB  EQU   COMMON+1668
@NM00044 EQU   COMMON+1656
@NM00043 EQU   COMMON+1641
EDITER   EQU   COMMON+1640
AROOT    EQU   COMMON+1636
AEDITCB  EQU   COMMON+1632
TRCCOUNT EQU   COMMON+1628
ASYSUDCB EQU   @NM00041+1
ENDLIST  EQU   @NM00042
AINDCB   EQU   DCBADDRS+12
ARDRDCB  EQU   DCBADDRS+8
APTRDCB  EQU   DCBADDRS+4
AOUTDCB  EQU   DCBADDRS
ATCBSMRY EQU   COMMON+1604
ATCBSMFR EQU   COMMON+1600
ONGOPTR  EQU   COMMON+1596
AEND     EQU   COMMON+1592
AERRMSGA EQU   COMMON+1584
APRTSTG  EQU   COMMON+1572
AFORMAT  EQU   COMMON+1568
ASTPROUT EQU   COMMON+1564
APCBENQ  EQU   COMMON+1560
ATCBRTRV EQU   COMMON+1556
ATCBREMV EQU   COMMON+1552
ATCBSAVE EQU   COMMON+1548
QATMERTN EQU   COMMON+1544
ALOADER  EQU   COMMON+1540
SYNMSGA  EQU   COMMON+1532
STOPEXIT EQU   COMMON+1528
ARGNBND  EQU   COMMON+1524
AWRDCNVT EQU   COMMON+1520
AADRCNVT EQU   COMMON+1516
AFMTLINE EQU   COMMON+1512
ASYNTAX  EQU   COMMON+1508
AWRITE   EQU   COMMON+1500
NONBLNK  EQU   COMMON+1244
BLNK     EQU   COMMON+988
@NM00040 EQU   COMMON+972
@NM00039 EQU   COMMON+915
EBCTABL  EQU   HEXTABL+10
@NM00038 EQU   HEXTABL
@NM00037 EQU   TABLE
CAPTABL  EQU   COMMON+403
TITLEPGE EQU   COMMON+394
@NM00036 EQU   COMMON+392
TITLETME EQU   COMMON+379
@NM00035 EQU   COMMON+377
TITLEDTE EQU   COMMON+364
@NM00034 EQU   COMMON+362
TITLEMOD EQU   COMMON+347
TITLEMSG EQU   COMMON+283
MSG2     EQU   COMMON+257
MSG1     EQU   COMMON+231
STOP     EQU   COMMON+227
TITLE    EQU   COMMON+222
BLANKS   EQU   COMMON+214
WTORMSG  EQU   COMMON+133
@NM00033 EQU   COMMON+130
@NM00032 EQU   PRSW
@NM00031 EQU   PRSW
PRNTRL   EQU   PRSW
TTLSW    EQU   PRSW
@NM00030 EQU   PRSW
QSEGTBSW EQU   PRSW
@NM00029 EQU   PRSW
@NM00028 EQU   BUFSW
PREFM    EQU   BUFSW
@NM00027 EQU   BUFSW
@NM00026 EQU   BUFSW
@NM00025 EQU   BUFSW
@NM00024 EQU   BUFSW
@NM00023 EQU   BUFSW
@NM00022 EQU   BUFSW
@NM00021 EQU   SWF
QUT1LOD  EQU   SWF
@NM00020 EQU   SWF
PAGEOK   EQU   SWF
NUCTFRMC EQU   SWF
QPRDINIT EQU   SWF
@NM00019 EQU   SWE
@NM00018 EQU   SWE
@NM00017 EQU   SWE
TITLESW  EQU   SWE
RESPC    EQU   SWE
@NM00016 EQU   SWE
STOPSW   EQU   SWE
@NM00015 EQU   SWD
GPRSFND  EQU   SWD
CONTSW   EQU   SWD
NOLOADSW EQU   SWD
NOSTDMG  EQU   SWD
@NM00014 EQU   SWD
@NM00013 EQU   SWD
@NM00012 EQU   SWC
@NM00011 EQU   SWC
SEGRD    EQU   SWC
EDITSW   EQU   SWC
SETFLSH  EQU   SWC
@NM00010 EQU   SWB
@NM00009 EQU   SWB
ENDSW    EQU   SWB
@NM00008 EQU   SWB
@NM00007 EQU   SWB
IOERR    EQU   SWB
SETCVTSW EQU   SWA
@NM00006 EQU   SWA
GOSW     EQU   SWA
@NM00005 EQU   SWA
@NM00004 EQU   SWA
@NM00003 EQU   SWA
@NM00002 EQU   SWA
LINENUM  EQU   COMMON+120
LINENUMB EQU   COMMON+118
SIXTEEN  EQU   COMMON+116
TWELVE   EQU   COMMON+114
ELEVEN   EQU   COMMON+112
HTEN     EQU   COMMON+110
EIGHT    EQU   COMMON+108
SEVEN    EQU   COMMON+106
FIVE     EQU   COMMON+104
FOUR     EQU   COMMON+102
THREE    EQU   COMMON+100
TWO      EQU   COMMON+98
ONEA     EQU   COMMON+96
RDERCNT  EQU   COMMON+88
READNO   EQU   COMMON+84
@NM00001 EQU   COMMON+79
RETCODE  EQU   COMMON+78
FILESEQ  EQU   COMMON+76
STORSIZE EQU   COMMON+64
PCBPTR   EQU   COMMON+60
TCBLIST  EQU   COMMON+52
CURBUF   EQU   COMMON+48
PAGENUMB EQU   COMMON+44
LINECNT  EQU   COMMON+40
SIX      EQU   COMMON+36
DELIMCD  EQU   COMMON+20
KYWDEND  EQU   COMMON+16
KYWDBGN  EQU   COMMON+12
VERBEND  EQU   COMMON+8
VERBGN   EQU   COMMON+4
.@UNREFD ANOP                          END UNREFERENCED COMPONENTS
@RT00117 EQU   AMD254
@RT00119 EQU   AMD254
@RT00131 EQU   CHECKBUF
@RF00163 EQU   FREESAVE
TERMINIT EQU   @EL00001
@RT00181 EQU   FREEXIT
@RT00188 EQU   FREEXIT
@RT00214 EQU   CPUREQST
@RT00216 EQU   REALREQ
@RT00233 EQU   TESTDATA
@RT00239 EQU   CHEKSWAP
@RT00243 EQU   OFFSETSV
@RT00245 EQU   FORMERR
@RF00249 EQU   CHEKSEG
@RT00256 EQU   FORMERR
@RC00260 EQU   READVIRT
@RF00263 EQU   READVIRT
@RT00268 EQU   CHEKSEG
@RT00296 EQU   READVIRT
@RT00300 EQU   REALONLY
@RT00304 EQU   FORMERR
@RT00306 EQU   FORMERR
@RT00322 EQU   FORMERR
@RT00326 EQU   TESTDATA
@RT00343 EQU   FORMERR
@RT00354 EQU   FORMERR
@RT00359 EQU   FORMERR
@RT00460 EQU   @EL00004
@RT00516 EQU   ASCBTRM0
ASERCD10 EQU   ASCBTRM0
@RT00567 EQU   @EL00005
@RF00594 EQU   @EL00005
@RT00607 EQU   INBUF2
@RF00607 EQU   NXTBUFFR
@RT00631 EQU   INBUF2
@RF00631 EQU   NXTBUFFR
@RF00617 EQU   INBUF2
@RT00642 EQU   COMPCPU
@RF00642 EQU   COMPAD
COMPXIT  EQU   @EL00006
@RT00699 EQU   DATINVLD
@RT00708 EQU   DATINVLD
@RT00713 EQU   DATINVLD
@RT00716 EQU   DATINVLD
@RT00727 EQU   DATINVLD
@RT00732 EQU   DATINVLD
@RT00742 EQU   DATINVLD
@RT00754 EQU   DATINVLD
@RT00759 EQU   DATINVLD
@RT00763 EQU   DATINVLD
@RT00766 EQU   DATINVLD
@RT00776 EQU   DATINVLD
@RT00781 EQU   DATINVLD
@RT00784 EQU   DATINVLD
@RT00100 EQU   TERMINIT
@ENDDATA EQU   *
         END   AMDPRRDC,(C'PLS0025',0701,76317)
