         TITLE 'ICAPRTBL'
         REPRO

         REPRO

         REPRO
†1jX0b†1jN0b†\0YÔ¢1¸Ë0d‡½0®†ç0Y„„0ðƒ 
         LCLA  &T,&SPN                                            0002
.@001    ANOP                                                     0002
ICAPRTBL CSECT ,                                                  0002
*
*A510100,510800,521300                                         @ZA10903
*C510300                                                       @ZA10903
* THE LOADER HAS BEEN PLACED IN FRONT OF THE PROCEDURE         @ZA13772
*
* THE FOLLOWING IS USED TO INITIALIZE THE PERMANENT STORAGE
* REQUIREMENTS OF THE SYSTEM
*
* REGISTER USAGE
*
ZEROR    EQU   0                       NULL REGISTER
*
*
         USING SNSBYTS,ZEROR,BASER     ESTABLISH ADDRESSABILITY
SNSBYTS  DC    XL8'0'                  DEVICE SENSE FOR DISPLAY
         ORG   *+16                    INITIAL PROGRAM LOADING CCWS
EXTOPSW  DS    8C                      EXTERNAL OLD PSW
SVCOPSW  DS    8C                      SUPERVISOR CALL OLD PSW
PGMOPSW  DS    8C                      PROGRAM OLD PSW
MCOPSW   DS    8C                      MACHINE CHECK OLD PSW
IOOPSW   DS    8C                      INPUT/OUTPUT OLD PSW
CSW      DS    8C                      CHANNEL STATUS WORD
CAW      DS    4C                      CHANNEL ADDRESS WORD
TIMER    DC    X'0000000000FFFF0000000000' INITIAL TIMER VALUE
EXTNPSW  DC    XL5'0'                  EXTERNAL NEW PSW
         DC    AL3(INIT300)
SVCNPSW  DC    XL5'0'                  SUPERVISOR CALL NEW PSW
         DC    AL3(INIT400)
PGMNPSW  DC    XL5'0'                  PROGRAM NEW PSW
         DC    AL3(INIT500)
MCNPSW   DC    XL5'0'                  MACHINE CHECK NEW PSW
         DC    AL3(INIT600)
IONPSW   DC    XL5'0'                  INPUT/OUTPUT NEW PSW
         DC    AL3(INIT700)
SCANOUT  DS    CL332                   DIAGNOSTIC SCAN-OUT AREA
         DS    0H
@EL01    BCR   15,@E                                              0016
INIT     EQU   *                                                  0016
*     GENERATE(L     BASER,SYSBAS);     /* INITIALIZE SECOND BASE REG *
         L     BASER,SYSBAS
         DS    0H
*     SAVER = ADDR(INITSAVE);           /* INITIALIZE REG SAVE ADDR   *
         LA    @D,INITSAVE                                        0023
* INIT100: GENERATE(LPSW  UTPSW);       /* LOAD UTILITY PSW           *
INIT100  LPSW  UTPSW
         DS    0H
* INIT200: RDRADDR = RDRR;              /* SAVE INPUT DEVICE ADDRESS  *
INIT200  ST    @B,RDRADDR                                         0025
*     CALL INPUT;                       /* READ IN CONTROL STATEMENTS *
         BAL   @E,INPUT                                           0026
* /*                                                                  *
* /* ENTRY POINT FOR EXTERNAL INTERRUPTS                              *
* /*                                                                  *
* INIT300: ERRCODE = CB0A;              /* SET EXTERNAL INT ERROR CODE*
INIT300  MVC   ERRCODE(3),CB0A                                    0027
*     CALL WAIT;                        /* DISPLAY CODE AND WAIT      *
         BAL   @E,WAIT                                            0028
* /*                                                                  *
* /* ENTRY POINT FOR SUPERVISOR CALL INTERRUPTS                       *
* /*                                                                  *
* INIT400: GENERATE(LPSW  SVCOPSW);     /* IGNORE SVC INTERRUPTIONS   *
INIT400  LPSW  SVCOPSW
         DS    0H
* /*                                                                  *
* /* ENTRY POINT FOR PROGRAM CHECK INTERRUPTIONS                      *
* /*                                                                  *
* INIT500: ERRCODE = CB0B;              /* SET PGM CHECK ERROR CODE   *
INIT500  MVC   ERRCODE(3),CB0B                                    0030
*     CALL WAIT;                        /* DISPLAY CODE AND WAIT      *
         BAL   @E,WAIT                                            0031
* /*                                                                  *
* /* ENTRY POINT FOR MACHINE CHECK INTERRUPTIONS                      *
* /*                                                                  *
* INIT600: ERRCODE = CB0B;              /* SET MCH CHECK ERROR CODE   *
INIT600  MVC   ERRCODE(3),CB0B                                    0032
*     GENERATE(B     IO900);            /* PREPARE FOR SEREP          *
         B     IO900
         DS    0H
* /*                                                                  *
* /* ENTRY POINT FOR INPUT/OUTPUT INTERRUPTIONS                       *
* /*                                                                  *
* INIT700: GENERATE(LPSW  IOOPSW);      /* IGNORE I/O INTERRUPTIONS   *
INIT700  LPSW  IOOPSW
         DS    0H
*     GENERATE;
         DS    0F
SYSBAS   DC    X'00001000'             SECOND BASE REGISTER VALUE
         DS    0H
* END INIT;                             /*                            *
@EL02    BCR   15,@E                                              0036
* INPUT:                                /* READ INPUT ROUTINE         *
*     PROCEDURE;
INPUT    STM   @E,@C,12(@D)                                       0037
         ST    @D,@SAV003+4                                       0037
         LA    @F,@SAV003                                         0037
         ST    @F,8(0,@D)                                         0037
         LR    @D,@F                                              0037
* /********************************************************************
* /*                                                                  *
* /*                                                                  *
* /* NAME                                                             *
* /*         INPUT                                                    *
* /*                                                                  *
* /* FUNCTION                                                         *
* /*    THIS ROUTINE IS USED TO READ AND ANALYZE THE JOB CONTROL      *
* /*    CARDS.                                                        *
* /*                                                                  *
* /* ENTRY POINTS                                                     *
* /*    INPUT- THIS POINT IS GIVEN CONTROL BY THE INIT ROUTINE.       *
* /*                                                                  *
* /* INPUT                                                            *
* /*    INPUT TO THIS ROUTINE IS A SET OF USER WRITTEN JOB CONTROL    *
* /*    CARDS.                                                        *
* /*                                                                  *
* /* OUTPUT                                                           *
* /*    NONE                                                          *
* /*                                                                  *
* /* EXTERNAL ROUTINES                                                *
* /*    IO                                                            *
* /*                                                                  *
* /* EXITS, NORMAL                                                    *
* /*    THE CNTRL ROUTINE IS CALLED AFTER ALL CARDS ARE READ IN.      *
* /*                                                                  *
* /* EXITS, ERROR                                                     *
* /*    THE WAIT ROUTINE IS CALLED IF AN ERROR IN THE CONTROL CARDS   *
* /*    IS DETECTED.                                                  *
* /*                                                                  *
* /* TABLE/WORK AREAS                                                 *
* /*    ERB02                                                         *
* /*    ERB03                                                         *
* /*    ERB04                                                         *
* /*    ERB05                                                         *
* /*    ERB06                                                         *
* /*    ERB07                                                         *
* /*    UCSLOAD                                                       *
* /*    PTRADDR                                                       *
* /*    UCSNMST                                                       *
* /*    FCBNMST                                                       *
* /*    ERRCODE                                                       *
* /*    FCBIMG                                                        *
* /*                                                                  *
* /********************************************************************
*     DECLARE
*          /* THE FOLLOWING ARE SUBROUTINES OF INPUT                  *
*          INTRP INTERNAL ENTRY,        /* INTERPRET DATA ROUTINE     *
*          GET INTERNAL ENTRY,          /* READ A CARD ROUTINE        *
*          SEARCH INTERNAL ENTRY,       /* FIND FIRST BLANK ROUTINE   *
*          SEEK INTERNAL ENTRY;         /* FIND FIRST NONBLANK ROUTINE*
*     DECLARE
*          /* IF A FLAG BIT IS ON THAT STATEMENT HAS BEEN READ IN     *
*          1 FLAG BIT(8),               /* CONTROL CARD FLAG BITS     *
*               2 JOBFLAG BIT(1),       /*    JOB STATEMENT           *
*               2 UCSFLAG BIT(1),       /*    UCS STATEMENT           *
*               2 FCBFLAG BIT(1),       /*    FCB STATEMENT           *
*               2 DFNFLAG BIT(1),       /*    DFN STATEMENT           *
*               2 ENDFLAG BIT(1);       /*    END STATEMENT           *
*     DECLARE
*          /* IF A FLAG BIT IS ON THAT DFN PARAMETER HAS BEEN READ    *
*          1 FLAGDFN BIT(8),            /* DFN STATEMENT FLAG BITS    *
*               2 ADDRFLAG BIT(1),      /*    ADDR PARAMETER          *
*               2 FOLDFLAG BIT(1);      /*    FOLD PARAMETER          *
*     DECLARE
*          /* IF A FLAG BIT IS ON THAT FCB PARAMETER HAS BEEN READ    *
*          1 FLAGFCB BIT(8),            /* FCB STATEMENT FLAG BITS    *
*               2 LPIFLAG BIT(1),       /*    LPI PARAMETER           *
*               2 FEFLAG BIT(1),        /*    FE PARAMETER            *
*               2 LNCHFLAG BIT(1);      /*    LNCH PARAMETER          *
*     DECLARE
*          /* THE FOLLOWING CHARACTERS ARE USED TO ANALYZE THE JOB    *
*          /* CONTROL STATEMENTS                                      *
*          CJOB CHAR(3) INIT('JOB'),    /* JOB STATEMENT HEADER       *
*          CDFN CHAR(3) INIT('DFN'),    /* DFN STATEMENT HEADER       *
*          CUCS CHAR(3) INIT('UCS'),    /* UCS STATEMENT HEADER       *
*          CFCB CHAR(3) INIT('FCB'),    /* FCB STATEMENT HEADER       *
*          CEND CHAR(3) INIT('END'),    /* END STATEMENT HEADER       *
*          CADDR CHAR(4) INIT('ADDR'),  /* DFN STATEMENT PARAMETER    *
*          CFOLD CHAR(4) INIT('FOLD'),  /* DFN STATEMENT PARAMETER    *
*          CY CHAR(1) INIT('Y'),        /* FOLD PARAMETER OPTION      *
*          CN CHAR(1) INIT('N'),        /* FOLD PARAMETER OPTION      *
*          CFORMEND CHAR(7) INIT('FORMEND'), /* FCB STATEMENT PARM    *
*          CLNCH CHAR(4) INIT('LNCH'),  /* FCB STATEMENT PARAMETER    *
*          CLPI CHAR(3) INIT('LPI'),    /* FCB STATEMENT PARAMETER    *
*          C6 CHAR(1) INIT('6'),        /* LPI PARAMETER OPTION       *
*          C8 CHAR(1) INIT('8'),        /* LPI PARAMETER OPTION       *
*          BLANK CHAR(1) INIT('40'X),   /* PARAMETER END CODE         *
*          COMMA CHAR(1) INIT(','),     /* PARAMETER DELIMETER        *
*          RPAREN CHAR(1) INIT(')'),    /* END OF OPTION              *
*          LPAREN CHAR(1) INIT('(');    /* START OF OPTION            *
*     DECLARE
*          UCSSEQ BIT(8);               /* UCS STATEMENT SEQUENCE NO  *
*     DECLARE
*          MVLNTH BIT(8);               /* MOVE-LENGTH OF FCB PARMS   *
*     DECLARE
*          FCBSAVE POINTER(31),         /* ADDRESS OF FIRST FCB PARM  *
*          JCLSTRT BASED(FCBSAVE);      /*    ADDRESSED BY JCLSTRT    *
*     DECLARE
*          FCBJCL CHAR(300);            /* FCB PARAMETER SAVE AREA    *
*     DECLARE
*          LPI8 BIT(8) INIT('10'X);     /* FLAG BIT FOR 8 LPI         *
*     DECLARE
*          CNT FIXED(15);               /* LIMIT OF CHECKING COLUMNS  *
*     DECLARE
*          INAREA CHAR(80);             /* CARD INPUT AREA            *
*     DECLARE
*          CLRBYTE BIT(8) INIT('00'X);  /* NULL BYTE FOR CLEARING     *
*     DECLARE
*          NUM CHAR(16) INIT('0123456789ABCDEF'); /* VALID CHARACTERS *
*                                                 /* FOR PRINTER ADDR *
*     DECLARE
*          ENDBIT BIT(8) INIT('10'X);   /* FLAG BIT FOR END-OF-FORM   *
*     DECLARE
*          LNNO FIXED(31);              /* FCB LINE NUMBER            *
*     DECLARE
*          CHNO CHAR(4);                /* FCB CHANNEL NUMBER         *
*     DECLARE
*          TABLE CHAR(10) INIT('0123456789'); /* VALID CHARACTERS FOR *
*                                             /* FCB LINE AND CHANNEL *
*                                             /* NUMBERS              *
*     DECLARE
*          DBWD CHAR(8) INIT('0000000000000000'X) BDY(DWORD);
*          /* CONVERSION AREA FOR THE SUBROUTINE INTRP                *
*     DECLARE
*          FWORD CHAR(4) BDY(WORD);     /* CONVERSION AREA FOR THE    *
*                                       /* SUBROUTINE INTRP           *
*     DECLARE
*          CR REGISTER(2) POINTER(31),  /* POINTER TO INPUT AREA      *
*          COL BASED(CR) CHAR(7);       /*    ADDRESSED BY COL        *
*     DECLARE
*          PR REGISTER(3) POINTER(31),  /* POINTER TO UCS AND FCB     *
*          IMAGE BASED(PR) CHAR(56);    /*    ADDRESSED BY IMAGE      *
*     DECLARE
*          WR REGISTER(4) POINTER(31),  /* WORK REGISTER FOR INTRP    *
*          DTST BASED(WR);              /* ADDRESSED BY DTST          *
*     DECLARE
*          I FIXED(31);                 /* LENGTH OF LOOP ONE         *
*     DECLARE
*          J FIXED(31);                 /* LENGTH OF LOOP TWO         *
*     DECLARE
*          LENGTH FIXED(31);            /* DATA LENGTH FOR INTRP      *
*     RESTRICT (12,                     /* GPR12 USED AS THE BASE     *
*               CR,                     /* POINTER TO INAREA          *
*               PR);                    /* POINTER TO IMAGE           *
* /*                                                                  *
* /* THE FOLLOWING IS USED TO GET A CARD, DETERMINE WHICH STATEMENT   *
* /* IT IS, AND PASS CONTROL TO THE CORRESPONDING ROUTINE             *
* /*                                                                  *
*     FLAG = FLAG & CLRBYTE;            /* CLEAR FLAG BYTE            *
         NC    FLAG(1),CLRBYTE                                    0065
* INPUT010: CALL GET;                   /* READ A CARD INTO INAREA    *
INPUT010 BAL   @E,GET                                             0066
*     CR = ADDR(INAREA);                /* SET UP POINTER TO INPUT    *
         LA    @2,INAREA                                          0067
*     CALL SEARCH;                      /* FIND FIRST BLANK           *
         BAL   @E,SEARCH                                          0068
*     CALL SEEK;                        /* FIND FIRST NON-BLANK       *
         BAL   @E,SEEK                                            0069
* /* IF THIS CARD IS THE JOB STATEMENT BRANCH TO THE JOB CARD ROUTINE *
*     IF COL(1:3) = CJOB                /* IF THE OPERATION FIELD IS  *
*          THEN GO TO INPUT100;         /*    JOB GO TO INPUT100      *
         CLC   0(3,@2),CJOB                                       0070
         BC    08,INPUT100                                        0071
* /* IF THE JOB STATEMENT HAS NOT BEEN READ CANCEL THE UTILITY        *
*     IF JOBFLAG = '0'B                 /* IS THE JOB STATEMENT BIT ON*
*          THEN                         /* YES - THE JOB CARD WAS READ*
         TM    FLAG,B'10000000'                                   0072
         BC    05,@9FF                                            0072
*               DO;                     /* CANCEL THE UTILITY         *
*                    ERRCODE = CB03;    /* INCORRECT JOB STATEMENT    *
         MVC   ERRCODE(3),CB03                                    0074
*                    CALL WAIT;         /* TERMINATE THE UTILITY      *
         BAL   @E,WAIT                                            0075
*               END;                    /*                            *
* /* IF THIS CARD IS THE DFN STATEMENT BRANCH TO THE DFN CARD ROUTINE *
*     IF COL(1:3) = CDFN                /* IF THE OPERATION FIELD IS  *
*          THEN GO TO INPUT200;         /*    DFN GO TO INPUT200      *
@9FF     CLC   0(3,@2),CDFN                                       0077
         BC    08,INPUT200                                        0078
* /* IF THIS CARD IS THE UCS STATEMENT BRANCH TO THE UCS CARD ROUTINE *
*     IF COL(1:3) = CUCS                /* IF THE OPERATION FIELD IS  *
*          THEN GO TO INPUT400;         /*    UCS GO TO INPUT400      *
         CLC   0(3,@2),CUCS                                       0079
         BC    08,INPUT400                                        0080
* /* IF THIS CARD IS THE FCB STATEMENT BRANCH TO THE FCB CARD ROUTINE *
*     IF COL(1:3) = CFCB                /* IF THE OPERATION FIELD IS  *
*          THEN GO TO INPUT600;         /*    FCB GO TO INPUT600      *
         CLC   0(3,@2),CFCB                                       0081
         BC    08,INPUT600                                        0082
* /* IF ALL STATEMENTS EXCEPT END HAVE NOT READ POST AN ERROR         *
*     IF FLAG ^= '1111'B                /* IF ALL FLAGS NOT ON        *
*          THEN GO TO INPUT020;         /*    SET MISSING-CARD CODE   *
         TM    FLAG,B'11110000'                                   0083
         BC    12,INPUT020                                        0084
* /* IF THIS CARD IS NOT THE END STATEMENT POST AN ERROR              *
*     IF COL(1:3) ^= CEND               /* IS OPERATION FIELD NOT END *
*          THEN                         /* YES - THIS IS NOT END CARD *
         CLC   0(3,@2),CEND                                       0085
         BC    08,@9FE                                            0085
*               DO;                     /* CANCEL THE UTILITY         *
*                    ERRCODE = CB07;    /* INCORRECT END STATEMENT    *
         MVC   ERRCODE(3),CB07                                    0087
*                    CALL WAIT;         /* TERMINATE THE UTILITY      *
         BAL   @E,WAIT                                            0088
*               END;                    /*                            *
*     CALL CONTROL;                     /* LOAD THE BUFFERS           *
@9FE     BAL   @E,CONTROL                                         0090
* INPUT020: ERRCODE = CB02;             /* MISSING CONTROL CARD ERROR *
INPUT020 MVC   ERRCODE(3),CB02                                    0091
*     CALL WAIT;                        /* TERMINATE THE UTILITY      *
         BAL   @E,WAIT                                            0092
* /*                                                                  *
* /* JOB STATEMENT ROUTINE                                            *
* /*                                                                  *
* /* IF ANOTHER STATEMENT HAS ALREADY BEEN READ POST AN ERROR         *
* INPUT100: IF FLAG ^= '0000'B          /* IF ALL FLAGS NOT OFF       *
*          THEN GO TO INPUT020;         /*    SET MISSING-CARD CODE   *
INPUT100 TM    FLAG,B'11110000'                                   0093
         BC    05,INPUT020                                        0094
*     JOBFLAG = '1'B;                   /* INDICATE JOB STATEMENT READ*
         OI    FLAG,B'10000000'                                   0095
*     GO TO INPUT010;                   /* READ ANOTHER CARD          *
         BC    15,INPUT010                                        0096
* /*                                                                  *
* /* DFN STATEMENT ROUTINE                                            *
* /*                                                                  *
* /* IF THE DFN STATEMENT HAS ALREADY BEEN READ POST AN ERROR         *
* INPUT200: IF DFNFLAG = '1'B           /* IS THE DFN STATEMENT BIT ON*
*          THEN GO TO INPUT020;         /* YES - SET ERROR CODE       *
INPUT200 TM    FLAG,B'00010000'                                   0097
         BC    01,INPUT020                                        0098
*     DFNFLAG = '1'B;                   /* INDICATE DFN STATEMENT READ*
         OI    FLAG,B'00010000'                                   0099
*     FLAGDFN = FLAGDFN & CLRBYTE;      /* CLEAR FLAG FOR DFN CARD    *
         NC    FLAGDFN(1),CLRBYTE                                 0100
*     CALL SEARCH;                      /* POINT BEYOND OPERATION FLD *
         BAL   @E,SEARCH                                          0101
*     CALL SEEK;                        /* POINT TO PARAMETER START   *
         BAL   @E,SEEK                                            0102
* /* IF THIS IS THE ADDR PARAMETER GO TO THE ADDR HANDLER             *
* INPUT210: IF COL(1:4) = CADDR         /* IF THE OPERAND FIELD IS    *
*          THEN GO TO INPUT230;         /*    ADDR GO TO INPUT230     *
INPUT210 CLC   0(4,@2),CADDR                                      0103
         BC    08,INPUT230                                        0104
* /* IF THIS IS THE FOLD PARAMETER GO TO THE FOLD HANDLER             *
*     IF COL(1:4) = CFOLD               /* IF THE OPERAND FIELD IS    *
*          THEN GO TO INPUT250;         /*    FOLD GO TO INPUT250     *
         CLC   0(4,@2),CFOLD                                      0105
         BC    08,INPUT250                                        0106
* INPUT220: ERRCODE = CB04;             /* INCORRECT DFN STATEMENT    *
INPUT220 MVC   ERRCODE(3),CB04                                    0107
*     CALL WAIT;                        /* TERMINATE THE UTILITY      *
         BAL   @E,WAIT                                            0108
* /* IF THE ADDR PARAMETER HAS ALREADY BEEN READ SET AN ERROR CODE    *
* INPUT230: IF ADDRFLAG = '1'B          /* IS THE ADDR PARM BIT ON    *
*          THEN GO TO INPUT220;         /* YES - SET ERROR CODE       *
INPUT230 TM    FLAGDFN,B'10000000'                                0109
         BC    01,INPUT220                                        0110
*     ADDRFLAG = '1'B;                  /* INDICATE ADDR PARM READ    *
         OI    FLAGDFN,B'10000000'                                0111
*     CR = CR + 5;                      /* POINT TO PRINTER ADDRESS   *
         AH    @2,@D1                                             0112
* /* CHECK THE USER DEFINED PRINTER ADDRESS BY COMPARING EACH         *
* /* CHARACTER WITH A LIST OF VALID CHARACTERS                        *
*     DO I = 1 TO 3;                    /* CHECK THE NEXT THREE CHARS *
         LA    @F,1                                               0113
         ST    @F,I                                               0113
*          DO J = 1 TO 16;              /* COMARE THEM TO VALID CHARS *
@DO9FD   LA    @F,1                                               0114
         ST    @F,J                                               0114
* /* IF THE CHARACTER IS VALID GO TO CHECK THE NEXT ONE               *
*               IF COL(I) = NUM(J)      /* IF THE CHARACTER IS VALID  *
*                    THEN GO TO INPUT240; /*  END THE COMPARISON      *
@DO9F9   L     @1,J                                               0115
         LA    @E,NUM-1(@1)                                       0115
         L     @B,I                                               0115
         LA    @A,0(@B,@2)                                        0115
         BCTR  @A,0                                               0115
         CLC   0(1,@A),0(@E)                                      0115
         BC    08,INPUT240                                        0116
*          END;                         /*                            *
*          GO TO INPUT220;              /* IF NOT VALID SET ERROR CODE*
         L     @F,J                                               0117
         AH    @F,@D2                                             0117
@DO9F8   ST    @F,J                                               0117
         CH    @F,@D3                                             0117
         BC    12,@DO9F9                                          0117
         BC    15,INPUT220                                        0118
* INPUT240: ;                           /*                            *
*     END;                              /*                            *
*     PTRADDR = COL;                    /* SAVE THE PRINTER ADDRESS   *
INPUT240 L     @F,I                                               0120
         AH    @F,@D2                                             0120
@DO9FC   ST    @F,I                                               0120
         CH    @F,@D4                                             0120
         BC    12,@DO9FD                                          0120
         MVC   PTRADDR(3),0(@2)                                   0121
*     CR = CR + 3;                      /* POINT BEYOND ADDRESS       *
         AH    @2,@D4                                             0122
*     GO TO INPUT270;                   /* CHECK FOR MORE PARAMETERS  *
         BC    15,INPUT270                                        0123
* /* IF THE FOLD PARAMETER HAS ALREADY BEEN READ SET AN ERROR CODE    *
* INPUT250: IF FOLDFLAG = '1'B          /* IS THE FOLD PARM BIT ON    *
*          THEN GO TO INPUT220;         /* YES - SET ERROR CODE       *
INPUT250 TM    FLAGDFN,B'01000000'                                0124
         BC    01,INPUT220                                        0125
*     FOLDFLAG = '1'B;                  /* INDICATE FOLD PARM READ    *
         OI    FLAGDFN,B'01000000'                                0126
*     CR = CR + 5;                      /* POINT TO FOLD OPTION       *
         AH    @2,@D1                                             0127
* /* IF THE USER SPECIFIES Y (YES-FOLD) TURN THE FOLDBIT ON           *
*     IF COL(1) = CY                    /* IF THE OPTION IS Y         *
*          THEN DO;                     /*    THE USER IS REQUEST FOLD*
         CLC   0(1,@2),CY                                         0128
         BC    07,@9F5                                            0128
*               FOLDBIT = '00000001'B;  /* INDICATE FOLD CCW ISSUED   *
         MVI   FOLDBIT,B'00000001'                                0130
*               GO TO INPUT260;         /* POINT TO NEXT PARAMETER    *
         BC    15,INPUT260                                        0131
*          END;                         /*                            *
* /* IF THE USER SPECIFIES N (NO-DONT FOLD) CONTINUE                  *
*     IF COL(1) = CN                    /* IF THE OPTION IS N         *
*          THEN GO TO INPUT260;         /*    POINT TO NEXT PARM      *
@9F5     CLC   0(1,@2),CN                                         0133
*     GO TO INPUT220;                   /* OPTION NOT VALID - ERROR   *
         BC    07,INPUT220                                        0135
* INPUT260: CR = CR + 1;                /* POINT TO THE NEXT PARM     *
INPUT260 AH    @2,@D2                                             0136
* /* IF BOTH DFN PARAMETERS HAVE BEEN READ GO ON TO THE NEXT STATEMENT*
* INPUT270: IF FLAGDFN = '11'B          /* IF BOTH PARM FLAG BITS ARE *
*          THEN GO TO INPUT010;         /*    ON READ ANOTHER CARD    *
INPUT270 TM    FLAGDFN,B'11000000'                                0137
         BC    01,INPUT010                                        0138
* /* IF THERE ARE NO MORE PARAMETERS IN THE DFN STATEMENT SET AN ERROR*
*     IF COL(1) ^= COMMA                /* IF THIS COLUMN IS NOT A    *
*          THEN GO TO INPUT220;         /* COMMA SET AN ERROR CODE    *
         CLC   0(1,@2),COMMA                                      0139
         BC    07,INPUT220                                        0140
*     CR = CR + 1;                      /* POINT TO NEXT PARAMETER    *
         AH    @2,@D2                                             0141
* /* IF THIS IS THE START OF THE NEXT PARM GO TO PROCESS IT           *
*     IF COL(1) ^= BLANK                /* IF THIS COLUMN IS NOT      *
*          THEN GO TO INPUT210;         /*    BLANK GO TO INPUT210    *
         CLC   0(1,@2),BLANK                                      0142
         BC    07,INPUT210                                        0143
* /* IF THERE IS NOT CONTINUATION CHARACTER SET AN ERROR CODE         *
*     IF INAREA(72) = BLANK             /* IF DFN STATEMENT IS NOT    *
*          THEN GO TO INPUT220;         /*    CONTINUED SET ERROR CODE*
         CLC   INAREA+71(1),BLANK                                 0144
         BC    08,INPUT220                                        0145
*     CALL GET;                         /* READ NEXT DFN CARD         *
         BAL   @E,GET                                             0146
*     CR = ADDR(INAREA);                /* POINT TO START OF INPUT    *
         LA    @2,INAREA                                          0147
*     CALL SEEK;                        /* FIND THE FIRST NON-BLANK   *
         BAL   @E,SEEK                                            0148
*     GO TO INPUT210;                   /* PROCESS THE NEXT PARAMETER *
         BC    15,INPUT210                                        0149
* /*                                                                  *
* /* UCS STATEMENT ROUTINE                                            *
* /*                                                                  *
* /* IF THE UCS STATEMENT HAS ALREADY BEEN READ POST AN ERROR         *
* INPUT400: IF UCSFLAG = '1'B           /* IS THE UCS STATEMENT BIT ON*
*          THEN GO TO INPUT020;         /*    YES - SET ERROR CODE    *
INPUT400 TM    FLAG,B'01000000'                                   0150
         BC    01,INPUT020                                        0151
*     UCSFLAG = '1'B;                   /* INDICATE UCS STATEMENT READ*
         OI    FLAG,B'01000000'                                   0152
* /* SAVE UP TO EIGHT CHARACTERS OF THE UCS NAME                      *
*     DO I = 1 TO 8;                    /* SET LIMIT OF LOOP TO EIGHT *
         LA    @F,1                                               0153
         ST    @F,I                                               0153
* /* IF ALL CHARACTERS OF THE NAME HAVE BEEN READ END THE LOOP        *
*          IF INAREA(I) = BLANK         /* IF THIS IS LAST CHARACTER  *
*               THEN GO TO INPUT420;    /*    END THE LOOP            *
@DO9F4   L     @1,I                                               0154
         LA    @A,INAREA-1(@1)                                    0154
         CLC   0(1,@A),BLANK                                      0154
         BC    08,INPUT420                                        0155
*               ELSE UCSNMST(I) = INAREA(I); /*    ELSE SAVE CHARACTER*
         LA    @E,INAREA-1(@1)                                    0156
         LA    @A,UCSNMST-1(@1)                                   0156
         MVC   0(1,@A),0(@E)                                      0156
*     END;                              /*                            *
* INPUT420: UCSSEQ = '00000001'B;       /* SET SEQUENCE NUMBER TO 1   *
         L     @F,I                                               0157
         AH    @F,@D2                                             0157
@DO9F3   ST    @F,I                                               0157
         CH    @F,@D5                                             0157
         BC    12,@DO9F4                                          0157
INPUT420 MVI   UCSSEQ,B'00000001'                                 0158
*     PR = ADDR(UCSLOAD);               /* LOAD UCS IMAGE ADDRESS     *
         LA    @3,UCSLOAD                                         0159
* /* CHECK FOR THE EIGTH UCS CARD - IF YES LOAD 40 CHARACTERS         *
* INPUT450: IF UCSSEQ = '00001000'B     /* IS THIS THE EIGTH CARD     *
*          THEN DO;                     /* YES - LOAD 40 CHARACTERS   *
INPUT450 CLI   UCSSEQ,B'00001000'                                 0160
         BC    07,@9F0                                            0160
*               DO I = 1 TO 40;         /* SET LIMIT TO 40            *
         LA    @F,1                                               0162
         ST    @F,I                                               0162
*               IMAGE(I) = INAREA(I + 15); /* MOVE CHARACTERS         *
@DO9EF   LA    @1,15                                              0163
         A     @1,I                                               0163
         LA    @E,INAREA-1(@1)                                    0163
         L     @B,I                                               0163
         LA    @A,0(@B,@3)                                        0163
         BCTR  @A,0                                               0163
         MVC   0(1,@A),0(@E)                                      0163
*               END;                    /*                            *
*          GO TO INPUT010;              /* READ ANOTHER DATA CARD     *
         L     @F,I                                               0164
         AH    @F,@D2                                             0164
@DO9EE   ST    @F,I                                               0164
         CH    @F,@D6                                             0164
         BC    12,@DO9EF                                          0164
         BC    15,INPUT010                                        0165
*          END;                         /*                            *
*          ELSE DO;                     /* NO - LOAD 56 CHARACTERS    *
*               DO I = 1 TO 56;         /* SET LIMIT TO 56            *
@9F0     LA    @F,1                                               0168
         ST    @F,I                                               0168
*               IMAGE(I) = INAREA(I + 15); /* MOVE CHARACTERS         *
@DO9EA   LA    @1,15                                              0169
         A     @1,I                                               0169
         LA    @E,INAREA-1(@1)                                    0169
         L     @B,I                                               0169
         LA    @A,0(@B,@3)                                        0169
         BCTR  @A,0                                               0169
         MVC   0(1,@A),0(@E)                                      0169
*               END;                    /*                            *
*          PR = PR + 56;                /* INCREASE POINTER BY 56     *
         L     @F,I                                               0170
         AH    @F,@D2                                             0170
@DO9E9   ST    @F,I                                               0170
         CH    @F,@D7                                             0170
         BC    12,@DO9EA                                          0170
         AH    @3,@D7                                             0171
*          UCSSEQ = UCSSEQ + 1;         /* INCREASE SEQUENCE BY 1     *
         LA    @F,1                                               0172
         SR    @0,@0                                              0172
         IC    @0,UCSSEQ                                          0172
         AR    @F,@0                                              0172
         STC   @F,UCSSEQ                                          0172
*          CALL GET;                    /* READ ANOTHER UCS DATA CARD *
         BAL   @E,GET                                             0173
* /* IF ANY COLUMN FROM 1 TO 15 CONTAINS A NON-BLANK THIS IS NOT A    *
* /* CORRECT UCS STATEMENT                                            *
*          DO I = 1 TO 15;              /* SET LIMIT TO 15            *
         LA    @F,1                                               0174
         ST    @F,I                                               0174
* /* IF THIS COLUMN IS A NON-BLANK SET AN ERROR CODE                  *
*               IF INAREA(I) ^= BLANK   /* IF COLUMN I IS A BLANK     *
*                    THEN DO;           /*    THEN TERMINATE          *
@DO9E6   L     @1,I                                               0175
         LA    @A,INAREA-1(@1)                                    0175
         CLC   0(1,@A),BLANK                                      0175
         BC    08,@9E2                                            0175
*                    ERRCODE = CB05;    /* INCORRECT UCS STATEMENT    *
         MVC   ERRCODE(3),CB05                                    0177
*                    CALL WAIT;         /* TERMINATE THE UTILITY      *
         BAL   @E,WAIT                                            0178
*                    END;               /*                            *
*          END;                         /*                            *
*          GO TO INPUT450;              /* ANALYZE THIS UCS CARD      *
@9E2     L     @F,I                                               0180
         AH    @F,@D2                                             0180
@DO9E5   ST    @F,I                                               0180
         CH    @F,@D8                                             0180
         BC    12,@DO9E6                                          0180
         BC    15,INPUT450                                        0181
*     END;                              /*                            *
* /*                                                                  *
* /* FCB STATEMENT ROUTINE                                            *
* /*                                                                  *
* /* IF THE FCB STATEMENT HAS ALREADY BEEN READ POST AN ERROR         *
* INPUT600: IF FCBFLAG = '1'B           /* IS THE FCB STATEMENT BIT ON*
*          THEN GO TO INPUT020;         /*    YES - SET ERROR CODE    *
@9EB     EQU   *                                                  0183
INPUT600 TM    FLAG,B'00100000'                                   0183
         BC    01,INPUT020                                        0184
*     FCBFLAG = '1'B;                   /* INDICATE FCB STATEMENT READ*
         OI    FLAG,B'00100000'                                   0185
* /* SAVE UP TO EIGHT CHARACTERS OF THE FCB NAME                      *
*     DO I = 1 TO 8;                    /* SET LIMIT OF LOOP TO EIGHT *
         LA    @F,1                                               0186
         ST    @F,I                                               0186
* /* IF ALL CHARACTERS OF THE NAME HAVE BEEN READ END THE LOOP        *
*          IF INAREA(I) = BLANK         /* IF THIS IS THE LAST CHAR   *
*               THEN GO TO INPUT605;    /*    END THE LOOP            *
@DO9E1   L     @1,I                                               0187
         LA    @A,INAREA-1(@1)                                    0187
         CLC   0(1,@A),BLANK                                      0187
         BC    08,INPUT605                                        0188
*               ELSE FCBNMST(I) = INAREA(I); /*    ELSE SAVE CHARACTER*
         LA    @E,INAREA-1(@1)                                    0189
         LA    @A,FCBNMST-1(@1)                                   0189
         MVC   0(1,@A),0(@E)                                      0189
*     END;                              /*                            *
* INPUT605: PR = ADDR(FCBJCL);          /* POINT TO JCL SAVE AREA     *
         L     @F,I                                               0190
         AH    @F,@D2                                             0190
@DO9E0   ST    @F,I                                               0190
         CH    @F,@D5                                             0190
         BC    12,@DO9E1                                          0190
INPUT605 LA    @3,FCBJCL                                          0191
* /*                                                                  *
* /* ALL FCB STATEMENT CARDS ARE READ IN AND THE OPERANDS SAVED AT    *
* /* FCBJCL                                                           *
* /*                                                                  *
* INPUT610: CALL SEARCH;                /* FIND THE FIRST BLANK       *
INPUT610 BAL   @E,SEARCH                                          0192
*     CALL SEEK;                        /* FIND THE FIRST NON-BLANK   *
         BAL   @E,SEEK                                            0193
*     FCBSAVE = CR;                     /* SAVE FIRST PARM ADDRESS    *
         ST    @2,FCBSAVE                                         0194
* /* IF THIS IS THE LAST FCB CARD MOVE IT TO FCBJCL AND PROCESS IT    *
*     IF INAREA(72) = BLANK             /* IF CONTINUATION COL BLANK  *
*          THEN GO TO INPUT650;         /*    HANDLE AS LAST CARD     *
         CLC   INAREA+71(1),BLANK                                 0195
         BC    08,INPUT650                                        0196
*     CALL SEARCH;                      /* FIND THE FIRST BLANK       *
         BAL   @E,SEARCH                                          0197
* /* IF THE FIRST BLANK IS BEYOND COL 71 THEN THE LENGTH OF THE MOVE  *
* /* MUST BE REDUCED BY ONE FOR THE CONTINUATION CHARACTER            *
*     IF CR > ADDR(INAREA) + 71         /* FIRST BLANK BEYOND COL 71? *
*          THEN DO;                     /* YES - REDUCE LENGTH BY ONE *
         LA    @F,71                                              0198
         LA    @0,INAREA                                          0198
         AR    @F,@0                                              0198
         CR    @F,@2                                              0198
         BC    10,@9DD                                            0198
*               MVLNTH = ADDR(INAREA) + 71 - FCBSAVE; /* DEFINE LENGTH*
         L     @F,FCBSAVE                                         0200
         LCR   @F,@F                                              0200
         AH    @F,@D9                                             0200
         LA    @0,INAREA                                          0200
         AR    @F,@0                                              0200
         STC   @F,MVLNTH                                          0200
*               GO TO INPUT620;         /* SAVE CARD AT FCBJCL        *
         BC    15,INPUT620                                        0201
*               END;                    /*                            *
*     CR = CR - 1;                      /* POINT TO COL BEFORE BLANK  *
@9DD     BCTR  @2,0                                               0203
* /* COLUMN BEFORE THE BLANK MUST BE A COMMA OR THERE IS AN ERROR     *
*     IF COL(1) ^= COMMA                /* IF COL IS NOT A COMMA      *
*          THEN GO TO INPUT640;         /*    SET AN ERROR CODE       *
         CLC   0(1,@2),COMMA                                      0204
         BC    07,INPUT640                                        0205
*     MVLNTH = CR - FCBSAVE + 1;        /* SET LENGTH OF MOVE         *
         LA    @F,1                                               0206
         S     @F,FCBSAVE                                         0206
         AR    @F,@2                                              0206
         STC   @F,MVLNTH                                          0206
* INPUT620: IMAGE = '';                 /* CLEAR JCL SAVEAREA @ZA10903*
INPUT620 MVI   0(@3),C' '                                         0207
         MVC   1(55,@3),0(@3)                                     0207
*     IMAGE(1:MVLNTH) = JCLSTRT;        /* MOVE CARD TO JCL SAVEAREA
*                                                             @ZA10903*
         L     @1,FCBSAVE                                         0208
         LR    @E,@1                                              0208
         SR    @B,@B                                              0208
         IC    @B,MVLNTH                                          0208
         BCTR  @B,0                                               0208
         LR    @A,@3                                              0208
         EX    @B,@MVC                                            0208
*     PR = PR + MVLNTH;                 /* INCREASE SAVEAREA POINTER  *
         SR    @0,@0                                              0209
         IC    @0,MVLNTH                                          0209
         AR    @3,@0                                              0209
*     CALL GET;                         /* READ ANOTHER DATA CARD     *
         BAL   @E,GET                                             0210
*     CR = ADDR(INAREA);                /* LOAD ADDRESS OF COL ONE    *
         LA    @2,INAREA                                          0211
* /* IF ANY COLUMN FROM 1 TO 15 CONTAINS A NON-BLANK THIS IS NOT A    *
* /* CORRECT FCB STATEMENT                                            *
*     DO I = 1 TO 15;                   /* SET LIMIT TO 15            *
         LA    @F,1                                               0212
         ST    @F,I                                               0212
* /* IF THIS COLUMN IS A NON-BLANK SET AN ERROR CODE                  *
*          IF INAREA(I) ^= BLANK        /* IF COLUMN I IS A BLANK     *
*               THEN GO TO INPUT640;    /*    THEN TERMINATE          *
@DO9DC   L     @1,I                                               0213
         LA    @A,INAREA-1(@1)                                    0213
         CLC   0(1,@A),BLANK                                      0213
         BC    07,INPUT640                                        0214
*     END;                              /*                            *
*     GO TO INPUT610;                   /* CHECK DATA ON THIS CARD    *
         L     @F,I                                               0215
         AH    @F,@D2                                             0215
@DO9DB   ST    @F,I                                               0215
         CH    @F,@D8                                             0215
         BC    12,@DO9DC                                          0215
         BC    15,INPUT610                                        0216
* INPUT640: ERRCODE = CB06;             /* INCORRECT FCB STATEMENT    *
INPUT640 MVC   ERRCODE(3),CB06                                    0217
*     CALL WAIT;                        /* TERMINATE THE UTILITY      *
         BAL   @E,WAIT                                            0218
* INPUT650: CALL SEARCH;                /* FIND THE FIRST BLANK       *
INPUT650 BAL   @E,SEARCH                                          0219
*     MVLNTH = CR - FCBSAVE;            /* SET LENGTH OF MOVE         *
         LR    @F,@2                                              0220
         S     @F,FCBSAVE                                         0220
         STC   @F,MVLNTH                                          0220
*     IMAGE = '';                       /* CLEAR JCL SAVEAREA @ZA10903*
         MVI   0(@3),C' '                                         0221
         MVC   1(55,@3),0(@3)                                     0221
*     IMAGE(1:MVLNTH) = JCLSTRT;        /* MOVE CARD TO JCL SAVEAREA  *
         L     @1,FCBSAVE                                         0222
         LR    @E,@1                                              0222
         SR    @B,@B                                              0222
         IC    @B,MVLNTH                                          0222
         BCTR  @B,0                                               0222
         LR    @A,@3                                              0222
         EX    @B,@MVC                                            0222
*     PR = PR + MVLNTH;                 /* INCREASE SAVEAREA POINTER  *
         SR    @0,@0                                              0223
         IC    @0,MVLNTH                                          0223
         AR    @3,@0                                              0223
* /*                                                                  *
* /* THE FCB OPERANDS ARE ANALYZED TO FORM THE FCB IMAGE              *
* /*                                                                  *
*     FLAGFCB = '00000000'B;            /* CLEAR FLAG FOR FCB CARD    *
         MVI   FLAGFCB,B'00000000'                                0224
*     CR = ADDR(FCBJCL);                /* POINT TO FIRST PARAMETER   *
         LA    @2,FCBJCL                                          0225
* /* IF ALL OF THE FCB PARAMETERS HAVE BEEN READ GET ANOTHER STATEMENT*
* INPUT660: IF FLAGFCB = '111'B         /* IF ALL FCB FLAGS ON        *
*          THEN GO TO INPUT010;         /*    READ ANOTHER JCL CARD   *
INPUT660 TM    FLAGFCB,B'11100000'                                0226
         BC    01,INPUT010                                        0227
* /* IF THIS PARM IS LPI GO TO THE LPI ROUTINE                        *
*     IF COL(1:3) = CLPI                /* IF COL HAS LPI CHARACTERS  *
*          THEN GO TO INPUT670;         /*    GO TO LPI ROUTINE       *
         CLC   0(3,@2),CLPI                                       0228
         BC    08,INPUT670                                        0229
* /* IF THIS PARM IS FORMEND GO TO THE FORMEND ROUTINE                *
*     IF COL(1:7) = CFORMEND            /* IF COL HAS FORMEND CHARS   *
*          THEN GO TO INPUT700;         /*    GO TO FORMEND ROUTINE   *
         CLC   0(7,@2),CFORMEND                                   0230
         BC    08,INPUT700                                        0231
* /* IF THIS PARM IS LNCH GO TO THE LNCH ROUTINE                      *
*     IF COL(1:4) = CLNCH               /* IF COL HAS LNCH CHARACTERS *
*          THEN GO TO INPUT720;         /*    GO TO LNCH ROUTINE      *
         CLC   0(4,@2),CLNCH                                      0232
         BC    08,INPUT720                                        0233
*      GO TO INPUT680;                  /* SET INCORRECT FCB CODE     *
         BC    15,INPUT680                                        0234
* /* IF THE LPI PARAMETER HAS ALREADY BEEN READ SET INCORRECT FCB CODE*
* INPUT670: IF LPIFLAG = '1'B           /* IF LPI FLAG IS ON          *
*          THEN GO TO INPUT680;         /*    SET AN ERROR CODE       *
INPUT670 TM    FLAGFCB,B'10000000'                                0235
         BC    01,INPUT680                                        0236
*     LPIFLAG = '1'B;                   /* INDICATE LPI PARM READ     *
         OI    FLAGFCB,B'10000000'                                0237
*     CR = CR + 4;                      /* POINT TO LPI OPTION        *
         AH    @2,@D10                                            0238
* /* IF THE USER HAS SPECIFIED 6 LINES PER INCH DO NOT SET LPI BIT ON *
*     IF COL(1) = C6                    /* IF THE OPTION IS 6         *
*          THEN DO;                     /*    THEN CONTINUE           *
         CLC   0(1,@2),C6                                         0239
         BC    07,@9D8                                            0239
*               CR = CR + 2;            /* POINT TO THE NEXT PARM     *
         AH    @2,@D11                                            0241
*               GO TO INPUT660;         /* ANALYZE THE NEXT PARM      *
         BC    15,INPUT660                                        0242
*          END;                         /*                            *
* /* IF THE USER HAS SPECIFIED 8 LINES PER INCH SET THE LPI BIT ON    *
*     IF COL(1) = C8                    /* IF THE OPTION IS 8         *
*          THEN DO;                     /*    THEN SET FLAG & CONTINUE*
@9D8     CLC   0(1,@2),C8                                         0244
         BC    07,@9D7                                            0244
*               FCBIMG(1) = FCBIMG(1) × LPI8; /* SET LPI BIT ON IN FCB*
         OC    FCBIMG(1),LPI8                                     0246
*               CR = CR + 2;            /* POINT TO THE NEXT PARM     *
         AH    @2,@D11                                            0247
*               GO TO INPUT660;         /* ANALYZE THE NEXT PARM      *
         BC    15,INPUT660                                        0248
*          END;                         /*                            *
* INPUT680: ERRCODE = CB06;             /* INCORRECT FCB STATEMENT    *
@9D7     EQU   *                                                  0250
INPUT680 MVC   ERRCODE(3),CB06                                    0250
*     CALL WAIT;                        /* TERMINATE THE UTILITY      *
         BAL   @E,WAIT                                            0251
* /* IF THE FORMEND PARAMETER HAS ALREADY BEEN READ SET AN ERROR CODE *
* INPUT700: IF FEFLAG = '1'B            /* IF FORMEND FLAG IS ON      *
*          THEN GO TO INPUT680;         /*     SET AN ERROR CODE      *
INPUT700 TM    FLAGFCB,B'01000000'                                0252
         BC    01,INPUT680                                        0253
*     FEFLAG = '1'B;                    /* INDICATE FORMEND PARM READ *
         OI    FLAGFCB,B'01000000'                                0254
*     CR = CR + 8;                      /* POINT TO THE FORMEND OPTION*
         AH    @2,@D5                                             0255
*     CALL INTRP;                       /* INTERPRET DECIMAL DIGITS   *
         BAL   @E,INTRP                                           0256
* /* IF THE LINE FOR END-OF-FORM IS BEYOND 180 SET AN ERROR CODE      *
*     IF PR > 180                       /* IF FORMEND EXCEEDS LIMIT   *
*          THEN GO TO INPUT680;         /*    SET AN ERROR CODE       *
         CH    @3,@D12                                            0257
         BC    02,INPUT680                                        0258
*     FCBIMG(PR) = FCBIMG(PR) × ENDBIT; /* SET END OF FORM BIT ON     *
         LR    @1,@3                                              0259
         LA    @A,FCBIMG-1(@1)                                    0259
         OC    0(1,@A),ENDBIT                                     0259
*     CR = CR + 1;                      /* POINT TO THE NEXT PARM     *
         AH    @2,@D2                                             0260
*     GO TO INPUT660;                   /* ANALYZE THE NEXT PARM      *
         BC    15,INPUT660                                        0261
* /* IF THE LNCH PARAMETER HAS ALREADY BEEN READ SET AN ERROR CODE    *
* INPUT720: IF LNCHFLAG = '1'B          /* IF LNCH BIT IS ON          *
*          THEN GO TO INPUT680;         /*    SET AN ERROR CODE       *
INPUT720 TM    FLAGFCB,B'00100000'                                0262
         BC    01,INPUT680                                        0263
*     LNCHFLAG = '1'B;                  /* INDICATE LNCH PARM READ    *
         OI    FLAGFCB,B'00100000'                                0264
*     CR = CR + 6;                      /* POINT TO THE LNCH OPTIONS  *
         AH    @2,@D13                                            0265
* /* IF ALL PAIRS OF LINES AND CHANNELS HAVE BEEN READ CHECK NEXT PARM*
* INPUT730: IF COL(1) = RPAREN          /* IF THE ENDING CHAR - ')'   *
*          THEN DO;                     /*    CHECK THE NEXT PARAMETER*
INPUT730 CLC   0(1,@2),RPAREN                                     0266
         BC    07,@9D6                                            0266
*               CR = CR + 2;            /* POINT TO NEXT PARAMETER    *
         AH    @2,@D11                                            0268
*               GO TO INPUT660;         /* ANALYZE NEXT PAREMETER     *
         BC    15,INPUT660                                        0269
*          END;                         /*                            *
* /* IF THIS IS NOT THE START OF THE NEXT PAIR SET AN ERROR           *
*     IF COL(1) ^= LPAREN               /* IF NOT A '('               *
*          THEN GO TO INPUT680;         /*    SET AN ERROR CODE       *
@9D6     CLC   0(1,@2),LPAREN                                     0271
         BC    07,INPUT680                                        0272
*     CR = CR + 1;                      /* POINT TO LINE NUMBER       *
         AH    @2,@D2                                             0273
*     CALL INTRP;                       /* INTERPRET DECIMAL DIGITS   *
         BAL   @E,INTRP                                           0274
* /* IF THE LINE NUMBER IS BEYOND 180 SET AN ERROR CODE               *
*     IF PR > 180                       /* IF LINE EXCEEDS LIMIT      *
*          THEN GO TO INPUT680;         /*    SET AN ERROR CODE       *
         CH    @3,@D12                                            0275
         BC    02,INPUT680                                        0276
*     LNNO = PR;                        /* SAVE THE LINE NUMBER       *
         ST    @3,LNNO                                            0277
*     CR = CR + 1;                      /* POINT TO CHANNEL NUMBER    *
         AH    @2,@D2                                             0278
*     CALL INTRP;                       /* INTERPRET DECIMAL DIGITS   *
         BAL   @E,INTRP                                           0279
* /* IF THE CHANNEL NUMBER IS BEYOND 12 SET AN ERROR CODE             *
*     IF PR > 12                        /* IF CHANNEL EXCEEDS LIMIT   *
*          THEN GO TO INPUT680;         /*    SET AN ERROR CODE       *
         CH    @3,@D14                                            0280
         BC    02,INPUT680                                        0281
*     CHNO = PR;                        /* SAVE THE CHANNEL NUMBER    *
         ST    @3,CHNO                                            0282
*     FCBIMG(LNNO) = FCBIMG(LNNO) × CHNO(4); /* SET CHANNEL DEF       *
         L     @1,LNNO                                            0283
         LA    @A,FCBIMG-1(@1)                                    0283
         OC    0(1,@A),CHNO+3                                     0283
*     CR = CR + 1;                      /* POINT TO NEXT CHARACTER    *
         AH    @2,@D2                                             0284
* /* IF THERE ARE MORE PAIRS POINT TO THE NEXT ONE                    *
*     IF COL(1) = COMMA                 /* IF A COMMA AT THIS CHAR    *
*          THEN CR = CR + 1;            /*    INCREASE POINTER        *
         CLC   0(1,@2),COMMA                                      0285
         BC    07,@9D5                                            0285
         AH    @2,@D2                                             0286
*     GO TO INPUT730;                   /* ANALYZE THE NEXT PAIR      *
         BC    15,INPUT730                                        0287
* /*                                                                  *
* /* THE FOLLOWING ROUTINE IS USED TO INTERPRET DECIMAL DATA AND      *
* /* RETURN WITH THE DATA IN HEX FORM.                                *
* /*                                                                  *
* INTRP: PROCEDURE                      /* INTERPRET ROUTINE          *
*          OPTIONS(NOSAVEAREA,          /* SAVEAREA IS NOT REQUIRED   *
*                  DONTSAVE(2,3,4));    /* PARAMETER REGISTERS        *
@EL03    L     @D,4(0,@D)                                         0288
         LM    @E,@C,12(@D)                                       0288
         BCR   15,@E                                              0288
INTRP    STM   @E,@1,12(@D)                                       0288
         STM   @5,@C,40(@D)                                       0288
*     RESTRICT (CR,                     /* DATA TO BE INTERPRETED     *
*               PR,                     /* HEX EQUIVALENT OF DATA     *
*               WR,                     /* STARTING ADDRESS OF DATA   *
*               12);                    /* GPR12 USED AS THE BASE     *
*     WR = CR;                          /* SAVE DATA STARTING ADDRESS *
         LR    @4,@2                                              0290
* /* CHECK ALL DIGITS OF THE DATA FIELD FOR NUMERALS BY COMPARING THEM*
* /* TO A LIST OF ALL POSSIBLE NUMERIC VALUES                         *
*     DO I = 1 TO 3;                    /* COMPARE UP TO THREE DIGITS *
         LA    @F,1                                               0291
         ST    @F,I                                               0291
*          DO J = 1 TO 10;              /* CHECK ALL POSSIBLE VALUES  *
@DO9D4   LA    @F,1                                               0292
         ST    @F,J                                               0292
*               IF COL(I) = TABLE(J)    /* IF THIS DIGIT IS OK        *
*                    THEN GO TO INPUT740; /*  CHECK THE NEXT ONE      *
@DO9D0   L     @1,J                                               0293
         LA    @E,TABLE-1(@1)                                     0293
         L     @5,I                                               0293
         LA    @A,0(@5,@2)                                        0293
         BCTR  @A,0                                               0293
         CLC   0(1,@A),0(@E)                                      0293
         BC    08,INPUT740                                        0294
*          END;                         /*                            *
*          GO TO INPUT750;              /* BRANCH OUT IF NOT EQUAL    *
         L     @F,J                                               0295
         AH    @F,@D2                                             0295
@DO9CF   ST    @F,J                                               0295
         CH    @F,@D15                                            0295
         BC    12,@DO9D0                                          0295
         BC    15,INPUT750                                        0296
* INPUT740: ;                           /*                            *
*     END;                              /*                            *
* INPUT750: CR = CR + I - 1;            /* INCREASE POINTER REGISTER  *
INPUT740 L     @F,I                                               0298
         AH    @F,@D2                                             0298
@DO9D3   ST    @F,I                                               0298
         CH    @F,@D4                                             0298
         BC    12,@DO9D4                                          0298
INPUT750 LH    @F,@D16                                            0299
         A     @F,I                                               0299
         AR    @2,@F                                              0299
*     FWORD = '00000000'X;              /* INITIALYZE FULLWORD        *
         MVC   FWORD(4),@X11                                      0300
*     LENGTH = CR - WR;                 /* DEFINE LENGTH OF DATA      *
         LR    @F,@2                                              0301
         SR    @F,@4                                              0301
         ST    @F,LENGTH                                          0301
* /* IF THE LENGTH IS ZERO THERE IS NO DECIMAL DATA FIELD AT THIS     *
* /* LOCATION AND THIS SHOULD BE CONSIDERED AN ERROR                  *
*     IF LENGTH = 0                     /* IF NO DECIMAL DATA         *
*          THEN RETURN TO INPUT640;     /*    SET AN ERROR CODE       *
         SR    @F,@F                                              0302
         C     @F,LENGTH                                          0302
         BC    07,@9CC                                            0302
         LA    @E,INPUT640                                        0303
         LM    @F,@1,16(@D)                                       0303
         LM    @5,@C,40(@D)                                       0303
         BCR   15,@E                                              0303
*     FWORD(5 - LENGTH:4) = DTST;       /* MOVE DATA TO FWORD         *
@9CC     LR    @E,@4                                              0304
         LA    @1,4                                               0304
         L     @5,LENGTH                                          0304
         LCR   @5,@5                                              0304
         AH    @5,@D1                                             0304
         SR    @1,@5                                              0304
         LA    @A,FWORD-1(@5)                                     0304
         EX    @1,@MVC                                            0304
*     GEN(PACK  DBWD(8),FWORD(4));      /* PACK DATA INTO DOUBLEWORD  *
         PACK  DBWD(8),FWORD(4)
         DS    0H
*     GEN(CVB   PR,DBWD);               /* CONVERT TO BINARY FORM     *
         CVB   PR,DBWD
         DS    0H
* END INTRP;                            /*                            *
@EL04    LM    @E,@1,12(@D)                                       0307
         LM    @5,@C,40(@D)                                       0307
         BCR   15,@E                                              0307
* /*                                                                  *
* /* THE FOLLOWING ROUTINE RECEIVES AN ADDRESS IN REG 2 AND           *
* /* INCREMENTS IT UNTIL A BLANK IS REACHED                           *
* /*                                                                  *
* SEARCH: PROCEDURE                     /* SEARCH FOR BLANK ROUTINE   *
*          OPTIONS(NOSAVEAREA,          /* SAVEAREA IS NOT REQUIRED   *
*                  DONTSAVE(2));        /* PARAMETER REGISTER         *
SEARCH   STM   @E,@1,12(@D)                                       0308
         STM   @3,@C,32(@D)                                       0308
*     RESTRICT (CR,                     /* STARTING ADDRESS           *
*               12);                    /* GPR12 USED AS THE BASE     *
*     CNT = 80;                         /* SET LIMIT OF SEARCH TO 80  *
         LA    @F,80                                              0310
         STH   @F,CNT                                             0310
* /* IF THE FIRST BLANK HAS BEEN REACHED RETURN TO THE CALLING ROUTINE*
* INPUT800: IF COL(1) = BLANK           /* IF ADDRESS POINTS TO BLANK *
*          THEN RETURN;                 /*    GO BACK TO CALLER       *
INPUT800 CLC   0(1,@2),BLANK                                      0311
         BC    08,@EL05                                           0312
*     CR = CR + 1;                      /* INCREASE POINTER           *
@9CB     AH    @2,@D2                                             0313
*     CNT = CNT - 1;                    /* REDUCE LIMIT BY ONE        *
         LH    @F,CNT                                             0314
         BCTR  @F,0                                               0314
         STH   @F,CNT                                             0314
* /* IF NO BLANK WAS REACHED AFTER 80 COLUMNS SET AN ERROR CODE       *
*     IF CNT = 0                        /* IF THE LIMIT IS ZERO       *
*          THEN GO TO INPUT020;         /*    SET AN ERROR CODE       *
         SR    @F,@F                                              0315
         CH    @F,CNT                                             0315
         BC    08,INPUT020                                        0316
*     GO TO INPUT800;                   /* CHECK THE NEXT COLUMN      *
         BC    15,INPUT800                                        0317
* END SEARCH;                           /*                            *
@EL05    LM    @E,@1,12(@D)                                       0318
         LM    @3,@C,32(@D)                                       0318
         BCR   15,@E                                              0318
* /*                                                                  *
* /* THE FOLLOWING ROUTINE RECEIVES AN ADDRESS IN REG 2 AND           *
* /* INCREMENTS IT UNTIL A NON-BLANK IS REACHED                       *
* /*                                                                  *
* SEEK: PROCEDURE                       /* SEEK NON-BLANK ROUTINE     *
*          OPTIONS(NOSAVEAREA,          /* SAVEAREA IS NOT REQUIRED   *
*                  DONTSAVE(2));        /* PARAMETER REGISTER         *
SEEK     STM   @E,@1,12(@D)                                       0319
         STM   @3,@C,32(@D)                                       0319
*     RESTRICT (CR,                     /* STARTENG ADDRESS           *
*               12);                    /* GPR12 USED AS THE BASE     *
*     CNT = 80;                         /* SET LIMIT OF SEEK TO 80    *
         LA    @F,80                                              0321
         STH   @F,CNT                                             0321
* /* IF FIRST NON-BLANK HAS BEEN REACHED RETURN TO CALLING ROUTINE    *
* INPUT900: IF COL(1) ^= BLANK          /* IF ADDRESS POINTS TO NON-  *
*          THEN RETURN;                 /*    BLANK GO BACK TO CALLER *
INPUT900 CLC   0(1,@2),BLANK                                      0322
         BC    07,@EL06                                           0323
*     CR = CR + 1;                      /* INCREASE POINTER           *
@9CA     AH    @2,@D2                                             0324
*     CNT = CNT - 1;                    /* REDUCE LIMIT BY ONE        *
         LH    @F,CNT                                             0325
         BCTR  @F,0                                               0325
         STH   @F,CNT                                             0325
* /* IF NO NON-BLANK HAS BEEN REACHED AFTER 80 COLUMNS SET AN ERROR   *
*     IF CNT = 0                        /* IF THE LIMIT IS ZERO       *
*          THEN GO TO INPUT020;         /*    SET AN ERROR CODE       *
         SR    @F,@F                                              0326
         CH    @F,CNT                                             0326
         BC    08,INPUT020                                        0327
*     GO TO INPUT900;                   /* CHECK THE NEXT COLUMN      *
         BC    15,INPUT900                                        0328
* END SEEK;                             /*                            *
@EL06    LM    @E,@1,12(@D)                                       0329
         LM    @3,@C,32(@D)                                       0329
         BCR   15,@E                                              0329
* /*                                                                  *
* /* THE FOLLOWING ROUTINE IS USED TO READ A DATA CARD                *
* /*                                                                  *
* GET: PROCEDURE;                       /* GET A DATA CARD ROUTINE    *
GET      STM   @E,@C,12(@D)                                       0330
         ST    @D,@SAV007+4                                       0330
         LA    @F,@SAV007                                         0330
         ST    @F,8(0,@D)                                         0330
         LR    @D,@F                                              0330
*     DECLARE
*          PARMR REGISTER(1) FIXED(31); /* PARAMETER REGISTER         *
*     DECLARE
*          DEVR REGISTER(2);            /* ADDRESS OF INPUT DEVICE    *
*     RESTRICT (PARMR,                  /* PARAMETER REGISTER         *
*               DEVR,                   /* ADDRESS OF INPUT DEVICE    *
*               12);                    /* GPR12 USED AS THE BASE     *
*     PARMR = 1;                        /* SET PARM REG FOR READER    *
         LA    @1,1                                               0334
*     GEN(LA    DEVR,READCCW);          /* INSERT CCW ADDRESS INTO    *
         LA    DEVR,READCCW
         DS    0H
*     GEN(ST    DEVR,CAW);              /*    CHANNEL ADDRESS WORD    *
         ST    DEVR,CAW
         DS    0H
*     DEVR = RDRADDR;                   /* INPUT DEVICE ADDRESS       *
         L     @2,RDRADDR                                         0337
*     CALL IO;                          /* EXECUTE IO OPERATION       *
         BAL   @E,IO                                              0338
*     RETURN;                           /*                            *
         BC    15,@EL07                                           0339
* READCCW: GEN(CCW   X'02',INAREA,X'20',80); /* READ  CARD TO INAREA  *
READCCW  CCW   X'02',INAREA,X'20',80
         DS    0H
* END GET;                              /*                            *
@EL07    L     @D,4(0,@D)                                         0341
         LM    @E,@C,12(@D)                                       0341
         BCR   15,@E                                              0341
* END INPUT;                            /*                            *
* CONTROL:                              /* LOAD BUFFER ROUTINE        *
*     PROCEDURE;
CONTROL  STM   @E,@C,12(@D)                                       0343
         ST    @D,@SAV008+4                                       0343
         LA    @F,@SAV008                                         0343
         ST    @F,8(0,@D)                                         0343
         LR    @D,@F                                              0343
* /********************************************************************
* /*                                                                  *
* /*                                                                  *
* /* NAME                                                             *
* /*         CONTROL                                                  *
* /*                                                                  *
* /* FUNCTION                                                         *
* /*    THIS ROUTINE PERFORMS THE OPERATIONS REQUESTED IN THE JOB     *
* /*    CONTROL CARDS BY LOADING THE UCS AND FCB BUFFERS              *
* /*                                                                  *
* /* ENTRY POINTS                                                     *
* /*    CONTROL- THIS POINT IS CALLED BY THE INPUT ROUTINE            *
* /*                                                                  *
* /* INPUT                                                            *
* /*    INPUT TO THIS ROUTINE IS THE DATA AREAS DEFINED IN THE INIT   *
* /*    AND INPUT ROUTINES. NO DATA SETS ARE READ-FROM BY THIS        *
* /*    ROUTINE.                                                      *
* /*                                                                  *
* /* OUTPUT                                                           *
* /*    OUTPUT FROM THE CONTROL ROUTINE IS THE UCS AREA AFTER THIS    *
* /*    IMAGE WAS REREAD FROM THE BUFFER                              *
* /*                                                                  *
* /* EXTERNAL ROUTINES                                                *
* /*    IO                                                            *
* /*                                                                  *
* /* EXITS, NORMAL                                                    *
* /*    IF ALL CCWS SET UP BY THIS ROUTINE ARE COMPLETED WITHOUT AN   *
* /*    ERROR, THE OUTPUT ROUTINE IS CALLED.                          *
* /*                                                                  *
* /* EXITS, ERROR                                                     *
* /*    NONE                                                          *
* /*                                                                  *
* /* TABLE/WORK AREAS                                                 *
* /*    FOLDBIT                                                       *
* /*    UCSLOAD                                                       *
* /*    FCBING                                                        *
* /*                                                                  *
* /********************************************************************
*     RESTRICT (12);                    /* GPR12 USED AS THE BASE     *
*     GENERATE;
*
* REGISTER USAGE
*
CCWR     EQU   4                       ADDRESS OF CCW TO BE EXECUTED
COUNTR   EQU   5                       COUNT USED TO LIMIT THE LOOP
QUADR    EQU   6                       QUADRANT VALUE OF UCS BYTE
LOOPR    EQU   6                       LOOP CONTROL             Y00391
INDXR    EQU   7                       INDEX VALUE OF UCS BYTE
WRKR     EQU   8                       WORK REGISTER
UCSR     EQU   9                       ADDRESS OF UCS IMAGE
RTNR     EQU   14                      ADDRESS TO BE RETURNED TO
*
* DISPLACEMENT AND CONSTANT VALUES
*
EUCS     EQU   0                       EXTENDED UCS BUFFER
INC      EQU   1                       UCS IMAGE ADDRESS INCREMENT
ORL      EQU   1                       LENGTH OF DATA CHECK
ADDRLNTH EQU   3                       LENGTH OF PRINTER ADDRESS
PKLNTH   EQU   4                       LENGTH OF PACK
SGNBTS   EQU   4                       SIGN BITS TO BE SHIFTED OUT
CCWFLAGS EQU   12                      DISPLACEMENT OF CHAINING FLAG
BLKLNTH  EQU   15                      BLANK EXTENDED UCS BUFFER
SHFTLNTH EQU   26                      SHIFT LENGTH TO DEFINE QUADRANT
CLRLNTH  EQU   80                      EXTENDED UCS BUFFER LENGTH
IMGLNTH  EQU   432                     UCS IMAGE LENGTH
FOLDMASK EQU   X'01'                   FOLDBIT CHECK
CHAINBIT EQU   X'40'                   CHAIN BIT TO LINK CCWS
NLBLK    EQU   X'C0'                   NULL - BLANK CODE
LOUNITS  EQU   X'F0'                   TEST FOR 0 THRU 9        A50331
*
*
*
         SR    PARMR,PARMR             SET PARAMETER REG FOR PRINTER
         LA    DEVR,PTRADDR            GET PTR TO ADDRESS       Y00391
         LA    LOOPR,ADDRLNTH          INITIALIZE LOOP CONTROL  Y00391
*                                                               A50331
NXTCHR   TM    EUCS(DEVR),LOUNITS      IS IT 0 THRU 9           Y00391
         BO    INCR                    YES-GO CHECK NEXT CHAR   Y00391
         TR    EUCS(INC,DEVR),TBL      TRANSLATE A THRU F       Y00391
INCR     LA    DEVR,INC(DEVR)          INCREMENT TO NXT CHAR    Y00391
         BCT   LOOPR,NXTCHR            GO CHECK NEXT CHAR       Y00391
         PACK  FLWD(PKLNTH),PTRADDR(ADDRLNTH) CHANGE PRINTER @ FORMAT
         L     DEVR,FLWD               INITIALIZE PRINTER ADDRESS REG
         SRL   DEVR,SGNBTS             SHIFT OUT SIGN BITS
         LA    UCSR,UCSLOAD            LOAD ADDRESS OF USER-DEFINED IMG
         LA    WRKR,IMGLNTH(UCSR)      LOAD ADDRESS OF EXTENDED UCSB
         XC    EUCS(CLRLNTH,WRKR),EUCS(WRKR) CLEAR EXTENDED UCSB
         LA    WRKR,BLKLNTH(WRKR)      LOAD ADDRESS OF DATA CHECK FIELD
         OI    EUCS(WRKR),NLBLK        ALLOW NULL OR BLANK PRINTING
         LA    COUNTR,IMGLNTH          SET COUNTER TO IMAGE LENGTH
CNTRL050 SR    QUADR,QUADR             CLEAR QUADRANT REGISTER
         SR    INDXR,INDXR             CLEAR INDEX REGISTER
         IC    INDXR,EUCS(UCSR)        INSERT ONE UCS BYTE
         SLDL  QUADR,SHFTLNTH          SEPERATE QUADRANT AND INDEX
         SRL   INDXR,SHFTLNTH              (QUADR=QUADRANT INDXR=INDEX)
         LA    QUADR,QUADIND(QUADR)    LOAD QUADRANT INDICATOR ADDRESS
         LA    INDXR,EUCS(WRKR,INDXR)  LOAD DATA CHECK BYTE ADDRESS
         OC    EUCS(ORL,INDXR),EUCS(QUADR) OR DATA CHECK BYTE WITH QUAD
         LA    UCSR,INC(UCSR)          INCREMENT UCS IMAGE ADDRESS
         BCT   CNTR,CNTRL050           LOOP TILL ALL BYTES CHECKED
         TM    FOLDBIT,FOLDMASK        IF FOLD IS NOT REQUESTED
         BZ    CNTRL100                     GO TO CNTRL100
         OI    LDUCS+CCWFLAGS,CHAINBIT CHAIN FOLD CCW TO LOAD UCS CCW
CNTRL100 LA    CCWR,LDUCS              PLACE ADDRESS OF LOAD UCS CCW
         ST    CCWR,CAW                     INTO CHANNEL ADDRESS WORD
         BAL   RTNR,IO                 EXECUTE LOAD UCS CCW CHAIN
         LA    CCWR,LDFCB              PLACE ADDRESS OF LOAD FCB CCW
         ST    CCWR,CAW                     INTO CHANNEL ADDRESS WORD
         BAL   RTNR,IO                 EXECUTE LOAD FCB CCW CHAIN
         LA    CCWR,RDUCS              PLACE ADDRESS OF READ UCS CCW
         ST    CCWR,CAW                     INTO CHANNEL ADDRESS WORD
         BAL   RTNR,IO                 EXECUTE READ UCS CCW CHAIN
         B     OUTPUT                  PRINT VERIFICATION OF IMAGE
FLWD     DS    F                       FULLWORD USED FOR PACK
TBL      EQU   *-193                                            Y00391
         DC    X'FAFBFCFDFEFF'         TRANSLATE TABLE          Y00391
QUADIND  DC    X'80402010'             QUADRANT INDICATOR
LDUCS    CCW   X'73',0,X'40',1         BLOCK DATA CHECK
         CCW   X'FB',UCSLOAD,X'00',512 LOAD UCS BUFFER
         CCW   X'43',0,X'00',1         FOLD
LDFCB    CCW   X'63',FCBIMG,X'00',180  LOAD FORMS CONTROL BUFFER
RDUCS    CCW   X'0A',UCSLOAD,X'00',512 READ UCS BUFFER
         DS    0H
* END CONTROL;                          /*                            *
@EL08    L     @D,4(0,@D)                                         0346
         LM    @E,@C,12(@D)                                       0346
         BCR   15,@E                                              0346
* OUTPUT:                               /* PRINT VERIFICATION ROUTINE *
*     PROCEDURE;
OUTPUT   STM   @E,@C,12(@D)                                       0347
         ST    @D,@SAV009+4                                       0347
         LA    @F,@SAV009                                         0347
         ST    @F,8(0,@D)                                         0347
         LR    @D,@F                                              0347
* /********************************************************************
* /*                                                                  *
* /*                                                                  *
* /* NAME                                                             *
* /*         OUTPUT                                                   *
* /*                                                                  *
* /* FUNCTION                                                         *
* /*    THIS ROUTINE IS USED TO PRINT THE UCS AND FCB NAMES AND THE   *
* /*    UCS IMAGE ON THE 3211 FOR VERIFICATION.                       *
* /*                                                                  *
* /* ENTRY POINTS                                                     *
* /*    OUTPUT- THIS POINT IS CALLED BY THE CONTROL ROUTINE           *
* /*                                                                  *
* /* INPUT                                                            *
* /*    INPUT TO THIS ROUTINE IS THE DATA AREAS DEFINED IN THE INPUT  *
* /*    ROUTINE.  NO DATA SETS ARE READ BY THIS ROUTINE.              *
* /*                                                                  *
* /* OUTPUT                                                           *
* /*    OUTPUT FROM THIS ROUTINE IS A DATA SET TO THE PRINTER. THIS   *
* /*    WILL CONTAIN A MESSAGE OF THE UCSNAME AND FCBNAME AND AN      *
* /*    EIGHT LINE PRINTOUT OF THE UCS IMAGE AS IT APPEARS ON THE UCS *
* /*    STATEMENT OF THE JOB CONTROL CARDS.                           *
* /*                                                                  *
* /* EXTERNAL ROUTINES                                                *
* /*    IO                                                            *
* /*                                                                  *
* /* EXITS, NORMAL                                                    *
* /*    IF ALL CCWS SET UP BY THIS ROUTINE ARE COMPLETED WITHOUT AN   *
* /*    ERROR, THE WAIT ROUTINE IS CALLED TO END THE UTILITY.         *
* /*                                                                  *
* /* EXITS, ERROR                                                     *
* /*    NONE                                                          *
* /*                                                                  *
* /* TABLES/WORK AREAS                                                *
* /*    UCSNMST                                                       *
* /*    FCBNMST                                                       *
* /*    UCSLOAD                                                       *
* /*                                                                  *
* /********************************************************************
*     RESTRICT (12);                    /* GPR12 USED AS THE BASE     *
*     GENERATE;
*
* REGISTER USAGE
*
PARAMR   EQU   1                       PARAMETER REGISTER
POINTR   EQU   3                       POINTER REGISTER TO UCS LOAD
CPAR     EQU   4                       CHANNEL PROGRAM ADDRESS
CNTR     EQU   5                       COUNT USED TO LIMIT THE LOOP
RETURNR  EQU   14                      ADDRESS TO BE RETURNED TO
*
* DISPLACEMENT AND CONSTANT VALUES
*
DISZ     EQU   0                       DISPLACEMENT OF ZERO
PTLN2    EQU   2                       COLUMN 2 OF PRINT LINE
CDLNTH   EQU   3                       ERROR CODE LENGTH
LPLNTH   EQU   7                       LENGTH OF LOOP TO PRINT UCS
PTLN7    EQU   7                       COLUMN 7 OF PRINT LINE
MOVELNTH EQU   8                       LENGTH OF UCS AND FCB NAMES
UCSNM    EQU   24                      DISPLACEMENT OF UCSNAME
MVLN2    EQU   40                      LENGTH OF LAST UCS IMAGE LINE
FCBNM    EQU   56                      DISPLACEMENT OF FCBNAME
MVLN     EQU   56                      LENGTH OF UCS IMAGE LINE
CLRL     EQU   131                     LENGTH OF CLEAR PRINT LINE
BLK      EQU   X'40'                   BLANK VALUE FOR CLEARING
         SR    PARAMR,PARAMR           SET PARAMETER REG FOR PRINTER
         MVC   PTLN+UCSNM(MOVELNTH),UCSNMST INSERT UCSNAME INTO PTLN
         MVC   PTLN+FCBNM(MOVELNTH),FCBNMST INSERT FCBNAME INTO PTLN
         LA    CPAR,NMCCW              LOAD ADDRESS OF CCW TO PUT NAMES
         ST    CPAR,CAW                STORE CCW ADDRESS IN CAW
         BAL   RETURNR,IO              EXECUTE PRINT NAMES CCW CHAIN
         LA    CNTR,LPLNTH             LOAD LENGTH OF LOOP IN COUNTER
         LA    POINTR,UCSLOAD          LOAD ADDRESS OF UCS IMAGE
OUT100   MVI   PTLN,BLK                CLEAR FIRST COLUMN OF PRINT LINE
         MVC   PTLN+PTLN2(CLRL),PTLN   CLEAR THE REST OF PRINT LINE
         MVC   PTLN+PTLN7(MVLN),DISZ(POINTR) MOVE 56 CHARACTERS OF UCS
         LA    CPAR,CCWUCS             PLACE ADDRESS OF PRINT UCS CCW
         ST    CPAR,CAW                     INTO CHANNEL ADDRESS WORD
         BAL   RETURNR,IO              EXECUTE PRINT UCS CCW
         LA    POINTR,MVLN(POINTR)     INCREASE POINTER BY MOVE LENGTH
         BCT   CNTR,OUT100             IF MORE RETURN TO PRINT NEXT ONE
         MVI   PTLN,BLK                CLEAR FIRST COLUMN OF PRINT LINE
         MVC   PTLN+PTLN2(CLRL),PTLN   CLEAR THE REST OF PRINT LINE
         MVC   PTLN+PTLN7(MVLN2),DISZ(POINTR) MOVE 40 CHARACTERS OF UCS
         LA    CPAR,CCWUCS             PLACE ADDRESS OF PRINT UCS CCW
         ST    CPAR,CAW                     INTO CHANNEL ADDRESS WORD
         BAL   RETURNR,IO              EXECUTE PRINT UCS CCW
         LA    CPAR,CCWEND             PLACE ADDRESS OF END CCW
         ST    CPAR,CAW                     INTO CHANNEL ADDRESS WORD
         BAL   RETURNR,IO              EXECUTE END CCW CHAIN
         MVC   ERRCODE(CDLNTH),CB01    MOVE CODE FOR END OF JOB
         B     WAIT                    END THE UTILITY
NMCCW    CCW   X'11',PTLN,X'00',132    PRINT NAMES AND SPACE TWO LINES
CCWUCS   CCW   X'09',PTLN,X'00',132    PRINT UCS LINE AND SPACE A LINE
CCWEND   CCW   X'13',0,X'40',1         SPACE ONE LINE
         CCW   X'89',ENDMESS,X'00',132 PRINT END OF JOB MESSAGE
PTLN     DC    CL132'                UCSNAME=                        FCX
               BNAME=  '
ENDMESS  DC    CL132'       NORMAL END OF JOB   '
         DS    0H
* END OUTPUT;                           /*                            *
@EL09    L     @D,4(0,@D)                                         0350
         LM    @E,@C,12(@D)                                       0350
         BCR   15,@E                                              0350
* WAIT:                                 /* END THE UTILITY ROUTINE    *
*     PROCEDURE OPTIONS(NOSAVEAREA,     /* DONT ESTABLISH REG 13      *
*                       DONTSAVE);      /* DONT SAVE ANY REGISTERS    *
WAIT     EQU   *                                                  0351
* /********************************************************************
* /*                                                                  *
* /*                                                                  *
* /* NAME                                                             *
* /*         WAIT                                                     *
* /*                                                                  *
* /* FUNCTION                                                         *
* /*    THIS ROUTINE TERMINATES THE UTILITY BY LOADING A WAIT PSW WITH*
* /*    THE ERROR CODE IN THE ADDRESS PORTION.                        *
* /*                                                                  *
* /* ENTRY POINTS                                                     *
* /*    WAIT IS THE ONLY ENTRY POINT TO THIS ROUTINE.                 *
* /*                                                                  *
* /* INPUT                                                            *
* /*    NONE                                                          *
* /*                                                                  *
* /* OUTPUT                                                           *
* /*    NONE                                                          *
* /*                                                                  *
* /* EXTERNAL ROUTINES                                                *
* /*    NONE                                                          *
* /*                                                                  *
* /* EXITS, NORMAL                                                    *
* /*    NORMAL EXIT FROM THE WAIT ROUTINE IS BY LOADING A NEW PSW.    *
* /*                                                                  *
* /* EXITS, ERROR                                                     *
* /*    NONE                                                          *
* /*                                                                  *
* /* TABLES/WORK AREAS                                                *
* /*    ERRCODE                                                       *
* /*    WAITPSW                                                       *
* /*                                                                  *
* /********************************************************************
*     RESTRICT (12);                    /* GPR12 USED AS THE BASE     *
*     GENERATE;
*
* DISPLACEMENT AND CONSTANT VALUES
*
ERCDLNTH EQU   3                       ERROR CODE LENGTH
INSTA    EQU   5                       INSTRUCTION ADDRESS
         MVC   WAITPSW+INSTA(ERCDLNTH),ERRCODE PUT ERROR CODE IN PSW
         LPSW  WAITPSW                 TERMINATE THE PROGRAM
         DS    0H
* END WAIT;                             /*                            *
@EL10    BCR   15,@E                                              0354
* IO:                                   /* PREFORM I/O OPERATIONS     *
*     PROCEDURE;
IO       STM   @E,@C,12(@D)                                       0355
         ST    @D,@SAV011+4                                       0355
         LA    @F,@SAV011                                         0355
         ST    @F,8(0,@D)                                         0355
         LR    @D,@F                                              0355
* /********************************************************************
* /*                                                                  *
* /*                                                                  *
* /* NAME                                                             *
* /*         IO                                                       *
* /*                                                                  *
* /* FUNCTION                                                         *
* /*    THIS ROUTINE WILL HANDLE ALL INPUT AND OUTPUT FOR THE UTILITY *
* /*    BY STARTING THE CCW CHAIN AND CHECKING FOR NORMAL COMPLETION. *
* /*                                                                  *
* /* ENTRY POINTS                                                     *
* /*    IO- THIS POINT MAY BE CALLED FROM THE INPUT, CONTROL, OR      *
* /*        OUTPUT ROUTINE.                                           *
* /*                                                                  *
* /* INPUT                                                            *
* /*    INPUT TO THE IO ROUTINE IS THE CONTENTS OF GPR2 WHICH         *
* /*    CONTAINS THE ADDRESS OF THE DEVICE TO BE STARTED.             *
* /*                                                                  *
* /* OUTPUT                                                           *
* /*    NONE                                                          *
* /*                                                                  *
* /* EXTERNAL ROUTINES                                                *
* /*    NONE                                                          *
* /*                                                                  *
* /* EXITS, NORMAL                                                    *
* /*    UPON NORMAL COMPLETION CONTROL IS RETURNED TO THE CALLING     *
* /*    PROGRAM(INPUT,CONTROL,OUTPUT) VIA REGISTER 14.                *
* /*                                                                  *
* /* EXITS, ERROR                                                     *
* /*    IF AN ERROR OCCURS DURING THE IO OPERATION THE WAIT ROUTINE   *
* /*    IS CALLED TO TERMINATE THE UTILITY.                           *
* /*                                                                  *
* /* TABLES/WORK AREAS                                                *
* /*    ERROR CODE                                                    *
* /*    CORE LOCATION 2 TO 7                                          *
* /*                                                                  *
* /********************************************************************
*     RESTRICT (12);                    /* GPR12 USED AS THE BASE     *
*     GENERATE;
*
* REGISTER USAGE
*
CPR      EQU   4                       ADDRESS OF CHANNEL PROGRAM
*
* DISPLACEMENT AND CONSTANT VALUES
*
DEVDIS   EQU   0                       DISPLACEMENT OF DEVICE ADDRESS
NOTOP    EQU   1                       NOT OPERATIONAL
BUSY     EQU   2                       CHANNEL - DEVICE BUSY
LC2      EQU   2                       LOW CORE LOCATION - 2
CODE     EQU   3                       PSW INTERRUPTION CODE
ERLNTH   EQU   3                       ERROR CODE LENGTH
LC3      EQU   3                       LOW CORE LOCATION - 3
CSWST    EQU   4                       CHANNEL STATUS WORD STORED
STAT1    EQU   4                       STATUS BYTE 1
DIS5     EQU   5                       DISPLACEMENT OF PSW ADDRESS
STAT2    EQU   5                       STATUS BYTE 2
SNSLNTH  EQU   6                       LENGTH OF DEVICE SENSE
UE       EQU   X'01'                   UNIT EXCEPTION
UC       EQU   X'02'                   UNIT CHECK
DE       EQU   X'04'                   DEVICE END
CE       EQU   X'0F'                   CHANNEL ERROR
CHANER   EQU   X'0F'                   CHANNEL ERROR CODE FOR SEREP
NODEVEND EQU   X'1F'                   NO-DEVICE-END CODE FOR SEREP
CUE      EQU   X'20'                   CONTROL UNIT END
DNR      EQU   X'40'                   DEVICE NOT READY SENSE BIT
         LTR   PARMR,PARMR             IF THIS OPERATION IS FOR THE
         BZ    IO100                        PRINTER GO TO IO100
         MVC   ERRCODE(ERLNTH),RDRCD   SET UP ERROR CODE FOR READER
         B     IO200                   GO TO IO200
IO100    MVC   ERRCODE(ERLNTH),PTRCD   SET UP ERROR CODE FOR PRINTER
         SSM   DISABLE                 DISABLE INTERRUPTS        A51547
IO200    SIO   DEVDIS(DEVR)            INITIATE I/O OPERATION
         BC    BUSY,IO200              BUSY - REISSUE COMMAND
         BC    NOTOP,IO400             NOT OPERATIONAL - SET ERROR
         BC    CSWST,IO320             CSW STORED - CHECK THE CSW
IO300    TIO   DEVDIS(DEVR)            TEST I/O OPERATION
         BC    BUSY,IO300              BUSY - RETRY TEST
         BC    NOTOP,IO400             NOT OPERATIONAL - SET ERROR
         BC    CSWST,IO350             CSW STORED - CHECK THE CSW
         TM    CSW+STAT1,DE            IF NO DEVICE END
         BZ    IO800                        SET AN ERROR CODE
         SSM   ENABLE                  ALLOW INTERRUPTS          A51547
         B     IO990                   RETURN TO CALLING ROUTINE
IO320    TM    CSW+STAT1,UC            IF A UNIT CHECK
         BNZ   IO600                        OBTAIN THE SENSE
         TM    CSW+STAT2,CE            IF A CHANNEL ERROR
         BNZ   IO700                        SET CHANNEL ERROR MESSAGE
         TM    CSW+STAT1,CUE           IF CONTROL UNIT END
         BNZ   IO200                        REISSUE COMMAND
         TM    CSW+STAT1,UE            IF UNIT EXCEPTION
         BNZ   IO390                        CONTROL STATEMENT ERROR
         B     IO300                   OTHER CONDITIONS - CONTINUE
IO350    TM    CSW+STAT1,UC            IF A UNIT CHECK
         BNZ   IO600                        OBTAIN THE SENSE
         TM    CSW+STAT2,CE            IF A CHANNEL ERROR
         BNZ   IO700                        SET CHANNEL ERROR MESSAGE
         TM    CSW+STAT1,UE            IF UNIT EXCEPTION
         BNZ   IO390                        CONTROL STATEMENT ERROR
         B     IO300                   OTHER CONDITIONS - RETEST
IO390    MVC   ERRCODE(ERLNTH),CB02    SET CONTROL STATEMENT ERROR
         B     WAIT                    TERMINATE THE PROGRAM
IO400    OC    ERRCODE(ERLNTH),CB11    SET DEVICE NOT ON LINE MESSAGE
         B     WAIT                    TERMINATE THE PROGRAM
IO500    OC    ERRCODE(ERLNTH),CB12    SET DEVICE NOT READY MESSAGE
         B     WAIT                    TERMINATE THE PROGRAM
IO600    LTR   PARMR,PARMR             IF THIS OPERATION IS FOR THE
         BZ    IO610                        PRINTER GO TO IO610
         LA    CPR,RDRSNS              LOAD READER SENSE CCW
         B     IO620                   GO TO IO620
IO610    LA    CPR,PTRSNS              LOAD PRINTER SENSE CCW
IO620    ST    CPR,CAW                 STORE SENSE CCW IN CAW
IO630    SIO   DEVDIS(DEVR)            START SENSE CCW
         BC    BUSY,IO630              BUSY - RESTART
IO640    TIO   DEVDIS(DEVR)            TEST SENSE CCW
         BC    BUSY,IO640              BUSY RETEST
         LTR   PARMR,PARMR             IF THIS OPERATION IS FOR THE
         BZ    IO650                        PRINTER GO TO IO650
         TM    LC3,DNR                 IF THE READER IS NOT READY
         BNZ   IO500                        GO TO IO500
         B     IO660                   GO TO IO660
IO650    TM    LC2,DNR                 IF THE PRINTER IS NOT READY
         BNZ   IO500                        GO TO IO500
IO660    OC    ERRCODE(ERLNTH),CB13    SET DEVICE UNIT CHECK MESSAGE
         B     WAIT                    TERMINATE THE PROGRAM
IO700    OC    ERRCODE(ERLNTH),CB14    SET CHANNEL ERROR MESSAGE
         MVI   MCNPSW+CODE,CHANER      INDICATE CHANNEL ERROR TO SEREP
         B     IO900                   GO TO IO900
IO800    OC    ERRCODE(ERLNTH),CB15    SET NO DEVICE END MESSAGE
         MVI   MCNPSW+CODE,NODEVEND    INDICATE NO-DEVICE-END TO SEREP
         OC    EXTOPSW(SNSLNTH),EXTOPSW CLEAR SENSE AREA
         LTR   PARMR,PARMR             IF THIS OPERATION IS FOR THE
         BZ    IO810                        PRINTER GO TO IO810
         LA    CPR,RDRSNS2             LOAD READER SENSE CCW
         B     IO820                   GET SENSE
IO810    LA    CPR,PTRSNS2             LOAD PRINTER SENSE CCW
IO820    ST    CPR,CAW                 STORE SENSE CCW IN CAW
IO830    SIO   DEVDIS(DEVR)            START SENSE CCW
         BC    BUSY,IO830              BUSY - RESTART
IO840    TIO   DEVDIS(DEVR)            TEST SENSE CCW
         BC    BUSY,IO840              BUSY - RETEST
IO900    MVC   WAITPSW+DIS5(ERLNTH),ERRCODE PUT ERROR CODE IN PSW
         LPSW  WAITPSW                 TERMINATE THE PROGRAM
RDRCD    DC    X'000000'               READER ERROR CODE FORMAT
PTRCD    DC    X'000008'               PRINTER ERROR CODE FORMAT
RDRSNS   CCW   X'04',LC3,X'00',1       CARD READER SENSE CCW
PTRSNS   CCW   X'04',LC2,X'00',6       PRINTER SENSE CCW
RDRSNS2  CCW   X'04',EXTOPSW,X'00',1   CARD READER SENSE CCW FOR SEREP
PTRSNS2  CCW   X'04',EXTOPSW,X'00',6   PRINTER SENSE CCW FOR SEREP
DISABLE  DC    X'00'                   PREVENT INTERRUPTS MASK   A51547
ENABLE   DC    X'FE'                   ALLOW INTERRUPTS MASK     A51547
         DS    0H
* IO990: RETURN;                        /* RETURN TO CALLING PROGRAM  *
* END IO;                               /*                            *
@EL11    L     @D,4(0,@D)                                         0359
         LM    @E,@C,12(@D)                                       0359
         BCR   15,@E                                              0359
* END ICAPRTBL;                         /*                            *
@DATA1   EQU   *
@0       EQU   00                  EQUATES FOR REGISTERS 0-15
@1       EQU   01
@2       EQU   02
@3       EQU   03
@4       EQU   04
@5       EQU   05
@6       EQU   06
@7       EQU   07
@8       EQU   08
@9       EQU   09
@A       EQU   10
@B       EQU   11
@C       EQU   12
@D       EQU   13
@E       EQU   14
@F       EQU   15
@D1      DC    H'5'
@D2      DC    H'1'
@D3      DC    H'16'
@D4      DC    H'3'
@D5      DC    H'8'
@D6      DC    H'40'
@D7      DC    H'56'
@D8      DC    H'15'
@D9      DC    H'71'
@D10     DC    H'4'
@D11     DC    H'2'
@D12     DC    H'180'
@D13     DC    H'6'
@D14     DC    H'12'
@D15     DC    H'10'
@D16     DC    H'-1'
@MVC     MVC   0(1,@A),0(@E)
         DS    0F
@X11     DC    X'00000000'
         DS    0D
@DATA    EQU   *
CB01     EQU   *                   3 BYTE(S)
         DC    X'000B01'
CB02     EQU   *                   3 BYTE(S)
         DC    X'000B02'
CB03     EQU   *                   3 BYTE(S)
         DC    X'000B03'
CB04     EQU   *                   3 BYTE(S)
         DC    X'000B04'
CB05     EQU   *                   3 BYTE(S)
         DC    X'000B05'
CB06     EQU   *                   3 BYTE(S)
         DC    X'000B06'
CB07     EQU   *                   3 BYTE(S)
         DC    X'000B07'
CB0A     EQU   *                   3 BYTE(S)
         DC    X'000B0A'
CB0B     EQU   *                   3 BYTE(S)
         DC    X'000B0B'
CB0C     EQU   *                   3 BYTE(S)
         DC    X'000B0C'
CB11     EQU   *                   3 BYTE(S)
         DC    X'000B11'
CB12     EQU   *                   3 BYTE(S)
         DC    X'000B12'
CB13     EQU   *                   3 BYTE(S)
         DC    X'000B13'
CB14     EQU   *                   3 BYTE(S)
         DC    X'000B14'
CB15     EQU   *                   3 BYTE(S)
         DC    X'000B15'
RDRADDR  EQU   @DATA+00000048      4 BYTE(S) ON WORD
         ORG   @DATA+00000056
WAITPSW  EQU   *                   8 BYTE(S) ON DWORD
         DC    X'0006000000000000'
UCSLOAD  EQU   @DATA+00000064      512 BYTE(S)
FCBIMG   EQU   @DATA+00000576      180 BYTE(S)
         ORG   FCBIMG+00000000
A00000   EQU   *                   180*1 BYTE(S)
         DC    00180X'00'
FOLDBIT  EQU   *                   8 BIT(S) ON BYTE
         DC    X'00'
PTRADDR  EQU   @DATA+00000757      3 BYTE(S)
         ORG   @DATA+00000760
UCSNMST  EQU   *                   9 BYTE(S)
         DC    C' '
         DC    00008C' '
FCBNMST  EQU   *                   9 BYTE(S)
         DC    C' '
         DC    00008C' '
ERRCODE  EQU   @DATA+00000778      3 BYTE(S)
UTPSW    EQU   @DATA+00000784      8 BYTE(S) ON DWORD
         ORG   UTPSW+00000000
SYSMASK  EQU   *                   8 BIT(S) ON BYTE
         DC    X'FE'
KEYAMWP  EQU   *                   8 BIT(S) ON BYTE
         DC    B'00000100'
INTCODE  EQU   *                   16 BIT(S) ON BYTE
         DC    X'0000'
PGMMASK  EQU   *                   8 BIT(S) ON BYTE
         DC    X'00'
INSTADDR EQU   *                   3  BYTE  POINTER ON WORD+1
         DC    AL3(INIT200)
INITSAVE EQU   @DATA+00000792      72 BYTE(S) ON WORD
RDRR     EQU   00000011            FULLWORD INTEGER REGISTER
BASER    EQU   00000012            FULLWORD INTEGER REGISTER
SAVER    EQU   00000013            FULLWORD INTEGER REGISTER
@SAV003  EQU   @DATA+00000864      72 BYTE(S) ON WORD
FLAG     EQU   @DATA+00000936      8 BIT(S) ON BYTE
JOBFLAG  EQU   FLAG+00000000       1 BIT(S)
UCSFLAG  EQU   FLAG+00000000       1 BIT(S)
FCBFLAG  EQU   FLAG+00000000       1 BIT(S)
DFNFLAG  EQU   FLAG+00000000       1 BIT(S)
ENDFLAG  EQU   FLAG+00000000       1 BIT(S)
FLAGDFN  EQU   @DATA+00000937      8 BIT(S) ON BYTE
ADDRFLAG EQU   FLAGDFN+00000000    1 BIT(S)
FOLDFLAG EQU   FLAGDFN+00000000    1 BIT(S)
FLAGFCB  EQU   @DATA+00000938      8 BIT(S) ON BYTE
LPIFLAG  EQU   FLAGFCB+00000000    1 BIT(S)
FEFLAG   EQU   FLAGFCB+00000000    1 BIT(S)
LNCHFLAG EQU   FLAGFCB+00000000    1 BIT(S)
         ORG   @DATA+00000939
CJOB     EQU   *                   3 BYTE(S)
         DC    C'JOB'
CDFN     EQU   *                   3 BYTE(S)
         DC    C'DFN'
CUCS     EQU   *                   3 BYTE(S)
         DC    C'UCS'
CFCB     EQU   *                   3 BYTE(S)
         DC    C'FCB'
CEND     EQU   *                   3 BYTE(S)
         DC    C'END'
CADDR    EQU   *                   4 BYTE(S)
         DC    C'ADDR'
CFOLD    EQU   *                   4 BYTE(S)
         DC    C'FOLD'
CY       EQU   *                   1 BYTE(S)
         DC    C'Y'
CN       EQU   *                   1 BYTE(S)
         DC    C'N'
CFORMEND EQU   *                   7 BYTE(S)
         DC    C'FORMEND'
CLNCH    EQU   *                   4 BYTE(S)
         DC    C'LNCH'
CLPI     EQU   *                   3 BYTE(S)
         DC    C'LPI'
C6       EQU   *                   1 BYTE(S)
         DC    C'6'
C8       EQU   *                   1 BYTE(S)
         DC    C'8'
BLANK    EQU   *                   1 BYTE(S)
         DC    X'40'
COMMA    EQU   *                   1 BYTE(S)
         DC    C','
RPAREN   EQU   *                   1 BYTE(S)
         DC    C')'
LPAREN   EQU   *                   1 BYTE(S)
         DC    C'('
UCSSEQ   EQU   @DATA+00000984      8 BIT(S) ON BYTE
MVLNTH   EQU   @DATA+00000985      8 BIT(S) ON BYTE
FCBSAVE  EQU   @DATA+00000988      FULLWORD POINTER
JCLSTRT  EQU   00000000            FULLWORD INTEGER
FCBJCL   EQU   @DATA+00000992      300 BYTE(S)
         ORG   @DATA+00001292
LPI8     EQU   *                   8 BIT(S) ON BYTE
         DC    X'10'
CNT      EQU   @DATA+00001294      HALFWORD INTEGER
INAREA   EQU   @DATA+00001296      80 BYTE(S)
         ORG   @DATA+00001376
CLRBYTE  EQU   *                   8 BIT(S) ON BYTE
         DC    X'00'
NUM      EQU   *                   16 BYTE(S)
         DC    C'0123456789ABCDEF'
ENDBIT   EQU   *                   8 BIT(S) ON BYTE
         DC    X'10'
LNNO     EQU   @DATA+00001396      FULLWORD INTEGER
CHNO     EQU   @DATA+00001400      4 BYTE(S)
         ORG   @DATA+00001404
TABLE    EQU   *                   10 BYTE(S)
         DC    C'0123456789'
         ORG   @DATA+00001416
DBWD     EQU   *                   8 BYTE(S) ON DWORD
         DC    X'0000000000000000'
FWORD    EQU   @DATA+00001424      4 BYTE(S) ON WORD
CR       EQU   00000002            FULLWORD POINTER REGISTER
COL      EQU   00000000            7 BYTE(S)
PR       EQU   00000003            FULLWORD POINTER REGISTER
IMAGE    EQU   00000000            56 BYTE(S)
WR       EQU   00000004            FULLWORD POINTER REGISTER
DTST     EQU   00000000            FULLWORD INTEGER
I        EQU   @DATA+00001428      FULLWORD INTEGER
J        EQU   @DATA+00001432      FULLWORD INTEGER
LENGTH   EQU   @DATA+00001436      FULLWORD INTEGER
@SAV007  EQU   @DATA+00001440      72 BYTE(S) ON WORD
PARMR    EQU   00000001            FULLWORD INTEGER REGISTER
DEVR     EQU   00000002            FULLWORD INTEGER REGISTER
@SAV008  EQU   @DATA+00001512      72 BYTE(S) ON WORD
@SAV009  EQU   @DATA+00001584      72 BYTE(S) ON WORD
@SAV011  EQU   @DATA+00001656      72 BYTE(S) ON WORD
         ORG   @DATA
         DS    00001728C
@TEMPS   DS    0F
@DATEND  EQU   *
@9D5     EQU   INPUT730
IO990    EQU   @EL11
         END   ICAPRTBL
