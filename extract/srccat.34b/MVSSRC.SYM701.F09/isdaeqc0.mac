         TITLE 'EQUIPMENT CHECK AND DATA CHECK REPORT ACCUMULATOR ROUTI*
               INE      '
ISDAEQC0 CSECT ,                                                   0001
@MAINENT DS    0H                                                  0001
         USING *,@15                                               0001
         B     @PROLOG                                             0001
         DC    AL1(8)                                              0001
         DC    C'ISDAEQC0'                                         0001
         DROP  @15
@PROLOG  STM   @14,@12,12(@13)                                     0001
         BALR  @12,0                                               0001
@PSTART  DS    0H                                                  0001
         USING @PSTART,@12                                         0001
         L     @00,@SIZDATD                                        0001
         ISDAGSPC R,LV=(0)
         LR    @11,@01                                             0001
         USING @DATD,@11                                           0001
         ST    @13,@SA00001+4                                      0001
         LM    @00,@01,20(@13)                                     0001
         ST    @11,8(,@13)                                         0001
         LR    @13,@11                                             0001
         MVC   @PC00001(4),0(@01)                                  0001
*                                                                  0021
*   /*****************************************************************/
*   /*                                                               */
*   /* PROGRAM START.                                                */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0021
*   CVTPTR=WORKPTR;                 /* SET LOCAL PTR TO SDACVT.    0021
*                                                            @Y30LB51*/
         L     @10,@PC00001                                        0021
         L     CVTPTR,WORKPTR(,@10)                                0021
*   LPARMPTR=PARMPTR;               /* SET LOCAL PTR TO SDAPARMS.  0022
*                                                            @Y30LB51*/
         L     LPARMPTR,PARMPTR(,CVTPTR)                           0022
*   EQCRETCD=0;                     /* INITIALIZE RETURN CODE.     0023
*                                                            @Y30LB51*/
         SLR   @10,@10                                             0023
         LR    EQCRETCD,@10                                        0023
*   EQCWKPTR=0;                     /* INITIALIZE WORK AREA PTR.   0024
*                                                            @Y30LB51*/
         LR    EQCWKPTR,@10                                        0024
*   IF EQC00PTR=0 THEN              /* IF THIS IS FIRST ENTRY      0025
*                                                            @Y30LB51*/
         C     @10,EQC00PTR(,CVTPTR)                               0025
         BNE   @RF00025                                            0025
*     DO;                           /* GET SPACE FOR WORK AREA AND 0026
*                                      TABLE.                @Y30LB51*/
*       CALL FIRSTENT;              /* GO GET SPACE.         @Y30LB51*/
         BAL   @14,FIRSTENT                                        0027
*       IF EQCRETCD^=0 THEN         /* IF SPACE WAS NOT AVAILABLE  0028
*                                                            @Y30LB51*/
         LTR   EQCRETCD,EQCRETCD                                   0028
         BZ    @RF00028                                            0028
*         DO;                       /* FREE ANY SPACE SECURED.     0029
*                                                            @Y30LB51*/
*           CALL FREECORE;          /* GO FREE THE SPACE     @Y30LB51*/
         BAL   @14,FREECORE                                        0030
*           RETURN CODE(EQCRETCD);  /* AND RETURN.           @Y30LB51*/
         L     @13,4(,@13)                                         0031
         L     @00,@SIZDATD                                        0031
         LR    @01,@11                                             0031
         ISDAFSPC R,LV=(0),A=(1)
         LR    @15,@05                                             0031
         L     @14,12(,@13)                                        0031
         LM    @00,@12,20(@13)                                     0031
         BR    @14                                                 0031
*         END;                      /*                       @Y30LB51*/
*       ELSE                                                       0033
*         ;                         /* SPACE WAS SECURED.    @Y30LB51*/
@RF00028 DS    0H                                                  0034
*     END;                          /*                       @Y30LB51*/
*   ELSE                            /* NOT FIRST ENTRY.      @Y30LB51*/
*     EQCWKPTR=EQC00PTR;            /* INITIALIZE PTR TO WORK AREA.
*                                                            @Y30LB51*/
         B     @RC00025                                            0035
@RF00025 L     EQCWKPTR,EQC00PTR(,CVTPTR)                          0035
*   LOGPTR=DATAPTR;                 /* SET LOCAL PTR TO RECORD.    0036
*                                                            @Y30LB51*/
@RC00025 MVC   LOGPTR(4,EQCWKPTR),DATAPTR(CVTPTR)                  0036
*   SENSEPTR=SDATAPTR;              /* SET LOCAL PTR TO SENSE AREA.
*                                                            @Y30LB51*/
         MVC   SENSEPTR(4,EQCWKPTR),SDATAPTR(CVTPTR)               0037
*   LPARMPTR=PARMPTR;               /* SET LOCAL PTR TO SDAPARMS.  0038
*                                                            @Y30LB51*/
         L     LPARMPTR,PARMPTR(,CVTPTR)                           0038
*   SSIDSAVE=''B;                   /* ZERO OUT SAVE AREAS.  @Y30LB51*/
         XC    SSIDSAVE(2,EQCWKPTR),SSIDSAVE(EQCWKPTR)             0039
*   FSCSYSSV=''B;                   /*                       @Y30LB51*/
         XC    FSCSYSSV(2,EQCWKPTR),FSCSYSSV(EQCWKPTR)             0040
*   FSCSAVE1=''B;                   /*                       @Y30LB51*/
         XC    FSCSAVE1(4,EQCWKPTR),FSCSAVE1(EQCWKPTR)             0041
*   FSCSAVE2=''B;                   /*                       @Y30LB51*/
         XC    FSCSAVE2(4,EQCWKPTR),FSCSAVE2(EQCWKPTR)             0042
*   EQCSW=0;                        /* RESET ALL SWITCHES.   @Y30LB51*/
         SLR   @10,@10                                             0043
         STH   @10,EQCSW(,EQCWKPTR)                                0043
*   CALL RECTYPE;                   /* DETERMINE RECORD TYPE.      0044
*                                                            @Y30LB51*/
         BAL   @14,RECTYPE                                         0044
*   IF EQCRETCD=0 THEN              /* IF RECORD IS ACCEPTED @Y30LB51*/
         LTR   EQCRETCD,EQCRETCD                                   0045
         BNZ   @RF00045                                            0045
*     CALL PROCREC;                 /* PUT RECORD IN ACCUMULATOR.  0046
*                                                            @Y30LB51*/
         BAL   @14,PROCREC                                         0046
*   ELSE                            /* RECORD NOT ACCEPTED.  @Y30LB51*/
*     IF EQCRETCD=BUFFREC THEN      /* IF BUFFERED LOG RECORD      0047
*                                                            @Y30LB51*/
         B     @RC00045                                            0047
@RF00045 CH    EQCRETCD,@CH00082                                   0047
         BNE   @RF00047                                            0047
*       EQCRETCD=0;                 /* RESET RETURN CODE.    @Y30LB51*/
         SLR   EQCRETCD,EQCRETCD                                   0048
*     ELSE                                                         0049
*       ;                           /* NOT BUFFERED LOG RECORD.    0049
*                                                            @Y30LB51*/
@RF00047 DS    0H                                                  0050
*   RETURN CODE(EQCRETCD);          /*                       @Y30LB51*/
@RC00045 L     @13,4(,@13)                                         0050
         L     @00,@SIZDATD                                        0050
         LR    @01,@11                                             0050
         ISDAFSPC R,LV=(0),A=(1)
         LR    @15,@05                                             0050
         L     @14,12(,@13)                                        0050
         LM    @00,@12,20(@13)                                     0050
         BR    @14                                                 0050
*FIRSTENT:                                                         0051
*   PROC OPTIONS(SAVE(14));         /*                       @Y30LB51*/
*                                                                  0051
@EL00001 L     @13,4(,@13)                                         0051
@EF00001 L     @00,@SIZDATD                                        0051
         LR    @01,@11                                             0051
         ISDAFSPC R,LV=(0),A=(1)
@ER00001 LM    @14,@12,12(@13)                                     0051
         BR    @14                                                 0051
FIRSTENT ST    @14,@SA00002                                        0051
*   /*****************************************************************/
*   /*                                                               */
*   /* THIS ROUTINE WILL OBTAIN SPACE FOR THE WORK AREA AND FOR THE  */
*   /* ACCUMULATOR TABLE. THE ISDAGET1 ENTRY WILL BE USED TO OBTAIN  */
*   /* THE SPACE FOR THE WORK AREA AND THE ISDAGET0 ENTRY WILL BE    */
*   /* USED TO OBTAIN THE SPACE FOR THE ACCUMULATOR TABLE. EACH TABLE*/
*   /* WILL BE INITIALIZED.                                          */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0052
*   SPNO='05'X;                     /* GET THE SUBPOOL NUMBER.     0052
*                                                            @Y30LB51*/
         MVI   SPNO(CVTPTR),X'05'                                  0052
*   CORELEN=LENGTH(EQCWORK);        /* GET WORK AREA LENGTH. @Y30LB51*/
         MVC   CORELEN(3,CVTPTR),@CF00417+1                        0053
*   CALL ISDAGET1(WORKPTR);         /* GET WORK AREA SPACE.  @Y30LB51*/
         L     @10,@PC00001                                        0054
         ST    @10,@AL00001                                        0054
         L     @15,@CV00347                                        0054
         LA    @01,@AL00001                                        0054
         BALR  @14,@15                                             0054
*   RFY                                                            0055
*     RF RSTD;                      /*                       @Y30LB51*/
*   EQCRETCD=RF;                    /* SAVE RETURN CODE.     @Y30LB51*/
         LR    EQCRETCD,RF                                         0056
*   RFY                                                            0057
*     RF UNRSTD;                    /*                       @Y30LB51*/
*   IF EQCRETCD=0 THEN              /* IF SPACE WAS AVAILABLE      0058
*                                                            @Y30LB51*/
         LTR   EQCRETCD,EQCRETCD                                   0058
         BNZ   @RF00058                                            0058
*     DO;                           /* INITIALIZE IT.        @Y30LB51*/
*       EQC00PTR=COREADDR;          /* SAVE ADDRESS OF WORK AREA.  0060
*                                                            @Y30LB51*/
         L     @10,COREADDR(,CVTPTR)                               0060
         ST    @10,EQC00PTR(,CVTPTR)                               0060
*       EQCWKPTR=COREADDR;          /* SET PTR TO WORK AREA. @Y30LB51*/
         LR    EQCWKPTR,@10                                        0061
*       EQCWORK=''B;                /* ZERO OUT WORK AREA.   @Y30LB51*/
         XC    EQCWORK(56,EQCWKPTR),EQCWORK(EQCWKPTR)              0062
*       CORELEN=LENGTH(ISDAGHDR)+LENGTH(EQCTBL)*TBLNR;/*           0063
*                                         GET EQC TABLE LENGTH.    0063
*                                                            @Y30LB51*/
         MVC   CORELEN(3,CVTPTR),@CF00419+1                        0063
*       CALL ISDAGET0(WORKPTR);     /* GET EQC TABLE SPACE.  @Y30LB51*/
         L     @10,@PC00001                                        0064
         ST    @10,@AL00001                                        0064
         L     @15,@CV00346                                        0064
         LA    @01,@AL00001                                        0064
         BALR  @14,@15                                             0064
*       RFY                                                        0065
*         RF RSTD;                  /*                       @Y30LB51*/
*       EQCRETCD=RF;                /* SAVE RETURN CODE.     @Y30LB51*/
         LR    EQCRETCD,RF                                         0066
*       RFY                                                        0067
*         RF UNRSTD;                /*                       @Y30LB51*/
*       IF EQCRETCD=0 THEN          /* IF SPACE WAS SECURED  @Y30LB51*/
         LTR   EQCRETCD,EQCRETCD                                   0068
         BNZ   @RF00068                                            0068
*         DO;                       /* INITIALIZE IT.        @Y30LB51*/
*           GET0PTR=COREADDR;       /* SAVE ADDRESS OF EQC TABLE.  0070
*                                                            @Y30LB51*/
         L     @10,COREADDR(,CVTPTR)                               0070
         ST    @10,GET0PTR(,EQCWKPTR)                              0070
*           FREEPTR=STARTPTR;       /* INITIALIZE THE FREE ENTRY PTR.
*                                                            @Y30LB51*/
         L     @07,STARTPTR(,@10)                                  0071
         ST    @07,FREEPTR(,EQCWKPTR)                              0071
*           BLOCKCNT=BLOCKCNT+1;    /* NUMBER THE ACCUMULATOR.     0072
*                                                            @Y30LB51*/
         LA    @15,1                                               0072
         LH    @14,BLOCKCNT(,@10)                                  0072
         ALR   @14,@15                                             0072
         STH   @14,BLOCKCNT(,@10)                                  0072
*           BLOCKID='EQC ';         /* PUT ID IN TABLE.      @Y30LB51*/
         MVC   BLOCKID(4,@10),@CC00368                             0073
*           TBLPTR=STARTPTR;        /* INITIALIZE PTR TO ACCUMULATOR.
*                                                            @Y30LB51*/
         LR    TBLPTR,@07                                          0074
*           DO I=1 TO TBLNR;        /*                       @Y30LB51*/
         STH   @15,I(,EQCWKPTR)                                    0075
@DL00075 DS    0H                                                  0076
*             EQCTBL=''B;           /* ZERO OUT THE ACCUMULATOR.   0076
*                                                            @Y30LB51*/
         XC    EQCTBL(56,TBLPTR),EQCTBL(TBLPTR)                    0076
*             TBLPTR=TBLPTR+LENGTH(EQCTBL);/*                      0077
*                                                            @Y30LB51*/
         AH    TBLPTR,@CH00417                                     0077
*           END;                    /*                       @Y30LB51*/
         LA    @15,1                                               0078
         AH    @15,I(,EQCWKPTR)                                    0078
         STH   @15,I(,EQCWKPTR)                                    0078
         CH    @15,@CH00338                                        0078
         BNH   @DL00075                                            0078
*           TBLPTR=STARTPTR;        /* RESET BASE PTR.       @Y30LB51*/
         L     @10,GET0PTR(,EQCWKPTR)                              0079
         L     TBLPTR,STARTPTR(,@10)                               0079
*         END;                                                     0080
*       ELSE                        /* ACCUMULATOR SPACE UNAVAILABLE.
*                                                            @Y30LB51*/
*         EQCRETCD=NOSPACE;         /*                       @Y30LB51*/
         B     @RC00068                                            0081
@RF00068 LA    EQCRETCD,4                                          0081
*     END;                          /*                       @Y30LB51*/
*   ELSE                            /* WORK AREA SPACE UNAVAILABLE.
*                                                            @Y30LB51*/
*     EQCRETCD=NOSPACE;             /*                       @Y30LB51*/
         B     @RC00058                                            0083
@RF00058 LA    EQCRETCD,4                                          0083
*   END FIRSTENT;                   /*                       @Y30LB51*/
@EL00002 DS    0H                                                  0084
@EF00002 DS    0H                                                  0084
@ER00002 L     @14,@SA00002                                        0084
         BR    @14                                                 0084
*RECTYPE:                                                          0085
*   PROC OPTIONS(SAVE(14));         /*                       @Y30LB51*/
*                                                                  0085
RECTYPE  ST    @14,@SA00003                                        0085
*   /*****************************************************************/
*   /*                                                               */
*   /* THIS ROUTINE WILL DETERMINE THE TYPE AND FORMAT OF THE INPUT  */
*   /* RECORD. THE REAL UNIT ADDRESS FOR EACH RECORD WILL BE STORED. */
*   /* THE SSID FOR ALL RECORDS, EXCEPT FOR THE REAL DASD RECORD,    */
*   /* WILL BE STORED. THE FAULT SYMPTOM CODE WILL BE STORED FOR ALL */
*   /* RECORDS EXCEPT THE MSC FORMAT 5 SUBFORMAT 5 RECORD, WHICH HAS */
*   /* NO FSC. A SUBROUTINE WILL BE CALLED TO PROCESS THE FSC FOR THE*/
*   /* FORMAT THREE RECORD AND ANOTHER SUBROUTINE WILL BE CALLED TO  */
*   /* DETERMINE IF ALTERNATE PATH RETRY HAS BEEN INVOLVED IN THE MSC*/
*   /* FORMAT FOUR RECORDS.                                          */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0086
*   RUASAVE=INRECCUA;               /* STORE THE REAL UNIT ADDRESS.
*                                                            @ZD00149*/
         L     @10,SDA00PTR(,CVTPTR)                               0086
         MVC   RUASAVE(2,EQCWKPTR),INRECCUA(@10)                   0086
*   IF INDEVTYP='S' THEN            /* IF AN MSC RECORD      @Y30LB51*/
         CLI   INDEVTYP(@10),C'S'                                  0087
         BNE   @RF00087                                            0087
*     DO;                           /* PROCESS THE RECORD.   @Y30LB51*/
*       SSIDSAVE=SUBSYSID;          /* STORE THE SSID AND FLAGS    0089
*                                                            @Y30LB51*/
         L     @10,SENSEPTR(,EQCWKPTR)                             0089
         MVC   SSIDSAVE(2,EQCWKPTR),SUBSYSID(@10)                  0089
*       SSIDSAVE=SSIDSAVE&SSIDMASK; /* AND ISOLATE THE SSID. @Y30LB51*/
         NC    SSIDSAVE(2,EQCWKPTR),@CB00336                       0090
*       IF FORMATNO(4)='1'B THEN    /* IF FMT 3 RECORD       @Y30LB51*/
         TM    FORMATNO(@10),B'00010000'                           0091
         BNO   @RF00091                                            0091
*         IF SUBSTAT5(8)='0'B THEN  /* AND NOT BUFFERED LOG  @Y30LB51*/
         TM    SUBSTAT5(@10),B'00000001'                           0092
         BNZ   @RF00092                                            0092
*           CALL MSCTHREE;          /* ACCEPT THE RECORD.    @Y30LB51*/
         BAL   @14,MSCTHREE                                        0093
*         ELSE                      /* BUFFERED LOG RECORD,  @Y30LB51*/
*           EQCRETCD=BUFFREC;       /* REJECT IT.            @Y30LB51*/
         B     @RC00092                                            0094
@RF00092 LA    EQCRETCD,1                                          0094
*       ELSE                        /* NOT FMT 3 RECORD.     @Y30LB51*/
*         DO;                       /* PROCESS IT.           @ZD00149*/
         B     @RC00091                                            0095
@RF00091 DS    0H                                                  0096
*           IF FORMATNO(6)='1'B THEN/* IF FMT 5 RECORD       @Y30LB51*/
         L     @10,SENSEPTR(,EQCWKPTR)                             0096
         TM    FORMATNO(@10),B'00000100'                           0096
         BNO   @RF00096                                            0096
*             IF SUBFMTNO='0101'B THEN/* AND SUBFMT 5        @ZD00149*/
         TM    SUBFMTNO(@10),B'01010000'                           0097
         BNO   @RF00097                                            0097
         TM    SUBFMTNO(@10),B'10100000'                           0097
         BNZ   @RF00097                                            0097
*               NOFSC='1'B;         /* MARK IT WITH NO FSC.  @Y30LB51*/
         OI    NOFSC(EQCWKPTR),B'00010000'                         0098
*             ELSE                  /* NOT SUBFORMAT 5 RECORD,     0099
*                                                            @ZD00149*/
*               FSCSYSSV=MSCFSC;    /* STORE THE FSC.        @ZD00149*/
         B     @RC00097                                            0099
@RF00097 L     @10,SENSEPTR(,EQCWKPTR)                             0099
         MVC   FSCSYSSV(2,EQCWKPTR),MSCFSC(@10)                    0099
*           ELSE                    /* NOT FMT 5 RECORD,     @Y30LB51*/
*             FSCSYSSV=MSCFSC;      /* STORE THE FSC.        @ZD00149*/
         B     @RC00096                                            0100
@RF00096 L     @10,SENSEPTR(,EQCWKPTR)                             0100
         MVC   FSCSYSSV(2,EQCWKPTR),MSCFSC(@10)                    0100
*           IF FORMATNO(5)='1'B THEN/* IF MSC FORMAT 4 RECORD      0101
*                                                            @ZD00149*/
@RC00096 L     @10,SENSEPTR(,EQCWKPTR)                             0101
         TM    FORMATNO(@10),B'00001000'                           0101
         BNO   @RF00101                                            0101
*             CALL MSCFOUR;         /* CHECK FOR APR.        @Y30LB51*/
         BAL   @14,MSCFOUR                                         0102
*           ELSE                                                   0103
*             ;                     /* NOT A FORMAT 4 RECORD.      0103
*                                                            @ZD00149*/
@RF00101 DS    0H                                                  0104
*         END;                      /*                       @ZD00149*/
*     END;                          /*                       @Y30LB51*/
*   ELSE                            /* NOT MSC RECORD,       @Y30LB51*/
*     DO;                           /* MUST BE DASD RECORD.  @Y30LB51*/
         B     @RC00087                                            0106
@RF00087 DS    0H                                                  0107
*       FSCSYSSV=FSCDASD;           /* STORE DASD FSC.       @Y30LB51*/
         L     @10,SENSEPTR(,EQCWKPTR)                             0107
         MVC   FSCSYSSV(2,EQCWKPTR),FSCDASD(@10)                   0107
*       IF INDEVTYP='V' THEN        /* IF A VIRTUAL DASD RECORD    0108
*                                                            @ZD00149*/
         L     @04,SDA00PTR(,CVTPTR)                               0108
         CLI   INDEVTYP(@04),C'V'                                  0108
         BNE   @RF00108                                            0108
*         DO;                       /* GET THE DEVICE SSID.  @ZD00149*/
*           SSIDSAVE=DASDSSID;      /* STORE THE DASD SSID   @ZD00149*/
         MVC   SSIDSAVE(2,EQCWKPTR),DASDSSID(@10)                  0110
*           SSIDDEV=0;              /* AND SET FIRST CHARACTER TO  0111
*                                      ZERO.                 @ZD00149*/
         MVI   SSIDDEV(EQCWKPTR),X'00'                             0111
*         END;                      /*                       @ZD00149*/
*       ELSE                        /* MUST BE REAL DASD RECORD,   0113
*                                                            @ZD00149*/
*         SSIDSAVE=''B;             /* SET SSID TO BLANKS.   @ZD00149*/
         B     @RC00108                                            0113
@RF00108 XC    SSIDSAVE(2,EQCWKPTR),SSIDSAVE(EQCWKPTR)             0113
*     END;                          /*                       @Y30LB51*/
*   END RECTYPE;                    /*                       @Y30LB51*/
@EL00003 DS    0H                                                  0115
@EF00003 DS    0H                                                  0115
@ER00003 L     @14,@SA00003                                        0115
         BR    @14                                                 0115
*MSCTHREE:                                                         0116
*   PROC OPTIONS(SAVE(14));         /*                       @Y30LB51*/
*                                                                  0116
MSCTHREE ST    @14,12(,@13)                                        0116
*   /*****************************************************************/
*   /*                                                               */
*   /* THIS ROUTINE WILL STORE THE FSC(S) OF AN MSC FORMAT 3 RECORD. */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0117
*   IF FSCACC1^=0 THEN              /* IF RT ACC FSC         @Y30LB51*/
         SLR   @10,@10                                             0117
         L     @04,SENSEPTR(,EQCWKPTR)                             0117
         CL    @10,FSCACC1(,@04)                                   0117
         BE    @RF00117                                            0117
*     DO;                           /* STORE IT.             @Y30LB51*/
*       FSCSAVE1=FSCACC1;           /* STORE RT ACC FSC      @Y30LB51*/
         MVC   FSCSAVE1(4,EQCWKPTR),FSCACC1(@04)                   0119
*       FMT3ACC1='1'B;              /* AND SET RT ACC FLAG.  @Y30LB51*/
         OI    FMT3ACC1(EQCWKPTR),B'10000000'                      0120
*       IF FSCACC2^=0 THEN          /* IF LEFT ACC FSC       @Y30LB51*/
         CL    @10,FSCACC2(,@04)                                   0121
         BE    @RF00121                                            0121
*         DO;                       /* STORE IT.             @Y30LB51*/
*           FSCSAVE2=FSCACC2;       /* STORE LEFT ACC FSC    @Y30LB51*/
         MVC   FSCSAVE2(4,EQCWKPTR),FSCACC2(@04)                   0123
*           FMT3ACC2='1'B;          /* AND SET LEFT ACC FLAG.      0124
*                                                            @Y30LB51*/
         OI    FMT3ACC2(EQCWKPTR),B'01000000'                      0124
*         END;                      /*                       @Y30LB51*/
*       ELSE                                                       0126
*         ;                         /* NO LEFT ACC FSC.      @Y30LB51*/
@RF00121 DS    0H                                                  0127
*     END;                          /*                       @Y30LB51*/
*   ELSE                            /* NO RT ACC FSC,        @Y30LB51*/
*     DO;                           /* MUST BE LEFT ACC FSC. @Y30LB51*/
         B     @RC00117                                            0128
@RF00117 DS    0H                                                  0129
*       FSCSAVE2=FSCACC2;           /* STORE LEFT ACC FSC    @Y30LB51*/
         L     @10,SENSEPTR(,EQCWKPTR)                             0129
         MVC   FSCSAVE2(4,EQCWKPTR),FSCACC2(@10)                   0129
*       FMT3ACC2='1'B;              /* AND SET LEFT ACC FLAG.      0130
*                                                            @Y30LB51*/
         OI    FMT3ACC2(EQCWKPTR),B'01000000'                      0130
*     END;                          /*                       @Y30LB51*/
*   END MSCTHREE;                   /*                       @Y30LB51*/
@EL00004 DS    0H                                                  0132
@EF00004 DS    0H                                                  0132
@ER00004 L     @14,12(,@13)                                        0132
         BR    @14                                                 0132
*MSCFOUR:                                                          0133
*   PROC OPTIONS(SAVE(14));         /*                       @Y30LB51*/
*                                                                  0133
MSCFOUR  ST    @14,12(,@13)                                        0133
*   /*****************************************************************/
*   /*                                                               */
*   /* THIS ROUTINE WILL PROCESS AN MSC FORMAT FOUR RECORD. THE FSC  */
*   /* WILL BE STORED AND THE SSID CHECKED TO DETERMINE IF IT HAS    */
*   /* BEEN CHANGED BY ALTERNATE PATH RETRY (APR).                   */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0134
*   FSCSYSSV=MSCFSC;                /* STORE THE FSC.        @Y30LB51*/
         L     @10,SENSEPTR(,EQCWKPTR)                             0134
         MVC   FSCSYSSV(2,EQCWKPTR),MSCFSC(@10)                    0134
*   IF(SUBFMTNO='1001'B)&(SSIDDEV^='02'X) THEN/* IF SUBFMT '9' RECORD
*                                      AND SSID IS NOT FOR R/W DEVICE
*                                                            @Y30LB51*/
         TM    SUBFMTNO(@10),B'10010000'                           0135
         BNO   @RF00135                                            0135
         TM    SUBFMTNO(@10),B'01100000'                           0135
         BNZ   @RF00135                                            0135
         CLI   SSIDDEV(EQCWKPTR),X'02'                             0135
         BE    @RF00135                                            0135
*     WORKAPR='1'B;                 /* SET APR FLAG.         @Y30LB51*/
         OI    WORKAPR(EQCWKPTR),B'00100000'                       0136
*   ELSE                            /* SUBFMT AND SSID OK.   @Y30LB51*/
*     IF(SUBFMTNO='1010'B)&(SSIDDEV^='08'X) THEN/* IF SUBFMT 'A'   0137
*                                      RECORD AND SSID IS NOT FOR  0137
*                                      STAGING ADAPTOR       @Y30LB51*/
         B     @RC00135                                            0137
@RF00135 L     @10,SENSEPTR(,EQCWKPTR)                             0137
         TM    SUBFMTNO(@10),B'10100000'                           0137
         BNO   @RF00137                                            0137
         TM    SUBFMTNO(@10),B'01010000'                           0137
         BNZ   @RF00137                                            0137
         CLI   SSIDDEV(EQCWKPTR),X'08'                             0137
         BE    @RF00137                                            0137
*       WORKAPR='1'B;               /* SET APR FLAG.         @Y30LB51*/
         OI    WORKAPR(EQCWKPTR),B'00100000'                       0138
*     ELSE                          /* SUBFMT AND SSID OK.   @Y30LB51*/
*       IF SUBFMTNO='1011'B THEN    /* IF SUBFMT 'B'         @Y30LB51*/
         B     @RC00137                                            0139
@RF00137 L     @10,SENSEPTR(,EQCWKPTR)                             0139
         TM    SUBFMTNO(@10),B'10110000'                           0139
         BNO   @RF00139                                            0139
         TM    SUBFMTNO(@10),B'01000000'                           0139
         BNZ   @RF00139                                            0139
*         IF(SSIDDEV^='04'X)&(SSIDDEV^='02'X) THEN/* AND IF NOT FOR
*                                      R/W DEVICE OR R/W CONTROLLER
*                                                            @Y30LB51*/
         CLI   SSIDDEV(EQCWKPTR),X'04'                             0140
         BE    @RF00140                                            0140
         CLI   SSIDDEV(EQCWKPTR),X'02'                             0140
         BE    @RF00140                                            0140
*           WORKAPR='1'B;           /* SET APR FLAG.         @Y30LB51*/
         OI    WORKAPR(EQCWKPTR),B'00100000'                       0141
*         ELSE                                                     0142
*           ;                       /* SUBFMT AND SSID OK.   @Y30LB51*/
@RF00140 DS    0H                                                  0143
*       ELSE                        /* MUST BE SUBFMT 'E'.   @Y30LB51*/
*         IF(SUBFMTNO='1110'B)&(SSIDDEV^='04'X) THEN/* IF SUBFMT 'E'
*                                      AND NOT FOR R/W CONTROLLER  0143
*                                                            @Y30LB51*/
         B     @RC00139                                            0143
@RF00139 L     @10,SENSEPTR(,EQCWKPTR)                             0143
         TM    SUBFMTNO(@10),B'11100000'                           0143
         BNO   @RF00143                                            0143
         TM    SUBFMTNO(@10),B'00010000'                           0143
         BNZ   @RF00143                                            0143
         CLI   SSIDDEV(EQCWKPTR),X'04'                             0143
         BE    @RF00143                                            0143
*           WORKAPR='1'B;           /* SET APR FLAG.         @Y30LB51*/
         OI    WORKAPR(EQCWKPTR),B'00100000'                       0144
*         ELSE                                                     0145
*           ;                       /* SUBFMT AND SSID OK.   @Y30LB51*/
@RF00143 DS    0H                                                  0146
*   END MSCFOUR;                    /*                       @Y30LB51*/
@EL00005 DS    0H                                                  0146
@EF00005 DS    0H                                                  0146
@ER00005 L     @14,12(,@13)                                        0146
         BR    @14                                                 0146
*PROCREC:                                                          0147
*   PROC OPTIONS(SAVE(14));         /*                       @Y30LB51*/
*                                                                  0147
PROCREC  ST    @14,@SA00006                                        0147
*   /*****************************************************************/
*   /*                                                               */
*   /* THIS ROUTINE WILL PROCESS THE RECORD. FOR THE FIRST 100       */
*   /* RECORDS THE RECORD WILL BE PLACED INTO THE ACCUMULATOR TABLE  */
*   /* IN THE ORDER OF RECEIPT. FOR ALL RECORDS AFTER THE FIRST 100  */
*   /* RECORDS, THE NEW RECORD WILL REPLACE THE OLDEST RECORD IN THE */
*   /* ACCUMULATOR. RECORDS WILL BE CHAINED IN ASCENDING ORDER OF THE*/
*   /* OF THE DATE/TIME STAMP.                                       */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0148
*   IF RECCOUNT>=100 THEN           /* IF 100 OR MORE RECORDS IN   0148
*                                      TABLE                 @Y30LB51*/
         LH    @10,RECCOUNT(,EQCWKPTR)                             0148
         CH    @10,@CH00338                                        0148
         BL    @RF00148                                            0148
*     IF DATETIME>OLDPTR->EQCDT THEN/* AND IF RECORD LATER THAN    0149
*                                      OLDEST RECORD         @Y30LB51*/
         L     @10,LOGPTR(,EQCWKPTR)                               0149
         L     @04,OLDPTR(,EQCWKPTR)                               0149
         CLC   DATETIME(8,@10),EQCDT(@04)                          0149
         BNH   @RF00149                                            0149
*       DO;                         /* PUT IT IN ACCUMULATOR.      0150
*                                                            @Y30LB51*/
*         PTRSAVE=OLDPTR;           /* PREPARE PTRS TO REPLACE OLDEST
*                                                            @Y30LB51*/
         ST    @04,PTRSAVE(,EQCWKPTR)                              0151
*         OLDPTR=PTRSAVE->EQCTPTR;  /* ENTRY WITH NEW RECORD AND   0152
*                                                            @Y30LB51*/
         MVC   OLDPTR(4,EQCWKPTR),EQCTPTR(@04)                     0152
*         FREEPTR=PTRSAVE;          /* ESTABLISH NEW CHAIN START.  0153
*                                                            @Y30LB51*/
         ST    @04,FREEPTR(,EQCWKPTR)                              0153
*         CALL RECIN;               /* PLACE RECORD IN ACCUMULATOR.
*                                                            @Y30LB51*/
         BAL   @14,RECIN                                           0154
*         CALL EQCSORT;             /* PLACE IT ON CHAIN.    @Y30LB51*/
         BAL   @14,EQCSORT                                         0155
*       END;                        /*                       @Y30LB51*/
*     ELSE                                                         0157
*       ;                           /* RECORD OLDER THAN OLDEST    0157
*                                      ENTRY.                @Y30LB51*/
@RF00149 DS    0H                                                  0158
*   ELSE                            /* LESS THAN 100 RECORDS.      0158
*                                                            @Y30LB51*/
*     DO;                           /*                       @Y30LB51*/
         B     @RC00148                                            0158
@RF00148 DS    0H                                                  0159
*       CALL RECIN;                 /* PUT RECORD IN ACCUMULATOR.  0159
*                                                            @Y30LB51*/
         BAL   @14,RECIN                                           0159
*       CALL EQCSORT;               /* PUT IT ON CHAIN.      @Y30LB51*/
         BAL   @14,EQCSORT                                         0160
*       FREEPTR=FREEPTR+LENGTH(EQCTBL);/*                          0161
*                                      SET PTR TO NEXT FREE ELEMENT.
*                                                            @Y30LB51*/
         LA    @10,56                                              0161
         AL    @10,FREEPTR(,EQCWKPTR)                              0161
         ST    @10,FREEPTR(,EQCWKPTR)                              0161
*     END;                          /*                       @Y30LB51*/
*   END PROCREC;                    /*                       @Y30LB51*/
@EL00006 DS    0H                                                  0163
@EF00006 DS    0H                                                  0163
@ER00006 L     @14,@SA00006                                        0163
         BR    @14                                                 0163
*RECIN:                                                            0164
*   PROC OPTIONS(SAVE(14));         /*                       @Y30LB51*/
*                                                                  0164
RECIN    ST    @14,@SA00007                                        0164
*   /*****************************************************************/
*   /*                                                               */
*   /* THIS ROUTINE WILL PLACE THE RECORD INTO THE ACCUMULATOR WHEN  */
*   /* CALLED BY ROUTINE 'PROCREC'.                                  */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0165
*   TBLPTR=FREEPTR;                 /* SET PTR TO TABLE SPACE      0165
*                                                            @Y30LB51*/
         L     TBLPTR,FREEPTR(,EQCWKPTR)                           0165
*   EQCTBL=''B;                     /* AND ZERO IT OUT.      @Y30LB51*/
         XC    EQCTBL(56,TBLPTR),EQCTBL(TBLPTR)                    0166
*   EQCRUA=RUASAVE;                 /* PUT RUA INTO TABLE.   @ZD00149*/
         MVC   EQCRUA(2,TBLPTR),RUASAVE(EQCWKPTR)                  0167
*   EQCSSID=SSIDSAVE;               /* PUT SSID INTO TABLE.  @Y30LB51*/
         MVC   EQCSSID(2,TBLPTR),SSIDSAVE(EQCWKPTR)                0168
*   EQCDT=DATETIME;                 /* PUT DATE/TIME STAMP INTO    0169
*                                      TABLE.                @Y30LB51*/
         L     @10,LOGPTR(,EQCWKPTR)                               0169
         MVC   EQCDT(8,TBLPTR),DATETIME(@10)                       0169
*   IF INDEVTYP='S' THEN            /* IF SUBSYSTEM RECORD   @Y30LB51*/
         L     @10,SDA00PTR(,CVTPTR)                               0170
         CLI   INDEVTYP(@10),C'S'                                  0170
         BNE   @RF00170                                            0170
*     DO;                           /* PUT 32 BYTES SENSE INTO TABLE.
*                                                            @Y30LB51*/
*       IF FORMATNO(6)='1'B THEN    /* IF FORMAT 5 RECORD    @ZD00149*/
         L     @10,SENSEPTR(,EQCWKPTR)                             0172
         TM    FORMATNO(@10),B'00000100'                           0172
         BNO   @RF00172                                            0172
*         CALL PUTDEV;              /* PUT DEVICE IDS INTO TABLE.  0173
*                                                            @ZD00149*/
         BAL   @14,PUTDEV                                          0173
*       ELSE                                                       0174
*         ;                         /* NOT A FORMAT 5 RECORD.      0174
*                                                            @ZD00149*/
@RF00172 DS    0H                                                  0175
*       EQCSENSE=ISDAMSCS;          /* PUT SENSE INTO TABLE. @Y30LB51*/
         L     @10,SENSEPTR(,EQCWKPTR)                             0175
         MVC   EQCSENSE(32,TBLPTR),ISDAMSCS(@10)                   0175
*       IF FORMATNO(4)='1'B THEN    /* IF MSC FMT 3 RECORD   @Y30LB51*/
         TM    FORMATNO(@10),B'00010000'                           0176
         BNO   @RF00176                                            0176
*         DO;                       /* PUT FSC INTO TABLE.   @Y30LB51*/
*           CSFLAG='1'B;            /* SET CS DEVICE FLAG.   @Y30.B51*/
         OI    CSFLAG(TBLPTR),B'00000001'                          0178
*           IF FMT3ACC1='1'B THEN   /* IF RT ACC FSC         @Y30LB51*/
         TM    FMT3ACC1(EQCWKPTR),B'10000000'                      0179
         BNO   @RF00179                                            0179
*             DO;                   /* PUT RT ACC FSC INTO TABLE.  0180
*                                                            @Y30LB51*/
*               EQCFSC=FSCSAVE1;    /* PUT RT ACC FSC INTO TABLE.  0181
*                                                            @Y30LB51*/
         MVC   EQCFSC(4,TBLPTR),FSCSAVE1(EQCWKPTR)                 0181
*               FMT3ACC1='0'B;      /* RESET RT ACC FSC FLAG.      0182
*                                                            @Y30LB51*/
         NI    FMT3ACC1(EQCWKPTR),B'01111111'                      0182
*             END;                  /*                       @Y30LB51*/
*           ELSE                    /* NOT RT ACC FSC,       @Y30LB51*/
*             DO;                   /* MUST BE LEFT ACC FSC. @Y30LB51*/
         B     @RC00179                                            0184
@RF00179 DS    0H                                                  0185
*               EQCFSC=FSCSAVE2;    /* PUT LEFT ACC FSC INTO TABLE.
*                                                            @Y30LB51*/
         MVC   EQCFSC(4,TBLPTR),FSCSAVE2(EQCWKPTR)                 0185
*               FMT3ACC2='0'B;      /* RESET LEFT ACC FSC FLAG.    0186
*                                                            @Y30LB51*/
         NI    FMT3ACC2(EQCWKPTR),B'10111111'                      0186
*             END;                  /*                       @Y30LB51*/
*         END;                      /*                       @Y30LB51*/
*       ELSE                        /* NOT MSC FORMAT 3 RECORD.    0189
*                                                            @Y30LB51*/
*         DO;                       /*                       @Y30LB51*/
         B     @RC00176                                            0189
@RF00176 DS    0H                                                  0190
*           FSCSYS=FSCSYSSV;        /* PUT FSC IN TABLE.     @Y30LB51*/
         MVC   FSCSYS(2,TBLPTR),FSCSYSSV(EQCWKPTR)                 0190
*           IF WORKAPR='1'B THEN    /* IF ALTERED SSID       @Y30LB51*/
         TM    WORKAPR(EQCWKPTR),B'00100000'                       0191
         BNO   @RF00191                                            0191
*             EQCAPR='1'B;          /* SET APR FLAG.         @Y30LB51*/
         OI    EQCAPR(TBLPTR),B'00000100'                          0192
*           ELSE                    /* NOT ALTERED SSID.     @Y30LB51*/
*             IF NOFSC='1'B THEN    /* IF NO FSC             @Y30LB51*/
         B     @RC00191                                            0193
@RF00191 TM    NOFSC(EQCWKPTR),B'00010000'                         0193
         BNO   @RF00193                                            0193
*               EQCNOFSC='1'B;      /* SET NO FSC FLAG.      @Y30LB51*/
         OI    EQCNOFSC(TBLPTR),B'00001000'                        0194
*             ELSE                                                 0195
*               ;                   /* FSC PRESENT.          @Y30LB51*/
@RF00193 DS    0H                                                  0196
*           IF MSCREC='1'B THEN     /* IF MSC RECORD         @Y30LB51*/
@RC00191 TM    MSCREC(EQCWKPTR),B'00001000'                        0196
         BNO   @RF00196                                            0196
*             MSCFLAG='1'B;         /* SET MSC FLAG.         @Y30LB51*/
         OI    MSCFLAG(TBLPTR),B'00000010'                         0197
*           ELSE                                                   0198
*             ;                     /* NOT MSC RECORD.       @Y30LB51*/
@RF00196 DS    0H                                                  0199
*         END;                      /*                       @Y30LB51*/
*     END;                          /*                       @Y30LB51*/
*   ELSE                            /* NOT SUBSYSTEM RECORD  @Y30LB51*/
*     DO;                           /* MUST BE DASD RECORD.  @Y30LB51*/
         B     @RC00170                                            0201
@RF00170 DS    0H                                                  0202
*       EQCFSC=FSCSYSSV;            /* PUT DASD FSC INTO TABLE.    0202
*                                                            @Y30LB51*/
         MVI   EQCFSC+2(TBLPTR),C' '                               0202
         MVI   EQCFSC+3(TBLPTR),C' '                               0202
         MVC   EQCFSC(2,TBLPTR),FSCSYSSV(EQCWKPTR)                 0202
*       CALL PUTDEV;                /* PUT DEVICE IDS INTO TABLE.  0203
*                                                            @ZD00149*/
         BAL   @14,PUTDEV                                          0203
*       EQCSENSE='';                /* BLANK OUT SENSE AREA. @Y30LB51*/
         MVI   EQCSENSE(TBLPTR),C' '                               0204
         MVC   EQCSENSE+1(31,TBLPTR),EQCSENSE(TBLPTR)              0204
*       DASDDATA=MSCDASD;           /* PUT DASD SENSE INTO TABLE.  0205
*                                                            @Y30LB51*/
         L     @10,SENSEPTR(,EQCWKPTR)                             0205
         MVC   DASDDATA(28,TBLPTR),MSCDASD(@10)                    0205
*       DASDFLAG='1'B;              /* SET DASD SSID FLAG.   @Y30LB51*/
         OI    DASDFLAG(TBLPTR),B'01000000'                        0206
*       IF INDEVTYP='R' THEN        /* IF REAL DASD SSID     @Y30LB51*/
         L     @10,SDA00PTR(,CVTPTR)                               0207
         CLI   INDEVTYP(@10),C'R'                                  0207
         BNE   @RF00207                                            0207
*         REALDASD='1'B;            /* SET REAL DASD SSID FLAG.    0208
*                                                            @Y30LB51*/
         OI    REALDASD(TBLPTR),B'00100000'                        0208
*       ELSE                        /* NOT REAL DASD SSID    @Y30LB51*/
*         VIRTDASD='1'B;            /* SET VIRTUAL DASD SSID FLAG. 0209
*                                                            @Y30LB51*/
         B     @RC00207                                            0209
@RF00207 OI    VIRTDASD(TBLPTR),B'00010000'                        0209
*     END;                          /*                       @Y30LB51*/
@RC00207 DS    0H                                                  0211
*   IF SDAFLAG0(8)='1'B THEN        /* IF GENERATED FSC      @Y30LB51*/
@RC00170 L     @10,SDA00PTR(,CVTPTR)                               0211
         TM    SDAFLAG0(@10),B'00000001'                           0211
         BNO   @RF00211                                            0211
*     FAKEFSC='1'B;                 /* SET GENERATED FSC FLAG.     0212
*                                                            @Y30LB51*/
         OI    FAKEFSC(TBLPTR),B'10000000'                         0212
*   ELSE                                                           0213
*     ;                             /* NOT GENERATED FSC.    @Y30LB51*/
@RF00211 DS    0H                                                  0214
*   RECCOUNT=RECCOUNT+1;            /* ADD ONE TO RECORD COUNTER.  0214
*                                                            @Y30LB51*/
         LA    @10,1                                               0214
         AH    @10,RECCOUNT(,EQCWKPTR)                             0214
         STH   @10,RECCOUNT(,EQCWKPTR)                             0214
*   END RECIN;                      /*                       @Y30LB51*/
@EL00007 DS    0H                                                  0215
@EF00007 DS    0H                                                  0215
@ER00007 L     @14,@SA00007                                        0215
         BR    @14                                                 0215
*PUTDEV:                                                           0216
*   PROC OPTIONS(SAVE(14));         /*                       @ZD00149*/
*                                                                  0216
PUTDEV   ST    @14,12(,@13)                                        0216
*   /*****************************************************************/
*   /*                                                               */
*   /* THIS ROUTINE WILL DETERMINE THE CONTROL UNIT AND DEVICE IDS,  */
*   /* IF PRESENT, AND STORE THEM.                                   */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0217
*   IF INDEVTYP='S' THEN            /* IF MSC RECORD         @ZD00149*/
         L     @10,SDA00PTR(,CVTPTR)                               0217
         CLI   INDEVTYP(@10),C'S'                                  0217
         BNE   @RF00217                                            0217
*     IF DRIVEID^='00'X&DRIVEID^='FF'X THEN /* HAVE DRIVE ID @ZA05081*/
         L     @10,SENSEPTR(,EQCWKPTR)                             0218
         CLI   DRIVEID(@10),X'00'                                  0218
         BE    @RF00218                                            0218
         CLI   DRIVEID(@10),X'FF'                                  0218
         BE    @RF00218                                            0218
*       DEVBYTEA=DRIVEID;           /* GET THE DRIVE ID.     @ZD00149*/
         MVC   DEVBYTEA(1,EQCWKPTR),DRIVEID(@10)                   0219
*     ELSE                          /* NO DRIVE ID PRESENT,  @ZD00149*/
*       DEVBYTEA=0;                 /* SET WORK AREA TO ZERO.      0220
*                                                            @ZD00149*/
         B     @RC00218                                            0220
@RF00218 MVI   DEVBYTEA(EQCWKPTR),X'00'                            0220
*   ELSE                            /* NOT A SUBSYSTEM RECORD,     0221
*                                                            @ZD00149*/
*     IF DRIVE^='00'X&DRIVE^='FF'X THEN /* HAVE DRIVE ID     @ZA05081*/
         B     @RC00217                                            0221
@RF00217 L     @10,SENSEPTR(,EQCWKPTR)                             0221
         CLI   DRIVE(@10),X'00'                                    0221
         BE    @RF00221                                            0221
         CLI   DRIVE(@10),X'FF'                                    0221
         BE    @RF00221                                            0221
*       DEVBYTEA=DRIVE;             /* GET THEM.             @ZD00149*/
         MVC   DEVBYTEA(1,EQCWKPTR),DRIVE(@10)                     0222
*     ELSE                          /* DRIVE ID NOT PRESENT, @ZD00149*/
*       DEVBYTEA=0;                 /* SET WORK AREA TO ZERO.      0223
*                                                            @ZD00149*/
         B     @RC00221                                            0223
@RF00221 MVI   DEVBYTEA(EQCWKPTR),X'00'                            0223
*   IF DEVBYTEA^=0 THEN             /* IF A DEVICE ID IS PRESENT   0224
*                                                            @ZD00149*/
@RC00221 DS    0H                                                  0224
@RC00217 CLI   DEVBYTEA(EQCWKPTR),0                                0224
         BE    @RF00224                                            0224
*     DO;                           /* PROCESS IT.           @ZD00149*/
*       CNTLUNIT=DEVBYTEA;          /* GET THE DEVICE IDS,   @ZD00149*/
         MVC   CNTLUNIT(1,TBLPTR),DEVBYTEA(EQCWKPTR)               0226
*       SRL(CNTLUNIT,6);            /* ISOLATE THE CONTROL UNIT ID 0227
*                                                            @ZD00149*/
         SLR   @10,@10                                             0227
         IC    @10,CNTLUNIT(,TBLPTR)                               0227
         SRL   @10,6                                               0227
         STC   @10,CNTLUNIT(,TBLPTR)                               0227
*       CNTLUNIT=CNTLUNIT'F0'X;    /* AND MAKE IT PRINTABLE.      0228
*                                                            @ZD00149*/
         OI    CNTLUNIT(TBLPTR),X'F0'                              0228
*       DEVBYTEA=DEVBYTEA&'3F'X;    /* ISOLATE THE DRIVE ID. @ZD00149*/
         NI    DEVBYTEA(EQCWKPTR),X'3F'                            0229
*       DO I=1 TO 8 WHILE(DEVBYTEA^=DEVICES(I));/* LOCATE THE DEVICE
*                                      ID.                   @ZD00149*/
         LA    @10,1                                               0230
         STH   @10,I(,EQCWKPTR)                                    0230
@DL00230 LH    @10,I(,EQCWKPTR)                                    0230
         LA    @01,DEVICES-1(@10)                                  0230
         CLC   DEVBYTEA(1,EQCWKPTR),0(@01)                         0230
         BE    @DC00230                                            0230
*       END;                        /*                       @ZD00149*/
         LA    @10,1                                               0231
         AH    @10,I(,EQCWKPTR)                                    0231
         STH   @10,I(,EQCWKPTR)                                    0231
         CH    @10,@CH00070                                        0231
         BNH   @DL00230                                            0231
@DC00230 DS    0H                                                  0232
*       IF I<9 THEN                 /* IF DEVICE ID FOUND    @ZD00149*/
         LH    @10,I(,EQCWKPTR)                                    0232
         CH    @10,@CH00410                                        0232
         BNL   @RF00232                                            0232
*         UNITID=DEVIDS(I);         /* PUT DEVICE ID INTO RECORD.  0233
*                                                            @ZD00149*/
         LA    @01,DEVIDS-1(@10)                                   0233
         MVC   UNITID(1,TBLPTR),0(@01)                             0233
*      ELSE                                                        0234
*        ;                          /*                       @ZD00149*/
@RF00232 DS    0H                                                  0235
*       DEVIN='1'B;                 /* SET PUT DEVICES FLAG. @ZD00149*/
         OI    DEVIN(TBLPTR),B'10000000'                           0235
*     END;                          /*                       @ZD00149*/
*   ELSE                                                           0237
*     ;                             /* NO DEVICE IDS PRESENT.      0237
*                                                            @ZD00149*/
@RF00224 DS    0H                                                  0238
*   END PUTDEV;                     /*                       @ZD00149*/
@EL00008 DS    0H                                                  0238
@EF00008 DS    0H                                                  0238
@ER00008 L     @14,12(,@13)                                        0238
         BR    @14                                                 0238
*EQCSORT:                                                          0239
*   PROC OPTIONS(SAVE(14));         /*                       @Y30LB51*/
*                                                                  0239
EQCSORT  ST    @14,12(,@13)                                        0239
*   /*****************************************************************/
*   /*                                                               */
*   /* THIS ROUTINE WILL PLACE THE NEW ACCUMULATOR ENTRY INTO THE    */
*   /* CHAIN IN ASCENDING ORDER OF DATE/TIME STAMP.                  */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0240
*   IF RECCOUNT=1 THEN              /* IF FIRST ENTRY        @Y30LB51*/
         CLC   RECCOUNT(2,EQCWKPTR),@CH00082                       0240
         BNE   @RF00240                                            0240
*     OLDPTR=FREEPTR;               /* SAVE CHAIN START ADDRESS.   0241
*                                                            @Y30LB51*/
         MVC   OLDPTR(4,EQCWKPTR),FREEPTR(EQCWKPTR)                0241
*   ELSE                            /* NOT FIRST ENTRY.      @Y30LB51*/
*     DO;                           /* PUT RECORD ONTO CHAIN.      0242
*                                                            @Y30LB51*/
         B     @RC00240                                            0242
@RF00240 DS    0H                                                  0243
*       TBLPTR=OLDPTR;              /* SET PTR TO CHAIN START.     0243
*                                                            @Y30LB51*/
         L     TBLPTR,OLDPTR(,EQCWKPTR)                            0243
*       DO WHILE(TBLPTR^=0)&(FREEPTR->EQCDT>=EQCDT);/* SEARCH FOR  0244
*                                      PLACE ON CHAIN OR END OF    0244
*                                      CHAIN.                @Y30LB51*/
         B     @DE00244                                            0244
@DL00244 DS    0H                                                  0245
*         PTRSAVE=TBLPTR;           /* SAVE ADDRESS CURRENT ENTRY. 0245
*                                                            @Y30LB51*/
         ST    TBLPTR,PTRSAVE(,EQCWKPTR)                           0245
*         TBLPTR=EQCTPTR;           /* SET PTR TO NEXT CHAIN ENTRY.
*                                                            @Y30LB51*/
         L     TBLPTR,EQCTPTR(,TBLPTR)                             0246
*       END;                        /*                       @Y30LB51*/
@DE00244 LTR   TBLPTR,TBLPTR                                       0247
         BZ    @DC00244                                            0247
         L     @10,FREEPTR(,EQCWKPTR)                              0247
         CLC   EQCDT(8,@10),EQCDT(TBLPTR)                          0247
         BNL   @DL00244                                            0247
@DC00244 DS    0H                                                  0248
*       IF TBLPTR=0 THEN            /* IF AT END OF CHAIN    @Y30LB51*/
         SLR   @10,@10                                             0248
         CR    TBLPTR,@10                                          0248
         BNE   @RF00248                                            0248
*         DO;                       /* ADD NEW RECORD TO CHAIN.    0249
*                                                            @Y30LB51*/
*           PTRSAVE->EQCTPTR=FREEPTR;/* ADD IT TO END OF CHAIN.    0250
*                                                            @Y30LB51*/
         L     @04,PTRSAVE(,EQCWKPTR)                              0250
         L     @15,FREEPTR(,EQCWKPTR)                              0250
         ST    @15,EQCTPTR(,@04)                                   0250
*           FREEPTR->EQCTPTR=0;     /* SET END OF CHAIN INDICATOR. 0251
*                                                            @Y30LB51*/
         ST    @10,EQCTPTR(,@15)                                   0251
*         END;                      /*                       @Y30LB51*/
*       ELSE                        /* INSERT NEW ENTRY IN ITS     0253
*                                                            @Y30LB51*/
*         DO;                       /* PLACE ON THE CHAIN.   @Y30LB51*/
         B     @RC00248                                            0253
@RF00248 DS    0H                                                  0254
*           FREEPTR->EQCTPTR=TBLPTR;/* POINT NEW ENTRY TO OLD ENTRY.
*                                                            @Y30LB51*/
         L     @10,FREEPTR(,EQCWKPTR)                              0254
         ST    TBLPTR,EQCTPTR(,@10)                                0254
*           IF TBLPTR=OLDPTR THEN   /* IF NEW ENTRY OLDEST IN TABLE
*                                                            @Y30LB51*/
         C     TBLPTR,OLDPTR(,EQCWKPTR)                            0255
         BNE   @RF00255                                            0255
*             OLDPTR=FREEPTR;       /* SET NEW CHAIN START.  @Y30LB51*/
         ST    @10,OLDPTR(,EQCWKPTR)                               0256
*           ELSE                    /* NEW ENTRY NOT OLDEST IN TABLE.
*                                                            @Y30LB51*/
*             PTRSAVE->EQCTPTR=FREEPTR;/* POINT OLD ENTRY TO NEW   0257
*                                      ENTRY.                @Y30LB51*/
         B     @RC00255                                            0257
@RF00255 L     @10,PTRSAVE(,EQCWKPTR)                              0257
         MVC   EQCTPTR(4,@10),FREEPTR(EQCWKPTR)                    0257
*         END;                      /*                       @Y30LB51*/
*     END;                          /*                       @Y30LB51*/
*   END EQCSORT;                    /*                       @Y30LB51*/
@EL00009 DS    0H                                                  0260
@EF00009 DS    0H                                                  0260
@ER00009 L     @14,12(,@13)                                        0260
         BR    @14                                                 0260
*FREECORE:                                                         0261
*   PROC OPTIONS(SAVE(14));         /*                       @Y30LB51*/
*                                                                  0261
FREECORE ST    @14,@SA00010                                        0261
*   /*****************************************************************/
*   /*                                                               */
*   /* THIS ROUTINE WILL FREE ALL GOTTEN CORE VIA THE ISDAFREE       */
*   /* ROUTINE.                                                      */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0262
*   SPNO='05'X;                     /* GET SUBPOOL NUMBER.   @Y30LB51*/
         MVI   SPNO(CVTPTR),X'05'                                  0262
*   IF EQC00PTR^=0 THEN             /* IF WORK AREA EXISTS   @Y30LB51*/
         SLR   @10,@10                                             0263
         C     @10,EQC00PTR(,CVTPTR)                               0263
         BE    @RF00263                                            0263
*     DO;                           /* FREE IT.              @Y30LB51*/
*       IF GET0PTR^=0 THEN          /* IF ACCUMULATOR TABLE EXISTS 0265
*                                                            @ZM31022*/
         L     @07,GET0PTR(,EQCWKPTR)                              0265
         CR    @07,@10                                             0265
         BE    @RF00265                                            0265
*         DO;                       /* FREE IT.              @ZM31022*/
*           CORELEN=LENGTH(ISDAGHDR)+LENGTH(EQCTBL)*TBLNR;/*       0267
*                                             GET ACCUMULATOR TABLE
*                                      LENGTH                @ZM31022*/
         MVC   CORELEN(3,CVTPTR),@CF00419+1                        0267
*           COREADDR=GET0PTR;       /* AND ADDRESS           @ZM31022*/
         ST    @07,COREADDR(,CVTPTR)                               0268
*           CALL ISDAFREE(WORKPTR); /* AND FREE IT.                  */
         L     @10,@PC00001                                        0269
         ST    @10,@AL00001                                        0269
         L     @15,@CV00348                                        0269
         LA    @01,@AL00001                                        0269
         BALR  @14,@15                                             0269
*         END;                      /*                       @ZM31022*/
*       ELSE;                       /* ACCUMULATOR TABLE DOES NOT  0271
*                                      EXIST.                @ZM31022*/
@RF00265 DS    0H                                                  0272
*       CORELEN=LENGTH(EQCWORK);    /* GET WORK AREA LENGTH  @Y30LB51*/
         MVC   CORELEN(3,CVTPTR),@CF00417+1                        0272
*       COREADDR=EQC00PTR;          /* AND ADDRESS           @Y30LB51*/
         MVC   COREADDR(4,CVTPTR),EQC00PTR(CVTPTR)                 0273
*       CALL ISDAFREE(WORKPTR);     /* AND FREE IT.          @Y30LB51*/
         L     @10,@PC00001                                        0274
         ST    @10,@AL00001                                        0274
         L     @15,@CV00348                                        0274
         LA    @01,@AL00001                                        0274
         BALR  @14,@15                                             0274
*     END;                          /*                       @Y30LB51*/
*   ELSE                                                           0276
*     ;                             /* WORK AREA DOES NOT EXIST.   0276
*                                                            @Y30LB51*/
@RF00263 DS    0H                                                  0277
*   EQC00PTR=0;                     /* SET WORK AREA ADDRESS TO ZERO.
*                                                            @Y30LB51*/
         SLR   @10,@10                                             0277
         ST    @10,EQC00PTR(,CVTPTR)                               0277
*   CEQC='00'X;                     /* SET 'DO NOT CALL' SWITCH.   0278
*                                                            @Y30LB51*/
         MVI   CEQC(LPARMPTR),X'00'                                0278
*   END FREECORE;                   /*                       @Y30LB51*/
@EL00010 DS    0H                                                  0279
@EF00010 DS    0H                                                  0279
@ER00010 L     @14,@SA00010                                        0279
         BR    @14                                                 0279
*   END ISDAEQC0                    /*                       @Y30LB51*/
*/* THE FOLLOWING INCLUDE STATEMENTS WERE FOUND IN THIS PROGRAM.      *
*/*%INCLUDE SYSLIB  (ISDACVT )                                        *
*/*%INCLUDE SYSLIB  (ISDAPRMS)                                        *
*/*%INCLUDE SYSLIB  (ISDAWORK)                                        *
*/*%INCLUDE SYSLIB  (ISDASOBR)                                        *
*/*%INCLUDE SYSLIB  (ISDAMSCS)                                        *
*/*%INCLUDE SYSLIB  (ISDAGHDR)                                        *
*/*%INCLUDE SYSLIB  (ISDAEQC5)                                        *
*;                                                                 0280
@DATA    DS    0H
@CH00082 DC    H'1'
@CH00070 DC    H'8'
@CH00410 DC    H'9'
@CH00338 DC    H'100'
@DATD    DSECT
         DS    0F
@SA00001 DS    18F
@PC00001 DS    1F
@SA00003 DS    1F
@SA00006 DS    1F
@SA00007 DS    1F
@SA00010 DS    0F
@SA00002 DS    0F
         DS    1F
@AL00001 DS    1A
ISDAEQC0 CSECT
         DS    0F
@CF00417 DC    F'56'
@CH00417 EQU   @CF00417+2
@CF00419 DC    F'5628'
@DATD    DSECT
         DS    0D
         ORG   *+1-(*-@DATD)/(*-@DATD) INSURE DSECT DATA
@ENDDATD EQU   *
ISDAEQC0 CSECT
         NOPR  ((@ENDDATD-@DATD)/161*16)
         DS    0F
@SIZDATD DC    AL1(0)
         DC    AL3(@ENDDATD-@DATD)
@CV00346 DC    V(ISDAGET0)
@CV00347 DC    V(ISDAGET1)
@CV00348 DC    V(ISDAFREE)
         DS    0D
@CC00368 DC    C'EQC '
@CB00336 DC    X'0FFF'
DEVICES  DC    X'38312A231C150E07'
DEVIDS   DC    X'C1C2C3C4C5C6C7C8'
PATCH    DS    CL50
         ORG   PATCH
@NM00025 DC    50X'00'
         ORG   PATCH+50
@00      EQU   00                      EQUATES FOR REGISTERS 0-15
@01      EQU   01
@02      EQU   02
@03      EQU   03
@04      EQU   04
@05      EQU   05
@06      EQU   06
@07      EQU   07
@08      EQU   08
@09      EQU   09
@10      EQU   10
@11      EQU   11
@12      EQU   12
@13      EQU   13
@14      EQU   14
@15      EQU   15
EQCRETCD EQU   @05
TBLPTR   EQU   @04
EQCWKPTR EQU   @03
LPARMPTR EQU   @06
CVTPTR   EQU   @02
RF       EQU   @15
ISDACVT  EQU   0
CVTPTRS0 EQU   ISDACVT
DATAPTR  EQU   CVTPTRS0
SDATAPTR EQU   CVTPTRS0+4
PARMPTR  EQU   CVTPTRS0+8
SDA00PTR EQU   CVTPTRS0+12
EQC00PTR EQU   CVTPTRS0+60
GET0CALL EQU   ISDACVT+100
SPNOLEN  EQU   GET0CALL
SPNO     EQU   SPNOLEN
CORELEN  EQU   SPNOLEN+1
COREADDR EQU   GET0CALL+4
HEXPCALL EQU   ISDACVT+108
PRT0CALL EQU   ISDACVT+120
OUTLINE  EQU   PRT0CALL
SDADATD  EQU   ISDACVT+256
PRTDATD  EQU   ISDACVT+416
ISDAPRMS EQU   0
CINPUT   EQU   ISDAPRMS
CSTART   EQU   ISDAPRMS+2
CEND     EQU   ISDAPRMS+6
CFSCONLY EQU   ISDAPRMS+13
CSSIDF   EQU   ISDAPRMS+17
CSERIAL  EQU   ISDAPRMS+21
CREPORTS EQU   ISDAPRMS+33
CEQC     EQU   CREPORTS+5
ISDAWORK EQU   0
INFLAGS  EQU   ISDAWORK
INDEVTYP EQU   INFLAGS+2
SDAFLAG0 EQU   INFLAGS+3
INRECCUA EQU   ISDAWORK+6
OBRMDR   EQU   0
SCW      EQU   OBRMDR
SWITCHES EQU   OBRMDR+6
DATETIME EQU   OBRMDR+12
DATE     EQU   DATETIME
TIME     EQU   DATETIME+4
CPUSERID EQU   OBRMDR+21
ISDAMSCS EQU   0
SUBSYSID EQU   ISDAMSCS+1
SSID     EQU   SUBSYSID
FORMATNO EQU   ISDAMSCS+3
SUBSENSE EQU   ISDAMSCS+4
SUBSTAT5 EQU   SUBSENSE+1
SUBFMTMG EQU   SUBSENSE+7
SUBFMTNO EQU   SUBFMTMG
MSCFSC   EQU   SUBSENSE+22
ISDAGHDR EQU   0
STARTPTR EQU   ISDAGHDR
GET0SPLN EQU   ISDAGHDR+8
BLOCKID  EQU   ISDAGHDR+20
BLOCKCNT EQU   ISDAGHDR+24
EQCWORK  EQU   0
GET0PTR  EQU   EQCWORK
PTRSAVE  EQU   EQCWORK+4
LOGPTR   EQU   EQCWORK+8
SENSEPTR EQU   EQCWORK+12
FREEPTR  EQU   EQCWORK+16
OLDPTR   EQU   EQCWORK+20
RUASAVE  EQU   EQCWORK+24
SSIDSAVE EQU   EQCWORK+26
SSIDDEV  EQU   SSIDSAVE
FSCSYSSV EQU   EQCWORK+28
FSCSAVE1 EQU   EQCWORK+30
FSCSAVE2 EQU   EQCWORK+34
RECCOUNT EQU   EQCWORK+38
I        EQU   EQCWORK+42
EQCSW    EQU   EQCWORK+52
FMT3ACC1 EQU   EQCSW
FMT3ACC2 EQU   EQCSW
WORKAPR  EQU   EQCSW
NOFSC    EQU   EQCSW
MSCREC   EQU   EQCSW
DEVBYTES EQU   EQCWORK+54
DEVBYTEA EQU   DEVBYTES
EQCTBL   EQU   0
EQCTPTR  EQU   EQCTBL
EQCRUA   EQU   EQCTBL+4
EQCSSID  EQU   EQCTBL+6
EQCFLAGS EQU   EQCTBL+8
FAKEFSC  EQU   EQCFLAGS
DASDFLAG EQU   EQCFLAGS
REALDASD EQU   EQCFLAGS
VIRTDASD EQU   EQCFLAGS
EQCNOFSC EQU   EQCFLAGS
EQCAPR   EQU   EQCFLAGS
MSCFLAG  EQU   EQCFLAGS
CSFLAG   EQU   EQCFLAGS
DEVIN    EQU   EQCFLAGS+1
EQCFSC   EQU   EQCTBL+10
FSCSYS   EQU   EQCFSC
EQCDT    EQU   EQCTBL+14
EQCDATE  EQU   EQCDT
EQCTIME  EQU   EQCDT+4
EQCUNIT  EQU   EQCTBL+22
CNTLUNIT EQU   EQCUNIT
UNITID   EQU   EQCUNIT+1
EQCSENSE EQU   EQCTBL+24
DASDDATA EQU   EQCSENSE
MSCDASD  EQU   0
DRIVE    EQU   MSCDASD+4
FMTMSG   EQU   MSCDASD+7
DASD10   EQU   MSCDASD+10
FSCDASD  EQU   MSCDASD+22
DASDSSID EQU   MSCDASD+26
MSCFMT3  EQU   4
STATUS3  EQU   MSCFMT3
FSCACC1  EQU   MSCFMT3+4
FSCACC2  EQU   MSCFMT3+8
MSCFIVE  EQU   0
DRIVEID  EQU   MSCFIVE+8
WORKPTR  EQU   0
*                                      START UNREFERENCED COMPONENTS
@NM00024 EQU   MSCFIVE+9
@NM00023 EQU   MSCFIVE
@NM00022 EQU   MSCFMT3+12
@NM00021 EQU   MSCFMT3+1
ENVIRON3 EQU   STATUS3
@NM00020 EQU   STATUS3
@NM00019 EQU   MSCDASD+24
@NM00018 EQU   MSCDASD+21
DASD20   EQU   MSCDASD+20
@NM00017 EQU   MSCDASD+12
DASD11   EQU   MSCDASD+11
@NM00016 EQU   DASD10
CLOCKERR EQU   DASD10
TIMEBIT  EQU   DASD10
@NM00015 EQU   MSCDASD+8
DASDMSG  EQU   FMTMSG
DASDFMT  EQU   FMTMSG
@NM00014 EQU   MSCDASD+5
@NM00013 EQU   MSCDASD
@NM00012 EQU   EQCSENSE+28
EQCHSEC  EQU   EQCTIME+3
EQCSEC   EQU   EQCTIME+2
EQCMIN   EQU   EQCTIME+1
EQCHR    EQU   EQCTIME
EQCDAY   EQU   EQCDATE+2
EQCYR    EQU   EQCDATE
@NM00011 EQU   EQCFSC+2
@NM00010 EQU   EQCFLAGS+1
UNITCHAR EQU   EQCSSID+1
DEVCHAR  EQU   EQCSSID
DEVBYTEB EQU   DEVBYTES+1
@NM00009 EQU   EQCSW
SENSELEN EQU   EQCWORK+50
L        EQU   EQCWORK+48
K        EQU   EQCWORK+46
J        EQU   EQCWORK+44
LINECT   EQU   EQCWORK+40
@NM00008 EQU   SSIDSAVE+1
@NM00007 EQU   ISDAGHDR+26
LASTPTR  EQU   ISDAGHDR+16
NEXTPTR  EQU   ISDAGHDR+12
GET0LEN  EQU   GET0SPLN+1
GET0SPNO EQU   GET0SPLN
ENDPTR   EQU   ISDAGHDR+4
SANOMSCD EQU   SUBSENSE+27
RCYLMSCD EQU   SUBSENSE+25
RUAMSCD  EQU   SUBSENSE+24
@NM00006 EQU   SUBSENSE+21
RUADASD  EQU   SUBSENSE+20
DASDFSC  EQU   SUBSENSE+18
@NM00005 EQU   SUBSENSE+8
MSGCODEN EQU   SUBFMTMG
SALOWAD2 EQU   SUBSENSE+6
SARETRY  EQU   SUBSENSE+5
@NM00004 EQU   SUBSENSE+4
DASDFMTN EQU   SUBSENSE+3
SALOWADD EQU   SUBSENSE+2
SUBSTAT4 EQU   SUBSENSE
SSIDDEVT EQU   SSID+1
SSIDLIBN EQU   SSID+1
SSIDTYPE EQU   SSID
SSIDFLAG EQU   SUBSYSID
STATUS   EQU   ISDAMSCS
CPUID    EQU   CPUSERID+3
CPUSER   EQU   CPUSERID
VERNO    EQU   OBRMDR+20
TENSHUND EQU   TIME+3
SECOND   EQU   TIME+2
MINUTE   EQU   TIME+1
HOUR     EQU   TIME
DAY      EQU   DATE+2
YEAR     EQU   DATE
RECENTRY EQU   OBRMDR+11
RCDCNT   EQU   OBRMDR+10
SWITCH3  EQU   SWITCHES+3
SWITCH2  EQU   SWITCHES+2
SWITCH1  EQU   SWITCHES+1
SWITCH0  EQU   SWITCHES
SYSREL   EQU   OBRMDR+5
CLASRC   EQU   OBRMDR+4
@NM00003 EQU   SCW+3
SCODE    EQU   SCW+2
SLENGTH  EQU   SCW
DEVPTR   EQU   ISDAWORK+16
NOUTREC  EQU   ISDAWORK+12
NINREC   EQU   ISDAWORK+8
CUABYTE1 EQU   INRECCUA+1
CUABYTE0 EQU   INRECCUA
DLENGTH  EQU   ISDAWORK+4
INSOURCE EQU   INFLAGS+1
IRECTYPE EQU   INFLAGS
CTRACE   EQU   ISDAPRMS+48
CGEN     EQU   ISDAPRMS+47
CDETAIL  EQU   ISDAPRMS+46
CPERIOD  EQU   ISDAPRMS+45
CPWR     EQU   CREPORTS+11
CAPRSUU  EQU   CREPORTS+10
CDRC     EQU   CREPORTS+9
CDAT     EQU   CREPORTS+8
CCSBCSF  EQU   CREPORTS+7
CDCKTLX  EQU   CREPORTS+6
CFSC     EQU   CREPORTS+4
CDHEDHU  EQU   CREPORTS+3
CSUM     EQU   CREPORTS+2
CPAD     EQU   CREPORTS+1
CDCS     EQU   CREPORTS
CSERNO   EQU   CSERIAL+4
@NM00002 EQU   CSERIAL+3
CIBM     EQU   CSERIAL
CRATIO   EQU   ISDAPRMS+19
CSSID    EQU   CSSIDF
@NM00001 EQU   CSSIDF
CFSC34   EQU   CFSCONLY+2
CFSC12   EQU   CFSCONLY
CTYPE    EQU   ISDAPRMS+11
CSUMMARY EQU   ISDAPRMS+10
CENDDAY  EQU   CEND+2
CENDYEAR EQU   CEND
CSTDAY   EQU   CSTART+2
CSTYEAR  EQU   CSTART
CHISTIN  EQU   CINPUT+1
CLOGIN   EQU   CINPUT
PRTSA001 EQU   PRTDATD
SDATEMPS EQU   SDADATD+136
SDASA002 EQU   SDADATD+76
SDAPC001 EQU   SDADATD+72
SDASA001 EQU   SDADATD
SDARPTID EQU   PRT0CALL+133
LINE     EQU   OUTLINE+1
ANSI     EQU   OUTLINE
DUMPIDNO EQU   HEXPCALL+8
DUMPLEN  EQU   HEXPCALL+4
DUMPADDR EQU   HEXPCALL
WORKCALL EQU   CVTPTRS0+96
GEN00PTR EQU   CVTPTRS0+92
CNFG0PTR EQU   CVTPTRS0+88
PWR00PTR EQU   CVTPTRS0+84
APR00PTR EQU   CVTPTRS0+80
DRC00PTR EQU   CVTPTRS0+76
DAT00PTR EQU   CVTPTRS0+72
CSB00PTR EQU   CVTPTRS0+68
DCK00PTR EQU   CVTPTRS0+64
FSC00PTR EQU   CVTPTRS0+56
DHE00PTR EQU   CVTPTRS0+52
SUM00PTR EQU   CVTPTRS0+48
PAD00PTR EQU   CVTPTRS0+44
DCS00PTR EQU   CVTPTRS0+40
LOG00PTR EQU   CVTPTRS0+36
HIST0PTR EQU   CVTPTRS0+32
PRT00PTR EQU   CVTPTRS0+28
GET00PTR EQU   CVTPTRS0+24
TYPE0PTR EQU   CVTPTRS0+20
PARM0PTR EQU   CVTPTRS0+16
*                                      END UNREFERENCED COMPONENTS
@RC00058 EQU   @EL00002
@RC00097 EQU   @RC00096
@RC00087 EQU   @EL00003
@RC00108 EQU   @EL00003
@RC00117 EQU   @EL00004
@RC00139 EQU   @EL00005
@RC00137 EQU   @EL00005
@RC00135 EQU   @EL00005
@RC00148 EQU   @EL00006
@RC00176 EQU   @RC00170
@RC00218 EQU   @RC00217
@RC00240 EQU   @EL00009
@RC00248 EQU   @EL00009
@RC00255 EQU   @EL00009
@RC00068 EQU   @RC00058
@RC00091 EQU   @RC00087
@RC00179 EQU   @RC00176
@RC00092 EQU   @RC00091
@ENDDATA EQU   *
         END   ISDAEQC0,(C'PLS1829',0603,75268)
